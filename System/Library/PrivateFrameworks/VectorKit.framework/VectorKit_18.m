void sub_1A20CF1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  void *v27;
  void *v28;
  void *v29;

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
  if (a24) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a27 + 40))(a27, a24, a26 - a24);
  }

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a22);
  _Unwind_Resume(a1);
}

uint64_t md::CustomImageData::operator=(uint64_t a1, void *a2)
{
  v2 = a2;
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  if ((void *)a1 != a2)
  {
    if (*(char *)(a1 + 23) < 0)
    {
      if (*((char *)a2 + 23) >= 0)
      {
        size_t v5 = *((unsigned __int8 *)a2 + 23);
      }
      else
      {
        a2 = (void *)*a2;
        size_t v5 = v2[1];
      }
      std::string::__assign_no_alias<false>((void **)a1, a2, v5);
    }
    else if ((*((unsigned char *)a2 + 23) & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>((void *)a1, (void *)*a2, a2[1]);
    }
    else
    {
      long long v4 = *(_OWORD *)a2;
      *(void *)(a1 + 16) = a2[2];
      *(_OWORD *)a1 = v4;
    }
  }
  v6 = (void *)v2[6];
  if (v6)
  {
    if (v6 == v2 + 3)
    {
      v9 = v8;
      (*(void (**)(void *, void *))(v2[3] + 24))(v2 + 3, v8);
    }
    else
    {
      v9 = (void *)(*(uint64_t (**)(void *))(*v6 + 16))(v6);
    }
  }
  else
  {
    v9 = 0;
  }
  std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::swap[abi:nn180100](v8, (void *)(a1 + 24));
  if (v9 == v8)
  {
    (*(void (**)(void *))(v8[0] + 32))(v8);
  }
  else if (v9)
  {
    (*(void (**)(void))(*v9 + 40))();
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<md::RouteWaypointLabelFeature>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::RouteWaypointLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581DA8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RouteWaypointLabelFeature>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581DA8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t *std::vector<GeoCodecsFeatureStylePair,geo::StdAllocator<GeoCodecsFeatureStylePair,mdm::Allocator>>::__insert_with_size[abi:nn180100]<GeoCodecsFeatureStylePair*,GeoCodecsFeatureStylePair*>(uint64_t *result, uint64_t a2, char *__src, char *a4, uint64_t a5)
{
  if (a5 < 1) {
    return result;
  }
  v6 = __src;
  uint64_t v7 = (uint64_t)result;
  uint64_t v9 = *result;
  unint64_t v8 = result[1];
  uint64_t v10 = a2 - *result;
  v11 = (uint64_t *)(*result + (v10 & 0xFFFFFFFFFFFFFFF8));
  uint64_t v12 = result[2];
  if (a5 > (uint64_t)(v12 - v8) >> 3)
  {
    unint64_t v13 = a5 + ((uint64_t)(v8 - v9) >> 3);
    if (v13 >> 61) {
      abort();
    }
    uint64_t v14 = v10 >> 3;
    uint64_t v15 = v12 - v9;
    if (v15 >> 2 > v13) {
      unint64_t v13 = v15 >> 2;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v16 = v13;
    }
    if (v16) {
      result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result[3] + 16))(result[3], 8 * v16, 4);
    }
    else {
      result = 0;
    }
    v21 = &result[v14];
    uint64_t v22 = a5;
    v23 = &v21[a5];
    uint64_t v24 = 8 * a5;
    v25 = v21;
    do
    {
      if (v25) {
        uint64_t *v25 = *(void *)v6;
      }
      ++v25;
      v6 += 8;
      v24 -= 8;
    }
    while (v24);
    v26 = *(uint64_t **)v7;
    if (*(uint64_t **)v7 == v11) {
      goto LABEL_31;
    }
    uint64_t v27 = (v10 & 0xFFFFFFFFFFFFFFF8) + v9;
    unint64_t v28 = v27 - (void)v26 - 8;
    if (v28 >= 0x68)
    {
      v29 = v11;
      if (v27 - ((unint64_t)result + (v10 & 0xFFFFFFFFFFFFFFF8)) >= 0x20)
      {
        uint64_t v30 = (v28 >> 3) + 1;
        v29 = &v11[-(v30 & 0x3FFFFFFFFFFFFFFCLL)];
        uint64_t v31 = 8 * v14 - 16;
        v32 = (long long *)(v9 + v31);
        v33 = (_OWORD *)((char *)result + v31);
        uint64_t v34 = v30 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v35 = *v32;
          *(v33 - 1) = *(v32 - 1);
          _OWORD *v33 = v35;
          v32 -= 2;
          v33 -= 2;
          v34 -= 4;
        }
        while (v34);
        v21 -= v30 & 0x3FFFFFFFFFFFFFFCLL;
        if (v30 == (v30 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_31;
        }
      }
    }
    else
    {
      v29 = v11;
    }
    do
    {
      uint64_t v36 = *--v29;
      *--v21 = v36;
    }
    while (v29 != v26);
LABEL_31:
    v37 = *(uint64_t **)(v7 + 8);
    if (v37 != v11)
    {
      uint64_t v38 = (v10 & 0xFFFFFFFFFFFFFFF8) + v9;
      unint64_t v39 = (unint64_t)v37 - v38 - 8;
      if (v39 < 0x68) {
        goto LABEL_59;
      }
      if ((unint64_t)result + (v10 & 0xFFFFFFFFFFFFFFF8) + v22 * 8 - v38 < 0x20) {
        goto LABEL_59;
      }
      uint64_t v40 = (v39 >> 3) + 1;
      uint64_t v41 = 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
      v11 = (uint64_t *)((char *)v11 + v41);
      v42 = &result[v14 + 2 + v22];
      v43 = (long long *)(8 * v14 + v9 + 16);
      uint64_t v44 = v40 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v45 = *v43;
        *((_OWORD *)v42 - 1) = *(v43 - 1);
        *(_OWORD *)v42 = v45;
        v42 += 4;
        v43 += 2;
        v44 -= 4;
      }
      while (v44);
      v23 = (uint64_t *)((char *)v23 + v41);
      if (v40 != (v40 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_59:
        do
        {
          uint64_t v46 = *v11++;
          *v23++ = v46;
        }
        while (v11 != v37);
      }
    }
    v47 = *(uint64_t **)v7;
    *(void *)uint64_t v7 = v21;
    *(void *)(v7 + 8) = v23;
    *(void *)(v7 + 16) = &result[v16];
    if (v47)
    {
      v48 = *(uint64_t (**)(void))(**(void **)(v7 + 24) + 40);
      return (uint64_t *)v48();
    }
    return result;
  }
  uint64_t v17 = (uint64_t)(v8 - (void)v11) >> 3;
  if (v17 >= a5)
  {
    v18 = &__src[8 * a5];
    v20 = (char *)result[1];
LABEL_44:
    v49 = (char *)&v11[a5];
    v50 = &v20[-8 * a5];
    v51 = v20;
    if ((unint64_t)v50 < v8)
    {
      v51 = v20;
      do
      {
        if (v51) {
          *(void *)v51 = *(void *)v50;
        }
        v50 += 8;
        v51 += 8;
      }
      while ((unint64_t)v50 < v8);
    }
    result[1] = (uint64_t)v51;
    if (v20 != v49) {
      result = (uint64_t *)memmove(&v20[-8 * ((v20 - v49) >> 3)], v11, v20 - v49);
    }
    if (v18 != v6)
    {
      return (uint64_t *)memmove(v11, v6, v18 - v6);
    }
    return result;
  }
  v18 = &__src[8 * v17];
  if (v18 == a4)
  {
    v20 = (char *)result[1];
  }
  else
  {
    v19 = &__src[8 * v17];
    v20 = (char *)result[1];
    do
    {
      if (v20) {
        *(void *)v20 = *(void *)v19;
      }
      v19 += 8;
      v20 += 8;
    }
    while (v19 != a4);
  }
  result[1] = (uint64_t)v20;
  if ((uint64_t)(v8 - (void)v11) >= 1) {
    goto LABEL_44;
  }
  return result;
}

void **std::vector<md::LabelFeaturePlacementInfo>::~vector[abi:nn180100](void **a1)
{
  v2 = (char *)*a1;
  if (*a1)
  {
    v3 = (char *)a1[1];
    long long v4 = *a1;
    if (v3 != v2)
    {
      size_t v5 = (char *)a1[1];
      do
      {
        uint64_t v7 = (void *)*((void *)v5 - 4);
        v5 -= 32;
        v6 = v7;
        if (v7)
        {
          *((void *)v3 - 3) = v6;
          operator delete(v6);
        }
        v3 = v5;
      }
      while (v5 != v2);
      long long v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t md::LabelExternalFeature::finalize(md::LabelExternalFeature *this)
{
  v2 = (unsigned __int8 *)*((void *)this + 6);
  v3 = (__int16 *)*((void *)this + 7);
  long long v4 = (void *)((char *)this + 48);
  unint64_t v5 = 126 - 2 * __clz(0x4EC4EC4EC4EC4EC5 * (((char *)v3 - (char *)v2) >> 3));
  if (v3 == (__int16 *)v2) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
  std::__introsort<std::_ClassicAlgPolicy,md::LabelExternalFeature::finalize(void)::{lambda(md::LabelExternalTextElement const&,md::LabelExternalTextElement const&)#1} &,md::LabelExternalTextElement*,false>(v2, v3, v6, 1);
  return std::vector<md::LabelExternalTextElement>::shrink_to_fit(v4);
}

void std::__introsort<std::_ClassicAlgPolicy,md::LabelExternalFeature::finalize(void)::{lambda(md::LabelExternalTextElement const&,md::LabelExternalTextElement const&)#1} &,md::LabelExternalTextElement*,false>(unsigned __int8 *a1, __int16 *a2, uint64_t a3, char a4)
{
int64_t std::vector<md::LabelExternalTextElement>::shrink_to_fit(void *a1)
{
  v2 = a1 + 2;
  uint64_t v3 = a1[2];
  uint64_t v4 = *a1;
  uint64_t v5 = a1[1];
  unint64_t v6 = 0x4EC4EC4EC4EC4EC5 * ((v3 - *a1) >> 3);
  int64_t result = v5 - *a1;
  unint64_t v8 = 0x4EC4EC4EC4EC4EC5 * (result >> 3);
  if (v6 > v8)
  {
    unsigned int v19 = v2;
    if (v5 == v4)
    {
      uint64_t v9 = (char *)(8 * (result >> 3));
      int64x2_t v16 = vdupq_n_s64((unint64_t)v9);
      uint64_t v15 = v4;
    }
    else
    {
      if (v8 >= 0x276276276276277) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v9 = (char *)operator new(result) + 8 * (result >> 3);
      v18.i64[0] = (uint64_t)v9;
      v18.i64[1] = (uint64_t)v9;
      do
      {
        __int16 v10 = *(_WORD *)(v5 - 104);
        v5 -= 104;
        *((_WORD *)v9 - 52) = v10;
        v9 -= 104;
        long long v11 = *(_OWORD *)(v5 + 8);
        *((void *)v9 + 3) = *(void *)(v5 + 24);
        *(_OWORD *)(v9 + 8) = v11;
        *(void *)(v5 + 16) = 0;
        *(void *)(v5 + 24) = 0;
        *(void *)(v5 + 8) = 0;
        long long v12 = *(_OWORD *)(v5 + 32);
        *((void *)v9 + 6) = *(void *)(v5 + 48);
        *((_OWORD *)v9 + 2) = v12;
        *(void *)(v5 + 40) = 0;
        *(void *)(v5 + 48) = 0;
        *(void *)(v5 + 32) = 0;
        long long v13 = *(_OWORD *)(v5 + 56);
        *((void *)v9 + 9) = *(void *)(v5 + 72);
        *(_OWORD *)(v9 + 56) = v13;
        *(void *)(v5 + 64) = 0;
        *(void *)(v5 + 72) = 0;
        *(void *)(v5 + 56) = 0;
        long long v14 = *(_OWORD *)(v5 + 80);
        *((void *)v9 + 12) = *(void *)(v5 + 96);
        *((_OWORD *)v9 + 5) = v14;
        *(void *)(v5 + 80) = 0;
        *(void *)(v5 + 88) = 0;
        *(void *)(v5 + 96) = 0;
      }
      while (v5 != v4);
      uint64_t v15 = *a1;
      uint64_t v4 = a1[1];
      uint64_t v3 = a1[2];
      int64x2_t v16 = v18;
    }
    *a1 = v9;
    *(int64x2_t *)(a1 + 1) = v16;
    v18.i64[0] = v4;
    v18.i64[1] = v3;
    v17[0] = v15;
    v17[1] = v15;
    return std::__split_buffer<md::LabelExternalTextElement>::~__split_buffer((uint64_t)v17);
  }
  return result;
}

void std::swap[abi:nn180100]<md::LabelExternalTextElement>(__int16 *a1, __int16 *a2)
{
  __int16 v4 = *a1;
  uint64_t v5 = *((void *)a1 + 1);
  *(void *)unsigned int v25 = *((void *)a1 + 2);
  *(void *)&v25[7] = *(void *)((char *)a1 + 23);
  char v6 = *((unsigned char *)a1 + 31);
  *((void *)a1 + 2) = 0;
  *((void *)a1 + 3) = 0;
  *((void *)a1 + 1) = 0;
  uint64_t v7 = a1 + 16;
  uint64_t v8 = *((void *)a1 + 4);
  *(void *)uint64_t v24 = *((void *)a1 + 5);
  *(void *)&v24[7] = *(void *)((char *)a1 + 47);
  char v9 = *((unsigned char *)a1 + 55);
  *((void *)a1 + 4) = 0;
  *((void *)a1 + 5) = 0;
  *((void *)a1 + 6) = 0;
  __int16 v10 = a1 + 28;
  uint64_t v19 = *((void *)a1 + 7);
  *(void *)&v23[7] = *(void *)((char *)a1 + 71);
  *(void *)v23 = *((void *)a1 + 8);
  char v18 = *((unsigned char *)a1 + 79);
  *((void *)a1 + 7) = 0;
  long long v12 = a1 + 40;
  uint64_t v11 = *((void *)a1 + 10);
  *((void *)a1 + 8) = 0;
  *((void *)a1 + 9) = 0;
  *(void *)&v22[7] = *(void *)((char *)a1 + 95);
  uint64_t v21 = v11;
  *(void *)unsigned int v22 = *((void *)a1 + 11);
  char v20 = *((unsigned char *)a1 + 103);
  *((void *)a1 + 10) = 0;
  *((void *)a1 + 11) = 0;
  *((void *)a1 + 12) = 0;
  *a1 = *a2;
  long long v13 = *(_OWORD *)(a2 + 4);
  *((void *)a1 + 3) = *((void *)a2 + 3);
  *(_OWORD *)(a1 + 4) = v13;
  *((unsigned char *)a2 + 31) = 0;
  *((unsigned char *)a2 + 8) = 0;
  if (*((char *)a1 + 55) < 0) {
    operator delete(*(void **)v7);
  }
  long long v14 = *((_OWORD *)a2 + 2);
  *((void *)v7 + 2) = *((void *)a2 + 6);
  *(_OWORD *)uint64_t v7 = v14;
  *((unsigned char *)a2 + 55) = 0;
  *((unsigned char *)a2 + 32) = 0;
  uint64_t v15 = (void **)(a2 + 28);
  if (*((char *)a1 + 79) < 0) {
    operator delete(*(void **)v10);
  }
  long long v16 = *(_OWORD *)v15;
  *((void *)v10 + 2) = *((void *)a2 + 9);
  *(_OWORD *)__int16 v10 = v16;
  *((unsigned char *)a2 + 79) = 0;
  *((unsigned char *)a2 + 56) = 0;
  if (*((char *)a1 + 103) < 0) {
    operator delete(*(void **)v12);
  }
  long long v17 = *((_OWORD *)a2 + 5);
  *((void *)v12 + 2) = *((void *)a2 + 12);
  *(_OWORD *)long long v12 = v17;
  *((unsigned char *)a2 + 103) = 0;
  *((unsigned char *)a2 + 80) = 0;
  *a2 = v4;
  if (*((char *)a2 + 31) < 0) {
    operator delete(*((void **)a2 + 1));
  }
  *((void *)a2 + 1) = v5;
  *((void *)a2 + 2) = *(void *)v25;
  *(void *)((char *)a2 + 23) = *(void *)&v25[7];
  *((unsigned char *)a2 + 31) = v6;
  if (*((char *)a2 + 55) < 0) {
    operator delete(*((void **)a2 + 4));
  }
  *((void *)a2 + 4) = v8;
  *((void *)a2 + 5) = *(void *)v24;
  *(void *)((char *)a2 + 47) = *(void *)&v24[7];
  *((unsigned char *)a2 + 55) = v9;
  if (*((char *)a2 + 79) < 0) {
    operator delete(*v15);
  }
  *((void *)a2 + 7) = v19;
  *((void *)a2 + 8) = *(void *)v23;
  *(void *)((char *)a2 + 71) = *(void *)&v23[7];
  *((unsigned char *)a2 + 79) = v18;
  if (*((char *)a2 + 103) < 0) {
    operator delete(*((void **)a2 + 10));
  }
  *((void *)a2 + 10) = v21;
  *((void *)a2 + 11) = *(void *)v22;
  *(void *)((char *)a2 + 95) = *(void *)&v22[7];
  *((unsigned char *)a2 + 103) = v20;
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalFeature::finalize(void)::{lambda(md::LabelExternalTextElement const&,md::LabelExternalTextElement const&)#1} &,md::LabelExternalTextElement*>(__int16 *a1, __int16 *a2, __int16 *a3, __int16 *a4)
{
  uint64_t v7 = a1;
  unsigned int v8 = *(unsigned __int8 *)a2;
  unsigned int v9 = *(unsigned __int8 *)a3;
  if (v8 >= *(unsigned __int8 *)a1)
  {
    if (v9 < v8)
    {
      std::swap[abi:nn180100]<md::LabelExternalTextElement>(a2, a3);
      if (*(unsigned __int8 *)a2 < *(unsigned __int8 *)v7)
      {
        a1 = v7;
        __int16 v10 = a2;
        goto LABEL_9;
      }
    }
  }
  else
  {
    if (v9 < v8)
    {
LABEL_5:
      __int16 v10 = a3;
LABEL_9:
      std::swap[abi:nn180100]<md::LabelExternalTextElement>(a1, v10);
      goto LABEL_10;
    }
    std::swap[abi:nn180100]<md::LabelExternalTextElement>(a1, a2);
    if (*(unsigned __int8 *)a3 < *(unsigned __int8 *)a2)
    {
      a1 = a2;
      goto LABEL_5;
    }
  }
LABEL_10:
  if (*(unsigned __int8 *)a4 < *(unsigned __int8 *)a3)
  {
    std::swap[abi:nn180100]<md::LabelExternalTextElement>(a3, a4);
    if (*(unsigned __int8 *)a3 < *(unsigned __int8 *)a2)
    {
      std::swap[abi:nn180100]<md::LabelExternalTextElement>(a2, a3);
      if (*(unsigned __int8 *)a2 < *(unsigned __int8 *)v7)
      {
        std::swap[abi:nn180100]<md::LabelExternalTextElement>(v7, a2);
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalFeature::finalize(void)::{lambda(md::LabelExternalTextElement const&,md::LabelExternalTextElement const&)#1} &,md::LabelExternalTextElement*>(__int16 *a1, __int16 *a2)
{
  v2 = a2;
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(0x4EC4EC4EC4EC4EC5 * v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      char v6 = a2 - 52;
      if (*((unsigned __int8 *)a2 - 104) < *(unsigned __int8 *)a1) {
        goto LABEL_11;
      }
      return result;
    case 3:
      long long v13 = a1 + 52;
      unsigned int v12 = *((unsigned __int8 *)a1 + 104);
      char v6 = a2 - 52;
      unsigned int v14 = *((unsigned __int8 *)a2 - 104);
      if (v12 >= *(unsigned __int8 *)a1)
      {
        if (v14 >= v12) {
          return result;
        }
        char v20 = a1 + 52;
        uint64_t v21 = a2 - 52;
LABEL_51:
        std::swap[abi:nn180100]<md::LabelExternalTextElement>(v20, v21);
        if (*((unsigned __int8 *)a1 + 104) < *(unsigned __int8 *)a1)
        {
          uint64_t v15 = a1;
          long long v16 = v13;
LABEL_13:
          std::swap[abi:nn180100]<md::LabelExternalTextElement>(v15, v16);
        }
      }
      else
      {
        if (v14 < v12)
        {
LABEL_11:
          uint64_t v15 = a1;
LABEL_12:
          long long v16 = v6;
          goto LABEL_13;
        }
        std::swap[abi:nn180100]<md::LabelExternalTextElement>(a1, a1 + 52);
        if (*(unsigned __int8 *)v6 < *((unsigned __int8 *)a1 + 104))
        {
          uint64_t v15 = a1 + 52;
          goto LABEL_12;
        }
      }
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalFeature::finalize(void)::{lambda(md::LabelExternalTextElement const&,md::LabelExternalTextElement const&)#1} &,md::LabelExternalTextElement*>(a1, a1 + 52, a1 + 104, a2 - 52);
      return 1;
    case 5:
      long long v13 = a1 + 52;
      long long v17 = (unsigned __int8 *)(a1 + 104);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalFeature::finalize(void)::{lambda(md::LabelExternalTextElement const&,md::LabelExternalTextElement const&)#1} &,md::LabelExternalTextElement*>(a1, a1 + 52, a1 + 104, a1 + 156);
      unsigned int v19 = *((unsigned __int8 *)v2 - 104);
      char v18 = v2 - 52;
      if (v19 >= *((unsigned __int8 *)a1 + 312)) {
        return 1;
      }
      std::swap[abi:nn180100]<md::LabelExternalTextElement>(a1 + 156, v18);
      if (*((unsigned __int8 *)a1 + 312) >= *v17) {
        return 1;
      }
      std::swap[abi:nn180100]<md::LabelExternalTextElement>(a1 + 104, a1 + 156);
      if (*v17 >= *(unsigned __int8 *)v13) {
        return 1;
      }
      char v20 = a1 + 52;
      uint64_t v21 = a1 + 104;
      goto LABEL_51;
    default:
      unsigned int v8 = (unsigned __int8 *)(a1 + 104);
      unsigned int v7 = *((unsigned __int8 *)a1 + 208);
      unsigned int v9 = *((unsigned __int8 *)a1 + 104);
      if (v9 < *(unsigned __int8 *)a1)
      {
        __int16 v10 = a1;
        if (v7 >= v9)
        {
          std::swap[abi:nn180100]<md::LabelExternalTextElement>(a1, a1 + 52);
          if (*((unsigned __int8 *)a1 + 208) >= *((unsigned __int8 *)a1 + 104)) {
            goto LABEL_23;
          }
          __int16 v10 = a1 + 52;
        }
        uint64_t v11 = a1 + 104;
        goto LABEL_22;
      }
      if (v7 < v9)
      {
        std::swap[abi:nn180100]<md::LabelExternalTextElement>(a1 + 52, a1 + 104);
        if (*((unsigned __int8 *)a1 + 104) < *(unsigned __int8 *)a1)
        {
          __int16 v10 = a1;
          uint64_t v11 = a1 + 52;
LABEL_22:
          std::swap[abi:nn180100]<md::LabelExternalTextElement>(v10, v11);
        }
      }
LABEL_23:
      unsigned int v22 = (unsigned __int8 *)(a1 + 156);
      if (a1 + 156 == v2) {
        return 1;
      }
      uint64_t v23 = 0;
      int v24 = 0;
      uint64_t v42 = (unsigned __int8 *)v2;
      while (1)
      {
        if (*v22 < *v8)
        {
          __int16 v25 = *(_WORD *)v22;
          uint64_t v44 = (void *)*((void *)v22 + 1);
          *(void *)unsigned int v54 = *((void *)v22 + 2);
          *(void *)&v54[7] = *(void *)(v22 + 23);
          unsigned __int8 v43 = v22[31];
          *((void *)v22 + 1) = 0;
          *((void *)v22 + 2) = 0;
          unsigned __int8 v46 = (void *)*((void *)v22 + 4);
          *(void *)v53 = *((void *)v22 + 5);
          *(void *)&v53[7] = *(void *)(v22 + 47);
          unsigned __int8 v45 = v22[55];
          *((void *)v22 + 3) = 0;
          *((void *)v22 + 4) = 0;
          *((void *)v22 + 5) = 0;
          *((void *)v22 + 6) = 0;
          v48 = (void *)*((void *)v22 + 7);
          *(void *)&v52[7] = *(void *)(v22 + 71);
          *(void *)unsigned int v52 = *((void *)v22 + 8);
          unsigned __int8 v47 = v22[79];
          *((void *)v22 + 7) = 0;
          *((void *)v22 + 8) = 0;
          *(void *)&v51[14] = *(void *)(v22 + 95);
          *(_OWORD *)v51 = *(_OWORD *)(v22 + 81);
          unsigned __int8 v49 = v22[103];
          unsigned __int8 v50 = v22[80];
          *((void *)v22 + 9) = 0;
          *((void *)v22 + 10) = 0;
          uint64_t v26 = v23;
          *((void *)v22 + 11) = 0;
          *((void *)v22 + 12) = 0;
          while (1)
          {
            uint64_t v27 = v26;
            unsigned int v28 = (char *)a1 + v26;
            *(__int16 *)((char *)a1 + v26 + 312) = *(__int16 *)((char *)a1 + v26 + 208);
            uint64_t v29 = (uint64_t)a1 + v26 + 320;
            if (*((char *)a1 + v26 + 343) < 0) {
              operator delete(*(void **)v29);
            }
            *(_OWORD *)uint64_t v29 = *(_OWORD *)(v28 + 216);
            *(void *)(v29 + 16) = *((void *)v28 + 29);
            v28[239] = 0;
            v28[216] = 0;
            uint64_t v30 = v28 + 344;
            if (v28[367] < 0) {
              operator delete(*(void **)v30);
            }
            unint64_t v31 = (char *)a1 + v27;
            *(_OWORD *)uint64_t v30 = *(_OWORD *)((char *)a1 + v27 + 240);
            *((void *)v30 + 2) = *(void *)((char *)a1 + v27 + 256);
            v31[263] = 0;
            v31[240] = 0;
            unsigned int v32 = (void **)((char *)a1 + v27 + 368);
            if (*((char *)a1 + v27 + 391) < 0) {
              operator delete(*v32);
            }
            *(_OWORD *)unsigned int v32 = *(_OWORD *)(v31 + 264);
            *(void *)((char *)a1 + v27 + 384) = *((void *)v31 + 35);
            v31[287] = 0;
            v31[264] = 0;
            v33 = (void **)(v31 + 392);
            if (v31[415] < 0) {
              operator delete(*v33);
            }
            unsigned int v34 = (unsigned __int8 *)a1 + v27;
            *(_OWORD *)v33 = *(_OWORD *)((char *)a1 + v27 + 288);
            *((void *)v31 + 51) = *(void *)((char *)a1 + v27 + 304);
            v34[311] = 0;
            v34[288] = 0;
            if (v27 == -208) {
              break;
            }
            unsigned int v35 = v34[104];
            uint64_t v26 = v27 - 104;
            if (v35 <= v25)
            {
              uint64_t v36 = (uint64_t)a1 + v26 + 312;
              v37 = (char *)a1 + v27;
              unsigned int v38 = (void **)((char *)a1 + v27 + 216);
              unsigned int v39 = (void **)((char *)a1 + v27 + 288);
              uint64_t v40 = (void **)(v37 + 240);
              uint64_t v41 = (void **)(v37 + 264);
              goto LABEL_41;
            }
          }
          unsigned int v38 = (void **)(v34 + 216);
          unsigned int v39 = (void **)(v34 + 288);
          uint64_t v40 = (void **)(v34 + 240);
          uint64_t v41 = (void **)(v34 + 264);
          uint64_t v36 = (uint64_t)a1;
LABEL_41:
          *(_WORD *)uint64_t v36 = v25;
          if (*(char *)(v36 + 31) < 0) {
            operator delete(*v38);
          }
          *unsigned int v38 = v44;
          *(void *)(v36 + 16) = *(void *)v54;
          *(void *)(v36 + 23) = *(void *)&v54[7];
          *(unsigned char *)(v36 + 31) = v43;
          if (*(char *)(v36 + 55) < 0) {
            operator delete(*v40);
          }
          *uint64_t v40 = v46;
          *(void *)(v36 + 40) = *(void *)v53;
          *(void *)(v36 + 47) = *(void *)&v53[7];
          *(unsigned char *)(v36 + 55) = v45;
          v2 = (__int16 *)v42;
          if (*(char *)(v36 + 79) < 0) {
            operator delete(*v41);
          }
          *uint64_t v41 = v48;
          *(void *)(v36 + 64) = *(void *)v52;
          *(void *)(v36 + 71) = *(void *)&v52[7];
          *(unsigned char *)(v36 + 79) = v47;
          if (*(char *)(v36 + 103) < 0) {
            operator delete(*v39);
          }
          *(unsigned char *)unsigned int v39 = v50;
          *(_OWORD *)(v36 + 81) = *(_OWORD *)v51;
          *(void *)(v36 + 95) = *(void *)&v51[14];
          *(unsigned char *)(v36 + 103) = v49;
          if (++v24 == 8) {
            return v22 + 104 == v42;
          }
        }
        unsigned int v8 = v22;
        v23 += 104;
        v22 += 104;
        if (v22 == (unsigned __int8 *)v2) {
          return 1;
        }
      }
  }
}

void md::LabelExternalTextElement::~LabelExternalTextElement(void **this)
{
  if (*((char *)this + 103) < 0)
  {
    operator delete(this[10]);
    if ((*((char *)this + 79) & 0x80000000) == 0)
    {
LABEL_3:
      if ((*((char *)this + 55) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((*((char *)this + 79) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(this[7]);
  if ((*((char *)this + 55) & 0x80000000) == 0)
  {
LABEL_4:
    if ((*((char *)this + 31) & 0x80000000) == 0) {
      return;
    }
LABEL_9:
    operator delete(this[1]);
    return;
  }
LABEL_8:
  operator delete(this[4]);
  if (*((char *)this + 31) < 0) {
    goto LABEL_9;
  }
}

void md::LabelExternalPointFeature::finalize(md::LabelExternalPointFeature *this)
{
  uint64_t v3 = (unsigned __int8 *)*((void *)this + 6);
  uint64_t v4 = (__int16 *)*((void *)this + 7);
  uint64_t v5 = (void *)((char *)this + 48);
  unint64_t v6 = 126 - 2 * __clz(0x4EC4EC4EC4EC4EC5 * (((char *)v4 - (char *)v3) >> 3));
  if (v4 == (__int16 *)v3) {
    uint64_t v7 = 0;
  }
  else {
    uint64_t v7 = v6;
  }
  std::__introsort<std::_ClassicAlgPolicy,md::LabelExternalFeature::finalize(void)::{lambda(md::LabelExternalTextElement const&,md::LabelExternalTextElement const&)#1} &,md::LabelExternalTextElement*,false>(v3, v4, v7, 1);
  std::vector<md::LabelExternalTextElement>::shrink_to_fit(v5);
  unint64_t v8 = v5[41];
  unint64_t v9 = v5[42];
  unint64_t v10 = 126 - 2 * __clz((uint64_t)(v9 - v8) >> 5);
  uint64_t v11 = (int64x2_t *)(v5 + 39);
  if (v9 == v8) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = v10;
  }
  std::__introsort<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*,false>(v8, v9, v12, 1);
  long long v13 = (char *)v5[38];
  int64x2_t v14 = vsubq_s64(*v11, vdupq_n_s64((unint64_t)v13));
  int64x2_t v15 = vshrq_n_s64(v14, 2uLL);
  unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * v15.i64[0];
  if (0xCCCCCCCCCCCCCCCDLL * v15.i64[1] > v16)
  {
    long long v17 = (char *)v11->i64[0];
    if ((char *)v11->i64[0] == v13)
    {
      uint64_t v18 = 20 * v16;
      uint64_t v19 = 20 * v16;
    }
    else
    {
      if (v16 >= 0xCCCCCCCCCCCCCCDLL) {
        goto LABEL_55;
      }
      uint64_t v18 = (uint64_t)operator new(v14.u64[0]) + 20 * v16;
      uint64_t v19 = v18;
      do
      {
        long long v20 = *(_OWORD *)(v17 - 20);
        *(_DWORD *)(v19 - 4) = *((_DWORD *)v17 - 1);
        *(_OWORD *)(v19 - 20) = v20;
        v19 -= 20;
        v17 -= 20;
      }
      while (v17 != v13);
    }
    *((void *)this + 44) = v19;
    *((void *)this + 45) = v18;
    *((void *)this + 46) = v18;
    if (v13) {
      operator delete(v13);
    }
  }
  uint64_t v21 = (unsigned char *)*((void *)this + 48);
  unsigned int v22 = (char *)*((void *)this + 47);
  size_t v23 = v21 - v22;
  unint64_t v24 = (v21 - v22) >> 5;
  if (v24 < (uint64_t)(*((void *)this + 49) - (void)v22) >> 5)
  {
    if (v21 == v22)
    {
      *((void *)this + 47) = 32 * v24;
      *((void *)this + 48) = 32 * v24;
      *((void *)this + 49) = 32 * v24;
    }
    else
    {
      if ((v23 & 0x8000000000000000) != 0) {
        goto LABEL_55;
      }
      __int16 v25 = (char *)operator new(v23) + 32 * v24;
      uint64_t v26 = v25;
      do
      {
        long long v27 = *((_OWORD *)v21 - 2);
        v21 -= 32;
        *((_OWORD *)v26 - 2) = v27;
        v26 -= 32;
        *((void *)v26 + 2) = *((void *)v21 + 2);
        *(void *)uint64_t v21 = 0;
        *((void *)v21 + 1) = 0;
        *((void *)v21 + 2) = 0;
        __int16 v28 = *((_WORD *)v21 + 12);
        v26[26] = v21[26];
        *((_WORD *)v26 + 12) = v28;
      }
      while (v21 != v22);
      unsigned int v22 = (char *)*((void *)this + 47);
      uint64_t v29 = (char *)*((void *)this + 48);
      *((void *)this + 47) = v26;
      *((void *)this + 48) = v25;
      *((void *)this + 49) = v25;
      if (v29 != v22)
      {
        uint64_t v30 = v29;
        do
        {
          unsigned int v32 = (void *)*((void *)v30 - 4);
          v30 -= 32;
          unint64_t v31 = v32;
          if (v32)
          {
            *((void *)v29 - 3) = v31;
            operator delete(v31);
          }
          uint64_t v29 = v30;
        }
        while (v30 != v22);
      }
    }
    if (v22) {
      operator delete(v22);
    }
  }
  v33 = (void *)*((void *)this + 50);
  int64x2_t v34 = v11[3];
  int64x2_t v35 = vsubq_s64(v34, vdupq_n_s64((unint64_t)v33));
  if (0xCCCCCCCCCCCCCCCDLL * v35.i64[1] > 0xCCCCCCCCCCCCCCCDLL * v35.i64[0])
  {
    uint64_t v36 = v11[3].i64[0];
    if ((void *)v34.i64[0] == v33)
    {
      v37 = (char *)v35.i64[0];
      unsigned int v38 = (char *)v35.i64[0];
    }
    else
    {
      if (0xCCCCCCCCCCCCCCCDLL * v35.i64[0] >= 0x3333333333333334) {
        goto LABEL_55;
      }
      v37 = (char *)operator new(v35.u64[0]) + v35.i64[0];
      unsigned int v38 = v37;
      do
      {
        char v39 = *(unsigned char *)(v36 - 5);
        v36 -= 5;
        *(v38 - 5) = v39;
        v38 -= 5;
        *(_DWORD *)(v38 + 1) = *(_DWORD *)(v36 + 1);
      }
      while ((void *)v36 != v33);
    }
    *((void *)this + 50) = v38;
    *((void *)this + 51) = v37;
    *((void *)this + 52) = v37;
    if (v33) {
      operator delete(v33);
    }
  }
  uint64_t v40 = (char *)*((void *)this + 54);
  uint64_t v41 = (char *)*((void *)this + 53);
  size_t v42 = v40 - v41;
  unint64_t v43 = (v40 - v41) >> 4;
  if (v43 >= (uint64_t)(*((void *)this + 55) - (void)v41) >> 4) {
    return;
  }
  if (v40 != v41)
  {
    if ((v42 & 0x8000000000000000) == 0)
    {
      uint64_t v44 = (char *)operator new(v42) + 16 * v43;
      unsigned __int8 v45 = v44;
      do
      {
        long long v46 = *((_OWORD *)v40 - 1);
        v40 -= 16;
        *((_OWORD *)v45 - 1) = v46;
        v45 -= 16;
        *(void *)uint64_t v40 = 0;
        *((void *)v40 + 1) = 0;
      }
      while (v40 != v41);
      uint64_t v41 = (char *)*((void *)this + 53);
      unsigned __int8 v47 = (char *)*((void *)this + 54);
      *((void *)this + 53) = v45;
      *((void *)this + 54) = v44;
      for (*((void *)this + 55) = v44; v47 != v41; v47 -= 16)
      {
        v48 = (std::__shared_weak_count *)*((void *)v47 - 1);
        if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
          std::__shared_weak_count::__release_weak(v48);
        }
      }
      goto LABEL_50;
    }
LABEL_55:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  *((void *)this + 53) = 16 * v43;
  *((void *)this + 54) = 16 * v43;
  *((void *)this + 55) = 16 * v43;
LABEL_50:
  if (v41)
  {
    operator delete(v41);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>(long long *a1, long long *a2, long long *a3)
{
  unsigned int v6 = *((unsigned __int8 *)a2 + 26);
  unsigned int v7 = *((unsigned __int8 *)a3 + 26);
  if (v6 >= *((unsigned __int8 *)a1 + 26))
  {
    if (v7 < v6)
    {
      long long v14 = *a2;
      uint64_t v15 = *((void *)a2 + 2);
      *((void *)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
      long long v17 = (_WORD *)a2 + 12;
      __int16 v16 = *((_WORD *)a2 + 12);
      *(void *)a2 = 0;
      __int16 v36 = v16;
      char v37 = *((unsigned char *)a2 + 26);
      *a2 = *a3;
      *((void *)a2 + 2) = *((void *)a3 + 2);
      *(void *)a3 = 0;
      *((void *)a3 + 1) = 0;
      *((void *)a3 + 2) = 0;
      __int16 v18 = (_WORD *)a3 + 12;
      char v19 = *((unsigned char *)a3 + 26);
      *((_WORD *)a2 + 12) = *((_WORD *)a3 + 12);
      *((unsigned char *)a2 + 26) = v19;
      unint64_t v20 = *(void **)a3;
      if (*(void *)a3)
      {
        *((void *)a3 + 1) = v20;
        long long v34 = v14;
        operator delete(v20);
        long long v14 = v34;
      }
      *a3 = v14;
      *((void *)a3 + 2) = v15;
      _WORD *v18 = v36;
      *((unsigned char *)a3 + 26) = v37;
      if (*((unsigned __int8 *)a2 + 26) < *((unsigned __int8 *)a1 + 26))
      {
        long long v21 = *a1;
        uint64_t v22 = *((void *)a1 + 2);
        *((void *)a1 + 1) = 0;
        *((void *)a1 + 2) = 0;
        *(void *)a1 = 0;
        __int16 v38 = *((_WORD *)a1 + 12);
        char v39 = *((unsigned char *)a1 + 26);
        *a1 = *a2;
        *((void *)a1 + 2) = *((void *)a2 + 2);
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        *((void *)a2 + 2) = 0;
        char v23 = *((unsigned char *)a2 + 26);
        *((_WORD *)a1 + 12) = *v17;
        *((unsigned char *)a1 + 26) = v23;
        unint64_t v24 = *(void **)a2;
        if (*(void *)a2)
        {
          *((void *)a2 + 1) = v24;
          long long v35 = v21;
          operator delete(v24);
          long long v21 = v35;
        }
        *a2 = v21;
        *((void *)a2 + 2) = v22;
        *long long v17 = v38;
        *((unsigned char *)a2 + 26) = v39;
      }
    }
  }
  else
  {
    unint64_t v8 = (__int16 *)a1 + 12;
    if (v7 >= v6)
    {
      uint64_t v25 = *(void *)a1;
      uint64_t v26 = *((void *)a1 + 1);
      uint64_t v27 = *((void *)a1 + 2);
      *((void *)a1 + 1) = 0;
      *((void *)a1 + 2) = 0;
      *(void *)a1 = 0;
      __int16 v42 = *v8;
      char v43 = *((unsigned char *)a1 + 26);
      *a1 = *a2;
      *((void *)a1 + 2) = *((void *)a2 + 2);
      *(void *)a2 = 0;
      *((void *)a2 + 1) = 0;
      *((void *)a2 + 2) = 0;
      unint64_t v28 = (__int16 *)a2 + 12;
      char v29 = *((unsigned char *)a2 + 26);
      *unint64_t v8 = *((_WORD *)a2 + 12);
      *((unsigned char *)a1 + 26) = v29;
      uint64_t v30 = *(void **)a2;
      if (*(void *)a2)
      {
        *((void *)a2 + 1) = v30;
        operator delete(v30);
      }
      *(void *)a2 = v25;
      *((void *)a2 + 1) = v26;
      *((void *)a2 + 2) = v27;
      *unint64_t v28 = v42;
      *((unsigned char *)a2 + 26) = v43;
      if (*((unsigned __int8 *)a3 + 26) < *((unsigned __int8 *)a2 + 26))
      {
        *(void *)a2 = 0;
        *((void *)a2 + 1) = 0;
        *((void *)a2 + 2) = 0;
        __int16 v44 = *v28;
        char v45 = *((unsigned char *)a2 + 26);
        *a2 = *a3;
        *((void *)a2 + 2) = *((void *)a3 + 2);
        *(void *)a3 = 0;
        *((void *)a3 + 1) = 0;
        *((void *)a3 + 2) = 0;
        char v31 = *((unsigned char *)a3 + 26);
        *unint64_t v28 = *((_WORD *)a3 + 12);
        *((unsigned char *)v28 + 2) = v31;
        unsigned int v32 = *(void **)a3;
        if (*(void *)a3)
        {
          *((void *)a3 + 1) = v32;
          operator delete(v32);
        }
        *(void *)a3 = v25;
        *((void *)a3 + 1) = v26;
        *((void *)a3 + 2) = v27;
        *((_WORD *)a3 + 12) = v44;
        *((unsigned char *)a3 + 26) = v45;
      }
    }
    else
    {
      long long v9 = *a1;
      uint64_t v10 = *((void *)a1 + 2);
      *((void *)a1 + 1) = 0;
      *((void *)a1 + 2) = 0;
      *(void *)a1 = 0;
      __int16 v40 = *v8;
      char v41 = *((unsigned char *)a1 + 26);
      *a1 = *a3;
      *((void *)a1 + 2) = *((void *)a3 + 2);
      *(void *)a3 = 0;
      *((void *)a3 + 1) = 0;
      *((void *)a3 + 2) = 0;
      uint64_t v11 = (_WORD *)a3 + 12;
      char v12 = *((unsigned char *)a3 + 26);
      *unint64_t v8 = *((_WORD *)a3 + 12);
      *((unsigned char *)a1 + 26) = v12;
      unint64_t v13 = *(void **)a3;
      if (*(void *)a3)
      {
        *((void *)a3 + 1) = v13;
        long long v33 = v9;
        operator delete(v13);
        long long v9 = v33;
      }
      *a3 = v9;
      *((void *)a3 + 2) = v10;
      _WORD *v11 = v40;
      *((unsigned char *)a3 + 26) = v41;
    }
  }
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>((long long *)a1, (long long *)a2, (long long *)a3);
  if (*(unsigned __int8 *)(a4 + 26) < *(unsigned __int8 *)(a3 + 26))
  {
    long long v8 = *(_OWORD *)a3;
    uint64_t v9 = *(void *)(a3 + 16);
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    uint64_t v11 = (_WORD *)(a3 + 24);
    __int16 v10 = *(_WORD *)(a3 + 24);
    *(void *)a3 = 0;
    __int16 v26 = v10;
    char v27 = *(unsigned char *)(a3 + 26);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(void *)(a3 + 16) = *(void *)(a4 + 16);
    *(void *)a4 = 0;
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    char v12 = *(unsigned char *)(a4 + 26);
    *(_WORD *)(a3 + 24) = *(_WORD *)(a4 + 24);
    *(unsigned char *)(a3 + 26) = v12;
    unint64_t v13 = *(void **)a4;
    if (*(void *)a4)
    {
      *(void *)(a4 + 8) = v13;
      long long v23 = v8;
      operator delete(v13);
      long long v8 = v23;
    }
    *(_OWORD *)a4 = v8;
    *(void *)(a4 + 16) = v9;
    *(_WORD *)(a4 + 24) = v26;
    *(unsigned char *)(a4 + 26) = v27;
    if (*(unsigned __int8 *)(a3 + 26) < *(unsigned __int8 *)(a2 + 26))
    {
      long long v14 = *(_OWORD *)a2;
      uint64_t v15 = *(void *)(a2 + 16);
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
      *(void *)a2 = 0;
      __int16 v16 = (_WORD *)(a2 + 24);
      __int16 v28 = *(_WORD *)(a2 + 24);
      char v29 = *(unsigned char *)(a2 + 26);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(void *)(a2 + 16) = *(void *)(a3 + 16);
      *(void *)a3 = 0;
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      char v17 = *(unsigned char *)(a3 + 26);
      *(_WORD *)(a2 + 24) = *v11;
      *(unsigned char *)(a2 + 26) = v17;
      __int16 v18 = *(void **)a3;
      if (*(void *)a3)
      {
        *(void *)(a3 + 8) = v18;
        long long v24 = v14;
        operator delete(v18);
        long long v14 = v24;
      }
      *(_OWORD *)a3 = v14;
      *(void *)(a3 + 16) = v15;
      _WORD *v11 = v28;
      *(unsigned char *)(a3 + 26) = v29;
      if (*(unsigned __int8 *)(a2 + 26) < *(unsigned __int8 *)(a1 + 26))
      {
        long long v19 = *(_OWORD *)a1;
        uint64_t v20 = *(void *)(a1 + 16);
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
        *(void *)a1 = 0;
        __int16 v30 = *(_WORD *)(a1 + 24);
        char v31 = *(unsigned char *)(a1 + 26);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(void *)(a1 + 16) = *(void *)(a2 + 16);
        *(void *)a2 = 0;
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
        char v21 = *(unsigned char *)(a2 + 26);
        *(_WORD *)(a1 + 24) = *v16;
        *(unsigned char *)(a1 + 26) = v21;
        uint64_t v22 = *(void **)a2;
        if (*(void *)a2)
        {
          *(void *)(a2 + 8) = v22;
          long long v25 = v19;
          operator delete(v22);
          long long v19 = v25;
        }
        *(_OWORD *)a2 = v19;
        *(void *)(a2 + 16) = v20;
        *__int16 v16 = v30;
        *(unsigned char *)(a2 + 26) = v31;
      }
    }
  }
}

void std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>(a1, a2, a3, a4);
  if (*(unsigned __int8 *)(a5 + 26) < *(unsigned __int8 *)(a4 + 26))
  {
    long long v10 = *(_OWORD *)a4;
    uint64_t v11 = *(void *)(a4 + 16);
    *(void *)(a4 + 8) = 0;
    *(void *)(a4 + 16) = 0;
    unint64_t v13 = (_WORD *)(a4 + 24);
    __int16 v12 = *(_WORD *)(a4 + 24);
    *(void *)a4 = 0;
    __int16 v34 = v12;
    char v35 = *(unsigned char *)(a4 + 26);
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(void *)(a4 + 16) = *(void *)(a5 + 16);
    *(void *)a5 = 0;
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 16) = 0;
    char v14 = *(unsigned char *)(a5 + 26);
    *(_WORD *)(a4 + 24) = *(_WORD *)(a5 + 24);
    *(unsigned char *)(a4 + 26) = v14;
    uint64_t v15 = *(void **)a5;
    if (*(void *)a5)
    {
      *(void *)(a5 + 8) = v15;
      long long v30 = v10;
      operator delete(v15);
      long long v10 = v30;
    }
    *(_OWORD *)a5 = v10;
    *(void *)(a5 + 16) = v11;
    *(_WORD *)(a5 + 24) = v34;
    *(unsigned char *)(a5 + 26) = v35;
    if (*(unsigned __int8 *)(a4 + 26) < *(unsigned __int8 *)(a3 + 26))
    {
      long long v16 = *(_OWORD *)a3;
      uint64_t v17 = *(void *)(a3 + 16);
      *(void *)(a3 + 8) = 0;
      *(void *)(a3 + 16) = 0;
      *(void *)a3 = 0;
      __int16 v18 = (_WORD *)(a3 + 24);
      __int16 v36 = *(_WORD *)(a3 + 24);
      char v37 = *(unsigned char *)(a3 + 26);
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(void *)(a3 + 16) = *(void *)(a4 + 16);
      *(void *)a4 = 0;
      *(void *)(a4 + 8) = 0;
      *(void *)(a4 + 16) = 0;
      char v19 = *(unsigned char *)(a4 + 26);
      *(_WORD *)(a3 + 24) = *v13;
      *(unsigned char *)(a3 + 26) = v19;
      uint64_t v20 = *(void **)a4;
      if (*(void *)a4)
      {
        *(void *)(a4 + 8) = v20;
        long long v31 = v16;
        operator delete(v20);
        long long v16 = v31;
      }
      *(_OWORD *)a4 = v16;
      *(void *)(a4 + 16) = v17;
      *unint64_t v13 = v36;
      *(unsigned char *)(a4 + 26) = v37;
      if (*(unsigned __int8 *)(a3 + 26) < *(unsigned __int8 *)(a2 + 26))
      {
        long long v21 = *(_OWORD *)a2;
        uint64_t v22 = *(void *)(a2 + 16);
        *(void *)(a2 + 8) = 0;
        *(void *)(a2 + 16) = 0;
        *(void *)a2 = 0;
        long long v23 = (_WORD *)(a2 + 24);
        __int16 v38 = *(_WORD *)(a2 + 24);
        char v39 = *(unsigned char *)(a2 + 26);
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(void *)(a2 + 16) = *(void *)(a3 + 16);
        *(void *)a3 = 0;
        *(void *)(a3 + 8) = 0;
        *(void *)(a3 + 16) = 0;
        char v24 = *(unsigned char *)(a3 + 26);
        *(_WORD *)(a2 + 24) = *v18;
        *(unsigned char *)(a2 + 26) = v24;
        long long v25 = *(void **)a3;
        if (*(void *)a3)
        {
          *(void *)(a3 + 8) = v25;
          long long v32 = v21;
          operator delete(v25);
          long long v21 = v32;
        }
        *(_OWORD *)a3 = v21;
        *(void *)(a3 + 16) = v22;
        _WORD *v18 = v38;
        *(unsigned char *)(a3 + 26) = v39;
        if (*(unsigned __int8 *)(a2 + 26) < *(unsigned __int8 *)(a1 + 26))
        {
          long long v26 = *(_OWORD *)a1;
          uint64_t v27 = *(void *)(a1 + 16);
          *(void *)(a1 + 8) = 0;
          *(void *)(a1 + 16) = 0;
          *(void *)a1 = 0;
          __int16 v40 = *(_WORD *)(a1 + 24);
          char v41 = *(unsigned char *)(a1 + 26);
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(void *)(a1 + 16) = *(void *)(a2 + 16);
          *(void *)a2 = 0;
          *(void *)(a2 + 8) = 0;
          *(void *)(a2 + 16) = 0;
          char v28 = *(unsigned char *)(a2 + 26);
          *(_WORD *)(a1 + 24) = *v23;
          *(unsigned char *)(a1 + 26) = v28;
          char v29 = *(void **)a2;
          if (*(void *)a2)
          {
            *(void *)(a2 + 8) = v29;
            long long v33 = v26;
            operator delete(v29);
            long long v26 = v33;
          }
          *(_OWORD *)a2 = v26;
          *(void *)(a2 + 16) = v27;
          _WORD *v23 = v40;
          *(unsigned char *)(a2 + 26) = v41;
        }
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 5;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (*(unsigned __int8 *)(a2 - 6) < *(unsigned __int8 *)(a1 + 26))
      {
        unsigned int v6 = (void *)(a2 - 32);
        long long v7 = *(_OWORD *)a1;
        uint64_t v8 = *(void *)(a1 + 16);
        *(void *)(a1 + 8) = 0;
        *(void *)(a1 + 16) = 0;
        *(void *)a1 = 0;
        __int16 v29 = *(_WORD *)(a1 + 24);
        char v30 = *(unsigned char *)(a1 + 26);
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 32);
        *(void *)(a1 + 16) = *(void *)(a2 - 16);
        void *v6 = 0;
        v6[1] = 0;
        v6[2] = 0;
        uint64_t v9 = (_WORD *)(a2 - 8);
        char v10 = *(unsigned char *)(a2 - 6);
        *(_WORD *)(a1 + 24) = *(_WORD *)(a2 - 8);
        *(unsigned char *)(a1 + 26) = v10;
        uint64_t v11 = *(void **)(a2 - 32);
        if (v11)
        {
          *(void *)(a2 - 24) = v11;
          long long v27 = v7;
          operator delete(v11);
          long long v7 = v27;
        }
        *(_OWORD *)(a2 - 32) = v7;
        *(void *)(a2 - 16) = v8;
        _WORD *v9 = v29;
        *(unsigned char *)(a2 - 6) = v30;
        return 1;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>((long long *)a1, (long long *)(a1 + 32), (long long *)(a2 - 32));
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>(a1, a1 + 32, a1 + 64, a2 - 32);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>(a1, a1 + 32, a1 + 64, a1 + 96, a2 - 32);
      return 1;
    default:
      uint64_t v12 = a1 + 64;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelExternalPointFeature::finalize(void)::{lambda(md::LabelFeaturePlacementInfo const&,md::LabelFeaturePlacementInfo const&)#1} &,md::LabelFeaturePlacementInfo*>((long long *)a1, (long long *)(a1 + 32), (long long *)(a1 + 64));
      uint64_t v13 = a1 + 96;
      if (a1 + 96 == a2) {
        return 1;
      }
      uint64_t v14 = 0;
      int v15 = 0;
      break;
  }
  while (1)
  {
    unsigned int v16 = *(unsigned __int8 *)(v13 + 26);
    if (v16 < *(unsigned __int8 *)(v12 + 26))
    {
      long long v28 = *(_OWORD *)v13;
      uint64_t v17 = *(void *)(v13 + 16);
      *(void *)(v13 + 8) = 0;
      *(void *)(v13 + 16) = 0;
      *(void *)uint64_t v13 = 0;
      uint64_t v18 = v14;
      __int16 v19 = *(_WORD *)(v13 + 24);
      uint64_t v20 = a1 + v14;
      while (1)
      {
        long long v21 = (void **)(v20 + 64);
        *(_OWORD *)(v20 + 96) = *(_OWORD *)(v20 + 64);
        *(void *)(v20 + 112) = *(void *)(v20 + 80);
        *(void *)(v20 + 64) = 0;
        *(void *)(v20 + 72) = 0;
        *(void *)(v20 + 80) = 0;
        *(_WORD *)(v20 + 120) = *(_WORD *)(v20 + 88);
        *(unsigned char *)(v20 + 122) = *(unsigned char *)(v20 + 90);
        if (v18 == -64)
        {
          char v24 = (_WORD *)(a1 + 24);
          uint64_t v25 = a1;
          long long v26 = *(void **)a1;
          if (!*(void *)a1) {
            goto LABEL_8;
          }
          goto LABEL_20;
        }
        uint64_t v22 = a1 + v18;
        if (v16 >= *(unsigned __int8 *)(a1 + v18 + 58)) {
          break;
        }
        long long v23 = *v21;
        v18 -= 32;
        uint64_t v20 = a1 + v18;
        if (*v21)
        {
          *(void *)(v20 + 104) = v23;
          operator delete(v23);
          *(void *)(v20 + 104) = 0;
          *(void *)(v20 + 112) = 0;
        }
      }
      uint64_t v25 = v22 + 64;
      char v24 = (_WORD *)(v22 + 88);
      long long v26 = *(void **)(v22 + 64);
      if (!v26) {
        goto LABEL_8;
      }
LABEL_20:
      *(void *)(v25 + 8) = v26;
      operator delete(v26);
LABEL_8:
      *(_OWORD *)uint64_t v25 = v28;
      *(void *)(v25 + 16) = v17;
      *char v24 = v19;
      *(unsigned char *)(v25 + 26) = v16;
      if (++v15 == 8) {
        return v13 + 32 == a2;
      }
    }
    uint64_t v12 = v13;
    v14 += 32;
    v13 += 32;
    if (v13 == a2) {
      return 1;
    }
  }
}

void std::__shared_ptr_emplace<md::LabelExternalPointFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581CC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelExternalPointFeature>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581CC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *md::LabelTransitRoute::generateTransitNodeFeatures(uint64_t **a1, int64x2_t ***a2)
{
  v485[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1 + 20;
  uint64_t v4 = a1 + 19;
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)(a1 + 19), a1[20]);
  v3[2] = 0;
  *(v3 - 1) = (uint64_t *)v3;
  unsigned __int8 *v3 = 0;
  BOOL v5 = *(v3 - 16);
  v468 = [v5 stations];

  unsigned int v6 = a1[11];
  long long v7 = a1[12];
  v440 = (md::LabelTransitRoute *)a1;
  if (v6 == v7) {
    goto LABEL_51;
  }
  unint64_t v8 = 0;
  char v9 = 1;
  do
  {
    uint64_t v10 = *v6;
    id v11 = *(id *)(*v6 + 16);
    uint64_t v12 = v11;
    if (v11 && [v11 hasStationIndex])
    {
      uint64_t v13 = objc_msgSend(v468, "objectAtIndexedSubscript:", objc_msgSend(v12, "stationIndex"));
      if ([v13 hasMuid])
      {
        unint64_t v14 = [v13 muid];

        if (v9) {
          goto LABEL_12;
        }
      }
      else
      {
        unint64_t v14 = 0;

        if (v9)
        {
LABEL_12:
          if (!v14) {
            goto LABEL_4;
          }
          int v15 = *v3;
          unsigned int v16 = v3;
          uint64_t v17 = v3;
          if (*v3)
          {
            while (1)
            {
              while (1)
              {
                uint64_t v17 = (uint64_t **)v15;
                unint64_t v18 = v15[4];
                if (v14 >= v18) {
                  break;
                }
                int v15 = *v17;
                unsigned int v16 = v17;
                if (!*v17) {
                  goto LABEL_20;
                }
              }
              if (v18 >= v14) {
                break;
              }
              int v15 = v17[1];
              if (!v15)
              {
                unsigned int v16 = v17 + 1;
                goto LABEL_20;
              }
            }
            char v9 = 0;
          }
          else
          {
LABEL_20:
            __int16 v19 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v440 + 21) + 16))(*((void *)v440 + 21), 40, 8);
            v19[4] = v14;
            uint64_t *v19 = 0;
            v19[1] = 0;
            v19[2] = (uint64_t)v17;
            *unsigned int v16 = v19;
            uint64_t v20 = (void *)**v4;
            if (v20)
            {
              *uint64_t v4 = v20;
              __int16 v19 = *v16;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v440 + 20), v19);
            char v9 = 0;
            ++*((void *)v440 + 22);
          }
          goto LABEL_5;
        }
      }
    }
    else
    {
      unint64_t v14 = 0;
      if (v9) {
        goto LABEL_12;
      }
    }
    if ((*(unsigned __int8 *)(v10 + 109) | 2) == 6)
    {
      if (v8)
      {
        long long v21 = *v3;
        uint64_t v22 = v3;
        long long v23 = v3;
        if (*v3)
        {
          while (1)
          {
            while (1)
            {
              long long v23 = (uint64_t **)v21;
              unint64_t v24 = v21[4];
              if (v8 >= v24) {
                break;
              }
              long long v21 = *v23;
              uint64_t v22 = v23;
              if (!*v23) {
                goto LABEL_33;
              }
            }
            if (v24 >= v8) {
              break;
            }
            long long v21 = v23[1];
            if (!v21)
            {
              uint64_t v22 = v23 + 1;
              goto LABEL_33;
            }
          }
          unint64_t v8 = 0;
        }
        else
        {
LABEL_33:
          uint64_t v25 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v440 + 21) + 16))(*((void *)v440 + 21), 40, 8);
          v25[4] = v8;
          uint64_t *v25 = 0;
          v25[1] = 0;
          v25[2] = (uint64_t)v23;
          *uint64_t v22 = v25;
          long long v26 = (void *)**v4;
          if (v26)
          {
            *uint64_t v4 = v26;
            uint64_t v25 = *v22;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v440 + 20), v25);
          unint64_t v8 = 0;
          ++*((void *)v440 + 22);
        }
      }
LABEL_4:
      char v9 = 1;
      goto LABEL_5;
    }
    char v9 = 0;
    if (v14) {
      unint64_t v8 = v14;
    }
LABEL_5:

    ++v6;
  }
  while (v6 != v7);
  if (v8)
  {
    long long v27 = *v3;
    long long v28 = v3;
    if (*v3)
    {
      while (1)
      {
        while (1)
        {
          long long v28 = (uint64_t **)v27;
          unint64_t v29 = v27[4];
          if (v8 >= v29) {
            break;
          }
          long long v27 = *v28;
          uint64_t v3 = v28;
          if (!*v28) {
            goto LABEL_48;
          }
        }
        if (v29 >= v8) {
          break;
        }
        long long v27 = v28[1];
        if (!v27)
        {
          uint64_t v3 = v28 + 1;
          goto LABEL_48;
        }
      }
    }
    else
    {
LABEL_48:
      char v30 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v440 + 21) + 16))(*((void *)v440 + 21), 40, 8);
      v30[4] = v8;
      *char v30 = 0;
      v30[1] = 0;
      v30[2] = (uint64_t)v28;
      unsigned __int8 *v3 = v30;
      long long v31 = (void *)**v4;
      if (v31)
      {
        *uint64_t v4 = v31;
        char v30 = *v3;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v440 + 20), v30);
      ++*((void *)v440 + 22);
    }
  }
LABEL_51:

  long long v32 = (uint64_t *)*((void *)v440 + 11);
  long long v33 = (uint64_t *)*((void *)v440 + 12);
  if (v32 == v33) {
    return md::LabelTransitRoute::updateTransitNodesRouteState(v440);
  }
  int v34 = 0;
  uint64_t v35 = 0xFFFFFFFFLL;
  int v36 = -1;
  while (2)
  {
    uint64_t v38 = *v32;
    uint64_t v37 = *(unsigned int *)(*v32 + 56);
    uint64_t v39 = *((void *)v440 + 7);
    uint64_t v40 = *(void *)(v39 + 8 * (int)v37);
    if (v40) {
      uint64_t v41 = v40 + 8;
    }
    else {
      uint64_t v41 = 0;
    }
    id v42 = *(id *)(v41 + 8);
    uint64_t v43 = [v42 type];

    if (v43 != 6) {
      goto LABEL_54;
    }
    if (v37 == v35)
    {
      int v36 = v34;
LABEL_54:
      uint64_t v37 = v35;
      goto LABEL_55;
    }
    *(unsigned char *)(v38 + 69) = 1;
    if (v35 != -1)
    {
      uint64_t v44 = *(void *)(v39 + 8 * (int)v37);
      uint64_t v45 = v44 ? v44 + 8 : 0;
      if (*(unsigned char *)(v45 + 70))
      {
        uint64_t v46 = *((void *)v440 + 11);
        if (v35 == v37 - 1)
        {
          uint64_t v47 = *(void *)(v46 + 8 * v36);
          goto LABEL_68;
        }
        uint64_t v47 = *(void *)(v46 + 8 * v36);
        uint64_t v50 = v47 + 8;
        if (!v47) {
          uint64_t v50 = 0;
        }
        double v51 = *((double *)v440 + 26);
        if (vabdd_f64(*(double *)(v38 + 40), *(double *)(v50 + 32)) < v51
          && vabdd_f64(*(double *)(v38 + 48), *(double *)(v50 + 40)) < v51)
        {
LABEL_68:
          if (v47) {
            uint64_t v48 = v47 + 8;
          }
          else {
            uint64_t v48 = 0;
          }
          *(unsigned char *)(v48 + 90) = 1;
          *(_DWORD *)(v48 + 92) = v35;
          *(_DWORD *)(v48 + 96) = v37;
          if (*v32) {
            uint64_t v49 = *v32 + 8;
          }
          else {
            uint64_t v49 = 0;
          }
          *(unsigned char *)(v49 + 90) = 1;
          *(_DWORD *)(v49 + 92) = v35;
          *(_DWORD *)(v49 + 96) = v37;
        }
      }
    }
    int v36 = v34;
LABEL_55:
    ++v32;
    ++v34;
    uint64_t v35 = v37;
    if (v32 != v33) {
      continue;
    }
    break;
  }
  unsigned int v53 = (uint64_t *)*((void *)v440 + 11);
  unsigned int v52 = (uint64_t *)*((void *)v440 + 12);
  if (v53 == v52) {
    return md::LabelTransitRoute::updateTransitNodesRouteState(v440);
  }
  v469 = (uint64_t *)*((void *)v440 + 12);
  while (2)
  {
    uint64_t v54 = *v53;
    if (*(unsigned char *)(*v53 + 110)) {
      BOOL v55 = 1;
    }
    else {
      BOOL v55 = *(unsigned char *)(*v53 + 99) == 0;
    }
    if (v55) {
      goto LABEL_83;
    }
    int v56 = *(_DWORD *)(v54 + 64);
    LODWORD(v477) = v56 + 1;
    v476.n128_u32[0] = v56 - 1;
    v475.n128_u16[0] = 0;
    {
      operator new();
    }
    uint64_t v57 = mdm::Allocator::instance(void)::alloc;
    if (md::LabelTransitRoute::findStopHeadingRange((uint64_t)v440, (double *)(v54 + 40), &v477, 1, (char *)&v475))
    {
      long long v58 = (unsigned __int8 *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v57 + 16))(v57, 2, 1);
      uint64_t v59 = v58;
      unint64_t v60 = (unint64_t)(v58 + 2);
      if (v58) {
        *(_WORD *)long long v58 = v475.n128_u16[0];
      }
    }
    else
    {
      unint64_t v60 = 0;
      uint64_t v59 = 0;
    }
    if (md::LabelTransitRoute::findStopHeadingRange((uint64_t)v440, (double *)(v54 + 40), &v476, -1, (char *)&v475))
    {
      uint64_t v61 = v60 - (void)v59;
      if ((uint64_t)(v60 - (void)v59) <= -3) {
        abort();
      }
      uint64_t v62 = v61 >> 1;
      if (v61 <= (unint64_t)((v61 >> 1) + 1)) {
        uint64_t v63 = v62 + 1;
      }
      else {
        uint64_t v63 = v60 - (void)v59;
      }
      if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v64 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v64 = v63;
      }
      if (v64)
      {
        uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v57 + 16))(v57, 2 * v64, 1);
        unint64_t v66 = (_WORD *)(v65 + 2 * v62);
        uint64_t v64 = v65 + 2 * v64;
        if (v65) {
          *unint64_t v66 = v475.n128_u16[0];
        }
      }
      else
      {
        unint64_t v66 = (_WORD *)(2 * v62);
      }
      uint64_t v68 = v66;
      __int16 v69 = (unsigned __int8 *)v60;
      if ((unsigned __int8 *)v60 != v59)
      {
        unint64_t v70 = v60 - (void)v59 - 2;
        unsigned int v71 = (unsigned __int8 *)v60;
        uint64_t v68 = v66;
        if (v70 < 0x1E) {
          goto LABEL_683;
        }
        unint64_t v72 = v70 >> 1;
        if ((unint64_t)&v66[-v72 - 1] < v60)
        {
          unsigned int v71 = (unsigned __int8 *)v60;
          uint64_t v68 = v66;
          if (v60 - 2 * v72 - 2 < (unint64_t)v66) {
            goto LABEL_683;
          }
        }
        unint64_t v73 = v72 + 1;
        unsigned int v71 = (unsigned __int8 *)(v60 - 2 * (v73 & 0xFFFFFFFFFFFFFFF0));
        unsigned int v74 = (const char *)(v60 - 32);
        unsigned int v75 = (char *)(v66 - 16);
        unint64_t v76 = v73 & 0xFFFFFFFFFFFFFFF0;
        do
        {
          int8x16x2_t v486 = vld2q_s8(v74);
          v74 -= 32;
          vst2q_s8(v75, v486);
          v75 -= 32;
          v76 -= 16;
        }
        while (v76);
        uint64_t v68 = &v66[-(v73 & 0xFFFFFFFFFFFFFFF0)];
        if (v73 != (v73 & 0xFFFFFFFFFFFFFFF0))
        {
LABEL_683:
          do
          {
            char v77 = *(v71 - 2);
            v71 -= 2;
            *((unsigned char *)v68-- - 2) = v77;
            *((unsigned char *)v68 + 1) = v71[1];
          }
          while (v71 != v59);
        }
        __int16 v69 = v59;
      }
      unint64_t v67 = (unsigned __int8 *)(v66 + 1);
      if (v69) {
        (*(void (**)(uint64_t, unsigned __int8 *, unint64_t))(*(void *)v57 + 40))(v57, v69, v60 - (void)v69);
      }
      unint64_t v60 = v64;
      uint64_t v59 = (unsigned __int8 *)v68;
    }
    else
    {
      unint64_t v67 = (unsigned __int8 *)v60;
    }
    if (!md::LabelTransitRoute::findRouteHeadingRange((uint64_t)v440, (double *)(v54 + 40), (int)v477, 1, (char *)&v475))
    {
      int64_t v78 = v67;
      goto LABEL_143;
    }
    if ((unint64_t)v67 >= v60)
    {
      uint64_t v79 = v67 - v59;
      if (v67 - v59 <= -3) {
        abort();
      }
      uint64_t v80 = v79 >> 1;
      if (v60 - (unint64_t)v59 <= (v79 >> 1) + 1) {
        uint64_t v81 = v80 + 1;
      }
      else {
        uint64_t v81 = v60 - (void)v59;
      }
      if (v60 - (unint64_t)v59 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v82 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v82 = v81;
      }
      if (v82)
      {
        uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v57 + 16))(v57, 2 * v82, 1);
        unint64_t v84 = (unsigned __int8 *)(v83 + 2 * v80);
        uint64_t v82 = v83 + 2 * v82;
        if (v83) {
          *(_WORD *)unint64_t v84 = v475.n128_u16[0];
        }
        int64_t v85 = v67 - v59;
        if (v67 != v59)
        {
LABEL_135:
          unint64_t v86 = v85 - 2;
          if (v86 >= 0x1E && ((unint64_t v87 = v86 >> 1, &v84[-2 * v87 - 2] >= v67) || &v67[-2 * v87 - 2] >= v84))
          {
            unint64_t v129 = v87 + 1;
            unint64_t v130 = (v87 + 1) & 0xFFFFFFFFFFFFFFF0;
            unint64_t v88 = &v67[-2 * v130];
            uint64_t v131 = (const char *)(v67 - 32);
            long long v132 = (char *)(v84 - 32);
            unint64_t v133 = v130;
            do
            {
              int8x16x2_t v487 = vld2q_s8(v131);
              v131 -= 32;
              vst2q_s8(v132, v487);
              v132 -= 32;
              v133 -= 16;
            }
            while (v133);
            __int16 v89 = &v84[-2 * v130];
            if (v129 == v130)
            {
LABEL_140:
              unint64_t v67 = v59;
              int64_t v78 = v84 + 2;
              if (!v59)
              {
LABEL_142:
                unint64_t v60 = v82;
                uint64_t v59 = v89;
                goto LABEL_143;
              }
LABEL_141:
              (*(void (**)(uint64_t, unsigned __int8 *, unint64_t))(*(void *)v57 + 40))(v57, v67, v60 - (void)v67);
              goto LABEL_142;
            }
          }
          else
          {
            unint64_t v88 = v67;
            __int16 v89 = v84;
          }
          do
          {
            unsigned __int8 v90 = *(v88 - 2);
            v88 -= 2;
            *(v89 - 2) = v90;
            v89 -= 2;
            v89[1] = v88[1];
          }
          while (v88 != v59);
          goto LABEL_140;
        }
      }
      else
      {
        unint64_t v84 = (unsigned __int8 *)(2 * v80);
        int64_t v85 = v67 - v59;
        if (v67 != v59) {
          goto LABEL_135;
        }
      }
      __int16 v89 = v84;
      int64_t v78 = v84 + 2;
      if (!v67) {
        goto LABEL_142;
      }
      goto LABEL_141;
    }
    if (v67) {
      *(_WORD *)unint64_t v67 = v475.n128_u16[0];
    }
    int64_t v78 = v67 + 2;
LABEL_143:
    if (!md::LabelTransitRoute::findRouteHeadingRange((uint64_t)v440, (double *)(v54 + 40), v476.n128_i32[0], -1, (char *)&v475))
    {
      unsigned int v91 = v78;
      goto LABEL_168;
    }
    if ((unint64_t)v78 >= v60)
    {
      uint64_t v92 = v78 - v59;
      if (v78 - v59 <= -3) {
        abort();
      }
      uint64_t v93 = v92 >> 1;
      if (v60 - (unint64_t)v59 <= (v92 >> 1) + 1) {
        uint64_t v94 = v93 + 1;
      }
      else {
        uint64_t v94 = v60 - (void)v59;
      }
      if (v60 - (unint64_t)v59 >= 0x7FFFFFFFFFFFFFFELL) {
        uint64_t v95 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v95 = v94;
      }
      if (v95)
      {
        uint64_t v96 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v57 + 16))(v57, 2 * v95, 1);
        unsigned __int8 v97 = (unsigned __int8 *)(v96 + 2 * v93);
        uint64_t v95 = v96 + 2 * v95;
        if (v96) {
          *(_WORD *)unsigned __int8 v97 = v475.n128_u16[0];
        }
        int64_t v98 = v78 - v59;
        if (v78 != v59)
        {
LABEL_160:
          unint64_t v99 = v98 - 2;
          if (v99 >= 0x1E && ((unint64_t v100 = v99 >> 1, &v97[-2 * v100 - 2] >= v78) || &v78[-2 * v100 - 2] >= v97))
          {
            unint64_t v134 = v100 + 1;
            unint64_t v135 = (v100 + 1) & 0xFFFFFFFFFFFFFFF0;
            unint64_t v101 = &v78[-2 * v135];
            __int16 v136 = (const char *)(v78 - 32);
            uint64_t v137 = (char *)(v97 - 32);
            unint64_t v138 = v135;
            do
            {
              int8x16x2_t v488 = vld2q_s8(v136);
              v136 -= 32;
              vst2q_s8(v137, v488);
              v137 -= 32;
              v138 -= 16;
            }
            while (v138);
            __int16 v102 = &v97[-2 * v135];
            if (v134 == v135)
            {
LABEL_165:
              int64_t v78 = v59;
              unsigned int v91 = v97 + 2;
              if (!v59)
              {
LABEL_167:
                unint64_t v60 = v95;
                uint64_t v59 = v102;
                goto LABEL_168;
              }
LABEL_166:
              (*(void (**)(uint64_t, unsigned __int8 *, unint64_t))(*(void *)v57 + 40))(v57, v78, v60 - (void)v78);
              goto LABEL_167;
            }
          }
          else
          {
            unint64_t v101 = v78;
            __int16 v102 = v97;
          }
          do
          {
            unsigned __int8 v103 = *(v101 - 2);
            v101 -= 2;
            *(v102 - 2) = v103;
            v102 -= 2;
            v102[1] = v101[1];
          }
          while (v101 != v59);
          goto LABEL_165;
        }
      }
      else
      {
        unsigned __int8 v97 = (unsigned __int8 *)(2 * v93);
        int64_t v98 = v78 - v59;
        if (v78 != v59) {
          goto LABEL_160;
        }
      }
      __int16 v102 = v97;
      unsigned int v91 = v97 + 2;
      if (!v78) {
        goto LABEL_167;
      }
      goto LABEL_166;
    }
    if (v78) {
      *(_WORD *)int64_t v78 = v475.n128_u16[0];
    }
    unsigned int v91 = v78 + 2;
LABEL_168:
    unint64_t v104 = (v91 - v59) >> 1;
    unint64_t v105 = 126 - 2 * __clz(v104);
    if (v91 == v59) {
      uint64_t v106 = 0;
    }
    else {
      uint64_t v106 = v105;
    }
    std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *,false>((unint64_t)v59, v91, v106, 1);
    if (v91 != v59)
    {
      unint64_t v107 = 0;
      while (1)
      {
        if (v107 + 1 == v104) {
          unint64_t v109 = 0;
        }
        else {
          unint64_t v109 = v107 + 1;
        }
        if (v107 != v109)
        {
          unsigned __int8 v110 = &v59[2 * v107];
          __int16 v111 = &v59[2 * v109];
          v112 = v110 + 1;
          unsigned __int8 v113 = *v110;
          unsigned __int8 v114 = *v111;
          unsigned int v115 = (*v111 - *v110);
          if (v115 > (v111[1] - *v110))
          {
            unsigned __int8 v116 = v111[1] - *v110;
            if ((v110[1] - *v110) > v116) {
              unsigned __int8 v116 = v110[1] - *v110;
            }
            unsigned char *v112 = v116 + v113;
            *unsigned __int8 v110 = v114;
LABEL_187:
            if (v111 + 2 == v91)
            {
              unsigned int v91 = &v59[2 * v109];
            }
            else
            {
              size_t v118 = ((v91 - v111 - 4) & 0xFFFFFFFFFFFFFFFELL) + 2;
              memmove(v111, v111 + 2, v118);
              unsigned int v91 = &v59[2 * v109 + v118];
            }
            goto LABEL_174;
          }
          if (v115 <= (v110[1] - *v110))
          {
            unsigned __int8 v117 = v111[1] - *v110;
            if ((v110[1] - *v110) > v117) {
              unsigned __int8 v117 = v110[1] - *v110;
            }
            unsigned char *v112 = v117 + v113;
            goto LABEL_187;
          }
        }
        ++v107;
LABEL_174:
        int64_t v108 = v91 - v59;
        unint64_t v104 = (v91 - v59) >> 1;
        if (v107 >= v104) {
          goto LABEL_191;
        }
      }
    }
    int64_t v108 = 0;
LABEL_191:
    if (v59 != v91)
    {
      __n128 v479 = 0uLL;
      v480 = 0;
      {
        operator new();
      }
      uint64_t v481 = mdm::Allocator::instance(void)::alloc;
      if (v108 == 2)
      {
        populatePlacementsInArc(v59[1], (uint64_t *)&v479, (float)((float)(v59[1] - *v59) * -1.4118) + 360.0);
      }
      else
      {
        uint64_t v124 = 0;
        unsigned int v125 = v59 + 1;
        while (v104 != v124)
        {
          uint64_t v126 = v124 + 1;
          if (v104 - 1 == v124) {
            uint64_t v127 = 0;
          }
          else {
            uint64_t v127 = v124 + 1;
          }
          unsigned int v128 = *v125;
          v125 += 2;
          populatePlacementsInArc(v128, (uint64_t *)&v479, (float)(v59[2 * v127] - v128) * 1.4118);
          uint64_t v124 = v126;
        }
      }
      __int16 v119 = (unsigned char *)v479.n128_u64[0];
      if (v479.n128_u64[0] != v479.n128_u64[1])
      {
        LOBYTE(v482) = -32;
        v471.n128_u64[0] = (unint64_t)&v482;
        unint64_t v120 = (uint64_t)(v479.n128_u64[1] - v479.n128_u64[0]) >> 3;
        std::__introsort<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *,false>((float *)v479.n128_u64[0], (float *)v479.n128_u64[1], (char **)&v471, 126 - 2 * __clz(v120), 1);
        uint64_t v121 = 4;
        if (v120 < 4) {
          uint64_t v121 = v120;
        }
        if (v121)
        {
          *(unsigned char *)(v54 + 71) = *v119;
          if (v121 != 1)
          {
            uint64_t v122 = 0;
            uint64_t v123 = (float *)(v119 + 12);
            while (*v123 >= 35.0)
            {
              *(unsigned char *)(v54 + 72 + v122++) = *((unsigned char *)v123 - 4);
              v123 += 2;
              if (v121 - 1 == v122) {
                goto LABEL_217;
              }
            }
            LOBYTE(v121) = v122 + 1;
          }
        }
LABEL_217:
        *(unsigned char *)(v54 + 70) = v121;
      }
      if (v119) {
        (*(void (**)(uint64_t, unsigned char *, int64_t))(*(void *)v481 + 40))(v481, v119, v480 - v119);
      }
    }
    if (v59) {
      (*(void (**)(uint64_t, unsigned __int8 *, unint64_t))(*(void *)v57 + 40))(v57, v59, v60 - (void)v59);
    }
    unsigned int v52 = v469;
LABEL_83:
    if (++v53 != v52) {
      continue;
    }
    break;
  }
  long long v139 = (uint64_t *)*((void *)v440 + 11);
  v430 = (uint64_t *)*((void *)v440 + 12);
  if (v139 == v430) {
    return md::LabelTransitRoute::updateTransitNodesRouteState(v440);
  }
  int v439 = 0;
  while (2)
  {
    ++v439;
    v438 = v139;
    uint64_t v441 = *v139;
    if (!*(unsigned char *)(*v139 + 99)) {
      goto LABEL_236;
    }
    v470 = (std::__shared_weak_count *)operator new(0x1D8uLL);
    v470->__shared_owners_ = 0;
    p_unint64_t shared_owners = &v470->__shared_owners_;
    v470->__shared_weak_owners_ = 0;
    v470->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581CC8;
    long long v140 = md::LabelExternalPointFeature::LabelExternalPointFeature((md::LabelExternalPointFeature *)&v470[1]);
    atomic_fetch_add_explicit(&v470->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v141 = *(std::__shared_weak_count **)(v441 + 88);
    v435 = (int64x2_t *)v140;
    *(void *)(v441 + 80) = v140;
    *(void *)(v441 + 88) = v470;
    if (v141 && !atomic_fetch_add(&v141->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v141->__on_zero_shared)(v141);
      std::__shared_weak_count::__release_weak(v141);
    }
    LOBYTE(v470[8].__shared_owners_) = 1;
    long long v142 = v470[9].__vftable;
    if ((std::__shared_weak_count_vtbl *)v470[9].__shared_owners_ != v142)
    {
      v142->__get_deleter = *(const void *(__cdecl **)(const std::__shared_weak_count *__hidden, const std::type_info *))(v441 + 40);
      v142->__on_zero_shared_weaunint64_t k = *(void (__cdecl **)(std::__shared_weak_count *__hidden))(v441 + 48);
      *(_WORD *)((char *)&v142[1].~__shared_weak_count + 5) = 257;
    }
    long long v143 = (id *)(v441 + 8);
    HIDWORD(v470[4].__shared_owners_) = v439;
    uint64_t v144 = *(void **)(v441 + 16);
    if (!v144)
    {
      if (*v143)
      {
        id v432 = *v143;
        uint64_t v431 = [v432 muid];
        __n128 v471 = 0u;
        long long v472 = 0u;
        long long v473 = 0u;
        long long v474 = 0u;
        id v168 = [v432 zoomNames];
        uint64_t v169 = [v168 countByEnumeratingWithState:&v471 objects:&v479 count:16];
        if (!v169) {
          goto LABEL_421;
        }
        uint64_t v463 = *(void *)v472;
        id v444 = v168;
LABEL_280:
        uint64_t v170 = 0;
        id obja = (id)v169;
        while (1)
        {
          if (*(void *)v472 != v463) {
            objc_enumerationMutation(v168);
          }
          id v171 = *(id *)(v471.n128_u64[1] + 8 * v170);
          v172 = [v171 labelText];
          if (![v172 length]) {
            goto LABEL_308;
          }
          long long v173 = [v171 labelLanguage];
          char v174 = [v171 minZoom];
          long long v175 = (const char *)[v172 UTF8String];
          id v176 = v173;
          long long v177 = (const char *)[v176 UTF8String];
          unint64_t shared_owners = v470[3].__shared_owners_;
          if (shared_owners < v470[3].__shared_weak_owners_) {
            break;
          }
          uint64_t v182 = std::vector<md::LabelExternalTextElement>::__emplace_back_slow_path<unsigned char &,char const*&,char const*&,char const*&,char const*&,md::LabelExternalTextType &>((int64x2_t *)&v470[3], v174, v175, v177, 0, 0, 0);
          uint64_t v169 = (uint64_t)obja;
          unsigned __int8 v183 = v470;
LABEL_307:
          v183[3].__shared_owners_ = v182;

LABEL_308:
          if (v169 == ++v170)
          {
            uint64_t v169 = [v168 countByEnumeratingWithState:&v471 objects:&v479 count:16];
            if (!v169) {
              goto LABEL_421;
            }
            goto LABEL_280;
          }
        }
        *(unsigned char *)unint64_t shared_owners = v174;
        *(unsigned char *)(shared_owners + 1) = 0;
        if (!v175) {
          long long v175 = "";
        }
        size_t v179 = strlen(v175);
        if (v179 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        size_t v180 = v179;
        id v451 = v171;
        v181 = (unsigned char *)(shared_owners + 8);
        if (v179 >= 0x17)
        {
          uint64_t v184 = (v179 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v179 | 7) != 0x17) {
            uint64_t v184 = v179 | 7;
          }
          uint64_t v185 = v184 + 1;
          v181 = operator new(v184 + 1);
          *(void *)(shared_owners + 16) = v180;
          *(void *)(shared_owners + 24) = v185 | 0x8000000000000000;
          *(void *)(shared_owners + 8) = v181;
          id v168 = v444;
        }
        else
        {
          *(unsigned char *)(shared_owners + 31) = v179;
          if (!v179)
          {
LABEL_296:
            v181[v180] = 0;
            if (!v177) {
              long long v177 = "";
            }
            size_t v186 = strlen(v177);
            if (v186 > 0x7FFFFFFFFFFFFFF7) {
              abort();
            }
            size_t v187 = v186;
            id v171 = v451;
            if (v186 >= 0x17)
            {
              uint64_t v189 = (v186 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v186 | 7) != 0x17) {
                uint64_t v189 = v186 | 7;
              }
              uint64_t v190 = v189 + 1;
              v188 = operator new(v189 + 1);
              *(void *)(shared_owners + 40) = v187;
              *(void *)(shared_owners + 48) = v190 | 0x8000000000000000;
              *(void *)(shared_owners + 32) = v188;
              id v168 = v444;
            }
            else
            {
              v188 = (void *)(shared_owners + 32);
              *(unsigned char *)(shared_owners + 55) = v186;
              if (!v186) {
                goto LABEL_306;
              }
            }
            memmove(v188, v177, v187);
LABEL_306:
            *((unsigned char *)v188 + v187) = 0;
            *(_WORD *)(shared_owners + 79) = 0;
            *(unsigned char *)(shared_owners + 56) = 0;
            *(unsigned char *)(shared_owners + 103) = 0;
            uint64_t v182 = shared_owners + 104;
            unsigned __int8 v183 = v470;
            v470[3].__shared_owners_ = shared_owners + 104;
            uint64_t v169 = (uint64_t)obja;
            goto LABEL_307;
          }
        }
        memmove(v181, v175, v180);
        goto LABEL_296;
      }
      v191 = *(void **)(v441 + 24);
      if (v191)
      {
        id v432 = v191;
        uint64_t v431 = [v432 muid];
        __n128 v471 = 0u;
        long long v472 = 0u;
        long long v473 = 0u;
        long long v474 = 0u;
        id v168 = [v432 zoomNames];
        uint64_t v192 = [v168 countByEnumeratingWithState:&v471 objects:&v479 count:16];
        if (!v192) {
          goto LABEL_421;
        }
        uint64_t v464 = *(void *)v472;
        id v445 = v168;
LABEL_314:
        uint64_t v193 = 0;
        id objb = (id)v192;
        while (1)
        {
          if (*(void *)v472 != v464) {
            objc_enumerationMutation(v168);
          }
          id v194 = *(id *)(v471.n128_u64[1] + 8 * v193);
          v195 = [v194 labelText];
          if (![v195 length]) {
            goto LABEL_342;
          }
          v196 = [v194 labelLanguage];
          char v197 = [v194 minZoom];
          v198 = (const char *)[v195 UTF8String];
          id v199 = v196;
          unsigned __int8 v200 = (const char *)[v199 UTF8String];
          unint64_t v201 = v470[3].__shared_owners_;
          if (v201 < v470[3].__shared_weak_owners_) {
            break;
          }
          uint64_t v205 = std::vector<md::LabelExternalTextElement>::__emplace_back_slow_path<unsigned char &,char const*&,char const*&,char const*&,char const*&,md::LabelExternalTextType &>((int64x2_t *)&v470[3], v197, v198, v200, 0, 0, 0);
          uint64_t v192 = (uint64_t)objb;
          uint64_t v206 = v470;
LABEL_341:
          v206[3].__shared_owners_ = v205;

LABEL_342:
          if (v192 == ++v193)
          {
            uint64_t v192 = [v168 countByEnumeratingWithState:&v471 objects:&v479 count:16];
            if (!v192) {
              goto LABEL_421;
            }
            goto LABEL_314;
          }
        }
        *(unsigned char *)unint64_t v201 = v197;
        *(unsigned char *)(v201 + 1) = 0;
        if (!v198) {
          v198 = "";
        }
        size_t v202 = strlen(v198);
        if (v202 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        size_t v203 = v202;
        id v452 = v194;
        __int16 v204 = (unsigned char *)(v201 + 8);
        if (v202 >= 0x17)
        {
          uint64_t v207 = (v202 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v202 | 7) != 0x17) {
            uint64_t v207 = v202 | 7;
          }
          uint64_t v208 = v207 + 1;
          __int16 v204 = operator new(v207 + 1);
          *(void *)(v201 + 16) = v203;
          *(void *)(v201 + 24) = v208 | 0x8000000000000000;
          *(void *)(v201 + 8) = v204;
          id v168 = v445;
        }
        else
        {
          *(unsigned char *)(v201 + 31) = v202;
          if (!v202)
          {
LABEL_330:
            v204[v203] = 0;
            if (!v200) {
              unsigned __int8 v200 = "";
            }
            size_t v209 = strlen(v200);
            if (v209 > 0x7FFFFFFFFFFFFFF7) {
              abort();
            }
            size_t v210 = v209;
            id v194 = v452;
            if (v209 >= 0x17)
            {
              uint64_t v212 = (v209 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v209 | 7) != 0x17) {
                uint64_t v212 = v209 | 7;
              }
              uint64_t v213 = v212 + 1;
              unsigned __int8 v211 = operator new(v212 + 1);
              *(void *)(v201 + 40) = v210;
              *(void *)(v201 + 48) = v213 | 0x8000000000000000;
              *(void *)(v201 + 32) = v211;
              id v168 = v445;
            }
            else
            {
              unsigned __int8 v211 = (void *)(v201 + 32);
              *(unsigned char *)(v201 + 55) = v209;
              if (!v209) {
                goto LABEL_340;
              }
            }
            memmove(v211, v200, v210);
LABEL_340:
            *((unsigned char *)v211 + v210) = 0;
            *(_WORD *)(v201 + 79) = 0;
            *(unsigned char *)(v201 + 56) = 0;
            *(unsigned char *)(v201 + 103) = 0;
            uint64_t v205 = v201 + 104;
            uint64_t v206 = v470;
            v470[3].__shared_owners_ = v201 + 104;
            uint64_t v192 = (uint64_t)objb;
            goto LABEL_341;
          }
        }
        memmove(v204, v198, v203);
        goto LABEL_330;
      }
      unsigned __int8 v214 = *(void **)(v441 + 32);
      if (!v214) {
        goto LABEL_424;
      }
      id v432 = v214;
      uint64_t v431 = [v432 muid];
      if (*(unsigned char *)(v441 + 109) == 5)
      {
        __n128 v471 = 0uLL;
        long long v472 = 0uLL;
        long long v473 = 0uLL;
        long long v474 = 0uLL;
        uint64_t v215 = [v432 entranceZoomNames];
        uint64_t v216 = [v215 countByEnumeratingWithState:&v471 objects:&v479 count:16];
        if (!v216)
        {

          goto LABEL_416;
        }
        char v217 = 0;
        uint64_t v465 = *(void *)v472;
        v448 = v215;
        while (1)
        {
          uint64_t v218 = 0;
          id objc = (id)v216;
          do
          {
            if (*(void *)v472 != v465) {
              objc_enumerationMutation(v215);
            }
            id v219 = *(id *)(v471.n128_u64[1] + 8 * v218);
            unsigned __int8 v220 = [v219 labelText];
            if ([v220 length])
            {
              unsigned __int8 v221 = [v219 labelLanguage];
              char v222 = [v219 minZoom];
              unsigned __int8 v223 = (const char *)[v220 UTF8String];
              id v224 = v221;
              uint64_t v225 = (const char *)[v224 UTF8String];
              unint64_t v226 = v470[3].__shared_owners_;
              if (v226 < v470[3].__shared_weak_owners_)
              {
                *(unsigned char *)unint64_t v226 = v222;
                *(unsigned char *)(v226 + 1) = 0;
                if (!v223) {
                  unsigned __int8 v223 = "";
                }
                size_t v227 = strlen(v223);
                id v453 = v219;
                if (v227 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                size_t v228 = v227;
                uint64_t v229 = (unsigned char *)(v226 + 8);
                if (v227 >= 0x17)
                {
                  uint64_t v232 = (v227 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v227 | 7) != 0x17) {
                    uint64_t v232 = v227 | 7;
                  }
                  uint64_t v233 = v232 + 1;
                  uint64_t v229 = operator new(v232 + 1);
                  *(void *)(v226 + 16) = v228;
                  *(void *)(v226 + 24) = v233 | 0x8000000000000000;
                  *(void *)(v226 + 8) = v229;
                  uint64_t v215 = v448;
                }
                else
                {
                  *(unsigned char *)(v226 + 31) = v227;
                  if (!v227)
                  {
LABEL_365:
                    v229[v228] = 0;
                    if (!v225) {
                      uint64_t v225 = "";
                    }
                    size_t v234 = strlen(v225);
                    if (v234 > 0x7FFFFFFFFFFFFFF7) {
                      abort();
                    }
                    size_t v235 = v234;
                    id v219 = v453;
                    if (v234 >= 0x17)
                    {
                      uint64_t v237 = (v234 & 0xFFFFFFFFFFFFFFF8) + 8;
                      if ((v234 | 7) != 0x17) {
                        uint64_t v237 = v234 | 7;
                      }
                      uint64_t v238 = v237 + 1;
                      v236 = operator new(v237 + 1);
                      *(void *)(v226 + 40) = v235;
                      *(void *)(v226 + 48) = v238 | 0x8000000000000000;
                      *(void *)(v226 + 32) = v236;
                      uint64_t v215 = v448;
                    }
                    else
                    {
                      v236 = (unsigned char *)(v226 + 32);
                      *(unsigned char *)(v226 + 55) = v234;
                      if (!v234)
                      {
LABEL_375:
                        v236[v235] = 0;
                        *(_WORD *)(v226 + 79) = 0;
                        *(unsigned char *)(v226 + 56) = 0;
                        *(unsigned char *)(v226 + 103) = 0;
                        uint64_t v230 = v226 + 104;
                        unsigned __int8 v231 = v470;
                        v470[3].__shared_owners_ = v226 + 104;
                        uint64_t v216 = (uint64_t)objc;
                        goto LABEL_376;
                      }
                    }
                    memmove(v236, v225, v235);
                    goto LABEL_375;
                  }
                }
                memmove(v229, v223, v228);
                goto LABEL_365;
              }
              uint64_t v230 = std::vector<md::LabelExternalTextElement>::__emplace_back_slow_path<unsigned char &,char const*&,char const*&,char const*&,char const*&,md::LabelExternalTextType &>((int64x2_t *)&v470[3], v222, v223, v225, 0, 0, 0);
              uint64_t v216 = (uint64_t)objc;
              unsigned __int8 v231 = v470;
LABEL_376:
              v231[3].__shared_owners_ = v230;

              char v217 = 1;
            }

            ++v218;
          }
          while (v216 != v218);
          uint64_t v216 = [v215 countByEnumeratingWithState:&v471 objects:&v479 count:16];
          if (!v216)
          {

            if (v217) {
              goto LABEL_422;
            }
LABEL_416:
            id v263 = *((id *)v440 + 1);
            id v168 = [v263 accessPointEntryName];

            if ([v168 length])
            {
LABEL_420:
              id v168 = v168;
              v265 = (const char *)[v168 UTF8String];
              id v266 = *((id *)v440 + 1);
              id v267 = [v266 locale];
              md::LabelExternalFeature::addTextForZoom(v435, 0, 0, v265, (const char *)[v267 UTF8String]);
            }
LABEL_421:

            goto LABEL_422;
          }
        }
      }
      __n128 v471 = 0uLL;
      long long v472 = 0uLL;
      long long v473 = 0uLL;
      long long v474 = 0uLL;
      unsigned __int8 v239 = [v432 exitZoomNames];
      uint64_t v240 = [v239 countByEnumeratingWithState:&v471 objects:&v479 count:16];
      if (!v240)
      {

        goto LABEL_419;
      }
      char v241 = 0;
      uint64_t v466 = *(void *)v472;
      v449 = v239;
LABEL_383:
      uint64_t v242 = 0;
      id objd = (id)v240;
      while (1)
      {
        if (*(void *)v472 != v466) {
          objc_enumerationMutation(v239);
        }
        id v243 = *(id *)(v471.n128_u64[1] + 8 * v242);
        int64_t v244 = [v243 labelText];
        if (![v244 length]) {
          goto LABEL_411;
        }
        unsigned __int8 v245 = [v243 labelLanguage];
        char v246 = [v243 minZoom];
        unsigned __int8 v247 = (const char *)[v244 UTF8String];
        id v248 = v245;
        v249 = (const char *)[v248 UTF8String];
        unint64_t v250 = v470[3].__shared_owners_;
        if (v250 < v470[3].__shared_weak_owners_) {
          break;
        }
        uint64_t v254 = std::vector<md::LabelExternalTextElement>::__emplace_back_slow_path<unsigned char &,char const*&,char const*&,char const*&,char const*&,md::LabelExternalTextType &>((int64x2_t *)&v470[3], v246, v247, v249, 0, 0, 0);
        uint64_t v240 = (uint64_t)objd;
        v255 = v470;
LABEL_410:
        v255[3].__shared_owners_ = v254;

        char v241 = 1;
LABEL_411:

        if (v240 == ++v242)
        {
          uint64_t v240 = [v239 countByEnumeratingWithState:&v471 objects:&v479 count:16];
          if (!v240)
          {

            if (v241) {
              goto LABEL_422;
            }
LABEL_419:
            id v264 = *((id *)v440 + 1);
            id v168 = [v264 accessPointExitName];

            if ([v168 length]) {
              goto LABEL_420;
            }
            goto LABEL_421;
          }
          goto LABEL_383;
        }
      }
      *(unsigned char *)unint64_t v250 = v246;
      *(unsigned char *)(v250 + 1) = 0;
      if (!v247) {
        unsigned __int8 v247 = "";
      }
      size_t v251 = strlen(v247);
      id v454 = v243;
      if (v251 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      size_t v252 = v251;
      v253 = (unsigned char *)(v250 + 8);
      if (v251 >= 0x17)
      {
        uint64_t v256 = (v251 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v251 | 7) != 0x17) {
          uint64_t v256 = v251 | 7;
        }
        uint64_t v257 = v256 + 1;
        v253 = operator new(v256 + 1);
        *(void *)(v250 + 16) = v252;
        *(void *)(v250 + 24) = v257 | 0x8000000000000000;
        *(void *)(v250 + 8) = v253;
        unsigned __int8 v239 = v449;
      }
      else
      {
        *(unsigned char *)(v250 + 31) = v251;
        if (!v251)
        {
LABEL_399:
          v253[v252] = 0;
          if (!v249) {
            v249 = "";
          }
          size_t v258 = strlen(v249);
          if (v258 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          size_t v259 = v258;
          id v243 = v454;
          if (v258 >= 0x17)
          {
            uint64_t v261 = (v258 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v258 | 7) != 0x17) {
              uint64_t v261 = v258 | 7;
            }
            uint64_t v262 = v261 + 1;
            v260 = operator new(v261 + 1);
            *(void *)(v250 + 40) = v259;
            *(void *)(v250 + 48) = v262 | 0x8000000000000000;
            *(void *)(v250 + 32) = v260;
            unsigned __int8 v239 = v449;
          }
          else
          {
            v260 = (void *)(v250 + 32);
            *(unsigned char *)(v250 + 55) = v258;
            if (!v258) {
              goto LABEL_409;
            }
          }
          memmove(v260, v249, v259);
LABEL_409:
          *((unsigned char *)v260 + v259) = 0;
          *(_WORD *)(v250 + 79) = 0;
          *(unsigned char *)(v250 + 56) = 0;
          *(unsigned char *)(v250 + 103) = 0;
          uint64_t v254 = v250 + 104;
          v255 = v470;
          v470[3].__shared_owners_ = v250 + 104;
          uint64_t v240 = (uint64_t)objd;
          goto LABEL_410;
        }
      }
      memmove(v253, v247, v252);
      goto LABEL_399;
    }
    id v432 = v144;
    uint64_t v431 = [v432 muid];
    __n128 v471 = 0u;
    long long v472 = 0u;
    long long v473 = 0u;
    long long v474 = 0u;
    obunint64_t j = [v432 zoomNames];
    uint64_t v462 = [obj countByEnumeratingWithState:&v471 objects:&v479 count:16];
    if (!v462) {
      goto LABEL_276;
    }
    uint64_t v145 = *(void *)v472;
    uint64_t v447 = *(void *)v472;
    while (2)
    {
      uint64_t v146 = 0;
      while (2)
      {
        if (*(void *)v472 != v145) {
          objc_enumerationMutation(obj);
        }
        id v147 = *(id *)(v471.n128_u64[1] + 8 * v146);
        char v148 = [v147 labelText];
        if (![v148 length]) {
          goto LABEL_274;
        }
        __int16 v149 = [v147 labelLanguage];
        char v150 = [v147 minZoom];
        __int16 v151 = (const char *)[v148 UTF8String];
        id v152 = v149;
        __int16 v153 = (const char *)[v152 UTF8String];
        unint64_t v154 = v470[3].__shared_owners_;
        if (v154 >= v470[3].__shared_weak_owners_)
        {
          uint64_t v158 = std::vector<md::LabelExternalTextElement>::__emplace_back_slow_path<unsigned char &,char const*&,char const*&,char const*&,char const*&,md::LabelExternalTextType &>((int64x2_t *)&v470[3], v150, v151, v153, 0, 0, 0);
          long long v159 = v470;
          goto LABEL_273;
        }
        *(unsigned char *)unint64_t v154 = v150;
        *(unsigned char *)(v154 + 1) = 0;
        if (!v151) {
          __int16 v151 = "";
        }
        size_t v155 = strlen(v151);
        if (v155 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        size_t v156 = v155;
        v157 = (void *)(v154 + 8);
        if (v155 >= 0x17)
        {
          id v442 = v147;
          uint64_t v160 = (v155 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v155 | 7) != 0x17) {
            uint64_t v160 = v155 | 7;
          }
          uint64_t v161 = v160 + 1;
          v157 = operator new(v160 + 1);
          *(void *)(v154 + 16) = v156;
          *(void *)(v154 + 24) = v161 | 0x8000000000000000;
          *(void *)(v154 + 8) = v157;
          id v147 = v442;
          goto LABEL_261;
        }
        *(unsigned char *)(v154 + 31) = v155;
        if (v155) {
LABEL_261:
        }
          memmove(v157, v151, v156);
        *((unsigned char *)v157 + v156) = 0;
        if (!v153) {
          __int16 v153 = "";
        }
        size_t v162 = strlen(v153);
        if (v162 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        size_t v163 = v162;
        if (v162 >= 0x17)
        {
          id v165 = v147;
          uint64_t v166 = (v162 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v162 | 7) != 0x17) {
            uint64_t v166 = v162 | 7;
          }
          uint64_t v167 = v166 + 1;
          unint64_t v164 = operator new(v166 + 1);
          *(void *)(v154 + 40) = v163;
          *(void *)(v154 + 48) = v167 | 0x8000000000000000;
          *(void *)(v154 + 32) = v164;
          id v147 = v165;
          goto LABEL_271;
        }
        unint64_t v164 = (void *)(v154 + 32);
        *(unsigned char *)(v154 + 55) = v162;
        if (v162) {
LABEL_271:
        }
          memmove(v164, v153, v163);
        *((unsigned char *)v164 + v163) = 0;
        *(_WORD *)(v154 + 79) = 0;
        *(unsigned char *)(v154 + 56) = 0;
        *(unsigned char *)(v154 + 103) = 0;
        uint64_t v158 = v154 + 104;
        long long v159 = v470;
        v470[3].__shared_owners_ = v154 + 104;
        uint64_t v145 = v447;
LABEL_273:
        v159[3].__shared_owners_ = v158;

LABEL_274:
        if (v462 != ++v146) {
          continue;
        }
        break;
      }
      uint64_t v462 = [obj countByEnumeratingWithState:&v471 objects:&v479 count:16];
      if (v462) {
        continue;
      }
      break;
    }
LABEL_276:

LABEL_422:
    if (v431)
    {
      v470[1].__shared_weak_owners_ = v431;
      v470[8].__shared_weak_owners_ = v431;
    }
LABEL_424:
    uint64_t v268 = *(void *)(*((void *)v440 + 7) + 8 * *(unsigned int *)(v441 + 56));
    if (v268) {
      uint64_t v269 = v268 + 8;
    }
    else {
      uint64_t v269 = 0;
    }
    if (!*(unsigned char *)(v269 + 28)) {
      goto LABEL_441;
    }
    v271 = v470[18].__vftable;
    unint64_t v270 = v470[18].__shared_owners_;
    if ((unint64_t)v271 < v270)
    {
      LOBYTE(v271->~__shared_weak_count) = 1;
      *(_DWORD *)((char *)&v271->~__shared_weak_count + 1) = *(_DWORD *)(v269 + 29);
      v272 = (std::__shared_weak_count_vtbl *)((char *)&v271->~__shared_weak_count + 5);
      goto LABEL_440;
    }
    shared_weak_owners = (std::__shared_weak_count_vtbl *)v470[17].__shared_weak_owners_;
    unint64_t v274 = 0xCCCCCCCCCCCCCCCDLL * ((char *)v271 - (char *)shared_weak_owners) + 1;
    if (v274 >= 0x3333333333333334) {
      goto LABEL_675;
    }
    unint64_t v275 = 0xCCCCCCCCCCCCCCCDLL * (v270 - (void)shared_weak_owners);
    if (2 * v275 > v274) {
      unint64_t v274 = 2 * v275;
    }
    BOOL v276 = v275 >= 0x1999999999999999;
    unint64_t v277 = 0x3333333333333333;
    if (!v276) {
      unint64_t v277 = v274;
    }
    if (v277 >= 0x3333333333333334) {
      goto LABEL_669;
    }
    uint64_t v278 = 5 * v277;
    v279 = (char *)operator new(5 * v277);
    v280 = &v279[(char *)v271 - (char *)shared_weak_owners];
    char *v280 = 1;
    *(_DWORD *)(v280 + 1) = *(_DWORD *)(v269 + 29);
    for (uint64_t i = (uint64_t)v280;
          v271 != shared_weak_owners;
          *(_DWORD *)(i + 1) = *(_DWORD *)((char *)&v271->~__shared_weak_count + 1))
    {
      char v282 = BYTE3(v271[-1].__on_zero_shared_weak);
      v271 = (std::__shared_weak_count_vtbl *)((char *)v271 - 5);
      *(unsigned char *)(i - 5) = v282;
      i -= 5;
    }
    v283 = &v279[v278];
    v272 = (std::__shared_weak_count_vtbl *)(v280 + 5);
    v470[17].__shared_weak_owners_ = i;
    v470[18].__vftable = (std::__shared_weak_count_vtbl *)(v280 + 5);
    v470[18].__shared_owners_ = (uint64_t)v283;
    if (shared_weak_owners) {
      operator delete(shared_weak_owners);
    }
LABEL_440:
    v470[18].__vftable = v272;
LABEL_441:
    md::LabelTransitRoute::refreshNodePositionState((uint64_t)v440, v441 + 8);
    if (v470[3].__vftable == (std::__shared_weak_count_vtbl *)v470[3].__shared_owners_) {
      goto LABEL_636;
    }
    if (*(unsigned char *)(v441 + 70))
    {
      unint64_t v284 = 0;
      unint64_t v285 = 0;
      v480 = 0;
      __n128 v479 = 0uLL;
      LOBYTE(v481) = 0;
      *(_WORD *)((char *)&v481 + 1) = 1;
      uint64_t v286 = v441;
      do
      {
        int v287 = *(unsigned __int8 *)(v286 + v285 + 71);
        unsigned int v288 = (v287 + 16) >> 5;
        if ((v287 & 0x1F) != 0) {
          LOWORD(v288) = 10;
        }
        __int16 v289 = v288 | ((_WORD)v287 << 8);
        if (v284 < (unint64_t)v480)
        {
          *(_WORD *)unint64_t v284 = 259;
          *(unsigned char *)(v284 + 2) = 0;
          *(_WORD *)(v284 + 3) = v289;
          v284 += 5;
        }
        else
        {
          v290 = (void *)v479.n128_u64[0];
          unint64_t v291 = 0xCCCCCCCCCCCCCCCDLL * (v284 - v479.n128_u64[0]) + 1;
          if (v291 >= 0x3333333333333334) {
            abort();
          }
          if (0x999999999999999ALL * (unint64_t)&v480[-v479.n128_u64[0]] > v291) {
            unint64_t v291 = 0x999999999999999ALL * (void)&v480[-v479.n128_u64[0]];
          }
          unint64_t v292 = 0x3333333333333333;
          if (0xCCCCCCCCCCCCCCCDLL * (unint64_t)&v480[-v479.n128_u64[0]] < 0x1999999999999999) {
            unint64_t v292 = v291;
          }
          if (v292 >= 0x3333333333333334) {
            goto LABEL_669;
          }
          uint64_t v293 = 5 * v292;
          v294 = (char *)operator new(5 * v292);
          v295 = &v294[v284 - (void)v290];
          *(_WORD *)v295 = 259;
          v295[2] = 0;
          *(_WORD *)(v295 + 3) = v289;
          for (unint64_t j = (unint64_t)v295; (void *)v284 != v290; *(_WORD *)(j + 3) = *(_WORD *)(v284 + 3))
          {
            __int16 v297 = *(_WORD *)(v284 - 5);
            v284 -= 5;
            *(_WORD *)(j - 5) = v297;
            j -= 5;
            *(unsigned char *)(j + 2) = 0;
          }
          unint64_t v284 = (unint64_t)(v295 + 5);
          v479.n128_u64[0] = j;
          v480 = &v294[v293];
          if (v290) {
            operator delete(v290);
          }
        }
        v479.n128_u64[1] = v284;
        ++v285;
        uint64_t v286 = v441;
      }
      while (v285 < *(unsigned __int8 *)(v441 + 70));
      if (v284 < (unint64_t)v480)
      {
        *(_WORD *)unint64_t v284 = 257;
        *(unsigned char *)(v284 + 2) = 0;
        *(_WORD *)(v284 + 3) = 0;
        unint64_t v298 = v284 + 5;
        v299 = v480;
        goto LABEL_471;
      }
      v300 = (void *)v479.n128_u64[0];
      unint64_t v301 = 0xCCCCCCCCCCCCCCCDLL * (v284 - v479.n128_u64[0]) + 1;
      if (v301 >= 0x3333333333333334) {
        goto LABEL_676;
      }
      if (0x999999999999999ALL * (unint64_t)&v480[-v479.n128_u64[0]] > v301) {
        unint64_t v301 = 0x999999999999999ALL * (void)&v480[-v479.n128_u64[0]];
      }
      unint64_t v302 = 0x3333333333333333;
      if (0xCCCCCCCCCCCCCCCDLL * (unint64_t)&v480[-v479.n128_u64[0]] < 0x1999999999999999) {
        unint64_t v302 = v301;
      }
      if (v302 >= 0x3333333333333334) {
        goto LABEL_669;
      }
      uint64_t v303 = 5 * v302;
      v304 = (char *)operator new(5 * v302);
      v305 = &v304[v284 - (void)v300];
      *(_WORD *)v305 = 257;
      v305[2] = 0;
      *(_WORD *)(v305 + 3) = 0;
      for (unint64_t k = (unint64_t)v305; (void *)v284 != v300; *(_WORD *)(k + 3) = *(_WORD *)(v284 + 3))
      {
        __int16 v307 = *(_WORD *)(v284 - 5);
        v284 -= 5;
        *(_WORD *)(k - 5) = v307;
        k -= 5;
        *(unsigned char *)(k + 2) = 0;
      }
      v299 = &v304[v303];
      unint64_t v298 = (unint64_t)(v305 + 5);
      v479.n128_u64[0] = k;
      v480 = v299;
      if (v300) {
        operator delete(v300);
      }
LABEL_471:
      v479.n128_u64[1] = v298;
      if (v298 < (unint64_t)v299)
      {
        *(_WORD *)unint64_t v298 = 257;
        *(unsigned char *)(v298 + 2) = 0;
        *(_WORD *)(v298 + 3) = -32764;
        unint64_t v308 = v298 + 5;
        v309 = v480;
        goto LABEL_483;
      }
      v310 = (void *)v479.n128_u64[0];
      unint64_t v311 = 0xCCCCCCCCCCCCCCCDLL * (v298 - v479.n128_u64[0]) + 1;
      if (v311 > 0x3333333333333333) {
        goto LABEL_676;
      }
      if (0x999999999999999ALL * (unint64_t)&v299[-v479.n128_u64[0]] > v311) {
        unint64_t v311 = 0x999999999999999ALL * (void)&v299[-v479.n128_u64[0]];
      }
      if (0xCCCCCCCCCCCCCCCDLL * (unint64_t)&v299[-v479.n128_u64[0]] >= 0x1999999999999999) {
        unint64_t v311 = 0x3333333333333333;
      }
      if (v311 > 0x3333333333333333) {
        goto LABEL_669;
      }
      uint64_t v312 = 5 * v311;
      v313 = (char *)operator new(5 * v311);
      v314 = &v313[v298 - (void)v310];
      *(_WORD *)v314 = 257;
      v314[2] = 0;
      *(_WORD *)(v314 + 3) = -32764;
      for (unint64_t m = (unint64_t)v314; (void *)v298 != v310; *(_WORD *)(m + 3) = *(_WORD *)(v298 + 3))
      {
        __int16 v316 = *(_WORD *)(v298 - 5);
        v298 -= 5;
        *(_WORD *)(m - 5) = v316;
        m -= 5;
        *(unsigned char *)(m + 2) = 0;
      }
      v309 = &v313[v312];
      unint64_t v308 = (unint64_t)(v314 + 5);
      v479.n128_u64[0] = m;
      v480 = v309;
      if (v310) {
        operator delete(v310);
      }
LABEL_483:
      v479.n128_u64[1] = v308;
      if (v308 < (unint64_t)v309)
      {
        *(_WORD *)unint64_t v308 = 257;
        *(unsigned char *)(v308 + 2) = 0;
        *(_WORD *)(v308 + 3) = -16378;
        unint64_t v317 = v308 + 5;
        v318 = v480;
        goto LABEL_495;
      }
      v319 = (void *)v479.n128_u64[0];
      unint64_t v320 = 0xCCCCCCCCCCCCCCCDLL * (v308 - v479.n128_u64[0]) + 1;
      if (v320 > 0x3333333333333333) {
        goto LABEL_676;
      }
      if (0x999999999999999ALL * (unint64_t)&v309[-v479.n128_u64[0]] > v320) {
        unint64_t v320 = 0x999999999999999ALL * (void)&v309[-v479.n128_u64[0]];
      }
      if (0xCCCCCCCCCCCCCCCDLL * (unint64_t)&v309[-v479.n128_u64[0]] >= 0x1999999999999999) {
        unint64_t v320 = 0x3333333333333333;
      }
      if (v320 > 0x3333333333333333) {
        goto LABEL_669;
      }
      uint64_t v321 = 5 * v320;
      v322 = (char *)operator new(5 * v320);
      v323 = &v322[v308 - (void)v319];
      *(_WORD *)v323 = 257;
      v323[2] = 0;
      *(_WORD *)(v323 + 3) = -16378;
      for (unint64_t n = (unint64_t)v323; (void *)v308 != v319; *(_WORD *)(n + 3) = *(_WORD *)(v308 + 3))
      {
        __int16 v325 = *(_WORD *)(v308 - 5);
        v308 -= 5;
        *(_WORD *)(n - 5) = v325;
        n -= 5;
        *(unsigned char *)(n + 2) = 0;
      }
      v318 = &v322[v321];
      unint64_t v317 = (unint64_t)(v323 + 5);
      v479.n128_u64[0] = n;
      v480 = v318;
      if (v319) {
        operator delete(v319);
      }
LABEL_495:
      v479.n128_u64[1] = v317;
      if (v317 < (unint64_t)v318)
      {
        *(_WORD *)unint64_t v317 = 257;
        *(unsigned char *)(v317 + 2) = 0;
        unint64_t v326 = v317 + 5;
        *(_WORD *)(v317 + 3) = 16386;
        goto LABEL_507;
      }
      v327 = (void *)v479.n128_u64[0];
      unint64_t v328 = 0xCCCCCCCCCCCCCCCDLL * (v317 - v479.n128_u64[0]) + 1;
      if (v328 > 0x3333333333333333) {
LABEL_676:
      }
        abort();
      if (0x999999999999999ALL * (unint64_t)&v318[-v479.n128_u64[0]] > v328) {
        unint64_t v328 = 0x999999999999999ALL * (void)&v318[-v479.n128_u64[0]];
      }
      if (0xCCCCCCCCCCCCCCCDLL * (unint64_t)&v318[-v479.n128_u64[0]] >= 0x1999999999999999) {
        unint64_t v328 = 0x3333333333333333;
      }
      if (v328 <= 0x3333333333333333)
      {
        uint64_t v329 = 5 * v328;
        v330 = (char *)operator new(5 * v328);
        v331 = &v330[v317 - (void)v327];
        *(_WORD *)v331 = 257;
        v331[2] = 0;
        *(_WORD *)(v331 + 3) = 16386;
        for (iuint64_t i = (unint64_t)v331; (void *)v317 != v327; *(_WORD *)(ii + 3) = *(_WORD *)(v317 + 3))
        {
          __int16 v333 = *(_WORD *)(v317 - 5);
          v317 -= 5;
          *(_WORD *)(ii - 5) = v333;
          ii -= 5;
          *(unsigned char *)(ii + 2) = 0;
        }
        v334 = &v330[v329];
        unint64_t v326 = (unint64_t)(v331 + 5);
        v479.n128_u64[0] = ii;
        v480 = v334;
        if (v327) {
          operator delete(v327);
        }
LABEL_507:
        v479.n128_u64[1] = v326;
        v335 = v470[17].__vftable;
        if ((unint64_t)v335 >= v470[17].__shared_owners_)
        {
          v341 = std::vector<md::LabelFeaturePlacementInfo>::__emplace_back_slow_path<md::LabelFeaturePlacementInfo const&>(&v470[16].__shared_weak_owners_, (uint64_t)&v479);
          v336 = (_WORD *)v479.n128_u64[0];
          v470[17].__vftable = (std::__shared_weak_count_vtbl *)v341;
          if (!v336) {
            goto LABEL_517;
          }
        }
        else
        {
          v335->~__shared_weak_count = 0;
          v335->~__shared_weak_count_0 = 0;
          v335->__on_zero_shared = 0;
          v336 = (_WORD *)v479.n128_u64[0];
          size_t v337 = v326 - v479.n128_u64[0];
          if (v326 != v479.n128_u64[0])
          {
            unint64_t v338 = 0xCCCCCCCCCCCCCCCDLL * v337;
            if (0xCCCCCCCCCCCCCCCDLL * v337 >= 0x3333333333333334) {
              abort();
            }
            v339 = (char *)operator new(v337);
            v335->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))v339;
            v335->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v339;
            v335->__on_zero_shared = (void (__cdecl *)(std::__shared_count *__hidden))&v339[5 * v338];
            v340 = v336;
            do
            {
              *(_WORD *)v339 = *v340;
              v339[2] = 0;
              *(_WORD *)(v339 + 3) = *(_WORD *)((char *)v340 + 3);
              v339 += 5;
              v340 = (_WORD *)((char *)v340 + 5);
            }
            while (v340 != (_WORD *)v326);
            v335->~__shared_weak_count_0 = (void (__cdecl *)(std::__shared_weak_count *__hidden))v339;
          }
          LOWORD(v335->__get_deleter) = v481;
          BYTE2(v335->__get_deleter) = BYTE2(v481);
          v470[17].__vftable = (std::__shared_weak_count_vtbl *)&v335->__on_zero_shared_weak;
          v470[17].__vftable = (std::__shared_weak_count_vtbl *)&v335->__on_zero_shared_weak;
          if (!v336) {
            goto LABEL_517;
          }
        }
        operator delete(v336);
        goto LABEL_517;
      }
LABEL_669:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_517:
    if (!*(unsigned char *)(v441 + 98) || !*(void *)(v441 + 80)) {
      goto LABEL_636;
    }
    uint64_t v450 = *((void *)v440 + 7);
    uint64_t v455 = *(unsigned int *)(v441 + 100);
    uint64_t v342 = *(void *)(v450 + 8 * v455);
    if (v342) {
      uint64_t v343 = v342 + 8;
    }
    else {
      uint64_t v343 = 0;
    }
    id v344 = *(id *)(v343 + 8);
    uint64_t v345 = *((void *)v440 + 7);
    uint64_t v446 = *(unsigned int *)(v441 + 104);
    uint64_t v346 = *(void *)(v345 + 8 * v446);
    if (v346) {
      uint64_t v347 = v346 + 8;
    }
    else {
      uint64_t v347 = 0;
    }
    id v348 = *(id *)(v347 + 8);
    v433 = v344;
    v349 = v348;
    v350 = [v344 transitSystem];
    v434 = v350;
    v443 = [v348 transitSystem];
    v351 = [v350 artwork];
    if (v351)
    {
      v352 = [v350 artwork];
      v485[0] = v352;
      id v353 = [MEMORY[0x1E4F1C978] arrayWithObjects:v485 count:1];
    }
    else
    {
      id v353 = 0;
    }

    v354 = [v443 artwork];
    if (v354)
    {
      v355 = [v443 artwork];
      v484 = v355;
      id v356 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v484 count:1];
    }
    else
    {
      id v356 = 0;
    }

    id obje = [v433 routeLineArtwork];
    v467 = [v348 routeLineArtwork];
    v357 = (char *)operator new(0x58uLL);
    *((void *)v357 + 1) = 0;
    *((void *)v357 + 2) = 0;
    *(void *)v357 = &unk_1EF581558;
    *(_OWORD *)(v357 + 24) = 0u;
    *(_OWORD *)(v357 + 40) = 0u;
    *(_OWORD *)(v357 + 56) = 0u;
    *(_OWORD *)(v357 + 72) = 0u;
    {
      operator new();
    }
    uint64_t v358 = mdm::Allocator::instance(void)::alloc;
    *((void *)v357 + 8) = 0;
    *((void *)v357 + 9) = 0;
    *((void *)v357 + 7) = v358;
    *((_DWORD *)v357 + 20) = 0;
    v479.n128_u64[0] = (unint64_t)(v357 + 24);
    v479.n128_u64[1] = (unint64_t)v357;
    v359 = operator new(0x30uLL);
    v359[1] = 0;
    v359[2] = 0;
    void *v359 = &unk_1EF5820F0;
    v359[3] = 0;
    v359[4] = 0;
    v359[5] = 0;
    v471.n128_u64[0] = (unint64_t)(v359 + 3);
    v471.n128_u64[1] = (unint64_t)v359;
    v357[24] = 3;
    *((void *)v357 + 9) = 210006;
    v359[4] = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)(v359 + 3), v479);
    if (!v434
      || !v443
      || (uint64_t v360 = [v434 muid], v361 = objc_msgSend(v443, "muid"), v362 = xmmword_1A28FE2D0, v360 == v361))
    {
      long long v362 = xmmword_1A28FCEB0;
    }
    int v483 = DWORD2(v362);
    uint64_t v482 = v362;
    v363 = (char *)operator new(0x48uLL);
    uint64_t v364 = 0;
    *((void *)v363 + 2) = 0;
    *((void *)v363 + 1) = 0;
    *(void *)v363 = &unk_1EF580870;
    *(_OWORD *)(v363 + 40) = 0u;
    *(_OWORD *)(v363 + 24) = 0u;
    *(_OWORD *)(v363 + 56) = 0u;
    v477 = v363 + 24;
    v478 = (std::__shared_weak_count *)v363;
    v476.n128_u64[0] = (unint64_t)(v363 + 24);
    v476.n128_u64[1] = (unint64_t)v363;
    atomic_fetch_add_explicit((atomic_ullong *volatile)v363 + 1, 1uLL, memory_order_relaxed);
    while (2)
    {
      int v365 = *((_DWORD *)&v482 + v364);
      uint64_t v366 = v476.n128_u64[0];
      if (*(void *)v476.n128_u64[0] == *(void *)(v476.n128_u64[0] + 8))
      {
        v367 = (char *)v476.n128_u64[1];
        __n128 v475 = v476;
        if (v476.n128_u64[1])
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v476.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
          uint64_t v368 = v366;
          if (!v365) {
            goto LABEL_551;
          }
        }
        else
        {
          uint64_t v368 = v476.n128_u64[0];
          if (!v365) {
            goto LABEL_551;
          }
        }
LABEL_540:
        if (v365 == 1)
        {
          BOOL v376 = md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_2::operator()((uint64_t *)&v475, v353);
          v381 = *(__n128 **)(v368 + 8);
          unint64_t v382 = *(void *)(v368 + 16);
          *(unsigned char *)(v368 + 24) = (v381 - *(_DWORD *)v368) >> 4;
          if ((unint64_t)v381 >= v382)
          {
            v384 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v368, v471);
          }
          else
          {
            v381->n128_u64[0] = v471.n128_u64[0];
            unint64_t v383 = v471.n128_u64[1];
            v381->n128_u64[1] = v471.n128_u64[1];
            if (v383) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v383 + 8), 1uLL, memory_order_relaxed);
            }
            v384 = v381 + 1;
          }
          *(void *)(v368 + 8) = v384;
          BOOL v385 = md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_2::operator()((uint64_t *)&v475, v356);
          goto LABEL_565;
        }
        if (v365 == 2)
        {
          uint64_t v369 = *(void *)(v450 + 8 * v455);
          uint64_t v370 = v369 ? v369 + 8 : 0;
          BOOL v371 = md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_3::operator()((uint64_t *)&v475, obje, (_DWORD *)(v370 + 29));
          v372 = *(__n128 **)(v368 + 8);
          unint64_t v373 = *(void *)(v368 + 16);
          *(unsigned char *)(v368 + 24) = (v372 - *(_DWORD *)v368) >> 4;
          if ((unint64_t)v372 >= v373)
          {
            v375 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v368, v471);
          }
          else
          {
            v372->n128_u64[0] = v471.n128_u64[0];
            unint64_t v374 = v471.n128_u64[1];
            v372->n128_u64[1] = v471.n128_u64[1];
            if (v374) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v374 + 8), 1uLL, memory_order_relaxed);
            }
            v375 = v372 + 1;
          }
          *(void *)(v368 + 8) = v375;
          uint64_t v386 = *(void *)(v345 + 8 * v446);
          uint64_t v387 = v386 ? v386 + 8 : 0;
          if ((v371 & md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_3::operator()((uint64_t *)&v475, v467, (_DWORD *)(v387 + 29)) & 1) == 0)goto LABEL_575; {
        }
          }
LABEL_566:
        if (v368 == v366)
        {
          uint64_t v368 = 0;
          v367 = 0;
        }
        else if (v367)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v367 + 1, 1uLL, memory_order_relaxed);
        }
      }
      else
      {
        v367 = (char *)operator new(0x48uLL);
        *((void *)v367 + 1) = 0;
        *((void *)v367 + 2) = 0;
        *(void *)v367 = &unk_1EF580870;
        *(_OWORD *)(v367 + 24) = 0u;
        uint64_t v368 = (uint64_t)(v367 + 24);
        *(_OWORD *)(v367 + 40) = 0u;
        *(_OWORD *)(v367 + 56) = 0u;
        v475.n128_u64[0] = (unint64_t)(v367 + 24);
        v475.n128_u64[1] = (unint64_t)v367;
        if (v365) {
          goto LABEL_540;
        }
LABEL_551:
        BOOL v376 = md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_1::operator()((uint64_t *)&v475, v353);
        v377 = *(__n128 **)(v368 + 8);
        unint64_t v378 = *(void *)(v368 + 16);
        *(unsigned char *)(v368 + 24) = (v377 - *(_DWORD *)v368) >> 4;
        if ((unint64_t)v377 >= v378)
        {
          v380 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v368, v471);
        }
        else
        {
          v377->n128_u64[0] = v471.n128_u64[0];
          unint64_t v379 = v471.n128_u64[1];
          v377->n128_u64[1] = v471.n128_u64[1];
          if (v379) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v379 + 8), 1uLL, memory_order_relaxed);
          }
          v380 = v377 + 1;
        }
        *(void *)(v368 + 8) = v380;
        BOOL v385 = md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_1::operator()((uint64_t *)&v475, v356);
LABEL_565:
        if (v376 && v385) {
          goto LABEL_566;
        }
LABEL_575:
        uint64_t v388 = *(void *)v368;
        uint64_t v389 = *(void *)(v368 + 8);
        if (v389 != *(void *)v368)
        {
          do
          {
            v390 = *(std::__shared_weak_count **)(v389 - 8);
            if (v390 && !atomic_fetch_add(&v390->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v390->__on_zero_shared)(v390);
              std::__shared_weak_count::__release_weak(v390);
            }
            v389 -= 16;
          }
          while (v389 != v388);
          uint64_t v366 = v476.n128_u64[0];
        }
        v367 = 0;
        *(void *)(v368 + 8) = v388;
        uint64_t v368 = 0;
      }
      v391 = *(std::__shared_weak_count **)(v366 + 40);
      *(void *)(v366 + 32) = v368;
      *(void *)(v366 + 40) = v367;
      if (v391 && !atomic_fetch_add(&v391->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v391->__on_zero_shared)(v391);
        std::__shared_weak_count::__release_weak(v391);
      }
      __n128 v392 = v475;
      if (v475.n128_u64[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v475.n128_u64[1] + 8), 1uLL, memory_order_relaxed);
      }
      v393 = (std::__shared_weak_count *)v476.n128_u64[1];
      __n128 v476 = v392;
      if (v393 && !atomic_fetch_add(&v393->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v393->__on_zero_shared)(v393);
        std::__shared_weak_count::__release_weak(v393);
        v394 = (std::__shared_weak_count *)v475.n128_u64[1];
        if (v475.n128_u64[1]) {
          goto LABEL_591;
        }
      }
      else
      {
        v394 = (std::__shared_weak_count *)v475.n128_u64[1];
        if (v475.n128_u64[1])
        {
LABEL_591:
          if (!atomic_fetch_add(&v394->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v394->__on_zero_shared)(v394);
            std::__shared_weak_count::__release_weak(v394);
          }
        }
      }
      if (++v364 != 3) {
        continue;
      }
      break;
    }
    uint64_t v395 = *(void *)(v441 + 80);
    v397 = v477;
    v396 = v478;
    if (v478) {
      atomic_fetch_add_explicit(&v478->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v398 = *(std::__shared_weak_count **)(v395 + 320);
    *(void *)(v395 + 312) = v397;
    *(void *)(v395 + 320) = v396;
    if (!v398 || atomic_fetch_add(&v398->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      if (obje) {
        goto LABEL_600;
      }
      goto LABEL_611;
    }
    ((void (*)(std::__shared_weak_count *))v398->__on_zero_shared)(v398);
    std::__shared_weak_count::__release_weak(v398);
    if (!obje) {
      goto LABEL_611;
    }
LABEL_600:
    CreateTransitLineDataElementGroup(&v475, 1, obje, v434);
    if (v475.n128_u64[0])
    {
      uint64_t v399 = *(void *)(v441 + 80);
      v400 = *(__n128 **)(v399 + 432);
      if ((unint64_t)v400 >= *(void *)(v399 + 440))
      {
        v402 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v399 + 424, v475);
      }
      else
      {
        v400->n128_u64[0] = v475.n128_u64[0];
        unint64_t v401 = v475.n128_u64[1];
        v400->n128_u64[1] = v475.n128_u64[1];
        if (v401) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v401 + 8), 1uLL, memory_order_relaxed);
        }
        v402 = v400 + 1;
      }
      *(void *)(v399 + 432) = v402;
    }
    v403 = (std::__shared_weak_count *)v475.n128_u64[1];
    if (v475.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v475.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v403->__on_zero_shared)(v403);
      std::__shared_weak_count::__release_weak(v403);
      if (v467)
      {
LABEL_612:
        CreateTransitLineDataElementGroup(&v475, 0, v467, v443);
        if (v475.n128_u64[0])
        {
          uint64_t v404 = *(void *)(v441 + 80);
          v405 = *(__n128 **)(v404 + 432);
          if ((unint64_t)v405 >= *(void *)(v404 + 440))
          {
            v407 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v404 + 424, v475);
          }
          else
          {
            v405->n128_u64[0] = v475.n128_u64[0];
            unint64_t v406 = v475.n128_u64[1];
            v405->n128_u64[1] = v475.n128_u64[1];
            if (v406) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v406 + 8), 1uLL, memory_order_relaxed);
            }
            v407 = v405 + 1;
          }
          *(void *)(v404 + 432) = v407;
        }
        v408 = (std::__shared_weak_count *)v475.n128_u64[1];
        if (v475.n128_u64[1]
          && !atomic_fetch_add((atomic_ullong *volatile)(v475.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v408->__on_zero_shared)(v408);
          std::__shared_weak_count::__release_weak(v408);
        }
      }
    }
    else
    {
LABEL_611:
      if (v467) {
        goto LABEL_612;
      }
    }
    v409 = (std::__shared_weak_count *)v476.n128_u64[1];
    if (v476.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v476.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v409->__on_zero_shared)(v409);
      std::__shared_weak_count::__release_weak(v409);
    }
    v410 = v478;
    if (v478 && !atomic_fetch_add(&v478->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v410->__on_zero_shared)(v410);
      std::__shared_weak_count::__release_weak(v410);
    }
    v411 = (std::__shared_weak_count *)v471.n128_u64[1];
    if (v471.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v471.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v411->__on_zero_shared)(v411);
      std::__shared_weak_count::__release_weak(v411);
    }
    v412 = (std::__shared_weak_count *)v479.n128_u64[1];
    if (v479.n128_u64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v479.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v412->__on_zero_shared)(v412);
      std::__shared_weak_count::__release_weak(v412);
    }

LABEL_636:
    v414 = a2[1];
    unint64_t v413 = (unint64_t)a2[2];
    if ((unint64_t)v414 < v413)
    {
      *v414 = v435;
      v414[1] = (int64x2_t *)v470;
      atomic_fetch_add_explicit(&v470->__shared_owners_, 1uLL, memory_order_relaxed);
      v415 = v414 + 2;
      v416 = a2;
      goto LABEL_656;
    }
    v417 = *a2;
    uint64_t v418 = ((char *)v414 - (char *)*a2) >> 4;
    unint64_t v419 = v418 + 1;
    if ((unint64_t)(v418 + 1) >> 60) {
LABEL_675:
    }
      abort();
    uint64_t v420 = v413 - (void)v417;
    if (v420 >> 3 > v419) {
      unint64_t v419 = v420 >> 3;
    }
    if ((unint64_t)v420 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v421 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v421 = v419;
    }
    if (v421 >> 60) {
      goto LABEL_669;
    }
    v422 = (char *)operator new(16 * v421);
    *(void *)&long long v423 = v435;
    *((void *)&v423 + 1) = v470;
    v424 = &v422[16 * v418];
    v425 = (int64x2_t **)&v422[16 * v421];
    *(_OWORD *)v424 = v423;
    v415 = (int64x2_t **)(v424 + 16);
    atomic_fetch_add_explicit(p_shared_owners, 1uLL, memory_order_relaxed);
    if (v414 == v417)
    {
      *a2 = (int64x2_t **)v424;
      a2[1] = v415;
      a2[2] = v425;
      v416 = a2;
      if (!v414) {
        goto LABEL_656;
      }
      goto LABEL_655;
    }
    do
    {
      long long v426 = *((_OWORD *)v414 - 1);
      v414 -= 2;
      *((_OWORD *)v424 - 1) = v426;
      v424 -= 16;
      *v414 = 0;
      v414[1] = 0;
    }
    while (v414 != v417);
    v414 = *a2;
    v427 = a2[1];
    *a2 = (int64x2_t **)v424;
    a2[1] = v415;
    a2[2] = v425;
    if (v427 == v414)
    {
      v416 = a2;
      if (!v414) {
        goto LABEL_656;
      }
      goto LABEL_655;
    }
    do
    {
      v428 = (std::__shared_weak_count *)*(v427 - 1);
      if (v428 && !atomic_fetch_add(&v428->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v428->__on_zero_shared)(v428);
        std::__shared_weak_count::__release_weak(v428);
      }
      v427 -= 2;
    }
    while (v427 != v414);
    v416 = a2;
    if (v414)
    {
LABEL_655:
      operator delete(v414);
      v416 = a2;
    }
LABEL_656:
    v416[1] = v415;
    if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v470->__on_zero_shared)(v470);
      std::__shared_weak_count::__release_weak(v470);
    }
LABEL_236:
    long long v139 = v438 + 1;
    if (v438 + 1 != v430) {
      continue;
    }
    return md::LabelTransitRoute::updateTransitNodesRouteState(v440);
  }
}

void sub_1A20D6DC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,atomic_ullong *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,std::__shared_weak_count *a32)
{
  if (!atomic_fetch_add(a21, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a32->__on_zero_shared)(a32);
    std::__shared_weak_count::__release_weak(a32);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void *md::LabelTransitRoute::updateTransitNodesRouteState(void *this)
{
  if (this[1])
  {
    uint64_t v1 = (uint64_t)this;
    if (this[11] != this[12])
    {
      uint64_t v50 = 0;
      {
        operator new();
      }
      uint64_t v51 = mdm::Allocator::instance(void)::alloc;
      uint64_t v52 = 0;
      int v2 = objc_msgSend(*(id *)(v1 + 8), "inspectedSegmentIndex", &v50);
      int v3 = v2;
      if (*(_DWORD *)(v1 + 120) != v2)
      {
        *(_DWORD *)(v1 + 120) = v2;
        uint64_t v20 = *(uint64_t **)(v1 + 56);
        long long v21 = *(uint64_t **)(v1 + 64);
        while (v20 != v21)
        {
          uint64_t v22 = *v20;
          int v23 = *(_DWORD *)(*v20 + 32);
          BOOL v24 = v23 < v3;
          int v25 = v23 == v3;
          if (v24) {
            int v25 = 2;
          }
          if (*(unsigned __int8 *)(v22 + 76) != v25)
          {
            *(unsigned char *)(v22 + 76) = v25;
            int v26 = *(_DWORD *)(v22 + 48);
            if (v26 >= 1)
            {
              for (int i = 0; i < v26; ++i)
              {
                unsigned int v28 = *(_DWORD *)(v22 + 44) + i;
                unint64_t v29 = v50;
                char v30 = &v50;
                long long v31 = &v50;
                if (v50)
                {
                  while (1)
                  {
                    while (1)
                    {
                      long long v31 = (uint64_t **)v29;
                      unsigned int v32 = *((_DWORD *)v29 + 7);
                      if (v28 >= v32) {
                        break;
                      }
                      unint64_t v29 = *v31;
                      char v30 = v31;
                      if (!*v31) {
                        goto LABEL_48;
                      }
                    }
                    if (v32 >= v28) {
                      break;
                    }
                    unint64_t v29 = v31[1];
                    if (!v29)
                    {
                      char v30 = v31 + 1;
                      goto LABEL_48;
                    }
                  }
                }
                else
                {
LABEL_48:
                  uint64_t v33 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v51 + 16))(v51, 32, 8);
                  *(_DWORD *)(v33 + 28) = v28;
                  *(void *)uint64_t v33 = 0;
                  *(void *)(v33 + 8) = 0;
                  *(void *)(v33 + 16) = v31;
                  *char v30 = (uint64_t *)v33;
                  if (*v49)
                  {
                    uint64_t v49 = (uint64_t *)*v49;
                    uint64_t v33 = (uint64_t)*v30;
                  }
                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v50, (uint64_t *)v33);
                  ++v52;
                  int v26 = *(_DWORD *)(v22 + 48);
                }
              }
            }
          }
          ++v20;
        }
      }
      int v4 = objc_msgSend(*(id *)(v1 + 8), "inspectedStepIndex", v49);
      unsigned int v5 = v4;
      int v6 = *(_DWORD *)(v1 + 124);
      if (v6 != v4)
      {
        int v7 = 0;
        if (*(_DWORD *)(v1 + 128) == -1) {
          int v8 = 0;
        }
        else {
          int v8 = *(_DWORD *)(v1 + 128);
        }
        if (v6 <= v4) {
          int v7 = ((*(void *)(v1 + 96) - *(void *)(v1 + 88)) >> 3) - 1;
        }
        *(_DWORD *)(v1 + 124) = v4;
        if (v8 != v7)
        {
          int v34 = 2 * (v7 >= v8);
          if (v7 < v8) {
            uint64_t v35 = -1;
          }
          else {
            uint64_t v35 = 1;
          }
          uint64_t v36 = v8;
          do
          {
            if (*(_DWORD *)(v1 + 144) != v36)
            {
              uint64_t v37 = *(void *)(*(void *)(v1 + 88) + 8 * v36);
              unsigned int v38 = *(_DWORD *)(v37 + 60);
              if (v7 >= v8)
              {
                if (v38 >= v5) {
                  break;
                }
              }
              else if (v38 < v5)
              {
                break;
              }
              *(_DWORD *)(v1 + 128) = v36;
              if (*(unsigned __int8 *)(v37 + 108) != v34)
              {
                *(unsigned char *)(v37 + 108) = v34;
                uint64_t v39 = v50;
                uint64_t v40 = &v50;
                uint64_t v41 = &v50;
                if (v50)
                {
                  while (1)
                  {
                    while (1)
                    {
                      uint64_t v41 = (uint64_t **)v39;
                      unsigned int v42 = *((_DWORD *)v39 + 7);
                      if (v42 <= v36) {
                        break;
                      }
                      uint64_t v39 = *v41;
                      uint64_t v40 = v41;
                      if (!*v41) {
                        goto LABEL_69;
                      }
                    }
                    if (v42 >= v36) {
                      break;
                    }
                    uint64_t v39 = v41[1];
                    if (!v39)
                    {
                      uint64_t v40 = v41 + 1;
                      goto LABEL_69;
                    }
                  }
                }
                else
                {
LABEL_69:
                  uint64_t v43 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v51 + 16))(v51, 32, 8);
                  *(_DWORD *)(v43 + 28) = v36;
                  *(void *)uint64_t v43 = 0;
                  *(void *)(v43 + 8) = 0;
                  *(void *)(v43 + 16) = v41;
                  *uint64_t v40 = (uint64_t *)v43;
                  if (*v49)
                  {
                    uint64_t v49 = (uint64_t *)*v49;
                    uint64_t v43 = (uint64_t)*v40;
                  }
                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v50, (uint64_t *)v43);
                  ++v52;
                }
              }
            }
            v36 += v35;
          }
          while (v7 != v36);
        }
      }
      uint64_t v9 = objc_msgSend(*(id *)(v1 + 8), "puckSnappedStopID", v49);
      if (v9 != *(void *)(v1 + 136))
      {
        unsigned int v10 = *(_DWORD *)(v1 + 144);
        if (v10 != -1)
        {
          uint64_t v11 = *(void *)(*(void *)(v1 + 88) + 8 * (int)v10);
          *(unsigned char *)(v11 + 108) = 2 * (*(_DWORD *)(v11 + 60) < v5);
          *(void *)(*(void *)(v11 + 80) + 360) = *(void *)(*(void *)(v11 + 80) + 352);
          uint64_t v12 = v50;
          uint64_t v13 = &v50;
          unint64_t v14 = &v50;
          if (v50)
          {
            while (1)
            {
              while (1)
              {
                unint64_t v14 = (uint64_t **)v12;
                unsigned int v15 = *((_DWORD *)v12 + 7);
                if (v10 >= v15) {
                  break;
                }
                uint64_t v12 = *v14;
                uint64_t v13 = v14;
                if (!*v14) {
                  goto LABEL_21;
                }
              }
              if (v15 >= v10) {
                break;
              }
              uint64_t v12 = v14[1];
              if (!v12)
              {
                uint64_t v13 = v14 + 1;
                goto LABEL_21;
              }
            }
          }
          else
          {
LABEL_21:
            uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v51 + 16))(v51, 32, 8);
            *(_DWORD *)(v16 + 28) = v10;
            *(void *)uint64_t v16 = 0;
            *(void *)(v16 + 8) = 0;
            *(void *)(v16 + 16) = v14;
            *uint64_t v13 = (uint64_t *)v16;
            if (*v49)
            {
              uint64_t v49 = (uint64_t *)*v49;
              uint64_t v16 = (uint64_t)*v13;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v50, (uint64_t *)v16);
            ++v52;
          }
          *(_DWORD *)(v1 + 144) = -1;
        }
        *(void *)(v1 + 136) = v9;
        if (v9)
        {
          uint64_t v17 = *(void *)(v1 + 88);
          uint64_t v18 = *(void *)(v1 + 96);
          if (v17 != v18)
          {
            int v19 = 0;
            while (objc_msgSend(*(id *)(*(void *)v17 + 8), "muid", v49) != v9)
            {
              ++v19;
              v17 += 8;
              if (v17 == v18) {
                goto LABEL_75;
              }
            }
            *(_DWORD *)(v1 + 144) = v19;
            if (*(void *)v17) {
              uint64_t v44 = *(void *)v17 + 8;
            }
            else {
              uint64_t v44 = 0;
            }
            *(unsigned char *)(v44 + 100) = 1;
          }
        }
LABEL_75:
        *(void *)(v1 + 136) = v9;
      }
      uint64_t v45 = v49;
      if (v49 != (uint64_t *)&v50)
      {
        do
        {
          md::LabelTransitRoute::refreshNodePositionState(v1, *(void *)(*(void *)(v1 + 88) + 8 * *((unsigned int *)v45 + 7)) + 8);
          uint64_t v46 = (uint64_t *)v45[1];
          if (v46)
          {
            do
            {
              uint64_t v47 = (uint64_t **)v46;
              uint64_t v46 = (uint64_t *)*v46;
            }
            while (v46);
          }
          else
          {
            do
            {
              uint64_t v47 = (uint64_t **)v45[2];
              BOOL v48 = *v47 == v45;
              uint64_t v45 = (uint64_t *)v47;
            }
            while (!v48);
          }
          uint64_t v45 = (uint64_t *)v47;
        }
        while (v47 != &v50);
      }
      return (void *)std::__tree<unsigned int,std::less<unsigned int>,geo::StdAllocator<unsigned int,mdm::Allocator>>::destroy((uint64_t)&v49, v50);
    }
  }
  return this;
}

void sub_1A20D7910(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
}

void md::LabelTransitRoute::refreshNodePositionState(uint64_t a1, uint64_t a2)
{
  v157 = 0;
  uint64_t v158 = 0;
  {
    operator new();
  }
  uint64_t v4 = mdm::Allocator::instance(void)::alloc;
  int v5 = *(unsigned __int8 *)(a2 + 101);
  switch(v5)
  {
    case 1:
      if ([*(id *)a2 hasStyleAttributes])
      {
        id v11 = objc_alloc(MEMORY[0x1E4F645A0]);
        uint64_t v12 = [*(id *)a2 styleAttributes];
        int v8 = (void *)[v11 initWithGEOStyleAttributes:v12];

        if (v8)
        {
LABEL_13:
          [v8 featureStyleAttributesPtr];
          unint64_t v14 = v153;
          uint64_t v13 = (std::__shared_weak_count *)v154;
          goto LABEL_54;
        }
LABEL_53:
        uint64_t v13 = 0;
        unint64_t v14 = 0;
LABEL_54:
        v157 = v14;
        uint64_t v158 = v13;

        uint64_t v16 = 0;
        unint64_t v17 = 0;
        if (v14) {
          goto LABEL_55;
        }
        goto LABEL_24;
      }
      uint64_t v18 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8, 4);
      unsigned int v10 = v18;
      if (v18) {
        void *v18 = 42;
      }
      goto LABEL_21;
    case 3:
      uint64_t v9 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                          + 16))(mdm::Allocator::instance(void)::alloc, 8, 4);
      unsigned int v10 = v9;
      if (v9) {
        void *v9 = 0x10000002ALL;
      }
LABEL_21:
      uint64_t v20 = (geo::codec::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 16, 4);
      uint64_t v16 = v20;
      unint64_t v17 = (unint64_t)v20 + 16;
      if (v20) {
        *((void *)v20 + 1) = 0x2BC00000025;
      }
      *(void *)uint64_t v20 = *v10;
      unsigned int v15 = (geo::codec::Allocator *)(*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v4 + 40))(v4, v10, 8);
      uint64_t v13 = 0;
      goto LABEL_24;
    case 2:
      if ([*(id *)(a2 + 8) hasStyleAttributes])
      {
        id v6 = objc_alloc(MEMORY[0x1E4F645A0]);
        int v7 = [*(id *)(a2 + 8) styleAttributes];
        int v8 = (void *)[v6 initWithGEOStyleAttributes:v7];

        if (v8) {
          goto LABEL_13;
        }
        goto LABEL_53;
      }
      int v19 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8, 4);
      unsigned int v10 = v19;
      if (v19) {
        void *v19 = 0x30000002ALL;
      }
      goto LABEL_21;
  }
  unsigned int v15 = (geo::codec::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 8, 4);
  uint64_t v16 = v15;
  unint64_t v17 = (unint64_t)v15 + 8;
  uint64_t v13 = 0;
  if (v15) {
    *(void *)unsigned int v15 = 0x200010010;
  }
LABEL_24:
  uint64_t v156 = geo::codec::Allocator::instance(v15);
  long long v21 = (std::__shared_weak_count *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v156 + 16))(v156, 8, 4);
  __int16 v153 = v21;
  p_unint64_t shared_owners = &v21->__shared_owners_;
  if (v21) {
    v21->__vftable = (std::__shared_weak_count_vtbl *)0xE100000006;
  }
  uint64_t v154 = (uint64_t)&v21->__shared_owners_;
  uint64_t v22 = (std::__shared_weak_count *)operator new(0x40uLL);
  v22->__shared_owners_ = 0;
  v22->__shared_weak_owners_ = 0;
  v22->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F680;
  v157 = (std::__shared_weak_count *)FeatureStyleAttributes::FeatureStyleAttributes((uint64_t)&v22[1], (uint64_t *)&v153);
  uint64_t v158 = v22;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  if (v153)
  {
    uint64_t v154 = (uint64_t)v153;
    (*(void (**)(uint64_t, std::__shared_weak_count *, int64_t))(*(void *)v156 + 40))(v156, v153, (char *)p_shared_owners - (char *)v153);
  }
  if (v16 == (geo::codec::Allocator *)v17)
  {
    unint64_t v17 = (unint64_t)v16;
  }
  else if (((v17 - (void)v16) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v23 = 0;
    char v24 = 0;
    int v25 = v157;
    uint64_t v26 = ((v17 - (unint64_t)v16) >> 3);
    unsigned __int8 v27 = BYTE1(v157[1].__shared_owners_);
    while (1)
    {
      size_t v28 = v27;
      unint64_t v29 = v25->__vftable;
      if (v27) {
        break;
      }
LABEL_34:
      *((void *)&v29->~__shared_weak_count + v28) = *((void *)v16 + v23);
      unsigned __int8 v27 = BYTE1(v25[1].__shared_owners_) + 1;
      BYTE1(v25[1].__shared_owners_) = v27;
      ++v23;
      char v24 = 1;
      if (v23 == v26)
      {
        unint64_t v29 = v25->__vftable;
        size_t v28 = v27;
LABEL_52:
        qsort(v29, v28, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
        goto LABEL_55;
      }
    }
    if (v27 > 0x1Fu)
    {
      do
      {
        uint64_t v33 = 0;
        int v34 = v29;
        while (1)
        {
          int v35 = (int)v34->~__shared_weak_count;
          int v34 = (std::__shared_weak_count_vtbl *)((char *)v34 + 8);
          if (v35 == *((_DWORD *)v16 + 2 * v23)) {
            break;
          }
          if (v27 == ++v33) {
            goto LABEL_45;
          }
        }
        *((_DWORD *)&v29->~__shared_weak_count + 2 * v33 + 1) = *((_DWORD *)v16 + 2 * v23 + 1);
LABEL_45:
        ++v23;
      }
      while (v23 != v26);
    }
    else
    {
      do
      {
        uint64_t v30 = 0;
        long long v31 = v29;
        while (1)
        {
          int v32 = (int)v31->~__shared_weak_count;
          long long v31 = (std::__shared_weak_count_vtbl *)((char *)v31 + 8);
          if (v32 == *((_DWORD *)v16 + 2 * v23)) {
            break;
          }
          if (v28 == ++v30) {
            goto LABEL_34;
          }
        }
        *((_DWORD *)&v29->~__shared_weak_count + 2 * v30 + 1) = *((_DWORD *)v16 + 2 * v23++ + 1);
      }
      while (v23 != v26);
    }
    if (v24) {
      goto LABEL_52;
    }
  }
LABEL_55:
  uint64_t v36 = *(unsigned int *)(a2 + 48);
  uint64_t v37 = *(void *)(a1 + 56);
  uint64_t v38 = *(void *)(v37 + 8 * v36);
  if (v38) {
    uint64_t v39 = v38 + 8;
  }
  else {
    uint64_t v39 = 0;
  }
  id v40 = *(id *)(v39 + 8);
  uint64_t v41 = [v40 type];

  if (v41 == 6)
  {
    uint64_t v42 = *(void *)(v37 + 8 * v36);
    if (v42) {
      uint64_t v43 = v42 + 8;
    }
    else {
      uint64_t v43 = 0;
    }
    id v44 = *(id *)(v43 + 8);
    uint64_t v45 = [v44 transitSystem];
    MergeTransitSystemStylesWithStyle(v45, &v157);
  }
  if ((unint64_t)v16 >= v17)
  {
    unint64_t v47 = v17 - (void)v16;
    unint64_t v48 = (uint64_t)(v17 - (void)v16) >> 2;
    if (v48 <= 1) {
      unint64_t v48 = 1;
    }
    if (v47 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v49 = v48;
    }
    uint64_t v50 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8 * v49, 4);
    uint64_t v51 = (geo::codec::Allocator *)v50;
    unint64_t v17 = (unint64_t)&v50[v49];
    if (v50) {
      void *v50 = 0x300000005;
    }
    uint64_t v46 = (geo::codec::Allocator *)(v50 + 1);
    if (v16) {
      (*(void (**)(uint64_t, geo::codec::Allocator *, unint64_t))(*(void *)v4 + 40))(v4, v16, v47);
    }
    uint64_t v16 = v51;
  }
  else
  {
    if (v16) {
      *(void *)uint64_t v16 = 0x300000005;
    }
    uint64_t v46 = (geo::codec::Allocator *)((char *)v16 + 8);
  }
  if ((unint64_t)v46 >= v17)
  {
    uint64_t v54 = (v46 - v16) >> 3;
    unint64_t v55 = v54 + 1;
    if ((unint64_t)(v54 + 1) >> 61) {
      abort();
    }
    uint64_t v56 = a2;
    unint64_t v57 = v17 - (void)v16;
    if ((uint64_t)(v17 - (void)v16) >> 2 > v55) {
      unint64_t v55 = (uint64_t)(v17 - (void)v16) >> 2;
    }
    uint64_t v58 = a1;
    if (v57 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v59 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v59 = v55;
    }
    if (v59)
    {
      uint64_t v60 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8 * v59, 4);
      uint64_t v61 = (void *)(v60 + 8 * v54);
      unint64_t v17 = v60 + 8 * v59;
      if (v60) {
        *uint64_t v61 = 0x100010007;
      }
    }
    else
    {
      unint64_t v17 = 0;
      uint64_t v61 = (void *)(8 * v54);
    }
    uint64_t v52 = (geo::codec::Allocator *)(v61 + 1);
    if (v46 == v16)
    {
LABEL_101:
      (*(void (**)(uint64_t, geo::codec::Allocator *, unint64_t))(*(void *)v4 + 40))(v4, v16, v57);
LABEL_102:
      uint64_t v16 = (geo::codec::Allocator *)v61;
      a1 = v58;
      a2 = v56;
      if ((unint64_t)v52 < v17) {
        goto LABEL_79;
      }
      goto LABEL_103;
    }
    unint64_t v62 = v46 - v16 - 8;
    if (v62 < 0x38)
    {
      uint64_t v64 = v46;
    }
    else if ((unint64_t)(v46 - (geo::codec::Allocator *)v61) < 0x20)
    {
      uint64_t v64 = v46;
    }
    else
    {
      uint64_t v63 = (v62 >> 3) + 1;
      uint64_t v64 = (geo::codec::Allocator *)((char *)v46 - 8 * (v63 & 0x3FFFFFFFFFFFFFFCLL));
      uint64_t v65 = v61 - 2;
      unint64_t v66 = (long long *)((char *)v46 - 16);
      uint64_t v67 = v63 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v68 = *v66;
        *(v65 - 1) = *(v66 - 1);
        *uint64_t v65 = v68;
        v65 -= 2;
        v66 -= 2;
        v67 -= 4;
      }
      while (v67);
      v61 -= v63 & 0x3FFFFFFFFFFFFFFCLL;
      if (v63 == (v63 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_100:
        if (!v16) {
          goto LABEL_102;
        }
        goto LABEL_101;
      }
    }
    do
    {
      uint64_t v69 = *((void *)v64 - 1);
      uint64_t v64 = (geo::codec::Allocator *)((char *)v64 - 8);
      *--uint64_t v61 = v69;
    }
    while (v64 != v16);
    goto LABEL_100;
  }
  *(void *)uint64_t v46 = 0x100010007;
  uint64_t v52 = (geo::codec::Allocator *)((char *)v46 + 8);
  if ((unint64_t)v46 + 8 < v17)
  {
LABEL_79:
    *(void *)uint64_t v52 = 0x100010002;
    unsigned int v53 = (uint64_t *)((char *)v52 + 8);
    goto LABEL_126;
  }
LABEL_103:
  uint64_t v70 = (v52 - v16) >> 3;
  unint64_t v71 = v70 + 1;
  if ((unint64_t)(v70 + 1) >> 61) {
    abort();
  }
  unint64_t v72 = v17 - (void)v16;
  if ((uint64_t)(v17 - (void)v16) >> 2 > v71) {
    unint64_t v71 = (uint64_t)(v17 - (void)v16) >> 2;
  }
  if (v72 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v73 = v71;
  }
  if (v73)
  {
    uint64_t v74 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8 * v73, 4);
    unsigned int v75 = (uint64_t *)(v74 + 8 * v70);
    unint64_t v17 = v74 + 8 * v73;
    if (v74) {
      *unsigned int v75 = 0x100010002;
    }
  }
  else
  {
    unint64_t v17 = 0;
    unsigned int v75 = (uint64_t *)(8 * v70);
  }
  unsigned int v53 = v75 + 1;
  if (v52 == v16) {
    goto LABEL_124;
  }
  unint64_t v76 = v52 - v16 - 8;
  if (v76 < 0x38)
  {
    int64_t v78 = v52;
    do
    {
LABEL_122:
      uint64_t v83 = *((void *)v78 - 1);
      int64_t v78 = (geo::codec::Allocator *)((char *)v78 - 8);
      *--unsigned int v75 = v83;
    }
    while (v78 != v16);
    goto LABEL_123;
  }
  if ((unint64_t)(v52 - (geo::codec::Allocator *)v75) < 0x20)
  {
    int64_t v78 = v52;
    goto LABEL_122;
  }
  uint64_t v77 = (v76 >> 3) + 1;
  int64_t v78 = (geo::codec::Allocator *)((char *)v52 - 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL));
  uint64_t v79 = v75 - 2;
  uint64_t v80 = (long long *)((char *)v52 - 16);
  uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v82 = *v80;
    *((_OWORD *)v79 - 1) = *(v80 - 1);
    *(_OWORD *)uint64_t v79 = v82;
    v79 -= 4;
    v80 -= 2;
    v81 -= 4;
  }
  while (v81);
  v75 -= v77 & 0x3FFFFFFFFFFFFFFCLL;
  if (v77 != (v77 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_122;
  }
LABEL_123:
  if (v16) {
LABEL_124:
  }
    (*(void (**)(uint64_t, geo::codec::Allocator *, unint64_t))(*(void *)v4 + 40))(v4, v16, v72);
  uint64_t v16 = (geo::codec::Allocator *)v75;
LABEL_126:
  uint64_t v84 = *(unsigned __int8 *)(a2 + 60);
  if ((unint64_t)v53 < v17)
  {
    uint64_t *v53 = (v84 << 32) | 0x2C;
    int64_t v85 = v53 + 1;
    goto LABEL_151;
  }
  uint64_t v86 = ((char *)v53 - (char *)v16) >> 3;
  unint64_t v87 = v86 + 1;
  if ((unint64_t)(v86 + 1) >> 61) {
    abort();
  }
  unint64_t v88 = v17 - (void)v16;
  if ((uint64_t)(v17 - (void)v16) >> 2 > v87) {
    unint64_t v87 = (uint64_t)(v17 - (void)v16) >> 2;
  }
  if (v88 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v89 = v87;
  }
  if (v89)
  {
    uint64_t v90 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8 * v89, 4);
    unsigned int v91 = (uint64_t *)(v90 + 8 * v86);
    unint64_t v17 = v90 + 8 * v89;
    if (v90) {
      *unsigned int v91 = (v84 << 32) | 0x2C;
    }
  }
  else
  {
    unint64_t v17 = 0;
    unsigned int v91 = (uint64_t *)(8 * v86);
  }
  int64_t v85 = v91 + 1;
  if (v53 == (uint64_t *)v16) {
    goto LABEL_149;
  }
  unint64_t v92 = (char *)v53 - (char *)v16 - 8;
  if (v92 < 0x38)
  {
    uint64_t v94 = v53;
    do
    {
LABEL_147:
      uint64_t v99 = *--v94;
      *--unsigned int v91 = v99;
    }
    while (v94 != (uint64_t *)v16);
    goto LABEL_148;
  }
  if ((unint64_t)((char *)v53 - (char *)v91) < 0x20)
  {
    uint64_t v94 = v53;
    goto LABEL_147;
  }
  uint64_t v93 = (v92 >> 3) + 1;
  uint64_t v94 = &v53[-(v93 & 0x3FFFFFFFFFFFFFFCLL)];
  uint64_t v95 = v91 - 2;
  uint64_t v96 = v53 - 2;
  uint64_t v97 = v93 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v98 = *(_OWORD *)v96;
    *((_OWORD *)v95 - 1) = *((_OWORD *)v96 - 1);
    *(_OWORD *)uint64_t v95 = v98;
    v95 -= 4;
    v96 -= 4;
    v97 -= 4;
  }
  while (v97);
  v91 -= v93 & 0x3FFFFFFFFFFFFFFCLL;
  if (v93 != (v93 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_147;
  }
LABEL_148:
  if (v16) {
LABEL_149:
  }
    (*(void (**)(uint64_t, geo::codec::Allocator *, unint64_t))(*(void *)v4 + 40))(v4, v16, v88);
  uint64_t v16 = (geo::codec::Allocator *)v91;
LABEL_151:
  uint64_t v100 = *(unsigned __int8 *)(a2 + 100);
  if ((unint64_t)v85 < v17)
  {
    uint64_t *v85 = (v100 << 32) | 0x10009;
    unint64_t v101 = (char *)(v85 + 1);
    goto LABEL_176;
  }
  uint64_t v152 = a2;
  uint64_t v102 = a1;
  uint64_t v103 = ((char *)v85 - (char *)v16) >> 3;
  unint64_t v104 = v103 + 1;
  if ((unint64_t)(v103 + 1) >> 61) {
    abort();
  }
  unint64_t v105 = v17 - (void)v16;
  if ((uint64_t)(v17 - (void)v16) >> 2 > v104) {
    unint64_t v104 = (uint64_t)(v17 - (void)v16) >> 2;
  }
  if (v105 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v106 = v104;
  }
  if (v106)
  {
    uint64_t v107 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8 * v106, 4);
    int64_t v108 = (uint64_t *)(v107 + 8 * v103);
    unint64_t v17 = v107 + 8 * v106;
    if (v107) {
      uint64_t *v108 = (v100 << 32) | 0x10009;
    }
  }
  else
  {
    unint64_t v17 = 0;
    int64_t v108 = (uint64_t *)(8 * v103);
  }
  unint64_t v101 = (char *)(v108 + 1);
  if (v85 == (uint64_t *)v16) {
    goto LABEL_174;
  }
  unint64_t v109 = (char *)v85 - (char *)v16 - 8;
  if (v109 < 0x38)
  {
    __int16 v111 = v85;
    do
    {
LABEL_172:
      uint64_t v116 = *--v111;
      *--int64_t v108 = v116;
    }
    while (v111 != (uint64_t *)v16);
    goto LABEL_173;
  }
  if ((unint64_t)((char *)v85 - (char *)v108) < 0x20)
  {
    __int16 v111 = v85;
    goto LABEL_172;
  }
  uint64_t v110 = (v109 >> 3) + 1;
  __int16 v111 = &v85[-(v110 & 0x3FFFFFFFFFFFFFFCLL)];
  v112 = v108 - 2;
  unsigned __int8 v113 = v85 - 2;
  uint64_t v114 = v110 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v115 = *(_OWORD *)v113;
    *((_OWORD *)v112 - 1) = *((_OWORD *)v113 - 1);
    *(_OWORD *)v112 = v115;
    v112 -= 4;
    v113 -= 4;
    v114 -= 4;
  }
  while (v114);
  v108 -= v110 & 0x3FFFFFFFFFFFFFFCLL;
  if (v110 != (v110 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_172;
  }
LABEL_173:
  if (v16) {
LABEL_174:
  }
    (*(void (**)(uint64_t, geo::codec::Allocator *, unint64_t))(*(void *)v4 + 40))(v4, v16, v105);
  uint64_t v16 = (geo::codec::Allocator *)v108;
  a1 = v102;
  a2 = v152;
LABEL_176:
  uint64_t v117 = *(void *)(*(void *)(a1 + 56) + 8 * *(unsigned int *)(a2 + 48));
  if (v117) {
    uint64_t v118 = v117 + 8;
  }
  else {
    uint64_t v118 = 0;
  }
  uint64_t v119 = *(unsigned __int8 *)(v118 + 68);
  if ((unint64_t)v101 < v17)
  {
    *(void *)unint64_t v101 = ((v119 << 32) | 0x10009) + 11;
    unint64_t v120 = v101 + 8;
    goto LABEL_204;
  }
  uint64_t v121 = (v101 - (char *)v16) >> 3;
  unint64_t v122 = v121 + 1;
  if ((unint64_t)(v121 + 1) >> 61) {
    abort();
  }
  unint64_t v123 = v17 - (void)v16;
  if ((uint64_t)(v17 - (void)v16) >> 2 > v122) {
    unint64_t v122 = (uint64_t)(v17 - (void)v16) >> 2;
  }
  if (v123 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v124 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v124 = v122;
  }
  if (v124)
  {
    uint64_t v125 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8 * v124, 4);
    uint64_t v126 = (char *)(v125 + 8 * v121);
    unint64_t v17 = v125 + 8 * v124;
    if (v125) {
      *(void *)uint64_t v126 = ((v119 << 32) | 0x10009) + 11;
    }
  }
  else
  {
    unint64_t v17 = 0;
    uint64_t v126 = (char *)(8 * v121);
  }
  unint64_t v120 = v126 + 8;
  if (v101 == (char *)v16) {
    goto LABEL_202;
  }
  unint64_t v127 = v101 - (char *)v16 - 8;
  if (v127 < 0x38)
  {
    unint64_t v129 = v101;
    do
    {
LABEL_200:
      uint64_t v134 = *((void *)v129 - 1);
      v129 -= 8;
      *((void *)v126 - 1) = v134;
      v126 -= 8;
    }
    while (v129 != (char *)v16);
    goto LABEL_201;
  }
  if ((unint64_t)(v101 - v126) < 0x20)
  {
    unint64_t v129 = v101;
    goto LABEL_200;
  }
  uint64_t v128 = (v127 >> 3) + 1;
  unint64_t v129 = &v101[-8 * (v128 & 0x3FFFFFFFFFFFFFFCLL)];
  unint64_t v130 = v126 - 16;
  uint64_t v131 = v101 - 16;
  uint64_t v132 = v128 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v133 = *(_OWORD *)v131;
    *((_OWORD *)v130 - 1) = *((_OWORD *)v131 - 1);
    *(_OWORD *)unint64_t v130 = v133;
    v130 -= 32;
    v131 -= 32;
    v132 -= 4;
  }
  while (v132);
  v126 -= 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
  if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_200;
  }
LABEL_201:
  if (v16) {
LABEL_202:
  }
    (*(void (**)(uint64_t, geo::codec::Allocator *, unint64_t))(*(void *)v4 + 40))(v4, v16, v123);
  uint64_t v16 = (geo::codec::Allocator *)v126;
LABEL_204:
  unint64_t v135 = v157;
  if (((v120 - (char *)v16) & 0x7FFFFFFF8) != 0)
  {
    uint64_t v136 = 0;
    char v137 = 0;
    uint64_t v138 = ((unint64_t)(v120 - (char *)v16) >> 3);
    unsigned __int8 v139 = BYTE1(v157[1].__shared_owners_);
    while (1)
    {
      size_t v140 = v139;
      long long v141 = v135->__vftable;
      if (v139) {
        break;
      }
LABEL_206:
      *((void *)&v141->~__shared_weak_count + v140) = *((void *)v16 + v136);
      unsigned __int8 v139 = BYTE1(v135[1].__shared_owners_) + 1;
      BYTE1(v135[1].__shared_owners_) = v139;
      ++v136;
      char v137 = 1;
      if (v136 == v138)
      {
        long long v141 = v135->__vftable;
        size_t v140 = v139;
LABEL_223:
        qsort(v141, v140, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
        goto LABEL_224;
      }
    }
    if (v139 > 0x1Fu)
    {
      do
      {
        uint64_t v145 = 0;
        uint64_t v146 = v141;
        while (1)
        {
          int v147 = (int)v146->~__shared_weak_count;
          uint64_t v146 = (std::__shared_weak_count_vtbl *)((char *)v146 + 8);
          if (v147 == *((_DWORD *)v16 + 2 * v136)) {
            break;
          }
          if (v140 == ++v145) {
            goto LABEL_217;
          }
        }
        *((_DWORD *)&v141->~__shared_weak_count + 2 * v145 + 1) = *((_DWORD *)v16 + 2 * v136 + 1);
LABEL_217:
        ++v136;
      }
      while (v136 != v138);
    }
    else
    {
      do
      {
        uint64_t v142 = 0;
        long long v143 = v141;
        while (1)
        {
          int v144 = (int)v143->~__shared_weak_count;
          long long v143 = (std::__shared_weak_count_vtbl *)((char *)v143 + 8);
          if (v144 == *((_DWORD *)v16 + 2 * v136)) {
            break;
          }
          if (v140 == ++v142) {
            goto LABEL_206;
          }
        }
        *((_DWORD *)&v141->~__shared_weak_count + 2 * v142 + 1) = *((_DWORD *)v16 + 2 * v136++ + 1);
      }
      while (v136 != v138);
    }
    if (v137) {
      goto LABEL_223;
    }
  }
LABEL_224:
  uint64_t v148 = *(void *)(a2 + 72);
  __int16 v149 = v158;
  if (v158)
  {
    atomic_fetch_add_explicit(&v158->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v149->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v150 = *(std::__shared_weak_count **)(v148 + 40);
  *(void *)(v148 + 32) = v135;
  *(void *)(v148 + 40) = v149;
  if (v150 && !atomic_fetch_add(&v150->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
    std::__shared_weak_count::__release_weak(v150);
  }
  if (v149 && !atomic_fetch_add(&v149->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v149->__on_zero_shared)(v149);
    std::__shared_weak_count::__release_weak(v149);
  }
  if (v16) {
    (*(void (**)(uint64_t, geo::codec::Allocator *, unint64_t))(*(void *)v4 + 40))(v4, v16, v17 - (void)v16);
  }
  __int16 v151 = v158;
  if (v158)
  {
    if (!atomic_fetch_add(&v158->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v151->__on_zero_shared)(v151);
      std::__shared_weak_count::__release_weak(v151);
    }
  }
}

void sub_1A20D8A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

char *std::vector<md::LabelFeaturePlacementInfo>::__emplace_back_slow_path<md::LabelFeaturePlacementInfo const&>(void *a1, uint64_t a2)
{
  int v3 = (char *)*a1;
  int v2 = (char *)a1[1];
  uint64_t v4 = (uint64_t)&v2[-*a1] >> 5;
  unint64_t v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59) {
    abort();
  }
  uint64_t v8 = a1[2] - (void)v3;
  if (v8 >> 4 > v5) {
    unint64_t v5 = v8 >> 4;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v9 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v9 = v5;
  }
  if (v9)
  {
    if (v9 >> 59) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unsigned int v10 = (char *)operator new(32 * v9);
  }
  else
  {
    unsigned int v10 = 0;
  }
  id v11 = &v10[32 * v4];
  uint64_t v12 = &v10[32 * v9];
  *((void *)&v26 + 1) = v12;
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *(void *)id v11 = 0;
  uint64_t v13 = *(_WORD **)a2;
  unint64_t v14 = *(_WORD **)(a2 + 8);
  size_t v15 = (size_t)v14 - *(void *)a2;
  if (v14 != *(_WORD **)a2)
  {
    unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * v15;
    if (0xCCCCCCCCCCCCCCCDLL * v15 >= 0x3333333333333334) {
      abort();
    }
    unint64_t v17 = (char *)operator new(v15);
    *(void *)id v11 = v17;
    *((void *)v11 + 1) = v17;
    *((void *)v11 + 2) = &v17[5 * v16];
    do
    {
      *(_WORD *)unint64_t v17 = *v13;
      void v17[2] = 0;
      *(_WORD *)(v17 + 3) = *(_WORD *)((char *)v13 + 3);
      v17 += 5;
      uint64_t v13 = (_WORD *)((char *)v13 + 5);
    }
    while (v13 != v14);
    *((void *)v11 + 1) = v17;
  }
  *((_WORD *)v11 + 12) = *(_WORD *)(a2 + 24);
  v11[26] = *(unsigned char *)(a2 + 26);
  uint64_t v18 = v11 + 32;
  *(void *)&long long v26 = v11 + 32;
  if (v2 == v3)
  {
    *a1 = v11;
    a1[1] = v18;
    a1[2] = v12;
  }
  else
  {
    do
    {
      int v19 = v11;
      *((void *)v11 - 3) = 0;
      *((void *)v11 - 2) = 0;
      long long v20 = *((_OWORD *)v2 - 2);
      v2 -= 32;
      *((_OWORD *)v11 - 2) = v20;
      v11 -= 32;
      *((void *)v19 - 2) = *((void *)v2 + 2);
      *(void *)int v2 = 0;
      *((void *)v2 + 1) = 0;
      *((void *)v2 + 2) = 0;
      LOWORD(v19) = *((_WORD *)v2 + 12);
      v11[26] = v2[26];
      *((_WORD *)v11 + 12) = (_WORD)v19;
    }
    while (v2 != v3);
    int v2 = (char *)*a1;
    long long v21 = (char *)a1[1];
    *a1 = v11;
    *(_OWORD *)(a1 + 1) = v26;
    uint64_t v18 = (char *)v26;
    if (v21 != v2)
    {
      uint64_t v22 = v21;
      do
      {
        char v24 = (void *)*((void *)v22 - 4);
        v22 -= 32;
        uint64_t v23 = v24;
        if (v24)
        {
          *((void *)v21 - 3) = v23;
          operator delete(v23);
        }
        long long v21 = v22;
      }
      while (v22 != v2);
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v18;
}

void sub_1A20D8D9C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<md::LabelFeaturePlacementInfo>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_1::operator()(uint64_t *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  int v3 = operator new(0x30uLL);
  v3[1] = 0;
  v3[2] = 0;
  void *v3 = &unk_1EF5820F0;
  v3[3] = 0;
  uint64_t v4 = v3 + 3;
  v3[4] = 0;
  v3[5] = 0;
  v26.n128_u64[0] = (unint64_t)(v3 + 3);
  v26.n128_u64[1] = (unint64_t)v3;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id v5 = v2;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v23;
    while (1)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v23 != v7) {
          objc_enumerationMutation(v5);
        }
        unint64_t v9 = *(void **)(*((void *)&v22 + 1) + 8 * i);
        if ([v9 artworkSourceType] == 2)
        {
          unsigned int v10 = [v9 iconDataSource];
          id v11 = (std::__shared_weak_count *)operator new(0x58uLL);
          v11->__shared_owners_ = 0;
          v11->__shared_weak_owners_ = 0;
          v11->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581558;
          v11[1].std::__shared_count = 0u;
          *(_OWORD *)&v11[1].__shared_weak_owners_ = 0u;
          *(_OWORD *)&v11[2].__shared_owners_ = 0u;
          v11[3].std::__shared_count = 0u;
          {
            operator new();
          }
          v11[2].__shared_owners_ = mdm::Allocator::instance(void)::alloc;
          v11[2].__shared_weak_owners_ = 0;
          v11[3].__vftable = 0;
          LODWORD(v11[3].__shared_owners_) = 0;
          v21.n128_u64[0] = (unint64_t)&v11[1];
          v21.n128_u64[1] = (unint64_t)v11;
          LOBYTE(v11[1].__vftable) = 2;
          LODWORD(v11[2].__shared_weak_owners_) = 49;
          HIDWORD(v11[2].__shared_weak_owners_) = [v10 cartoID];
          unint64_t v12 = v26.n128_u64[0];
          uint64_t v13 = *(void **)(v26.n128_u64[0] + 8);
          if ((unint64_t)v13 >= *(void *)(v26.n128_u64[0] + 16))
          {
            *(void *)(v12 + 8) = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v26.n128_i64[0], v21);
            if (v11) {
              goto LABEL_12;
            }
          }
          else
          {
            *uint64_t v13 = v11 + 1;
            v13[1] = v11;
            atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)(v12 + 8) = v13 + 2;
LABEL_12:
            if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
              std::__shared_weak_count::__release_weak(v11);
            }
          }

          continue;
        }
      }
      uint64_t v6 = [v5 countByEnumeratingWithState:&v22 objects:v27 count:16];
      if (!v6)
      {
        uint64_t v4 = (uint64_t *)v26.n128_u64[0];
        break;
      }
    }
  }

  uint64_t v14 = *v4;
  uint64_t v15 = v4[1];
  if (*v4 == v15)
  {
    uint64_t v18 = (std::__shared_weak_count *)v26.n128_u64[1];
    if (!v26.n128_u64[1]) {
      goto LABEL_30;
    }
    goto LABEL_28;
  }
  uint64_t v16 = *a1;
  unint64_t v17 = *(uint64_t ***)(*a1 + 8);
  if ((unint64_t)v17 >= *(void *)(*a1 + 16))
  {
    uint64_t v18 = (std::__shared_weak_count *)v26.n128_u64[1];
    *(void *)(v16 + 8) = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(*a1, v26);
    if (!v18) {
      goto LABEL_30;
    }
    goto LABEL_28;
  }
  *unint64_t v17 = v4;
  uint64_t v18 = (std::__shared_weak_count *)v26.n128_u64[1];
  v17[1] = (uint64_t *)v26.n128_u64[1];
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v16 + 8) = v17 + 2;
  if (v18)
  {
LABEL_28:
    if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
LABEL_30:

  return v14 != v15;
}

void sub_1A20D9150(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

BOOL md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_2::operator()(uint64_t *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v2 = a2;
  int v3 = operator new(0x30uLL);
  v3[1] = 0;
  v3[2] = 0;
  void *v3 = &unk_1EF5820F0;
  v3[3] = 0;
  uint64_t v4 = v3 + 3;
  v3[4] = 0;
  v3[5] = 0;
  v26.n128_u64[0] = (unint64_t)(v3 + 3);
  v26.n128_u64[1] = (unint64_t)v3;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id v5 = v2;
  uint64_t v6 = [v5 countByEnumeratingWithState:&v22 objects:v27 count:16];
  if (v6)
  {
    uint64_t v7 = *(void *)v23;
    while (1)
    {
      for (uint64_t i = 0; i != v6; ++i)
      {
        if (*(void *)v23 != v7) {
          objc_enumerationMutation(v5);
        }
        unint64_t v9 = *(void **)(*((void *)&v22 + 1) + 8 * i);
        if ([v9 artworkSourceType] == 2)
        {
          unsigned int v10 = [v9 iconDataSource];
          id v11 = (std::__shared_weak_count *)operator new(0x58uLL);
          v11->__shared_owners_ = 0;
          v11->__shared_weak_owners_ = 0;
          v11->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581558;
          v11[1].std::__shared_count = 0u;
          *(_OWORD *)&v11[1].__shared_weak_owners_ = 0u;
          *(_OWORD *)&v11[2].__shared_owners_ = 0u;
          v11[3].std::__shared_count = 0u;
          {
            operator new();
          }
          v11[2].__shared_owners_ = mdm::Allocator::instance(void)::alloc;
          v11[2].__shared_weak_owners_ = 0;
          v11[3].__vftable = 0;
          LODWORD(v11[3].__shared_owners_) = 0;
          v21.n128_u64[0] = (unint64_t)&v11[1];
          v21.n128_u64[1] = (unint64_t)v11;
          LOBYTE(v11[1].__vftable) = 2;
          LODWORD(v11[2].__shared_weak_owners_) = 37;
          HIDWORD(v11[2].__shared_weak_owners_) = [v10 defaultTransitType];
          unint64_t v12 = v26.n128_u64[0];
          uint64_t v13 = *(void **)(v26.n128_u64[0] + 8);
          if ((unint64_t)v13 >= *(void *)(v26.n128_u64[0] + 16))
          {
            *(void *)(v12 + 8) = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v26.n128_i64[0], v21);
            if (v11) {
              goto LABEL_12;
            }
          }
          else
          {
            *uint64_t v13 = v11 + 1;
            v13[1] = v11;
            atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
            *(void *)(v12 + 8) = v13 + 2;
LABEL_12:
            if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
              std::__shared_weak_count::__release_weak(v11);
            }
          }

          continue;
        }
      }
      uint64_t v6 = [v5 countByEnumeratingWithState:&v22 objects:v27 count:16];
      if (!v6)
      {
        uint64_t v4 = (uint64_t *)v26.n128_u64[0];
        break;
      }
    }
  }

  uint64_t v14 = *v4;
  uint64_t v15 = v4[1];
  if (*v4 == v15)
  {
    uint64_t v18 = (std::__shared_weak_count *)v26.n128_u64[1];
    if (!v26.n128_u64[1]) {
      goto LABEL_30;
    }
    goto LABEL_28;
  }
  uint64_t v16 = *a1;
  unint64_t v17 = *(uint64_t ***)(*a1 + 8);
  if ((unint64_t)v17 >= *(void *)(*a1 + 16))
  {
    uint64_t v18 = (std::__shared_weak_count *)v26.n128_u64[1];
    *(void *)(v16 + 8) = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(*a1, v26);
    if (!v18) {
      goto LABEL_30;
    }
    goto LABEL_28;
  }
  *unint64_t v17 = v4;
  uint64_t v18 = (std::__shared_weak_count *)v26.n128_u64[1];
  v17[1] = (uint64_t *)v26.n128_u64[1];
  if (v18) {
    atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v16 + 8) = v17 + 2;
  if (v18)
  {
LABEL_28:
    if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
LABEL_30:

  return v14 != v15;
}

void sub_1A20D9550(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

BOOL md::LabelTransitRoute::addTransferSubtitleToNode(md::LabelTransitRoute::NodeInfo &)::$_3::operator()(uint64_t *a1, void *a2, _DWORD *a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  id v40 = a2;
  uint64_t v4 = operator new(0x30uLL);
  v4[1] = 0;
  v4[2] = 0;
  *uint64_t v4 = &unk_1EF5820F0;
  v4[3] = 0;
  id v5 = v4 + 3;
  v4[4] = 0;
  v4[5] = 0;
  v52.n128_u64[0] = (unint64_t)(v4 + 3);
  v52.n128_u64[1] = (unint64_t)v4;
  long long v48 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v51 = 0u;
  id v6 = v40;
  unint64_t v7 = [v6 countByEnumeratingWithState:&v48 objects:v53 count:16];
  if (v7)
  {
    uint64_t v8 = 0;
    uint64_t v9 = *(void *)v49;
    float32x4_t v44 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    for (uint64_t i = *(void *)v49; ; uint64_t i = *(void *)v49)
    {
      if (i != v9) {
        objc_enumerationMutation(v6);
      }
      id v11 = *(void **)(*((void *)&v48 + 1) + 8 * v8);
      if ([v11 artworkSourceType] == 1) {
        break;
      }
LABEL_34:
      if (++v8 >= v7)
      {
        unint64_t v7 = [v6 countByEnumeratingWithState:&v48 objects:v53 count:16];
        if (!v7)
        {
          id v5 = (uint64_t *)v52.n128_u64[0];
          goto LABEL_40;
        }
        uint64_t v8 = 0;
      }
    }
    unint64_t v12 = [v11 shieldDataSource];
    uint64_t v13 = (char *)operator new(0x58uLL);
    *((void *)v13 + 1) = 0;
    *((void *)v13 + 2) = 0;
    *(void *)uint64_t v13 = &unk_1EF581558;
    *(_OWORD *)(v13 + 24) = 0u;
    *(_OWORD *)(v13 + 40) = 0u;
    *(_OWORD *)(v13 + 56) = 0u;
    *(_OWORD *)(v13 + 72) = 0u;
    {
      operator new();
    }
    uint64_t v14 = mdm::Allocator::instance(void)::alloc;
    *((void *)v13 + 8) = 0;
    *((void *)v13 + 9) = 0;
    *((void *)v13 + 7) = v14;
    *((_DWORD *)v13 + 20) = 0;
    v47.n128_u64[0] = (unint64_t)(v13 + 24);
    v47.n128_u64[1] = (unint64_t)v13;
    v13[24] = 1;
    *((void *)v13 + 9) = [v12 shieldType];
    uint64_t v15 = [v12 shieldColorString];
    if ([v15 length])
    {
      uint64_t v16 = [v12 shieldColorString];
      float v17 = VKShieldColorsFromHexString(v16);
      float v19 = v18;
      float v21 = v20;
      unsigned int v46 = v22;
      if (v17 >= 0.04045) {
        float v23 = powf((float)(v17 * 0.94787) + 0.052133, 2.4);
      }
      else {
        float v23 = v17 * 0.077399;
      }
      float v45 = v23;
      if (v19 >= 0.04045) {
        float v24 = powf((float)(v19 * 0.94787) + 0.052133, 2.4);
      }
      else {
        float v24 = v19 * 0.077399;
      }
      if (v21 >= 0.04045)
      {
        float v43 = v24;
        float v25 = powf((float)(v21 * 0.94787) + 0.052133, 2.4);
        float v24 = v43;
      }
      else
      {
        float v25 = v21 * 0.077399;
      }
      v26.i64[0] = __PAIR64__(LODWORD(v24), LODWORD(v45));
      v26.i64[1] = __PAIR64__(v46, LODWORD(v25));
      int16x8_t v27 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(v26, v44));
      *(int16x4_t *)v27.i8 = vmovn_s32((int32x4_t)v27);
      *((_DWORD *)v13 + 20) = vmovn_s16(v27).u32[0];
    }
    else
    {
      *((_DWORD *)v13 + 20) = *a3;
    }

    uint64_t v28 = [v12 shieldText];
    uint64_t v29 = [v28 length];
    if (v29)
    {
      id v3 = [v12 shieldText];
      uint64_t v30 = (char *)[v3 UTF8String];
    }
    else
    {
      uint64_t v30 = "";
    }
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_external((void *)v13 + 4, v30);
    if (v29) {

    }
    unint64_t v31 = v52.n128_u64[0];
    int v32 = *(void **)(v52.n128_u64[0] + 8);
    if ((unint64_t)v32 >= *(void *)(v52.n128_u64[0] + 16))
    {
      uint64_t v33 = (std::__shared_weak_count *)v13;
      *(void *)(v31 + 8) = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(v52.n128_i64[0], v47);
      if (!v13)
      {
LABEL_33:

        goto LABEL_34;
      }
    }
    else
    {
      void *v32 = v47.n128_u64[0];
      uint64_t v33 = (std::__shared_weak_count *)v13;
      v32[1] = v13;
      if (v13) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v13 + 1, 1uLL, memory_order_relaxed);
      }
      *(void *)(v31 + 8) = v32 + 2;
      if (!v13) {
        goto LABEL_33;
      }
    }
    if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
    goto LABEL_33;
  }
LABEL_40:

  uint64_t v34 = *v5;
  uint64_t v35 = v5[1];
  if (*v5 == v35)
  {
    uint64_t v38 = (std::__shared_weak_count *)v52.n128_u64[1];
    if (!v52.n128_u64[1]) {
      goto LABEL_51;
    }
    goto LABEL_49;
  }
  uint64_t v36 = *a1;
  uint64_t v37 = *(uint64_t ***)(*a1 + 8);
  if ((unint64_t)v37 >= *(void *)(*a1 + 16))
  {
    uint64_t v38 = (std::__shared_weak_count *)v52.n128_u64[1];
    *(void *)(v36 + 8) = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(*a1, v52);
    if (!v38) {
      goto LABEL_51;
    }
    goto LABEL_49;
  }
  char *v37 = v5;
  uint64_t v38 = (std::__shared_weak_count *)v52.n128_u64[1];
  v37[1] = (uint64_t *)v52.n128_u64[1];
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(void *)(v36 + 8) = v37 + 2;
  if (v38)
  {
LABEL_49:
    if (!atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
LABEL_51:

  return v34 != v35;
}

void sub_1A20D9B44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Unwind_Resume(a1);
}

void CreateTransitLineDataElementGroup(void *a1, int a2, void *a3, void *a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v36 = a4;
  unint64_t v31 = v6;
  if ([v6 count])
  {
    unint64_t v7 = operator new(0x30uLL);
    v7[1] = 0;
    v7[2] = 0;
    *unint64_t v7 = &unk_1EF5824E0;
    v7[4] = 0;
    v7[5] = 0;
    v7[3] = 0;
    *a1 = v7 + 3;
    a1[1] = v7;
    long long v39 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v42 = 0u;
    obunint64_t j = v6;
    unint64_t v8 = [obj countByEnumeratingWithState:&v39 objects:v43 count:16];
    if (v8)
    {
      uint64_t v37 = 0;
      uint64_t v9 = *(void *)v40;
      if (a2) {
        char v10 = 1;
      }
      else {
        char v10 = 2;
      }
      char v32 = v10;
      uint64_t v34 = *(void *)v40;
      while (1)
      {
        if (v9 != v34) {
          objc_enumerationMutation(obj);
        }
        id v11 = *(void **)(*((void *)&v39 + 1) + 8 * v37);
        unint64_t v12 = [v36 name];
        if ([v11 artworkSourceType] == 1)
        {
          uint64_t v13 = [v11 shieldDataSource];
          uint64_t v14 = [v13 shieldText];
        }
        else
        {
          uint64_t v14 = 0;
        }
        if ([v14 length] || objc_msgSend(v12, "length"))
        {
          uint64_t v15 = (char *)operator new(0x50uLL);
          *((void *)v15 + 1) = 0;
          *((void *)v15 + 2) = 0;
          *(void *)uint64_t v15 = &unk_1EF581A60;
          *(_OWORD *)(v15 + 40) = 0u;
          *(_OWORD *)(v15 + 56) = 0u;
          *((void *)v15 + 9) = 0;
          *(_OWORD *)(v15 + 24) = 0u;
          *(void *)&long long v38 = v15 + 24;
          *((void *)&v38 + 1) = v15;
          v15[24] = v32;
          if ([v14 length]) {
            std::string::__assign_external((std::string *)(v15 + 32), (const std::string::value_type *)[v14 UTF8String]);
          }
          if ([v12 length]) {
            std::string::__assign_external((std::string *)(v15 + 56), (const std::string::value_type *)[v12 UTF8String]);
          }
          uint64_t v16 = *a1;
          float v18 = *(void **)(*a1 + 8);
          unint64_t v17 = *(void *)(*a1 + 16);
          if ((unint64_t)v18 >= v17)
          {
            float v20 = *(void **)v16;
            uint64_t v21 = ((uint64_t)v18 - *(void *)v16) >> 4;
            unint64_t v22 = v21 + 1;
            if ((unint64_t)(v21 + 1) >> 60) {
              abort();
            }
            uint64_t v23 = v17 - (void)v20;
            if (v23 >> 3 > v22) {
              unint64_t v22 = v23 >> 3;
            }
            if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v24 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v24 = v22;
            }
            if (v24 >> 60) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            float v25 = (char *)operator new(16 * v24);
            float32x4_t v26 = &v25[16 * v21];
            *(_OWORD *)float32x4_t v26 = v38;
            if (*((void *)&v38 + 1))
            {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 1uLL, memory_order_relaxed);
              float v20 = *(void **)v16;
              float v18 = *(void **)(v16 + 8);
            }
            int16x8_t v27 = &v25[16 * v24];
            float v19 = v26 + 16;
            if (v18 == v20)
            {
              *(void *)uint64_t v16 = v26;
              *(void *)(v16 + 8) = v19;
              *(void *)(v16 + 16) = v27;
            }
            else
            {
              do
              {
                long long v28 = *((_OWORD *)v18 - 1);
                v18 -= 2;
                *((_OWORD *)v26 - 1) = v28;
                v26 -= 16;
                void *v18 = 0;
                v18[1] = 0;
              }
              while (v18 != v20);
              float v20 = *(void **)v16;
              uint64_t v29 = *(void **)(v16 + 8);
              *(void *)uint64_t v16 = v26;
              *(void *)(v16 + 8) = v19;
              *(void *)(v16 + 16) = v27;
              while (v29 != v20)
              {
                uint64_t v30 = (std::__shared_weak_count *)*(v29 - 1);
                if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                  std::__shared_weak_count::__release_weak(v30);
                }
                v29 -= 2;
              }
            }
            if (v20) {
              operator delete(v20);
            }
          }
          else
          {
            void *v18 = v38;
            v18[1] = v15;
            atomic_fetch_add_explicit((atomic_ullong *volatile)v15 + 1, 1uLL, memory_order_relaxed);
            float v19 = v18 + 2;
          }
          *(void *)(v16 + 8) = v19;
          if (*((void *)&v38 + 1)
            && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            (*(void (**)(void))(**((void **)&v38 + 1) + 16))(*((void *)&v38 + 1));
            std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v38 + 1));
          }
        }

        if (++v37 >= v8)
        {
          unint64_t v8 = [obj countByEnumeratingWithState:&v39 objects:v43 count:16];
          if (!v8) {
            break;
          }
          uint64_t v37 = 0;
        }
        uint64_t v9 = *(void *)v40;
      }
    }
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
}

void sub_1A20DA058(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a12);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::LabelExternalDataElement>::__on_zero_shared(uint64_t a1)
{
  if (*(char *)(a1 + 79) < 0)
  {
    operator delete(*(void **)(a1 + 56));
    if ((*(char *)(a1 + 55) & 0x80000000) == 0) {
      return;
    }
  }
  else if ((*(char *)(a1 + 55) & 0x80000000) == 0)
  {
    return;
  }
  id v2 = *(void **)(a1 + 32);
  operator delete(v2);
}

void std::__shared_ptr_emplace<md::LabelExternalDataElement>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581A60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelExternalDataElement>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581A60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::LabelExternalDataElementGroup>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        id v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<md::LabelExternalDataElementGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5824E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelExternalDataElementGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5824E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::LabelTransferGroup>::__on_zero_shared(void *a1)
{
  id v2 = (std::__shared_weak_count *)a1[8];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (char *)a1[3];
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = (char *)a1[3];
    if (!v3) {
      return;
    }
  }
  uint64_t v4 = (char *)a1[4];
  id v5 = v3;
  if (v4 != v3)
  {
    do
    {
      id v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 16;
    }
    while (v4 != v3);
    id v5 = (char *)a1[3];
  }
  a1[4] = v3;
  operator delete(v5);
}

void std::__shared_ptr_emplace<md::LabelTransferGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580870;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelTransferGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580870;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::LabelAnnotationElementGroup>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  if (v1)
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void **)(a1 + 24);
    if (v3 != v1)
    {
      do
      {
        id v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v1);
      uint64_t v4 = *(void **)(a1 + 24);
    }
    *(void *)(a1 + 32) = v1;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<md::LabelAnnotationElementGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5820F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelAnnotationElementGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5820F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<md::LabelAnnotationElement>::__on_zero_shared(uint64_t result)
{
  if (*(char *)(result + 55) < 0) {
    return (*(uint64_t (**)(void, void, uint64_t))(**(void **)(result + 56) + 40))(*(void *)(result + 56), *(void *)(result + 32), *(void *)(result + 48) & 0x7FFFFFFFFFFFFFFFLL);
  }
  return result;
}

void std::__shared_ptr_emplace<md::LabelAnnotationElement>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581558;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelAnnotationElement>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581558;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__split_buffer<md::LabelFeaturePlacementInfo>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      while (1)
      {
        uint64_t v5 = v2 - 32;
        uint64_t v4 = *(void **)(v2 - 32);
        *(void *)(a1 + 16) = v2 - 32;
        if (!v4) {
          break;
        }
        *(void *)(v2 - 24) = v4;
        operator delete(v4);
        uint64_t v2 = *(void *)(a1 + 16);
        if (v2 == v3) {
          goto LABEL_6;
        }
      }
      v2 -= 32;
    }
    while (v5 != v3);
  }
LABEL_6:
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void MergeTransitSystemStylesWithStyle(void *a1, std::__shared_weak_count **a2)
{
  id v3 = a1;
  if (v3)
  {
    uint64_t v4 = [MEMORY[0x1E4F64AA8] attributesForTransitSystem:v3];
    if (v4)
    {
      uint64_t v5 = (void *)[objc_alloc(MEMORY[0x1E4F645A0]) initWithGEOStyleAttributes:v4];
      id v6 = v5;
      if (v5)
      {
        [v5 featureStyleAttributesPtr];
        uint64_t v8 = v23;
        unint64_t v7 = v24;
      }
      else
      {
        unint64_t v7 = 0;
        uint64_t v8 = 0;
      }
      uint64_t v9 = BYTE1((*a2)[1].__shared_owners_);
      if (BYTE1((*a2)[1].__shared_owners_))
      {
        uint64_t v10 = 0;
        char v11 = 0;
        unint64_t v12 = (*a2)->__vftable;
        unsigned __int8 v13 = *(unsigned char *)(v8 + 33);
        while (1)
        {
          size_t v14 = v13;
          uint64_t v15 = *(void **)v8;
          if (v13) {
            break;
          }
LABEL_8:
          v15[v14] = *((void *)&v12->~__shared_weak_count + v10);
          unsigned __int8 v13 = *(unsigned char *)(v8 + 33) + 1;
          *(unsigned char *)(v8 + 33) = v13;
          ++v10;
          char v11 = 1;
          if (v10 == v9)
          {
            uint64_t v15 = *(void **)v8;
            size_t v14 = v13;
LABEL_25:
            qsort(v15, v14, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
            goto LABEL_26;
          }
        }
        if (v13 > 0x1Fu)
        {
          do
          {
            uint64_t v19 = 0;
            float v20 = (int *)v15;
            while (1)
            {
              int v21 = *v20;
              v20 += 2;
              if (v21 == *((_DWORD *)&v12->~__shared_weak_count + 2 * v10)) {
                break;
              }
              if (v14 == ++v19) {
                goto LABEL_19;
              }
            }
            HIDWORD(v15[v19]) = *((_DWORD *)&v12->~__shared_weak_count + 2 * v10 + 1);
LABEL_19:
            ++v10;
          }
          while (v10 != v9);
        }
        else
        {
          do
          {
            uint64_t v16 = 0;
            unint64_t v17 = (int *)v15;
            while (1)
            {
              int v18 = *v17;
              v17 += 2;
              if (v18 == *((_DWORD *)&v12->~__shared_weak_count + 2 * v10)) {
                break;
              }
              if (v14 == ++v16) {
                goto LABEL_8;
              }
            }
            HIDWORD(v15[v16]) = *((_DWORD *)&v12->~__shared_weak_count + 2 * v10++ + 1);
          }
          while (v10 != v9);
        }
        if (v11) {
          goto LABEL_25;
        }
      }
LABEL_26:
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v22 = a2[1];
      *a2 = (std::__shared_weak_count *)v8;
      a2[1] = v7;
      if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
        std::__shared_weak_count::__release_weak(v22);
      }

      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
}

void sub_1A20DA984(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::LabelTransitRoute::findStopHeadingRange(uint64_t a1, double *a2, _DWORD *a3, int a4, char *a5)
{
  int v8 = 0;
  int v9 = 0;
  __int16 v10 = 0;
  __int16 v11 = 0;
  __int16 v12 = 0;
  int v13 = 0;
  uint64_t v14 = 0xFFFFFFFFLL;
  int v15 = 4;
  long long v41 = a3;
  int v40 = a4;
  while (1)
  {
    unint64_t v16 = (v8 + *a3);
    if (v8 + *a3 < 0) {
      break;
    }
    uint64_t v17 = *(void *)(a1 + 240);
    if (v16 >= (*(void *)(a1 + 248) - v17) >> 4) {
      break;
    }
    int v18 = (double *)(v17 + 16 * v16);
    double v19 = *v18 - *a2;
    double v20 = v18[1] - a2[1];
    double v21 = v19 * v19 + v20 * v20;
    if (v21 <= *(double *)(a1 + 232))
    {
      if (v13)
      {
        if (v9)
        {
          char v33 = *a5;
          unsigned int v34 = (v11 - *a5);
          if (v34 <= (v12 - *a5))
          {
            if (v34 <= (a5[1] - *a5))
            {
              int v13 = 0;
              unsigned int v37 = (a5[1] - *a5);
              if (v37 <= (v12 - *a5)) {
                LOBYTE(v37) = v12 - *a5;
              }
              a5[1] = v37 + v33;
              int v9 = 1;
            }
            else
            {
              int v13 = 0;
              int v9 = 1;
            }
          }
          else
          {
            int v13 = 0;
            unsigned int v35 = (a5[1] - *a5);
            if (v35 <= (v12 - *a5)) {
              LOBYTE(v35) = v12 - *a5;
            }
            a5[1] = v35 + v33;
            *a5 = v11;
            int v9 = 1;
          }
        }
        else
        {
          int v13 = 0;
          *(_WORD *)a5 = v11 | (unsigned __int16)(v12 << 8);
          int v9 = 1;
        }
      }
    }
    else
    {
      if (v21 > *(double *)(a1 + 224))
      {
        LODWORD(v16) = v14;
        if (v14 == -1) {
          goto LABEL_44;
        }
LABEL_42:
        *a3 = v16 + a4;
        return v9 & 1;
      }
      if (v21 <= *(double *)(a1 + 216))
      {
        unint64_t v16 = v14;
      }
      else
      {
        int v42 = v9;
        float v22 = v20;
        float v23 = v19;
        float v24 = atan2f(v22, v23) * 0.159154943;
        __int16 v25 = vcvts_n_s32_f32(v24 - floorf(v24), 8uLL);
        if (v13)
        {
          int v26 = (char)(v10 - v25);
          BOOL v27 = v26 <= 0;
          if (v26 <= 0) {
            __int16 v28 = v10;
          }
          else {
            __int16 v28 = v25;
          }
          if (v27) {
            char v29 = v25;
          }
          else {
            char v29 = v10;
          }
          unsigned int v30 = (v28 - v11);
          unsigned __int8 v31 = v29 - v11;
          if (v30 <= v31)
          {
            if (v30 <= (v12 - v11))
            {
              __int16 v36 = v31;
              if ((v12 - v11) > v31) {
                __int16 v36 = (v12 - v11);
              }
              __int16 v12 = v36 + v11;
            }
            int v13 = 1;
          }
          else
          {
            unsigned int v32 = (v12 - v11);
            if (v32 <= v31) {
              LOWORD(v32) = v31;
            }
            __int16 v12 = v32 + v11;
            int v13 = 1;
            __int16 v11 = v28;
          }
        }
        else
        {
          int v13 = 1;
          __int16 v12 = v25;
          __int16 v11 = v25;
        }
        __int16 v10 = v25;
        unint64_t v16 = v14;
        int v9 = v42;
        a4 = v40;
        a3 = v41;
      }
    }
    v8 += a4;
    uint64_t v14 = v16;
    if (!--v15) {
      goto LABEL_41;
    }
  }
  int v38 = v8 + *a3;
  LODWORD(v16) = v14;
  if (!((v13 == 0) | v9 & 1))
  {
    *(_WORD *)a5 = v11 | (unsigned __int16)(v12 << 8);
    LOBYTE(v9) = 1;
    LODWORD(v16) = v38;
  }
LABEL_41:
  if (v16 != -1) {
    goto LABEL_42;
  }
LABEL_44:
  LOBYTE(v9) = 0;
  return v9 & 1;
}

BOOL md::LabelTransitRoute::findRouteHeadingRange(uint64_t a1, double *a2, int a3, int a4, char *a5)
{
  LODWORD(v8) = 0;
  char v9 = 0;
  uint64_t v10 = a4;
  uint64_t v11 = a3;
  uint64_t v12 = 10;
  do
  {
    if (v11 < 0) {
      break;
    }
    uint64_t v13 = *(void *)(a1 + 240);
    if (v11 >= (unint64_t)((*(void *)(a1 + 248) - v13) >> 4)) {
      break;
    }
    uint64_t v14 = (double *)(v13 + 16 * v11);
    double v15 = *v14 - *a2;
    double v16 = v14[1] - a2[1];
    double v17 = v15 * v15 + v16 * v16;
    if (v17 > *(double *)(a1 + 184))
    {
      float v18 = v16;
      float v19 = v15;
      float v20 = atan2f(v18, v19) * 0.159154943;
      __int16 v21 = vcvts_n_s32_f32(v20 - floorf(v20), 8uLL);
      if (v8)
      {
        int v22 = (char)(v9 - v21);
        if (v22 <= 0) {
          char v23 = v9;
        }
        else {
          char v23 = v21;
        }
        if (v22 <= 0) {
          char v24 = v21;
        }
        else {
          char v24 = v9;
        }
        char v25 = *a5;
        unsigned int v26 = (v23 - *a5);
        unsigned __int8 v27 = v24 - *a5;
        if (v26 <= v27)
        {
          if (v26 <= (a5[1] - *a5))
          {
            unsigned __int8 v29 = v27;
            if ((a5[1] - *a5) > v27) {
              unsigned __int8 v29 = a5[1] - *a5;
            }
            a5[1] = v29 + v25;
          }
        }
        else
        {
          unsigned int v28 = (a5[1] - *a5);
          if (v28 <= v27) {
            LOBYTE(v28) = v27;
          }
          a5[1] = v28 + v25;
          *a5 = v23;
        }
      }
      else
      {
        *(_WORD *)a5 = v21 | (v21 << 8);
      }
      uint64_t v8 = 1;
      if (v17 > *(double *)(a1 + 192)) {
        return v8;
      }
      char v9 = v21;
    }
    v11 += v10;
    --v12;
  }
  while (v12);
  return v8 != 0;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *,false>(unint64_t result, unsigned __int8 *a2, uint64_t a3, char a4)
{
  char v9 = (unsigned __int8 *)result;
LABEL_2:
  uint64_t v10 = a2 - 2;
  uint64_t v11 = v9;
  while (1)
  {
    char v9 = v11;
    uint64_t v12 = a2 - v11;
    uint64_t v13 = (a2 - v11) >> 1;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0:
        case 1:
          return result;
        case 2:
          unsigned int v85 = *v11;
          if (*v10 >= v85) {
            return result;
          }
          __int16 v86 = v11[1];
          *(_WORD *)uint64_t v11 = *(_WORD *)v10;
          __int16 v87 = v85 | (v86 << 8);
          goto LABEL_180;
        case 3:
          unsigned int v88 = v11[2];
          unsigned int v89 = *v11;
          unsigned int v90 = *v10;
          if (v88 >= v89)
          {
            if (v90 < v88)
            {
              __int16 v128 = v11[3];
              *((_WORD *)v11 + 1) = *(_WORD *)v10;
              *(_WORD *)uint64_t v10 = v88 | (v128 << 8);
              unsigned int v129 = *v11;
              if (v11[2] < v129)
              {
                __int16 v130 = v11[1];
                *(_WORD *)uint64_t v11 = *((_WORD *)v11 + 1);
                __int16 v100 = v129 | (v130 << 8);
LABEL_155:
                *((_WORD *)v11 + 1) = v100;
              }
            }
          }
          else
          {
            __int16 v87 = v89 | (v11[1] << 8);
            if (v90 >= v88)
            {
              *(_WORD *)uint64_t v11 = *((_WORD *)v11 + 1);
              *((_WORD *)v11 + 1) = v87;
              if (*v10 >= v89) {
                return result;
              }
              *((_WORD *)v11 + 1) = *(_WORD *)v10;
            }
            else
            {
              *(_WORD *)uint64_t v11 = *(_WORD *)v10;
            }
LABEL_180:
            *(_WORD *)uint64_t v10 = v87;
          }
          break;
        case 4:
          return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *>(v11, v11 + 2, v11 + 4, (_WORD *)a2 - 1);
        case 5:
          BOOL result = (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *>(v11, v11 + 2, v11 + 4, (_WORD *)v11 + 3);
          unsigned int v91 = v11[6];
          if (*v10 >= v91) {
            return result;
          }
          __int16 v92 = v11[7];
          *((_WORD *)v11 + 3) = *(_WORD *)v10;
          *(_WORD *)uint64_t v10 = v91 | (v92 << 8);
          unsigned int v93 = v11[4];
          if (v11[6] >= v93) {
            return result;
          }
          __int16 v94 = *((_WORD *)v11 + 3);
          __int16 v95 = v11[5];
          *((_WORD *)v11 + 2) = v94;
          *((_WORD *)v11 + 3) = v93 | (v95 << 8);
          unsigned int v96 = v11[2];
          if (v96 <= v94) {
            return result;
          }
          __int16 v97 = v11[3];
          *((_WORD *)v11 + 1) = v94;
          *((_WORD *)v11 + 2) = v96 | (v97 << 8);
          unsigned int v98 = *v11;
          if (v98 <= v94) {
            return result;
          }
          __int16 v99 = v11[1];
          *(_WORD *)uint64_t v11 = v94;
          __int16 v100 = v98 | (v99 << 8);
          goto LABEL_155;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v12 <= 47)
    {
      unint64_t v101 = v11 + 2;
      BOOL v103 = v11 == a2 || v101 == a2;
      if (a4)
      {
        if (!v103)
        {
          uint64_t v104 = 0;
          unint64_t v105 = v11;
          do
          {
            uint64_t v107 = v101;
            unsigned int v108 = v105[2];
            if (v108 < *v105)
            {
              __int16 v109 = v105[3];
              uint64_t v110 = v104;
              do
              {
                *(_WORD *)&v11[v110 + 2] = *(_WORD *)&v11[v110];
                if (!v110)
                {
                  uint64_t v106 = v11;
                  goto LABEL_120;
                }
                unsigned int v111 = v11[v110 - 2];
                v110 -= 2;
              }
              while (v108 < v111);
              uint64_t v106 = &v11[v110 + 2];
LABEL_120:
              *(_WORD *)uint64_t v106 = v108 | (v109 << 8);
            }
            unint64_t v101 = v107 + 2;
            v104 += 2;
            unint64_t v105 = v107;
          }
          while (v107 + 2 != a2);
        }
      }
      else if (!v103)
      {
        do
        {
          uint64_t v131 = v101;
          unsigned int v132 = v9[2];
          if (v132 < *v9)
          {
            __int16 v133 = v9[3];
            uint64_t v134 = v131;
            do
            {
              unint64_t v135 = v134;
              __int16 v136 = *((_WORD *)v134 - 1);
              v134 -= 2;
              *unint64_t v135 = v136;
            }
            while (v132 < *((unsigned __int8 *)v135 - 4));
            *(_WORD *)uint64_t v134 = v132 | (v133 << 8);
          }
          unint64_t v101 = v131 + 2;
          char v9 = v131;
        }
        while (v131 + 2 != a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    double v15 = &v11[2 * ((unint64_t)v13 >> 1)];
    unsigned int v16 = *v10;
    if ((unint64_t)v12 >= 0x101)
    {
      unsigned int v17 = *v15;
      unsigned int v18 = *v11;
      if (v17 >= v18)
      {
        if (v16 < v17)
        {
          char v23 = &v11[2 * v14];
          __int16 v24 = v23[1];
          *(_WORD *)char v23 = *(_WORD *)v10;
          *(_WORD *)uint64_t v10 = v17 | (v24 << 8);
          unsigned int v25 = *v11;
          if (*v15 < v25)
          {
            __int16 v26 = v11[1];
            *(_WORD *)uint64_t v11 = *(_WORD *)v15;
            *(_WORD *)double v15 = v25 | (v26 << 8);
          }
        }
      }
      else
      {
        __int16 v19 = v18 | (v11[1] << 8);
        if (v16 < v17)
        {
          *(_WORD *)uint64_t v11 = *(_WORD *)v10;
          goto LABEL_22;
        }
        *(_WORD *)uint64_t v11 = *(_WORD *)v15;
        *(_WORD *)double v15 = v19;
        if (*v10 < v18)
        {
          *(_WORD *)double v15 = *(_WORD *)v10;
LABEL_22:
          *(_WORD *)uint64_t v10 = v19;
        }
      }
      unint64_t v31 = v14 - 1;
      unsigned int v32 = &v11[2 * v14 - 2];
      unsigned int v33 = *v32;
      unsigned int v34 = v11[2];
      unsigned int v35 = *(a2 - 4);
      if (v33 >= v34)
      {
        if (v35 < v33)
        {
          unsigned int v37 = &v11[2 * v31];
          __int16 v38 = v37[1];
          *(_WORD *)unsigned int v37 = *((_WORD *)a2 - 2);
          *((_WORD *)a2 - 2) = v33 | (v38 << 8);
          unsigned int v39 = v11[2];
          if (*v32 < v39)
          {
            __int16 v40 = v11[3];
            *((_WORD *)v11 + 1) = *(_WORD *)v32;
            *(_WORD *)unsigned int v32 = v39 | (v40 << 8);
          }
        }
      }
      else
      {
        __int16 v36 = v34 | (v11[3] << 8);
        if (v35 < v33)
        {
          *((_WORD *)v11 + 1) = *((_WORD *)a2 - 2);
          goto LABEL_34;
        }
        *((_WORD *)v11 + 1) = *(_WORD *)v32;
        *(_WORD *)unsigned int v32 = v36;
        if (*(a2 - 4) < v34)
        {
          *(_WORD *)unsigned int v32 = *((_WORD *)a2 - 2);
LABEL_34:
          *((_WORD *)a2 - 2) = v36;
        }
      }
      long long v41 = &v11[2 * v14 + 2];
      unsigned int v42 = *v41;
      unsigned int v43 = v11[4];
      unsigned int v44 = *(a2 - 6);
      if (v42 >= v43)
      {
        if (v44 < v42)
        {
          unsigned int v46 = &v11[2 * v14 + 2];
          __int16 v47 = v46[1];
          *(_WORD *)unsigned int v46 = *((_WORD *)a2 - 3);
          *((_WORD *)a2 - 3) = v42 | (v47 << 8);
          unsigned int v48 = v11[4];
          if (*v41 < v48)
          {
            __int16 v49 = v11[5];
            *((_WORD *)v11 + 2) = *(_WORD *)v41;
            *(_WORD *)long long v41 = v48 | (v49 << 8);
          }
        }
      }
      else
      {
        __int16 v45 = v43 | (v11[5] << 8);
        if (v44 < v42)
        {
          *((_WORD *)v11 + 2) = *((_WORD *)a2 - 3);
          goto LABEL_43;
        }
        *((_WORD *)v11 + 2) = *(_WORD *)v41;
        *(_WORD *)long long v41 = v45;
        if (*(a2 - 6) < v43)
        {
          *(_WORD *)long long v41 = *((_WORD *)a2 - 3);
LABEL_43:
          *((_WORD *)a2 - 3) = v45;
        }
      }
      unsigned int v50 = *v15;
      unsigned int v51 = *v32;
      unsigned int v52 = *v41;
      if (v50 >= v51)
      {
        if (v52 < v50)
        {
          uint64_t v54 = &v11[2 * v14];
          __int16 v55 = *(_WORD *)v41;
          __int16 v56 = v54[1];
          *(_WORD *)uint64_t v54 = *(_WORD *)v41;
          *(_WORD *)long long v41 = v50 | (v56 << 8);
          if (v51 > v55)
          {
            unint64_t v57 = &v11[2 * v31];
            __int16 v58 = v57[1];
            *(_WORD *)unint64_t v57 = v55;
            *(_WORD *)double v15 = v51 | (v58 << 8);
          }
        }
      }
      else
      {
        __int16 v53 = v51 | (v11[2 * v31 + 1] << 8);
        if (v52 < v50)
        {
          *(_WORD *)unsigned int v32 = *(_WORD *)v41;
          goto LABEL_52;
        }
        *(_WORD *)unsigned int v32 = *(_WORD *)v15;
        *(_WORD *)double v15 = v53;
        if (v52 < v51)
        {
          *(_WORD *)double v15 = *(_WORD *)v41;
LABEL_52:
          *(_WORD *)long long v41 = v53;
        }
      }
      __int16 v59 = *(_WORD *)v11;
      *(_WORD *)uint64_t v11 = *(_WORD *)v15;
      *(_WORD *)double v15 = v59;
      goto LABEL_54;
    }
    unsigned int v20 = *v11;
    unsigned int v21 = *v15;
    if (v20 >= v21)
    {
      if (v16 < v20)
      {
        __int16 v27 = v11[1];
        *(_WORD *)uint64_t v11 = *(_WORD *)v10;
        *(_WORD *)uint64_t v10 = v20 | (v27 << 8);
        unsigned int v28 = *v15;
        if (*v11 < v28)
        {
          unsigned __int8 v29 = &v11[2 * v14];
          __int16 v30 = v29[1];
          *(_WORD *)unsigned __int8 v29 = *(_WORD *)v11;
          *(_WORD *)uint64_t v11 = v28 | (v30 << 8);
        }
      }
      goto LABEL_54;
    }
    __int16 v22 = v21 | (v11[2 * v14 + 1] << 8);
    if (v16 >= v20)
    {
      *(_WORD *)double v15 = *(_WORD *)v11;
      *(_WORD *)uint64_t v11 = v22;
      if (*v10 >= v21) {
        goto LABEL_54;
      }
      *(_WORD *)uint64_t v11 = *(_WORD *)v10;
    }
    else
    {
      *(_WORD *)double v15 = *(_WORD *)v10;
    }
    *(_WORD *)uint64_t v10 = v22;
LABEL_54:
    --a3;
    unsigned int v60 = *v11;
    if ((a4 & 1) != 0 || *(v11 - 2) < v60)
    {
      __int16 v61 = v11[1];
      unint64_t v62 = v11;
      do
      {
        uint64_t v63 = v62;
        unsigned int v65 = v62[2];
        v62 += 2;
        unsigned __int8 v64 = v65;
      }
      while (v65 < v60);
      unint64_t v66 = a2;
      if (v63 == v11)
      {
        unint64_t v66 = a2;
        do
        {
          if (v62 >= v66) {
            break;
          }
          unsigned int v68 = *(v66 - 2);
          v66 -= 2;
        }
        while (v68 >= v60);
      }
      else
      {
        do
        {
          unsigned int v67 = *(v66 - 2);
          v66 -= 2;
        }
        while (v67 >= v60);
      }
      if (v62 < v66)
      {
        uint64_t v69 = v62;
        uint64_t v70 = v66;
        do
        {
          __int16 v71 = v69[1];
          *(_WORD *)uint64_t v69 = *(_WORD *)v70;
          *(_WORD *)uint64_t v70 = v64 | (unsigned __int16)(v71 << 8);
          do
          {
            uint64_t v63 = v69;
            unsigned int v72 = v69[2];
            v69 += 2;
            unsigned __int8 v64 = v72;
          }
          while (v72 < v60);
          do
          {
            unsigned int v73 = *(v70 - 2);
            v70 -= 2;
          }
          while (v73 >= v60);
        }
        while (v69 < v70);
      }
      if (v63 != v11) {
        *(_WORD *)uint64_t v11 = *(_WORD *)v63;
      }
      *(_WORD *)uint64_t v63 = v60 | (v61 << 8);
      if (v62 < v66) {
        goto LABEL_75;
      }
      BOOL v74 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *>(v11, v63);
      uint64_t v11 = v63 + 2;
      BOOL result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *>(v63 + 2, a2);
      if (result)
      {
        a2 = v63;
        if (v74) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v74)
      {
LABEL_75:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *,false>(v9, v63, a3, a4 & 1);
        a4 = 0;
        uint64_t v11 = v63 + 2;
      }
    }
    else
    {
      if (v60 < *v10)
      {
        do
        {
          unsigned int v75 = v11[2];
          v11 += 2;
        }
        while (v60 >= v75);
      }
      else
      {
        unint64_t v76 = v11 + 2;
        do
        {
          uint64_t v11 = v76;
          if (v76 >= a2) {
            break;
          }
          v76 += 2;
        }
        while (v60 >= *v11);
      }
      uint64_t v77 = a2;
      if (v11 < a2)
      {
        uint64_t v77 = a2;
        do
        {
          unsigned int v78 = *(v77 - 2);
          v77 -= 2;
        }
        while (v60 < v78);
      }
      __int16 v79 = v9[1];
      if (v11 < v77)
      {
        unsigned __int8 v80 = *v11;
        do
        {
          __int16 v81 = v11[1];
          *(_WORD *)uint64_t v11 = *(_WORD *)v77;
          *(_WORD *)uint64_t v77 = v80 | (unsigned __int16)(v81 << 8);
          do
          {
            unsigned int v82 = v11[2];
            v11 += 2;
            unsigned __int8 v80 = v82;
          }
          while (v60 >= v82);
          do
          {
            unsigned int v83 = *(v77 - 2);
            v77 -= 2;
          }
          while (v60 < v83);
        }
        while (v11 < v77);
      }
      uint64_t v84 = v11 - 2;
      BOOL v4 = v11 - 2 >= v9;
      BOOL v5 = v11 - 2 == v9;
      if (v11 - 2 != v9) {
        *(_WORD *)char v9 = *(_WORD *)v84;
      }
      a4 = 0;
      *(_WORD *)uint64_t v84 = v60 | (v79 << 8);
    }
  }
  if (v11 != a2)
  {
    int64_t v112 = (unint64_t)(v13 - 2) >> 1;
    int64_t v113 = v112;
    do
    {
      if (v112 >= v113)
      {
        uint64_t v115 = (2 * v113) | 1;
        uint64_t v116 = &v11[2 * v115];
        if (2 * v113 + 2 < v13)
        {
          unsigned int v117 = *v116;
          unsigned int v119 = v116[2];
          BOOL v118 = v117 >= v119;
          if (v117 > v119) {
            unsigned int v119 = *v116;
          }
          if (!v118)
          {
            v116 += 2;
            uint64_t v115 = 2 * v113 + 2;
          }
        }
        else
        {
          unsigned int v119 = *v116;
        }
        unint64_t v120 = &v11[2 * v113];
        unsigned int v121 = *v120;
        if (v119 >= v121)
        {
          __int16 v122 = v11[2 * v113 + 1];
          while (1)
          {
            uint64_t v126 = v120;
            unint64_t v120 = v116;
            *(_WORD *)uint64_t v126 = *(_WORD *)v116;
            if (v112 < v115) {
              break;
            }
            uint64_t v127 = (2 * v115) | 1;
            uint64_t v116 = &v11[2 * v127];
            uint64_t v115 = 2 * v115 + 2;
            if (v115 < v13)
            {
              unsigned int v123 = *v116;
              unsigned int v124 = v116[2];
              BOOL v125 = v123 >= v124;
              if (v123 <= v124) {
                BOOL result = v116[2];
              }
              else {
                BOOL result = *v116;
              }
              if (v125) {
                uint64_t v115 = v127;
              }
              else {
                v116 += 2;
              }
              if (result < v121) {
                break;
              }
            }
            else
            {
              BOOL result = *v116;
              uint64_t v115 = v127;
              if (result < v121) {
                break;
              }
            }
          }
          *(_WORD *)unint64_t v120 = v121 | (v122 << 8);
        }
      }
      BOOL v114 = v113-- <= 0;
    }
    while (!v114);
    uint64_t v137 = (unint64_t)v12 >> 1;
    while (2)
    {
      uint64_t v138 = 0;
      LOWORD(v139) = *v11;
      __int16 v140 = v11[1];
      long long v141 = v11;
      do
      {
        uint64_t v142 = 2 * v138 + 2;
        long long v143 = &v141[v142];
        uint64_t v144 = (2 * v138) | 1;
        if (v142 < v137)
        {
          BOOL result = v143[2];
          if (*v143 < result)
          {
            v143 += 2;
            uint64_t v144 = 2 * v138 + 2;
          }
        }
        *(_WORD *)long long v141 = *(_WORD *)v143;
        long long v141 = v143;
        uint64_t v138 = v144;
      }
      while (v144 <= (uint64_t)((unint64_t)(v137 - 2) >> 1));
      a2 -= 2;
      if (v143 == a2)
      {
LABEL_163:
        *(_WORD *)long long v143 = v139 | (v140 << 8);
      }
      else
      {
        *(_WORD *)long long v143 = *(_WORD *)a2;
        *(_WORD *)a2 = v139 | (v140 << 8);
        uint64_t v145 = v143 - v11 + 2;
        if (v145 >= 3)
        {
          unint64_t v146 = (((unint64_t)v145 >> 1) - 2) >> 1;
          int v147 = &v11[2 * v146];
          unsigned int v139 = *v143;
          if (*v147 < v139)
          {
            __int16 v140 = v143[1];
            do
            {
              uint64_t v148 = v143;
              long long v143 = v147;
              *(_WORD *)uint64_t v148 = *(_WORD *)v147;
              if (!v146) {
                break;
              }
              unint64_t v146 = (v146 - 1) >> 1;
              int v147 = &v11[2 * v146];
            }
            while (*v147 < v139);
            goto LABEL_163;
          }
        }
      }
      BOOL v114 = v137-- <= 2;
      if (v114) {
        return result;
      }
      continue;
    }
  }
  return result;
}

uint64_t populatePlacementsInArc(uint64_t result, uint64_t *a2, float a3)
{
  float v3 = a3;
  if (a3 >= 75.0)
  {
    unsigned __int8 v5 = result;
    while (1)
    {
      float v7 = (float)(v3 * 0.0013889) - floorf(v3 * 0.0013889);
      float v3 = v3 * 0.5;
      int v8 = (vcvts_n_s32_f32(v7, 8uLL) + v5);
      unint64_t v9 = a2[1];
      unint64_t v10 = a2[2];
      if (v9 >= v10) {
        break;
      }
      if (v9)
      {
        *(_DWORD *)unint64_t v9 = v8;
        *(float *)(v9 + 4) = v3;
      }
      uint64_t v6 = v9 + 8;
LABEL_5:
      a2[1] = v6;
      BOOL result = populatePlacementsInArc(v5, a2, v3);
      unsigned __int8 v5 = v8;
      if (v3 < 75.0) {
        return result;
      }
    }
    uint64_t v11 = (uint64_t)(v9 - *a2) >> 3;
    unint64_t v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 61) {
      abort();
    }
    uint64_t v13 = v10 - *a2;
    if (v13 >> 2 > v12) {
      unint64_t v12 = v13 >> 2;
    }
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v12)
    {
      uint64_t v14 = 8 * v12;
      uint64_t v15 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a2[3] + 16))(a2[3], 8 * v12, 4);
      uint64_t v16 = v15 + 8 * v11;
      unint64_t v12 = v15 + v14;
      if (v15)
      {
        *(_DWORD *)uint64_t v16 = v8;
        *(float *)(v16 + 4) = v3;
      }
    }
    else
    {
      uint64_t v16 = 8 * v11;
    }
    uint64_t v18 = *a2;
    uint64_t v17 = a2[1];
    uint64_t v19 = v17 - *a2;
    if (v17 == *a2)
    {
      uint64_t v21 = v16;
      goto LABEL_29;
    }
    unint64_t v20 = v19 - 8;
    if ((unint64_t)(v19 - 8) < 0x38)
    {
      uint64_t v21 = v16;
    }
    else
    {
      uint64_t v21 = v16;
      if ((unint64_t)(v17 - v16) >= 0x20)
      {
        uint64_t v22 = (v20 >> 3) + 1;
        char v23 = (_OWORD *)(v16 - 16);
        __int16 v24 = (long long *)(v17 - 16);
        uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v26 = *v24;
          *(v23 - 1) = *(v24 - 1);
          _OWORD *v23 = v26;
          v23 -= 2;
          v24 -= 2;
          v25 -= 4;
        }
        while (v25);
        uint64_t v21 = v16 - 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        v17 -= 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
        if (v22 == (v22 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_28;
        }
      }
    }
    do
    {
      uint64_t v27 = *(void *)(v17 - 8);
      v17 -= 8;
      *(void *)(v21 - 8) = v27;
      v21 -= 8;
    }
    while (v17 != v18);
LABEL_28:
    uint64_t v17 = *a2;
LABEL_29:
    uint64_t v6 = v16 + 8;
    *a2 = v21;
    a2[1] = v16 + 8;
    uint64_t v28 = a2[2];
    a2[2] = v12;
    if (v17) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a2[3] + 40))(a2[3], v17, v28 - v17);
    }
    goto LABEL_5;
  }
  return result;
}

float *std::__introsort<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *,false>(float *result, float *a2, char **a3, uint64_t a4, char a5)
{
  uint64_t v11 = result;
LABEL_2:
  unint64_t v12 = a2 - 2;
  id v168 = a2 - 6;
  uint64_t v169 = a2 - 4;
  uint64_t v166 = a2 - 3;
  uint64_t v167 = a2;
  uint64_t i = v11;
  while (1)
  {
    uint64_t v11 = i;
    uint64_t v14 = (char *)a2 - (char *)i;
    unint64_t v15 = ((char *)a2 - (char *)i) >> 3;
    if (v6 || !v5)
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          float v72 = *(a2 - 1);
          float v73 = i[1];
          if (vabds_f32(v72, v73) > 10.0)
          {
            if (v72 <= v73) {
              return result;
            }
            goto LABEL_278;
          }
          char v150 = **a3;
          int v151 = (char)(*(unsigned char *)v12 - v150);
          if (v151 < 0) {
            int v151 = -v151;
          }
          int v152 = (char)(*(unsigned char *)i - v150);
          if (v152 < 0) {
            int v152 = -v152;
          }
          if (v151 < v152)
          {
LABEL_278:
            uint64_t v153 = *(void *)i;
            *(void *)uint64_t i = *(void *)v12;
            *(void *)unint64_t v12 = v153;
            return result;
          }
          break;
        case 3uLL:
          return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(i, i + 2, v12, a3);
        case 4uLL:
          return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(i, i + 2, i + 4, (uint64_t)v12, a3);
        case 5uLL:
          return std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *,0>(i, i + 2, i + 4, (uint64_t)(i + 6), (uint64_t)v12, a3);
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 191) {
      break;
    }
    if (!a4)
    {
      if (i == a2) {
        return result;
      }
      int64_t v93 = (v15 - 2) >> 1;
      int64_t v94 = v93;
      while (1)
      {
        int64_t v96 = v94;
        if (v93 < v94) {
          goto LABEL_194;
        }
        uint64_t v97 = (2 * v94) | 1;
        unsigned int v98 = &i[2 * v97];
        if (2 * v96 + 2 < (uint64_t)v15)
        {
          float v99 = v98[1];
          float v100 = v98[3];
          if (vabds_f32(v99, v100) <= 10.0)
          {
            char v101 = **a3;
            int v102 = (char)(*(unsigned char *)v98 - v101);
            if (v102 < 0) {
              int v102 = -v102;
            }
            int v103 = (char)(*((unsigned char *)v98 + 8) - v101);
            if (v103 < 0) {
              int v103 = -v103;
            }
            if (v102 < v103)
            {
LABEL_205:
              v98 += 2;
              uint64_t v97 = 2 * v96 + 2;
            }
          }
          else if (v99 > v100)
          {
            goto LABEL_205;
          }
        }
        uint64_t v104 = &i[2 * v96];
        float v105 = v98[1];
        float v106 = v104[1];
        if (vabds_f32(v105, v106) <= 10.0)
        {
          char v107 = **a3;
          int v108 = (char)(*(unsigned char *)v98 - v107);
          if (v108 < 0) {
            int v108 = -v108;
          }
          int v109 = (char)(*(unsigned char *)v104 - v107);
          if (v109 < 0) {
            int v109 = -v109;
          }
          if (v108 >= v109)
          {
LABEL_214:
            int v110 = *(_DWORD *)v104;
            *(void *)uint64_t v104 = *(void *)v98;
            if (v93 < v97)
            {
LABEL_192:
              __int16 v95 = v98;
LABEL_193:
              *(_DWORD *)__int16 v95 = v110;
              v95[1] = v106;
              goto LABEL_194;
            }
            while (2)
            {
              uint64_t v114 = 2 * v97;
              uint64_t v97 = (2 * v97) | 1;
              __int16 v95 = &i[2 * v97];
              uint64_t v115 = v114 + 2;
              if (v115 < (uint64_t)v15)
              {
                float v116 = v95[1];
                float v117 = v95[3];
                if (vabds_f32(v116, v117) <= 10.0)
                {
                  char v118 = **a3;
                  LODWORD(result) = (char)(*(unsigned char *)v95 - v118);
                  if ((int)result < 0) {
                    LODWORD(result) = -(int)result;
                  }
                  BOOL result = (float *)result;
                  int v119 = (char)(*((unsigned char *)v95 + 8) - v118);
                  if (v119 < 0) {
                    int v119 = -v119;
                  }
                  if (result >= v119) {
                    goto LABEL_232;
                  }
                }
                else if (v116 <= v117)
                {
                  goto LABEL_232;
                }
                v95 += 2;
                uint64_t v97 = v115;
              }
LABEL_232:
              float v120 = v95[1];
              if (vabds_f32(v120, v106) <= 10.0)
              {
                char v111 = **a3;
                int v112 = (char)(*(unsigned char *)v95 - v111);
                if (v112 < 0) {
                  int v112 = -v112;
                }
                int v113 = (char)(v110 - v111);
                if (v113 < 0) {
                  int v113 = -v113;
                }
                if (v112 < v113) {
                  goto LABEL_192;
                }
              }
              else if (v120 > v106)
              {
                goto LABEL_192;
              }
              *(void *)unsigned int v98 = *(void *)v95;
              unsigned int v98 = v95;
              if (v93 < v97) {
                goto LABEL_193;
              }
              continue;
            }
          }
        }
        else if (v105 <= v106)
        {
          goto LABEL_214;
        }
LABEL_194:
        int64_t v94 = v96 - 1;
        if (!v96)
        {
          uint64_t v121 = (unint64_t)v14 >> 3;
          while (1)
          {
            uint64_t v123 = 0;
            uint64_t v124 = *(void *)i;
            BOOL v125 = i;
            do
            {
              uint64_t v126 = v125;
              v125 += 2 * v123 + 2;
              uint64_t v127 = 2 * v123;
              uint64_t v123 = (2 * v123) | 1;
              uint64_t v128 = v127 + 2;
              if (v128 < v121)
              {
                float v129 = v125[1];
                float v130 = v125[3];
                if (vabds_f32(v129, v130) <= 10.0)
                {
                  char v131 = **a3;
                  int v132 = (char)(*(unsigned char *)v125 - v131);
                  if (v132 < 0) {
                    int v132 = -v132;
                  }
                  int v133 = (char)(*((unsigned char *)v125 + 8) - v131);
                  if (v133 < 0) {
                    int v133 = -v133;
                  }
                  if (v132 < v133)
                  {
LABEL_238:
                    v125 += 2;
                    uint64_t v123 = v128;
                  }
                }
                else if (v129 > v130)
                {
                  goto LABEL_238;
                }
              }
              *(void *)uint64_t v126 = *(void *)v125;
            }
            while (v123 <= (uint64_t)((unint64_t)(v121 - 2) >> 1));
            a2 -= 2;
            if (v125 == a2)
            {
              *(void *)BOOL v125 = v124;
              goto LABEL_236;
            }
            *(void *)BOOL v125 = *(void *)a2;
            *(void *)a2 = v124;
            uint64_t v134 = (char *)v125 - (char *)i + 8;
            if (v134 >= 9)
            {
              unint64_t v135 = ((unint64_t)v134 >> 3) - 2;
              unint64_t v136 = v135 >> 1;
              uint64_t v137 = &i[2 * (v135 >> 1)];
              float v138 = v137[1];
              float v139 = v125[1];
              if (vabds_f32(v138, v139) <= 10.0)
              {
                char v140 = **a3;
                int v141 = (char)(*(unsigned char *)v137 - v140);
                if (v141 < 0) {
                  int v141 = -v141;
                }
                int v142 = (char)(*(unsigned char *)v125 - v140);
                if (v142 < 0) {
                  int v142 = -v142;
                }
                if (v141 < v142)
                {
LABEL_261:
                  int v143 = *(_DWORD *)v125;
                  *(void *)BOOL v125 = *(void *)v137;
                  if (v135 >= 2)
                  {
                    while (1)
                    {
                      unint64_t v147 = v136 - 1;
                      unint64_t v136 = (v136 - 1) >> 1;
                      uint64_t v148 = &i[2 * v136];
                      float v149 = v148[1];
                      if (vabds_f32(v149, v139) <= 10.0)
                      {
                        char v144 = **a3;
                        int v145 = (char)(*(unsigned char *)v148 - v144);
                        if (v145 < 0) {
                          int v145 = -v145;
                        }
                        int v146 = (char)(v143 - v144);
                        if (v146 < 0) {
                          int v146 = -v146;
                        }
                        if (v145 >= v146) {
                          break;
                        }
                      }
                      else if (v149 <= v139)
                      {
                        break;
                      }
                      *(void *)uint64_t v137 = *(void *)v148;
                      uint64_t v137 = &i[2 * v136];
                      if (v147 <= 1) {
                        goto LABEL_272;
                      }
                    }
                  }
                  uint64_t v148 = v137;
LABEL_272:
                  *(_DWORD *)uint64_t v148 = v143;
                  v148[1] = v139;
                }
              }
              else if (v138 > v139)
              {
                goto LABEL_261;
              }
            }
LABEL_236:
            if (v121-- <= 2) {
              return result;
            }
          }
        }
      }
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &i[2 * (v15 >> 1)];
    if ((unint64_t)v14 >= 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(v11, &v11[2 * (v15 >> 1)], v12, a3);
      uint64_t v18 = &v11[2 * v16];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(v11 + 2, v18 - 2, v169, a3);
      a2 = v167;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(v11 + 4, &v11[2 * v16 + 2], v168, a3);
      BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(v18 - 2, v17, &v11[2 * v16 + 2], a3);
      uint64_t v19 = *(void *)v11;
      *(void *)uint64_t v11 = *(void *)v18;
      *(void *)uint64_t v18 = v19;
      --a4;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(&v11[2 * (v15 >> 1)], v11, v12, a3);
      --a4;
      if (a5)
      {
LABEL_14:
        float v22 = v11[1];
        unint64_t v20 = *a3;
        goto LABEL_20;
      }
    }
    unint64_t v20 = *a3;
    float v21 = *(v11 - 1);
    float v22 = v11[1];
    if (vabds_f32(v21, v22) <= 10.0)
    {
      int v23 = (char)(*((unsigned char *)v11 - 8) - *v20);
      if (v23 < 0) {
        int v23 = -v23;
      }
      int v24 = (char)(*(unsigned char *)v11 - *v20);
      if (v24 < 0) {
        int v24 = -v24;
      }
      if (v23 < v24) {
        goto LABEL_20;
      }
LABEL_83:
      float v49 = *v11;
      float v50 = *(a2 - 1);
      if (vabds_f32(v22, v50) <= 10.0)
      {
        int v54 = (char)(LOBYTE(v49) - *v20);
        if (v54 < 0) {
          int v54 = -v54;
        }
        int v55 = (char)(*(unsigned char *)v12 - *v20);
        if (v55 < 0) {
          int v55 = -v55;
        }
        if (v54 < v55)
        {
LABEL_101:
          for (uint64_t i = v11 + 2; ; i += 2)
          {
            float v58 = i[1];
            if (vabds_f32(v22, v58) <= 10.0)
            {
              int v56 = (char)(LOBYTE(v49) - *v20);
              if (v56 < 0) {
                int v56 = -v56;
              }
              int v57 = (char)(*(unsigned char *)i - *v20);
              if (v57 < 0) {
                int v57 = -v57;
              }
              if (v56 < v57) {
                goto LABEL_110;
              }
            }
            else if (v58 < v22)
            {
              goto LABEL_110;
            }
          }
        }
      }
      else if (v50 < v22)
      {
        goto LABEL_101;
      }
      for (uint64_t i = v11 + 2; i < a2; i += 2)
      {
        float v53 = i[1];
        if (vabds_f32(v22, v53) <= 10.0)
        {
          int v51 = (char)(LOBYTE(v49) - *v20);
          if (v51 < 0) {
            int v51 = -v51;
          }
          int v52 = (char)(*(unsigned char *)i - *v20);
          if (v52 < 0) {
            int v52 = -v52;
          }
          if (v51 < v52) {
            break;
          }
        }
        else if (v53 < v22)
        {
          break;
        }
      }
LABEL_110:
      __int16 v59 = a2;
      if (i >= a2) {
        goto LABEL_138;
      }
      unsigned int v60 = v166;
      while (vabds_f32(v22, v50) > 10.0)
      {
        if (v50 >= v22) {
          goto LABEL_120;
        }
LABEL_117:
        float v63 = *v60;
        v60 -= 2;
        float v50 = v63;
      }
      int v61 = (char)(LOBYTE(v49) - *v20);
      if (v61 < 0) {
        int v61 = -v61;
      }
      int v62 = (char)(*((unsigned char *)v60 + 4) - *v20);
      if (v62 < 0) {
        int v62 = -v62;
      }
      if (v61 < v62) {
        goto LABEL_117;
      }
LABEL_120:
      __int16 v59 = v60 + 1;
LABEL_138:
      if (i < v59)
      {
        uint64_t v64 = *(void *)i;
        *(void *)uint64_t i = *(void *)v59;
        i += 2;
        *(void *)__int16 v59 = v64;
        unsigned int v65 = *a3;
        while (1)
        {
          float v68 = i[1];
          if (vabds_f32(v22, v68) <= 10.0)
          {
            int v66 = (char)(LOBYTE(v49) - *v65);
            if (v66 < 0) {
              int v66 = -v66;
            }
            int v67 = (char)(*(unsigned char *)i - *v65);
            if (v67 < 0) {
              int v67 = -v67;
            }
            if (v66 < v67)
            {
              do
              {
LABEL_136:
                while (1)
                {
                  v59 -= 2;
                  float v71 = v59[1];
                  if (vabds_f32(v22, v71) <= 10.0) {
                    break;
                  }
                  if (v71 >= v22) {
                    goto LABEL_138;
                  }
                }
                int v69 = (char)(LOBYTE(v49) - *v65);
                if (v69 < 0) {
                  int v69 = -v69;
                }
                int v70 = (char)(*(unsigned char *)v59 - *v65);
                if (v70 < 0) {
                  int v70 = -v70;
                }
              }
              while (v69 < v70);
              goto LABEL_138;
            }
          }
          else if (v68 < v22)
          {
            goto LABEL_136;
          }
          i += 2;
        }
      }
      BOOL v5 = i - 2 >= v11;
      BOOL v6 = i - 2 == v11;
      if (i - 2 != v11) {
        *(void *)uint64_t v11 = *((void *)i - 1);
      }
      a5 = 0;
      *(i - 2) = v49;
      *(i - 1) = v22;
    }
    else
    {
      if (v21 <= v22) {
        goto LABEL_83;
      }
LABEL_20:
      uint64_t v25 = v11 + 2;
      float v26 = *v11;
      while (1)
      {
        float v29 = v25[1];
        if (vabds_f32(v29, v22) <= 10.0) {
          break;
        }
        if (v29 <= v22) {
          goto LABEL_29;
        }
LABEL_26:
        v25 += 2;
      }
      int v27 = (char)(*(unsigned char *)v25 - *v20);
      if (v27 < 0) {
        int v27 = -v27;
      }
      int v28 = (char)(LOBYTE(v26) - *v20);
      if (v28 < 0) {
        int v28 = -v28;
      }
      if (v27 < v28) {
        goto LABEL_26;
      }
LABEL_29:
      unint64_t j = v12;
      if (v25 - 2 != v11)
      {
        while (1)
        {
          float v33 = j[1];
          if (vabds_f32(v33, v22) <= 10.0)
          {
            int v31 = (char)(*(unsigned char *)j - *v20);
            if (v31 < 0) {
              int v31 = -v31;
            }
            int v32 = (char)(LOBYTE(v26) - *v20);
            if (v32 < 0) {
              int v32 = -v32;
            }
            if (v31 < v32) {
              goto LABEL_56;
            }
          }
          else if (v33 > v22)
          {
            goto LABEL_56;
          }
          j -= 2;
        }
      }
      unint64_t j = a2;
      if (v25 < a2)
      {
        for (unint64_t j = v12; ; j -= 2)
        {
          float v37 = j[1];
          if (vabds_f32(v37, v22) <= 10.0)
          {
            int v34 = (char)(*(unsigned char *)j - *v20);
            if (v34 < 0) {
              int v34 = -v34;
            }
            int v35 = (char)(LOBYTE(v26) - *v20);
            if (v35 < 0) {
              int v35 = -v35;
            }
            if (v34 < v35 || v25 >= j) {
              break;
            }
          }
          else if (v37 > v22 || v25 >= j)
          {
            break;
          }
        }
      }
LABEL_56:
      uint64_t i = v25;
      if (v25 < j)
      {
        uint64_t i = v25;
        unint64_t v39 = (unint64_t)j;
        do
        {
          uint64_t v40 = *(void *)i;
          *(void *)uint64_t i = *(void *)v39;
          i += 2;
          *(void *)unint64_t v39 = v40;
          long long v41 = *a3;
          while (1)
          {
            float v44 = i[1];
            if (vabds_f32(v44, v22) <= 10.0) {
              break;
            }
            if (v44 <= v22) {
              goto LABEL_74;
            }
LABEL_65:
            i += 2;
          }
          int v42 = (char)(*(unsigned char *)i - *v41);
          if (v42 < 0) {
            int v42 = -v42;
          }
          int v43 = (char)(LOBYTE(v26) - *v41);
          if (v43 < 0) {
            int v43 = -v43;
          }
          if (v42 < v43) {
            goto LABEL_65;
          }
          do
          {
LABEL_74:
            while (1)
            {
              v39 -= 8;
              float v47 = *(float *)(v39 + 4);
              if (vabds_f32(v47, v22) <= 10.0) {
                break;
              }
              if (v47 > v22) {
                goto LABEL_58;
              }
            }
            int v45 = (char)(*(unsigned char *)v39 - *v41);
            if (v45 < 0) {
              int v45 = -v45;
            }
            int v46 = (char)(LOBYTE(v26) - *v41);
            if (v46 < 0) {
              int v46 = -v46;
            }
          }
          while (v45 >= v46);
LABEL_58:
          ;
        }
        while ((unint64_t)i < v39);
      }
      if (i - 2 != v11) {
        *(void *)uint64_t v11 = *((void *)i - 1);
      }
      *(i - 2) = v26;
      *(i - 1) = v22;
      if (v25 < j)
      {
LABEL_82:
        BOOL result = (float *)std::__introsort<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *,false>(v11, i - 2, a3, a4, a5 & 1);
        a5 = 0;
      }
      else
      {
        BOOL v48 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(v11, i - 2, a3);
        BOOL result = (float *)std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(i, a2, a3);
        if (result)
        {
          a2 = i - 2;
          if (v48) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v48) {
          goto LABEL_82;
        }
      }
    }
  }
  BOOL v74 = i + 2;
  BOOL v76 = i == a2 || v74 == a2;
  if (a5)
  {
    if (v76) {
      return result;
    }
    uint64_t v77 = 0;
    unsigned int v78 = i;
LABEL_169:
    __int16 v79 = v78;
    unsigned int v78 = v74;
    float v80 = v79[3];
    float v81 = v79[1];
    if (vabds_f32(v80, v81) <= 10.0)
    {
      char v82 = **a3;
      int v83 = (char)(*(unsigned char *)v74 - v82);
      if (v83 < 0) {
        int v83 = -v83;
      }
      int v84 = (char)(*(unsigned char *)v79 - v82);
      if (v84 < 0) {
        int v84 = -v84;
      }
      if (v83 >= v84) {
        goto LABEL_168;
      }
    }
    else if (v80 <= v81)
    {
      goto LABEL_168;
    }
    int v85 = *((_DWORD *)v79 + 2);
    *((void *)v79 + 1) = *(void *)v79;
    __int16 v86 = i;
    if (v79 == i) {
      goto LABEL_167;
    }
    uint64_t v87 = v77;
    while (1)
    {
      unsigned int v88 = (void *)((char *)i + v87);
      float v89 = *(float *)((char *)i + v87 - 4);
      if (vabds_f32(v80, v89) > 10.0)
      {
        if (v89 >= v80)
        {
          __int16 v86 = (float *)((char *)i + v87);
          goto LABEL_167;
        }
      }
      else
      {
        char v90 = **a3;
        int v91 = (char)(v85 - v90);
        if (v91 < 0) {
          int v91 = -v91;
        }
        int v92 = (char)(*((unsigned char *)v88 - 8) - v90);
        if (v92 < 0) {
          int v92 = -v92;
        }
        if (v91 >= v92)
        {
          __int16 v86 = v79;
LABEL_167:
          *(_DWORD *)__int16 v86 = v85;
          v86[1] = v80;
LABEL_168:
          BOOL v74 = v78 + 2;
          v77 += 8;
          if (v78 + 2 == a2) {
            return result;
          }
          goto LABEL_169;
        }
      }
      v79 -= 2;
      void *v88 = *(v88 - 1);
      v87 -= 8;
      if (!v87)
      {
        __int16 v86 = i;
        goto LABEL_167;
      }
    }
  }
  if (!v76)
  {
    while (2)
    {
      uint64_t v154 = v11;
      uint64_t v11 = v74;
      float v155 = v154[3];
      float v156 = v154[1];
      if (vabds_f32(v155, v156) <= 10.0)
      {
        char v157 = **a3;
        int v158 = (char)(*(unsigned char *)v11 - v157);
        if (v158 < 0) {
          int v158 = -v158;
        }
        int v159 = (char)(*(unsigned char *)v154 - v157);
        if (v159 < 0) {
          int v159 = -v159;
        }
        if (v158 < v159) {
          goto LABEL_291;
        }
      }
      else if (v155 > v156)
      {
LABEL_291:
        float v160 = *v11;
        do
        {
          while (1)
          {
            unint64_t v164 = v154;
            *((void *)v154 + 1) = *(void *)v154;
            v154 -= 2;
            float v165 = *(v164 - 1);
            if (vabds_f32(v155, v165) <= 10.0) {
              break;
            }
            if (v165 >= v155) {
              goto LABEL_281;
            }
          }
          char v161 = **a3;
          int v162 = (char)(LOBYTE(v160) - v161);
          if (v162 < 0) {
            int v162 = -v162;
          }
          int v163 = (char)(*((unsigned char *)v164 - 8) - v161);
          if (v163 < 0) {
            int v163 = -v163;
          }
        }
        while (v162 < v163);
LABEL_281:
        *unint64_t v164 = v160;
        v164[1] = v155;
      }
      BOOL v74 = v11 + 2;
      if (v11 + 2 == a2) {
        return result;
      }
      continue;
    }
  }
  return result;
}

float *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(float *result, float *a2, float *a3, char **a4)
{
  BOOL v4 = *a4;
  char v5 = *(unsigned char *)a2;
  float v6 = a2[1];
  float v7 = result[1];
  if (vabds_f32(v6, v7) <= 10.0)
  {
    int v9 = (char)(v5 - *v4);
    if (v9 < 0) {
      int v9 = -v9;
    }
    int v10 = (char)(*(unsigned char *)result - *v4);
    if (v10 < 0) {
      int v10 = -v10;
    }
    if (v9 >= v10) {
      goto LABEL_3;
    }
LABEL_11:
    float v11 = a3[1];
    if (vabds_f32(v11, v6) <= 10.0)
    {
      char v20 = *v4;
      int v21 = (char)(*(unsigned char *)a3 - v20);
      if (v21 < 0) {
        int v21 = -v21;
      }
      int v22 = (char)(v5 - v20);
      if (v22 < 0) {
        int v22 = -v22;
      }
      if (v21 >= v22)
      {
LABEL_13:
        uint64_t v12 = *(void *)result;
        *(void *)BOOL result = *(void *)a2;
        *(void *)a2 = v12;
        float v13 = a3[1];
        if (vabds_f32(v13, *((float *)&v12 + 1)) <= 10.0)
        {
          char v24 = **a4;
          int v25 = (char)(*(unsigned char *)a3 - v24);
          if (v25 < 0) {
            int v25 = -v25;
          }
          int v26 = (char)(v12 - v24);
          if (v26 < 0) {
            int v26 = -v26;
          }
          if (v25 >= v26) {
            return result;
          }
        }
        else if (v13 <= *((float *)&v12 + 1))
        {
          return result;
        }
        *(void *)a2 = *(void *)a3;
        *(void *)a3 = v12;
        return result;
      }
    }
    else if (v11 <= v6)
    {
      goto LABEL_13;
    }
    uint64_t v23 = *(void *)result;
    *(void *)BOOL result = *(void *)a3;
    *(void *)a3 = v23;
    return result;
  }
  if (v6 > v7) {
    goto LABEL_11;
  }
LABEL_3:
  float v8 = a3[1];
  if (vabds_f32(v8, v6) <= 10.0)
  {
    char v14 = *v4;
    int v15 = (char)(*(unsigned char *)a3 - v14);
    if (v15 < 0) {
      int v15 = -v15;
    }
    int v16 = (char)(v5 - v14);
    if (v16 < 0) {
      int v16 = -v16;
    }
    if (v15 >= v16) {
      return result;
    }
  }
  else if (v8 <= v6)
  {
    return result;
  }
  uint64_t v17 = *(void *)a2;
  *(void *)a2 = *(void *)a3;
  *(void *)a3 = v17;
  float v18 = a2[1];
  float v19 = result[1];
  if (vabds_f32(v18, v19) <= 10.0)
  {
    char v27 = **a4;
    int v28 = (char)(*(unsigned char *)a2 - v27);
    if (v28 < 0) {
      int v28 = -v28;
    }
    int v29 = (char)(*(unsigned char *)result - v27);
    if (v29 < 0) {
      int v29 = -v29;
    }
    if (v28 < v29) {
      goto LABEL_41;
    }
  }
  else if (v18 > v19)
  {
LABEL_41:
    uint64_t v30 = *(void *)result;
    *(void *)BOOL result = *(void *)a2;
    *(void *)a2 = v30;
  }
  return result;
}

float *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(float *a1, float *a2, float *a3, uint64_t a4, char **a5)
{
  BOOL result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(a1, a2, a3, a5);
  float v11 = *(float *)(a4 + 4);
  float v12 = a3[1];
  if (vabds_f32(v11, v12) <= 10.0)
  {
    char v13 = **a5;
    int v14 = (char)(*(unsigned char *)a4 - v13);
    if (v14 < 0) {
      int v14 = -v14;
    }
    int v15 = (char)(*(unsigned char *)a3 - v13);
    if (v15 < 0) {
      int v15 = -v15;
    }
    if (v14 >= v15) {
      return result;
    }
  }
  else if (v11 <= v12)
  {
    return result;
  }
  uint64_t v16 = *(void *)a3;
  *(void *)a3 = *(void *)a4;
  *(void *)a4 = v16;
  float v17 = a3[1];
  float v18 = a2[1];
  if (vabds_f32(v17, v18) <= 10.0)
  {
    char v19 = **a5;
    int v20 = (char)(*(unsigned char *)a3 - v19);
    if (v20 < 0) {
      int v20 = -v20;
    }
    int v21 = (char)(*(unsigned char *)a2 - v19);
    if (v21 < 0) {
      int v21 = -v21;
    }
    if (v20 >= v21) {
      return result;
    }
  }
  else if (v17 <= v18)
  {
    return result;
  }
  uint64_t v22 = *(void *)a2;
  *(void *)a2 = *(void *)a3;
  *(void *)a3 = v22;
  float v23 = a2[1];
  float v24 = a1[1];
  if (vabds_f32(v23, v24) > 10.0)
  {
    if (v23 <= v24) {
      return result;
    }
LABEL_25:
    uint64_t v28 = *(void *)a1;
    *(void *)a1 = *(void *)a2;
    *(void *)a2 = v28;
    return result;
  }
  char v25 = **a5;
  int v26 = (char)(*(unsigned char *)a2 - v25);
  if (v26 < 0) {
    int v26 = -v26;
  }
  int v27 = (char)(*(unsigned char *)a1 - v25);
  if (v27 < 0) {
    int v27 = -v27;
  }
  if (v26 < v27) {
    goto LABEL_25;
  }
  return result;
}

float *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *,0>(float *a1, float *a2, float *a3, uint64_t a4, uint64_t a5, char **a6)
{
  BOOL result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(a1, a2, a3, a4, a6);
  float v13 = *(float *)(a5 + 4);
  float v14 = *(float *)(a4 + 4);
  if (vabds_f32(v13, v14) <= 10.0)
  {
    char v15 = **a6;
    int v16 = (char)(*(unsigned char *)a5 - v15);
    if (v16 < 0) {
      int v16 = -v16;
    }
    int v17 = (char)(*(unsigned char *)a4 - v15);
    if (v17 < 0) {
      int v17 = -v17;
    }
    if (v16 >= v17) {
      return result;
    }
  }
  else if (v13 <= v14)
  {
    return result;
  }
  uint64_t v18 = *(void *)a4;
  *(void *)a4 = *(void *)a5;
  *(void *)a5 = v18;
  float v19 = *(float *)(a4 + 4);
  float v20 = a3[1];
  if (vabds_f32(v19, v20) <= 10.0)
  {
    char v21 = **a6;
    int v22 = (char)(*(unsigned char *)a4 - v21);
    if (v22 < 0) {
      int v22 = -v22;
    }
    int v23 = (char)(*(unsigned char *)a3 - v21);
    if (v23 < 0) {
      int v23 = -v23;
    }
    if (v22 >= v23) {
      return result;
    }
  }
  else if (v19 <= v20)
  {
    return result;
  }
  uint64_t v24 = *(void *)a3;
  *(void *)a3 = *(void *)a4;
  *(void *)a4 = v24;
  float v25 = a3[1];
  float v26 = a2[1];
  if (vabds_f32(v25, v26) <= 10.0)
  {
    char v27 = **a6;
    int v28 = (char)(*(unsigned char *)a3 - v27);
    if (v28 < 0) {
      int v28 = -v28;
    }
    int v29 = (char)(*(unsigned char *)a2 - v27);
    if (v29 < 0) {
      int v29 = -v29;
    }
    if (v28 >= v29) {
      return result;
    }
  }
  else if (v25 <= v26)
  {
    return result;
  }
  uint64_t v30 = *(void *)a2;
  *(void *)a2 = *(void *)a3;
  *(void *)a3 = v30;
  float v31 = a2[1];
  float v32 = a1[1];
  if (vabds_f32(v31, v32) > 10.0)
  {
    if (v31 <= v32) {
      return result;
    }
LABEL_33:
    uint64_t v36 = *(void *)a1;
    *(void *)a1 = *(void *)a2;
    *(void *)a2 = v36;
    return result;
  }
  char v33 = **a6;
  int v34 = (char)(*(unsigned char *)a2 - v33);
  if (v34 < 0) {
    int v34 = -v34;
  }
  int v35 = (char)(*(unsigned char *)a1 - v33);
  if (v35 < 0) {
    int v35 = -v35;
  }
  if (v34 < v35) {
    goto LABEL_33;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(float *a1, float *a2, char **a3)
{
  uint64_t v6 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      float v8 = *(a2 - 1);
      float v9 = a1[1];
      if (vabds_f32(v8, v9) > 10.0)
      {
        if (v8 <= v9) {
          return result;
        }
        goto LABEL_39;
      }
      char v27 = **a3;
      int v28 = (char)(*((unsigned char *)a2 - 8) - v27);
      if (v28 < 0) {
        int v28 = -v28;
      }
      int v29 = (char)(*(unsigned char *)a1 - v27);
      if (v29 < 0) {
        int v29 = -v29;
      }
      if (v28 < v29)
      {
LABEL_39:
        uint64_t v30 = *(void *)a1;
        *(void *)a1 = *((void *)a2 - 1);
        *((void *)a2 - 1) = v30;
        return result;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(a1, a1 + 2, a1 + 4, (uint64_t)(a2 - 2), a3);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *,0>(a1, a1 + 2, a1 + 4, (uint64_t)(a1 + 6), (uint64_t)(a2 - 2), a3);
      return 1;
    default:
      int v10 = a1 + 4;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelTransitRoute::generateTransitNodeTextPlacements(void)::$_0 &,LabelPlacementRegion *>(a1, a1 + 2, a1 + 4, a3);
      float v11 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      while (2)
      {
        float v15 = v11[1];
        float v16 = v10[1];
        if (vabds_f32(v15, v16) <= 10.0)
        {
          char v17 = **a3;
          int v18 = (char)(*(unsigned char *)v11 - v17);
          if (v18 < 0) {
            int v18 = -v18;
          }
          int v19 = (char)(*(unsigned char *)v10 - v17);
          if (v19 < 0) {
            int v19 = -v19;
          }
          if (v18 >= v19) {
            goto LABEL_9;
          }
        }
        else if (v15 <= v16)
        {
          goto LABEL_9;
        }
        int v20 = *(_DWORD *)v11;
        *(void *)float v11 = *(void *)v10;
        uint64_t v14 = (uint64_t)a1;
        if (v10 == a1) {
          goto LABEL_8;
        }
        uint64_t v21 = v12;
        while (2)
        {
          float v25 = (char *)a1 + v21;
          float v26 = *(float *)((char *)a1 + v21 + 12);
          if (vabds_f32(v15, v26) > 10.0)
          {
            if (v26 >= v15)
            {
              uint64_t v14 = (uint64_t)v10;
              goto LABEL_8;
            }
            goto LABEL_25;
          }
          char v22 = **a3;
          int v23 = (char)(v20 - v22);
          if (v23 < 0) {
            int v23 = -v23;
          }
          int v24 = (char)(v25[8] - v22);
          if (v24 < 0) {
            int v24 = -v24;
          }
          if (v23 < v24)
          {
LABEL_25:
            v10 -= 2;
            *((void *)v25 + 2) = *((void *)v25 + 1);
            v21 -= 8;
            if (v21 == -16)
            {
              uint64_t v14 = (uint64_t)a1;
              goto LABEL_8;
            }
            continue;
          }
          break;
        }
        uint64_t v14 = (uint64_t)a1 + v21 + 16;
LABEL_8:
        *(_DWORD *)uint64_t v14 = v20;
        *(float *)(v14 + 4) = v15;
        if (++v13 == 8) {
          return v11 + 2 == a2;
        }
LABEL_9:
        int v10 = v11;
        v12 += 8;
        v11 += 2;
        if (v11 != a2) {
          continue;
        }
        return 1;
      }
  }
}

unsigned __int8 *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *>(unsigned __int8 *result, unsigned __int8 *a2, unsigned __int8 *a3, _WORD *a4)
{
  unsigned int v4 = *a2;
  unsigned int v5 = *result;
  unsigned int v6 = *a3;
  if (v4 >= v5)
  {
    if (v6 < v4)
    {
      __int16 v8 = a2[1];
      *(_WORD *)a2 = *(_WORD *)a3;
      *(_WORD *)a3 = v4 | (v8 << 8);
      unsigned int v9 = *result;
      unsigned int v6 = v4;
      if (*a2 < v9)
      {
        __int16 v10 = result[1];
        *(_WORD *)BOOL result = *(_WORD *)a2;
        *(_WORD *)a2 = v9 | (v10 << 8);
        unsigned int v6 = *a3;
      }
    }
  }
  else
  {
    __int16 v7 = v5 | (result[1] << 8);
    if (v6 < v4)
    {
      *(_WORD *)BOOL result = *(_WORD *)a3;
LABEL_9:
      *(_WORD *)a3 = v7;
      unsigned int v6 = v5;
      goto LABEL_10;
    }
    *(_WORD *)BOOL result = *(_WORD *)a2;
    *(_WORD *)a2 = v7;
    unsigned int v6 = *a3;
    if (v6 < v5)
    {
      *(_WORD *)a2 = *(_WORD *)a3;
      goto LABEL_9;
    }
  }
LABEL_10:
  if (*(unsigned __int8 *)a4 < v6)
  {
    __int16 v11 = a3[1];
    *(_WORD *)a3 = *a4;
    *a4 = v6 | (v11 << 8);
    unsigned int v12 = *a2;
    if (*a3 < v12)
    {
      __int16 v13 = a2[1];
      *(_WORD *)a2 = *(_WORD *)a3;
      *(_WORD *)a3 = v12 | (v13 << 8);
      unsigned int v14 = *result;
      if (*a2 < v14)
      {
        __int16 v15 = result[1];
        *(_WORD *)BOOL result = *(_WORD *)a2;
        *(_WORD *)a2 = v14 | (v15 << 8);
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v4 = (a2 - a1) >> 1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *a1;
      if (*(a2 - 2) < v6)
      {
        __int16 v7 = a1[1];
        *(_WORD *)a1 = *((_WORD *)a2 - 1);
        *((_WORD *)a2 - 1) = v6 | (v7 << 8);
      }
      return result;
    case 3:
      unsigned int v8 = a1[2];
      unsigned int v9 = *a1;
      unsigned int v10 = *(a2 - 2);
      if (v8 >= v9)
      {
        if (v10 < v8)
        {
          __int16 v26 = a1[3];
          *((_WORD *)a1 + 1) = *((_WORD *)a2 - 1);
          *((_WORD *)a2 - 1) = v8 | (v26 << 8);
          unsigned int v27 = *a1;
          if (a1[2] < v27)
          {
            __int16 v28 = a1[1];
            *(_WORD *)a1 = *((_WORD *)a1 + 1);
            *((_WORD *)a1 + 1) = v27 | (v28 << 8);
          }
        }
      }
      else
      {
        __int16 v11 = v9 | (a1[1] << 8);
        if (v10 >= v8)
        {
          *(_WORD *)a1 = *((_WORD *)a1 + 1);
          *((_WORD *)a1 + 1) = v11;
          if (*(a2 - 2) < v9)
          {
            *((_WORD *)a1 + 1) = *((_WORD *)a2 - 1);
            *((_WORD *)a2 - 1) = v11;
          }
        }
        else
        {
          *(_WORD *)a1 = *((_WORD *)a2 - 1);
          *((_WORD *)a2 - 1) = v11;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *>(a1, a1 + 2, a1 + 4, (_WORD *)a2 - 1);
      return 1;
    case 5:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,md::LabelAngleRange *>(a1, a1 + 2, a1 + 4, (_WORD *)a1 + 3);
      unsigned int v17 = a1[6];
      if (*(a2 - 2) < v17)
      {
        __int16 v18 = a1[7];
        *((_WORD *)a1 + 3) = *((_WORD *)a2 - 1);
        *((_WORD *)a2 - 1) = v17 | (v18 << 8);
        unsigned int v19 = a1[4];
        if (a1[6] < v19)
        {
          __int16 v20 = *((_WORD *)a1 + 3);
          __int16 v21 = a1[5];
          *((_WORD *)a1 + 2) = v20;
          *((_WORD *)a1 + 3) = v19 | (v21 << 8);
          unsigned int v22 = a1[2];
          if (v22 > v20)
          {
            __int16 v23 = a1[3];
            *((_WORD *)a1 + 1) = v20;
            *((_WORD *)a1 + 2) = v22 | (v23 << 8);
            unsigned int v24 = *a1;
            if (v24 > v20)
            {
              __int16 v25 = a1[1];
              *(_WORD *)a1 = v20;
              *((_WORD *)a1 + 1) = v24 | (v25 << 8);
            }
          }
        }
      }
      return 1;
    default:
      unsigned int v12 = a1 + 4;
      unsigned int v13 = a1[4];
      unsigned int v14 = a1[2];
      unsigned int v15 = *a1;
      if (v14 >= v15)
      {
        if (v13 < v14)
        {
          __int16 v29 = *((_WORD *)a1 + 2);
          __int16 v30 = a1[3];
          *((_WORD *)a1 + 1) = v29;
          *((_WORD *)a1 + 2) = v14 | (v30 << 8);
          if (v15 > v29)
          {
            __int16 v31 = a1[1];
            *(_WORD *)a1 = v29;
            *((_WORD *)a1 + 1) = v15 | (v31 << 8);
          }
        }
      }
      else
      {
        __int16 v16 = v15 | (a1[1] << 8);
        if (v13 >= v14)
        {
          *(_WORD *)a1 = *((_WORD *)a1 + 1);
          *((_WORD *)a1 + 1) = v16;
          if (v13 >= v15) {
            goto LABEL_27;
          }
          *((_WORD *)a1 + 1) = *((_WORD *)a1 + 2);
        }
        else
        {
          *(_WORD *)a1 = *((_WORD *)a1 + 2);
        }
        *((_WORD *)a1 + 2) = v16;
      }
LABEL_27:
      float v32 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v33 = 0;
      int v34 = 0;
      break;
  }
  while (1)
  {
    unsigned int v36 = *v32;
    if (v36 < *v12)
    {
      __int16 v37 = v32[1];
      uint64_t v38 = v33;
      do
      {
        *(_WORD *)&a1[v38 + 6] = *(_WORD *)&a1[v38 + 4];
        if (v38 == -4)
        {
          int v35 = a1;
          goto LABEL_30;
        }
        unsigned int v39 = a1[v38 + 2];
        v38 -= 2;
      }
      while (v36 < v39);
      int v35 = &a1[v38 + 6];
LABEL_30:
      *(_WORD *)int v35 = v36 | (v37 << 8);
      if (++v34 == 8) {
        return v32 + 2 == a2;
      }
    }
    unsigned int v12 = v32;
    v33 += 2;
    v32 += 2;
    if (v32 == a2) {
      return 1;
    }
  }
}

void geo::_retain_ptr<VKRouteLine * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559438;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKRouteLine * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559438;

  return a1;
}

void md::LabelTransitRouteLine::generateTransitShieldFeatures(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v204 = *MEMORY[0x1E4F143B8];
  long long v202 = 0uLL;
  unsigned int v201 = 0;
  __asm { FMOV            V0.4S, #-1.0 }
  uint64_t v200 = _Q0;
  id v7 = *(id *)(a1 + 32);
  unsigned int v8 = v7;
  if (v7)
  {
    id v180 = v7;
    [v7 sections];
    unsigned int v9 = (char *)__p[0];
    unsigned int v10 = __p[1];
    if (__p[0])
    {
      __int16 v11 = __p[0];
      if (__p[1] != __p[0])
      {
        unsigned int v12 = __p[1];
        unsigned int v13 = (char *)__p[1];
        do
        {
          unsigned int v15 = (void *)*((void *)v13 - 1);
          v13 -= 8;
          unsigned int v14 = v15;
          if (v15)
          {
            _ZF = (*v14)-- == 1;
            if (_ZF)
            {
              md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v14 + 1));
              {
                operator new();
              }
              (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *(v12 - 1), 400);
              *(v12 - 1) = 0;
            }
          }
          unsigned int v12 = v13;
        }
        while (v13 != v9);
        __int16 v11 = __p[0];
      }
      __p[1] = v9;
      operator delete(v11);
    }
    if (v10 != v9)
    {
      uint64_t v172 = 0;
      unint64_t v16 = (v10 - v9) >> 3;
      if (v16 <= 1) {
        unint64_t v16 = 1;
      }
      unint64_t v164 = v16;
      float32x4_t v176 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      while (1)
      {
        [v8 sections];
        unsigned int v17 = (char *)__p[0];
        __int16 v18 = __p[1];
        uint64_t v19 = *((void *)__p[0] + v172);
        if (v19) {
          uint64_t v20 = v19 + 8;
        }
        else {
          uint64_t v20 = 0;
        }
        uint64_t v177 = v20;
        __int16 v21 = __p[0];
        if (__p[1] != __p[0])
        {
          unsigned int v22 = (char *)__p[1];
          do
          {
            unsigned int v24 = (void *)*((void *)v22 - 1);
            v22 -= 8;
            __int16 v23 = v24;
            if (v24)
            {
              _ZF = (*v23)-- == 1;
              if (_ZF)
              {
                md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v23 + 1));
                {
                  operator new();
                }
                (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 40))(mdm::Allocator::instance(void)::alloc, *(v18 - 1), 400);
                *(v18 - 1) = 0;
              }
            }
            __int16 v18 = v22;
          }
          while (v22 != v17);
          __int16 v21 = __p[0];
        }
        __p[1] = v17;
        operator delete(v21);
        id WeakRetained = objc_loadWeakRetained((id *)(v177 + 200));
        id v168 = WeakRetained;
        id v171 = [WeakRetained composedRouteSegment];
        if ([v171 type] != 6) {
          goto LABEL_235;
        }
        id v173 = v171;
        uint64_t v170 = [WeakRetained composedRouteStep];
        id v26 = *(id *)(a1 + 8);
        uint64_t v169 = objc_msgSend(v26, "stepAtIndex:", objc_msgSend(WeakRetained, "finalStepIndex"));

        uint64_t v166 = [v173 boardStep];
        long long v175 = [v169 transitLine];
        if ((unint64_t)[v173 rideOptionsCount] >= 2)
        {
          unsigned int v27 = [v166 transitLine];
          uint64_t v28 = [v27 muid];
          __int16 v29 = [v169 transitLine];
          LODWORD(v28) = v28 == [v29 muid];

          if (v28)
          {
            uint64_t v30 = [v166 transitLine];

            long long v175 = (void *)v30;
          }
        }
        __int16 v31 = (char *)operator new(0x150uLL);
        *((void *)v31 + 1) = 0;
        *((void *)v31 + 2) = 0;
        *(void *)__int16 v31 = &unk_1EF581AD0;
        *((_WORD *)v31 + 16) = 2;
        *(_OWORD *)(v31 + 40) = 0u;
        *(_OWORD *)(v31 + 56) = 0u;
        *(_OWORD *)(v31 + 72) = 0u;
        *(_OWORD *)(v31 + 88) = 0u;
        *((void *)v31 + 13) = 0x7FFFFFFF437C0000;
        v31[112] = 0;
        *((void *)v31 + 19) = 0;
        *((void *)v31 + 20) = 0;
        *((void *)v31 + 18) = 0;
        *((void *)v31 + 24) = 0;
        *((void *)v31 + 15) = 0;
        *((void *)v31 + 16) = 0;
        v31[136] = 0;
        *((void *)v31 + 3) = &unk_1EF545218;
        *((_WORD *)v31 + 100) = 0;
        *((_OWORD *)v31 + 13) = 0u;
        *((_OWORD *)v31 + 14) = 0u;
        *((_OWORD *)v31 + 15) = 0u;
        {
          operator new();
        }
        *((void *)v31 + 32) = mdm::Allocator::instance(void)::alloc;
        *((void *)v31 + 33) = 0;
        *((void *)v31 + 34) = 0;
        *((void *)v31 + 35) = 0;
        {
          operator new();
        }
        *((void *)v31 + 36) = mdm::Allocator::instance(void)::alloc;
        *((void *)v31 + 37) = 0;
        *((void *)v31 + 38) = 0;
        *((void *)v31 + 39) = 0;
        {
          operator new();
        }
        *((void *)v31 + 40) = mdm::Allocator::instance(void)::alloc;
        v31[328] = 4;
        float v32 = (std::__shared_weak_count *)*((void *)&v202 + 1);
        *(void *)&long long v202 = v31 + 24;
        *((void *)&v202 + 1) = v31;
        if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
          std::__shared_weak_count::__release_weak(v32);
        }
        int v34 = *(void **)(a3 + 8);
        unint64_t v33 = *(void *)(a3 + 16);
        if ((unint64_t)v34 < v33) {
          break;
        }
        __int16 v37 = *(void **)a3;
        uint64_t v38 = ((uint64_t)v34 - *(void *)a3) >> 4;
        unint64_t v39 = v38 + 1;
        if ((unint64_t)(v38 + 1) >> 60) {
          abort();
        }
        uint64_t v40 = v33 - (void)v37;
        if (v40 >> 3 > v39) {
          unint64_t v39 = v40 >> 3;
        }
        if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v41 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v41 = v39;
        }
        if (v41 >> 60) {
LABEL_253:
        }
          std::__throw_bad_array_new_length[abi:nn180100]();
        int v42 = (char *)operator new(16 * v41);
        int v43 = &v42[16 * v38];
        uint64_t v44 = *((void *)&v202 + 1);
        *(_OWORD *)int v43 = v202;
        if (v44)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
          __int16 v37 = *(void **)a3;
          int v34 = *(void **)(a3 + 8);
        }
        int v45 = &v42[16 * v41];
        unsigned int v36 = v43 + 16;
        if (v34 != v37)
        {
          do
          {
            long long v46 = *((_OWORD *)v34 - 1);
            v34 -= 2;
            *((_OWORD *)v43 - 1) = v46;
            v43 -= 16;
            *int v34 = 0;
            v34[1] = 0;
          }
          while (v34 != v37);
          __int16 v37 = *(void **)a3;
          float v47 = *(void **)(a3 + 8);
          *(void *)a3 = v43;
          *(void *)(a3 + 8) = v36;
          *(void *)(a3 + 16) = v45;
          if (v47 == v37)
          {
            uint64_t v48 = a3;
            if (!v37) {
              goto LABEL_70;
            }
          }
          else
          {
            do
            {
              float v49 = (std::__shared_weak_count *)*(v47 - 1);
              if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
                std::__shared_weak_count::__release_weak(v49);
              }
              v47 -= 2;
            }
            while (v47 != v37);
            uint64_t v48 = a3;
            if (!v37) {
              goto LABEL_70;
            }
          }
LABEL_68:
          operator delete(v37);
LABEL_69:
          uint64_t v48 = a3;
          goto LABEL_70;
        }
        *(void *)a3 = v43;
        *(void *)(a3 + 8) = v36;
        uint64_t v48 = a3;
        *(void *)(a3 + 16) = v45;
        if (v37) {
          goto LABEL_68;
        }
LABEL_70:
        *(void *)(v48 + 8) = v36;
        long long v199 = 0uLL;
        float v165 = [MEMORY[0x1E4F64AA8] attributesForTransitLine:v175];
        if (v165)
        {
          float v50 = (void *)[objc_alloc(MEMORY[0x1E4F645A0]) initWithGEOStyleAttributes:v165];
          int v51 = v50;
          if (v50)
          {
            [v50 featureStyleAttributesPtr];
            long long v52 = *(_OWORD *)__p;
          }
          else
          {
            long long v52 = 0uLL;
          }
          long long v199 = v52;
        }
        else
        {
          uint64_t v53 = geo::codec::Allocator::instance(0);
          uint64_t v188 = v53;
          int v54 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v53 + 16))(v53, 8, 4);
          int v55 = v54;
          __p[0] = v54;
          size_t v187 = v54 + 1;
          if (v54) {
            *int v54 = 0x10000000ALL;
          }
          __p[1] = v54 + 1;
          int v56 = operator new(0x40uLL);
          v56[1] = 0;
          v56[2] = 0;
          void *v56 = &unk_1EF57F680;
          *(void *)&long long v199 = FeatureStyleAttributes::FeatureStyleAttributes((uint64_t)(v56 + 3), (uint64_t *)__p);
          *((void *)&v199 + 1) = v56;
          if (v55) {
            (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v53 + 40))(v53, v55, 8);
          }
        }
        int v57 = [v175 system];
        MergeTransitSystemStylesWithStyle(v57, (std::__shared_weak_count **)&v199);

        {
          operator new();
        }
        uint64_t v58 = mdm::Allocator::instance(void)::alloc;
        __int16 v59 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                             + 16))(mdm::Allocator::instance(void)::alloc, 8, 4);
        unsigned int v60 = v59;
        if (v59) {
          *__int16 v59 = 0xB00000005;
        }
        uint64_t v163 = v58;
        int v61 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v58 + 16))(v58, 16, 4);
        int v62 = v61;
        if (v61) {
          v61[1] = 0x100010002;
        }
        *int v61 = *v60;
        (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v58 + 40))(v58, v60, 8);
        uint64_t v63 = 0;
        char v64 = 0;
        uint64_t v65 = v199;
        unsigned __int8 v66 = *(unsigned char *)(v199 + 33);
        unsigned __int8 v183 = v62;
        while (1)
        {
          size_t v67 = v66;
          float v68 = *(void **)v65;
          if (v66) {
            break;
          }
LABEL_85:
          v68[v67] = v62[v63];
          unsigned __int8 v66 = *(unsigned char *)(v65 + 33) + 1;
          *(unsigned char *)(v65 + 33) = v66;
          char v64 = 1;
          _ZF = v63 == 1;
          uint64_t v63 = 1;
          if (_ZF)
          {
            float v68 = *(void **)v65;
            size_t v67 = v66;
LABEL_103:
            qsort(v68, v67, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
            goto LABEL_104;
          }
        }
        if (v66 > 0x1Fu)
        {
          do
          {
            uint64_t v72 = 0;
            float v73 = (int *)v68;
            while (1)
            {
              int v74 = *v73;
              v73 += 2;
              if (v74 == LODWORD(v62[v63])) {
                break;
              }
              if (v67 == ++v72) {
                goto LABEL_97;
              }
            }
            HIDWORD(v68[v72]) = HIDWORD(v62[v63]);
LABEL_97:
            _ZF = v63 == 1;
            uint64_t v63 = 1;
          }
          while (!_ZF);
        }
        else
        {
          do
          {
            uint64_t v69 = 0;
            int v70 = (int *)v68;
            while (1)
            {
              int v71 = *v70;
              v70 += 2;
              if (v71 == LODWORD(v62[v63])) {
                break;
              }
              if (v67 == ++v69) {
                goto LABEL_85;
              }
            }
            HIDWORD(v68[v69]) = HIDWORD(v62[v63]);
            _ZF = v63 == 1;
            uint64_t v63 = 1;
          }
          while (!_ZF);
        }
        if (v64) {
          goto LABEL_103;
        }
LABEL_104:
        unsigned int v75 = [v173 transitLine];
        id v76 = [v75 name];
        uint64_t v77 = (char *)[v76 UTF8String];

        unsigned int v78 = [v173 transitSystem];
        id v79 = [v78 name];
        float v80 = (char *)[v79 UTF8String];

        float v81 = (void *)v202;
        v81[2] = [v175 muid];
        char v82 = (std::__shared_weak_count *)*((void *)&v199 + 1);
        if (*((void *)&v199 + 1))
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v199 + 1) + 8), 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit(&v82->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v83 = (std::__shared_weak_count *)v81[5];
        v81[4] = v65;
        v81[5] = v82;
        if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
          std::__shared_weak_count::__release_weak(v83);
          if (v82)
          {
LABEL_109:
            if (!atomic_fetch_add(&v82->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v82->__on_zero_shared)(v82);
              std::__shared_weak_count::__release_weak(v82);
            }
          }
        }
        else if (v82)
        {
          goto LABEL_109;
        }
        uint64_t v84 = v202;
        *(unsigned char *)(v202 + 177) = *(unsigned char *)(a2 + 468);
        *(unsigned char *)(v84 + 176) = 13;
        if (v77) {
          std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_external((void *)(v84 + 272), v77);
        }
        if (v80) {
          std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_external((void *)(v84 + 240), v80);
        }
        int v85 = [v170 routeLineArtwork];
        if ([v85 count]) {
          [v170 routeLineArtwork];
        }
        else {
        id v86 = [v173 routeLineArtwork];
        }

        long long v197 = 0u;
        long long v198 = 0u;
        long long v195 = 0u;
        long long v196 = 0u;
        obunint64_t j = v86;
        unint64_t v87 = [obj countByEnumeratingWithState:&v195 objects:v203 count:16];
        if (v87)
        {
          uint64_t v88 = 0;
          uint64_t v89 = *(void *)v196;
          uint64_t v90 = *(void *)v196;
          while (2)
          {
            if (v90 != v89) {
              objc_enumerationMutation(obj);
            }
            int v91 = [*(id *)(*((void *)&v195 + 1) + 8 * v88) shieldDataSource];
            if (!v91) {
              goto LABEL_180;
            }
            int v92 = operator new(0x58uLL);
            v92[1] = 0;
            v92[2] = 0;
            *int v92 = &unk_1EF581558;
            *(_OWORD *)(v92 + 3) = 0u;
            *(_OWORD *)(v92 + 5) = 0u;
            *(_OWORD *)(v92 + 7) = 0u;
            *(_OWORD *)(v92 + 9) = 0u;
            {
              operator new();
            }
            uint64_t v93 = mdm::Allocator::instance(void)::alloc;
            v92[8] = 0;
            v92[9] = 0;
            v92[7] = v93;
            *((_DWORD *)v92 + 20) = 0;
            __p[0] = v92 + 3;
            __p[1] = v92;
            v92[9] = [v91 shieldType];
            int64_t v94 = [v91 shieldText];
            if (v94)
            {
              unsigned int v8 = v180;
              id v182 = [v91 shieldText];
              __int16 v95 = (char *)[v182 UTF8String];
            }
            else
            {
              __int16 v95 = "";
              unsigned int v8 = v180;
            }
            std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_external(v92 + 4, v95);
            if (v94) {

            }
            int64_t v96 = [v91 shieldColorString];
            if ([v96 length])
            {
              uint64_t v97 = [v91 shieldColorString];
              float v98 = VKShieldColorsFromHexString(v97);
              float v100 = v99;
              float v102 = v101;
              unsigned int v179 = v103;
              if (v98 >= 0.04045) {
                float v178 = powf((float)(v98 * 0.94787) + 0.052133, 2.4);
              }
              else {
                float v178 = v98 * 0.077399;
              }
              if (v100 >= 0.04045) {
                float v109 = powf((float)(v100 * 0.94787) + 0.052133, 2.4);
              }
              else {
                float v109 = v100 * 0.077399;
              }
              if (v102 < 0.04045)
              {
                float v110 = v102 * 0.077399;
                goto LABEL_152;
              }
LABEL_151:
              float v174 = v109;
              float v110 = powf((float)(v102 * 0.94787) + 0.052133, 2.4);
              float v109 = v174;
              goto LABEL_152;
            }
            if ([v175 hasLineColorString])
            {
              uint64_t v97 = [v175 lineColorString];
              float v104 = VKShieldColorsFromHexString(v97);
              float v106 = v105;
              float v102 = v107;
              unsigned int v179 = v108;
              if (v104 >= 0.04045) {
                float v178 = powf((float)(v104 * 0.94787) + 0.052133, 2.4);
              }
              else {
                float v178 = v104 * 0.077399;
              }
              if (v106 >= 0.04045) {
                float v109 = powf((float)(v106 * 0.94787) + 0.052133, 2.4);
              }
              else {
                float v109 = v106 * 0.077399;
              }
              if (v102 >= 0.04045) {
                goto LABEL_151;
              }
              float v110 = v102 * 0.077399;
LABEL_152:
              v112.i64[0] = __PAIR64__(LODWORD(v109), LODWORD(v178));
              v112.i64[1] = __PAIR64__(v179, LODWORD(v110));
              char v111 = __p[0];
              int16x8_t v113 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(v112, v176));
              *(int16x4_t *)v113.i8 = vmovn_s32((int32x4_t)v113);
              *((_DWORD *)__p[0] + 14) = vmovn_s16(v113).u32[0];
            }
            else
            {
              char v111 = __p[0];
              *((_DWORD *)__p[0] + 14) = -16777216;
            }

            uint64_t v114 = (void *)v202;
            float v116 = *(char **)(v202 + 192);
            unint64_t v115 = *(void *)(v202 + 200);
            if ((unint64_t)v116 >= v115)
            {
              int v119 = *(char **)(v202 + 184);
              uint64_t v120 = (v116 - v119) >> 4;
              unint64_t v121 = v120 + 1;
              if ((unint64_t)(v120 + 1) >> 60) {
                abort();
              }
              uint64_t v122 = v115 - (void)v119;
              if (v122 >> 3 > v121) {
                unint64_t v121 = v122 >> 3;
              }
              if ((unint64_t)v122 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v123 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v123 = v121;
              }
              if (v123 >> 60) {
                goto LABEL_253;
              }
              uint64_t v124 = (char *)operator new(16 * v123);
              BOOL v125 = (atomic_ullong *)__p[1];
              uint64_t v126 = &v124[16 * v120];
              *(void *)uint64_t v126 = v111;
              *((void *)v126 + 1) = v125;
              if (v125)
              {
                atomic_fetch_add_explicit(v125 + 1, 1uLL, memory_order_relaxed);
                int v119 = (char *)v114[23];
                float v116 = (char *)v114[24];
              }
              uint64_t v127 = &v124[16 * v123];
              char v118 = v126 + 16;
              if (v116 == v119)
              {
                v114[23] = v126;
                v114[24] = v118;
                v114[25] = v127;
              }
              else
              {
                do
                {
                  long long v128 = *((_OWORD *)v116 - 1);
                  v116 -= 16;
                  *((_OWORD *)v126 - 1) = v128;
                  v126 -= 16;
                  *(void *)float v116 = 0;
                  *((void *)v116 + 1) = 0;
                }
                while (v116 != v119);
                int v119 = (char *)v114[23];
                float v129 = (char *)v114[24];
                v114[23] = v126;
                v114[24] = v118;
                v114[25] = v127;
                while (v129 != v119)
                {
                  float v130 = (std::__shared_weak_count *)*((void *)v129 - 1);
                  if (v130 && !atomic_fetch_add(&v130->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v130->__on_zero_shared)(v130);
                    std::__shared_weak_count::__release_weak(v130);
                  }
                  v129 -= 16;
                }
              }
              unsigned int v8 = v180;
              if (v119) {
                operator delete(v119);
              }
            }
            else
            {
              *(void *)float v116 = v111;
              float v117 = (atomic_ullong *)__p[1];
              *((void **)v116 + 1) = __p[1];
              if (v117) {
                atomic_fetch_add_explicit(v117 + 1, 1uLL, memory_order_relaxed);
              }
              char v118 = v116 + 16;
            }
            v114[24] = v118;
            char v131 = (std::__shared_weak_count *)__p[1];
            if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v131->__on_zero_shared)(v131);
              std::__shared_weak_count::__release_weak(v131);
            }
LABEL_180:

            if (++v88 >= v87)
            {
              unint64_t v87 = [obj countByEnumeratingWithState:&v195 objects:v203 count:16];
              if (!v87) {
                break;
              }
              uint64_t v88 = 0;
            }
            uint64_t v90 = *(void *)v196;
            continue;
          }
        }

        __p[0] = 0;
        __p[1] = 0;
        size_t v187 = 0;
        {
          operator new();
        }
        uint64_t v188 = mdm::Allocator::instance(void)::alloc;
        uint64_t v190 = 0;
        uint64_t v191 = 0;
        uint64_t v189 = 0;
        {
          operator new();
        }
        uint64_t v192 = mdm::Allocator::instance(void)::alloc;
        long long v132 = *(_OWORD *)(v177 + 168);
        long long v193 = *(_OWORD *)(v177 + 144);
        long long v194 = v132;
        uint64_t v133 = (*(uint64_t (**)(uint64_t))(*(void *)v177 + 56))(v177);
        if (v133)
        {
          uint64_t v134 = 0;
          while (2)
          {
            uint64_t v136 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v177 + 48))(v177, v134);
            uint64_t v184 = *(void *)v136;
            unsigned int v185 = *(_DWORD *)(v136 + 8);
            _ZF = *(void *)v136 == v200 && *(_DWORD *)(v136 + 8) == (unint64_t)v201;
            if (_ZF) {
              goto LABEL_191;
            }
            float v139 = (char *)__p[1];
            float v138 = v187;
            if (__p[1] < v187)
            {
              if (__p[1]) {
                *(void *)__p[1] = v184;
              }
              unint64_t v135 = v139 + 8;
              goto LABEL_190;
            }
            char v140 = __p[0];
            int64_t v141 = ((char *)__p[1] - (char *)__p[0]) >> 3;
            unint64_t v142 = v141 + 1;
            if ((unint64_t)(v141 + 1) >> 61) {
              abort();
            }
            if ((v187 - (char *)__p[0]) >> 2 > v142) {
              unint64_t v142 = (v187 - (char *)__p[0]) >> 2;
            }
            if ((unint64_t)(v187 - (char *)__p[0]) >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v143 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v143 = v142;
            }
            if (v143)
            {
              uint64_t v144 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v188 + 16))(v188, 8 * v143, 4);
              int v145 = (void *)(v144 + 8 * v141);
              int v146 = (unsigned char *)(v144 + 8 * v143);
              if (v144) {
                *int v145 = v184;
              }
              int64_t v147 = v139 - v140;
              if (v139 != v140)
              {
LABEL_209:
                unint64_t v148 = v147 - 8;
                if ((unint64_t)(v147 - 8) < 0x38)
                {
                  float v149 = v145;
                }
                else
                {
                  float v149 = v145;
                  if ((unint64_t)(v139 - (char *)v145) >= 0x20)
                  {
                    uint64_t v150 = (v148 >> 3) + 1;
                    int v151 = v145 - 2;
                    int v152 = v139 - 16;
                    uint64_t v153 = v150 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v154 = *(_OWORD *)v152;
                      *(v151 - 1) = *((_OWORD *)v152 - 1);
                      *int v151 = v154;
                      v151 -= 2;
                      v152 -= 32;
                      v153 -= 4;
                    }
                    while (v153);
                    float v149 = &v145[-(v150 & 0x3FFFFFFFFFFFFFFCLL)];
                    v139 -= 8 * (v150 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v150 == (v150 & 0x3FFFFFFFFFFFFFFCLL)) {
                      goto LABEL_220;
                    }
                  }
                }
                do
                {
                  uint64_t v155 = *((void *)v139 - 1);
                  v139 -= 8;
                  *--float v149 = v155;
                }
                while (v139 != v140);
                char v140 = __p[0];
                float v138 = v187;
LABEL_220:
                unint64_t v135 = v145 + 1;
                __p[0] = v149;
                __p[1] = v145 + 1;
                size_t v187 = v146;
                if (v140) {
                  (*(void (**)(uint64_t, unsigned char *, int64_t))(*(void *)v188 + 40))(v188, v140, v138 - v140);
                }
LABEL_190:
                __p[1] = v135;
                unsigned int v201 = v185;
                uint64_t v200 = v184;
LABEL_191:
                if (++v134 == v133) {
                  goto LABEL_222;
                }
                continue;
              }
            }
            else
            {
              int v146 = 0;
              int v145 = (void *)(8 * v141);
              int64_t v147 = (char *)__p[1] - (char *)__p[0];
              if (__p[1] != __p[0]) {
                goto LABEL_209;
              }
            }
            break;
          }
          float v149 = v145;
          char v140 = v139;
          goto LABEL_220;
        }
LABEL_222:
        uint64_t v156 = v202;
        unint64_t v157 = *(void *)(v202 + 216);
        if (v157 >= *(void *)(v202 + 224))
        {
          id WeakRetained = v168;
          uint64_t v158 = std::vector<md::LabelExternalRoadFeature::SectionInfo,geo::StdAllocator<md::LabelExternalRoadFeature::SectionInfo,mdm::Allocator>>::__emplace_back_slow_path<md::LabelExternalRoadFeature::SectionInfo const&>((uint64_t *)(v202 + 208), (uint64_t)__p);
        }
        else
        {
          id WeakRetained = v168;
          if (v157) {
            md::LabelExternalRoadFeature::SectionInfo::SectionInfo(*(void *)(v202 + 216), (uint64_t)__p);
          }
          uint64_t v158 = v157 + 96;
          *(void *)(v156 + 216) = v157 + 96;
        }
        *(void *)(v156 + 216) = v158;
        if (v189) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v192 + 40))(v192, v189, v191 - v189);
        }
        if (__p[0]) {
          (*(void (**)(uint64_t, void *, int64_t))(*(void *)v188 + 40))(v188, __p[0], v187 - (char *)__p[0]);
        }

        (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v163 + 40))(v163, v183, 16);
        int v159 = (std::__shared_weak_count *)*((void *)&v199 + 1);
        if (*((void *)&v199 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v199 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v159->__on_zero_shared)(v159);
          std::__shared_weak_count::__release_weak(v159);
        }

LABEL_235:
        if (++v172 == v164) {
          goto LABEL_249;
        }
      }
      *int v34 = v202;
      uint64_t v35 = *((void *)&v202 + 1);
      v34[1] = *((void *)&v202 + 1);
      if (v35) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v35 + 8), 1uLL, memory_order_relaxed);
      }
      unsigned int v36 = v34 + 2;
      goto LABEL_69;
    }
  }
LABEL_249:

  float v160 = (std::__shared_weak_count *)*((void *)&v202 + 1);
  if (*((void *)&v202 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v202 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v160->__on_zero_shared)(v160);
      std::__shared_weak_count::__release_weak(v160);
    }
  }
}

void sub_1A20DEE34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v37 - 256);
  _Unwind_Resume(a1);
}

uint64_t md::LabelExternalRoadFeature::SectionInfo::SectionInfo(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t v4 = *(void *)(a2 + 24);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = v4;
  unsigned int v5 = *(void **)a2;
  unsigned int v6 = *(void **)(a2 + 8);
  uint64_t v7 = (uint64_t)v6 - *(void *)a2;
  if (v7)
  {
    if (v7 < 0) {
      abort();
    }
    uint64_t v8 = v7 >> 3;
    unsigned int v9 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v4 + 16))(v4);
    *(void *)a1 = v9;
    *(void *)(a1 + 8) = v9;
    *(void *)(a1 + 16) = &v9[v8];
    do
    {
      if (v9) {
        void *v9 = *v5;
      }
      ++v5;
      ++v9;
    }
    while (v5 != v6);
    *(void *)(a1 + 8) = v9;
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  uint64_t v10 = *(void *)(a2 + 56);
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = v10;
  __int16 v11 = *(char **)(a2 + 32);
  unsigned int v12 = *(char **)(a2 + 40);
  uint64_t v13 = v12 - v11;
  if (v12 != v11)
  {
    if (v13 < 0) {
      abort();
    }
    unsigned int v14 = (_DWORD *)(*(uint64_t (**)(uint64_t, int64_t, uint64_t))(*(void *)v10 + 16))(v10, v12 - v11, 4);
    *(void *)(a1 + 32) = v14;
    *(void *)(a1 + 48) = &v14[v13 >> 2];
    do
    {
      if (v14) {
        *unsigned int v14 = *(_DWORD *)v11;
      }
      v11 += 4;
      ++v14;
    }
    while (v11 != v12);
    *(void *)(a1 + 40) = v14;
  }
  long long v15 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(a1 + 80) = v15;
  return a1;
}

void sub_1A20DF290(_Unwind_Exception *a1)
{
  gss::FeatureAttributeSet::~FeatureAttributeSet(v1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<md::LabelExternalRoadFeature::SectionInfo,geo::StdAllocator<md::LabelExternalRoadFeature::SectionInfo,mdm::Allocator>>::__emplace_back_slow_path<md::LabelExternalRoadFeature::SectionInfo const&>(uint64_t *a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 5);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x2AAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 5) > v3) {
    unint64_t v3 = 0x5555555555555556 * ((a1[2] - *a1) >> 5);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 5) >= 0x155555555555555) {
    uint64_t v6 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    uint64_t v6 = v3;
  }
  unsigned int v24 = a1 + 3;
  if (v6) {
    uint64_t v7 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 96 * v6, 8);
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = v7 + 96 * v2;
  uint64_t v22 = v8;
  *(void *)&long long v23 = v8;
  *((void *)&v23 + 1) = v7 + 96 * v6;
  if (v7)
  {
    md::LabelExternalRoadFeature::SectionInfo::SectionInfo(v8, a2);
    uint64_t v8 = v22;
    uint64_t v9 = v23;
  }
  else
  {
    uint64_t v9 = 96 * v2;
  }
  uint64_t v10 = v9 + 96;
  *(void *)&long long v23 = v9 + 96;
  uint64_t v11 = *a1;
  uint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v10;
    uint64_t v18 = a1[2];
    a1[2] = *((void *)&v23 + 1);
  }
  else
  {
    uint64_t v13 = 0;
    do
    {
      uint64_t v14 = v8 + v13;
      uint64_t v15 = v12 + v13;
      *(void *)(v14 - 96) = 0;
      *(void *)(v14 - 88) = 0;
      *(void *)(v14 - 80) = 0;
      *(void *)(v14 - 72) = *(void *)(v12 + v13 - 72);
      *(_OWORD *)(v14 - 96) = *(_OWORD *)(v12 + v13 - 96);
      *(void *)(v14 - 80) = *(void *)(v12 + v13 - 80);
      *(void *)(v15 - 96) = 0;
      *(void *)(v15 - 88) = 0;
      *(void *)(v15 - 80) = 0;
      *(void *)(v14 - 64) = 0;
      *(void *)(v14 - 56) = 0;
      *(void *)(v14 - 48) = 0;
      *(void *)(v14 - 40) = *(void *)(v12 + v13 - 40);
      *(_OWORD *)(v14 - 64) = *(_OWORD *)(v12 + v13 - 64);
      *(void *)(v14 - 48) = *(void *)(v12 + v13 - 48);
      *(void *)(v15 - 64) = 0;
      *(void *)(v15 - 56) = 0;
      *(void *)(v15 - 48) = 0;
      long long v16 = *(_OWORD *)(v12 + v13 - 16);
      *(_OWORD *)(v14 - 32) = *(_OWORD *)(v12 + v13 - 32);
      *(_OWORD *)(v14 - 16) = v16;
      v13 -= 96;
    }
    while (v12 + v13 != v11);
    uint64_t v12 = *a1;
    uint64_t v17 = a1[1];
    *a1 = v8 + v13;
    uint64_t v18 = a1[2];
    *(_OWORD *)(a1 + 1) = v23;
    uint64_t v10 = v23;
    while (v17 != v12)
    {
      uint64_t v19 = *(void *)(v17 - 64);
      if (v19)
      {
        *(void *)(v17 - 56) = v19;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v17 - 40) + 40))(*(void *)(v17 - 40), v19, *(void *)(v17 - 48) - v19);
      }
      uint64_t v20 = *(void *)(v17 - 96);
      if (v20)
      {
        *(void *)(v17 - 88) = v20;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v17 - 72) + 40))(*(void *)(v17 - 72), v20, *(void *)(v17 - 80) - v20);
      }
      v17 -= 96;
    }
  }
  if (v12) {
    (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v24 + 40))(*v24, v12, v18 - v12);
  }
  return v10;
}

void sub_1A20DF528(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<md::LabelExternalRoadFeature::SectionInfo,geo::StdAllocator<md::LabelExternalRoadFeature::SectionInfo,mdm::Allocator> &>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::LabelExternalRoadFeature::SectionInfo::~SectionInfo(md::LabelExternalRoadFeature::SectionInfo *this)
{
  uint64_t v2 = *((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 7) + 40))(*((void *)this + 7), v2, *((void *)this + 6) - v2);
  }
  uint64_t v3 = *(void *)this;
  if (*(void *)this)
  {
    *((void *)this + 1) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 3) + 40))(*((void *)this + 3), v3, *((void *)this + 2) - v3);
  }
}

uint64_t std::__split_buffer<md::LabelExternalRoadFeature::SectionInfo,geo::StdAllocator<md::LabelExternalRoadFeature::SectionInfo,mdm::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    uint64_t v4 = (uint64_t *)(i - 96);
    *(void *)(a1 + 16) = i - 96;
    uint64_t v5 = *(void *)(i - 64);
    if (v5)
    {
      *(void *)(i - 56) = v5;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(i - 40) + 40))(*(void *)(i - 40), v5, *(void *)(i - 48) - v5);
    }
    uint64_t v6 = *v4;
    if (*v4)
    {
      *(void *)(i - 88) = v6;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(i - 72) + 40))(*(void *)(i - 72), v6, *(void *)(i - 80) - v6);
    }
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

void md::LabelExternalRoadFeature::~LabelExternalRoadFeature(md::LabelExternalRoadFeature *this)
{
  md::LabelExternalRoadFeature::~LabelExternalRoadFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  std::__shared_weak_count *v10;
  uint64_t vars8;

  *(void *)this = &unk_1EF545218;
  if (*((char *)this + 295) < 0)
  {
    (*(void (**)(void, void, uint64_t))(**((void **)this + 37) + 40))(*((void *)this + 37), *((void *)this + 34), *((void *)this + 36) & 0x7FFFFFFFFFFFFFFFLL);
    if ((*((char *)this + 263) & 0x80000000) == 0)
    {
LABEL_3:
      uint64_t v2 = *((void *)this + 26);
      if (!v2) {
        goto LABEL_4;
      }
      goto LABEL_8;
    }
  }
  else if ((*((char *)this + 263) & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  (*(void (**)(void, void, uint64_t))(**((void **)this + 33) + 40))(*((void *)this + 33), *((void *)this + 30), *((void *)this + 32) & 0x7FFFFFFFFFFFFFFFLL);
  uint64_t v2 = *((void *)this + 26);
  if (!v2)
  {
LABEL_4:
    uint64_t v3 = (char *)*((void *)this + 23);
    if (!v3) {
      goto LABEL_25;
    }
    goto LABEL_17;
  }
LABEL_8:
  uint64_t v4 = *((void *)this + 27);
  uint64_t v5 = v2;
  if (v4 != v2)
  {
    do
    {
      uint64_t v6 = *(void *)(v4 - 64);
      if (v6)
      {
        *(void *)(v4 - 56) = v6;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v4 - 40) + 40))(*(void *)(v4 - 40), v6, *(void *)(v4 - 48) - v6);
      }
      uint64_t v7 = *(void *)(v4 - 96);
      if (v7)
      {
        *(void *)(v4 - 88) = v7;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v4 - 72) + 40))(*(void *)(v4 - 72), v7, *(void *)(v4 - 80) - v7);
      }
      v4 -= 96;
    }
    while (v4 != v2);
    uint64_t v5 = *((void *)this + 26);
  }
  *((void *)this + 27) = v2;
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 29) + 40))(*((void *)this + 29), v5, *((void *)this + 28) - v5);
  uint64_t v3 = (char *)*((void *)this + 23);
  if (v3)
  {
LABEL_17:
    uint64_t v8 = (char *)*((void *)this + 24);
    uint64_t v9 = v3;
    if (v8 != v3)
    {
      do
      {
        uint64_t v10 = (std::__shared_weak_count *)*((void *)v8 - 1);
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        v8 -= 16;
      }
      while (v8 != v3);
      uint64_t v9 = (char *)*((void *)this + 23);
    }
    *((void *)this + 24) = v3;
    operator delete(v9);
  }
LABEL_25:
  md::LabelExternalFeature::~LabelExternalFeature(this);
}

uint64_t std::__shared_ptr_emplace<md::LabelExternalRoadFeature>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::LabelExternalRoadFeature>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581AD0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelExternalRoadFeature>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581AD0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t altitude::anonymous namespace'::lookAtTile(uint64_t result, uint64_t a2, double *a3)
{
  *(_OWORD *)BOOL result = *(_OWORD *)a2;
  *(void *)(result + 16) = *(void *)(a2 + 16);
  double v3 = *(double *)(a2 + 8);
  double v4 = *a3 - *(double *)a2;
  double v5 = a3[1] - v3;
  double v6 = *(double *)(a2 + 16);
  double v7 = a3[2] - v6;
  double v8 = 1.0 / sqrt(v4 * v4 + v5 * v5 + v7 * v7);
  double v9 = v8 * v4;
  double v10 = v8 * v5;
  double v11 = v8 * v7;
  double v12 = 1.0 / sqrt(*(double *)a2 * *(double *)a2 + v3 * v3 + v6 * v6);
  double v13 = v12 * *(double *)a2;
  double v14 = v12 * v3;
  double v15 = -(v8 * v7 * (v12 * v3) - v10 * (v12 * v6));
  double v16 = -(v9 * (v12 * v6) - v8 * v7 * v13);
  double v17 = -(v10 * v13 - v9 * v14);
  double v18 = v15 * v15 + v16 * v16 + v17 * v17;
  if (v18 < 2.22044605e-16)
  {
    double v20 = *(double *)(a2 + 24);
    double v19 = *(double *)(a2 + 32);
    double v21 = *(double *)(a2 + 40);
    double v22 = *(double *)(a2 + 48);
    double v23 = v21 * -2.0;
    double v24 = (v20 + v20) * v19 + v22 * (v21 * -2.0);
    double v25 = v21 * -2.0 * v21 + 1.0 - (v20 + v20) * v20;
    double v26 = -(v23 * v19 - (v20 + v20) * v22);
    double v15 = -(v25 * v11 - v26 * v10);
    double v16 = -(v26 * v9 - v24 * v11);
    double v17 = -(v24 * v10 - v25 * v9);
    double v18 = v15 * v15 + v16 * v16 + v17 * v17;
  }
  double v27 = 1.0 / sqrt(v18);
  double v28 = v27 * v15;
  double v29 = v27 * v16;
  double v30 = v27 * v17;
  double v31 = -(v30 * v10 - v29 * v11);
  double v32 = -(v28 * v11 - v30 * v9);
  double v33 = -(v29 * v9 - v28 * v10);
  double v34 = -v9;
  double v35 = v28 - (v28 * v11 - v30 * v9);
  if (v35 - v11 <= 0.0)
  {
    double v41 = -(v8 * v7);
    if (v28 <= v32 || v28 <= v41)
    {
      BOOL v43 = v32 <= v41;
      double v44 = sqrt(1.0 - (v11 + v35));
      double v45 = 1.0 / (v44 + v44);
      double v46 = (v30 - v9) * v45;
      double v47 = v33 - v10;
      double v48 = v47 * v45;
      double v49 = v44 * 0.5;
      double v50 = (v29 - v31) * v45;
      double v51 = sqrt(v11 + 1.0 - v28 + v32);
      double v52 = 1.0 / (v51 + v51);
      double v53 = (v31 + v29) * v52;
      double v54 = v51 * 0.5;
      double v55 = v47 * v52;
      double v56 = (v34 - v30) * v52;
      if (v43) {
        double v37 = v46;
      }
      else {
        double v37 = v53;
      }
      if (v43) {
        double v38 = v48;
      }
      else {
        double v38 = v54;
      }
      if (v43) {
        double v39 = v49;
      }
      else {
        double v39 = v55;
      }
      if (v43) {
        double v40 = v50;
      }
      else {
        double v40 = v56;
      }
    }
    else
    {
      double v57 = sqrt(v11 + 1.0 + v28 - v32);
      double v58 = v57 + v57;
      double v37 = v57 * 0.5;
      double v59 = 1.0 / v58;
      double v38 = (v31 + v29) * v59;
      double v39 = (v30 - v9) * v59;
      double v40 = (v33 + v10) * v59;
    }
  }
  else
  {
    double v36 = 0.5 / sqrt(v35 - v11 + 1.0);
    double v37 = v36 * (v10 - (v29 * v9 - v28 * v10));
    double v38 = v36 * (v34 - v30);
    double v39 = v36 * (v29 - v31);
    double v40 = 0.25 / v36;
  }
  *(double *)(result + 24) = v37;
  *(double *)(result + 32) = v38;
  *(double *)(result + 40) = v39;
  *(double *)(result + 48) = v40;
  return result;
}

void md::FlyoverMetaTileData::~FlyoverMetaTileData(md::FlyoverMetaTileData *this)
{
  *(void *)this = &unk_1EF53B8C8;
  *((void *)this + 79) = &unk_1EF53B908;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::MapTileData::~MapTileData(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF53B8C8;
  *((void *)this + 79) = &unk_1EF53B908;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  md::MapTileData::~MapTileData(this);
}

void md::SingleGEOResourceDataRequester::createDebugNode(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    (*(void (**)(char *__return_ptr))(*(void *)v4 + 24))(v37);
    if (v37[0])
    {
      unint64_t v5 = *(void *)&v37[4];
      v37[23] = 14;
      strcpy(v37, "Download Range");
      double v6 = (char *)operator new(0x80uLL);
      v36[1] = (uint64_t)(v6 + 128);
      v36[2] = (uint64_t)(v6 + 128);
      *((void *)v6 + 1) = v5;
      *((void *)v6 + 5) = 0;
      *((void *)v6 + 6) = 0;
      *((void *)v6 + 4) = 0;
      *((void *)v6 + 9) = HIDWORD(v5);
      *((void *)v6 + 12) = 0;
      *((_DWORD *)v6 + 14) = 1;
      *((void *)v6 + 13) = 0;
      *((void *)v6 + 14) = 0;
      *((_DWORD *)v6 + 30) = 1;
      v36[0] = (uint64_t)v6;
      gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v37, v36);
      if (v6[119] < 0)
      {
        operator delete(*((void **)v6 + 12));
        if ((v6[55] & 0x80000000) == 0) {
          goto LABEL_5;
        }
      }
      else if ((v6[55] & 0x80000000) == 0)
      {
LABEL_5:
        double v7 = v6;
        goto LABEL_11;
      }
      operator delete(*((void **)v6 + 4));
      goto LABEL_5;
    }
  }
  v37[23] = 14;
  strcpy(v37, "Download Range");
  memset(&v34, 0, sizeof(v34));
  int v35 = 4;
  std::string::__assign_external(&v34, "None");
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v37, (uint64_t)v33);
  if ((SHIBYTE(v34.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 28)) {
      goto LABEL_12;
    }
    goto LABEL_8;
  }
  double v7 = (void *)v34.__r_.__value_.__r.__words[0];
LABEL_11:
  operator delete(v7);
  if (!*(unsigned char *)(a1 + 28))
  {
LABEL_12:
    v37[23] = 17;
    strcpy(v37, "Visible Range Min");
    memset(&__p, 0, sizeof(__p));
    int v26 = 4;
    std::string::__assign_external(&__p, "None");
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v37, (uint64_t)v24);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if (*(unsigned char *)(a1 + 36)) {
        goto LABEL_14;
      }
    }
    else if (*(unsigned char *)(a1 + 36))
    {
      goto LABEL_14;
    }
    goto LABEL_18;
  }
LABEL_8:
  v37[23] = 17;
  strcpy(v37, "Visible Range Min");
  uint64_t v8 = *(unsigned int *)(a1 + 32);
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  int v32 = 1;
  uint64_t v29 = 0;
  uint64_t v28 = v8;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v37, (uint64_t)v27);
  if (*(unsigned char *)(a1 + 36))
  {
LABEL_14:
    v37[23] = 17;
    strcpy(v37, "Visible Range Max");
    uint64_t v9 = *(unsigned int *)(a1 + 40);
    uint64_t v21 = 0;
    uint64_t v22 = 0;
    int v23 = 1;
    uint64_t v20 = 0;
    uint64_t v19 = v9;
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v37, (uint64_t)v18);
    goto LABEL_20;
  }
LABEL_18:
  v37[23] = 17;
  strcpy(v37, "Visible Range Max");
  memset(&v16, 0, sizeof(v16));
  int v17 = 4;
  std::string::__assign_external(&v16, "None");
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v37, (uint64_t)v15);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
LABEL_20:
  v37[23] = 17;
  strcpy(v37, "gdc::ResourceType");
  unint64_t v10 = *(unsigned __int16 *)(a1 + 24);
  if (v10 > 0x35) {
    double v11 = "<Invalid>";
  }
  else {
    double v11 = off_1E5A96820[v10];
  }
  memset(&v13, 0, sizeof(v13));
  int v14 = 4;
  std::string::__assign_external(&v13, v11);
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v37, (uint64_t)v12);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v13.__r_.__value_.__l.__data_);
  }
}

void sub_1A20E0154(_Unwind_Exception *a1)
{
  gdc::DebugTreeNode::~DebugTreeNode(v1);
  _Unwind_Resume(a1);
}

void md::SingleGEOResourceDataRequester::~SingleGEOResourceDataRequester(md::SingleGEOResourceDataRequester *this)
{
  *(void *)this = &unk_1EF54C560;
  if (*((unsigned char *)this + 36)) {
    *((unsigned char *)this + 36) = 0;
  }
  if (*((unsigned char *)this + 28)) {
    *((unsigned char *)this + 28) = 0;
  }
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF54C560;
  if (*((unsigned char *)this + 36)) {
    *((unsigned char *)this + 36) = 0;
  }
  if (*((unsigned char *)this + 28)) {
    *((unsigned char *)this + 28) = 0;
  }
}

uint64_t karo::Worker::threadMain(karo::Worker *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 80);
  if ((v1 & 1) == 0)
  {
    double v3 = (karo::Job **)((char *)this + 56);
    do
    {
      uint64_t v5 = *((void *)this + 9);
      pthread_mutex_lock(*(pthread_mutex_t **)(v5 + 16));
      uint64_t v6 = *((void *)this + 7);
      if (v6)
      {
        atomic_store(0, (unint64_t *)(v6 + 168));
        double v7 = *v3;
        pthread_mutex_lock(*((pthread_mutex_t **)*v3 + 19));
        int v8 = *((_DWORD *)v7 + 40);
        pthread_mutex_unlock(*((pthread_mutex_t **)v7 + 19));
        if (v8)
        {
          uint64_t v9 = *v3;
          pthread_mutex_lock(*(pthread_mutex_t **)(v5 + 16));
          unint64_t v10 = *(uint64_t **)(v5 + 112);
          if (!v10) {
            goto LABEL_17;
          }
          unsigned int v11 = *((_DWORD *)v9 + 5);
          double v12 = (uint64_t *)(v5 + 112);
          std::string v13 = *(void **)(v5 + 112);
          do
          {
            unsigned int v14 = *(_DWORD *)(v13[4] + 20);
            BOOL v15 = v14 >= v11;
            if (v14 >= v11) {
              std::string v16 = v13;
            }
            else {
              std::string v16 = v13 + 1;
            }
            if (v15) {
              double v12 = v13;
            }
            std::string v13 = (void *)*v16;
          }
          while (*v16);
          if (v12 != (uint64_t *)(v5 + 112) && v11 >= *(_DWORD *)(v12[4] + 20))
          {
            uint64_t v19 = (uint64_t *)v12[1];
            uint64_t v20 = v12;
            if (v19)
            {
              do
              {
                uint64_t v21 = v19;
                uint64_t v19 = (uint64_t *)*v19;
              }
              while (v19);
            }
            else
            {
              do
              {
                uint64_t v21 = (uint64_t *)v20[2];
                BOOL v22 = *v21 == (void)v20;
                uint64_t v20 = v21;
              }
              while (!v22);
            }
            if (*(uint64_t **)(v5 + 104) == v12) {
              *(void *)(v5 + 104) = v21;
            }
            --*(void *)(v5 + 120);
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v10, v12);
            int v23 = (std::__shared_weak_count *)v12[6];
            if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
              std::__shared_weak_count::__release_weak(v23);
            }
            operator delete(v12);
          }
          else
          {
LABEL_17:
            uint64_t v17 = *(void *)(v5 + 72);
            unint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((*(void *)(v5 + 80) - v17) >> 3);
            while (1)
            {
              unint64_t v18 = (v18 - 1);
              if ((v18 & 0x80000000) != 0) {
                break;
              }
              if (*(karo::Job **)(v17 + 24 * v18 + 8) == v9)
              {
                if (0xAAAAAAAAAAAAAAABLL * ((*(void *)(v5 + 80) - v17) >> 3) - 1 != v18) {
                  atomic_store(1u, (unsigned __int8 *)(v5 + 96));
                }
                karo::util::replaceIndexWithLast<karo::JobManager::QueueElement>((uint64_t *)(v5 + 72), v18);
                break;
              }
            }
          }
          atomic_store(0, (unint64_t *)v9 + 3);
          *((_DWORD *)v9 + 5) = 0;
          pthread_mutex_unlock(*(pthread_mutex_t **)(v5 + 16));
        }
        double v24 = (std::__shared_weak_count *)*((void *)this + 8);
        void *v3 = 0;
        v3[1] = 0;
        if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      unsigned __int8 v25 = atomic_load((unsigned __int8 *)(v5 + 96));
      if (v25)
      {
        do
        {
          atomic_store(0, (unsigned __int8 *)(v5 + 96));
          unint64_t v37 = *(void *)(v5 + 72);
          uint64_t v38 = v37;
          if (v37 != *(void *)(v5 + 80))
          {
            do
            {
              unsigned int v39 = atomic_load((unsigned int *)(*(void *)(v38 + 8) + 16));
              *(_DWORD *)uint64_t v38 = v39;
              v38 += 24;
            }
            while (v38 != *(void *)(v5 + 80));
            unint64_t v37 = *(void *)(v5 + 72);
          }
          unint64_t v34 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v38 - v37) >> 3));
          if (v38 == v37) {
            uint64_t v35 = 0;
          }
          else {
            uint64_t v35 = v34;
          }
          std::__introsort<std::_ClassicAlgPolicy,karo::JobManager::JobQueueLess &,karo::JobManager::QueueElement *,false>(v37, v38, v35, 1);
          unsigned __int8 v36 = atomic_load((unsigned __int8 *)(v5 + 96));
        }
        while ((v36 & 1) != 0);
      }
      uint64_t v26 = *(void *)(v5 + 80);
      while (v26 != *(void *)(v5 + 72))
      {
        uint64_t v27 = v26 - 24;
        unint64_t v28 = atomic_load((unint64_t *)(*(void *)(v26 - 16) + 168));
        v26 -= 24;
        if (!v28)
        {
          uint64_t v30 = *(void *)(v27 + 8);
          uint64_t v29 = *(void *)(v27 + 16);
          if (v29) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v31 = (std::__shared_weak_count *)*((void *)this + 8);
          *((void *)this + 7) = v30;
          *((void *)this + 8) = v29;
          if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
          atomic_store((unint64_t)this, (unint64_t *)(*(void *)(v27 + 8) + 168));
          break;
        }
      }
      if (!*v3) {
        pthread_cond_wait(*(pthread_cond_t **)(v5 + 24), *(pthread_mutex_t **)(v5 + 16));
      }
      uint64_t v32 = pthread_mutex_unlock(*(pthread_mutex_t **)(v5 + 16));
      if (*v3)
      {
        double v33 = (void *)MEMORY[0x1A6239C40](v32);
        karo::Job::step(*v3);
      }
      unsigned __int8 v4 = atomic_load((unsigned __int8 *)this + 80);
    }
    while ((v4 & 1) == 0);
  }
  return 1;
}

void karo::Worker::~Worker(karo::Worker *this)
{
  *(void *)this = &unk_1EF568148;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF568120;
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x20C4093837F09);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(*((void **)this + 3));
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;

  *(void *)this = &unk_1EF568148;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF568120;
  uint64_t v3 = *((void *)this + 2);
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x20C4093837F09);
  }
  if (*((char *)this + 47) < 0) {
    operator delete(*((void **)this + 3));
  }
}

BOOL md::MultiRectSetCompare::operator()(double *a1, double *a2)
{
  if (*(void *)a1 == *(void *)a2
    && *((void *)a1 + 1) == *((void *)a2 + 1)
    && *((void *)a1 + 2) == *((void *)a2 + 2)
    && *((void *)a1 + 3) == *((void *)a2 + 3))
  {
    return 0;
  }
  double v4 = a1[1];
  double v5 = a1[2] - *a1;
  double v6 = a1[3] - v4;
  double v7 = a2[1];
  double v8 = a2[2] - *a2;
  double v9 = a2[3] - v7;
  BOOL v10 = v6 * v5 <= v9 * v8;
  if (v6 * v5 != v9 * v8) {
    return !v10;
  }
  double v11 = *a1 + v5 * 0.5;
  double v12 = *a2 + v8 * 0.5;
  BOOL v13 = v11 < v12;
  if (v11 == v12)
  {
    double v14 = v4 + v6 * 0.5;
    double v15 = v7 + v9 * 0.5;
    BOOL v13 = v14 < v15;
    if (v14 == v15)
    {
      BOOL v10 = v5 <= v8;
      if (v5 == v8) {
        BOOL v10 = v6 <= v9;
      }
      return !v10;
    }
  }
  return v13;
}

void md::MultiRectRegion::addRect(double **a1, double *a2)
{
  double v4 = *a2;
  double v6 = (double *)(a1 + 1);
  double v5 = *a1;
  if (*a1 != (double *)(a1 + 1))
  {
    double v8 = a2[2];
    double v7 = a2[3];
    double v9 = a2[1];
    while (1)
    {
      double v10 = v5[6];
      double v11 = v5[7];
      double v13 = v5[4];
      double v12 = v5[5];
      if ((v11 - v12) * (v10 - v13) < (v7 - v9) * (v8 - v4) + -2.22044605e-16) {
        break;
      }
      if (v4 >= v13 && v8 <= v10 && v9 >= v12 && v7 <= v11) {
        return;
      }
      uint64_t v17 = (double *)*((void *)v5 + 1);
      if (v17)
      {
        do
        {
          unint64_t v18 = v17;
          uint64_t v17 = *(double **)v17;
        }
        while (v17);
      }
      else
      {
        do
        {
          unint64_t v18 = (double *)*((void *)v5 + 2);
          BOOL v34 = *(void *)v18 == (void)v5;
          double v5 = v18;
        }
        while (!v34);
      }
      double v5 = v18;
      if (v18 == v6) {
        goto LABEL_43;
      }
    }
  }
  if (v5 != v6)
  {
    do
    {
      if (v5[4] >= *a2 && v5[6] <= a2[2] && v5[5] >= a2[1] && v5[7] <= a2[3])
      {
        BOOL v22 = (double *)*((void *)v5 + 1);
        int v23 = v5;
        if (v22)
        {
          do
          {
            uint64_t v21 = v22;
            BOOL v22 = *(double **)v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            uint64_t v21 = (double *)*((void *)v23 + 2);
            BOOL v34 = *(void *)v21 == (void)v23;
            int v23 = v21;
          }
          while (!v34);
        }
        if (*a1 == v5) {
          *a1 = v21;
        }
        uint64_t v19 = (uint64_t *)a1[1];
        a1[2] = (double *)((char *)a1[2] - 1);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v19, (uint64_t *)v5);
        operator delete(v5);
      }
      else
      {
        uint64_t v20 = (double *)*((void *)v5 + 1);
        if (v20)
        {
          do
          {
            uint64_t v21 = v20;
            uint64_t v20 = *(double **)v20;
          }
          while (v20);
        }
        else
        {
          do
          {
            uint64_t v21 = (double *)*((void *)v5 + 2);
            BOOL v34 = *(void *)v21 == (void)v5;
            double v5 = v21;
          }
          while (!v34);
        }
      }
      double v5 = v21;
    }
    while (v21 != v6);
    double v4 = *a2;
  }
LABEL_43:
  double v24 = *((double *)a1 + 4);
  *((double *)a1 + 3) = fmin(v4, *((double *)a1 + 3));
  double v25 = *((double *)a1 + 6);
  *((double *)a1 + 5) = fmax(*((double *)a1 + 5), a2[2]);
  *((double *)a1 + 4) = fmin(a2[1], v24);
  *((double *)a1 + 6) = fmax(v25, a2[3]);
  uint64_t v26 = a1[1];
  if (v26)
  {
    double v27 = a2[1];
    double v28 = a2[2] - *a2;
    double v29 = a2[3] - v27;
    double v30 = v29 * v28;
    double v31 = *a2 + v28 * 0.5;
    double v32 = v27 + v29 * 0.5;
    while (1)
    {
      while (1)
      {
        double v6 = v26;
        BOOL v34 = *(void *)a2 == *((void *)v26 + 4) && *((void *)a2 + 1) == *((void *)v26 + 5);
        if (v34 && *((void *)a2 + 2) == *((void *)v26 + 6) && *((void *)a2 + 3) == *((void *)v26 + 7)) {
          goto LABEL_64;
        }
        double v37 = v26[4];
        double v36 = v26[5];
        double v38 = v26[6] - v37;
        double v39 = v26[7] - v36;
        BOOL v40 = v30 <= v39 * v38;
        if (v30 == v39 * v38) {
          break;
        }
LABEL_60:
        if (!v40) {
          goto LABEL_45;
        }
LABEL_64:
        if (*((void *)v26 + 4) == *(void *)a2
          && *((void *)v26 + 5) == *((void *)a2 + 1)
          && *((void *)v26 + 6) == *((void *)a2 + 2)
          && *((void *)v26 + 7) == *((void *)a2 + 3))
        {
          return;
        }
        double v47 = v26[4];
        double v46 = v26[5];
        double v48 = v26[6] - v47;
        double v49 = v26[7] - v46;
        BOOL v50 = v49 * v48 <= v30;
        if (v49 * v48 == v30)
        {
          double v51 = v47 + v48 * 0.5;
          BOOL v52 = v51 < v31;
          if (v51 != v31 || (v53 = v46 + v49 * 0.5, BOOL v52 = v53 < v32, v53 != v32))
          {
            if (!v52) {
              return;
            }
            goto LABEL_83;
          }
          BOOL v50 = v48 <= v28;
          if (v48 == v28) {
            BOOL v50 = v49 <= v29;
          }
        }
        if (v50) {
          return;
        }
LABEL_83:
        double v33 = (uint64_t **)(v26 + 1);
        uint64_t v26 = (double *)*((void *)v26 + 1);
        if (!v26) {
          goto LABEL_86;
        }
      }
      double v41 = v37 + v38 * 0.5;
      BOOL v42 = v31 < v41;
      if (v31 == v41)
      {
        double v43 = v36 + v39 * 0.5;
        BOOL v42 = v32 < v43;
        if (v32 == v43)
        {
          BOOL v40 = v28 <= v38;
          if (v28 == v38) {
            BOOL v40 = v29 <= v39;
          }
          goto LABEL_60;
        }
      }
      if (!v42) {
        goto LABEL_64;
      }
LABEL_45:
      uint64_t v26 = *(double **)v26;
      double v33 = (uint64_t **)v6;
      if (!*(void *)v6) {
        goto LABEL_86;
      }
    }
  }
  double v33 = (uint64_t **)v6;
LABEL_86:
  double v54 = operator new(0x40uLL);
  long long v55 = *((_OWORD *)a2 + 1);
  v54[2] = *(_OWORD *)a2;
  v54[3] = v55;
  *(void *)double v54 = 0;
  *((void *)v54 + 1) = 0;
  *((void *)v54 + 2) = v6;
  void *v33 = (uint64_t *)v54;
  double v56 = *(double **)*a1;
  if (v56)
  {
    *a1 = v56;
    double v57 = *v33;
  }
  else
  {
    double v57 = (uint64_t *)v54;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)a1[1], v57);
  a1[2] = (double *)((char *)a1[2] + 1);
}

void ggl::LandmarkFlat::LandmarkPipelineState::~LandmarkPipelineState(ggl::LandmarkFlat::LandmarkPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  double v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  double v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::LandmarkFlat::LandmarkPipelineSetup::textureIsEnabled(ggl::LandmarkFlat::LandmarkPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::LandmarkFlat::LandmarkPipelineSetup::constantDataIsEnabled(ggl::LandmarkFlat::LandmarkPipelineSetup *this, unint64_t a2)
{
  return a2 < 4;
}

void ggl::LandmarkFlat::LandmarkPipelineSetup::~LandmarkPipelineSetup(ggl::LandmarkFlat::LandmarkPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void *updateFeatureFlag(int a1, float *a2, int a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  double v6 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    v8[0] = 67109376;
    v8[1] = a1;
    __int16 v9 = 1024;
    int v10 = a3;
    _os_log_impl(&dword_1A1780000, v6, OS_LOG_TYPE_INFO, "Updating FeatureFlag:%d - %d", (uint8_t *)v8, 0xEu);
  }

  LOBYTE(v8[0]) = 0;
  BOOL result = std::__hash_table<std::__hash_value_type<md::FeatureFlag,BOOL>,std::__unordered_map_hasher<md::FeatureFlag,std::__hash_value_type<md::FeatureFlag,BOOL>,std::hash<md::FeatureFlag>,std::equal_to<md::FeatureFlag>,true>,std::__unordered_map_equal<md::FeatureFlag,std::__hash_value_type<md::FeatureFlag,BOOL>,std::equal_to<md::FeatureFlag>,std::hash<md::FeatureFlag>,true>,std::allocator<std::__hash_value_type<md::FeatureFlag,BOOL>>>::__emplace_unique_key_args<md::FeatureFlag,std::piecewise_construct_t const&,std::tuple<md::FeatureFlag&&>,std::tuple<>>(a2, 0, v8);
  *((unsigned char *)result + 17) = a3;
  return result;
}

void *___ZN2md19FeatureFlagProviderC2EPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  **(unsigned char **)(v4 + 40) = 1;
  return updateFeatureFlag(0, *(float **)(v4 + 56), a4);
}

void *___ZN2md19FeatureFlagProviderC2EPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  **(unsigned char **)(v4 + 40) = 1;
  return updateFeatureFlag(1, *(float **)(v4 + 56), a4);
}

void *___ZN2md19FeatureFlagProviderC2EPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 32);
  **(unsigned char **)(v4 + 40) = 1;
  return updateFeatureFlag(2, *(float **)(v4 + 56), a4);
}

void std::__shared_ptr_emplace<std::unordered_map<md::FeatureFlag,BOOL>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 24);
  *(void *)(a1 + 24) = 0;
  if (v4)
  {
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<std::unordered_map<md::FeatureFlag,BOOL>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58FAC8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<std::unordered_map<md::FeatureFlag,BOOL>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58FAC8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::FeatureFlagProvider::~FeatureFlagProvider(md::FeatureFlagProvider *this)
{
  uint64_t v2 = (id *)*((void *)this + 2);
  for (uint64_t i = (id *)*((void *)this + 3); v2 != i; ++v2)
  {
    id v4 = *v2;
    MapsFeature_RemoveBlockListener();
  }
  double v5 = (std::__shared_weak_count *)*((void *)this + 8);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  double v6 = (std::__shared_weak_count *)*((void *)this + 6);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  uint64_t v7 = *((void *)this + 2);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 3);
    __int16 v9 = (void *)*((void *)this + 2);
    if (v8 != v7)
    {
      do
      {
        int v10 = *(void **)(v8 - 8);
        v8 -= 8;
      }
      while (v8 != v7);
      __int16 v9 = (void *)*((void *)this + 2);
    }
    *((void *)this + 3) = v7;
    operator delete(v9);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v11) {
    std::__shared_weak_count::__release_weak(v11);
  }
}

void sub_1A20E1184(_Unwind_Exception *a1)
{
  id v4 = (std::__shared_weak_count *)v1[8];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  double v5 = (std::__shared_weak_count *)v1[6];
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = v1[2];
  if (v6)
  {
    uint64_t v8 = v1[3];
    __int16 v9 = (void *)v1[2];
    if (v8 != v6)
    {
      do
      {
        int v10 = *(void **)(v8 - 8);
        v8 -= 8;
      }
      while (v8 != v6);
      __int16 v9 = (void *)v1[2];
    }
    v1[3] = v6;
    operator delete(v9);
    uint64_t v7 = (std::__shared_weak_count *)v1[1];
    if (!v7) {
LABEL_9:
    }
      _Unwind_Resume(a1);
  }
  else
  {
    uint64_t v7 = (std::__shared_weak_count *)v1[1];
    if (!v7) {
      goto LABEL_9;
    }
  }
  std::__shared_weak_count::__release_weak(v7);
  _Unwind_Resume(a1);
}

void md::LabelAnimator::setupAnimations(uint64_t a1, int a2, unsigned char *a3)
{
  (*(void (**)(unsigned char *))(*(void *)a3 + 184))(a3);
  if (a2 == 19)
  {
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a1 + 32);
    if (v12 - v11 == -144)
    {
      while (v12 != v11)
      {
        double v14 = *(void **)(v12 - 144);
        v12 -= 144;
        double v13 = v14;
        if (v14 != *(void **)(v12 + 16)) {
          free(v13);
        }
      }
      *(void *)(a1 + 32) = v11;
    }
    else
    {
      std::vector<md::LabelAnimation,geo::StdAllocator<md::LabelAnimation,mdm::Allocator>>::__append((uint64_t *)(a1 + 24));
      uint64_t v11 = *(void *)(a1 + 32);
    }
    a3[563] = 57 * ((v11 - *(void *)(a1 + 24)) >> 4) - 1;
    operator new();
  }
  if (a2 == 18)
  {
    uint64_t v7 = *(void *)(a1 + 24);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8 - v7 == -144)
    {
      while (v8 != v7)
      {
        int v10 = *(void **)(v8 - 144);
        v8 -= 144;
        __int16 v9 = v10;
        if (v10 != *(void **)(v8 + 16)) {
          free(v9);
        }
      }
      *(void *)(a1 + 32) = v7;
    }
    else
    {
      std::vector<md::LabelAnimation,geo::StdAllocator<md::LabelAnimation,mdm::Allocator>>::__append((uint64_t *)(a1 + 24));
      uint64_t v7 = *(void *)(a1 + 32);
    }
    a3[563] = 57 * ((v7 - *(void *)(a1 + 24)) >> 4) - 1;
    operator new();
  }
  if (!*(unsigned char *)(a1 + 88))
  {
    if (*(unsigned char *)(a1 + 90))
    {
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 8) + 1192) + 52) != 2) {
        return;
      }
      *(unsigned char *)(a1 + 90) = 0;
    }
    double v15 = *(md::LabelAnimationTrack ***)(a1 + 56);
    std::string v16 = *(md::LabelAnimationTrack ***)(a1 + 64);
    if (v15 == v16) {
      goto LABEL_25;
    }
    char v17 = 0;
    do
    {
      v6.n128_u32[0] = *(_DWORD *)(a1 + 20);
      md::LabelAnimationTrack::runAnimation(*v15, v6);
      unint64_t v18 = *v15++;
      v17 |= *((unsigned char *)v18 + 40) == 0;
    }
    while (v15 != v16);
    if ((v17 & 1) == 0) {
LABEL_25:
    }
      *(unsigned char *)(a1 + 88) = 1;
  }
}

uint64_t md::LabelAnimator::setupBalloonAnimation(uint64_t result, int a2, uint64_t a3, uint64_t a4)
{
  BOOL v4 = a2 != 1;
  if (a2 == 1) {
    uint64_t v5 = a4;
  }
  else {
    uint64_t v5 = a3;
  }
  if (a2 == 1) {
    uint64_t v6 = a3;
  }
  else {
    uint64_t v6 = a4;
  }
  uint64_t v7 = *(void *)(v5 + 16);
  if (v7)
  {
    __int16 v9 = (void *)result;
    uint64_t v10 = *(void *)(v6 + 16);
    BOOL result = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 224))(v7);
    if (result == 7)
    {
      (*(void (**)(uint64_t **__return_ptr, uint64_t))(*(void *)v7 + 200))(&v14, v7);
      uint64_t v11 = *v14;
      double v15 = v14;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v17 + 40))(v17, v14, v16 - (void)v14);
      (*(void (**)(uint64_t **__return_ptr, uint64_t))(*(void *)v7 + 200))(&v14, v7);
      double v15 = v14;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v17 + 40))(v17, v14, v16 - (void)v14);
      (*(void (**)(uint64_t **__return_ptr, uint64_t))(*(void *)v7 + 200))(&v14, v7);
      double v15 = v14;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v17 + 40))(v17, v14, v16 - (void)v14);
      (*(void (**)(uint64_t **__return_ptr, uint64_t))(*(void *)v7 + 200))(&v14, v7);
      double v15 = v14;
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)v17 + 40))(v17, v14, v16 - (void)v14);
      LODWORD(v14) = 0;
      if (v10)
      {
        md::LabelAnimator::resolveParams(v9, v4, 0xAu, 0, 0);
        md::LabelAnimator::createMorphAnimation(v12, (uint64_t)v9, v10, v11, v4);
      }
      md::LabelAnimator::resolveParams(v9, a2, 0xBu, 0, 3);
      md::LabelAnimator::createMorphAnimation(v13, (uint64_t)v9, v11, 0, a2);
    }
  }
  return result;
}

void sub_1A20E1E98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *md::LabelAnimator::setupIconMorphAnimation(void *result, char a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6)
{
  if ((a2 & 1) == 0 || (a4 & 1) == 0) {
    return result;
  }
  __int16 v9 = result;
  BOOL result = (*(void *(**)(long long *__return_ptr, uint64_t))(*(void *)a3 + 200))(&v14, a3);
  uint64_t v10 = v14;
  if ((void)v14 == *((void *)&v14 + 1))
  {
    BOOL result = (*(void *(**)(uint64_t *__return_ptr, uint64_t))(*(void *)a5 + 200))(&v19, a5);
    BOOL v11 = v19 != v20;
    if (v19)
    {
      uint64_t v20 = v19;
      BOOL result = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v22 + 40))(v22, v19, v21 - v19);
    }
    uint64_t v10 = v14;
    if (!(void)v14) {
      goto LABEL_6;
    }
  }
  else
  {
    BOOL v11 = 1;
    if (!(void)v14) {
      goto LABEL_6;
    }
  }
  *((void *)&v14 + 1) = v10;
  BOOL result = (void *)(*(uint64_t (**)(void, uint64_t, void))(**((void **)&v15 + 1) + 40))(*((void *)&v15 + 1), v10, v15 - v10);
LABEL_6:
  if (!v11)
  {
    __n128 v12 = md::LabelAnimator::resolveParams(v9, 0, 4u, 0, 0);
    long long v15 = v12[1];
    long long v16 = v12[2];
    long long v17 = v12[3];
    if ((a6 & 0xFF00000000) != 0)
    {
      __n128 v13 = (__n128)*v12;
      long long v14 = *v12;
      LODWORD(v15) = a6;
      LODWORD(v16) = a6;
      LODWORD(v17) = a6;
      int v18 = a6;
    }
    else
    {
      int v18 = *((_DWORD *)v12 + 16);
      __n128 v13 = (__n128)*v12;
      long long v14 = *v12;
    }
    md::LabelAnimator::createMorphAnimation(v13, (uint64_t)v9, a3, a5, 0);
  }
  return result;
}

void sub_1A20E210C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (a9) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 - a9);
  }
  _Unwind_Resume(exception_object);
}

void md::LabelAnimator::setupMKBalloonPickAnimations(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (*(void *)(a3 + 16)) {
      operator new();
    }
  }
  else if (*(void *)(a4 + 16))
  {
    operator new();
  }
}

void *md::LabelAnimator::setupTextMorphAnimation(void *result, uint64_t a2, uint64_t a3, int a4, int a5, uint64_t a6)
{
  if (!(a2 | a3)) {
    return result;
  }
  int v6 = a6;
  BOOL v11 = result;
  int v12 = BYTE4(a6);
  if (a2)
  {
    BOOL result = (*(void *(**)(uint64_t *__return_ptr, uint64_t))(*(void *)a2 + 200))(&v29, a2);
    uint64_t v13 = v29;
    BOOL v14 = v29 != v30;
    if (v29 != v30 || a3 == 0)
    {
      if (!v29) {
        goto LABEL_10;
      }
      goto LABEL_9;
    }
  }
  else if (!a3)
  {
    return result;
  }
  BOOL result = (*(void *(**)(long long *__return_ptr, uint64_t))(*(void *)a3 + 200))(&v24, a3);
  long long v21 = v24;
  BOOL v14 = (void)v24 != *((void *)&v24 + 1);
  if ((void)v24)
  {
    *((void *)&v24 + 1) = v24;
    BOOL result = (void *)(*(uint64_t (**)(void, void, void))(**((void **)&v25 + 1) + 40))(*((void *)&v25 + 1), v21, v25 - v21);
  }
  if (a2)
  {
    uint64_t v13 = v29;
    if (!v29)
    {
LABEL_10:
      if (!v14)
      {
        if (a5 == 1) {
          char v16 = 5;
        }
        else {
          char v16 = 4;
        }
        if (a4 == 1) {
          char v17 = v16;
        }
        else {
          char v17 = 3;
        }
        if (!a3) {
          char v17 = 1;
        }
        if (a2) {
          unsigned __int8 v18 = v17;
        }
        else {
          unsigned __int8 v18 = 1;
        }
        uint64_t v19 = md::LabelAnimator::resolveParams(v11, 0, v18, 0, 1);
        long long v25 = v19[1];
        long long v26 = v19[2];
        long long v27 = v19[3];
        if (v12)
        {
          __n128 v20 = (__n128)*v19;
          long long v24 = *v19;
          LODWORD(v25) = v6;
          LODWORD(v26) = v6;
          LODWORD(v27) = v6;
          int v28 = v6;
        }
        else
        {
          int v28 = *((_DWORD *)v19 + 16);
          __n128 v20 = (__n128)*v19;
          long long v24 = *v19;
        }
        md::LabelAnimator::createMorphAnimation(v20, (uint64_t)v11, a2, a3, 0);
      }
      return result;
    }
LABEL_9:
    uint64_t v30 = v13;
    BOOL result = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v32 + 40))(v32, v13, v31 - v13);
    goto LABEL_10;
  }
  if ((void)v21 == *((void *)&v21 + 1))
  {
    uint64_t v22 = md::LabelAnimator::resolveParams(v11, 1, 1u, 0, 1);
    long long v25 = v22[1];
    long long v26 = v22[2];
    long long v27 = v22[3];
    if (v12)
    {
      __n128 v23 = (__n128)*v22;
      long long v24 = *v22;
      LODWORD(v25) = v6;
      LODWORD(v26) = v6;
      LODWORD(v27) = v6;
      int v28 = v6;
    }
    else
    {
      int v28 = *((_DWORD *)v22 + 16);
      __n128 v23 = (__n128)*v22;
      long long v24 = *v22;
    }
    md::LabelAnimator::createMorphAnimation(v23, (uint64_t)v11, a3, 0, 1);
  }
  return result;
}

void sub_1A20E27E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (v24)
  {
    if (a21) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a24 + 40))(a24, a21, a23 - a21);
    }
  }
  _Unwind_Resume(exception_object);
}

float nextRandomNumber(void)
{
  {
    std::random_device::random_device[abi:nn180100]();
    __cxa_atexit(MEMORY[0x1E4FBA228], &nextRandomNumber(void)::randomDevice, &dword_1A1780000);
  }
  {
    unsigned int v8 = MEMORY[0x1A6238DF0](&nextRandomNumber(void)::randomDevice);
    unsigned int v9 = v8 + ((v8 / 0x7FFFFFFF) | ((v8 / 0x7FFFFFFF) << 31));
    if (v9 <= 1) {
      unsigned int v9 = 1;
    }
    nextRandomNumber(void)::randomEngine = v9;
  }
  v0 = (float *)&unk_1E957D000;
  {
    v0 = (float *)&unk_1E957D000;
    if (v10)
    {
      nextRandomNumber(void)::generator = 1065353216;
      v0 = (float *)&unk_1E957D000;
    }
  }
  float v1 = v0[716];
  unsigned int v2 = 48271 * (nextRandomNumber(void)::randomEngine % 0xADC8u);
  unsigned int v3 = 3399 * (nextRandomNumber(void)::randomEngine / 0xADC8u);
  BOOL v4 = v2 >= v3;
  unsigned int v5 = v2 - v3;
  if (v4) {
    int v6 = 0;
  }
  else {
    int v6 = 0x7FFFFFFF;
  }
  nextRandomNumber(void)::randomEngine = v6 + v5;
  return (float)(v1 * 4.6566e-10) * (float)(v6 + v5 - 1);
}

void sub_1A20E29AC(_Unwind_Exception *a1)
{
}

void std::random_device::random_device[abi:nn180100]()
{
  *((unsigned char *)&__token.__r_.__value_.__s + 23) = 12;
  strcpy((char *)&__token, "/dev/urandom");
  std::random_device::random_device((std::random_device *)&nextRandomNumber(void)::randomDevice, &__token);
  if (SHIBYTE(__token.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__token.__r_.__value_.__l.__data_);
  }
}

void sub_1A20E2A40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void non-virtual thunk to'ggl::TexturedAnimatedRibbon::BaseMesh::~BaseMesh(ggl::TexturedAnimatedRibbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::TexturedAnimatedRibbon::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::TexturedAnimatedRibbon::BaseMesh *)((char *)this - 16));
}

void ggl::TexturedAnimatedRibbon::BaseMesh::~BaseMesh(ggl::TexturedAnimatedRibbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::TexturedAnimatedRibbon::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::TexturedAnimatedRibbon::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::TexturedAnimatedRibbon::BasePipelineState::~BasePipelineState(ggl::TexturedAnimatedRibbon::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  BOOL v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  BOOL v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::TexturedAnimatedRibbon::BasePipelineSetup::textureIsEnabled(ggl::TexturedAnimatedRibbon::BasePipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::TexturedAnimatedRibbon::BasePipelineSetup::constantDataIsEnabled(ggl::TexturedAnimatedRibbon::BasePipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::TexturedAnimatedRibbon::BasePipelineSetup::~BasePipelineSetup(ggl::TexturedAnimatedRibbon::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::Glyph::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::Glyph::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Glyph::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::Glyph::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584F18;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::Glyph::DefaultVbo>,geo::StdAllocator<ggl::VertexDataTyped<ggl::Glyph::DefaultVbo>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584F18;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::Glyph::DefaultMesh::~DefaultMesh(ggl::Glyph::DefaultMesh *this)
{
  ggl::Mesh::~Mesh((ggl::Glyph::DefaultMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Glyph::DefaultMesh *)((char *)this - 16));
}

void ggl::Glyph::DefaultMesh::~DefaultMesh(ggl::Glyph::DefaultMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::Glyph::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::Glyph::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void md::realistic::RoadRenderLayer::setActive(md::realistic::RoadRenderLayer *this, int a2)
{
  *((unsigned char *)this + 32) = a2;
  atomic_store(a2, (unsigned __int8 *)(*((void *)this + 28) + 224));
  uint64_t v2 = *((void *)this + 30);
  if (a2) {
    *(unsigned char *)(v2 + 136) = 1;
  }
  else {
    altitude::RoadRequestManager::disable((pthread_mutex_t **)v2);
  }
}

void md::realistic::RoadRenderLayer::layout(md::realistic::RoadRenderLayer *this, const md::LayoutContext *a2)
{
  BOOL v4 = *(md::PassList **)(*((void *)this + 5) + 24);
  uint64_t v5 = *(void *)(*((void *)a2 + 92) + 16);
  uint64_t v6 = mach_absolute_time();
  uint64_t v7 = *((void *)this + 5);
  uint64_t v8 = *(void *)(v7 + 144);
  uint64_t v9 = *(unsigned int *)(*(void *)(v7 + 136) + 88);
  float32x4_t v10 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v5 + 376)), *(float64x2_t *)(v5 + 392));
  float32x4_t v11 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v5 + 408)), *(float64x2_t *)(v5 + 424));
  float32x4_t v12 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v5 + 440)), *(float64x2_t *)(v5 + 456));
  float32x4_t v13 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v5 + 472)), *(float64x2_t *)(v5 + 488));
  BOOL v14 = (void *)*((void *)this + 24);
  long long v15 = (std::__shared_weak_count *)*((void *)this + 25);
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v16 = v14[1];
  char v17 = (float32x4_t *)v14[9];
  *char v17 = v10;
  v17[1] = v11;
  void v17[2] = v12;
  v17[3] = v13;
  if (v14[8] > v16) {
    unint64_t v16 = v14[8];
  }
  v14[7] = 0;
  v14[8] = v16;
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  unsigned __int8 v18 = (uint64_t *)(*(uint64_t (**)(void))(**((void **)this + 27) + 56))(*((void *)this + 27));
  uint64_t v19 = *v18;
  uint64_t v20 = v18[1];
  while (v19 != v20)
  {
    uint64_t v21 = *(void *)(*(void *)v19 + 336);
    if (v21) {
      (*(void (**)(uint64_t, const md::LayoutContext *, uint64_t, void, uint64_t, uint64_t))(*(void *)v21 + 80))(v21, a2, v5, *(void *)(*((void *)a2 + 92) + 24), v9, v8);
    }
    v19 += 8;
  }
  uint64_t v22 = (uint64_t *)(*(uint64_t (**)(void))(**((void **)this + 27) + 56))(*((void *)this + 27));
  uint64_t v25 = *v22;
  uint64_t v26 = v22[1];
  while (v25 != v26)
  {
    long long v27 = *(void **)(*(void *)v25 + 336);
    if (v27) {
      altitude::RoadTileComponent::collectRenderItems(v27, v23, v4, v24, 2, *(md::RealisticCommandBufferSelector **)(*((void *)this + 5) + 120));
    }
    v25 += 8;
  }
  if (*((unsigned char *)this + 280))
  {
    int v28 = (void *)*((void *)v4 + 1);
    uint64_t v29 = v28[3];
    uint64_t v30 = v28[4];
    uint64_t v31 = v30 - v29;
    if (v30 == v29) {
      goto LABEL_27;
    }
    uint64_t v32 = 0;
    unint64_t v33 = v31 >> 3;
    while (1)
    {
      BOOL v34 = *(unsigned __int8 **)(v29 + 8 * v32);
      if (*v34 == *((unsigned __int8 *)this + 272))
      {
        unint64_t v35 = *((void *)v34 + 1);
        uint64_t v36 = v28[15];
        if (v35 < (v28[16] - v36) >> 3) {
          break;
        }
      }
      if (++v32 >= v33) {
        goto LABEL_27;
      }
    }
    uint64_t v37 = *(void *)(v36 + 8 * v35);
    if (!v37)
    {
LABEL_27:
      uint64_t v38 = 0;
      uint64_t v39 = *((void *)this + 23);
      if (!v39) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v38 = *(void *)(*(void *)(v37 + 24) + 8 * *((unsigned __int8 *)this + 273));
      uint64_t v39 = *((void *)this + 23);
      if (!v39) {
LABEL_28:
      }
        operator new();
    }
    ggl::CommandBuffer::pushRenderItem(v38, *(void *)(**(void **)(v39 + 48) + 184));
  }
  uint64_t v40 = 0;
  double v41 = (void *)*((void *)v4 + 1);
  while (1)
  {
    BOOL v42 = *(unsigned __int8 **)(v41[3] + 8 * v40);
    if (*v42 == *((unsigned __int8 *)this + 274))
    {
      unint64_t v43 = *((void *)v42 + 1);
      uint64_t v44 = v41[15];
      if (v43 < (v41[16] - v44) >> 3) {
        break;
      }
    }
    ++v40;
  }
  uint64_t v45 = *(void *)(*(void *)(*(void *)(v44 + 8 * v43) + 24) + 8 * *((unsigned __int8 *)this + 275));
  unint64_t v46 = *(void *)(v45 + 72);
  double v47 = *(uint64_t **)(v45 + 80);
  unint64_t v48 = 126 - 2 * __clz((uint64_t)((uint64_t)v47 - v46) >> 3);
  if (v47 == (uint64_t *)v46) {
    uint64_t v49 = 0;
  }
  else {
    uint64_t v49 = v48;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v46, v47, v49, 1);
  uint64_t v50 = 0;
  double v51 = (void *)*((void *)v4 + 1);
  while (1)
  {
    BOOL v52 = *(unsigned __int8 **)(v51[3] + 8 * v50);
    if (*v52 == *((unsigned __int8 *)this + 276))
    {
      unint64_t v53 = *((void *)v52 + 1);
      uint64_t v54 = v51[15];
      if (v53 < (v51[16] - v54) >> 3) {
        break;
      }
    }
    ++v50;
  }
  uint64_t v55 = *(void *)(*(void *)(*(void *)(v54 + 8 * v53) + 24) + 8 * *((unsigned __int8 *)this + 277));
  unint64_t v56 = *(void *)(v55 + 72);
  double v57 = *(uint64_t **)(v55 + 80);
  unint64_t v58 = 126 - 2 * __clz((uint64_t)((uint64_t)v57 - v56) >> 3);
  if (v57 == (uint64_t *)v56) {
    uint64_t v59 = 0;
  }
  else {
    uint64_t v59 = v58;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v56, v57, v59, 1);
  uint64_t v60 = 0;
  int v61 = (void *)*((void *)v4 + 1);
  while (1)
  {
    int v62 = *(unsigned __int8 **)(v61[3] + 8 * v60);
    if (*v62 == *((unsigned __int8 *)this + 278))
    {
      unint64_t v63 = *((void *)v62 + 1);
      uint64_t v64 = v61[15];
      if (v63 < (v61[16] - v64) >> 3) {
        break;
      }
    }
    ++v60;
  }
  uint64_t v65 = *(void *)(*(void *)(*(void *)(v64 + 8 * v63) + 24) + 8 * *((unsigned __int8 *)this + 279));
  unint64_t v66 = *(void *)(v65 + 72);
  size_t v67 = *(uint64_t **)(v65 + 80);
  unint64_t v68 = 126 - 2 * __clz((uint64_t)((uint64_t)v67 - v66) >> 3);
  if (v67 == (uint64_t *)v66) {
    uint64_t v69 = 0;
  }
  else {
    uint64_t v69 = v68;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v66, v67, v69, 1);
  uint64_t v70 = mach_absolute_time();
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 104), v70 - v6);
}

void sub_1A20E3F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va4, a3);
  va_start(va3, a3);
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v12 = va_arg(va3, void);
  uint64_t v14 = va_arg(va3, void);
  uint64_t v15 = va_arg(va3, void);
  uint64_t v16 = va_arg(va3, void);
  uint64_t v17 = va_arg(va3, void);
  uint64_t v18 = va_arg(va3, void);
  va_copy(va4, va3);
  uint64_t v19 = va_arg(va4, void);
  uint64_t v21 = va_arg(va4, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v3 - 120);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v3 - 104);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va3);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)va4);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v3 - 136);
  uint64_t v5 = mach_absolute_time();
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 104), v5 - a3);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<ggl::StenciledAlphaClear::ClearPipelineSetup *,std::shared_ptr<ggl::PipelineSetup>::__shared_ptr_default_delete<ggl::PipelineSetup,ggl::StenciledAlphaClear::ClearPipelineSetup>,std::allocator<ggl::StenciledAlphaClear::ClearPipelineSetup>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<ggl::StenciledAlphaClear::ClearPipelineSetup *,std::shared_ptr<ggl::PipelineSetup>::__shared_ptr_default_delete<ggl::PipelineSetup,ggl::StenciledAlphaClear::ClearPipelineSetup>,std::allocator<ggl::StenciledAlphaClear::ClearPipelineSetup>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::realistic::RoadRenderLayer::~RoadRenderLayer(md::realistic::RoadRenderLayer *this)
{
  md::realistic::RoadRenderLayer::~RoadRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  std::__shared_weak_count *v14;
  void *v15;

  *(void *)this = &unk_1EF5546A0;
  uint64_t v2 = *((void *)this + 23);
  if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    *((void *)this + 23) = 0;
  }
  uint64_t v3 = *((void *)this + 7);
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  BOOL v4 = *((void *)this + 8);
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 10);
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 9);
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *((void *)this + 31);
  *((void *)this + 31) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = *((void *)this + 30);
  *((void *)this + 30) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  float32x4_t v10 = *((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *((void *)this + 28);
  *((void *)this + 28) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v12)
  {
    float32x4_t v13 = std::__hash_table<std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,std::__unordered_map_hasher<md::DashTextureCache::Key,std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,md::DashTextureCache::KeyHasher,std::equal_to<md::DashTextureCache::Key>,true>,std::__unordered_map_equal<md::DashTextureCache::Key,std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,std::equal_to<md::DashTextureCache::Key>,md::DashTextureCache::KeyHasher,true>,std::allocator<std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>>>::~__hash_table(v12);
    MEMORY[0x1A6239270](v13, 0x10A0C408EF24B1CLL);
  }
  uint64_t v14 = (std::__shared_weak_count *)*((void *)this + 25);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  md::realistic::RoadRenderLayer::RoadModelPipelineStates::~RoadModelPipelineStates((md::realistic::RoadRenderLayer *)((char *)this + 88));
  *(void *)this = &unk_1EF530C60;
  uint64_t v15 = (void *)*((void *)this + 1);
  if (v15)
  {
    *((void *)this + 2) = v15;
    operator delete(v15);
  }
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverBorderRibbon::DefaultPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverBorderRibbon::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588210;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverBorderRibbon::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588210;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverRoadStrokeProcedural::DefaultPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverRoadStrokeProcedural::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588B08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverRoadStrokeProcedural::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588B08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverRoadStrokeTextured::DefaultPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverRoadStrokeTextured::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588980;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverRoadStrokeTextured::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588980;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverRoadFillProcedural::DefaultPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverRoadFillProcedural::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588948;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverRoadFillProcedural::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588948;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FlyoverRoadFillTextured::DefaultPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FlyoverRoadFillTextured::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5887F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FlyoverRoadFillTextured::DefaultPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5887F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::realistic::RoadRenderLayer::RoadRenderLayer(md::realistic::RoadRenderLayer *this, md::realistic::RealisticRenderer *a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  v3[0] = vext_s8(*(int8x8_t *)(*(void *)(*((void *)a2 + 15) + 8) + 12), *(int8x8_t *)(*(void *)(*((void *)a2 + 15) + 8) + 12), 6uLL);
  md::realistic::RealisticRenderLayer::RealisticRenderLayer((uint64_t)this, 2, (uint64_t)a2, v3, 4);
  *(void *)this = &unk_1EF5546A0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((unsigned char *)this + 48) = 0;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((void *)this + 25) = 0;
  operator new();
}

void sub_1A20E80AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, md::realistic::RoadRenderLayer::RoadModelPipelineStates *a9)
{
  if (*(char *)(v11 - 201) < 0) {
    operator delete(*(void **)(v11 - 224));
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  float32x4_t v13 = (std::__shared_weak_count *)v9[33];
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = v9[31];
  v9[31] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = v9[30];
  v9[30] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = v9[29];
  v9[29] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = v9[28];
  v9[28] = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t v18 = v9[26];
  v9[26] = 0;
  if (v18)
  {
    uint64_t v19 = std::__hash_table<std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,std::__unordered_map_hasher<md::DashTextureCache::Key,std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,md::DashTextureCache::KeyHasher,std::equal_to<md::DashTextureCache::Key>,true>,std::__unordered_map_equal<md::DashTextureCache::Key,std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,std::equal_to<md::DashTextureCache::Key>,md::DashTextureCache::KeyHasher,true>,std::allocator<std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>>>::~__hash_table(v18);
    MEMORY[0x1A6239270](v19, 0x10A0C408EF24B1CLL);
  }
  uint64_t v20 = (std::__shared_weak_count *)v9[25];
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  md::realistic::RoadRenderLayer::RoadModelPipelineStates::~RoadModelPipelineStates(a9);
  void *v9 = &unk_1EF530C60;
  uint64_t v21 = (void *)v9[1];
  if (!v21) {
    _Unwind_Resume(a1);
  }
  v9[2] = v21;
  operator delete(v21);
  _Unwind_Resume(a1);
}

void ggl::TexturedInnerShadowRibbon::PipelineState::~PipelineState(ggl::TexturedInnerShadowRibbon::PipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::TexturedInnerShadowRibbon::PipelineSetup::textureIsEnabled(ggl::TexturedInnerShadowRibbon::PipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

BOOL ggl::TexturedInnerShadowRibbon::PipelineSetup::constantDataIsEnabled(ggl::TexturedInnerShadowRibbon::PipelineSetup *this, unint64_t a2)
{
  return a2 < 5;
}

void ggl::TexturedInnerShadowRibbon::PipelineSetup::~PipelineSetup(ggl::TexturedInnerShadowRibbon::PipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void sub_1A20E894C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A20E8FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A20E920C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VKAnnotationTrackingCameraController;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

uint64_t karo::graphics::CullingNode::cull(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)(result + 80))
  {
    uint64_t v3 = result;
    uint64_t v4 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 64) + 24))(*(void *)(result + 64), result, 0xFFFFFFFFLL);
    uint64_t result = (*(uint64_t (**)(void, uint64_t))(**(void **)(v3 + 72) + 24))(*(void *)(v3 + 72), v3);
    uint64_t v6 = *(uint64_t **)(v3 + 40);
    uint64_t v5 = *(uint64_t **)(v3 + 48);
    if (v6 != v5)
    {
      uint64_t v7 = result;
      do
      {
        uint64_t v8 = *v6++;
        uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v8 + 32))(v8, v4, v7, a2);
      }
      while (v6 != v5);
    }
  }
  return result;
}

uint64_t karo::graphics::CullingNode::cull(uint64_t this)
{
  if (!*(unsigned char *)(this + 80)) {
    return this;
  }
  float v1 = (void *)this;
  uint64_t v2 = *(void *)(this + 64);
  if (v2)
  {
    uint64_t v3 = (*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)v2 + 24))(v2, v1, 0xFFFFFFFFLL);
    this = v1[9];
    if (this)
    {
LABEL_4:
      this = (*(uint64_t (**)(uint64_t, void *))(*(void *)this + 24))(this, v1);
      uint64_t v4 = this;
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = 0;
    this = v1[9];
    if (this) {
      goto LABEL_4;
    }
  }
  uint64_t v4 = 0;
LABEL_7:
  uint64_t v6 = (uint64_t *)v1[5];
  for (uint64_t i = (uint64_t *)v1[6];
        v6 != i;
        this = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 24))(v7, v3, v4))
  {
    uint64_t v7 = *v6++;
  }
  return this;
}

void karo::graphics::CullingNode::~CullingNode(karo::graphics::CullingNode *this)
{
  *(void *)this = &unk_1EF5681F8;
  *((void *)this + 8) = 0;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;

  *(void *)this = &unk_1EF5681F8;
  *((void *)this + 8) = 0;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 6) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

void md::DebugRenderLayer::renderTriangulatedLines(uint64_t a1, md::LayoutContext *a2, double *a3, _DWORD *a4, uint64_t *a5, uint64_t a6, uint64_t *a7, float a8)
{
  float32x4_t v13 = (void *)*((void *)a2 + 1);
  int8x8_t v14 = (int8x8_t)v13[1];
  if (!*(void *)&v14) {
    goto LABEL_24;
  }
  uint8x8_t v15 = (uint8x8_t)vcnt_s8(v14);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] > 1uLL)
  {
    uint64_t v16 = 0x1AF456233693CD46;
    if (*(void *)&v14 <= 0x1AF456233693CD46uLL) {
      uint64_t v16 = 0x1AF456233693CD46uLL % *(void *)&v14;
    }
  }
  else
  {
    uint64_t v16 = (*(void *)&v14 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v17 = *(void **)(*v13 + 8 * v16);
  if (!v17) {
    goto LABEL_24;
  }
  uint64_t v18 = (void *)*v17;
  if (!v18) {
    goto LABEL_24;
  }
  if (v15.u32[0] < 2uLL)
  {
    uint64_t v19 = *(void *)&v14 - 1;
    while (1)
    {
      uint64_t v21 = v18[1];
      if (v21 == 0x1AF456233693CD46)
      {
        if (v18[2] == 0x1AF456233693CD46) {
          goto LABEL_22;
        }
      }
      else if ((v21 & v19) != v16)
      {
        goto LABEL_24;
      }
      uint64_t v18 = (void *)*v18;
      if (!v18) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v20 = v18[1];
    if (v20 == 0x1AF456233693CD46) {
      break;
    }
    if (v20 >= *(void *)&v14) {
      v20 %= *(void *)&v14;
    }
    if (v20 != v16) {
      goto LABEL_24;
    }
LABEL_11:
    uint64_t v18 = (void *)*v18;
    if (!v18) {
      goto LABEL_24;
    }
  }
  if (v18[2] != 0x1AF456233693CD46) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v22 = v18[5];
  if (*(void *)(v22 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v177 = *(void *)(v22 + 32);
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v177 = 0;
LABEL_25:
  uint64_t v23 = *(void *)(*(void *)(a1 + 48) + 104);
  uint64_t v24 = *(void *)(v23 + 8);
  if (v24 == *(void *)v23)
  {
    uint64_t v35 = *(void *)(v23 + 88);
    if (!v35)
    {
LABEL_201:
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_202;
    }
    uint64_t v25 = (*(uint64_t (**)(uint64_t))(*(void *)v35 + 48))(v35);
    uint64_t v26 = *(uint64_t **)(v23 + 40);
    unint64_t v36 = *(void *)(v23 + 48);
    if ((unint64_t)v26 < v36)
    {
LABEL_37:
      if (v26) {
        uint64_t *v26 = v25;
      }
      uint64_t v37 = v26 + 1;
      goto LABEL_74;
    }
    uint64_t v38 = *(void *)(v23 + 32);
    uint64_t v39 = ((uint64_t)v26 - v38) >> 3;
    unint64_t v30 = v39 + 1;
    if ((unint64_t)(v39 + 1) >> 61) {
LABEL_203:
    }
      abort();
    uint64_t v40 = v36 - v38;
    if (v40 >> 2 > v30) {
      unint64_t v30 = v40 >> 2;
    }
    if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v30)
    {
      uint64_t v41 = 8 * v30;
      uint64_t v42 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v23 + 56) + 16))(*(void *)(v23 + 56), 8 * v30, 8);
      BOOL v34 = (uint64_t *)(v42 + 8 * v39);
      unint64_t v30 = v42 + v41;
      if (v42) {
        *BOOL v34 = v25;
      }
    }
    else
    {
      BOOL v34 = (uint64_t *)(8 * v39);
    }
    uint64_t v37 = v34 + 1;
    uint64_t v52 = *(void *)(v23 + 32);
    uint64_t v43 = *(void *)(v23 + 40);
    if (v43 == v52) {
      goto LABEL_72;
    }
    unint64_t v53 = v43 - v52 - 8;
    if (v53 < 0x38)
    {
      uint64_t v55 = *(void *)(v23 + 40);
    }
    else if ((unint64_t)(v43 - (void)v34) < 0x20)
    {
      uint64_t v55 = *(void *)(v23 + 40);
    }
    else
    {
      uint64_t v54 = (v53 >> 3) + 1;
      uint64_t v55 = v43 - 8 * (v54 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v56 = v34 - 2;
      double v57 = (long long *)(v43 - 16);
      uint64_t v58 = v54 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v59 = *v57;
        *((_OWORD *)v56 - 1) = *(v57 - 1);
        *(_OWORD *)unint64_t v56 = v59;
        v56 -= 4;
        v57 -= 2;
        v58 -= 4;
      }
      while (v58);
      v34 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
      if (v54 == (v54 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_71;
      }
    }
    do
    {
      uint64_t v61 = *(void *)(v55 - 8);
      v55 -= 8;
      *--BOOL v34 = v61;
    }
    while (v55 != v52);
LABEL_71:
    uint64_t v43 = *(void *)(v23 + 32);
    goto LABEL_72;
  }
  uint64_t v25 = *(void *)(v24 - 8);
  *(void *)(v23 + 8) = v24 - 8;
  uint64_t v26 = *(uint64_t **)(v23 + 40);
  unint64_t v27 = *(void *)(v23 + 48);
  if ((unint64_t)v26 < v27) {
    goto LABEL_37;
  }
  uint64_t v28 = *(void *)(v23 + 32);
  uint64_t v29 = ((uint64_t)v26 - v28) >> 3;
  unint64_t v30 = v29 + 1;
  if ((unint64_t)(v29 + 1) >> 61) {
    goto LABEL_203;
  }
  uint64_t v31 = v27 - v28;
  if (v31 >> 2 > v30) {
    unint64_t v30 = v31 >> 2;
  }
  if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v30)
  {
    uint64_t v32 = 8 * v30;
    uint64_t v33 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v23 + 56) + 16))(*(void *)(v23 + 56), 8 * v30, 8);
    BOOL v34 = (uint64_t *)(v33 + 8 * v29);
    unint64_t v30 = v33 + v32;
    if (v33) {
      *BOOL v34 = v25;
    }
  }
  else
  {
    BOOL v34 = (uint64_t *)(8 * v29);
  }
  uint64_t v37 = v34 + 1;
  uint64_t v44 = *(void *)(v23 + 32);
  uint64_t v43 = *(void *)(v23 + 40);
  if (v43 != v44)
  {
    unint64_t v45 = v43 - v44 - 8;
    if (v45 < 0x38)
    {
      uint64_t v47 = *(void *)(v23 + 40);
    }
    else if ((unint64_t)(v43 - (void)v34) < 0x20)
    {
      uint64_t v47 = *(void *)(v23 + 40);
    }
    else
    {
      uint64_t v46 = (v45 >> 3) + 1;
      uint64_t v47 = v43 - 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v48 = v34 - 2;
      uint64_t v49 = (long long *)(v43 - 16);
      uint64_t v50 = v46 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v51 = *v49;
        *((_OWORD *)v48 - 1) = *(v49 - 1);
        *(_OWORD *)unint64_t v48 = v51;
        v48 -= 4;
        v49 -= 2;
        v50 -= 4;
      }
      while (v50);
      v34 -= v46 & 0x3FFFFFFFFFFFFFFCLL;
      if (v46 == (v46 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_71;
      }
    }
    do
    {
      uint64_t v60 = *(void *)(v47 - 8);
      v47 -= 8;
      *--BOOL v34 = v60;
    }
    while (v47 != v44);
    goto LABEL_71;
  }
LABEL_72:
  *(void *)(v23 + 32) = v34;
  *(void *)(v23 + 40) = v37;
  uint64_t v62 = *(void *)(v23 + 48);
  *(void *)(v23 + 48) = v30;
  if (v43) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v23 + 56) + 40))(*(void *)(v23 + 56), v43, v62 - v43);
  }
LABEL_74:
  *(void *)(v23 + 40) = v37;
  long long v175 = a4;
  float32x4_t v176 = a2;
  *(void *)&v180[0].f64[0] = v25;
  uint64_t v63 = *(void *)(v23 + 120);
  if (!v63) {
    goto LABEL_201;
  }
  uint64_t v64 = a1;
  (*(void (**)(uint64_t, float64x2_t *))(*(void *)v63 + 48))(v63, v180);
  uint64_t v65 = *a5;
  uint64_t v66 = a5[1];
  uint64_t v67 = v66 - *a5;
  unint64_t v68 = 0xAAAAAAAAAAAAAAACLL * (v67 >> 3);
  uint64_t v69 = **(void **)(v25 + 64);
  unint64_t v70 = *(void *)(v69 + 8) * v68;
  uint64_t v71 = *(void *)(v69 + 72);
  unint64_t v72 = *(void *)(v69 + 80) - v71;
  if (v70 != v72)
  {
    if (v70 <= v72)
    {
      if (v70 < v72) {
        *(void *)(v69 + 80) = v71 + v70;
      }
    }
    else
    {
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v69 + 72, v70 - v72);
    }
    float v73 = *(std::__shared_weak_count **)(v69 + 32);
    *(void *)(v69 + 24) = 0;
    *(void *)(v69 + 32) = 0;
    if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
      std::__shared_weak_count::__release_weak(v73);
    }
    *(void *)(v69 + 120) = 0;
    *(_DWORD *)(v69 + 112) = 0;
    uint64_t v74 = *(void *)(v69 + 80) - *(void *)(v69 + 72);
    *(void *)(v69 + 40) = 0;
    *(void *)(v69 + 48) = v74;
    *(void *)(v69 + 56) = 0;
    *(void *)(v69 + 64) = v74;
    uint64_t v69 = **(void **)(v25 + 64);
    unint64_t v70 = *(void *)(v69 + 8) * v68;
  }
  long long v188 = 0uLL;
  *(void *)&long long v75 = 0;
  *((void *)&v75 + 1) = v69;
  if (v70) {
    uint64_t v76 = *(void *)(v69 + 72);
  }
  else {
    uint64_t v76 = 0;
  }
  long long v188 = v75;
  unint64_t v189 = 0;
  unint64_t v190 = v70;
  uint64_t v192 = v76;
  __int16 v191 = 1;
  uint64_t v77 = (std::__shared_weak_count *)operator new(0xF8uLL);
  v77->__shared_owners_ = 0;
  v77->__shared_weak_owners_ = 0;
  v77->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D28;
  uint64_t v78 = ggl::BufferData::BufferData((uint64_t)&v77[1], 2, 1, 0, 6, v67 >> 2);
  LODWORD(v77[10].__vftable) = 0;
  v77[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B630;
  v77[1].__shared_owners_ = 2;
  v77[9].__shared_owners_ = (uint64_t)&unk_1EF55B650;
  v77[9].__shared_weak_owners_ = (uint64_t)"DebugLineIndexData";
  uint64_t v186 = v78;
  size_t v187 = v77;
  long long v181 = 0uLL;
  *(void *)&long long v82 = 0;
  *((void *)&v82 + 1) = v78;
  if (v66 == v65) {
    int v83 = 0;
  }
  else {
    int v83 = v77[4].__vftable;
  }
  long long v181 = v82;
  unint64_t v182 = 0;
  uint64_t v183 = 4 * (v67 >> 3);
  unsigned int v185 = v83;
  __int16 v184 = 1;
  atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v77->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v84 = *(std::__shared_weak_count **)(v25 + 104);
  *(void *)(v25 + 96) = v78;
  *(void *)(v25 + 104) = v77;
  if (v84 && !atomic_fetch_add(&v84->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v84->__on_zero_shared)(v84);
    std::__shared_weak_count::__release_weak(v84);
  }
  if (!atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
    std::__shared_weak_count::__release_weak(v77);
  }
  uint64_t v85 = *a5;
  uint64_t v86 = a5[1];
  uint64_t v87 = v86 - *a5;
  if (v86 != *a5)
  {
    uint64_t v88 = 0;
    unint64_t v89 = v87 / 24;
    uint64_t v90 = v185;
    if (v89 <= 1) {
      unint64_t v89 = 1;
    }
    uint64_t v91 = v192 + 64;
    unsigned int v92 = 5;
    do
    {
      v80.i32[0] = *(_DWORD *)(v85 + 12);
      float v93 = *(float *)(v85 + 16);
      v81.f32[0] = 1.0 / sqrtf((float)(v80.f32[0] * v80.f32[0]) + (float)(v93 * v93));
      float v94 = v81.f32[0] * v80.f32[0];
      float v95 = v81.f32[0] * v93;
      float v96 = -(float)(v81.f32[0] * v93);
      *(_DWORD *)(v91 - 64) = *(_DWORD *)v85;
      *(_DWORD *)(v91 - 60) = *(_DWORD *)(v85 + 4);
      *(_DWORD *)(v91 - 56) = *(_DWORD *)(v85 + 8);
      *(float *)(v91 - 48) = v96;
      *(float *)(v91 - 44) = v81.f32[0] * v80.f32[0];
      *(_DWORD *)(v91 - 40) = 0;
      *(_DWORD *)(v91 - 32) = *(_DWORD *)v85;
      *(_DWORD *)(v91 - 28) = *(_DWORD *)(v85 + 4);
      *(_DWORD *)(v91 - 24) = *(_DWORD *)(v85 + 8);
      v79.f32[0] = -(float)(v81.f32[0] * v80.f32[0]);
      *(float *)(v91 - 16) = v95;
      *(_DWORD *)(v91 - 12) = v79.i32[0];
      *(_DWORD *)(v91 - 8) = 0x80000000;
      v80.i64[0] = *(void *)v85;
      v80.i32[2] = *(_DWORD *)(v85 + 8);
      v81.i64[0] = *(void *)(v85 + 12);
      v81.i32[2] = *(_DWORD *)(v85 + 20);
      float32x4_t v80 = vaddq_f32(v81, v80);
      *(_DWORD *)(v91 + 8) = v80.i32[2];
      *(void *)uint64_t v91 = v80.i64[0];
      *(float *)(v91 + 16) = v95;
      *(_DWORD *)(v91 + 20) = v79.i32[0];
      *(_DWORD *)(v91 + 24) = 0x80000000;
      v79.i64[0] = *(void *)v85;
      v79.i32[2] = *(_DWORD *)(v85 + 8);
      v80.i64[0] = *(void *)(v85 + 12);
      v80.i32[2] = *(_DWORD *)(v85 + 20);
      float32x4_t v79 = vaddq_f32(v80, v79);
      *(_DWORD *)(v91 + 40) = v79.i32[2];
      *(void *)(v91 + 32) = v79.i64[0];
      *(float *)(v91 + 48) = v96;
      *(float *)(v91 + 52) = v94;
      *(_DWORD *)(v91 + 56) = 0;
      *((_WORD *)v90 + v92 - 5) = v88;
      *((_WORD *)v90 + v92 - 4) = v88 + 1;
      *((_WORD *)v90 + v92 - 3) = v88 + 2;
      *((_WORD *)v90 + v92 - 2) = v88;
      *((_WORD *)v90 + v92 - 1) = v88 + 2;
      *((_WORD *)&v90->~__shared_weak_count + v92) = v88 + 3;
      v92 += 6;
      v88 += 4;
      v85 += 24;
      v91 += 128;
      --v89;
    }
    while (v89);
  }
  uint64_t v97 = *(void *)(*(void *)(v64 + 48) + 120);
  uint64_t v98 = *(void *)(v97 + 8);
  if (v98 == *(void *)v97)
  {
    uint64_t v110 = *(void *)(v97 + 88);
    if (v110)
    {
      uint64_t v99 = (*(uint64_t (**)(uint64_t))(*(void *)v110 + 48))(v110);
      float v100 = *(uint64_t **)(v97 + 40);
      unint64_t v111 = *(void *)(v97 + 48);
      if ((unint64_t)v100 < v111) {
        goto LABEL_113;
      }
      uint64_t v113 = *(void *)(v97 + 32);
      uint64_t v114 = ((uint64_t)v100 - v113) >> 3;
      unint64_t v115 = v114 + 1;
      if ((unint64_t)(v114 + 1) >> 61) {
LABEL_204:
      }
        abort();
      uint64_t v116 = v111 - v113;
      if (v116 >> 2 > v115) {
        unint64_t v115 = v116 >> 2;
      }
      if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v117 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v117 = v115;
      }
      if (v117)
      {
        uint64_t v118 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v97 + 56) + 16))(*(void *)(v97 + 56), 8 * v117, 8);
        unsigned int v108 = (uint64_t *)(v118 + 8 * v114);
        uint64_t v109 = v118 + 8 * v117;
        if (v118) {
          uint64_t *v108 = v99;
        }
      }
      else
      {
        uint64_t v109 = 0;
        unsigned int v108 = (uint64_t *)(8 * v114);
      }
      float32x4_t v112 = v108 + 1;
      uint64_t v128 = *(void *)(v97 + 32);
      uint64_t v119 = *(void *)(v97 + 40);
      if (v119 == v128) {
        goto LABEL_149;
      }
      unint64_t v129 = v119 - v128 - 8;
      if (v129 < 0x38)
      {
        uint64_t v131 = *(void *)(v97 + 40);
      }
      else if ((unint64_t)(v119 - (void)v108) < 0x20)
      {
        uint64_t v131 = *(void *)(v97 + 40);
      }
      else
      {
        uint64_t v130 = (v129 >> 3) + 1;
        uint64_t v131 = v119 - 8 * (v130 & 0x3FFFFFFFFFFFFFFCLL);
        long long v132 = v108 - 2;
        uint64_t v133 = (long long *)(v119 - 16);
        uint64_t v134 = v130 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v135 = *v133;
          *((_OWORD *)v132 - 1) = *(v133 - 1);
          *(_OWORD *)long long v132 = v135;
          v132 -= 4;
          v133 -= 2;
          v134 -= 4;
        }
        while (v134);
        v108 -= v130 & 0x3FFFFFFFFFFFFFFCLL;
        if (v130 == (v130 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_148;
        }
      }
      do
      {
        uint64_t v137 = *(void *)(v131 - 8);
        v131 -= 8;
        *--unsigned int v108 = v137;
      }
      while (v131 != v128);
LABEL_148:
      uint64_t v119 = *(void *)(v97 + 32);
      goto LABEL_149;
    }
LABEL_202:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
    return;
  }
  uint64_t v99 = *(void *)(v98 - 8);
  *(void *)(v97 + 8) = v98 - 8;
  float v100 = *(uint64_t **)(v97 + 40);
  unint64_t v101 = *(void *)(v97 + 48);
  if ((unint64_t)v100 < v101)
  {
LABEL_113:
    if (v100) {
      *float v100 = v99;
    }
    float32x4_t v112 = v100 + 1;
    goto LABEL_151;
  }
  uint64_t v102 = *(void *)(v97 + 32);
  uint64_t v103 = ((uint64_t)v100 - v102) >> 3;
  unint64_t v104 = v103 + 1;
  if ((unint64_t)(v103 + 1) >> 61) {
    goto LABEL_204;
  }
  uint64_t v105 = v101 - v102;
  if (v105 >> 2 > v104) {
    unint64_t v104 = v105 >> 2;
  }
  if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v106 = v104;
  }
  if (v106)
  {
    uint64_t v107 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v97 + 56) + 16))(*(void *)(v97 + 56), 8 * v106, 8);
    unsigned int v108 = (uint64_t *)(v107 + 8 * v103);
    uint64_t v109 = v107 + 8 * v106;
    if (v107) {
      uint64_t *v108 = v99;
    }
  }
  else
  {
    uint64_t v109 = 0;
    unsigned int v108 = (uint64_t *)(8 * v103);
  }
  float32x4_t v112 = v108 + 1;
  uint64_t v120 = *(void *)(v97 + 32);
  uint64_t v119 = *(void *)(v97 + 40);
  if (v119 != v120)
  {
    unint64_t v121 = v119 - v120 - 8;
    if (v121 < 0x38)
    {
      uint64_t v123 = *(void *)(v97 + 40);
    }
    else if ((unint64_t)(v119 - (void)v108) < 0x20)
    {
      uint64_t v123 = *(void *)(v97 + 40);
    }
    else
    {
      uint64_t v122 = (v121 >> 3) + 1;
      uint64_t v123 = v119 - 8 * (v122 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v124 = v108 - 2;
      BOOL v125 = (long long *)(v119 - 16);
      uint64_t v126 = v122 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v127 = *v125;
        *((_OWORD *)v124 - 1) = *(v125 - 1);
        *(_OWORD *)uint64_t v124 = v127;
        v124 -= 4;
        v125 -= 2;
        v126 -= 4;
      }
      while (v126);
      v108 -= v122 & 0x3FFFFFFFFFFFFFFCLL;
      if (v122 == (v122 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_148;
      }
    }
    do
    {
      uint64_t v136 = *(void *)(v123 - 8);
      v123 -= 8;
      *--unsigned int v108 = v136;
    }
    while (v123 != v120);
    goto LABEL_148;
  }
LABEL_149:
  *(void *)(v97 + 32) = v108;
  *(void *)(v97 + 40) = v112;
  uint64_t v138 = *(void *)(v97 + 48);
  *(void *)(v97 + 48) = v109;
  if (v119) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v97 + 56) + 40))(*(void *)(v97 + 56), v119, v138 - v119);
  }
LABEL_151:
  *(void *)(v97 + 40) = v112;
  *(void *)&v180[0].f64[0] = v99;
  uint64_t v139 = *(void *)(v97 + 120);
  if (!v139) {
    goto LABEL_202;
  }
  (*(void (**)(uint64_t, float64x2_t *))(*(void *)v139 + 48))(v139, v180);
  gm::operator*<double,4,4,4>(v180[0].f64, (double *)(v177 + 808), a3);
  float32x4_t v140 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v180[2]), v180[3]);
  float32x4_t v141 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v180[4]), v180[5]);
  float32x4_t v142 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v180[6]), v180[7]);
  uint64_t v143 = *(void **)(v99 + 64);
  uint64_t v144 = (void *)v143[2];
  unint64_t v145 = v144[1];
  int v146 = (float32x4_t *)v144[9];
  float32x4_t *v146 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v180[0]), v180[1]);
  v146[1] = v140;
  v146[2] = v141;
  v146[3] = v142;
  if (v144[8] > v145) {
    unint64_t v145 = v144[8];
  }
  v144[7] = 0;
  v144[8] = v145;
  v143[5] = 0;
  uint64_t v147 = *a7;
  v143[4] = *a7;
  uint64_t v148 = *(void *)(v99 + 160);
  uint64_t v149 = a7[1];
  if (v149) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v149 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v150 = *(std::__shared_weak_count **)(v148 + 40);
  *(void *)(v148 + 32) = v147;
  *(void *)(v148 + 40) = v149;
  if (v150 && !atomic_fetch_add(&v150->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v150->__on_zero_shared)(v150);
    std::__shared_weak_count::__release_weak(v150);
  }
  int v151 = **(void ***)(v99 + 64);
  unint64_t v152 = v151[1];
  uint64_t v153 = v151[9];
  *(_DWORD *)uint64_t v153 = *v175;
  *(_DWORD *)(v153 + 4) = v175[1];
  *(_DWORD *)(v153 + 8) = v175[2];
  *(_DWORD *)(v153 + 12) = v175[3];
  unint64_t v154 = v151[8];
  if (v154 <= v152) {
    unint64_t v154 = v152;
  }
  v151[7] = 0;
  *(float *)(v153 + 20) = a8;
  if (v154 > v152) {
    unint64_t v152 = v154;
  }
  v151[8] = v152;
  uint64_t v155 = (float64x2_t *)md::LayoutContext::frameState(v176);
  uint64_t v156 = *(void *)(*(void *)(v99 + 64) + 48);
  unint64_t v157 = *(void *)(v156 + 8);
  **(float32x2_t **)(v156 + 72) = vcvt_f32_f64(v155[31]);
  if (*(void *)(v156 + 64) > v157) {
    unint64_t v157 = *(void *)(v156 + 64);
  }
  *(void *)(v156 + 56) = 0;
  *(void *)(v156 + 64) = v157;
  uint64_t v158 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(v64 + 48) + 160));
  v158[8] = v25;
  v158[4] = v99;
  v158[3] = *(void *)(*(void *)(v64 + 48) + 176);
  ggl::CommandBuffer::pushRenderItem(a6, (uint64_t)v158);
  if (v185)
  {
    unint64_t v160 = v182;
    unint64_t v159 = v183;
    if (v183 != v182)
    {
      char v161 = (void *)*((void *)&v181 + 1);
      int v162 = v184;
      int v163 = HIBYTE(v184);
      if ((void)v181 && *(unsigned char *)(*((void *)&v181 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v181 + 64))();
      }
      if (v162 && !v163)
      {
        unint64_t v165 = v161[7];
        unint64_t v164 = v161[8];
        if (v164 == v165) {
          unint64_t v165 = v161[10] - v161[9];
        }
        if (v160 < v165) {
          unint64_t v165 = v160;
        }
        if (v164 <= v159) {
          unint64_t v164 = v159;
        }
        if (v164 == v165) {
          unint64_t v164 = v165 + v161[10] - v161[9];
        }
        v161[7] = v165;
        v161[8] = v164;
      }
    }
  }
  uint64_t v166 = v187;
  if (v187 && !atomic_fetch_add(&v187->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v166->__on_zero_shared)(v166);
    std::__shared_weak_count::__release_weak(v166);
  }
  if (v192)
  {
    unint64_t v168 = v189;
    unint64_t v167 = v190;
    if (v190 != v189)
    {
      uint64_t v169 = (void *)*((void *)&v188 + 1);
      int v170 = v191;
      int v171 = HIBYTE(v191);
      if ((void)v188 && *(unsigned char *)(*((void *)&v188 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v188 + 64))();
      }
      if (v170 && !v171)
      {
        unint64_t v173 = v169[7];
        unint64_t v172 = v169[8];
        if (v172 == v173) {
          unint64_t v173 = v169[10] - v169[9];
        }
        if (v168 < v173) {
          unint64_t v173 = v168;
        }
        if (v172 <= v167) {
          unint64_t v172 = v167;
        }
        if (v172 == v173) {
          unint64_t v172 = v173 + v169[10] - v169[9];
        }
        v169[7] = v173;
        v169[8] = v172;
      }
    }
  }
}

void sub_1A20EA4A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a31);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v31 - 176);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)(v31 - 160));
  _Unwind_Resume(a1);
}

uint64_t md::DebugRenderLayer::renderLines(uint64_t a1, void *a2, double *a3, _DWORD *a4, uint64_t *a5, uint64_t a6, void *a7)
{
  uint64_t v12 = a1;
  int8x8_t v13 = (int8x8_t)a2[1];
  if (!*(void *)&v13) {
    goto LABEL_24;
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v13);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    uint64_t v15 = 0x1AF456233693CD46;
    if (*(void *)&v13 <= 0x1AF456233693CD46uLL) {
      uint64_t v15 = 0x1AF456233693CD46uLL % *(void *)&v13;
    }
  }
  else
  {
    uint64_t v15 = (*(void *)&v13 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v16 = *(void **)(*a2 + 8 * v15);
  if (!v16) {
    goto LABEL_24;
  }
  uint64_t v17 = (void *)*v16;
  if (!v17) {
    goto LABEL_24;
  }
  if (v14.u32[0] < 2uLL)
  {
    uint64_t v18 = *(void *)&v13 - 1;
    while (1)
    {
      uint64_t v20 = v17[1];
      if (v20 == 0x1AF456233693CD46)
      {
        if (v17[2] == 0x1AF456233693CD46) {
          goto LABEL_22;
        }
      }
      else if ((v20 & v18) != v15)
      {
        goto LABEL_24;
      }
      uint64_t v17 = (void *)*v17;
      if (!v17) {
        goto LABEL_24;
      }
    }
  }
  while (1)
  {
    unint64_t v19 = v17[1];
    if (v19 == 0x1AF456233693CD46) {
      break;
    }
    if (v19 >= *(void *)&v13) {
      v19 %= *(void *)&v13;
    }
    if (v19 != v15) {
      goto LABEL_24;
    }
LABEL_11:
    uint64_t v17 = (void *)*v17;
    if (!v17) {
      goto LABEL_24;
    }
  }
  if (v17[2] != 0x1AF456233693CD46) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v21 = v17[5];
  if (*(void *)(v21 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v22 = *(void *)(v21 + 32);
    goto LABEL_25;
  }
LABEL_24:
  uint64_t v22 = 0;
LABEL_25:
  uint64_t v23 = ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::pop(*(void *)(*(void *)(a1 + 48) + 96));
  uint64_t v25 = 0x5555555555555556 * ((a5[1] - *a5) >> 3);
  uint64_t v26 = **(void **)(v23 + 64);
  unint64_t v27 = *(void *)(v26 + 8) * v25;
  uint64_t v28 = *(void *)(v26 + 72);
  unint64_t v29 = *(void *)(v26 + 80) - v28;
  if (v27 != v29)
  {
    unint64_t v68 = a4;
    uint64_t v30 = v12;
    uint64_t v31 = v22;
    uint64_t v32 = a7;
    uint64_t v33 = a3;
    uint64_t v34 = a6;
    if (v27 <= v29)
    {
      if (v27 < v29) {
        *(void *)(v26 + 80) = v28 + v27;
      }
    }
    else
    {
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v26 + 72, v27 - v29);
    }
    uint64_t v35 = *(std::__shared_weak_count **)(v26 + 32);
    *(void *)(v26 + 24) = 0;
    *(void *)(v26 + 32) = 0;
    if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
    *(void *)(v26 + 120) = 0;
    *(_DWORD *)(v26 + 112) = 0;
    uint64_t v36 = *(void *)(v26 + 80) - *(void *)(v26 + 72);
    *(void *)(v26 + 40) = 0;
    *(void *)(v26 + 48) = v36;
    *(void *)(v26 + 56) = 0;
    *(void *)(v26 + 64) = v36;
    uint64_t v26 = **(void **)(v23 + 64);
    unint64_t v27 = *(void *)(v26 + 8) * v25;
    a6 = v34;
    a3 = v33;
    a7 = v32;
    uint64_t v22 = v31;
    uint64_t v12 = v30;
    a4 = v68;
  }
  float32x4_t v70 = 0uLL;
  v37.i64[0] = 0;
  v37.i64[1] = v26;
  if (v27) {
    uint64_t v38 = *(void *)(v26 + 72);
  }
  else {
    uint64_t v38 = 0;
  }
  float32x4_t v70 = v37;
  unint64_t v71 = 0;
  unint64_t v72 = v27;
  uint64_t v74 = v38;
  __int16 v73 = 1;
  uint64_t v39 = *a5;
  uint64_t v40 = a5[1] - *a5;
  if (v40)
  {
    unint64_t v41 = v40 / 24;
    if (v41 <= 1) {
      unint64_t v41 = 1;
    }
    uint64_t v42 = v38 + 16;
    do
    {
      uint64_t v43 = *(void *)v39;
      *(_DWORD *)(v42 - 8) = *(_DWORD *)(v39 + 8);
      *(void *)(v42 - 16) = v43;
      *(_DWORD *)(v42 - 4) = 1065353216;
      v37.i64[0] = *(void *)v39;
      v37.i32[2] = *(_DWORD *)(v39 + 8);
      v24.i64[0] = *(void *)(v39 + 12);
      v24.i32[2] = *(_DWORD *)(v39 + 20);
      float32x4_t v37 = vaddq_f32(v24, v37);
      *(_DWORD *)(v42 + 8) = v37.i32[2];
      *(void *)uint64_t v42 = v37.i64[0];
      *(_DWORD *)(v42 + 12) = 1065353216;
      v42 += 32;
      v39 += 24;
      --v41;
    }
    while (v41);
  }
  uint64_t v44 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*(void *)(*(void *)(v12 + 48) + 112));
  gm::operator*<double,4,4,4>(v69[0].f64, (double *)(v22 + 808), a3);
  float32x4_t v45 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v69[2]), v69[3]);
  float32x4_t v46 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v69[4]), v69[5]);
  float32x4_t v47 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v69[6]), v69[7]);
  unint64_t v48 = *(void **)(v44 + 64);
  uint64_t v49 = (void *)v48[2];
  unint64_t v50 = v49[1];
  long long v51 = (float32x4_t *)v49[9];
  float32x4_t *v51 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v69[0]), v69[1]);
  v51[1] = v45;
  v51[2] = v46;
  v51[3] = v47;
  if (v49[8] > v50) {
    unint64_t v50 = v49[8];
  }
  v49[7] = 0;
  v49[8] = v50;
  v48[5] = 0;
  uint64_t v52 = *a7;
  v48[4] = *a7;
  uint64_t v53 = *(void *)(v44 + 160);
  uint64_t v54 = a7[1];
  if (v54) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v54 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v55 = *(std::__shared_weak_count **)(v53 + 40);
  *(void *)(v53 + 32) = v52;
  *(void *)(v53 + 40) = v54;
  if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }
  unint64_t v56 = **(void ***)(v44 + 64);
  unint64_t v57 = v56[1];
  uint64_t v58 = (_DWORD *)v56[9];
  *uint64_t v58 = *a4;
  v58[1] = a4[1];
  v58[2] = a4[2];
  v58[3] = a4[3];
  if (v56[8] > v57) {
    unint64_t v57 = v56[8];
  }
  v56[7] = 0;
  v56[8] = v57;
  long long v59 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(v12 + 48) + 160));
  v59[8] = v23;
  v59[4] = v44;
  v59[3] = *(void *)(*(void *)(v12 + 48) + 168);
  uint64_t result = ggl::CommandBuffer::pushRenderItem(a6, (uint64_t)v59);
  if (v74)
  {
    unint64_t v62 = v71;
    unint64_t v61 = v72;
    if (v72 != v71)
    {
      uint64_t v63 = (void *)v70.i64[1];
      uint64_t result = v70.i64[0];
      int v64 = v73;
      int v65 = HIBYTE(v73);
      if (v70.i64[0] && *(unsigned char *)(v70.i64[1] + 17) != 2) {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)v70.i64[0] + 64))();
      }
      if (v64 && !v65)
      {
        unint64_t v67 = v63[7];
        unint64_t v66 = v63[8];
        if (v66 == v67) {
          unint64_t v67 = v63[10] - v63[9];
        }
        if (v62 < v67) {
          unint64_t v67 = v62;
        }
        if (v66 <= v61) {
          unint64_t v66 = v61;
        }
        if (v66 == v67) {
          unint64_t v66 = v67 + v63[10] - v63[9];
        }
        v63[7] = v67;
        v63[8] = v66;
      }
    }
  }
  return result;
}

void sub_1A20EAA00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t md::DebugLayerRenderResources::unitBoxMesh(md::DebugLayerRenderResources *this)
{
  if (!*((void *)this + 38))
  {
    uint64_t v3 = (std::__shared_weak_count *)operator new(0xF8uLL);
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5843F0;
    ggl::BufferData::BufferData((uint64_t)&v3[1], 16, 0, 0, 6, 8);
    v3[9].__shared_weak_owners_ = (uint64_t)"/Debug/UnitBox/VertexData";
    v3[10].__vftable = (std::__shared_weak_count_vtbl *)&ggl::CommonMesh::bufferPos4Reflection;
    v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55BFC8;
    v3[9].__shared_owners_ = (uint64_t)&unk_1EF55BFE8;
    float32x4_t v24 = v3;
    uint64_t v4 = (std::__shared_weak_count *)operator new(0xF8uLL);
    v4->__shared_owners_ = 0;
    v4->__shared_weak_owners_ = 0;
    v4->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D28;
    ggl::BufferData::BufferData((uint64_t)&v4[1], 2, 1, 0, 6, 36);
    LODWORD(v4[10].__vftable) = 0;
    v4[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B630;
    v4[1].__shared_owners_ = 2;
    v4[9].__shared_owners_ = (uint64_t)&unk_1EF55B650;
    v4[9].__shared_weak_owners_ = (uint64_t)"/Debug/UnitBox/IndexData";
    *(void *)&long long v5 = 0;
    *(void *)&long long v6 = 0;
    *((void *)&v6 + 1) = v3 + 1;
    long long v21 = v6;
    unint64_t v22 = 8 * v3[1].__shared_owners_;
    uint64_t v23 = v3[4].__vftable;
    *(_OWORD *)&v23->~__shared_weak_count = xmmword_1A28FCDD0;
    *(_OWORD *)&v23->__on_zero_shared = xmmword_1A28FC6C0;
    *(_OWORD *)&v23->__on_zero_shared_weaunint64_t k = xmmword_1A28FD290;
    *(_OWORD *)&v23[1].~__shared_weak_count_0 = xmmword_1A28FD270;
    *(_OWORD *)&v23[1].__get_deleter = xmmword_1A28FCDA0;
    *(_OWORD *)&v23[2].~__shared_weak_count = xmmword_1A28FE130;
    __asm { FMOV            V2.4S, #1.0 }
    *(_OWORD *)&v23[2].__on_zero_shared = xmmword_1A28FD460;
    *(_OWORD *)&v23[2].__on_zero_shared_weaunint64_t k = _Q2;
    *((void *)&v5 + 1) = v4 + 1;
    long long v19 = v5;
    uint64_t v20 = v4[4].__vftable;
    *(_OWORD *)&v20->~__shared_weak_count = xmmword_1A28FE380;
    *(_OWORD *)&v20->__on_zero_shared = xmmword_1A28FE390;
    *(_OWORD *)&v20->__on_zero_shared_weaunint64_t k = xmmword_1A28FE3A0;
    *(_OWORD *)&v20[1].~__shared_weak_count_0 = xmmword_1A28FE3B0;
    v20[1].__get_deleter = (const void *(__cdecl *)(const std::__shared_weak_count *__hidden, const std::type_info *))0x4000000050005;
    uint64_t v12 = operator new(0xA8uLL);
    v12[1] = 0;
    v12[2] = 0;
    *uint64_t v12 = &unk_1EF583120;
    uint64_t v26 = &v3[1].__vftable;
    unint64_t v27 = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    v25[0] = (uint64_t)&v4[1];
    v25[1] = (uint64_t)v4;
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::CommonMesh::Pos4Mesh::Pos4Mesh((uint64_t)(v12 + 3), (uint64_t)"/Debug/UnitBox/Mesh", (uint64_t *)&v26, v25);
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    int8x8_t v13 = v27;
    if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    uint8x8_t v14 = (std::__shared_weak_count *)*((void *)this + 39);
    *((void *)this + 38) = v12 + 3;
    *((void *)this + 39) = v12;
    if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
    if (v20)
    {
      if ((void)v19 && *(unsigned char *)(*((void *)&v19 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v19 + 64))();
      }
      uint64_t v16 = *(void *)(*((void *)&v19 + 1) + 56);
      unint64_t v15 = *(void *)(*((void *)&v19 + 1) + 64);
      if (v15 == v16) {
        uint64_t v16 = *(void *)(*((void *)&v19 + 1) + 80) - *(void *)(*((void *)&v19 + 1) + 72);
      }
      if (v16) {
        uint64_t v16 = 0;
      }
      if (v15 <= 0x48) {
        unint64_t v15 = 72;
      }
      *(void *)(*((void *)&v19 + 1) + 56) = v16;
      *(void *)(*((void *)&v19 + 1) + 64) = v15;
    }
    if (v23 && v22)
    {
      if ((void)v21 && *(unsigned char *)(*((void *)&v21 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v21 + 64))();
      }
      uint64_t v18 = *(void *)(*((void *)&v21 + 1) + 56);
      unint64_t v17 = *(void *)(*((void *)&v21 + 1) + 64);
      if (v17 == v18) {
        uint64_t v18 = *(void *)(*((void *)&v21 + 1) + 80) - *(void *)(*((void *)&v21 + 1) + 72);
      }
      if (v18) {
        uint64_t v18 = 0;
      }
      if (v17 <= v22) {
        unint64_t v17 = v22;
      }
      if (v17 == v18) {
        unint64_t v17 = v18 + *(void *)(*((void *)&v21 + 1) + 80) - *(void *)(*((void *)&v21 + 1) + 72);
      }
      *(void *)(*((void *)&v21 + 1) + 56) = v18;
      *(void *)(*((void *)&v21 + 1) + 64) = v17;
    }
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
  }
  return (uint64_t)this + 304;
}

void sub_1A20EAF90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23)
{
}

void md::DebugRenderLayer::renderInstancedMesh(uint64_t a1, void *a2, double *a3, _DWORD *a4, int a5, uint64_t a6, uint64_t a7, void *a8, uint64_t *a9)
{
  float32x4_t v10 = *(const void **)a7;
  uint64_t v9 = *(void *)(a7 + 8);
  if (*(void *)a7 == v9) {
    return;
  }
  int8x8_t v15 = (int8x8_t)a2[1];
  if (!*(void *)&v15) {
    goto LABEL_25;
  }
  uint8x8_t v16 = (uint8x8_t)vcnt_s8(v15);
  v16.i16[0] = vaddlv_u8(v16);
  if (v16.u32[0] > 1uLL)
  {
    uint64_t v17 = 0x1AF456233693CD46;
    if (*(void *)&v15 <= 0x1AF456233693CD46uLL) {
      uint64_t v17 = 0x1AF456233693CD46uLL % *(void *)&v15;
    }
  }
  else
  {
    uint64_t v17 = (*(void *)&v15 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v18 = *(void **)(*a2 + 8 * v17);
  if (!v18) {
    goto LABEL_25;
  }
  long long v19 = (void *)*v18;
  if (!v19) {
    goto LABEL_25;
  }
  if (v16.u32[0] < 2uLL)
  {
    uint64_t v20 = *(void *)&v15 - 1;
    while (1)
    {
      uint64_t v22 = v19[1];
      if (v22 == 0x1AF456233693CD46)
      {
        if (v19[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v22 & v20) != v17)
      {
        goto LABEL_25;
      }
      long long v19 = (void *)*v19;
      if (!v19) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v21 = v19[1];
    if (v21 == 0x1AF456233693CD46) {
      break;
    }
    if (v21 >= *(void *)&v15) {
      v21 %= *(void *)&v15;
    }
    if (v21 != v17) {
      goto LABEL_25;
    }
LABEL_12:
    long long v19 = (void *)*v19;
    if (!v19) {
      goto LABEL_25;
    }
  }
  if (v19[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v23 = v19[5];
  if (*(void *)(v23 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v24 = *(void *)(v23 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v24 = 0;
LABEL_26:
  uint64_t v25 = (std::__shared_weak_count *)operator new(0xE0uLL);
  v25->__shared_owners_ = 0;
  v25->__shared_weak_owners_ = 0;
  v25->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583F20;
  uint64_t v26 = ggl::BufferData::BufferData((uint64_t)&v25[1], qword_1E9563F90, 3, 1, 6, (v9 - (uint64_t)v10) >> 6);
  unint64_t v27 = 0;
  v25[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B970;
  uint64_t v102 = v26;
  uint64_t v103 = v25;
  unint64_t shared_owners = v25[1].__shared_owners_;
  unint64_t v29 = (unint64_t)v25[3].__vftable - v25[2].__shared_weak_owners_;
  unint64_t v30 = v29 / shared_owners * shared_owners;
  unint64_t v31 = v29 % shared_owners;
  if (v29 != v29 % shared_owners) {
    unint64_t v27 = v25[4].__vftable;
  }
  memcpy(v27, *(const void **)a7, *(void *)(a7 + 8) - *(void *)a7);
  if (v27 && v29 != v31)
  {
    unint64_t shared_weak_owners = v25[3].__shared_weak_owners_;
    if (shared_weak_owners <= v30) {
      unint64_t shared_weak_owners = v30;
    }
    v25[3].__shared_owners_ = 0;
    v25[3].__shared_weak_owners_ = shared_weak_owners;
  }
  uint64_t v33 = *(void *)(*(void *)(a1 + 48) + 128);
  uint64_t v34 = *(void *)(v33 + 8);
  if (v34 == *(void *)v33)
  {
    uint64_t v46 = *(void *)(v33 + 88);
    if (!v46)
    {
LABEL_105:
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
      return;
    }
    uint64_t v35 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v46 + 48))(v46);
    uint64_t v36 = *(void **)(v33 + 40);
    unint64_t v47 = *(void *)(v33 + 48);
    if ((unint64_t)v36 < v47)
    {
LABEL_46:
      if (v36) {
        *uint64_t v36 = v35;
      }
      unint64_t v48 = v36 + 1;
      goto LABEL_84;
    }
    uint64_t v49 = *(void *)(v33 + 32);
    uint64_t v50 = ((uint64_t)v36 - v49) >> 3;
    unint64_t v51 = v50 + 1;
    if ((unint64_t)(v50 + 1) >> 61) {
LABEL_106:
    }
      abort();
    uint64_t v52 = v47 - v49;
    if (v52 >> 2 > v51) {
      unint64_t v51 = v52 >> 2;
    }
    if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v53 = v51;
    }
    if (v53)
    {
      uint64_t v54 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v33 + 56) + 16))(*(void *)(v33 + 56), 8 * v53, 8);
      uint64_t v44 = (void *)(v54 + 8 * v50);
      uint64_t v45 = v54 + 8 * v53;
      if (v54) {
        *uint64_t v44 = v35;
      }
    }
    else
    {
      uint64_t v45 = 0;
      uint64_t v44 = (void *)(8 * v50);
    }
    unint64_t v48 = v44 + 1;
    uint64_t v64 = *(void *)(v33 + 32);
    uint64_t v55 = *(void *)(v33 + 40);
    if (v55 == v64) {
      goto LABEL_82;
    }
    unint64_t v65 = v55 - v64 - 8;
    if (v65 < 0x38)
    {
      uint64_t v67 = *(void *)(v33 + 40);
    }
    else if ((unint64_t)(v55 - (void)v44) < 0x20)
    {
      uint64_t v67 = *(void *)(v33 + 40);
    }
    else
    {
      uint64_t v66 = (v65 >> 3) + 1;
      uint64_t v67 = v55 - 8 * (v66 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v68 = v44 - 2;
      uint64_t v69 = (long long *)(v55 - 16);
      uint64_t v70 = v66 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v71 = *v69;
        *(v68 - 1) = *(v69 - 1);
        *unint64_t v68 = v71;
        v68 -= 2;
        v69 -= 2;
        v70 -= 4;
      }
      while (v70);
      v44 -= v66 & 0x3FFFFFFFFFFFFFFCLL;
      if (v66 == (v66 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_81;
      }
    }
    do
    {
      uint64_t v73 = *(void *)(v67 - 8);
      v67 -= 8;
      *--uint64_t v44 = v73;
    }
    while (v67 != v64);
LABEL_81:
    uint64_t v55 = *(void *)(v33 + 32);
    goto LABEL_82;
  }
  uint64_t v35 = *(void **)(v34 - 8);
  *(void *)(v33 + 8) = v34 - 8;
  uint64_t v36 = *(void **)(v33 + 40);
  unint64_t v37 = *(void *)(v33 + 48);
  if ((unint64_t)v36 < v37) {
    goto LABEL_46;
  }
  uint64_t v38 = *(void *)(v33 + 32);
  uint64_t v39 = ((uint64_t)v36 - v38) >> 3;
  unint64_t v40 = v39 + 1;
  if ((unint64_t)(v39 + 1) >> 61) {
    goto LABEL_106;
  }
  uint64_t v41 = v37 - v38;
  if (v41 >> 2 > v40) {
    unint64_t v40 = v41 >> 2;
  }
  if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v42 = v40;
  }
  if (v42)
  {
    uint64_t v43 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v33 + 56) + 16))(*(void *)(v33 + 56), 8 * v42, 8);
    uint64_t v44 = (void *)(v43 + 8 * v39);
    uint64_t v45 = v43 + 8 * v42;
    if (v43) {
      *uint64_t v44 = v35;
    }
  }
  else
  {
    uint64_t v45 = 0;
    uint64_t v44 = (void *)(8 * v39);
  }
  unint64_t v48 = v44 + 1;
  uint64_t v56 = *(void *)(v33 + 32);
  uint64_t v55 = *(void *)(v33 + 40);
  if (v55 != v56)
  {
    unint64_t v57 = v55 - v56 - 8;
    if (v57 < 0x38)
    {
      uint64_t v59 = *(void *)(v33 + 40);
    }
    else if ((unint64_t)(v55 - (void)v44) < 0x20)
    {
      uint64_t v59 = *(void *)(v33 + 40);
    }
    else
    {
      uint64_t v58 = (v57 >> 3) + 1;
      uint64_t v59 = v55 - 8 * (v58 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v60 = v44 - 2;
      unint64_t v61 = (long long *)(v55 - 16);
      uint64_t v62 = v58 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v63 = *v61;
        *(v60 - 1) = *(v61 - 1);
        *uint64_t v60 = v63;
        v60 -= 2;
        v61 -= 2;
        v62 -= 4;
      }
      while (v62);
      v44 -= v58 & 0x3FFFFFFFFFFFFFFCLL;
      if (v58 == (v58 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_81;
      }
    }
    do
    {
      uint64_t v72 = *(void *)(v59 - 8);
      v59 -= 8;
      *--uint64_t v44 = v72;
    }
    while (v59 != v56);
    goto LABEL_81;
  }
LABEL_82:
  *(void *)(v33 + 32) = v44;
  *(void *)(v33 + 40) = v48;
  uint64_t v74 = *(void *)(v33 + 48);
  *(void *)(v33 + 48) = v45;
  if (v55) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v33 + 56) + 40))(*(void *)(v33 + 56), v55, v74 - v55);
  }
LABEL_84:
  *(void *)(v33 + 40) = v48;
  *(void *)&v101[0].f64[0] = v35;
  uint64_t v75 = *(void *)(v33 + 120);
  if (!v75) {
    goto LABEL_105;
  }
  (*(void (**)(uint64_t, float64x2_t *))(*(void *)v75 + 48))(v75, v101);
  gm::operator*<double,4,4,4>(v101[0].f64, (double *)(v24 + 808), a3);
  float32x4_t v76 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v101[2]), v101[3]);
  float32x4_t v77 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v101[4]), v101[5]);
  float32x4_t v78 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v101[6]), v101[7]);
  float32x4_t v79 = (void *)v35[8];
  float32x4_t v80 = (void *)v79[2];
  unint64_t v81 = v80[1];
  long long v82 = (float32x4_t *)v80[9];
  float32x4_t *v82 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v101[0]), v101[1]);
  v82[1] = v76;
  v82[2] = v77;
  v82[3] = v78;
  if (v80[8] > v81) {
    unint64_t v81 = v80[8];
  }
  v80[7] = 0;
  v80[8] = v81;
  v79[5] = 0;
  uint64_t v83 = *a9;
  v79[4] = *a9;
  uint64_t v84 = v35[20];
  uint64_t v85 = a9[1];
  if (v85) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v85 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v86 = *(std::__shared_weak_count **)(v84 + 40);
  *(void *)(v84 + 32) = v83;
  *(void *)(v84 + 40) = v85;
  if (v86 && !atomic_fetch_add(&v86->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
    std::__shared_weak_count::__release_weak(v86);
  }
  uint64_t v87 = (uint64_t *)v35[4];
  uint64_t v88 = v102;
  uint64_t *v87 = v102;
  v87[1] = 0;
  unint64_t v89 = (uint64_t *)v35[16];
  uint64_t v90 = v103;
  if (v103) {
    atomic_fetch_add_explicit(&v103->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v91 = (std::__shared_weak_count *)v89[1];
  uint64_t *v89 = v88;
  v89[1] = (uint64_t)v90;
  if (v91 && !atomic_fetch_add(&v91->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
    std::__shared_weak_count::__release_weak(v91);
  }
  unsigned int v92 = *(void **)v35[8];
  unint64_t v93 = v92[1];
  float v94 = (_DWORD *)v92[9];
  _DWORD *v94 = *a4;
  v94[1] = a4[1];
  v94[2] = a4[2];
  v94[3] = a4[3];
  if (v92[8] > v93) {
    unint64_t v93 = v92[8];
  }
  v92[7] = 0;
  v92[8] = v93;
  float v95 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 48) + 160));
  v95[8] = *a8;
  v95[4] = v35;
  uint64_t v96 = 208;
  if (a5) {
    uint64_t v96 = 216;
  }
  v95[3] = *(void *)(*(void *)(a1 + 48) + v96);
  v95[13] = (uint64_t)(*(void *)(a7 + 8) - *(void *)a7) >> 6;
  ggl::CommandBuffer::pushRenderItem(a6, (uint64_t)v95);
  uint64_t v97 = v103;
  if (v103)
  {
    if (!atomic_fetch_add(&v103->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
      std::__shared_weak_count::__release_weak(v97);
    }
  }
}

void sub_1A20EB764(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 - 104);
  _Unwind_Resume(a1);
}

char *md::DebugLayerRenderResources::unitQuadMesh(md::DebugLayerRenderResources *this)
{
  uint64_t v1 = (char *)this + 288;
  if (!*((void *)this + 36))
  {
    uint64_t v3 = operator new(0xA8uLL);
    v3[1] = 0;
    int8x8_t v3[2] = 0;
    void *v3 = &unk_1EF583120;
    uint64_t v4 = ggl::CommonMesh::Pos4Mesh::Pos4Mesh((ggl::CommonMesh::Pos4Mesh *)(v3 + 3), "/DebugSharedUnitQuadMesh");
    long long v5 = (std::__shared_weak_count *)*((void *)this + 37);
    *((void *)this + 36) = v4;
    *((void *)this + 37) = v3;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    uint64_t v6 = **(void **)(*(void *)v1 + 64);
    uint64_t v7 = *(void *)(v6 + 8);
    unint64_t v8 = 6 * v7;
    uint64_t v9 = *(void *)(v6 + 72);
    unint64_t v10 = *(void *)(v6 + 80) - v9;
    if (6 * v7 != v10)
    {
      if (6 * v7 <= v10)
      {
        if (v8 < v10) {
          *(void *)(v6 + 80) = v9 + v8;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v6 + 72, 6 * v7 - v10);
      }
      uint64_t v11 = *(std::__shared_weak_count **)(v6 + 32);
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 0;
      if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      *(void *)(v6 + 120) = 0;
      *(_DWORD *)(v6 + 112) = 0;
      uint64_t v12 = *(void *)(v6 + 80) - *(void *)(v6 + 72);
      *(void *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = v12;
      *(void *)(v6 + 56) = 0;
      *(void *)(v6 + 64) = v12;
      uint64_t v6 = **(void **)(*(void *)v1 + 64);
      uint64_t v7 = *(void *)(v6 + 8);
    }
    unint64_t v14 = *(void *)(v6 + 64);
    int8x8_t v13 = *(_OWORD **)(v6 + 72);
    *int8x8_t v13 = xmmword_1A28FCDD0;
    v13[1] = xmmword_1A28FC6C0;
    v13[2] = xmmword_1A28FD270;
    v13[3] = xmmword_1A28FD270;
    v13[4] = xmmword_1A28FD290;
    v13[5] = xmmword_1A28FCDD0;
    unint64_t v15 = 5 * v7;
    if (v14 > v15) {
      unint64_t v15 = v14;
    }
    *(void *)(v6 + 56) = 0;
    *(void *)(v6 + 64) = v15;
  }
  return v1;
}

uint64_t md::DebugLayerRenderResources::icoSphere(md::DebugLayerRenderResources *this)
{
  if (*((void *)this + 44)) {
    return (uint64_t)this + 352;
  }
  long long v73 = 0u;
  long long v74 = 0u;
  int v75 = 1065353216;
  uint64_t v70 = 0;
  long long v71 = 0;
  uint64_t v72 = 0;
  std::string __p = 0;
  unint64_t v68 = 0;
  uint64_t v69 = 0;
  md::GeometryLogic::createIcoSphere(&v70, &__p, 1);
  uint64_t v3 = __p;
  uint64_t v2 = v68;
  long long v5 = v70;
  uint64_t v4 = v71;
  uint64_t v6 = (std::__shared_weak_count *)operator new(0xF8uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5843F0;
  ggl::BufferData::BufferData((uint64_t)&v6[1], 16, 0, 0, 6, 0xAAAAAAAAAAAAAAABLL * (v4 - v5));
  v6[9].__shared_weak_owners_ = (uint64_t)"/Debug/IcoSphere/VertexData";
  v6[10].__vftable = (std::__shared_weak_count_vtbl *)&ggl::CommonMesh::bufferPos4Reflection;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55BFC8;
  v6[9].__shared_owners_ = (uint64_t)&unk_1EF55BFE8;
  unint64_t v65 = v6 + 1;
  uint64_t v66 = v6;
  uint64_t v7 = operator new(0xF8uLL);
  *((void *)v7 + 1) = 0;
  *((void *)v7 + 2) = 0;
  *(void *)uint64_t v7 = &unk_1EF583D28;
  uint64_t v8 = ggl::BufferData::BufferData((uint64_t)v7 + 24, 2, 1, 0, 6, (v2 - v3) >> 2);
  *((_DWORD *)v7 + 60) = 0;
  *((void *)v7 + 3) = &unk_1EF55B630;
  *((void *)v7 + 4) = 2;
  *((void *)v7 + 28) = &unk_1EF55B650;
  *((void *)v7 + 29) = "/Debug/IcoSphere/IndexData";
  uint64_t v63 = v8;
  uint64_t v64 = (std::__shared_weak_count *)v7;
  unint64_t v10 = v70;
  uint64_t v9 = v71;
  *(void *)&long long v11 = 0;
  if (0xAAAAAAAAAAAAAAABLL * (v71 - v70) * v6[1].__shared_owners_) {
    uint64_t v12 = v6[4].__vftable;
  }
  else {
    uint64_t v12 = 0;
  }
  *((void *)&v11 + 1) = v6 + 1;
  long long v60 = v11;
  unint64_t v61 = 0xAAAAAAAAAAAAAAABLL * (v71 - v70) * v6[1].__shared_owners_;
  uint64_t v62 = v12;
  if (v70 != v71)
  {
    unint64_t v13 = (char *)v71 - (char *)v70 - 12;
    if (v13 <= 0x83
      || (unint64_t v14 = v13 / 0xC, v12 < (std::__shared_weak_count_vtbl *)&v70[3 * v14 + 3])
      && v70 < (float *)&v12->__on_zero_shared + 4 * v14)
    {
      uint64_t v15 = 0;
      goto LABEL_10;
    }
    unint64_t v46 = v14 + 1;
    uint64_t v15 = (v14 + 1) & 0x3FFFFFFFFFFFFFF8;
    p_get_deleter = (float *)&v12[1].__get_deleter;
    __asm { FMOV            V3.4S, #1.0 }
    uint64_t v53 = v70;
    uint64_t v54 = v15;
    do
    {
      uint64_t v55 = v53;
      float32x4x3_t v76 = vld3q_f32(v55);
      v55 += 12;
      *(float32x4x3_t *)v79.val[0].f32 = vld3q_f32(v55);
      v79.val[3] = _Q3;
      uint64_t v56 = p_get_deleter - 16;
      vst4q_f32(v56, *(float32x4x4_t *)(&_Q3 - 3));
      vst4q_f32(p_get_deleter, v79);
      p_get_deleter += 32;
      v53 += 24;
      v54 -= 8;
    }
    while (v54);
    if (v46 != v15)
    {
      v10 += 3 * v15;
LABEL_10:
      uint8x8_t v16 = (float *)((char *)v12 + 16 * v15);
      do
      {
        uint64_t v17 = *(void *)v10;
        v16[2] = v10[2];
        *(void *)uint8x8_t v16 = v17;
        v16[3] = 1.0;
        v10 += 3;
        v16 += 4;
      }
      while (v10 != v9);
    }
  }
  long long v19 = __p;
  uint64_t v18 = v68;
  v20.i64[0] = 0;
  v20.i64[1] = v8;
  if (v68 == __p)
  {
    int16x8_t v57 = v20;
    unint64_t v58 = (v68 - (unsigned char *)__p) >> 1;
    uint64_t v59 = 0;
  }
  else
  {
    uint64_t v21 = *((void *)v7 + 12);
    int16x8_t v57 = v20;
    unint64_t v58 = (v68 - (unsigned char *)__p) >> 1;
    uint64_t v59 = v21;
    unint64_t v22 = v68 - (unsigned char *)__p - 12;
    if (v22 > 0x53)
    {
      unint64_t v24 = v22 / 0xC + 1;
      uint64_t v25 = v24 & 0x3FFFFFFFFFFFFFF8;
      uint64_t v26 = (const float *)__p;
      unint64_t v27 = (__int16 *)*((void *)v7 + 12);
      uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFF8;
      do
      {
        unint64_t v29 = v26;
        *(float32x4x3_t *)v20.i8 = vld3q_f32(v29);
        v29 += 12;
        float32x4x3_t v77 = vld3q_f32(v29);
        v78.val[0] = vuzp1q_s16(v20, (int16x8_t)v77.val[0]);
        v78.val[1] = vuzp1q_s16(v30, (int16x8_t)v77.val[1]);
        v78.val[2] = vuzp1q_s16(v31, (int16x8_t)v77.val[2]);
        vst3q_s16(v27, v78);
        v27 += 24;
        v26 += 24;
        v28 -= 8;
      }
      while (v28);
      if (v24 == v25) {
        goto LABEL_22;
      }
      uint64_t v23 = 3 * v25;
      v19 += 3 * (v24 & 0x3FFFFFFFFFFFFFF8);
    }
    else
    {
      uint64_t v23 = 0;
    }
    uint64_t v32 = v21 + 2 * v23;
    do
    {
      v20.i64[0] = *(void *)v19;
      v20.i32[2] = v19[2];
      int16x4_t v33 = vmovn_s32((int32x4_t)v20);
      *(_WORD *)(v32 + 4) = v33.i16[2];
      *(_DWORD *)uint64_t v32 = v33.i32[0];
      v32 += 6;
      v19 += 3;
    }
    while (v19 != v18);
  }
LABEL_22:
  uint64_t v34 = operator new(0xA8uLL);
  v34[1] = 0;
  v34[2] = 0;
  *uint64_t v34 = &unk_1EF583120;
  uint64_t v35 = std::construct_at[abi:nn180100]<ggl::CommonMesh::Pos4Mesh,char const(&)[22],std::shared_ptr<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4>> &,std::shared_ptr<ggl::IndexDataTyped<unsigned short>> &,ggl::CommonMesh::Pos4Mesh*>((uint64_t)(v34 + 3), (uint64_t)"/Debug/IcoSphere/Mesh", (uint64_t)&v6[1], v6, &v63);
  uint64_t v36 = (std::__shared_weak_count *)*((void *)this + 45);
  *((void *)this + 44) = v35;
  *((void *)this + 45) = v34;
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  if (v59 && v58)
  {
    if (v57.i64[0] && *(unsigned char *)(v57.i64[1] + 17) != 2) {
      (*(void (**)(void))(*(void *)v57.i64[0] + 64))();
    }
    uint64_t v38 = *(void *)(v57.i64[1] + 56);
    unint64_t v37 = *(void *)(v57.i64[1] + 64);
    if (v37 == v38) {
      uint64_t v38 = *(void *)(v57.i64[1] + 80) - *(void *)(v57.i64[1] + 72);
    }
    if (v38) {
      uint64_t v38 = 0;
    }
    if (v37 <= v58) {
      unint64_t v37 = v58;
    }
    if (v37 == v38) {
      unint64_t v37 = v38 + *(void *)(v57.i64[1] + 80) - *(void *)(v57.i64[1] + 72);
    }
    *(void *)(v57.i64[1] + 56) = v38;
    *(void *)(v57.i64[1] + 64) = v37;
  }
  if (v62 && v61)
  {
    if ((void)v60 && *(unsigned char *)(*((void *)&v60 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v60 + 64))();
    }
    uint64_t v40 = *(void *)(*((void *)&v60 + 1) + 56);
    unint64_t v39 = *(void *)(*((void *)&v60 + 1) + 64);
    if (v39 == v40) {
      uint64_t v40 = *(void *)(*((void *)&v60 + 1) + 80) - *(void *)(*((void *)&v60 + 1) + 72);
    }
    if (v40) {
      uint64_t v40 = 0;
    }
    if (v39 <= v61) {
      unint64_t v39 = v61;
    }
    if (v39 == v40) {
      unint64_t v39 = v40 + *(void *)(*((void *)&v60 + 1) + 80) - *(void *)(*((void *)&v60 + 1) + 72);
    }
    *(void *)(*((void *)&v60 + 1) + 56) = v40;
    *(void *)(*((void *)&v60 + 1) + 64) = v39;
  }
  uint64_t v41 = v64;
  if (v64 && !atomic_fetch_add(&v64->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
  uint64_t v42 = v66;
  if (v66 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
  if (__p)
  {
    unint64_t v68 = __p;
    operator delete(__p);
  }
  if (v70)
  {
    long long v71 = v70;
    operator delete(v70);
  }
  uint64_t v43 = (void *)v74;
  if ((void)v74)
  {
    do
    {
      uint64_t v44 = (void *)*v43;
      operator delete(v43);
      uint64_t v43 = v44;
    }
    while (v44);
  }
  if ((void)v73) {
    operator delete((void *)v73);
  }
  return (uint64_t)this + 352;
}

void sub_1A20EBFCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,void *__p,uint64_t a26)
{
  std::__shared_weak_count::~__shared_weak_count(v26);
  operator delete(v29);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a9);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a21);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a23);
  if (__p)
  {
    a26 = (uint64_t)__p;
    operator delete(__p);
  }
  int16x8_t v30 = *(void **)(v27 - 136);
  if (v30)
  {
    *(void *)(v27 - 128) = v30;
    operator delete(v30);
  }
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v27 - 112);
  _Unwind_Resume(a1);
}

void md::DebugRenderLayer::renderQuadTile(uint64_t a1, md::LayoutContext *a2, QuadTile *a3, float32x4_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  objc_msgSend(NSString, "stringWithFormat:", @"%d.%d.%d\n%s", a3->_xIdx, a3->_yIdx, a3->_level, a7);
  id v74 = (id)objc_claimAutoreleasedReturnValue();
  unint64_t v13 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v14 = (int8x8_t)v13[1];
  if (!*(void *)&v14)
  {
    uint64_t v17 = 0;
    goto LABEL_48;
  }
  uint8x8_t v15 = (uint8x8_t)vcnt_s8(v14);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] > 1uLL)
  {
    uint64_t v16 = 0x1AF456233693CD46;
    if (*(void *)&v14 <= 0x1AF456233693CD46uLL) {
      uint64_t v16 = 0x1AF456233693CD46uLL % *(void *)&v14;
    }
  }
  else
  {
    uint64_t v16 = (*(void *)&v14 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v18 = *v13;
  long long v19 = *(void **)(v18 + 8 * v16);
  if (!v19) {
    goto LABEL_25;
  }
  int16x8_t v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_25;
  }
  if (v15.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v22 = v20[1];
      if (v22 == 0x1AF456233693CD46)
      {
        if (v20[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v22 & (*(void *)&v14 - 1)) != v16)
      {
        goto LABEL_25;
      }
      int16x8_t v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v21 = v20[1];
    if (v21 == 0x1AF456233693CD46) {
      break;
    }
    if (v21 >= *(void *)&v14) {
      v21 %= *(void *)&v14;
    }
    if (v21 != v16) {
      goto LABEL_25;
    }
LABEL_12:
    int16x8_t v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_25;
    }
  }
  if (v20[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v23 = v20[5];
  if (*(void *)(v23 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v17 = *(void *)(v23 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v17 = 0;
LABEL_26:
  if (v15.u32[0] > 1uLL)
  {
    uint64_t v24 = 0x3070CB6B3C7F21D3;
    if (*(void *)&v14 <= 0x3070CB6B3C7F21D3uLL) {
      uint64_t v24 = 0x3070CB6B3C7F21D3uLL % *(void *)&v14;
    }
  }
  else
  {
    uint64_t v24 = (*(void *)&v14 - 1) & 0x3070CB6B3C7F21D3;
  }
  uint64_t v25 = *(void **)(v18 + 8 * v24);
  if (!v25) {
    goto LABEL_48;
  }
  uint64_t v26 = (void *)*v25;
  if (!v26) {
    goto LABEL_48;
  }
  if (v15.u32[0] < 2uLL)
  {
    uint64_t v27 = *(void *)&v14 - 1;
    while (1)
    {
      uint64_t v29 = v26[1];
      if (v29 == 0x3070CB6B3C7F21D3)
      {
        if (v26[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_46;
        }
      }
      else if ((v29 & v27) != v24)
      {
        goto LABEL_48;
      }
      uint64_t v26 = (void *)*v26;
      if (!v26) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v28 = v26[1];
    if (v28 != 0x3070CB6B3C7F21D3)
    {
      if (v28 >= *(void *)&v14) {
        v28 %= *(void *)&v14;
      }
      if (v28 != v24) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v26[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_35:
      uint64_t v26 = (void *)*v26;
      if (!v26) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v30 = v26[5];
  if (*(void *)(v30 + 8) == 0x3070CB6B3C7F21D3)
  {
    int16x8_t v31 = *(uint64_t **)(v30 + 32);
    goto LABEL_49;
  }
LABEL_48:
  int16x8_t v31 = 0;
LABEL_49:
  uint64_t v32 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*(void *)(*(void *)(a1 + 48) + 112));
  BOOL v33 = *(unsigned __int8 *)(md::LayoutContext::frameState(a2) + 128) - 1 < 3;
  md::GeometryLogic::tileMatrix((md::GeometryLogic *)v75, v33, a3, 0.0, v34);
  gm::operator*<double,4,4,4>(v76.f64, (double *)(v17 + 808), v75);
  float32x2_t v35 = vcvt_f32_f64(v76);
  float v36 = v77;
  float v37 = v78;
  float32x2_t v38 = vcvt_f32_f64(v79);
  float32x2_t v39 = vcvt_f32_f64(v83);
  float32x4_t v40 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v80), v81);
  float v41 = v84;
  float v42 = v85;
  float32x2_t v43 = vcvt_f32_f64(v82);
  uint64_t v44 = *(void **)(*(void *)(v32 + 64) + 16);
  unint64_t v45 = v44[1];
  uint64_t v46 = v44[9];
  *(float32x2_t *)uint64_t v46 = v35;
  *(float *)(v46 + 8) = v36;
  *(float *)(v46 + 12) = v37;
  *(float32x2_t *)(v46 + 16) = v38;
  float v73 = v40.f32[1];
  *(float32x4_t *)(v46 + 24) = v40;
  *(float32x2_t *)(v46 + 40) = v43;
  *(float32x2_t *)(v46 + 48) = v39;
  *(float *)(v46 + 56) = v41;
  *(float *)(v46 + 60) = v42;
  if (v44[8] > v45) {
    unint64_t v45 = v44[8];
  }
  v44[7] = 0;
  v44[8] = v45;
  md::GeometryContext::transformConstantData(v76.f64, v31, &a3->_type, *(unsigned __int8 *)(v17 + 3776), 0.0, 0.0);
  uint64_t v47 = *(void *)(v32 + 64);
  float64x2_t v48 = v76;
  *(float64_t *)(v47 + 32) = v76.f64[0];
  *(void *)(v47 + 40) = 0;
  uint64_t v49 = *(void *)(v32 + 160);
  if (*(void *)&v48.f64[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v48.f64[1] + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v50 = *(std::__shared_weak_count **)(v49 + 40);
  *(float64x2_t *)(v49 + 32) = v48;
  if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }
  float64_t v51 = v76.f64[1];
  if (*(void *)&v76.f64[1]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v76.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(float64_t))(**(void **)&v51 + 16))(COERCE_FLOAT64_T(*(void *)&v51));
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v51);
  }
  uint64_t v52 = **(void ***)(v32 + 64);
  unint64_t v53 = v52[1];
  uint64_t v54 = (_DWORD *)v52[9];
  *uint64_t v54 = a4->i32[0];
  v54[1] = a4->i32[1];
  v54[2] = a4->i32[2];
  v54[3] = a4->i32[3];
  if (v52[8] > v53) {
    unint64_t v53 = v52[8];
  }
  v52[7] = 0;
  v52[8] = v53;
  uint64_t v55 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 48) + 160));
  v55[8] = *(void *)md::DebugLayerRenderResources::unitRectMesh(*(md::DebugLayerRenderResources **)(a1 + 48));
  v55[4] = v32;
  v55[3] = *(void *)(*(void *)(a1 + 48) + 168);
  ggl::CommandBuffer::pushRenderItem(a5, (uint64_t)v55);
  id v56 = v74;
  int16x8_t v57 = (int8x16_t *)[v56 UTF8String];
  [*(id *)a2 sizeInPixels];
  *(float *)&v58.i32[1] = v73;
  *(float *)v58.i32 = v42 + (float)((float)(v73 + v37) * 0.5);
  float32x2_t v59 = vdiv_f32(vmla_f32(v39, (float32x2_t)0x3F0000003F000000, vadd_f32(v38, v35)), (float32x2_t)vdup_lane_s32(v58, 0));
  __asm { FMOV            V3.2S, #1.0 }
  v65.i32[0] = vadd_f32(v59, _D3).u32[0];
  v65.i32[1] = vsub_f32(_D3, v59).i32[1];
  v67.f64[1] = v66;
  __asm { FMOV            V1.2D, #0.5 }
  *(float32x2_t *)&v67.f64[0] = vcvt_f32_f64(vmulq_f64(vmulq_f64(v67, _Q1), vcvtq_f64_f32(v65)));
  int16x8_t v69 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(*a4, (float32x4_t)vdupq_n_s32(0x437F0000u)));
  *(int16x4_t *)v69.i8 = vmovn_s32((int32x4_t)v69);
  *(_DWORD *)(a6 + 96) = vmovn_s16(v69).u32[0];
  *(float64_t *)(a6 + 8) = v67.f64[0];
  *(void *)(a6 + 40) = 0x100000001;
  size_t v70 = strlen(v57->i8);
  ggl::DebugConsole::drawString(a6, v57, v70, v71, v72);
}

void sub_1A20EC5B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

void md::DebugRenderLayer::renderSolidQuadTile(uint64_t a1, md::LayoutContext *a2, QuadTile *a3, float32x4_t *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  unint64_t v13 = objc_msgSend(NSString, "stringWithFormat:", @"%d.%d.%d\n%s", a3->_xIdx, a3->_yIdx, a3->_level, a7);
  int8x8_t v14 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v15 = (int8x8_t)v14[1];
  if (!*(void *)&v15)
  {
    uint64_t v18 = 0;
    goto LABEL_48;
  }
  uint8x8_t v16 = (uint8x8_t)vcnt_s8(v15);
  v16.i16[0] = vaddlv_u8(v16);
  if (v16.u32[0] > 1uLL)
  {
    uint64_t v17 = 0x1AF456233693CD46;
    if (*(void *)&v15 <= 0x1AF456233693CD46uLL) {
      uint64_t v17 = 0x1AF456233693CD46uLL % *(void *)&v15;
    }
  }
  else
  {
    uint64_t v17 = (*(void *)&v15 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v19 = *v14;
  int16x8_t v20 = *(void **)(v19 + 8 * v17);
  if (!v20) {
    goto LABEL_25;
  }
  unint64_t v21 = (void *)*v20;
  if (!v21) {
    goto LABEL_25;
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v23 = v21[1];
      if (v23 == 0x1AF456233693CD46)
      {
        if (v21[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v23 & (*(void *)&v15 - 1)) != v17)
      {
        goto LABEL_25;
      }
      unint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v21[1];
    if (v22 == 0x1AF456233693CD46) {
      break;
    }
    if (v22 >= *(void *)&v15) {
      v22 %= *(void *)&v15;
    }
    if (v22 != v17) {
      goto LABEL_25;
    }
LABEL_12:
    unint64_t v21 = (void *)*v21;
    if (!v21) {
      goto LABEL_25;
    }
  }
  if (v21[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v24 = v21[5];
  if (*(void *)(v24 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v18 = *(void *)(v24 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v18 = 0;
LABEL_26:
  if (v16.u32[0] > 1uLL)
  {
    uint64_t v25 = 0x3070CB6B3C7F21D3;
    if (*(void *)&v15 <= 0x3070CB6B3C7F21D3uLL) {
      uint64_t v25 = 0x3070CB6B3C7F21D3uLL % *(void *)&v15;
    }
  }
  else
  {
    uint64_t v25 = (*(void *)&v15 - 1) & 0x3070CB6B3C7F21D3;
  }
  uint64_t v26 = *(void **)(v19 + 8 * v25);
  if (!v26) {
    goto LABEL_48;
  }
  uint64_t v27 = (void *)*v26;
  if (!v27) {
    goto LABEL_48;
  }
  if (v16.u32[0] < 2uLL)
  {
    uint64_t v28 = *(void *)&v15 - 1;
    while (1)
    {
      uint64_t v30 = v27[1];
      if (v30 == 0x3070CB6B3C7F21D3)
      {
        if (v27[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_46;
        }
      }
      else if ((v30 & v28) != v25)
      {
        goto LABEL_48;
      }
      uint64_t v27 = (void *)*v27;
      if (!v27) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v29 = v27[1];
    if (v29 != 0x3070CB6B3C7F21D3)
    {
      if (v29 >= *(void *)&v15) {
        v29 %= *(void *)&v15;
      }
      if (v29 != v25) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v27[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_35:
      uint64_t v27 = (void *)*v27;
      if (!v27) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v31 = v27[5];
  if (*(void *)(v31 + 8) == 0x3070CB6B3C7F21D3)
  {
    uint64_t v32 = *(uint64_t **)(v31 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v32 = 0;
LABEL_49:
  uint64_t v33 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*(void *)(*(void *)(a1 + 48) + 112));
  BOOL v34 = *(unsigned __int8 *)(md::LayoutContext::frameState(a2) + 128) - 1 < 3;
  md::GeometryLogic::tileMatrix((md::GeometryLogic *)v76, v34, a3, 0.0, v35);
  gm::operator*<double,4,4,4>(v77.f64, (double *)(v18 + 808), v76);
  float32x2_t v36 = vcvt_f32_f64(v77);
  float v37 = v78;
  float v38 = v79;
  float32x2_t v39 = vcvt_f32_f64(v80);
  float32x2_t v40 = vcvt_f32_f64(v84);
  float32x4_t v41 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v81), v82);
  float v42 = v85;
  float v43 = v86;
  float32x2_t v44 = vcvt_f32_f64(v83);
  unint64_t v45 = *(void **)(*(void *)(v33 + 64) + 16);
  unint64_t v46 = v45[1];
  uint64_t v47 = v45[9];
  *(float32x2_t *)uint64_t v47 = v36;
  *(float *)(v47 + 8) = v37;
  *(float *)(v47 + 12) = v38;
  *(float32x2_t *)(v47 + 16) = v39;
  float v75 = v41.f32[1];
  *(float32x4_t *)(v47 + 24) = v41;
  *(float32x2_t *)(v47 + 40) = v44;
  *(float32x2_t *)(v47 + 48) = v40;
  *(float *)(v47 + 56) = v42;
  *(float *)(v47 + 60) = v43;
  if (v45[8] > v46) {
    unint64_t v46 = v45[8];
  }
  v45[7] = 0;
  v45[8] = v46;
  uint64_t v48 = md::LayoutContext::frameState(a2);
  md::GeometryContext::transformConstantData(v77.f64, v32, &a3->_type, *(unsigned __int8 *)(v48 + 128), 0.0, 0.0);
  uint64_t v49 = *(void *)(v33 + 64);
  float64x2_t v50 = v77;
  *(float64_t *)(v49 + 32) = v77.f64[0];
  *(void *)(v49 + 40) = 0;
  uint64_t v51 = *(void *)(v33 + 160);
  if (*(void *)&v50.f64[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v50.f64[1] + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v52 = *(std::__shared_weak_count **)(v51 + 40);
  *(float64x2_t *)(v51 + 32) = v50;
  if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
    std::__shared_weak_count::__release_weak(v52);
  }
  float64_t v53 = v77.f64[1];
  if (*(void *)&v77.f64[1]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v77.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(float64_t))(**(void **)&v53 + 16))(COERCE_FLOAT64_T(*(void *)&v53));
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v53);
  }
  uint64_t v54 = **(void ***)(v33 + 64);
  unint64_t v55 = v54[1];
  id v56 = (_DWORD *)v54[9];
  _DWORD *v56 = a4->i32[0];
  v56[1] = a4->i32[1];
  v56[2] = a4->i32[2];
  v56[3] = a4->i32[3];
  if (v54[8] > v55) {
    unint64_t v55 = v54[8];
  }
  v54[7] = 0;
  v54[8] = v55;
  int16x8_t v57 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 48) + 160));
  v57[8] = *(void *)md::DebugLayerRenderResources::unitQuadMesh(*(md::DebugLayerRenderResources **)(a1 + 48));
  v57[4] = v33;
  v57[3] = *(void *)(*(void *)(a1 + 48) + 192);
  ggl::CommandBuffer::pushRenderItem(a5, (uint64_t)v57);
  id v58 = v13;
  float32x2_t v59 = (int8x16_t *)[v58 UTF8String];
  [*(id *)a2 sizeInPixels];
  *(float *)&v60.i32[1] = v75;
  *(float *)v60.i32 = v43 + (float)((float)(v75 + v38) * 0.5);
  float32x2_t v61 = vdiv_f32(vmla_f32(v40, (float32x2_t)0x3F0000003F000000, vadd_f32(v39, v36)), (float32x2_t)vdup_lane_s32(v60, 0));
  __asm { FMOV            V3.2S, #1.0 }
  v67.i32[0] = vadd_f32(v61, _D3).u32[0];
  v67.i32[1] = vsub_f32(_D3, v61).i32[1];
  v69.f64[1] = v68;
  __asm { FMOV            V1.2D, #0.5 }
  *(float32x2_t *)&v69.f64[0] = vcvt_f32_f64(vmulq_f64(vmulq_f64(v69, _Q1), vcvtq_f64_f32(v67)));
  int16x8_t v71 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(*a4, (float32x4_t)vdupq_n_s32(0x437F0000u)));
  *(int16x4_t *)v71.i8 = vmovn_s32((int32x4_t)v71);
  *(_DWORD *)(a6 + 96) = vmovn_s16(v71).u32[0];
  *(float64_t *)(a6 + 8) = v69.f64[0];
  *(void *)(a6 + 40) = 0x100000001;
  size_t v72 = strlen(v59->i8);
  ggl::DebugConsole::drawString(a6, v59, v72, v73, v74);
}

void sub_1A20ECB5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::DebugRenderLayer::renderTexturedQuadTile(md::DebugRenderLayer *this, uint64_t **a2, QuadTile *a3, ggl::Texture2D *a4, ggl::CommandBuffer *a5, float a6)
{
  uint64_t v7 = a5;
  uint64_t v8 = a4;
  uint64_t v9 = a3;
  unint64_t v10 = (md::LayoutContext *)a2;
  uint64_t v12 = a2[1];
  int8x8_t v13 = (int8x8_t)v12[1];
  if (!*(void *)&v13)
  {
    uint64_t v16 = 0;
    goto LABEL_48;
  }
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v13);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    uint64_t v15 = 0x1AF456233693CD46;
    if (*(void *)&v13 <= 0x1AF456233693CD46uLL) {
      uint64_t v15 = 0x1AF456233693CD46uLL % *(void *)&v13;
    }
  }
  else
  {
    uint64_t v15 = (*(void *)&v13 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v17 = *v12;
  uint64_t v18 = *(void **)(v17 + 8 * v15);
  if (!v18) {
    goto LABEL_25;
  }
  uint64_t v19 = (void *)*v18;
  if (!v19) {
    goto LABEL_25;
  }
  if (v14.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v21 = v19[1];
      if (v21 == 0x1AF456233693CD46)
      {
        if (v19[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v21 & (*(void *)&v13 - 1)) != v15)
      {
        goto LABEL_25;
      }
      uint64_t v19 = (void *)*v19;
      if (!v19) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v20 = v19[1];
    if (v20 == 0x1AF456233693CD46) {
      break;
    }
    if (v20 >= *(void *)&v13) {
      v20 %= *(void *)&v13;
    }
    if (v20 != v15) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v19 = (void *)*v19;
    if (!v19) {
      goto LABEL_25;
    }
  }
  if (v19[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v22 = v19[5];
  if (*(void *)(v22 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v16 = *(void *)(v22 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v16 = 0;
LABEL_26:
  if (v14.u32[0] > 1uLL)
  {
    uint64_t v23 = 0x3070CB6B3C7F21D3;
    if (*(void *)&v13 <= 0x3070CB6B3C7F21D3uLL) {
      uint64_t v23 = 0x3070CB6B3C7F21D3uLL % *(void *)&v13;
    }
  }
  else
  {
    uint64_t v23 = (*(void *)&v13 - 1) & 0x3070CB6B3C7F21D3;
  }
  uint64_t v24 = *(void **)(v17 + 8 * v23);
  if (!v24) {
    goto LABEL_48;
  }
  uint64_t v25 = (void *)*v24;
  if (!v25) {
    goto LABEL_48;
  }
  if (v14.u32[0] < 2uLL)
  {
    uint64_t v26 = *(void *)&v13 - 1;
    while (1)
    {
      uint64_t v28 = v25[1];
      if (v28 == 0x3070CB6B3C7F21D3)
      {
        if (v25[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_46;
        }
      }
      else if ((v28 & v26) != v23)
      {
        goto LABEL_48;
      }
      uint64_t v25 = (void *)*v25;
      if (!v25) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v27 = v25[1];
    if (v27 != 0x3070CB6B3C7F21D3)
    {
      if (v27 >= *(void *)&v13) {
        v27 %= *(void *)&v13;
      }
      if (v27 != v23) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v25[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_35:
      uint64_t v25 = (void *)*v25;
      if (!v25) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v29 = v25[5];
  if (*(void *)(v29 + 8) == 0x3070CB6B3C7F21D3)
  {
    uint64_t v30 = *(uint64_t **)(v29 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v30 = 0;
LABEL_49:
  uint64_t v31 = *(void *)(*((void *)this + 6) + 144);
  uint64_t v32 = *(void *)(v31 + 8);
  if (v32 == *(void *)v31)
  {
    uint64_t v48 = *(void *)(v31 + 88);
    if (!v48)
    {
LABEL_117:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_118:
      abort();
    }
    uint64_t v33 = (*(uint64_t (**)(uint64_t))(*(void *)v48 + 48))(v48);
    BOOL v34 = *(uint64_t **)(v31 + 40);
    unint64_t v49 = *(void *)(v31 + 48);
    if ((unint64_t)v34 < v49)
    {
LABEL_61:
      if (v34) {
        *BOOL v34 = v33;
      }
      float64x2_t v50 = v34 + 1;
      goto LABEL_101;
    }
    uint64_t v106 = v16;
    float32x2_t v36 = v10;
    float v37 = v30;
    float v38 = v8;
    uint64_t v51 = v9;
    uint64_t v52 = v7;
    uint64_t v53 = *(void *)(v31 + 32);
    uint64_t v54 = ((uint64_t)v34 - v53) >> 3;
    unint64_t v43 = v54 + 1;
    if ((unint64_t)(v54 + 1) >> 61) {
      goto LABEL_118;
    }
    uint64_t v55 = v49 - v53;
    if (v55 >> 2 > v43) {
      unint64_t v43 = v55 >> 2;
    }
    if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v43)
    {
      uint64_t v56 = 8 * v43;
      uint64_t v57 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v31 + 56) + 16))(*(void *)(v31 + 56), 8 * v43, 8);
      uint64_t v47 = (uint64_t *)(v57 + 8 * v54);
      unint64_t v43 = v57 + v56;
      if (v57) {
        uint64_t *v47 = v33;
      }
    }
    else
    {
      uint64_t v47 = (uint64_t *)(8 * v54);
    }
    uint64_t v7 = v52;
    float64x2_t v50 = v47 + 1;
    uint64_t v67 = *(void *)(v31 + 32);
    uint64_t v58 = *(void *)(v31 + 40);
    uint64_t v9 = v51;
    if (v58 == v67) {
      goto LABEL_88;
    }
    unint64_t v68 = v58 - v67 - 8;
    uint64_t v8 = v38;
    if (v68 < 0x38)
    {
      uint64_t v70 = *(void *)(v31 + 40);
      uint64_t v30 = v37;
    }
    else
    {
      uint64_t v30 = v37;
      if ((unint64_t)(v58 - (void)v47) >= 0x20)
      {
        uint64_t v69 = (v68 >> 3) + 1;
        uint64_t v70 = v58 - 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
        int16x8_t v71 = v47 - 2;
        size_t v72 = (long long *)(v58 - 16);
        uint64_t v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
        unint64_t v10 = v36;
        do
        {
          long long v74 = *v72;
          *((_OWORD *)v71 - 1) = *(v72 - 1);
          *(_OWORD *)int16x8_t v71 = v74;
          v71 -= 4;
          v72 -= 2;
          v73 -= 4;
        }
        while (v73);
        v47 -= v69 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v16 = v106;
        if (v69 == (v69 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_98;
        }
        goto LABEL_97;
      }
      uint64_t v70 = *(void *)(v31 + 40);
    }
    unint64_t v10 = v36;
    uint64_t v16 = v106;
    do
    {
LABEL_97:
      uint64_t v76 = *(void *)(v70 - 8);
      v70 -= 8;
      *--uint64_t v47 = v76;
    }
    while (v70 != v67);
LABEL_98:
    uint64_t v58 = *(void *)(v31 + 32);
    goto LABEL_99;
  }
  uint64_t v33 = *(void *)(v32 - 8);
  *(void *)(v31 + 8) = v32 - 8;
  BOOL v34 = *(uint64_t **)(v31 + 40);
  unint64_t v35 = *(void *)(v31 + 48);
  if ((unint64_t)v34 < v35) {
    goto LABEL_61;
  }
  uint64_t v106 = v16;
  float32x2_t v36 = (const md::LayoutContext *)a2;
  float v37 = v30;
  float v38 = a4;
  uint64_t v41 = *(void *)(v31 + 32);
  uint64_t v42 = ((uint64_t)v34 - v41) >> 3;
  unint64_t v43 = v42 + 1;
  if ((unint64_t)(v42 + 1) >> 61) {
    goto LABEL_118;
  }
  uint64_t v44 = v35 - v41;
  if (v44 >> 2 > v43) {
    unint64_t v43 = v44 >> 2;
  }
  if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v43 = 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v43)
  {
    uint64_t v45 = 8 * v43;
    uint64_t v46 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v31 + 56) + 16))(*(void *)(v31 + 56), 8 * v43, 8);
    uint64_t v47 = (uint64_t *)(v46 + 8 * v42);
    unint64_t v43 = v46 + v45;
    if (v46) {
      uint64_t *v47 = v33;
    }
  }
  else
  {
    uint64_t v47 = (uint64_t *)(8 * v42);
  }
  uint64_t v7 = a5;
  float64x2_t v50 = v47 + 1;
  uint64_t v59 = *(void *)(v31 + 32);
  uint64_t v58 = *(void *)(v31 + 40);
  uint64_t v9 = a3;
  if (v58 != v59)
  {
    unint64_t v60 = v58 - v59 - 8;
    uint64_t v8 = v38;
    if (v60 < 0x38)
    {
      uint64_t v62 = *(void *)(v31 + 40);
      uint64_t v30 = v37;
    }
    else
    {
      uint64_t v30 = v37;
      if ((unint64_t)(v58 - (void)v47) >= 0x20)
      {
        uint64_t v61 = (v60 >> 3) + 1;
        uint64_t v62 = v58 - 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v63 = v47 - 2;
        uint64_t v64 = (long long *)(v58 - 16);
        uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
        unint64_t v10 = v36;
        do
        {
          long long v66 = *v64;
          *((_OWORD *)v63 - 1) = *(v64 - 1);
          *(_OWORD *)uint64_t v63 = v66;
          v63 -= 4;
          v64 -= 2;
          v65 -= 4;
        }
        while (v65);
        v47 -= v61 & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v16 = v106;
        if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_98;
        }
        do
        {
LABEL_92:
          uint64_t v75 = *(void *)(v62 - 8);
          v62 -= 8;
          *--uint64_t v47 = v75;
        }
        while (v62 != v59);
        goto LABEL_98;
      }
      uint64_t v62 = *(void *)(v31 + 40);
    }
    unint64_t v10 = v36;
    uint64_t v16 = v106;
    goto LABEL_92;
  }
LABEL_88:
  uint64_t v8 = v38;
  uint64_t v30 = v37;
  unint64_t v10 = v36;
  uint64_t v16 = v106;
LABEL_99:
  *(void *)(v31 + 32) = v47;
  *(void *)(v31 + 40) = v50;
  uint64_t v77 = *(void *)(v31 + 48);
  *(void *)(v31 + 48) = v43;
  if (v58) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v31 + 56) + 40))(*(void *)(v31 + 56), v58, v77 - v58);
  }
LABEL_101:
  *(void *)(v31 + 40) = v50;
  *(void *)&v108[0].f64[0] = v33;
  uint64_t v78 = *(void *)(v31 + 120);
  if (!v78) {
    goto LABEL_117;
  }
  (*(void (**)(uint64_t, float64x2_t *))(*(void *)v78 + 48))(v78, v108);
  BOOL v79 = *(unsigned __int8 *)(md::LayoutContext::frameState(v10) + 128) - 1 < 3;
  md::GeometryLogic::tileMatrix((md::GeometryLogic *)v107, v79, v9, 0.0, v80);
  gm::operator*<double,4,4,4>(v108[0].f64, (double *)(v16 + 808), v107);
  float32x2_t v81 = vcvt_f32_f64(v108[1]);
  float32x2_t v82 = vcvt_f32_f64(v108[2]);
  float32x2_t v83 = vcvt_f32_f64(v108[3]);
  float32x2_t v84 = vcvt_f32_f64(v108[4]);
  float32x2_t v85 = vcvt_f32_f64(v108[5]);
  float32x2_t v86 = vcvt_f32_f64(v108[6]);
  float32x2_t v87 = vcvt_f32_f64(v108[7]);
  uint64_t v88 = **(void ***)(v33 + 64);
  unint64_t v89 = v88[1];
  uint64_t v90 = (float32x2_t *)v88[9];
  *uint64_t v90 = vcvt_f32_f64(v108[0]);
  v90[1] = v81;
  v90[2] = v82;
  v90[3] = v83;
  v90[4] = v84;
  v90[5] = v85;
  v90[6] = v86;
  v90[7] = v87;
  if (v88[8] > v89) {
    unint64_t v89 = v88[8];
  }
  v88[7] = 0;
  v88[8] = v89;
  md::GeometryContext::transformConstantData(v108[0].f64, v30, &v9->_type, *(unsigned __int8 *)(v16 + 3776), 0.0, 0.0);
  uint64_t v91 = *(void *)(v33 + 64);
  float64x2_t v92 = v108[0];
  *(float64_t *)(v91 + 16) = v108[0].f64[0];
  *(void *)(v91 + 24) = 0;
  uint64_t v93 = *(void *)(v33 + 160);
  if (*(void *)&v92.f64[1]) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v92.f64[1] + 8), 1uLL, memory_order_relaxed);
  }
  float v94 = *(std::__shared_weak_count **)(v93 + 24);
  *(float64x2_t *)(v93 + 16) = v92;
  if (v94 && !atomic_fetch_add(&v94->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
    std::__shared_weak_count::__release_weak(v94);
  }
  float64_t v95 = v108[0].f64[1];
  if (*(void *)&v108[0].f64[1]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v108[0].f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(float64_t))(**(void **)&v95 + 16))(COERCE_FLOAT64_T(*(void *)&v95));
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v95);
  }
  uint64_t v96 = *(void **)(*(void *)(v33 + 64) + 48);
  unint64_t v97 = v96[1];
  uint64_t v98 = v96[9];
  *(_DWORD *)(v98 + 8) = 1065353216;
  __asm { FMOV            V0.4S, #1.0 }
  *(void *)uint64_t v98 = _Q0;
  *(float *)(v98 + 12) = a6;
  if (v96[8] > v97) {
    unint64_t v97 = v96[8];
  }
  v96[7] = 0;
  v96[8] = v97;
  if (!v8) {
    uint64_t v8 = *(ggl::Texture2D **)(*((void *)this + 6) + 240);
  }
  **(void **)(v33 + 96) = v8;
  unint64_t v104 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*((void *)this + 6) + 160));
  v104[8] = *(void *)md::DebugLayerRenderResources::unitTexturedMesh(*((md::DebugLayerRenderResources **)this + 6));
  v104[4] = v33;
  v104[3] = *(void *)(*((void *)this + 6) + 192);
  return ggl::CommandBuffer::pushRenderItem((uint64_t)v7, (uint64_t)v104);
}

uint64_t md::DebugRenderLayer::renderScreenTexturedQuad(uint64_t a1, md::LayoutContext *this, uint64_t a3, uint64_t a4, double a5, float a6, float a7)
{
  uint64_t v13 = md::LayoutContext::frameState(this);
  double v14 = *(double *)(v13 + 496);
  double v15 = *(double *)(v13 + 504);
  double v16 = v15 * v14;
  double v17 = v14 / v15;
  if (v16 <= 0.0) {
    double v18 = 1.0;
  }
  else {
    double v18 = v17;
  }
  uint64_t v19 = *(void *)(*(void *)(a1 + 48) + 152);
  uint64_t v20 = *(void *)(v19 + 8);
  if (v20 == *(void *)v19)
  {
    uint64_t v31 = *(void *)(v19 + 88);
    if (!v31)
    {
LABEL_59:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_60:
      abort();
    }
    uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 48))(v31);
    uint64_t v22 = *(uint64_t **)(v19 + 40);
    unint64_t v32 = *(void *)(v19 + 48);
    if ((unint64_t)v22 >= v32)
    {
      uint64_t v34 = *(void *)(v19 + 32);
      uint64_t v35 = ((uint64_t)v22 - v34) >> 3;
      unint64_t v26 = v35 + 1;
      if ((unint64_t)(v35 + 1) >> 61) {
        goto LABEL_60;
      }
      uint64_t v36 = v32 - v34;
      if (v36 >> 2 > v26) {
        unint64_t v26 = v36 >> 2;
      }
      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v26)
      {
        uint64_t v37 = 8 * v26;
        uint64_t v38 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v19 + 56) + 16))(*(void *)(v19 + 56), 8 * v26, 8);
        uint64_t v30 = (uint64_t *)(v38 + 8 * v35);
        unint64_t v26 = v38 + v37;
        if (v38) {
          *uint64_t v30 = v21;
        }
      }
      else
      {
        uint64_t v30 = (uint64_t *)(8 * v35);
      }
      uint64_t v33 = v30 + 1;
      uint64_t v48 = *(void *)(v19 + 32);
      uint64_t v39 = *(void *)(v19 + 40);
      if (v39 == v48) {
        goto LABEL_51;
      }
      unint64_t v49 = v39 - v48 - 8;
      if (v49 < 0x38)
      {
        uint64_t v51 = *(void *)(v19 + 40);
      }
      else if ((unint64_t)(v39 - (void)v30) < 0x20)
      {
        uint64_t v51 = *(void *)(v19 + 40);
      }
      else
      {
        uint64_t v50 = (v49 >> 3) + 1;
        uint64_t v51 = v39 - 8 * (v50 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v52 = v30 - 2;
        uint64_t v53 = (long long *)(v39 - 16);
        uint64_t v54 = v50 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v55 = *v53;
          *((_OWORD *)v52 - 1) = *(v53 - 1);
          *(_OWORD *)uint64_t v52 = v55;
          v52 -= 4;
          v53 -= 2;
          v54 -= 4;
        }
        while (v54);
        v30 -= v50 & 0x3FFFFFFFFFFFFFFCLL;
        if (v50 == (v50 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_50;
        }
      }
      do
      {
        uint64_t v57 = *(void *)(v51 - 8);
        v51 -= 8;
        *--uint64_t v30 = v57;
      }
      while (v51 != v48);
      goto LABEL_50;
    }
  }
  else
  {
    uint64_t v21 = *(void *)(v20 - 8);
    *(void *)(v19 + 8) = v20 - 8;
    uint64_t v22 = *(uint64_t **)(v19 + 40);
    unint64_t v23 = *(void *)(v19 + 48);
    if ((unint64_t)v22 >= v23)
    {
      uint64_t v24 = *(void *)(v19 + 32);
      uint64_t v25 = ((uint64_t)v22 - v24) >> 3;
      unint64_t v26 = v25 + 1;
      if ((unint64_t)(v25 + 1) >> 61) {
        goto LABEL_60;
      }
      uint64_t v27 = v23 - v24;
      if (v27 >> 2 > v26) {
        unint64_t v26 = v27 >> 2;
      }
      if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v26 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v26)
      {
        uint64_t v28 = 8 * v26;
        uint64_t v29 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v19 + 56) + 16))(*(void *)(v19 + 56), 8 * v26, 8);
        uint64_t v30 = (uint64_t *)(v29 + 8 * v25);
        unint64_t v26 = v29 + v28;
        if (v29) {
          *uint64_t v30 = v21;
        }
      }
      else
      {
        uint64_t v30 = (uint64_t *)(8 * v25);
      }
      uint64_t v33 = v30 + 1;
      uint64_t v40 = *(void *)(v19 + 32);
      uint64_t v39 = *(void *)(v19 + 40);
      if (v39 == v40) {
        goto LABEL_51;
      }
      unint64_t v41 = v39 - v40 - 8;
      if (v41 < 0x38)
      {
        uint64_t v43 = *(void *)(v19 + 40);
      }
      else if ((unint64_t)(v39 - (void)v30) < 0x20)
      {
        uint64_t v43 = *(void *)(v19 + 40);
      }
      else
      {
        uint64_t v42 = (v41 >> 3) + 1;
        uint64_t v43 = v39 - 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v44 = v30 - 2;
        uint64_t v45 = (long long *)(v39 - 16);
        uint64_t v46 = v42 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v47 = *v45;
          *((_OWORD *)v44 - 1) = *(v45 - 1);
          *(_OWORD *)uint64_t v44 = v47;
          v44 -= 4;
          v45 -= 2;
          v46 -= 4;
        }
        while (v46);
        v30 -= v42 & 0x3FFFFFFFFFFFFFFCLL;
        if (v42 == (v42 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_50;
        }
      }
      do
      {
        uint64_t v56 = *(void *)(v43 - 8);
        v43 -= 8;
        *--uint64_t v30 = v56;
      }
      while (v43 != v40);
LABEL_50:
      uint64_t v39 = *(void *)(v19 + 32);
LABEL_51:
      *(void *)(v19 + 32) = v30;
      *(void *)(v19 + 40) = v33;
      uint64_t v58 = *(void *)(v19 + 48);
      *(void *)(v19 + 48) = v26;
      if (v39) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v19 + 56) + 40))(*(void *)(v19 + 56), v39, v58 - v39);
      }
      goto LABEL_53;
    }
  }
  if (v22) {
    *uint64_t v22 = v21;
  }
  uint64_t v33 = v22 + 1;
LABEL_53:
  *(void *)(v19 + 40) = v33;
  uint64_t v67 = v21;
  uint64_t v59 = *(void *)(v19 + 120);
  if (!v59) {
    goto LABEL_59;
  }
  float v60 = v18 * a7;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v59 + 48))(v59, &v67);
  uint64_t v61 = **(void ***)(v21 + 64);
  unint64_t v62 = v61[1];
  unint64_t v64 = v61[8];
  uint64_t v63 = v61[9];
  *(double *)uint64_t v63 = a5;
  *(float *)(v63 + 8) = a6;
  *(float *)(v63 + 12) = v60;
  if (v64 > v62) {
    unint64_t v62 = v64;
  }
  v61[7] = 0;
  v61[8] = v62;
  if (!a3) {
    a3 = *(void *)(*(void *)(a1 + 48) + 240);
  }
  **(void **)(v21 + 96) = a3;
  uint64_t v65 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*(void *)(a1 + 48) + 160));
  v65[8] = *(void *)md::DebugLayerRenderResources::unitTexturedMesh(*(md::DebugLayerRenderResources **)(a1 + 48));
  v65[4] = v21;
  v65[3] = *(void *)(*(void *)(a1 + 48) + 192);
  return ggl::CommandBuffer::pushRenderItem(a4, (uint64_t)v65);
}

void md::DebugRenderLayer::paintLayerMeshBounds(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t *a7, _DWORD *a8)
{
  uint64_t v139 = 0;
  float32x4_t v140 = 0;
  float32x4_t v141 = 0;
  md::SceneContext::renderData((md::SceneContext *)&v137, a5, a4);
  long long v9 = v137;
  uint64_t v106 = v138;
  __asm { FMOV            V8.2S, #1.0 }
  uint64_t v103 = a1;
  while ((void)v9 != v106)
  {
    float32x4_t v140 = v139;
    double v15 = *(int8x8_t **)(*(void *)(v9 + 112) + 1320);
    unint64_t v16 = (unint64_t)v15[1];
    uint64_t v108 = *((void *)&v9 + 1);
    uint64_t v107 = v9;
    if ((v16 & (v16 - 1)) != 0)
    {
      unint64_t v18 = 0x64A448A5CD5D38DBLL;
      if (v16 <= 0x64A448A5CD5D38DBLL) {
        unint64_t v18 = 0x64A448A5CD5D38DBLL % v16;
      }
      double v17 = *(void **)(*(void *)v15 + 8 * v18);
      do
      {
        do
          double v17 = (void *)*v17;
        while (v17[1] != 0x64A448A5CD5D38DBLL);
      }
      while (v17[2] != 0x64A448A5CD5D38DBLL);
    }
    else
    {
      double v17 = *(void **)(*(void *)v15 + 8 * ((v16 - 1) & 0x64A448A5CD5D38DBLL));
      do
      {
        do
          double v17 = (void *)*v17;
        while (v17[1] != 0x64A448A5CD5D38DBLL);
      }
      while (v17[2] != 0x64A448A5CD5D38DBLL);
    }
    uint64_t v19 = *(void *)(v17[5] + 32);
    unsigned int v110 = *(unsigned __int8 *)(a6 + 3776) - 1;
    if (v110 >= 3) {
      uint64_t v20 = (double *)(v19 + 304);
    }
    else {
      uint64_t v20 = (double *)(v19 + 176);
    }
    uint64_t v21 = *(void *)(a6 + 5584);
    if (!v21) {
      uint64_t v21 = a6;
    }
    gm::operator*<double,4,4,4>(&v121, (double *)(v21 + 808), v20);
    float v22 = v121;
    float v23 = *(double *)&v122;
    v136[0] = v22;
    v136[1] = v23;
    float v24 = *((double *)&v122 + 1);
    float v25 = v123;
    v136[2] = v24;
    v136[3] = v25;
    float v26 = v124;
    float v27 = v125;
    v136[4] = v26;
    v136[5] = v27;
    *(float *)&unsigned int v28 = v126;
    float v29 = v127;
    LODWORD(v136[6]) = v28;
    v136[7] = v29;
    float v30 = v128;
    float v31 = v129;
    v136[8] = v30;
    v136[9] = v31;
    float v32 = v130;
    float v33 = v131;
    v136[10] = v32;
    v136[11] = v33;
    float v34 = v132;
    float v35 = v133;
    v136[12] = v34;
    v136[13] = v35;
    float v36 = v134;
    float v37 = v135;
    v136[14] = v36;
    v136[15] = v37;
    float v38 = v25 + v22;
    float v39 = v29 + v26;
    float v40 = v33 + v30;
    float v41 = v37 + v34;
    float v42 = v25 - v22;
    float v43 = v29 - v26;
    float v44 = v33 - v30;
    float v45 = v37 - v34;
    float v46 = v25 + v23;
    float v47 = v29 + v27;
    float v48 = v33 + v31;
    float v49 = sqrtf((float)((float)(v46 * v46) + (float)(v47 * v47)) + (float)(v48 * v48));
    float v50 = v25 - v23;
    float v51 = v29 - v27;
    float v52 = v33 - v31;
    float v53 = v29 - *(float *)&v28;
    v54.f32[0] = v24;
    v54.f32[1] = v25 - v24;
    v55.f32[0] = v32;
    v55.f32[1] = v33 - v32;
    float32x2_t v56 = vdiv_f32(_D8, vsqrt_f32(vmla_f32(vmla_f32(vmul_f32(v54, v54), (float32x2_t)__PAIR64__(LODWORD(v53), v28), (float32x2_t)__PAIR64__(LODWORD(v53), v28)), v55, v55)));
    *(float *)&double v121 = v24 * v56.f32[0];
    *((float *)&v121 + 1) = *(float *)&v28 * v56.f32[0];
    *(float *)&long long v122 = v32 * v56.f32[0];
    v54.f32[0] = v36;
    *(float32x2_t *)((char *)&v122 + 4) = vmul_f32(v56, v54);
    HIDWORD(v122) = vmuls_lane_f32(v53, v56, 1);
    double v123 = COERCE_DOUBLE(__PAIR64__(COERCE_UNSIGNED_INT(vmuls_lane_f32(v37 - v36, v56, 1)), COERCE_UNSIGNED_INT(vmuls_lane_f32(v33 - v32, v56, 1))));
    *(float *)&double v124 = (float)(1.0 / v49) * v46;
    *((float *)&v124 + 1) = (float)(1.0 / v49) * v47;
    *(float *)&double v125 = (float)(1.0 / v49) * v48;
    v56.f32[0] = 1.0 / sqrtf((float)((float)(v50 * v50) + (float)(v51 * v51)) + (float)(v52 * v52));
    *((float *)&v125 + 1) = (float)(v37 + v35) * (float)(1.0 / v49);
    *(float *)&double v126 = v56.f32[0] * v50;
    *((float *)&v126 + 1) = v56.f32[0] * v51;
    *(float *)&double v127 = v56.f32[0] * v52;
    float v57 = 1.0 / sqrtf((float)((float)(v38 * v38) + (float)(v39 * v39)) + (float)(v40 * v40));
    *((float *)&v127 + 1) = (float)(v37 - v35) * v56.f32[0];
    *(float *)&double v128 = v57 * v38;
    *((float *)&v128 + 1) = v57 * v39;
    *(float *)&double v129 = v57 * v40;
    float v58 = 1.0 / sqrtf((float)((float)(v42 * v42) + (float)(v43 * v43)) + (float)(v44 * v44));
    *((float *)&v129 + 1) = v41 * v57;
    *(float *)&double v130 = v58 * v42;
    *((float *)&v130 + 1) = v58 * v43;
    *(float *)&double v131 = v58 * v44;
    *((float *)&v131 + 1) = v45 * v58;
    geo::Frustum<float>::calculateCorners((float *)&v121, v136);
    md::GeometryContext::transformConstantData((double *)&v119, a7, (unsigned __int8 *)v19, *(unsigned __int8 *)(a6 + 3776), *(double *)(v19 + 432), *(double *)(v19 + 440));
    uint64_t v109 = (long long *)v20;
    uint64_t v59 = gdc::Registry::storage<md::components::MeshInstance>(v15);
    float v60 = (void *)v59;
    unint64_t v61 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)(v59 + 88) - *(void *)(v59 + 80)) >> 4);
    unint64_t v62 = v141;
    uint64_t v63 = v139;
    if (v61 <= (v141 - v139) >> 6)
    {
      uint64_t v67 = v139;
    }
    else
    {
      if (v61 >> 58) {
LABEL_68:
      }
        abort();
      unint64_t v64 = v140;
      uint64_t v65 = (char *)operator new(0x6DB6DB6DB6DB6DC0 * ((uint64_t)(*(void *)(v59 + 88) - *(void *)(v59 + 80)) >> 4));
      long long v66 = &v65[(v64 - v63) & 0xFFFFFFFFFFFFFFC0];
      uint64_t v67 = v66;
      if (v64 != v63)
      {
        unint64_t v68 = &v65[(v64 - v63) & 0xFFFFFFFFFFFFFFC0];
        do
        {
          uint64_t v67 = v68 - 64;
          long long v69 = *((_OWORD *)v64 - 4);
          long long v70 = *((_OWORD *)v64 - 3);
          long long v71 = *((_OWORD *)v64 - 1);
          *((_OWORD *)v68 - 2) = *((_OWORD *)v64 - 2);
          *((_OWORD *)v68 - 1) = v71;
          *((_OWORD *)v68 - 4) = v69;
          *((_OWORD *)v68 - 3) = v70;
          v64 -= 64;
          v68 -= 64;
        }
        while (v64 != v63);
      }
      unint64_t v62 = &v65[64 * v61];
      uint64_t v139 = v67;
      float32x4_t v140 = v66;
      float32x4_t v141 = v62;
      if (v63) {
        operator delete(v63);
      }
    }
    uint64_t v73 = v60[7];
    uint64_t v72 = v60[8];
    if (v73 != v72)
    {
      uint64_t v74 = v60[10];
      uint64_t v75 = v140;
      do
      {
        long long v111 = xmmword_1A28FC710;
        *(void *)&long long v112 = 0x80000000800000;
        if (v110 > 2)
        {
          md::GeometryLogic::adjustedMeshBounds((uint64_t)&v142, v74 + 36, v119);
        }
        else
        {
          uint64_t v145 = 0;
          int v144 = 0;
          md::GeometryLogic::calculateGeocentricBounds((float32_t *)(v74 + 36), v119, (uint64_t)&v111, (uint64_t)&v144);
          md::GeometryLogic::scaleGeocentricBoundsWithNormal((float32x4_t *)&v142, (float32x2_t *)(v74 + 36), (uint64_t)&v111, (uint64_t)&v144, v119, v76);
        }
        float32x4_t v77 = (float32x4_t)v142;
        uint64_t v78 = v143;
        long long v111 = v142;
        *(void *)&long long v112 = v143;
        if (geo::Intersect::encloses<float>((float *)&v121, (float *)&v111))
        {
          float v79 = v77.f32[3] - v77.f32[0];
          float v80 = *(float *)&v78 - v77.f32[1];
          float v81 = *((float *)&v78 + 1) - v77.f32[2];
          if (v75 < v62)
          {
            *(float *)uint64_t v75 = v79;
            *(void *)(v75 + 12) = 0;
            *(void *)(v75 + 4) = 0;
            *((float *)v75 + 5) = v80;
            *((void *)v75 + 3) = 0;
            *((void *)v75 + 4) = 0;
            *((float *)v75 + 10) = v81;
            *((_DWORD *)v75 + 11) = 0;
            *((void *)v75 + 6) = v77.i64[0];
            *((_DWORD *)v75 + 14) = v77.i32[2];
            *((_DWORD *)v75 + 15) = 1065353216;
            v75 += 64;
          }
          else
          {
            uint64_t v82 = (v75 - v67) >> 6;
            unint64_t v83 = v82 + 1;
            if ((unint64_t)(v82 + 1) >> 58) {
              goto LABEL_68;
            }
            if ((v62 - v67) >> 5 > v83) {
              unint64_t v83 = (v62 - v67) >> 5;
            }
            if ((unint64_t)(v62 - v67) >= 0x7FFFFFFFFFFFFFC0) {
              unint64_t v84 = 0x3FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v84 = v83;
            }
            if (v84)
            {
              if (v84 >> 58) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              float32x2_t v85 = (char *)operator new(v84 << 6);
            }
            else
            {
              float32x2_t v85 = 0;
            }
            float32x2_t v86 = &v85[64 * v82];
            *(float *)float32x2_t v86 = v79;
            *(void *)(v86 + 12) = 0;
            *(void *)(v86 + 4) = 0;
            *((float *)v86 + 5) = v80;
            *((void *)v86 + 3) = 0;
            *((void *)v86 + 4) = 0;
            *((float *)v86 + 10) = v81;
            *((_DWORD *)v86 + 11) = 0;
            *((void *)v86 + 6) = v77.i64[0];
            *((_DWORD *)v86 + 14) = v77.i32[2];
            *((_DWORD *)v86 + 15) = 1065353216;
            if (v75 == v67)
            {
              uint64_t v88 = &v85[64 * v82];
            }
            else
            {
              float32x2_t v87 = &v85[64 * v82];
              do
              {
                uint64_t v88 = v87 - 64;
                long long v89 = *((_OWORD *)v75 - 4);
                long long v90 = *((_OWORD *)v75 - 3);
                long long v91 = *((_OWORD *)v75 - 1);
                *((_OWORD *)v87 - 2) = *((_OWORD *)v75 - 2);
                *((_OWORD *)v87 - 1) = v91;
                *((_OWORD *)v87 - 4) = v89;
                *((_OWORD *)v87 - 3) = v90;
                v75 -= 64;
                v87 -= 64;
              }
              while (v75 != v67);
            }
            unint64_t v62 = &v85[64 * v84];
            uint64_t v75 = v86 + 64;
            uint64_t v139 = v88;
            float32x4_t v141 = v62;
            if (v67) {
              operator delete(v67);
            }
            uint64_t v67 = v88;
          }
          float32x4_t v140 = v75;
        }
        v74 += 112;
        v73 += 8;
      }
      while (v73 != v72);
    }
    md::GeometryLogic::createUnitTransformConstantData((md::GeometryLogic *)&v142);
    long long v92 = v109[5];
    long long v115 = v109[4];
    long long v116 = v92;
    long long v93 = v109[7];
    long long v117 = v109[6];
    long long v118 = v93;
    long long v94 = v109[1];
    long long v111 = *v109;
    long long v112 = v94;
    long long v95 = v109[3];
    long long v113 = v109[2];
    long long v114 = v95;
    uint64_t v96 = (void *)md::DebugLayerRenderResources::unitBoxMesh(*(md::DebugLayerRenderResources **)(v103 + 48));
    md::DebugRenderLayer::renderInstancedMesh(v103, *(void **)(a2 + 8), (double *)&v111, a8, 1, a3, (uint64_t)&v139, v96, (uint64_t *)&v142);
    unint64_t v97 = (std::__shared_weak_count *)*((void *)&v142 + 1);
    if (*((void *)&v142 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v142 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
      std::__shared_weak_count::__release_weak(v97);
      uint64_t v98 = v120;
      if (!v120) {
        goto LABEL_61;
      }
    }
    else
    {
      uint64_t v98 = v120;
      if (!v120) {
        goto LABEL_61;
      }
    }
    if (!atomic_fetch_add(&v98->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
      std::__shared_weak_count::__release_weak(v98);
    }
LABEL_61:
    uint64_t v99 = v107 + 144;
    *((void *)&v9 + 1) = v108;
    if (v107 + 144 != v108)
    {
      while (!*(void *)(v99 + 112))
      {
        v99 += 144;
        if (v99 == v108)
        {
          uint64_t v99 = v108;
          break;
        }
      }
    }
    *(void *)&long long v9 = v99;
  }
  if (v139) {
    operator delete(v139);
  }
}

void sub_1A20EDFAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a39);
  float v41 = *(void **)(v39 - 216);
  if (v41) {
    operator delete(v41);
  }
  _Unwind_Resume(a1);
}

void md::DebugRenderLayer::layout(md::LayoutContext const&)::$_14::operator()(uint64_t a1, _DWORD *a2, float *a3)
{
  uint64_t v6 = *(float **)a1;
  md::GeometryLogic::adjustedMeshBounds((uint64_t)v38, (uint64_t)(a3 + 9), **(void **)(a1 + 8));
  if (geo::Intersect::encloses<float>(v6, v38))
  {
    float v8 = a3[9];
    float v7 = a3[10];
    float v9 = a3[11];
    float v10 = a3[12] - v8;
    float v11 = a3[13] - v7;
    float v12 = a3[14] - v9;
    if (*a2)
    {
      uint64_t v13 = *(float ***)(a1 + 16);
      double v15 = v13[1];
      unint64_t v14 = (unint64_t)v13[2];
      if ((unint64_t)v15 >= v14)
      {
        unint64_t v16 = *v13;
        uint64_t v17 = ((char *)v15 - (char *)*v13) >> 6;
        unint64_t v18 = v17 + 1;
        if (!((unint64_t)(v17 + 1) >> 58))
        {
          uint64_t v19 = v14 - (void)v16;
          if (v19 >> 5 > v18) {
            unint64_t v18 = v19 >> 5;
          }
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFC0) {
            unint64_t v20 = 0x3FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v20 = v18;
          }
          if (!v20)
          {
            uint64_t v21 = 0;
            goto LABEL_25;
          }
          if (!(v20 >> 58))
          {
            uint64_t v21 = (char *)operator new(v20 << 6);
LABEL_25:
            float v30 = &v21[64 * v17];
            *(float *)float v30 = v10;
            *(void *)(v30 + 12) = 0;
            *(void *)(v30 + 4) = 0;
            *((float *)v30 + 5) = v11;
            float v31 = &v21[64 * v20];
            *((void *)v30 + 3) = 0;
            *((void *)v30 + 4) = 0;
            *((float *)v30 + 10) = v12;
            *((_DWORD *)v30 + 11) = 0;
            *((float *)v30 + 12) = v8;
            *((float *)v30 + 13) = v7;
            *((_DWORD *)v30 + 15) = 1065353216;
            float v23 = (float *)(v30 + 64);
            *((float *)v30 + 14) = v9;
            if (v15 == v16) {
              goto LABEL_32;
            }
            do
            {
              long long v32 = *((_OWORD *)v15 - 4);
              long long v33 = *((_OWORD *)v15 - 3);
              long long v34 = *((_OWORD *)v15 - 1);
              *((_OWORD *)v30 - 2) = *((_OWORD *)v15 - 2);
              *((_OWORD *)v30 - 1) = v34;
              *((_OWORD *)v30 - 4) = v32;
              *((_OWORD *)v30 - 3) = v33;
              v30 -= 64;
              v15 -= 16;
            }
            while (v15 != v16);
            goto LABEL_31;
          }
LABEL_37:
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v13 = *(float ***)(a1 + 24);
      double v15 = v13[1];
      unint64_t v22 = (unint64_t)v13[2];
      if ((unint64_t)v15 >= v22)
      {
        float v24 = *v13;
        uint64_t v25 = ((char *)v15 - (char *)*v13) >> 6;
        unint64_t v26 = v25 + 1;
        if (!((unint64_t)(v25 + 1) >> 58))
        {
          uint64_t v27 = v22 - (void)v24;
          if (v27 >> 5 > v26) {
            unint64_t v26 = v27 >> 5;
          }
          if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFC0) {
            unint64_t v28 = 0x3FFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v28 = v26;
          }
          if (v28)
          {
            if (v28 >> 58) {
              goto LABEL_37;
            }
            float v29 = (char *)operator new(v28 << 6);
          }
          else
          {
            float v29 = 0;
          }
          float v30 = &v29[64 * v25];
          *(float *)float v30 = v10;
          *(void *)(v30 + 12) = 0;
          *(void *)(v30 + 4) = 0;
          *((float *)v30 + 5) = v11;
          float v31 = &v29[64 * v28];
          *((void *)v30 + 3) = 0;
          *((void *)v30 + 4) = 0;
          *((float *)v30 + 10) = v12;
          *((_DWORD *)v30 + 11) = 0;
          *((float *)v30 + 12) = v8;
          *((float *)v30 + 13) = v7;
          *((_DWORD *)v30 + 15) = 1065353216;
          float v23 = (float *)(v30 + 64);
          *((float *)v30 + 14) = v9;
          if (v15 == v24) {
            goto LABEL_32;
          }
          do
          {
            long long v35 = *((_OWORD *)v15 - 4);
            long long v36 = *((_OWORD *)v15 - 3);
            long long v37 = *((_OWORD *)v15 - 1);
            *((_OWORD *)v30 - 2) = *((_OWORD *)v15 - 2);
            *((_OWORD *)v30 - 1) = v37;
            *((_OWORD *)v30 - 4) = v35;
            *((_OWORD *)v30 - 3) = v36;
            v30 -= 64;
            v15 -= 16;
          }
          while (v15 != v24);
LABEL_31:
          double v15 = *v13;
LABEL_32:
          *uint64_t v13 = (float *)v30;
          v13[1] = v23;
          v13[2] = (float *)v31;
          if (v15) {
            operator delete(v15);
          }
          goto LABEL_34;
        }
LABEL_36:
        abort();
      }
    }
    *double v15 = v10;
    *(void *)(v15 + 3) = 0;
    *(void *)(v15 + 1) = 0;
    v15[5] = v11;
    *((void *)v15 + 3) = 0;
    *((void *)v15 + 4) = 0;
    v15[10] = v12;
    v15[11] = 0.0;
    v15[12] = v8;
    v15[13] = v7;
    v15[14] = v9;
    float v23 = v15 + 16;
    v15[15] = 1.0;
LABEL_34:
    v13[1] = v23;
  }
}

char *md::DebugLayerRenderResources::unitRectMesh(md::DebugLayerRenderResources *this)
{
  uint64_t v1 = (char *)this + 272;
  if (!*((void *)this + 34))
  {
    uint64_t v3 = operator new(0xA8uLL);
    v3[1] = 0;
    int8x8_t v3[2] = 0;
    void *v3 = &unk_1EF583120;
    uint64_t v4 = ggl::CommonMesh::Pos4Mesh::Pos4Mesh((ggl::CommonMesh::Pos4Mesh *)(v3 + 3), "/DebugSharedUnitRectMesh");
    long long v5 = (std::__shared_weak_count *)*((void *)this + 35);
    *((void *)this + 34) = v4;
    *((void *)this + 35) = v3;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    uint64_t v6 = **(void **)(*(void *)v1 + 64);
    unint64_t v7 = 8 * *(void *)(v6 + 8);
    uint64_t v8 = *(void *)(v6 + 72);
    unint64_t v9 = *(void *)(v6 + 80) - v8;
    if (v7 != v9)
    {
      if (v7 <= v9)
      {
        if (v7 < v9) {
          *(void *)(v6 + 80) = v8 + v7;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v6 + 72, v7 - v9);
      }
      float v10 = *(std::__shared_weak_count **)(v6 + 32);
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 0;
      if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
      *(void *)(v6 + 120) = 0;
      *(_DWORD *)(v6 + 112) = 0;
      uint64_t v11 = *(void *)(v6 + 80) - *(void *)(v6 + 72);
      *(void *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = v11;
      *(void *)(v6 + 56) = 0;
      *(void *)(v6 + 64) = v11;
      uint64_t v6 = **(void **)(*(void *)v1 + 64);
      unint64_t v7 = 8 * *(void *)(v6 + 8);
    }
    unint64_t v13 = *(void *)(v6 + 64);
    float v12 = *(_OWORD **)(v6 + 72);
    *float v12 = xmmword_1A28FCDD0;
    v12[1] = xmmword_1A28FC6C0;
    v12[2] = xmmword_1A28FC6C0;
    v12[3] = xmmword_1A28FD270;
    v12[4] = xmmword_1A28FD270;
    v12[5] = xmmword_1A28FD290;
    v12[6] = xmmword_1A28FD290;
    v12[7] = xmmword_1A28FCDD0;
    if (v13 > v7) {
      unint64_t v7 = v13;
    }
    *(void *)(v6 + 56) = 0;
    *(void *)(v6 + 64) = v7;
  }
  return v1;
}

uint64_t md::DebugLayerRenderResources::cameraBoxMesh(md::DebugLayerRenderResources *this)
{
  if (!*((void *)this + 40))
  {
    uint64_t v3 = (std::__shared_weak_count *)operator new(0xF8uLL);
    v3->__shared_owners_ = 0;
    v3->__shared_weak_owners_ = 0;
    v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5843F0;
    ggl::BufferData::BufferData((uint64_t)&v3[1], 16, 0, 0, 6, 8);
    v3[9].__shared_weak_owners_ = (uint64_t)"/Debug/CameraBox/VertexData";
    v3[10].__vftable = (std::__shared_weak_count_vtbl *)&ggl::CommonMesh::bufferPos4Reflection;
    v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55BFC8;
    v3[9].__shared_owners_ = (uint64_t)&unk_1EF55BFE8;
    float v29 = v3 + 1;
    float v30 = v3;
    uint64_t v4 = operator new(0xF8uLL);
    v4[1] = 0;
    v4[2] = 0;
    *uint64_t v4 = &unk_1EF583D28;
    uint64_t v5 = ggl::BufferData::BufferData((uint64_t)(v4 + 3), 2, 1, 0, 6, 24);
    *((_DWORD *)v4 + 60) = 0;
    v4[3] = &unk_1EF55B630;
    v4[4] = 2;
    v4[28] = &unk_1EF55B650;
    v4[29] = "/Debug/CameraBox/IndexData";
    uint64_t v27 = v5;
    unint64_t v28 = (std::__shared_weak_count *)v4;
    *(void *)&long long v6 = 0;
    *(void *)&long long v7 = 0;
    *((void *)&v7 + 1) = v3 + 1;
    long long v24 = v7;
    unint64_t v25 = 8 * v3[1].__shared_owners_;
    unint64_t v26 = v3[4].__vftable;
    *(_OWORD *)&v26->~__shared_weak_count = xmmword_1A28FD2B0;
    *(_OWORD *)&v26->__on_zero_shared = xmmword_1A28FE3C0;
    *(_OWORD *)&v26->__on_zero_shared_weaunint64_t k = xmmword_1A28FE3D0;
    *(_OWORD *)&v26[1].~__shared_weak_count_0 = xmmword_1A28FD270;
    *(_OWORD *)&v26[1].__get_deleter = xmmword_1A28FE3E0;
    *(_OWORD *)&v26[2].~__shared_weak_count = xmmword_1A28FC890;
    __asm { FMOV            V2.4S, #1.0 }
    *(_OWORD *)&v26[2].__on_zero_shared = xmmword_1A28FE3F0;
    *(_OWORD *)&v26[2].__on_zero_shared_weaunint64_t k = _Q2;
    *((void *)&v6 + 1) = v5;
    long long v22 = v6;
    float v23 = (_OWORD *)v4[12];
    _OWORD *v23 = xmmword_1A28FE410;
    v23[1] = xmmword_1A28FE420;
    v23[2] = xmmword_1A28FE430;
    unint64_t v13 = operator new(0xA8uLL);
    v13[1] = 0;
    v13[2] = 0;
    *unint64_t v13 = &unk_1EF583120;
    uint64_t v14 = std::construct_at[abi:nn180100]<ggl::CommonMesh::Pos4Mesh,char const(&)[22],std::shared_ptr<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4>> &,std::shared_ptr<ggl::IndexDataTyped<unsigned short>> &,ggl::CommonMesh::Pos4Mesh*>((uint64_t)(v13 + 3), (uint64_t)"/Debug/CameraBox/Mesh", (uint64_t)&v3[1], v3, &v27);
    double v15 = (std::__shared_weak_count *)*((void *)this + 41);
    *((void *)this + 40) = v14;
    *((void *)this + 41) = v13;
    if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    if (v23)
    {
      if ((void)v22 && *(unsigned char *)(*((void *)&v22 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v22 + 64))();
      }
      uint64_t v17 = *(void *)(*((void *)&v22 + 1) + 56);
      unint64_t v16 = *(void *)(*((void *)&v22 + 1) + 64);
      if (v16 == v17) {
        uint64_t v17 = *(void *)(*((void *)&v22 + 1) + 80) - *(void *)(*((void *)&v22 + 1) + 72);
      }
      if (v17) {
        uint64_t v17 = 0;
      }
      if (v16 <= 0x30) {
        unint64_t v16 = 48;
      }
      *(void *)(*((void *)&v22 + 1) + 56) = v17;
      *(void *)(*((void *)&v22 + 1) + 64) = v16;
    }
    if (v26 && v25)
    {
      if ((void)v24 && *(unsigned char *)(*((void *)&v24 + 1) + 17) != 2) {
        (*(void (**)(void))(*(void *)v24 + 64))();
      }
      uint64_t v19 = *(void *)(*((void *)&v24 + 1) + 56);
      unint64_t v18 = *(void *)(*((void *)&v24 + 1) + 64);
      if (v18 == v19) {
        uint64_t v19 = *(void *)(*((void *)&v24 + 1) + 80) - *(void *)(*((void *)&v24 + 1) + 72);
      }
      if (v19) {
        uint64_t v19 = 0;
      }
      if (v18 <= v25) {
        unint64_t v18 = v25;
      }
      if (v18 == v19) {
        unint64_t v18 = v19 + *(void *)(*((void *)&v24 + 1) + 80) - *(void *)(*((void *)&v24 + 1) + 72);
      }
      *(void *)(*((void *)&v24 + 1) + 56) = v19;
      *(void *)(*((void *)&v24 + 1) + 64) = v18;
    }
    unint64_t v20 = v28;
    if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
    uint64_t v21 = v30;
    if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
  return (uint64_t)this + 320;
}

void sub_1A20EE8DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v18);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a9);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v16 - 80);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v16 - 64);
  _Unwind_Resume(a1);
}

ggl::CommonMesh::Pos4Mesh *std::make_shared[abi:nn180100]<ggl::CommonMesh::Pos4Mesh,char const(&)[20],void>(ggl::CommonMesh::Pos4Mesh **a1)
{
  uint64_t v2 = operator new(0xA8uLL);
  v2[1] = 0;
  v2[2] = 0;
  void *v2 = &unk_1EF583120;
  uint64_t result = ggl::CommonMesh::Pos4Mesh::Pos4Mesh((ggl::CommonMesh::Pos4Mesh *)(v2 + 3), "/DebugFootprintMesh");
  *a1 = result;
  a1[1] = (ggl::CommonMesh::Pos4Mesh *)v2;
  return result;
}

void md::DebugRenderLayer::paintModelTiles(md::DebugRenderLayer *this, const md::LayoutContext *a2, float32x2_t *a3, ggl::CommandBuffer *a4)
{
  uint64_t v8 = (void *)((char *)this + 96);
  std::__hash_table<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::__unordered_map_hasher<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,true>,std::__unordered_map_equal<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>>>::clear((void *)this + 12);
  uint64_t v9 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  float v10 = (void *)*((void *)this + 12);
  *((void *)this + 12) = v9;
  if (v10) {
    operator delete(v10);
  }
  uint64_t v11 = *((void *)this + 9);
  *((void *)this + 14) = v11;
  unint64_t v12 = *((void *)this + 8);
  *((void *)this + 13) = v12;
  *((void *)this + 8) = 0;
  uint64_t v13 = *((void *)this + 10);
  *((void *)this + 15) = v13;
  *((_DWORD *)this + 32) = *((_DWORD *)this + 22);
  if (v13)
  {
    unint64_t v14 = *(void *)(v11 + 8);
    if ((v12 & (v12 - 1)) != 0)
    {
      BOOL v16 = v14 >= v12;
      unint64_t v15 = v14 % v12;
      if (!v16) {
        unint64_t v15 = v14;
      }
    }
    else
    {
      unint64_t v15 = v14 & (v12 - 1);
    }
    *(void *)(*v8 + 8 * v15) = (char *)this + 112;
    *((void *)this + 9) = 0;
    *((void *)this + 10) = 0;
  }
  std::__hash_table<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::__unordered_map_hasher<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,true>,std::__unordered_map_equal<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>>>::clear((void *)this + 7);
  uint64_t v17 = (void *)*((void *)a2 + 1);
  int8x8_t v18 = (int8x8_t)v17[1];
  uint64_t v67 = v8;
  if (!*(void *)&v18) {
    goto LABEL_32;
  }
  uint8x8_t v19 = (uint8x8_t)vcnt_s8(v18);
  v19.i16[0] = vaddlv_u8(v19);
  if (v19.u32[0] > 1uLL)
  {
    unint64_t v20 = 0x99BED48DEFBBD82BLL;
    if (*(void *)&v18 <= 0x99BED48DEFBBD82BLL) {
      unint64_t v20 = 0x99BED48DEFBBD82BLL % *(void *)&v18;
    }
  }
  else
  {
    unint64_t v20 = (*(void *)&v18 - 1) & 0x99BED48DEFBBD82BLL;
  }
  uint64_t v21 = *(void **)(*v17 + 8 * v20);
  if (!v21) {
    goto LABEL_32;
  }
  long long v22 = (void *)*v21;
  if (!v22) {
    goto LABEL_32;
  }
  if (v19.u32[0] < 2uLL)
  {
    uint64_t v23 = *(void *)&v18 - 1;
    while (1)
    {
      uint64_t v25 = v22[1];
      if (v25 == 0x99BED48DEFBBD82BLL)
      {
        if (v22[2] == 0x99BED48DEFBBD82BLL) {
          goto LABEL_30;
        }
      }
      else if ((v25 & v23) != v20)
      {
        goto LABEL_32;
      }
      long long v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_32;
      }
    }
  }
  while (1)
  {
    unint64_t v24 = v22[1];
    if (v24 == 0x99BED48DEFBBD82BLL) {
      break;
    }
    if (v24 >= *(void *)&v18) {
      v24 %= *(void *)&v18;
    }
    if (v24 != v20) {
      goto LABEL_32;
    }
LABEL_19:
    long long v22 = (void *)*v22;
    if (!v22) {
      goto LABEL_32;
    }
  }
  if (v22[2] != 0x99BED48DEFBBD82BLL) {
    goto LABEL_19;
  }
LABEL_30:
  uint64_t v26 = v22[5];
  if (*(void *)(v26 + 8) != 0x99BED48DEFBBD82BLL)
  {
LABEL_32:
    long long v70 = 0;
    goto LABEL_33;
  }
  long long v70 = *(uint64_t **)(v26 + 32);
LABEL_33:
  uint64_t v27 = &md::DebugRenderLayer::paintModelTiles(md::LayoutContext const&,md::DebugConsole *,ggl::CommandBuffer *)::debugDataTypes;
  do
  {
    uint64_t v72 = v27;
    int v28 = (unsigned __int16)*v27;
    float v29 = +[VKDebugSettings sharedSettings];
    int v74 = [v29 paintTiles];
    int v73 = [v29 paintVertices];
    int v71 = [v29 paintJunctions];
    int v30 = 0;
    int v31 = 0;
    uint64_t v32 = 0;
    uint64_t v33 = 0;
    uint64_t v34 = 0;
    switch(v28)
    {
      case 1:
      case 57:
        int v35 = [v29 paintPolygonTiles];
        int v36 = [v29 paintCoastlines];
        int v30 = [v29 paintLoadReason];
        uint64_t v32 = 0;
        uint64_t v33 = 0;
        if (v35) {
          uint64_t v34 = 0x100000000;
        }
        else {
          uint64_t v34 = 0;
        }
        if (v36) {
          int v31 = 0x1000000;
        }
        else {
          int v31 = 0;
        }
        goto LABEL_64;
      case 2:
        LODWORD(v38) = [v29 paintRoadBoundaries];
        char v37 = [v29 paintRoadTiles];
        int v68 = [v29 paintLoadReason];
        uint64_t v38 = v38;

        if (v37)
        {
          uint64_t v39 = v72;
          int v40 = v68;
LABEL_56:
          uint64_t v50 = 0;
          int v31 = 0;
          uint64_t v47 = 0;
          uint64_t v48 = 0;
          uint64_t v49 = 0x10000;
        }
        else
        {
          uint64_t v50 = 0;
          int v31 = 0;
          uint64_t v47 = 0;
          uint64_t v48 = 0;
          uint64_t v49 = 0;
LABEL_54:
          uint64_t v39 = v72;
          int v40 = v68;
        }
        break;
      case 6:
        int v41 = [v29 paintVenues];
        int v31 = 0;
        uint64_t v32 = 0;
        int v30 = 0;
        uint64_t v33 = 0;
        BOOL v42 = v41 == 0;
        uint64_t v43 = 0x1000000000000;
        goto LABEL_61;
      case 14:
        int v44 = [v29 paintBuildings];
        int v30 = [v29 paintLoadReason];
        int v31 = 0;
        uint64_t v32 = 0;
        uint64_t v33 = 0;
        BOOL v42 = v44 == 0;
        uint64_t v43 = 0x100000000000000;
        goto LABEL_61;
      case 16:
        int v45 = [v29 drawDebugTransit];
        int v30 = [v29 paintLoadReason];
        int v31 = 0;
        uint64_t v33 = 0;
        uint64_t v34 = 0;
        if (v45) {
          uint64_t v32 = 0x100000000;
        }
        else {
          uint64_t v32 = 0;
        }
        goto LABEL_64;
      case 19:
        int v46 = [v29 paintPointTiles];
        int v68 = 0;
        goto LABEL_51;
      case 20:
        int v46 = [v29 paintPoiTiles];
        int v68 = [v29 paintLoadReason];
LABEL_51:

        uint64_t v38 = 0;
        int v31 = 0;
        uint64_t v47 = 0;
        uint64_t v48 = 0;
        uint64_t v49 = 0;
        if (v46) {
          uint64_t v50 = 0x1000000;
        }
        else {
          uint64_t v50 = 0;
        }
        goto LABEL_54;
      case 44:
        int v69 = [v29 paintRoadTiles];
        int v51 = [v29 paintLoadReason];

        int v40 = v51;
        uint64_t v38 = 0;
        uint64_t v50 = 0;
        int v31 = 0;
        uint64_t v47 = 0;
        uint64_t v48 = 0;
        uint64_t v49 = 0;
        uint64_t v39 = v72;
        if (v69) {
          goto LABEL_56;
        }
        break;
      case 51:
        int v52 = [v29 paintDaVinciMetaTiles];
        int v31 = 0;
        uint64_t v32 = 0;
        int v30 = 0;
        uint64_t v34 = 0;
        if (v52) {
          uint64_t v33 = 0x1000000000000;
        }
        else {
          uint64_t v33 = 0;
        }
        goto LABEL_64;
      case 64:
        int v53 = [v29 paintTopographicTiles];
        int v31 = 0;
        uint64_t v32 = 0;
        int v30 = 0;
        uint64_t v33 = 0;
        BOOL v42 = v53 == 0;
        uint64_t v43 = 0x10000000000;
LABEL_61:
        if (v42) {
          uint64_t v34 = 0;
        }
        else {
          uint64_t v34 = v43;
        }
        goto LABEL_64;
      default:
LABEL_64:
        int v54 = v30;
        uint64_t v55 = v32;
        float32x2_t v56 = v29;
        uint64_t v50 = v34;

        uint64_t v48 = v33;
        uint64_t v47 = v55;
        int v40 = v54;
        uint64_t v38 = 0;
        uint64_t v49 = 0;
        uint64_t v39 = v72;
        break;
    }
    uint64_t v57 = 256;
    if (v74) {
      uint64_t v58 = 256;
    }
    else {
      uint64_t v58 = 0;
    }
    uint64_t v59 = v38 | v49 | v50 | v58;
    uint64_t v60 = 0x10000000000;
    if (!v40) {
      uint64_t v60 = 0;
    }
    uint64_t v61 = 0x10000;
    if (!v71) {
      uint64_t v61 = 0;
    }
    if (!v73) {
      uint64_t v57 = 0;
    }
    uint64_t v62 = v61 | v57 | v48 | v60 | v47;
    *(void *)uint64_t v78 = v59;
    v78[14] = BYTE6(v48);
    *(_WORD *)&v78[12] = WORD2(v62);
    *(_DWORD *)&v78[8] = v62 | v31;
    if (v59 | *(void *)&v78[7])
    {
      md::SceneContext::renderData((md::SceneContext *)&v76, *v70, v28);
      long long v63 = v76;
      uint64_t v64 = v77;
      while (1)
      {
        uint64_t v65 = v63;
        if ((void)v63 == v64) {
          break;
        }
        uint64_t v75 = *((void *)&v63 + 1);
        md::DebugRenderLayer::renderTileData((uint64_t)this, a2, v78, *(void **)(v63 + 112), v28, a4, a3);
        *((void *)&v63 + 1) = v75;
        uint64_t v66 = v65 + 144;
        if (v65 + 144 != v75)
        {
          while (!*(void *)(v66 + 112))
          {
            v66 += 144;
            if (v66 == v75)
            {
              uint64_t v66 = v75;
              break;
            }
          }
        }
        *(void *)&long long v63 = v66;
      }
    }
    uint64_t v27 = v39 + 1;
  }
  while (v27 != (__int16 *)&unk_1A2961BAC);
  std::__hash_table<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::__unordered_map_hasher<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,true>,std::__unordered_map_equal<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>>>::clear(v67);
}

void sub_1A20EEF7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::DebugRenderLayer::renderTileData(uint64_t a1, md::LayoutContext *a2, unsigned char *a3, void *a4, int a5, ggl::CommandBuffer *a6, float32x2_t *a7)
{
  uint64_t v13 = +[VKDebugSettings sharedSettings];
  [v13 daVinciMetaTileOpacity];
  __int32 v15 = v14;
  BOOL v16 = a4 + 80;
  v407 = (QuadTile *)(a4 + 21);

  unint64_t v17 = a4[80];
  if (a5 == 51)
  {
    if (!v17)
    {
      v426.i32[2] = 0;
      v426.i64[0] = 1065353216;
      v426.i32[3] = v15;
      md::DebugRenderLayer::renderSolidQuadTile(a1, a2, v407, &v426, (uint64_t)a6, (uint64_t)a7, (uint64_t)"");
      return;
    }
  }
  else if (!v17)
  {
    return;
  }
  int v391 = a5;
  v393 = (uint64_t **)a2;
  uint64_t v406 = a1;
  int8x8_t v18 = (uint64_t *)(a1 + 56);
  v409 = a4;
  if (!std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)(a1 + 56), v17))
  {
    if (std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)(a1 + 96), v17))
    {
      uint8x8_t v19 = std::__hash_table<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::__unordered_map_hasher<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,true>,std::__unordered_map_equal<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>>>::__emplace_unique_key_args<std::shared_ptr<geo::codec::VectorTile>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<geo::codec::VectorTile> const&>,std::tuple<>>(a1 + 96, v17, a4 + 80);
      uint64_t v20 = *v16;
      unint64_t v21 = HIDWORD(*v16);
      unint64_t v22 = 0x9DDFEA08EB382D69 * ((8 * *v16 + 8) ^ v21);
      unint64_t v23 = (0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) ^ ((0x9DDFEA08EB382D69 * (v21 ^ (v22 >> 47) ^ v22)) >> 47);
      unint64_t v24 = 0x9DDFEA08EB382D69 * v23;
      unint64_t v25 = *(void *)(a1 + 64);
      if (v25)
      {
        uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v25);
        v26.i16[0] = vaddlv_u8(v26);
        if (v26.u32[0] > 1uLL)
        {
          a1 = 0x9DDFEA08EB382D69 * v23;
          if (v24 >= v25) {
            a1 = v24 % v25;
          }
        }
        else
        {
          a1 = v24 & (v25 - 1);
        }
        int v35 = *(void **)(*v18 + 8 * a1);
        if (v35)
        {
          int v36 = (void *)*v35;
          if (v36)
          {
            if (v26.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v38 = v36[1];
                if (v38 == v24)
                {
                  if (v36[2] == v20) {
                    goto LABEL_127;
                  }
                }
                else if ((v38 & (v25 - 1)) != a1)
                {
                  goto LABEL_31;
                }
                int v36 = (void *)*v36;
                if (!v36) {
                  goto LABEL_31;
                }
              }
            }
            do
            {
              unint64_t v37 = v36[1];
              if (v37 == v24)
              {
                if (v36[2] == v20) {
                  goto LABEL_127;
                }
              }
              else
              {
                if (v37 >= v25) {
                  v37 %= v25;
                }
                if (v37 != a1) {
                  break;
                }
              }
              int v36 = (void *)*v36;
            }
            while (v36);
          }
        }
      }
LABEL_31:
      uint64_t v39 = (uint64_t *)(v406 + 72);
      int v40 = (uint64_t *)operator new(0x30uLL);
      int v41 = v40;
      v426.i64[0] = (uint64_t)v40;
      v426.i64[1] = v406 + 72;
      *int v40 = 0;
      v40[1] = v24;
      uint64_t v42 = v409[81];
      v40[2] = v20;
      v40[3] = v42;
      if (v42) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v42 + 8), 1uLL, memory_order_relaxed);
      }
      v40[4] = v19[4];
      uint64_t v43 = v19[5];
      v40[5] = v43;
      if (v43) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v43 + 8), 1uLL, memory_order_relaxed);
      }
      char v427 = 1;
      float v44 = (float)(unint64_t)(*(void *)(v406 + 80) + 1);
      float v45 = *(float *)(v406 + 88);
      if (!v25 || (float)(v45 * (float)v25) < v44)
      {
        BOOL v46 = 1;
        if (v25 >= 3) {
          BOOL v46 = (v25 & (v25 - 1)) != 0;
        }
        unint64_t v47 = v46 | (2 * v25);
        unint64_t v48 = vcvtps_u32_f32(v44 / v45);
        if (v47 <= v48) {
          size_t prime = v48;
        }
        else {
          size_t prime = v47;
        }
        if (prime == 1)
        {
          size_t prime = 2;
          uint64_t v50 = v406;
        }
        else
        {
          uint64_t v50 = v406;
          if ((prime & (prime - 1)) != 0) {
            size_t prime = std::__next_prime(prime);
          }
        }
        int8x8_t v51 = *(int8x8_t *)(v50 + 64);
        if (prime > *(void *)&v51) {
          goto LABEL_96;
        }
        if (prime < *(void *)&v51)
        {
          unint64_t v52 = vcvtps_u32_f32((float)*(unint64_t *)(v50 + 80) / *(float *)(v50 + 88));
          if (*(void *)&v51 < 3uLL || (uint8x8_t v53 = (uint8x8_t)vcnt_s8(v51), v53.i16[0] = vaddlv_u8(v53), v53.u32[0] > 1uLL))
          {
            unint64_t v52 = std::__next_prime(v52);
          }
          else
          {
            uint64_t v54 = 1 << -(char)__clz(v52 - 1);
            if (v52 >= 2) {
              unint64_t v52 = v54;
            }
          }
          if (prime <= v52) {
            size_t prime = v52;
          }
          if (prime < *(void *)&v51) {
LABEL_96:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v18, prime);
        }
        unint64_t v25 = *(void *)(v50 + 64);
        if ((v25 & (v25 - 1)) != 0)
        {
          if (v24 >= v25) {
            a1 = v24 % v25;
          }
          else {
            a1 = v24;
          }
        }
        else
        {
          a1 = (v25 - 1) & v24;
        }
      }
      uint64_t v72 = *v18;
      int v73 = *(uint64_t **)(*v18 + 8 * a1);
      if (v73)
      {
        *int v41 = *v73;
        a4 = v409;
LABEL_125:
        uint64_t *v73 = (uint64_t)v41;
        goto LABEL_126;
      }
      *int v41 = *v39;
      *uint64_t v39 = (uint64_t)v41;
      *(void *)(v72 + 8 * a1) = v39;
      uint64_t v74 = *v41;
      a4 = v409;
      if (!*v41) {
        goto LABEL_126;
      }
    }
    else
    {
      uint64_t v27 = a6;
      int v28 = (std::__shared_weak_count *)operator new(0x100uLL);
      v28->__shared_owners_ = 0;
      v28->__shared_weak_owners_ = 0;
      v28->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5808A8;
      __p[0] = md::ModelTileDebugData::ModelTileDebugData((uint64_t)&v28[1], v16);
      __p[1] = v28;
      uint64_t v29 = *v16;
      unint64_t v30 = HIDWORD(*v16);
      unint64_t v31 = 0x9DDFEA08EB382D69 * ((8 * *v16 + 8) ^ v30);
      unint64_t v32 = (0x9DDFEA08EB382D69 * (v30 ^ (v31 >> 47) ^ v31)) ^ ((0x9DDFEA08EB382D69 * (v30 ^ (v31 >> 47) ^ v31)) >> 47);
      unint64_t v33 = 0x9DDFEA08EB382D69 * v32;
      unint64_t v25 = *(void *)(a1 + 64);
      if (v25)
      {
        uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v25);
        v34.i16[0] = vaddlv_u8(v34);
        if (v34.u32[0] > 1uLL)
        {
          unint64_t v7 = 0x9DDFEA08EB382D69 * v32;
          if (v33 >= v25) {
            unint64_t v7 = v33 % v25;
          }
        }
        else
        {
          unint64_t v7 = v33 & (v25 - 1);
        }
        uint64_t v55 = *(void **)(*v18 + 8 * v7);
        if (v55)
        {
          float32x2_t v56 = (void *)*v55;
          if (v56)
          {
            if (v34.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v58 = v56[1];
                if (v58 == v33)
                {
                  if (v56[2] == v29) {
                    goto LABEL_106;
                  }
                }
                else if ((v58 & (v25 - 1)) != v7)
                {
                  goto LABEL_71;
                }
                float32x2_t v56 = (void *)*v56;
                if (!v56) {
                  goto LABEL_71;
                }
              }
            }
            do
            {
              unint64_t v57 = v56[1];
              if (v57 == v33)
              {
                if (v56[2] == v29)
                {
LABEL_106:
                  a6 = v27;
                  a4 = v409;
                  if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
                    std::__shared_weak_count::__release_weak(v28);
                  }
                  goto LABEL_127;
                }
              }
              else
              {
                if (v57 >= v25) {
                  v57 %= v25;
                }
                if (v57 != v7) {
                  break;
                }
              }
              float32x2_t v56 = (void *)*v56;
            }
            while (v56);
          }
        }
      }
LABEL_71:
      uint64_t v59 = (uint64_t *)operator new(0x30uLL);
      int v41 = v59;
      uint64_t v60 = (uint64_t *)(a1 + 72);
      v426.i64[0] = (uint64_t)v59;
      v426.i64[1] = v406 + 72;
      *uint64_t v59 = 0;
      v59[1] = v33;
      uint64_t v61 = v409[81];
      v59[2] = v29;
      v59[3] = v61;
      if (v61) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v61 + 8), 1uLL, memory_order_relaxed);
      }
      *((_OWORD *)v59 + 2) = *(_OWORD *)__p;
      __p[0] = 0;
      __p[1] = 0;
      char v427 = 1;
      float v62 = (float)(unint64_t)(*(void *)(v406 + 80) + 1);
      float v63 = *(float *)(v406 + 88);
      a6 = v27;
      a4 = v409;
      if (!v25 || (float)(v63 * (float)v25) < v62)
      {
        BOOL v64 = 1;
        if (v25 >= 3) {
          BOOL v64 = (v25 & (v25 - 1)) != 0;
        }
        unint64_t v65 = v64 | (2 * v25);
        unint64_t v66 = vcvtps_u32_f32(v62 / v63);
        if (v65 <= v66) {
          size_t v67 = v66;
        }
        else {
          size_t v67 = v65;
        }
        if (v67 == 1)
        {
          size_t v67 = 2;
        }
        else if ((v67 & (v67 - 1)) != 0)
        {
          size_t v67 = std::__next_prime(v67);
        }
        int8x8_t v68 = *(int8x8_t *)(v406 + 64);
        if (v67 > *(void *)&v68) {
          goto LABEL_85;
        }
        if (v67 < *(void *)&v68)
        {
          unint64_t v69 = vcvtps_u32_f32((float)*(unint64_t *)(v406 + 80) / *(float *)(v406 + 88));
          if (*(void *)&v68 < 3uLL || (uint8x8_t v70 = (uint8x8_t)vcnt_s8(v68), v70.i16[0] = vaddlv_u8(v70), v70.u32[0] > 1uLL))
          {
            unint64_t v69 = std::__next_prime(v69);
          }
          else
          {
            uint64_t v71 = 1 << -(char)__clz(v69 - 1);
            if (v69 >= 2) {
              unint64_t v69 = v71;
            }
          }
          if (v67 <= v69) {
            size_t v67 = v69;
          }
          if (v67 < *(void *)&v68) {
LABEL_85:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v18, v67);
        }
        unint64_t v25 = *(void *)(v406 + 64);
        if ((v25 & (v25 - 1)) != 0)
        {
          if (v33 >= v25) {
            unint64_t v7 = v33 % v25;
          }
          else {
            unint64_t v7 = v33;
          }
        }
        else
        {
          unint64_t v7 = (v25 - 1) & v33;
        }
      }
      uint64_t v75 = *v18;
      int v73 = *(uint64_t **)(*v18 + 8 * v7);
      if (v73)
      {
        *int v41 = *v73;
        goto LABEL_125;
      }
      *int v41 = *v60;
      *uint64_t v60 = (uint64_t)v41;
      *(void *)(v75 + 8 * v7) = v60;
      uint64_t v74 = *v41;
      if (!*v41)
      {
LABEL_126:
        ++*(void *)(v406 + 80);
        goto LABEL_127;
      }
    }
    unint64_t v76 = *(void *)(v74 + 8);
    if ((v25 & (v25 - 1)) != 0)
    {
      if (v76 >= v25) {
        v76 %= v25;
      }
    }
    else
    {
      v76 &= v25 - 1;
    }
    int v73 = (uint64_t *)(*v18 + 8 * v76);
    goto LABEL_125;
  }
LABEL_127:
  uint64_t v77 = (void *)std::__hash_table<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::__unordered_map_hasher<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,true>,std::__unordered_map_equal<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>>>::__emplace_unique_key_args<std::shared_ptr<geo::codec::VectorTile>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<geo::codec::VectorTile> const&>,std::tuple<>>((uint64_t)v18, *v16, v16)[4];
  uint64_t v78 = v393;
  float v79 = v393[1];
  int8x8_t v80 = (int8x8_t)v79[1];
  float v392 = *(float *)&v15;
  if (!*(void *)&v80)
  {
    uint64_t v83 = 0;
    goto LABEL_174;
  }
  uint8x8_t v81 = (uint8x8_t)vcnt_s8(v80);
  v81.i16[0] = vaddlv_u8(v81);
  if (v81.u32[0] > 1uLL)
  {
    uint64_t v82 = 0x1AF456233693CD46;
    if (*(void *)&v80 <= 0x1AF456233693CD46uLL) {
      uint64_t v82 = 0x1AF456233693CD46uLL % *(void *)&v80;
    }
  }
  else
  {
    uint64_t v82 = (*(void *)&v80 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v84 = *v79;
  float32x2_t v85 = *(void **)(v84 + 8 * v82);
  if (!v85) {
    goto LABEL_151;
  }
  float32x2_t v86 = (void *)*v85;
  if (!v86) {
    goto LABEL_151;
  }
  if (v81.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v88 = v86[1];
      if (v88 == 0x1AF456233693CD46)
      {
        if (v86[2] == 0x1AF456233693CD46) {
          goto LABEL_149;
        }
      }
      else if ((v88 & (*(void *)&v80 - 1)) != v82)
      {
        goto LABEL_151;
      }
      float32x2_t v86 = (void *)*v86;
      if (!v86) {
        goto LABEL_151;
      }
    }
  }
  while (1)
  {
    unint64_t v87 = v86[1];
    if (v87 == 0x1AF456233693CD46) {
      break;
    }
    if (v87 >= *(void *)&v80) {
      v87 %= *(void *)&v80;
    }
    if (v87 != v82) {
      goto LABEL_151;
    }
LABEL_138:
    float32x2_t v86 = (void *)*v86;
    if (!v86) {
      goto LABEL_151;
    }
  }
  if (v86[2] != 0x1AF456233693CD46) {
    goto LABEL_138;
  }
LABEL_149:
  uint64_t v89 = v86[5];
  if (*(void *)(v89 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v83 = *(void *)(v89 + 32);
    goto LABEL_152;
  }
LABEL_151:
  uint64_t v83 = 0;
LABEL_152:
  if (v81.u32[0] > 1uLL)
  {
    uint64_t v90 = 0x3070CB6B3C7F21D3;
    if (*(void *)&v80 <= 0x3070CB6B3C7F21D3uLL) {
      uint64_t v90 = 0x3070CB6B3C7F21D3uLL % *(void *)&v80;
    }
  }
  else
  {
    uint64_t v90 = (*(void *)&v80 - 1) & 0x3070CB6B3C7F21D3;
  }
  long long v91 = *(void **)(v84 + 8 * v90);
  if (!v91) {
    goto LABEL_174;
  }
  long long v92 = (void *)*v91;
  if (!v92) {
    goto LABEL_174;
  }
  if (v81.u32[0] < 2uLL)
  {
    uint64_t v93 = *(void *)&v80 - 1;
    while (1)
    {
      uint64_t v95 = v92[1];
      if (v95 == 0x3070CB6B3C7F21D3)
      {
        if (v92[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_172;
        }
      }
      else if ((v95 & v93) != v90)
      {
        goto LABEL_174;
      }
      long long v92 = (void *)*v92;
      if (!v92) {
        goto LABEL_174;
      }
    }
  }
  while (2)
  {
    unint64_t v94 = v92[1];
    if (v94 != 0x3070CB6B3C7F21D3)
    {
      if (v94 >= *(void *)&v80) {
        v94 %= *(void *)&v80;
      }
      if (v94 != v90) {
        goto LABEL_174;
      }
      goto LABEL_161;
    }
    if (v92[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_161:
      long long v92 = (void *)*v92;
      if (!v92) {
        goto LABEL_174;
      }
      continue;
    }
    break;
  }
LABEL_172:
  uint64_t v96 = v92[5];
  if (*(void *)(v96 + 8) == 0x3070CB6B3C7F21D3)
  {
    unint64_t v97 = *(uint64_t **)(v96 + 32);
    goto LABEL_175;
  }
LABEL_174:
  unint64_t v97 = 0;
LABEL_175:
  float v98 = 0.0;
  if (geo::codec::VectorTile::lineVertices((geo::codec::VectorTile *)*v16))
  {
    uint64_t v99 = (md::DebugLayerRenderResources **)v406;
    if (*(void *)(geo::codec::VectorTile::lineVertices((geo::codec::VectorTile *)*v16) + 24)) {
      float v98 = 1.0 / *((float *)a4 + 156);
    }
  }
  else
  {
    uint64_t v99 = (md::DebugLayerRenderResources **)v406;
  }
  BOOL v100 = *(unsigned __int8 *)(md::LayoutContext::frameState((md::LayoutContext *)v393) + 128) - 1 < 3;
  double v101 = v98;
  md::GeometryLogic::tileMatrix((md::GeometryLogic *)&v426, v100, v407, v98, v102);
  gm::operator*<double,4,4,4>((double *)__p, (double *)(v83 + 808), (double *)v426.i64);
  float v103 = *(double *)__p;
  float v394 = v103;
  float v104 = *(double *)&__p[1];
  float v105 = v414;
  float v106 = v415;
  float v107 = v417;
  float v403 = v107;
  float v108 = v418;
  float v109 = v419;
  float v110 = v420;
  float v401 = v110;
  float v111 = v421;
  float v112 = v422;
  float v398 = v112;
  float v399 = v109;
  float32x2_t v113 = vcvt_f32_f64(v416);
  float32x2_t v114 = vcvt_f32_f64(v423);
  float v115 = v424;
  float v396 = v115;
  float v397 = v111;
  float v116 = v425;
  long long v117 = a3;
  uint64_t v395 = v77;
  if (a3[2])
  {
    uint64_t v118 = v77[16];
    if (v118
      && *(void *)(**(void **)(v118 + 64) + 8) <= *(void *)(**(void **)(v118 + 64) + 48)
                                                      - *(void *)(**(void **)(v118 + 64) + 40))
    {
      uint64_t v119 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*((void *)v99[6] + 14));
      uint64_t v120 = *(void **)(*(void *)(v119 + 64) + 16);
      unint64_t v121 = v120[1];
      long long v122 = (float32x2_t *)v120[9];
      v122->f32[0] = v394;
      v122->f32[1] = v104;
      v122[1].f32[0] = v105;
      v122[1].f32[1] = v106;
      v122[2] = v113;
      v122[3].f32[0] = v403;
      v122[3].f32[1] = v108;
      v122[4].f32[0] = v399;
      v122[4].f32[1] = v401;
      v122[5].f32[0] = v397;
      v122[5].f32[1] = v398;
      v122[6] = v114;
      v122[7].f32[0] = v396;
      v122[7].f32[1] = v116;
      if (v120[8] > v121) {
        unint64_t v121 = v120[8];
      }
      v120[7] = 0;
      v120[8] = v121;
      md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, v101);
      uint64_t v123 = *(void *)(v119 + 64);
      double v124 = __p[0];
      double v125 = (atomic_ullong *)__p[1];
      *(void **)(v123 + 32) = __p[0];
      *(void *)(v123 + 40) = 0;
      uint64_t v126 = *(void *)(v119 + 160);
      if (v125) {
        atomic_fetch_add_explicit(v125 + 1, 1uLL, memory_order_relaxed);
      }
      double v127 = *(std::__shared_weak_count **)(v126 + 40);
      *(void *)(v126 + 32) = v124;
      *(void *)(v126 + 40) = v125;
      if (v127 && !atomic_fetch_add(&v127->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v127->__on_zero_shared)(v127);
        std::__shared_weak_count::__release_weak(v127);
      }
      double v128 = (std::__shared_weak_count *)__p[1];
      if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
        std::__shared_weak_count::__release_weak(v128);
      }
      double v129 = **(void ***)(v119 + 64);
      unint64_t v130 = v129[1];
      *(_OWORD *)v129[9] = xmmword_1A28FC6C0;
      if (v129[8] > v130) {
        unint64_t v130 = v129[8];
      }
      v129[7] = 0;
      v129[8] = v130;
      double v131 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
      v131[8] = v118;
      v131[4] = v119;
      v131[3] = *((void *)v99[6] + 21);
      ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v131);
      long long v117 = a3;
      uint64_t v77 = v395;
    }
    uint64_t v132 = v77[17];
    if (v132
      && *(void *)(**(void **)(v132 + 64) + 8) <= *(void *)(**(void **)(v132 + 64) + 48)
                                                      - *(void *)(**(void **)(v132 + 64) + 40))
    {
      uint64_t v133 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*((void *)v99[6] + 14));
      double v134 = *(void **)(*(void *)(v133 + 64) + 16);
      unint64_t v135 = v134[1];
      uint64_t v136 = (float32x2_t *)v134[9];
      v136->f32[0] = v394;
      v136->f32[1] = v104;
      v136[1].f32[0] = v105;
      v136[1].f32[1] = v106;
      v136[2] = v113;
      v136[3].f32[0] = v403;
      v136[3].f32[1] = v108;
      v136[4].f32[0] = v399;
      v136[4].f32[1] = v401;
      v136[5].f32[0] = v397;
      v136[5].f32[1] = v398;
      v136[6] = v114;
      v136[7].f32[0] = v396;
      v136[7].f32[1] = v116;
      if (v134[8] > v135) {
        unint64_t v135 = v134[8];
      }
      v134[7] = 0;
      v134[8] = v135;
      md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, v101);
      uint64_t v137 = *(void *)(v133 + 64);
      uint64_t v138 = __p[0];
      uint64_t v139 = (atomic_ullong *)__p[1];
      *(void **)(v137 + 32) = __p[0];
      *(void *)(v137 + 40) = 0;
      uint64_t v140 = *(void *)(v133 + 160);
      if (v139) {
        atomic_fetch_add_explicit(v139 + 1, 1uLL, memory_order_relaxed);
      }
      float32x4_t v141 = *(std::__shared_weak_count **)(v140 + 40);
      *(void *)(v140 + 32) = v138;
      *(void *)(v140 + 40) = v139;
      if (v141 && !atomic_fetch_add(&v141->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v141->__on_zero_shared)(v141);
        std::__shared_weak_count::__release_weak(v141);
      }
      long long v142 = (std::__shared_weak_count *)__p[1];
      if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v142->__on_zero_shared)(v142);
        std::__shared_weak_count::__release_weak(v142);
      }
      uint64_t v143 = **(void ***)(v133 + 64);
      unint64_t v144 = v143[1];
      *(_OWORD *)v143[9] = xmmword_1A28FD5D0;
      if (v143[8] > v144) {
        unint64_t v144 = v143[8];
      }
      v143[7] = 0;
      v143[8] = v144;
      uint64_t v145 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
      v145[8] = v132;
      v145[4] = v133;
      v145[3] = *((void *)v99[6] + 21);
      ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v145);
      long long v117 = a3;
      uint64_t v77 = v395;
    }
  }
  if (v117[3])
  {
    uint64_t v146 = v77[22];
    if (v146)
    {
      if (*(void *)(**(void **)(v146 + 64) + 8) <= *(void *)(**(void **)(v146 + 64) + 48)
                                                        - *(void *)(**(void **)(v146 + 64) + 40))
      {
        uint64_t v147 = ggl::FragmentedPool<ggl::Point::PipelineSetup>::pop(*((void *)v99[6] + 17));
        uint64_t v148 = **(void ***)(v147 + 64);
        unint64_t v149 = v148[1];
        uint64_t v150 = (float32x2_t *)v148[9];
        v150->f32[0] = v394;
        v150->f32[1] = v104;
        v150[1].f32[0] = v105;
        v150[1].f32[1] = v106;
        v150[2] = v113;
        v150[3].f32[0] = v403;
        v150[3].f32[1] = v108;
        v150[4].f32[0] = v399;
        v150[4].f32[1] = v401;
        v150[5].f32[0] = v397;
        v150[5].f32[1] = v398;
        v150[6] = v114;
        v150[7].f32[0] = v396;
        v150[7].f32[1] = v116;
        unint64_t v151 = v148[8];
        uint64_t v152 = v148[9];
        if (v151 <= v149) {
          unint64_t v151 = v149;
        }
        v148[7] = 0;
        *(_OWORD *)(v152 + 80) = xmmword_1A28FE440;
        if (v151 > v149) {
          unint64_t v149 = v151;
        }
        v148[8] = v149;
        md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
        uint64_t v153 = *(void *)(v147 + 64);
        unint64_t v154 = __p[0];
        uint64_t v155 = (atomic_ullong *)__p[1];
        *(void **)(v153 + 16) = __p[0];
        *(void *)(v153 + 24) = 0;
        uint64_t v156 = *(void *)(v147 + 160);
        if (v155) {
          atomic_fetch_add_explicit(v155 + 1, 1uLL, memory_order_relaxed);
        }
        unint64_t v157 = *(std::__shared_weak_count **)(v156 + 24);
        *(void *)(v156 + 16) = v154;
        *(void *)(v156 + 24) = v155;
        if (v157 && !atomic_fetch_add(&v157->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v157->__on_zero_shared)(v157);
          std::__shared_weak_count::__release_weak(v157);
        }
        uint64_t v158 = (std::__shared_weak_count *)__p[1];
        if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v158->__on_zero_shared)(v158);
          std::__shared_weak_count::__release_weak(v158);
        }
        unint64_t v159 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
        v159[8] = v146;
        v159[4] = v147;
        v159[3] = *((void *)v99[6] + 23);
        ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v159);
        long long v117 = a3;
        uint64_t v77 = v395;
      }
    }
  }
  int v160 = v117[6];
  if (v117[4] || v117[8] || v117[6] || v117[7])
  {
    uint64_t v161 = v77[18];
    if (v161
      && *(void *)(**(void **)(v161 + 64) + 8) <= *(void *)(**(void **)(v161 + 64) + 48)
                                                      - *(void *)(**(void **)(v161 + 64) + 40))
    {
      uint64_t v162 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*((void *)v99[6] + 14));
      int v163 = *(void **)(*(void *)(v162 + 64) + 16);
      unint64_t v164 = v163[1];
      unint64_t v165 = (float32x2_t *)v163[9];
      v165->f32[0] = v394;
      v165->f32[1] = v104;
      v165[1].f32[0] = v105;
      v165[1].f32[1] = v106;
      v165[2] = v113;
      v165[3].f32[0] = v403;
      v165[3].f32[1] = v108;
      v165[4].f32[0] = v399;
      v165[4].f32[1] = v401;
      v165[5].f32[0] = v397;
      v165[5].f32[1] = v398;
      v165[6] = v114;
      v165[7].f32[0] = v396;
      v165[7].f32[1] = v116;
      if (v163[8] > v164) {
        unint64_t v164 = v163[8];
      }
      v163[7] = 0;
      v163[8] = v164;
      md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
      uint64_t v166 = *(void *)(v162 + 64);
      unint64_t v167 = __p[0];
      unint64_t v168 = (atomic_ullong *)__p[1];
      *(void **)(v166 + 32) = __p[0];
      *(void *)(v166 + 40) = 0;
      uint64_t v169 = *(void *)(v162 + 160);
      if (v168) {
        atomic_fetch_add_explicit(v168 + 1, 1uLL, memory_order_relaxed);
      }
      int v170 = *(std::__shared_weak_count **)(v169 + 40);
      *(void *)(v169 + 32) = v167;
      *(void *)(v169 + 40) = v168;
      if (v170 && !atomic_fetch_add(&v170->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v170->__on_zero_shared)(v170);
        std::__shared_weak_count::__release_weak(v170);
      }
      int v171 = (std::__shared_weak_count *)__p[1];
      if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v171->__on_zero_shared)(v171);
        std::__shared_weak_count::__release_weak(v171);
      }
      unint64_t v172 = **(void ***)(v162 + 64);
      unint64_t v173 = v172[1];
      uint64_t v174 = v172[9];
      *(_DWORD *)uint64_t v174 = 1065353216;
      *(int8x8_t *)(v174 + 4) = vbsl_s8((int8x8_t)vcltz_s32(vshl_n_s32(vdup_n_s32(v391 == 57), 0x1FuLL)), (int8x8_t)1056964608, (int8x8_t)0x3F00000000000000);
      *(_DWORD *)(v174 + 12) = 1065353216;
      if (v172[8] > v173) {
        unint64_t v173 = v172[8];
      }
      v172[7] = 0;
      v172[8] = v173;
      long long v175 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
      v175[8] = v161;
      v175[4] = v162;
      v175[3] = *((void *)v99[6] + 21);
      ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v175);
      long long v117 = a3;
      int v160 = a3[6];
      uint64_t v77 = v395;
    }
    if (v160)
    {
      uint64_t v176 = v77[19];
      if (v176
        && *(void *)(**(void **)(v176 + 64) + 8) <= *(void *)(**(void **)(v176 + 64) + 48)
                                                        - *(void *)(**(void **)(v176 + 64) + 40))
      {
        uint64_t v177 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*((void *)v99[6] + 14));
        float v178 = *(void **)(*(void *)(v177 + 64) + 16);
        unint64_t v179 = v178[1];
        id v180 = (float32x2_t *)v178[9];
        v180->f32[0] = v394;
        v180->f32[1] = v104;
        v180[1].f32[0] = v105;
        v180[1].f32[1] = v106;
        v180[2] = v113;
        v180[3].f32[0] = v403;
        v180[3].f32[1] = v108;
        v180[4].f32[0] = v399;
        v180[4].f32[1] = v401;
        v180[5].f32[0] = v397;
        v180[5].f32[1] = v398;
        v180[6] = v114;
        v180[7].f32[0] = v396;
        v180[7].f32[1] = v116;
        if (v178[8] > v179) {
          unint64_t v179 = v178[8];
        }
        v178[7] = 0;
        v178[8] = v179;
        md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
        uint64_t v181 = *(void *)(v177 + 64);
        unint64_t v182 = __p[0];
        uint64_t v183 = (atomic_ullong *)__p[1];
        *(void **)(v181 + 32) = __p[0];
        *(void *)(v181 + 40) = 0;
        uint64_t v184 = *(void *)(v177 + 160);
        if (v183) {
          atomic_fetch_add_explicit(v183 + 1, 1uLL, memory_order_relaxed);
        }
        unsigned int v185 = *(std::__shared_weak_count **)(v184 + 40);
        *(void *)(v184 + 32) = v182;
        *(void *)(v184 + 40) = v183;
        if (v185 && !atomic_fetch_add(&v185->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v185->__on_zero_shared)(v185);
          std::__shared_weak_count::__release_weak(v185);
        }
        uint64_t v186 = (std::__shared_weak_count *)__p[1];
        if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v186->__on_zero_shared)(v186);
          std::__shared_weak_count::__release_weak(v186);
        }
        size_t v187 = **(void ***)(v177 + 64);
        unint64_t v188 = v187[1];
        *(_OWORD *)v187[9] = xmmword_1A28FE450;
        if (v187[8] > v188) {
          unint64_t v188 = v187[8];
        }
        v187[7] = 0;
        v187[8] = v188;
        unint64_t v189 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
        v189[8] = v176;
        v189[4] = v177;
        v189[3] = *((void *)v99[6] + 21);
        ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v189);
        long long v117 = a3;
        uint64_t v77 = v395;
      }
      uint64_t v190 = v77[20];
      if (v190
        && *(void *)(**(void **)(v190 + 64) + 8) <= *(void *)(**(void **)(v190 + 64) + 48)
                                                        - *(void *)(**(void **)(v190 + 64) + 40))
      {
        uint64_t v191 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*((void *)v99[6] + 14));
        uint64_t v192 = *(void **)(*(void *)(v191 + 64) + 16);
        unint64_t v193 = v192[1];
        long long v194 = (float32x2_t *)v192[9];
        v194->f32[0] = v394;
        v194->f32[1] = v104;
        v194[1].f32[0] = v105;
        v194[1].f32[1] = v106;
        v194[2] = v113;
        v194[3].f32[0] = v403;
        v194[3].f32[1] = v108;
        v194[4].f32[0] = v399;
        v194[4].f32[1] = v401;
        v194[5].f32[0] = v397;
        v194[5].f32[1] = v398;
        v194[6] = v114;
        v194[7].f32[0] = v396;
        v194[7].f32[1] = v116;
        if (v192[8] > v193) {
          unint64_t v193 = v192[8];
        }
        v192[7] = 0;
        v192[8] = v193;
        md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
        uint64_t v195 = *(void *)(v191 + 64);
        long long v196 = __p[0];
        long long v197 = (atomic_ullong *)__p[1];
        *(void **)(v195 + 32) = __p[0];
        *(void *)(v195 + 40) = 0;
        uint64_t v198 = *(void *)(v191 + 160);
        if (v197) {
          atomic_fetch_add_explicit(v197 + 1, 1uLL, memory_order_relaxed);
        }
        long long v199 = *(std::__shared_weak_count **)(v198 + 40);
        *(void *)(v198 + 32) = v196;
        *(void *)(v198 + 40) = v197;
        if (v199 && !atomic_fetch_add(&v199->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v199->__on_zero_shared)(v199);
          std::__shared_weak_count::__release_weak(v199);
        }
        uint64_t v200 = (std::__shared_weak_count *)__p[1];
        if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v200->__on_zero_shared)(v200);
          std::__shared_weak_count::__release_weak(v200);
        }
        unsigned int v201 = **(void ***)(v191 + 64);
        unint64_t v202 = v201[1];
        *(_OWORD *)v201[9] = xmmword_1A28FE460;
        if (v201[8] > v202) {
          unint64_t v202 = v201[8];
        }
        v201[7] = 0;
        v201[8] = v202;
        size_t v203 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
        v203[8] = v190;
        v203[4] = v191;
        v203[3] = *((void *)v99[6] + 21);
        ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v203);
        long long v117 = a3;
        uint64_t v77 = v395;
      }
    }
  }
  if (v117[9])
  {
    uint64_t v204 = v77[23];
    if (v204)
    {
      if (*(void *)(**(void **)(v204 + 64) + 8) <= *(void *)(**(void **)(v204 + 64) + 48)
                                                        - *(void *)(**(void **)(v204 + 64) + 40))
      {
        uint64_t v205 = ggl::FragmentedPool<ggl::Point::PipelineSetup>::pop(*((void *)v99[6] + 17));
        uint64_t v206 = **(void ***)(v205 + 64);
        unint64_t v207 = v206[1];
        uint64_t v208 = (float32x2_t *)v206[9];
        v208->f32[0] = v394;
        v208->f32[1] = v104;
        v208[1].f32[0] = v105;
        v208[1].f32[1] = v106;
        v208[2] = v113;
        v208[3].f32[0] = v403;
        v208[3].f32[1] = v108;
        v208[4].f32[0] = v399;
        v208[4].f32[1] = v401;
        v208[5].f32[0] = v397;
        v208[5].f32[1] = v398;
        v208[6] = v114;
        v208[7].f32[0] = v396;
        v208[7].f32[1] = v116;
        unint64_t v209 = v206[8];
        uint64_t v210 = v206[9];
        if (v209 <= v207) {
          unint64_t v209 = v207;
        }
        v206[7] = 0;
        *(_OWORD *)(v210 + 80) = xmmword_1A28FE440;
        if (v209 > v207) {
          unint64_t v207 = v209;
        }
        v206[8] = v207;
        md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
        uint64_t v211 = *(void *)(v205 + 64);
        uint64_t v212 = __p[0];
        uint64_t v213 = (atomic_ullong *)__p[1];
        *(void **)(v211 + 16) = __p[0];
        *(void *)(v211 + 24) = 0;
        uint64_t v214 = *(void *)(v205 + 160);
        if (v213) {
          atomic_fetch_add_explicit(v213 + 1, 1uLL, memory_order_relaxed);
        }
        uint64_t v215 = *(std::__shared_weak_count **)(v214 + 24);
        *(void *)(v214 + 16) = v212;
        *(void *)(v214 + 24) = v213;
        if (v215 && !atomic_fetch_add(&v215->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v215->__on_zero_shared)(v215);
          std::__shared_weak_count::__release_weak(v215);
        }
        uint64_t v216 = (std::__shared_weak_count *)__p[1];
        if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v216->__on_zero_shared)(v216);
          std::__shared_weak_count::__release_weak(v216);
        }
        char v217 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
        v217[8] = v204;
        v217[4] = v205;
        v217[3] = *((void *)v99[6] + 23);
        ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v217);
        long long v117 = a3;
        uint64_t v77 = v395;
      }
    }
  }
  if (v117[10])
  {
    uint64_t v218 = v77[24];
    if (v218
      && *(void *)(**(void **)(v218 + 64) + 8) <= *(void *)(**(void **)(v218 + 64) + 48)
                                                      - *(void *)(**(void **)(v218 + 64) + 40))
    {
      uint64_t v219 = ggl::FragmentedPool<ggl::Point::PipelineSetup>::pop(*((void *)v99[6] + 17));
      unsigned __int8 v220 = **(void ***)(v219 + 64);
      unint64_t v221 = v220[1];
      char v222 = (float32x2_t *)v220[9];
      v222->f32[0] = v394;
      v222->f32[1] = v104;
      v222[1].f32[0] = v105;
      v222[1].f32[1] = v106;
      v222[2] = v113;
      v222[3].f32[0] = v403;
      v222[3].f32[1] = v108;
      v222[4].f32[0] = v399;
      v222[4].f32[1] = v401;
      v222[5].f32[0] = v397;
      v222[5].f32[1] = v398;
      v222[6] = v114;
      v222[7].f32[0] = v396;
      v222[7].f32[1] = v116;
      unint64_t v223 = v220[8];
      uint64_t v224 = v220[9];
      if (v223 <= v221) {
        unint64_t v223 = v221;
      }
      v220[7] = 0;
      *(_OWORD *)(v224 + 80) = xmmword_1A28FCDA0;
      if (v223 > v221) {
        unint64_t v221 = v223;
      }
      v220[8] = v221;
      md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
      uint64_t v225 = *(void *)(v219 + 64);
      unint64_t v226 = __p[0];
      size_t v227 = (atomic_ullong *)__p[1];
      *(void **)(v225 + 16) = __p[0];
      *(void *)(v225 + 24) = 0;
      uint64_t v228 = *(void *)(v219 + 160);
      if (v227) {
        atomic_fetch_add_explicit(v227 + 1, 1uLL, memory_order_relaxed);
      }
      uint64_t v229 = *(std::__shared_weak_count **)(v228 + 24);
      *(void *)(v228 + 16) = v226;
      *(void *)(v228 + 24) = v227;
      if (v229 && !atomic_fetch_add(&v229->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v229->__on_zero_shared)(v229);
        std::__shared_weak_count::__release_weak(v229);
      }
      uint64_t v230 = (std::__shared_weak_count *)__p[1];
      if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v230->__on_zero_shared)(v230);
        std::__shared_weak_count::__release_weak(v230);
      }
      unsigned __int8 v231 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
      v231[8] = v218;
      v231[4] = v219;
      v231[3] = *((void *)v99[6] + 23);
      ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v231);
      long long v117 = a3;
      uint64_t v77 = v395;
    }
    uint64_t v232 = v77[26];
    if (v232
      && *(void *)(**(void **)(v232 + 64) + 8) <= *(void *)(**(void **)(v232 + 64) + 48)
                                                      - *(void *)(**(void **)(v232 + 64) + 40))
    {
      uint64_t v233 = ggl::FragmentedPool<ggl::Point::PipelineSetup>::pop(*((void *)v99[6] + 17));
      size_t v234 = **(void ***)(v233 + 64);
      unint64_t v235 = v234[1];
      v236 = (float32x2_t *)v234[9];
      v236->f32[0] = v394;
      v236->f32[1] = v104;
      v236[1].f32[0] = v105;
      v236[1].f32[1] = v106;
      v236[2] = v113;
      v236[3].f32[0] = v403;
      v236[3].f32[1] = v108;
      v236[4].f32[0] = v399;
      v236[4].f32[1] = v401;
      v236[5].f32[0] = v397;
      v236[5].f32[1] = v398;
      v236[6] = v114;
      v236[7].f32[0] = v396;
      v236[7].f32[1] = v116;
      unint64_t v237 = v234[8];
      uint64_t v238 = v234[9];
      if (v237 <= v235) {
        unint64_t v237 = v235;
      }
      v234[7] = 0;
      *(_OWORD *)(v238 + 80) = xmmword_1A28FC6C0;
      if (v237 > v235) {
        unint64_t v235 = v237;
      }
      v234[8] = v235;
      md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
      uint64_t v239 = *(void *)(v233 + 64);
      uint64_t v240 = __p[0];
      char v241 = (atomic_ullong *)__p[1];
      *(void **)(v239 + 16) = __p[0];
      *(void *)(v239 + 24) = 0;
      uint64_t v242 = *(void *)(v233 + 160);
      if (v241) {
        atomic_fetch_add_explicit(v241 + 1, 1uLL, memory_order_relaxed);
      }
      id v243 = *(std::__shared_weak_count **)(v242 + 24);
      *(void *)(v242 + 16) = v240;
      *(void *)(v242 + 24) = v241;
      if (v243 && !atomic_fetch_add(&v243->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v243->__on_zero_shared)(v243);
        std::__shared_weak_count::__release_weak(v243);
      }
      int64_t v244 = (std::__shared_weak_count *)__p[1];
      if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v244->__on_zero_shared)(v244);
        std::__shared_weak_count::__release_weak(v244);
      }
      unsigned __int8 v245 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
      v245[8] = v232;
      v245[4] = v233;
      v245[3] = *((void *)v99[6] + 23);
      ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v245);
      long long v117 = a3;
      uint64_t v77 = v395;
    }
    uint64_t v246 = v77[25];
    if (v246
      && *(void *)(**(void **)(v246 + 64) + 8) <= *(void *)(**(void **)(v246 + 64) + 48)
                                                      - *(void *)(**(void **)(v246 + 64) + 40))
    {
      uint64_t v247 = ggl::FragmentedPool<ggl::Point::PipelineSetup>::pop(*((void *)v99[6] + 17));
      id v248 = **(void ***)(v247 + 64);
      unint64_t v249 = v248[1];
      unint64_t v250 = (float32x2_t *)v248[9];
      v250->f32[0] = v394;
      v250->f32[1] = v104;
      v250[1].f32[0] = v105;
      v250[1].f32[1] = v106;
      v250[2] = v113;
      v250[3].f32[0] = v403;
      v250[3].f32[1] = v108;
      v250[4].f32[0] = v399;
      v250[4].f32[1] = v401;
      v250[5].f32[0] = v397;
      v250[5].f32[1] = v398;
      v250[6] = v114;
      v250[7].f32[0] = v396;
      v250[7].f32[1] = v116;
      unint64_t v251 = v248[8];
      uint64_t v252 = v248[9];
      if (v251 <= v249) {
        unint64_t v251 = v249;
      }
      v248[7] = 0;
      *(_OWORD *)(v252 + 80) = xmmword_1A28FD460;
      if (v251 > v249) {
        unint64_t v249 = v251;
      }
      v248[8] = v249;
      md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
      uint64_t v253 = *(void *)(v247 + 64);
      uint64_t v254 = __p[0];
      v255 = (atomic_ullong *)__p[1];
      *(void **)(v253 + 16) = __p[0];
      *(void *)(v253 + 24) = 0;
      uint64_t v256 = *(void *)(v247 + 160);
      if (v255) {
        atomic_fetch_add_explicit(v255 + 1, 1uLL, memory_order_relaxed);
      }
      uint64_t v257 = *(std::__shared_weak_count **)(v256 + 24);
      *(void *)(v256 + 16) = v254;
      *(void *)(v256 + 24) = v255;
      if (v257 && !atomic_fetch_add(&v257->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v257->__on_zero_shared)(v257);
        std::__shared_weak_count::__release_weak(v257);
      }
      size_t v258 = (std::__shared_weak_count *)__p[1];
      if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v258->__on_zero_shared)(v258);
        std::__shared_weak_count::__release_weak(v258);
      }
      size_t v259 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
      v259[8] = v246;
      v259[4] = v247;
      v259[3] = *((void *)v99[6] + 23);
      ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v259);
      long long v117 = a3;
      uint64_t v77 = v395;
    }
  }
  if (v117[11])
  {
    uint64_t v260 = v77[21];
    if (v260)
    {
      if (*(void *)(**(void **)(v260 + 64) + 8) <= *(void *)(**(void **)(v260 + 64) + 48)
                                                        - *(void *)(**(void **)(v260 + 64) + 40))
      {
        uint64_t v261 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*((void *)v99[6] + 14));
        uint64_t v262 = *(void **)(*(void *)(v261 + 64) + 16);
        unint64_t v263 = v262[1];
        id v264 = (float32x2_t *)v262[9];
        v264->f32[0] = v394;
        v264->f32[1] = v104;
        v264[1].f32[0] = v105;
        v264[1].f32[1] = v106;
        v264[2] = v113;
        v264[3].f32[0] = v403;
        v264[3].f32[1] = v108;
        v264[4].f32[0] = v399;
        v264[4].f32[1] = v401;
        v264[5].f32[0] = v397;
        v264[5].f32[1] = v398;
        v264[6] = v114;
        v264[7].f32[0] = v396;
        v264[7].f32[1] = v116;
        if (v262[8] > v263) {
          unint64_t v263 = v262[8];
        }
        v262[7] = 0;
        v262[8] = v263;
        md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
        uint64_t v265 = *(void *)(v261 + 64);
        id v266 = __p[0];
        id v267 = (atomic_ullong *)__p[1];
        *(void **)(v265 + 32) = __p[0];
        *(void *)(v265 + 40) = 0;
        uint64_t v268 = *(void *)(v261 + 160);
        if (v267) {
          atomic_fetch_add_explicit(v267 + 1, 1uLL, memory_order_relaxed);
        }
        uint64_t v269 = *(std::__shared_weak_count **)(v268 + 40);
        *(void *)(v268 + 32) = v266;
        *(void *)(v268 + 40) = v267;
        if (v269 && !atomic_fetch_add(&v269->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v269->__on_zero_shared)(v269);
          std::__shared_weak_count::__release_weak(v269);
        }
        unint64_t v270 = (std::__shared_weak_count *)__p[1];
        if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v270->__on_zero_shared)(v270);
          std::__shared_weak_count::__release_weak(v270);
        }
        v271 = **(void ***)(v261 + 64);
        unint64_t v272 = v271[1];
        *(_OWORD *)v271[9] = xmmword_1A28FE130;
        if (v271[8] > v272) {
          unint64_t v272 = v271[8];
        }
        v271[7] = 0;
        v271[8] = v272;
        v273 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
        v273[8] = v260;
        v273[4] = v261;
        v273[3] = *((void *)v99[6] + 21);
        ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v273);
        long long v117 = a3;
        uint64_t v77 = v395;
      }
    }
  }
  if (v117[12])
  {
    uint64_t v274 = v77[27];
    if (v274)
    {
      if (*(void *)(**(void **)(v274 + 64) + 8) <= *(void *)(**(void **)(v274 + 64) + 48)
                                                        - *(void *)(**(void **)(v274 + 64) + 40))
      {
        uint64_t v275 = ggl::FragmentedPool<ggl::Point::PipelineSetup>::pop(*((void *)v99[6] + 17));
        BOOL v276 = **(void ***)(v275 + 64);
        unint64_t v277 = v276[1];
        uint64_t v278 = (float32x2_t *)v276[9];
        v278->f32[0] = v394;
        v278->f32[1] = v104;
        v278[1].f32[0] = v105;
        v278[1].f32[1] = v106;
        v278[2] = v113;
        v278[3].f32[0] = v403;
        v278[3].f32[1] = v108;
        v278[4].f32[0] = v399;
        v278[4].f32[1] = v401;
        v278[5].f32[0] = v397;
        v278[5].f32[1] = v398;
        v278[6] = v114;
        v278[7].f32[0] = v396;
        v278[7].f32[1] = v116;
        unint64_t v279 = v276[8];
        uint64_t v280 = v276[9];
        if (v279 <= v277) {
          unint64_t v279 = v277;
        }
        v276[7] = 0;
        *(_OWORD *)(v280 + 80) = xmmword_1A28FCDA0;
        if (v279 > v277) {
          unint64_t v277 = v279;
        }
        v276[8] = v277;
        md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
        uint64_t v281 = *(void *)(v275 + 64);
        char v282 = __p[0];
        v283 = (atomic_ullong *)__p[1];
        *(void **)(v281 + 16) = __p[0];
        *(void *)(v281 + 24) = 0;
        uint64_t v284 = *(void *)(v275 + 160);
        if (v283) {
          atomic_fetch_add_explicit(v283 + 1, 1uLL, memory_order_relaxed);
        }
        unint64_t v285 = *(std::__shared_weak_count **)(v284 + 24);
        *(void *)(v284 + 16) = v282;
        *(void *)(v284 + 24) = v283;
        if (v285 && !atomic_fetch_add(&v285->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v285->__on_zero_shared)(v285);
          std::__shared_weak_count::__release_weak(v285);
        }
        uint64_t v286 = (std::__shared_weak_count *)__p[1];
        if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v286->__on_zero_shared)(v286);
          std::__shared_weak_count::__release_weak(v286);
        }
        int v287 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
        v287[8] = v274;
        v287[4] = v275;
        v287[3] = *((void *)v99[6] + 23);
        ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v287);
        long long v117 = a3;
      }
    }
  }
  uint64_t v288 = *(void *)(v117 + 6);
  uint64_t v289 = *(void *)v117;
  BYTE5(v289) = v117[8];
  HIWORD(v289) = v288;
  if (v289
    || (BYTE3(v288) | BYTE4(v288)) | (BYTE5(v288) | v117[14])
    || (unsigned __int16)WORD2(*(void *)v117) >> 8)
  {
    uint64_t v290 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*((void *)v99[6] + 14));
    unint64_t v291 = *(void **)(*(void *)(v290 + 64) + 16);
    unint64_t v292 = v291[1];
    uint64_t v293 = (float32x2_t *)v291[9];
    v293->f32[0] = v394;
    v293->f32[1] = v104;
    v293[1].f32[0] = v105;
    v293[1].f32[1] = v106;
    v293[2] = v113;
    v293[3].f32[0] = v403;
    v293[3].f32[1] = v108;
    v293[4].f32[0] = v399;
    v293[4].f32[1] = v401;
    v293[5].f32[0] = v397;
    v293[5].f32[1] = v398;
    v293[6] = v114;
    v293[7].f32[0] = v396;
    v293[7].f32[1] = v116;
    if (v291[8] > v292) {
      unint64_t v292 = v291[8];
    }
    v291[7] = 0;
    v291[8] = v292;
    md::GeometryContext::transformConstantData((double *)__p, v97, &v407->_type, *(unsigned __int8 *)(v83 + 3776), 0.0, 0.0);
    uint64_t v294 = *(void *)(v290 + 64);
    v295 = __p[0];
    v296 = (atomic_ullong *)__p[1];
    *(void **)(v294 + 32) = __p[0];
    *(void *)(v294 + 40) = 0;
    uint64_t v297 = *(void *)(v290 + 160);
    if (v296) {
      atomic_fetch_add_explicit(v296 + 1, 1uLL, memory_order_relaxed);
    }
    unint64_t v298 = *(std::__shared_weak_count **)(v297 + 40);
    *(void *)(v297 + 32) = v295;
    *(void *)(v297 + 40) = v296;
    if (v298 && !atomic_fetch_add(&v298->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v298->__on_zero_shared)(v298);
      std::__shared_weak_count::__release_weak(v298);
    }
    v299 = (std::__shared_weak_count *)__p[1];
    if (__p[1] && !atomic_fetch_add((atomic_ullong *volatile)__p[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v299->__on_zero_shared)(v299);
      std::__shared_weak_count::__release_weak(v299);
    }
    v300 = **(void ***)(v290 + 64);
    unint64_t v301 = v300[1];
    *(_OWORD *)v300[9] = xmmword_1A28FCDD0;
    if (v300[8] > v301) {
      unint64_t v301 = v300[8];
    }
    v300[7] = 0;
    v300[8] = v301;
    unint64_t v302 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*((void *)v99[6] + 20));
    v302[8] = *(void *)md::DebugLayerRenderResources::unitRectMesh(v99[6]);
    v302[4] = v290;
    v302[3] = *((void *)v99[6] + 21);
    ggl::CommandBuffer::pushRenderItem((uint64_t)a6, (uint64_t)v302);
    uint64_t v303 = *v393;
    [v303 sizeInPixels];
    float64_t v402 = v305;
    float64_t v404 = v304;
    *(float *)&double v304 = v116 + v108;
    int32x2_t v400 = *(int32x2_t *)&v304;

    a7[12].i32[0] = -16777216;
    float32x2_t v306 = vdiv_f32(vadd_f32(v114, v113), (float32x2_t)vdup_lane_s32(v400, 0));
    __asm { FMOV            V1.2S, #1.0 }
    v312.i32[0] = vadd_f32(v306, _D1).u32[0];
    v312.i32[1] = vsub_f32(_D1, v306).i32[1];
    float64x2_t v313 = vcvtq_f64_f32(v312);
    __asm { FMOV            V1.2D, #0.5 }
    v315.f64[0] = v404;
    v315.f64[1] = v402;
    a7[1] = vcvt_f32_f64(vmulq_f64(v313, vmulq_f64(_Q1, v315)));
    objc_msgSend(NSString, "stringWithFormat:", @"X:%d Y:%d Z:%d\n", *((unsigned int *)a4 + 44), *((unsigned int *)a4 + 43), *((unsigned __int8 *)a4 + 169));
    id v316 = objc_claimAutoreleasedReturnValue();
    unint64_t v317 = v395;
    v318 = (int8x16_t *)[v316 UTF8String];
    size_t v319 = strlen(v318->i8);
    ggl::DebugConsole::drawString((uint64_t)a7, v318, v319, v320, v321);
    v322 = a3;
    if (a3[11])
    {
      v323 = objc_msgSend(NSString, "stringWithFormat:", @"Coast Lines: %tu   Verts: %tu \n", v395[12], v395[13]);

      id v316 = v323;
      v324 = (int8x16_t *)[v316 UTF8String];
      size_t v325 = strlen(v324->i8);
      ggl::DebugConsole::drawString((uint64_t)a7, v324, v325, v326, v327);
      v322 = a3;
    }
    if (v322[5])
    {
      unint64_t v328 = objc_msgSend(NSString, "stringWithFormat:", @"Hillshade Rasters: %u   Verts: %tu \n", geo::codec::VectorTile::hillshadeRasterCount((geo::codec::VectorTile *)*v16), 0);

      id v316 = v328;
      uint64_t v329 = (int8x16_t *)[v316 UTF8String];
      size_t v330 = strlen(v329->i8);
      ggl::DebugConsole::drawString((uint64_t)a7, v329, v330, v331, v332);
      v322 = a3;
    }
    if (v322[10])
    {
      __int16 v333 = objc_msgSend(NSString, "stringWithFormat:", @"Junctions:%zu Overpasses:%zu Crossings:%zu\n", v395[9], v395[11], v395[10]);

      id v316 = v333;
      v334 = (int8x16_t *)[v316 UTF8String];
      size_t v335 = strlen(v334->i8);
      ggl::DebugConsole::drawString((uint64_t)a7, v334, v335, v336, v337);
      v322 = a3;
    }
    if (v322[9])
    {
      unint64_t v338 = objc_msgSend(NSString, "stringWithFormat:", @"Vertices: %tu \n", v395[8]);

      id v316 = v338;
      v339 = (int8x16_t *)[v316 UTF8String];
      size_t v340 = strlen(v339->i8);
      ggl::DebugConsole::drawString((uint64_t)a7, v339, v340, v341, v342);
      v322 = a3;
    }
    if (v322[2])
    {
      uint64_t v343 = objc_msgSend(NSString, "stringWithFormat:", @"Unnamed Lines: %tu Verts: %tu \n", v395[2], v395[3]);

      id v344 = v343;
      uint64_t v345 = (int8x16_t *)[v344 UTF8String];
      size_t v346 = strlen(v345->i8);
      ggl::DebugConsole::drawString((uint64_t)a7, v345, v346, v347, v348);
      v349 = objc_msgSend(NSString, "stringWithFormat:", @"Named lines: %tu Verts: %tu \n", *v395, v395[1]);

      id v316 = v349;
      v350 = (int8x16_t *)[v316 UTF8String];
      size_t v351 = strlen(v350->i8);
      ggl::DebugConsole::drawString((uint64_t)a7, v350, v351, v352, v353);
      v322 = a3;
    }
    if (v322[3])
    {
      v354 = objc_msgSend(NSString, "stringWithFormat:", @"Points: %tu\n", v395[7]);

      id v316 = v354;
      v355 = (int8x16_t *)[v316 UTF8String];
      size_t v356 = strlen(v355->i8);
      ggl::DebugConsole::drawString((uint64_t)a7, v355, v356, v357, v358);
      v322 = a3;
    }
    if (!v322[4] && !v322[8] && !v322[6] && !v322[7])
    {
      if (!*v322) {
        goto LABEL_402;
      }
LABEL_405:
      uint64_t v364 = a4[109];
      if (a4[110] == v364)
      {
        uint64_t v386 = [NSString stringWithFormat:@"(no traffic)\n"];

        id v316 = v386;
        uint64_t v387 = (int8x16_t *)[v316 UTF8String];
        size_t v388 = strlen(v387->i8);
        ggl::DebugConsole::drawString((uint64_t)a7, v387, v388, v389, v390);
        if (!a3[14]) {
          goto LABEL_419;
        }
      }
      else
      {
        id v405 = v316;
        unint64_t v365 = 0;
        unsigned int v366 = 1;
        do
        {
          if (!md::DebugRenderLayer::renderTileData(md::LayoutContext const&,md::PaintFlags const&,md::MapTileData const*,md::MapDataType,ggl::CommandBuffer *,md::DebugConsole *)::dateFormatter)
          {
            id v367 = objc_alloc_init(MEMORY[0x1E4F28C10]);
            uint64_t v368 = (void *)md::DebugRenderLayer::renderTileData(md::LayoutContext const&,md::PaintFlags const&,md::MapTileData const*,md::MapDataType,ggl::CommandBuffer *,md::DebugConsole *)::dateFormatter;
            md::DebugRenderLayer::renderTileData(md::LayoutContext const&,md::PaintFlags const&,md::MapTileData const*,md::MapDataType,ggl::CommandBuffer *,md::DebugConsole *)::dateFormatter = (uint64_t)v367;

            [(id)md::DebugRenderLayer::renderTileData(md::LayoutContext const&,md::PaintFlags const&,md::MapTileData const*,md::MapDataType,ggl::CommandBuffer *,md::DebugConsole *)::dateFormatter setDateStyle:1];
            [(id)md::DebugRenderLayer::renderTileData(md::LayoutContext const&,md::PaintFlags const&,md::MapTileData const*,md::MapDataType,ggl::CommandBuffer *,md::DebugConsole *)::dateFormatter setTimeStyle:1];
          }
          uint64_t v369 = v364 + 16 * v365;
          uint64_t v370 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSince1970:(double)zilch::TrafficDynamicTile::feedUpdateTimeSeconds(*(zilch::TrafficDynamicTile **)(*(void *)v369 + 144))];
          BOOL v371 = *(int32x2_t **)(*(void *)v369 + 8);
          __int32 v372 = v371[1].i32[0];
          unint64_t v373 = NSString;
          int32x2_t v374 = *v371;
          v411[0] = -1;
          v411[1] = v372;
          int32x2_t v412 = vrev64_s32(v374);
          md::debugString<geo::QuadTile>(__p, v411);
          int v375 = SHIBYTE(v414);
          BOOL v376 = (void **)__p[0];
          uint64_t v377 = [(id)md::DebugRenderLayer::renderTileData(md::LayoutContext const&,md::PaintFlags const&,md::MapTileData const*,md::MapDataType,ggl::CommandBuffer *,md::DebugConsole *)::dateFormatter stringFromDate:v370];
          unint64_t v378 = (void *)v377;
          if (v375 >= 0) {
            unint64_t v379 = __p;
          }
          else {
            unint64_t v379 = v376;
          }
          v380 = [v373 stringWithFormat:@"traffic %s : %@\n", v379, v377];

          if (SHIBYTE(v414) < 0) {
            operator delete(__p[0]);
          }
          id v381 = v380;
          unint64_t v382 = (int8x16_t *)[v381 UTF8String];
          size_t v383 = strlen(v382->i8);
          ggl::DebugConsole::drawString((uint64_t)a7, v382, v383, v384, v385);

          unint64_t v365 = v366;
          uint64_t v364 = v409[109];
          ++v366;
        }
        while (v365 < (v409[110] - v364) >> 4);
        uint64_t v78 = v393;
        uint64_t v99 = (md::DebugLayerRenderResources **)v406;
        unint64_t v317 = v395;
        id v316 = v405;
        if (!a3[14]) {
          goto LABEL_419;
        }
      }
LABEL_418:
      md::DebugRenderLayer::renderTexturedQuadTile((md::DebugRenderLayer *)v99, v78, v407, (ggl::Texture2D *)v317[28], a6, v392);
      goto LABEL_419;
    }
    v359 = objc_msgSend(NSString, "stringWithFormat:", @"Polygons: %tu  Verts: %tu\n", v395[4], v395[5]);

    id v316 = v359;
    uint64_t v360 = (int8x16_t *)[v316 UTF8String];
    size_t v361 = strlen(v360->i8);
    ggl::DebugConsole::drawString((uint64_t)a7, v360, v361, v362, v363);
    v322 = a3;
    if (*a3) {
      goto LABEL_405;
    }
LABEL_402:
    if (v322[14]) {
      goto LABEL_418;
    }
LABEL_419:
  }
}

void sub_1A20F1818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

void sub_1A20F1850(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1A20F1868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38)
{
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::Point::PipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      __int32 v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint8x8_t v34 = v12 - 2;
        int v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint8x8_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *unint64_t v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      __int32 v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint8x8_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint8x8_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  __int32 v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void *std::__hash_table<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::__unordered_map_hasher<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,true>,std::__unordered_map_equal<std::shared_ptr<geo::codec::VectorTile>,std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>,std::equal_to<std::shared_ptr<geo::codec::VectorTile>>,std::hash<std::shared_ptr<geo::codec::VectorTile>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<geo::codec::VectorTile>,std::shared_ptr<md::ModelTileDebugData>>>>::__emplace_unique_key_args<std::shared_ptr<geo::codec::VectorTile>,std::piecewise_construct_t const&,std::tuple<std::shared_ptr<geo::codec::VectorTile> const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = v8 & (v9 - 1);
    }
    uint64_t v11 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v11)
    {
      unint64_t v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2) {
                return v12;
              }
            }
            else if ((v14 & (v9 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2) {
              return v12;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v3) {
              break;
            }
          }
          unint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  __int32 v15 = (void *)(a1 + 16);
  uint64_t v16 = operator new(0x30uLL);
  unint64_t v12 = v16;
  *uint64_t v16 = 0;
  v16[1] = v8;
  uint64_t v17 = a3[1];
  v16[2] = *a3;
  v16[3] = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  v16[4] = 0;
  v16[5] = 0;
  float v18 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v19 = *(float *)(a1 + 32);
  if (!v9 || (float)(v19 * (float)v9) < v18)
  {
    BOOL v20 = 1;
    if (v9 >= 3) {
      BOOL v20 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v9);
    unint64_t v22 = vcvtps_u32_f32(v18 / v19);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v24 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v24) {
      goto LABEL_36;
    }
    if (prime < *(void *)&v24)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v24 < 3uLL || (uint8x8_t v26 = (uint8x8_t)vcnt_s8(v24), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (prime <= v25) {
        size_t prime = v25;
      }
      if (prime < *(void *)&v24) {
LABEL_36:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v9 = *(void *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
      else {
        unint64_t v3 = v8;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
  }
  uint64_t v28 = *(void *)a1;
  long long v29 = *(void **)(*(void *)a1 + 8 * v3);
  if (v29)
  {
    *unint64_t v12 = *v29;
LABEL_60:
    void *v29 = v12;
    goto LABEL_61;
  }
  *unint64_t v12 = *v15;
  *__int32 v15 = v12;
  *(void *)(v28 + 8 * v3) = v15;
  if (*v12)
  {
    unint64_t v30 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v30 >= v9) {
        v30 %= v9;
      }
    }
    else
    {
      v30 &= v9 - 1;
    }
    long long v29 = (void *)(*(void *)a1 + 8 * v30);
    goto LABEL_60;
  }
LABEL_61:
  ++*(void *)(a1 + 24);
  return v12;
}

void sub_1A20F1F6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::ModelTileDebugData>::__on_zero_shared(void *a1)
{
  uint64_t v2 = a1[31];
  a1[31] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = a1[30];
  a1[30] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = a1[29];
  a1[29] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = a1[28];
  a1[28] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = a1[27];
  a1[27] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  uint64_t v7 = a1[26];
  a1[26] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = a1[25];
  a1[25] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = a1[24];
  a1[24] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = a1[23];
  a1[23] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = a1[22];
  a1[22] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = a1[21];
  a1[21] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = a1[20];
  a1[20] = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = a1[19];
  a1[19] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  __int32 v15 = (std::__shared_weak_count *)a1[18];
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
}

void std::__shared_ptr_emplace<md::ModelTileDebugData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5808A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ModelTileDebugData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5808A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::construct_at[abi:nn180100]<ggl::CommonMesh::Pos4Mesh,char const(&)[22],std::shared_ptr<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4>> &,std::shared_ptr<ggl::IndexDataTyped<unsigned short>> &,ggl::CommonMesh::Pos4Mesh*>(uint64_t a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t *a5)
{
  uint64_t v10 = a3;
  uint64_t v11 = a4;
  if (a4) {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = (std::__shared_weak_count *)a5[1];
  v9[0] = *a5;
  v9[1] = (uint64_t)v6;
  if (v6)
  {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    ggl::CommonMesh::Pos4Mesh::Pos4Mesh(a1, a2, &v10, v9);
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  else
  {
    ggl::CommonMesh::Pos4Mesh::Pos4Mesh(a1, a2, &v10, v9);
  }
  uint64_t v7 = v11;
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<md::components::Decal>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::components::Decal>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(_DWORD *)(v14 + 4 * v7) = *(_DWORD *)(v15 - 4);
  a1[11] = v15 - 4;
  uint64_t v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    uint64_t v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::components::Decal>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::components::Decal>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

char *md::DebugLayerRenderResources::unitTexturedMesh(md::DebugLayerRenderResources *this)
{
  uint64_t v1 = (char *)this + 256;
  if (!*((void *)this + 32))
  {
    uint64_t v3 = operator new(0xA8uLL);
    v3[1] = 0;
    int8x8_t v3[2] = 0;
    void *v3 = &unk_1EF583078;
    uint64_t v4 = ggl::CommonMesh::Pos2UVMesh::Pos2UVMesh((ggl::CommonMesh::Pos2UVMesh *)(v3 + 3), "/DebugSharedUnitTexturedMesh");
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 33);
    *((void *)this + 32) = v4;
    *((void *)this + 33) = v3;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    uint64_t v6 = **(void **)(*(void *)v1 + 64);
    unint64_t v7 = 6 * *(void *)(v6 + 8);
    uint64_t v8 = *(void *)(v6 + 72);
    unint64_t v9 = *(void *)(v6 + 80) - v8;
    if (v7 != v9)
    {
      if (v7 <= v9)
      {
        if (v7 < v9) {
          *(void *)(v6 + 80) = v8 + v7;
        }
      }
      else
      {
        std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v6 + 72, v7 - v9);
      }
      unint64_t v10 = *(std::__shared_weak_count **)(v6 + 32);
      *(void *)(v6 + 24) = 0;
      *(void *)(v6 + 32) = 0;
      if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
      *(void *)(v6 + 120) = 0;
      *(_DWORD *)(v6 + 112) = 0;
      uint64_t v11 = *(void *)(v6 + 80) - *(void *)(v6 + 72);
      *(void *)(v6 + 40) = 0;
      *(void *)(v6 + 48) = v11;
      *(void *)(v6 + 56) = 0;
      *(void *)(v6 + 64) = v11;
      uint64_t v6 = **(void **)(*(void *)v1 + 64);
      unint64_t v7 = 6 * *(void *)(v6 + 8);
    }
    if (v7) {
      uint64_t v12 = *(void *)(v6 + 72);
    }
    else {
      uint64_t v12 = 0;
    }
    *(void *)uint64_t v12 = 0;
    *(void *)(v12 + 8) = 0;
    __asm { FMOV            V1.4S, #1.0 }
    *(_OWORD *)(v12 + 16) = xmmword_1A28FD280;
    *(_OWORD *)(v12 + 32) = _Q1;
    *(_OWORD *)(v12 + 48) = _Q1;
    *(_OWORD *)(v12 + 64) = xmmword_1A28FD290;
    *(void *)(v12 + 80) = 0;
    *(void *)(v12 + 88) = 0;
    if (v12 && v7)
    {
      if (*(void *)(v6 + 64) > v7) {
        unint64_t v7 = *(void *)(v6 + 64);
      }
      *(void *)(v6 + 56) = 0;
      *(void *)(v6 + 64) = v7;
    }
  }
  return v1;
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_6,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_7,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_8,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_9>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gm::Box<double,3>,std::__variant_detail::_Trait::Sphere<double,3,std::enable_if<true,void>>,geo::OrientedBox<double,3u,double,double>> const&>(uint64_t *a1, long long *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)(*a1 + 48);
  uint64_t v4 = *(void *)(*a1 + 56);
  long long v51 = 0u;
  long long v53 = 0u;
  uint64_t v54 = 0;
  long long v52 = 0u;
  long long v50 = 0u;
  long long v49 = 0u;
  double v5 = *((double *)a2 + 6);
  double v6 = *((double *)a2 + 10) - *((double *)a2 + 7);
  double v7 = *((double *)a2 + 11) - *((double *)a2 + 8);
  double v8 = *((double *)a2 + 12) - *((double *)a2 + 9);
  long long v55 = *(long long *)((char *)a2 + 56);
  uint64_t v56 = *((void *)a2 + 9);
  uint64_t v57 = 0x3FF0000000000000;
  double v48 = v6;
  *(double *)&long long v51 = v7;
  *((double *)&v53 + 1) = v8;
  double v9 = *((double *)a2 + 4);
  double v10 = *((double *)a2 + 5);
  double v11 = v9 + v9;
  double v12 = (v9 + v9) * v9;
  double v13 = (v10 + v10) * v10;
  uint64_t v15 = *((void *)a2 + 2);
  double v14 = *((double *)a2 + 3);
  double v16 = (v14 + v14) * v9;
  double v17 = (v10 + v10) * v5;
  double v18 = v16 - v17;
  double v19 = v10 * (v14 + v14);
  double v20 = v5 * v11;
  double v21 = v17 + v16;
  double v22 = v5 * v11 + v19;
  double v23 = 1.0 - (v14 + v14) * v14;
  double v24 = v11 * v10;
  double v25 = v5 * (v14 + v14);
  *(double *)v34.i64 = 1.0 - (v12 + v13);
  *(double *)&v34.i64[1] = v21;
  double v37 = v18;
  double v38 = v23 - v13;
  double v41 = v22;
  double v42 = v24 - v25;
  double v35 = v19 - v20;
  double v39 = v25 + v24;
  double v43 = v23 - v12;
  uint64_t v36 = 0;
  uint64_t v40 = 0;
  uint64_t v44 = 0;
  long long v45 = *a2;
  uint64_t v46 = v15;
  uint64_t v47 = 0x3FF0000000000000;
  double v26 = gm::operator*<double,4,4,4>(v33, (double *)v34.i64, &v48);
  uint64_t v27 = *(void *)(v2 + 72);
  LODWORD(v26) = **(_DWORD **)(v2 + 64);
  float32x4_t v34 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)&v26))), (float32x4_t)vdupq_n_s32(0x3B808081u));
  int v28 = *(unsigned __int8 *)(v27 + 12);
  uint64_t v29 = **(void **)(v2 + 80);
  unint64_t v30 = (char *)operator new(0x40uLL);
  *(void *)&long long v49 = v30 + 64;
  *((void *)&v49 + 1) = v30 + 64;
  *(_DWORD *)unint64_t v30 = 1065353216;
  *(void *)(v30 + 12) = 0;
  *(void *)(v30 + 4) = 0;
  *((_DWORD *)v30 + 5) = 1065353216;
  *((void *)v30 + 3) = 0;
  *((void *)v30 + 4) = 0;
  *((_DWORD *)v30 + 10) = 1065353216;
  *(void *)(v30 + 52) = 0;
  *(void *)(v30 + 44) = 0;
  *((_DWORD *)v30 + 15) = 1065353216;
  double v48 = *(double *)&v30;
  unint64_t v31 = *(uint64_t **)(v2 + 88);
  uint64_t v32 = (void *)md::DebugLayerRenderResources::unitBoxMesh(*(md::DebugLayerRenderResources **)(v3 + 48));
  md::DebugRenderLayer::renderInstancedMesh(v3, *(void **)(v4 + 8), v33, &v34, v28 != 0, v29, (uint64_t)&v48, v32, v31);
  operator delete(v30);
}

void sub_1A20F2964(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_6,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_7,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_8,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_9>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gm::Box<double,3>,std::__variant_detail::_Trait::Sphere<double,3,std::enable_if<true,void>>,geo::OrientedBox<double,3u,double,double>> const&>(uint64_t *a1, long long *a2)
{
  uint64_t v2 = *a1;
  uint64_t v4 = *((void *)a2 + 2);
  uint64_t v3 = *((void *)a2 + 3);
  uint64_t v5 = *(void *)(*a1 + 96);
  uint64_t v6 = *(void *)(*a1 + 104);
  long long v7 = *a2;
  long long v24 = xmmword_1A28FCBD0;
  double v25 = 0;
  uint64_t v26 = 0;
  long long v27 = xmmword_1A28FCCC0;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = xmmword_1A28FCBD0;
  long long v31 = v7;
  uint64_t v32 = v4;
  uint64_t v33 = 0x3FF0000000000000;
  long long v17 = 0u;
  uint64_t v19 = 0;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  memset(&v16.u32[2], 0, 32);
  uint64_t v23 = 0x3FF0000000000000;
  v16.i64[0] = v3;
  *(void *)&long long v17 = v3;
  uint64_t v20 = v3;
  double v8 = gm::operator*<double,4,4,4>(v15, (double *)&v24, (double *)v16.i64);
  uint64_t v9 = *(void *)(v2 + 120);
  LODWORD(v8) = **(_DWORD **)(v2 + 112);
  float32x4_t v16 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)&v8))), (float32x4_t)vdupq_n_s32(0x3B808081u));
  int v10 = *(unsigned __int8 *)(v9 + 12);
  uint64_t v11 = **(void **)(v2 + 128);
  double v12 = (char *)operator new(0x40uLL);
  *((void *)&v24 + 1) = v12 + 64;
  double v25 = v12 + 64;
  *(_DWORD *)double v12 = 1065353216;
  *(void *)(v12 + 12) = 0;
  *(void *)(v12 + 4) = 0;
  *((_DWORD *)v12 + 5) = 1065353216;
  *((void *)v12 + 3) = 0;
  *((void *)v12 + 4) = 0;
  *((_DWORD *)v12 + 10) = 1065353216;
  *(void *)(v12 + 52) = 0;
  *(void *)(v12 + 44) = 0;
  *((_DWORD *)v12 + 15) = 1065353216;
  *(void *)&long long v24 = v12;
  double v13 = *(uint64_t **)(v2 + 136);
  double v14 = (void *)md::DebugLayerRenderResources::icoSphere(*(md::DebugLayerRenderResources **)(v5 + 48));
  md::DebugRenderLayer::renderInstancedMesh(v5, *(void **)(v6 + 8), v15, &v16, v10 != 0, v11, (uint64_t)&v24, v14, v13);
  operator delete(v12);
}

void sub_1A20F2AF8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_6,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_7,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_8,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_9>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gm::Box<double,3>,std::__variant_detail::_Trait::Sphere<double,3,std::enable_if<true,void>>,geo::OrientedBox<double,3u,double,double>> const&>(uint64_t **a1, double *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = **a1;
  uint64_t v4 = (*a1)[1];
  double v5 = *a2;
  double v6 = a2[1];
  double v7 = a2[2];
  double v8 = a2[3];
  double v9 = a2[4];
  double v10 = a2[5];
  uint64_t v23 = 0;
  uint64_t v25 = 0;
  long long v20 = 0u;
  long long v21 = 0u;
  long long v24 = 0u;
  uint64_t v27 = 0;
  uint64_t v31 = 0x3FF0000000000000;
  double v19 = v8 - v5;
  double v22 = v9 - v6;
  double v26 = v10 - v7;
  double v28 = v5;
  double v29 = v6;
  double v30 = v7;
  uint64_t v11 = v2[3];
  LODWORD(v5) = *(_DWORD *)v2[2];
  float32x4_t v18 = vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)&v5))), (float32x4_t)vdupq_n_s32(0x3B808081u));
  int v12 = *(unsigned __int8 *)(v11 + 12);
  uint64_t v13 = *(void *)v2[4];
  double v14 = (char *)operator new(0x40uLL);
  v17[1] = v14 + 64;
  void v17[2] = v14 + 64;
  *(_DWORD *)double v14 = 1065353216;
  *(void *)(v14 + 12) = 0;
  *(void *)(v14 + 4) = 0;
  *((_DWORD *)v14 + 5) = 1065353216;
  *((void *)v14 + 3) = 0;
  *((void *)v14 + 4) = 0;
  *((_DWORD *)v14 + 10) = 1065353216;
  *(void *)(v14 + 52) = 0;
  *(void *)(v14 + 44) = 0;
  *((_DWORD *)v14 + 15) = 1065353216;
  v17[0] = v14;
  uint64_t v15 = (uint64_t *)v2[5];
  float32x4_t v16 = (void *)md::DebugLayerRenderResources::unitBoxMesh(*(md::DebugLayerRenderResources **)(v3 + 48));
  md::DebugRenderLayer::renderInstancedMesh(v3, *(void **)(v4 + 8), &v19, &v18, v12 != 0, v13, (uint64_t)v17, v16, v15);
  operator delete(v14);
}

void sub_1A20F2C58(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ggl::DeviceDataTyped<ggl::Debug::InstanceTransform>::~DeviceDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::DeviceDataTyped<ggl::Debug::InstanceTransform>::~DeviceDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::Debug::InstanceTransform>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::Debug::InstanceTransform>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583F20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DeviceDataTyped<ggl::Debug::InstanceTransform>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583F20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__variant_detail::__visitation::__base::__dispatcher<3ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_1,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_2,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_3,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_4,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_5>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gm::Box<float,3>,std::__variant_detail::_Trait::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo<float,2u,float,float>> const&>(float32x4_t ****a1, uint64_t a2, int32x4_t a3)
{
  uint64_t v3 = **a1;
  a3.i64[0] = *(void *)(a2 + 28);
  float v4 = *(float *)(a2 + 12);
  float v5 = *(float *)(a2 + 16);
  float v6 = *(float *)(a2 + 20);
  float v7 = *(float *)(a2 + 24);
  float v8 = v5 + v5;
  float v9 = (float)(v5 + v5) * v5;
  float v10 = (float)(v6 + v6) * v6;
  *(float *)&unsigned int v11 = 1.0 - (float)(v9 + v10);
  float v12 = v4 + v4;
  float v13 = (float)(v4 + v4) * v5;
  float v14 = (float)(v6 + v6) * v7;
  float v15 = v6 * (float)(v4 + v4);
  float v16 = v7 * v8;
  *(float *)&unsigned int v17 = (float)(v7 * v8) + v15;
  float v18 = 1.0 - (float)((float)(v4 + v4) * v4);
  float v19 = v8 * v6;
  float v20 = v7 * v12;
  *(float *)&unsigned int v21 = v19 - v20;
  *(float *)&unsigned int v22 = v20 + v19;
  v23.i32[1] = 0;
  v23.f32[0] = v15 - v16;
  v23.i64[1] = __PAIR64__(v18 - v10, v13 - v14);
  *(float *)&unsigned int v24 = v18 - v9;
  v26.i64[0] = __PAIR64__(v21, v17);
  LODWORD(v25) = 0;
  v26.i64[1] = v24;
  float32x4_t v27 = *(float32x4_t *)a2;
  v27.i32[3] = 1.0;
  *(float *)&unsigned int v28 = *(float *)(a2 + 36) - *(float *)(a2 + 28);
  float32x4_t v29 = (float32x4_t)vzip1q_s32((int32x4_t)v28, (int32x4_t)v28);
  int8x16_t v30 = (int8x16_t)vmulq_f32(v29, v23);
  v31.i64[0] = __PAIR64__(v14 + v13, v11);
  v31.i64[1] = v22;
  float32x4_t v32 = vmlaq_f32((float32x4_t)vextq_s8(v30, v30, 8uLL), v31, v29);
  *((float *)&v25 + 1) = *(float *)(a2 + 40) - *(float *)(a2 + 32);
  float32x4_t v33 = (float32x4_t)vzip1q_s32((int32x4_t)v25, (int32x4_t)v25);
  int8x16_t v34 = (int8x16_t)vmulq_f32(v33, v23);
  float32x4_t v35 = vmlaq_f32((float32x4_t)vextq_s8(v34, v34, 8uLL), v31, v33);
  float32x4_t v36 = (float32x4_t)vzip1q_s32(a3, a3);
  int8x16_t v37 = (int8x16_t)vmulq_f32(v36, v23);
  float32x4_t v38 = vaddq_f32(v27, vmlaq_f32((float32x4_t)vextq_s8(v37, v37, 8uLL), v31, v36));
  uint64_t v40 = v3[1];
  unint64_t v39 = (unint64_t)v3[2];
  if ((unint64_t)v40 >= v39)
  {
    double v42 = *v3;
    uint64_t v43 = ((char *)v40 - (char *)*v3) >> 6;
    unint64_t v44 = v43 + 1;
    if ((unint64_t)(v43 + 1) >> 58) {
      abort();
    }
    uint64_t v45 = v39 - (void)v42;
    if (v45 >> 5 > v44) {
      unint64_t v44 = v45 >> 5;
    }
    if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v46 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v46 = v44;
    }
    if (v46)
    {
      float32x4_t v52 = v38;
      float32x4_t v53 = v35;
      float32x4_t v54 = v32;
      float32x4_t v55 = v26;
      if (v46 >> 58) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v47 = (char *)operator new(v46 << 6);
      float32x4_t v32 = v54;
      float32x4_t v26 = v55;
      float32x4_t v38 = v52;
      float32x4_t v35 = v53;
    }
    else
    {
      uint64_t v47 = 0;
    }
    double v48 = (float32x4_t *)&v47[64 * v43];
    float32x4_t *v48 = v32;
    v48[1] = v35;
    v48[2] = v26;
    v48[3] = v38;
    double v41 = v48 + 4;
    if (v40 != v42)
    {
      do
      {
        float32x4_t v49 = v40[-4];
        float32x4_t v50 = v40[-3];
        float32x4_t v51 = v40[-1];
        v48[-2] = v40[-2];
        v48[-1] = v51;
        v48[-4] = v49;
        v48[-3] = v50;
        v48 -= 4;
        v40 -= 4;
      }
      while (v40 != v42);
      uint64_t v40 = *v3;
    }
    std::__shared_weak_count *v3 = v48;
    v3[1] = v41;
    int8x8_t v3[2] = (float32x4_t *)&v47[64 * v46];
    if (v40) {
      operator delete(v40);
    }
  }
  else
  {
    *uint64_t v40 = v32;
    v40[1] = v35;
    double v41 = v40 + 4;
    v40[2] = v26;
    v40[3] = v38;
  }
  v3[1] = v41;
}

void std::__variant_detail::__visitation::__base::__dispatcher<2ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_1,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_2,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_3,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_4,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_5>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gm::Box<float,3>,std::__variant_detail::_Trait::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo<float,2u,float,float>> const&>(uint64_t a1, uint64_t a2, double a3, int32x4_t a4)
{
  float v4 = *(float32x4_t ***)(*(void *)a1 + 16);
  float v5 = *(float *)(a2 + 24);
  float v6 = *(float *)(a2 + 36);
  a4.i64[0] = *(void *)(a2 + 28);
  float v7 = *(float *)(a2 + 12);
  float v8 = *(float *)(a2 + 16);
  float v9 = *(float *)(a2 + 20);
  float v10 = v8 + v8;
  float v11 = (float)(v8 + v8) * v8;
  float v12 = (float)(v9 + v9) * v9;
  *(float *)&unsigned int v13 = 1.0 - (float)(v11 + v12);
  float v14 = v7 + v7;
  float v15 = (float)(v7 + v7) * v8;
  float v16 = (float)(v9 + v9) * v5;
  float32_t v17 = v15 - v16;
  float v18 = v9 * (float)(v7 + v7);
  float v19 = v5 * v10;
  *(float *)&unsigned int v20 = (float)(v5 * v10) + v18;
  *(float *)&unsigned int v21 = v16 + v15;
  float v22 = 1.0 - (float)((float)(v7 + v7) * v7);
  float v23 = v10 * v9;
  float v24 = v5 * v14;
  *(float *)&unsigned int v25 = v23 - v24;
  *(float *)&unsigned int v26 = v24 + v23;
  v27.i32[1] = 0;
  v27.f32[0] = v18 - v19;
  v27.f32[2] = v17;
  v27.f32[3] = v22 - v12;
  *(float *)&unsigned int v28 = v22 - v11;
  v29.i64[0] = __PAIR64__(v25, v20);
  LODWORD(v30) = 0;
  v29.i64[1] = v28;
  float32x4_t v31 = *(float32x4_t *)a2;
  v31.i32[3] = 1.0;
  *(float *)&unsigned int v32 = *(float *)(a2 + 40) - *(float *)(a2 + 28);
  float32x4_t v33 = (float32x4_t)vzip1q_s32((int32x4_t)v32, (int32x4_t)v32);
  int8x16_t v34 = (int8x16_t)vmulq_f32(v33, v27);
  v35.i64[0] = __PAIR64__(v21, v13);
  v35.i64[1] = v26;
  float32x4_t v36 = vmlaq_f32((float32x4_t)vextq_s8(v34, v34, 8uLL), v35, v33);
  *((float *)&v30 + 1) = *(float *)(a2 + 44) - *(float *)(a2 + 32);
  float32x4_t v37 = (float32x4_t)vzip1q_s32((int32x4_t)v30, (int32x4_t)v30);
  int8x16_t v38 = (int8x16_t)vmulq_f32(v37, v27);
  float32x4_t v39 = vmlaq_f32((float32x4_t)vextq_s8(v38, v38, 8uLL), v35, v37);
  float32x4_t v40 = vmulq_n_f32(v29, *(float *)(a2 + 48) - v6);
  float32x4_t v41 = (float32x4_t)vzip1q_s32(a4, a4);
  int8x16_t v42 = (int8x16_t)vmulq_f32(v41, v27);
  float32x4_t v43 = vaddq_f32(v31, vmlaq_n_f32(vmlaq_f32((float32x4_t)vextq_s8(v42, v42, 8uLL), v35, v41), v29, v6));
  uint64_t v45 = v4[1];
  unint64_t v44 = (unint64_t)v4[2];
  if ((unint64_t)v45 >= v44)
  {
    uint64_t v47 = *v4;
    uint64_t v48 = ((char *)v45 - (char *)*v4) >> 6;
    unint64_t v49 = v48 + 1;
    if ((unint64_t)(v48 + 1) >> 58) {
      abort();
    }
    uint64_t v50 = v44 - (void)v47;
    if (v50 >> 5 > v49) {
      unint64_t v49 = v50 >> 5;
    }
    if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v51 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v51 = v49;
    }
    if (v51)
    {
      float32x4_t v57 = v43;
      float32x4_t v58 = v39;
      float32x4_t v59 = v40;
      float32x4_t v60 = v36;
      if (v51 >> 58) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      float32x4_t v52 = (char *)operator new(v51 << 6);
      float32x4_t v40 = v59;
      float32x4_t v36 = v60;
      float32x4_t v43 = v57;
      float32x4_t v39 = v58;
    }
    else
    {
      float32x4_t v52 = 0;
    }
    float32x4_t v53 = (float32x4_t *)&v52[64 * v48];
    float32x4_t *v53 = v36;
    v53[1] = v39;
    v53[2] = v40;
    v53[3] = v43;
    unint64_t v46 = v53 + 4;
    if (v45 != v47)
    {
      do
      {
        float32x4_t v54 = v45[-4];
        float32x4_t v55 = v45[-3];
        float32x4_t v56 = v45[-1];
        v53[-2] = v45[-2];
        v53[-1] = v56;
        v53[-4] = v54;
        v53[-3] = v55;
        v53 -= 4;
        v45 -= 4;
      }
      while (v45 != v47);
      uint64_t v45 = *v4;
    }
    *float v4 = v53;
    v4[1] = v46;
    v4[2] = (float32x4_t *)&v52[64 * v51];
    if (v45) {
      operator delete(v45);
    }
  }
  else
  {
    *uint64_t v45 = v36;
    v45[1] = v39;
    unint64_t v46 = v45 + 4;
    v45[2] = v40;
    v45[3] = v43;
  }
  v4[1] = v46;
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_1,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_2,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_3,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_4,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_5>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gm::Box<float,3>,std::__variant_detail::_Trait::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo<float,2u,float,float>> const&>(uint64_t a1, float32x4_t *a2)
{
  float32x4_t v4 = *a2;
  float v2 = a2->f32[3];
  uint64_t v3 = *(float32x4_t ***)(*(void *)a1 + 24);
  v30.i64[0] = 0;
  v30.i64[1] = 0x3F80000000000000;
  v4.i32[3] = 1.0;
  LODWORD(v5) = 0;
  float32x4_t v6 = (float32x4_t)vzip1q_s32((int32x4_t)LODWORD(v2), (int32x4_t)LODWORD(v2));
  int8x16_t v7 = (int8x16_t)vmulq_f32(v6, v30);
  float32x4_t v8 = vmlaq_f32((float32x4_t)vextq_s8(v7, v7, 8uLL), (float32x4_t)xmmword_1A28FCEA0, v6);
  *((float *)&v5 + 1) = v2;
  float32x4_t v9 = (float32x4_t)vzip1q_s32((int32x4_t)v5, (int32x4_t)v5);
  int8x16_t v10 = (int8x16_t)vmulq_f32(v9, v30);
  float32x4_t v11 = vmlaq_f32((float32x4_t)vextq_s8(v10, v10, 8uLL), (float32x4_t)xmmword_1A28FCEA0, v9);
  float32x4_t v12 = vmulq_n_f32((float32x4_t)xmmword_1A28FCE90, v2);
  float v14 = v3[1];
  unint64_t v13 = (unint64_t)v3[2];
  if ((unint64_t)v14 >= v13)
  {
    float v16 = *v3;
    uint64_t v17 = ((char *)v14 - (char *)*v3) >> 6;
    unint64_t v18 = v17 + 1;
    if ((unint64_t)(v17 + 1) >> 58) {
      abort();
    }
    uint64_t v19 = v13 - (void)v16;
    if (v19 >> 5 > v18) {
      unint64_t v18 = v19 >> 5;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v20 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20)
    {
      float32x4_t v26 = v12;
      float32x4_t v27 = v11;
      float32x4_t v28 = v8;
      float32x4_t v29 = v4;
      if (v20 >> 58) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unsigned int v21 = (char *)operator new(v20 << 6);
      float32x4_t v8 = v28;
      float32x4_t v4 = v29;
      float32x4_t v12 = v26;
      float32x4_t v11 = v27;
    }
    else
    {
      unsigned int v21 = 0;
    }
    float v22 = (float32x4_t *)&v21[64 * v17];
    *float v22 = v8;
    v22[1] = v11;
    v22[2] = v12;
    v22[3] = v4;
    float v15 = v22 + 4;
    if (v14 != v16)
    {
      do
      {
        float32x4_t v23 = v14[-4];
        float32x4_t v24 = v14[-3];
        float32x4_t v25 = v14[-1];
        v22[-2] = v14[-2];
        v22[-1] = v25;
        v22[-4] = v23;
        v22[-3] = v24;
        v22 -= 4;
        v14 -= 4;
      }
      while (v14 != v16);
      float v14 = *v3;
    }
    std::__shared_weak_count *v3 = v22;
    v3[1] = v15;
    int8x8_t v3[2] = (float32x4_t *)&v21[64 * v20];
    if (v14) {
      operator delete(v14);
    }
  }
  else
  {
    *float v14 = v8;
    v14[1] = v11;
    float v15 = v14 + 4;
    v14[2] = v12;
    v14[3] = v4;
  }
  v3[1] = v15;
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:nn180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_1,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_2,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_3,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_4,md::DebugRenderLayer::layout(md::LayoutContext const&)::$_5>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,gm::Box<float,3>,std::__variant_detail::_Trait::Sphere<float,3,std::enable_if<true,void>>,geo::OrientedBox<float,3u,float,float>,geo<float,2u,float,float>> const&>(uint64_t a1, float *a2)
{
  float v2 = *(float ***)(*(void *)a1 + 8);
  float v4 = *a2;
  float v3 = a2[1];
  float v5 = a2[2];
  float v6 = a2[3] - *a2;
  float v7 = a2[4] - v3;
  float v8 = a2[5] - v5;
  int8x16_t v10 = v2[1];
  unint64_t v9 = (unint64_t)v2[2];
  if ((unint64_t)v10 >= v9)
  {
    float32x4_t v12 = *v2;
    uint64_t v13 = ((char *)v10 - (char *)*v2) >> 6;
    unint64_t v14 = v13 + 1;
    if ((unint64_t)(v13 + 1) >> 58) {
      abort();
    }
    uint64_t v15 = v9 - (void)v12;
    if (v15 >> 5 > v14) {
      unint64_t v14 = v15 >> 5;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFC0) {
      unint64_t v16 = 0x3FFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v16 = v14;
    }
    if (v16)
    {
      if (v16 >> 58) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v17 = (char *)operator new(v16 << 6);
    }
    else
    {
      uint64_t v17 = 0;
    }
    unint64_t v18 = &v17[64 * v13];
    *(float *)unint64_t v18 = v6;
    *(void *)(v18 + 12) = 0;
    *(void *)(v18 + 4) = 0;
    *((float *)v18 + 5) = v7;
    *((void *)v18 + 3) = 0;
    *((void *)v18 + 4) = 0;
    *((float *)v18 + 10) = v8;
    *((_DWORD *)v18 + 11) = 0;
    *((float *)v18 + 12) = v4;
    *((float *)v18 + 13) = v3;
    *((_DWORD *)v18 + 15) = 1065353216;
    float32x4_t v11 = (float *)(v18 + 64);
    *((float *)v18 + 14) = v5;
    if (v10 != v12)
    {
      do
      {
        long long v19 = *((_OWORD *)v10 - 4);
        long long v20 = *((_OWORD *)v10 - 3);
        long long v21 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v18 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v18 - 1) = v21;
        *((_OWORD *)v18 - 4) = v19;
        *((_OWORD *)v18 - 3) = v20;
        v18 -= 64;
        v10 -= 16;
      }
      while (v10 != v12);
      int8x16_t v10 = *v2;
    }
    uint64_t *v2 = (float *)v18;
    v2[1] = v11;
    v2[2] = (float *)&v17[64 * v16];
    if (v10) {
      operator delete(v10);
    }
  }
  else
  {
    *int8x16_t v10 = v6;
    *(void *)(v10 + 3) = 0;
    *(void *)(v10 + 1) = 0;
    v10[5] = v7;
    *((void *)v10 + 3) = 0;
    *((void *)v10 + 4) = 0;
    v10[10] = v8;
    v10[11] = 0.0;
    v10[12] = v4;
    v10[13] = v3;
    v10[14] = v5;
    float32x4_t v11 = v10 + 16;
    v10[15] = 1.0;
  }
  v2[1] = v11;
}

uint64_t std::__function::__func<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_11,std::allocator<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_11>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571F10;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_11,std::allocator<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_11>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF571F10;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_11,std::allocator<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_11>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_10,std::allocator<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_10>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF571EC8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_10,std::allocator<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_10>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF571EC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_10,std::allocator<md::DebugRenderLayer::layout(md::LayoutContext const&)::$_10>,void ()(void)>::~__func()
{
}

void md::DebugRenderLayer::~DebugRenderLayer(md::DebugRenderLayer *this)
{
  *(void *)this = &unk_1EF5361C8;
  uint64_t v2 = (char *)this + 56;
  std::__hash_table<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::__unordered_map_hasher<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::__unordered_map_equal<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>>::~__hash_table((uint64_t)this + 96);
  std::__hash_table<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::__unordered_map_hasher<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::__unordered_map_equal<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>>::~__hash_table((uint64_t)v2);
  uint64_t v3 = (md::DebugLayerRenderResources *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v3)
  {
    md::DebugLayerRenderResources::~DebugLayerRenderResources(v3);
    MEMORY[0x1A6239270]();
  }
  *(void *)this = &unk_1EF530C60;
  float v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  md::DebugLayerRenderResources *v3;
  void *v4;

  *(void *)this = &unk_1EF5361C8;
  uint64_t v2 = (char *)this + 56;
  std::__hash_table<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::__unordered_map_hasher<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::__unordered_map_equal<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>>::~__hash_table((uint64_t)this + 96);
  std::__hash_table<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::__unordered_map_hasher<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::__unordered_map_equal<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,std::equal_to<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,std::hash<std::shared_ptr<md::ARWalkingManeuverLabelFeature>>,true>,std::allocator<std::__hash_value_type<std::shared_ptr<md::ARWalkingManeuverLabelFeature>,std::shared_ptr<md::HighPrecisionAltitudeRequest>>>>::~__hash_table((uint64_t)v2);
  uint64_t v3 = (md::DebugLayerRenderResources *)*((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v3)
  {
    md::DebugLayerRenderResources::~DebugLayerRenderResources(v3);
    MEMORY[0x1A6239270]();
  }
  *(void *)this = &unk_1EF530C60;
  float v4 = (void *)*((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    operator delete(v4);
  }
}

void md::DebugLayerRenderResources::~DebugLayerRenderResources(md::DebugLayerRenderResources *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 47);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 45);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 45);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  float v4 = (std::__shared_weak_count *)*((void *)this + 43);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    float v5 = (std::__shared_weak_count *)*((void *)this + 41);
    if (!v5) {
      goto LABEL_13;
    }
  }
  else
  {
    float v5 = (std::__shared_weak_count *)*((void *)this + 41);
    if (!v5) {
      goto LABEL_13;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_13:
  float v6 = (std::__shared_weak_count *)*((void *)this + 39);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    float v7 = (std::__shared_weak_count *)*((void *)this + 37);
    if (!v7) {
      goto LABEL_19;
    }
  }
  else
  {
    float v7 = (std::__shared_weak_count *)*((void *)this + 37);
    if (!v7) {
      goto LABEL_19;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_19:
  float v8 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    unint64_t v9 = (std::__shared_weak_count *)*((void *)this + 33);
    if (!v9) {
      goto LABEL_25;
    }
  }
  else
  {
    unint64_t v9 = (std::__shared_weak_count *)*((void *)this + 33);
    if (!v9) {
      goto LABEL_25;
    }
  }
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_25:
  int8x16_t v10 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    float32x4_t v11 = (std::__shared_weak_count *)*((void *)this + 29);
    if (!v11) {
      goto LABEL_31;
    }
  }
  else
  {
    float32x4_t v11 = (std::__shared_weak_count *)*((void *)this + 29);
    if (!v11) {
      goto LABEL_31;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_31:
  uint64_t v12 = *((void *)this + 27);
  *((void *)this + 27) = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
  }
  uint64_t v13 = *((void *)this + 26);
  *((void *)this + 26) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  uint64_t v14 = *((void *)this + 25);
  *((void *)this + 25) = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  }
  uint64_t v15 = *((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = *((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  }
  uint64_t v17 = *((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t v18 = *((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v19 = *((void *)this + 20);
  *((void *)this + 20) = 0;
  if (v19)
  {
    uint64_t v20 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v19);
    MEMORY[0x1A6239270](v20, 0x10A0C40D234DDC7);
  }
  uint64_t v21 = *((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v21)
  {
    uint64_t v22 = ggl::FragmentedPool<ggl::Textured::ScreenTexturedQuadPipelineSetup>::~FragmentedPool(v21);
    MEMORY[0x1A6239270](v22, 0x10A0C40D234DDC7);
  }
  uint64_t v23 = *((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v23)
  {
    uint64_t v24 = ggl::FragmentedPool<ggl::Textured::Pos2DUVExtendedPipelineSetup>::~FragmentedPool(v23);
    MEMORY[0x1A6239270](v24, 0x10A0C40D234DDC7);
  }
  uint64_t v25 = *((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v25)
  {
    uint64_t v26 = ggl::FragmentedPool<ggl::Point::PipelineSetup>::~FragmentedPool(v25);
    MEMORY[0x1A6239270](v26, 0x10A0C40D234DDC7);
  }
  uint64_t v27 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v27)
  {
    uint64_t v28 = ggl::FragmentedPool<ggl::Debug::InstancedBasePipelineSetup>::~FragmentedPool(v27);
    MEMORY[0x1A6239270](v28, 0x10A0C40D234DDC7);
  }
  uint64_t v29 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v29)
  {
    uint64_t v30 = ggl::FragmentedPool<ggl::Debug::LinePipelineSetup>::~FragmentedPool(v29);
    MEMORY[0x1A6239270](v30, 0x10A0C40D234DDC7);
  }
  uint64_t v31 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v31)
  {
    uint64_t v32 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::~FragmentedPool(v31);
    MEMORY[0x1A6239270](v32, 0x10A0C40D234DDC7);
  }
  uint64_t v33 = *((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v33)
  {
    uint64_t v34 = ggl::FragmentedPool<ggl::Debug::LineMesh>::~FragmentedPool(v33);
    MEMORY[0x1A6239270](v34, 0x10A0C40D234DDC7);
  }
  uint64_t v35 = *((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v35)
  {
    uint64_t v36 = ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::~FragmentedPool(v35);
    MEMORY[0x1A6239270](v36, 0x10A0C40D234DDC7);
  }
  float32x4_t v37 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
    std::__shared_weak_count::__release_weak(v37);
    int8x16_t v38 = (std::__shared_weak_count *)*((void *)this + 9);
    if (!v38) {
      goto LABEL_69;
    }
  }
  else
  {
    int8x16_t v38 = (std::__shared_weak_count *)*((void *)this + 9);
    if (!v38) {
      goto LABEL_69;
    }
  }
  if (!atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
LABEL_69:
  float32x4_t v39 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
    float32x4_t v40 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v40) {
      goto LABEL_75;
    }
  }
  else
  {
    float32x4_t v40 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v40) {
      goto LABEL_75;
    }
  }
  if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
LABEL_75:
  float32x4_t v41 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
    int8x16_t v42 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v42) {
      return;
    }
  }
  else
  {
    int8x16_t v42 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v42) {
      return;
    }
  }
  if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
}

uint64_t ggl::FragmentedPool<ggl::Textured::ScreenTexturedQuadPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  float v4 = *(void **)a1;
  float v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  unint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Textured::Pos2DUVExtendedPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  float v4 = *(void **)a1;
  float v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  unint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Point::PipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  float v4 = *(void **)a1;
  float v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  unint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Debug::InstancedBasePipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  float v4 = *(void **)a1;
  float v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  unint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Debug::LinePipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  float v4 = *(void **)a1;
  float v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  unint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Debug::LineMesh>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  float v4 = *(void **)a1;
  float v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  unint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::Debug::LinePipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Debug::LinePipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Debug::LineMesh *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Debug::LineMesh * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Debug::InstancedBasePipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Debug::InstancedBasePipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Point::PipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Point::PipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Textured::Pos2DUVExtendedPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Textured::Pos2DUVExtendedPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Textured::ScreenTexturedQuadPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Textured::ScreenTexturedQuadPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Textured::ScreenTexturedQuadPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Textured::ScreenTexturedQuadPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Textured::Pos2DUVExtendedPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Textured::Pos2DUVExtendedPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Point::PipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Point::PipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Debug::InstancedBasePipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Debug::InstancedBasePipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Debug::LinePipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Debug::LinePipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Debug::LineMesh>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Debug::LineMesh>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::RenderItem * ()(void)>::operator()()
{
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::RenderItem * ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF577688;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_8>,ggl::RenderItem * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured31ScreenTexturedQuadPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57C798;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured31ScreenTexturedQuadPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7>,ggl::Textured::ScreenTexturedQuadPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::Textured::ScreenTexturedQuad>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Textured::ScreenTexturedQuad>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::ScreenTexturedQuad>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::ScreenTexturedQuad>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587870;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::ScreenTexturedQuad>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587870;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7>,ggl::Textured::ScreenTexturedQuadPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF577640;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_7>,ggl::Textured::ScreenTexturedQuadPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured28Pos2DUVExtendedPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57C708;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_8Textured28Pos2DUVExtendedPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::Textured::Pos2DUVExtendedPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A20F5D4C(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(v2, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ggl::ConstantDataTyped<ggl::Textured::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Textured::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5878A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5878A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::Textured::Pos2DUVExtendedPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF5775F8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_6>,ggl::Textured::Pos2DUVExtendedPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Point13PipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57C1F8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Point13PipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,ggl::Point::PipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::Point::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Point::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Point::View>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Point::View>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587090;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Point::View>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587090;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,ggl::Point::PipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF5775B0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_5>,ggl::Point::PipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug26InstancedBasePipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57C168;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug26InstancedBasePipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::Debug::InstancedBasePipelineSetup * ()(void)>::operator()()
{
}

void sub_1A20F6920(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(v2, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::Debug::InstancedBasePipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF577568;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_4>,ggl::Debug::InstancedBasePipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,ggl::CommonMesh::Pos4Mesh * ()(void)>::operator()()
{
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,ggl::CommonMesh::Pos4Mesh * ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF577520;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_3>,ggl::CommonMesh::Pos4Mesh * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug8LineMeshEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57C1B0;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug8LineMeshEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::Debug::LineMesh * ()(void)>::operator()()
{
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::Debug::LineMesh * ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF5774D8;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_2>,ggl::Debug::LineMesh * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug17LinePipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57C0D8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug17LinePipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::Debug::LinePipelineSetup * ()(void)>::operator()()
{
}

void sub_1A20F7560(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(v4, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  if (!atomic_fetch_add(v3, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void ggl::ConstantDataTyped<ggl::Debug::Viewport>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Debug::Viewport>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::Viewport>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::Viewport>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586F08;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::Viewport>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586F08;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::Debug::LinePipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF577490;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::Debug::LinePipelineSetup * ()(void)>::~__func()
{
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::Debug::BasePipelineSetup * ()(void)>::operator()()
{
}

void sub_1A20F7BF4(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(v2, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::Debug::BasePipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF577448;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::DebugLayerRenderResources::DebugLayerRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::Debug::BasePipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::Textured::ScreenTexturedQuadPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Textured::ScreenTexturedQuadPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589BE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Textured::ScreenTexturedQuadPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589BE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Textured::Pos2DUVExtendedPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Textured::Pos2DUVExtendedPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589B70;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Textured::Pos2DUVExtendedPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589B70;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Point::PipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Point::PipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589160;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Point::PipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589160;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Debug::InstancedBasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Debug::InstancedBasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5890F0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Debug::InstancedBasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5890F0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::Debug::LinePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Debug::LinePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589080;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Debug::LinePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589080;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::Venue3DStroke::HorizontalDefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::Venue3DStroke::HorizontalDefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::Venue3DStroke::HorizontalDefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh::~HorizontalVenue3DStrokeMesh(ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh *this)
{
  ggl::Mesh::~Mesh((ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh *)((char *)this - 16));
}

void ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh::~HorizontalVenue3DStrokeMesh(ggl::Venue3DStroke::HorizontalVenue3DStrokeMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::Venue3DStroke::HorizontalDefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::Venue3DStroke::HorizontalDefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::Venue3DStroke::VerticalDefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::Venue3DStroke::VerticalDefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::Venue3DStroke::VerticalDefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::Venue3DStroke::VerticalVenue3DStrokeMesh::~VerticalVenue3DStrokeMesh(ggl::Venue3DStroke::VerticalVenue3DStrokeMesh *this)
{
  ggl::Mesh::~Mesh((ggl::Venue3DStroke::VerticalVenue3DStrokeMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Venue3DStroke::VerticalVenue3DStrokeMesh *)((char *)this - 16));
}

void ggl::Venue3DStroke::VerticalVenue3DStrokeMesh::~VerticalVenue3DStrokeMesh(ggl::Venue3DStroke::VerticalVenue3DStrokeMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::Venue3DStroke::VerticalDefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::Venue3DStroke::VerticalDefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineState::~HorizontalVenue3DStrokePipelineState(ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  float v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  float v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineSetup::textureIsEnabled(ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineSetup::constantDataIsEnabled(ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineSetup::~HorizontalVenue3DStrokePipelineSetup(ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::Venue3DStroke::VerticalVenue3DStrokePipelineState::~VerticalVenue3DStrokePipelineState(ggl::Venue3DStroke::VerticalVenue3DStrokePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  float v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  float v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::Venue3DStroke::VerticalVenue3DStrokePipelineSetup::textureIsEnabled(ggl::Venue3DStroke::VerticalVenue3DStrokePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::Venue3DStroke::VerticalVenue3DStrokePipelineSetup::constantDataIsEnabled(ggl::Venue3DStroke::VerticalVenue3DStrokePipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::Venue3DStroke::VerticalVenue3DStrokePipelineSetup::~VerticalVenue3DStrokePipelineSetup(ggl::Venue3DStroke::VerticalVenue3DStrokePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::MuninCrossFadeRenderLayer::layout(uint64_t this, const md::LayoutContext *a2)
{
  uint64_t v5 = this;
  uint64_t v6 = (void *)*((void *)a2 + 1);
  unint64_t v7 = v6[1];
  if ((v7 & (v7 - 1)) != 0)
  {
    unint64_t v9 = 0xC83717EF586624DCLL;
    if (v7 <= 0xC83717EF586624DCLL) {
      unint64_t v9 = 0xC83717EF586624DCLL % v7;
    }
    uint64_t v8 = *(void **)(*v6 + 8 * v9);
    do
    {
      do
        uint64_t v8 = (void *)*v8;
      while (v8[1] != 0xC83717EF586624DCLL);
    }
    while (v8[2] != 0xC83717EF586624DCLL);
  }
  else
  {
    uint64_t v8 = *(void **)(*v6 + 8 * ((v7 - 1) & 0xC83717EF586624DCLL));
    do
    {
      do
        uint64_t v8 = (void *)*v8;
      while (v8[1] != 0xC83717EF586624DCLL);
    }
    while (v8[2] != 0xC83717EF586624DCLL);
  }
  int8x16_t v10 = *(int **)(*(void *)(v8[5] + 32) + 32);
  if (v10)
  {
    if (*(int **)(this + 136) != v10)
    {
      uint64_t v11 = *((void *)v10 + 4);
      if (!v11)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        int8x8_t v68 = v67;
        (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
        std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v72);
        ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)v73);
        ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)v78);
        std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v74);
        std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v75);
        (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
        std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)v76);
        std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)v77);
        std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)v84);

        _Unwind_Resume(v68);
      }
      (*(void (**)(uint64_t))(*(void *)v11 + 48))(v11);
      uint64_t v12 = *(uint64_t **)(v5 + 128);
      *(void *)(v5 + 128) = 0;
      if (v12)
      {
        uint64_t v13 = (std::__shared_weak_count *)v12[3];
        if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
          std::__shared_weak_count::__release_weak(v13);
        }
        uint64_t v14 = v12[1];
        v12[1] = 0;
        if (v14) {
          (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
        }
        uint64_t v15 = *v12;
        *uint64_t v12 = 0;
        if (v15) {
          (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
        }
        MEMORY[0x1A6239270](v12, 0x20C40DC1BFBCFLL);
      }
    }
    long long v70 = 0u;
    long long v71 = 0u;
    uint64_t v16 = *(void **)(*(void *)(*(void *)(v5 + 40) + 24) + 8);
    uint64_t v17 = v16[3];
    uint64_t v18 = v16[4];
    if (v18 == v17) {
      goto LABEL_68;
    }
    uint64_t v19 = 0;
    while (1)
    {
      uint64_t v20 = *(void *)(v17 + 8 * v19);
      if (*(unsigned char *)v20 == 4)
      {
        unint64_t v21 = *(void *)(v20 + 8);
        uint64_t v22 = v16[18];
        if (v21 < (v16[19] - v22) >> 3) {
          break;
        }
      }
      if (++v19 >= (unint64_t)((v18 - v17) >> 3)) {
        goto LABEL_61;
      }
    }
    uint64_t v23 = *(void *)(v22 + 8 * v21);
    if (v23)
    {
      long long v24 = *(_OWORD *)(v23 + 72);
      long long v70 = *(_OWORD *)(v23 + 56);
      long long v71 = v24;
      uint64_t v25 = (_DWORD *)(v5 + 48);
      if (v24 != *(_OWORD *)(v5 + 64)) {
        goto LABEL_37;
      }
      if ((void)v24)
      {
        if (v70 != *v25) {
          goto LABEL_37;
        }
        unint64_t v26 = 0;
        do
        {
          if ((void)v24 - 1 == v26) {
            goto LABEL_36;
          }
          int v27 = *((_DWORD *)&v70 + v26 + 1);
          int v28 = *(_DWORD *)(v5 + 52 + 4 * v26++);
        }
        while (v27 == v28);
        if (v26 < (unint64_t)v24)
        {
LABEL_37:
          long long v29 = *(_OWORD *)(v23 + 72);
          *(_OWORD *)uint64_t v25 = *(_OWORD *)(v23 + 56);
          *(_OWORD *)(v5 + 64) = v29;
          uint64_t v30 = (void *)*((void *)a2 + 1);
          unint64_t v31 = v30[1];
          if ((v31 & (v31 - 1)) != 0)
          {
            unint64_t v33 = 0xA60DDA5A69582425;
            if (v31 <= 0xA60DDA5A69582425) {
              unint64_t v33 = 0xA60DDA5A69582425 % v31;
            }
            uint64_t v32 = *(void **)(*v30 + 8 * v33);
            do
            {
              do
                uint64_t v32 = (void *)*v32;
              while (v32[1] != 0xA60DDA5A69582425);
            }
            while (v32[2] != 0xA60DDA5A69582425);
          }
          else
          {
            uint64_t v32 = *(void **)(*v30 + 8 * ((v31 - 1) & 0xA60DDA5A69582425));
            do
            {
              do
                uint64_t v32 = (void *)*v32;
              while (v32[1] != 0xA60DDA5A69582425);
            }
            while (v32[2] != 0xA60DDA5A69582425);
          }
          id v34 = **(id **)(v32[5] + 32);
          uint64_t v35 = *(void *)([v34 shaderLibrary] + 80);
          uint64_t v36 = *(std::__shared_weak_count **)(v35 + 2872);
          v85[0] = *(void *)(v35 + 2864);
          v85[1] = v36;
          if (v36) {
            atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v78[0] = 1;
          *(_OWORD *)&v78[4] = xmmword_1A28FE480;
          int v79 = 1;
          uint64_t v80 = 0;
          uint64_t v81 = 0;
          int v82 = 0;
          char v83 = 15;
          uint64_t v37 = [v34 gglDevice];
          int8x16_t v38 = operator new(0x198uLL);
          v38[1] = 0;
          v38[2] = 0;
          *int8x16_t v38 = &unk_1EF589B70;
          long long v39 = *(_OWORD *)(v5 + 64);
          v73[0] = *(_OWORD *)v25;
          v73[1] = v39;
          v84[0] = ggl::Textured::Pos2DUVExtendedPipelineState::Pos2DUVExtendedPipelineState((uint64_t)(v38 + 3), v85, (uint64_t)v78, v73, *(unsigned char *)(v37 + 20));
          v84[1] = v38;
          if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
            std::__shared_weak_count::__release_weak(v36);
          }
          float32x4_t v40 = operator new(0xE8uLL);
          v40[1] = 0;
          v40[2] = 0;
          *float32x4_t v40 = &unk_1EF586DB8;
          uint64_t v41 = ggl::BufferData::BufferData((uint64_t)(v40 + 3), qword_1E9552208, 2, 1, 6, 1);
          v40[28] = ggl::Tile::View::reflection(void)::reflection;
          v40[3] = &unk_1EF55E258;
          v77[0] = v41;
          v77[1] = v40;
          unint64_t v42 = v40[4];
          uint64_t v43 = v40[12];
          *(_DWORD *)uint64_t v43 = 1065353216;
          *(void *)(v43 + 4) = 0;
          *(void *)(v43 + 12) = 0;
          *(_DWORD *)(v43 + 20) = 1065353216;
          *(void *)(v43 + 24) = 0;
          *(void *)(v43 + 32) = 0;
          *(_DWORD *)(v43 + 40) = 1065353216;
          *(void *)(v43 + 52) = 0;
          *(void *)(v43 + 44) = 0;
          __asm { FMOV            V0.2S, #1.0 }
          *(void *)(v43 + 60) = _D0;
          if (v40[11] > v42) {
            unint64_t v42 = v40[11];
          }
          v40[10] = 0;
          v40[11] = v42;
          md::GeometryLogic::createUnitTransformConstantData((md::GeometryLogic *)v78);
          long long v49 = *(_OWORD *)v78;
          *(_OWORD *)uint64_t v78 = 0uLL;
          uint64_t v50 = *(std::__shared_weak_count **)(v5 + 104);
          *(_OWORD *)(v5 + 96) = v49;
          if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
            std::__shared_weak_count::__release_weak(v50);
          }
          unint64_t v51 = *(std::__shared_weak_count **)&v78[8];
          if (*(void *)&v78[8])
          {
            if (!atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v78[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
              std::__shared_weak_count::__release_weak(v51);
            }
          }
          float32x4_t v52 = operator new(0xE8uLL);
          v52[1] = 0;
          v52[2] = 0;
          *float32x4_t v52 = &unk_1EF587838;
          uint64_t v53 = ggl::BufferData::BufferData((uint64_t)(v52 + 3), qword_1E956A060, 2, 1, 6, 1);
          v52[28] = ggl::Textured::TileScalar::reflection(void)::reflection;
          v52[3] = &unk_1EF55E9B8;
          v76[0] = v53;
          v76[1] = v52;
          operator new();
        }
      }
LABEL_36:
      if (!*(void *)(v5 + 128)) {
        goto LABEL_37;
      }
    }
LABEL_61:
    uint64_t v54 = v18 - v17;
    if (v18 == v17) {
      goto LABEL_68;
    }
    uint64_t v55 = 0;
    unint64_t v56 = v54 >> 3;
    while (1)
    {
      uint64_t v57 = *(void *)(v17 + 8 * v55);
      if (*(unsigned char *)v57 == 4)
      {
        unint64_t v58 = *(void *)(v57 + 8);
        uint64_t v59 = v16[15];
        if (v58 < (v16[16] - v59) >> 3) {
          break;
        }
      }
      if (++v55 >= v56) {
        goto LABEL_68;
      }
    }
    uint64_t v60 = *(void *)(v59 + 8 * v58);
    if (!v60) {
LABEL_68:
    }
      uint64_t v61 = 0;
    else {
      uint64_t v61 = **(void **)(v60 + 24);
    }
    float v62 = *(void **)(v5 + 80);
    unint64_t v63 = v62[1];
    uint64_t v64 = v62[9];
    int v65 = *v10;
    *(_DWORD *)(v64 + 8) = 1065353216;
    __asm { FMOV            V1.4S, #1.0 }
    *(void *)uint64_t v64 = _Q1;
    *(_DWORD *)(v64 + 12) = v65;
    if (v62[8] > v63) {
      unint64_t v63 = v62[8];
    }
    v62[7] = 0;
    v62[8] = v63;
    this = ggl::CommandBuffer::pushRenderItem(v61, **(void **)(v5 + 128));
  }
  *(void *)(v5 + 136) = v10;
  return this;
}

void sub_1A20F9FF0()
{
}

void sub_1A20F9FF8()
{
}

void sub_1A20FA000()
{
}

void sub_1A20FA008()
{
}

void sub_1A20FA010()
{
}

void sub_1A20FA018()
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v0 - 104);
  JUMPOUT(0x1A20F9FE0);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos2UV>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos2UV>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584460;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos2UV>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584460;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::Textured::TileScalar>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Textured::TileScalar>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587838;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Textured::TileScalar>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587838;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::MuninCrossFadeRenderLayer::~MuninCrossFadeRenderLayer(md::MuninCrossFadeRenderLayer *this)
{
  md::MuninCrossFadeRenderLayer::~MuninCrossFadeRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  std::__shared_weak_count *v8;
  std::__shared_weak_count *v9;
  void *v10;

  *(void *)this = &unk_1EF5467F8;
  uint64_t v2 = (uint64_t *)*((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2)
  {
    uint64_t v3 = (std::__shared_weak_count *)v2[3];
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    float v4 = v2[1];
    v2[1] = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    uint64_t v5 = *v2;
    std::__shared_weak_count *v2 = 0;
    if (v5) {
      (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
    }
    MEMORY[0x1A6239270](v2, 0x20C40DC1BFBCFLL);
  }
  uint64_t v6 = *((void *)this + 15);
  *((void *)this + 15) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  unint64_t v7 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    unint64_t v9 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v9) {
      goto LABEL_20;
    }
  }
  else
  {
    unint64_t v9 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v9) {
      goto LABEL_20;
    }
  }
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_20:
  *(void *)this = &unk_1EF530C60;
  int8x16_t v10 = (void *)*((void *)this + 1);
  if (v10)
  {
    *((void *)this + 2) = v10;
    operator delete(v10);
  }
}

CGDataProvider *karo::media::PngLoader::loadFromChunk(int *a1, void *data, size_t size, uint64_t a4)
{
  if (karo::media::PngLoader::loadFromChunk(karo::media::ImageFormat const&,unsigned char const*,unsigned long,karo::media::Image &)::onceToken != -1) {
    dispatch_once(&karo::media::PngLoader::loadFromChunk(karo::media::ImageFormat const&,unsigned char const*,unsigned long,karo::media::Image &)::onceToken, &__block_literal_global_10468);
  }
  uint64_t result = CGDataProviderCreateWithData(0, data, size, 0);
  if (result)
  {
    unint64_t v9 = result;
    CGImageSourceRef v10 = CGImageSourceCreateWithDataProvider(result, (CFDictionaryRef)karo::media::PngLoader::loadFromChunk(karo::media::ImageFormat const&,unsigned char const*,unsigned long,karo::media::Image &)::options);
    CGDataProviderRelease(v9);
    if (!v10) {
      return 0;
    }
    if (!CGImageSourceGetCount(v10))
    {
      CFRelease(v10);
      return 0;
    }
    ImageAtIndex = CGImageSourceCreateImageAtIndex(v10, 0, (CFDictionaryRef)karo::media::PngLoader::loadFromChunk(karo::media::ImageFormat const&,unsigned char const*,unsigned long,karo::media::Image &)::options);
    CFRelease(v10);
    if (!ImageAtIndex) {
      return 0;
    }
    uint64_t v35 = a1;
    CGImageGetImageProvider();
    ColorSpace = CGImageGetColorSpace(ImageAtIndex);
    int Width = CGImageGetWidth(ImageAtIndex);
    size_t Height = CGImageGetHeight(ImageAtIndex);
    size_t BytesPerRow = CGImageGetBytesPerRow(ImageAtIndex);
    size_t BitsPerComponent = CGImageGetBitsPerComponent(ImageAtIndex);
    size_t NumberOfComponents = CGColorSpaceGetNumberOfComponents(ColorSpace);
    CGImageGetBitmapInfo(ImageAtIndex);
    CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(ImageAtIndex);
    size_t v36 = Height;
    uint64_t v18 = CGImageProviderCopyImageBlockSetWithOptions();
    if ((BitsPerComponent >> 3) * NumberOfComponents != CGImageBlockSetGetPixelSize()) {
      ++NumberOfComponents;
    }
    if (!v18 || CGImageBlockSetGetCount() != 1 || !CGImageBlockSetGetImageBlock())
    {
LABEL_43:
      CGImageBlockSetRelease();
      CGImageRelease(ImageAtIndex);
      return (CGDataProvider *)1;
    }
    uint64_t v38 = 0;
    uint64_t v39 = 0;
    uint64_t v19 = (char *)CGImageBlockGetData();
    if (CGColorSpaceGetModel(ColorSpace) == kCGColorSpaceModelIndexed)
    {
      BaseColorSpace = CGColorSpaceGetBaseColorSpace(ColorSpace);
      CGColorSpaceGetNumberOfComponents(BaseColorSpace);
      CGColorSpaceGetColorTableCount(ColorSpace);
      operator new[]();
    }
    uint64_t v21 = CGImageBlockGetBytesPerRow();
    std::make_shared[abi:nn180100]<ggl::Data,unsigned long,void>((ggl::Data **)&v37, BytesPerRow * v36);
    std::shared_ptr<md::LabelFeature>::operator=[abi:nn180100]((uint64_t)&v38, &v37);
    std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v37);
    uint64_t v22 = *(void *)(v38 + 8);
    if (v21 == BytesPerRow)
    {
      memcpy(*(void **)(v38 + 8), v19, BytesPerRow * v36);
    }
    else if (v36)
    {
      size_t v23 = 0;
      unsigned int v24 = 1;
      do
      {
        memcpy((void *)(v22 + v23 * BytesPerRow), &v19[v23 * v21], BytesPerRow);
        size_t v23 = v24++;
      }
      while (v36 > v23);
    }
    if (BitsPerComponent == 16)
    {
      unint64_t v26 = v35;
      int v25 = v36;
      unsigned int v27 = AlphaInfo;
      if (NumberOfComponents == 1)
      {
        int v28 = 7;
LABEL_32:
        karo::media::Image::setFormat(a4, v28);
      }
    }
    else
    {
      unint64_t v26 = v35;
      int v25 = v36;
      unsigned int v27 = AlphaInfo;
      if (BitsPerComponent != 8) {
        goto LABEL_33;
      }
      switch(NumberOfComponents)
      {
        case 1uLL:
          int v28 = 6;
          goto LABEL_32;
        case 4uLL:
          int v28 = 1;
          goto LABEL_32;
        case 3uLL:
          int v28 = 0;
          goto LABEL_32;
      }
    }
LABEL_33:
    uint64_t v29 = *(void *)(a4 + 8);
    if (v29)
    {
      *(_DWORD *)uint64_t v29 = Width;
      *(_DWORD *)(v29 + 4) = v25;
    }
    *(unsigned char *)(a4 + 104) = (v27 > 6) | (0x1Eu >> v27) & 1;
    *(unsigned char *)(a4 + 20) = *(_DWORD *)(a4 + 16) == 1;
    if (v29)
    {
      uint64_t v30 = *(void **)(v29 + 16);
      uint64_t v32 = v38;
      uint64_t v31 = v39;
      if (v39) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v33 = (std::__shared_weak_count *)v30[1];
      *uint64_t v30 = v32;
      v30[1] = v31;
      if (v33)
      {
        if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
          std::__shared_weak_count::__release_weak(v33);
        }
      }
    }
    if (!karo::media::Image::convertToFormat(a4, *v26))
    {
      CGImageBlockSetRelease();
      CGImageRelease(ImageAtIndex);
      std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v38);
      return 0;
    }
    std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v38);
    goto LABEL_43;
  }
  return result;
}

ggl::Data *std::make_shared[abi:nn180100]<ggl::Data,unsigned long,void>(ggl::Data **a1, uint64_t a2)
{
  float v4 = operator new(0x30uLL);
  v4[1] = 0;
  v4[2] = 0;
  *float v4 = &unk_1EF588E18;
  uint64_t result = ggl::Data::Data((ggl::Data *)(v4 + 3), a2);
  *a1 = result;
  a1[1] = (ggl::Data *)v4;
  return result;
}

CFDictionaryRef ___ZN4karo5media9PngLoader13loadFromChunkERKNS0_11ImageFormatEPKhmRNS0_5ImageE_block_invoke()
{
  keys[1] = *(void **)MEMORY[0x1E4F143B8];
  keys[0] = *(void **)MEMORY[0x1E4F1DD48];
  values = (void *)*MEMORY[0x1E4F1CFD0];
  CFDictionaryRef result = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  karo::media::PngLoader::loadFromChunk(karo::media::ImageFormat const&,unsigned char const*,unsigned long,karo::media::Image &)::options = (uint64_t)result;
  return result;
}

void md::SequentialGEOResourceDataRequester::createDebugNode(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  a2[4] = 0u;
  a2[5] = 0u;
  a2[2] = 0u;
  a2[3] = 0u;
  *a2 = 0u;
  a2[1] = 0u;
  uint64_t v4 = *(void *)(a1 + 8);
  if (v4)
  {
    (*(void (**)(char *__return_ptr))(*(void *)v4 + 32))(v40);
    if (v40[0] || (uint64_t v12 = *(unsigned __int16 **)(a1 + 48), v13 = *(unsigned __int16 **)(a1 + 56), v12 == v13))
    {
LABEL_3:
      unsigned int v5 = *(unsigned __int16 *)(a1 + 24);
    }
    else
    {
      while (1)
      {
        unsigned int v5 = *v12;
        (*(void (**)(char *__return_ptr))(**(void **)(a1 + 8) + 32))(v40);
        if (v40[0]) {
          break;
        }
        if (++v12 == v13) {
          goto LABEL_3;
        }
      }
    }
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      (*(void (**)(char *__return_ptr))(*(void *)v6 + 24))(v40);
      if (v40[0])
      {
        unint64_t v7 = *(void *)&v40[4];
        v40[23] = 14;
        strcpy(v40, "Download Range");
        uint64_t v8 = (char *)operator new(0x80uLL);
        v39[1] = (uint64_t)(v8 + 128);
        v39[2] = (uint64_t)(v8 + 128);
        *((void *)v8 + 1) = v7;
        *((void *)v8 + 5) = 0;
        *((void *)v8 + 6) = 0;
        *((void *)v8 + 4) = 0;
        *((void *)v8 + 9) = HIDWORD(v7);
        *((void *)v8 + 12) = 0;
        *((_DWORD *)v8 + 14) = 1;
        *((void *)v8 + 13) = 0;
        *((void *)v8 + 14) = 0;
        *((_DWORD *)v8 + 30) = 1;
        v39[0] = (uint64_t)v8;
        gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v40, v39);
        if (v8[119] < 0)
        {
          operator delete(*((void **)v8 + 12));
          if ((v8[55] & 0x80000000) == 0) {
            goto LABEL_8;
          }
        }
        else if ((v8[55] & 0x80000000) == 0)
        {
LABEL_8:
          unint64_t v9 = v8;
          goto LABEL_15;
        }
        operator delete(*((void **)v8 + 4));
        goto LABEL_8;
      }
    }
  }
  else
  {
    unsigned int v5 = *(unsigned __int16 *)(a1 + 24);
  }
  v40[23] = 14;
  strcpy(v40, "Download Range");
  memset(&v37, 0, sizeof(v37));
  int v38 = 4;
  std::string::__assign_external(&v37, "None");
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v40, (uint64_t)v36);
  if ((SHIBYTE(v37.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (!*(unsigned char *)(a1 + 28)) {
      goto LABEL_16;
    }
    goto LABEL_12;
  }
  unint64_t v9 = (void *)v37.__r_.__value_.__r.__words[0];
LABEL_15:
  operator delete(v9);
  if (!*(unsigned char *)(a1 + 28))
  {
LABEL_16:
    v40[23] = 17;
    strcpy(v40, "Visible Range Min");
    memset(&__p, 0, sizeof(__p));
    int v29 = 4;
    std::string::__assign_external(&__p, "None");
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v40, (uint64_t)v27);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(__p.__r_.__value_.__l.__data_);
      if (*(unsigned char *)(a1 + 36)) {
        goto LABEL_18;
      }
    }
    else if (*(unsigned char *)(a1 + 36))
    {
      goto LABEL_18;
    }
    goto LABEL_24;
  }
LABEL_12:
  v40[23] = 17;
  strcpy(v40, "Visible Range Min");
  uint64_t v10 = *(unsigned int *)(a1 + 32);
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  int v35 = 1;
  uint64_t v32 = 0;
  uint64_t v31 = v10;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v40, (uint64_t)v30);
  if (*(unsigned char *)(a1 + 36))
  {
LABEL_18:
    v40[23] = 17;
    strcpy(v40, "Visible Range Max");
    uint64_t v11 = *(unsigned int *)(a1 + 40);
    uint64_t v24 = 0;
    uint64_t v25 = 0;
    int v26 = 1;
    uint64_t v23 = 0;
    uint64_t v22 = v11;
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v40, (uint64_t)v21);
    goto LABEL_26;
  }
LABEL_24:
  v40[23] = 17;
  strcpy(v40, "Visible Range Max");
  memset(&v19, 0, sizeof(v19));
  int v20 = 4;
  std::string::__assign_external(&v19, "None");
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v40, (uint64_t)v18);
  if (SHIBYTE(v19.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v19.__r_.__value_.__l.__data_);
  }
LABEL_26:
  v40[23] = 17;
  strcpy(v40, "gdc::ResourceType");
  if (v5 > 0x35) {
    uint64_t v14 = "<Invalid>";
  }
  else {
    uint64_t v14 = off_1E5A96820[v5];
  }
  memset(&v16, 0, sizeof(v16));
  int v17 = 4;
  std::string::__assign_external(&v16, v14);
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v40, (uint64_t)v15);
  if (SHIBYTE(v16.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v16.__r_.__value_.__l.__data_);
  }
}

void sub_1A20FB120(_Unwind_Exception *a1)
{
  gdc::DebugTreeNode::~DebugTreeNode(v1);
  _Unwind_Resume(a1);
}

void md::SequentialGEOResourceDataRequester::requestDataKeys(md::SequentialGEOResourceDataRequester *this, const gdc::SelectionContext *a2, char a3)
{
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    unint64_t v7 = (gdc::LayerDataCollector *)*((void *)a2 + 1);
    (*(void (**)(void **__return_ptr))(*(void *)v4 + 32))(v37);
    if (LOBYTE(v37[0])
      || (std::string v16 = (unsigned __int16 *)*((void *)this + 6), v17 = (unsigned __int16 *)*((void *)this + 7), v16 == v17))
    {
LABEL_3:
      uint64_t v8 = *((unsigned __int16 *)this + 12);
    }
    else
    {
      while (1)
      {
        uint64_t v8 = *v16;
        (*(void (**)(void **__return_ptr))(**((void **)this + 1) + 32))(v37);
        if (LOBYTE(v37[0])) {
          break;
        }
        if (++v16 == v17) {
          goto LABEL_3;
        }
      }
    }
    uint64_t v9 = *((void *)this + 1);
    if (v9)
    {
      (*(void (**)(uint64_t *__return_ptr))(*(void *)v9 + 32))(&v50);
      if ((_BYTE)v50)
      {
        (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 24))(&v48);
        if ((_BYTE)v48)
        {
          int v10 = 0;
          uint64_t v11 = (char *)&v48 + 4;
          if (*((unsigned char *)this + 28)) {
            uint64_t v11 = (char *)this + 32;
          }
          uint64_t v12 = (unsigned int *)&v49;
          if (*((unsigned char *)this + 36)) {
            uint64_t v12 = (unsigned int *)((char *)this + 40);
          }
          uint64_t v13 = (unsigned int *)*((void *)a2 + 8);
          unint64_t v14 = *v13;
          if (v14)
          {
            unint64_t v15 = HIDWORD(v50);
            if (HIDWORD(v50))
            {
              if (HIDWORD(v50) >= v14)
              {
                int v10 = 0;
              }
              else
              {
                int v10 = 0;
                do
                {
                  ++v10;
                  v15 *= 2;
                }
                while (v15 < v14);
              }
              while (v15 > v14)
              {
                --v10;
                v14 *= 2;
              }
            }
          }
          unsigned int v18 = *(_DWORD *)v11;
          unsigned int v31 = *v12;
          uint64_t v45 = 0;
          unint64_t v46 = 0;
          uint64_t v47 = 0;
          std::string v19 = (uint64_t *)*((void *)v13 + 3);
          if (v19)
          {
            int v20 = -v10 & ~(-v10 >> 31);
            char v30 = v20;
            do
            {
              uint64_t v21 = *((unsigned __int8 *)v19 + 17);
              int v22 = (*((_DWORD *)v19 + 5) % (1 << v21) + (1 << v21)) % (1 << v21);
              int v23 = *((_DWORD *)v19 + 6) % (1 << v21) + (1 << v21);
              v42[0] = *((unsigned char *)v19 + 16);
              v42[1] = v21;
              int v43 = v22;
              int v44 = v23 % (1 << v21);
              unsigned int v24 = v21 - v20;
              if (v21 < v20) {
                unsigned int v24 = 0;
              }
              if (!v21) {
                unsigned int v24 = 0;
              }
              if (v18 <= v24 && v31 >= v24)
              {
                unint64_t v46 = v45;
                unsigned int v25 = **((_DWORD **)a2 + 8);
                (*(void (**)(void **__return_ptr))(**((void **)this + 1) + 32))(v37);
                unint64_t v32 = v32 & 0xFFFFFFFFFF000000 | *((unsigned __int16 *)this + 22) | ((unint64_t)*((unsigned __int8 *)this + 46) << 16);
                md::TileAdjustmentHelpers::adjustTileForSizeAndResourceType(v25, HIDWORD(v37[0]), v8, *((void *)this + 1), v42, v32, (unint64_t *)&v45);
                int v26 = v45;
                unsigned int v27 = v46;
                while (v26 != v27)
                {
                  (*(void (**)(void *__return_ptr, md::SequentialGEOResourceDataRequester *, char *))(*(void *)this + 80))(v41, this, v26);
                  if (a3) {
                    int v28 = 1;
                  }
                  else {
                    int v28 = *((_DWORD *)this + 4);
                  }
                  gdc::Tiled::mapDataKeyFromTile((unsigned __int8 *)v37, 0, (unsigned __int8 *)v41, *((_WORD *)this + 11), v28);
                  gdc::LayerDataCollector::addDataKey(v7, (const gdc::LayerDataRequestKey *)v37, (const QuadTile *)(v19 + 2));
                  if (*((unsigned char *)this + 20))
                  {
                    if (a3) {
                      int v29 = 1;
                    }
                    else {
                      int v29 = *((_DWORD *)this + 4);
                    }
                    gdc::Tiled::mapDataKeyFromTile(v33, 1u, (unsigned __int8 *)v41, *((_WORD *)this + 11), v29);
                    gdc::LayerDataCollector::addDataKey(v7, (const gdc::LayerDataRequestKey *)v33, (const QuadTile *)(v19 + 2));
                    if (v36) {
                      char v36 = 0;
                    }
                    if (v34 != v35) {
                      free(v34);
                    }
                  }
                  if (v40) {
                    char v40 = 0;
                  }
                  if (v38 != v39) {
                    free(v38);
                  }
                  v26 += 24;
                }
                LOBYTE(v20) = v30;
              }
              std::string v19 = (uint64_t *)*v19;
            }
            while (v19);
            if (v45)
            {
              unint64_t v46 = v45;
              operator delete(v45);
            }
          }
        }
      }
    }
  }
}

void sub_1A20FB548(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void **)(v1 - 136);
  if (v3)
  {
    *(void *)(v1 - 128) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void md::SequentialGEOResourceDataRequester::~SequentialGEOResourceDataRequester(md::SequentialGEOResourceDataRequester *this)
{
  *(void *)this = &unk_1EF54EC70;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_1EF54C560;
  if (*((unsigned char *)this + 36)) {
    *((unsigned char *)this + 36) = 0;
  }
  if (*((unsigned char *)this + 28)) {
    *((unsigned char *)this + 28) = 0;
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;

  *(void *)this = &unk_1EF54EC70;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    *((void *)this + 7) = v2;
    operator delete(v2);
  }
  *(void *)this = &unk_1EF54C560;
  if (*((unsigned char *)this + 36)) {
    *((unsigned char *)this + 36) = 0;
  }
  if (*((unsigned char *)this + 28)) {
    *((unsigned char *)this + 28) = 0;
  }
}

void generateRoadSignPath(CGContext *a1, const RoadSignMetrics *a2, const RoadSignPartMetrics *a3)
{
  CGContextSaveGState(a1);
  CGContextBeginPath(a1);
  switch(a3->_type)
  {
    case 1u:
      outsideImagePathExtensiounint64_t n = a3->_outsideImagePathExtension;
      double MinX = CGRectGetMinX(a3->_signBaseRect);
      CGRectGetMinY(a3->_signBaseRect);
      CGFloat v104 = MinX - outsideImagePathExtension;
      CGRectGetMinX(a3->_signBaseRect);
      CGFloat MinY = CGRectGetMinY(a3->_signBaseRect);
      double MaxX = CGRectGetMaxX(a3->_signBaseRect);
      CGRectGetMaxY(a3->_signBaseRect);
      CGFloat v107 = MaxX + outsideImagePathExtension;
      CGRectGetMaxX(a3->_signBaseRect);
      CGFloat MaxY = CGRectGetMaxY(a3->_signBaseRect);
      CGContextMoveToPoint(a1, v104, MinY);
      CGContextAddLineToPoint(a1, v104, MaxY);
      CGContextAddLineToPoint(a1, v107, MaxY);
      unsigned int v18 = a1;
      CGFloat v19 = v107;
      CGFloat v20 = MinY;
      goto LABEL_61;
    case 2u:
    case 3u:
      double v6 = a3->_outsideImagePathExtension;
      double v7 = CGRectGetMinX(a3->_signBaseRect);
      CGRectGetMinY(a3->_signBaseRect);
      double v8 = v7 - v6;
      CGRectGetMinX(a3->_signBaseRect);
      CGFloat v9 = CGRectGetMinY(a3->_signBaseRect);
      double v10 = CGRectGetMaxX(a3->_signBaseRect);
      CGRectGetMaxY(a3->_signBaseRect);
      double v11 = v10 + v6;
      CGRectGetMaxX(a3->_signBaseRect);
      CGFloat v12 = CGRectGetMaxY(a3->_signBaseRect);
      CGFloat x = a3->_arrowTip.x;
      CGFloat y = a3->_arrowTip.y;
      CGFloat v15 = a3->_arrowWingMax.x;
      CGFloat v109 = a3->_arrowWingMin.x;
      CGFloat v111 = a3->_arrowWingMin.y;
      CGFloat v16 = a3->_arrowWingMax.y;
      int type = a3->_type;
      CGContextMoveToPoint(a1, v8, v9);
      CGContextAddLineToPoint(a1, v8, v12);
      if (type == 2)
      {
        CGContextAddLineToPoint(a1, v11, v12);
        CGContextAddLineToPoint(a1, v11, v9);
        CGContextAddArcToPoint(a1, v15, v16, x, y, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
        CGContextAddArcToPoint(a1, x, y, v109, v111, round(a2->_scale * a2->_arrowTipCornerRadius * a2->_contentScale));
        CGContextAddArcToPoint(a1, v109, v111, v8, v9, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
        unsigned int v18 = a1;
        CGFloat v19 = v8;
      }
      else
      {
        CGContextAddArcToPoint(a1, v109, v111, x, y, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
        CGContextAddArcToPoint(a1, x, y, v15, v16, round(a2->_scale * a2->_arrowTipCornerRadius * a2->_contentScale));
        CGContextAddArcToPoint(a1, v15, v16, v11, v12, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
        CGContextAddLineToPoint(a1, v11, v12);
        unsigned int v18 = a1;
        CGFloat v19 = v11;
      }
      CGFloat v20 = v9;
      goto LABEL_61;
    case 4u:
    case 5u:
      double v21 = a3->_outsideImagePathExtension;
      double v22 = CGRectGetMinX(a3->_signBaseRect);
      CGFloat v23 = CGRectGetMinY(a3->_signBaseRect);
      double v24 = CGRectGetMaxX(a3->_signBaseRect);
      CGFloat v25 = CGRectGetMaxY(a3->_signBaseRect);
      double v26 = v22 - v21;
      if (a3->_type == 4)
      {
        double v27 = v24 + v21;
      }
      else
      {
        double v22 = v24;
        double v27 = v26;
      }
      CGContextMoveToPoint(a1, v27, v23);
      CGContextAddLineToPoint(a1, v27, v25);
      CGContextAddArcToPoint(a1, v22, v25, v22, v23, round(a2->_scale * a2->_cornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v22, v23, v27, v23, round(a2->_scale * a2->_cornerRadius * a2->_contentScale));
      break;
    case 6u:
    case 7u:
      double v28 = a3->_outsideImagePathExtension;
      double v29 = CGRectGetMinX(a3->_signBaseRect);
      CGFloat v30 = CGRectGetMinY(a3->_signBaseRect);
      double v31 = CGRectGetMaxX(a3->_signBaseRect);
      CGFloat v32 = CGRectGetMaxY(a3->_signBaseRect);
      p_arrowWingMaCGFloat x = &a3->_arrowWingMax;
      p_CGFloat y = &a3->_arrowWingMax.y;
      if (a3->_type == 6) {
        p_arrowWingMiunint64_t n = &a3->_arrowWingMax;
      }
      else {
        p_arrowWingMiunint64_t n = &a3->_arrowWingMin;
      }
      if (a3->_type == 6) {
        char v36 = &a3->_arrowWingMax.y;
      }
      else {
        char v36 = &a3->_arrowWingMin.y;
      }
      if (a3->_type == 6)
      {
        p_arrowWingMaCGFloat x = &a3->_arrowWingMin;
        p_CGFloat y = &a3->_arrowWingMin.y;
        CGFloat v37 = v29;
      }
      else
      {
        CGFloat v37 = v31;
      }
      if (a3->_type == 6) {
        double v38 = v31 + v28;
      }
      else {
        double v38 = v29 - v28;
      }
      CGFloat v39 = *p_y;
      CGFloat v40 = p_arrowWingMax->x;
      CGFloat v42 = a3->_arrowTip.x;
      CGFloat v41 = a3->_arrowTip.y;
      CGFloat v112 = p_arrowWingMin->x;
      CGFloat y1a = *v36;
      CGContextMoveToPoint(a1, v38, v30);
      CGContextAddLineToPoint(a1, v38, v32);
      CGContextAddArcToPoint(a1, v37, v32, v37, v30, round(a2->_scale * a2->_cornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v37, v30, v40, v39, round(a2->_scale * a2->_cornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v40, v39, v42, v41, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v42, v41, v112, y1a, round(a2->_scale * a2->_arrowTipCornerRadius * a2->_contentScale));
      double v43 = round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale);
      int v44 = a1;
      CGFloat v45 = v112;
      CGFloat v46 = y1a;
      goto LABEL_50;
    case 8u:
    case 9u:
      double v77 = a3->_outsideImagePathExtension;
      double v78 = CGRectGetMinX(a3->_signBaseRect);
      CGFloat v79 = CGRectGetMinY(a3->_signBaseRect);
      double v80 = CGRectGetMaxX(a3->_signBaseRect);
      CGFloat v81 = CGRectGetMaxY(a3->_signBaseRect);
      CGFloat v82 = a3->_arrowWingMax.x;
      CGFloat v83 = a3->_arrowWingMax.y;
      CGFloat v110 = a3->_arrowTip.y;
      CGFloat v114 = a3->_arrowTip.x;
      CGFloat v84 = a3->_arrowWingMin.y;
      double v85 = v80 + v77;
      double v86 = v78 - v77;
      CGFloat v87 = a3->_arrowWingMin.x;
      if (a3->_type == 8)
      {
        double v80 = v78;
        CGFloat v88 = v85;
      }
      else
      {
        CGFloat v88 = v86;
      }
      CGContextMoveToPoint(a1, v88, v79);
      CGContextAddLineToPoint(a1, v88, v81);
      CGContextAddArcToPoint(a1, v80, v81, v82, v83, round(a2->_scale * a2->_cornerRadius * a2->_contentScale));
      CGContextAddLineToPoint(a1, v82, v83);
      double v89 = round(a2->_scale * a2->_arrowTipCornerRadius * a2->_contentScale);
      if (v89 <= 0.0) {
        CGContextAddLineToPoint(a1, v114, v110);
      }
      else {
        CGContextAddArcToPoint(a1, v114, v110, v87, v84, v89);
      }
      CGContextAddLineToPoint(a1, v87, v84);
      CGContextAddArcToPoint(a1, v80, v79, v88, v79, round(a2->_scale * a2->_cornerRadius * a2->_contentScale));
      break;
    case 0xAu:
    case 0xBu:
      double v90 = a3->_outsideImagePathExtension;
      double v91 = CGRectGetMinX(a3->_signBaseRect);
      CGFloat v30 = CGRectGetMinY(a3->_signBaseRect);
      double v92 = CGRectGetMaxX(a3->_signBaseRect);
      CGFloat v93 = CGRectGetMaxY(a3->_signBaseRect);
      CGFloat v94 = a3->_arrowTip.x;
      CGFloat v95 = a3->_arrowTip.y;
      double v96 = v91 - v90;
      unint64_t v97 = &a3->_arrowWingMin;
      float v98 = &a3->_arrowWingMin.y;
      if (a3->_type == 10)
      {
        unint64_t v97 = &a3->_arrowWingMax;
        float v98 = &a3->_arrowWingMax.y;
        double v99 = v92 + v90;
      }
      else
      {
        double v91 = v92;
        double v99 = v96;
      }
      CGFloat v100 = *v98;
      CGFloat v101 = v97->x;
      CGContextMoveToPoint(a1, v99, v30);
      CGContextAddLineToPoint(a1, v99, v93);
      CGContextAddArcToPoint(a1, v91, v93, v94, v95, round(a2->_scale * a2->_cornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v94, v95, v101, v100, round(a2->_scale * a2->_arrowTipCornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v101, v100, v99, v30, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
      unsigned int v18 = a1;
      CGFloat v19 = v99;
      goto LABEL_60;
    case 0xCu:
    case 0xDu:
      double v47 = a3->_outsideImagePathExtension;
      double v48 = CGRectGetMinX(a3->_signBaseRect);
      CGFloat v49 = CGRectGetMinY(a3->_signBaseRect);
      double v50 = CGRectGetMaxX(a3->_signBaseRect);
      CGFloat v51 = CGRectGetMaxY(a3->_signBaseRect);
      float32x4_t v52 = &a3->_arrowWingMax;
      uint64_t v53 = &a3->_arrowWingMax.y;
      if (a3->_type == 12) {
        uint64_t v54 = &a3->_arrowWingMax;
      }
      else {
        uint64_t v54 = &a3->_arrowWingMin;
      }
      if (a3->_type == 12) {
        uint64_t v55 = &a3->_arrowWingMax.y;
      }
      else {
        uint64_t v55 = &a3->_arrowWingMin.y;
      }
      if (a3->_type == 12)
      {
        float32x4_t v52 = &a3->_arrowWingMin;
        uint64_t v53 = &a3->_arrowWingMin.y;
        CGFloat v56 = v48;
      }
      else
      {
        CGFloat v56 = v50;
      }
      if (a3->_type == 12) {
        double v57 = v50 + v47;
      }
      else {
        double v57 = v48 - v47;
      }
      CGFloat v58 = *v53;
      CGFloat v59 = v52->x;
      CGFloat v61 = a3->_arrowTip.x;
      CGFloat v60 = a3->_arrowTip.y;
      CGFloat v113 = v54->x;
      CGFloat y1b = *v55;
      CGContextMoveToPoint(a1, v57, v49);
      CGContextAddLineToPoint(a1, v57, v51);
      CGContextAddArcToPoint(a1, v56, v51, v59, v58, round(a2->_scale * a2->_cornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v59, v58, v61, v60, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v61, v60, v113, y1b, round(a2->_scale * a2->_arrowTipCornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v113, y1b, v57, v49, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
      unsigned int v18 = a1;
      CGFloat v19 = v57;
      CGFloat v20 = v49;
      goto LABEL_61;
    case 0xEu:
    case 0xFu:
      double v62 = a3->_outsideImagePathExtension;
      double v63 = CGRectGetMinX(a3->_signBaseRect);
      CGFloat v30 = CGRectGetMinY(a3->_signBaseRect);
      double v64 = CGRectGetMaxX(a3->_signBaseRect);
      CGFloat v65 = CGRectGetMaxY(a3->_signBaseRect);
      unint64_t v66 = &a3->_arrowWingMin;
      size_t v67 = &a3->_arrowWingMin.y;
      if (a3->_type == 14) {
        double v38 = v64 + v62;
      }
      else {
        double v38 = v63 - v62;
      }
      if (a3->_type == 14) {
        double v68 = v63;
      }
      else {
        double v68 = v64;
      }
      CGFloat y1 = v68;
      if (a3->_type == 14) {
        unint64_t v69 = &a3->_arrowWingMin;
      }
      else {
        unint64_t v69 = &a3->_arrowWingMax;
      }
      if (a3->_type == 14) {
        long long v70 = &a3->_arrowWingMin.y;
      }
      else {
        long long v70 = &a3->_arrowWingMax.y;
      }
      if (a3->_type == 14)
      {
        unint64_t v66 = &a3->_arrowWingMax;
        size_t v67 = &a3->_arrowWingMax.y;
      }
      CGFloat v71 = *v67;
      CGFloat v72 = v66->x;
      CGFloat v74 = a3->_arrowTip.x;
      CGFloat v73 = a3->_arrowTip.y;
      CGFloat v75 = *v70;
      CGFloat v76 = v69->x;
      CGContextMoveToPoint(a1, v38, v65);
      CGContextAddArcToPoint(a1, v72, v71, v74, v73, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v74, v73, v76, v75, round(a2->_scale * a2->_arrowTipCornerRadius * a2->_contentScale));
      CGContextAddArcToPoint(a1, v76, v75, y1, v30, round(a2->_scale * a2->_arrowJoinCornerRadius * a2->_contentScale));
      double v43 = round(a2->_scale * a2->_cornerRadius * a2->_contentScale);
      int v44 = a1;
      CGFloat v45 = y1;
      CGFloat v46 = v30;
LABEL_50:
      CGContextAddArcToPoint(v44, v45, v46, v38, v30, v43);
      unsigned int v18 = a1;
      CGFloat v19 = v38;
LABEL_60:
      CGFloat v20 = v30;
LABEL_61:
      CGContextAddLineToPoint(v18, v19, v20);
      break;
    default:
      break;
  }
  CGContextClosePath(a1);
  CGContextRestoreGState(a1);
}

void md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    unsigned int v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      unsigned int v5 = __p;
    }
    CGFloat v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::TransitLogic::runBeforeLayout(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v195 = *MEMORY[0x1E4F143B8];
  v181[0] = &unk_1EF56F6D8;
  v181[1] = a2;
  v179[0] = &unk_1EF56F720;
  v179[1] = a2;
  id v180 = v179;
  uint64_t v184 = v183;
  unint64_t v182 = v181;
  v183[0] = &unk_1EF56F720;
  v183[1] = a2;
  _ZNSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__0NS_9allocatorISK_EEFvvEEclEv((uint64_t)v181);
  if (v180 == v179)
  {
    (*(void (**)(void *))(v179[0] + 32))(v179);
  }
  else if (v180)
  {
    (*(void (**)(void))(*v180 + 40))();
  }
  if (v182 == v181)
  {
    (*(void (**)(void *))(v181[0] + 32))(v181);
  }
  else if (v182)
  {
    (*(void (**)(void))(*v182 + 40))();
  }
  double v8 = (void *)*a3;
  char v7 = (uint64_t *)a3[1];
  if (a1 + 232 == a4)
  {
    *(unsigned char *)(a4 + 224) = *(unsigned char *)(a1 + 456);
  }
  else
  {
    *(_DWORD *)(a4 + 48) = *(_DWORD *)(a1 + 280);
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)a4, *(void **)(a1 + 256));
    *(_DWORD *)(a4 + 104) = *(_DWORD *)(a1 + 336);
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(a4 + 56), *(void **)(a1 + 312));
    *(_DWORD *)(a4 + 160) = *(_DWORD *)(a1 + 392);
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(a4 + 112), *(void **)(a1 + 368));
    *(_DWORD *)(a4 + 216) = *(_DWORD *)(a1 + 448);
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(a4 + 168), *(void **)(a1 + 424));
    *(unsigned char *)(a4 + 224) = *(unsigned char *)(a1 + 456);
    *(_DWORD *)(a4 + 264) = *(_DWORD *)(a1 + 496);
    std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,void *> *>>((void *)(a4 + 232), *(uint64_t **)(a1 + 480));
    *(_DWORD *)(a4 + 304) = *(_DWORD *)(a1 + 536);
    std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,void *> *>>((void *)(a4 + 272), *(uint64_t **)(a1 + 520));
  }
  *(unsigned char *)(a4 + 312) = *(unsigned char *)(a1 + 544);
  *(void *)(a1 + 552) = v8[366];
  *(void *)(a1 + 560) = v8[367];
  *(void *)(a1 + 568) = v8[368];
  *(void *)(a1 + 576) = v8[369];
  uint64_t v9 = *v7;
  {
    qword_1EB3176C0 = 0;
    qword_1EB3176B8 = 0;
    md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
    __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
  }
  double v10 = *(_WORD **)(v9 + 48);
  double v11 = *(_WORD **)(v9 + 56);
  if (v10 == v11)
  {
    CGFloat v12 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
  }
  else
  {
    CGFloat v12 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    uint64_t v13 = *(_WORD **)(v9 + 48);
    while (*v13 != 16)
    {
      v13 += 16;
      if (v13 == v11) {
        goto LABEL_25;
      }
    }
    if (v13 == v11)
    {
      CGFloat v12 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    }
    else
    {
      while (*v10 != 16)
      {
        v10 += 16;
        if (v10 == v11)
        {
          double v10 = *(_WORD **)(v9 + 56);
          break;
        }
      }
      CGFloat v12 = (uint64_t *)(v10 + 4);
    }
  }
LABEL_25:
  uint64_t v14 = *v7;
  {
    qword_1EB3176C0 = 0;
    qword_1EB3176B8 = 0;
    md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
    __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
  }
  CGFloat v15 = *(_WORD **)(v14 + 48);
  CGFloat v16 = *(_WORD **)(v14 + 56);
  int v17 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
  if (v15 != v16)
  {
    unsigned int v18 = v15;
    while (*v18 != 17)
    {
      v18 += 16;
      if (v18 == v16) {
        goto LABEL_37;
      }
    }
    if (v18 == v16)
    {
      int v17 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    }
    else
    {
      while (*v15 != 17)
      {
        v15 += 16;
        if (v15 == v16)
        {
          CGFloat v15 = v16;
          break;
        }
      }
      int v17 = (uint64_t *)(v15 + 4);
    }
  }
LABEL_37:
  unint64_t v164 = 0;
  unint64_t v165 = 0;
  v162[1] = 0;
  int v163 = &v164;
  uint64_t v161 = v162;
  v162[0] = 0;
  CGFloat v19 = v12 + 1;
  uint64_t v20 = *(void *)(a1 + 120);
  v185[0] = *v12;
  *(void *)&long long v175 = v12 + 1;
  *(void *)&long long v171 = v20;
  *(void *)&long long v166 = a1 + 128;
  uint64_t v186 = &v163;
  size_t v187 = &v164;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long> &,std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long> &,std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long> &,std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long> &,std::insert_iterator<std::set<gdc::LayerDataWithWorld>> &>(&v188, (uint64_t)v185, &v175, (uint64_t)&v171, &v166, &v186);
  uint64_t v21 = *(void *)(a1 + 144);
  v185[0] = *v17;
  *(void *)&long long v175 = v17 + 1;
  *(void *)&long long v171 = v21;
  *(void *)&long long v166 = a1 + 152;
  uint64_t v186 = &v161;
  size_t v187 = v162;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long> &,std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long> &,std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long> &,std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long> &,std::insert_iterator<std::set<gdc::LayerDataWithWorld>> &>(&v188, (uint64_t)v185, &v175, (uint64_t)&v171, &v166, &v186);
  if ((uint64_t *)(a1 + 120) != v12) {
    std::__tree<gdc::LayerDataWithWorld>::__assign_multi<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>((uint64_t **)(a1 + 120), (void *)*v12, v12 + 1);
  }
  if ((uint64_t *)(a1 + 144) != v17) {
    std::__tree<gdc::LayerDataWithWorld>::__assign_multi<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>((uint64_t **)(a1 + 144), (void *)*v17, v17 + 1);
  }
  double v22 = *(void **)(a1 + 168);
  *(void *)(a1 + 176) = v22;
  unint64_t v23 = v12[2];
  if (v23 > (uint64_t)(*(void *)(a1 + 184) - (void)v22) >> 3)
  {
    if (v23 >> 61) {
      abort();
    }
    double v24 = (char *)operator new(8 * v23);
    *(void *)(a1 + 168) = v24;
    *(void *)(a1 + 176) = v24;
    *(void *)(a1 + 184) = &v24[8 * v23];
    if (v22) {
      operator delete(v22);
    }
  }
  CGFloat v25 = (void *)*v12;
  if ((uint64_t *)*v12 != v19)
  {
    double v26 = *(char **)(a1 + 176);
    while (1)
    {
      uint64_t v27 = v25[4];
      unint64_t v28 = *(void *)(a1 + 184);
      if ((unint64_t)v26 >= v28) {
        break;
      }
      *(void *)double v26 = v27;
      v26 += 8;
LABEL_69:
      *(void *)(a1 + 176) = v26;
      CGFloat v40 = (uint64_t *)v25[1];
      if (v40)
      {
        do
        {
          CGFloat v41 = v40;
          CGFloat v40 = (uint64_t *)*v40;
        }
        while (v40);
      }
      else
      {
        do
        {
          CGFloat v41 = (uint64_t *)v25[2];
          BOOL v42 = *v41 == (void)v25;
          CGFloat v25 = v41;
        }
        while (!v42);
      }
      CGFloat v25 = v41;
      if (v41 == v19) {
        goto LABEL_85;
      }
    }
    double v29 = *(char **)(a1 + 168);
    uint64_t v30 = (v26 - v29) >> 3;
    unint64_t v31 = v30 + 1;
    if ((unint64_t)(v30 + 1) >> 61) {
      abort();
    }
    uint64_t v32 = v28 - (void)v29;
    if (v32 >> 2 > v31) {
      unint64_t v31 = v32 >> 2;
    }
    if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v33 = v31;
    }
    if (v33)
    {
      if (v33 >> 61) {
LABEL_276:
      }
        std::__throw_bad_array_new_length[abi:nn180100]();
      uint64_t v34 = operator new(8 * v33);
    }
    else
    {
      uint64_t v34 = 0;
    }
    int v35 = &v34[8 * v30];
    *int v35 = v27;
    char v36 = (char *)(v35 + 1);
    if (v26 == v29)
    {
      double v29 = v26;
    }
    else
    {
      unint64_t v37 = v26 - 8 - v29;
      if (v37 < 0x168)
      {
        double v38 = v26;
        goto LABEL_63;
      }
      if (&v34[v26 - v29 - 8 - (v37 & 0xFFFFFFFFFFFFFFF8)] > &v34[v26 - v29 - 8])
      {
        double v38 = v26;
        goto LABEL_63;
      }
      if (&v26[-(v37 & 0xFFFFFFFFFFFFFFF8) - 8] > v26 - 8)
      {
        double v38 = v26;
        goto LABEL_63;
      }
      if ((unint64_t)(v29 - v34) < 0x20)
      {
        double v38 = v26;
        goto LABEL_63;
      }
      uint64_t v43 = (v37 >> 3) + 1;
      double v38 = &v26[-8 * (v43 & 0x3FFFFFFFFFFFFFFCLL)];
      int v44 = &v34[8 * v30 - 16];
      CGFloat v45 = v26 - 16;
      uint64_t v46 = v43 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v47 = *(_OWORD *)v45;
        *(v44 - 1) = *((_OWORD *)v45 - 1);
        *int v44 = v47;
        v44 -= 2;
        v45 -= 32;
        v46 -= 4;
      }
      while (v46);
      v35 -= v43 & 0x3FFFFFFFFFFFFFFCLL;
      if (v43 != (v43 & 0x3FFFFFFFFFFFFFFCLL))
      {
        do
        {
LABEL_63:
          uint64_t v39 = *((void *)v38 - 1);
          v38 -= 8;
          *--int v35 = v39;
        }
        while (v38 != v29);
        double v29 = *(char **)(a1 + 168);
      }
    }
    *(void *)(a1 + 168) = v35;
    *(void *)(a1 + 176) = v36;
    *(void *)(a1 + 184) = &v34[8 * v33];
    if (v29) {
      operator delete(v29);
    }
    double v26 = v36;
    goto LABEL_69;
  }
LABEL_85:
  unint64_t v48 = v165;
  if (v165)
  {
    if (v165 >> 61) {
      abort();
    }
    std::string __p = (char *)operator new(8 * v165);
    CGFloat v49 = &__p[8 * v48];
  }
  else
  {
    std::string __p = 0;
    CGFloat v49 = 0;
  }
  double v50 = v163;
  if (v163 != &v164)
  {
    CGFloat v51 = __p;
    while (1)
    {
      uint64_t v52 = v50[4];
      if (v51 < v49)
      {
        *(void *)CGFloat v51 = v52;
        v51 += 8;
        uint64_t v53 = (void *)v50[1];
        if (v53) {
          goto LABEL_112;
        }
        goto LABEL_114;
      }
      uint64_t v54 = (v51 - __p) >> 3;
      unint64_t v55 = v54 + 1;
      if ((unint64_t)(v54 + 1) >> 61) {
        abort();
      }
      if ((v49 - __p) >> 2 > v55) {
        unint64_t v55 = (v49 - __p) >> 2;
      }
      if ((unint64_t)(v49 - __p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v56 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v56 = v55;
      }
      if (v56)
      {
        if (v56 >> 61) {
          goto LABEL_276;
        }
        double v57 = operator new(8 * v56);
      }
      else
      {
        double v57 = 0;
      }
      CGFloat v58 = &v57[8 * v54];
      *(void *)CGFloat v58 = v52;
      CGFloat v59 = v58 + 8;
      CGFloat v60 = __p;
      if (v51 != __p)
      {
        unint64_t v61 = v51 - 8 - __p;
        if (v61 < 0x168
          || &v57[v51 - __p - 8 - (v61 & 0xFFFFFFFFFFFFFFF8)] > &v57[v51 - __p - 8]
          || &v51[-(v61 & 0xFFFFFFFFFFFFFFF8) - 8] > v51 - 8
          || (unint64_t)(__p - v57) < 0x20)
        {
          double v62 = v51;
          CGFloat v60 = __p;
          do
          {
LABEL_108:
            uint64_t v63 = *((void *)v62 - 1);
            v62 -= 8;
            *((void *)v58 - 1) = v63;
            v58 -= 8;
          }
          while (v62 != v60);
          goto LABEL_109;
        }
        uint64_t v65 = (v61 >> 3) + 1;
        double v62 = &v51[-8 * (v65 & 0x3FFFFFFFFFFFFFFCLL)];
        unint64_t v66 = &v57[8 * v54 - 16];
        size_t v67 = v51 - 16;
        uint64_t v68 = v65 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v69 = *(_OWORD *)v67;
          *(v66 - 1) = *((_OWORD *)v67 - 1);
          *unint64_t v66 = v69;
          v66 -= 2;
          v67 -= 32;
          v68 -= 4;
        }
        while (v68);
        v58 -= 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
        CGFloat v60 = __p;
        if (v65 != (v65 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_108;
        }
      }
LABEL_109:
      CGFloat v49 = &v57[8 * v56];
      if (v60) {
        operator delete(v60);
      }
      std::string __p = v58;
      CGFloat v51 = v59;
      uint64_t v53 = (void *)v50[1];
      if (v53)
      {
        do
        {
LABEL_112:
          double v64 = (void **)v53;
          uint64_t v53 = (void *)*v53;
        }
        while (v53);
        goto LABEL_91;
      }
      do
      {
LABEL_114:
        double v64 = (void **)v50[2];
        BOOL v42 = *v64 == v50;
        double v50 = v64;
      }
      while (!v42);
LABEL_91:
      double v50 = v64;
      if (v64 == &v164) {
        goto LABEL_125;
      }
    }
  }
  CGFloat v51 = __p;
LABEL_125:
  long long v70 = v161;
  if (v161 != v162)
  {
    do
    {
      uint64_t v71 = v70[4];
      if (v51 < v49)
      {
        *(void *)CGFloat v51 = v71;
        v51 += 8;
        CGFloat v72 = (void *)v70[1];
        if (v72) {
          goto LABEL_148;
        }
        goto LABEL_150;
      }
      uint64_t v73 = (v51 - __p) >> 3;
      unint64_t v74 = v73 + 1;
      if ((unint64_t)(v73 + 1) >> 61) {
        abort();
      }
      if ((v49 - __p) >> 2 > v74) {
        unint64_t v74 = (v49 - __p) >> 2;
      }
      if ((unint64_t)(v49 - __p) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v75 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v75 = v74;
      }
      if (v75)
      {
        if (v75 >> 61) {
          goto LABEL_276;
        }
        CGFloat v76 = operator new(8 * v75);
      }
      else
      {
        CGFloat v76 = 0;
      }
      double v77 = &v76[8 * v73];
      *(void *)double v77 = v71;
      double v78 = v77 + 8;
      CGFloat v79 = __p;
      if (v51 != __p)
      {
        unint64_t v80 = v51 - 8 - __p;
        if (v80 < 0x168
          || &v76[v51 - __p - 8 - (v80 & 0xFFFFFFFFFFFFFFF8)] > &v76[v51 - __p - 8]
          || &v51[-(v80 & 0xFFFFFFFFFFFFFFF8) - 8] > v51 - 8
          || (unint64_t)(__p - v76) < 0x20)
        {
          CGFloat v81 = v51;
          CGFloat v79 = __p;
          do
          {
LABEL_144:
            uint64_t v82 = *((void *)v81 - 1);
            v81 -= 8;
            *((void *)v77 - 1) = v82;
            v77 -= 8;
          }
          while (v81 != v79);
          goto LABEL_145;
        }
        uint64_t v84 = (v80 >> 3) + 1;
        CGFloat v81 = &v51[-8 * (v84 & 0x3FFFFFFFFFFFFFFCLL)];
        double v85 = &v76[8 * v73 - 16];
        double v86 = v51 - 16;
        uint64_t v87 = v84 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v88 = *(_OWORD *)v86;
          *(v85 - 1) = *((_OWORD *)v86 - 1);
          _OWORD *v85 = v88;
          v85 -= 2;
          v86 -= 32;
          v87 -= 4;
        }
        while (v87);
        v77 -= 8 * (v84 & 0x3FFFFFFFFFFFFFFCLL);
        CGFloat v79 = __p;
        if (v84 != (v84 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_144;
        }
      }
LABEL_145:
      CGFloat v49 = &v76[8 * v75];
      if (v79) {
        operator delete(v79);
      }
      std::string __p = v77;
      CGFloat v51 = v78;
      CGFloat v72 = (void *)v70[1];
      if (v72)
      {
        do
        {
LABEL_148:
          CGFloat v83 = (void **)v72;
          CGFloat v72 = (void *)*v72;
        }
        while (v72);
        goto LABEL_127;
      }
      do
      {
LABEL_150:
        CGFloat v83 = (void **)v70[2];
        BOOL v42 = *v83 == v70;
        long long v70 = v83;
      }
      while (!v42);
LABEL_127:
      long long v70 = v83;
    }
    while (v83 != v162);
  }
  *(unsigned char *)(a1 + 456) = 0;
  if (__p != v51)
  {
    double v89 = (unint64_t *)__p;
    do
    {
      uint64_t v90 = *v89;
      if (*(void *)(a1 + 272))
      {
        unint64_t v91 = *(void *)(a1 + 440);
        md::TransitTileData::appendNodesAttachedToLines(*v89, *(void **)(a1 + 256), a1 + 400);
        md::TransitTileData::setSelectedLines(v90, (void *)(a1 + 232));
        md::TransitTileData::setSelectedNodes(*(uint64_t **)(v90 + 968), *(uint64_t **)(v90 + 976), *(void *)(a1 + 400), *(void *)(a1 + 408));
        if (*(void *)(a1 + 440) > v91) {
          *(unsigned char *)(a1 + 456) = 1;
        }
      }
      else
      {
        unint64_t v188 = 0;
        uint64_t v189 = 0;
        {
          operator new();
        }
        uint64_t v190 = mdm::Allocator::instance(void)::alloc;
        uint64_t v191 = 0;
        {
          operator new();
        }
        uint64_t v92 = mdm::Allocator::instance(void)::alloc;
        uint64_t v192 = mdm::Allocator::instance(void)::alloc;
        uint64_t v193 = 0;
        int v194 = 1065353216;
        md::TransitTileData::setSelectedLines(v90, &v188);
        CGFloat v93 = v191;
        if (v191)
        {
          do
          {
            CGFloat v94 = (void *)*v93;
            (*(void (**)(uint64_t))(*(void *)v92 + 40))(v92);
            CGFloat v93 = v94;
          }
          while (v94);
        }
        if (v188) {
          (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v190 + 40))(v190, v188, 8 * v189);
        }
        {
          operator new();
        }
        {
          operator new();
        }
        md::TransitTileData::setSelectedNodes(*(uint64_t **)(v90 + 968), *(uint64_t **)(v90 + 976), 0, 0);
      }
      ++v89;
    }
    while (v89 != (unint64_t *)v51);
  }
  if (*(unsigned char *)(a1 + 216))
  {
    uint64_t v96 = *(void *)(a1 + 464);
    unint64_t v95 = *(void *)(a1 + 472);
    uint64_t v98 = *(void *)(a1 + 504);
    unint64_t v97 = *(void *)(a1 + 512);
    double v99 = (void **)(a1 + 480);
    uint64_t v100 = *(void *)(a1 + 520);
    uint64_t v102 = *(void *)(a1 + 480);
    uint64_t v101 = *(void *)(a1 + 488);
    uint64_t v103 = *(void *)(a1 + 528);
    int v104 = *(_DWORD *)(a1 + 496);
    int v105 = *(_DWORD *)(a1 + 536);
    *(void *)(a1 + 464) = v98;
    *(void *)(a1 + 472) = v97;
    *(void *)(a1 + 504) = v96;
    *(void *)(a1 + 512) = v95;
    *(void *)(a1 + 520) = v102;
    *(void *)(a1 + 480) = v100;
    *(void *)(a1 + 488) = v103;
    *(void *)(a1 + 528) = v101;
    *(_DWORD *)(a1 + 496) = v105;
    *(_DWORD *)(a1 + 536) = v104;
    if (v103)
    {
      unint64_t v106 = *(void *)(v100 + 8);
      if ((v97 & (v97 - 1)) != 0)
      {
        if (v106 >= v97) {
          v106 %= v97;
        }
      }
      else
      {
        v106 &= v97 - 1;
      }
      *(void *)(v98 + 8 * v106) = v99;
    }
    if (v101)
    {
      unint64_t v107 = *(void *)(*(void *)(a1 + 520) + 8);
      if ((v95 & (v95 - 1)) != 0)
      {
        if (v107 >= v95) {
          v107 %= v95;
        }
      }
      else
      {
        v107 &= v95 - 1;
      }
      *(void *)(*(void *)(a1 + 504) + 8 * v107) = a1 + 520;
    }
    if (v103)
    {
      float v108 = *v99;
      if (*v99)
      {
        do
        {
          CGFloat v109 = (void *)*v108;
          operator delete(v108);
          float v108 = v109;
        }
        while (v109);
        unint64_t v97 = *(void *)(a1 + 472);
      }
      *double v99 = 0;
      if (v97)
      {
        for (uint64_t i = 0; i != v97; ++i)
          *(void *)(*(void *)(a1 + 464) + 8 * i) = 0;
      }
      *(void *)(a1 + 488) = 0;
    }
    unint64_t v157 = (float *)(a1 + 464);
    *(unsigned char *)(a1 + 544) = 1;
    id v111 = *(id *)(a1 + 200);
    CGFloat v112 = [v111 routeInfo];
    unint64_t v159 = [v112 route];

    uint64_t v155 = [v159 stations];
    long long v177 = 0u;
    long long v178 = 0u;
    long long v175 = 0u;
    long long v176 = 0u;
    obuint64_t j = [v159 segments];
    uint64_t v150 = [obj countByEnumeratingWithState:&v175 objects:&v188 count:16];
    if (v150)
    {
      uint64_t v149 = *(void *)v176;
      do
      {
        for (uint64_t j = 0; j != v150; ++j)
        {
          if (*(void *)v176 != v149) {
            objc_enumerationMutation(obj);
          }
          CGFloat v113 = *(void **)(*((void *)&v175 + 1) + 8 * j);
          if ([v113 type] == 6)
          {
            int v114 = [v113 stepCount];
            long long v173 = 0u;
            long long v174 = 0u;
            long long v171 = 0u;
            long long v172 = 0u;
            id v158 = [v113 steps];
            uint64_t v115 = [v158 countByEnumeratingWithState:&v171 objects:&v186 count:16];
            if (!v115) {
              goto LABEL_207;
            }
            uint64_t v160 = *(void *)v172;
            char v116 = 1;
            int v153 = v114 - 2;
            int v154 = -1;
            while (1)
            {
              uint64_t v117 = 0;
              int v156 = v153 - v154;
              v154 += v115;
              do
              {
                if (*(void *)v172 != v160) {
                  objc_enumerationMutation(v158);
                }
                uint64_t v118 = *(void **)(*((void *)&v171 + 1) + 8 * v117);
                uint64_t v119 = [v118 transitStep];
                uint64_t v120 = [v118 originStop];
                unint64_t v121 = [v159 getStationForStop:v120];
                if ([v121 hasMuid])
                {
                  if ([v119 vehicleInfosCount])
                  {
                    long long v122 = [v119 vehicleInfos];
                    uint64_t v123 = [v122 objectAtIndexedSubscript:0];

                    BOOL v124 = [v123 pickupDropoffType] == 100;
                    if (!v120) {
                      goto LABEL_239;
                    }
                  }
                  else
                  {
                    BOOL v124 = 0;
                    if (!v120) {
                      goto LABEL_239;
                    }
                  }
                  if (v124) {
                    goto LABEL_239;
                  }
                  unint64_t v170 = [v121 muid];
                  double v125 = std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v157, v170, &v170);
                  uint64_t v126 = v125;
                  if (v116 & 1 | (v156 == v117))
                  {
                    char v127 = 1;
                    goto LABEL_227;
                  }
                  if (*((unsigned char *)v125 + 28) != 1)
                  {
                    char v127 = 2;
LABEL_227:
                    *((unsigned char *)v125 + 28) = v127;
                  }
                  double v128 = [v118 destinationStop];
                  double v129 = v128;
                  if (v128)
                  {
                    id v130 = v128;
                    id v131 = v120;
                    if ([v130 hasStopIndex]
                      && [v131 hasStopIndex])
                    {
                      int v132 = [v130 stopIndex];
                      BOOL v133 = v132 == [v131 stopIndex];

                      if (v133 && [v119 hasSignificanceForEndNode])
                      {
                        if (*((unsigned char *)v126 + 29))
                        {
                          unsigned int v134 = [v119 significanceForEndNode];
                          unsigned int v135 = *((_DWORD *)v126 + 6);
                          if (v135 <= v134) {
                            unsigned int v135 = v134;
                          }
                          *((_DWORD *)v126 + 6) = v135;
                        }
                        else
                        {
                          *((_DWORD *)v126 + 6) = [v119 significanceForEndNode];
                          *((unsigned char *)v126 + 29) = 1;
                        }
                      }
                    }
                    else
                    {
                    }
                  }

                  char v116 = 0;
                }
LABEL_239:

                ++v117;
              }
              while (v115 != v117);
              uint64_t v136 = [v158 countByEnumeratingWithState:&v171 objects:&v186 count:16];
              uint64_t v115 = v136;
              if (!v136) {
                goto LABEL_207;
              }
            }
          }
          if ([v113 type] == 5)
          {
            long long v168 = 0u;
            long long v169 = 0u;
            long long v166 = 0u;
            long long v167 = 0u;
            id v158 = [v113 steps];
            uint64_t v137 = [v158 countByEnumeratingWithState:&v166 objects:v185 count:16];
            if (v137)
            {
              uint64_t v138 = *(void *)v167;
              do
              {
                for (uint64_t k = 0; k != v137; ++k)
                {
                  if (*(void *)v167 != v138) {
                    objc_enumerationMutation(v158);
                  }
                  uint64_t v140 = *(void **)(*((void *)&v166 + 1) + 8 * k);
                  float32x4_t v141 = [v140 transitStep];
                  if ([v141 maneuverType] == 7
                    || [v141 maneuverType] == 8)
                  {
                    long long v142 = [v140 accessPoint];
                    uint64_t v143 = v142;
                    if (v142 && [v142 hasStationIndex])
                    {
                      unint64_t v144 = objc_msgSend(v155, "objectAtIndexedSubscript:", objc_msgSend(v143, "stationIndex"));
                      if ([v144 hasMuid])
                      {
                        unint64_t v170 = [v144 muid];
                        uint64_t v145 = std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(v157, v170, &v170);
                        *((unsigned char *)v145 + 28) = 1;
                        if ([v141 hasSignificanceForEndNode])
                        {
                          if (*((unsigned char *)v145 + 29))
                          {
                            unsigned int v146 = [v141 significanceForEndNode];
                            unsigned int v147 = *((_DWORD *)v145 + 6);
                            if (v147 <= v146) {
                              unsigned int v147 = v146;
                            }
                            *((_DWORD *)v145 + 6) = v147;
                          }
                          else
                          {
                            *((_DWORD *)v145 + 6) = [v141 significanceForEndNode];
                            *((unsigned char *)v145 + 29) = 1;
                          }
                        }
                      }
                    }
                  }
                }
                uint64_t v137 = [v158 countByEnumeratingWithState:&v166 objects:v185 count:16];
              }
              while (v137);
            }
LABEL_207:
          }
        }
        uint64_t v150 = [obj countByEnumeratingWithState:&v175 objects:&v188 count:16];
      }
      while (v150);
    }
  }
  if (__p) {
    operator delete(__p);
  }
  std::__tree<gdc::LayerDataWithWorld>::destroy(v162[0]);
  std::__tree<gdc::LayerDataWithWorld>::destroy(v164);
  if (v184)
  {
    (*(void (**)(void *))(*v184 + 48))(v184);
    if (v184 == v183)
    {
      (*(void (**)(void *))(v183[0] + 32))(v183);
    }
    else if (v184)
    {
      (*(void (**)(void))(*v184 + 40))();
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
}

void sub_1A20FD700(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61)
{
  if (__p) {
    operator delete(__p);
  }
  std::__tree<gdc::LayerDataWithWorld>::destroy(a22);
  std::__tree<gdc::LayerDataWithWorld>::destroy(a25);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)&a61);
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__0NS_9allocatorISK_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)unsigned int v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "TransitLogic", "", v5, 2u);
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(float *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      double v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            double v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          double v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  double v10 = operator new(0x20uLL);
  *double v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    unint64_t v5 = v3;
    goto LABEL_72;
  }
  BOOL v15 = 1;
  if (v7 >= 3) {
    BOOL v15 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v16 = v15 | (2 * v7);
  unint64_t v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17) {
    size_t prime = v17;
  }
  else {
    size_t prime = v16;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = *((void *)a1 + 1);
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    CGFloat v19 = operator new(8 * prime);
    uint64_t v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    unint64_t v23 = (uint64_t *)(a1 + 4);
    double v22 = (void *)*((void *)a1 + 2);
    if (!v22) {
      goto LABEL_59;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (uint64_t i = (void *)*v22; *v22; uint64_t i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          double v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          *double v22 = *i;
          uint64_t v29 = 8 * v28;
          *uint64_t i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          double v22 = i;
          size_t v26 = v28;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    unint64_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_64;
        }
        *double v22 = *v33;
        uint64_t v34 = 8 * v35;
        void *v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        unint64_t v33 = v22;
      }
      size_t v35 = v24;
LABEL_64:
      double v22 = v33;
      unint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      CGFloat v40 = *(void **)a1;
      *(void *)a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      *((void *)a1 + 1) = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = *((void *)a1 + 1);
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_72:
  char v36 = *(void **)a1;
  unint64_t v37 = *(void **)(*(void *)a1 + 8 * v5);
  if (v37)
  {
    *double v10 = *v37;
LABEL_80:
    void *v37 = v10;
    goto LABEL_81;
  }
  *double v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v5] = a1 + 4;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    unint64_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A20FDED0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(void *result, void *a2)
{
  unint64_t v3 = (unint64_t)result;
  uint64_t v4 = result[1];
  if (!v4) {
    goto LABEL_7;
  }
  for (uint64_t i = 0; i != v4; ++i)
    *(void *)(*result + 8 * i) = 0;
  result[5] = 0;
  double v6 = (void *)result[3];
  result[3] = 0;
  if (v6)
  {
    while (a2)
    {
      v6[2] = a2[2];
      unint64_t v7 = (void *)*v6;
      CFDictionaryRef result = (void *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__node_insert_multi(v3, v6);
      a2 = (void *)*a2;
      double v6 = v7;
      if (!v7) {
        goto LABEL_7;
      }
    }
    do
    {
      double v10 = (void *)*v6;
      CFDictionaryRef result = (void *)(*(uint64_t (**)(void))(**(void **)(v3 + 32) + 40))(*(void *)(v3 + 32));
      double v6 = v10;
    }
    while (v10);
  }
  else
  {
LABEL_7:
    while (a2)
    {
      uint8x8_t v8 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v3 + 32) + 16))(*(void *)(v3 + 32), 24, 8);
      *uint8x8_t v8 = 0;
      v8[1] = 0;
      uint64_t v9 = a2[2];
      v8[1] = v9;
      _DWORD v8[2] = v9;
      CFDictionaryRef result = (void *)std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__node_insert_multi(v3, v8);
      a2 = (void *)*a2;
    }
  }
  return result;
}

void sub_1A20FDFF8(_Unwind_Exception *a1)
{
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 32) + 40))(*(void *)(v1 + 32), v2, 24);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,void *> *>>(void *a1, uint64_t *a2)
{
  uint64_t v4 = a1[1];
  if (!v4) {
    goto LABEL_7;
  }
  for (uint64_t i = 0; i != v4; ++i)
    *(void *)(*a1 + 8 * i) = 0;
  double v6 = (uint64_t *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v6)
  {
    while (a2)
    {
      v6[2] = a2[2];
      int v7 = *((_DWORD *)a2 + 6);
      *((_WORD *)v6 + 14) = *((_WORD *)a2 + 14);
      *((_DWORD *)v6 + 6) = v7;
      uint8x8_t v8 = (uint64_t *)*v6;
      std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi((uint64_t)a1, v6);
      a2 = (uint64_t *)*a2;
      double v6 = v8;
      if (!v8) {
        goto LABEL_7;
      }
    }
    do
    {
      double v10 = (uint64_t *)*v6;
      operator delete(v6);
      double v6 = v10;
    }
    while (v10);
  }
  else
  {
LABEL_7:
    while (a2)
    {
      uint64_t v9 = operator new(0x20uLL);
      *(void *)uint64_t v9 = 0;
      v9[1] = *((_OWORD *)a2 + 1);
      *((void *)v9 + 1) = *((void *)v9 + 2);
      std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi((uint64_t)a1, v9);
      a2 = (uint64_t *)*a2;
    }
  }
}

void sub_1A20FE110(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi(uint64_t a1, void *a2)
{
  unint64_t v4 = a2[2];
  a2[1] = v4;
  unint64_t v5 = *(void *)(a1 + 8);
  float v6 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v7 = *(float *)(a1 + 32);
  if (!v5 || (float)(v7 * (float)v5) < v6)
  {
    BOOL v8 = 1;
    if (v5 >= 3) {
      BOOL v8 = (v5 & (v5 - 1)) != 0;
    }
    unint64_t v9 = v8 | (2 * v5);
    unint64_t v10 = vcvtps_u32_f32(v6 / v7);
    if (v9 <= v10) {
      size_t prime = v10;
    }
    else {
      size_t prime = v9;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v5 = *(void *)(a1 + 8);
    }
    if (prime > v5) {
      goto LABEL_105;
    }
    if (prime >= v5) {
      goto LABEL_40;
    }
    unint64_t v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (v5 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v5), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      unint64_t v25 = std::__next_prime(v25);
    }
    else
    {
      uint64_t v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2) {
        unint64_t v25 = v27;
      }
    }
    if (prime <= v25) {
      size_t prime = v25;
    }
    if (prime >= v5)
    {
      unint64_t v5 = *(void *)(a1 + 8);
      goto LABEL_40;
    }
    if (prime)
    {
LABEL_105:
      if (prime >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v12 = operator new(8 * prime);
      float v13 = *(void **)a1;
      *(void *)a1 = v12;
      if (v13) {
        operator delete(v13);
      }
      uint64_t v14 = 0;
      *(void *)(a1 + 8) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v14++) = 0;
      while (prime != v14);
      uint64_t v16 = a1 + 16;
      BOOL v15 = *(void **)(a1 + 16);
      if (v15)
      {
        size_t v17 = v15[1];
        size_t v18 = prime - 1;
        if ((prime & (prime - 1)) != 0)
        {
          if (v17 >= prime) {
            v17 %= prime;
          }
          *(void *)(*(void *)a1 + 8 * v17) = v16;
          for (uint64_t i = (void *)*v15; *v15; uint64_t i = (void *)*v15)
          {
            size_t v37 = i[1];
            if (v37 >= prime) {
              v37 %= prime;
            }
            if (v37 == v17)
            {
              BOOL v15 = i;
            }
            else
            {
              unint64_t v38 = i;
              if (*(void *)(*(void *)a1 + 8 * v37))
              {
                do
                {
                  uint64_t v39 = v38;
                  unint64_t v38 = (void *)*v38;
                }
                while (v38 && i[2] == v38[2]);
                *BOOL v15 = v38;
                uint64_t v40 = 8 * v37;
                *uint64_t v39 = **(void **)(*(void *)a1 + v40);
                **(void **)(*(void *)a1 + v40) = i;
              }
              else
              {
                *(void *)(*(void *)a1 + 8 * v37) = v15;
                BOOL v15 = i;
                size_t v17 = v37;
              }
            }
          }
        }
        else
        {
          size_t v19 = v17 & v18;
          *(void *)(*(void *)a1 + 8 * v19) = v16;
          for (uint64_t j = (void *)*v15; *v15; uint64_t j = (void *)*v15)
          {
            size_t v21 = j[1] & v18;
            if (v21 == v19)
            {
              BOOL v15 = j;
            }
            else
            {
              double v22 = j;
              if (*(void *)(*(void *)a1 + 8 * v21))
              {
                do
                {
                  unint64_t v23 = v22;
                  double v22 = (void *)*v22;
                }
                while (v22 && j[2] == v22[2]);
                *BOOL v15 = v22;
                uint64_t v24 = 8 * v21;
                void *v23 = **(void **)(*(void *)a1 + v24);
                **(void **)(*(void *)a1 + v24) = j;
              }
              else
              {
                *(void *)(*(void *)a1 + 8 * v21) = v15;
                BOOL v15 = j;
                size_t v19 = v21;
              }
            }
          }
        }
      }
      unint64_t v5 = prime;
    }
    else
    {
      double v50 = *(void **)a1;
      *(void *)a1 = 0;
      if (v50) {
        operator delete(v50);
      }
      unint64_t v5 = 0;
      *(void *)(a1 + 8) = 0;
    }
  }
LABEL_40:
  uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
  v29.i16[0] = vaddlv_u8(v29);
  if (v29.u32[0] >= 2uLL)
  {
    unint64_t v41 = v4;
    if (v5 <= v4) {
      unint64_t v41 = v4 % v5;
    }
    BOOL v42 = *(void **)(*(void *)a1 + 8 * v41);
    if (!v42)
    {
      size_t v35 = 0;
      unint64_t v48 = a2[1];
      if (v48 < v5) {
        goto LABEL_78;
      }
      goto LABEL_77;
    }
    int v43 = 0;
    do
    {
      size_t v35 = v42;
      BOOL v42 = (void *)*v42;
      if (!v42) {
        break;
      }
      unint64_t v46 = v42[1];
      unint64_t v47 = v46;
      if (v46 >= v5) {
        unint64_t v47 = v46 % v5;
      }
      if (v47 != v41) {
        break;
      }
      BOOL v44 = v46 == v4 && v42[2] == a2[2];
      int v45 = v43 & !v44;
      v43 |= v44;
    }
    while (v45 != 1);
  }
  else
  {
    uint64_t v30 = (v5 - 1) & v4;
    uint8x8_t v31 = *(void **)(*(void *)a1 + 8 * v30);
    if (!v31)
    {
      size_t v35 = 0;
      unint64_t v48 = a2[1];
      goto LABEL_75;
    }
    int v32 = 0;
    do
    {
      size_t v35 = v31;
      uint8x8_t v31 = (void *)*v31;
      if (!v31) {
        break;
      }
      uint64_t v36 = v31[1];
      if ((v36 & (v5 - 1)) != v30) {
        break;
      }
      BOOL v33 = v36 == v4 && v31[2] == a2[2];
      char v34 = v32 & !v33;
      v32 |= v33;
    }
    while ((v34 & 1) == 0);
  }
  unint64_t v48 = a2[1];
  if (v29.u32[0] <= 1uLL)
  {
LABEL_75:
    v48 &= v5 - 1;
    goto LABEL_78;
  }
  if (v48 >= v5) {
LABEL_77:
  }
    v48 %= v5;
LABEL_78:
  if (!v35)
  {
    *a2 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = a2;
    *(void *)(*(void *)a1 + 8 * v48) = a1 + 16;
    if (!*a2) {
      goto LABEL_92;
    }
    unint64_t v49 = *(void *)(*a2 + 8);
    if (v29.u32[0] > 1uLL)
    {
      if (v49 >= v5) {
        v49 %= v5;
      }
    }
    else
    {
      v49 &= v5 - 1;
    }
LABEL_91:
    *(void *)(*(void *)a1 + 8 * v49) = a2;
    goto LABEL_92;
  }
  *a2 = *v35;
  *size_t v35 = a2;
  if (*a2)
  {
    unint64_t v49 = *(void *)(*a2 + 8);
    if (v29.u32[0] > 1uLL)
    {
      if (v49 >= v5) {
        v49 %= v5;
      }
    }
    else
    {
      v49 &= v5 - 1;
    }
    if (v49 != v48) {
      goto LABEL_91;
    }
  }
LABEL_92:
  ++*(void *)(a1 + 24);
}

unint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__node_insert_multi(unint64_t result, void *a2)
{
  unint64_t v3 = result;
  unint64_t v4 = a2[2];
  a2[1] = v4;
  unint64_t v5 = *(void *)(result + 8);
  float v6 = (float)(unint64_t)(*(void *)(result + 40) + 1);
  float v7 = *(float *)(result + 48);
  if (!v5 || (float)(v7 * (float)v5) < v6)
  {
    BOOL v8 = 1;
    if (v5 >= 3) {
      BOOL v8 = (v5 & (v5 - 1)) != 0;
    }
    unint64_t v9 = v8 | (2 * v5);
    unint64_t v10 = vcvtps_u32_f32(v6 / v7);
    if (v9 <= v10) {
      size_t v11 = v10;
    }
    else {
      size_t v11 = v9;
    }
    if (v11 == 1)
    {
      size_t v11 = 2;
    }
    else if ((v11 & (v11 - 1)) != 0)
    {
      CFDictionaryRef result = std::__next_prime(v11);
      size_t v11 = result;
      unint64_t v5 = *(void *)(v3 + 8);
    }
    if (v11 > v5) {
      goto LABEL_13;
    }
    if (v11 >= v5) {
      goto LABEL_39;
    }
    CFDictionaryRef result = vcvtps_u32_f32((float)*(unint64_t *)(v3 + 40) / *(float *)(v3 + 48));
    if (v5 < 3 || (uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v5), v24.i16[0] = vaddlv_u8(v24), v24.u32[0] > 1uLL))
    {
      CFDictionaryRef result = std::__next_prime(result);
    }
    else
    {
      uint64_t v25 = 1 << -(char)__clz(result - 1);
      if (result >= 2) {
        CFDictionaryRef result = v25;
      }
    }
    if (v11 <= result) {
      size_t v11 = result;
    }
    if (v11 >= v5)
    {
      unint64_t v5 = *(void *)(v3 + 8);
      goto LABEL_39;
    }
    if (v11)
    {
LABEL_13:
      CFDictionaryRef result = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(v3 + 16) + 16))(*(void *)(v3 + 16), 8 * v11, 8);
      uint64_t v12 = *(void *)v3;
      *(void *)unint64_t v3 = result;
      if (v12) {
        CFDictionaryRef result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v3 + 16) + 40))(*(void *)(v3 + 16), v12, 8 * *(void *)(v3 + 8));
      }
      uint64_t v13 = 0;
      *(void *)(v3 + 8) = v11;
      do
        *(void *)(*(void *)v3 + 8 * v13++) = 0;
      while (v11 != v13);
      unint64_t v15 = v3 + 24;
      uint64_t v14 = *(void **)(v3 + 24);
      if (v14)
      {
        size_t v16 = v14[1];
        size_t v17 = v11 - 1;
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v16 >= v11) {
            v16 %= v11;
          }
          *(void *)(*(void *)v3 + 8 * v16) = v15;
          for (uint64_t i = (void *)*v14; *v14; uint64_t i = (void *)*v14)
          {
            size_t v35 = i[1];
            if (v35 >= v11) {
              v35 %= v11;
            }
            if (v35 == v16)
            {
              uint64_t v14 = i;
            }
            else
            {
              uint64_t v36 = i;
              if (*(void *)(*(void *)v3 + 8 * v35))
              {
                do
                {
                  size_t v37 = v36;
                  uint64_t v36 = (void *)*v36;
                }
                while (v36 && i[2] == v36[2]);
                *uint64_t v14 = v36;
                uint64_t v38 = 8 * v35;
                void *v37 = **(void **)(*(void *)v3 + v38);
                **(void **)(*(void *)v3 + v38) = i;
              }
              else
              {
                *(void *)(*(void *)v3 + 8 * v35) = v14;
                uint64_t v14 = i;
                size_t v16 = v35;
              }
            }
          }
        }
        else
        {
          size_t v18 = v16 & v17;
          *(void *)(*(void *)v3 + 8 * v18) = v15;
          for (uint64_t j = (void *)*v14; *v14; uint64_t j = (void *)*v14)
          {
            size_t v20 = j[1] & v17;
            if (v20 == v18)
            {
              uint64_t v14 = j;
            }
            else
            {
              size_t v21 = j;
              if (*(void *)(*(void *)v3 + 8 * v20))
              {
                do
                {
                  double v22 = v21;
                  size_t v21 = (void *)*v21;
                }
                while (v21 && j[2] == v21[2]);
                *uint64_t v14 = v21;
                uint64_t v23 = 8 * v20;
                *double v22 = **(void **)(*(void *)v3 + v23);
                **(void **)(*(void *)v3 + v23) = j;
              }
              else
              {
                *(void *)(*(void *)v3 + 8 * v20) = v14;
                uint64_t v14 = j;
                size_t v18 = v20;
              }
            }
          }
        }
      }
      unint64_t v5 = v11;
    }
    else
    {
      uint64_t v48 = *(void *)v3;
      *(void *)unint64_t v3 = 0;
      if (v48) {
        CFDictionaryRef result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v3 + 16) + 40))(*(void *)(v3 + 16), v48, 8 * *(void *)(v3 + 8));
      }
      unint64_t v5 = 0;
      *(void *)(v3 + 8) = 0;
    }
  }
LABEL_39:
  uint8x8_t v27 = (uint8x8_t)vcnt_s8((int8x8_t)v5);
  v27.i16[0] = vaddlv_u8(v27);
  if (v27.u32[0] >= 2uLL)
  {
    unint64_t v39 = v4;
    if (v5 <= v4) {
      unint64_t v39 = v4 % v5;
    }
    uint64_t v40 = *(void **)(*(void *)v3 + 8 * v39);
    if (!v40)
    {
      BOOL v33 = 0;
      unint64_t v46 = a2[1];
      if (v46 < v5) {
        goto LABEL_77;
      }
      goto LABEL_76;
    }
    int v41 = 0;
    do
    {
      BOOL v33 = v40;
      uint64_t v40 = (void *)*v40;
      if (!v40) {
        break;
      }
      unint64_t v44 = v40[1];
      unint64_t v45 = v44;
      if (v44 >= v5) {
        unint64_t v45 = v44 % v5;
      }
      if (v45 != v39) {
        break;
      }
      BOOL v42 = v44 == v4 && v40[2] == a2[2];
      int v43 = v41 & !v42;
      v41 |= v42;
    }
    while (v43 != 1);
  }
  else
  {
    uint64_t v28 = (v5 - 1) & v4;
    uint8x8_t v29 = *(void **)(*(void *)v3 + 8 * v28);
    if (!v29)
    {
      BOOL v33 = 0;
      unint64_t v46 = a2[1];
      goto LABEL_74;
    }
    int v30 = 0;
    do
    {
      BOOL v33 = v29;
      uint8x8_t v29 = (void *)*v29;
      if (!v29) {
        break;
      }
      uint64_t v34 = v29[1];
      if ((v34 & (v5 - 1)) != v28) {
        break;
      }
      BOOL v31 = v34 == v4 && v29[2] == a2[2];
      char v32 = v30 & !v31;
      v30 |= v31;
    }
    while ((v32 & 1) == 0);
  }
  unint64_t v46 = a2[1];
  if (v27.u32[0] <= 1uLL)
  {
LABEL_74:
    v46 &= v5 - 1;
    goto LABEL_77;
  }
  if (v46 >= v5) {
LABEL_76:
  }
    v46 %= v5;
LABEL_77:
  if (!v33)
  {
    *a2 = *(void *)(v3 + 24);
    *(void *)(v3 + 24) = a2;
    *(void *)(*(void *)v3 + 8 * v46) = v3 + 24;
    if (!*a2) {
      goto LABEL_91;
    }
    unint64_t v47 = *(void *)(*a2 + 8);
    if (v27.u32[0] > 1uLL)
    {
      if (v47 >= v5) {
        v47 %= v5;
      }
    }
    else
    {
      v47 &= v5 - 1;
    }
LABEL_90:
    *(void *)(*(void *)v3 + 8 * v47) = a2;
    goto LABEL_91;
  }
  *a2 = *v33;
  void *v33 = a2;
  if (*a2)
  {
    unint64_t v47 = *(void *)(*a2 + 8);
    if (v27.u32[0] > 1uLL)
    {
      if (v47 >= v5) {
        v47 %= v5;
      }
    }
    else
    {
      v47 &= v5 - 1;
    }
    if (v47 != v46) {
      goto LABEL_90;
    }
  }
LABEL_91:
  ++*(void *)(v3 + 40);
  return result;
}

void _ZNSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__1NS_9allocatorISK_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)unint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "TransitLogic", "", v5, 2u);
  }
}

uint64_t _ZNKSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__1NS_9allocatorISK_EEFvvEE7__cloneEPNS0_6__baseISN_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56F720;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__1NS_9allocatorISK_EEFvvEE7__cloneEv(uint64_t a1)
{
  CFDictionaryRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFDictionaryRef result = &unk_1EF56F720;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__1NS_9allocatorISK_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__0NS_9allocatorISK_EEFvvEE7__cloneEPNS0_6__baseISN_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56F6D8;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__0NS_9allocatorISK_EEFvvEE7__cloneEv(uint64_t a1)
{
  CFDictionaryRef result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *CFDictionaryRef result = &unk_1EF56F6D8;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md12TransitLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_14TransitContextEE3__0NS_9allocatorISK_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

double md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::allocateContext@<D0>(uint64_t a1@<X8>)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v11 = a1;
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v11;
    if (v3) {
      operator new();
    }
  }
  *(void *)(a1 + 16) = *((void *)v1 + 91);
  *(void *)(a1 + 24) = 0;
  {
    uint64_t v12 = a1;
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v12;
    if (v4) {
      operator new();
    }
  }
  *(void *)(a1 + 32) = *((void *)v1 + 91);
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 1065353216;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  {
    uint64_t v13 = a1;
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v13;
    if (v5) {
      operator new();
    }
  }
  *(void *)(a1 + 72) = *((void *)v1 + 91);
  *(void *)(a1 + 80) = 0;
  {
    uint64_t v14 = a1;
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v14;
    if (v6) {
      operator new();
    }
  }
  *(void *)(a1 + 88) = *((void *)v1 + 91);
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 1065353216;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  {
    uint64_t v15 = a1;
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v15;
    if (v7) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = *((void *)v1 + 91);
  *(void *)(a1 + 136) = 0;
  {
    uint64_t v16 = a1;
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v16;
    if (v8) {
      operator new();
    }
  }
  *(void *)(a1 + 144) = *((void *)v1 + 91);
  *(void *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 160) = 1065353216;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = 0;
  {
    uint64_t v17 = a1;
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v17;
    if (v9) {
      operator new();
    }
  }
  *(void *)(a1 + 184) = *((void *)v1 + 91);
  *(void *)(a1 + 192) = 0;
  {
    uint64_t v18 = a1;
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v18;
    if (v10) {
      operator new();
    }
  }
  *(void *)(a1 + 200) = *((void *)v1 + 91);
  *(void *)(a1 + 208) = 0;
  *(_DWORD *)(a1 + 216) = 1065353216;
  *(unsigned char *)(a1 + 224) = 0;
  double result = 0.0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 248) = 0u;
  *(_DWORD *)(a1 + 264) = 1065353216;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_DWORD *)(a1 + 304) = 1065353216;
  *(unsigned char *)(a1 + 312) = 0;
  return result;
}

uint64_t md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0xFD5D5EC7C4E1E43ELL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SceneContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xFD5D5EC7C4E1E43ELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SceneContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xFD5D5EC7C4E1E43ELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SceneContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xFD5D5EC7C4E1E43ELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SceneContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xFD5D5EC7C4E1E43ELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::SceneContext>(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v7, v3);
    }
  }
  return result;
}

void md::Logic<md::TransitLogic,md::TransitContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::SceneContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A20FF8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  md::TransitContext::~TransitContext((md::TransitContext *)&a9);
  MEMORY[0x1A6239270](v9, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

void md::TransitContext::~TransitContext(md::TransitContext *this)
{
  uint64_t v2 = (void *)*((void *)this + 36);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 34);
  *((void *)this + 34) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (void *)*((void *)this + 31);
  if (v5)
  {
    do
    {
      uint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  uint64_t v7 = (void *)*((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v7) {
    operator delete(v7);
  }
  int v8 = (void *)*((void *)this + 24);
  if (v8)
  {
    do
    {
      uint64_t v9 = (void *)*v8;
      (*(void (**)(void))(**((void **)this + 25) + 40))(*((void *)this + 25));
      int v8 = v9;
    }
    while (v9);
  }
  uint64_t v10 = *((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v10) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 23) + 40))(*((void *)this + 23), v10, 8 * *((void *)this + 22));
  }
  uint64_t v11 = (void *)*((void *)this + 17);
  if (v11)
  {
    do
    {
      uint64_t v12 = (void *)*v11;
      (*(void (**)(void))(**((void **)this + 18) + 40))(*((void *)this + 18));
      uint64_t v11 = v12;
    }
    while (v12);
  }
  uint64_t v13 = *((void *)this + 14);
  *((void *)this + 14) = 0;
  if (v13) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 16) + 40))(*((void *)this + 16), v13, 8 * *((void *)this + 15));
  }
  uint64_t v14 = (void *)*((void *)this + 10);
  if (v14)
  {
    do
    {
      uint64_t v15 = (void *)*v14;
      (*(void (**)(void))(**((void **)this + 11) + 40))(*((void *)this + 11));
      uint64_t v14 = v15;
    }
    while (v15);
  }
  uint64_t v16 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v16) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), v16, 8 * *((void *)this + 8));
  }
  uint64_t v17 = (void *)*((void *)this + 3);
  if (v17)
  {
    do
    {
      uint64_t v18 = (void *)*v17;
      (*(void (**)(void))(**((void **)this + 4) + 40))(*((void *)this + 4));
      uint64_t v17 = v18;
    }
    while (v18);
  }
  uint64_t v19 = *(void *)this;
  *(void *)this = 0;
  if (v19) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 2) + 40))(*((void *)this + 2), v19, 8 * *((void *)this + 1));
  }
}

uint64_t gdc::ObjectHolder<md::TransitContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::TransitContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555488;
  uint64_t v1 = (md::TransitContext *)a1[4];
  if (v1)
  {
    md::TransitContext::~TransitContext(v1);
    MEMORY[0x1A6239270]();
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::TransitContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555488;
  uint64_t v2 = (md::TransitContext *)a1[4];
  if (v2)
  {
    md::TransitContext::~TransitContext(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::TransitLogic::didBecomeInactive(md::TransitLogic *this)
{
  uint64_t v1 = this;
  *((void *)this + 22) = *((void *)this + 21);
  uint64_t v2 = (void *)((char *)this + 128);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*((void **)this + 16));
  uint64_t v3 = (void *)*((void *)v1 + 19);
  uint64_t v1 = (md::TransitLogic *)((char *)v1 + 152);
  *((void *)v1 - 4) = v2;
  void *v2 = 0;
  *((void *)v1 - 2) = 0;
  std::__tree<gdc::LayerDataWithWorld>::destroy(v3);
  *((void *)v1 - 1) = v1;
  *(void *)uint64_t v1 = 0;
  *((void *)v1 + 1) = 0;
}

void md::TransitLogic::~TransitLogic(md::TransitLogic *this)
{
  md::TransitLogic::~TransitLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;

  *(void *)this = &unk_1EF531D70;
  md::TransitContext::~TransitContext((md::TransitLogic *)((char *)this + 232));
  *((void *)this + 24) = &unk_1EF5595D8;

  uint64_t v2 = (void *)*((void *)this + 21);
  if (v2)
  {
    *((void *)this + 22) = v2;
    operator delete(v2);
  }
  std::__tree<gdc::LayerDataWithWorld>::destroy(*((void **)this + 19));
  std::__tree<gdc::LayerDataWithWorld>::destroy(*((void **)this + 16));
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::TransitLogic::setSelectedLines(md::TransitLogic *this, VKTransitLineMarker *a2)
{
  uint64_t v3 = a2;
  uint64_t v41 = 0;
  int8x8_t v42 = 0;
  {
    operator new();
  }
  uint64_t v43 = mdm::Allocator::instance(void)::alloc;
  unint64_t v44 = 0;
  {
    operator new();
  }
  uint64_t v45 = mdm::Allocator::instance(void)::alloc;
  uint64_t v46 = 0;
  int v47 = 1065353216;
  if (v3 && [(VKTransitLineMarker *)v3 featureID])
  {
    unint64_t v40 = [(VKTransitLineMarker *)v3 featureID];
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__emplace_unique_key_args<unsigned long long,unsigned long long>((unint64_t)&v41, v40, &v40);
  }
  if ((uint64_t *)((char *)this + 232) != &v41)
  {
    *((_DWORD *)this + 70) = v47;
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)this + 29, v44);
  }
  if (*((void *)this + 55))
  {
    uint64_t v4 = (void *)*((void *)this + 53);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void *)*v4;
        (*(void (**)(void))(**((void **)this + 54) + 40))(*((void *)this + 54));
        uint64_t v4 = v5;
      }
      while (v5);
    }
    *((void *)this + 53) = 0;
    uint64_t v6 = *((void *)this + 51);
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
        *(void *)(*((void *)this + 50) + 8 * i) = 0;
    }
    *((void *)this + 55) = 0;
  }
  int v8 = (unint64_t *)*((void *)this + 21);
  uint64_t v9 = (unint64_t *)*((void *)this + 22);
  if (v8 != v9)
  {
    do
      md::TransitTileData::appendNodesAttachedToLines(*v8++, *((void **)this + 32), (unint64_t)this + 400);
    while (v8 != v9);
    uint64_t v10 = (uint64_t *)*((void *)this + 21);
    for (uint64_t j = (uint64_t *)*((void *)this + 22); v10 != j; ++v10)
    {
      uint64_t v12 = *v10;
      md::TransitTileData::setSelectedLines(*v10, (void *)this + 29);
      md::TransitTileData::setSelectedNodes(*(uint64_t **)(v12 + 968), *(uint64_t **)(v12 + 976), *((void *)this + 50), *((void *)this + 51));
    }
  }
  uint64_t v13 = *((void *)this + 28);
  uint64_t v14 = *(void *)(v13 + 32);
  uint64_t v15 = *(void *)(v13 + 40);
  if (v14 != v15)
  {
    while (*(_WORD *)v14 != 17)
    {
      v14 += 16;
      if (v14 == v15) {
        goto LABEL_66;
      }
    }
  }
  if (v14 != v15)
  {
    uint64_t v16 = *(md::SelectedTransitLayerDataSource **)(v14 + 8);
    if (v16)
    {
      if (v46)
      {
        uint64_t v17 = [(VKTransitLineMarker *)v3 identifier];
        if (!v46) {
          goto LABEL_64;
        }
        uint64_t v18 = *((void *)this + 21);
        uint64_t v19 = *((void *)this + 22);
        if (v18 == v19) {
          goto LABEL_64;
        }
        uint8x8_t v20 = (uint8x8_t)vcnt_s8(v42);
        v20.i16[0] = vaddlv_u8(v20);
        unint64_t v21 = v20.u32[0];
        uint64_t v22 = *(void *)&v42 - 1;
        float v23 = 3.4028e38;
        do
        {
          uint64_t v25 = *(void *)(*(void *)v18 + 888);
          uint64_t v26 = *(void *)(*(void *)v18 + 896);
          if (v25 == v26 || *(void *)&v42 == 0)
          {
            float v24 = 3.4028e38;
          }
          else
          {
            float v24 = 3.4028e38;
            do
            {
              for (uint64_t k = *(void *)(v25 + 80); k != *(void *)(v25 + 88); k += 8)
              {
                uint64_t v29 = *(void *)(*(void *)(*(void *)k + 8) + 16);
                unint64_t v30 = *(void *)(v29 + 40);
                if (v21 > 1)
                {
                  unint64_t v31 = *(void *)(v29 + 40);
                  if (v30 >= *(void *)&v42) {
                    unint64_t v31 = v30 % *(void *)&v42;
                  }
                }
                else
                {
                  unint64_t v31 = v22 & v30;
                }
                char v32 = *(void **)(v41 + 8 * v31);
                if (v32)
                {
                  BOOL v33 = (void *)*v32;
                  if (v33)
                  {
                    if (v21 < 2)
                    {
                      while (1)
                      {
                        uint64_t v34 = v33[1];
                        if (v30 == v34)
                        {
                          if (v33[2] == v30) {
                            goto LABEL_38;
                          }
                        }
                        else if ((v34 & v22) != v31)
                        {
                          goto LABEL_39;
                        }
                        BOOL v33 = (void *)*v33;
                        if (!v33) {
                          goto LABEL_39;
                        }
                      }
                    }
                    do
                    {
                      unint64_t v35 = v33[1];
                      if (v30 == v35)
                      {
                        if (v33[2] == v30)
                        {
LABEL_38:
                          float v24 = fminf(*(float *)(v29 + 88), v24);
                          break;
                        }
                      }
                      else
                      {
                        if (v35 >= *(void *)&v42) {
                          v35 %= *(void *)&v42;
                        }
                        if (v35 != v31) {
                          break;
                        }
                      }
                      BOOL v33 = (void *)*v33;
                    }
                    while (v33);
                  }
                }
LABEL_39:
                ;
              }
              v25 += 248;
            }
            while (v25 != v26);
          }
          float v23 = fminf(v24, v23);
          v18 += 8;
        }
        while (v18 != v19);
        if (v23 >= 4295000000.0) {
LABEL_64:
        }
          int v36 = -1;
        else {
          int v36 = vcvtms_u32_f32(v23);
        }
        md::SelectedTransitLayerDataSource::setSelectedLine(v16, v17, v36);
      }
      else
      {
        md::SelectedTransitLayerDataSource::setSelectedLine(v16, 0, -1);
      }
    }
  }
LABEL_66:
  *((unsigned char *)this + 456) = 1;
  size_t v37 = v44;
  if (v44)
  {
    do
    {
      uint64_t v38 = (void *)*v37;
      (*(void (**)(uint64_t))(*(void *)v45 + 40))(v45);
      size_t v37 = v38;
    }
    while (v38);
  }
  uint64_t v39 = v41;
  uint64_t v41 = 0;
  if (v39) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v43 + 40))(v43, v39, 8 * *(void *)&v42);
  }
}

void sub_1A2100220(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::unordered_set<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::~unordered_set[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

unint64_t std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,geo::StdAllocator<unsigned long long,mdm::Allocator>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(unint64_t result, unint64_t a2, void *a3)
{
  uint64_t v6 = result;
  unint64_t v7 = *(void *)(result + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void **)(*(void *)result + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (void *)*v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return result;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return result;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  double result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 32) + 16))(*(void *)(result + 32), 24, 8);
  unint64_t v13 = result;
  *(void *)double result = 0;
  *(void *)(result + 8) = a2;
  *(void *)(result + 16) = *a3;
  float v14 = (float)(unint64_t)(*(void *)(v6 + 40) + 1);
  float v15 = *(float *)(v6 + 48);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t v19 = v18;
    }
    else {
      size_t v19 = v17;
    }
    if (v19 == 1)
    {
      size_t v19 = 2;
    }
    else if ((v19 & (v19 - 1)) != 0)
    {
      double result = std::__next_prime(v19);
      size_t v19 = result;
    }
    int8x8_t v20 = *(int8x8_t *)(v6 + 8);
    if (v19 > *(void *)&v20) {
      goto LABEL_34;
    }
    if (v19 < *(void *)&v20)
    {
      double result = vcvtps_u32_f32((float)*(unint64_t *)(v6 + 40) / *(float *)(v6 + 48));
      if (*(void *)&v20 < 3uLL || (uint8x8_t v21 = (uint8x8_t)vcnt_s8(v20), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        double result = std::__next_prime(result);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(result - 1);
        if (result >= 2) {
          double result = v22;
        }
      }
      if (v19 <= result) {
        size_t v19 = result;
      }
      if (v19 < *(void *)&v20) {
LABEL_34:
      }
        double result = std::__hash_table<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::__unordered_map_hasher<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,md::TrafficFeatureHash,std::equal_to<VKTrafficFeature * {__strong}>,true>,std::__unordered_map_equal<VKTrafficFeature * {__strong},std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,std::equal_to<VKTrafficFeature * {__strong}>,md::TrafficFeatureHash,true>,geo::StdAllocator<std::__hash_value_type<VKTrafficFeature * {__strong},md::RouteAnnotationLabelFeature *>,mdm::Allocator>>::__do_rehash<true>(v6, v19);
    }
    unint64_t v7 = *(void *)(v6 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  float v23 = *(unint64_t **)(*(void *)v6 + 8 * v3);
  if (v23)
  {
    *(void *)unint64_t v13 = *v23;
LABEL_58:
    unint64_t *v23 = v13;
    goto LABEL_59;
  }
  *(void *)unint64_t v13 = *(void *)(v6 + 24);
  *(void *)(v6 + 24) = v13;
  *(void *)(*(void *)v6 + 8 * v3) = v6 + 24;
  if (*(void *)v13)
  {
    unint64_t v24 = *(void *)(*(void *)v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    float v23 = (unint64_t *)(*(void *)v6 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(v6 + 40);
  return result;
}

void sub_1A2100544(_Unwind_Exception *a1)
{
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 32) + 40))(*(void *)(v1 + 32), v2, 24);
  _Unwind_Resume(a1);
}

void md::TransitLogic::setRouteContext(md::TransitLogic *this, VKRouteContext *a2)
{
  unint64_t v3 = a2;
  if (*((VKRouteContext **)this + 25) != v3) {
    *((unsigned char *)this + 216) = 1;
  }
  uint64_t v4 = v3;
  unint64_t v7 = v4;
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v4 = v7;
  }
  uint64_t v6 = (void *)*((void *)this + 25);
  *((void *)this + 25) = v4;
}

void std::vector<VKTransitLineMarker * {__strong}>::reserve(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(char **)a1;
  if (a2 <= (uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 3) {
    return;
  }
  if (a2 >> 61) {
    abort();
  }
  uint64_t v4 = *(char **)(a1 + 8);
  uint64_t v5 = 8 * a2;
  uint64_t v6 = (char *)operator new(8 * a2);
  unint64_t v7 = &v6[v5];
  uint64_t v8 = v4 - v2;
  unint64_t v9 = (unint64_t)&v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
  if (v4 != v2)
  {
    unint64_t v10 = v8 - 8;
    if ((unint64_t)(v8 - 8) > 0x77)
    {
      BOOL v12 = (unint64_t)&v4[-(v10 & 0xFFFFFFFFFFFFFFF8) - 8] >= v9
         || &v6[(v8 & 0xFFFFFFFFFFFFFFF8) - (v10 & 0xFFFFFFFFFFFFFFF8) - 8] >= v4;
      unint64_t v11 = &v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
      if (v12)
      {
        uint64_t v13 = v8 >> 3;
        uint64_t v14 = (v10 >> 3) + 1;
        float v15 = &v6[8 * v13 - 16];
        BOOL v16 = v4 - 32;
        uint64_t v17 = v14 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v19 = *(_OWORD *)v16;
          long long v18 = *((_OWORD *)v16 + 1);
          *(_OWORD *)BOOL v16 = 0uLL;
          *((_OWORD *)v16 + 1) = 0uLL;
          v16 -= 32;
          *((_OWORD *)v15 - 1) = v19;
          *(_OWORD *)float v15 = v18;
          v15 -= 32;
          v17 -= 4;
        }
        while (v17);
        unint64_t v11 = (char *)(v9 - 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL));
        v4 -= 8 * (v14 & 0x3FFFFFFFFFFFFFFCLL);
        if (v14 == (v14 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_21:
          uint64_t v2 = *(char **)a1;
          uint8x8_t v21 = *(char **)(a1 + 8);
          *(void *)a1 = v11;
          *(void *)(a1 + 8) = v9;
          *(void *)(a1 + 16) = v7;
          while (v21 != v2)
          {
            uint64_t v22 = (void *)*((void *)v21 - 1);
            v21 -= 8;
          }
          goto LABEL_7;
        }
      }
    }
    else
    {
      unint64_t v11 = &v6[(v4 - v2) & 0xFFFFFFFFFFFFFFF8];
    }
    do
    {
      uint64_t v20 = *((void *)v4 - 1);
      v4 -= 8;
      *(void *)uint64_t v4 = 0;
      *((void *)v11 - 1) = v20;
      v11 -= 8;
    }
    while (v4 != v2);
    goto LABEL_21;
  }
  *(void *)a1 = v9;
  *(void *)(a1 + 8) = v9;
  *(void *)(a1 + 16) = v7;
LABEL_7:
  if (v2)
  {
    operator delete(v2);
  }
}

void md::TransitLogic::getTransitLineMarkersForSelectionAtGroundPoint(void *a1, float64x2_t **a2, float64x2_t **a3, float64x2_t *a4)
{
  if (a2 == a3)
  {
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
    return;
  }
  uint64_t v4 = 0;
  uint64_t v5 = 0;
  uint64_t v6 = 0;
  int32x4_t v77 = vdupq_n_s32(0x7F7FFFFFu);
  __asm { FMOV            V2.4S, #1.0 }
  float32x4_t v80 = _Q2;
  float64x2_t v81 = (float64x2_t)vdupq_n_s64(0x3CD203AF9EE75616uLL);
  do
  {
    float v12 = *(float *)&(*a2)[84].f64[1];
    if (v12 != 0.0)
    {
      unint64_t v13 = 0;
      float v14 = (float)(1.0 / v12) * (float)(1.0 / v12);
      unint64_t v75 = a2;
      CGFloat v76 = *a2;
      float32x2_t v82 = vcvt_f32_f64(vdivq_f64(vsubq_f64(*a4, (*a2)[81]), vsubq_f64((*a2)[82], (*a2)[81])));
      float32x4_t v78 = (float32x4_t)vdupq_lane_s32((int32x2_t)v82, 1);
      float32x4_t v79 = (float32x4_t)vdupq_lane_s32((int32x2_t)v82, 0);
      while (1)
      {
        if (v13 >= geo::codec::VectorTile::transitLinkCount(*(geo::codec::VectorTile **)&v76[45].f64[0]))
        {
          a2 = v75;
          break;
        }
        uint64_t v15 = geo::codec::VectorTile::transitLinks(*(geo::codec::VectorTile **)&v76[45].f64[0]);
        uint64_t v16 = v15 + 184 * v13;
        if (!*(_DWORD *)(v16 + 20)) {
          goto LABEL_7;
        }
        uint64_t v17 = 0;
        long long v18 = (unint64_t *)(v15 + 184 * v13 + 32);
        while (1)
        {
          unint64_t v84 = 0;
          long long v19 = (void *)geo::codec::transitLinkPoints(v16, v17, &v84);
          if (v84 < 2)
          {
            float v22 = 3.4028e38;
            goto LABEL_15;
          }
          float32x2_t v21 = *(float32x2_t *)v19;
          if (v84 >= 9)
          {
            unint64_t v25 = (v84 - 1) & 0xFFFFFFFFFFFFFFF8;
            v20.i64[1] = *v19;
            float32x4_t v26 = (float32x4_t)vdupq_lane_s32((int32x2_t)v21, 0);
            uint8x8_t v27 = v19 + 5;
            unint64_t v28 = v25;
            float32x4_t v29 = (float32x4_t)v77;
            float32x4_t v30 = (float32x4_t)v77;
            do
            {
              unint64_t v31 = (const float *)(v27 - 2);
              float32x4x2_t v85 = vld2q_f32(v31);
              int32x4_t v33 = *(int32x4_t *)v27;
              int8x16_t v32 = *((int8x16_t *)v27 + 1);
              v27 += 4;
              float32x4_t v34 = (float32x4_t)vextq_s8((int8x16_t)v26, (int8x16_t)v85.val[0], 0xCuLL);
              float32x4_t v26 = (float32x4_t)vuzp1q_s32(v33, (int32x4_t)v32);
              float32x4_t v35 = (float32x4_t)vextq_s8((int8x16_t)v20, (int8x16_t)v85.val[1], 0xCuLL);
              float32x4_t v20 = (float32x4_t)vuzp2q_s32(v33, (int32x4_t)v32);
              float32x4_t v36 = (float32x4_t)vextq_s8((int8x16_t)v85.val[0], (int8x16_t)v26, 0xCuLL);
              float32x4_t v37 = (float32x4_t)vextq_s8((int8x16_t)v85.val[1], (int8x16_t)v20, 0xCuLL);
              float32x4_t v38 = vsubq_f32(v85.val[0], v34);
              float32x4_t v39 = vsubq_f32(v26, v36);
              v85.val[0] = vsubq_f32(v85.val[1], v35);
              v85.val[1] = vsubq_f32(v20, v37);
              float32x4_t v40 = vmlaq_f32(vmulq_f32(v38, v38), v85.val[0], v85.val[0]);
              float32x4_t v41 = vmlaq_f32(vmulq_f32(v39, v39), v85.val[1], v85.val[1]);
              float32x4_t v42 = (float32x4_t)vbicq_s8((int8x16_t)vminnmq_f32(vmaxnmq_f32(vdivq_f32(vmlaq_f32(vmulq_f32(vsubq_f32(v79, v34), v38), v85.val[0], vsubq_f32(v78, v35)), v40), (float32x4_t)0), v80), (int8x16_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v81, vcvtq_f64_f32(*(float32x2_t *)v40.f32)), (int32x4_t)vcgeq_f64(v81, vcvt_hight_f64_f32(v40))));
              float32x4_t v43 = (float32x4_t)vbicq_s8((int8x16_t)vminnmq_f32(vmaxnmq_f32(vdivq_f32(vmlaq_f32(vmulq_f32(vsubq_f32(v79, v36), v39), v85.val[1], vsubq_f32(v78, v37)), v41), (float32x4_t)0), v80), (int8x16_t)vuzp1q_s32((int32x4_t)vcgeq_f64(v81, vcvtq_f64_f32(*(float32x2_t *)v41.f32)), (int32x4_t)vcgeq_f64(v81, vcvt_hight_f64_f32(v41))));
              float32x4_t v44 = vsubq_f32(v79, vmlaq_f32(v34, v38, v42));
              float32x4_t v45 = vmlaq_f32(v35, v85.val[0], v42);
              float32x4_t v46 = vmlaq_f32(v37, v85.val[1], v43);
              v85.val[0] = vsubq_f32(v79, vmlaq_f32(v36, v39, v43));
              v85.val[1] = vsubq_f32(v78, v45);
              float32x4_t v47 = vsubq_f32(v78, v46);
              float32x4_t v30 = vminnmq_f32(vmlaq_f32(vmulq_f32(v44, v44), v85.val[1], v85.val[1]), v30);
              float32x4_t v29 = vminnmq_f32(vmlaq_f32(vmulq_f32(v85.val[0], v85.val[0]), v47, v47), v29);
              v28 -= 8;
            }
            while (v28);
            float v22 = vminnmvq_f32(vminnmq_f32(v30, v29));
            if (v84 - 1 == v25) {
              goto LABEL_15;
            }
            uint64_t v23 = v25 | 1;
            float32x2_t v21 = (float32x2_t)vextq_s8(v32, v32, 8uLL).u64[0];
          }
          else
          {
            float v22 = 3.4028e38;
            uint64_t v23 = 1;
          }
          unint64_t v48 = v84 - v23;
          unint64_t v49 = (float32x2_t *)&v19[v23];
          do
          {
            float32x2_t v51 = *v49;
            float32x2_t v52 = vsub_f32(*v49, v21);
            float32x2_t v53 = vmul_f32(v52, v52);
            float v54 = 0.0;
            if (vaddv_f32(v53) > 1.0e-15)
            {
              float32x2_t v55 = vmul_f32(vsub_f32(v82, v21), v52);
              float v54 = fminf(fmaxf(vdiv_f32(vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v55, 1), v55), vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v53, 1), v53)).f32[0], 0.0), 1.0);
            }
            float32x2_t v50 = vsub_f32(v82, vmla_n_f32(v21, v52, v54));
            float v22 = fminf(vaddv_f32(vmul_f32(v50, v50)), v22);
            ++v49;
            float32x2_t v21 = v51;
            --v48;
          }
          while (v48);
LABEL_15:
          float v24 = v14 * v22;
          if ((float)(v14 * v22) < 100.0) {
            break;
          }
          if (++v17 >= (unint64_t)*(unsigned int *)(v16 + 20)) {
            goto LABEL_7;
          }
        }
        if (*v18)
        {
          unint64_t v56 = 0;
          do
          {
            uint64_t v57 = geo::codec::vectorTransitLineAlongLink((void *)v16, v56);
            uint64_t v58 = v57;
            if (v4 == v5)
            {
LABEL_34:
              if (v5 < (float *)v6)
              {
                *(void *)uint64_t v5 = v57;
                *((void *)v5 + 1) = v16;
                v5[4] = v24;
                v5 += 6;
              }
              else
              {
                unint64_t v60 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v4) >> 3) + 1;
                if (v60 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * ((v6 - (char *)v4) >> 3) > v60) {
                  unint64_t v60 = 0x5555555555555556 * ((v6 - (char *)v4) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((v6 - (char *)v4) >> 3) >= 0x555555555555555) {
                  unint64_t v61 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v61 = v60;
                }
                if (v61)
                {
                  if (v61 > 0xAAAAAAAAAAAAAAALL) {
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  }
                  double v62 = (char *)operator new(24 * v61);
                }
                else
                {
                  double v62 = 0;
                }
                uint64_t v63 = &v62[8 * (((char *)v5 - (char *)v4) >> 3)];
                *(void *)uint64_t v63 = v58;
                *((void *)v63 + 1) = v16;
                *((float *)v63 + 4) = v24;
                if (v4 == v5)
                {
                  uint64_t v65 = &v62[8 * (((char *)v5 - (char *)v4) >> 3)];
                }
                else
                {
                  double v64 = &v62[8 * (((char *)v5 - (char *)v4) >> 3)];
                  do
                  {
                    uint64_t v65 = v64 - 24;
                    long long v66 = *(_OWORD *)(v5 - 6);
                    *((void *)v64 - 1) = *((void *)v5 - 1);
                    *(_OWORD *)(v64 - 24) = v66;
                    v5 -= 6;
                    v64 -= 24;
                  }
                  while (v5 != v4);
                }
                uint64_t v6 = &v62[24 * v61];
                uint64_t v5 = (float *)(v63 + 24);
                if (v4) {
                  operator delete(v4);
                }
                uint64_t v4 = (float *)v65;
              }
            }
            else
            {
              CGFloat v59 = v4;
              while (*(void *)(*(void *)v59 + 40) != *(void *)(v57 + 40))
              {
                v59 += 6;
                if (v59 == v5) {
                  goto LABEL_34;
                }
              }
              v59[4] = fminf(v24, v59[4]);
            }
            ++v56;
          }
          while (v56 < *v18);
        }
LABEL_7:
        ++v13;
      }
    }
    ++a2;
  }
  while (a2 != a3);
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (v4 != v5)
  {
    std::__introsort<std::_ClassicAlgPolicy,md::TransitLogic::getTransitLineMarkersForSelectionAtGroundPoint(gm::Matrix<double,3,1> const&)::$_0 &,std::pair<md::TransitLineWithLink,float> *,false>((unint64_t)v4, v5, 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v4) >> 3)), 1, v12);
    std::vector<VKTransitLineMarker * {__strong}>::reserve((uint64_t)a1, 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v4) >> 3));
    size_t v67 = v4;
    do
    {
      uint64_t v70 = +[VKTransitLineMarker markerWithFeature:*(void *)v67 transitLink:*((void *)v67 + 1)];
      CGFloat v83 = (void *)v70;
      uint64_t v71 = (uint64_t *)a1[1];
      if ((unint64_t)v71 < a1[2])
      {
        uint64_t v68 = 0;
        CGFloat v83 = 0;
        *uint64_t v71 = v70;
        long long v69 = v71 + 1;
      }
      else
      {
        long long v69 = std::vector<objc_object * {__strong}>::__emplace_back_slow_path<objc_object * {__strong}>(a1, (uint64_t *)&v83);
        uint64_t v68 = v83;
      }
      a1[1] = v69;

      v67 += 6;
    }
    while (v67 != v5);
  }
  if (v4) {
    operator delete(v4);
  }
}

void sub_1A2100D30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void **a10)
{
  std::vector<VKTransitLineMarker * {__strong}>::~vector[abi:nn180100](a10);
  if (v10) {
    operator delete(v10);
  }
  _Unwind_Resume(a1);
}

float std::__introsort<std::_ClassicAlgPolicy,md::TransitLogic::getTransitLineMarkersForSelectionAtGroundPoint(gm::Matrix<double,3,1> const&)::$_0 &,std::pair<md::TransitLineWithLink,float> *,false>(unint64_t a1, float *a2, uint64_t a3, char a4, float result)
{
float std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLogic::getTransitLineMarkersForSelectionAtGroundPoint(gm::Matrix<double,3,1> const&)::$_0 &,std::pair<md::TransitLineWithLink,float> *>(float *a1, float *a2, float *a3, float *a4)
{
  float v4 = a2[4];
  BOOL v5 = a1 + 4;
  BOOL v6 = a3 + 4;
  float result = a3[4];
  if (v4 >= a1[4])
  {
    if (result < v4)
    {
      long long v10 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v10;
      float result = a2[4];
      a2[4] = a3[4];
      a3[4] = result;
      if (a2[4] < *v5)
      {
        long long v11 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)a2 = v11;
        unint64_t v9 = (int *)(a1 + 4);
        float v12 = (int *)(a2 + 4);
LABEL_10:
        int v16 = *v9;
        int *v9 = *v12;
        *float v12 = v16;
        float result = *v6;
      }
    }
  }
  else
  {
    if (result < v4)
    {
      long long v8 = *(_OWORD *)a1;
      *(_OWORD *)a1 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v8;
      unint64_t v9 = (int *)(a1 + 4);
LABEL_9:
      float v12 = (int *)(a3 + 4);
      goto LABEL_10;
    }
    long long v13 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v13;
    float v14 = a1[4];
    a1[4] = a2[4];
    a2[4] = v14;
    float result = *v6;
    if (*v6 < v14)
    {
      long long v15 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v15;
      unint64_t v9 = (int *)(a2 + 4);
      goto LABEL_9;
    }
  }
  if (a4[4] < result)
  {
    long long v17 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v17;
    *(float *)&long long v17 = a3[4];
    a3[4] = a4[4];
    *((_DWORD *)a4 + 4) = v17;
    float result = a3[4];
    if (result < a2[4])
    {
      long long v18 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v18;
      *(float *)&long long v18 = a2[4];
      a2[4] = a3[4];
      *((_DWORD *)a3 + 4) = v18;
      float result = a2[4];
      if (result < *v5)
      {
        long long v19 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)a2 = v19;
        float result = a1[4];
        a1[4] = a2[4];
        a2[4] = result;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLogic::getTransitLineMarkersForSelectionAtGroundPoint(gm::Matrix<double,3,1> const&)::$_0 &,std::pair<md::TransitLineWithLink,float> *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (a2 - a1) >> 3;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if (*(float *)(a2 - 8) < *(float *)(a1 + 16))
      {
        long long v6 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)(a2 - 24) = v6;
        LODWORD(v6) = *(_DWORD *)(a1 + 16);
        *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v6;
      }
      return result;
    case 3uLL:
      unint64_t v7 = (float *)(a1 + 16);
      float v8 = *(float *)(a1 + 16);
      unint64_t v9 = (float *)(a2 - 8);
      float v10 = *(float *)(a2 - 8);
      long long v11 = (_OWORD *)(a1 + 24);
      float v12 = (_OWORD *)(a2 - 24);
      long long v13 = (_DWORD *)(a1 + 40);
      float v14 = *(float *)(a1 + 40);
      if (v14 < v8)
      {
        if (v10 >= v14)
        {
          long long v39 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *v11;
          _OWORD *v11 = v39;
          *(float *)(a1 + 16) = v14;
          *(float *)(a1 + 40) = v8;
          if (*v9 >= v8) {
            return result;
          }
          long long v40 = *v11;
          _OWORD *v11 = *v12;
          *float v12 = v40;
          unint64_t v7 = (float *)(a1 + 40);
        }
        else
        {
          long long v15 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *v12;
          *float v12 = v15;
        }
        long long v13 = (_DWORD *)(a2 - 8);
        goto LABEL_25;
      }
      if (v10 < v14)
      {
        long long v35 = *v11;
        _OWORD *v11 = *v12;
        *float v12 = v35;
        LODWORD(v35) = *v13;
        *long long v13 = *(_DWORD *)v9;
        *(_DWORD *)unint64_t v9 = v35;
        if (*(float *)v13 < *v7)
        {
          long long v36 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *v11;
          _OWORD *v11 = v36;
LABEL_25:
          float v41 = *v7;
          *unint64_t v7 = *(float *)v13;
          *(float *)long long v13 = v41;
          return result;
        }
      }
      return result;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLogic::getTransitLineMarkersForSelectionAtGroundPoint(gm::Matrix<double,3,1> const&)::$_0 &,std::pair<md::TransitLineWithLink,float> *>((float *)a1, (float *)(a1 + 24), (float *)(a1 + 48), (float *)(a2 - 24));
      return 1;
    case 5uLL:
      float v24 = (long long *)(a1 + 24);
      float v25 = (long long *)(a1 + 48);
      int v26 = (long long *)(a1 + 72);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::TransitLogic::getTransitLineMarkersForSelectionAtGroundPoint(gm::Matrix<double,3,1> const&)::$_0 &,std::pair<md::TransitLineWithLink,float> *>((float *)a1, (float *)(a1 + 24), (float *)(a1 + 48), (float *)(a1 + 72));
      if (*(float *)(a2 - 8) < *(float *)(a1 + 88))
      {
        long long v27 = *v26;
        long long *v26 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)(a2 - 24) = v27;
        LODWORD(v27) = *(_DWORD *)(a1 + 88);
        *(_DWORD *)(a1 + 88) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v27;
        float v28 = *(float *)(a1 + 88);
        float v29 = *(float *)(a1 + 64);
        if (v28 < v29)
        {
          long long v30 = *v25;
          long long *v25 = *v26;
          long long *v26 = v30;
          *(float *)(a1 + 64) = v28;
          *(float *)(a1 + 88) = v29;
          float v31 = *(float *)(a1 + 40);
          if (v28 < v31)
          {
            long long v32 = *v24;
            *float v24 = *v25;
            long long *v25 = v32;
            *(float *)(a1 + 40) = v28;
            *(float *)(a1 + 64) = v31;
            float v33 = *(float *)(a1 + 16);
            if (v28 < v33)
            {
              long long v34 = *(_OWORD *)a1;
              *(_OWORD *)a1 = *v24;
              *float v24 = v34;
              *(float *)(a1 + 16) = v28;
              *(float *)(a1 + 40) = v33;
            }
          }
        }
      }
      return 1;
    default:
      int v16 = (float *)(a1 + 16);
      float v17 = *(float *)(a1 + 16);
      uint64_t v18 = a1 + 48;
      long long v19 = (_OWORD *)(a1 + 24);
      float32x4_t v20 = (float *)(a1 + 40);
      float v21 = *(float *)(a1 + 40);
      float v22 = *(float *)(a1 + 64);
      if (v21 < v17)
      {
        if (v22 >= v21)
        {
          long long v42 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *v19;
          _OWORD *v19 = v42;
          *(float *)(a1 + 16) = v21;
          *(float *)(a1 + 40) = v17;
          if (v22 >= v17) {
            goto LABEL_30;
          }
          long long v43 = *v19;
          _OWORD *v19 = *(_OWORD *)v18;
          *(_OWORD *)uint64_t v18 = v43;
          int v16 = (float *)(a1 + 40);
        }
        else
        {
          long long v23 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v18;
          *(_OWORD *)uint64_t v18 = v23;
        }
        float32x4_t v20 = (float *)(a1 + 64);
        goto LABEL_29;
      }
      if (v22 < v21)
      {
        long long v37 = *v19;
        _OWORD *v19 = *(_OWORD *)v18;
        *(_OWORD *)uint64_t v18 = v37;
        float *v20 = v22;
        *(float *)(a1 + 64) = v21;
        if (v22 < v17)
        {
          long long v38 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *v19;
          _OWORD *v19 = v38;
LABEL_29:
          *int v16 = v22;
          float *v20 = v17;
        }
      }
LABEL_30:
      uint64_t v44 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v45 = 0;
      int v46 = 0;
      while (1)
      {
        float v48 = *(float *)(v44 + 16);
        if (v48 < *(float *)(v18 + 16))
        {
          long long v51 = *(_OWORD *)v44;
          uint64_t v49 = v45;
          do
          {
            uint64_t v50 = a1 + v49;
            *(_OWORD *)(v50 + 72) = *(_OWORD *)(a1 + v49 + 48);
            *(_DWORD *)(v50 + 88) = *(_DWORD *)(a1 + v49 + 64);
            if (v49 == -48)
            {
              uint64_t v47 = a1;
              goto LABEL_33;
            }
            v49 -= 24;
          }
          while (v48 < *(float *)(v50 + 40));
          uint64_t v47 = a1 + v49 + 72;
LABEL_33:
          *(_OWORD *)uint64_t v47 = v51;
          *(float *)(v47 + 16) = v48;
          if (++v46 == 8) {
            return v44 + 24 == a2;
          }
        }
        uint64_t v18 = v44;
        v45 += 24;
        v44 += 24;
        if (v44 == a2) {
          return 1;
        }
      }
  }
}

void sub_1A2102378(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2103180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_1A2103338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2103C5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void std::vector<geo::PolylineCoordinate>::__append(char **a1, unint64_t a2)
{
  BOOL v5 = a1[1];
  uint64_t v4 = a1[2];
  long long v6 = v5;
  if (a2 <= (v4 - v5) >> 3)
  {
    if (!a2)
    {
LABEL_19:
      a1[1] = v6;
      return;
    }
    unint64_t v14 = (a2 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v14 >= 7)
    {
      unint64_t v15 = v14 + 1;
      int v16 = v5 + 32;
      uint64_t v17 = v15 & 0x3FFFFFFFFFFFFFF8;
      do
      {
        *(v16 - 2) = xmmword_1A28FE4D0;
        *(v16 - 1) = xmmword_1A28FE4D0;
        *int v16 = xmmword_1A28FE4D0;
        v16[1] = xmmword_1A28FE4D0;
        v16 += 4;
        v17 -= 8;
      }
      while (v17);
      if (v15 == (v15 & 0x3FFFFFFFFFFFFFF8)) {
        goto LABEL_18;
      }
      long long v6 = &v5[8 * (v15 & 0x3FFFFFFFFFFFFFF8)];
    }
    do
    {
      *(void *)long long v6 = 0xBF80000000000000;
      v6 += 8;
    }
    while (v6 != &v5[8 * a2]);
LABEL_18:
    long long v6 = &v5[8 * a2];
    goto LABEL_19;
  }
  unint64_t v7 = *a1;
  uint64_t v8 = v5 - *a1;
  uint64_t v9 = v8 >> 3;
  unint64_t v10 = (v8 >> 3) + a2;
  if (v10 >> 61) {
    abort();
  }
  uint64_t v11 = v4 - v7;
  if (v11 >> 2 > v10) {
    unint64_t v10 = v11 >> 2;
  }
  if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v12 = v10;
  }
  if (v12)
  {
    if (v12 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    long long v13 = (char *)operator new(8 * v12);
  }
  else
  {
    long long v13 = 0;
  }
  uint64_t v18 = &v13[8 * v9];
  long long v19 = &v18[8 * a2];
  unint64_t v20 = (a2 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  float v21 = v18;
  if (v20 >= 7)
  {
    uint64_t v22 = (v20 + 1) & 0x3FFFFFFFFFFFFFF8;
    long long v23 = v18 + 32;
    uint64_t v24 = v22;
    do
    {
      *(v23 - 2) = xmmword_1A28FE4D0;
      *(v23 - 1) = xmmword_1A28FE4D0;
      _OWORD *v23 = xmmword_1A28FE4D0;
      v23[1] = xmmword_1A28FE4D0;
      v23 += 4;
      v24 -= 8;
    }
    while (v24);
    if (v20 + 1 == v22) {
      goto LABEL_27;
    }
    float v21 = &v18[8 * v22];
  }
  do
  {
    *(void *)float v21 = 0xBF80000000000000;
    v21 += 8;
  }
  while (v21 != v19);
LABEL_27:
  float v25 = &v13[8 * v12];
  if (v5 != v7)
  {
    unint64_t v26 = v5 - v7 - 8;
    if (v26 < 0x58) {
      goto LABEL_43;
    }
    if ((unint64_t)(v5 - &v13[v8]) < 0x20) {
      goto LABEL_43;
    }
    uint64_t v27 = (v26 >> 3) + 1;
    long long v6 = &v5[-8 * (v27 & 0x3FFFFFFFFFFFFFFCLL)];
    float v28 = &v13[8 * v9 - 16];
    float v29 = (long long *)(v5 - 16);
    uint64_t v30 = v27 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v31 = *v29;
      *((_OWORD *)v28 - 1) = *(v29 - 1);
      *(_OWORD *)float v28 = v31;
      v28 -= 32;
      v29 -= 2;
      v30 -= 4;
    }
    while (v30);
    v18 -= 8 * (v27 & 0x3FFFFFFFFFFFFFFCLL);
    if (v27 != (v27 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_43:
      do
      {
        uint64_t v32 = *((void *)v6 - 1);
        v6 -= 8;
        *((void *)v18 - 1) = v32;
        v18 -= 8;
      }
      while (v6 != v7);
    }
  }
  float v33 = *a1;
  *a1 = v18;
  a1[1] = v19;
  a1[2] = v25;
  if (v33)
  {
    operator delete(v33);
  }
}

void sub_1A210412C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'md::MuninRoadLabel::collidesWithObject(md::MuninRoadLabel *this, const md::CollisionObject *a2)
{
  uint64_t result = *((void *)this + 4);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const md::CollisionObject *))(*(void *)result + 464))(result, a2);
  }
  return result;
}

uint64_t non-virtual thunk to'md::MuninRoadLabel::collidesWithItem(md::MuninRoadLabel *this, const md::LabelCollidableItem *a2)
{
  return (*(uint64_t (**)(void, const md::LabelCollidableItem *, void))(**((void **)this + 4) + 456))(*((void *)this + 4), a2, 0);
}

uint64_t non-virtual thunk to'md::MuninRoadLabel::collisionBounds(md::MuninRoadLabel *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 4) + 248))();
}

void non-virtual thunk to'md::MuninRoadLabel::~MuninRoadLabel(md::MuninRoadLabel *this)
{
  md::MuninRoadLabel::~MuninRoadLabel((md::MuninRoadLabel *)((char *)this - 40));
  JUMPOUT(0x1A6239270);
}

{
  md::MuninRoadLabel::~MuninRoadLabel((md::MuninRoadLabel *)((char *)this - 40));
}

void md::MuninRoadLabel::~MuninRoadLabel(md::MuninRoadLabel *this)
{
  *(void *)this = &unk_1EF534060;
  *((void *)this + 5) = &unk_1EF5340A0;
  if (*((unsigned char *)this + 355)) {
    *(unsigned char *)(*((void *)this + 41) + 285) = 1;
  }
  atomic_fetch_add(md::MuninRoadLabel::_totalLabels, 0xFFFFFFFF);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 71);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 69);
    if (!v3) {
      goto LABEL_9;
    }
  }
  else
  {
    unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 69);
    if (!v3) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_9:
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 63);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    BOOL v5 = (std::__shared_weak_count *)*((void *)this + 42);
    if (!v5) {
      goto LABEL_15;
    }
  }
  else
  {
    BOOL v5 = (std::__shared_weak_count *)*((void *)this + 42);
    if (!v5) {
      goto LABEL_15;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_15:
  uint64_t v6 = *((void *)this + 39);
  *((void *)this + 39) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  unint64_t v7 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v8) {
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v8) {
      goto LABEL_23;
    }
  }
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_23:
  uint64_t v9 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  unint64_t v10 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  *(void *)this = &unk_1EF554058;
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v11)
  {
    if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
}

{
  uint64_t vars8;

  md::MuninRoadLabel::~MuninRoadLabel(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::MuninRoadLabel::collidesWithItem(md::MuninRoadLabel *this, const md::LabelCollidableItem *a2)
{
  return (*(uint64_t (**)(void, const md::LabelCollidableItem *, void))(**((void **)this + 9) + 456))(*((void *)this + 9), a2, 0);
}

uint64_t md::MuninRoadLabel::collidesWithObject(md::MuninRoadLabel *this, const md::CollisionObject *a2)
{
  uint64_t result = *((void *)this + 9);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const md::CollisionObject *))(*(void *)result + 464))(result, a2);
  }
  return result;
}

uint64_t md::MuninRoadLabel::collisionBounds(md::MuninRoadLabel *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 9) + 248))();
}

uint64_t md::MuninRoadLabel::isCollidable(md::MuninRoadLabel *this)
{
  return *((unsigned __int8 *)this + 299);
}

uint64_t md::MuninRoadLabelCollisionItem::didCollide(md::MuninRoadLabelCollisionItem *this)
{
  return *((unsigned __int8 *)this + 64);
}

uint64_t md::LabelCollisionItemBase::isReserveSpaceItem(md::LabelCollisionItemBase *this)
{
  return 0;
}

uint64_t md::LabelCollisionItemBase::reserveSpaceItem(md::LabelCollisionItemBase *this)
{
  return 0;
}

uint64_t md::MuninRoadLabelCollisionItem::dedupingGroupSubID(md::MuninRoadLabelCollisionItem *this)
{
  return *(unsigned __int16 *)(*((void *)this + 7) + 36);
}

uint64_t md::MuninRoadLabelCollisionItem::dedupingGroup(md::MuninRoadLabelCollisionItem *this)
{
  return *(void *)(*((void *)this + 7) + 24);
}

BOOL md::MuninRoadLabelCollisionItem::outranksItem(md::MuninRoadLabelCollisionItem *this, const md::LabelCollisionItemBase *a2)
{
  return *((unsigned __int8 *)this + 52) <= *((unsigned __int8 *)a2 + 52);
}

uint64_t md::MuninRoadLabelCollisionItem::setCollisionResult(uint64_t a1, unsigned __int8 *a2)
{
  *(unsigned char *)(a1 + 64) = a2[1];
  return md::MuninRoadLabel::setCollisionResult(*(void *)(a1 + 56), a2);
}

uint64_t md::MuninRoadLabel::setCollisionResult(uint64_t a1, unsigned __int8 *a2)
{
  *(void *)(a1 + 320) = *((void *)a2 + 1);
  int v3 = a2[1];
  int v4 = v3 ^ 1;
  uint64_t result = *(void *)(a1 + 24);
  if (!result) {
    goto LABEL_5;
  }
  if (a2[1])
  {
    if (*a2) {
      *(unsigned char *)(a1 + 494) = 21;
    }
LABEL_5:
    if (*(unsigned __int8 *)(a1 + 300) == v4) {
      goto LABEL_23;
    }
    uint64_t v6 = (unsigned __int8 *)(a1 + 300);
    *(unsigned char *)(a1 + 300) = v4;
    if (v3)
    {
      int v7 = *a2;
      if (!*a2) {
        *(unsigned char *)(a1 + 301) = 1;
      }
      if (*(unsigned char *)(a1 + 493) != 2) {
        goto LABEL_22;
      }
      if (v7) {
        char v8 = 21;
      }
      else {
        char v8 = 20;
      }
      *(unsigned char *)(a1 + 493) = 1;
      *(unsigned char *)(a1 + 494) = v8;
      goto LABEL_19;
    }
LABEL_16:
    if (!*(unsigned char *)(a1 + 299))
    {
LABEL_22:
      int v4 = *v6;
LABEL_23:
      if (!v4) {
        return result;
      }
      goto LABEL_24;
    }
    int v9 = byte_1A29C6350[*(char *)(a1 + 493) + 12];
    if (v9 == 255)
    {
      if (*(unsigned char *)(a1 + 493) == 2)
      {
LABEL_20:
        unsigned __int8 v10 = atomic_load((unsigned __int8 *)(a1 + 353));
        if ((v10 & 1) == 0) {
          *(unsigned char *)(a1 + 356) = 2 * (*(unsigned char *)(a1 + 493) == 2);
        }
        goto LABEL_22;
      }
    }
    else
    {
      *(unsigned char *)(a1 + 493) = v9;
      *(unsigned char *)(a1 + 494) = 37;
      if (v9 == 2) {
        goto LABEL_20;
      }
    }
LABEL_19:
    *(unsigned char *)(a1 + 299) = 0;
    goto LABEL_20;
  }
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)result + 32))(result, a1, *(unsigned __int8 *)(a1 + 36));
  if (*(unsigned __int8 *)(a1 + 300) != v4)
  {
    uint64_t v6 = (unsigned __int8 *)(a1 + 300);
    *(unsigned char *)(a1 + 300) = v4;
    goto LABEL_16;
  }
LABEL_24:
  uint64_t result = *(void *)(a1 + 72);
  if (result)
  {
    uint64_t v11 = *(uint64_t (**)(void))(*(void *)result + 448);
    return v11();
  }
  return result;
}

uint64_t md::LabelCollisionItemBase::nextPlacementCandidate()
{
  return 0;
}

uint64_t md::MuninRoadLabelCollisionItem::placementCandidate(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  uint64_t v2 = *(void *)(v1 + 72);
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 440))(v2);
  }
  return v1 + 40;
}

uint64_t md::MuninRoadLabelCollisionItem::isCollidable(md::MuninRoadLabelCollisionItem *this)
{
  return *(unsigned __int8 *)(*((void *)this + 7) + 299);
}

uint64_t md::MuninRoadLabelCollisionItem::isHighlighted(md::MuninRoadLabelCollisionItem *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(*((void *)this + 7) + 298));
  return v1 & 1;
}

uint64_t md::MuninRoadLabelCollisionItem::collidesWithObject(md::MuninRoadLabelCollisionItem *this, const md::CollisionObject *a2)
{
  uint64_t result = *(void *)(*((void *)this + 7) + 72);
  if (result) {
    return (*(uint64_t (**)(uint64_t, const md::CollisionObject *))(*(void *)result + 464))(result, a2);
  }
  return result;
}

void md::MuninRoadLabelCollisionItem::~MuninRoadLabelCollisionItem(md::MuninRoadLabelCollisionItem *this)
{
}

int32x2_t *md::MuninRoadLabel::setActive(int32x2_t *this, int a2)
{
  if (this[38].u8[0] != a2)
  {
    uint64_t v2 = this;
    this[38].i8[0] = a2;
    if ((a2 & 1) == 0)
    {
      int v3 = (void *)this[3];
      if (v3)
      {
        int v4 = (void *)v3[2];
        BOOL v5 = (void *)v3[1];
        if (v5 != v4)
        {
          while ((int32x2_t *)*v5 != this)
          {
            if (++v5 == v4)
            {
              BOOL v5 = (void *)v3[2];
              break;
            }
          }
        }
        if (v5 != v4)
        {
          uint64_t v6 = v5 + 1;
          if (v5 + 1 != v4)
          {
            do
            {
              if ((int32x2_t *)*v6 != this) {
                *v5++ = *v6;
              }
              ++v6;
            }
            while (v6 != v4);
            int v4 = (void *)v3[2];
          }
        }
        if (v5 != v4) {
          int8x8_t v3[2] = v5;
        }
        this = (int32x2_t *)(*(uint64_t (**)(void *, int32x2_t *))(*v3 + 48))(v3, this);
        v2[3] = 0;
      }
      v2[43] = vdup_n_s32(0xC2C80000);
      if (v2[44].i8[3])
      {
        *(unsigned char *)(*(void *)&v2[41] + 285) = 1;
        v2[44].i8[3] = 0;
      }
    }
  }
  return this;
}

void md::MuninRoadLabel::updateStateMachineForDisplay(uint64_t a1, int a2, char a3, uint64_t a4, __n128 a5)
{
  if (a4)
  {
    char v6 = ((0x27u >> (a2 - 3)) & 1) != 0 ? 0x80808050508uLL >> (8 * (a2 - 3)) : a2;
    char v7 = (a2 - 3) <= 5 ? v6 : a2;
    if (!*(unsigned char *)(a4 + 3382)) {
      LOBYTE(a2) = v7;
    }
  }
  int v8 = byte_1A29C636E[4 * a2 + *(char *)(a1 + 538)];
  if (v8 == 255)
  {
    int v8 = *(unsigned __int8 *)(a1 + 538);
    if (*(unsigned char *)(a1 + 538)) {
      goto LABEL_12;
    }
LABEL_15:
    *(_DWORD *)(a1 + 264) = 0;
    int v9 = (float (**)(__n128))(a1 + 288);
    a5.n128_u64[0] = 0;
    goto LABEL_16;
  }
  *(unsigned char *)(a1 + 538) = v8;
  *(unsigned char *)(a1 + 539) = a3;
  if (!v8) {
    goto LABEL_15;
  }
LABEL_12:
  if (v8 != 3) {
    goto LABEL_17;
  }
  *(_DWORD *)(a1 + 264) = 1065353216;
  int v9 = (float (**)(__n128))(a1 + 280);
  a5.n128_u32[0] = 1.0;
LABEL_16:
  *(float *)(a1 + 268) = (*v9)(a5);
LABEL_17:
  int v10 = *(unsigned __int8 *)(a1 + 538);
  if (v10 == 1)
  {
    uint64_t v14 = *(void *)(a1 + 560);
    if (!v14 || (float v15 = *(float *)(v14 + 8), v15 == 0.0)) {
      float v15 = 0.4;
    }
    *(void *)(a1 + 280) = EaseQuadOut;
    *(float *)(a1 + 272) = fmaxf(v15, 0.000001);
    float v13 = EaseQuadOut(*(float *)(a1 + 264));
  }
  else
  {
    if (v10 != 2) {
      return;
    }
    uint64_t v11 = *(void *)(a1 + 560);
    if (!v11 || (float v12 = *(float *)(v11 + 12), v12 == 0.0)) {
      float v12 = 0.4;
    }
    *(void *)(a1 + 288) = EaseQuadIn;
    *(float *)(a1 + 276) = fmaxf(v12, 0.000001);
    float v13 = EaseQuadIn(*(float *)(a1 + 264));
  }
  *(float *)(a1 + 268) = v13;
}

void std::__shared_ptr_emplace<md::OcclusionQuery>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  int v3 = (void *)a1[4];
  if (v2 != v3)
  {
    do
    {
      int v4 = (void *)v2[10];
      if (v4 != (void *)v2[12]) {
        free(v4);
      }
      BOOL v5 = (void *)v2[1];
      if (v5 != (void *)v2[3]) {
        free(v5);
      }
      v2 += 31;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)a1[3];
  }
  if (v2 != (void *)a1[5])
  {
    free(v2);
  }
}

void std::__shared_ptr_emplace<md::OcclusionQuery>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FD48;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::OcclusionQuery>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FD48;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::MuninRoadLabel::debugString(md::MuninRoadLabel *this, md::LabelManager *a2, uint64_t a3)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v52);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"RoadLabel:\n", 11);
  if (*((float *)a2 + 120) != 0.0 || *((float *)a2 + 121) != 0.0)
  {
    uint64_t v6 = v52[0];
    *(_DWORD *)((char *)&v52[1] + *(void *)(v52[0] - 24)) = *(_DWORD *)((unsigned char *)&v52[1] + *(void *)(v52[0] - 24)) & 0xFFFFFEFB | 4;
    *(void *)((char *)&v52[2] + *(void *)(v6 - 24)) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"  Offset: elev=", 15);
    char v7 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)" nrml=", 6);
    int v8 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v8, (uint64_t)"\n", 1);
  }
  *(void *)((char *)&v52[2] + *(void *)(v52[0] - 24)) = 2;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"  Zoom: Cur=", 12);
  int v9 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v9, (uint64_t)" Min=", 5);
  int v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)" Max=", 5);
  std::ostream::operator<<();
  *(void *)((char *)&v52[2] + *(void *)(v52[0] - 24)) = 1;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)", Dist=", 7);
  uint64_t v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)"\n", 1);
  if (*((unsigned char *)a2 + 540))
  {
    *(void *)((char *)&v52[2] + *(void *)(v52[0] - 24)) = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"  PerspScale: Mode=", 19);
    float v12 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)" Value=", 7);
    float v13 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)"\n", 1);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"  Staging: State=", 17);
  unint64_t v14 = *((unsigned __int8 *)a2 + 493);
  if (v14 > 2) {
    float v15 = "<NONE>";
  }
  else {
    float v15 = off_1E5A93878[v14];
  }
  size_t v16 = strlen(v15);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)v15, v16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)" Outcome=", 9);
  md::stringFromLabelOutcome((uint64_t)&__p, *((unsigned __int8 *)a2 + 494));
  if (v50 >= 0) {
    p_p = &__p;
  }
  else {
    p_p = __p;
  }
  if (v50 >= 0) {
    uint64_t v18 = HIBYTE(v50);
  }
  else {
    uint64_t v18 = v49;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)p_p, v18);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"\n", 1);
  if (SHIBYTE(v50) < 0) {
    operator delete(__p);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"  Display: State=", 17);
  unint64_t v19 = *((unsigned __int8 *)a2 + 538);
  if (v19 > 3) {
    unint64_t v20 = "<NONE>";
  }
  else {
    unint64_t v20 = off_1E5A93890[v19];
  }
  size_t v21 = strlen(v20);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)v20, v21);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)" Outcome=", 9);
  md::stringFromLabelOutcome((uint64_t)&__p, *((unsigned __int8 *)a2 + 539));
  if (v50 >= 0) {
    uint64_t v22 = &__p;
  }
  else {
    uint64_t v22 = __p;
  }
  if (v50 >= 0) {
    uint64_t v23 = HIBYTE(v50);
  }
  else {
    uint64_t v23 = v49;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)v22, v23);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)" isDisplayLabel=", 16);
  uint64_t v24 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)" isActiveForDisplay=", 20);
  float v25 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v25, (uint64_t)"\n", 1);
  if (SHIBYTE(v50) < 0)
  {
    operator delete(__p);
    uint64_t v26 = *((void *)a2 + 10);
    if (!v26)
    {
LABEL_35:
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"No Style\n", 9);
      goto LABEL_36;
    }
  }
  else
  {
    uint64_t v26 = *((void *)a2 + 10);
    if (!v26) {
      goto LABEL_35;
    }
  }
  if (!*(unsigned char *)(v26 + 125) || *(unsigned __int8 *)(v26 + 136) == 255) {
    goto LABEL_35;
  }
  uint64_t v27 = *(void *)(v26 + 280);
  if (v27)
  {
    if (vabds_f32(*(float *)(v27 + 8), *(float *)(v26 + 104)) >= 0.01)
    {
      md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)v26, v27, 0);
      uint64_t v27 = *(void *)(v26 + 280);
    }
  }
  else
  {
    uint64_t v27 = md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(v26, 0);
    *(void *)(v26 + 280) = v27;
  }
  uint64_t v42 = *(void *)v27;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"  Style: ", 9);
  int v43 = *(char *)(v42 + 95);
  if (v43 >= 0) {
    uint64_t v44 = v42 + 72;
  }
  else {
    uint64_t v44 = *(void *)(v42 + 72);
  }
  if (v43 >= 0) {
    uint64_t v45 = *(unsigned __int8 *)(v42 + 95);
  }
  else {
    uint64_t v45 = *(void *)(v42 + 80);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, v44, v45);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"/", 1);
  *(void *)((char *)&v52[2] + *(void *)(v52[0] - 24)) = 2;
  std::ostream::operator<<();
  if (*(float *)(v42 + 96) != 0.0)
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"/", 1);
    std::ostream::operator<<();
  }
  if (*(unsigned char *)(v42 + 109)) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"/up", 3);
  }
  if (*(unsigned char *)(v42 + 110)) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"/down", 5);
  }
  if (*(unsigned char *)(v42 + 111)) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"/title", 6);
  }
  if (*(unsigned char *)(v42 + 108)) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"/ri", 3);
  }
  if (*(unsigned char *)(v42 + 112)) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"/sc", 3);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"    font:", 9);
  md::FontOptions::debugString(&__p, (long long *)(v42 + 72), *(grl::FontManager **)[*(id *)(a3 + 96) grlFontManager]);
  if (v50 >= 0) {
    int v46 = &__p;
  }
  else {
    int v46 = __p;
  }
  if (v50 >= 0) {
    uint64_t v47 = HIBYTE(v50);
  }
  else {
    uint64_t v47 = v49;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)v46, v47);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"\n", 1);
  if (SHIBYTE(v50) < 0) {
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v51 + 40))(v51, __p, v50 & 0x7FFFFFFFFFFFFFFFLL);
  }
LABEL_36:
  uint64_t v28 = *((void *)a2 + 40);
  if (v28
    && *(unsigned char *)(v28 + 52) == 4
    && ((uint64_t v29 = *(void *)(v28 + 56),
         std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"  Collided with '", 17), md::LabelFeature::debugName((md::LabelFeature *)&__p, *(void **)(v29 + 8)), v50 >= 0)? (uint64_t v30 = &__p): (uint64_t v30 = __p), v50 >= 0 ? (v31 = HIBYTE(v50)) : (v31 = v49), std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)v30, v31), std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"'\n", 2), SHIBYTE(v50) < 0))
  {
    (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v51 + 40))(v51, __p, v50 & 0x7FFFFFFFFFFFFFFFLL);
    if (!*((void *)a2 + 8)) {
      goto LABEL_54;
    }
  }
  else if (!*((void *)a2 + 8))
  {
    goto LABEL_54;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"\n", 1);
  (*(void (**)(void **__return_ptr))(**((void **)a2 + 8) + 792))(&__p);
  if (v50 >= 0) {
    uint64_t v32 = &__p;
  }
  else {
    uint64_t v32 = __p;
  }
  if (v50 >= 0) {
    uint64_t v33 = HIBYTE(v50);
  }
  else {
    uint64_t v33 = v49;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)v32, v33);
  if (SHIBYTE(v50) < 0) {
    operator delete(__p);
  }
LABEL_54:
  if ((v59 & 0x10) != 0)
  {
    unint64_t v35 = v58;
    if (v58 < v55)
    {
      unint64_t v58 = v55;
      unint64_t v35 = v55;
    }
    long long v36 = (const void **)&v54;
  }
  else
  {
    if ((v59 & 8) == 0)
    {
      size_t v34 = 0;
      *((unsigned char *)this + 23) = 0;
      goto LABEL_69;
    }
    long long v36 = (const void **)v53;
    unint64_t v35 = v53[2];
  }
  long long v37 = *v36;
  size_t v34 = v35 - (void)*v36;
  if (v34 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v34 >= 0x17)
  {
    uint64_t v38 = (v34 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v34 | 7) != 0x17) {
      uint64_t v38 = v34 | 7;
    }
    uint64_t v39 = v38 + 1;
    long long v40 = (md::MuninRoadLabel *)operator new(v38 + 1);
    *((void *)this + 1) = v34;
    *((void *)this + 2) = v39 | 0x8000000000000000;
    *(void *)this = v40;
    this = v40;
    goto LABEL_68;
  }
  *((unsigned char *)this + 23) = v34;
  if (v34) {
LABEL_68:
  }
    memmove(this, v37, v34);
LABEL_69:
  *((unsigned char *)this + v34) = 0;
  v52[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v52 + *(void *)(v52[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v52[1] = MEMORY[0x1E4FBA470] + 16;
  if (v57 < 0) {
    operator delete(v56);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v60);
}

void sub_1A2105628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, char a17)
{
}

uint64_t md::MuninRoadLabel::debugDraw(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a1 + 72);
  if (result)
  {
    BOOL v5 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)result + 248))(result);
    *(_DWORD *)(a2 + 8) = *v5;
    *(_DWORD *)(a2 + 12) = v5[1];
    uint64_t v13 = *(void *)(a2 + 8);
    uint64_t v6 = v13;
    char v7 = (float *)(v5 + 2);
    *(_DWORD *)(a2 + 8) = v5[2];
    *(_DWORD *)(a2 + 12) = v5[3];
    int v8 = v5[3];
    float v11 = *(float *)&v6;
    int v12 = v8;
    ggl::DebugConsole::drawLine(a2, &v11);
    ggl::DebugConsole::drawLine(a2, (float *)&v13);
    float v11 = *v7;
    int v12 = HIDWORD(v6);
    ggl::DebugConsole::drawLine(a2, &v11);
    v9.n128_f32[0] = ggl::DebugConsole::drawLine(a2, v7);
    int v10 = *(uint64_t (**)(__n128))(**(void **)(a1 + 72) + 768);
    return v10(v9);
  }
  return result;
}

uint64_t md::ARSceneLogic::debugConsoleString@<X0>(md::LayoutContext *a1@<X3>, uint64_t a2@<X0>, md::PendingSceneLogic *a3@<X8>)
{
  return md::PendingSceneLogic::createDebugConsoleString(a3, a1, *(md::SceneContext **)(a2 + 120), a1);
}

void md::ARSceneLogic::runBeforeLayout(uint64_t a1, md::LayoutContext *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v6 = *a3;
  md::SceneStateManager::clear(*(md::SceneStateManager **)(a1 + 536));
  double v7 = *(double *)(a1 + 320);
  double v8 = *(double *)(a1 + 160);
  int v9 = *(_DWORD *)(a1 + 400);
  char v10 = *(unsigned char *)(a1 + 240);
  double v11 = *(double *)(v6 + 8);
  double v12 = *(double *)(v6 + 16);
  double v13 = v11 * 0.5;
  long double v14 = tan(v11 * 0.5 + 0.785398163);
  double v15 = v12 * 0.159154943 + 0.5;
  double v16 = log(v14) * 0.159154943 + 0.5;
  long double v17 = cos(v11 + v11) * -559.82 + 111132.92;
  long double v18 = v17 + cos(v11 * 4.0) * 1.175;
  long double v19 = v18 + cos(v11 * 6.0) * -0.0023;
  long double v20 = tan(v11 * 0.5 + 0.78103484);
  double v21 = log(v20);
  long double v22 = tan(v13 + 0.789761487);
  *(double *)&long long v23 = fabs((log(v22) - v21) * 0.159154943) / v19;
  int v24 = 1 << v10;
  signed int v25 = vcvtmd_s64_f64((v15 - *(double *)&v23 * v8) * (double)(1 << v10));
  int v26 = v24 + ~vcvtmd_s64_f64((*(double *)&v23 * v8 + v16) * (double)v24);
  unsigned int v27 = vcvtmd_s64_f64((v16 - *(double *)&v23 * v8) * (double)(1 << v10));
  signed int v28 = vcvtmd_s64_f64((*(double *)&v23 * v8 + v15) * (double)(1 << v10));
  *(_OWORD *)long long v199 = 0u;
  *(_OWORD *)uint64_t v200 = 0u;
  float v201 = 1.0;
  *(_OWORD *)size_t v203 = 0u;
  *(_OWORD *)uint64_t v204 = 0u;
  *(_OWORD *)std::string __p = 0u;
  BOOL v29 = v26 <= (int)((1 << v10) + ~v27) && v25 <= v28;
  uint64_t v192 = a1;
  uint64_t v190 = a2;
  if (!v29)
  {
    long long v197 = 0;
    uint64_t v30 = 0;
    goto LABEL_6;
  }
  unsigned __int8 v191 = v9;
  unint64_t v55 = 0;
  unint64_t v56 = 0;
  char v57 = 0;
  double v58 = *(double *)&v23 * v7;
  unsigned int v193 = v24 - v27;
  unint64_t v59 = (v28 + 1);
  long long v197 = 0;
  signed int v194 = v25;
  while (1)
  {
    if (v197 == v57) {
      uint64_t v61 = 0;
    }
    else {
      uint64_t v61 = 170 * (v197 - v57) - 1;
    }
    unint64_t v62 = (unint64_t)&v55[v56];
    if ((char *)v61 == &v55[v56])
    {
      std::deque<geo::QuadTile>::__add_back_capacity((uint64_t)__p);
      unint64_t v56 = (unint64_t)v204[0];
      unint64_t v55 = (char *)v204[1];
      char v57 = (void **)__p[1];
      long long v197 = (void **)v203[0];
      unint64_t v62 = (unint64_t)v204[0] + (unint64_t)v204[1];
    }
    unint64_t v60 = (unint64_t)v57[v62 / 0xAA] + 24 * (v62 % 0xAA);
    *(unsigned char *)unint64_t v60 = -1;
    *(unsigned char *)(v60 + 1) = v10;
    *(_DWORD *)(v60 + 4) = v26;
    *(_DWORD *)(v60 + 8) = v25;
    v204[1] = ++v55;
    if (v59 == ++v25)
    {
      ++v26;
      signed int v25 = v194;
      if (v26 == v193) {
        break;
      }
    }
  }
  if (v55)
  {
    uint64_t v30 = v57;
    while (1)
    {
      float v63 = (unsigned __int8 *)v30[v56 / 0xAA] + 24 * (v56 % 0xAA);
      uint64_t v64 = v63[1];
      uint64_t v65 = *v63;
      *(void *)&long long v23 = *(void *)(v63 + 4);
      long long v195 = v23;
      --v55;
      unint64_t v66 = v56 + 1;
      v204[0] = (void *)(v56 + 1);
      v204[1] = v55;
      if (v56 + 1 >= 0x154)
      {
        unint64_t v67 = *v30++;
        operator delete(v67);
        unint64_t v66 = v56 - 169;
        __p[1] = v30;
        v204[0] = (void *)(v56 - 169);
      }
      if (v64 >= v191)
      {
        *((void *)&v23 + 1) = *((void *)&v195 + 1);
        int v70 = v195;
        int v68 = DWORD1(v195);
      }
      else
      {
        int v68 = DWORD1(v195);
        double v69 = 1.0 / (double)(1 << v64);
        int v70 = v195;
        double v71 = v69 * (double)SDWORD1(v195);
        double v72 = v69 * (double)((1 << v64) + ~v195);
        double v73 = v71 + v69;
        double v74 = v72 + v69;
        BOOL v75 = v73 < v71 || v74 < v72;
        if (!v75 && v58 != 0.0)
        {
          double v76 = fmax(v15 - v73, v71 - v15);
          double v77 = fmax(v16 - v74, v72 - v16);
          BOOL v78 = v76 < v58 && v77 < v58;
          if (v78 && (v76 <= 0.0 || v77 <= 0.0 || v76 * v76 + v77 * v77 < v58 * v58))
          {
            BOOL v79 = v197;
            if (v197 == v30) {
              uint64_t v80 = 0;
            }
            else {
              uint64_t v80 = 170 * (v197 - v30) - 1;
            }
            unint64_t v81 = (unint64_t)&v55[v66];
            if ((char *)v80 == &v55[v66])
            {
              std::deque<geo::QuadTile>::__add_back_capacity((uint64_t)__p);
              unint64_t v66 = (unint64_t)v204[0];
              unint64_t v55 = (char *)v204[1];
              uint64_t v30 = (void **)__p[1];
              BOOL v79 = (void **)v203[0];
              unint64_t v81 = (unint64_t)v204[0] + (unint64_t)v204[1];
            }
            char v82 = v64 + 1;
            long long v83 = v195;
            *(int32x2_t *)&long long v83 = vadd_s32(*(int32x2_t *)&v83, *(int32x2_t *)&v83);
            unint64_t v84 = (unint64_t)v30[v81 / 0xAA] + 24 * (v81 % 0xAA);
            *(unsigned char *)unint64_t v84 = v65;
            *(unsigned char *)(v84 + 1) = v82;
            long long v196 = v83;
            *(void *)(v84 + 4) = v83;
            float32x4x2_t v85 = v55 + 1;
            v204[1] = v55 + 1;
            float v86 = v79;
            int v87 = &v55[v66 + 1];
            if ((char *)(170 * (v79 - v30) - 1) == v87)
            {
              std::deque<geo::QuadTile>::__add_back_capacity((uint64_t)__p);
              unint64_t v66 = (unint64_t)v204[0];
              float32x4x2_t v85 = (char *)v204[1];
              uint64_t v30 = (void **)__p[1];
              float v86 = (void **)v203[0];
              int v87 = (char *)v204[0] + (unint64_t)v204[1];
            }
            unint64_t v88 = (unint64_t)v30[(unint64_t)v87 / 0xAA] + 24 * ((unint64_t)v87 % 0xAA);
            *(unsigned char *)unint64_t v88 = v65;
            *(unsigned char *)(v88 + 1) = v82;
            *(_DWORD *)(v88 + 4) = v196;
            *(_DWORD *)(v88 + 8) = DWORD1(v196) | 1;
            float v89 = v85 + 1;
            v204[1] = v89;
            unint64_t v90 = (unint64_t)&v89[v66];
            if ((char *)(170 * (v86 - v30) - 1) == &v89[v66])
            {
              std::deque<geo::QuadTile>::__add_back_capacity((uint64_t)__p);
              unint64_t v66 = (unint64_t)v204[0];
              float v89 = (char *)v204[1];
              uint64_t v30 = (void **)__p[1];
              float v86 = (void **)v203[0];
              unint64_t v90 = (unint64_t)v204[0] + (unint64_t)v204[1];
            }
            unint64_t v111 = (unint64_t)v30[v90 / 0xAA] + 24 * (v90 % 0xAA);
            *(unsigned char *)unint64_t v111 = v65;
            *(unsigned char *)(v111 + 1) = v82;
            *(_DWORD *)(v111 + 4) = v196 | 1;
            *(_DWORD *)(v111 + 8) = DWORD1(v196);
            int64_t v112 = v89 + 1;
            v204[1] = v112;
            long long v197 = v86;
            unint64_t v113 = (unint64_t)&v112[v66];
            if ((char *)(170 * (v86 - v30) - 1) == &v112[v66])
            {
              std::deque<geo::QuadTile>::__add_back_capacity((uint64_t)__p);
              unint64_t v66 = (unint64_t)v204[0];
              int64_t v112 = (char *)v204[1];
              uint64_t v30 = (void **)__p[1];
              long long v197 = (void **)v203[0];
              unint64_t v113 = (unint64_t)v204[0] + (unint64_t)v204[1];
            }
            *((void *)&v23 + 1) = *((void *)&v196 + 1);
            unint64_t v114 = (unint64_t)v30[v113 / 0xAA] + 24 * (v113 % 0xAA);
            *(unsigned char *)unint64_t v114 = v65;
            *(unsigned char *)(v114 + 1) = v82;
            *(void *)(v114 + 4) = v196 | 0x100000001;
            unint64_t v55 = v112 + 1;
            v204[1] = v112 + 1;
            goto LABEL_59;
          }
        }
      }
      unint64_t v91 = (v64
           - 0x61C8864680B583EBLL
           + ((v65 - 0x61C8864680B583EBLL) << 6)
           + ((unint64_t)(v65 - 0x61C8864680B583EBLL) >> 2)) ^ (v65 - 0x61C8864680B583EBLL);
      unint64_t v92 = (v70 - 0x61C8864680B583EBLL + (v91 << 6) + (v91 >> 2)) ^ v91;
      unint64_t v93 = (v68 - 0x61C8864680B583EBLL + (v92 << 6) + (v92 >> 2)) ^ v92;
      unint64_t v94 = (unint64_t)v199[1];
      if (v199[1])
      {
        uint8x8_t v95 = (uint8x8_t)vcnt_s8((int8x8_t)v199[1]);
        v95.i16[0] = vaddlv_u8(v95);
        if (v95.u32[0] > 1uLL)
        {
          unint64_t v59 = (v68 - 0x61C8864680B583EBLL + (v92 << 6) + (v92 >> 2)) ^ v92;
          if ((void *)v93 >= v199[1]) {
            unint64_t v59 = v93 % (unint64_t)v199[1];
          }
        }
        else
        {
          unint64_t v59 = v93 & ((unint64_t)v199[1] - 1);
        }
        uint64_t v96 = (uint64_t **)*((void *)v199[0] + v59);
        if (v96)
        {
          unint64_t v97 = *v96;
          if (v97)
          {
            if (v95.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v99 = v97[1];
                if (v99 == v93)
                {
                  if (*((unsigned __int8 *)v97 + 16) == v65
                    && *((unsigned __int8 *)v97 + 17) == v64
                    && *((_DWORD *)v97 + 5) == v70
                    && *((_DWORD *)v97 + 6) == v68)
                  {
                    goto LABEL_59;
                  }
                }
                else if ((v99 & ((uint64_t)v199[1] - 1)) != v59)
                {
                  goto LABEL_113;
                }
                unint64_t v97 = (uint64_t *)*v97;
                if (!v97) {
                  goto LABEL_113;
                }
              }
            }
            do
            {
              unint64_t v98 = v97[1];
              if (v98 == v93)
              {
                if (*((unsigned __int8 *)v97 + 16) == v65
                  && *((unsigned __int8 *)v97 + 17) == v64
                  && *((_DWORD *)v97 + 5) == v70
                  && *((_DWORD *)v97 + 6) == v68)
                {
                  goto LABEL_59;
                }
              }
              else
              {
                if ((void *)v98 >= v199[1]) {
                  v98 %= (unint64_t)v199[1];
                }
                if (v98 != v59) {
                  break;
                }
              }
              unint64_t v97 = (uint64_t *)*v97;
            }
            while (v97);
          }
        }
      }
LABEL_113:
      float v100 = operator new(0x28uLL);
      *float v100 = 0;
      v100[1] = v93;
      *((unsigned char *)v100 + 16) = v65;
      *((unsigned char *)v100 + 17) = v64;
      *((void *)&v23 + 1) = *((void *)&v195 + 1);
      *(void *)((char *)v100 + 20) = v195;
      *(float *)&long long v23 = (float)((unint64_t)v200[1] + 1);
      if (!v94 || (float)(v201 * (float)v94) < *(float *)&v23)
      {
        BOOL v101 = (v94 & (v94 - 1)) != 0;
        if (v94 < 3) {
          BOOL v101 = 1;
        }
        unint64_t v102 = v101 | (2 * v94);
        unint64_t v103 = vcvtps_u32_f32(*(float *)&v23 / v201);
        if (v102 <= v103) {
          size_t prime = v103;
        }
        else {
          size_t prime = v102;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
          unint64_t v94 = (unint64_t)v199[1];
        }
        if (prime > v94) {
          goto LABEL_125;
        }
        if (prime < v94)
        {
          unint64_t v105 = vcvtps_u32_f32((float)(unint64_t)v200[1] / v201);
          if (v94 < 3 || (uint8x8_t v106 = (uint8x8_t)vcnt_s8((int8x8_t)v94), v106.i16[0] = vaddlv_u8(v106), v106.u32[0] > 1uLL))
          {
            unint64_t v105 = std::__next_prime(v105);
          }
          else
          {
            uint64_t v107 = 1 << -(char)__clz(v105 - 1);
            if (v105 >= 2) {
              unint64_t v105 = v107;
            }
          }
          if (prime <= v105) {
            size_t prime = v105;
          }
          if (prime < v94) {
LABEL_125:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v199, prime);
        }
        unint64_t v94 = (unint64_t)v199[1];
        if (((unint64_t)v199[1] & ((unint64_t)v199[1] - 1)) != 0)
        {
          if ((void *)v93 >= v199[1]) {
            unint64_t v59 = v93 % (unint64_t)v199[1];
          }
          else {
            unint64_t v59 = v93;
          }
        }
        else
        {
          unint64_t v59 = ((unint64_t)v199[1] - 1) & v93;
        }
      }
      uint64_t v108 = v199[0];
      float v109 = (void *)*((void *)v199[0] + v59);
      if (v109)
      {
        *float v100 = *v109;
      }
      else
      {
        *float v100 = v200[0];
        v200[0] = v100;
        v108[v59] = v200;
        if (!*v100) {
          goto LABEL_58;
        }
        unint64_t v110 = *(void *)(*v100 + 8);
        if ((v94 & (v94 - 1)) != 0)
        {
          if (v110 >= v94) {
            v110 %= v94;
          }
        }
        else
        {
          v110 &= v94 - 1;
        }
        float v109 = (char *)v199[0] + 8 * v110;
      }
      *float v109 = v100;
LABEL_58:
      ++v200[1];
LABEL_59:
      unint64_t v56 = v66;
      if (!v55) {
        goto LABEL_6;
      }
    }
  }
  uint64_t v30 = v57;
LABEL_6:
  v204[1] = 0;
  unint64_t v31 = (char *)v197 - (char *)v30;
  if ((unint64_t)((char *)v197 - (char *)v30) >= 0x11)
  {
    do
    {
      uint64_t v32 = *v30++;
      operator delete(v32);
      __p[1] = v30;
      v31 -= 8;
    }
    while (v31 > 0x10);
  }
  while (v30 != v197)
  {
    uint64_t v33 = *v30++;
    operator delete(v33);
  }
  if (__p[0]) {
    operator delete(__p[0]);
  }
  uint64_t v34 = *(void *)(a1 + 536);
  uint64_t v36 = *(void *)(v34 + 112);
  uint64_t v35 = *(void *)(v34 + 120);
  if (v36 != v35)
  {
    while (*(_WORD *)v36)
    {
      v36 += 112;
      if (v36 == v35)
      {
        uint64_t v36 = v35;
        break;
      }
    }
  }
  LODWORD(__p[0]) = 512;
  std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::unordered_set((uint64_t)&__p[1], (uint64_t)v199);
  *(_DWORD *)(v36 + 56) = __p[0];
  if (*(void *)(v36 + 88))
  {
    long long v37 = *(void **)(v36 + 80);
    if (v37)
    {
      do
      {
        uint64_t v38 = (void *)*v37;
        operator delete(v37);
        long long v37 = v38;
      }
      while (v38);
    }
    *(void *)(v36 + 80) = 0;
    uint64_t v39 = *(void *)(v36 + 72);
    if (v39)
    {
      for (uint64_t i = 0; i != v39; ++i)
        *(void *)(*(void *)(v36 + 64) + 8 * i) = 0;
    }
    *(void *)(v36 + 88) = 0;
  }
  float v41 = __p[1];
  __p[1] = 0;
  uint64_t v42 = *(void **)(v36 + 64);
  *(void *)(v36 + 64) = v41;
  if (v42) {
    operator delete(v42);
  }
  unint64_t v44 = (unint64_t)v203[0];
  int v43 = v203[1];
  *(void **)(v36 + 80) = v203[1];
  *(void *)(v36 + 72) = v44;
  v203[0] = 0;
  uint64_t v45 = v204[0];
  *(void **)(v36 + 88) = v204[0];
  *(_DWORD *)(v36 + 96) = v204[1];
  if (v45)
  {
    unint64_t v46 = v43[1];
    if ((v44 & (v44 - 1)) != 0)
    {
      if (v46 >= v44) {
        v46 %= v44;
      }
    }
    else
    {
      v46 &= v44 - 1;
    }
    *(void *)(*(void *)(v36 + 64) + 8 * v46) = v36 + 80;
    v203[1] = 0;
    v204[0] = 0;
  }
  else if (v43)
  {
    do
    {
      uint64_t v47 = (void *)*v43;
      operator delete(v43);
      int v43 = v47;
    }
    while (v47);
  }
  float v48 = __p[1];
  __p[1] = 0;
  if (v48) {
    operator delete(v48);
  }
  uint64_t v49 = *(void *)(a1 + 464);
  uint64_t v50 = *(void *)(a1 + 472);
  if (v49 != v50)
  {
    while (*(_WORD *)v49)
    {
      v49 += 32;
      if (v49 == v50)
      {
        uint64_t v49 = *(void *)(a1 + 472);
        break;
      }
    }
  }
  uint64_t v51 = *(void *)(*(void *)(v49 + 16) + 16);
  if (v51)
  {
    float32x2_t v52 = *(void **)(v36 + 104);
    *(_OWORD *)size_t v203 = 0u;
    *(_OWORD *)uint64_t v204 = 0u;
    int v205 = 1065353216;
    __p[0] = &unk_1EF558EE0;
    __p[1] = v52;
    *(void *)&long long v206 = v36 + 16;
    *((void *)&v206 + 1) = v36 + 56;
    *(void *)(v51 + 8) = v52;
    if ((void **)v51 == __p)
    {
      *(_OWORD *)(v51 + 56) = v206;
      __p[0] = &unk_1EF555180;
    }
    else
    {
      *(_DWORD *)(v51 + 48) = 1065353216;
      std::__hash_table<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned short,void *> *>>((void *)(v51 + 16), 0);
      float v53 = v204[0];
      *(_OWORD *)(v51 + 56) = v206;
      __p[0] = &unk_1EF555180;
      if (v53)
      {
        do
        {
          uint64_t v54 = (void *)*v53;
          operator delete(v53);
          float v53 = v54;
        }
        while (v54);
      }
    }
    uint64_t v115 = v203[0];
    v203[0] = 0;
    if (v115) {
      operator delete(v115);
    }
    uint64_t v116 = *(void *)(a1 + 120);
    *(_OWORD *)std::string __p = 0u;
    *(_OWORD *)size_t v203 = 0u;
    LODWORD(v204[0]) = 1065353216;
    for (uint64_t j = *(uint64_t **)(v116 + 144); j; uint64_t j = (uint64_t *)*j)
    {
      if (*((_WORD *)j + 10)) {
        BOOL v130 = 1;
      }
      else {
        BOOL v130 = *((unsigned char *)j + 18) == 2;
      }
      if (!v130) {
        std::__hash_table<unsigned short,std::hash<unsigned short>,std::equal_to<unsigned short>,std::allocator<unsigned short>>::__emplace_unique_key_args<unsigned short,unsigned short>((uint64_t)__p, *((_WORD *)j + 8), *((_WORD *)j + 8));
      }
    }
    gdc::SelectionContext::setLayerDataTypes(v51, (uint64_t *)__p);
    float v118 = v203[0];
    if (v203[0])
    {
      do
      {
        unint64_t v119 = (void *)*v118;
        operator delete(v118);
        float v118 = v119;
      }
      while (v119);
    }
    uint64_t v120 = __p[0];
    __p[0] = 0;
    if (v120) {
      operator delete(v120);
    }
  }
  uint64_t v121 = *(void **)(*(void *)(a1 + 120) + 24);
  uint64_t v122 = *(void *)(v36 + 104);
  uint64_t v123 = (uint64_t)(*(double *)(md::LayoutContext::frameState(v190) + 88) * 1000.0);
  uint64_t v124 = *(void *)(a1 + 464);
  uint64_t v125 = *(void *)(a1 + 472);
  while (v124 != v125)
  {
    for (uint64_t k = *(void *)(v124 + 16); k != v124 + 8; uint64_t k = *(void *)(k + 8))
    {
      for (unint64_t m = *(uint64_t ***)(*(void *)(k + 16) + 32); m; unint64_t m = (uint64_t **)*m)
      {
        uint64_t v128 = (unsigned __int16 *)v121[1];
        int64_t v129 = (unsigned __int16 *)v121[2];
        if (v128 != v129)
        {
          while (*((unsigned __int16 *)m + 8) != *v128)
          {
            v128 += 12;
            if (v128 == v129) {
              goto LABEL_167;
            }
          }
        }
        if (v128 != v129) {
          (*(void (**)(void, void, void))(**((void **)v128 + 2) + 24))(*((void *)v128 + 2), *(void *)(k + 16), 0);
        }
LABEL_167:
        ;
      }
    }
    v124 += 32;
  }
  uint64_t v214 = 0;
  uint64_t v215 = 0;
  uint64_t v216 = 0;
  gdc::LayerDataManager::createDataRequests(v121, (uint64_t *)(a1 + 464), &v214, v123);
  uint64_t v131 = *(void *)(a1 + 464);
  uint64_t v132 = *(void *)(a1 + 472);
  if (v131 != v132)
  {
    do
    {
      for (uint64_t n = *(void *)(v131 + 16); n != v131 + 8; uint64_t n = *(void *)(n + 8))
      {
        for (iuint64_t i = *(uint64_t ***)(*(void *)(n + 16) + 32); ii; iuint64_t i = (uint64_t **)*ii)
        {
          float32x4_t v141 = (unsigned __int16 *)v121[1];
          long long v142 = (unsigned __int16 *)v121[2];
          if (v141 != v142)
          {
            while (*((unsigned __int16 *)ii + 8) != *v141)
            {
              v141 += 12;
              if (v141 == v142) {
                goto LABEL_189;
              }
            }
          }
          if (v141 != v142) {
            (*(void (**)(void, void))(**((void **)v141 + 1) + 40))(*((void *)v141 + 1), *(void *)(*(void *)(n + 16) + 8));
          }
LABEL_189:
          ;
        }
      }
      v131 += 32;
    }
    while (v131 != v132);
    uint64_t v174 = *(void *)(v192 + 464);
    uint64_t v175 = *(void *)(v192 + 472);
    while (v174 != v175)
    {
      for (juint64_t j = *(void *)(v174 + 16); jj != v174 + 8; juint64_t j = *(void *)(jj + 8))
      {
        for (kuint64_t k = *(uint64_t ***)(*(void *)(jj + 16) + 32); kk; kuint64_t k = (uint64_t **)*kk)
        {
          long long v178 = (unsigned __int16 *)v121[1];
          unint64_t v179 = (unsigned __int16 *)v121[2];
          if (v178 != v179)
          {
            while (*((unsigned __int16 *)kk + 8) != *v178)
            {
              v178 += 12;
              if (v178 == v179) {
                goto LABEL_262;
              }
            }
          }
          if (v178 != v179) {
            (*(void (**)(void, void))(**((void **)v178 + 1) + 48))(*((void *)v178 + 1), *(void *)(jj + 16));
          }
LABEL_262:
          ;
        }
      }
      v174 += 32;
    }
  }
  gdc::LayerDataCollector::sortIndexList((unsigned __int8 **)v122);
  unint64_t v133 = *(unsigned __int8 **)v122;
  long long v134 = *(unsigned __int8 **)(v122 + 8);
  if (*(unsigned __int8 **)v122 != v134)
  {
    int v135 = 0;
    char v136 = 1;
    char v137 = 1;
    uint64_t v138 = v192;
    while (1)
    {
      unsigned int v143 = *((unsigned __int16 *)v133 + 4);
      unint64_t v144 = *((void *)v133 + 17);
      long long v145 = *(unsigned __int16 **)(v122 + 24);
      long long v146 = *(unsigned __int16 **)(v122 + 32);
      long long v147 = v145;
      if (v145 != v146)
      {
        long long v147 = *(unsigned __int16 **)(v122 + 24);
        while (*v147 != v143)
        {
          v147 += 16;
          if (v147 == v146) {
            goto LABEL_208;
          }
        }
      }
      if (v147 == v146) {
        goto LABEL_208;
      }
      long long v149 = v147 + 4;
      uint64_t v148 = *((void *)v147 + 1);
      if (0x8E38E38E38E38E39 * ((*((void *)v149 + 1) - v148) >> 4) <= v144) {
        goto LABEL_290;
      }
      unsigned int v150 = *(_DWORD *)(v148 + 144 * v144 + 128);
      if (v150 != 2) {
        break;
      }
      int v135 = 1;
LABEL_197:
      v133 += 144;
      if (v133 == v134)
      {
        id v180 = v214;
        goto LABEL_271;
      }
    }
    if (v150 > 1)
    {
      if (v145 != v146)
      {
        while (*v145 != v143)
        {
          v145 += 16;
          if (v145 == v146)
          {
            long long v145 = *(unsigned __int16 **)(v122 + 32);
            break;
          }
        }
      }
      uint64_t v155 = *((void *)v145 + 1);
      if (0x8E38E38E38E38E39 * ((*((void *)v145 + 2) - v155) >> 4) <= v144) {
LABEL_290:
      }
        abort();
      int v198 = v135;
      uint64_t v156 = v155 + 144 * v144;
      unint64_t v157 = *(void *)(v156 + 112);
      unint64_t v212 = v157;
      long long v158 = *(std::__shared_weak_count **)(v156 + 120);
      uint64_t v213 = v158;
      if (v158) {
        atomic_fetch_add_explicit(&v158->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      LOBYTE(__p[0]) = *v133;
      gdc::LayerDataKey::LayerDataKey((uint64_t)&__p[1], (uint64_t)(v133 + 8));
      char v207 = 0;
      if (v133[96])
      {
        int v208 = *((_DWORD *)v133 + 25);
        char v207 = 1;
      }
      uint64_t v209 = *((void *)v133 + 13);
      __int16 v210 = *((_WORD *)v133 + 56);
      uint64_t v211 = *(void *)(v133 + 116);
      long long v159 = geo::linear_map<unsigned short,std::set<gdc::LayerDataWithWorld>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::set<gdc::LayerDataWithWorld>>>,std::vector<std::pair<unsigned short,std::set<gdc::LayerDataWithWorld>>>>::operator[]((char **)(*(void *)(v138 + 536) + 48), *((_WORD *)v133 + 4));
      long long v160 = operator new(0x38uLL);
      long long v161 = v160;
      v160[4] = v157;
      v160[5] = v158;
      if (v158) {
        atomic_fetch_add_explicit(&v158->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      long long v162 = (void **)(v159 + 4);
      signed int v163 = vcvtmd_s64_f64((double)*((int *)v133 + 30) / (double)(1 << v133[113]));
      *((unsigned char *)v160 + 48) = v163;
      long long v164 = (void **)*((void *)v159 + 1);
      long long v165 = (void **)(v159 + 4);
      if (v164)
      {
        while (1)
        {
          while (1)
          {
            long long v165 = v164;
            int v166 = *((unsigned __int8 *)v164 + 48);
            signed int v167 = (char)v166;
            unint64_t v168 = (unint64_t)v164[4];
            if (!(v166 == v163 ? v157 < v168 : (char)v166 > v163)) {
              break;
            }
            long long v164 = (void **)*v165;
            long long v162 = v165;
            if (!*v165) {
              goto LABEL_239;
            }
          }
          BOOL v170 = v168 < v157;
          BOOL v130 = v167 == v163;
          BOOL v171 = v167 < v163;
          if (v130) {
            BOOL v171 = v170;
          }
          if (!v171) {
            break;
          }
          long long v164 = (void **)v165[1];
          if (!v164)
          {
            long long v162 = v165 + 1;
            goto LABEL_239;
          }
        }
        if (v158 && !atomic_fetch_add(&v158->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v158->__on_zero_shared)(v158);
          std::__shared_weak_count::__release_weak(v158);
        }
        operator delete(v161);
      }
      else
      {
LABEL_239:
        *long long v160 = 0;
        v160[1] = 0;
        v160[2] = v165;
        *long long v162 = v160;
        uint64_t v172 = **(void **)v159;
        if (v172)
        {
          *(void *)long long v159 = v172;
          long long v161 = *v162;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v159 + 1), (uint64_t *)v161);
        ++*((void *)v159 + 2);
      }
      uint64_t v138 = v192;
      if (v207) {
        char v207 = 0;
      }
      if (v203[0] != v204[0]) {
        free(v203[0]);
      }
      long long v173 = v213;
      if (v213 && !atomic_fetch_add(&v213->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v173->__on_zero_shared)(v173);
        std::__shared_weak_count::__release_weak(v173);
      }
      int v135 = v198;
      goto LABEL_197;
    }
LABEL_208:
    long long v151 = *(unsigned __int16 **)(v138 + 488);
    long long v152 = *(unsigned __int16 **)(v138 + 496);
    if (v151 != v152)
    {
      while (1)
      {
        unsigned int v153 = *v151;
        if (v153 == v143) {
          break;
        }
        ++v151;
        if (v143 < v153 || v151 == v152)
        {
          long long v151 = *(unsigned __int16 **)(v138 + 496);
          break;
        }
      }
    }
    v137 &= v151 != v152;
    v136 &= v151 == v152;
    goto LABEL_197;
  }
  id v180 = 0;
  LOBYTE(v135) = 0;
  char v137 = 1;
  char v136 = 1;
  uint64_t v138 = v192;
LABEL_271:
  *(unsigned char *)(v36 + 10) = v135 & 1;
  *(unsigned char *)(v36 + 8) = v136 & 1;
  *(unsigned char *)(v36 + 9) = v136 & 1 & v137;
  if (v180)
  {
    for (munint64_t m = v215; mm != v180; mm -= 24)
    {
      unint64_t v182 = (unsigned char *)*((void *)mm - 3);
      if (v182)
      {
        do
        {
          if (v182[112]) {
            v182[112] = 0;
          }
          uint64_t v184 = *(unsigned char **)v182;
          unsigned int v185 = (void *)*((void *)v182 + 4);
          if (v185 != *((void **)v182 + 6)) {
            free(v185);
          }
          operator delete(v182);
          unint64_t v182 = v184;
        }
        while (v184);
      }
      uint64_t v183 = (void *)*((void *)mm - 5);
      *((void *)mm - 5) = 0;
      if (v183) {
        operator delete(v183);
      }
    }
    operator delete(v180);
  }
  md::RegistryManager::update(*(void **)(v138 + 128), *(void *)(v138 + 128) + 696, a4, 0);
  uint64_t v186 = v200[0];
  if (v200[0])
  {
    do
    {
      size_t v187 = (void *)*v186;
      operator delete(v186);
      uint64_t v186 = v187;
    }
    while (v187);
  }
  unint64_t v188 = v199[0];
  v199[0] = 0;
  if (v188) {
    operator delete(v188);
  }
}

void sub_1A2106ACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

uint64_t std::deque<geo::QuadTile>::~deque[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void ***)(a1 + 8);
  int v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      int v3 = *(void ***)(a1 + 16);
      uint64_t v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 85;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 170;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      double v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t std::__split_buffer<std::pair<unsigned short,std::set<gdc::LayerDataWithWorld>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v3; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 32;
    std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(i - 16));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void std::__split_buffer<geo::QuadTile *>::push_back(char **a1, void *a2)
{
  unint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_23;
  }
  uint64_t v6 = *a1;
  unint64_t v5 = a1[1];
  if (v5 > *a1)
  {
    uint64_t v7 = (v5 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    double v11 = &v5[-8 * v9];
    int64_t v12 = v4 - v5;
    if (v4 != v5)
    {
      memmove(&v5[-8 * v9], a1[1], v4 - v5);
      unint64_t v4 = a1[1];
    }
    double v13 = &v4[8 * v10];
    unint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_23;
  }
  unint64_t v14 = (v4 - v6) >> 2;
  if (v4 == v6) {
    unint64_t v14 = 1;
  }
  if (v14 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  long double v17 = (char *)operator new(8 * v14);
  long double v18 = &v17[8 * v15];
  int64_t v20 = v4 - v5;
  BOOL v19 = v4 == v5;
  unint64_t v4 = v18;
  if (!v19)
  {
    unint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      long double v22 = &v17[8 * v15];
      goto LABEL_20;
    }
    long long v23 = &v17[8 * v15];
    long double v22 = v23;
    if ((unint64_t)(v23 - v5) < 0x20)
    {
      do
      {
LABEL_20:
        uint64_t v30 = *(void *)v5;
        v5 += 8;
        *(void *)long double v22 = v30;
        v22 += 8;
      }
      while (v22 != v4);
      goto LABEL_21;
    }
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    long double v22 = &v18[v25];
    int v26 = (long long *)(v5 + 16);
    unsigned int v27 = v23 + 16;
    uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v29 = *v26;
      *(v27 - 1) = *(v26 - 1);
      *unsigned int v27 = v29;
      v26 += 2;
      v27 += 2;
      v28 -= 4;
    }
    while (v28);
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
    {
      v5 += v25;
      goto LABEL_20;
    }
  }
LABEL_21:
  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v6)
  {
    operator delete(v6);
    unint64_t v4 = a1[2];
  }
LABEL_23:
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<geo::QuadTile *>::push_front(void **a1, void *a2)
{
  unint64_t v4 = (char *)a1[1];
  if (v4 != *a1)
  {
    unint64_t v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v7 = a1[2];
  uint64_t v6 = a1[3];
  if (v7 >= v6)
  {
    uint64_t v13 = v6 - v4;
    BOOL v12 = v13 == 0;
    unint64_t v14 = v13 >> 2;
    if (v12) {
      unint64_t v14 = 1;
    }
    if (v14 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v15 = (v14 + 3) >> 2;
    uint64_t v16 = 8 * v14;
    long double v17 = (char *)operator new(8 * v14);
    unint64_t v5 = &v17[8 * v15];
    long double v18 = &v17[v16];
    BOOL v19 = v5;
    uint64_t v20 = v7 - v4;
    if (v7 != v4)
    {
      BOOL v19 = &v5[v20 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v21 = v20 - 8;
      long double v22 = &v17[8 * v15];
      long long v23 = v4;
      if (v21 > 0x37)
      {
        uint64_t v24 = &v17[8 * v15];
        long double v22 = v24;
        long long v23 = v4;
        if ((unint64_t)(v24 - v4) >= 0x20)
        {
          uint64_t v25 = (v21 >> 3) + 1;
          uint64_t v26 = 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
          long double v22 = &v5[v26];
          unsigned int v27 = (long long *)(v4 + 16);
          uint64_t v28 = v24 + 16;
          uint64_t v29 = v25 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v30 = *v27;
            *(v28 - 1) = *(v27 - 1);
            *uint64_t v28 = v30;
            v27 += 2;
            v28 += 2;
            v29 -= 4;
          }
          while (v29);
          if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
          {
            *a1 = v17;
            a1[1] = v5;
            a1[2] = v19;
            a1[3] = v18;
            goto LABEL_24;
          }
          long long v23 = &v4[v26];
        }
      }
      do
      {
        uint64_t v31 = *(void *)v23;
        v23 += 8;
        *(void *)long double v22 = v31;
        v22 += 8;
      }
      while (v22 != v19);
    }
    *a1 = v17;
    a1[1] = v5;
    a1[2] = v19;
    a1[3] = v18;
    if (!v4) {
      goto LABEL_25;
    }
LABEL_24:
    operator delete(v4);
    unint64_t v5 = (char *)a1[1];
    goto LABEL_25;
  }
  uint64_t v8 = (v6 - v7) >> 3;
  if (v8 >= -1) {
    uint64_t v9 = v8 + 1;
  }
  else {
    uint64_t v9 = v8 + 2;
  }
  uint64_t v10 = v9 >> 1;
  double v11 = &v7[8 * (v9 >> 1)];
  unint64_t v5 = &v11[-(v7 - v4)];
  if (v7 != v4)
  {
    memmove(&v11[-(v7 - v4)], v4, v7 - v4);
    unint64_t v4 = (char *)a1[2];
  }
  a1[1] = v5;
  a1[2] = &v4[8 * v10];
LABEL_25:
  *((void *)v5 - 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

uint64_t md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

void md::ARSceneLogic::allocateContext(md::ARSceneLogic *this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *((void *)this + 67);
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 68);
  if (!v3)
  {
    *a2 = v2;
    a2[1] = 0;
    return;
  }
  p_unint64_t shared_owners = &v3->__shared_owners_;
  atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  *a2 = v2;
  a2[1] = v3;
  atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      return;
    }
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
}

uint64_t md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) != 0x29BDA47DB65B52C8 || !*(void *)(a3 + 32))
  {
    a4[23] = 0;
    *a4 = 0;
    return result;
  }
  unint64_t v4 = *(void **)(a2 + 8);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_27;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x1AF456233693CD46;
    if (*(void *)&v5 <= 0x1AF456233693CD46uLL) {
      uint64_t v7 = 0x1AF456233693CD46uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_27;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_27;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x1AF456233693CD46)
      {
        if (v9[2] == 0x1AF456233693CD46) {
          goto LABEL_25;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_27;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_27;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x1AF456233693CD46) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_27;
    }
LABEL_14:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_27;
    }
  }
  if (v9[2] != 0x1AF456233693CD46) {
    goto LABEL_14;
  }
LABEL_25:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v14 = 0;
LABEL_28:
  uint64_t v15 = v14;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
}

uint64_t md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x29BDA47DB65B52C8 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
}

uint64_t md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x29BDA47DB65B52C8 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 144))(result);
}

uint64_t md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x29BDA47DB65B52C8 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 136))(result);
}

uint64_t md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0x29BDA47DB65B52C8 || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x1AF456233693CD46;
    if (*(void *)&v4 <= 0x1AF456233693CD46uLL) {
      uint64_t v6 = 0x1AF456233693CD46uLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x1AF456233693CD46) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 128))(result);
}

void md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A21078FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  MEMORY[0x1A6239270](v9, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARSceneContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARSceneContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555410;
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    MEMORY[0x1A6239270](v1, 0x20C40A4A59CD2);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARSceneContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555410;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x20C40A4A59CD2);
  }
  return a1;
}

void md::ARSceneLogic::~ARSceneLogic(md::ARSceneLogic *this)
{
  md::ARSceneLogic::~ARSceneLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  std::__shared_weak_count *v12;

  *(void *)this = &unk_1EF531260;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 68);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 61);
  if (v3 != *((void **)this + 63)) {
    free(v3);
  }
  int8x8_t v4 = *((void *)this + 58);
  if (v4)
  {
    uint8x8_t v5 = *((void *)this + 59);
    uint64_t v6 = (void *)*((void *)this + 58);
    if (v5 != v4)
    {
      do
      {
        if (*(void *)(v5 - 8))
        {
          uint64_t v7 = *(void *)(v5 - 24);
          uint64_t v8 = *(uint64_t **)(v5 - 16);
          uint64_t v9 = *v8;
          *(void *)(v9 + 8) = *(void *)(v7 + 8);
          **(void **)(v7 + 8) = v9;
          *(void *)(v5 - 8) = 0;
          if (v8 != (uint64_t *)(v5 - 24))
          {
            do
            {
              uint64_t v11 = (uint64_t *)v8[1];
              unint64_t v10 = v8[2];
              _DWORD v8[2] = 0;
              if (v10) {
                (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
              }
              operator delete(v8);
              uint64_t v8 = v11;
            }
            while (v11 != (uint64_t *)(v5 - 24));
          }
        }
        v5 -= 32;
      }
      while (v5 != v4);
      uint64_t v6 = (void *)*((void *)this + 58);
    }
    *((void *)this + 59) = v4;
    operator delete(v6);
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable((uint64_t)this + 384);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable((uint64_t)this + 304);
  md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable((uint64_t)this + 224);
  md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable((uint64_t)this + 144);
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t md::Monitorable<md::ConfigValue<GEOConfigKeyUInteger,unsigned int>>::~Monitorable(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    GEOConfigRemoveBlockListener();
    uint64_t v2 = *(void **)(a1 + 24);
    *(void *)(a1 + 24) = 0;
  }
  atomic_store(0, *(unsigned __int8 **)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 72);
  if (v3 == a1 + 48)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 48) + 32))(a1 + 48);
    int8x8_t v4 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  int8x8_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4)
  {
LABEL_9:
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
LABEL_11:

  return a1;
}

void sub_1A2107DE8(_Unwind_Exception *a1)
{
  std::function<void ()>::~function((void *)(v1 + 48));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 32);

  _Unwind_Resume(a1);
}

uint64_t md::Monitorable<md::ConfigValue<GEOConfigKeyDouble,double>>::~Monitorable(uint64_t a1)
{
  if (*(void *)(a1 + 24))
  {
    GEOConfigRemoveBlockListener();
    uint64_t v2 = *(void **)(a1 + 24);
    *(void *)(a1 + 24) = 0;
  }
  atomic_store(0, *(unsigned __int8 **)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 72);
  if (v3 == a1 + 48)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 48) + 32))(a1 + 48);
    int8x8_t v4 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v4) {
      goto LABEL_11;
    }
    goto LABEL_9;
  }
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  int8x8_t v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4)
  {
LABEL_9:
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
LABEL_11:

  return a1;
}

void sub_1A2107F0C(_Unwind_Exception *a1)
{
  std::function<void ()(double)>::~function((void *)(v1 + 48));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 32);

  _Unwind_Resume(a1);
}

void *std::function<void ()(unsigned int)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *___ZN2md11MonitorableINS_11ConfigValueI20GEOConfigKeyUIntegerjEEE16setCallbackQueueEPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18functionIFvjEEE_block_invoke(void *result)
{
  uint64_t v1 = (unsigned char *)result[5];
  if (v1)
  {
    uint64_t v2 = result[4];
    if (*v1)
    {
      int v3 = *(_DWORD *)(v2 + 16);
      if (*(void *)v2) {
        BOOL v4 = *(void *)(v2 + 8) == 0;
      }
      else {
        BOOL v4 = 1;
      }
      if (!v4) {
        *(_DWORD *)(v2 + 16) = GEOConfigGetUInteger();
      }
      uint64_t result = *(void **)(v2 + 72);
      if (result)
      {
        int v5 = v3;
        return (void *)(*(uint64_t (**)(void *, int *))(*result + 48))(result, &v5);
      }
    }
  }
  return result;
}

void *___ZN2md11MonitorableINS_11ConfigValueI18GEOConfigKeyDoubledEEE16setCallbackQueueEPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18functionIFvdEEE_block_invoke(void *result)
{
  uint64_t v1 = (unsigned char *)result[5];
  if (v1)
  {
    uint64_t v2 = (void *)result[4];
    if (*v1)
    {
      uint64_t v3 = v2[2];
      if (*v2) {
        BOOL v4 = v2[1] == 0;
      }
      else {
        BOOL v4 = 1;
      }
      if (!v4)
      {
        GEOConfigGetDouble();
        v2[2] = v5;
      }
      uint64_t result = (void *)v2[9];
      if (result)
      {
        uint64_t v6 = v3;
        return (void *)(*(uint64_t (**)(void *, uint64_t *))(*result + 48))(result, &v6);
      }
    }
  }
  return result;
}

void md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void md::Logic<md::ARSceneLogic,md::ARSceneContext,md::LogicDependencies<gdc::TypeList<md::CameraContext>,gdc::TypeList<>>>::allocateContext(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t md::RouteAnnotationLabelFeature::collisionPriority(md::RouteAnnotationLabelFeature *this)
{
  return *((unsigned __int8 *)this + 396);
}

double md::RouteAnnotationLabelFeature::routeOffsetInMeters(md::RouteAnnotationLabelFeature *this)
{
  return *((double *)this + 46);
}

void md::RouteAnnotationLabelFeature::populateStyleQueries(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unint64_t v62 = 0;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 488))(a1)
    && (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 480))(a1, 0))
  {
    operator new();
  }
  uint64_t v6 = *(void *)(a1 + 328);
  for (uint64_t i = *(void *)(a1 + 336); i != v6; i -= 16)
  {
    uint64_t v8 = *(std::__shared_weak_count **)(i - 8);
    if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  *(void *)(a1 + 336) = v6;
  unint64_t v10 = *(id **)(a1 + 296);
  char v9 = *(id **)(a1 + 304);
  if (v10 != v9)
  {
    uint64_t v56 = a2;
    do
    {
      id v11 = *v10;
      uint64_t v12 = v11;
      if (v11)
      {
        [v11 attributes];
      }
      else
      {
        long long v60 = 0u;
        long long v61 = 0u;
      }
      (*(void (**)(uint64_t, long long *))(*(void *)a1 + 544))(a1, &v60);
      _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v59);
      uint64_t v13 = v59;
      uint64_t v14 = v60;
      if (((*((void *)&v60 + 1) - (void)v60) & 0x7FFFFFFF8) != 0)
      {
        uint64_t v15 = 0;
        char v16 = 0;
        uint64_t v17 = ((*((void *)&v60 + 1) - (void)v60) >> 3);
        unsigned __int8 v18 = *(unsigned char *)(v59 + 33);
        while (1)
        {
          size_t v19 = v18;
          uint64_t v20 = *(void **)v13;
          if (v18) {
            break;
          }
LABEL_18:
          v20[v19] = *(void *)(v14 + 8 * v15);
          unsigned __int8 v18 = *(unsigned char *)(v13 + 33) + 1;
          *(unsigned char *)(v13 + 33) = v18;
          ++v15;
          char v16 = 1;
          if (v15 == v17)
          {
            uint64_t v20 = *(void **)v13;
            size_t v19 = v18;
LABEL_35:
            qsort(v20, v19, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
            goto LABEL_36;
          }
        }
        if (v18 > 0x1Fu)
        {
          do
          {
            uint64_t v24 = 0;
            uint64_t v25 = (int *)v20;
            while (1)
            {
              int v26 = *v25;
              v25 += 2;
              if (v26 == *(_DWORD *)(v14 + 8 * v15)) {
                break;
              }
              if (v19 == ++v24) {
                goto LABEL_29;
              }
            }
            HIDWORD(v20[v24]) = *(_DWORD *)(v14 + 8 * v15 + 4);
LABEL_29:
            ++v15;
          }
          while (v15 != v17);
        }
        else
        {
          do
          {
            uint64_t v21 = 0;
            long double v22 = (int *)v20;
            while (1)
            {
              int v23 = *v22;
              v22 += 2;
              if (v23 == *(_DWORD *)(v14 + 8 * v15)) {
                break;
              }
              if (v19 == ++v21) {
                goto LABEL_18;
              }
            }
            HIDWORD(v20[v21]) = *(_DWORD *)(v14 + 8 * v15++ + 4);
          }
          while (v15 != v17);
        }
        if (v16) {
          goto LABEL_35;
        }
      }
LABEL_36:
      unsigned int v27 = *(void **)(a1 + 336);
      unint64_t v28 = *(void *)(a1 + 344);
      if ((unint64_t)v27 >= v28)
      {
        uint64_t v31 = *(void *)(a1 + 328);
        uint64_t v32 = ((uint64_t)v27 - v31) >> 4;
        unint64_t v33 = v32 + 1;
        if ((unint64_t)(v32 + 1) >> 60) {
          abort();
        }
        uint64_t v34 = v28 - v31;
        if (v34 >> 3 > v33) {
          unint64_t v33 = v34 >> 3;
        }
        if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0) {
          uint64_t v35 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v35 = v33;
        }
        if (v35)
        {
          uint64_t v36 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 352) + 16))(*(void *)(a1 + 352), 16 * v35, 8);
          long long v37 = (_OWORD *)(v36 + 16 * v32);
          uint64_t v38 = v36 + 16 * v35;
          if (v36)
          {
            uint64_t v39 = *((void *)&v59 + 1);
            _OWORD *v37 = v59;
            if (v39) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
            }
          }
        }
        else
        {
          uint64_t v38 = 0;
          long long v37 = (_OWORD *)(16 * v32);
        }
        long long v30 = v37 + 1;
        long long v40 = *(void **)(a1 + 328);
        float v41 = *(void **)(a1 + 336);
        if (v41 == v40)
        {
          *(void *)(a1 + 328) = v37;
          *(void *)(a1 + 336) = v30;
          uint64_t v45 = *(void *)(a1 + 344);
          *(void *)(a1 + 344) = v38;
          a2 = v56;
          if (v41) {
            goto LABEL_62;
          }
        }
        else
        {
          uint64_t v42 = a3;
          do
          {
            long long v43 = *((_OWORD *)v41 - 1);
            v41 -= 2;
            *--long long v37 = v43;
            *float v41 = 0;
            v41[1] = 0;
          }
          while (v41 != v40);
          float v41 = *(void **)(a1 + 328);
          unint64_t v44 = *(void **)(a1 + 336);
          *(void *)(a1 + 328) = v37;
          *(void *)(a1 + 336) = v30;
          uint64_t v45 = *(void *)(a1 + 344);
          *(void *)(a1 + 344) = v38;
          if (v44 == v41)
          {
            a3 = v42;
            a2 = v56;
            if (v41) {
              goto LABEL_62;
            }
          }
          else
          {
            unint64_t v46 = v9;
            do
            {
              uint64_t v47 = (std::__shared_weak_count *)*(v44 - 1);
              if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                std::__shared_weak_count::__release_weak(v47);
              }
              v44 -= 2;
            }
            while (v44 != v41);
            a3 = v42;
            char v9 = v46;
            a2 = v56;
            if (v41) {
LABEL_62:
            }
              (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 352) + 40))(*(void *)(a1 + 352), v41, v45 - (void)v41);
          }
        }
      }
      else
      {
        if (v27)
        {
          *unsigned int v27 = v13;
          uint64_t v29 = *((void *)&v59 + 1);
          v27[1] = *((void *)&v59 + 1);
          if (v29) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
          }
        }
        long long v30 = v27 + 2;
      }
      *(void *)(a1 + 336) = v30;
      long long v57 = v59;
      if (*((void *)&v59 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v59 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      float v48 = v62;
      md::createFeatureAttributeSet((gss::Allocator *)v63, (uint64_t *)&v57);
      md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v58, a3, v63, v48);
      if (v63[0])
      {
        v63[1] = v63[0];
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v64 + 40))(v64, v63[0], v63[2] - v63[0]);
      }
      uint64_t v49 = *(_OWORD **)(a2 + 8);
      if ((unint64_t)v49 >= *(void *)(a2 + 16))
      {
        uint64_t v50 = std::vector<std::shared_ptr<md::RouteAnnotationLabelFeature>,geo::StdAllocator<std::shared_ptr<md::RouteAnnotationLabelFeature>,mdm::Allocator>>::__emplace_back_slow_path<std::shared_ptr<md::RouteAnnotationLabelFeature>>(a2, (uint64_t)&v58);
      }
      else
      {
        if (v49)
        {
          _OWORD *v49 = v58;
          long long v58 = 0uLL;
        }
        uint64_t v50 = v49 + 1;
      }
      *(void *)(a2 + 8) = v50;
      uint64_t v51 = (std::__shared_weak_count *)*((void *)&v58 + 1);
      if (*((void *)&v58 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v58 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
        float32x2_t v52 = (std::__shared_weak_count *)*((void *)&v57 + 1);
        if (!*((void *)&v57 + 1)) {
          goto LABEL_78;
        }
      }
      else
      {
        float32x2_t v52 = (std::__shared_weak_count *)*((void *)&v57 + 1);
        if (!*((void *)&v57 + 1)) {
          goto LABEL_78;
        }
      }
      if (!atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }
LABEL_78:
      float v53 = (std::__shared_weak_count *)*((void *)&v59 + 1);
      if (*((void *)&v59 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v59 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
        uint64_t v54 = v60;
        if (!(void)v60) {
          goto LABEL_12;
        }
LABEL_81:
        *((void *)&v60 + 1) = v54;
        (*(void (**)(void, uint64_t, void))(**((void **)&v61 + 1) + 40))(*((void *)&v61 + 1), v54, v61 - v54);
        goto LABEL_12;
      }
      uint64_t v54 = v60;
      if ((void)v60) {
        goto LABEL_81;
      }
LABEL_12:

      ++v10;
    }
    while (v10 != v9);
  }
  unint64_t v55 = v62;
  if (v62)
  {
    if (*((char *)v62 + 23) < 0) {
      (*(void (**)(void, void, uint64_t))(*(void *)v62[3] + 40))(v62[3], *v62, v62[2] & 0x7FFFFFFFFFFFFFFFLL);
    }
    MEMORY[0x1A6239270](v55, 0x1032C402ED93987);
  }
}

void sub_1A2108930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  MEMORY[0x1A6239270](v14, 0x1032C402ED93987);
  std::unique_ptr<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void md::RouteAnnotationLabelFeature::populateDebugNode(id **this, gdc::DebugTreeNode *a2, const md::LabelManager *a3)
{
  uint64_t v3 = a2;
  md::LabelFeature::populateDebugNode((md::LabelFeature *)this, a2, (unint64_t)a3);
  HIBYTE(v30[2]) = 11;
  strcpy((char *)v30, "RouteOffset");
  uint64_t v5 = *((unsigned int *)this + 90);
  double v6 = *((float *)this + 91);
  char v7 = (char *)operator new(0x80uLL);
  unint64_t v46 = v7 + 128;
  unint64_t v47 = (unint64_t)(v7 + 128);
  *((void *)v7 + 1) = v5;
  *((void *)v7 + 5) = 0;
  *((void *)v7 + 6) = 0;
  *((void *)v7 + 4) = 0;
  *((_DWORD *)v7 + 14) = 1;
  *((double *)v7 + 10) = v6;
  *((void *)v7 + 12) = 0;
  *((void *)v7 + 13) = 0;
  *((void *)v7 + 14) = 0;
  *((_DWORD *)v7 + 30) = 2;
  __dst = (void **)v7;
  gdc::DebugTreeNode::addProperty((uint64_t)v3, (uint64_t)v30, (uint64_t *)&__dst);
  if (v7[119] < 0)
  {
    operator delete(*((void **)v7 + 12));
    if ((v7[55] & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((v7[55] & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)v7 + 4));
LABEL_3:
  operator delete(v7);
  uint64_t v8 = this[46];
  HIBYTE(v30[2]) = 19;
  strcpy((char *)v30, "RouteOffsetInMeters");
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  uint64_t v41 = 0;
  int v44 = 2;
  long long v40 = v8;
  gdc::DebugTreeNode::addProperty((uint64_t)v3, (uint64_t)v30, (uint64_t)v39);
  char v9 = this[37];
  uint64_t v25 = this[38];
  if (v9 != v25)
  {
    uint64_t v23 = *(void *)(MEMORY[0x1E4FBA418] + 24);
    uint64_t v24 = *MEMORY[0x1E4FBA418];
    for (uint64_t i = 1; ; ++i)
    {
      id v11 = *v9;
      std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v30);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)"Feature ", 8);
      std::ostream::operator<<();
      uint64_t v12 = [v11 uniqueIdentifier];
      uint64_t v13 = (void *)v12;
      if ((v37 & 0x10) != 0)
      {
        unint64_t v15 = v36;
        char v16 = (const void **)&v32;
        if (v36 < v33)
        {
          unint64_t v36 = v33;
          unint64_t v15 = v33;
          char v16 = (const void **)&v32;
        }
      }
      else
      {
        if ((v37 & 8) == 0)
        {
          HIBYTE(v47) = 0;
          LOBYTE(__dst) = 0;
          if (!v12) {
            goto LABEL_9;
          }
          goto LABEL_22;
        }
        unint64_t v15 = v31[2];
        char v16 = (const void **)v31;
      }
      uint64_t v17 = *v16;
      size_t v18 = v15 - (void)*v16;
      if (v18 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      if (v18 >= 0x17) {
        break;
      }
      HIBYTE(v47) = v15 - *(unsigned char *)v16;
      p_dst = (void **)&__dst;
      if (v18) {
        goto LABEL_20;
      }
LABEL_21:
      *((unsigned char *)p_dst + v18) = 0;
      if (!v13)
      {
LABEL_9:
        memset(&v28, 0, sizeof(v28));
        uint64_t v14 = "";
        int v29 = 4;
LABEL_23:
        std::string::__assign_external(&v28, v14);
        goto LABEL_25;
      }
LABEL_22:
      id v26 = [v11 uniqueIdentifier];
      uint64_t v14 = (const std::string::value_type *)[v26 UTF8String];
      memset(&v28, 0, sizeof(v28));
      int v29 = 4;
      if (v14) {
        goto LABEL_23;
      }
      *((unsigned char *)&v28.__r_.__value_.__s + 23) = 6;
      qmemcpy(&v28, "<null>", 6);
LABEL_25:
      gdc::DebugTreeNode::addProperty((uint64_t)v3, (uint64_t)&__dst, (uint64_t)v27);
      if (SHIBYTE(v28.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v28.__r_.__value_.__l.__data_);
        if (!v13) {
          goto LABEL_28;
        }
LABEL_27:

        goto LABEL_28;
      }
      if (v13) {
        goto LABEL_27;
      }
LABEL_28:
      if (SHIBYTE(v47) < 0) {
        operator delete(__dst);
      }

      v30[0] = v24;
      *(void *)((char *)v30 + *(void *)(v24 - 24)) = v23;
      v30[1] = MEMORY[0x1E4FBA470] + 16;
      if (v35 < 0) {
        operator delete(__p);
      }
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x1A62391A0](&v38);

      if (++v9 == v25) {
        return;
      }
    }
    uint64_t v20 = v3;
    uint64_t v21 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17) {
      uint64_t v21 = v18 | 7;
    }
    uint64_t v22 = v21 + 1;
    p_dst = (void **)operator new(v21 + 1);
    unint64_t v46 = (char *)v18;
    unint64_t v47 = v22 | 0x8000000000000000;
    __dst = p_dst;
    uint64_t v3 = v20;
LABEL_20:
    memmove(p_dst, v17, v18);
    goto LABEL_21;
  }
}

void sub_1A2108EB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  std::ostringstream::~ostringstream((uint64_t)&a27);
  _Unwind_Resume(a1);
}

uint64_t md::RouteAnnotationLabelFeature::debugString@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, char a4@<W3>, unsigned char *a5@<X8>)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v74);
  md::LabelFeature::debugString((unsigned char *)a1, a2, a3, a4, __p);
  if (v73 >= 0) {
    char v9 = __p;
  }
  else {
    char v9 = (void **)__p[0];
  }
  if (v73 >= 0) {
    uint64_t v10 = HIBYTE(v73);
  }
  else {
    uint64_t v10 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)v9, v10);
  if (SHIBYTE(v73) < 0) {
    operator delete(__p[0]);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"RouteAnnotation:\n", 17);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"  CollisionPriority:", 20);
  id v11 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v11, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"  RouteOffsetInMeters:", 22);
  uint64_t v12 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"  DistanceFromUser:", 19);
  (*(void (**)(void))(**(void **)(*(void *)(a2 + 168) + 32) + 72))(*(void *)(*(void *)(a2 + 168)
                                                                                                  + 32));
  uint64_t v13 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"  facingAzimuth:", 16);
  uint64_t v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"\n", 1);
  unint64_t v15 = *(id **)(a1 + 296);
  int v70 = *(id **)(a1 + 304);
  if (v15 != v70)
  {
    uint64_t v16 = 1;
    while (1)
    {
      id v17 = *v15;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"  TrafficFeature ", 17);
      size_t v18 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"\n", 1);
      uint64_t v19 = [v17 trafficFeatureType];
      switch(v19)
      {
        case 1:
          id v20 = v17;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"    CameraType: ", 16);
          +[VKTrafficCameraFeature stringForTrafficCameraType:](VKTrafficCameraFeature, "stringForTrafficCameraType:", [v20 type]);
          id v21 = objc_claimAutoreleasedReturnValue();
          long long v30 = (const char *)[v21 UTF8String];
          size_t v31 = strlen(v30);
          if (v31 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          std::string::size_type v32 = v31;
          if (v31 >= 0x17)
          {
            uint64_t v44 = (v31 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v31 | 7) != 0x17) {
              uint64_t v44 = v31 | 7;
            }
            uint64_t v45 = v44 + 1;
            p_dst = (std::string *)operator new(v44 + 1);
            __dst.__r_.__value_.__l.__size_ = v32;
            __dst.__r_.__value_.__r.__words[2] = v45 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
          }
          else
          {
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v31;
            p_dst = &__dst;
            if (!v31) {
              goto LABEL_45;
            }
          }
          memmove(p_dst, v30, v32);
LABEL_45:
          p_dst->__r_.__value_.__s.__data_[v32] = 0;
          unint64_t v46 = std::string::append(&__dst, "\n", 1uLL);
          std::string::size_type v47 = v46->__r_.__value_.__r.__words[2];
          *(_OWORD *)std::string __p = *(_OWORD *)&v46->__r_.__value_.__l.__data_;
          uint64_t v73 = v47;
          v46->__r_.__value_.__l.__size_ = 0;
          v46->__r_.__value_.__r.__words[2] = 0;
          v46->__r_.__value_.__r.__words[0] = 0;
          if (v73 >= 0) {
            uint64_t v42 = __p;
          }
          else {
            uint64_t v42 = (void **)__p[0];
          }
          if (v73 >= 0) {
            uint64_t v43 = HIBYTE(v73);
          }
          else {
            uint64_t v43 = (uint64_t)__p[1];
          }
LABEL_61:
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)v42, v43);
          if (SHIBYTE(v73) < 0)
          {
            operator delete(__p[0]);
            if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_63;
            }
          }
          else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_63:

            goto LABEL_64;
          }
          operator delete(__dst.__r_.__value_.__l.__data_);
          goto LABEL_63;
        case 2:
          id v20 = v17;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"    SignalType: ", 16);
          +[VKTrafficSignalFeature stringForTrafficSignalType:](VKTrafficSignalFeature, "stringForTrafficSignalType:", [v20 type]);
          id v21 = objc_claimAutoreleasedReturnValue();
          id v26 = (const char *)[v21 UTF8String];
          size_t v27 = strlen(v26);
          if (v27 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          std::string::size_type v28 = v27;
          if (v27 >= 0x17)
          {
            uint64_t v38 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v27 | 7) != 0x17) {
              uint64_t v38 = v27 | 7;
            }
            uint64_t v39 = v38 + 1;
            int v29 = (std::string *)operator new(v38 + 1);
            __dst.__r_.__value_.__l.__size_ = v28;
            __dst.__r_.__value_.__r.__words[2] = v39 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v29;
          }
          else
          {
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v27;
            int v29 = &__dst;
            if (!v27)
            {
LABEL_35:
              v29->__r_.__value_.__s.__data_[v28] = 0;
              long long v40 = std::string::append(&__dst, "\n", 1uLL);
              std::string::size_type v41 = v40->__r_.__value_.__r.__words[2];
              *(_OWORD *)std::string __p = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
              uint64_t v73 = v41;
              v40->__r_.__value_.__l.__size_ = 0;
              v40->__r_.__value_.__r.__words[2] = 0;
              v40->__r_.__value_.__r.__words[0] = 0;
              if (v73 >= 0) {
                uint64_t v42 = __p;
              }
              else {
                uint64_t v42 = (void **)__p[0];
              }
              if (v73 >= 0) {
                uint64_t v43 = HIBYTE(v73);
              }
              else {
                uint64_t v43 = (uint64_t)__p[1];
              }
              goto LABEL_61;
            }
          }
          memmove(v29, v26, v28);
          goto LABEL_35;
        case 4:
          id v20 = v17;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"    UserReportedIncidentType: ", 30);
          +[VKTrafficIncidentFeature stringForIncidentType:](VKTrafficIncidentFeature, "stringForIncidentType:", [v20 type]);
          id v21 = objc_claimAutoreleasedReturnValue();
          uint64_t v22 = (const char *)[v21 UTF8String];
          size_t v23 = strlen(v22);
          if (v23 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          std::string::size_type v24 = v23;
          if (v23 >= 0x17)
          {
            uint64_t v48 = (v23 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v23 | 7) != 0x17) {
              uint64_t v48 = v23 | 7;
            }
            uint64_t v49 = v48 + 1;
            uint64_t v25 = (std::string *)operator new(v48 + 1);
            __dst.__r_.__value_.__l.__size_ = v24;
            __dst.__r_.__value_.__r.__words[2] = v49 | 0x8000000000000000;
            __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v25;
          }
          else
          {
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v23;
            uint64_t v25 = &__dst;
            if (!v23)
            {
LABEL_55:
              v25->__r_.__value_.__s.__data_[v24] = 0;
              uint64_t v50 = std::string::append(&__dst, "\n", 1uLL);
              std::string::size_type v51 = v50->__r_.__value_.__r.__words[2];
              *(_OWORD *)std::string __p = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
              uint64_t v73 = v51;
              v50->__r_.__value_.__l.__size_ = 0;
              v50->__r_.__value_.__r.__words[2] = 0;
              v50->__r_.__value_.__r.__words[0] = 0;
              if (v73 >= 0) {
                uint64_t v42 = __p;
              }
              else {
                uint64_t v42 = (void **)__p[0];
              }
              if (v73 >= 0) {
                uint64_t v43 = HIBYTE(v73);
              }
              else {
                uint64_t v43 = (uint64_t)__p[1];
              }
              goto LABEL_61;
            }
          }
          memmove(v25, v22, v24);
          goto LABEL_55;
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"    Type: ", 10);
      +[VKTrafficFeature stringForFeatureType:](VKTrafficFeature, "stringForFeatureType:", [v17 trafficFeatureType]);
      id v20 = objc_claimAutoreleasedReturnValue();
      uint64_t v34 = (const char *)[v20 UTF8String];
      size_t v35 = strlen(v34);
      if (v35 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      std::string::size_type v36 = v35;
      if (v35 >= 0x17) {
        break;
      }
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v35;
      int v37 = &__dst;
      if (v35) {
        goto LABEL_71;
      }
LABEL_72:
      v37->__r_.__value_.__s.__data_[v36] = 0;
      uint64_t v56 = std::string::append(&__dst, "\n", 1uLL);
      std::string::size_type v57 = v56->__r_.__value_.__r.__words[2];
      *(_OWORD *)std::string __p = *(_OWORD *)&v56->__r_.__value_.__l.__data_;
      uint64_t v73 = v57;
      v56->__r_.__value_.__l.__size_ = 0;
      v56->__r_.__value_.__r.__words[2] = 0;
      v56->__r_.__value_.__r.__words[0] = 0;
      if (v73 >= 0) {
        long long v58 = __p;
      }
      else {
        long long v58 = (void **)__p[0];
      }
      if (v73 >= 0) {
        uint64_t v59 = HIBYTE(v73);
      }
      else {
        uint64_t v59 = (uint64_t)__p[1];
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)v58, v59);
      if (SHIBYTE(v73) < 0)
      {
        operator delete(__p[0]);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
LABEL_82:
        }
          operator delete(__dst.__r_.__value_.__l.__data_);
      }
      else if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      {
        goto LABEL_82;
      }
LABEL_64:

      if ([v17 isGrouped])
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"    GroupItemVerticalDisplayOrder: ", 35);
        [v17 groupItemVerticalDisplayOrder];
        float32x2_t v52 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v52, (uint64_t)"\n", 1);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v74, (uint64_t)"    GroupItemHorizontalDisplayOrder: ", 37);
        [v17 groupItemHorizontalDisplayOrder];
        float v53 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v53, (uint64_t)"\n", 1);
      }

      ++v15;
      ++v16;
      if (v15 == v70) {
        goto LABEL_83;
      }
    }
    uint64_t v54 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v35 | 7) != 0x17) {
      uint64_t v54 = v35 | 7;
    }
    uint64_t v55 = v54 + 1;
    int v37 = (std::string *)operator new(v54 + 1);
    __dst.__r_.__value_.__l.__size_ = v36;
    __dst.__r_.__value_.__r.__words[2] = v55 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v37;
LABEL_71:
    memmove(v37, v34, v36);
    goto LABEL_72;
  }
LABEL_83:
  if ((v81 & 0x10) != 0)
  {
    unint64_t v62 = v80;
    long long v60 = a5;
    if (v80 < v77)
    {
      unint64_t v80 = v77;
      unint64_t v62 = v77;
    }
    float v63 = (const void **)&v76;
  }
  else
  {
    long long v60 = a5;
    if ((v81 & 8) == 0)
    {
      size_t v61 = 0;
      a5[23] = 0;
      goto LABEL_98;
    }
    float v63 = (const void **)v75;
    unint64_t v62 = v75[2];
  }
  uint64_t v64 = *v63;
  size_t v61 = v62 - (void)*v63;
  if (v61 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v61 >= 0x17)
  {
    uint64_t v65 = (v61 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v61 | 7) != 0x17) {
      uint64_t v65 = v61 | 7;
    }
    uint64_t v66 = v65 + 1;
    unint64_t v67 = operator new(v65 + 1);
    v60[1] = v61;
    v60[2] = v66 | 0x8000000000000000;
    *long long v60 = v67;
    long long v60 = v67;
    goto LABEL_97;
  }
  *((unsigned char *)v60 + 23) = v61;
  if (v61) {
LABEL_97:
  }
    memmove(v60, v64, v61);
LABEL_98:
  *((unsigned char *)v60 + v61) = 0;
  v74[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v74 + *(void *)(v74[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v74[1] = MEMORY[0x1E4FBA470] + 16;
  if (v79 < 0) {
    operator delete(v78);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v82);
}

void sub_1A2109830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,char a25)
{
  if (a23 < 0) {
    operator delete(__p);
  }
  std::ostringstream::~ostringstream((uint64_t)&a25);
  _Unwind_Resume(a1);
}

uint64_t md::RouteAnnotationLabelFeature::isRouteFeature(md::RouteAnnotationLabelFeature *this)
{
  return 1;
}

uint64_t md::RouteAnnotationLabelFeature::routeCoordinate(uint64_t a1)
{
  return *(void *)(a1 + 360);
}

uint64_t md::RouteAnnotationLabelFeature::dedupingGroup@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(this + 256);
  *a2 = *(void *)(this + 248);
  a2[1] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return this;
}

uint64_t md::RouteAnnotationLabelFeature::labelFeatureType(md::RouteAnnotationLabelFeature *this)
{
  return 23;
}

uint64_t md::RouteAnnotationLabelFeature::facingVector(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 380)) {
    return *(void *)(a1 + 384);
  }
  else {
    return 0;
  }
}

uint64_t md::PointLabelFeatureBase::labelPoint(uint64_t a1)
{
  return a1 + 192;
}

uint64_t md::RouteAnnotationLabelFeature::updateDynamicStyling(md::RouteAnnotationLabelFeature *this, md::LabelManager *a2, md::Label *a3)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(*((void *)a2 + 21) + 32) + 88))(&v14);
  uint64_t v5 = *((void *)this + 37);
  if (*((void *)this + 38) == v5) {
    return 0;
  }
  char v6 = 0;
  unint64_t v7 = 0;
  do
  {
    id v8 = *(id *)(v5 + 8 * v7);
    if ([v8 shouldUpdateStyle])
    {
      char v9 = 1;
      v11[0] = 0;
      if (!(_BYTE)v14) {
        goto LABEL_6;
      }
      goto LABEL_5;
    }
    if (v8)
    {
      [v8 routeLegWhen];
      if (v12 && (_BYTE)v14)
      {
        char v9 = v13 != BYTE1(v14);
        v11[0] = 0;
LABEL_5:
        v11[1] = BYTE1(v14);
        v11[0] = 1;
        goto LABEL_6;
      }
      char v9 = (v12 != 0) ^ (v14 != 0);
      v11[0] = 0;
      if ((_BYTE)v14) {
        goto LABEL_5;
      }
    }
    else
    {
      char v9 = (_BYTE)v14 != 0;
      v11[0] = 0;
      if ((_BYTE)v14) {
        goto LABEL_5;
      }
    }
LABEL_6:
    [v8 setRouteLegWhen:v11];
    if (v11[0]) {
      v11[0] = 0;
    }
    [v8 setShouldUpdateStyle:0];
    v6 |= v9;

    ++v7;
    uint64_t v5 = *((void *)this + 37);
  }
  while (v7 < (*((void *)this + 38) - v5) >> 3);
  if (v6) {
    (*(void (**)(md::RouteAnnotationLabelFeature *, md::LabelManager *))(*(void *)this + 536))(this, a2);
  }
  return 0;
}

void sub_1A2109B58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

md::CompositeLabelPart *md::RouteAnnotationLabelFeature::newRootPart(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v132 = 0;
  unint64_t v133 = 0;
  long long v134 = 0;
  int v124 = [**(id **)(a1 + 296) groupItemVerticalDisplayOrder];
  if (*(void *)(a1 + 304) == *(void *)(a1 + 296)) {
    return 0;
  }
  uint64_t v121 = a4;
  uint64_t v122 = a3;
  unint64_t v7 = 0;
  id v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
  char v9 = 1;
  do
  {
    long long v129 = 0uLL;
    uint64_t v130 = 0;
    {
      operator new();
    }
    uint64_t v131 = *((void *)v8 + 91);
    if ([*(id *)(*(void *)(a1 + 296) + 8 * v7) isCamera])
    {
      id v10 = *(id *)(*(void *)(a1 + 296) + 8 * v7);
      if ([v10 isSpeedLimitCamera])
      {
        id v11 = [v10 speedLimitText];
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_external(&v129, (char *)[v11 UTF8String]);
      }
    }
    if ([*(id *)(*(void *)(a1 + 296) + 8 * v7) groupItemVerticalDisplayOrder] != v124)
    {
      int v124 = [*(id *)(*(void *)(a1 + 296) + 8 * v7) groupItemVerticalDisplayOrder];
      char v9 = 1;
    }
    char v12 = *(md::LabelStyle **)(*(void *)(a1 + 96) + 16 * v7);
    if (v12)
    {
      int v13 = *(_DWORD *)(*(void *)(a2 + 336) + 176);
      uint64_t v14 = md::LabelPoint::mercatorPoint((md::LabelPoint *)(a1 + 192));
      long long v15 = *(_OWORD *)(*(void *)(a1 + 328) + 16 * v7);
      long long v126 = v15;
      if (*((void *)&v15 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v15 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v16 = *(void *)(a2 + 264);
      id v17 = (char *)operator new(0x148uLL);
      uint64_t v123 = (_OWORD *)v14;
      *((void *)v17 + 1) = 0;
      *((void *)v17 + 2) = 0;
      *(void *)id v17 = &unk_1EF57FB50;
      *(_OWORD *)(v17 + 24) = 0u;
      *(_OWORD *)(v17 + 40) = 0u;
      *((void *)v17 + 7) = 0;
      {
        operator new();
      }
      uint64_t v18 = *((void *)v8 + 91);
      *((void *)v17 + 18) = 0;
      *((void *)v17 + 9) = 0;
      *((void *)v17 + 10) = 0;
      *((void *)v17 + 8) = v18;
      *((_WORD *)v17 + 44) = 0;
      *((void *)v17 + 12) = v17 + 128;
      *((void *)v17 + 13) = v17 + 128;
      *((void *)v17 + 14) = v17 + 128;
      *((void *)v17 + 15) = 2;
      v17[136] = 0;
      *(_DWORD *)(v17 + 137) = 16843008;
      v17[141] = 0;
      *((void *)v17 + 19) = 0;
      *((void *)v17 + 20) = 0;
      {
        operator new();
      }
      *((void *)v17 + 21) = *((void *)v8 + 91);
      *((void *)v17 + 22) = 0;
      *(void *)(v17 + 181) = 0;
      v17[192] = 4;
      *(void *)(v17 + 196) = 0;
      v17[204] = 0;
      *(void *)(v17 + 212) = 0xFFFF3F800000;
      *((_WORD *)v17 + 110) = 0;
      *((_DWORD *)v17 + 56) = 1065353216;
      *((void *)v17 + 40) = 0;
      *((_OWORD *)v17 + 15) = 0u;
      *((_OWORD *)v17 + 16) = 0u;
      *((_OWORD *)v17 + 17) = 0u;
      *((void *)v17 + 36) = 0;
      float32x4_t v141 = (md::LabelImageKey *)(v17 + 24);
      long long v142 = (std::__shared_weak_count *)v17;
      v17[136] = 6;
      *((float *)v17 + 20) = md::LabelStyle::iconContentScale(v12);
      uint64_t v20 = *((void *)v12 + 37);
      if (!v20)
      {
        uint64_t v19 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>((uint64_t)v12, 0);
        uint64_t v20 = *(void *)v19;
        *((void *)v12 + 37) = *(void *)v19;
      }
      *(void *)(v17 + 196) = *(void *)(v20 + 56);
      if ((void)v126)
      {
        unint64_t v21 = *(unsigned __int8 *)(v126 + 33);
        uint64_t v22 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
        if (*(unsigned char *)(v126 + 33))
        {
          uint64_t v23 = *(void *)v126;
          if (**(_DWORD **)v126 == 4)
          {
            unint64_t v24 = 0;
LABEL_22:
            int v25 = *(unsigned __int16 *)(v23 + 8 * v24 + 4);
LABEL_29:
            *((_DWORD *)v17 + 54) = v25;
            long long __dst = 0uLL;
            uint64_t v138 = 0;
            {
              if (v19) {
                operator new();
              }
            }
            uint64_t v139 = *((void *)v22 + 91);
            memset(v140, 0, 13);
            if (SHIBYTE(v130) < 0)
            {
              uint64_t v19 = (uint64_t)std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<true>((void **)&__dst, (void *)v129, *((size_t *)&v129 + 1));
            }
            else
            {
              long long __dst = v129;
              uint64_t v138 = v130;
            }
            if (v17[167] < 0)
            {
              if (v138 >= 0) {
                p_dst = &__dst;
              }
              else {
                p_dst = (long long *)__dst;
              }
              if (v138 >= 0) {
                size_t v29 = HIBYTE(v138);
              }
              else {
                size_t v29 = *((void *)&__dst + 1);
              }
              uint64_t v19 = (uint64_t)std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<false>((void **)v17 + 18, p_dst, v29);
            }
            else if (v138 < 0)
            {
              uint64_t v19 = (uint64_t)std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<true>((void **)v17 + 18, (void *)__dst, *((size_t *)&__dst + 1));
            }
            else
            {
              *((_OWORD *)v17 + 9) = __dst;
              *((void *)v17 + 20) = v138;
            }
            *((void *)v17 + 22) = v140[0];
            *((_DWORD *)v17 + 46) = v140[1];
            v17[188] = BYTE4(v140[1]);
            if (!v17[204]) {
              v17[204] = 1;
            }
            *((_DWORD *)v17 + 52) = 0;
            *((_DWORD *)v17 + 53) = v13;
            int v30 = *(unsigned __int8 *)(a2 + 3360);
            uint64_t v31 = *((void *)v12 + 37);
            if (!v31)
            {
              uint64_t v19 = md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>((uint64_t)v12, 0);
              uint64_t v31 = *(void *)v19;
              *((void *)v12 + 37) = *(void *)v19;
            }
            unsigned int v32 = *(unsigned __int8 *)(v31 + 92) - 1;
            if (v32 > 8) {
              int v33 = 0;
            }
            else {
              int v33 = dword_1A29003B0[v32];
            }
            uint64_t v34 = (grl *)grl::SizeGroupMin((grl *)v19);
            int v35 = (int)v34;
            int v36 = grl::SizeGroupMax(v34);
            int v37 = v33 + v30;
            if (v33 + v30 >= v36) {
              int v37 = v36;
            }
            if (v37 <= v35) {
              LOBYTE(v37) = v35;
            }
            v17[192] = v37;
            *(_OWORD *)(v17 + 24) = *v123;
            uint64_t v38 = *((void *)v12 + 37);
            id v8 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
            if (v38)
            {
              int v39 = *(_DWORD *)(v38 + 64);
              if (!v39) {
                goto LABEL_64;
              }
            }
            else
            {
              long long v40 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>((uint64_t)v12, 0);
              uint64_t v41 = *v40;
              *((void *)v12 + 37) = *v40;
              int v39 = *(_DWORD *)(v41 + 64);
              if (!v39) {
                goto LABEL_64;
              }
            }
            if ((void)v126)
            {
              unint64_t v42 = *(unsigned __int8 *)(v126 + 33);
              if (*(unsigned char *)(v126 + 33))
              {
                uint64_t v43 = *(void *)v126;
                if (**(_DWORD **)v126 == v39)
                {
                  unint64_t v44 = 0;
LABEL_63:
                  int v45 = *(_DWORD *)(v43 + 8 * v44 + 4);
                  *((_DWORD *)v17 + 21) = v39;
                  *((_WORD *)v17 + 44) = v45;
                  v17[138] = 1;
                }
                else
                {
                  unint64_t v44 = 0;
                  long long v58 = (int *)(v43 + 8);
                  while (v42 - 1 != v44)
                  {
                    int v59 = *v58;
                    v58 += 2;
                    ++v44;
                    if (v59 == v39)
                    {
                      if (v44 < v42) {
                        goto LABEL_63;
                      }
                      break;
                    }
                  }
                }
              }
            }
LABEL_64:
            uint64_t v46 = *((void *)v12 + 34);
            if (!v46)
            {
              std::string::size_type v47 = md::LabelStyle::prepareStyleGroup<md::LabelPointStyleGroup>((uint64_t)v12);
              uint64_t v46 = *v47;
              *((void *)v12 + 34) = *v47;
            }
            size_t v48 = *(unsigned __int8 *)(v46 + 103);
            if (*(char *)(v46 + 103) < 0) {
              uint64_t v49 = *(void *)(v46 + 88);
            }
            else {
              uint64_t v49 = *(unsigned __int8 *)(v46 + 103);
            }
            uint64_t v50 = (void **)(v46 + 80);
            std::string::size_type v51 = (void **)(v17 + 40);
            if (v49) {
              BOOL v52 = v51 == v50;
            }
            else {
              BOOL v52 = 1;
            }
            if (!v52)
            {
              if (v17[63] < 0)
              {
                uint64_t v55 = *(void ***)(v46 + 80);
                size_t v54 = *(void *)(v46 + 88);
                if ((v48 & 0x80u) == 0) {
                  uint64_t v56 = v50;
                }
                else {
                  uint64_t v56 = v55;
                }
                if ((v48 & 0x80u) == 0) {
                  size_t v57 = v48;
                }
                else {
                  size_t v57 = v54;
                }
                std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<false>(v51, v56, v57);
                id v17 = (char *)v142;
                int v135 = v141;
                char v136 = v142;
                if (!v142)
                {
LABEL_92:
                  md::LabelImageLoader::loadImage(&v127, v16, &v135);
                  if (v17 && !atomic_fetch_add((atomic_ullong *volatile)v17 + 1, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    (*(void (**)(char *))(*(void *)v17 + 16))(v17);
                    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v17);
                    if ((SHIBYTE(v138) & 0x80000000) == 0) {
                      goto LABEL_96;
                    }
                  }
                  else if ((SHIBYTE(v138) & 0x80000000) == 0)
                  {
LABEL_96:
                    long long v60 = v142;
                    if (v142 && !atomic_fetch_add(&v142->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
                      std::__shared_weak_count::__release_weak(v60);
                      size_t v61 = (std::__shared_weak_count *)*((void *)&v126 + 1);
                      if (!*((void *)&v126 + 1)) {
                        goto LABEL_104;
                      }
                    }
                    else
                    {
                      size_t v61 = (std::__shared_weak_count *)*((void *)&v126 + 1);
                      if (!*((void *)&v126 + 1)) {
                        goto LABEL_104;
                      }
                    }
                    if (!atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
                      std::__shared_weak_count::__release_weak(v61);
                    }
LABEL_104:
                    if (!v127)
                    {
LABEL_143:
                      unint64_t v88 = v128;
                      if (v128 && !atomic_fetch_add(&v128->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
                        std::__shared_weak_count::__release_weak(v88);
                      }
                      goto LABEL_146;
                    }
                    {
                      operator new();
                    }
                    unint64_t v62 = (unsigned char *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                        + 16))(mdm::Allocator::instance(void)::alloc, 824, 8);
                    uint64_t v63 = *(void *)(*(void *)(a1 + 96) + 16 * v7);
                    md::IconLabelPart::IconLabelPart((uint64_t)v62, &v127);
                    *uint64_t v64 = &unk_1EF52FC00;
                    md::LabelIconStyleMonitor::LabelIconStyleMonitor((uint64_t)(v64 + 96), v63);
                    v62[664] = 0;
                    (*(void (**)(unsigned char *, uint64_t))(*(void *)v62 + 176))(v62, 1);
                    uint64_t v65 = v133;
                    if (v9)
                    {
                      uint64_t v66 = v132;
                      if (v133 - v132 == -24)
                      {
                        id v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                        if (v133 != v132)
                        {
                          unint64_t v67 = v133;
                          do
                          {
                            double v69 = (void *)*((void *)v67 - 3);
                            v67 -= 24;
                            int v68 = v69;
                            if (v69)
                            {
                              *((void *)v65 - 2) = v68;
                              operator delete(v68);
                            }
                            uint64_t v65 = v67;
                          }
                          while (v67 != v66);
                        }
                        unint64_t v133 = v66;
                        int v70 = v66;
                        goto LABEL_118;
                      }
                      if (v134 == v133)
                      {
                        unint64_t v89 = 0xAAAAAAAAAAAAAAABLL * ((v133 - v132) >> 3);
                        unint64_t v90 = v89 + 1;
                        if (v89 + 1 > 0xAAAAAAAAAAAAAAALL) {
                          abort();
                        }
                        if (0x5555555555555556 * ((v134 - v132) >> 3) > v90) {
                          unint64_t v90 = 0x5555555555555556 * ((v134 - v132) >> 3);
                        }
                        if (0xAAAAAAAAAAAAAAABLL * ((v134 - v132) >> 3) >= 0x555555555555555) {
                          unint64_t v91 = 0xAAAAAAAAAAAAAAALL;
                        }
                        else {
                          unint64_t v91 = v90;
                        }
                        if (v91)
                        {
                          if (v91 > 0xAAAAAAAAAAAAAAALL) {
LABEL_209:
                          }
                            std::__throw_bad_array_new_length[abi:nn180100]();
                          unint64_t v92 = (char *)operator new(24 * v91);
                        }
                        else
                        {
                          unint64_t v92 = 0;
                        }
                        unint64_t v93 = &v92[24 * v89];
                        unint64_t v94 = &v92[24 * v91];
                        *(void *)unint64_t v93 = 0;
                        *((void *)v93 + 1) = 0;
                        *((void *)v93 + 2) = 0;
                        int v70 = v93 + 24;
                        if (v65 == v66)
                        {
                          uint64_t v132 = v93;
                          unint64_t v133 = v93 + 24;
                          long long v134 = &v92[24 * v91];
                          id v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                        }
                        else
                        {
                          id v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                          do
                          {
                            uint8x8_t v95 = v93;
                            *((void *)v93 - 2) = 0;
                            *((void *)v93 - 1) = 0;
                            long long v96 = *(_OWORD *)(v65 - 24);
                            v65 -= 24;
                            *(_OWORD *)(v93 - 24) = v96;
                            v93 -= 24;
                            *((void *)v95 - 1) = *((void *)v65 + 2);
                            *(void *)uint64_t v65 = 0;
                            *((void *)v65 + 1) = 0;
                            *((void *)v65 + 2) = 0;
                          }
                          while (v65 != v66);
                          uint64_t v65 = v132;
                          unint64_t v97 = v133;
                          uint64_t v132 = v93;
                          unint64_t v133 = v70;
                          long long v134 = v94;
                          if (v97 != v65)
                          {
                            unint64_t v98 = v97;
                            do
                            {
                              float v100 = (void *)*((void *)v98 - 3);
                              v98 -= 24;
                              uint64_t v99 = v100;
                              if (v100)
                              {
                                *((void *)v97 - 2) = v99;
                                operator delete(v99);
                              }
                              unint64_t v97 = v98;
                            }
                            while (v98 != v65);
                          }
                        }
                        if (v65) {
                          operator delete(v65);
                        }
LABEL_118:
                        double v72 = (char *)*((void *)v70 - 2);
                        unint64_t v71 = *((void *)v70 - 1);
                        if ((unint64_t)v72 < v71)
                        {
                          *(void *)double v72 = v62;
                          uint64_t v73 = v72 + 8;
LABEL_142:
                          char v9 = 0;
                          *((void *)v70 - 2) = v73;
                          goto LABEL_143;
                        }
                        double v74 = (char *)*((void *)v70 - 3);
                        uint64_t v75 = (v72 - v74) >> 3;
                        unint64_t v76 = v75 + 1;
                        if ((unint64_t)(v75 + 1) >> 61) {
                          abort();
                        }
                        uint64_t v77 = v71 - (void)v74;
                        if (v77 >> 2 > v76) {
                          unint64_t v76 = v77 >> 2;
                        }
                        if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
                          unint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          unint64_t v78 = v76;
                        }
                        if (v78)
                        {
                          if (v78 >> 61) {
                            goto LABEL_209;
                          }
                          char v79 = (char *)operator new(8 * v78);
                        }
                        else
                        {
                          char v79 = 0;
                        }
                        unint64_t v80 = &v79[8 * v75];
                        *(void *)unint64_t v80 = v62;
                        uint64_t v73 = v80 + 8;
                        if (v72 == v74)
                        {
                          id v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                          goto LABEL_140;
                        }
                        unint64_t v81 = v72 - 8 - v74;
                        if (v81 >= 0x58)
                        {
                          id v8 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
                          if ((unint64_t)(v74 - v79) >= 0x20)
                          {
                            uint64_t v82 = (v81 >> 3) + 1;
                            long long v83 = &v79[8 * v75 - 16];
                            unint64_t v84 = (long long *)(v72 - 16);
                            uint64_t v85 = v82 & 0x3FFFFFFFFFFFFFFCLL;
                            do
                            {
                              long long v86 = *v84;
                              *((_OWORD *)v83 - 1) = *(v84 - 1);
                              *(_OWORD *)long long v83 = v86;
                              v83 -= 32;
                              v84 -= 2;
                              v85 -= 4;
                            }
                            while (v85);
                            v80 -= 8 * (v82 & 0x3FFFFFFFFFFFFFFCLL);
                            v72 -= 8 * (v82 & 0x3FFFFFFFFFFFFFFCLL);
                            if (v82 == (v82 & 0x3FFFFFFFFFFFFFFCLL)) {
                              goto LABEL_139;
                            }
                          }
                        }
                        else
                        {
                          id v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                        }
                        do
                        {
                          uint64_t v87 = *((void *)v72 - 1);
                          v72 -= 8;
                          *((void *)v80 - 1) = v87;
                          v80 -= 8;
                        }
                        while (v72 != v74);
LABEL_139:
                        double v72 = (char *)*((void *)v70 - 3);
LABEL_140:
                        *((void *)v70 - 3) = v80;
                        *((void *)v70 - 2) = v73;
                        *((void *)v70 - 1) = &v79[8 * v78];
                        if (v72) {
                          operator delete(v72);
                        }
                        goto LABEL_142;
                      }
                      *(void *)unint64_t v133 = 0;
                      *((void *)v65 + 1) = 0;
                      *((void *)v65 + 2) = 0;
                      int v70 = v65 + 24;
                      unint64_t v133 = v65 + 24;
                    }
                    else
                    {
                      int v70 = v133;
                    }
                    id v8 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
                    goto LABEL_118;
                  }
                  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v139 + 40))(v139, __dst, v138 & 0x7FFFFFFFFFFFFFFFLL);
                  goto LABEL_96;
                }
LABEL_91:
                atomic_fetch_add_explicit((atomic_ullong *volatile)v17 + 1, 1uLL, memory_order_relaxed);
                goto LABEL_92;
              }
              if ((v48 & 0x80) != 0)
              {
                std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__assign_no_alias<true>((void **)v51, *(void **)(v46 + 80), *(void *)(v46 + 88));
              }
              else
              {
                long long v53 = *(_OWORD *)v50;
                *((void *)v17 + 7) = *(void *)(v46 + 96);
                *(_OWORD *)std::string::size_type v51 = v53;
              }
            }
            int v135 = (md::LabelImageKey *)(v17 + 24);
            char v136 = (std::__shared_weak_count *)v17;
            goto LABEL_91;
          }
          unint64_t v24 = 0;
          id v26 = (int *)(v23 + 8);
          while (v21 - 1 != v24)
          {
            int v27 = *v26;
            v26 += 2;
            ++v24;
            if (v27 == 4)
            {
              if (v24 < v21) {
                goto LABEL_22;
              }
              break;
            }
          }
        }
        int v25 = 0xFFFF;
        goto LABEL_29;
      }
      int v25 = 0xFFFF;
      uint64_t v22 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      goto LABEL_29;
    }
LABEL_146:
    if (SHIBYTE(v130) < 0) {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v131 + 40))(v131, v129, v130 & 0x7FFFFFFFFFFFFFFFLL);
    }
    ++v7;
  }
  while (v7 < (uint64_t)(*(void *)(a1 + 304) - *(void *)(a1 + 296)) >> 3);
  unint64_t v102 = v132;
  BOOL v101 = v133;
  if (v132 == v133)
  {
    unint64_t v114 = 0;
    if (v133) {
      goto LABEL_201;
    }
  }
  else
  {
    unint64_t v103 = (char *)(v133 - v132);
    if ((0xAAAAAAAAAAAAAAABLL * ((v133 - v132) >> 3)) >> 61) {
      abort();
    }
    size_t v104 = 0x5555555555555558 * ((v133 - v132) >> 3);
    unint64_t v105 = (md::LabelPart **)operator new(v104);
    bzero(v105, 0x5555555555555558 * ((v101 - v102) >> 3));
    unint64_t v106 = 0;
    do
    {
      uint64_t v107 = (md::LabelPart ***)&v102[24 * v106];
      if ((char *)v107[1] - (char *)*v107 == 8)
      {
        v105[v106] = **v107;
      }
      else
      {
        {
          operator new();
        }
        uint64_t v108 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                    + 16))(mdm::Allocator::instance(void)::alloc, 696, 8);
        md::StackLabelPart::StackLabelPart(v108, 1, 0, 0, 1);
        float v109 = *v107;
        unint64_t v110 = v107[1];
        if (*v107 != v110)
        {
          do
            md::CompositeLabelPart::addLabelPart(v108, *v109++);
          while (v109 != v110);
        }
        v105[v106] = (md::LabelPart *)v108;
        unint64_t v102 = v132;
        BOOL v101 = v133;
      }
      ++v106;
    }
    while (v106 < 0xAAAAAAAAAAAAAAABLL * ((v101 - v102) >> 3));
    if (v103 == (char *)24)
    {
      unint64_t v111 = *v105;
      uint64_t v113 = v121;
      uint64_t v112 = v122;
    }
    else
    {
      uint64_t v113 = v121;
      uint64_t v112 = v122;
      {
        operator new();
      }
      unint64_t v111 = (md::LabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                   + 16))(mdm::Allocator::instance(void)::alloc, 696, 8);
      md::StackLabelPart::StackLabelPart((uint64_t)v111, 0, 0, 0, 0);
      uint64_t v115 = v105;
      do
      {
        md::CompositeLabelPart::addLabelPart((uint64_t)v111, *v115++);
        v104 -= 8;
      }
      while (v104);
    }
    {
      operator new();
    }
    unint64_t v114 = (md::CompositeLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                          + 16))(mdm::Allocator::instance(void)::alloc, 648, 8);
    md::WorldSpaceLabelPart::WorldSpaceLabelPart(v114, v111, v112, *(unsigned char *)(v113 + 253), 0);
    operator delete(v105);
    BOOL v101 = v132;
    if (v132)
    {
LABEL_201:
      uint64_t v116 = v133;
      if (v133 != v101)
      {
        unint64_t v117 = v133;
        do
        {
          unint64_t v119 = (void *)*((void *)v117 - 3);
          v117 -= 24;
          float v118 = v119;
          if (v119)
          {
            *((void *)v116 - 2) = v118;
            operator delete(v118);
          }
          uint64_t v116 = v117;
        }
        while (v117 != v101);
      }
      unint64_t v133 = v101;
      operator delete(v101);
    }
  }
  return v114;
}

void sub_1A210ABD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,char a36)
{
  operator delete(v36);
  std::vector<std::vector<unsigned long>>::~vector[abi:nn180100](&a33);
  _Unwind_Resume(a1);
}

uint64_t RouteAnnotationIconLabelPart::needsCrossfade(uint64_t a1, uint64_t a2, int a3, unsigned char *a4)
{
  if (!a3) {
    return 0;
  }
  uint64_t v5 = (unsigned __int8 *)(a1 + 768);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = *(void *)(v6 + 8);
  uint64_t v8 = *(unsigned int *)(v6 + 48);
  LOBYTE(v6) = atomic_load((unsigned __int8 *)(v6 + 1240));
  uint64_t v9 = *(void *)(*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void))(*(void *)v7 + 552))(v7, v8, 0, v6 & 1, 0);
  return md::LabelIconStyleMonitor::needsCrossfade(v5, v9, a4);
}

uint64_t RouteAnnotationIconLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5)
{
  if (*(unsigned char *)(a2 + 449)) {
    uint64_t v10 = 3;
  }
  else {
    uint64_t v10 = 4;
  }
  double v11 = (*(double (**)(uint64_t, uint64_t))(*(void *)a1 + 816))(a1, v10);
  md::IconLabelPart::layoutForDisplay(a1, a2, a3, a4, a5, v11, v12, v13);
  return 37;
}

void RouteAnnotationIconLabelPart::~RouteAnnotationIconLabelPart(RouteAnnotationIconLabelPart *this)
{
  *(void *)this = &unk_1EF52FC00;
  if (*((char *)this + 791) < 0) {
    (*(void (**)(void, void, uint64_t))(**((void **)this + 99) + 40))(*((void *)this + 99), *((void *)this + 96), *((void *)this + 98) & 0x7FFFFFFFFFFFFFFFLL);
  }
  md::IconLabelPart::~IconLabelPart(this);
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v4) {
      operator new();
    }
  }
  uint64_t v3 = *(void (**)(void))(**((void **)v2 + 91) + 40);
  v3();
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF52FC00;
  if (*((char *)this + 791) < 0) {
    (*(void (**)(void, void, uint64_t))(**((void **)this + 99) + 40))(*((void *)this + 99), *((void *)this + 96), *((void *)this + 98) & 0x7FFFFFFFFFFFFFFFLL);
  }
  md::IconLabelPart::~IconLabelPart(this);
}

uint64_t md::RouteAnnotationLabelFeature::labelTypeAtPosition()
{
  return 13;
}

void md::RouteAnnotationLabelFeature::~RouteAnnotationLabelFeature(md::RouteAnnotationLabelFeature *this)
{
  md::RouteAnnotationLabelFeature::~RouteAnnotationLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void (***v10)(void, void);
  void (***v11)(void, void);
  uint64_t v12;
  void (***v13)(void, void);
  void (***v14)(void, void);
  void (***v15)(void, void);
  void (**v16)(void, uint64_t);
  BOOL v17;
  std::__shared_weak_count *v18;
  uint64_t vars8;

  *(void *)this = &unk_1EF548A10;
  uint64_t v2 = *((void *)this + 41);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 42);
    int v4 = *((void *)this + 41);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v5->__on_zero_shared)(v5, v4);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      int v4 = *((void *)this + 41);
    }
    *((void *)this + 42) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 44) + 40))(*((void *)this + 44), v4, *((void *)this + 43) - v4);
  }
  uint64_t v6 = *((void *)this + 37);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 38);
    uint64_t v8 = *((void *)this + 37);
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = *(void **)(v7 - 8);
        v7 -= 8;
      }
      while (v7 != v6);
      uint64_t v8 = *((void *)this + 37);
    }
    *((void *)this + 38) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 40) + 40))(*((void *)this + 40), v8, *((void *)this + 39) - v8);
  }
  uint64_t v10 = (void (***)(void, void))*((void *)this + 33);
  if (v10)
  {
    double v11 = (void (***)(void, void))*((void *)this + 34);
    double v12 = *((void *)this + 33);
    if (v11 != v10)
    {
      double v13 = v11 - 3;
      uint64_t v14 = v11 - 3;
      long long v15 = v11 - 3;
      do
      {
        uint64_t v16 = *v15;
        v15 -= 3;
        (*v16)(v14, v12);
        v13 -= 3;
        id v17 = v14 == v10;
        uint64_t v14 = v15;
      }
      while (!v17);
      double v12 = *((void *)this + 33);
    }
    *((void *)this + 34) = v10;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 36) + 40))(*((void *)this + 36), v12, *((void *)this + 35) - v12);
  }
  uint64_t v18 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  md::LabelFeature::~LabelFeature(this);
}

uint64_t std::vector<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::__emplace_back_slow_path<VKTrafficFeature * {__strong}&,geo::memory_management_mode const&>(uint64_t *a1, id *a2)
{
  uint64_t v2 = 0xAAAAAAAAAAAAAAALL;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) < 0x555555555555555) {
    uint64_t v2 = v4;
  }
  if (v2)
  {
    uint64_t v7 = 24 * v2;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 24 * v2, 8);
    uint64_t v9 = v8 + 24 * v3;
    uint64_t v10 = v8 + v7;
    if (v8)
    {
      uint64_t v11 = v8;
      id v12 = *a2;
      *(void *)uint64_t v9 = &unk_1EF5596F8;
      *(void *)(v11 + 24 * v3 + 8) = v12;
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 8 * ((a1[1] - *a1) >> 3);
  }
  uint64_t v13 = v9 + 24;
  long long v15 = (char *)*a1;
  uint64_t v14 = (char *)a1[1];
  if (v14 == (char *)*a1)
  {
    *a1 = v9;
    a1[1] = v13;
    uint64_t v19 = (char *)a1[2];
    a1[2] = v10;
    if (!v14) {
      return v13;
    }
    goto LABEL_18;
  }
  uint64_t v16 = v9 - 24;
  do
  {
    *(void *)(v9 - 24) = &unk_1EF5596F8;
    v9 -= 24;
    *(void *)(v9 + 8) = 0;
    objc_storeStrong((id *)(v9 + 8), *((id *)v14 - 2));
    id v17 = (void *)*((void *)v14 - 2);
    *((void *)v14 - 2) = 0;

    v16 -= 24;
    v14 -= 24;
  }
  while (v14 != v15);
  uint64_t v14 = (char *)*a1;
  uint64_t v18 = (char *)a1[1];
  *a1 = v9;
  a1[1] = v13;
  uint64_t v19 = (char *)a1[2];
  a1[2] = v10;
  if (v18 != v14)
  {
    uint64_t v20 = v18 - 24;
    unint64_t v21 = v18 - 24;
    uint64_t v22 = v18 - 24;
    do
    {
      uint64_t v23 = *(void (***)(char *))v22;
      v22 -= 24;
      (*v23)(v21);
      v20 -= 24;
      BOOL v24 = v21 == v14;
      unint64_t v21 = v22;
    }
    while (!v24);
  }
  if (v14) {
LABEL_18:
  }
    (*(void (**)(uint64_t, char *, int64_t))(*(void *)a1[3] + 40))(a1[3], v14, v19 - v14);
  return v13;
}

void geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5596F8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5596F8;

  return a1;
}

void std::__introsort<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
void sub_1A210BFD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

BOOL md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)(a1 + 8);
  int v5 = [v4 groupItemVerticalDisplayOrder];
  int v6 = [*(id *)(a2 + 8) groupItemVerticalDisplayOrder];

  id v7 = *(id *)(a1 + 8);
  uint64_t v8 = v7;
  if (v5 == v6)
  {
    int v9 = [v7 groupItemHorizontalDisplayOrder];
    int v10 = [*(id *)(a2 + 8) groupItemHorizontalDisplayOrder];

    id v11 = *(id *)(a1 + 8);
    uint64_t v8 = v11;
    if (v9 == v10)
    {
      unsigned int v12 = [v11 collisionPriority];
      unsigned int v13 = [*(id *)(a2 + 8) collisionPriority];
    }
    else
    {
      unsigned int v12 = [v11 groupItemHorizontalDisplayOrder];
      unsigned int v13 = [*(id *)(a2 + 8) groupItemHorizontalDisplayOrder];
    }
  }
  else
  {
    unsigned int v12 = [v7 groupItemVerticalDisplayOrder];
    unsigned int v13 = [*(id *)(a2 + 8) groupItemVerticalDisplayOrder];
  }
  BOOL v14 = v12 > v13;

  return v14;
}

void sub_1A210C16C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = (id *)(a1 + 8);
  obuint64_t j = *(id *)(a1 + 8);
  id v4 = *v3;
  id *v3 = 0;

  int v5 = *(void **)(a2 + 8);
  a2 += 8;
  objc_storeStrong(v3, v5);
  id v6 = *(id *)a2;
  *(void *)a2 = 0;

  objc_storeStrong((id *)a2, obj);
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a2, a1);
  BOOL v7 = md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a3, a2);
  if (v6)
  {
    if (v7)
    {
      uint64_t v8 = a1;
    }
    else
    {
      std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a1, a2);
      if (!md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a3, a2))return; {
      uint64_t v8 = a2;
      }
    }
    uint64_t v9 = a3;
  }
  else
  {
    if (!v7) {
      return;
    }
    std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a2, a3);
    if (!md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a2, a1))return; {
    uint64_t v8 = a1;
    }
    uint64_t v9 = a2;
  }
  std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(v8, v9);
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>(a1, a2, a3);
  if (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a4, a3))
  {
    std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a3, a4);
    if (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a3, a2))
    {
      std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a2, a3);
      if (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a2, a1))
      {
        std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a1, a2);
      }
    }
  }
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *,0>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>(a1, a2, a3, a4);
  if (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a5, a4))
  {
    std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a4, a5);
    if (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a4, a3))
    {
      std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a3, a4);
      if (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a3, a2))
      {
        std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a2, a3);
        if (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a2, a1))
        {
          std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a1, a2);
        }
      }
    }
  }
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>(uint64_t a1, uint64_t a2)
{
  BOOL v4 = 1;
  switch(0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 3))
  {
    case 0uLL:
    case 1uLL:
      return v4;
    case 2uLL:
      uint64_t v5 = a2 - 24;
      if (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(a2 - 24, a1))
      {
        std::swap[abi:nn180100]<geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(a1, v5);
      }
      return v4;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>(a1, a1 + 24, a2 - 24);
      return v4;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>(a1, a1 + 24, a1 + 48, a2 - 24);
      return v4;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *,0>(a1, a1 + 24, a1 + 48, a1 + 72, a2 - 24);
      return v4;
    default:
      uint64_t v6 = a1 + 48;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0 &,geo::_retain_ptr<VKTrafficFeature * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>(a1, a1 + 24, a1 + 48);
      uint64_t v7 = a1 + 72;
      if (a1 + 72 == a2) {
        return 1;
      }
      uint64_t v8 = 0;
      int v9 = 0;
      break;
  }
  while (1)
  {
    if (!md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()(v7, v6))goto LABEL_9; {
    unint64_t v17 = &unk_1EF5596F8;
    }
    obuint64_t j = *(id *)(v7 + 8);
    unsigned int v12 = *(void **)(v7 + 8);
    *(void *)(v7 + 8) = 0;

    uint64_t v13 = v8;
    do
    {
      uint64_t v14 = a1 + v13;
      objc_storeStrong((id *)(a1 + v13 + 80), *(id *)(a1 + v13 + 56));
      unint64_t v15 = *(void **)(a1 + v13 + 56);
      *(void *)(a1 + v13 + 56) = 0;

      if (v13 == -48)
      {
        uint64_t v10 = a1;
        goto LABEL_7;
      }
      v13 -= 24;
    }
    while (md::RouteAnnotationLabelFeature::RouteAnnotationLabelFeature(geo::Mercator3<double> const&,geo::PolylineCoordinate const&,double,double,std::vector<VKTrafficFeature * {__strong}> const&,std::shared_ptr<md::LabelDedupingGroup> const&,md::LabelManager *)::$_0::operator()((uint64_t)&v17, v14 + 24));
    uint64_t v10 = a1 + v13 + 72;
LABEL_7:
    objc_storeStrong((id *)(v10 + 8), obj);
    id v11 = obj;
    obuint64_t j = 0;

    if (++v9 == 8) {
      break;
    }
    unint64_t v17 = &unk_1EF5596F8;

LABEL_9:
    uint64_t v6 = v7;
    v8 += 24;
    v7 += 24;
    if (v7 == a2) {
      return 1;
    }
  }
  BOOL v4 = v7 + 24 == a2;
  unint64_t v17 = &unk_1EF5596F8;

  return v4;
}

void sub_1A210C6BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

uint64_t md::RouteElevationSource::shouldDrapeOnTerrain(md::RouteElevationSource *this)
{
  return 0;
}

uint64_t md::RouteElevationSource::elevationForCoordinate()
{
  return 0;
}

void md::RouteElevationSource::~RouteElevationSource(md::RouteElevationSource *this)
{
  *(void *)this = &unk_1EF513470;
  *((void *)this + 12) = 0;
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 8);
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF513470;
  *((void *)this + 12) = 0;
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 8);
}

uint64_t md::FlyoverRouteElevationSource::shouldDrapeOnTerrain(md::FlyoverRouteElevationSource *this)
{
  return *((unsigned __int8 *)this + 120);
}

uint64_t md::FlyoverRouteElevationSource::elevationForCoordinate(uint64_t a1, double *a2, void *a3)
{
  if (!*(unsigned char *)(a1 + 120))
  {
    uint64_t v29 = *(md::GeoidModel **)(a1 + 96);
    if (!v29) {
      goto LABEL_40;
    }
    double v30 = a2[2];
    Undulatiouint64_t n = md::GeoidModel::getUndulation(v29, *a2, a2[1]);
    double v32 = *(float *)&Undulation;
    if (!HIDWORD(Undulation)) {
      double v32 = 0.0;
    }
    float v4 = v32 + v30;
    unint64_t v33 = 0x100000000;
    return v33 & 0xFF00000000 | (v3 << 40) | LODWORD(v4);
  }
  unint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v7 = (void *)a3[5];
  unint64_t v3 = (unint64_t)(a3 + 6);
  if (v7 == a3 + 6) {
    goto LABEL_40;
  }
  double v8 = a2[1];
  float v4 = 3.3703e12;
  long double v9 = tan(*a2 * 0.00872664626 + 0.785398163);
  double v10 = log(v9) * 0.159154943 + 0.5;
  int8x8_t v11 = (int8x8_t)a3[1];
  uint8x8_t v12 = (uint8x8_t)vcnt_s8(v11);
  v12.i16[0] = vaddlv_u8(v12);
  unint64_t v13 = v12.u32[0];
  uint64_t v14 = *(void *)&v11 - 1;
  while (1)
  {
    if (v11)
    {
      uint64_t v15 = *((unsigned __int8 *)v7 + 25);
      double v16 = (double)(1 << v15);
      signed int v17 = vcvtmd_s64_f64((v8 * 0.00277777778 + 0.5) * v16);
      signed int v18 = (1 << v15) + ~vcvtmd_s64_f64(v10 * v16);
      unint64_t v19 = (v18
           - 0x61C8864680B583EBLL
           + (((v15 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14) << 6)
           + (((v15 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14) >> 2)) ^ (v15 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14;
      unint64_t v20 = (v17 - 0x61C8864680B583EBLL + (v19 << 6) + (v19 >> 2)) ^ v19;
      if (v13 > 1)
      {
        unint64_t v21 = v20;
        if (v20 >= *(void *)&v11) {
          unint64_t v21 = v20 % *(void *)&v11;
        }
      }
      else
      {
        unint64_t v21 = v20 & v14;
      }
      unint64_t v22 = *(uint64_t ***)(*a3 + 8 * v21);
      if (v22)
      {
        BOOL v23 = *v22;
        if (v23) {
          break;
        }
      }
    }
LABEL_30:
    id v26 = (void *)v7[1];
    if (v26)
    {
      do
      {
        uint64_t v27 = v26;
        id v26 = (void *)*v26;
      }
      while (v26);
    }
    else
    {
      do
      {
        uint64_t v27 = (void *)v7[2];
        BOOL v28 = *v27 == (void)v7;
        uint64_t v7 = v27;
      }
      while (!v28);
    }
    uint64_t v7 = v27;
    if (v27 == (void *)v3) {
      goto LABEL_40;
    }
  }
  if (v13 < 2)
  {
    while (1)
    {
      uint64_t v24 = v23[1];
      if (v20 == v24)
      {
        if (__PAIR64__(*((unsigned __int8 *)v23 + 17), *((unsigned __int8 *)v23 + 16)) == __PAIR64__(v15, 255)
          && *((_DWORD *)v23 + 5) == v18
          && *((_DWORD *)v23 + 6) == v17)
        {
          goto LABEL_42;
        }
      }
      else if ((v24 & v14) != v21)
      {
        goto LABEL_30;
      }
      BOOL v23 = (uint64_t *)*v23;
      if (!v23) {
        goto LABEL_30;
      }
    }
  }
  while (1)
  {
    unint64_t v25 = v23[1];
    if (v20 == v25) {
      break;
    }
    if (v25 >= *(void *)&v11) {
      v25 %= *(void *)&v11;
    }
    if (v25 != v21) {
      goto LABEL_30;
    }
LABEL_22:
    BOOL v23 = (uint64_t *)*v23;
    if (!v23) {
      goto LABEL_30;
    }
  }
  if (__PAIR64__(*((unsigned __int8 *)v23 + 17), *((unsigned __int8 *)v23 + 16)) != __PAIR64__(v15, 255)
    || *((_DWORD *)v23 + 5) != v18
    || *((_DWORD *)v23 + 6) != v17)
  {
    goto LABEL_22;
  }
LABEL_42:
  unint64_t v3 = v23[5];
  uint64_t v35 = (std::__shared_weak_count *)v23[6];
  if (v35) {
    atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v53 = v3;
  uint64_t v54 = v35;
  char v36 = 1;
  if (!v3)
  {
    unint64_t v33 = 0;
LABEL_57:
    if (!v35) {
      goto LABEL_60;
    }
LABEL_58:
    if (!atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
    goto LABEL_60;
  }
  int v37 = 1 << *(unsigned char *)(v3 + 169);
  double v38 = 1.0 / (double)v37;
  double v39 = v38 * (double)*(int *)(v3 + 176);
  int v40 = *(_DWORD *)(v3 + 172);
  double v41 = a2[1];
  uint64_t v42 = *((void *)a2 + 2);
  long double v43 = tan(*a2 * 0.00872664626 + 0.785398163);
  long double v44 = log(v43);
  double v45 = v41 * 0.00277777778 + 0.5;
  double v46 = v44 * 0.159154943 + 0.5;
  *(double *)unint64_t v52 = v45;
  *(double *)&v52[1] = v46;
  v52[2] = v42;
  double v47 = v38 * (double)(v37 + ~v40);
  if (v45 < v39 || v45 >= v39 + v38 || v46 < v47 || v46 >= v47 + v38)
  {
    unint64_t v33 = 0;
    char v36 = 1;
    goto LABEL_57;
  }
  unint64_t v51 = (*(uint64_t (**)(unint64_t, void *, uint64_t))(*(void *)v3 + 56))(v3, v52, 1);
  char v36 = 0;
  float v4 = *(float *)&v51;
  unint64_t v33 = v51 & 0xFFFFFFFF00000000;
  unint64_t v3 = v51 >> 40;
  if (v35) {
    goto LABEL_58;
  }
LABEL_60:
  if ((v36 & 1) == 0) {
    return v33 & 0xFF00000000 | (v3 << 40) | LODWORD(v4);
  }
LABEL_40:
  unint64_t v33 = 0;
  LODWORD(v4) &= 0xFFFFFF00;
  return v33 & 0xFF00000000 | (v3 << 40) | LODWORD(v4);
}

void sub_1A210CBD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::FlyoverRouteElevationSource::~FlyoverRouteElevationSource(md::FlyoverRouteElevationSource *this)
{
  md::FlyoverRouteElevationSource::~FlyoverRouteElevationSource(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;
  void *v6;

  *(void *)this = &unk_1EF513B40;
  uint64_t v2 = (void *)*((void *)this + 28);
  if (v2 != *((void **)this + 30)) {
    free(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 25);
  while (v3)
  {
    float v4 = v3;
    unint64_t v3 = (void *)*v3;
    uint64_t v5 = (std::__shared_weak_count *)v4[6];
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
    operator delete(v4);
  }
  uint64_t v6 = (void *)*((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v6) {
    operator delete(v6);
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 104);
  *(void *)this = &unk_1EF513470;
  *((void *)this + 12) = 0;
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 8);
}

md::GeoidModel *md::StandardRouteElevationSource::elevationForCoordinate(uint64_t a1, double *a2)
{
  uint64_t result = *(md::GeoidModel **)(a1 + 96);
  if (result)
  {
    double v3 = a2[2];
    Undulatiouint64_t n = md::GeoidModel::getUndulation(result, *a2, a2[1]);
    double v5 = *(float *)&Undulation;
    if (!HIDWORD(Undulation)) {
      double v5 = 0.0;
    }
    *(float *)&unsigned int v6 = v5 + v3;
    return (md::GeoidModel *)(v6 | 0x100000000);
  }
  return result;
}

void md::StandardRouteElevationSource::~StandardRouteElevationSource(md::StandardRouteElevationSource *this)
{
  *(void *)this = &unk_1EF513470;
  *((void *)this + 12) = 0;
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 8);
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF513470;
  *((void *)this + 12) = 0;
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 8);
}

void std::__function::__func<md::RouteElevationSource::RouteElevationSource(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::RouteElevationSource::RouteElevationSource(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  id v4 = [MEMORY[0x1E4F64918] modernManager];
  uint64_t v2 = [v4 activeTileGroup];
  double v3 = [v2 activeTileSetForTileType:92 scale:1];
  *(unsigned char *)(v1 + 88) = v3 != 0;

  if (*(unsigned char *)(v1 + 24) && *(unsigned char *)(v1 + 88))
  {
    id v5 = +[VKSharedResourcesManager sharedResources];
    *(void *)(v1 + 96) = [v5 undulationModel];
  }
  else
  {
    *(void *)(v1 + 96) = 0;
  }
}

void sub_1A210CF0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::RouteElevationSource::RouteElevationSource(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::RouteElevationSource::RouteElevationSource(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF51E458;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::RouteElevationSource::RouteElevationSource(NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::RouteElevationSource::RouteElevationSource(NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::~__func()
{
}

float *md::DashTextureCache::textureForPattern(void *a1, uint64_t a2, float *a3, unsigned int a4, float a5)
{
  uint64_t v9 = *((void *)a3 + 3);
  uint64_t v10 = *(void *)a3;
  uint64_t v11 = *((void *)a3 + 1);
  uint64_t v12 = v11 - *(void *)a3;
  if (v11 == *(void *)a3)
  {
    uint64_t v18 = 0;
    uint64_t v17 = 0;
    uint64_t v15 = 0;
  }
  else
  {
    if (v12 < 0) {
      goto LABEL_176;
    }
    uint64_t v13 = v12 >> 2;
    uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(*((void *)a3 + 3));
    uint64_t v15 = v14;
    uint64_t v16 = 0;
    do
    {
      if (v14 + v16) {
        *(_DWORD *)(v14 + v16) = *(_DWORD *)(v10 + v16);
      }
      v16 += 4;
    }
    while (v10 + v16 != v11);
    uint64_t v17 = v14 + v16;
    uint64_t v18 = v14 + 4 * v13;
  }
  float v19 = a3[8];
  uint64_t v120 = 0;
  uint64_t v121 = 0;
  uint64_t v122 = 0;
  uint64_t v123 = v9;
  uint64_t v20 = v17 - v15;
  if (v17 == v15)
  {
    unint64_t v25 = 0;
    BOOL v23 = 0;
  }
  else
  {
    if (v20 < 0) {
      goto LABEL_176;
    }
    uint64_t v21 = v20 >> 2;
    uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
    BOOL v23 = (float *)v22;
    uint64_t v24 = 0;
    uint64_t v120 = v22;
    uint64_t v122 = v22 + 4 * v21;
    do
    {
      if (v22 + v24) {
        *(_DWORD *)(v22 + v24) = *(_DWORD *)(v15 + v24);
      }
      v24 += 4;
    }
    while (v15 + v24 != v17);
    unint64_t v25 = (float *)(v22 + v24);
    uint64_t v121 = v22 + v24;
  }
  float v124 = v19;
  unint64_t v118 = (int)(float)(a5 + 0.5);
  __int16 v125 = (int)(float)(a5 + 0.5);
  char v126 = 0;
  char v127 = a4;
  if (v15) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 40))(v9, v15, v18 - v15);
  }
  unint64_t v26 = (LODWORD(v19) - 0x61C8864680B57FA7) ^ 0x11;
  if (v19 == 0.0) {
    unint64_t v26 = 0x9E3779B97F4A8048;
  }
  if (v23 != v25)
  {
    uint64_t v27 = v23;
    do
    {
      float v28 = *v27++;
      uint64_t v29 = LODWORD(v28) - 0x61C8864680B583EBLL;
      if (v28 == 0.0) {
        uint64_t v29 = 0x9E3779B97F4A7C15;
      }
      v26 ^= (v26 >> 2) + (v26 << 6) + v29;
    }
    while (v27 != v25);
  }
  int8x8_t v30 = *(int8x8_t *)(a2 + 8);
  if (!*(void *)&v30) {
    goto LABEL_64;
  }
  unint64_t v31 = v26 ^ a4 ^ v118;
  uint8x8_t v32 = (uint8x8_t)vcnt_s8(v30);
  v32.i16[0] = vaddlv_u8(v32);
  if (v32.u32[0] > 1uLL)
  {
    unint64_t v33 = v31;
    if (v31 >= *(void *)&v30) {
      unint64_t v33 = v31 % *(void *)&v30;
    }
  }
  else
  {
    unint64_t v33 = (*(void *)&v30 - 1) & v31;
  }
  uint64_t v34 = *(uint64_t ***)(*(void *)a2 + 8 * v33);
  if (!v34 || (uint64_t v35 = *v34) == 0)
  {
LABEL_64:
    uint64_t v48 = operator new(0x60uLL);
    v48[1] = 0;
    v48[2] = 0;
    void *v48 = &unk_1EF57F808;
    uint64_t v117 = *((void *)a3 + 3);
    uint64_t v49 = *(void *)a3;
    uint64_t v50 = *((void *)a3 + 1);
    if (v50 == *(void *)a3)
    {
      uint64_t v54 = 0;
      unint64_t v52 = 0;
    }
    else
    {
      if (v50 - *(void *)a3 < 0) {
        goto LABEL_176;
      }
      uint64_t v51 = (*(uint64_t (**)(uint64_t))(*(void *)v117 + 16))(v117);
      unint64_t v52 = (float *)v51;
      uint64_t v53 = 0;
      do
      {
        if (v51 + v53) {
          *(_DWORD *)(v51 + v53) = *(_DWORD *)(v49 + v53);
        }
        v53 += 4;
      }
      while (v49 + v53 != v50);
      uint64_t v54 = (float *)(v51 + v53);
    }
    int v55 = *((_DWORD *)a3 + 8);
    v48[4] = 0;
    v48[5] = 0;
    v48[3] = 0;
    v48[6] = v117;
    uint64_t v56 = (char *)v54 - (char *)v52;
    if (v54 == v52)
    {
      unint64_t v61 = 0;
      uint64_t v59 = 0;
      unint64_t v62 = v54;
    }
    else
    {
      if (v56 < 0) {
        goto LABEL_176;
      }
      uint64_t v57 = v56 >> 2;
      uint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)v117 + 16))(v117);
      uint64_t v59 = v58;
      unint64_t v60 = 0;
      v48[3] = v58;
      v48[5] = v58 + 4 * v57;
      do
      {
        if (v58 + v60) {
          *(float *)(v58 + v60) = v52[v60 / 4];
        }
        v60 += 4;
      }
      while (&v52[v60 / 4] != v54);
      unint64_t v61 = v58 + v60;
      v48[4] = v58 + v60;
      unint64_t v62 = v52;
    }
    *((_DWORD *)v48 + 14) = v55;
    *((unsigned char *)v48 + 80) = a4;
    v48[11] = 0;
    *((_DWORD *)v48 + 18) = v55;
    *((_WORD *)v48 + 35) = v118;
    if (v54 == v62)
    {
      id v63 = (float *)operator new(0xCuLL);
      *((_DWORD *)v63 + 2) = 1;
      *(void *)id v63 = 0x40000000BF800000;
      uint64_t v64 = v63 + 3;
      unsigned int v77 = a4;
    }
    else
    {
      id v63 = 0;
      uint64_t v64 = 0;
      unint64_t v65 = 0;
      do
      {
        if (v64 == v63)
        {
          char v67 = 1;
          float v66 = 0.0;
        }
        else
        {
          float v66 = *(v64 - 2);
          char v67 = *((unsigned char *)v64 - 4) ^ 1;
        }
        float v68 = *v62 + v66;
        if (v64 < v65)
        {
          *uint64_t v64 = v66;
          v64[1] = v68;
          *((unsigned char *)v64 + 8) = v67;
          v64 += 3;
        }
        else
        {
          uint64_t v69 = ((char *)v64 - (char *)v63) / 12;
          unint64_t v70 = v69 + 1;
          if ((unint64_t)(v69 + 1) > 0x1555555555555555) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          if (0x5555555555555556 * (v65 - v63) > v70) {
            unint64_t v70 = 0x5555555555555556 * (v65 - v63);
          }
          if (0xAAAAAAAAAAAAAAABLL * (v65 - v63) >= 0xAAAAAAAAAAAAAAALL) {
            unint64_t v71 = 0x1555555555555555;
          }
          else {
            unint64_t v71 = v70;
          }
          if (v71)
          {
            if (v71 > 0x1555555555555555) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            double v72 = (char *)operator new(12 * v71);
          }
          else
          {
            double v72 = 0;
          }
          uint64_t v73 = (float *)&v72[12 * v69];
          float *v73 = v66;
          v73[1] = v68;
          *((unsigned char *)v73 + 8) = v67;
          for (uint64_t i = v73; v64 != v63; *((_DWORD *)i + 2) = v76)
          {
            uint64_t v75 = *(void *)(v64 - 3);
            v64 -= 3;
            int v76 = *((_DWORD *)v64 + 2);
            *(void *)(i - 3) = v75;
            i -= 3;
          }
          unint64_t v65 = (float *)&v72[12 * v71];
          uint64_t v64 = v73 + 3;
          if (v63) {
            operator delete(v63);
          }
          id v63 = i;
        }
        ++v62;
      }
      while (v62 != v54);
      unsigned int v77 = *((unsigned __int8 *)v48 + 80);
      uint64_t v59 = v48[3];
      unint64_t v61 = v48[4];
    }
    __int16 v78 = v77 == 0;
    if (v118 <= 1) {
      __int16 v79 = 1;
    }
    else {
      __int16 v79 = v118;
    }
    __int16 v80 = v79 + 4 * v78;
    if ((v80 & 0xF800) != 0) {
      __int16 v80 = 2048;
    }
    *((_WORD *)v48 + 32) = v80;
    uint64_t v81 = v48[6];
    uint64_t v82 = v61 - v59;
    if (v61 == v59)
    {
      uint64_t v86 = 0;
      goto LABEL_118;
    }
    if ((v82 & 0x8000000000000000) == 0)
    {
      uint64_t v83 = v82 >> 2;
      uint64_t v84 = (*(uint64_t (**)(void))(*(void *)v81 + 16))(v48[6]);
      uint64_t v82 = v84;
      uint64_t v85 = 0;
      do
      {
        if (v84 + v85) {
          *(_DWORD *)(v84 + v85) = *(_DWORD *)(v59 + v85);
        }
        v85 += 4;
      }
      while (v59 + v85 != v61);
      uint64_t v86 = v84 + 4 * v83;
LABEL_118:
      unsigned int v87 = (int)(float)(*((float *)v48 + 14) + 0.5);
      if (v87 <= 1) {
        unsigned int v87 = 1;
      }
      if (v87 >= 0x800) {
        LOWORD(v87) = 2048;
      }
      *((_WORD *)v48 + 33) = v87;
      if (v82) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v81 + 40))(v81, v82, v86 - v82);
      }
      *((_WORD *)v48 + 34) = 1;
      unint64_t v88 = operator new(0x60uLL);
      v88[1] = 0;
      v88[2] = 0;
      void *v88 = &unk_1EF583AF8;
      unint64_t v89 = v88 + 3;
      ggl::TextureData2D::TextureData2D((uint64_t)(v88 + 3), *((unsigned __int16 *)v48 + 32), *((unsigned __int16 *)v48 + 33), 1u, 2, 0);
      if (*((_WORD *)v48 + 34))
      {
        uint64_t v92 = 0;
        do
        {
          unint64_t v93 = (void *)(*(uint64_t (**)(void *, uint64_t))(*v89 + 16))(v89, v92);
          uint64_t v94 = *((unsigned __int16 *)v48 + 33) >> v92;
          if (v94)
          {
            uint64_t v95 = *((unsigned __int16 *)v48 + 32) >> v92;
            if (v95)
            {
              float v90 = 1.0 / (float)v94;
              if (a4)
              {
                if (v63 == v64)
                {
                  bzero(v93, (v95 * v94));
                }
                else
                {
                  for (uint64_t j = 0; j != v94; ++j)
                  {
                    uint64_t v97 = 0;
                    float v91 = (float)(int)j;
                    do
                    {
                      float v99 = (float)(*((float *)v48 + 18) * v91) * v90;
                      float v100 = v63;
                      do
                      {
                        if (v99 >= *v100 && v99 < v100[1])
                        {
                          int v98 = -*((unsigned __int8 *)v100 + 8);
                          goto LABEL_136;
                        }
                        v100 += 3;
                      }
                      while (v100 != v64);
                      LOBYTE(v98) = 0;
LABEL_136:
                      *((unsigned char *)v93 + v97 + j * v95) = v98;
                      ++v97;
                    }
                    while (v97 != v95);
                  }
                }
              }
              else
              {
                for (uint64_t k = 0; k != v94; ++k)
                {
                  unint64_t v103 = 0;
                  float v91 = (float)(int)k;
                  do
                  {
                    unsigned __int16 v105 = 2 - v103;
                    unsigned __int16 v106 = v103 + ~(_WORD)v118;
                    if (v103 < v118 + 2) {
                      unsigned __int16 v106 = 0;
                    }
                    if (v103 >= 2) {
                      unsigned __int16 v105 = v106;
                    }
                    float v107 = fmaxf((float)v105, 0.0);
                    if (v105) {
                      float v108 = 0.5;
                    }
                    else {
                      float v108 = 1.0;
                    }
                    if (v107 <= 2.0) {
                      float v109 = v107 * 0.5;
                    }
                    else {
                      float v109 = 1.0;
                    }
                    if (v63 == v64)
                    {
LABEL_147:
                      LOBYTE(v104) = 0;
                    }
                    else
                    {
                      float v110 = (float)(*((float *)v48 + 18) * v91) * v90;
                      unint64_t v111 = v63;
                      while (v110 < *v111 || v110 >= v111[1])
                      {
                        v111 += 3;
                        if (v111 == v64) {
                          goto LABEL_147;
                        }
                      }
                      int v104 = -*((unsigned __int8 *)v111 + 8);
                    }
                    *((unsigned char *)v93 + v103 + k * v95) = (int)(float)((float)(v108
                                                                          + (float)((float)((float)(v109 * v109)
                                                                                          * (float)((float)(v109 * 2.0)
                                                                                                  + -3.0))
                                                                                  * v108))
                                                                  * (float)v104);
                    ++v103;
                  }
                  while (v103 != v95);
                }
              }
            }
          }
          uint64_t v92 = (v92 + 1);
        }
        while (v92 < *((unsigned __int16 *)v48 + 34));
      }
      LOWORD(v90) = *((_WORD *)v48 + 32);
      LOWORD(v91) = *((_WORD *)v48 + 35);
      *((float *)v48 + 19) = (float)LODWORD(v90) / (float)LODWORD(v91);
      uint64_t v113 = (char *)operator new(0x58uLL);
      *((void *)v113 + 1) = 0;
      *(void *)uint64_t v113 = &unk_1EF583858;
      *((void *)v113 + 5) = 0;
      *((void *)v113 + 6) = 0;
      *((void *)v113 + 4) = 0;
      *((_DWORD *)v113 + 14) = 0;
      *((void *)v113 + 2) = 0;
      *((void *)v113 + 3) = &unk_1EF55AE58;
      *(void *)(v113 + 60) = 0x100000001;
      *(void *)&long long v114 = 0x100000001;
      *((void *)&v114 + 1) = 0x100000001;
      *(_OWORD *)(v113 + 68) = v114;
      *((_DWORD *)v113 + 21) = 0;
      operator new();
    }
LABEL_176:
    abort();
  }
  unint64_t v36 = v25 - v23;
  if (v32.u32[0] < 2uLL)
  {
    uint64_t v37 = *(void *)&v30 - 1;
    while (1)
    {
      uint64_t v38 = v35[1];
      if (v31 == v38)
      {
        if (*((float *)v35 + 12) == v19)
        {
          uint64_t v39 = v35[2];
          uint64_t v40 = v35[3];
          if (v36 == (v40 - v39) >> 2)
          {
            if (v40 == v39)
            {
LABEL_44:
              if (*((unsigned __int16 *)v35 + 28) == v118
                && !*((unsigned char *)v35 + 58)
                && *((unsigned __int8 *)v35 + 59) == a4)
              {
                goto LABEL_169;
              }
            }
            else
            {
              unint64_t v41 = 0;
              unsigned int v42 = 1;
              while (vabds_f32(*(float *)(v39 + 4 * v41), v23[v41]) <= 0.00000011921)
              {
                unint64_t v41 = v42++;
                if (v36 <= v41) {
                  goto LABEL_44;
                }
              }
            }
          }
        }
      }
      else if ((v38 & v37) != v33)
      {
        goto LABEL_64;
      }
      uint64_t v35 = (uint64_t *)*v35;
      if (!v35) {
        goto LABEL_64;
      }
    }
  }
  while (1)
  {
    unint64_t v43 = v35[1];
    if (v31 != v43)
    {
      if (v43 >= *(void *)&v30) {
        v43 %= *(void *)&v30;
      }
      if (v43 != v33) {
        goto LABEL_64;
      }
      goto LABEL_50;
    }
    if (*((float *)v35 + 12) == v19)
    {
      uint64_t v44 = v35[2];
      uint64_t v45 = v35[3];
      if (v36 == (v45 - v44) >> 2)
      {
        if (v45 != v44)
        {
          unint64_t v46 = 0;
          unsigned int v47 = 1;
          while (vabds_f32(*(float *)(v44 + 4 * v46), v23[v46]) <= 0.00000011921)
          {
            unint64_t v46 = v47++;
            if (v36 <= v46) {
              goto LABEL_58;
            }
          }
          goto LABEL_50;
        }
LABEL_58:
        if (*((unsigned __int16 *)v35 + 28) == v118
          && !*((unsigned char *)v35 + 58)
          && *((unsigned __int8 *)v35 + 59) == a4)
        {
          break;
        }
      }
    }
LABEL_50:
    uint64_t v35 = (uint64_t *)*v35;
    if (!v35) {
      goto LABEL_64;
    }
  }
LABEL_169:
  uint64_t result = std::__hash_table<std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,std::__unordered_map_hasher<md::DashTextureCache::Key,std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,md::DashTextureCache::KeyHasher,std::equal_to<md::DashTextureCache::Key>,true>,std::__unordered_map_equal<md::DashTextureCache::Key,std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,std::equal_to<md::DashTextureCache::Key>,md::DashTextureCache::KeyHasher,true>,std::allocator<std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>>>::__emplace_unique_key_args<md::DashTextureCache::Key,std::piecewise_construct_t const&,std::tuple<md::DashTextureCache::Key const&>,std::tuple<>>((float *)a2, (uint64_t)&v120, (uint64_t)&v120);
  uint64_t v116 = *((void *)result + 9);
  *a1 = *((void *)result + 8);
  a1[1] = v116;
  if (v116) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v116 + 8), 1uLL, memory_order_relaxed);
  }
  if (v120) {
    return (float *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v123 + 40))(v123, v120, v122 - v120);
  }
  return result;
}

float *std::__hash_table<std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,std::__unordered_map_hasher<md::DashTextureCache::Key,std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,md::DashTextureCache::KeyHasher,std::equal_to<md::DashTextureCache::Key>,true>,std::__unordered_map_equal<md::DashTextureCache::Key,std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>,std::equal_to<md::DashTextureCache::Key>,md::DashTextureCache::KeyHasher,true>,std::allocator<std::__hash_value_type<md::DashTextureCache::Key,std::shared_ptr<md::DashTexture>>>>::__emplace_unique_key_args<md::DashTextureCache::Key,std::piecewise_construct_t const&,std::tuple<md::DashTextureCache::Key const&>,std::tuple<>>(float *a1, uint64_t a2, uint64_t a3)
{
  float v6 = *(float *)(a2 + 32);
  if (v6 == 0.0) {
    unint64_t v7 = 0x9E3779B97F4A8048;
  }
  else {
    unint64_t v7 = (LODWORD(v6) - 0x61C8864680B57FA7) ^ 0x11;
  }
  double v8 = *(float **)a2;
  uint64_t v9 = *(float **)(a2 + 8);
  if (*(float **)a2 != v9)
  {
    uint64_t v10 = *(float **)a2;
    do
    {
      float v11 = *v10++;
      uint64_t v12 = LODWORD(v11) - 0x61C8864680B583EBLL;
      if (v11 == 0.0) {
        uint64_t v12 = 0x9E3779B97F4A7C15;
      }
      v7 ^= (v7 >> 2) + (v7 << 6) + v12;
    }
    while (v10 != v9);
  }
  uint64_t v13 = *(unsigned __int16 *)(a2 + 40);
  uint64_t v14 = *(unsigned __int8 *)(a2 + 42);
  uint64_t v15 = *(unsigned __int8 *)(a2 + 43);
  unint64_t v16 = v7 ^ v13 ^ v14 ^ v15;
  unint64_t v17 = *((void *)a1 + 1);
  if (v17)
  {
    uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v17);
    v18.i16[0] = vaddlv_u8(v18);
    if (v18.u32[0] > 1uLL)
    {
      unint64_t v3 = v7 ^ v13 ^ v14 ^ v15;
      if (v16 >= v17) {
        unint64_t v3 = v16 % v17;
      }
    }
    else
    {
      unint64_t v3 = (v17 - 1) & v16;
    }
    float v19 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v19)
    {
      uint64_t v20 = (float *)*v19;
      if (*v19)
      {
        unint64_t v21 = v9 - v8;
        if (v18.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v22 = *((void *)v20 + 1);
            if (v22 == v16)
            {
              if (v20[12] == v6)
              {
                uint64_t v23 = *((void *)v20 + 2);
                uint64_t v24 = *((void *)v20 + 3);
                if (v21 == (v24 - v23) >> 2)
                {
                  if (v24 == v23)
                  {
LABEL_28:
                    if (*((unsigned __int16 *)v20 + 28) == v13
                      && __PAIR64__(*((unsigned __int8 *)v20 + 59), *((unsigned __int8 *)v20 + 58)) == __PAIR64__(v15, v14))
                    {
                      return v20;
                    }
                  }
                  else
                  {
                    unint64_t v25 = 0;
                    unsigned int v26 = 1;
                    while (vabds_f32(*(float *)(v23 + 4 * v25), v8[v25]) <= 0.00000011921)
                    {
                      unint64_t v25 = v26++;
                      if (v21 <= v25) {
                        goto LABEL_28;
                      }
                    }
                  }
                }
              }
            }
            else if ((v22 & (v17 - 1)) != v3)
            {
              goto LABEL_46;
            }
            uint64_t v20 = *(float **)v20;
            if (!v20) {
              goto LABEL_46;
            }
          }
        }
        do
        {
          unint64_t v27 = *((void *)v20 + 1);
          if (v27 == v16)
          {
            if (v20[12] == v6)
            {
              uint64_t v28 = *((void *)v20 + 2);
              uint64_t v29 = *((void *)v20 + 3);
              if (v21 == (v29 - v28) >> 2)
              {
                if (v29 == v28)
                {
LABEL_41:
                  if (*((unsigned __int16 *)v20 + 28) == v13
                    && __PAIR64__(*((unsigned __int8 *)v20 + 59), *((unsigned __int8 *)v20 + 58)) == __PAIR64__(v15, v14))
                  {
                    return v20;
                  }
                }
                else
                {
                  unint64_t v30 = 0;
                  unsigned int v31 = 1;
                  while (vabds_f32(*(float *)(v28 + 4 * v30), v8[v30]) <= 0.00000011921)
                  {
                    unint64_t v30 = v31++;
                    if (v21 <= v30) {
                      goto LABEL_41;
                    }
                  }
                }
              }
            }
          }
          else
          {
            if (v27 >= v17) {
              v27 %= v17;
            }
            if (v27 != v3) {
              break;
            }
          }
          uint64_t v20 = *(float **)v20;
        }
        while (v20);
      }
    }
  }
LABEL_46:
  uint64_t v20 = (float *)operator new(0x50uLL);
  *(void *)uint64_t v20 = 0;
  *((void *)v20 + 1) = v16;
  *((void *)v20 + 2) = 0;
  *((void *)v20 + 3) = 0;
  uint64_t v32 = *(void *)(a3 + 24);
  *((void *)v20 + 4) = 0;
  *((void *)v20 + 5) = v32;
  unint64_t v33 = *(_DWORD **)a3;
  uint64_t v34 = *(_DWORD **)(a3 + 8);
  uint64_t v35 = (uint64_t)v34 - *(void *)a3;
  if (v34 != *(_DWORD **)a3)
  {
    if (v35 < 0) {
      abort();
    }
    uint64_t v36 = v35 >> 2;
    uint64_t v37 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v32 + 16))(v32);
    *((void *)v20 + 2) = v37;
    *((void *)v20 + 4) = &v37[v36];
    do
    {
      if (v37) {
        _DWORD *v37 = *v33;
      }
      ++v33;
      ++v37;
    }
    while (v33 != v34);
    *((void *)v20 + 3) = v37;
  }
  v20[12] = *(float *)(a3 + 32);
  v20[14] = *(float *)(a3 + 40);
  *((void *)v20 + 8) = 0;
  *((void *)v20 + 9) = 0;
  float v38 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v39 = a1[8];
  if (!v17 || (float)(v39 * (float)v17) < v38)
  {
    BOOL v40 = 1;
    if (v17 >= 3) {
      BOOL v40 = (v17 & (v17 - 1)) != 0;
    }
    unint64_t v41 = v40 | (2 * v17);
    unint64_t v42 = vcvtps_u32_f32(v38 / v39);
    if (v41 <= v42) {
      size_t prime = v42;
    }
    else {
      size_t prime = v41;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v17 = *((void *)a1 + 1);
    if (prime <= v17)
    {
      if (prime >= v17) {
        goto LABEL_90;
      }
      unint64_t v55 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v17 < 3 || (uint8x8_t v56 = (uint8x8_t)vcnt_s8((int8x8_t)v17), v56.i16[0] = vaddlv_u8(v56), v56.u32[0] > 1uLL))
      {
        unint64_t v55 = std::__next_prime(v55);
      }
      else
      {
        uint64_t v57 = 1 << -(char)__clz(v55 - 1);
        if (v55 >= 2) {
          unint64_t v55 = v57;
        }
      }
      if (prime <= v55) {
        size_t prime = v55;
      }
      if (prime >= v17)
      {
        unint64_t v17 = *((void *)a1 + 1);
LABEL_90:
        if ((v17 & (v17 - 1)) != 0)
        {
          if (v16 >= v17) {
            unint64_t v3 = v16 % v17;
          }
          else {
            unint64_t v3 = v16;
          }
        }
        else
        {
          unint64_t v3 = (v17 - 1) & v16;
        }
        goto LABEL_103;
      }
      if (!prime)
      {
        unint64_t v65 = *(void **)a1;
        *(void *)a1 = 0;
        if (v65) {
          operator delete(v65);
        }
        unint64_t v17 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_90;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v44 = operator new(8 * prime);
    uint64_t v45 = *(void **)a1;
    *(void *)a1 = v44;
    if (v45) {
      operator delete(v45);
    }
    uint64_t v46 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v46++) = 0;
    while (prime != v46);
    uint64_t v48 = (uint64_t *)(a1 + 4);
    unsigned int v47 = (void *)*((void *)a1 + 2);
    if (!v47)
    {
LABEL_89:
      unint64_t v17 = prime;
      goto LABEL_90;
    }
    size_t v49 = v47[1];
    size_t v50 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v51 = v49 & v50;
      *(void *)(*(void *)a1 + 8 * v51) = v48;
      for (uint64_t i = (void *)*v47; *v47; uint64_t i = (void *)*v47)
      {
        size_t v53 = i[1] & v50;
        if (v53 == v51)
        {
          unsigned int v47 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v53))
        {
          void *v47 = *i;
          uint64_t v54 = 8 * v53;
          *uint64_t i = **(void **)(*(void *)a1 + v54);
          **(void **)(*(void *)a1 + v54) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v53) = v47;
          unsigned int v47 = i;
          size_t v51 = v53;
        }
      }
      goto LABEL_89;
    }
    if (v49 >= prime) {
      v49 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v49) = v48;
    uint64_t v58 = (void *)*v47;
    if (!*v47) {
      goto LABEL_89;
    }
    while (1)
    {
      size_t v60 = v58[1];
      if (v60 >= prime) {
        v60 %= prime;
      }
      if (v60 != v49)
      {
        if (!*(void *)(*(void *)a1 + 8 * v60))
        {
          *(void *)(*(void *)a1 + 8 * v60) = v47;
          goto LABEL_94;
        }
        void *v47 = *v58;
        uint64_t v59 = 8 * v60;
        *uint64_t v58 = **(void **)(*(void *)a1 + v59);
        **(void **)(*(void *)a1 + v59) = v58;
        uint64_t v58 = v47;
      }
      size_t v60 = v49;
LABEL_94:
      unsigned int v47 = v58;
      uint64_t v58 = (void *)*v58;
      size_t v49 = v60;
      if (!v58) {
        goto LABEL_89;
      }
    }
  }
LABEL_103:
  unint64_t v61 = *(void **)a1;
  unint64_t v62 = *(float ***)(*(void *)a1 + 8 * v3);
  if (v62)
  {
    *(void *)uint64_t v20 = *v62;
LABEL_111:
    *unint64_t v62 = v20;
    goto LABEL_112;
  }
  *(void *)uint64_t v20 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v20;
  v61[v3] = a1 + 4;
  if (*(void *)v20)
  {
    unint64_t v63 = *(void *)(*(void *)v20 + 8);
    if ((v17 & (v17 - 1)) != 0)
    {
      if (v63 >= v17) {
        v63 %= v17;
      }
    }
    else
    {
      v63 &= v17 - 1;
    }
    unint64_t v62 = (float **)(*(void *)a1 + 8 * v63);
    goto LABEL_111;
  }
LABEL_112:
  ++*((void *)a1 + 3);
  return v20;
}

uint64_t std::__shared_ptr_emplace<md::DashTexture>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 88);
  *(void *)(a1 + 88) = 0;
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  uint64_t v3 = *(void *)(a1 + 24);
  if (v3)
  {
    *(void *)(a1 + 32) = v3;
    id v4 = *(uint64_t (**)(void))(**(void **)(a1 + 48) + 40);
    return v4();
  }
  return result;
}

void std::__shared_ptr_emplace<md::DashTexture>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F808;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::DashTexture>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F808;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1A210E554(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A210E638(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A210E6DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (SHIBYTE(a11) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A210E720(_Unwind_Exception *a1)
{
  uint64_t v2 = v1;

  _Unwind_Resume(a1);
}

void md::RealisticCommandBufferSelector::~RealisticCommandBufferSelector(md::RealisticCommandBufferSelector *this)
{
  *(void *)this = &unk_1EF53F0B8;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;

  *(void *)this = &unk_1EF53F0B8;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

uint64_t md::CommandBufferSelector::_getCommandBufferID(md::CommandBufferSelector *this)
{
  return 0;
}

uint64_t md::CommandBufferSelector::_getPassID(md::CommandBufferSelector *this)
{
  return 0;
}

void md::CommandBufferSelector::~CommandBufferSelector(md::CommandBufferSelector *this)
{
  *(void *)this = &unk_1EF53F0B8;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;

  *(void *)this = &unk_1EF53F0B8;
  uint64_t v2 = (void *)*((void *)this + 4);
  if (v2)
  {
    *((void *)this + 5) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 1);
  if (v3)
  {
    *((void *)this + 2) = v3;
    operator delete(v3);
  }
}

void md::mun::MeshResourceFetcher::expireResource(md::mun::MeshResourceFetcher *this, const gdc::ResourceKey *a2)
{
  v6[6] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = v3;
  id v5 = [MEMORY[0x1E4F64AC8] modernLoader];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN2md3mun19MeshResourceFetcher14expireResourceERKN3gdc11ResourceKeyE_block_invoke;
  v6[3] = &__block_descriptor_48_e723_B24__0r___GEOTileKey_b7b1_____GEOStandardTileKey_b40b6b26b26b14b4b4___GEOGloriaQuadIDTileKey_b6b64b14b4______b10b10b12_I____GEORegionalResourceKey_b32b8b6b8b8b1b57___GEOSputnikMetadataKey_b32b24b14b8b42___GEOFlyoverKey_b6b26b26b8b24b14b8b8___GEOTransitLineSelectionKey_b6b25b25b64___GEOPolygonSelectionKey_b6b25b25b64___GEORoadSelectionKey_b6b25b25b64___GEOContourLinesKey_b6b26b26b4b8b50___GEOTileOverlayKey_b6b26b26b8b32b16b6___GEOIdentifiedResourceKey_QCCb1b39___GEOMuninMeshKey_b64b32b16b5b3___GEOVisualLocalizationTrackKey_SCb16b6b26b26b22___GEOVisualLocalizationMetadataKey_b6b9b25b6b26b26b22___GEOVisualLocalizationDataKey_QCb5b21b21b1___GEOS2TileKey_b6b26b26b3b14b4b4b37___GEOLiveTileKey_b6b26b26b14b4b4b4b36___8d16l;
  v6[4] = v2;
  v6[5] = v4;
  [v5 expireTilesWithPredicate:v6];
}

void sub_1A210E9D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t anonymous namespace'::tileKeyFromResourceKey(_anonymous_namespace_ *this, const gdc::ResourceKey *a2)
{
  gdc::ResourceKey::keyData((gdc::ResourceKey *)v3, this);
  if (v3[0] != v3[2]) {
    free(v3[0]);
  }
  return GEOMuninMeshTileKeyMake();
}

uint64_t ___ZN2md3mun19MeshResourceFetcher14expireResourceERKN3gdc11ResourceKeyE_block_invoke()
{
  return GEOTileKeyEquals();
}

void md::mun::MeshResourceFetcher::cancelAllResources(md::mun::MeshResourceFetcher *this)
{
  id v2 = [MEMORY[0x1E4F64AC8] modernLoader];
  [v2 cancelAllForClientSynchronous:*((void *)this + 56)];
}

void sub_1A210EAC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::mun::MeshResourceFetcher::cancelResource(md::mun::MeshResourceFetcher *this, const gdc::ResourceKey *a2)
{
  v5[2] = *MEMORY[0x1E4F143B8];
  v5[1] = v3;
  uint64_t v4 = [MEMORY[0x1E4F64AC8] modernLoader];
  [v4 cancelKey:v5 forClient:*((void *)this + 56)];
}

void sub_1A210EB58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::mun::MeshResourceFetcher::cancelResources(uint64_t a1, uint64_t a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  id v5 = [MEMORY[0x1E4F64AC8] modernLoader];
  float v6 = *(uint64_t **)(a2 + 16);
  if (v6)
  {
    while (1)
    {
      uint64_t v42 = v6[2];
      unint64_t v43 = v47;
      uint64_t v44 = (char *)v47;
      uint64_t v45 = v47;
      uint64_t v46 = 32;
      double v8 = (char *)v6[3];
      unint64_t v7 = (char *)v6[4];
      unint64_t v9 = v7 - v8;
      uint64_t v10 = v47;
      if ((unint64_t)(v7 - v8) < 0x21) {
        goto LABEL_25;
      }
      size_t v11 = v9 <= 0x40 ? 64 : v7 - v8;
      uint64_t v10 = malloc_type_malloc(v11, 0x100004077774924uLL);
      uint64_t v12 = (char *)v43;
      uint64_t v13 = v44;
      if (v43 != v44) {
        break;
      }
LABEL_24:
      unint64_t v43 = v10;
      uint64_t v44 = (char *)v10;
      uint64_t v46 = v11;
LABEL_25:
      if (v8 != v7)
      {
        if (v9 < 8)
        {
          uint64_t v28 = v10;
        }
        else if ((unint64_t)((char *)v10 - v8) < 0x20)
        {
          uint64_t v28 = v10;
        }
        else
        {
          if (v9 < 0x20)
          {
            uint64_t v27 = 0;
LABEL_36:
            unint64_t v33 = v9 & 0xFFFFFFFFFFFFFFF8;
            uint64_t v28 = (char *)v10 + (v9 & 0xFFFFFFFFFFFFFFF8);
            uint64_t v34 = v27 - (v9 & 0xFFFFFFFFFFFFFFF8);
            uint64_t v35 = (uint64_t *)&v8[v27];
            uint64_t v36 = (void *)((char *)v10 + v27);
            do
            {
              uint64_t v37 = *v35++;
              *v36++ = v37;
              v34 += 8;
            }
            while (v34);
            if (v9 != v33)
            {
              v8 += v33;
              goto LABEL_41;
            }
LABEL_42:
            uint64_t v10 = v44;
            goto LABEL_43;
          }
          uint64_t v27 = v9 & 0xFFFFFFFFFFFFFFE0;
          uint64_t v29 = (long long *)(v8 + 16);
          unint64_t v30 = v10 + 2;
          unint64_t v31 = v9 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            long long v32 = *v29;
            *(v30 - 1) = *(v29 - 1);
            *unint64_t v30 = v32;
            v29 += 2;
            v30 += 2;
            v31 -= 32;
          }
          while (v31);
          if (v9 == v27) {
            goto LABEL_42;
          }
          if ((v9 & 0x18) != 0) {
            goto LABEL_36;
          }
          v8 += v27;
          uint64_t v28 = (char *)v10 + v27;
        }
        do
        {
LABEL_41:
          char v38 = *v8++;
          *v28++ = v38;
        }
        while (v8 != v7);
        goto LABEL_42;
      }
LABEL_43:
      uint64_t v39 = v6[11];
      uint64_t v44 = (char *)v10 + v9;
      v47[4] = v39;
      long long v48 = *((_OWORD *)v6 + 6);
      uint64_t v49 = 0;
      uint64_t v50 = 0;
      uint64_t v50 = v40;
      id v41 = *(id *)(a1 + 448);
      [v5 cancelKey:&v49 forClient:v41];

      if (v43 != v45) {
        free(v43);
      }
      float v6 = (uint64_t *)*v6;
      if (!v6) {
        goto LABEL_45;
      }
    }
    unint64_t v14 = v44 - (unsigned char *)v43;
    if ((unint64_t)(v44 - (unsigned char *)v43) < 8)
    {
      uint64_t v15 = v10;
    }
    else
    {
      uint64_t v15 = v10;
      if ((unint64_t)((char *)v10 - (unsigned char *)v43) >= 0x20)
      {
        if (v14 < 0x20)
        {
          uint64_t v16 = 0;
LABEL_18:
          unint64_t v21 = v14 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v15 = (char *)v10 + (v14 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v22 = v16 - (v14 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v23 = (uint64_t *)&v12[v16];
          uint64_t v24 = (void *)((char *)v10 + v16);
          do
          {
            uint64_t v25 = *v23++;
            *v24++ = v25;
            v22 += 8;
          }
          while (v22);
          if (v14 == v21) {
            goto LABEL_24;
          }
          v12 += v21;
          goto LABEL_23;
        }
        uint64_t v16 = v14 & 0xFFFFFFFFFFFFFFE0;
        unint64_t v17 = (long long *)((char *)v43 + 16);
        uint8x8_t v18 = v10 + 2;
        unint64_t v19 = v14 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v20 = *v17;
          *(v18 - 1) = *(v17 - 1);
          _OWORD *v18 = v20;
          v17 += 2;
          v18 += 2;
          v19 -= 32;
        }
        while (v19);
        if (v14 == v16) {
          goto LABEL_24;
        }
        if ((v14 & 0x18) != 0) {
          goto LABEL_18;
        }
        v12 += v16;
        uint64_t v15 = (char *)v10 + v16;
      }
    }
    do
    {
LABEL_23:
      char v26 = *v12++;
      *v15++ = v26;
    }
    while (v12 != v13);
    goto LABEL_24;
  }
LABEL_45:
}

void sub_1A210EE5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13)
{
  _Unwind_Resume(a1);
}

void md::mun::MeshResourceFetcher::fetchResources(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  id v86 = a4;
  unint64_t v7 = *(uint64_t **)(a2 + 16);
  if (v7)
  {
    uint64_t v84 = a1;
    while (1)
    {
      double v8 = v106;
      uint64_t v101 = v7[2];
      unint64_t v102 = v106;
      unint64_t v103 = v106;
      int v104 = v106;
      uint64_t v105 = 32;
      unint64_t v9 = (char *)v7[3];
      uint64_t v10 = (char *)v7[4];
      unint64_t v11 = v10 - v9;
      if ((unint64_t)(v10 - v9) < 0x21) {
        goto LABEL_25;
      }
      size_t v12 = v11 <= 0x40 ? 64 : v10 - v9;
      double v8 = malloc_type_malloc(v12, 0x100004077774924uLL);
      uint64_t v13 = (char *)v102;
      unint64_t v14 = v103;
      if (v102 != v103) {
        break;
      }
LABEL_24:
      unint64_t v102 = v8;
      unint64_t v103 = v8;
      uint64_t v105 = v12;
LABEL_25:
      if (v9 == v10) {
        goto LABEL_43;
      }
      if (v11 < 8)
      {
        uint64_t v29 = v8;
        goto LABEL_41;
      }
      if ((unint64_t)(v8 - v9) < 0x20)
      {
        uint64_t v29 = v8;
        goto LABEL_41;
      }
      if (v11 >= 0x20)
      {
        unint64_t v28 = v11 & 0xFFFFFFFFFFFFFFE0;
        unint64_t v30 = (long long *)(v9 + 16);
        unint64_t v31 = v8 + 16;
        unint64_t v32 = v11 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v33 = *v30;
          *(v31 - 1) = *(v30 - 1);
          *unint64_t v31 = v33;
          v30 += 2;
          v31 += 2;
          v32 -= 32;
        }
        while (v32);
        if (v11 == v28) {
          goto LABEL_42;
        }
        if ((v11 & 0x18) == 0)
        {
          v9 += v28;
          uint64_t v29 = &v8[v28];
          goto LABEL_41;
        }
      }
      else
      {
        unint64_t v28 = 0;
      }
      unint64_t v34 = v11 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v29 = &v8[v11 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v35 = v28 - (v11 & 0xFFFFFFFFFFFFFFF8);
      uint64_t v36 = (uint64_t *)&v9[v28];
      uint64_t v37 = &v8[v28];
      do
      {
        uint64_t v38 = *v36++;
        *v37++ = v38;
        v35 += 8;
      }
      while (v35);
      if (v11 == v34) {
        goto LABEL_42;
      }
      v9 += v34;
      do
      {
LABEL_41:
        char v39 = *v9++;
        *v29++ = v39;
      }
      while (v9 != v10);
LABEL_42:
      double v8 = v103;
LABEL_43:
      uint64_t v40 = v7[11];
      unint64_t v103 = &v8[v11];
      uint64_t v107 = v40;
      long long v108 = *((_OWORD *)v7 + 6);
      uint64_t v41 = v7[14];
      long long v121 = 0uLL;
      *((void *)&v121 + 1) = v42;
      os_signpost_id_t v43 = v108;
      if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
      }
      uint64_t v44 = (id)GEOGetVectorKitResourceLoadingLog_log;
      uint64_t v45 = v44;
      if (v43 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v44))
      {
        *(_DWORD *)buf = 134219264;
        uint64_t v110 = *(void *)((char *)&v121 + 1);
        __int16 v111 = 1024;
        int v112 = *(_DWORD *)((char *)&v121 + 9);
        __int16 v113 = 1024;
        int v114 = *(unsigned __int16 *)((char *)&v121 + 13);
        __int16 v115 = 1024;
        int v116 = HIBYTE(v121) & 0x1F;
        __int16 v117 = 1024;
        unsigned int v118 = (*(unsigned __int16 *)((char *)&v121 + 13) | (HIBYTE(v121) << 16)) >> 21;
        __int16 v119 = 2048;
        uint64_t v120 = *((void *)&v108 + 1);
        _os_signpost_emit_with_name_impl(&dword_1A1780000, v45, OS_SIGNPOST_INTERVAL_BEGIN, v43, "ResourceFetch", "pointId=%llu buildId=%d bucketId=%d cameraId=%d lod=%d parent_signpost=%llu", buf, 0x2Eu);
      }

      unint64_t v46 = atomic_load((unint64_t *)(a1 + 104));
      if (v46) {
        (*(void (**)(unint64_t))(*(void *)v46 + 16))(v46);
      }
      unsigned int v47 = [MEMORY[0x1E4F64AC8] modernLoader];
      uint64_t v48 = HIDWORD(v101);
      id v49 = *(id *)(a1 + 448);
      uint64_t v50 = qos_class_self();
      uint64_t v87 = v108;
      id v88 = *(id *)(a1 + 472);
      id v51 = *(id *)(a3 + 16);
      v89[0] = MEMORY[0x1E4F143A8];
      v89[1] = 3321888768;
      unint64_t v52 = v99;
      v89[2] = ___ZN2md3mun19MeshResourceFetcher14fetchResourcesERKNSt3__113unordered_mapIN3gdc11ResourceKeyEyNS4_15ResourceKeyHashENS2_8equal_toIS5_EENS2_9allocatorINS2_4pairIKS5_yEEEEEEPN3geo9TaskQueueEPU32objcproto21OS_dispatch_semaphore8NSObject_block_invoke;
      v89[3] = &unk_1EF58DFC8;
      uint64_t v91 = a1;
      os_signpost_id_t v92 = v43;
      size_t v53 = (char *)v102;
      uint64_t v93 = v41;
      uint64_t v94 = v101;
      uint64_t v95 = v99;
      long long v96 = (char *)v99;
      uint64_t v97 = v99;
      uint64_t v98 = 32;
      uint64_t v54 = v103;
      unint64_t v55 = v103 - (unsigned char *)v102;
      if ((unint64_t)(v103 - (unsigned char *)v102) >= 0x21)
      {
        if (v55 <= 0x40) {
          size_t v56 = 64;
        }
        else {
          size_t v56 = v103 - (unsigned char *)v102;
        }
        unint64_t v52 = malloc_type_malloc(v56, 0x100004077774924uLL);
        uint64_t v57 = (char *)v95;
        uint64_t v58 = v96;
        if (v95 == v96) {
          goto LABEL_70;
        }
        unint64_t v59 = v96 - (unsigned char *)v95;
        if ((unint64_t)(v96 - (unsigned char *)v95) < 8)
        {
          size_t v60 = v52;
        }
        else
        {
          size_t v60 = v52;
          if ((unint64_t)((char *)v52 - (unsigned char *)v95) >= 0x20)
          {
            if (v59 < 0x20)
            {
              uint64_t v61 = 0;
LABEL_64:
              unint64_t v66 = v59 & 0xFFFFFFFFFFFFFFF8;
              size_t v60 = (char *)v52 + (v59 & 0xFFFFFFFFFFFFFFF8);
              uint64_t v67 = v61 - (v59 & 0xFFFFFFFFFFFFFFF8);
              float v68 = &v57[v61];
              uint64_t v69 = (void *)((char *)v52 + v61);
              do
              {
                uint64_t v70 = *(void *)v68;
                v68 += 8;
                *v69++ = v70;
                v67 += 8;
              }
              while (v67);
              if (v59 != v66)
              {
                v57 += v66;
                goto LABEL_69;
              }
LABEL_70:
              uint64_t v95 = v52;
              long long v96 = (char *)v52;
              uint64_t v98 = v56;
              goto LABEL_71;
            }
            uint64_t v61 = v59 & 0xFFFFFFFFFFFFFFE0;
            unint64_t v62 = (long long *)((char *)v95 + 16);
            unint64_t v63 = v52 + 2;
            unint64_t v64 = v59 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v65 = *v62;
              *(v63 - 1) = *(v62 - 1);
              *unint64_t v63 = v65;
              v62 += 2;
              v63 += 2;
              v64 -= 32;
            }
            while (v64);
            if (v59 == v61) {
              goto LABEL_70;
            }
            if ((v59 & 0x18) != 0) {
              goto LABEL_64;
            }
            v57 += v61;
            size_t v60 = (char *)v52 + v61;
          }
        }
        do
        {
LABEL_69:
          char v71 = *v57++;
          *v60++ = v71;
        }
        while (v57 != v58);
        goto LABEL_70;
      }
LABEL_71:
      if (v53 != v54)
      {
        if (v55 < 8)
        {
          uint64_t v73 = v52;
        }
        else if ((unint64_t)((char *)v52 - v53) < 0x20)
        {
          uint64_t v73 = v52;
        }
        else
        {
          if (v55 < 0x20)
          {
            uint64_t v72 = 0;
LABEL_82:
            unint64_t v78 = v55 & 0xFFFFFFFFFFFFFFF8;
            uint64_t v73 = (char *)v52 + (v55 & 0xFFFFFFFFFFFFFFF8);
            uint64_t v79 = v72 - (v55 & 0xFFFFFFFFFFFFFFF8);
            __int16 v80 = (uint64_t *)&v53[v72];
            uint64_t v81 = (void *)((char *)v52 + v72);
            do
            {
              uint64_t v82 = *v80++;
              *v81++ = v82;
              v79 += 8;
            }
            while (v79);
            if (v55 != v78)
            {
              v53 += v78;
              goto LABEL_87;
            }
LABEL_88:
            unint64_t v52 = v96;
            goto LABEL_89;
          }
          uint64_t v72 = v55 & 0xFFFFFFFFFFFFFFE0;
          double v74 = (long long *)(v53 + 16);
          uint64_t v75 = v52 + 2;
          unint64_t v76 = v55 & 0xFFFFFFFFFFFFFFE0;
          do
          {
            long long v77 = *v74;
            *(v75 - 1) = *(v74 - 1);
            *uint64_t v75 = v77;
            v74 += 2;
            v75 += 2;
            v76 -= 32;
          }
          while (v76);
          if (v55 == v72) {
            goto LABEL_88;
          }
          if ((v55 & 0x18) != 0) {
            goto LABEL_82;
          }
          v53 += v72;
          uint64_t v73 = (char *)v52 + v72;
        }
        do
        {
LABEL_87:
          char v83 = *v53++;
          *v73++ = v83;
        }
        while (v53 != v54);
        goto LABEL_88;
      }
LABEL_89:
      long long v96 = (char *)v52 + v55;
      v99[4] = v107;
      long long v100 = v108;
      id v90 = v86;
      [v47 loadKey:&v121 priority:v48 forClient:v49 options:3 reason:1 qos:v50 signpostID:v87 auditToken:v88 callbackQ:v51 beginNetwork:0 callback:v89];
      a1 = v84;

      if (v95 != v97) {
        free(v95);
      }
      if (v102 != v104) {
        free(v102);
      }
      unint64_t v7 = (uint64_t *)*v7;
      if (!v7) {
        goto LABEL_93;
      }
    }
    unint64_t v15 = v103 - (unsigned char *)v102;
    if ((unint64_t)(v103 - (unsigned char *)v102) < 8)
    {
      uint64_t v16 = v8;
    }
    else
    {
      uint64_t v16 = v8;
      if ((unint64_t)(v8 - (unsigned char *)v102) >= 0x20)
      {
        if (v15 < 0x20)
        {
          uint64_t v17 = 0;
LABEL_18:
          unint64_t v22 = v15 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v16 = &v8[v15 & 0xFFFFFFFFFFFFFFF8];
          uint64_t v23 = v17 - (v15 & 0xFFFFFFFFFFFFFFF8);
          uint64_t v24 = (uint64_t *)&v13[v17];
          uint64_t v25 = &v8[v17];
          do
          {
            uint64_t v26 = *v24++;
            *v25++ = v26;
            v23 += 8;
          }
          while (v23);
          if (v15 == v22) {
            goto LABEL_24;
          }
          v13 += v22;
          goto LABEL_23;
        }
        uint64_t v17 = v15 & 0xFFFFFFFFFFFFFFE0;
        uint8x8_t v18 = (long long *)((char *)v102 + 16);
        unint64_t v19 = v8 + 16;
        unint64_t v20 = v15 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v21 = *v18;
          *(v19 - 1) = *(v18 - 1);
          _OWORD *v19 = v21;
          v18 += 2;
          v19 += 2;
          v20 -= 32;
        }
        while (v20);
        if (v15 == v17) {
          goto LABEL_24;
        }
        if ((v15 & 0x18) != 0) {
          goto LABEL_18;
        }
        v13 += v17;
        uint64_t v16 = &v8[v17];
      }
    }
    do
    {
LABEL_23:
      char v27 = *v13++;
      *v16++ = v27;
    }
    while (v13 != v14);
    goto LABEL_24;
  }
LABEL_93:
}

void sub_1A210F5C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,void *a50)
{
  if (a48 != a50) {
    free(a48);
  }

  _Unwind_Resume(a1);
}

void ___ZN2md3mun19MeshResourceFetcher14fetchResourcesERKNSt3__113unordered_mapIN3gdc11ResourceKeyEyNS4_15ResourceKeyHashENS2_8equal_toIS5_EENS2_9allocatorINS2_4pairIKS5_yEEEEEEPN3geo9TaskQueueEPU32objcproto21OS_dispatch_semaphore8NSObject_block_invoke(void *a1, uint64_t a2, void *a3, uint64_t a4, void *a5, void *a6)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  id v64 = a3;
  id v9 = a5;
  id v65 = a6;
  unint64_t v66 = v9;
  uint64_t v10 = (unint64_t *)a1[5];
  if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
  }
  unint64_t v11 = (id)GEOGetVectorKitResourceLoadingLog_log;
  size_t v12 = v11;
  os_signpost_id_t v13 = a1[6];
  if (v13 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v12, OS_SIGNPOST_INTERVAL_END, v13, "ResourceFetch", "", buf, 2u);
  }

  if (v64)
  {
    unint64_t v14 = [v64 decodedRepresentation];
    unint64_t v15 = v14;
    if (v14)
    {
      unint64_t v63 = v14;
    }
    else
    {
      id v74 = v9;
      unint64_t v63 = [v64 readDataWithError:&v74];
      id v16 = v74;

      unint64_t v66 = v16;
    }
  }
  else
  {
    unint64_t v63 = 0;
  }
  *(void *)buf = 0;
  uint64_t v70 = 0;
  char v71 = 0;
  uint64_t v17 = (std::__shared_weak_count *)operator new(0x38uLL);
  v17->__shared_owners_ = 0;
  v17->__shared_weak_owners_ = 0;
  v17->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C50;
  uint8x8_t v18 = gdc::DataObject::DataObject((gdc::DataObject *)&v17[1], v63);
  unint64_t v19 = v70;
  *(void *)buf = v18;
  uint64_t v70 = v17;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  unint64_t v20 = [v65 objectForKey:*MEMORY[0x1E4F64248]];
  long long v21 = v20;
  if (v20)
  {
    char v22 = [v20 unsignedIntValue];
    if ((v22 + 1) >= 7u) {
      unsigned __int8 v23 = 0;
    }
    else {
      unsigned __int8 v23 = 0x2040302010002uLL >> (8 * (v22 + 1));
    }
  }
  else
  {
    unsigned __int8 v23 = 0;
  }

  uint64_t v24 = [v65 objectForKey:*MEMORY[0x1E4F64250]];
  uint64_t v25 = v24;
  if (v24)
  {
    unsigned int v26 = [v24 unsignedIntValue];
    if (v26 >= 3) {
      unsigned __int8 v27 = 0;
    }
    else {
      unsigned __int8 v27 = 0x30102u >> (8 * v26);
    }
  }
  else
  {
    unsigned __int8 v27 = 0;
  }

  if (!v66)
  {
    if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
    }
    uint64_t v45 = (id)GEOGetVectorKitResourceLoadingLog_log;
    unint64_t v46 = v45;
    os_signpost_id_t v47 = a1[6];
    if (v47 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v45))
    {
      uint64_t v48 = a1[19];
      *(_DWORD *)uint64_t v75 = 134217984;
      *(void *)unint64_t v76 = v48;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v46, OS_SIGNPOST_INTERVAL_BEGIN, v47, "CreateResource", "parent_signpost=%llu", v75, 0xCu);
    }

    if ((*(uint64_t (**)(unint64_t *, void, void *, void, void, void, void, uint8_t *))(*v10 + 128))(v10, a1[7], a1 + 8, v23, v27, 0, 0, buf))
    {
      id v49 = 0;
    }
    else
    {
      id v49 = [MEMORY[0x1E4F28C58] errorWithDomain:@"com.apple.C3mMesh" code:-1 userInfo:0];
      if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
      }
      uint64_t v54 = (id)GEOGetVectorKitResourceLoadingLog_log;
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        uint64_t v55 = a1[7];
        *(_DWORD *)uint64_t v75 = 134217984;
        *(void *)unint64_t v76 = v55;
        _os_log_impl(&dword_1A1780000, v54, OS_LOG_TYPE_ERROR, "MuninMeshResourceFetcher failed to create Resource. %llu", v75, 0xCu);
      }
    }
    if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
    }
    size_t v56 = (id)GEOGetVectorKitResourceLoadingLog_log;
    uint64_t v57 = v56;
    os_signpost_id_t v58 = a1[6];
    if (v58 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v56))
    {
      *(_WORD *)uint64_t v75 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v57, OS_SIGNPOST_INTERVAL_END, v58, "CreateResource", "", v75, 2u);
    }

    id v59 = v49;
    unint64_t v60 = atomic_load(v10 + 13);
    if (v60) {
      (*(void (**)(unint64_t, id))(*(void *)v60 + 24))(v60, v59);
    }

    goto LABEL_76;
  }
  if ([v66 code] == -2)
  {
    unint64_t v28 = [v66 domain];
    uint64_t v29 = GEOErrorDomain();
    int v30 = [v28 isEqualToString:v29];

    if (v30)
    {
      if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
      }
      unint64_t v31 = (id)GEOGetVectorKitResourceLoadingLog_log;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
      {
        uint64_t v32 = a1[7];
        *(_DWORD *)uint64_t v75 = 134217984;
        *(void *)unint64_t v76 = v32;
        _os_log_impl(&dword_1A1780000, v31, OS_LOG_TYPE_INFO, "MuninMeshResourceFetcher received cancelled resource. %llu", v75, 0xCu);
      }

      (*(void (**)(unint64_t *, void, void *))(*v10 + 120))(v10, a1[7], a1 + 8);
      unint64_t v33 = atomic_load(v10 + 13);
      if (v33) {
        (*(void (**)(unint64_t, void))(*(void *)v33 + 24))(v33, 0);
      }
      goto LABEL_76;
    }
  }
  if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
  }
  unint64_t v34 = (id)GEOGetVectorKitResourceLoadingLog_log;
  if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
  {
    uint64_t v35 = a1[7];
    *(_DWORD *)uint64_t v75 = 134217984;
    *(void *)unint64_t v76 = v35;
    _os_log_impl(&dword_1A1780000, v34, OS_LOG_TYPE_ERROR, "MuninMeshResourceFetcher received failed Resource. %llu", v75, 0xCu);
  }

  uint64_t v36 = [MEMORY[0x1E4F648E8] sharedReachability];
  [v36 reportLoadFailure:v66];

  uint64_t v37 = [v66 code];
  id v38 = [v66 domain];
  char v39 = (char *)[v38 UTF8String];
  id v40 = [v66 description];
  uint64_t v41 = (const char *)[v40 UTF8String];
  size_t v42 = strlen(v41);
  if (v42 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v43 = v42;
  if (v42 >= 0x17)
  {
    uint64_t v50 = (v42 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v42 | 7) != 0x17) {
      uint64_t v50 = v42 | 7;
    }
    uint64_t v51 = v50 + 1;
    p_dst = (long long *)operator new(v50 + 1);
    *((void *)&__dst + 1) = v43;
    unint64_t v68 = v51 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
  }
  else
  {
    HIBYTE(v68) = v42;
    p_dst = &__dst;
    if (!v42) {
      goto LABEL_54;
    }
  }
  memmove(p_dst, v41, v43);
LABEL_54:
  *((unsigned char *)p_dst + v43) = 0;
  gdc::Error::Error((uint64_t)v75, v37, v39, &__dst);
  if (SHIBYTE(v68) < 0) {
    operator delete((void *)__dst);
  }

  (*(void (**)(unint64_t *, void, void *, uint8_t *))(*v10 + 112))(v10, a1[7], a1 + 8, v75);
  id v52 = v66;
  unint64_t v53 = atomic_load(v10 + 13);
  if (v53) {
    (*(void (**)(unint64_t, id))(*(void *)v53 + 24))(v53, v52);
  }

  if (v79 < 0)
  {
    operator delete(v78);
    if ((v77 & 0x80000000) == 0) {
      goto LABEL_76;
    }
  }
  else if ((v77 & 0x80000000) == 0)
  {
    goto LABEL_76;
  }
  operator delete(*(void **)&v76[4]);
LABEL_76:
  uint64_t v61 = a1[4];
  if (v61) {
    dispatch_semaphore_signal(v61);
  }
  if (v71)
  {
    if (v72 != v73) {
      free(v72);
    }
    char v71 = 0;
  }
  unint64_t v62 = v70;
  if (v70 && !atomic_fetch_add(&v70->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
    std::__shared_weak_count::__release_weak(v62);
  }
}

void sub_1A210FF30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, char a20)
{
  _Unwind_Resume(a1);
}

void __destroy_helper_block_ea8_64c23_ZTSN3gdc11ResourceKeyE(uint64_t a1)
{
  id v2 = *(void **)(a1 + 72);
  if (v2 != *(void **)(a1 + 88)) {
    free(v2);
  }
}

__n128 __copy_helper_block_ea8_64c23_ZTSN3gdc11ResourceKeyE(__n128 *a1, __n128 *a2)
{
  uint64_t v4 = &a1[6].n128_i8[8];
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a1[4].n128_u64[1] = (unint64_t)v4;
  a1[5].n128_u64[0] = (unint64_t)v4;
  a1[5].n128_u64[1] = (unint64_t)v4;
  a1[6].n128_u64[0] = 32;
  id v5 = (__int8 *)a2[4].n128_u64[1];
  float v6 = (__int8 *)a2[5].n128_u64[0];
  unint64_t v7 = v6 - v5;
  if ((unint64_t)(v6 - v5) >= 0x21)
  {
    if (v7 <= 0x40) {
      size_t v8 = 64;
    }
    else {
      size_t v8 = v6 - v5;
    }
    uint64_t v4 = (__int8 *)malloc_type_malloc(v8, 0x100004077774924uLL);
    id v9 = (__int8 *)a1[4].n128_u64[1];
    uint64_t v10 = (__int8 *)a1[5].n128_u64[0];
    if (v9 == v10) {
      goto LABEL_21;
    }
    unint64_t v11 = v10 - v9;
    if ((unint64_t)(v10 - v9) < 8)
    {
      size_t v12 = v4;
      goto LABEL_20;
    }
    size_t v12 = v4;
    if ((unint64_t)(v4 - v9) < 0x20) {
      goto LABEL_20;
    }
    if (v11 >= 0x20)
    {
      unint64_t v13 = v11 & 0xFFFFFFFFFFFFFFE0;
      unint64_t v14 = (long long *)(v9 + 16);
      unint64_t v15 = v4 + 16;
      unint64_t v16 = v11 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v17 = *v14;
        *(v15 - 1) = *(v14 - 1);
        *unint64_t v15 = v17;
        v14 += 2;
        v15 += 2;
        v16 -= 32;
      }
      while (v16);
      if (v11 == v13) {
        goto LABEL_21;
      }
      if ((v11 & 0x18) == 0)
      {
        v9 += v13;
        size_t v12 = &v4[v13];
        goto LABEL_20;
      }
    }
    else
    {
      unint64_t v13 = 0;
    }
    unint64_t v18 = v11 & 0xFFFFFFFFFFFFFFF8;
    size_t v12 = &v4[v11 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v19 = v13 - (v11 & 0xFFFFFFFFFFFFFFF8);
    unint64_t v20 = (uint64_t *)&v9[v13];
    long long v21 = &v4[v13];
    do
    {
      uint64_t v22 = *v20++;
      *(void *)long long v21 = v22;
      v21 += 8;
      v19 += 8;
    }
    while (v19);
    if (v11 == v18) {
      goto LABEL_21;
    }
    v9 += v18;
    do
    {
LABEL_20:
      __int8 v23 = *v9++;
      *v12++ = v23;
    }
    while (v9 != v10);
LABEL_21:
    a1[4].n128_u64[1] = (unint64_t)v4;
    a1[5].n128_u64[0] = (unint64_t)v4;
    a1[6].n128_u64[0] = v8;
  }
  if (v5 != v6)
  {
    if (v7 < 8)
    {
      uint64_t v25 = v4;
      goto LABEL_38;
    }
    if ((unint64_t)(v4 - v5) < 0x20)
    {
      uint64_t v25 = v4;
      goto LABEL_38;
    }
    if (v7 >= 0x20)
    {
      unint64_t v24 = v7 & 0xFFFFFFFFFFFFFFE0;
      unsigned int v26 = (long long *)(v5 + 16);
      unsigned __int8 v27 = v4 + 16;
      unint64_t v28 = v7 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v29 = *v26;
        *(v27 - 1) = *(v26 - 1);
        *unsigned __int8 v27 = v29;
        v26 += 2;
        v27 += 2;
        v28 -= 32;
      }
      while (v28);
      if (v7 == v24) {
        goto LABEL_39;
      }
      if ((v7 & 0x18) == 0)
      {
        v5 += v24;
        uint64_t v25 = &v4[v24];
        goto LABEL_38;
      }
    }
    else
    {
      unint64_t v24 = 0;
    }
    unint64_t v30 = v7 & 0xFFFFFFFFFFFFFFF8;
    uint64_t v25 = &v4[v7 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v31 = v24 - (v7 & 0xFFFFFFFFFFFFFFF8);
    uint64_t v32 = (uint64_t *)&v5[v24];
    unint64_t v33 = &v4[v24];
    do
    {
      uint64_t v34 = *v32++;
      *(void *)unint64_t v33 = v34;
      v33 += 8;
      v31 += 8;
    }
    while (v31);
    if (v7 == v30) {
      goto LABEL_39;
    }
    v5 += v30;
    do
    {
LABEL_38:
      __int8 v35 = *v5++;
      *v25++ = v35;
    }
    while (v5 != v6);
LABEL_39:
    uint64_t v4 = (__int8 *)a1[5].n128_u64[0];
  }
  a1[5].n128_u64[0] = (unint64_t)&v4[v7];
  a1[8].n128_u64[1] = a2[8].n128_u64[1];
  __n128 result = a2[9];
  a1[9] = result;
  return result;
}

uint64_t gdc::Error::Error(uint64_t a1, uint64_t a2, char *__s, long long *a4)
{
  *(void *)a1 = a2;
  unint64_t v7 = (void *)(a1 + 8);
  size_t v8 = strlen(__s);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v9 = v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = operator new(v11 + 1);
    *(void *)(a1 + 16) = v9;
    *(void *)(a1 + 24) = v12 | 0x8000000000000000;
    *(void *)(a1 + 8) = v10;
    goto LABEL_8;
  }
  *(unsigned char *)(a1 + 31) = v8;
  uint64_t v10 = v7;
  if (v8) {
LABEL_8:
  }
    memmove(v10, __s, v9);
  *((unsigned char *)v10 + v9) = 0;
  unint64_t v13 = (std::string *)(a1 + 32);
  if (*((char *)a4 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v13, *(const std::string::value_type **)a4, *((void *)a4 + 1));
  }
  else
  {
    long long v14 = *a4;
    *(void *)(a1 + 48) = *((void *)a4 + 2);
    *(_OWORD *)&v13->__r_.__value_.__l.__data_ = v14;
  }
  return a1;
}

void sub_1A2110370(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 31) < 0) {
    operator delete(*v2);
  }
  _Unwind_Resume(exception_object);
}

void gdc::Error::~Error(void **this)
{
  if ((*((char *)this + 55) & 0x80000000) == 0)
  {
    if ((*((char *)this + 31) & 0x80000000) == 0) {
      return;
    }
LABEL_5:
    operator delete(this[1]);
    return;
  }
  operator delete(this[4]);
  if (*((char *)this + 31) < 0) {
    goto LABEL_5;
  }
}

void gdc::RawResourceSourceData::~RawResourceSourceData(gdc::RawResourceSourceData *this)
{
  if (*((unsigned char *)this + 16))
  {
    id v2 = (void *)*((void *)this + 4);
    if (v2 != *((void **)this + 6)) {
      free(v2);
    }
    *((unsigned char *)this + 16) = 0;
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void std::__shared_ptr_emplace<gdc::DataObject>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C50;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gdc::DataObject>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C50;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::mun::MeshResourceFetcher::~MeshResourceFetcher(md::mun::MeshResourceFetcher *this)
{
  md::mun::MeshResourceFetcher::~MeshResourceFetcher(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF550360;
  id v2 = [MEMORY[0x1E4F64AC8] modernLoader];
  [v2 cancelAllForClient:*((void *)this + 56)];

  uint64_t v3 = [MEMORY[0x1E4F64AC8] modernLoader];
  [v3 closeForClient:*((void *)this + 56)];

  *((void *)this + 58) = &unk_1EF559AF8;
  *((void *)this + 55) = &unk_1EF559F18;

  gdc::ResourceFetcher::~ResourceFetcher(this);
}

void sub_1A21105F8(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  *(void *)(v1 + 464) = &unk_1EF559AF8;
  *(void *)(v1 + 440) = &unk_1EF559F18;

  gdc::ResourceFetcher::~ResourceFetcher((gdc::ResourceFetcher *)v1);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::TextureResourceDecoder>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::TextureResourceDecoder>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5816E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::TextureResourceDecoder>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5816E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::MCDecoder<md::mun::MuninMCMeshResource>::decode(uint64_t a1@<X0>, const gdc::ResourceKey *a2@<X1>, void *a3@<X2>, void *a4@<X8>)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  if (!*a3)
  {
    *a4 = 0;
    a4[1] = 0;
    return;
  }
  uint64_t v4 = a3;
  id v5 = a2;
  uint64_t v73 = (void (**)(void **))&unk_1EF5794E8;
  id v74 = a2;
  uint64_t v75 = (void **)&v73;
  v71[0] = &unk_1EF5794A0;
  v71[1] = a2;
  uint64_t v72 = v71;
  char v77 = v76;
  v76[0] = &unk_1EF5794A0;
  v76[1] = a2;
  if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
  }
  unint64_t v7 = (id)GEOGetVectorKitResourceLoadingLog_log;
  size_t v8 = v7;
  size_t v9 = v74;
  os_signpost_id_t v10 = *((void *)v74 + 10);
  if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
  {
    uint64_t v11 = *((void *)v9 + 11);
    *(_DWORD *)buf = 134217984;
    *(void *)&uint8_t buf[4] = v11;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v8, OS_SIGNPOST_INTERVAL_BEGIN, v10, "DecodeMC", "parent_signpost=%llu", buf, 0xCu);
  }

  if (v72 == v71)
  {
    (*(void (**)(void *))(v71[0] + 32))(v71);
  }
  else if (v72)
  {
    (*(void (**)(void))(*v72 + 40))();
  }
  if (v75 == (void **)&v73)
  {
    v73[4]((void **)&v73);
  }
  else if (v75)
  {
    (*((void (**)(void))*v75 + 5))();
  }
  uint64_t v12 = (*(uint64_t (**)(void))(*(void *)*v4 + 32))();
  unint64_t v13 = (*(uint64_t (**)(void))(*(void *)*v4 + 24))();
  long long v14 = mc_scene_decode(v12, v13);
  unint64_t v15 = v14;
  if (!v14)
  {
    *a4 = 0;
    a4[1] = 0;
    goto LABEL_98;
  }
  id v65 = 0;
  unint64_t v66 = 0;
  uint64_t v67 = 0;
  if (v14[5])
  {
    unint64_t v16 = 0;
    long long v17 = (id *)(a1 + 8);
    unint64_t v62 = (id *)(a1 + 8);
    unint64_t v63 = v14;
    do
    {
      unint64_t v18 = (unint64_t *)((char *)v15[4] + 24 * v16);
      unint64_t v19 = v18[2];
      v70[0] = 0uLL;
      if (v19)
      {
        uint64_t v20 = *(void *)(v19 + 8);
        if (v20)
        {
          memset(buf, 0, 17);
          long long v21 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:v20 length:*(unsigned int *)(v19 + 4) freeWhenDone:0];
          uint64_t v22 = (std::__shared_weak_count *)operator new(0x38uLL);
          v22->__shared_owners_ = 0;
          v22->__shared_weak_owners_ = 0;
          v22->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C50;
          *(void *)buf = gdc::DataObject::DataObject((gdc::DataObject *)&v22[1], v21);
          *(void *)&uint8_t buf[8] = v22;
          md::TextureResourceDecoder::decode(v17, v5, (const gdc::RawResourceSourceData *)buf, __src);
          v70[0] = __src[0];

          if (!atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
            std::__shared_weak_count::__release_weak(v22);
          }
        }
      }
      __int8 v23 = v66;
      unint64_t v24 = (v66 - v65) >> 4;
      if (v24 <= *v18)
      {
        unint64_t v30 = *v18 + 1;
        unint64_t v31 = v30 - v24;
        if (v30 <= v24)
        {
          if (v30 < v24)
          {
            uint64_t v44 = &v65[16 * v30];
            while (v23 != v44)
            {
              uint64_t v45 = (std::__shared_weak_count *)*((void *)v23 - 1);
              if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
                std::__shared_weak_count::__release_weak(v45);
              }
              v23 -= 16;
            }
            unint64_t v66 = v44;
          }
        }
        else
        {
          if (v31 <= (v67 - v66) >> 4)
          {
            bzero(v66, 16 * v31);
            v66 += 16 * v31;
            goto LABEL_25;
          }
          if (v30 >> 60) {
            abort();
          }
          uint64_t v32 = v4;
          uint64_t v33 = v67 - v65;
          if ((v67 - v65) >> 3 > v30) {
            unint64_t v30 = v33 >> 3;
          }
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v34 = v30;
          }
          if (v34 >> 60) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          __int8 v35 = v5;
          uint64_t v36 = (char *)operator new(16 * v34);
          uint64_t v37 = &v36[16 * v24];
          size_t v38 = 16 * v31;
          char v39 = &v36[16 * v34];
          bzero(v37, v38);
          id v40 = &v37[v38];
          if (v66 == v65)
          {
            id v65 = v37;
            unint64_t v66 = &v37[v38];
            uint64_t v67 = v39;
            id v5 = v35;
            uint64_t v4 = v32;
            long long v17 = v62;
            unint64_t v15 = v63;
            goto LABEL_62;
          }
          uint64_t v4 = v32;
          do
          {
            long long v41 = *((_OWORD *)v23 - 1);
            v23 -= 16;
            *((_OWORD *)v37 - 1) = v41;
            v37 -= 16;
            *(void *)__int8 v23 = 0;
            *((void *)v23 + 1) = 0;
          }
          while (v23 != v65);
          __int8 v23 = v65;
          size_t v42 = v66;
          id v65 = v37;
          unint64_t v66 = v40;
          uint64_t v67 = v39;
          id v5 = v35;
          long long v17 = v62;
          if (v42 != v23)
          {
            unint64_t v15 = v63;
            do
            {
              size_t v43 = (std::__shared_weak_count *)*((void *)v42 - 1);
              if (v43 && !atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
                std::__shared_weak_count::__release_weak(v43);
              }
              v42 -= 16;
            }
            while (v42 != v23);
LABEL_62:
            if (!v23) {
              goto LABEL_25;
            }
LABEL_63:
            operator delete(v23);
            goto LABEL_25;
          }
          unint64_t v15 = v63;
          if (v23) {
            goto LABEL_63;
          }
        }
      }
LABEL_25:
      unint64_t v25 = *v18;
      long long v26 = v70[0];
      if (*((void *)&v70[0] + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v70[0] + 1) + 8), 1uLL, memory_order_relaxed);
      }
      unsigned __int8 v27 = &v65[16 * v25];
      unint64_t v28 = (std::__shared_weak_count *)*((void *)v27 + 1);
      *(_OWORD *)unsigned __int8 v27 = v26;
      if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
        std::__shared_weak_count::__release_weak(v28);
        long long v29 = (std::__shared_weak_count *)*((void *)&v70[0] + 1);
        if (*((void *)&v70[0] + 1))
        {
LABEL_30:
          if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
            std::__shared_weak_count::__release_weak(v29);
          }
        }
      }
      else
      {
        long long v29 = (std::__shared_weak_count *)*((void *)&v70[0] + 1);
        if (*((void *)&v70[0] + 1)) {
          goto LABEL_30;
        }
      }
      ++v16;
    }
    while (v16 < (unint64_t)v15[5]);
  }
  uint64_t v46 = (*(uint64_t (**)(void))(*(void *)*v4 + 32))();
  unint64_t v47 = (*(uint64_t (**)(void))(*(void *)*v4 + 24))();
  no_copCGFloat y = mc_container_create_read_no_copy("MCP4", v46, v47);
  if (no_copy)
  {
    for (unint64_t i = 0; i < mc_container_chapter_count((uint64_t)no_copy); ++i)
    {
      if (mc_container_get_chapter_info((uint64_t)no_copy, i, (uint64_t)v69)
        && v69[0] == 5
        && mc_container_decode_la_data_chapter((uint64_t)no_copy, i, __src))
      {
        memcpy(&buf[7], __src, 0x2F0uLL);
        mc_container_free((uint64_t)no_copy);
        memcpy((char *)v70 + 7, &buf[7], 0x2F0uLL);
        char v50 = 0;
        goto LABEL_77;
      }
    }
    mc_container_free((uint64_t)no_copy);
  }
  char v50 = 1;
LABEL_77:
  uint64_t v51 = operator new(0x3C8uLL);
  v51[1] = 0;
  v51[2] = 0;
  void *v51 = &unk_1EF5828D0;
  if ((v50 & 1) == 0) {
    memcpy(&buf[7], (char *)v70 + 7, 0x2F0uLL);
  }
  id v52 = (char *)(v51 + 4);
  gdc::Resource::Resource((uint64_t)(v51 + 4), (uint64_t)v5);
  v51[3] = &unk_1EF5503F8;
  unsigned char v51[22] = v15;
  *((unsigned char *)v51 + 184) = 0;
  if ((v50 & 1) == 0)
  {
    memcpy(v51 + 24, &buf[7], 0x2F0uLL);
    *((unsigned char *)v51 + 184) = 1;
  }
  v51[120] = 0;
  *((_OWORD *)v51 + 59) = 0u;
  unint64_t v53 = v65;
  uint64_t v54 = v66;
  uint64_t v55 = v66 - v65;
  if (v66 != v65)
  {
    if (v55 < 0) {
      abort();
    }
    size_t v56 = (char *)operator new(v66 - v65);
    uint64_t v57 = 0;
    v51[118] = v56;
    v51[119] = v56;
    v51[120] = &v56[16 * (v55 >> 4)];
    do
    {
      os_signpost_id_t v58 = &v65[v57];
      id v59 = &v56[v57];
      *(void *)id v59 = *(void *)&v65[v57];
      uint64_t v60 = *(void *)&v65[v57 + 8];
      *((void *)v59 + 1) = v60;
      if (v60) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v60 + 8), 1uLL, memory_order_relaxed);
      }
      v57 += 16;
    }
    while (v58 + 16 != v66);
    v51[119] = &v56[v57];
    *a4 = v52;
    a4[1] = v51;
    if (!v65) {
      goto LABEL_98;
    }
    if (v66 != v65)
    {
      do
      {
        uint64_t v61 = (std::__shared_weak_count *)*((void *)v54 - 1);
        if (v61 && !atomic_fetch_add(&v61->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
          std::__shared_weak_count::__release_weak(v61);
        }
        v54 -= 16;
      }
      while (v54 != v65);
      unint64_t v53 = v65;
    }
    goto LABEL_97;
  }
  *a4 = v52;
  a4[1] = v51;
  if (v65) {
LABEL_97:
  }
    operator delete(v53);
LABEL_98:
  if (v77)
  {
    (*(void (**)(void *))(*v77 + 48))(v77);
    if (v77 == v76)
    {
      (*(void (**)(void *))(v76[0] + 32))(v76);
    }
    else if (v77)
    {
      (*(void (**)(void))(*v77 + 40))();
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
}

void sub_1A2111138(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)va);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)&STACK[0x670]);
  _Unwind_Resume(a1);
}

void md::mun::MuninMCMeshResource::~MuninMCMeshResource(void ***this)
{
  md::mun::MuninMCMeshResource::~MuninMCMeshResource(this);
  JUMPOUT(0x1A6239270);
}

{
  void **v2;
  void **v3;
  void **v4;
  std::__shared_weak_count *v5;
  void **v6;

  *this = (void **)&unk_1EF5503F8;
  mc_scene_free(this[19]);
  id v2 = this[115];
  if (v2)
  {
    uint64_t v3 = this[116];
    uint64_t v4 = this[115];
    if (v3 != v2)
    {
      do
      {
        id v5 = (std::__shared_weak_count *)*(v3 - 1);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 2;
      }
      while (v3 != v2);
      uint64_t v4 = this[115];
    }
    this[116] = v2;
    operator delete(v4);
  }
  if (*((unsigned char *)this + 160)) {
    *((unsigned char *)this + 160) = 0;
  }
  float v6 = this[2];
  if (v6 != this[4]) {
    free(v6);
  }
}

void sub_1A211137C(_Unwind_Exception *a1)
{
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)(v1 + 920));
  if (*(unsigned char *)(v1 + 160)) {
    *(unsigned char *)(v1 + 160) = 0;
  }
  uint64_t v3 = *(void **)(v1 + 16);
  if (v3 != *(void **)(v1 + 32)) {
    free(v3);
  }
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::mun::MuninMCMeshResource>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::mun::MuninMCMeshResource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5828D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::mun::MuninMCMeshResource>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5828D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#2},std::allocator<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#2}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
  }
  id v2 = (id)GEOGetVectorKitResourceLoadingLog_log;
  uint64_t v3 = v2;
  uint64_t v4 = *(void *)(a1 + 8);
  os_signpost_id_t v5 = *(void *)(v4 + 80);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    uint64_t v6 = *(void *)(v4 + 88);
    int v7 = 134217984;
    uint64_t v8 = v6;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v5, "DecodeMC", "parent_signpost=%llu", (uint8_t *)&v7, 0xCu);
  }
}

uint64_t std::__function::__func<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#2},std::allocator<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#2}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5794A0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#2},std::allocator<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#2}>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5794A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#2},std::allocator<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#2}>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#1},std::allocator<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#1}>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  if (GEOGetVectorKitResourceLoadingLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitResourceLoadingLog_onceToken, &__block_literal_global_25);
  }
  uint64_t v2 = (id)GEOGetVectorKitResourceLoadingLog_log;
  uint64_t v3 = v2;
  uint64_t v4 = *(void *)(a1 + 8);
  os_signpost_id_t v5 = *(void *)(v4 + 80);
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    uint64_t v6 = *(void *)(v4 + 88);
    int v7 = 134217984;
    uint64_t v8 = v6;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v5, "DecodeMC", "parent_signpost=%llu", (uint8_t *)&v7, 0xCu);
  }
}

uint64_t std::__function::__func<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#1},std::allocator<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5794E8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#1},std::allocator<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#1}>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5794E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#1},std::allocator<md::MCDecoder<md::mun::MuninMCMeshResource>::decode(gdc::ResourceKey const&,gdc::RawResourceSourceData const&)::{lambda(void)#1}>,void ()(void)>::~__func()
{
}

void md::MCDecoder<md::mun::MuninMCMeshResource>::~MCDecoder(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5544F8;
  *(void *)(a1 + 8) = &unk_1EF5426B0;
  *(void *)(a1 + 16) = &unk_1EF559798;

  JUMPOUT(0x1A6239270);
}

uint64_t md::MCDecoder<md::mun::MuninMCMeshResource>::~MCDecoder(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5544F8;
  *(void *)(a1 + 8) = &unk_1EF5426B0;
  *(void *)(a1 + 16) = &unk_1EF559798;

  return a1;
}

uint64_t std::__shared_ptr_emplace<md::MCDecoder<md::mun::MuninMCMeshResource>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::MCDecoder<md::mun::MuninMCMeshResource>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582B00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::MCDecoder<md::mun::MuninMCMeshResource>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582B00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::C3mResourceDecoder<md::mun::MuninMeshResource>::decode(uint64_t a1@<X0>, const gdc::ResourceKey *a2@<X1>, unsigned char *a3@<X2>, void *a4@<X8>)
{
  if (*(void *)a3) {
    BOOL v6 = a3[16] == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6
    || (uint64_t v9 = (unsigned char *)(*(uint64_t (**)(void))(**(void **)a3 + 32))(*(void *)a3),
        unint64_t v10 = (*(uint64_t (**)(void))(**(void **)a3 + 24))(),
        geo::c3m::loadFromChunk((uint64_t *)(a1 + 72), v9, v10, (uint64_t)v47, v11, v12),
        !v47[0]))
  {
    *a4 = 0;
    a4[1] = 0;
  }
  else
  {
    std::string __p = 0;
    uint64_t v45 = 0;
    unint64_t v46 = 0;
    std::vector<std::shared_ptr<md::GEOVectorTileResource>>::reserve((uint64_t)&__p, 0x4EC4EC4EC4EC4EC5 * ((v53 - v52) >> 3));
    unint64_t v13 = v52;
    long long v14 = v53;
    if (v52 != v53)
    {
      unint64_t v15 = (id *)(a1 + 8);
      do
      {
        int v16 = *v13;
        if ((v16 - 4) < 2 || v16 == 2)
        {
          unint64_t v18 = (void **)*((void *)v13 + 1);
          if (*((void *)v13 + 2) - (void)v18 == 32)
          {
            char v39 = 0;
            id v40 = 0;
            char v41 = 0;
            unint64_t v19 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:**v18 length:(*v18)[1] - **v18 freeWhenDone:0];
            uint64_t v20 = (std::__shared_weak_count *)operator new(0x38uLL);
            v20->__shared_owners_ = 0;
            v20->__shared_weak_owners_ = 0;
            v20->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C50;
            char v39 = gdc::DataObject::DataObject((gdc::DataObject *)&v20[1], v19);
            id v40 = v20;
            md::ImageResourceDecoder::decode(a2, (const gdc::RawResourceSourceData *)&v39, (uint64_t *)&v38);
            long long v21 = v45;
            if ((unint64_t)v45 < v46) {
              goto LABEL_21;
            }
            goto LABEL_25;
          }
        }
        else if (!*v13)
        {
          uint64_t v22 = (void **)*((void *)v13 + 1);
          if (*((void *)v13 + 2) - (void)v22 == 32)
          {
            char v39 = 0;
            id v40 = 0;
            char v41 = 0;
            unint64_t v19 = [MEMORY[0x1E4F1C9B8] dataWithBytesNoCopy:**v22 length:(*v22)[1] - **v22 freeWhenDone:0];
            __int8 v23 = (std::__shared_weak_count *)operator new(0x38uLL);
            v23->__shared_owners_ = 0;
            v23->__shared_weak_owners_ = 0;
            v23->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582C50;
            char v39 = gdc::DataObject::DataObject((gdc::DataObject *)&v23[1], v19);
            id v40 = v23;
            md::TextureResourceDecoder::decode(v15, a2, (const gdc::RawResourceSourceData *)&v39, &v38);
            long long v21 = v45;
            if ((unint64_t)v45 < v46)
            {
LABEL_21:
              *(_OWORD *)long long v21 = v38;
              uint64_t v45 = v21 + 16;
              goto LABEL_28;
            }
LABEL_25:
            unsigned __int8 v27 = std::vector<std::shared_ptr<gdc::LayerDataRequest>>::__push_back_slow_path<std::shared_ptr<gdc::LayerDataRequest>>((char **)&__p, (uint64_t)&v38);
            unint64_t v28 = (std::__shared_weak_count *)*((void *)&v38 + 1);
            uint64_t v45 = v27;
            if (*((void *)&v38 + 1)
              && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v38 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
              std::__shared_weak_count::__release_weak(v28);
            }
LABEL_28:

            if (v41)
            {
              if (v42 != v43) {
                free(v42);
              }
              char v41 = 0;
            }
            long long v26 = v40;
            if (!v40) {
              goto LABEL_9;
            }
LABEL_33:
            if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
              std::__shared_weak_count::__release_weak(v26);
            }
            goto LABEL_9;
          }
        }
        char v39 = 0;
        id v40 = 0;
        unint64_t v24 = v45;
        if ((unint64_t)v45 < v46)
        {
          *(void *)uint64_t v45 = 0;
          *((void *)v24 + 1) = 0;
          uint64_t v45 = v24 + 16;
        }
        else
        {
          unint64_t v25 = std::vector<std::shared_ptr<gdc::LayerDataRequest>>::__push_back_slow_path<std::shared_ptr<gdc::LayerDataRequest>>((char **)&__p, (uint64_t)&v39);
          long long v26 = v40;
          uint64_t v45 = v25;
          if (v40) {
            goto LABEL_33;
          }
        }
LABEL_9:
        v13 += 104;
      }
      while (v13 != v14);
    }
    long long v29 = operator new(0x348uLL);
    v29[1] = 0;
    v29[2] = 0;
    void *v29 = &unk_1EF582898;
    gdc::Resource::Resource((uint64_t)(v29 + 4), (uint64_t)a2);
    v29[3] = &unk_1EF550340;
    geo::c3m::Model::Model((geo::c3m::Model *)(v29 + 22), (const geo::c3m::Model *)&v48);
    *a4 = v29 + 4;
    a4[1] = v29;
    unint64_t v30 = (char *)__p;
    if (__p)
    {
      unint64_t v31 = v45;
      if (v45 != __p)
      {
        do
        {
          uint64_t v32 = (std::__shared_weak_count *)*((void *)v31 - 1);
          if (v32 && !atomic_fetch_add(&v32->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
            std::__shared_weak_count::__release_weak(v32);
          }
          v31 -= 16;
        }
        while (v31 != v30);
        unint64_t v30 = (char *)__p;
      }
      operator delete(v30);
    }
    if (v47[0])
    {
      uint64_t v33 = v52;
      unint64_t v34 = v53;
      if (v52 != v53)
      {
        do
        {
          __int8 v35 = (void *)*((void *)v33 + 1);
          uint64_t v36 = (void *)*((void *)v33 + 2);
          if (v35 != v36)
          {
            do
            {
              uint64_t v37 = (std::__shared_weak_count *)v35[1];
              if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
                std::__shared_weak_count::__release_weak(v37);
              }
              v35 += 4;
            }
            while (v35 != v36);
            __int8 v35 = (void *)*((void *)v33 + 1);
          }
          if (v35 != *((void **)v33 + 3)) {
            free(v35);
          }
          v33 += 104;
        }
        while (v33 != v34);
        uint64_t v33 = v52;
      }
      if (v33 != v54) {
        free(v33);
      }
      geo::small_vector_base<geo::c3m::Mesh>::runDestructors((uint64_t)v49, v50);
      if (v49 != v51) {
        free(v49);
      }
    }
  }
}

void sub_1A2111E78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,char a30)
{
  unint64_t shared_weak_owners = (void *)v31[1].__shared_weak_owners_;
  if (shared_weak_owners != (void *)v31[2].__shared_owners_) {
    free(shared_weak_owners);
  }
  std::__shared_weak_count::~__shared_weak_count(v31);
  operator delete(v34);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)&a27);
  if (a30) {
    geo::c3m::Model::~Model(v30);
  }
  _Unwind_Resume(a1);
}

geo::c3m::Model *geo::c3m::Model::Model(geo::c3m::Model *this, const geo::c3m::Model *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = this;
  long long v4 = *(_OWORD *)a2;
  *((void *)this + 2) = *((void *)a2 + 2);
  *(_OWORD *)this = v4;
  long long v5 = *(_OWORD *)((char *)a2 + 24);
  *((void *)this + 5) = *((void *)a2 + 5);
  *(_OWORD *)((char *)this + 24) = v5;
  *((void *)this + 6) = *((void *)a2 + 6);
  long long v6 = *(_OWORD *)((char *)a2 + 56);
  long long v7 = *(_OWORD *)((char *)a2 + 72);
  *(_OWORD *)((char *)this + 88) = *(_OWORD *)((char *)a2 + 88);
  *(_OWORD *)((char *)this + 72) = v7;
  *(_OWORD *)((char *)this + 56) = v6;
  uint64_t v8 = (void *)((char *)this + 136);
  *((void *)this + 13) = (char *)this + 136;
  *((void *)this + 14) = (char *)this + 136;
  *((void *)this + 15) = (char *)this + 136;
  *((void *)this + 16) = 1;
  uint64_t v9 = (long long **)*((void *)a2 + 13);
  unint64_t v10 = (long long **)*((void *)a2 + 14);
  unint64_t v11 = 0xD37A6F4DE9BD37A7 * (v10 - v9);
  if (v11 >= 2)
  {
    if (v11 <= 4) {
      unint64_t v12 = 4;
    }
    else {
      unint64_t v12 = 0xD37A6F4DE9BD37A7 * (v10 - v9);
    }
    unint64_t v13 = malloc_type_malloc(184 * v12, 0x1030040E47C81F6uLL);
    uint64_t v8 = v13;
    uint64_t v14 = *((void *)v3 + 13);
    uint64_t v15 = *((void *)v3 + 14);
    if (v14 == v15)
    {
      uint64_t v24 = *((void *)v3 + 13);
    }
    else
    {
      int v16 = v13;
      do
      {
        *int v16 = v16 + 4;
        v16[1] = v16 + 4;
        v16[2] = v16 + 4;
        uint64_t v18 = *(void *)(v14 + 16);
        v16[3] = *(void *)(v14 + 24);
        uint64_t v19 = *(void *)v14;
        if (*(void *)v14 == v18)
        {
          v16[1] = (char *)v16 + *(void *)(v14 + 8) - v19 + 32;
          uint64_t v20 = *(void *)(v14 + 8);
          if (v19 != v20)
          {
            unint64_t v21 = 0;
            do
            {
              uint64_t v22 = &v16[v21 / 8];
              long long v23 = *(_OWORD *)(v19 + v21);
              v22[6] = *(void *)(v19 + v21 + 16);
              *((_OWORD *)v22 + 2) = v23;
              v21 += 24;
            }
            while (v19 + v21 != v20);
          }
        }
        else
        {
          uint64_t v17 = *(void *)(v14 + 8);
          *int v16 = v19;
          v16[1] = v17;
          *(_OWORD *)uint64_t v14 = 0uLL;
          *(_OWORD *)(v14 + 16) = 0uLL;
        }
        v16[10] = 0;
        v16[11] = 0;
        v16[12] = 0;
        *((_OWORD *)v16 + 5) = *(_OWORD *)(v14 + 80);
        v16[12] = *(void *)(v14 + 96);
        *(void *)(v14 + 80) = 0;
        *(void *)(v14 + 88) = 0;
        *(void *)(v14 + 96) = 0;
        v16[13] = 0;
        v16[14] = 0;
        v16[15] = 0;
        *(_OWORD *)(v16 + 13) = *(_OWORD *)(v14 + 104);
        v16[15] = *(void *)(v14 + 120);
        *(void *)(v14 + 104) = 0;
        *(void *)(v14 + 112) = 0;
        *(void *)(v14 + 120) = 0;
        v16[16] = 0;
        v16[17] = 0;
        v16[18] = 0;
        *((_OWORD *)v16 + 8) = *(_OWORD *)(v14 + 128);
        v16[18] = *(void *)(v14 + 144);
        *(void *)(v14 + 128) = 0;
        *(void *)(v14 + 136) = 0;
        *(void *)(v14 + 144) = 0;
        v16[19] = 0;
        v16[20] = 0;
        v16[21] = 0;
        *(_OWORD *)(v16 + 19) = *(_OWORD *)(v14 + 152);
        v16[21] = *(void *)(v14 + 168);
        *(void *)(v14 + 152) = 0;
        *(void *)(v14 + 160) = 0;
        *(void *)(v14 + 168) = 0;
        v16[22] = *(void *)(v14 + 176);
        v16 += 23;
        v14 += 184;
      }
      while (v14 != v15);
      uint64_t v24 = *((void *)v3 + 13);
      uint64_t v14 = *((void *)v3 + 14);
    }
    geo::small_vector_base<geo::c3m::Mesh>::runDestructors(v24, v14);
    *((void *)v3 + 13) = v8;
    *((void *)v3 + 14) = v8;
    *((void *)v3 + 16) = v12;
  }
  uint64_t v93 = v3;
  if (v9 != v10)
  {
    unint64_t v94 = 0xD37A6F4DE9BD37A7 * (v10 - v9);
    long long v96 = v2;
    do
    {
      unint64_t v25 = v8 + 4;
      *uint64_t v8 = v8 + 4;
      v8[1] = v8 + 4;
      _DWORD v8[2] = v8 + 4;
      void v8[3] = 2;
      long long v26 = *v9;
      unsigned __int8 v27 = v9[1];
      unint64_t v28 = 0xAAAAAAAAAAAAAAABLL * (((char *)v27 - (char *)*v9) >> 3);
      if (v28 >= 3)
      {
        if (v28 <= 4) {
          unint64_t v29 = 4;
        }
        else {
          unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * (((char *)v27 - (char *)*v9) >> 3);
        }
        unint64_t v25 = malloc_type_malloc(24 * v29, 0x1000040504FFAC1uLL);
        unint64_t v30 = (long long *)*v8;
        unint64_t v31 = (long long *)v8[1];
        if ((long long *)*v8 != v31)
        {
          uint64_t v32 = v25;
          do
          {
            long long v33 = *v30;
            v32[2] = *((void *)v30 + 2);
            *(_OWORD *)uint64_t v32 = v33;
            v32 += 3;
            unint64_t v30 = (long long *)((char *)v30 + 24);
          }
          while (v30 != v31);
        }
        *uint64_t v8 = v25;
        v8[1] = v25;
        void v8[3] = v29;
      }
      if (v26 != v27)
      {
        do
        {
          long long v34 = *v26;
          uint64_t v25[2] = *((void *)v26 + 2);
          *(_OWORD *)unint64_t v25 = v34;
          v25 += 3;
          long long v26 = (long long *)((char *)v26 + 24);
        }
        while (v26 != v27);
        unint64_t v25 = (void *)v8[1];
      }
      v8[10] = 0;
      v8[1] = &v25[3 * v28];
      v8[11] = 0;
      v8[12] = 0;
      uint64_t v36 = v9[10];
      __int8 v35 = v9[11];
      int64_t v37 = (char *)v35 - (char *)v36;
      if (v35 != v36)
      {
        if (0xAAAAAAAAAAAAAAABLL * (v37 >> 2) >= 0x1555555555555556) {
          abort();
        }
        long long v38 = (char *)operator new(v37);
        v8[10] = v38;
        v8[11] = v38;
        v8[12] = &v38[4 * (v37 >> 2)];
        size_t v39 = 12 * ((v37 - 12) / 0xCuLL) + 12;
        memcpy(v38, v36, v39);
        v8[11] = &v38[v39];
      }
      v8[13] = 0;
      v8[14] = 0;
      v8[15] = 0;
      char v41 = v9[13];
      id v40 = v9[14];
      uint64_t v42 = (char *)v40 - (char *)v41;
      if (v40 != v41)
      {
        if (v42 < 0) {
          abort();
        }
        size_t v43 = (char *)operator new((char *)v40 - (char *)v41);
        v8[13] = v43;
        v8[14] = v43;
        v8[15] = &v43[8 * (v42 >> 3)];
        size_t v44 = v42 & 0xFFFFFFFFFFFFFFF8;
        memcpy(v43, v41, v44);
        v8[14] = &v43[v44];
      }
      v8[16] = 0;
      v8[17] = 0;
      v8[18] = 0;
      unint64_t v46 = v9[16];
      uint64_t v45 = v9[17];
      int64_t v47 = (char *)v45 - (char *)v46;
      if (v45 != v46)
      {
        if (v47 < 0) {
          abort();
        }
        uint64_t v48 = (char *)operator new((char *)v45 - (char *)v46);
        v8[16] = v48;
        v8[17] = v48;
        id v49 = &v48[2 * (v47 >> 1)];
        v8[18] = v49;
        memcpy(v48, v46, v47);
        v8[17] = v49;
      }
      v8[19] = 0;
      v8[20] = 0;
      v8[21] = 0;
      uint64_t v51 = v9[19];
      uint64_t v50 = v9[20];
      int64_t v52 = (char *)v50 - (char *)v51;
      if (v50 != v51)
      {
        if (v52 < 0) {
          abort();
        }
        unint64_t v53 = (char *)operator new((char *)v50 - (char *)v51);
        v8[19] = v53;
        v8[20] = v53;
        uint64_t v54 = &v53[2 * (v52 >> 1)];
        v8[21] = v54;
        memcpy(v53, v51, v52);
        v8[20] = v54;
      }
      v8[22] = v9[22];
      v9 += 23;
      v8 += 23;
    }
    while (v9 != v10);
    uint64_t v3 = v93;
    unint64_t v11 = v94;
    uint64_t v8 = (void *)*((void *)v93 + 14);
    uint64_t v2 = v96;
  }
  *((void *)v3 + 14) = &v8[23 * v11];
  uint64_t v55 = (char *)v3 + 352;
  *((void *)v3 + 40) = (char *)v3 + 352;
  *((void *)v3 + 41) = (char *)v3 + 352;
  *((void *)v3 + 42) = (char *)v3 + 352;
  *((void *)v3 + 43) = 3;
  uint64_t v57 = (char *)*((void *)v2 + 40);
  size_t v56 = (char *)*((void *)v2 + 41);
  unint64_t v58 = 0x4EC4EC4EC4EC4EC5 * ((v56 - v57) >> 3);
  uint64_t v95 = v56;
  if (v58 >= 4)
  {
    if (v58 <= 8) {
      uint64_t v59 = 8;
    }
    else {
      uint64_t v59 = 0x4EC4EC4EC4EC4EC5 * ((v56 - v57) >> 3);
    }
    uint64_t v60 = (char *)malloc_type_malloc(104 * v59, 0x10200409A70330CuLL);
    uint64_t v55 = v60;
    uint64_t v61 = *((void *)v3 + 40);
    uint64_t v62 = *((void *)v3 + 41);
    if (v61 != v62)
    {
      unint64_t v63 = v60;
      do
      {
        *(unsigned char *)unint64_t v63 = *(unsigned char *)v61;
        v63[1] = v63 + 5;
        id v65 = *(void **)(v61 + 8);
        v63[2] = v63 + 5;
        uint64_t v63[3] = v63 + 5;
        unint64_t v66 = *(void **)(v61 + 24);
        v63[4] = *(void *)(v61 + 32);
        if (v65 == v66)
        {
          v63[2] = (char *)v63 + *(void *)(v61 + 16) - (void)v65 + 40;
          uint64_t v67 = *(void **)(v61 + 16);
          if (v65 != v67)
          {
            uint64_t v68 = 0;
            do
            {
              uint64_t v69 = (char *)&v63[v68];
              uint64_t v70 = &v65[v68];
              *(_OWORD *)(v69 + 40) = *(_OWORD *)&v65[v68];
              void *v70 = 0;
              v70[1] = 0;
              uint64_t v71 = v65[v68 + 2];
              v69[64] = v65[v68 + 3];
              *((void *)v69 + 7) = v71;
              v68 += 4;
            }
            while (v70 + 4 != v67);
          }
        }
        else
        {
          uint64_t v64 = *(void *)(v61 + 16);
          v63[1] = v65;
          v63[2] = v64;
          *(_OWORD *)(v61 + 8) = 0uLL;
          *(_OWORD *)(v61 + 24) = 0uLL;
        }
        v63 += 13;
        v61 += 104;
      }
      while (v61 != v62);
      uint64_t v72 = (void *)*((void *)v93 + 40);
      for (unint64_t i = (void *)*((void *)v93 + 41); v72 != i; v72 += 13)
      {
        id v74 = (void *)v72[1];
        uint64_t v75 = (void *)v72[2];
        if (v74 != v75)
        {
          do
          {
            unint64_t v76 = (std::__shared_weak_count *)v74[1];
            if (v76 && !atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
              std::__shared_weak_count::__release_weak(v76);
            }
            v74 += 4;
          }
          while (v74 != v75);
          id v74 = (void *)v72[1];
        }
        if (v74 != (void *)v72[3]) {
          free(v74);
        }
      }
    }
    uint64_t v3 = v93;
    size_t v56 = v95;
    *((void *)v93 + 40) = v55;
    *((void *)v93 + 41) = v55;
    *((void *)v93 + 43) = v59;
  }
  if (v57 != v56)
  {
    do
    {
      *uint64_t v55 = *v57;
      char v77 = v55 + 40;
      *((void *)v55 + 1) = v55 + 40;
      *((void *)v55 + 2) = v55 + 40;
      *((void *)v55 + 3) = v55 + 40;
      *((void *)v55 + 4) = 2;
      uint64_t v79 = *((void *)v57 + 1);
      uint64_t v78 = *((void *)v57 + 2);
      unint64_t v80 = (v78 - v79) >> 5;
      if ((unint64_t)(v78 - v79) >= 0x41)
      {
        if (v80 <= 4) {
          uint64_t v81 = 4;
        }
        else {
          uint64_t v81 = (v78 - v79) >> 5;
        }
        uint64_t v82 = malloc_type_malloc(32 * v81, 0x10200402C28E7A6uLL);
        char v77 = v82;
        uint64_t v83 = *((void *)v55 + 1);
        uint64_t v84 = *((void *)v55 + 2);
        if (v83 != v84)
        {
          uint64_t v85 = (char *)v82;
          do
          {
            *(_OWORD *)uint64_t v85 = *(_OWORD *)v83;
            *(void *)uint64_t v83 = 0;
            *(void *)(v83 + 8) = 0;
            uint64_t v86 = *(void *)(v83 + 16);
            v85[24] = *(unsigned char *)(v83 + 24);
            *((void *)v85 + 2) = v86;
            v83 += 32;
            v85 += 32;
          }
          while (v83 != v84);
          uint64_t v88 = *((void *)v55 + 1);
          uint64_t v87 = *((void *)v55 + 2);
          while (v88 != v87)
          {
            unint64_t v89 = *(std::__shared_weak_count **)(v88 + 8);
            if (v89)
            {
              if (!atomic_fetch_add(&v89->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v89->__on_zero_shared)(v89);
                std::__shared_weak_count::__release_weak(v89);
              }
            }
            v88 += 32;
          }
        }
        *((void *)v55 + 1) = v77;
        *((void *)v55 + 2) = v77;
        *((void *)v55 + 4) = v81;
        size_t v56 = v95;
        unint64_t v80 = (v78 - v79) >> 5;
      }
      if (v79 != v78)
      {
        do
        {
          uint64_t v91 = *(void *)(v79 + 8);
          *char v77 = *(void *)v79;
          v77[1] = v91;
          if (v91) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v91 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v90 = *(void *)(v79 + 16);
          *((unsigned char *)v77 + 24) = *(unsigned char *)(v79 + 24);
          void v77[2] = v90;
          v79 += 32;
          v77 += 4;
        }
        while (v79 != v78);
        char v77 = (void *)*((void *)v55 + 2);
      }
      *((void *)v55 + 2) = &v77[4 * v80];
      v57 += 104;
      v55 += 104;
    }
    while (v57 != v56);
    uint64_t v3 = v93;
    uint64_t v55 = (char *)*((void *)v93 + 41);
  }
  *((void *)v3 + 41) = &v55[104 * v58];
  return v3;
}

void sub_1A2112720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t *a10)
{
  geo::small_vector_base<geo::c3m::Mesh>::runDestructors(a10[13], a10[14]);
  unint64_t v11 = (void *)a10[13];
  if (v11 != (void *)a10[15]) {
    free(v11);
  }
  _Unwind_Resume(a1);
}

void geo::c3m::Model::~Model(geo::c3m::Model *this)
{
  uint64_t v2 = (void *)*((void *)this + 40);
  uint64_t v3 = (void *)*((void *)this + 41);
  if (v2 != v3)
  {
    do
    {
      long long v4 = (void *)v2[1];
      long long v5 = (void *)v2[2];
      if (v4 != v5)
      {
        do
        {
          long long v6 = (std::__shared_weak_count *)v4[1];
          if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
          v4 += 4;
        }
        while (v4 != v5);
        long long v4 = (void *)v2[1];
      }
      if (v4 != (void *)v2[3]) {
        free(v4);
      }
      v2 += 13;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)*((void *)this + 40);
  }
  if (v2 != *((void **)this + 42)) {
    free(v2);
  }
  geo::small_vector_base<geo::c3m::Mesh>::runDestructors(*((void *)this + 13), *((void *)this + 14));
  long long v7 = (void *)*((void *)this + 13);
  if (v7 != *((void **)this + 15)) {
    free(v7);
  }
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  std::__shared_weak_count *v6;

  uint64_t v2 = (void *)*((void *)this + 40);
  uint64_t v3 = (void *)*((void *)this + 41);
  if (v2 != v3)
  {
    while (1)
    {
      long long v4 = (void *)v2[1];
      long long v5 = (void *)v2[2];
      if (v4 == v5)
      {
        if (v4 == (void *)v2[3]) {
          goto LABEL_3;
        }
      }
      else
      {
        do
        {
          long long v6 = (std::__shared_weak_count *)v4[1];
          if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
            std::__shared_weak_count::__release_weak(v6);
          }
          v4 += 4;
        }
        while (v4 != v5);
        long long v4 = (void *)v2[1];
        if (v4 == (void *)v2[3]) {
          goto LABEL_3;
        }
      }
      free(v4);
LABEL_3:
      v2 += 13;
      if (v2 == v3)
      {
        uint64_t v2 = (void *)*((void *)this + 40);
        break;
      }
    }
  }
  if (v2 != *((void **)this + 42)) {
    free(v2);
  }
  geo::small_vector_base<geo::c3m::Mesh>::runDestructors((uint64_t)this + 104, *((void *)this + 13), *((void *)this + 14));
  if (*((void *)this + 13) != *((void *)this + 15)) {
    free(*((void **)this + 13));
  }
}

void geo::small_vector_base<geo::c3m::Mesh>::runDestructors(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v3 = a1;
    do
    {
      long long v4 = *(void **)(v3 + 152);
      if (v4)
      {
        *(void *)(v3 + 160) = v4;
        operator delete(v4);
      }
      long long v5 = *(void **)(v3 + 128);
      if (v5)
      {
        *(void *)(v3 + 136) = v5;
        operator delete(v5);
      }
      long long v6 = *(void **)(v3 + 104);
      if (v6)
      {
        *(void *)(v3 + 112) = v6;
        operator delete(v6);
      }
      long long v7 = *(void **)(v3 + 80);
      if (v7)
      {
        *(void *)(v3 + 88) = v7;
        operator delete(v7);
      }
      if (*(void *)v3 != *(void *)(v3 + 16)) {
        free(*(void **)v3);
      }
      v3 += 184;
    }
    while (v3 != a2);
  }
}

void md::mun::MuninMeshResource::~MuninMeshResource(md::mun::MuninMeshResource *this)
{
  *(void *)this = &unk_1EF550340;
  geo::c3m::Model::~Model((md::mun::MuninMeshResource *)((char *)this + 152));
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2 != *((void **)this + 4)) {
    free(v2);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;

  *(void *)this = &unk_1EF550340;
  geo::c3m::Model::~Model((md::mun::MuninMeshResource *)((char *)this + 152));
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2 != *((void **)this + 4)) {
    free(v2);
  }
}

uint64_t std::__shared_ptr_emplace<md::mun::MuninMeshResource>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::mun::MuninMeshResource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582898;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::mun::MuninMeshResource>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582898;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::C3mResourceDecoder<md::mun::MuninMeshResource>::~C3mResourceDecoder(uint64_t a1)
{
  md::C3mResourceDecoder<md::mun::MuninMeshResource>::~C3mResourceDecoder(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::C3mResourceDecoder<md::mun::MuninMeshResource>::~C3mResourceDecoder(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5387D8;
  std::mutex::~mutex((std::mutex *)(a1 + 112));
  uint64_t v2 = *(void ****)(a1 + 88);
  if (v2)
  {
    do
    {
      uint64_t v3 = *v2;
      geo::c3m::EdgebreakerDecodeTable::~EdgebreakerDecodeTable(v2 + 4);
      operator delete(v2);
      uint64_t v2 = (void ***)v3;
    }
    while (v3);
  }
  long long v4 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)(a1 + 40) = &unk_1EF53D7F8;
  *(void *)(a1 + 48) = &unk_1EF559798;

  *(void *)(a1 + 8) = &unk_1EF5426B0;
  *(void *)(a1 + 16) = &unk_1EF559798;

  return a1;
}

uint64_t std::__shared_ptr_emplace<md::C3mResourceDecoder<md::mun::MuninMeshResource>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::C3mResourceDecoder<md::mun::MuninMeshResource>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580720;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::C3mResourceDecoder<md::mun::MuninMeshResource>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580720;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::LegacyTrafficRenderLayer::reserveStencilRange(uint64_t result, uint64_t a2)
{
  unsigned __int8 v2 = *(unsigned char *)(result + 49) - *(unsigned char *)(result + 48) + 1;
  uint64_t v3 = *(unsigned __int8 **)(a2 + 24);
  int v4 = *v3;
  unsigned int v5 = v4 + v2;
  unsigned int v6 = v3[1];
  BOOL v7 = v5 > v6;
  if (v5 <= v6) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v3 + 4;
  }
  *(void *)(result + 368) = v8;
  if (v7)
  {
    v3[1] = v3[2];
    int v4 = 1;
  }
  unsigned __int8 *v3 = v4 + v2;
  *(_DWORD *)(result + 364) = v4 - *(unsigned __int8 *)(result + 48);
  return result;
}

void *md::LegacyTrafficRenderLayer::layout(md::LegacyTrafficRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v314 = *MEMORY[0x1E4F143B8];
  v308[0] = &unk_1EF576CB0;
  v308[1] = a2;
  v306[0] = &unk_1EF576CF8;
  v306[1] = a2;
  __int16 v307 = v306;
  unint64_t v311 = v310;
  v309 = v308;
  v310[0] = &unk_1EF576CF8;
  v310[1] = a2;
  std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()((uint64_t)v308);
  if (v307 == v306)
  {
    (*(void (**)(void *))(v306[0] + 32))(v306);
  }
  else if (v307)
  {
    (*(void (**)(void *))(*v307 + 40))(v307);
  }
  if (v309 == v308)
  {
    (*(void (**)(void *))(v308[0] + 32))(v308);
  }
  else if (v309)
  {
    (*(void (**)(void *))(*v309 + 40))(v309);
  }
  uint64_t v4 = *((void *)this + 44);
  *(void *)(v4 + 112) = 0;
  *(void *)(v4 + 120) = 0;
  unsigned int v5 = *(void **)(*(void *)(*((void *)this + 5) + 24) + 8);
  uint64_t v6 = v5[3];
  uint64_t v7 = v5[4];
  uint64_t v8 = v7 - v6;
  int64_t v244 = a2;
  if (v7 == v6) {
    goto LABEL_16;
  }
  uint64_t v9 = 0;
  unint64_t v10 = v8 >> 3;
  while (1)
  {
    unint64_t v11 = *(unsigned __int8 **)(v6 + 8 * v9);
    if (*v11 == *((unsigned __int8 *)this + 384))
    {
      unint64_t v12 = *((void *)v11 + 1);
      uint64_t v13 = v5[15];
      if (v12 < (v5[16] - v13) >> 3) {
        break;
      }
    }
    if (++v9 >= v10) {
      goto LABEL_16;
    }
  }
  uint64_t v14 = *(void *)(v13 + 8 * v12);
  if (!v14) {
LABEL_16:
  }
    uint64_t v15 = 0;
  else {
    uint64_t v15 = *(void *)(*(void *)(v14 + 24) + 8 * *((unsigned __int8 *)this + 385));
  }
  uint64_t v16 = *(void *)(v15 + 72);
  if (*(void *)(v15 + 80) != v16) {
    *(void *)(v15 + 80) = v16;
  }
  *(void *)(v15 + 32) = 0;
  int v249 = *((_DWORD *)this + 91);
  LOBYTE(v287.f64[0]) = 0;
  v312[0] = &unk_1EF578918;
  float64x2_t v313 = v312;
  uint64_t v17 = (uint64_t *)*((void *)v244 + 1);
  int8x8_t v18 = (int8x8_t)v17[1];
  uint64_t v252 = this;
  if (!*(void *)&v18) {
    goto LABEL_226;
  }
  uint8x8_t v19 = (uint8x8_t)vcnt_s8(v18);
  v19.i16[0] = vaddlv_u8(v19);
  if (v19.u32[0] > 1uLL)
  {
    uint64_t v20 = 0x3070CB6B3C7F21D3;
    if (*(void *)&v18 <= 0x3070CB6B3C7F21D3uLL) {
      uint64_t v20 = 0x3070CB6B3C7F21D3uLL % *(void *)&v18;
    }
  }
  else
  {
    uint64_t v20 = (*(void *)&v18 - 1) & 0x3070CB6B3C7F21D3;
  }
  uint64_t v21 = *v17;
  uint64_t v22 = *(void **)(v21 + 8 * v20);
  if (!v22) {
    goto LABEL_42;
  }
  long long v23 = (void *)*v22;
  if (!v23) {
    goto LABEL_42;
  }
  if (v19.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v25 = v23[1];
      if (v25 == 0x3070CB6B3C7F21D3)
      {
        if (v23[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_40;
        }
      }
      else if ((v25 & (*(void *)&v18 - 1)) != v20)
      {
        goto LABEL_42;
      }
      long long v23 = (void *)*v23;
      if (!v23) {
        goto LABEL_42;
      }
    }
  }
  while (1)
  {
    unint64_t v24 = v23[1];
    if (v24 == 0x3070CB6B3C7F21D3) {
      break;
    }
    if (v24 >= *(void *)&v18) {
      v24 %= *(void *)&v18;
    }
    if (v24 != v20) {
      goto LABEL_42;
    }
LABEL_29:
    long long v23 = (void *)*v23;
    if (!v23) {
      goto LABEL_42;
    }
  }
  if (v23[2] != 0x3070CB6B3C7F21D3) {
    goto LABEL_29;
  }
LABEL_40:
  uint64_t v26 = v23[5];
  if (*(void *)(v26 + 8) == 0x3070CB6B3C7F21D3)
  {
    uint64_t v246 = *(void *)(v26 + 32);
    goto LABEL_43;
  }
LABEL_42:
  uint64_t v246 = 0;
LABEL_43:
  if (v19.u32[0] > 1uLL)
  {
    unint64_t v27 = 0x99BED48DEFBBD82BLL;
    if (*(void *)&v18 <= 0x99BED48DEFBBD82BLL) {
      unint64_t v27 = 0x99BED48DEFBBD82BLL % *(void *)&v18;
    }
  }
  else
  {
    unint64_t v27 = (*(void *)&v18 - 1) & 0x99BED48DEFBBD82BLL;
  }
  unint64_t v28 = *(void **)(v21 + 8 * v27);
  if (!v28) {
    goto LABEL_66;
  }
  unint64_t v29 = (void *)*v28;
  if (!v29) {
    goto LABEL_66;
  }
  if (v19.u32[0] < 2uLL)
  {
    uint64_t v30 = *(void *)&v18 - 1;
    while (1)
    {
      uint64_t v32 = v29[1];
      if (v32 == 0x99BED48DEFBBD82BLL)
      {
        if (v29[2] == 0x99BED48DEFBBD82BLL) {
          goto LABEL_63;
        }
      }
      else if ((v32 & v30) != v27)
      {
        goto LABEL_66;
      }
      unint64_t v29 = (void *)*v29;
      if (!v29) {
        goto LABEL_66;
      }
    }
  }
  while (2)
  {
    unint64_t v31 = v29[1];
    if (v31 != 0x99BED48DEFBBD82BLL)
    {
      if (v31 >= *(void *)&v18) {
        v31 %= *(void *)&v18;
      }
      if (v31 != v27) {
        goto LABEL_66;
      }
      goto LABEL_52;
    }
    if (v29[2] != 0x99BED48DEFBBD82BLL)
    {
LABEL_52:
      unint64_t v29 = (void *)*v29;
      if (!v29) {
        goto LABEL_66;
      }
      continue;
    }
    break;
  }
LABEL_63:
  uint64_t v33 = v29[5];
  if (*(void *)(v33 + 8) == 0x99BED48DEFBBD82BLL)
  {
    uint64_t v242 = *(void *)(v33 + 32);
    if (!v246) {
      goto LABEL_226;
    }
    goto LABEL_67;
  }
LABEL_66:
  uint64_t v242 = 0;
  if (!v246)
  {
LABEL_226:
    (*(void (**)(void *))(v312[0] + 32))(v312);
    goto LABEL_227;
  }
LABEL_67:
  long long v34 = *(void **)v242;
  __int8 v35 = *(unsigned __int16 **)(*(void *)v242 + 184);
  uint64_t v36 = *(unsigned __int16 **)(*(void *)v242 + 192);
  if (v35 == v36)
  {
LABEL_76:
    size_t v39 = (unsigned __int16 *)v34[26];
    id v40 = (unsigned __int16 *)v34[27];
    if (v39 != v40)
    {
      uint64_t v42 = (unsigned __int16 *)v34[14];
      char v41 = (unsigned __int16 *)v34[15];
      do
      {
        uint64_t v45 = v42;
        if (v42 != v41)
        {
          uint64_t v45 = v42;
          while (*v45 != *v39)
          {
            v45 += 56;
            if (v45 == v41)
            {
              uint64_t v45 = v41;
              break;
            }
          }
        }
        int v43 = *((unsigned __int8 *)v45 + 8);
        ++v39;
        if (v43) {
          _ZF = v39 == v40;
        }
        else {
          _ZF = 1;
        }
      }
      while (!_ZF);
      if (!v43) {
        goto LABEL_90;
      }
    }
    int v46 = *((unsigned __int8 *)this + 48);
    int v47 = *((unsigned __int8 *)this + 49);
    *((unsigned char *)this + 360) = v46 != v47;
    if (v46 == v47) {
      goto LABEL_226;
    }
  }
  else
  {
    int64_t v37 = (unsigned __int16 *)v34[15];
    while (1)
    {
      long long v38 = (unsigned __int16 *)v34[14];
      if (v38 != v37)
      {
        long long v38 = (unsigned __int16 *)v34[14];
        while (*v38 != *v35)
        {
          v38 += 56;
          if (v38 == v37)
          {
            long long v38 = (unsigned __int16 *)v34[15];
            break;
          }
        }
      }
      if (!*((unsigned char *)v38 + 8)) {
        break;
      }
      if (++v35 == v36) {
        goto LABEL_76;
      }
    }
LABEL_90:
    *((unsigned char *)this + 360) = 1;
  }
  uint64_t v48 = (void *)*((void *)this + 44);
  unint64_t v49 = v48[14];
  unint64_t v247 = v48[15];
  uint64_t v50 = (uint64_t *)*((void *)this + 34);
  uint64_t v51 = (uint64_t *)*((void *)this + 35);
  if (v50 != v51)
  {
    do
    {
      uint64_t v52 = *v50;
      if (!v313
        || (*(void *)uint64_t v253 = *v50, (*(unsigned int (**)(void *, unsigned char *))(*v313 + 48))(v313, v253)))
      {
        uint64_t v53 = *(void *)(v52 + 384);
        uint64_t v54 = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::find<gdc::LayerDataRequestKey>((void *)(*(void *)v242 + 8), (unsigned __int8 *)(v53 + 16));
        if (v54)
        {
          unint64_t v55 = 0xAAAAAAAAAAAAAAABLL * (v54[17] - v54[16]);
          if (*(unsigned __int8 *)(v53 + 168) == 255) {
            v49 += v55;
          }
          else {
            v247 += v55;
          }
        }
      }
      ++v50;
    }
    while (v50 != v51);
    uint64_t v48 = (void *)*((void *)this + 44);
  }
  uint64_t v56 = v246 + 144;
  uint64_t v57 = 128;
  if (*(unsigned __int8 *)(v246 + 320) - 1 >= 3) {
    uint64_t v56 = v246 + 128;
  }
  else {
    uint64_t v57 = 144;
  }
  uint64_t v58 = *(void *)(v246 + v57);
  uint64_t v59 = *(std::__shared_weak_count **)(v56 + 8);
  uint64_t v285 = v58;
  uint64_t v286 = v59;
  if (v59) {
    atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v250 = v48;
  if (v49 > (uint64_t)(v48[8] - v48[7]) >> 3)
  {
    __asm { FMOV            V0.4S, #1.0 }
    operator new();
  }
  if (v247 > (uint64_t)(v48[11] - v48[10]) >> 3) {
    operator new();
  }
  uint64_t v64 = (void *)*((void *)v244 + 1);
  int8x8_t v65 = (int8x8_t)v64[1];
  if (!*(void *)&v65)
  {
    uint64_t v68 = 0;
    goto LABEL_135;
  }
  uint8x8_t v66 = (uint8x8_t)vcnt_s8(v65);
  v66.i16[0] = vaddlv_u8(v66);
  if (v66.u32[0] > 1uLL)
  {
    uint64_t v67 = 0x1AF456233693CD46;
    if (*(void *)&v65 <= 0x1AF456233693CD46uLL) {
      uint64_t v67 = 0x1AF456233693CD46uLL % *(void *)&v65;
    }
  }
  else
  {
    uint64_t v67 = (*(void *)&v65 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v69 = *(void **)(*v64 + 8 * v67);
  if (!v69) {
    goto LABEL_134;
  }
  uint64_t v70 = (void *)*v69;
  if (!v70) {
    goto LABEL_134;
  }
  if (v66.u32[0] < 2uLL)
  {
    uint64_t v71 = *(void *)&v65 - 1;
    while (1)
    {
      uint64_t v73 = v70[1];
      if (v73 == 0x1AF456233693CD46)
      {
        if (v70[2] == 0x1AF456233693CD46) {
          goto LABEL_132;
        }
      }
      else if ((v73 & v71) != v67)
      {
        goto LABEL_134;
      }
      uint64_t v70 = (void *)*v70;
      if (!v70) {
        goto LABEL_134;
      }
    }
  }
  while (2)
  {
    unint64_t v72 = v70[1];
    if (v72 != 0x1AF456233693CD46)
    {
      if (v72 >= *(void *)&v65) {
        v72 %= *(void *)&v65;
      }
      if (v72 != v67) {
        goto LABEL_134;
      }
      goto LABEL_121;
    }
    if (v70[2] != 0x1AF456233693CD46)
    {
LABEL_121:
      uint64_t v70 = (void *)*v70;
      if (!v70) {
        goto LABEL_134;
      }
      continue;
    }
    break;
  }
LABEL_132:
  uint64_t v74 = v70[5];
  if (*(void *)(v74 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v68 = *(void *)(v74 + 32);
    goto LABEL_135;
  }
LABEL_134:
  uint64_t v68 = 0;
LABEL_135:
  int v245 = *(unsigned __int8 *)(md::LayoutContext::frameState(v244) + 128);
  uint64_t v75 = (float64_t *)(v68 + 808);
  if (LOBYTE(v287.f64[0])) {
    uint64_t v75 = &v287.f64[1];
  }
  float64x2_t v76 = *(float64x2_t *)(v75 + 10);
  float64x2_t v281 = *(float64x2_t *)(v75 + 8);
  float64x2_t v282 = v76;
  float64x2_t v77 = *(float64x2_t *)(v75 + 14);
  float64x2_t v283 = *(float64x2_t *)(v75 + 12);
  float64x2_t v284 = v77;
  float64x2_t v78 = *(float64x2_t *)(v75 + 2);
  float64x2_t v277 = *(float64x2_t *)v75;
  float64x2_t v278 = v78;
  float64x2_t v79 = *(float64x2_t *)(v75 + 6);
  float64x2_t v279 = *(float64x2_t *)(v75 + 4);
  float64x2_t v280 = v79;
  unint64_t v80 = (void *)*((void *)this + 34);
  char v241 = (void *)*((void *)this + 35);
  if (v80 != v241)
  {
    while (1)
    {
      id v243 = v80;
      uint64_t v81 = *v80;
      if (!v313
        || (*(void *)uint64_t v253 = *v80, ((*(uint64_t (**)(void *, unsigned char *))(*v313 + 48))(v313, v253) & 1) != 0))
      {
        uint64_t v82 = *(void *)(v81 + 384);
        uint64_t v83 = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::find<gdc::LayerDataRequestKey>((void *)(*(void *)v242 + 8), (unsigned __int8 *)(v82 + 16));
        if (v83)
        {
          uint64_t v84 = v83[16];
          uint64_t v85 = v83[17];
          if (v85 != v84) {
            break;
          }
        }
      }
LABEL_139:
      unint64_t v80 = v243 + 1;
      if (v243 + 1 == v241) {
        goto LABEL_220;
      }
    }
    id v248 = (unsigned __int8 *)(v82 + 168);
    while (2)
    {
      uint64_t v86 = *(unsigned __int8 **)(v81 + 384);
      uint64_t v87 = (void *)*((void *)this + 44);
      if (v86[168] != 255)
      {
        uint64_t v88 = v87[15];
        uint64_t v89 = v48[10];
        uint64_t v90 = *(void *)(*(void *)(**(void **)(v89 + 8 * v88) + 64) + 32);
        *(_OWORD *)uint64_t v253 = 0uLL;
        uint64_t v91 = *(void *)(v90 + 8);
        if (v91) {
          os_signpost_id_t v92 = *(_DWORD **)(v90 + 72);
        }
        else {
          os_signpost_id_t v92 = 0;
        }
        *(void *)&long long v117 = 0;
        *((void *)&v117 + 1) = v90;
        *(_OWORD *)uint64_t v253 = v117;
        *(void *)&v253[16] = 0;
        *(void *)&v253[24] = v91;
        *(void *)&v253[40] = v92;
        *(_WORD *)&v253[32] = 1;
        unsigned int v118 = (_DWORD *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v86 + 32))(v86);
        v92[8] = *v118;
        v92[9] = v118[1];
        v92[10] = v118[2];
        __int16 v119 = (_DWORD *)(*(uint64_t (**)(void))(**(void **)(v81 + 384) + 32))(*(void *)(v81 + 384));
        v92[12] = v119[3];
        v92[13] = v119[4];
        v92[14] = v119[5];
        *(void *)(*(void *)(v89 + 8 * v88) + 32) = **((void **)v252 + 44);
        *(void *)(*(void *)(v89 + 8 * v88) + 40) = **(void **)(v89 + 8 * v88);
        uint64_t v120 = *(uint64_t **)(v89 + 8 * v88);
        v120[7] = 0;
        *((_DWORD *)v120 + 12) = v249 + *(unsigned __int8 *)(v82 + 169);
        uint64_t v121 = *v120;
        md::GeometryContext::transformConstantData((double *)v297, (uint64_t *)v246, v248, v245, 0.0, 0.0);
        uint64_t v122 = *(void *)(v121 + 64);
        long long v123 = *(_OWORD *)v297;
        *(void *)(v122 + 16) = *(void *)v297;
        *(void *)(v122 + 24) = 0;
        uint64_t v124 = *(void *)(v121 + 160);
        if (*((void *)&v123 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v123 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        __int16 v125 = *(std::__shared_weak_count **)(v124 + 24);
        *(_OWORD *)(v124 + 16) = v123;
        if (v125 && !atomic_fetch_add(&v125->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
          std::__shared_weak_count::__release_weak(v125);
          char v126 = *(std::__shared_weak_count **)&v297[8];
          if (*(void *)&v297[8]) {
            goto LABEL_165;
          }
        }
        else
        {
          char v126 = *(std::__shared_weak_count **)&v297[8];
          if (*(void *)&v297[8])
          {
LABEL_165:
            if (!atomic_fetch_add(&v126->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
              std::__shared_weak_count::__release_weak(v126);
            }
          }
        }
        float32x4_t v145 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v279), v280);
        float32x4_t v146 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v281), v282);
        float32x4_t v147 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v283), v284);
        uint64_t v148 = *(uint64_t **)(v89 + 8 * v88);
        uint64_t v150 = *v148;
        long long v149 = v148 + 1;
        long long v151 = **(void ***)(v150 + 64);
        unint64_t v152 = v151[1];
        unsigned int v153 = (float32x4_t *)v151[9];
        *unsigned int v153 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v277), v278);
        v153[1] = v145;
        v153[2] = v146;
        v153[3] = v147;
        if (v151[8] > v152) {
          unint64_t v152 = v151[8];
        }
        v151[7] = 0;
        v151[8] = v152;
        long long v154 = *(void **)(v15 + 80);
        unint64_t v155 = *(void *)(v15 + 88);
        if ((unint64_t)v154 < v155)
        {
          uint64_t v156 = v252;
          if (v154) {
            *long long v154 = v149;
          }
          unint64_t v157 = v154 + 1;
          goto LABEL_205;
        }
        uint64_t v158 = *(void *)(v15 + 72);
        uint64_t v159 = ((uint64_t)v154 - v158) >> 3;
        unint64_t v160 = v159 + 1;
        if ((unint64_t)(v159 + 1) >> 61) {
          abort();
        }
        uint64_t v161 = v155 - v158;
        if (v161 >> 2 > v160) {
          unint64_t v160 = v161 >> 2;
        }
        if ((unint64_t)v161 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v162 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v162 = v160;
        }
        if (v162)
        {
          uint64_t v163 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v15 + 96) + 16))(*(void *)(v15 + 96), 8 * v162, 8);
          long long v164 = (void *)(v163 + 8 * v159);
          uint64_t v165 = v163 + 8 * v162;
          if (v163) {
            *long long v164 = v149;
          }
        }
        else
        {
          uint64_t v165 = 0;
          long long v164 = (void *)(8 * v159);
        }
        uint64_t v156 = v252;
        uint64_t v167 = *(void *)(v15 + 72);
        uint64_t v166 = *(void *)(v15 + 80);
        uint64_t v168 = v166 - v167;
        if (v166 == v167)
        {
          BOOL v170 = v164;
          goto LABEL_203;
        }
        unint64_t v169 = v168 - 8;
        if ((unint64_t)(v168 - 8) < 0x38)
        {
          BOOL v170 = v164;
        }
        else
        {
          BOOL v170 = v164;
          if ((unint64_t)(v166 - (void)v164) >= 0x20)
          {
            uint64_t v171 = (v169 >> 3) + 1;
            uint64_t v172 = v164 - 2;
            long long v173 = (long long *)(v166 - 16);
            uint64_t v174 = v171 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v175 = *v173;
              *(v172 - 1) = *(v173 - 1);
              _OWORD *v172 = v175;
              v172 -= 2;
              v173 -= 2;
              v174 -= 4;
            }
            while (v174);
            BOOL v170 = &v164[-(v171 & 0x3FFFFFFFFFFFFFFCLL)];
            v166 -= 8 * (v171 & 0x3FFFFFFFFFFFFFFCLL);
            if (v171 == (v171 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_202:
              uint64_t v166 = *(void *)(v15 + 72);
LABEL_203:
              unint64_t v157 = v164 + 1;
              *(void *)(v15 + 72) = v170;
              *(void *)(v15 + 80) = v164 + 1;
              uint64_t v177 = *(void *)(v15 + 88);
              *(void *)(v15 + 88) = v165;
              if (v166) {
                (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v15 + 96) + 40))(*(void *)(v15 + 96), v166, v177 - v166);
              }
LABEL_205:
              *(void *)(v15 + 80) = v157;
              ++*(void *)(*((void *)v156 + 44) + 120);
              if (*(void *)&v253[40])
              {
                long long v178 = *(_OWORD *)&v253[16];
                if (*(void *)&v253[24] != *(void *)&v253[16])
                {
                  unint64_t v179 = *(void **)&v253[8];
                  int v180 = v253[32];
                  int v181 = v253[33];
                  if (*(void *)v253 && *(unsigned char *)(*(void *)&v253[8] + 17) != 2) {
                    (*(void (**)(void))(**(void **)v253 + 64))();
                  }
                  if (v180 && !v181)
                  {
                    unint64_t v182 = v179[7];
                    unint64_t v183 = v179[8];
                    if (v183 == v182) {
                      unint64_t v182 = v179[10] - v179[9];
                    }
                    if ((unint64_t)v178 < v182) {
                      unint64_t v182 = v178;
                    }
                    if (v183 <= *((void *)&v178 + 1)) {
                      unint64_t v183 = *((void *)&v178 + 1);
                    }
                    if (v183 == v182) {
                      unint64_t v183 = v182 + v179[10] - v179[9];
                    }
                    v179[7] = v182;
                    v179[8] = v183;
                  }
                }
              }
              uint64_t v48 = v250;
              this = v252;
LABEL_147:
              v84 += 3;
              if (v84 == v85) {
                goto LABEL_139;
              }
              continue;
            }
          }
        }
        do
        {
          uint64_t v176 = *(void *)(v166 - 8);
          v166 -= 8;
          *--BOOL v170 = v176;
        }
        while (v166 != v167);
        goto LABEL_202;
      }
      break;
    }
    uint64_t v93 = v87[14];
    uint64_t v94 = v48[7];
    *(void *)(*(void *)(v94 + 8 * v93) + 32) = *v87;
    *(void *)(*(void *)(v94 + 8 * v93) + 40) = **(void **)(v94 + 8 * v93);
    uint64_t v95 = *(uint64_t **)(v94 + 8 * v93);
    v95[7] = 0;
    *((_DWORD *)v95 + 12) = v249 + *(unsigned __int8 *)(v82 + 169);
    if ((v245 - 1) > 2u)
    {
      int v127 = 1 << *((unsigned char *)v84 + 1);
      double v128 = 1.0 / (double)v127;
      double v129 = v128 * (double)*((int *)v84 + 2);
      double v130 = v128 * (double)(v127 + ~*((_DWORD *)v84 + 1));
      memset(&v271[8], 0, 32);
      *(double *)v271 = v128;
      *(double *)&v271[40] = v128;
      long long v272 = 0u;
      long long v273 = 0u;
      long long v274 = *(unint64_t *)&v128;
      *(double *)&long long v275 = v129;
      *((double *)&v275 + 1) = v130;
      long long v276 = xmmword_1A28FCCC0;
      uint64_t v131 = *v95;
      uint64_t v132 = *(void *)(*v95 + 64);
      *(void *)(v132 + 24) = 0;
      uint64_t v133 = v87[1];
      *(void *)(v132 + 16) = v133;
      uint64_t v134 = *(void *)(v131 + 160);
      uint64_t v135 = v87[2];
      if (v135) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v135 + 8), 1uLL, memory_order_relaxed);
      }
      int v116 = *(std::__shared_weak_count **)(v134 + 24);
      *(void *)(v134 + 16) = v133;
      *(void *)(v134 + 24) = v135;
      if (!v116) {
        goto LABEL_172;
      }
    }
    else
    {
      int v96 = 1 << *(unsigned char *)(v82 + 169);
      double v97 = 1.0 / (double)v96;
      uint64_t v98 = *(int *)(v82 + 176);
      int v99 = v96 + ~*(_DWORD *)(v82 + 172);
      *(double *)uint64_t v253 = v97 * (double)v98;
      *(double *)&v253[8] = v97 * (double)v99;
      *(double *)&v253[16] = v97 + (double)v98 * v97;
      *(double *)&v253[24] = v97 + (double)v99 * v97;
      gdc::GlobeTileUtils::boundsFromMercatorRect((uint64_t)&v260, (double *)v253, 0.0, 0.0);
      v254.f64[1] = 0.0;
      memset(&v253[8], 0, 72);
      v256.f64[1] = 1.0;
      float64x2_t v255 = v266;
      v256.f64[0] = v267;
      *(double *)uint64_t v253 = v268 - v266.f64[0];
      *(double *)&v253[40] = v269 - v266.f64[1];
      v254.f64[0] = v270 - v267;
      double v100 = v263;
      double v101 = v264;
      double v102 = v100 + v100;
      double v103 = (v100 + v100) * v100;
      double v104 = (v101 + v101) * v101;
      double v105 = v262;
      double v106 = v105 + v105;
      double v107 = (v105 + v105) * v263;
      double v108 = (v101 + v101) * v265;
      double v109 = v264 * (v105 + v105);
      double v110 = 1.0 - (v105 + v105) * v105;
      *(double *)uint64_t v297 = 1.0 - (v103 + v104);
      *(double *)&v297[8] = v108 + v107;
      *((double *)&v298 + 1) = v107 - v108;
      *(double *)&long long v299 = v110 - v104;
      *((double *)&v300 + 1) = v265 * v102 + v109;
      double v301 = v102 * v264 - v265 * v106;
      *(double *)&v297[16] = v109 - v265 * v102;
      *((double *)&v299 + 1) = v265 * v106 + v102 * v264;
      double v302 = v110 - v103;
      *(void *)&long long v298 = 0;
      *(void *)&long long v300 = 0;
      uint64_t v303 = 0;
      long long v304 = v260;
      *(void *)&long long v305 = v261;
      *((void *)&v305 + 1) = 0x3FF0000000000000;
      gm::operator*<double,4,4,4>((double *)v259, (double *)v297, (double *)v253);
      *(_OWORD *)v271 = v259[0];
      *(_OWORD *)&v271[16] = v259[1];
      *(_OWORD *)&v271[32] = v259[2];
      long long v272 = v259[3];
      long long v273 = v259[4];
      long long v274 = v259[5];
      long long v275 = v259[6];
      long long v276 = v259[7];
      uint64_t v111 = **(void **)(v94 + 8 * v93);
      md::GeometryContext::transformConstantData((double *)v253, (uint64_t *)v246, v248, v245, 0.0, 0.0);
      uint64_t v112 = *(void *)(v111 + 64);
      long long v113 = *(_OWORD *)v253;
      *(void *)(v112 + 16) = *(void *)v253;
      *(void *)(v112 + 24) = 0;
      uint64_t v114 = *(void *)(v111 + 160);
      if (*((void *)&v113 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v113 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      __int16 v115 = *(std::__shared_weak_count **)(v114 + 24);
      *(_OWORD *)(v114 + 16) = v113;
      if (v115 && !atomic_fetch_add(&v115->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v115->__on_zero_shared)(v115);
        std::__shared_weak_count::__release_weak(v115);
      }
      int v116 = *(std::__shared_weak_count **)&v253[8];
      if (!*(void *)&v253[8]) {
        goto LABEL_172;
      }
    }
    if (!atomic_fetch_add(&v116->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v116->__on_zero_shared)(v116);
      std::__shared_weak_count::__release_weak(v116);
    }
LABEL_172:
    gm::operator*<double,4,4,4>((double *)v253, v277.f64, (double *)v271);
    float32x4_t v136 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v253[32]), *(float64x2_t *)&v253[48]);
    float32x4_t v137 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v253[64]), v254);
    float32x4_t v138 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v255), v256);
    uint64_t v139 = *(uint64_t **)(v94 + 8 * v93);
    uint64_t v141 = *v139;
    uint64_t v140 = (uint64_t)(v139 + 1);
    long long v142 = **(void ***)(v141 + 64);
    unint64_t v143 = v142[1];
    unint64_t v144 = (float32x4_t *)v142[9];
    float32x4_t *v144 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v253), *(float64x2_t *)&v253[16]);
    v144[1] = v136;
    v144[2] = v137;
    v144[3] = v138;
    if (v142[8] > v143) {
      unint64_t v143 = v142[8];
    }
    v142[7] = 0;
    v142[8] = v143;
    ggl::CommandBuffer::pushRenderItem(v15, v140);
    this = v252;
    ++*(void *)(*((void *)v252 + 44) + 112);
    goto LABEL_147;
  }
LABEL_220:
  uint64_t v184 = v286;
  if (v286 && !atomic_fetch_add(&v286->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
    std::__shared_weak_count::__release_weak(v184);
  }
  if (v313 == v312) {
    goto LABEL_226;
  }
  if (v313) {
    (*(void (**)(void))(*v313 + 40))();
  }
LABEL_227:
  *(void *)(v15 + 32) = *((void *)this + 46);
  uint64_t v185 = *((void *)v244 + 3);
  unsigned int v186 = *(unsigned __int8 *)(v185 + 1);
  unsigned int v187 = *(unsigned __int8 *)(v185 + 2);
  int v188 = *((unsigned __int8 *)this + 360);
  md::RibbonLayoutContext::RibbonLayoutContext((md::RibbonLayoutContext *)v253, v244);
  BOOL v189 = v188 == 0;
  float64x2_t v256 = 0uLL;
  memset_pattern16(&v257, &unk_1A28FFCB0, 0x10uLL);
  BOOL v190 = v186 < v187;
  v258[21] = 0;
  *(void *)size_t v258 = 0;
  *(void *)&v258[8] = 0;
  *(_DWORD *)&unsigned char v258[15] = 0;
  BOOL v191 = v186 < v187 && v189;
  if (*((unsigned char *)this + 360)) {
    BOOL v190 = 1;
  }
  v253[56] = v190;
  v258[16] = **((unsigned char **)v244 + 92);
  v258[17] = 1;
  v258[18] = v191;
  uint64_t v192 = *((void *)this + 34);
  uint64_t v251 = *((void *)this + 35);
  if (v192 != v251)
  {
    while (2)
    {
      uint64_t v193 = *(void *)(*(void *)v192 + 384);
      if (v193)
      {
        signed int v194 = (void *)*((void *)v244 + 1);
        unint64_t v195 = v194[1];
        if ((v195 & (v195 - 1)) != 0)
        {
          unint64_t v197 = 0x1AF456233693CD46;
          if (v195 <= 0x1AF456233693CD46) {
            unint64_t v197 = 0x1AF456233693CD46 % v195;
          }
          long long v196 = *(void **)(*v194 + 8 * v197);
          do
          {
            do
              long long v196 = (void *)*v196;
            while (v196[1] != 0x1AF456233693CD46);
          }
          while (v196[2] != 0x1AF456233693CD46);
        }
        else
        {
          long long v196 = *(void **)(*v194 + 8 * ((v195 - 1) & 0x1AF456233693CD46));
          do
          {
            do
              long long v196 = (void *)*v196;
            while (v196[1] != 0x1AF456233693CD46);
          }
          while (v196[2] != 0x1AF456233693CD46);
        }
        int v198 = *(double **)(v196[5] + 32);
        int v199 = 1 << *(unsigned char *)(v193 + 169);
        double v200 = 1.0 / (double)v199;
        double v201 = (double)(v199 + ~*(_DWORD *)(v193 + 172));
        double v202 = v200 * (double)*(int *)(v193 + 176);
        uint64_t v303 = 0;
        long long v300 = 0u;
        double v301 = 0.0;
        long long v298 = 0u;
        long long v299 = 0u;
        *(_OWORD *)&v297[8] = 0u;
        *(double *)uint64_t v297 = v200;
        *(double *)&long long v299 = v200;
        double v302 = v200;
        *(double *)&long long v304 = v202;
        *((double *)&v304 + 1) = v200 * v201;
        long long v305 = xmmword_1A28FCCC0;
        gm::operator*<double,4,4,4>(v287.f64, v198 + 101, (double *)v297);
        float32x2_t v203 = vcvt_f32_f64(v288);
        float32x2_t v204 = vcvt_f32_f64(v289);
        float32x2_t v205 = vcvt_f32_f64(v290);
        float32x2_t v206 = vcvt_f32_f64(v291);
        float32x2_t v207 = vcvt_f32_f64(v292);
        float32x2_t v208 = vcvt_f32_f64(v293);
        float32x2_t v209 = vcvt_f32_f64(v294);
        __int16 v210 = *(void **)(v193 + 720);
        unint64_t v211 = v210[1];
        unint64_t v212 = (float32x2_t *)v210[9];
        float32x2_t *v212 = vcvt_f32_f64(v287);
        v212[1] = v203;
        v212[2] = v204;
        v212[3] = v205;
        v212[4] = v206;
        v212[5] = v207;
        v212[6] = v208;
        v212[7] = v209;
        float32_t v213 = v198[471] * v198[173] / (v198[171] * v200);
        v212[8].f32[0] = v213;
        if (v210[8] > v211) {
          unint64_t v211 = v210[8];
        }
        v210[7] = 0;
        v210[8] = v211;
        unint64_t v214 = v194[1];
        if ((v214 & (v214 - 1)) != 0)
        {
          unint64_t v216 = 0xE42D19AFCA302E68;
          if (v214 <= 0xE42D19AFCA302E68) {
            unint64_t v216 = 0xE42D19AFCA302E68 % v214;
          }
          uint64_t v215 = *(void **)(*v194 + 8 * v216);
          do
          {
            do
              uint64_t v215 = (void *)*v215;
            while (v215[1] != 0xE42D19AFCA302E68);
          }
          while (v215[2] != 0xE42D19AFCA302E68);
        }
        else
        {
          uint64_t v215 = *(void **)(*v194 + 8 * ((v214 - 1) & 0xE42D19AFCA302E68));
          do
          {
            do
              uint64_t v215 = (void *)*v215;
            while (v215[1] != 0xE42D19AFCA302E68);
          }
          while (v215[2] != 0xE42D19AFCA302E68);
        }
        uint64_t v217 = **(void **)(v215[5] + 32);
        *(float64_t *)((char *)v287.f64 + 7) = 0.0;
        v287.f64[0] = 0.0;
        HIBYTE(v287.f64[1]) = 1;
        gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)v297, v217, (gss::FeatureAttributeSet *)(v193 + 752), (gss::QueryOverrides *)&v287);
        uint64_t v218 = +[VKDebugSettings sharedSettings];
        int v219 = [v218 loadGreenTraffic];

        long long v220 = *(_OWORD *)v297;
        *(_OWORD *)v271 = *(_OWORD *)v297;
        if (*(void *)&v297[8])
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v297[8] + 8), 1uLL, memory_order_relaxed);
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v220 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        md::TrafficMeshStyle::setup((int *)&v277, v220, *((std::__shared_weak_count **)&v220 + 1), v219);
        if (*((void *)&v220 + 1)
          && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v220 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(void))(**((void **)&v220 + 1) + 16))(*((void *)&v220 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v220 + 1));
          unint64_t v221 = *(std::__shared_weak_count **)&v271[8];
          if (*(void *)&v271[8]) {
            goto LABEL_263;
          }
        }
        else
        {
          unint64_t v221 = *(std::__shared_weak_count **)&v271[8];
          if (*(void *)&v271[8])
          {
LABEL_263:
            if (!atomic_fetch_add(&v221->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v221->__on_zero_shared)(v221);
              std::__shared_weak_count::__release_weak(v221);
            }
          }
        }
        float64x2_t v291 = *(float64x2_t *)&v253[64];
        float64x2_t v292 = v254;
        float64x2_t v293 = v255;
        float64x2_t v287 = *(float64x2_t *)v253;
        float64x2_t v288 = *(float64x2_t *)&v253[16];
        float64x2_t v289 = *(float64x2_t *)&v253[32];
        float64x2_t v290 = *(float64x2_t *)&v253[48];
        char v222 = *(std::__shared_weak_count **)&v256.f64[1];
        if (*(void *)&v256.f64[1]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v256.f64[1] + 8), 1uLL, memory_order_relaxed);
        }
        float64x2_t v295 = v257;
        *(_OWORD *)v296 = *(_OWORD *)v258;
        *(void *)&v296[14] = *(void *)&v258[14];
        float64x2_t v223 = *(float64x2_t *)v297;
        if (*(void *)&v297[8]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v297[8] + 8), 1uLL, memory_order_relaxed);
        }
        float64x2_t v294 = v223;
        if (v222 && !atomic_fetch_add(&v222->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v222->__on_zero_shared)(v222);
          std::__shared_weak_count::__release_weak(v222);
        }
        float64x2_t v295 = v277;
        char v224 = v253[56];
        if (v253[56])
        {
          if (v258[18]) {
            char v224 = *(unsigned char *)(*((void *)v244 + 3) + 1);
          }
          else {
            char v224 = *(unsigned char *)(v193 + 169) + *((unsigned char *)v252 + 364);
          }
        }
        BYTE1(v290.f64[1]) = v224;
        uint64_t v225 = *(void *)(v193 + 736);
        if (v225)
        {
          uint64_t v226 = *(void *)(v225 + 152);
          uint64_t v227 = *((void *)v252 + 47);
          if (!v226 || v226 != v227) {
            md::PilledTrafficLayer::setSharedResources(*(void **)(v193 + 736), v227);
          }
          md::PilledTrafficLayer::layout((md::PilledTrafficLayer *)v225, (const md::TrafficContext *)&v287);
          md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(*(uint64_t **)(v225 + 8), *(uint64_t **)(v225 + 16), v15, v228);
        }
        uint64_t v229 = *(void *)(v193 + 744);
        if (v229)
        {
          uint64_t v230 = *(const md::TrafficSharedResources **)(v229 + 160);
          unsigned __int8 v231 = (const md::TrafficSharedResources *)*((void *)v252 + 47);
          if (!v230 || v230 != v231) {
            md::SolidTrafficLayer::setSharedResources(*(md::SolidTrafficLayer **)(v193 + 744), v231);
          }
          md::SolidTrafficLayer::layout((md::SolidTrafficLayer *)v229, (const md::TrafficContext *)&v287);
          md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(*(void **)(v229 + 8), *(void **)(v229 + 16), v15, v232);
        }
        float64_t v233 = v294.f64[1];
        if (*(void *)&v294.f64[1]
          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v294.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(float64_t))(**(void **)&v233 + 16))(COERCE_FLOAT64_T(*(void *)&v233));
          std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v233);
          size_t v234 = *(std::__shared_weak_count **)&v297[8];
          if (*(void *)&v297[8]) {
            goto LABEL_290;
          }
        }
        else
        {
          size_t v234 = *(std::__shared_weak_count **)&v297[8];
          if (*(void *)&v297[8])
          {
LABEL_290:
            if (!atomic_fetch_add(&v234->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v234->__on_zero_shared)(v234);
              std::__shared_weak_count::__release_weak(v234);
            }
          }
        }
      }
      v192 += 8;
      if (v192 == v251) {
        break;
      }
      continue;
    }
  }
  unint64_t v235 = *(void *)(v15 + 72);
  v236 = *(uint64_t **)(v15 + 80);
  unint64_t v237 = 126 - 2 * __clz((uint64_t)((uint64_t)v236 - v235) >> 3);
  if (v236 == (uint64_t *)v235) {
    uint64_t v238 = 0;
  }
  else {
    uint64_t v238 = v237;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v235, v236, v238, 1);
  float64_t v239 = v256.f64[1];
  if (*(void *)&v256.f64[1]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v256.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(float64_t))(**(void **)&v239 + 16))(COERCE_FLOAT64_T(*(void *)&v239));
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v239);
  }
  if (!v311)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  (*(void (**)(void *))(*v311 + 48))(v311);
  __n128 result = v311;
  if (v311 == v310) {
    return (void *)(*(uint64_t (**)(void *))(v310[0] + 32))(v310);
  }
  if (v311) {
    return (void *)(*(uint64_t (**)(void))(*v311 + 40))();
  }
  return result;
}

void sub_1A2114EF8(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&STACK[0x370]);
  std::function<BOOL ()(md::MapTileDataRenderable<md::TrafficTileData> const*)>::~function((void *)(v1 - 152));
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v1 - 184));
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  unsigned __int8 v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)unsigned int v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "LegacyTrafficLayout", "", v5, 2u);
  }
}

void std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  unsigned __int8 v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)unsigned int v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "LegacyTrafficLayout", "", v5, 2u);
  }
}

uint64_t std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF576CF8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF576CF8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF576CB0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF576CB0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::LegacyTrafficRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::LegacyTrafficRenderLayer::~LegacyTrafficRenderLayer(md::LegacyTrafficRenderLayer *this)
{
  md::CartographicTiledVectorRenderLayer<md::MapTileDataRenderable<md::TrafficTileData>>::~CartographicTiledVectorRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

uint64_t non-virtual thunk to'md::RouteLineLayerDataSource::onOverlayRemoved(uint64_t result)
{
  uint64_t v1 = *(void *)(result - 568);
  for (uint64_t i = *(void *)(v1 + 8); i != v1; uint64_t i = *(void *)(i + 8))
    *(void *)(*(void *)(i + 128) + 152) = 1;
  return result;
}

uint64_t md::RouteLineLayerDataSource::onOverlayRemoved(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  for (uint64_t i = *(void *)(v1 + 8); i != v1; uint64_t i = *(void *)(i + 8))
    *(void *)(*(void *)(i + 128) + 152) = 1;
  return result;
}

uint64_t md::RouteLineLayerDataSource::onOverlayAdded(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 16);
  for (uint64_t i = *(void *)(v1 + 8); i != v1; uint64_t i = *(void *)(i + 8))
    *(void *)(*(void *)(i + 128) + 152) = 1;
  return result;
}

void md::RouteLineLayerDataSource::createLayerData(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t *a3@<X2>, void *a4@<X8>)
{
  v96[2] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v7 = *(int **)(a2 + 16);
  char v8 = *((unsigned char *)v7 + 8);
  int v9 = v7[1];
  int v10 = *v7;
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  uint64_t v88 = &v89;
  uint64_t v11 = *(void *)(a1 + 592);
  std::mutex::lock((std::mutex *)(v11 + 96));
  uint64_t v93 = 0;
  uint64_t v94 = 0;
  os_signpost_id_t v92 = &v93;
  std::set<objc_object  {objcproto14VKRouteOverlay}*>::insert[abi:nn180100]<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(&v92, *(void **)(v11 + 24), (void *)(v11 + 32));
  std::mutex::unlock((std::mutex *)(v11 + 96));
  uint64_t v12 = *(void *)(a1 + 592);
  std::mutex::lock((std::mutex *)(v12 + 96));
  uint64_t v81 = a3;
  uint64_t v82 = a2;
  v96[0] = 0;
  v96[1] = 0;
  uint64_t v95 = v96;
  std::set<objc_object  {objcproto14VKRouteOverlay}*>::insert[abi:nn180100]<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(&v95, *(void **)(v12 + 48), (void *)(v12 + 56));
  double v13 = 1.0 / (double)(1 << v8);
  double v84 = v13 * (double)((1 << v8) + ~v9);
  double v85 = v13 * (double)v10;
  double v86 = v85 + v13;
  double v83 = v84 + v13;
  std::mutex::unlock((std::mutex *)(v12 + 96));
  char v14 = 0;
  uint64_t v15 = 0;
  double v16 = 0.5;
  do
  {
    char v17 = v14;
    int8x8_t v18 = &(&v92)[3 * v15];
    uint64_t v21 = (void *)*v18;
    uint8x8_t v19 = v18 + 1;
    uint64_t v20 = v21;
    if (v21 != v19)
    {
      do
      {
        id v22 = (id)v20[4];
        id v23 = [v22 boundingMapRegion];
        [v23 northLat];
        double v25 = v24;
        [v23 westLng];
        double v27 = v26;
        [v23 southLat];
        double v29 = v28;
        [v23 eastLng];
        double v31 = v30;

        if (v86 > v16 + v27 * 0.00277777778)
        {
          long double v32 = tan(v25 * 0.00872664626 + 0.785398163);
          double v33 = log(v32) * 0.159154943 + 0.5;
          long double v34 = tan(v29 * 0.00872664626 + 0.785398163);
          double v35 = log(v34) * 0.159154943 + 0.5;
          double v16 = 0.5;
          BOOL v36 = v85 >= v31 * 0.00277777778 + 0.5 || v83 <= v35;
          if (!v36 && v84 < v33)
          {
            long long v38 = v89;
            size_t v39 = &v89;
            id v40 = &v89;
            if (v89)
            {
              while (1)
              {
                while (1)
                {
                  id v40 = (void **)v38;
                  unint64_t v41 = v38[4];
                  if ((unint64_t)v22 >= v41) {
                    break;
                  }
                  long long v38 = *v40;
                  size_t v39 = v40;
                  if (!*v40) {
                    goto LABEL_22;
                  }
                }
                if (v41 >= (unint64_t)v22) {
                  break;
                }
                long long v38 = v40[1];
                if (!v38)
                {
                  size_t v39 = v40 + 1;
                  goto LABEL_22;
                }
              }
            }
            else
            {
LABEL_22:
              uint64_t v42 = operator new(0x28uLL);
              unsigned __int8 v42[4] = v22;
              void *v42 = 0;
              v42[1] = 0;
              v42[2] = v40;
              *size_t v39 = v42;
              if (*v88)
              {
                uint64_t v88 = (void *)*v88;
                uint64_t v42 = (void *)*v39;
              }
              int v43 = v89;
              BOOL v44 = v42 == v89;
              *((unsigned char *)v42 + 24) = v42 == v89;
              if (!v44)
              {
                do
                {
                  uint64_t v45 = v42[2];
                  if (*(unsigned char *)(v45 + 24)) {
                    break;
                  }
                  int v46 = *(void **)(v45 + 16);
                  uint64_t v47 = *v46;
                  if (*v46 == v45)
                  {
                    uint64_t v50 = v46[1];
                    if (!v50 || (v51 = *(unsigned __int8 *)(v50 + 24), uint64_t v48 = (unsigned char *)(v50 + 24), v51))
                    {
                      if (*(void **)v45 == v42)
                      {
                        uint64_t v52 = (uint64_t *)v42[2];
                      }
                      else
                      {
                        uint64_t v52 = *(uint64_t **)(v45 + 8);
                        uint64_t v53 = *v52;
                        *(void *)(v45 + 8) = *v52;
                        if (v53)
                        {
                          *(void *)(v53 + 16) = v45;
                          int v46 = *(void **)(v45 + 16);
                        }
                        v52[2] = (uint64_t)v46;
                        *(void *)(*(void *)(v45 + 16) + 8 * (**(void **)(v45 + 16) != v45)) = v52;
                        *uint64_t v52 = v45;
                        *(void *)(v45 + 16) = v52;
                        int v46 = (void *)v52[2];
                        uint64_t v45 = *v46;
                      }
                      *((unsigned char *)v52 + 24) = 1;
                      *((unsigned char *)v46 + 24) = 0;
                      uint64_t v56 = *(void *)(v45 + 8);
                      *int v46 = v56;
                      if (v56) {
                        *(void *)(v56 + 16) = v46;
                      }
                      *(void *)(v45 + 16) = v46[2];
                      *(void *)(v46[2] + 8 * (*(void *)v46[2] != (void)v46)) = v45;
                      *(void *)(v45 + 8) = v46;
                      goto LABEL_51;
                    }
                  }
                  else if (!v47 || (int v49 = *(unsigned __int8 *)(v47 + 24), v48 = (unsigned char *)(v47 + 24), v49))
                  {
                    if (*(void **)v45 == v42)
                    {
                      uint64_t v54 = v42[1];
                      *(void *)uint64_t v45 = v54;
                      if (v54)
                      {
                        *(void *)(v54 + 16) = v45;
                        int v46 = *(void **)(v45 + 16);
                      }
                      v42[2] = v46;
                      *(void *)(*(void *)(v45 + 16) + 8 * (**(void **)(v45 + 16) != v45)) = v42;
                      v42[1] = v45;
                      *(void *)(v45 + 16) = v42;
                      int v46 = (void *)v42[2];
                    }
                    else
                    {
                      uint64_t v42 = (void *)v42[2];
                    }
                    *((unsigned char *)v42 + 24) = 1;
                    *((unsigned char *)v46 + 24) = 0;
                    uint64_t v45 = v46[1];
                    unint64_t v55 = *(void **)v45;
                    v46[1] = *(void *)v45;
                    if (v55) {
                      v55[2] = v46;
                    }
                    *(void *)(v45 + 16) = v46[2];
                    *(void *)(v46[2] + 8 * (*(void *)v46[2] != (void)v46)) = v45;
                    *(void *)uint64_t v45 = v46;
LABEL_51:
                    v46[2] = v45;
                    break;
                  }
                  *(unsigned char *)(v45 + 24) = 1;
                  uint64_t v42 = v46;
                  *((unsigned char *)v46 + 24) = v46 == v43;
                  unsigned char *v48 = 1;
                }
                while (v46 != v43);
              }
              ++v90;
            }
          }
        }

        uint64_t v57 = (void *)v20[1];
        if (v57)
        {
          do
          {
            uint64_t v58 = v57;
            uint64_t v57 = (void *)*v57;
          }
          while (v57);
        }
        else
        {
          do
          {
            uint64_t v58 = (void *)v20[2];
            BOOL v44 = *v58 == (void)v20;
            uint64_t v20 = v58;
          }
          while (!v44);
        }
        uint64_t v20 = v58;
      }
      while (v58 != v19);
    }
    char v14 = 1;
    uint64_t v15 = 1;
  }
  while ((v17 & 1) == 0);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v96[0]);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v93);
  uint64_t v59 = *v81;
  uint64_t v60 = v81[1];
  if (*(_WORD *)(*(void *)(v82 + 16) + 16) == 10)
  {
    if (v59 != v60)
    {
      while (*(_WORD *)v59 != 10)
      {
        v59 += 48;
        if (v59 == v60) {
          goto LABEL_75;
        }
      }
    }
  }
  else if (v59 != v60)
  {
    while (*(_WORD *)v59 != 9)
    {
      v59 += 48;
      if (v59 == v60) {
        goto LABEL_75;
      }
    }
  }
  if (v59 == v60 || *(void *)(v59 + 32) != 1)
  {
LABEL_75:
    unint64_t v63 = 0;
    uint8x8_t v66 = 0;
    uint64_t v65 = 0;
    char v64 = 1;
    goto LABEL_76;
  }
  uint64_t v61 = *(void *)(v59 + 24);
  uint64_t v62 = *(void *)(v61 + 112);
  unint64_t v63 = *(std::__shared_weak_count **)(v61 + 120);
  if (v63)
  {
    atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
    atomic_fetch_add_explicit(&v63->__shared_owners_, 1uLL, memory_order_relaxed);
    if (atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      char v64 = 0;
      if (v62) {
        goto LABEL_73;
      }
LABEL_105:
      uint8x8_t v66 = 0;
      uint64_t v65 = 0;
      goto LABEL_76;
    }
    ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
    std::__shared_weak_count::__release_weak(v63);
    char v64 = 0;
    if (!v62) {
      goto LABEL_105;
    }
  }
  else
  {
    char v64 = 1;
    if (!v62) {
      goto LABEL_105;
    }
  }
LABEL_73:
  uint64_t v65 = *(void *)(v62 + 144);
  uint8x8_t v66 = *(std::__shared_weak_count **)(v62 + 152);
  if (!v66)
  {
LABEL_76:
    char v67 = 1;
    goto LABEL_77;
  }
  char v67 = 0;
  atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_77:
  uint64_t v87 = v65;
  if ((v67 & 1) == 0 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
    std::__shared_weak_count::__release_weak(v66);
  }
  if ((v64 & 1) == 0 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
    std::__shared_weak_count::__release_weak(v63);
  }
  uint64_t v68 = (char *)operator new(0x328uLL);
  *((void *)v68 + 1) = 0;
  *((void *)v68 + 2) = 0;
  *(void *)uint64_t v68 = &unk_1EF57FB88;
  os_signpost_id_t v92 = 0;
  uint64_t v93 = 0;
  uint64_t v94 = 0;
  v91[0] = 0;
  v91[1] = 0;
  md::MapTileData::MapTileData((uint64_t)(v68 + 24), v82, (uint64_t)&v92, v91, 1);
  uint64_t v69 = v89;
  uint64_t v70 = v90;
  *((void *)v68 + 3) = &unk_1EF532E10;
  *((void *)v68 + 82) = &unk_1EF532E50;
  *((void *)v68 + 93) = v88;
  uint64_t v71 = v68 + 752;
  *((void *)v68 + 94) = v69;
  *((void *)v68 + 95) = v70;
  if (v70)
  {
    v69[2] = v71;
    uint64_t v89 = 0;
    uint64_t v90 = 0;
  }
  else
  {
    *((void *)v68 + 93) = v71;
  }
  *((void *)v68 + 98) = 0;
  *((_OWORD *)v68 + 48) = 0u;
  *((void *)v68 + 99) = v87;
  *((void *)v68 + 100) = v66;
  if (v66) {
    atomic_fetch_add_explicit(&v66->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  unint64_t v72 = (void *)*((void *)v68 + 93);
  if (v72 != v71)
  {
    do
    {
      id v73 = (id)v72[4];
      uint64_t v74 = v73;
      uint64_t v75 = (void *)*((void *)v68 + 97);
      if ((unint64_t)v75 >= *((void *)v68 + 98))
      {
        float64x2_t v77 = std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__emplace_back_slow_path<objc_object  {objcproto14VKRouteOverlay}*&,geo::memory_management_mode const&>((void **)v68 + 96, v73);
      }
      else
      {
        id v76 = v73;
        *uint64_t v75 = &unk_1EF559F98;
        v75[1] = v76;
        float64x2_t v77 = (char *)(v75 + 3);
      }
      *((void *)v68 + 97) = v77;

      float64x2_t v78 = (void *)v72[1];
      if (v78)
      {
        do
        {
          float64x2_t v79 = v78;
          float64x2_t v78 = (void *)*v78;
        }
        while (v78);
      }
      else
      {
        do
        {
          float64x2_t v79 = (void *)v72[2];
          BOOL v44 = *v79 == (void)v72;
          unint64_t v72 = v79;
        }
        while (!v44);
      }
      unint64_t v72 = v79;
    }
    while (v79 != v71);
  }
  *a4 = v68 + 24;
  a4[1] = v68;
  if (v66 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
    std::__shared_weak_count::__release_weak(v66);
  }
  std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy(v89);
}

void sub_1A2115D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31)
{
  std::__shared_weak_count::~__shared_weak_count(v31);
  operator delete(v33);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a20);
  std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy(a23);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_emplace<md::RouteLineData>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::RouteLineData>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FB88;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RouteLineData>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FB88;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::RouteLineLayerDataSource::fallbackSettings(md::RouteLineLayerDataSource *this)
{
  return 65537;
}

void md::RouteLineLayerDataSource::constructRequests(uint64_t a1, void **a2, void **a3)
{
  if (*(void *)(a1 + 24)) {
    BOOL v3 = a2 == a3;
  }
  else {
    BOOL v3 = 1;
  }
  if (!v3)
  {
    for (uint64_t i = a2; i != a3; i += 2)
    {
      uint64_t v6 = (int32x2_t *)(*i)[2];
      unsigned int v7 = v6[1].u8[0];
      int32x2_t v8 = *v6;
      __int32 v9 = v6[1].i32[1];
      __int32 v10 = v6[2].i32[0];
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 24) + 32))(&v42);
      unint64_t v11 = HIDWORD(v42);
      uint64_t v12 = *(void *)(a1 + 24);
      (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)v12 + 24))(&v48, v12, (unsigned __int16)v10);
      if (v11)
      {
        if (v11 <= 0x1FF)
        {
          int v13 = 0;
          unint64_t v14 = v11;
          do
          {
            ++v13;
            unint64_t v11 = 2 * v14;
            BOOL v15 = v14 >= 0x100;
            v14 *= 2;
          }
          while (!v15);
          if (v11 < 0x201) {
            goto LABEL_19;
          }
LABEL_17:
          for (unint64_t j = 512; j < v11; j *= 2)
            --v13;
          goto LABEL_19;
        }
        int v13 = 0;
        if (v11 >= 0x201) {
          goto LABEL_17;
        }
      }
      else
      {
        int v13 = 0;
      }
LABEL_19:
      if ((_BYTE)v48)
      {
        int v17 = v13 + v7;
        if (SHIDWORD(v48) > v17) {
          int v17 = HIDWORD(v48);
        }
        if (v49 < v17) {
          int v17 = v49;
        }
        int v18 = v7 - v17;
        if (v18 >= 0)
        {
          int32x2_t v19 = vrev64_s32(v8);
          if (v7)
          {
            unsigned int v20 = v7 >= v18 ? v18 : v7;
            char v21 = v7 - v20;
            int32x2_t v19 = vshl_s32(v19, vneg_s32(vdup_n_s32(v20)));
          }
          else
          {
            char v21 = 0;
          }
          v33[0] = 1;
          LOBYTE(v36) = v9;
          BYTE1(v36) = v21;
          *(int32x2_t *)((char *)&v36 + 4) = v19;
          (*(void (**)(uint64_t *__return_ptr, uint64_t, void, long long *))(*(void *)v12 + 16))(&v43, v12, (unsigned __int16)v10, &v36);
          if ((_BYTE)v43)
          {
            id v22 = *i;
            if (*((unsigned char *)*i + 96)) {
              int v23 = *((_DWORD *)v22 + 25);
            }
            else {
              int v23 = 2147483646;
            }
            uint64_t v24 = *((void *)v22 + 14);
            int v31 = v46;
            int v25 = v45;
            int v26 = v44;
            v33[0] = *v22;
            __int16 v34 = v10;
            int v35 = v23;
            *(void *)&long long v36 = v39;
            *((void *)&v36 + 1) = v39;
            int64_t v37 = v39;
            uint64_t v38 = 32;
            unint64_t v40 = 0;
            LODWORD(v48) = v47;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)&v36, v39, (char *)&v48, (char *)&v48 + 4);
            LODWORD(v48) = v31;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)&v36, *((char **)&v36 + 1), (char *)&v48, (char *)&v48 + 4);
            LODWORD(v48) = v25;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)&v36, *((char **)&v36 + 1), (char *)&v48, (char *)&v48 + 4);
            LODWORD(v48) = v26;
            geo::small_vector_base<unsigned char>::insert<unsigned char *>((void **)&v36, *((char **)&v36 + 1), (char *)&v48, (char *)&v48 + 4);
            double v27 = (unsigned __int8 *)v36;
            unint64_t v28 = *((void *)&v36 + 1) - v36;
            if (*((void *)&v36 + 1) == (void)v36)
            {
              unint64_t v29 = 0;
            }
            else
            {
              unint64_t v29 = 0;
              if (v28 <= 1) {
                unint64_t v28 = 1;
              }
              do
              {
                unsigned int v30 = *v27++;
                v29 ^= (v29 << 6) + (v29 >> 2) - 0x61C8864680B583EBLL + v30;
                --v28;
              }
              while (v28);
            }
            unint64_t v40 = v29;
            uint64_t v41 = v24;
            gdc::LayerDataRequest::request(*i, (uint64_t)v33, 0);
            if ((char *)v36 != v37) {
              free((void *)v36);
            }
          }
        }
      }
    }
  }
}

void md::RouteLineLayerDataSource::createDebugNode(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  gdc::LayerDataSource::createDebugNode((void *)a1, a2);
  v7[23] = 15;
  strcpy(v7, "IsTransitActive");
  uint64_t v4 = *(unsigned __int8 *)(a1 + 600);
  int v6 = 0;
  memset(&v5[4], 0, 24);
  v5[0] = v4;
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v7, (uint64_t)v5);
}

void *md::RouteLineLayerDataSource::addFallbackData(md::RouteLineLayerDataSource *this, const gdc::SelectionContext *a2)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  BOOL v3 = (unint64_t *)*((void *)a2 + 1);
  uint64_t v4 = 9;
  if (*((unsigned char *)this + 600)) {
    uint64_t v4 = 10;
  }
  v72[0] = &unk_1EF56B9B0;
  v72[1] = md::RouteLineData::mapDataKeyFromTile;
  v72[2] = v4;
  id v73 = v72;
  char v67 = 0;
  uint64_t v68 = 0;
  uint64_t v69 = 0;
  uint64_t v44 = (uint64_t)v3;
  gdc::LayerDataCollector::missingData((gdc::LayerDataCollector *)&v52, v3, *((unsigned __int16 *)this + 16));
  int v5 = v52;
  unsigned int v7 = v53;
  int v6 = (char *)v54;
  uint64_t v8 = v55;
  int v47 = (unsigned __int16)v56;
  __int32 v9 = (char *)this + 608;
  int v46 = v57;
  uint64_t v45 = v58;
LABEL_5:
  while (v5 != v47 || v7 != v46 || v8 != v45)
  {
    char v48 = v7[113];
    uint64_t v10 = *(void *)(v7 + 116);
    char v11 = v7[112];
    uint64_t v12 = (_DWORD *)*((void *)v7 + 2);
    int v13 = v12[2];
    int v14 = v12[3];
    unsigned int v15 = v13;
    LODWORD(v12) = *v12;
    int v16 = 1 << v13;
    int v17 = (*(_DWORD *)(*((void *)v7 + 2) + 4) % v16 + v16) % v16;
    v64[0] = v14;
    v64[1] = v13;
    int v18 = ((int)v12 % v16 + v16) % v16;
    int v65 = v17;
    int v66 = v18;
    if (v15 <= 0x1E
      && ((int v19 = vcvtmd_s64_f64((double)v18 / (double)v16), v19 >= 0) ? (v20 = v19) : (v20 = -v19), v20 <= 0x7F))
    {
      v22.i64[0] = ((v18 + v16) % v16) | ((unint64_t)((v18 + v16) % v16) << 16);
      v22.i64[1] = ((v17 + v16) % v16) | ((unint64_t)((v17 + v16) % v16) << 16);
      v23.i64[0] = 0xFFFF0000FFFFLL;
      v23.i64[1] = 0xFFFF0000FFFFLL;
      int64x2_t v24 = (int64x2_t)vandq_s8(v22, v23);
      unsigned long long v25 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64(v24, 8uLL), (int8x16_t)v24) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
      unsigned long long v26 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v25, 4uLL), (int8x16_t)v25) & __PAIR128__(0xFF0FFF0FFF0FFF0FLL, 0xFF0FFF0FFF0FFF0FLL);
      v23.i64[0] = 0x3333333333333333;
      v23.i64[1] = 0x3333333333333333;
      int8x16_t v27 = vandq_s8(vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v26, 2uLL), (int8x16_t)v26), v23);
      int8x16_t v28 = (int8x16_t)vshlq_u64((uint64x2_t)v27, (uint64x2_t)xmmword_1A28FC6E0);
      v27.i64[1] *= 2;
      int64x2_t v29 = (int64x2_t)vandq_s8(vorrq_s8(v28, v27), (int8x16_t)xmmword_1A28FC6F0);
      unint64_t v21 = vorrq_s8((int8x16_t)v29, (int8x16_t)vdupq_laneq_s64(v29, 1)).u64[0];
    }
    else
    {
      LOBYTE(v19) = 0;
      LOBYTE(v15) = 0;
      unint64_t v21 = 0;
    }
    if (!*v9) {
      unsigned char *v9 = 1;
    }
    *((void *)this + 77) = v21;
    *((unsigned char *)this + 624) = v15;
    *((unsigned char *)this + 625) = v19;
    __int16 v30 = *((_WORD *)this + 16);
    int v31 = (const gdc::LayerDataRequestKey *)*((void *)this + 2);
    uint64_t v32 = (uint64_t)v73;
    if (v73)
    {
      if (v73 == v72)
      {
        uint64_t v71 = v70;
        (*(void (**)(void *, void *))(v72[0] + 24))(v72, v70);
        goto LABEL_22;
      }
      uint64_t v32 = (*(uint64_t (**)(void))(*v73 + 16))();
    }
    uint64_t v71 = (void *)v32;
LABEL_22:
    md::TileAdjustmentHelpers::getFallbackDataForTile((int64x2_t *)((char *)this + 712), v30, v64, v31, (uint64_t)v70, (uint64_t)this + 608);
    if (v71 == v70)
    {
      (*(void (**)(void *))(v70[0] + 32))(v70);
    }
    else if (v71)
    {
      (*(void (**)(void))(*v71 + 40))();
    }
    LOBYTE(v62) = v11;
    HIBYTE(v62) = v48;
    uint64_t v63 = v10;
    gdc::FallbackCollector::collectFallbackData((uint64_t)this + 608, (void **)&v67, 1, 0, &v62);
    gdc::FallbackCollector::end((md::RouteLineLayerDataSource *)((char *)this + 608), v33);
    __int16 v34 = v7 + 144;
    unsigned int v7 = v6;
    if (v34 != v6)
    {
      unsigned int v7 = v34;
      while (1)
      {
        if (*((unsigned __int16 *)v7 + 4) == v5)
        {
          uint64_t v35 = *((void *)v7 + 17);
          if (!*(void *)(v8 + 144 * v35 + 112) || *(unsigned char *)(v8 + 144 * v35 + 136)) {
            break;
          }
        }
        v7 += 144;
        if (v7 == v6)
        {
          unsigned int v7 = v6;
          goto LABEL_5;
        }
      }
    }
  }
  long long v36 = v67;
  int64_t v37 = (__int16 *)v68;
  if (v67 == (__int16 *)v68)
  {
    if (v67) {
      goto LABEL_54;
    }
  }
  else
  {
    uint64_t v38 = v67 + 56;
    do
    {
      char v40 = *(unsigned char *)(*(void *)v38 + 16);
      gdc::LayerDataKey::LayerDataKey((uint64_t)v49, (uint64_t)(v38 - 44));
      LOBYTE(v52) = v40;
      gdc::LayerDataKey::LayerDataKey((uint64_t)&v53, (uint64_t)v49);
      char v60 = 0;
      unint64_t v61 = (v59
           - 0x61C8864680B583EBLL
           + ((v52 - 0x61C8864680B583EBLL) << 6)
           + (((unint64_t)v52 - 0x61C8864680B583EBLL) >> 2)) ^ (v52
                                                                                      - 0x61C8864680B583EBLL);
      gdc::LayerDataCollector::addFallbackData(v44, (uint64_t)&v52, v38 - 56, v38);
      if (v60) {
        char v60 = 0;
      }
      if (v54 != v56) {
        free(v54);
      }
      if (v50 != v51) {
        free(v50);
      }
      size_t v39 = v38 + 8;
      v38 += 64;
    }
    while (v39 != v37);
    if (v36)
    {
      if (v36 != v37)
      {
        do
        {
          uint64_t v41 = (std::__shared_weak_count *)*((void *)v37 - 1);
          if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
          uint64_t v42 = (void *)*((void *)v37 - 12);
          if (v42 != *((void **)v37 - 10)) {
            free(v42);
          }
          v37 -= 64;
        }
        while (v37 != v36);
        long long v36 = v67;
      }
LABEL_54:
      operator delete(v36);
    }
  }
  __n128 result = v73;
  if (v73 == v72) {
    return (void *)(*(uint64_t (**)(void *))(v72[0] + 32))(v72);
  }
  if (v73) {
    return (void *)(*(uint64_t (**)(void))(*v73 + 40))();
  }
  return result;
}

void sub_1A211692C(_Unwind_Exception *a1)
{
  std::vector<gdc::FallbackData>::~vector[abi:nn180100]((void **)(v1 - 200));
  std::function<gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::~function((void *)(v1 - 144));
  _Unwind_Resume(a1);
}

void *std::function<gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<std::__bind<gdc::LayerDataRequestKey (&)(gdc::RequestType,geo::QuadTile const&,unsigned short),std::placeholders::__ph<1> const&,std::placeholders::__ph<3> const&,unsigned short const&>,std::allocator<std::__bind<gdc::LayerDataRequestKey (&)(gdc::RequestType,geo::QuadTile const&,unsigned short),std::placeholders::__ph<1> const&,std::placeholders::__ph<3> const&,unsigned short const&>>,gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::operator()(uint64_t a1, unsigned __int8 *a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, uint64_t, void))(a1 + 8))(*a2, a4, *(unsigned __int16 *)(a1 + 16));
}

__n128 std::__function::__func<std::__bind<gdc::LayerDataRequestKey (&)(gdc::RequestType,geo::QuadTile const&,unsigned short),std::placeholders::__ph<1> const&,std::placeholders::__ph<3> const&,unsigned short const&>,std::allocator<std::__bind<gdc::LayerDataRequestKey (&)(gdc::RequestType,geo::QuadTile const&,unsigned short),std::placeholders::__ph<1> const&,std::placeholders::__ph<3> const&,unsigned short const&>>,gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56B9B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<std::__bind<gdc::LayerDataRequestKey (&)(gdc::RequestType,geo::QuadTile const&,unsigned short),std::placeholders::__ph<1> const&,std::placeholders::__ph<3> const&,unsigned short const&>,std::allocator<std::__bind<gdc::LayerDataRequestKey (&)(gdc::RequestType,geo::QuadTile const&,unsigned short),std::placeholders::__ph<1> const&,std::placeholders::__ph<3> const&,unsigned short const&>>,gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56B9B0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<std::__bind<gdc::LayerDataRequestKey (&)(gdc::RequestType,geo::QuadTile const&,unsigned short),std::placeholders::__ph<1> const&,std::placeholders::__ph<3> const&,unsigned short const&>,std::allocator<std::__bind<gdc::LayerDataRequestKey (&)(gdc::RequestType,geo::QuadTile const&,unsigned short),std::placeholders::__ph<1> const&,std::placeholders::__ph<3> const&,unsigned short const&>>,gdc::LayerDataRequestKey ()(gdc::RequestType,unsigned short const&,geo::QuadTile const&)>::~__func()
{
}

void md::RouteLineLayerDataSource::~RouteLineLayerDataSource(md::RouteLineLayerDataSource *this)
{
  md::RouteLineLayerDataSource::~RouteLineLayerDataSource(this);
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  void *v3;
  uint64_t *v4;
  uint64_t *v5;
  void *v6;
  unint64_t v7;
  BOOL v8;
  void *v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t *v12;
  BOOL v13;
  void *v14;
  void *v15;
  uint64_t vars8;

  *(void *)this = &unk_1EF545790;
  uint64_t v2 = (char *)this + 584;
  *((void *)this + 73) = &unk_1EF545840;
  BOOL v3 = (void *)*((void *)this + 74);
  uint64_t v4 = (uint64_t *)v3[10];
  if (v4)
  {
    int v5 = v3 + 10;
    int v6 = (void *)v3[10];
    do
    {
      unsigned int v7 = v6[4];
      uint64_t v8 = v7 >= (unint64_t)v2;
      if (v7 >= (unint64_t)v2) {
        __int32 v9 = v6;
      }
      else {
        __int32 v9 = v6 + 1;
      }
      if (v8) {
        int v5 = v6;
      }
      int v6 = (void *)*v9;
    }
    while (*v9);
    if (v5 != v3 + 10 && v5[4] <= (unint64_t)v2)
    {
      uint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          char v11 = v10;
          uint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          char v11 = (uint64_t *)v12[2];
          int v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if ((uint64_t *)v3[9] == v5) {
        v3[9] = v11;
      }
      --v3[11];
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v4, v5);
      operator delete(v5);
    }
  }
  int v14 = (void *)*((void *)this + 92);
  if (v14)
  {
    *((void *)this + 93) = v14;
    operator delete(v14);
  }
  unsigned int v15 = (void *)*((void *)this + 89);
  if (v15)
  {
    *((void *)this + 90) = v15;
    operator delete(v15);
  }
  geo::Pool<gdc::FallbackNode>::disposeElements((uint64_t)this + 664);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 84));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 80));
  if (*((unsigned char *)this + 608)) {
    *((unsigned char *)this + 608) = 0;
  }
  gdc::LayerDataSource::~LayerDataSource(this);
}

void sub_1A2116C18(_Unwind_Exception *a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v1 + 672));
  _Unwind_Resume(a1);
}

void *md::realistic::RealisticRenderer::onLayoutEnd(md::realistic::RealisticRenderer *this, md::LayoutContext *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(*((void *)this + 1) + 8);
  v7[0] = &unk_1EF57A148;
  v7[1] = this;
  uint64_t v8 = v7;
  geo::TaskQueue::async(&v5, v2, v7);
  BOOL v3 = v6;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  __n128 result = v8;
  if (v8 == v7) {
    return (void *)(*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (void *)(*(uint64_t (**)(void))(*v8 + 40))();
  }
  return result;
}

void sub_1A2116D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

intptr_t std::__function::__func<md::realistic::RealisticRenderer::onLayoutEnd(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::onLayoutEnd(md::LayoutContext &)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  int v219 = *(void **)(a1 + 8);
  uint64_t v1 = v219[16];
  (*(void (**)(void, void))(**(void **)(v1 + 688) + 56))(*(void *)(v1 + 688), *(unsigned int *)(*(void *)(*(void *)(v1 + 856) + 136) + 88));
  uint64_t v2 = *(void *)(v1 + 696);
  uint64_t v218 = v1;
  unsigned int v3 = *(_DWORD *)(*(void *)(*(void *)(v1 + 856) + 136) + 88);
  uint64_t v4 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 48) + 24))(*(void *)(v2 + 48), v2, 0xFFFFFFFFLL);
  uint64_t v5 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 56) + 24))(*(void *)(v2 + 56), v2);
  std::mutex::lock((std::mutex *)(v2 + 104));
  int v6 = *(int **)(v2 + 80);
  if (v6 != (int *)(v2 + 88))
  {
    do
    {
      uint64_t v12 = (float **)*((void *)v6 + 6);
      for (uint64_t i = (float **)*((void *)v6 + 7); v12 != i; v12 += 2)
        altitude::ObjectTreeLoader::traverse(v2, v6 + 10, v12, v4, v5, v3);
      int v13 = (int *)*((void *)v6 + 1);
      if (v13)
      {
        do
        {
          int v14 = v13;
          int v13 = *(int **)v13;
        }
        while (v13);
      }
      else
      {
        do
        {
          int v14 = (int *)*((void *)v6 + 2);
          BOOL v15 = *(void *)v14 == (void)v6;
          int v6 = v14;
        }
        while (!v15);
      }
      int v6 = v14;
    }
    while (v14 != (int *)(v2 + 88));
  }
  std::mutex::unlock((std::mutex *)(v2 + 104));
  unsigned int v7 = *(int **)(v2 + 168);
  uint64_t v8 = *(int **)(v2 + 176);
  uint64_t v225 = v2;
  if (v7 != v8)
  {
    uint64_t v9 = (void *)(v2 + 200);
    uint64_t v10 = *(md::realistic::GlobeRenderLayer **)(*(void *)(*(void *)(*(void *)(v2 + 32) + 8) + 40) + 8);
    uint64_t v226 = *(int **)(v2 + 176);
    char v222 = (void *)(v2 + 200);
    while (1)
    {
      int v17 = v7[10];
      if (v17 == -1)
      {
        if (!v3) {
          goto LABEL_15;
        }
      }
      else if (*(_DWORD *)(*((void *)v7 + 2) + 48 * v17 + 40) >= v3)
      {
        goto LABEL_15;
      }
      int v18 = v7[11];
      if (v18 == -1)
      {
        if (v17 != -1)
        {
          __int16 v34 = *(altitude::RenderableGroup **)(*((void *)v7 + 2) + 48 * v17 + 24);
          uint64_t v35 = (void *)*((void *)v34 + 6);
          long long v36 = (void *)*((void *)v34 + 7);
          if (v35 != v36)
          {
            int64_t v37 = (char *)*((void *)v10 + 28);
            uint64_t v38 = (char *)*((void *)v10 + 29);
            do
            {
              uint64_t v41 = v37;
              if (v38 != v37)
              {
                uint64_t v43 = 0;
                unint64_t v44 = (v38 - v37) >> 4;
                if (v44 <= 1) {
                  uint64_t v45 = 1;
                }
                else {
                  uint64_t v45 = (v38 - v37) >> 4;
                }
                int v46 = v37;
                do
                {
                  if (*(void *)v46 == *v35)
                  {
                    size_t v39 = &v37[16 * v43];
                    char v40 = &v37[16 * v44];
                    uint64_t v42 = *((void *)v40 - 2);
                    uint64_t v41 = v40 - 16;
                    *(void *)size_t v39 = v42;
                    v39[8] = v41[8];
                    *((void *)v10 + 29) = v41;
                    goto LABEL_39;
                  }
                  ++v43;
                  v46 += 16;
                }
                while (v45 != v43);
                uint64_t v41 = v38;
              }
LABEL_39:
              ++v35;
              uint64_t v38 = v41;
            }
            while (v35 != v36);
          }
          md::realistic::GlobeRenderLayer::unregisterAnimatedGroup(v10, v34);
          v7[10] = -1;
          unsigned __int16 v52 = (uint64_t *)*v9;
          if (*v9)
          {
            unsigned int v54 = *v7;
            unsigned int v53 = v7[1];
            uint64_t v55 = v9;
            unsigned int v56 = v7[2];
            do
            {
              while (*((_DWORD *)v52 + 8) < v54 || *((_DWORD *)v52 + 9) < v53 || *((_DWORD *)v52 + 10) < v56)
              {
                unsigned __int16 v52 = (uint64_t *)v52[1];
                if (!v52) {
                  goto LABEL_67;
                }
              }
              uint64_t v55 = v52;
              unsigned __int16 v52 = (uint64_t *)*v52;
            }
            while (v52);
LABEL_67:
            if (v55 != v9 && v54 >= *((_DWORD *)v55 + 8) && v53 >= *((_DWORD *)v55 + 9) && v56 >= *((_DWORD *)v55 + 10))
            {
              uint64_t v57 = (void *)v55[6];
              uint64_t v58 = v55 + 7;
              if (v57 != v58)
              {
                do
                {
                  *(unsigned char *)(v57[4] + 180) = 1;
                  uint64_t v59 = (void *)v57[1];
                  if (v59)
                  {
                    do
                    {
                      char v60 = v59;
                      uint64_t v59 = (void *)*v59;
                    }
                    while (v59);
                  }
                  else
                  {
                    do
                    {
                      char v60 = (void *)v57[2];
                      BOOL v15 = *v60 == (void)v57;
                      uint64_t v57 = v60;
                    }
                    while (!v15);
                  }
                  uint64_t v57 = v60;
                }
                while (v60 != v58);
              }
            }
          }
        }
        goto LABEL_15;
      }
      uint64_t v19 = *((void *)v7 + 2);
      uint64_t v20 = *(void *)(v19 + 48 * v18 + 24);
      if (v20)
      {
        if (v17 == -1)
        {
          unint64_t v61 = (uint64_t *)*v9;
          if (*v9)
          {
            unsigned int v63 = *v7;
            unsigned int v62 = v7[1];
            char v64 = v9;
            unsigned int v65 = v7[2];
            do
            {
              while (*((_DWORD *)v61 + 8) < v63 || *((_DWORD *)v61 + 9) < v62 || *((_DWORD *)v61 + 10) < v65)
              {
                unint64_t v61 = (uint64_t *)v61[1];
                if (!v61) {
                  goto LABEL_87;
                }
              }
              char v64 = v61;
              unint64_t v61 = (uint64_t *)*v61;
            }
            while (v61);
LABEL_87:
            if (v64 != v9 && v63 >= *((_DWORD *)v64 + 8) && v62 >= *((_DWORD *)v64 + 9) && v65 >= *((_DWORD *)v64 + 10))
            {
              int v66 = (void *)v64[6];
              char v67 = v64 + 7;
              if (v66 != v67)
              {
                do
                {
                  *(unsigned char *)(v66[4] + 180) = 0;
                  uint64_t v68 = (void *)v66[1];
                  if (v68)
                  {
                    do
                    {
                      uint64_t v69 = v68;
                      uint64_t v68 = (void *)*v68;
                    }
                    while (v68);
                  }
                  else
                  {
                    do
                    {
                      uint64_t v69 = (void *)v66[2];
                      BOOL v15 = *v69 == (void)v66;
                      int v66 = v69;
                    }
                    while (!v15);
                  }
                  int v66 = v69;
                }
                while (v69 != v67);
              }
            }
          }
        }
        else
        {
          unint64_t v21 = *(altitude::RenderableGroup **)(v19 + 48 * v17 + 24);
          int8x16_t v22 = (void *)*((void *)v21 + 6);
          int8x16_t v23 = (void *)*((void *)v21 + 7);
          if (v22 != v23)
          {
            int64x2_t v24 = (char *)*((void *)v10 + 28);
            unsigned long long v25 = (char *)*((void *)v10 + 29);
            do
            {
              int8x16_t v28 = v24;
              if (v25 != v24)
              {
                uint64_t v30 = 0;
                unint64_t v31 = (v25 - v24) >> 4;
                if (v31 <= 1) {
                  uint64_t v32 = 1;
                }
                else {
                  uint64_t v32 = (v25 - v24) >> 4;
                }
                double v33 = v24;
                do
                {
                  if (*(void *)v33 == *v22)
                  {
                    unsigned long long v26 = &v24[16 * v30];
                    int8x16_t v27 = &v24[16 * v31];
                    uint64_t v29 = *((void *)v27 - 2);
                    int8x16_t v28 = v27 - 16;
                    *(void *)unsigned long long v26 = v29;
                    v26[8] = v28[8];
                    *((void *)v10 + 29) = v28;
                    goto LABEL_26;
                  }
                  ++v30;
                  v33 += 16;
                }
                while (v32 != v30);
                int8x16_t v28 = v25;
              }
LABEL_26:
              ++v22;
              unsigned long long v25 = v28;
            }
            while (v22 != v23);
          }
          md::realistic::GlobeRenderLayer::unregisterAnimatedGroup(v10, v21);
          int v18 = v7[11];
          uint64_t v19 = *((void *)v7 + 2);
          uint64_t v20 = *(void *)(v19 + 48 * v18 + 24);
        }
        int v47 = *(uint64_t **)(v20 + 48);
        char v48 = *(uint64_t **)(v20 + 56);
        if (v47 == v48)
        {
LABEL_59:
          uint64_t v51 = *(void *)(v19 + 48 * v18 + 24);
        }
        else
        {
          do
          {
            uint64_t v50 = *v47;
            if ((*(_DWORD *)(*v47 + 160) - 1) <= 2)
            {
              if (*(unsigned char *)(v50 + 312)) {
                char v49 = 5;
              }
              else {
                char v49 = 4;
              }
            }
            else
            {
              char v49 = 4;
            }
            md::realistic::GlobeRenderLayer::registerNoCullingRenderable(v10, v50, v49);
            ++v47;
          }
          while (v47 != v48);
          int v18 = v7[11];
          if (v18 != -1)
          {
            uint64_t v19 = *((void *)v7 + 2);
            goto LABEL_59;
          }
          uint64_t v51 = 0;
        }
        uint64_t v71 = (char *)*((void *)v10 + 32);
        unint64_t v70 = *((void *)v10 + 33);
        if ((unint64_t)v71 < v70)
        {
          *(void *)uint64_t v71 = v51;
          int v16 = v71 + 8;
        }
        else
        {
          unint64_t v72 = (char *)*((void *)v10 + 31);
          uint64_t v73 = (v71 - v72) >> 3;
          unint64_t v74 = v73 + 1;
          if ((unint64_t)(v73 + 1) >> 61) {
LABEL_323:
          }
            abort();
          uint64_t v75 = v70 - (void)v72;
          if (v75 >> 2 > v74) {
            unint64_t v74 = v75 >> 2;
          }
          if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v76 = v74;
          }
          if (v76)
          {
            if (v76 >> 61) {
LABEL_324:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            float64x2_t v77 = (char *)operator new(8 * v76);
          }
          else
          {
            float64x2_t v77 = 0;
          }
          float64x2_t v78 = &v77[8 * v73];
          *(void *)float64x2_t v78 = v51;
          int v16 = v78 + 8;
          if (v71 != v72)
          {
            unint64_t v79 = v71 - v72 - 8;
            if (v79 < 0x58) {
              goto LABEL_327;
            }
            if ((unint64_t)(v72 - v77) < 0x20) {
              goto LABEL_327;
            }
            uint64_t v80 = (v79 >> 3) + 1;
            uint64_t v81 = &v77[8 * v73 - 16];
            uint64_t v82 = (long long *)(v71 - 16);
            uint64_t v83 = v80 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v84 = *v82;
              *((_OWORD *)v81 - 1) = *(v82 - 1);
              *(_OWORD *)uint64_t v81 = v84;
              v81 -= 32;
              v82 -= 2;
              v83 -= 4;
            }
            while (v83);
            v78 -= 8 * (v80 & 0x3FFFFFFFFFFFFFFCLL);
            v71 -= 8 * (v80 & 0x3FFFFFFFFFFFFFFCLL);
            if (v80 != (v80 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_327:
              do
              {
                uint64_t v85 = *((void *)v71 - 1);
                v71 -= 8;
                *((void *)v78 - 1) = v85;
                v78 -= 8;
              }
              while (v71 != v72);
            }
            uint64_t v71 = (char *)*((void *)v10 + 31);
          }
          *((void *)v10 + 31) = v78;
          *((void *)v10 + 32) = v16;
          *((void *)v10 + 33) = &v77[8 * v76];
          uint64_t v2 = v225;
          if (v71) {
            operator delete(v71);
          }
          uint64_t v8 = v226;
          uint64_t v9 = v222;
        }
        *((void *)v10 + 32) = v16;
        v7[10] = v7[11];
        v7[11] = -1;
      }
LABEL_15:
      v7 += 12;
      if (v7 == v8)
      {
        unsigned int v7 = *(int **)(v2 + 168);
        double v86 = *(int **)(v2 + 176);
        goto LABEL_125;
      }
    }
  }
  double v86 = *(int **)(v2 + 168);
LABEL_125:
  if ((int)(-1431655765 * ((unint64_t)((char *)v86 - (char *)v7) >> 4) - *(_DWORD *)(v2 + 220)) >= 1)
  {
    unint64_t v223 = -1431655765 * ((unint64_t)((char *)v86 - (char *)v7) >> 4) - *(_DWORD *)(v2 + 220);
    if (v7 != v86)
    {
      uint64_t v87 = 0;
      uint64_t v88 = 0;
      uint64_t v89 = 0;
      uint64_t v227 = v86;
      while (1)
      {
        uint64_t v91 = *((void *)v7 + 2);
        if (*((void *)v7 + 3) != v91) {
          break;
        }
        uint64_t v90 = v88;
LABEL_129:
        v7 += 12;
        uint64_t v88 = v90;
        if (v7 == v227) {
          goto LABEL_168;
        }
      }
      uint64_t v92 = 0;
      unsigned int v93 = 0;
      while (1)
      {
        if (v7[11] != v93 && v7[10] != v93)
        {
          uint64_t v94 = v91 + 48 * v92;
          if (*(void *)(v94 + 24))
          {
            if (v88 >= v89)
            {
              int64_t v95 = (char *)v88 - (char *)v87;
              uint64_t v96 = v88 - v87;
              unint64_t v97 = v96 + 1;
              if ((unint64_t)(v96 + 1) >> 61) {
                goto LABEL_323;
              }
              if (((char *)v89 - (char *)v87) >> 2 > v97) {
                unint64_t v97 = ((char *)v89 - (char *)v87) >> 2;
              }
              if ((unint64_t)((char *)v89 - (char *)v87) >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v98 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v98 = v97;
              }
              if (v98)
              {
                if (v98 >> 61) {
                  goto LABEL_324;
                }
                int v99 = v87;
                double v100 = operator new(8 * v98);
                uint64_t v87 = v99;
              }
              else
              {
                double v100 = 0;
              }
              double v101 = (uint64_t *)&v100[8 * v96];
              *double v101 = v94;
              uint64_t v90 = v101 + 1;
              if (v88 != v87)
              {
                unint64_t v102 = (char *)(v88 - 1) - (char *)v87;
                if (v102 < 0x168)
                {
                  double v103 = v88;
                  goto LABEL_153;
                }
                if (&v100[v95 - 8 - (v102 & 0xFFFFFFFFFFFFFFF8)] > &v100[v95 - 8])
                {
                  double v103 = v88;
                  goto LABEL_153;
                }
                if ((uint64_t *)((char *)v88 - (v102 & 0xFFFFFFFFFFFFFFF8) - 8) > v88 - 1)
                {
                  double v103 = v88;
                  goto LABEL_153;
                }
                if ((unint64_t)((char *)v88 - &v100[v95]) < 0x20)
                {
                  double v103 = v88;
                  goto LABEL_153;
                }
                uint64_t v105 = (v102 >> 3) + 1;
                double v103 = &v88[-(v105 & 0x3FFFFFFFFFFFFFFCLL)];
                double v106 = &v100[8 * v96 - 16];
                double v107 = v88 - 2;
                uint64_t v108 = v105 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v109 = *(_OWORD *)v107;
                  *(v106 - 1) = *((_OWORD *)v107 - 1);
                  *double v106 = v109;
                  v106 -= 2;
                  v107 -= 4;
                  v108 -= 4;
                }
                while (v108);
                v101 -= v105 & 0x3FFFFFFFFFFFFFFCLL;
                if (v105 != (v105 & 0x3FFFFFFFFFFFFFFCLL))
                {
                  do
                  {
LABEL_153:
                    uint64_t v104 = *--v103;
                    *--double v101 = v104;
                  }
                  while (v103 != v87);
                }
              }
              uint64_t v89 = (uint64_t *)&v100[8 * v98];
              if (v87) {
                operator delete(v87);
              }
              uint64_t v87 = v101;
              goto LABEL_138;
            }
            *v88++ = v94;
          }
        }
        uint64_t v90 = v88;
LABEL_138:
        uint64_t v91 = *((void *)v7 + 2);
        uint64_t v92 = ++v93;
        uint64_t v88 = v90;
        if (0xAAAAAAAAAAAAAAABLL * ((*((void *)v7 + 3) - v91) >> 4) <= v93) {
          goto LABEL_129;
        }
      }
    }
    uint64_t v90 = 0;
    uint64_t v87 = 0;
LABEL_168:
    __n128 v228 = v87;
    unint64_t v110 = v90 - v87;
    unint64_t v111 = 126 - 2 * __clz(v110);
    if (v90 == v87) {
      uint64_t v112 = 0;
    }
    else {
      uint64_t v112 = v111;
    }
    std::__introsort<std::_ClassicAlgPolicy,altitude::ObjectTreeLoader::cleanupModels(void)::OldestFirst &,altitude::ObjectTreeModel::LodLevel **,false>((unint64_t)v87, v90, v112, 1);
    long long v113 = v228;
    if (v90 != v228)
    {
      unint64_t v114 = v223;
      if (v223 >= v110) {
        unint64_t v114 = v110;
      }
      if (v114 <= 1) {
        uint64_t v115 = 1;
      }
      else {
        uint64_t v115 = v114;
      }
      int v116 = v228;
      do
      {
        uint64_t v118 = *v116;
        __int16 v119 = *(std::__shared_weak_count **)(*v116 + 32);
        *(void *)(v118 + 24) = 0;
        *(void *)(v118 + 32) = 0;
        if (v119 && !atomic_fetch_add(&v119->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
          std::__shared_weak_count::__release_weak(v119);
          long long v113 = v228;
        }
        uint64_t v117 = *v116++;
        *(_DWORD *)(v117 + 40) = 0;
        *(unsigned char *)(v117 + 44) = 0;
        --v115;
      }
      while (v115);
    }
    uint64_t v121 = *(void *)(v225 + 168);
    uint64_t v120 = *(void *)(v225 + 176);
    if (v120 != v121)
    {
      uint64_t v122 = 0;
      unsigned int v123 = 0;
      unint64_t v124 = 0xAAAAAAAAAAAAAAABLL * ((v120 - v121) >> 4);
      while (1)
      {
        uint64_t v125 = v121 + 48 * v122;
        if (*(_DWORD *)(v125 + 44) != -1) {
          goto LABEL_184;
        }
        uint64_t v126 = v121 + 48 * v122;
        double v129 = *(char **)(v126 + 16);
        uint64_t v128 = v126 + 16;
        int v127 = v129;
        double v130 = *(char **)(v128 + 8);
        char v224 = (char **)(v128 + 8);
        uint64_t v131 = v129;
        if (v129 != v130) {
          break;
        }
LABEL_190:
        unint64_t v132 = v124 - 1;
        uint64_t v133 = (uint64_t *)(v121 + 48 * (v124 - 1));
        uint64_t v134 = *v133;
        *(_DWORD *)(v125 + 8) = *((_DWORD *)v133 + 2);
        *(void *)uint64_t v125 = v134;
        if (v132 != v122)
        {
          unsigned int v221 = v123;
          unint64_t v220 = v132;
          uint64_t v135 = v121 + 48 * v132;
          uint64_t v137 = *(void *)(v135 + 16);
          uint64_t v136 = *(void *)(v135 + 24);
          unint64_t v138 = 0xAAAAAAAAAAAAAAABLL * ((v136 - v137) >> 4);
          uint64_t v139 = v121 + 48 * v122;
          uint64_t v142 = *(void *)(v139 + 32);
          uint64_t v141 = (void *)(v139 + 32);
          uint64_t v140 = v142;
          uint64_t v143 = v121;
          if (0xAAAAAAAAAAAAAAABLL * ((v142 - (uint64_t)v127) >> 4) >= v138)
          {
            unint64_t v149 = 0xAAAAAAAAAAAAAAABLL * ((v130 - v127) >> 4);
            if (v149 >= v138)
            {
              if (v137 == v136)
              {
                uint64_t v161 = (char **)(v128 + 8);
              }
              else
              {
                do
                {
                  uint64_t v163 = *((void *)v127 + 1);
                  if (v163) {
                    atomic_fetch_add((atomic_uint *volatile)(v163 + 128), 0xFFFFFFFF);
                  }
                  uint64_t v164 = *(void *)(v137 + 8);
                  uint64_t v165 = *(void *)(v137 + 16);
                  if (v165) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v165 + 8), 1uLL, memory_order_relaxed);
                  }
                  uint64_t v166 = (std::__shared_weak_count *)*((void *)v127 + 2);
                  *((void *)v127 + 1) = v164;
                  *((void *)v127 + 2) = v165;
                  if (v166)
                  {
                    if (!atomic_fetch_add(&v166->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v166->__on_zero_shared)(v166);
                      std::__shared_weak_count::__release_weak(v166);
                      long long v113 = v228;
                    }
                    uint64_t v164 = *((void *)v127 + 1);
                  }
                  if (v164) {
                    atomic_fetch_add((atomic_uint *volatile)(v164 + 128), 1u);
                  }
                  uint64_t v168 = *(void *)(v137 + 24);
                  uint64_t v167 = *(void *)(v137 + 32);
                  if (v167) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v167 + 8), 1uLL, memory_order_relaxed);
                  }
                  unint64_t v169 = (std::__shared_weak_count *)*((void *)v127 + 4);
                  *((void *)v127 + 3) = v168;
                  *((void *)v127 + 4) = v167;
                  if (v169 && !atomic_fetch_add(&v169->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v169->__on_zero_shared)(v169);
                    std::__shared_weak_count::__release_weak(v169);
                    long long v113 = v228;
                  }
                  int v162 = *(_DWORD *)(v137 + 40);
                  v127[44] = *(unsigned char *)(v137 + 44);
                  *((_DWORD *)v127 + 10) = v162;
                  v137 += 48;
                  v127 += 48;
                }
                while (v137 != v136);
                uint64_t v121 = v143;
                uint64_t v161 = (char **)(v128 + 8);
                double v130 = *v224;
              }
              unsigned int v123 = v221;
              if (v130 == v127)
              {
                unint64_t v132 = v220;
              }
              else
              {
                int v181 = v130 - 48;
                do
                {
                  unint64_t v182 = (std::__shared_weak_count *)*((void *)v130 - 2);
                  if (v182 && !atomic_fetch_add(&v182->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v182->__on_zero_shared)(v182);
                    std::__shared_weak_count::__release_weak(v182);
                    long long v113 = v228;
                  }
                  *((void *)v130 - 6) = off_1EF5677B0;
                  uint64_t v183 = *((void *)v130 - 5);
                  if (v183) {
                    atomic_fetch_add((atomic_uint *volatile)(v183 + 128), 0xFFFFFFFF);
                  }
                  uint64_t v184 = (std::__shared_weak_count *)*((void *)v130 - 4);
                  if (v184 && !atomic_fetch_add(&v184->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
                    std::__shared_weak_count::__release_weak(v184);
                    long long v113 = v228;
                  }
                  v130 -= 48;
                  v181 -= 48;
                }
                while (v130 != v127);
                uint64_t v121 = v143;
                unint64_t v132 = v220;
              }
            }
            else
            {
              if (v127 == v130)
              {
                uint64_t v161 = (char **)(v128 + 8);
              }
              else
              {
                uint64_t v150 = (uint64_t *)(v137 + 24);
                unint64_t v217 = 0xAAAAAAAAAAAAAAABLL * ((v130 - v127) >> 4);
                uint64_t v151 = 16 * ((v130 - v127) >> 4);
                unint64_t v152 = v127 + 24;
                do
                {
                  uint64_t v154 = *(v152 - 2);
                  if (v154) {
                    atomic_fetch_add((atomic_uint *volatile)(v154 + 128), 0xFFFFFFFF);
                  }
                  uint64_t v155 = *(v150 - 2);
                  uint64_t v156 = *(v150 - 1);
                  if (v156) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v156 + 8), 1uLL, memory_order_relaxed);
                  }
                  unint64_t v157 = (std::__shared_weak_count *)*(v152 - 1);
                  *(v152 - 2) = v155;
                  *(v152 - 1) = v156;
                  if (v157)
                  {
                    if (!atomic_fetch_add(&v157->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v157->__on_zero_shared)(v157);
                      std::__shared_weak_count::__release_weak(v157);
                      long long v113 = v228;
                    }
                    uint64_t v155 = *(v152 - 2);
                  }
                  if (v155) {
                    atomic_fetch_add((atomic_uint *volatile)(v155 + 128), 1u);
                  }
                  uint64_t v159 = *v150;
                  uint64_t v158 = v150[1];
                  if (v158) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v158 + 8), 1uLL, memory_order_relaxed);
                  }
                  unint64_t v160 = (std::__shared_weak_count *)v152[1];
                  *unint64_t v152 = v159;
                  v152[1] = v158;
                  if (v160 && !atomic_fetch_add(&v160->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v160->__on_zero_shared)(v160);
                    std::__shared_weak_count::__release_weak(v160);
                    long long v113 = v228;
                  }
                  int v153 = *((_DWORD *)v150 + 4);
                  *((unsigned char *)v152 + 20) = *((unsigned char *)v150 + 20);
                  *((_DWORD *)v152 + 4) = v153;
                  v150 += 6;
                  v152 += 6;
                  v151 -= 48;
                }
                while (v151);
                uint64_t v161 = v224;
                int v127 = *v224;
                uint64_t v121 = v143;
                unint64_t v149 = v217;
              }
              uint64_t v185 = v137 + 48 * v149;
              unsigned int v186 = v127;
              unsigned int v123 = v221;
              unint64_t v132 = v220;
              if (v185 != v136)
              {
                unsigned int v187 = v127;
                unsigned int v186 = v127;
                do
                {
                  uint64_t v189 = *(void *)(v185 + 8);
                  uint64_t v190 = *(void *)(v185 + 16);
                  *(void *)unsigned int v186 = off_1EF5677B0;
                  *((void *)v186 + 1) = v189;
                  *((void *)v186 + 2) = v190;
                  if (v190)
                  {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v190 + 8), 1uLL, memory_order_relaxed);
                    uint64_t v189 = *((void *)v186 + 1);
                  }
                  if (v189) {
                    atomic_fetch_add((atomic_uint *volatile)(v189 + 128), 1u);
                  }
                  uint64_t v191 = *(void *)(v185 + 32);
                  *((void *)v186 + 3) = *(void *)(v185 + 24);
                  *((void *)v186 + 4) = v191;
                  if (v191) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v191 + 8), 1uLL, memory_order_relaxed);
                  }
                  int v188 = *(_DWORD *)(v185 + 40);
                  v186[44] = *(unsigned char *)(v185 + 44);
                  *((_DWORD *)v186 + 10) = v188;
                  v185 += 48;
                  v186 += 48;
                  v187 += 48;
                }
                while (v185 != v136);
              }
              int v127 = v186;
            }
          }
          else
          {
            if (v127)
            {
              unint64_t v144 = v127;
              if (v127 != v130)
              {
                unint64_t v216 = v141;
                float32x4_t v145 = v130 - 48;
                do
                {
                  float32x4_t v146 = (std::__shared_weak_count *)*((void *)v130 - 2);
                  if (v146 && !atomic_fetch_add(&v146->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v146->__on_zero_shared)(v146);
                    std::__shared_weak_count::__release_weak(v146);
                  }
                  *((void *)v130 - 6) = off_1EF5677B0;
                  uint64_t v147 = *((void *)v130 - 5);
                  if (v147) {
                    atomic_fetch_add((atomic_uint *volatile)(v147 + 128), 0xFFFFFFFF);
                  }
                  uint64_t v148 = (std::__shared_weak_count *)*((void *)v130 - 4);
                  if (v148 && !atomic_fetch_add(&v148->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v148->__on_zero_shared)(v148);
                    std::__shared_weak_count::__release_weak(v148);
                  }
                  v130 -= 48;
                  v145 -= 48;
                }
                while (v130 != v127);
                unint64_t v144 = *(char **)v128;
                uint64_t v141 = v216;
              }
              uint64_t v161 = (char **)(v128 + 8);
              void *v224 = v127;
              operator delete(v144);
              uint64_t v140 = 0;
              *(void *)uint64_t v128 = 0;
              *(void *)(v128 + 8) = 0;
              *(void *)(v128 + 16) = 0;
              unint64_t v138 = 0xAAAAAAAAAAAAAAABLL * ((v136 - v137) >> 4);
            }
            else
            {
              uint64_t v161 = (char **)(v128 + 8);
            }
            if (v138 > 0x555555555555555) {
              goto LABEL_323;
            }
            unint64_t v170 = 0xAAAAAAAAAAAAAAABLL * (v140 >> 4);
            uint64_t v171 = 2 * v170;
            if (2 * v170 <= v138) {
              uint64_t v171 = v138;
            }
            unint64_t v172 = v170 >= 0x2AAAAAAAAAAAAAALL ? 0x555555555555555 : v171;
            if (v172 > 0x555555555555555) {
              goto LABEL_323;
            }
            long long v173 = v141;
            uint64_t v174 = 48 * v172;
            long long v175 = (char *)operator new(48 * v172);
            int v127 = v175;
            *(void *)uint64_t v128 = v175;
            *uint64_t v161 = v175;
            *long long v173 = &v175[v174];
            if (v137 == v136)
            {
              long long v113 = v228;
              uint64_t v121 = v143;
              unint64_t v132 = v220;
            }
            else
            {
              uint64_t v176 = v175;
              long long v113 = v228;
              uint64_t v121 = v143;
              unint64_t v132 = v220;
              do
              {
                uint64_t v178 = *(void *)(v137 + 8);
                uint64_t v179 = *(void *)(v137 + 16);
                *(void *)int v127 = off_1EF5677B0;
                *((void *)v127 + 1) = v178;
                *((void *)v127 + 2) = v179;
                if (v179)
                {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v179 + 8), 1uLL, memory_order_relaxed);
                  uint64_t v178 = *((void *)v127 + 1);
                }
                if (v178) {
                  atomic_fetch_add((atomic_uint *volatile)(v178 + 128), 1u);
                }
                uint64_t v180 = *(void *)(v137 + 32);
                *((void *)v127 + 3) = *(void *)(v137 + 24);
                *((void *)v127 + 4) = v180;
                if (v180) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v180 + 8), 1uLL, memory_order_relaxed);
                }
                int v177 = *(_DWORD *)(v137 + 40);
                v127[44] = *(unsigned char *)(v137 + 44);
                *((_DWORD *)v127 + 10) = v177;
                v137 += 48;
                v127 += 48;
                v176 += 48;
              }
              while (v137 != v136);
            }
            unsigned int v123 = v221;
          }
          *uint64_t v161 = v127;
        }
        *(void *)(v121 + 48 * v122 + 40) = *(void *)(v121 + 48 * v132 + 40);
        uint64_t v192 = *(void *)(v225 + 176);
        uint64_t v193 = *(void *)(v192 - 32);
        if (v193)
        {
          uint64_t v194 = *(void *)(v192 - 24);
          unint64_t v195 = *(void **)(v192 - 32);
          if (v194 != v193)
          {
            uint64_t v196 = v194 - 48;
            do
            {
              unint64_t v197 = *(std::__shared_weak_count **)(v194 - 16);
              if (v197 && !atomic_fetch_add(&v197->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
                std::__shared_weak_count::__release_weak(v197);
              }
              *(void *)(v194 - 48) = off_1EF5677B0;
              uint64_t v198 = *(void *)(v194 - 40);
              if (v198) {
                atomic_fetch_add((atomic_uint *volatile)(v198 + 128), 0xFFFFFFFF);
              }
              int v199 = *(std::__shared_weak_count **)(v194 - 32);
              if (v199 && !atomic_fetch_add(&v199->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v199->__on_zero_shared)(v199);
                std::__shared_weak_count::__release_weak(v199);
              }
              v194 -= 48;
              v196 -= 48;
            }
            while (v194 != v193);
            unint64_t v195 = *(void **)(v192 - 32);
          }
          *(void *)(v192 - 24) = v193;
          operator delete(v195);
          long long v113 = v228;
        }
        uint64_t v120 = v192 - 48;
        *(void *)(v225 + 176) = v192 - 48;
        uint64_t v121 = *(void *)(v225 + 168);
LABEL_185:
        uint64_t v122 = v123;
        unint64_t v124 = 0xAAAAAAAAAAAAAAABLL * ((v120 - v121) >> 4);
        if (v124 <= v123) {
          goto LABEL_304;
        }
      }
      while (!*((void *)v131 + 3))
      {
        v131 += 48;
        if (v131 == v130) {
          goto LABEL_190;
        }
      }
LABEL_184:
      ++v123;
      goto LABEL_185;
    }
LABEL_304:
    if (v113) {
      operator delete(v113);
    }
  }
  double v200 = *(altitude::QuickSurfaceManager **)(v218 + 704);
  if (*((unsigned char *)v200 + 64)) {
    altitude::QuickSurfaceManager::update(v200);
  }
  if (*(unsigned char *)(v218 + 272))
  {
    double v201 = *(altitude::GlobeView **)(v218 + 464);
  }
  else
  {
    double v201 = *(altitude::GlobeView **)(v218 + 464);
    if (!*((unsigned char *)v201 + 613)) {
      goto LABEL_318;
    }
  }
  MainTileLoaderStatistics = altitude::GlobeView::getMainTileLoaderStatistics(v201, *(void *)(v218 + 528));
  unsigned int v204 = *((_DWORD *)MainTileLoaderStatistics + 1);
  if (v204)
  {
    LODWORD(v203) = *((_DWORD *)MainTileLoaderStatistics + 5);
    double v205 = (double)v203 / (double)v204;
    if (*(unsigned char *)(v218 + 272) && v205 >= 1.0)
    {
      altitude::GlobeView::setCoarseLoading((altitude::GlobeView *)v218);
      uint64_t v206 = *(void *)(v218 + 464);
LABEL_317:
      *(unsigned char *)(v206 + 613) = 0;
      goto LABEL_318;
    }
    uint64_t v206 = *(void *)(v218 + 464);
    if (*(unsigned char *)(v206 + 613) && v205 >= 0.9) {
      goto LABEL_317;
    }
  }
LABEL_318:
  (*(void (**)(void))(**(void **)(v219[16] + 16) + 16))(*(void *)(v219[16] + 16));
  uint64_t v207 = *(void *)(*(void *)(v219[17] + 72) + 24);
  (*(void (**)(uint64_t))(*(void *)v207 + 24))(v207);
  uint64_t v208 = v219[21];
  uint64_t v209 = *(void *)(v208 + 72);
  if (v209)
  {
    uint64_t v210 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v209 + 24))(v209, v219[21], 0xFFFFFFFFLL);
    uint64_t v211 = *(void *)(v208 + 80);
    karo::graphics::View::copyView(v211, v210);
    *(unsigned char *)(v211 + 1291) = *(unsigned char *)(v210 + 1291);
    *(_DWORD *)(v211 + 1320) = *(_DWORD *)(v210 + 1320);
    *(void *)(v211 + 1328) = *(void *)(v210 + 1328);
    *(void *)(v211 + 1336) = *(void *)(v210 + 1336);
    *(_DWORD *)(v211 + 1344) = *(_DWORD *)(v210 + 1344);
    long long v212 = *(_OWORD *)(v210 + 1352);
    long long v213 = *(_OWORD *)(v210 + 1368);
    *(void *)(v211 + 1384) = *(void *)(v210 + 1384);
    *(_OWORD *)(v211 + 1352) = v212;
    *(_OWORD *)(v211 + 1368) = v213;
    *(_DWORD *)(v211 + 1392) = *(_DWORD *)(v210 + 1392);
    *(void *)(v211 + 1400) = *(void *)(v210 + 1400);
    *(void *)(v211 + 1408) = *(void *)(v210 + 1408);
    *(void *)(v211 + 1416) = *(void *)(v210 + 1416);
    *(void *)(v211 + 1424) = *(void *)(v210 + 1424);
    *(void *)(v211 + 1432) = *(void *)(v210 + 1432);
    *(void *)(v211 + 1440) = *(void *)(v210 + 1440);
    *(void *)(v211 + 1448) = *(void *)(v210 + 1448);
    *(void *)(v211 + 1456) = *(void *)(v210 + 1456);
  }
  unint64_t v214 = v219[28];
  return dispatch_semaphore_signal(v214);
}

uint64_t std::__function::__func<md::realistic::RealisticRenderer::onLayoutEnd(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::onLayoutEnd(md::LayoutContext &)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57A148;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::realistic::RealisticRenderer::onLayoutEnd(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::onLayoutEnd(md::LayoutContext &)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF57A148;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::realistic::RealisticRenderer::onLayoutEnd(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::onLayoutEnd(md::LayoutContext &)::$_0>,void ()(void)>::~__func()
{
}

void md::realistic::RealisticRenderer::onLayoutStart(size_t *this, md::LayoutContext *a2)
{
  uint64_t v424 = *MEMORY[0x1E4F143B8];
  (*(void (**)(size_t *, md::LayoutContext *))(*this + 16))(this, a2);
  size_t v3 = this[22];
  if (!v3) {
    return;
  }
  size_t v4 = this[3];
  if (!v4) {
    return;
  }
  uint64_t v406 = *((unsigned int *)this + 54);
  size_t __sz = this[22];
  if (!*(void *)(v3 + 104))
  {
    uint64_t v38 = 0;
    goto LABEL_86;
  }
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  std::string __p = 0;
  v407 = 0;
  unsigned int v7 = 0;
  do
  {
    unint64_t v9 = *(void *)(v3 + 96) + v5;
    uint64_t v10 = *(void *)(*(void *)(v3 + 72) + ((v9 >> 6) & 0x3FFFFFFFFFFFFF8));
    uint64_t v11 = v9 & 0x1FF;
    LODWORD(v9) = atomic_load((unsigned int *)(*(void *)(v10 + 8 * v11) + 72));
    if (v9 != 5)
    {
      uint64_t v8 = v407;
      goto LABEL_6;
    }
    uint64_t v12 = *(void *)(v10 + 8 * v11);
    if (*(int *)(v12 + 76) <= 0)
    {
      int v14 = *(CVPixelBufferRef **)(v12 + 16);
      BOOL v15 = *(CVPixelBufferRef **)(v12 + 24);
      if (v14 != v15)
      {
        do
        {
          if (*v14) {
            CVPixelBufferRelease(*v14);
          }
          ++v14;
        }
        while (v14 != v15);
        goto LABEL_24;
      }
    }
    else
    {
      if (*(void *)(*(void *)v12 + 88) == v406)
      {
        uint64_t v8 = v407;
        uint64_t v13 = v407 - __p;
        if ((unint64_t)(v407 - __p) <= 0xF)
        {
          atomic_store(6u, (unsigned int *)(v12 + 72));
          if (v407 < v7)
          {
            *(void *)v407 = *(void *)(v10 + 8 * v11);
            uint64_t v8 = v407 + 8;
            goto LABEL_6;
          }
          uint64_t v22 = v13 >> 3;
          uint64_t v23 = v7 - __p;
          if ((v7 - __p) >> 2 <= (unint64_t)((v13 >> 3) + 1)) {
            uint64_t v24 = v22 + 1;
          }
          else {
            uint64_t v24 = v23 >> 2;
          }
          if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v25 = v24;
          }
          if (v25 >> 61) {
            goto LABEL_533;
          }
          unsigned long long v26 = operator new(8 * v25);
          int8x16_t v27 = &v26[8 * v22];
          *(void *)int8x16_t v27 = *(void *)(v10 + 8 * v11);
          uint64_t v8 = v27 + 8;
          int8x16_t v28 = __p;
          if (v407 == __p)
          {
            size_t v3 = __sz;
LABEL_47:
            unsigned int v7 = &v26[8 * v25];
            if (v28) {
              operator delete(v28);
            }
            std::string __p = v27;
            goto LABEL_6;
          }
          unint64_t v29 = v407 - 8 - __p;
          if (v29 >= 0x168)
          {
            if (&v26[(v13 & 0xFFFFFFFFFFFFFFF8) - 8 - (v29 & 0xFFFFFFFFFFFFFFF8)] <= &v26[(v13 & 0xFFFFFFFFFFFFFFF8)
                                                                                             - 8]
              && &v407[-(v29 & 0xFFFFFFFFFFFFFFF8) - 8] <= v407 - 8
              && (unint64_t)(v407 - &v26[v13 & 0xFFFFFFFFFFFFFFF8]) >= 0x20)
            {
              uint64_t v32 = (v29 >> 3) + 1;
              uint64_t v30 = &v407[-8 * (v32 & 0x3FFFFFFFFFFFFFFCLL)];
              double v33 = &v26[8 * v22 - 16];
              __int16 v34 = v407 - 16;
              uint64_t v35 = v32 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v36 = *(_OWORD *)v34;
                *(v33 - 1) = *((_OWORD *)v34 - 1);
                _OWORD *v33 = v36;
                v33 -= 2;
                v34 -= 32;
                v35 -= 4;
              }
              while (v35);
              v27 -= 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
              size_t v3 = __sz;
              int8x16_t v28 = __p;
              if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_47;
              }
              goto LABEL_46;
            }
            uint64_t v30 = v407;
          }
          else
          {
            uint64_t v30 = v407;
          }
          size_t v3 = __sz;
          int8x16_t v28 = __p;
          do
          {
LABEL_46:
            uint64_t v31 = *((void *)v30 - 1);
            v30 -= 8;
            *((void *)v27 - 1) = v31;
            v27 -= 8;
          }
          while (v30 != v28);
          goto LABEL_47;
        }
LABEL_6:
        ++v6;
        v407 = v8;
        goto LABEL_7;
      }
      *(void *)(*(void *)v12 + 16) = *(void *)(*(void *)v12 + 24);
      uint64_t v12 = *(void *)(v10 + 8 * v11);
      int v14 = *(CVPixelBufferRef **)(v12 + 16);
      int v16 = *(CVPixelBufferRef **)(v12 + 24);
      if (v14 != v16)
      {
        do
        {
          if (*v14) {
            CVPixelBufferRelease(*v14);
          }
          ++v14;
        }
        while (v14 != v16);
LABEL_24:
        uint64_t v12 = *(void *)(v10 + 8 * v11);
        int v14 = *(CVPixelBufferRef **)(v12 + 16);
      }
    }
    *(void *)(v12 + 24) = v14;
    atomic_store(0, (unsigned int *)(*(void *)(v10 + 8 * v11) + 72));
    size_t v3 = __sz;
    uint64_t v18 = *(void *)(__sz + 96);
    uint64_t v17 = *(void *)(__sz + 104);
    *(void *)(*(void *)(*(void *)(__sz + 72) + (((unint64_t)(v18 + v5) >> 6) & 0x3FFFFFFFFFFFFF8))
              + 8 * ((v18 + v5) & 0x1FF)) = *(void *)(*(void *)(*(void *)(__sz + 72)
                                                                  + (((unint64_t)(v17 - 1 + v18) >> 6) & 0x3FFFFFFFFFFFFF8))
                                                      + 8 * ((v17 - 1 + v18) & 0x1FF));
    uint64_t v20 = *(void *)(__sz + 72);
    uint64_t v19 = *(void *)(__sz + 80);
    *(void *)(__sz + 104) = v17 - 1;
    if (v19 == v20) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = ((v19 - v20) << 6) - 1;
    }
    if ((unint64_t)(v21 - (v17 + v18) + 1) >= 0x400)
    {
      operator delete(*(void **)(v19 - 8));
      *(void *)(__sz + 80) -= 8;
    }
LABEL_7:
    uint64_t v5 = v6;
  }
  while (*(void *)(v3 + 104) > (unint64_t)v6);
  int64_t v37 = __p;
  uint64_t v38 = v407;
  if (v407 == __p) {
    goto LABEL_86;
  }
  size_t v39 = *(void **)(v4 + 8);
  uint64_t v40 = v39[3];
  uint64_t v41 = v39[4];
  uint64_t v42 = v41 - v40;
  if (v41 != v40)
  {
    unint64_t v43 = 0;
    unint64_t v44 = v42 >> 3;
    do
    {
      uint64_t v45 = *(void *)(v40 + 8 * v43);
      if (!*(unsigned char *)v45 && *(void *)(v45 + 8) < (unint64_t)((uint64_t)(v39[16] - v39[15]) >> 3)) {
        break;
      }
      ++v43;
    }
    while (v43 < v44);
  }
  while (2)
  {
    uint64_t v46 = *(void *)v37;
    int v47 = *(CVPixelBufferRef **)(*(void *)v37 + 16);
    char v48 = *(CVPixelBufferRef **)(*(void *)v37 + 24);
    unint64_t v49 = (char *)v48 - (char *)v47;
    if (v48 != v47)
    {
      int v50 = *(_DWORD *)(v46 + 44);
      if (v50 == 4)
      {
        if (*(_DWORD *)(v46 + 48))
        {
          unsigned __int8 v51 = 14;
LABEL_71:
          if (*(unsigned char *)(v46 + 40)) {
            unsigned __int8 v52 = 10;
          }
          else {
            unsigned __int8 v52 = 1;
          }
          altitude::TexturePager::getPooledTexture(__sz, 512, 512, v52, v51);
        }
        else
        {
          IOSurface = CVPixelBufferGetIOSurface(*v47);
          int Width = IOSurfaceGetWidth(IOSurface);
          int Height = IOSurfaceGetHeight(IOSurface);
          if (*(unsigned char *)(*(void *)v37 + 40)) {
            unsigned __int8 v60 = 10;
          }
          else {
            unsigned __int8 v60 = 1;
          }
          altitude::TexturePager::getPooledTexture(__sz, Width, Height, v60, 0xEu);
        }
      }
      else if (v50 == 14)
      {
        if (*(_DWORD *)(v46 + 48))
        {
          unsigned __int8 v51 = 24;
          goto LABEL_71;
        }
        unsigned int v53 = CVPixelBufferGetIOSurface(*v47);
        int v54 = IOSurfaceGetWidth(v53);
        int v55 = IOSurfaceGetHeight(v53);
        if (*(unsigned char *)(*(void *)v37 + 40)) {
          unsigned __int8 v56 = 10;
        }
        else {
          unsigned __int8 v56 = 1;
        }
        altitude::TexturePager::getPooledTexture(__sz, v54, v55, v56, 0x18u);
      }
      atomic_store(v49 >> 3, (unsigned int *)(*(void *)v37 + 8));
      *(void *)(**(void **)v37 + 88) = v406;
      unint64_t v61 = **(__CVBuffer ***)(*(void *)v37 + 16);
      CVPixelBufferLockBaseAddress(v61, 1uLL);
      CVPixelBufferGetBaseAddress(v61);
      CVPixelBufferGetWidth(v61);
      CVPixelBufferGetHeight(v61);
      operator new();
    }
    v37 += 8;
    if (v37 != v407) {
      continue;
    }
    break;
  }
  size_t v3 = __sz;
  uint64_t v38 = __p;
LABEL_86:
  std::mutex::lock((std::mutex *)(v3 + 256));
  unsigned int v63 = *(ggl::Texture2D ***)(v3 + 232);
  unsigned int v62 = *(ggl::Texture2D ***)(v3 + 240);
  *(void *)(v3 + 232) = 0;
  *(void *)(v3 + 240) = 0;
  *(void *)(v3 + 248) = 0;
  std::mutex::unlock((std::mutex *)(v3 + 256));
  if (v63 != v62)
  {
    char v64 = v63 + 1;
    do
    {
      int v66 = v64 - 1;
      uint64_t v67 = (uint64_t)*(v64 - 1);
      uint64_t v68 = v64[1];
      if (v68) {
        CVPixelBufferRelease(v68);
      }
      if (atomic_fetch_add((atomic_uint *volatile)(v67 + 8), 0xFFFFFFFF) == 1)
      {
        *(void *)(v67 + 24) = *(void *)(v67 + 16);
        uint64_t v69 = *(std::__shared_weak_count **)(v67 + 64);
        *(void *)(v67 + 56) = 0;
        *(void *)(v67 + 64) = 0;
        if (v69 && !atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
          std::__shared_weak_count::__release_weak(v69);
        }
        if (*(int *)(v67 + 76) < 1)
        {
          altitude::TexturePager::addPooledTexture((altitude::TexturePager *)__sz, *v64);
          unsigned int v65 = 0;
        }
        else
        {
          *(void *)(*(void *)v67 + 16) = *v64;
          unsigned int v65 = 7;
        }
        atomic_store(v65, (unsigned int *)(v67 + 72));
      }
      v64 += 3;
    }
    while (v66 + 3 != v62);
  }
  if (v63) {
    operator delete(v63);
  }
  if (v38) {
    operator delete(v38);
  }
  unint64_t v70 = *(void *)(__sz + 96);
  uint64_t v71 = *(void *)(__sz + 72);
  unint64_t v72 = (void *)(v71 + 8 * (v70 >> 9));
  if (*(void *)(__sz + 80) == v71)
  {
    unint64_t v74 = 0;
  }
  else
  {
    uint64_t v73 = (char *)(*v72 + 8 * (*(void *)(__sz + 96) & 0x1FFLL));
    unint64_t v74 = (char *)(*(void *)(v71 + (((*(void *)(__sz + 104) + v70) >> 6) & 0x3FFFFFFFFFFFFF8))
                 + 8 * ((*(void *)(__sz + 104) + v70) & 0x1FF));
    if (v73 != v74)
    {
      while (1)
      {
        uint64_t v82 = (unsigned int *)(*(void *)v73 + 72);
        if (!atomic_load(v82)) {
          break;
        }
        unsigned int v84 = atomic_load(v82);
        if (v84 == 7) {
          break;
        }
        v73 += 8;
        if (&v73[-*v72] == (char *)4096)
        {
          uint64_t v85 = (char *)v72[1];
          ++v72;
          uint64_t v73 = v85;
        }
        if (v73 == v74) {
          goto LABEL_121;
        }
      }
    }
    if (v73 != v74)
    {
      uint64_t v75 = v73;
      unint64_t v76 = v72;
      while (1)
      {
        v75 += 8;
        if (&v75[-*v76] == (char *)4096)
        {
          float64x2_t v77 = (char *)v76[1];
          ++v76;
          uint64_t v75 = v77;
        }
        if (v75 == v74) {
          break;
        }
        float64x2_t v78 = (unsigned int *)(*(void *)v75 + 72);
        if (atomic_load(v78))
        {
          unsigned int v80 = atomic_load(v78);
          if (v80 != 7)
          {
            *(void *)uint64_t v73 = *(void *)v75;
            v73 += 8;
            if (&v73[-*v72] == (char *)4096)
            {
              uint64_t v81 = (char *)v72[1];
              ++v72;
              uint64_t v73 = v81;
            }
          }
        }
      }
      unint64_t v74 = v73;
    }
  }
LABEL_121:
  unint64_t v87 = *(void *)(__sz + 96);
  uint64_t v86 = *(void *)(__sz + 104);
  __int16 v88 = v87 + v86;
  uint64_t v89 = *(void *)(__sz + 72);
  uint64_t v90 = *(void *)(__sz + 80);
  uint64_t v91 = (char *)(v89 + 8 * ((v87 + v86) >> 9));
  if (v90 == v89)
  {
    uint64_t v92 = 0;
    if (!v74) {
      goto LABEL_125;
    }
LABEL_123:
    uint64_t v93 = ((v92 - *(void *)v91) >> 3) + ((v91 - (char *)v72) << 6) - ((uint64_t)&v74[-*v72] >> 3);
  }
  else
  {
    uint64_t v92 = *(void *)v91 + 8 * (v88 & 0x1FF);
    if (v74 != (char *)v92) {
      goto LABEL_123;
    }
LABEL_125:
    uint64_t v93 = 0;
  }
  uint64_t v94 = (char *)(v89 + 8 * (v87 >> 9));
  if (v90 == v89)
  {
    uint64_t v95 = 0;
    if (v74) {
      goto LABEL_128;
    }
    goto LABEL_132;
  }
  uint64_t v95 = *(void *)v94 + 8 * (*(void *)(__sz + 96) & 0x1FFLL);
  if (v74 == (char *)v95)
  {
LABEL_132:
    unint64_t v97 = 0;
    unint64_t v98 = (char *)(v89 + 8 * (v87 >> 9));
    goto LABEL_135;
  }
LABEL_128:
  uint64_t v96 = ((uint64_t)&v74[-*v72] >> 3) + (((char *)v72 - v94) << 6);
  unint64_t v97 = v96 - ((v95 - *(void *)v94) >> 3);
  if (v96 == (v95 - *(void *)v94) >> 3)
  {
    unint64_t v74 = (char *)v95;
    unint64_t v98 = v94;
  }
  else if (v96 < 1)
  {
    unint64_t v99 = 511 - v96;
    unint64_t v98 = &v94[-8 * (v99 >> 9)];
    unint64_t v74 = (char *)(*(void *)v98 + 8 * (~(_WORD)v99 & 0x1FF));
  }
  else
  {
    unint64_t v98 = &v94[8 * ((unint64_t)v96 >> 9)];
    unint64_t v74 = (char *)(*(void *)v98 + 8 * (v96 & 0x1FF));
  }
LABEL_135:
  size_t v100 = __sz;
  if (v93 >= 1)
  {
    unint64_t v101 = v86 - v93;
    unint64_t v102 = *(char **)v98;
    uint64_t v103 = v93 + ((uint64_t)&v74[-*(void *)v98] >> 3);
    if (v97 <= v101 >> 1)
    {
      if (v103 < 1)
      {
        uint64_t v105 = &v98[-8 * ((unint64_t)(511 - v103) >> 9)];
        double v106 = *(char **)v105;
        uint64_t v107 = ~(511 - (_WORD)v103) & 0x1FF;
      }
      else
      {
        uint64_t v105 = &v98[8 * ((unint64_t)v103 >> 9)];
        double v106 = *(char **)v105;
        uint64_t v107 = v103 & 0x1FF;
      }
      double v129 = &v106[8 * v107];
      if (v94 == v98)
      {
        if (v74 != (char *)v95)
        {
          for (uint64_t i = v105 - 8; ; i -= 8)
          {
            uint64_t v143 = (v129 - v106) >> 3;
            if ((uint64_t)&v74[-v95] >> 3 < v143) {
              uint64_t v143 = (uint64_t)&v74[-v95] >> 3;
            }
            v74 -= 8 * v143;
            if (v143) {
              memmove(&v129[-8 * v143], v74, 8 * v143);
            }
            if (v74 == (char *)v95) {
              break;
            }
            unint64_t v144 = *(char **)i;
            double v106 = v144;
            double v129 = v144 + 4096;
          }
        }
      }
      else
      {
        if (v102 == v74) {
          goto LABEL_214;
        }
        while (1)
        {
          uint64_t v130 = (v129 - v106) >> 3;
          if ((v74 - v102) >> 3 < v130) {
            uint64_t v130 = (v74 - v102) >> 3;
          }
          v74 -= 8 * v130;
          v129 -= 8 * v130;
          if (v130) {
            memmove(v129, v74, 8 * v130);
          }
          if (v74 == v102) {
            break;
          }
          uint64_t v131 = (char *)*((void *)v105 - 1);
          v105 -= 8;
          double v106 = v131;
          double v129 = v131 + 4096;
        }
        while (1)
        {
          double v106 = *(char **)v105;
          if ((char *)(*(void *)v105 + 4096) == v129)
          {
            float32x4_t v145 = (char *)*((void *)v105 + 1);
            v105 += 8;
            double v106 = v145;
            double v129 = v145;
          }
LABEL_214:
          v98 -= 8;
          if (v98 == v94) {
            break;
          }
          float32x4_t v146 = *(char **)v98;
          uint64_t v147 = (char *)(*(void *)v98 + 4096);
          while (1)
          {
            uint64_t v148 = (v129 - v106) >> 3;
            if ((v147 - v146) >> 3 < v148) {
              uint64_t v148 = (v147 - v146) >> 3;
            }
            v147 -= 8 * v148;
            v129 -= 8 * v148;
            if (v148) {
              memmove(v129, v147, 8 * v148);
            }
            if (v147 == v146) {
              break;
            }
            unint64_t v149 = (char *)*((void *)v105 - 1);
            v105 -= 8;
            double v106 = v149;
            double v129 = v149 + 4096;
          }
        }
        uint64_t v150 = (char *)(*(void *)v94 + 4096);
        if (v150 != (char *)v95)
        {
          for (unint64_t j = v105 - 8; ; j -= 8)
          {
            uint64_t v152 = (v129 - v106) >> 3;
            if ((uint64_t)&v150[-v95] >> 3 < v152) {
              uint64_t v152 = (uint64_t)&v150[-v95] >> 3;
            }
            v150 -= 8 * v152;
            if (v152) {
              memmove(&v129[-8 * v152], v150, 8 * v152);
            }
            if (v150 == (char *)v95) {
              break;
            }
            int v153 = *(char **)j;
            double v106 = v153;
            double v129 = v153 + 4096;
          }
        }
      }
      size_t v100 = __sz;
      uint64_t v154 = *(void *)(__sz + 104) - v93;
      unint64_t v155 = *(void *)(__sz + 96) + v93;
      *(void *)(__sz + 96) = v155;
      *(void *)(__sz + 104) = v154;
      if (v155 >= 0x400)
      {
        uint64_t v156 = *(void ***)(__sz + 72);
        do
        {
          operator delete(*v156);
          uint64_t v156 = (void **)(*(void *)(__sz + 72) + 8);
          *(void *)(__sz + 72) = v156;
          unint64_t v157 = *(void *)(__sz + 96) - 512;
          *(void *)(__sz + 96) = v157;
        }
        while (v157 >= 0x400);
      }
    }
    else
    {
      if (v103 < 1)
      {
        unint64_t v108 = 511 - v103;
        LOWORD(v103) = ~(511 - v103);
        uint64_t v104 = &v98[-8 * (v108 >> 9)];
      }
      else
      {
        uint64_t v104 = &v98[8 * ((unint64_t)v103 >> 9)];
      }
      uint64_t v109 = *(void *)v104;
      unint64_t v110 = (char *)(*(void *)v104 + 8 * (v103 & 0x1FF));
      if (v90 == v89)
      {
        uint64_t v111 = 0;
        if (v104 == v91) {
          goto LABEL_186;
        }
LABEL_144:
        uint64_t v112 = (char *)(v109 + 4096);
        if ((char *)(v109 + 4096) != v110)
        {
          while (1)
          {
            if ((v112 - v110) >> 3 >= (v102 - v74 + 4096) >> 3) {
              uint64_t v113 = (v102 - v74 + 4096) >> 3;
            }
            else {
              uint64_t v113 = (v112 - v110) >> 3;
            }
            if (v113) {
              memmove(v74, v110, 8 * v113);
            }
            v110 += 8 * v113;
            if (v110 == v112) {
              break;
            }
            unint64_t v114 = (char *)*((void *)v98 + 1);
            v98 += 8;
            unint64_t v102 = v114;
            unint64_t v74 = v114;
          }
          v74 += 8 * v113;
          unint64_t v102 = *(char **)v98;
          if ((char *)(*(void *)v98 + 4096) == v74)
          {
            uint64_t v115 = (char *)*((void *)v98 + 1);
            v98 += 8;
            unint64_t v102 = v115;
            unint64_t v74 = v115;
          }
        }
        for (uint64_t k = v104 + 8; k != v91; k += 8)
        {
          uint64_t v117 = 0;
          uint64_t v118 = *(void *)k;
          while (1)
          {
            if ((4096 - 8 * v117) >> 3 >= (v102 - v74 + 4096) >> 3) {
              uint64_t v119 = (v102 - v74 + 4096) >> 3;
            }
            else {
              uint64_t v119 = (4096 - 8 * v117) >> 3;
            }
            if (v119) {
              memmove(v74, (const void *)(v118 + 8 * v117), 8 * v119);
            }
            v117 += v119;
            if (v117 == 512) {
              break;
            }
            uint64_t v120 = (char *)*((void *)v98 + 1);
            v98 += 8;
            unint64_t v102 = v120;
            unint64_t v74 = v120;
          }
          v74 += 8 * v119;
          unint64_t v102 = *(char **)v98;
          if ((char *)(*(void *)v98 + 4096) == v74)
          {
            uint64_t v121 = (char *)*((void *)v98 + 1);
            v98 += 8;
            unint64_t v102 = v121;
            unint64_t v74 = v121;
          }
        }
        uint64_t v122 = *(char **)v91;
        if (*(void *)v91 != v111)
        {
          uint64_t v125 = *(char **)v98;
          unint64_t v124 = (void **)(v98 + 8);
          unsigned int v123 = v125;
          while (1)
          {
            uint64_t v126 = (v123 - v74 + 4096) >> 3;
            if ((v111 - (uint64_t)v122) >> 3 >= v126) {
              uint64_t v127 = v126;
            }
            else {
              uint64_t v127 = (v111 - (uint64_t)v122) >> 3;
            }
            if (v127) {
              memmove(v74, v122, 8 * v127);
            }
            v122 += 8 * v127;
            if (v122 == (char *)v111) {
              break;
            }
            uint64_t v128 = (char *)*v124++;
            unsigned int v123 = v128;
            unint64_t v74 = v128;
          }
        }
      }
      else
      {
        uint64_t v111 = *(void *)v91 + 8 * (v88 & 0x1FF);
        if (v104 != v91) {
          goto LABEL_144;
        }
LABEL_186:
        if (v110 != (char *)v111)
        {
          for (unint64_t m = (void **)(v98 + 8); ; ++m)
          {
            if ((v111 - (uint64_t)v110) >> 3 >= (v102 - v74 + 4096) >> 3) {
              uint64_t v133 = (v102 - v74 + 4096) >> 3;
            }
            else {
              uint64_t v133 = (v111 - (uint64_t)v110) >> 3;
            }
            if (v133) {
              memmove(v74, v110, 8 * v133);
            }
            v110 += 8 * v133;
            if (v110 == (char *)v111) {
              break;
            }
            uint64_t v134 = (char *)*m;
            unint64_t v102 = v134;
            unint64_t v74 = v134;
          }
        }
      }
      size_t v100 = __sz;
      uint64_t v136 = *(void *)(__sz + 72);
      uint64_t v135 = *(void *)(__sz + 80);
      if (v135 == v136) {
        uint64_t v137 = 0;
      }
      else {
        uint64_t v137 = ((v135 - v136) << 6) - 1;
      }
      uint64_t v138 = *(void *)(__sz + 96);
      uint64_t v139 = *(void *)(__sz + 104) - v93;
      *(void *)(__sz + 104) = v139;
      if ((unint64_t)(v137 - (v139 + v138)) >= 0x400)
      {
        do
        {
          operator delete(*(void **)(v135 - 8));
          uint64_t v140 = *(void *)(__sz + 72);
          uint64_t v135 = *(void *)(__sz + 80) - 8;
          *(void *)(__sz + 80) = v135;
          if (v135 == v140) {
            uint64_t v141 = 0;
          }
          else {
            uint64_t v141 = ((v135 - v140) << 6) - 1;
          }
        }
        while ((unint64_t)(v141 - (*(void *)(__sz + 104) + *(void *)(__sz + 96))) > 0x3FF);
      }
    }
  }
  uint64_t v158 = *(void *)(v100 + 40);
  uint64_t v159 = (void *)v100;
  if (*(void *)(v100 + 48) != v158)
  {
    uint64_t v160 = 0;
    unsigned int v161 = 0;
    while (2)
    {
      uint64_t v168 = *(unsigned int **)(v158 + 8 * v160);
      if (atomic_load(v168 + 18))
      {
        unsigned int v170 = atomic_load(v168 + 18);
        if (v170 != 7) {
          goto LABEL_239;
        }
      }
      if ((int)v168[19] <= 0)
      {
        unsigned int v186 = (std::__shared_weak_count *)*((void *)v168 + 8);
        if (v186 && !atomic_fetch_add(&v186->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v186->__on_zero_shared)(v186);
          std::__shared_weak_count::__release_weak(v186);
        }
        unsigned int v187 = (void *)*((void *)v168 + 2);
        if (v187)
        {
          *((void *)v168 + 3) = v187;
          operator delete(v187);
        }
        MEMORY[0x1A6239270](v168, 0x10A0C40358E639CLL);
        *(void *)(v159[5] + 8 * v160) = *(void *)(v159[6] - 8);
        v159[6] -= 8;
        goto LABEL_240;
      }
      uint64_t v171 = *(void *)v168;
      uint64_t v172 = *(void *)(*(void *)v168 + 88);
      unsigned int v173 = atomic_load(v168 + 18);
      if (v172 != v406)
      {
        if (v173 == 7)
        {
          int v188 = *(ggl::Texture2D **)(v171 + 16);
          if (v188)
          {
            if (v188 != *(ggl::Texture2D **)(v171 + 24))
            {
              altitude::TexturePager::addPooledTexture((altitude::TexturePager *)v159, v188);
              *(void *)(v171 + 16) = *(void *)(v171 + 24);
              atomic_store(0, v168 + 18);
            }
          }
        }
        goto LABEL_239;
      }
      if (v173)
      {
        unsigned int v174 = atomic_load(v168 + 18);
        if (v174 != 7) {
          goto LABEL_239;
        }
      }
      uint64_t v175 = *(void *)(*(void *)v168 + 16);
      if (v175)
      {
        if (v175 != *(void *)(*(void *)v168 + 24)) {
          goto LABEL_239;
        }
      }
      atomic_store(1u, v168 + 18);
      uint64_t v176 = (char *)v159[10];
      uint64_t v165 = (char *)v159[9];
      uint64_t v177 = v176 - v165;
      if (v176 == v165) {
        uint64_t v178 = 0;
      }
      else {
        uint64_t v178 = ((v176 - v165) << 6) - 1;
      }
      unint64_t v179 = v159[12];
      uint64_t v166 = v159[13];
      unint64_t v167 = v166 + v179;
      if (v178 != v166 + v179) {
        goto LABEL_238;
      }
      if (v179 < 0x200)
      {
        uint64_t v180 = v177 >> 3;
        int v181 = (char *)v159[11];
        unint64_t v182 = (char *)v159[8];
        uint64_t v183 = v181 - v182;
        if (v177 >> 3 < (unint64_t)((v181 - v182) >> 3))
        {
          uint64_t v184 = operator new(0x1000uLL);
          uint64_t v185 = v184;
          if (v181 != v176)
          {
            *(void *)uint64_t v176 = v184;
            uint64_t v159 = (void *)__sz;
            *(void *)(__sz + 80) += 8;
            goto LABEL_237;
          }
          unint64_t v203 = v165;
          if (v182 != v165) {
            goto LABEL_346;
          }
          if (v176 == v165) {
            unint64_t v204 = 1;
          }
          else {
            unint64_t v204 = v183 >> 2;
          }
          if (!(v204 >> 61))
          {
            double v205 = (char *)operator new(8 * v204);
            unint64_t v206 = (v204 + 3) >> 2;
            unint64_t v203 = &v205[8 * v206];
            uint64_t v207 = &v205[8 * v204];
            uint64_t v208 = v203;
            if (v176 != v165)
            {
              uint64_t v208 = &v203[(v176 - v182) & 0xFFFFFFFFFFFFFFF8];
              unint64_t v209 = v176 - v182 - 8;
              uint64_t v210 = &v205[8 * v206];
              uint64_t v211 = v165;
              if (v209 > 0x37)
              {
                uint64_t v212 = 8 * v206;
                uint64_t v210 = &v205[8 * v206];
                uint64_t v211 = v165;
                if ((unint64_t)(v210 - v182) >= 0x20)
                {
                  uint64_t v213 = (v209 >> 3) + 1;
                  uint64_t v214 = 8 * (v213 & 0x3FFFFFFFFFFFFFFCLL);
                  uint64_t v210 = &v203[v214];
                  uint64_t v215 = (long long *)(v165 + 16);
                  unint64_t v216 = &v205[v212 + 16];
                  uint64_t v217 = v213 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v218 = *v215;
                    *((_OWORD *)v216 - 1) = *(v215 - 1);
                    *(_OWORD *)unint64_t v216 = v218;
                    v215 += 2;
                    v216 += 32;
                    v217 -= 4;
                  }
                  while (v217);
                  if (v213 == (v213 & 0x3FFFFFFFFFFFFFFCLL))
                  {
                    *(void *)(__sz + 64) = v205;
                    *(void *)(__sz + 72) = v203;
                    *(void *)(__sz + 80) = v208;
                    *(void *)(__sz + 88) = v207;
                    goto LABEL_345;
                  }
                  uint64_t v211 = &v165[v214];
                }
              }
              do
              {
                uint64_t v260 = *(void *)v211;
                v211 += 8;
                *(void *)uint64_t v210 = v260;
                v210 += 8;
              }
              while (v210 != v208);
            }
            *(void *)(__sz + 64) = v205;
            *(void *)(__sz + 72) = v203;
            *(void *)(__sz + 80) = v208;
            *(void *)(__sz + 88) = v207;
            if (v165)
            {
LABEL_345:
              operator delete(v165);
              unint64_t v203 = *(char **)(__sz + 72);
            }
LABEL_346:
            *((void *)v203 - 1) = v185;
            size_t v261 = __sz;
            double v262 = *(char **)(__sz + 72);
            double v263 = *(char **)(__sz + 80);
            *(void *)(__sz + 72) = v262 - 8;
            uint64_t v264 = *((void *)v262 - 1);
            *(void *)(__sz + 72) = v262;
            if (v263 != *(char **)(__sz + 88)) {
              goto LABEL_370;
            }
            double v265 = *(char **)(__sz + 64);
            if (v262 > v265)
            {
              uint64_t v266 = (v262 - v265) >> 3;
              if (v266 >= -1) {
                uint64_t v267 = v266 + 1;
              }
              else {
                uint64_t v267 = v266 + 2;
              }
              uint64_t v268 = v267 >> 1;
              double v269 = &v262[-8 * (v267 >> 1)];
              int64_t v270 = v263 - v262;
              if (v263 == v262)
              {
                size_t v261 = __sz;
              }
              else
              {
                memmove(&v262[-8 * (v267 >> 1)], v262, v263 - v262);
                size_t v261 = __sz;
                double v262 = *(char **)(__sz + 72);
              }
              double v263 = &v269[v270];
              *(void *)(v261 + 72) = &v262[-8 * v268];
              *(void *)(v261 + 80) = &v269[v270];
              goto LABEL_370;
            }
            unint64_t v271 = v263 == v265 ? 1 : (v263 - v265) >> 2;
            if (!(v271 >> 61))
            {
              long long v272 = operator new(8 * v271);
              unint64_t v273 = v271 >> 2;
              long long v274 = &v272[8 * (v271 >> 2)];
              long long v275 = v274;
              if (v263 != v262)
              {
                long long v275 = &v274[(v263 - v262) & 0xFFFFFFFFFFFFFFF8];
                unint64_t v276 = v263 - v262 - 8;
                if (v276 >= 0x38)
                {
                  uint64_t v278 = 8 * v273;
                  unint64_t v279 = &v272[8 * v273] - v262;
                  float64x2_t v277 = &v272[8 * (v271 >> 2)];
                  if (v279 < 0x20) {
                    goto LABEL_367;
                  }
                  uint64_t v280 = (v276 >> 3) + 1;
                  uint64_t v281 = 8 * (v280 & 0x3FFFFFFFFFFFFFFCLL);
                  float64x2_t v277 = &v274[v281];
                  float64x2_t v282 = (long long *)(v262 + 16);
                  float64x2_t v283 = &v272[v278 + 16];
                  uint64_t v284 = v280 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    long long v285 = *v282;
                    *(v283 - 1) = *(v282 - 1);
                    _OWORD *v283 = v285;
                    v282 += 2;
                    v283 += 2;
                    v284 -= 4;
                  }
                  while (v284);
                  if (v280 != (v280 & 0x3FFFFFFFFFFFFFFCLL))
                  {
                    v262 += v281;
                    goto LABEL_367;
                  }
                }
                else
                {
                  float64x2_t v277 = &v272[8 * (v271 >> 2)];
                  do
                  {
LABEL_367:
                    uint64_t v286 = *(void *)v262;
                    v262 += 8;
                    *(void *)float64x2_t v277 = v286;
                    v277 += 8;
                  }
                  while (v277 != v275);
                }
              }
              size_t v261 = __sz;
              *(void *)(__sz + 64) = v272;
              *(void *)(__sz + 72) = v274;
              *(void *)(__sz + 80) = v275;
              *(void *)(__sz + 88) = &v272[8 * v271];
              double v263 = v275;
              if (v265)
              {
                operator delete(v265);
                double v263 = *(char **)(__sz + 80);
              }
LABEL_370:
              *(void *)double v263 = v264;
              *(void *)(v261 + 80) += 8;
              uint64_t v159 = (void *)v261;
LABEL_237:
              uint64_t v165 = (char *)v159[9];
              uint64_t v166 = v159[13];
              unint64_t v167 = v159[12] + v166;
LABEL_238:
              *(void *)(*(void *)&v165[(v167 >> 6) & 0x3FFFFFFFFFFFFF8] + 8 * (v167 & 0x1FF)) = v168;
              v159[13] = v166 + 1;
LABEL_239:
              ++v161;
LABEL_240:
              uint64_t v160 = v161;
              uint64_t v158 = v159[5];
              if (v161 >= (unint64_t)((v159[6] - v158) >> 3)) {
                goto LABEL_371;
              }
              continue;
            }
          }
LABEL_533:
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        if (v181 == v182) {
          unint64_t v189 = 1;
        }
        else {
          unint64_t v189 = v183 >> 2;
        }
        if (v189 >> 61) {
          goto LABEL_533;
        }
        uint64_t v190 = (char *)operator new(8 * v189);
        uint64_t v191 = operator new(0x1000uLL);
        uint64_t v192 = &v190[8 * v180];
        uint64_t v193 = &v190[8 * v189];
        if (v180 == v189)
        {
          if (v177 < 1)
          {
            if (v176 == v165) {
              unint64_t v228 = 1;
            }
            else {
              unint64_t v228 = v177 >> 2;
            }
            if (v228 >> 61) {
              goto LABEL_533;
            }
            uint64_t v229 = v191;
            uint64_t v192 = (char *)operator new(8 * v228);
            uint64_t v193 = &v192[8 * v228];
            operator delete(v190);
            uint64_t v165 = *(char **)(__sz + 72);
            uint64_t v176 = *(char **)(__sz + 80);
            uint64_t v190 = v192;
            uint64_t v191 = v229;
          }
          else
          {
            unint64_t v194 = v180 + 2;
            if (v180 >= -1) {
              unint64_t v194 = v180 + 1;
            }
            v192 -= 8 * (v194 >> 1);
          }
        }
        *(void *)uint64_t v192 = v191;
        uint64_t v230 = v192 + 8;
        if (v176 == v165)
        {
LABEL_307:
          unsigned __int8 v231 = *(void **)(__sz + 64);
          *(void *)(__sz + 64) = v190;
          *(void *)(__sz + 72) = v192;
          uint64_t v159 = (void *)__sz;
          *(void *)(__sz + 80) = v230;
          *(void *)(__sz + 88) = v193;
          if (v231) {
            operator delete(v231);
          }
          goto LABEL_237;
        }
        while (2)
        {
          if (v192 != v190)
          {
            __n128 v232 = v192;
            float64_t v233 = v230;
            goto LABEL_310;
          }
          if (v230 < v193)
          {
            uint64_t v235 = (v193 - v230) >> 3;
            if (v235 >= -1) {
              unint64_t v236 = v235 + 1;
            }
            else {
              unint64_t v236 = v235 + 2;
            }
            float64_t v233 = &v230[8 * (v236 >> 1)];
            __n128 v232 = &v192[8 * (v236 >> 1)];
            if (v230 == v192)
            {
              uint64_t v190 = v230;
            }
            else
            {
              memmove(&v192[8 * (v236 >> 1)], v192, v230 - v192);
              uint64_t v190 = v192;
            }
LABEL_310:
            uint64_t v234 = *((void *)v176 - 1);
            v176 -= 8;
            *((void *)v232 - 1) = v234;
            uint64_t v192 = v232 - 8;
            uint64_t v230 = v233;
            if (v176 == *(char **)(__sz + 72)) {
              goto LABEL_307;
            }
            continue;
          }
          break;
        }
        if (v193 == v192) {
          unint64_t v237 = 1;
        }
        else {
          unint64_t v237 = (v193 - v192) >> 2;
        }
        if (v237 >> 61) {
          goto LABEL_533;
        }
        uint64_t v238 = (char *)operator new(8 * v237);
        uint64_t v190 = v238;
        unint64_t v239 = (v237 + 3) >> 2;
        __n128 v232 = &v238[8 * v239];
        float64_t v233 = v232;
        int64_t v240 = v230 - v192;
        if (v230 != v192)
        {
          float64_t v233 = &v232[v240 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v241 = v240 - 8;
          uint64_t v242 = &v238[8 * v239];
          id v243 = v192;
          if (v241 < 0x38
            || (v244 = 8 * v239, uint64_t v242 = &v238[8 * v239], v243 = v192, (unint64_t)(v242 - v192) < 0x20))
          {
            do
            {
LABEL_329:
              uint64_t v251 = *(void *)v243;
              v243 += 8;
              *(void *)uint64_t v242 = v251;
              v242 += 8;
            }
            while (v242 != v233);
          }
          else
          {
            uint64_t v245 = (v241 >> 3) + 1;
            uint64_t v246 = 8 * (v245 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v242 = &v232[v246];
            unint64_t v247 = (long long *)(v192 + 16);
            id v248 = &v238[v244 + 16];
            uint64_t v249 = v245 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v250 = *v247;
              *((_OWORD *)v248 - 1) = *(v247 - 1);
              *(_OWORD *)id v248 = v250;
              v247 += 2;
              v248 += 32;
              v249 -= 4;
            }
            while (v249);
            if (v245 != (v245 & 0x3FFFFFFFFFFFFFFCLL))
            {
              id v243 = &v192[v246];
              goto LABEL_329;
            }
          }
        }
        uint64_t v193 = &v238[8 * v237];
        operator delete(v192);
        goto LABEL_310;
      }
      break;
    }
    v159[12] = v179 - 512;
    int v162 = v159;
    uint64_t v163 = v165 + 8;
    uint64_t v164 = *(void *)v165;
    v162[9] = v165 + 8;
    if ((char *)v162[11] != v176)
    {
LABEL_236:
      *(void *)uint64_t v176 = v164;
      v162[10] += 8;
      uint64_t v159 = v162;
      goto LABEL_237;
    }
    unint64_t v195 = (char *)v162[8];
    if (v163 > v195)
    {
      uint64_t v196 = (v163 - v195) >> 3;
      if (v196 >= -1) {
        uint64_t v197 = v196 + 1;
      }
      else {
        uint64_t v197 = v196 + 2;
      }
      uint64_t v198 = v197 >> 1;
      int v199 = &v163[-8 * (v197 >> 1)];
      int64_t v200 = v176 - v163;
      if (v176 == v163)
      {
        double v202 = v176;
        double v201 = (void *)__sz;
      }
      else
      {
        memmove(&v163[-8 * (v197 >> 1)], v163, v176 - v163);
        double v201 = (void *)__sz;
        double v202 = *(char **)(__sz + 72);
      }
      uint64_t v176 = &v199[v200];
      v201[9] = &v202[-8 * v198];
      v201[10] = &v199[v200];
      int v162 = v201;
      goto LABEL_236;
    }
    unint64_t v219 = (v176 - v195) >> 2;
    if (v176 == v195) {
      unint64_t v219 = 1;
    }
    if (v219 >> 61) {
      goto LABEL_533;
    }
    unint64_t v220 = v219 >> 2;
    uint64_t v221 = 8 * v219;
    char v222 = (char *)operator new(8 * v219);
    unint64_t v223 = &v222[8 * v220];
    int64_t v225 = v176 - v163;
    BOOL v224 = v176 == v163;
    uint64_t v176 = v223;
    if (!v224)
    {
      uint64_t v176 = &v223[v225 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v226 = v225 - 8;
      if ((unint64_t)(v225 - 8) >= 0x38)
      {
        uint64_t v227 = &v222[8 * v220];
        if ((unint64_t)(v227 - v163) < 0x20) {
          goto LABEL_339;
        }
        uint64_t v252 = (v226 >> 3) + 1;
        uint64_t v253 = 8 * (v252 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v227 = &v223[v253];
        float64x2_t v254 = (long long *)(v165 + 24);
        float64x2_t v255 = &v222[8 * v220 + 16];
        uint64_t v256 = v252 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v257 = *v254;
          *((_OWORD *)v255 - 1) = *(v254 - 1);
          *(_OWORD *)float64x2_t v255 = v257;
          v254 += 2;
          v255 += 32;
          v256 -= 4;
        }
        while (v256);
        if (v252 != (v252 & 0x3FFFFFFFFFFFFFFCLL))
        {
          v163 += v253;
          goto LABEL_339;
        }
      }
      else
      {
        uint64_t v227 = &v222[8 * v220];
        do
        {
LABEL_339:
          uint64_t v258 = *(void *)v163;
          v163 += 8;
          *(void *)uint64_t v227 = v258;
          v227 += 8;
        }
        while (v227 != v176);
      }
    }
    size_t v259 = &v222[v221];
    int v162 = (void *)__sz;
    *(void *)(__sz + 64) = v222;
    *(void *)(__sz + 72) = v223;
    *(void *)(__sz + 80) = v176;
    *(void *)(__sz + 88) = v259;
    if (v195)
    {
      operator delete(v195);
      uint64_t v176 = *(char **)(__sz + 80);
    }
    goto LABEL_236;
  }
LABEL_371:
  if (*((unsigned char *)v159 + 376))
  {
    uint64_t v287 = v159[15];
    uint64_t v288 = v159[16];
    if (v287 != v288)
    {
      do
      {
        uint64_t v289 = *(void *)(v287 + 8);
        if (v289) {
          (*(void (**)(uint64_t))(*(void *)v289 + 8))(v289);
        }
        v287 += 16;
      }
      while (v287 != v288);
      uint64_t v287 = v159[15];
    }
    v159[16] = v287;
    *((unsigned char *)v159 + 376) = 0;
  }
  uint64_t v290 = v159[9];
  if (v159[10] == v290
    || (unint64_t v291 = v159[12],
        float64x2_t v292 = (void *)(v290 + 8 * (v291 >> 9)),
        uint64_t v293 = *v292 + 8 * (v291 & 0x1FF),
        uint64_t v294 = *(void *)(v290 + (((v159[13] + v291) >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * ((v159[13] + v291) & 0x1FF),
        v293 == v294))
  {
    unint64_t v317 = 0;
    goto LABEL_463;
  }
  float64x2_t v295 = 0;
  v296 = 0;
  uint64_t v297 = 0;
  while (2)
  {
    unsigned int v298 = atomic_load((unsigned int *)(*(void *)v293 + 72));
    if (v298 == 1)
    {
      if (v296 < v297)
      {
        *(void *)v296 = *(void *)v293;
        v296 += 8;
        goto LABEL_402;
      }
      int64_t v299 = v296 - v295;
      uint64_t v300 = (v296 - v295) >> 3;
      unint64_t v301 = v300 + 1;
      v408 = v295;
      if ((unint64_t)(v300 + 1) >> 61) {
        abort();
      }
      if ((v297 - v295) >> 2 > v301) {
        unint64_t v301 = (v297 - v295) >> 2;
      }
      if ((unint64_t)(v297 - v295) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v302 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v302 = v301;
      }
      if (v302)
      {
        if (v302 >> 61) {
          goto LABEL_533;
        }
        uint64_t v303 = (char *)operator new(8 * v302);
        long long v304 = v296;
      }
      else
      {
        long long v304 = v296;
        uint64_t v303 = 0;
      }
      float64x2_t v295 = &v303[8 * v300];
      *(void *)float64x2_t v295 = *(void *)v293;
      v296 = v295 + 8;
      long long v305 = v408;
      if (v304 != v408)
      {
        float32x2_t v306 = v304;
        __int16 v307 = v304 - 8;
        unint64_t v308 = v307 - v408;
        if ((unint64_t)(v307 - v408) < 0x168
          || &v303[v299 - 8 - (v308 & 0xFFFFFFFFFFFFFFF8)] > &v303[v299 - 8]
          || &v307[-(v308 & 0xFFFFFFFFFFFFFFF8)] > v307
          || (unint64_t)(v307 - &v303[v299] + 8) < 0x20)
        {
          v309 = v306;
          long long v305 = v408;
        }
        else
        {
          uint64_t v312 = (v308 >> 3) + 1;
          v309 = &v306[-8 * (v312 & 0x3FFFFFFFFFFFFFFCLL)];
          float64x2_t v313 = &v303[8 * v300 - 16];
          uint64_t v314 = v306 - 16;
          uint64_t v315 = v312 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v316 = *(_OWORD *)v314;
            *((_OWORD *)v313 - 1) = *((_OWORD *)v314 - 1);
            *(_OWORD *)float64x2_t v313 = v316;
            v313 -= 32;
            v314 -= 32;
            v315 -= 4;
          }
          while (v315);
          v295 -= 8 * (v312 & 0x3FFFFFFFFFFFFFFCLL);
          long long v305 = v408;
          if (v312 == (v312 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_400;
          }
        }
        do
        {
          uint64_t v310 = *((void *)v309 - 1);
          v309 -= 8;
          *((void *)v295 - 1) = v310;
          v295 -= 8;
        }
        while (v309 != v305);
      }
LABEL_400:
      uint64_t v297 = &v303[8 * v302];
      if (v305) {
        operator delete(v305);
      }
LABEL_402:
      atomic_store(2u, (unsigned int *)(*(void *)v293 + 72));
    }
    v293 += 8;
    if (v293 - *v292 == 4096)
    {
      uint64_t v311 = v292[1];
      ++v292;
      uint64_t v293 = v311;
    }
    if (v293 != v294) {
      continue;
    }
    break;
  }
  if (v296 != v295)
  {
    v409 = v295;
    v318 = v295;
    while (1)
    {
      v410 = v296;
      size_t v319 = *(unsigned int **)v318;
      double v320 = **(void ***)v318;
      uint64_t v321 = v320[5];
      int v322 = *(_DWORD *)(v321 + 4);
      if (v322 == 2)
      {
LABEL_419:
        uint64_t v323 = (uint64_t)(*(void *)(v321 + 16) - *(void *)(v321 + 8)) >> 4;
        atomic_store(v323, v319 + 2);
        v324 = *(unsigned int **)v318;
        size_t v325 = (unint64_t *)(*(void *)v318 + 16);
        unint64_t v326 = *v325;
        uint64_t v327 = v323;
        v413[0] = 0.0;
        unint64_t v328 = (uint64_t)(*((void *)v324 + 3) - v326) >> 3;
        if (v323 <= v328)
        {
          if (v323 < v328) {
            *((void *)v324 + 3) = v326 + 8 * v323;
          }
        }
        else
        {
          std::vector<__CVBuffer *>::__append(v325, v323 - v328, v413);
        }
        if (v323)
        {
          uint64_t v336 = 0;
          while (1)
          {
            atomic_fetch_add((atomic_uint *volatile)(__sz + 320), 1u);
            uint64_t v337 = *(void *)(v320[5] + 8);
            long long v338 = *(_OWORD *)(v337 + 16 * v336);
            v339 = *(std::__shared_weak_count **)(v337 + 16 * v336 + 8);
            if (v339) {
              atomic_fetch_add_explicit(&v339->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            long long v411 = v338;
            if (md::HardwareFigDecoder::instance(void)::once != -1)
            {
              dispatch_once(&md::HardwareFigDecoder::instance(void)::once, &__block_literal_global_25645);
              *(void *)&long long v338 = v411;
            }
            size_t v340 = (uint64_t *)md::HardwareFigDecoder::instance(void)::_singleton;
            uint64_t v341 = *(void *)(v338 + 8);
            uint64_t v342 = *(void *)(v338 + 16);
            uint64_t v343 = *(unsigned int **)v318;
            if (v339) {
              atomic_fetch_add_explicit(&v339->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            float64x2_t v423 = 0;
            id v344 = (char *)operator new(0x30uLL);
            *(void *)id v344 = &unk_1EF57D128;
            *((void *)v344 + 1) = __sz;
            *((void *)v344 + 2) = v343;
            *(_OWORD *)(v344 + 24) = v411;
            *((_DWORD *)v344 + 10) = v336;
            float64x2_t v423 = v344;
            md::HardwareFigDecoder::decodeAsync(*v340, v341, v342, v422);
            if (v423 != v422) {
              break;
            }
            (*(void (**)(void *))(v422[0] + 32))(v422);
            if (v339) {
              goto LABEL_440;
            }
LABEL_427:
            if (v327 == ++v336) {
              goto LABEL_415;
            }
          }
          if (v423) {
            (*(void (**)(void))(*v423 + 40))();
          }
          if (!v339) {
            goto LABEL_427;
          }
LABEL_440:
          if (!atomic_fetch_add(&v339->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v339->__on_zero_shared)(v339);
            std::__shared_weak_count::__release_weak(v339);
          }
          goto LABEL_427;
        }
        goto LABEL_415;
      }
      if (v322 == 1) {
        break;
      }
      if (!v322) {
        goto LABEL_419;
      }
LABEL_415:
      v318 += 8;
      v296 = v410;
      if (v318 == v410)
      {
        uint64_t v159 = (void *)__sz;
        unint64_t v317 = v409;
        goto LABEL_463;
      }
    }
    BOOL v329 = v319[11] != 14;
    uint64_t v330 = (uint64_t)(*(void *)(v321 + 16) - *(void *)(v321 + 8)) >> 4;
    atomic_store(v330, v319 + 2);
    double v331 = *(unsigned int **)v318;
    int32x2_t v332 = (unint64_t *)(*(void *)v318 + 16);
    unint64_t v333 = *v332;
    uint64_t v334 = v330;
    v413[0] = 0.0;
    unint64_t v335 = (uint64_t)(*((void *)v331 + 3) - v333) >> 3;
    if (v330 <= v335)
    {
      if (v330 < v335) {
        *((void *)v331 + 3) = v333 + 8 * v330;
      }
    }
    else
    {
      std::vector<__CVBuffer *>::__append(v332, v330 - v335, v413);
    }
    if (!v330) {
      goto LABEL_415;
    }
    uint64_t v345 = 0;
    unsigned int v346 = 2 * v329;
    uint64_t v347 = MEMORY[0x1E4F143A8];
    while (2)
    {
      atomic_fetch_add((atomic_uint *volatile)(__sz + 320), 1u);
      uint64_t v348 = *(void *)(v320[5] + 8);
      long long v349 = *(_OWORD *)(v348 + 16 * v345);
      v350 = *(std::__shared_weak_count **)(v348 + 16 * v345 + 8);
      if (v350) {
        atomic_fetch_add_explicit(&v350->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v351 = v320[7];
      double v352 = *(const void **)(v351 + 8);
      int32x2_t v353 = *(opaqueCMSampleBuffer **)(v351 + 16);
      uint64_t v354 = v320[9];
      uint64_t v355 = *(void *)(v354 + 8);
      uint64_t v356 = *(void *)(v354 + 16);
      uint64_t v357 = *(void *)(__sz + 400);
      int32x2_t v358 = *(void **)(v349 + 8);
      v359 = *(opaqueCMFormatDescription **)(v349 + 16);
      blocuint64_t k = v347;
      uint64_t block_8 = 3321888768;
      float64x2_t v416 = ___ZN8altitude12TexturePager25processTextureDecodeQueueEv_block_invoke;
      double v417 = &__block_descriptor_72_ea8_32c64_ZTSKZN8altitude12TexturePager25processTextureDecodeQueueEvE3__1_e24_v20__0____CVBuffer__8i16l;
      uint64_t v360 = *(unsigned int **)v318;
      if (v350)
      {
        atomic_fetch_add_explicit(&v350->__shared_owners_, 1uLL, memory_order_relaxed);
        size_t v418 = __sz;
        double v419 = v360;
        long long v420 = v349;
        atomic_fetch_add_explicit(&v350->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      else
      {
        size_t v418 = __sz;
        double v419 = v360;
        long long v420 = v349;
      }
      int v421 = v345;
      md::HardwareVideoDecodingSession::decode(v357, v346, v352, v353, v355, v356, v358, v359, 1u, &block);
      if (v350 && !atomic_fetch_add(&v350->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v350->__on_zero_shared)(v350);
        std::__shared_weak_count::__release_weak(v350);
        size_t v361 = (std::__shared_weak_count *)*((void *)&v420 + 1);
        if (*((void *)&v420 + 1)) {
          goto LABEL_455;
        }
      }
      else
      {
        size_t v361 = (std::__shared_weak_count *)*((void *)&v420 + 1);
        if (*((void *)&v420 + 1))
        {
LABEL_455:
          if (!atomic_fetch_add(&v361->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v361->__on_zero_shared)(v361);
            std::__shared_weak_count::__release_weak(v361);
          }
        }
      }
      if (v350 && !atomic_fetch_add(&v350->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v350->__on_zero_shared)(v350);
        std::__shared_weak_count::__release_weak(v350);
      }
      if (v334 == ++v345) {
        goto LABEL_415;
      }
      continue;
    }
  }
  unint64_t v317 = v296;
  uint64_t v159 = (void *)__sz;
LABEL_463:
  double v362 = v159;
  int32x2_t v363 = (std::mutex *)(v159 + 21);
  std::mutex::lock(v363);
  unint64_t v365 = (uint64_t *)v362[18];
  uint64_t v364 = (uint64_t *)v362[19];
  v362[18] = 0;
  v362[19] = 0;
  v362[20] = 0;
  std::mutex::unlock(v363);
  if (v365 != v364)
  {
    unsigned int v366 = v365;
    do
    {
      uint64_t v368 = *v366;
      uint64_t v369 = v366[2];
      if (v369) {
        *(void *)(*(void *)(v368 + 16) + 8 * *((unsigned int *)v366 + 2)) = v369;
      }
      if (atomic_fetch_add((atomic_uint *volatile)(v368 + 8), 0xFFFFFFFF) == 1)
      {
        if (atomic_load((unsigned int *)(v368 + 8)))
        {
          unint64_t v371 = 0;
          BOOL v372 = 1;
          do
          {
            while (!v372)
            {
              BOOL v372 = 0;
              ++v371;
              unint64_t v373 = atomic_load((unsigned int *)(v368 + 8));
              if (v371 >= v373) {
                goto LABEL_480;
              }
            }
            uint64_t v374 = *(void *)(*(void *)(v368 + 16) + 8 * v371);
            BOOL v372 = v374 != 0;
            ++v371;
            unint64_t v375 = atomic_load((unsigned int *)(v368 + 8));
          }
          while (v371 < v375);
          if (!v374) {
            goto LABEL_480;
          }
        }
        if (*(int *)(v368 + 76) < 1)
        {
LABEL_480:
          id v367 = *(CVPixelBufferRef **)(v368 + 16);
          BOOL v376 = *(CVPixelBufferRef **)(v368 + 24);
          if (v367 != v376)
          {
            do
            {
              if (*v367) {
                CVPixelBufferRelease(*v367);
              }
              ++v367;
            }
            while (v367 != v376);
            id v367 = *(CVPixelBufferRef **)(v368 + 16);
          }
          *(void *)(v368 + 24) = v367;
          atomic_store(0, (unsigned int *)(v368 + 72));
        }
        else if (*(unsigned char *)(v368 + 40))
        {
          atomic_store(3u, (unsigned int *)(v368 + 72));
        }
        else
        {
          atomic_store(5u, (unsigned int *)(v368 + 72));
        }
      }
      v366 += 3;
    }
    while (v366 != v364);
  }
  if (v365) {
    operator delete(v365);
  }
  if (v317) {
    operator delete(v317);
  }
  uint64_t v377 = *(void *)(__sz + 72);
  if (*(void *)(__sz + 80) != v377)
  {
    unint64_t v378 = *(void *)(__sz + 96);
    unint64_t v379 = (void *)(v377 + 8 * (v378 >> 9));
    uint64_t v380 = *v379 + 8 * (v378 & 0x1FF);
    uint64_t v381 = *(void *)(v377 + (((*(void *)(__sz + 104) + v378) >> 6) & 0x3FFFFFFFFFFFFF8))
         + 8 * ((*(void *)(__sz + 104) + v378) & 0x1FF);
    if (v380 != v381)
    {
      unint64_t v382 = 0;
      size_t v383 = 0;
      double v384 = 0;
      while (1)
      {
        unsigned int v385 = atomic_load((unsigned int *)(*(void *)v380 + 72));
        if (v385 == 3) {
          break;
        }
LABEL_515:
        v380 += 8;
        if (v380 - *v379 == 4096)
        {
          uint64_t v395 = v379[1];
          ++v379;
          uint64_t v380 = v395;
        }
        if (v380 == v381)
        {
          if (v382 != v383)
          {
            uint64_t v401 = MEMORY[0x1E4F143A8];
            float64_t v402 = v382;
            do
            {
              atomic_fetch_add((atomic_uint *volatile)(__sz + 320), 1u);
              float v403 = *(NSObject **)(__sz + 32);
              blocuint64_t k = v401;
              uint64_t block_8 = 3321888768;
              float64x2_t v416 = ___ZN8altitude12TexturePager25processTextureMipmapQueueEv_block_invoke;
              double v417 = &__block_descriptor_48_ea8_32c64_ZTSKZN8altitude12TexturePager25processTextureMipmapQueueEvE3__0_e5_v8__0l;
              float64_t v404 = *(unsigned int **)v402;
              v402 += 8;
              size_t v418 = __sz;
              double v419 = v404;
              dispatch_async(v403, &block);
            }
            while (v402 != v383);
          }
          if (v382) {
            operator delete(v382);
          }
          return;
        }
      }
      if (v383 < v384)
      {
        *(void *)size_t v383 = *(void *)v380;
        uint64_t v386 = v383 + 8;
LABEL_514:
        atomic_store(4u, (unsigned int *)(*(void *)v380 + 72));
        size_t v383 = v386;
        goto LABEL_515;
      }
      uint64_t v387 = (v383 - v382) >> 3;
      unint64_t v388 = v387 + 1;
      if ((unint64_t)(v387 + 1) >> 61) {
        abort();
      }
      if ((v384 - v382) >> 2 > v388) {
        unint64_t v388 = (v384 - v382) >> 2;
      }
      if ((unint64_t)(v384 - v382) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v389 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v389 = v388;
      }
      if (v389)
      {
        if (v389 >> 61) {
          goto LABEL_533;
        }
        int32x2_t v390 = operator new(8 * v389);
      }
      else
      {
        int32x2_t v390 = 0;
      }
      int v391 = &v390[8 * v387];
      *(void *)int v391 = *(void *)v380;
      uint64_t v386 = v391 + 8;
      if (v383 != v382)
      {
        unint64_t v392 = v383 - 8 - v382;
        if (v392 >= 0x168)
        {
          if (&v390[v383 - v382 - 8 - (v392 & 0xFFFFFFFFFFFFFFF8)] > &v390[v383 - v382 - 8])
          {
            v393 = v383;
          }
          else if (&v383[-(v392 & 0xFFFFFFFFFFFFFFF8) - 8] > v383 - 8)
          {
            v393 = v383;
          }
          else if ((unint64_t)(v382 - v390) >= 0x20)
          {
            uint64_t v396 = (v392 >> 3) + 1;
            v393 = &v383[-8 * (v396 & 0x3FFFFFFFFFFFFFFCLL)];
            float v397 = &v390[8 * v387 - 16];
            float v398 = v383 - 16;
            uint64_t v399 = v396 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v400 = *(_OWORD *)v398;
              *(v397 - 1) = *((_OWORD *)v398 - 1);
              _OWORD *v397 = v400;
              v397 -= 2;
              v398 -= 32;
              v399 -= 4;
            }
            while (v399);
            v391 -= 8 * (v396 & 0x3FFFFFFFFFFFFFFCLL);
            if (v396 == (v396 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_511;
            }
          }
          else
          {
            v393 = v383;
          }
        }
        else
        {
          v393 = v383;
        }
        do
        {
          uint64_t v394 = *((void *)v393 - 1);
          v393 -= 8;
          *((void *)v391 - 1) = v394;
          v391 -= 8;
        }
        while (v393 != v382);
      }
LABEL_511:
      double v384 = &v390[8 * v389];
      if (v382) {
        operator delete(v382);
      }
      unint64_t v382 = v391;
      goto LABEL_514;
    }
  }
}

void sub_1A211A838()
{
  operator delete(v0);
  JUMPOUT(0x1A2119390);
}

void sub_1A211A86C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (!a15) {
    JUMPOUT(0x1A2119388);
  }
  JUMPOUT(0x1A2119390);
}

void *md::realistic::RealisticRenderer::layoutRenderLayers(void *this, md::LayoutContext *a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (md::RenderLayer **)this[5];
  for (uint64_t i = (md::RenderLayer **)this[6]; v2 != i; ++v2)
  {
    uint64_t v5 = *v2;
    if (*v2)
    {
      unsigned int v6 = *(md::PassList **)(*((void *)v5 + 5) + 24);
      md::RenderLayer::lock(*v2, v6, a2);
      uint64_t v7 = *(void *)(*(void *)(*((void *)v5 + 5) + 8) + 8);
      uint64_t v8 = operator new(0x20uLL);
      *uint64_t v8 = &unk_1EF57A2B0;
      v8[1] = v5;
      _DWORD v8[2] = a2;
      void v8[3] = v6;
      uint64_t v13 = v8;
      geo::TaskQueue::async(&v10, v7, v12);
      unint64_t v9 = v11;
      if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      this = v13;
      if (v13 == v12)
      {
        this = (void *)(*(uint64_t (**)(void *))(v12[0] + 32))(v12);
      }
      else if (v13)
      {
        this = (void *)(*(uint64_t (**)(void))(*v13 + 40))();
      }
    }
  }
  return this;
}

void sub_1A211AC08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t *a15)
{
  if (a15 == &a12)
  {
    (*(void (**)(uint64_t *))(a12 + 32))(&a12);
    _Unwind_Resume(exception_object);
  }
  if (a15) {
    (*(void (**)(void))(*a15 + 40))();
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::realistic::RealisticRenderer::type(md::realistic::RealisticRenderer *this)
{
  return 1;
}

void md::realistic::RealisticRenderer::prune(void *a1, uint64_t a2)
{
  if (a2 == 2)
  {
    unint64_t v9 = (void *)a1[16];
    uint64_t v10 = (altitude::GlobeCleanupLoader *)v9[56];
    if (v10) {
      altitude::GlobeCleanupLoader::pruneNodesAndGeometry(v10);
    }
    uint64_t v11 = (altitude::ObjectTreeLoader *)v9[87];
    if (v11) {
      altitude::ObjectTreeLoader::pruneModels(v11);
    }
    uint64_t v12 = v9[105];
    if (v12) {
      *(unsigned char *)(v12 + 376) = 1;
    }
    if (md::HardwareFigDecoder::instance(void)::once == -1) {
      goto LABEL_28;
    }
LABEL_35:
    dispatch_once(&md::HardwareFigDecoder::instance(void)::once, &__block_literal_global_25645);
LABEL_28:
    md::HardwareFigDecoder::discardCaches(*(std::mutex **)md::HardwareFigDecoder::instance(void)::_singleton);
    goto LABEL_29;
  }
  if (a2)
  {
    uint64_t v13 = (void *)a1[16];
    uint64_t v14 = (altitude::GlobeCleanupLoader *)v13[56];
    if (v14) {
      altitude::GlobeCleanupLoader::pruneNodesAndGeometry(v14);
    }
    BOOL v15 = (altitude::ObjectTreeLoader *)v13[87];
    if (v15) {
      altitude::ObjectTreeLoader::pruneModels(v15);
    }
    uint64_t v16 = v13[105];
    if (v16) {
      *(unsigned char *)(v16 + 376) = 1;
    }
    if (md::HardwareFigDecoder::instance(void)::once == -1) {
      goto LABEL_28;
    }
    goto LABEL_35;
  }
  size_t v4 = (void *)a1[16];
  uint64_t v5 = (altitude::GlobeCleanupLoader *)v4[56];
  if (v5) {
    altitude::GlobeCleanupLoader::pruneNodesAndGeometry(v5);
  }
  unsigned int v6 = (altitude::ObjectTreeLoader *)v4[87];
  if (v6) {
    altitude::ObjectTreeLoader::pruneModels(v6);
  }
  uint64_t v7 = v4[105];
  if (v7) {
    *(unsigned char *)(v7 + 376) = 1;
  }
  if (md::HardwareFigDecoder::instance(void)::once != -1) {
    dispatch_once(&md::HardwareFigDecoder::instance(void)::once, &__block_literal_global_25645);
  }
  md::HardwareFigDecoder::discardCaches(*(std::mutex **)md::HardwareFigDecoder::instance(void)::_singleton);
  uint64_t v8 = v4[56];
  if (v8) {
    *(void *)(v8 + 432) = 0;
  }
LABEL_29:
  uint64_t v18 = (void *)a1[5];
  uint64_t v17 = (void *)a1[6];
  while (v18 != v17)
  {
    if (*v18) {
      (*(void (**)(void, uint64_t))(*(void *)*v18 + 56))(*v18, a2);
    }
    ++v18;
  }
}

uint64_t md::realistic::RealisticRenderer::update(dispatch_semaphore_t *this, md::LayoutContext *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  dispatch_semaphore_wait(this[28], 0xFFFFFFFFFFFFFFFFLL);
  **((_WORD **)a2 + 92) = 1;
  *((_DWORD *)this + 54) = this[17][11].isa;
  uint64_t isa = (uint64_t)this[1][1].isa;
  v11[0] = &unk_1EF57A190;
  v11[1] = this;
  unsigned char v11[2] = a2;
  uint64_t v12 = v11;
  geo::TaskQueue::barrierAsync(&v9, isa, v11);
  uint64_t v5 = v10;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (v12 == v11)
  {
    (*(void (**)(void *))(v11[0] + 32))(v11);
  }
  else if (v12)
  {
    (*(void (**)(void))(*v12 + 40))();
  }
  unsigned int v6 = this[5];
  dispatch_semaphore_t v7 = this[6];
  while (v6 != (void *)v7)
  {
    if (*v6) {
      (*(void (**)(void, md::LayoutContext *))(*(void *)*v6 + 72))(*v6, a2);
    }
    ++v6;
  }
  uint64_t result = md::LayoutContext::frameState(a2);
  if (*(unsigned char *)(result + 117)) {
    return ((uint64_t (*)(dispatch_semaphore_t *, md::LayoutContext *))(*this)[10].isa)(this, a2);
  }
  return result;
}

void sub_1A211B008(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void geo::TaskQueue::barrierAsync(char **a1, uint64_t a2, void *a3)
{
  unsigned int v6 = operator new(0x40uLL);
  v6[1] = 0;
  v6[2] = 0;
  void *v6 = &unk_1EF582E48;
  dispatch_semaphore_t v7 = (char *)(v6 + 3);
  uint64_t v8 = a3[3];
  if (!v8) {
    goto LABEL_4;
  }
  if ((void *)v8 != a3)
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)v8 + 16))(v8);
LABEL_4:
    v6[6] = v8;
    goto LABEL_6;
  }
  v6[6] = v7;
  (*(void (**)(void *, char *))(*a3 + 24))(a3, v7);
LABEL_6:
  *((_WORD *)v6 + 28) = 0;
  *a1 = v7;
  a1[1] = (char *)v6;
  unint64_t v9 = *(NSObject **)(a2 + 16);
  if (*(unsigned char *)(a2 + 56))
  {
    uint64_t v10 = v9;
    uint64_t v11 = *(NSObject **)(a2 + 40);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3321888768;
    block[2] = ___ZN3geo9TaskQueue12barrierAsyncENSt3__18functionIFvvEEE_block_invoke;
    block[3] = &unk_1EF58E438;
    uint64_t v12 = v10;
    uint64_t v18 = v12;
    uint64_t v19 = (char *)(v6 + 3);
    uint64_t v20 = (std::__shared_weak_count *)v6;
    atomic_fetch_add_explicit(v6 + 1, 1uLL, memory_order_relaxed);
    dispatch_async(v11, block);
    uint64_t v13 = v20;
    if (v20)
    {
      if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
        std::__shared_weak_count::__release_weak(v13);
      }
    }
  }
  else
  {
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3321888768;
    v15[2] = ___ZN3geo9TaskQueue12barrierAsyncENSt3__18functionIFvvEEE_block_invoke_18;
    v15[3] = &__block_descriptor_48_ea8_32c37_ZTSNSt3__110shared_ptrIN3geo4TaskEEE_e5_v8__0l;
    v15[4] = v6 + 3;
    uint64_t v16 = (std::__shared_weak_count *)v6;
    atomic_fetch_add_explicit(v6 + 1, 1uLL, memory_order_relaxed);
    dispatch_barrier_async(v9, v15);
    uint64_t v14 = v16;
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
}

void sub_1A211B280(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void ___ZN3geo9TaskQueue12barrierAsyncENSt3__18functionIFvvEEE_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3321888768;
  v6[2] = ___ZN3geo9TaskQueue12barrierAsyncENSt3__18functionIFvvEEE_block_invoke_2;
  v6[3] = &__block_descriptor_48_ea8_32c37_ZTSNSt3__110shared_ptrIN3geo4TaskEEE_e5_v8__0l;
  uint64_t v4 = a1[5];
  size_t v3 = (std::__shared_weak_count *)a1[6];
  v6[4] = v4;
  dispatch_semaphore_t v7 = v3;
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  dispatch_barrier_async(v2, v6);
  uint64_t v5 = v7;
  if (v7)
  {
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

uint64_t ___ZN3geo9TaskQueue12barrierAsyncENSt3__18functionIFvvEEE_block_invoke_18(uint64_t result)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(*(void *)(result + 32) + 32));
  if ((v1 & 1) == 0)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(*(void *)(result + 32) + 24);
    if (v3)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3);
      atomic_store(1u, (unsigned __int8 *)(*(void *)(v2 + 32) + 33));
    }
    else
    {
      std::__throw_bad_function_call[abi:nn180100]();
      return __destroy_helper_block_ea8_32c37_ZTSNSt3__110shared_ptrIN3geo4TaskEEE();
    }
  }
  return result;
}

void __destroy_helper_block_ea8_32c37_ZTSNSt3__110shared_ptrIN3geo4TaskEEE(uint64_t a1)
{
  unsigned __int8 v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_32c37_ZTSNSt3__110shared_ptrIN3geo4TaskEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_40c37_ZTSNSt3__110shared_ptrIN3geo4TaskEEE(uint64_t a1)
{
  unsigned __int8 v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_40c37_ZTSNSt3__110shared_ptrIN3geo4TaskEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t ___ZN3geo9TaskQueue12barrierAsyncENSt3__18functionIFvvEEE_block_invoke_2(uint64_t result)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)(*(void *)(result + 32) + 32));
  if ((v1 & 1) == 0)
  {
    uint64_t v2 = result;
    uint64_t v3 = *(void *)(*(void *)(result + 32) + 24);
    if (v3)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 48))(v3);
      atomic_store(1u, (unsigned __int8 *)(*(void *)(v2 + 32) + 33));
    }
    else
    {
      std::__throw_bad_function_call[abi:nn180100]();
      return std::__function::__func<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0>,void ()(void)>::operator()();
    }
  }
  return result;
}

uint64_t std::__function::__func<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(v2 + 136);
  double v4 = *(double *)(md::LayoutContext::frameState(*(md::LayoutContext **)(a1 + 16)) + 88);
  double v5 = *(double *)(v3 + 168);
  if (v4 - v5 <= 0.0 || v5 <= 0.0) {
    double v7 = 0.0;
  }
  else {
    double v7 = v4 - v5;
  }
  *(double *)(v3 + 168) = v4;
  *(double *)(v3 + 176) = v7;
  int v8 = *(_DWORD *)(v3 + 88) + 1;
  double v9 = *(double *)(v3 + 104) + v7;
  *(void *)(v3 + 128) = *(void *)(v3 + 104);
  *(_OWORD *)(v3 + 112) = *(_OWORD *)(v3 + 88);
  *(_DWORD *)(v3 + 88) = v8;
  *(double *)(v3 + 96) = v7;
  *(double *)(v3 + 104) = v9;
  uint64_t v10 = *(unsigned char **)(v2 + 144);
  v10[8] = 1;
  v10[9] = v10[10];
  v10[48] = -1;
  altitude::GlobeView::updateCameraFrame(*(altitude::GlobeView **)(v2 + 128));
  altitude::GlobeView::update(*(altitude::GlobeView **)(v2 + 128));
  (*(void (**)(void))(**(void **)(*(void *)(v2 + 128) + 688) + 64))(*(void *)(*(void *)(v2 + 128) + 688));
  uint64_t v11 = *(void *)(v2 + 128);
  uint64_t v12 = *(void *)(v11 + 72);
  long long v13 = *(_OWORD *)(v12 + 24);
  long long v14 = *(_OWORD *)(v12 + 40);
  long long v15 = *(_OWORD *)(v12 + 8);
  *(void *)(v11 + 352) = *(void *)(v12 + 56);
  *(_OWORD *)(v11 + 320) = v13;
  *(_OWORD *)(v11 + 336) = v14;
  *(_OWORD *)(v11 + 304) = v15;
  *(_DWORD *)(v11 + 164) = *(_DWORD *)(*(void *)(v11 + 688) + 196);
  if (**(unsigned char **)(*(void *)(a1 + 16) + 72))
  {
    (*(void (**)(void, void, uint64_t))(**(void **)(*(void *)(v2 + 160) + 64) + 24))(*(void *)(*(void *)(v2 + 160) + 64), 0, 0xFFFFFFFFLL);
    uint64_t v16 = *(void **)(v2 + 128);
    uint64_t v17 = *(void *)(*(void *)(a1 + 16) + 72);
    uint64_t v18 = (*(uint64_t (**)(void, void, uint64_t))(**(void **)(v16[61] + 64) + 24))(*(void *)(v16[61] + 64), 0, 0xFFFFFFFFLL);
    if (v18)
    {
      uint64_t v19 = (karo::graphics::View *)v18;
      uint64_t v20 = (double *)(*(uint64_t (**)(void))(*(void *)(v18 + 40) + 24))();
      long double v21 = v20[2];
      double v22 = sqrt(*v20 * *v20 + v20[1] * v20[1]);
      double v23 = atan2(v21, v22 * 0.996647189);
      __double2 v24 = __sincos_stret(v23);
      double v25 = atan2(v21 + v24.__sinval * v24.__sinval * 42841.3115 * v24.__sinval, v22 + v24.__cosval * v24.__cosval * -42697.6727 * v24.__cosval);
      __double2 v26 = __sincos_stret(v25);
      double v27 = 1.0;
      float v28 = v22 / v26.__cosval + -6378137.0 / sqrt(v26.__sinval * v26.__sinval * -0.00669437999 + 1.0);
      float v29 = fmaxf(v28, 1.0);
      float v30 = sqrt((float)(v29 * v29) + v29 * 12742017.5);
      float v31 = v30 + 10000.0;
      (*(void (**)(karo::graphics::View *, uint64_t, void))(*(void *)v19 + 32))(v19, v17 + 16, 0);
      uint64_t v32 = (double *)v16[9];
      double v34 = v32[46];
      double v33 = v32[47];
      if (v33 >= v34)
      {
        double v38 = v32[57];
        double v35 = v33 * v34;
      }
      else
      {
        double v35 = v33 * v34;
        if (v33 * v34 > 0.0) {
          double v27 = v33 / v34;
        }
        long double v36 = tan(v32[57] * 0.5);
        long double v37 = atan(v27 * v36);
        double v38 = v37 + v37;
      }
      if (v35 <= 0.0) {
        double v39 = 1.0;
      }
      else {
        double v39 = v34 / v33;
      }
      long double v40 = tan(v38 * 0.5);
      *((double *)v19 + 125) = v38;
      *((double *)v19 + 124) = v39;
      *((double *)v19 + 118) = v31;
      *((void *)v19 + 119) = 0x3FF0000000000000;
      *((long double *)v19 + 122) = -(v40 * v39);
      *((long double *)v19 + 123) = v40 * v39;
      *((long double *)v19 + 121) = -v40;
      *((long double *)v19 + 120) = v40;
      *((void *)v19 + 126) = 0;
      *((unsigned char *)v19 + 1016) = 0;
      long double v41 = v39 * (v40 + v40);
      double v42 = -v31 / (v31 + -1.0);
      *((long double *)v19 + 47) = 2.0 / v41;
      *((_OWORD *)v19 + 24) = 0u;
      *((_OWORD *)v19 + 25) = 0u;
      *((long double *)v19 + 52) = 1.0 / v40;
      *(_OWORD *)((char *)v19 + 424) = 0u;
      *(_OWORD *)((char *)v19 + 440) = 0u;
      *((double *)v19 + 57) = v42;
      *((void *)v19 + 59) = 0;
      *((void *)v19 + 60) = 0;
      *((void *)v19 + 58) = 0xBFF0000000000000;
      *((double *)v19 + 61) = v42;
      *((void *)v19 + 62) = 0;
      *((long double *)v19 + 145) = v41 * 0.5;
      *((_OWORD *)v19 + 73) = 0u;
      *((_OWORD *)v19 + 74) = 0u;
      *((long double *)v19 + 150) = v40;
      *(_OWORD *)((char *)v19 + 1208) = 0u;
      *(_OWORD *)((char *)v19 + 1224) = 0u;
      *((void *)v19 + 155) = 0;
      *((double *)v19 + 156) = (v31 + -1.0) / -v31;
      *((void *)v19 + 157) = 0;
      *((void *)v19 + 158) = 0;
      *((void *)v19 + 159) = 0xBFF0000000000000;
      *((void *)v19 + 160) = 0x3FF0000000000000;
      karo::graphics::View::projectionUpdate(v19, 0);
      uint64_t v43 = v16[65];
      if (v43)
      {
        uint64_t v44 = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v43 + 24))(v43, 0, 0xFFFFFFFFLL);
        if (*(_DWORD *)(v44 + 1296) == 3)
        {
          uint64_t v45 = v44;
          uint64_t v46 = v16[98];
          karo::graphics::View::copyView(v44, v46);
          *(unsigned char *)(v45 + 1291) = *(unsigned char *)(v46 + 1291);
          *(_DWORD *)(v45 + 1320) = *(_DWORD *)(v46 + 1320);
          *(void *)(v45 + 1328) = *(void *)(v46 + 1328);
          *(void *)(v45 + 1336) = *(void *)(v46 + 1336);
          *(_DWORD *)(v45 + 1344) = *(_DWORD *)(v46 + 1344);
          long long v47 = *(_OWORD *)(v46 + 1352);
          long long v48 = *(_OWORD *)(v46 + 1368);
          *(void *)(v45 + 1384) = *(void *)(v46 + 1384);
          *(_OWORD *)(v45 + 1352) = v47;
          *(_OWORD *)(v45 + 1368) = v48;
          *(_DWORD *)(v45 + 1392) = *(_DWORD *)(v46 + 1392);
          *(void *)(v45 + 1400) = *(void *)(v46 + 1400);
          *(void *)(v45 + 1408) = *(void *)(v46 + 1408);
          *(void *)(v45 + 1416) = *(void *)(v46 + 1416);
          *(void *)(v45 + 1424) = *(void *)(v46 + 1424);
          *(void *)(v45 + 1432) = *(void *)(v46 + 1432);
          *(void *)(v45 + 1440) = *(void *)(v46 + 1440);
          *(void *)(v45 + 1448) = *(void *)(v46 + 1448);
          *(void *)(v45 + 1456) = *(void *)(v46 + 1456);
          *(float *)(v45 + 1316) = v31;
        }
      }
    }
  }
  (*(void (**)(void))(**(void **)(v2 + 160) + 24))(*(void *)(v2 + 160));
  altitude::GlobeTileRenderManager::update(*(altitude::GlobeTileRenderManager **)(v2 + 168));
  uint64_t v49 = *(void *)(a1 + 16);
  *(void *)(*(void *)(v49 + 736) + 8) = (*(uint64_t (**)(void, void, uint64_t))(**(void **)(*(void *)(v2 + 128) + 768)
                                                                                                 + 24))(*(void *)(*(void *)(v2 + 128) + 768), 0, 0xFFFFFFFFLL);
  uint64_t v50 = *(void *)(a1 + 16);
  *(void *)(*(void *)(v50 + 736) + 16) = (*(uint64_t (**)(void, void, uint64_t))(**(void **)(*(void *)(v2 + 160) + 64)
                                                                                                  + 24))(*(void *)(*(void *)(v2 + 160) + 64), 0, 0xFFFFFFFFLL);
  uint64_t v51 = *(void *)(a1 + 16);
  *(void *)(*(void *)(*(void *)(v51 + 736) + 8) + 1024) = *(void *)(v51 + 736) + 32;
  *(void *)(*(void *)(v51 + 736) + 24) = (*(uint64_t (**)(void, void))(**(void **)(*(void *)(v2 + 160) + 72)
                                                                                         + 24))(*(void *)(*(void *)(v2 + 160) + 72), 0);
  uint64_t result = altitude::Context::getDebugRenderUtil(*(altitude::Context **)(v2 + 136));
  uint64_t v53 = *(void *)(*(void *)(*(void *)(a1 + 16) + 736) + 8);
  int v54 = (float64x2_t *)(v53 + 376);
  double v55 = *(double *)(v53 + 80);
  double v56 = *(double *)(v53 + 88);
  double v57 = *(double *)(v53 + 96);
  double v58 = *(double *)(v53 + 64);
  double v59 = *(double *)(v53 + 72);
  double v61 = *(double *)(v53 + 48);
  double v60 = *(double *)(v53 + 56);
  double v62 = -(v58 * v55 - v60 * v56) - (v58 * v55 - v60 * v56);
  double v63 = -(v61 * v56 - v58 * v59) - (v61 * v56 - v58 * v59);
  double v64 = -(v60 * v59 - v61 * v55) - (v60 * v59 - v61 * v55);
  double v65 = -(v60 - v62 * v56 + v63 * v57 + v64 * v59);
  double v66 = -(v61 + v62 * v57 + v63 * v56 - v64 * v55);
  double v67 = v58 + v62 * v55 + v64 * v57;
  double v68 = v55 * -2.0;
  double v69 = -(v55 * (v55 * -2.0));
  double v70 = 1.0 - (v69 - v56 * (v56 * -2.0));
  double v71 = -(v55 * (v59 * -2.0));
  double v72 = v56 * -2.0 * v57;
  double v73 = v71 - v72;
  double v74 = -(v56 * (v59 * -2.0));
  double v75 = v57 * v68;
  double v76 = v57 * v68 - v56 * (v59 * -2.0);
  double v77 = v72 + v71;
  double v78 = v59 * -2.0 * v59 + 1.0;
  double v79 = v78 - -(v56 * (v56 * -2.0));
  double v80 = -(v56 * v68);
  double v81 = v57 * (v59 * -2.0);
  double v82 = v80 - v81;
  double v83 = v74 - v75;
  double v84 = v81 + v80;
  double v85 = v78 - v69;
  v86.f64[0] = v70;
  v86.f64[1] = v77;
  v87.f64[0] = v73;
  v87.f64[1] = v79;
  v88.f64[0] = v76;
  v88.f64[1] = v82;
  v89.f64[0] = v66;
  v89.f64[1] = v65;
  double v90 = -(v67 - v63 * v59);
  __asm { FMOV            V7.2D, #1.0 }
  _Q7.f64[0] = v90;
  *(void *)(result + 64) = *(void *)(v53 + 376);
  *(void *)(result + 72) = *(void *)(v53 + 384);
  *(void *)(result + 80) = *(void *)(v53 + 392);
  *(void *)(result + 88) = *(void *)(v53 + 400);
  *(void *)(result + 96) = *(void *)(v53 + 408);
  *(void *)(result + 104) = *(void *)(v53 + 416);
  *(void *)(result + 112) = *(void *)(v53 + 424);
  *(void *)(result + 120) = *(void *)(v53 + 432);
  *(void *)(result + 128) = *(void *)(v53 + 440);
  *(void *)(result + 136) = *(void *)(v53 + 448);
  *(void *)(result + 144) = *(void *)(v53 + 456);
  *(void *)(result + 152) = *(void *)(v53 + 464);
  *(void *)(result + 160) = *(void *)(v53 + 472);
  *(void *)(result + 168) = *(void *)(v53 + 480);
  *(void *)(result + 176) = *(void *)(v53 + 488);
  *(void *)(result + 184) = *(void *)(v53 + 496);
  *(double *)(result + 192) = v70;
  *(double *)(result + 200) = v77;
  *(double *)(result + 208) = v83;
  *(void *)(result + 216) = 0;
  *(double *)(result + 224) = v73;
  *(double *)(result + 232) = v79;
  *(double *)(result + 240) = v84;
  *(void *)(result + 248) = 0;
  *(double *)(result + 256) = v76;
  *(double *)(result + 264) = v82;
  *(double *)(result + 272) = v85;
  *(void *)(result + 280) = 0;
  *(double *)(result + 288) = v66;
  *(double *)(result + 296) = v65;
  *(double *)(result + 304) = v90;
  *(void *)(result + 312) = 0x3FF0000000000000;
  uint64_t v96 = *(void **)(result + 48);
  unint64_t v97 = v96[1];
  float32x4_t v98 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*v54), v54[1]);
  float32x4_t v99 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v54[2]), v54[3]);
  float64x2_t v101 = v54[4];
  float64x2_t v100 = v54[5];
  float64x2_t v103 = v54[6];
  float64x2_t v102 = v54[7];
  unint64_t v105 = v96[8];
  uint64_t v104 = (float32x4_t *)v96[9];
  v104[4] = v98;
  v104[5] = v99;
  v104[6] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v101), v100);
  v104[7] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v103), v102);
  float32x4_t *v104 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v86), (float64x2_t)*(unint64_t *)&v83);
  v104[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v87), (float64x2_t)*(unint64_t *)&v84);
  v104[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v88), (float64x2_t)*(unint64_t *)&v85);
  v104[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v89), _Q7);
  if (v105 <= v97) {
    unint64_t v106 = v97;
  }
  else {
    unint64_t v106 = v105;
  }
  v96[7] = 0;
  v96[8] = v106;
  uint64_t v107 = *(uint64_t **)(v2 + 40);
  for (uint64_t i = *(uint64_t **)(v2 + 48); v107 != i; ++v107)
  {
    uint64_t v109 = *v107;
    if (*v107)
    {
      if (*(unsigned char *)(v109 + 34) == 4)
      {
        unint64_t v110 = *(void **)(*(void *)(a1 + 16) + 8);
        int8x8_t v111 = (int8x8_t)v110[1];
        if (v111)
        {
          uint8x8_t v112 = (uint8x8_t)vcnt_s8(v111);
          v112.i16[0] = vaddlv_u8(v112);
          if (v112.u32[0] > 1uLL)
          {
            uint64_t v113 = 0x13043386C0978CC2;
            if (*(void *)&v111 <= 0x13043386C0978CC2uLL) {
              uint64_t v113 = 0x13043386C0978CC2uLL % *(void *)&v111;
            }
          }
          else
          {
            uint64_t v113 = (*(void *)&v111 - 1) & 0x13043386C0978CC2;
          }
          unint64_t v114 = *(void **)(*v110 + 8 * v113);
          if (v114)
          {
            uint64_t v115 = (void *)*v114;
            if (v115)
            {
              if (v112.u32[0] < 2uLL)
              {
                uint64_t v116 = *(void *)&v111 - 1;
                while (1)
                {
                  uint64_t v118 = v115[1];
                  if (v118 == 0x13043386C0978CC2)
                  {
                    if (v115[2] == 0x13043386C0978CC2) {
                      goto LABEL_49;
                    }
                  }
                  else if ((v118 & v116) != v113)
                  {
                    goto LABEL_25;
                  }
                  uint64_t v115 = (void *)*v115;
                  if (!v115) {
                    goto LABEL_25;
                  }
                }
              }
              do
              {
                unint64_t v117 = v115[1];
                if (v117 == 0x13043386C0978CC2)
                {
                  if (v115[2] == 0x13043386C0978CC2)
                  {
LABEL_49:
                    uint64_t v119 = v115[5];
                    if (*(void *)(v119 + 8) == 0x13043386C0978CC2)
                    {
                      uint64_t v120 = *(void *)(v119 + 32);
                      if (v120)
                      {
                        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v109 + 320) + 104))(*(void *)(v109 + 320), v120 + 104, 1);
                        (*(void (**)(void, uint64_t, void))(**(void **)(v109 + 320) + 104))(*(void *)(v109 + 320), v120, 0);
                        [*(id *)(*(void *)(v109 + 320) + 24) update];
                        uint64_t result = [*(id *)(*(void *)(v109 + 320) + 24) setRouteLineSplitAnnotation:*(void *)(v120 + 184)];
                      }
                    }
                    break;
                  }
                }
                else
                {
                  if (v117 >= *(void *)&v111) {
                    v117 %= *(void *)&v111;
                  }
                  if (v117 != v113) {
                    break;
                  }
                }
                uint64_t v115 = (void *)*v115;
              }
              while (v115);
            }
          }
        }
      }
    }
LABEL_25:
    ;
  }
  return result;
}

__n128 std::__function::__func<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57A190;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF57A190;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0,std::allocator<md::realistic::RealisticRenderer::update(md::LayoutContext &)::$_0>,void ()(void)>::~__func()
{
}

void md::realistic::RealisticRenderer::~RealisticRenderer(md::realistic::RealisticRenderer *this)
{
  md::realistic::RealisticRenderer::~RealisticRenderer(this);
  JUMPOUT(0x1A6239270);
}

{
  karo::JobManager **v2;
  karo::JobManager *v3;
  karo::JobManager *v4;
  karo::JobManager *v5;
  karo::JobManager *v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  std::__shared_weak_count *v29;
  karo::JobManager **v30;
  karo::JobManager *v31;
  karo::JobManager *v32;
  karo::JobManager *v33;
  karo::JobManager *v34;
  karo::JobManager *v35;
  karo::JobManager *v36;
  std::__shared_weak_count *v37;
  std::__shared_weak_count *v38;
  void v39[3];
  void *v40;
  uint64_t v41;

  long double v41 = *MEMORY[0x1E4F143B8];
  *(void *)this = &unk_1EF554820;
  uint64_t v2 = *(karo::JobManager ***)(*((void *)this + 17) + 72);
  uint64_t v3 = *v2;
  double v4 = v2[1];
  *((unsigned char *)*v2 + 64) = 1;
  *((unsigned char *)v2[2] + 64) = 1;
  if (v4) {
    *((unsigned char *)v4 + 64) = 1;
  }
  karo::JobManager::cancelAll(v3);
  karo::JobManager::cancelAll(v2[2]);
  double v5 = v2[1];
  if (!v5)
  {
    *((unsigned char *)*v2 + 64) = 0;
    unsigned int v6 = v2[2];
    goto LABEL_7;
  }
  karo::JobManager::cancelAll(v5);
  unsigned int v6 = v2[1];
  *((unsigned char *)*v2 + 64) = 0;
  *((unsigned char *)v2[2] + 64) = 0;
  if (v6) {
LABEL_7:
  }
    *((unsigned char *)v6 + 64) = 0;
  double v7 = *(void *)(*((void *)this + 1) + 8);
  v39[0] = &unk_1EF57A1D8;
  long double v40 = v39;
  geo::TaskQueue::barrierSync(v7, v39);
  if (v40 == v39)
  {
    (*(void (**)(void *))(v39[0] + 32))(v39);
  }
  else if (v40)
  {
    (*(void (**)(void))(*v40 + 40))();
  }
  int v8 = (uint64_t *)*((void *)this + 5);
  double v9 = *v8;
  *int v8 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *((void *)this + 5);
  uint64_t v11 = *(void *)(v10 + 8);
  *(void *)(v10 + 8) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *((void *)this + 5);
  long long v13 = *(void *)(v12 + 16);
  *(void *)(v12 + 16) = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  long long v14 = *((void *)this + 5);
  long long v15 = *(void *)(v14 + 24);
  *(void *)(v14 + 24) = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  uint64_t v16 = *((void *)this + 5);
  uint64_t v17 = *(void *)(v16 + 32);
  *(void *)(v16 + 32) = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t v18 = *((void *)this + 5);
  uint64_t v19 = *(void *)(v18 + 40);
  *(void *)(v18 + 40) = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = *((void *)this + 5);
  long double v21 = *(void *)(v20 + 48);
  *(void *)(v20 + 48) = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  double v22 = *((void *)this + 5);
  double v23 = *(void *)(v22 + 56);
  *(void *)(v22 + 56) = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  __double2 v24 = (void *)*((void *)this + 28);
  *((void *)this + 28) = 0;

  double v25 = *((void *)this + 16);
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  __double2 v26 = *((void *)this + 18);
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  double v27 = *((void *)this + 17);
  if (v27)
  {

    float v28 = *(void *)(v27 + 160);
    if (v28 == v27 + 136)
    {
      (*(void (**)(uint64_t))(*(void *)(v27 + 136) + 32))(v27 + 136);
      float v29 = *(std::__shared_weak_count **)(v27 + 24);
      if (!v29)
      {
LABEL_41:
        MEMORY[0x1A6239270](v27, 0x10A0C40AE0CB074);
        goto LABEL_42;
      }
    }
    else
    {
      if (v28) {
        (*(void (**)(uint64_t))(*(void *)v28 + 40))(v28);
      }
      float v29 = *(std::__shared_weak_count **)(v27 + 24);
      if (!v29) {
        goto LABEL_41;
      }
    }
    if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    goto LABEL_41;
  }
LABEL_42:
  float v30 = (karo::JobManager **)*((void *)this + 19);
  if (v30)
  {
    float v31 = *v30;
    uint64_t v32 = v30[1];
    *((unsigned char *)*v30 + 64) = 1;
    *((unsigned char *)v30[2] + 64) = 1;
    if (v32) {
      *((unsigned char *)v32 + 64) = 1;
    }
    karo::JobManager::cancelAll(v31);
    karo::JobManager::cancelAll(v30[2]);
    double v33 = v30[1];
    if (v33) {
      karo::JobManager::cancelAll(v33);
    }
    if (*v30) {
      (*(void (**)(karo::JobManager *))(*(void *)*v30 + 8))(*v30);
    }
    double v34 = v30[2];
    if (v34) {
      (*(void (**)(karo::JobManager *))(*(void *)v34 + 8))(v34);
    }
    double v35 = v30[1];
    if (v35) {
      (*(void (**)(karo::JobManager *))(*(void *)v35 + 8))(v35);
    }
    long double v36 = v30[3];
    if (v36) {
      (*(void (**)(karo::JobManager *))(*(void *)v36 + 8))(v36);
    }
    MEMORY[0x1A6239270](v30, 0x20C40DC1BFBCFLL);
  }

  long double v37 = (std::__shared_weak_count *)*((void *)this + 26);
  if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
    std::__shared_weak_count::__release_weak(v37);
  }
  double v38 = (std::__shared_weak_count *)*((void *)this + 24);
  if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
    std::__shared_weak_count::__release_weak(v38);
  }
  md::Renderer::~Renderer(this);
}

void sub_1A211C61C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v2 + 25));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v2 + 23));
  md::Renderer::~Renderer((md::Renderer *)v2);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::realistic::RealisticRenderer::~RealisticRenderer()::$_0,std::allocator<md::realistic::RealisticRenderer::~RealisticRenderer()::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57A1D8;
}

void *std::__function::__func<md::realistic::RealisticRenderer::~RealisticRenderer()::$_0,std::allocator<md::realistic::RealisticRenderer::~RealisticRenderer()::$_0>,void ()(void)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF57A1D8;
  return result;
}

void std::__function::__func<md::realistic::RealisticRenderer::~RealisticRenderer()::$_0,std::allocator<md::realistic::RealisticRenderer::~RealisticRenderer()::$_0>,void ()(void)>::~__func()
{
}

void md::realistic::RealisticRenderer::RealisticRenderer(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  md::Renderer::Renderer(a1, a2, a3, a4, a5);
}

void sub_1A2120918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, id *a14, void **a15)
{
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  uint64_t v18 = (std::__shared_weak_count *)v15[36];
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  uint64_t v19 = v15[34];
  v15[34] = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = (std::__shared_weak_count *)v15[33];
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  uint64_t v21 = v15[31];
  v15[31] = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  double v22 = (std::__shared_weak_count *)v15[30];
  if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
  double v23 = (std::__shared_weak_count *)v15[28];
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  uint64_t v24 = v15[26];
  v15[26] = 0;
  if (v24)
  {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
    double v25 = (char *)v15[22];
    if (!v25)
    {
LABEL_22:
      __double2 v26 = (char *)v15[19];
      if (!v26) {
        goto LABEL_23;
      }
      goto LABEL_46;
    }
  }
  else
  {
    double v25 = (char *)v15[22];
    if (!v25) {
      goto LABEL_22;
    }
  }
  double v35 = (char *)v15[23];
  long double v36 = v25;
  if (v35 != v25)
  {
    do
    {
      long double v37 = (std::__shared_weak_count *)*((void *)v35 - 1);
      if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
      v35 -= 16;
    }
    while (v35 != v25);
    long double v36 = (char *)v15[22];
  }
  v15[23] = v25;
  operator delete(v36);
  __double2 v26 = (char *)v15[19];
  if (!v26)
  {
LABEL_23:
    double v27 = (void *)v15[16];
    if (!v27) {
      goto LABEL_24;
    }
    goto LABEL_54;
  }
LABEL_46:
  double v38 = (char *)v15[20];
  double v39 = v26;
  if (v38 != v26)
  {
    do
    {
      long double v40 = (std::__shared_weak_count *)*((void *)v38 - 1);
      if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
        std::__shared_weak_count::__release_weak(v40);
      }
      v38 -= 16;
    }
    while (v38 != v26);
    double v39 = (char *)v15[19];
  }
  v15[20] = v26;
  operator delete(v39);
  double v27 = (void *)v15[16];
  if (!v27)
  {
LABEL_24:
    float v28 = (void *)v15[13];
    if (!v28) {
      goto LABEL_26;
    }
    goto LABEL_25;
  }
LABEL_54:
  v15[17] = v27;
  operator delete(v27);
  float v28 = (void *)v15[13];
  if (!v28)
  {
LABEL_26:
    float v29 = (char *)*a15;
    if (*a15)
    {
      float v30 = (char *)v15[11];
      float v31 = *a15;
      if (v30 != v29)
      {
        do
        {
          uint64_t v32 = (void *)*((void *)v30 - 2);
          v30 -= 16;
        }
        while (v30 != v29);
        float v31 = *a15;
      }
      v15[11] = v29;
      operator delete(v31);
    }
    double v33 = (std::__shared_weak_count *)v15[8];
    if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
      std::__shared_weak_count::__release_weak(v33);
    }
    *long long v15 = &unk_1EF530C60;
    double v34 = (void *)v15[1];
    if (v34)
    {
      v15[2] = v34;
      operator delete(v34);
    }
    MEMORY[0x1A6239270](v15, 0x10A1C409D47ECBALL);

    std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(a14 + 25));
    std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(a14 + 23));
    md::Renderer::~Renderer((md::Renderer *)a14);

    _Unwind_Resume(a1);
  }
LABEL_25:
  v15[14] = v28;
  operator delete(v28);
  goto LABEL_26;
}

void std::__shared_ptr_emplace<md::GlobeOverlayContainer>::__on_zero_shared(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v2 = *(id *)(a1 + 32);
  uint64_t v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v3)
  {
    uint64_t v4 = *(void *)v10;
    do
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (*(void *)v10 != v4) {
          objc_enumerationMutation(v2);
        }
        unsigned int v6 = *(void **)(*((void *)&v9 + 1) + 8 * i);
        uint64_t v7 = 0;
        int v8 = 0;
        [v6 setFlyoverContainer:&v7];
        if (v8) {
          std::__shared_weak_count::__release_weak(v8);
        }
      }
      uint64_t v3 = [v2 countByEnumeratingWithState:&v9 objects:v13 count:16];
    }
    while (v3);
  }

  std::mutex::~mutex((std::mutex *)(a1 + 40));
}

void sub_1A2121BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::__shared_weak_count *a10)
{
  std::mutex::~mutex((std::mutex *)(v10 + 40));
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::GlobeOverlayContainer>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581248;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::GlobeOverlayContainer>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581248;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void altitude::StencilManager::~StencilManager(altitude::StencilManager *this)
{
}

void md::realistic::RealisticRenderer::warmUp(altitude::GlobeView ***this, double a2)
{
  altitude::GlobeView::updateCameraFrame(*this[17]);
  altitude::GlobeView::update(*this[17]);
  uint64_t v4 = this[17];
  double v5 = *((double *)v4 + 21);
  if (a2 - v5 <= 0.0 || v5 <= 0.0) {
    double v7 = 0.0;
  }
  else {
    double v7 = a2 - v5;
  }
  *((double *)v4 + 21) = a2;
  *((double *)v4 + 22) = v7;
  int v8 = *((_DWORD *)v4 + 22) + 1;
  double v9 = *((double *)v4 + 13) + v7;
  v4[16] = v4[13];
  *((_OWORD *)v4 + 7) = *(_OWORD *)(v4 + 11);
  *((_DWORD *)v4 + 22) = v8;
  *((double *)v4 + 12) = v7;
  *((double *)v4 + 13) = v9;
  (*(void (**)(altitude::GlobeView *, void))(*(void *)this[16][86] + 56))(this[16][86], *((unsigned int *)this[17] + 22));
  uint64_t v10 = this[16][88];
  if (*((unsigned char *)v10 + 64))
  {
    altitude::QuickSurfaceManager::update(v10);
  }
}

void std::vector<double>::__append(uint64_t a1, unint64_t a2)
{
  double v5 = *(char **)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  unsigned int v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 3)
  {
    if (a2)
    {
      bzero(v5, 8 * a2);
      unsigned int v6 = &v5[8 * a2];
    }
    *(void *)(a1 + 8) = v6;
  }
  else
  {
    double v7 = *(char **)a1;
    uint64_t v8 = (uint64_t)&v5[-*(void *)a1];
    uint64_t v9 = v8 >> 3;
    unint64_t v10 = (v8 >> 3) + a2;
    if (v10 >> 61) {
      abort();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      long long v13 = operator new(8 * v12);
    }
    else
    {
      long long v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    size_t v15 = 8 * a2;
    uint64_t v16 = &v13[8 * v12];
    bzero(v14, v15);
    uint64_t v17 = &v14[v15];
    if (v5 != v7)
    {
      unint64_t v18 = v5 - v7 - 8;
      if (v18 < 0x58) {
        goto LABEL_31;
      }
      if ((unint64_t)(v5 - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 3) + 1;
      unsigned int v6 = &v5[-8 * (v19 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v20 = &v13[8 * v9 - 16];
      uint64_t v21 = v5 - 16;
      uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v23 = *(_OWORD *)v21;
        *(v20 - 1) = *((_OWORD *)v21 - 1);
        _OWORD *v20 = v23;
        v20 -= 2;
        v21 -= 32;
        v22 -= 4;
      }
      while (v22);
      v14 -= 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_31:
        do
        {
          uint64_t v24 = *((void *)v6 - 1);
          v6 -= 8;
          *((void *)v14 - 1) = v24;
          v14 -= 8;
        }
        while (v6 != v7);
      }
    }
    *(void *)a1 = v14;
    *(void *)(a1 + 8) = v17;
    *(void *)(a1 + 16) = v16;
    if (v7)
    {
      operator delete(v7);
    }
  }
}

const md::MuninRoadEdge *md::MuninRoadEdge::MuninRoadEdge(const md::MuninRoadEdge *a1, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, md::MuninJunction *a6, md::MuninJunction *a7)
{
  *(void *)a1 = a2;
  *((_DWORD *)a1 + 2) = 0;
  long long v13 = *(unsigned char **)(a2 + 16);
  uint64_t v14 = "";
  if (v13 && *v13) {
    uint64_t v14 = *(const char **)(a2 + 16);
  }
  {
    operator new();
  }
  uint64_t v15 = mdm::Allocator::instance(void)::alloc;
  *((void *)a1 + 5) = mdm::Allocator::instance(void)::alloc;
  size_t v16 = strlen(v14);
  if (v16 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v17 = v16;
  if (v16 >= 0x17)
  {
    uint64_t v19 = (v16 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v16 | 7) != 0x17) {
      uint64_t v19 = v16 | 7;
    }
    uint64_t v20 = v19 + 1;
    unint64_t v18 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v15 + 16))(v15, v19 + 1, 1);
    *((void *)a1 + 3) = v17;
    *((void *)a1 + 4) = v20 | 0x8000000000000000;
    *((void *)a1 + 2) = v18;
    goto LABEL_12;
  }
  *((unsigned char *)a1 + 39) = v16;
  unint64_t v18 = (char *)a1 + 16;
  if (v16) {
LABEL_12:
  }
    memmove(v18, v14, v17);
  *((unsigned char *)v18 + v17) = 0;
  long long v21 = a3[1];
  *((_OWORD *)a1 + 3) = *a3;
  *((_OWORD *)a1 + 4) = v21;
  *((void *)a1 + 10) = a4;
  *((void *)a1 + 11) = a5;
  *((void *)a1 + 12) = a6;
  *((void *)a1 + 13) = a7;
  *((unsigned char *)a1 + 112) = 0;
  uint64_t v22 = *(void *)a1;
  if (*(_WORD *)(*(void *)a1 + 148))
  {
    float v23 = (float)*(unsigned __int16 *)(*(void *)a1 + 148) * 0.01;
  }
  else
  {
    unint64_t v24 = *(unsigned __int8 *)(v22 + 151);
    if (v24 > 8) {
      float v23 = 14.8;
    }
    else {
      float v23 = flt_1A2962128[v24];
    }
  }
  *((float *)a1 + 2) = v23;
  int v25 = *(unsigned __int8 *)(v22 + 152);
  BOOL v27 = v25 == 10 || (v25 - 1) < 3;
  *((unsigned char *)a1 + 112) = v27;
  md::MuninJunction::addRoad(a6, a1);
  md::MuninJunction::addRoad(a7, a1);
  return a1;
}

void sub_1A21221A8(_Unwind_Exception *a1)
{
  std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::~basic_string(v1);
  _Unwind_Resume(a1);
}

void md::MuninRoadEdge::localizedName(md::MuninRoadEdge *this, uint64_t **a2, int a3)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  {
    int v9 = a3;
    double v7 = a2;
    a2 = v7;
    a3 = v9;
    if (v5) {
      operator new();
    }
  }
  *((void *)this + 3) = mdm::Allocator::instance(void)::alloc;
  if (*a2)
  {
    v13[0] = 0;
    v13[1] = 0;
    uint64_t v14 = 0;
    {
      int v10 = a3;
      uint64_t v8 = a2;
      a2 = v8;
      a3 = v10;
      if (v6) {
        operator new();
      }
    }
    uint64_t v15 = mdm::Allocator::instance(void)::alloc;
    md::LabelFeature::textFromFeature((unint64_t)&v11, *a2, a3, (uint64_t)v13, 0);
    int v4 = SHIBYTE(v14);
    *(_OWORD *)this = v11;
    *((void *)this + 2) = v12;
    if (v4 < 0) {
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)v15 + 40))(v15, v13[0], v14 & 0x7FFFFFFFFFFFFFFFLL);
    }
  }
}

void sub_1A212236C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (SHIBYTE(a17) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a18 + 40))(a18, a15, a17 & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::~basic_string(v18);
  _Unwind_Resume(a1);
}

uint64_t md::MuninRoadEdge::walkEdgeGeometry(uint64_t *a1, int a2, uint64_t a3)
{
  v34[3] = *MEMORY[0x1E4F143B8];
  uint64_t result = *a1;
  if (result)
  {
    if (*(void *)(a3 + 24))
    {
      v34[0] = 0;
      uint64_t result = (uint64_t)geo::codec::multiSectionFeaturePoints((void *)result, 0, v34);
      double v7 = a1 + 10;
      if ((unint64_t)a1[10] <= v34[0])
      {
        uint64_t v8 = a1 + 11;
        if ((unint64_t)a1[11] <= v34[0])
        {
          uint64_t v9 = result;
          int v10 = (std::__shared_weak_count **)*a1;
          float64x2_t v33 = 0uLL;
          long long v11 = v10[1];
          if (v11)
          {
            long long v11 = std::__shared_weak_count::lock(v11);
            uint64_t v12 = v11;
            *(void *)&v33.f64[1] = v11;
            if (v11)
            {
              long long v11 = *v10;
              *(void *)&v33.f64[0] = *v10;
            }
          }
          else
          {
            uint64_t v12 = 0;
          }
          geo::codec::VectorTile::key((geo::codec::VectorTile *)v11);
          v34[1] = GEOTileKeyMake();
          v34[2] = v13;
          if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
          uint64_t result = GEOMapRectForGEOTileKey();
          float64x2_t v14 = *(float64x2_t *)(MEMORY[0x1E4F63F08] + 16);
          v16.f64[1] = v15;
          v18.f64[1] = v17;
          float64x2_t v19 = vdivq_f64(vaddq_f64(v16, v18), v14);
          double v20 = 1.0 - v19.f64[1];
          float64x2_t v21 = vdivq_f64(v18, v14);
          BOOL v22 = a2 == 0;
          if (a2) {
            float v23 = v7;
          }
          else {
            float v23 = v8;
          }
          unint64_t v24 = *v23;
          if (v22) {
            int v25 = v7;
          }
          else {
            int v25 = v8;
          }
          unint64_t v26 = *v25;
          if (v26 > v24) {
            uint64_t v27 = 1;
          }
          else {
            uint64_t v27 = -1;
          }
          float64x2_t v28 = vsubq_f64(v19, v21);
          v21.f64[1] = v20;
          float64x2_t v31 = v28;
          float64x2_t v32 = v21;
          unint64_t v29 = v26 + 2 * v27;
          do
          {
            if (v29 == v24 + v27) {
              break;
            }
            float64x2_t v33 = vmlaq_f64(v32, vcvtq_f64_f32(*(float32x2_t *)(v9 + 8 * v24)), v31);
            uint64_t v30 = *(void *)(a3 + 24);
            if (!v30)
            {
              std::__throw_bad_function_call[abi:nn180100]();
              __break(1u);
            }
            uint64_t result = (*(uint64_t (**)(uint64_t, float64x2_t *))(*(void *)v30 + 48))(v30, &v33);
            v24 += v27;
          }
          while ((result & 1) != 0);
        }
      }
    }
  }
  return result;
}

void sub_1A21225F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::function<BOOL ()(gm::Matrix<double,2,1> const&)>::~function(void *a1)
{
  id v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::MuninRoadEdge::worldPolyline(BOOL,std::vector<gm::Matrix<double,2,1>> &)::$_0,std::allocator<md::MuninRoadEdge::worldPolyline(BOOL,std::vector<gm::Matrix<double,2,1>> &)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::operator()(uint64_t a1, _OWORD *a2)
{
  uint64_t v3 = *(char ***)(a1 + 8);
  int v5 = v3[1];
  unint64_t v4 = (unint64_t)v3[2];
  if ((unint64_t)v5 >= v4)
  {
    double v7 = *v3;
    uint64_t v8 = (v5 - *v3) >> 4;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 60) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 3 > v9) {
      unint64_t v9 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v12 = (char *)operator new(16 * v11);
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v13 = &v12[16 * v8];
    *(_OWORD *)uint64_t v13 = *a2;
    int v6 = v13 + 16;
    if (v5 != v7)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        v5 -= 16;
      }
      while (v5 != v7);
      int v5 = *v3;
    }
    std::__shared_weak_count *v3 = v13;
    v3[1] = v6;
    int8x8_t v3[2] = &v12[16 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *(_OWORD *)int v5 = *a2;
    int v6 = v5 + 16;
  }
  v3[1] = v6;
  return 1;
}

uint64_t std::__function::__func<md::MuninRoadEdge::worldPolyline(BOOL,std::vector<gm::Matrix<double,2,1>> &)::$_0,std::allocator<md::MuninRoadEdge::worldPolyline(BOOL,std::vector<gm::Matrix<double,2,1>> &)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57D758;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MuninRoadEdge::worldPolyline(BOOL,std::vector<gm::Matrix<double,2,1>> &)::$_0,std::allocator<md::MuninRoadEdge::worldPolyline(BOOL,std::vector<gm::Matrix<double,2,1>> &)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF57D758;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MuninRoadEdge::worldPolyline(BOOL,std::vector<gm::Matrix<double,2,1>> &)::$_0,std::allocator<md::MuninRoadEdge::worldPolyline(BOOL,std::vector<gm::Matrix<double,2,1>> &)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::~__func()
{
}

double md::MuninRoadEdge::edgeLengthInMeters(md::MuninRoadEdge *this)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  v13[1] = 0;
  double v14 = 0.0;
  v13[0] = 0;
  v15[0] = &unk_1EF57D710;
  v15[1] = v13;
  v15[2] = &v14;
  float64x2_t v16 = v15;
  md::MuninRoadEdge::walkEdgeGeometry((uint64_t *)this, 1, (uint64_t)v15);
  if (v16 == v15)
  {
    (*(void (**)(void *))(v15[0] + 32))(v15);
  }
  else if (v16)
  {
    (*(void (**)(void))(*v16 + 40))();
  }
  double v2 = v14;
  long double v3 = exp((*((double *)this + 7) + (*((double *)this + 9) - *((double *)this + 7)) * 0.5) * 6.28318531 + -3.14159265);
  long double v4 = atan(v3) * 114.591559 + -90.0;
  double v5 = cos(v4 * 0.034906585);
  double v6 = cos(v4 * 0.0698131701);
  double v7 = cos(v4 * 0.104719755);
  long double v8 = v4 * 0.00872664626;
  long double v9 = tan(v4 * 0.00872664626 + 0.78103484);
  double v10 = log(v9);
  long double v11 = tan(v8 + 0.789761487);
  return (v5 * -559.82 + 111132.92 + v6 * 1.175 + v7 * -0.0023) * v2 / fabs((log(v11) - v10) * 0.159154943);
}

void sub_1A2122A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15 == v15)
  {
    (*(void (**)(uint64_t *))(a12 + 32))(&a12);
    _Unwind_Resume(exception_object);
  }
  if (a15) {
    (*(void (**)(void))(*(void *)a15 + 40))();
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::MuninRoadEdge::edgeLength(void)::$_0,std::allocator<md::MuninRoadEdge::edgeLength(void)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (*(_OWORD *)v2 != 0)
  {
    float64x2_t v3 = vsubq_f64(*(float64x2_t *)a2, *(float64x2_t *)v2);
    **(double **)(a1 + 16) = sqrt(vaddvq_f64(vmulq_f64(v3, v3))) + **(double **)(a1 + 16);
  }
  *(void *)uint64_t v2 = *(void *)a2;
  *(void *)(v2 + 8) = *(void *)(a2 + 8);
  return 1;
}

__n128 std::__function::__func<md::MuninRoadEdge::edgeLength(void)::$_0,std::allocator<md::MuninRoadEdge::edgeLength(void)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF57D710;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MuninRoadEdge::edgeLength(void)::$_0,std::allocator<md::MuninRoadEdge::edgeLength(void)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF57D710;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::MuninRoadEdge::edgeLength(void)::$_0,std::allocator<md::MuninRoadEdge::edgeLength(void)::$_0>,BOOL ()(gm::Matrix<double,2,1> const&)>::~__func()
{
}

double md::MuninRoadEdge::direction(std::__shared_weak_count ***this, int a2)
{
  v23[3] = *MEMORY[0x1E4F143B8];
  float64x2_t v3 = *this;
  if (!v3) {
    return 0.0;
  }
  double result = 0.0;
  if (this[10] != this[11])
  {
    v23[0] = 0;
    double v6 = geo::codec::multiSectionFeaturePoints(v3, 0, v23);
    double result = 0.0;
    if ((unint64_t)this[10] < v23[0])
    {
      double result = 0.0;
      if ((unint64_t)this[11] < v23[0])
      {
        double v7 = v6;
        long double v8 = *this;
        long double v9 = (*this)[1];
        if (v9)
        {
          long double v9 = std::__shared_weak_count::lock(v9);
          double v10 = v9;
          if (v9) {
            long double v9 = *v8;
          }
        }
        else
        {
          double v10 = 0;
        }
        geo::codec::VectorTile::key((geo::codec::VectorTile *)v9);
        v23[1] = GEOTileKeyMake();
        v23[2] = v11;
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        GEOMapRectForGEOTileKey();
        v13.f64[1] = v12;
        float64x2_t v14 = vdivq_f64(v13, *(float64x2_t *)(MEMORY[0x1E4F63F08] + 16));
        float64x2_t v15 = vmulq_f64(v14, vcvtq_f64_f32((float32x2_t)v7[(void)this[10]]));
        float64x2_t v16 = vmulq_f64(v14, vcvtq_f64_f32((float32x2_t)v7[(void)this[11]]));
        float64x2_t v17 = vsubq_f64(v15, v16);
        int8x16_t v18 = (int8x16_t)vmulq_f64(v17, v17);
        float64x2_t v19 = vsubq_f64(v16, v15);
        int8x16_t v20 = (int8x16_t)vmulq_f64(v19, v19);
        if (a2) {
          unint64_t v21 = -1;
        }
        else {
          unint64_t v21 = 0;
        }
        int8x16_t v22 = (int8x16_t)vdupq_n_s64(v21);
        *(void *)&double result = *(_OWORD *)&vmulq_n_f64((float64x2_t)vbslq_s8(v22, (int8x16_t)v19, (int8x16_t)v17), 1.0 / sqrt(vaddvq_f64((float64x2_t)vbslq_s8(v22, v20, v18))));
      }
    }
  }
  return result;
}

void sub_1A2122D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::C3bTileRequestId,altitude::C3bRequestData>::waitOnRequest(uint64_t a1, uint64_t a2, unsigned int a3)
{
  double v6 = (pthread_mutex_t **)(a1 + 40);
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  long double v9 = *(void **)(a1 + 72);
  double v7 = (void *)(a1 + 72);
  long double v8 = v9;
  if (!v9) {
    goto LABEL_8;
  }
  double v10 = v7;
  do
  {
    BOOL v11 = std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100]((uint64_t)(v8 + 4), a2);
    float64_t v12 = v8 + 1;
    if (!v11)
    {
      float64_t v12 = v8;
      double v10 = v8;
    }
    long double v8 = (void *)*v12;
  }
  while (*v12);
  if (v10 == v7 || std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100](a2, (uint64_t)(v10 + 4)))
  {
LABEL_8:
    float64x2_t v13 = 0;
    uint64_t v14 = 0;
    goto LABEL_9;
  }
  float64x2_t v16 = (karo::Job *)v10[11];
  float64x2_t v13 = (std::__shared_weak_count *)v10[12];
  if (v13) {
    atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  pthread_mutex_unlock(*v6);
  if (v16)
  {
    karo::Job::waitToFinish(v16, a3);
    int8x16_t v18 = (pthread_mutex_t *)*((void *)v16 + 19);
    float64x2_t v17 = (pthread_mutex_t **)((char *)v16 + 152);
    pthread_mutex_lock(v18);
    uint64_t v14 = (_BYTE)v17[1] & 1;
    double v6 = v17;
LABEL_9:
    pthread_mutex_unlock(*v6);
    if (!v13) {
      return v14;
    }
    goto LABEL_10;
  }
  uint64_t v14 = 0;
  if (!v13) {
    return v14;
  }
LABEL_10:
  if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  return v14;
}

void sub_1A2122EEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  int v4 = *(char *)(a1 + 47);
  if (v4 >= 0) {
    double v5 = (const void *)(a1 + 24);
  }
  else {
    double v5 = *(const void **)(a1 + 24);
  }
  if (v4 >= 0) {
    size_t v6 = *(unsigned __int8 *)(a1 + 47);
  }
  else {
    size_t v6 = *(void *)(a1 + 32);
  }
  int v7 = *(char *)(a2 + 47);
  if (v7 >= 0) {
    long double v8 = (const void *)(a2 + 24);
  }
  else {
    long double v8 = *(const void **)(a2 + 24);
  }
  if (v7 >= 0) {
    size_t v9 = *(unsigned __int8 *)(a2 + 47);
  }
  else {
    size_t v9 = *(void *)(a2 + 32);
  }
  if (v9 >= v6) {
    size_t v10 = v6;
  }
  else {
    size_t v10 = v9;
  }
  int v11 = memcmp(v5, v8, v10);
  if (v11)
  {
    if (v11 < 0) {
      return 1;
    }
  }
  else if (v6 < v9)
  {
    return 1;
  }
  int v12 = memcmp(v8, v5, v10);
  if (v12)
  {
    if (v12 < 0) {
      return 0;
    }
  }
  else if (v9 < v6)
  {
    return 0;
  }
  int v13 = *(_DWORD *)(a1 + 16);
  int v14 = *(_DWORD *)(a2 + 16);
  if (v13 < v14) {
    return 1;
  }
  if (v14 < v13) {
    return 0;
  }
  unsigned int v16 = *(unsigned __int8 *)(a1 + 48);
  unsigned int v17 = *(unsigned __int8 *)(a2 + 48);
  if (v16 < v17) {
    return 1;
  }
  if (v17 < v16) {
    return 0;
  }
  if (*(_DWORD *)a1 < *(_DWORD *)a2) {
    return 1;
  }
  if (*(_DWORD *)a1 > *(_DWORD *)a2) {
    return 0;
  }
  unsigned int v18 = *(_DWORD *)(a1 + 4);
  unsigned int v19 = *(_DWORD *)(a2 + 4);
  if (v18 < v19) {
    return 1;
  }
  if (v18 > v19) {
    return 0;
  }
  unsigned int v20 = *(_DWORD *)(a1 + 8);
  unsigned int v21 = *(_DWORD *)(a2 + 8);
  if (v20 < v21) {
    return 1;
  }
  if (v20 > v21) {
    return 0;
  }
  return *(_DWORD *)(a1 + 12) < *(_DWORD *)(a2 + 12);
}

void karo::AsyncRequestManagerTemplate<altitude::C3bTileRequestId,altitude::C3bRequestData>::getRequest(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, void *a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  long double v8 = (void *)(a1 + 72);
  size_t v9 = *(void **)(a1 + 72);
  if (!v9) {
    goto LABEL_8;
  }
  size_t v10 = (void *)(a1 + 72);
  do
  {
    BOOL v11 = std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100]((uint64_t)(v9 + 4), a2);
    int v12 = v9 + 1;
    if (!v11)
    {
      int v12 = v9;
      size_t v10 = v9;
    }
    size_t v9 = (void *)*v12;
  }
  while (*v12);
  if (v10 == v8 || std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100](a2, (uint64_t)(v10 + 4)))
  {
LABEL_8:
    (*(void (**)(long long *__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 64))(&v29, a1, a2, a3);
    long long v28 = v29;
    *(_OWORD *)a4 = v29;
    int v13 = (void *)*v8;
    int v14 = v8;
    if (*v8)
    {
      while (1)
      {
        while (1)
        {
          int v14 = v13;
          uint64_t v15 = (uint64_t)(v13 + 4);
          if (!std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100](a2, (uint64_t)(v13 + 4))) {
            break;
          }
          int v13 = (void *)*v14;
          long double v8 = v14;
          if (!*v14) {
            goto LABEL_14;
          }
        }
        if (!std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100](v15, a2)) {
          break;
        }
        long double v8 = v14 + 1;
        int v13 = (void *)v14[1];
        if (!v13) {
          goto LABEL_14;
        }
      }
      unsigned int v16 = (char *)v14;
      long long v20 = v28;
      uint64_t v21 = *((void *)&v28 + 1);
      if (!*((void *)&v28 + 1)) {
        goto LABEL_21;
      }
    }
    else
    {
LABEL_14:
      unsigned int v16 = (char *)operator new(0x68uLL);
      *((_OWORD *)v16 + 2) = *(_OWORD *)a2;
      *((_DWORD *)v16 + 12) = *(_DWORD *)(a2 + 16);
      unsigned int v17 = (std::string *)(v16 + 56);
      if (*(char *)(a2 + 47) < 0)
      {
        std::string::__init_copy_ctor_external(v17, *(const std::string::value_type **)(a2 + 24), *(void *)(a2 + 32));
      }
      else
      {
        *(_OWORD *)&v17->__r_.__value_.__l.__data_ = *(_OWORD *)(a2 + 24);
        *((void *)v16 + 9) = *(void *)(a2 + 40);
      }
      v16[80] = *(unsigned char *)(a2 + 48);
      *((void *)v16 + 11) = 0;
      *((void *)v16 + 12) = 0;
      *(void *)unsigned int v16 = 0;
      *((void *)v16 + 1) = 0;
      *((void *)v16 + 2) = v14;
      *long double v8 = v16;
      uint64_t v18 = **(void **)(a1 + 64);
      unsigned int v19 = (uint64_t *)v16;
      if (v18)
      {
        *(void *)(a1 + 64) = v18;
        unsigned int v19 = (uint64_t *)*v8;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 72), v19);
      ++*(void *)(a1 + 80);
      long long v20 = *(_OWORD *)a4;
      uint64_t v21 = a4[1];
      if (!v21) {
        goto LABEL_21;
      }
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v21 + 8), 1uLL, memory_order_relaxed);
LABEL_21:
    int8x16_t v22 = (std::__shared_weak_count *)*((void *)v16 + 12);
    *(_OWORD *)(v16 + 88) = v20;
    if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    unint64_t v23 = *(void *)(a1 + 48);
    if (v23)
    {
      uint64_t v24 = *a4;
      int v25 = (std::__shared_weak_count *)a4[1];
      *(void *)&long long v29 = v24;
      *((void *)&v29 + 1) = v25;
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        karo::JobManager::queueJob(v23, &v29);
        if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      else
      {
        karo::JobManager::queueJob(v23, &v29);
      }
    }
    return;
  }
  uint64_t v27 = v10[11];
  uint64_t v26 = v10[12];
  if (v26) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v26 + 8), 1uLL, memory_order_relaxed);
  }
  *a4 = v27;
  a4[1] = v26;
}

void sub_1A2123314(_Unwind_Exception *a1)
{
  operator delete(v2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::C3bTileRequestId,altitude::C3bRequestData>::requestT@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, unsigned int a5@<W4>, char a6@<W5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a3) {
    a3 = *(_DWORD *)(a1 + 88) + 1;
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, a2, a7);
  unsigned int v16 = v22;
  unsigned int v17 = atomic_load(v22 + 4);
  if (v17 != a4) {
    (*(void (**)(unsigned int *, uint64_t))(*(void *)v22 + 24))(v22, a4);
  }
  v16[45] = a3;
  v16[46] = a5;
  *((unsigned char *)v16 + 176) = a6;
  uint64_t v18 = v22;
  unsigned int v19 = v23;
  *a8 = off_1EF5677B0;
  a8[1] = v18;
  a8[2] = v19;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v18 = (unsigned int *)a8[1];
  }
  if (v18) {
    atomic_fetch_add((atomic_uint *volatile)v18 + 32, 1u);
  }
  long long v20 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A21234C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::C3bTileRequestId,altitude::C3bRequestData>::requestT(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 88) + 1;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*a2 != v9)
  {
    do
    {
      uint64_t v10 = v8 + 56;
      (*(void (**)(unsigned int **__return_ptr, uint64_t))(*(void *)a1 + 96))(&v22, a1);
      BOOL v11 = v22;
      int v12 = *(_DWORD *)(v10 + 64);
      unsigned int v13 = *(_DWORD *)(v10 + 68);
      char v14 = *(unsigned char *)(v10 + 72);
      unsigned int v15 = atomic_load(v22 + 4);
      if (v15 != v12) {
        (*(void (**)(unsigned int *))(*(void *)v22 + 24))(v22);
      }
      v11[45] = a4;
      v11[46] = v13;
      *((unsigned char *)v11 + 176) = v14;
      unsigned int v16 = *(void **)(a3 + 8);
      if ((unint64_t)v16 >= *(void *)(a3 + 16))
      {
        unsigned int v19 = std::vector<karo::AsyncRequestManager::RequestHandle>::__emplace_back_slow_path<std::shared_ptr<karo::AsyncRequestManager::Request> &>((void **)a3, (uint64_t)v22, (uint64_t)v23);
      }
      else
      {
        *unsigned int v16 = off_1EF5677B0;
        unsigned int v17 = v22;
        v16[1] = v22;
        uint64_t v18 = (uint64_t)v23;
        v16[2] = v23;
        if (v18)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          unsigned int v17 = (unsigned int *)v16[1];
        }
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)v17 + 32, 1u);
        }
        unsigned int v19 = v16 + 3;
        *(void *)(a3 + 8) = v16 + 3;
      }
      *(void *)(a3 + 8) = v19;
      long long v20 = v23;
      if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      uint64_t v8 = v10 + 80;
    }
    while (v10 + 80 != v9);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void sub_1A21236B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 40));
  _Unwind_Resume(a1);
}

void altitude::C3bRequestManager::createRequest(uint64_t a1@<X2>, void *a2@<X8>)
{
  if (a1) {
    operator new();
  }
  *a2 = 0;
  a2[1] = 0;
}

void sub_1A2123B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (*(char *)(v31 + 439) < 0) {
    operator delete(*v32);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v31 + 376));
  double v34 = *(std::__shared_weak_count **)(v31 + 360);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  double v35 = *(std::__shared_weak_count **)(v31 + 344);
  if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
    std::__shared_weak_count::__release_weak(v35);
  }
  long double v36 = *(std::__shared_weak_count **)(v31 + 328);
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  uint64_t v37 = *(void *)(v31 + 296);
  if (v37)
  {
    uint64_t v38 = *(void *)(v31 + 304);
    double v39 = *(void **)(v31 + 296);
    if (v38 != v37)
    {
      do
      {
        long double v40 = *(std::__shared_weak_count **)(v38 - 8);
        if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
          std::__shared_weak_count::__release_weak(v40);
        }
        v38 -= 16;
      }
      while (v38 != v37);
      double v39 = *(void **)(v31 + 296);
    }
    *(void *)(v31 + 304) = v37;
    operator delete(v39);
  }
  long double v41 = *(std::__shared_weak_count **)(v31 + 288);
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
  double v42 = *(std::__shared_weak_count **)(v31 + 272);
  if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
  uint64_t v43 = *(std::__shared_weak_count **)(v31 + 224);
  if (v43)
  {
    if (!atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
      std::__shared_weak_count::__release_weak(v43);
    }
  }
  karo::Job::~Job((karo::Job *)v31);
  MEMORY[0x1A6239270]();
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<altitude::C3bLoadJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::C3bLoadJob>,std::allocator<altitude::C3bLoadJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::C3bLoadJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::C3bLoadJob>,std::allocator<altitude::C3bLoadJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void karo::AsyncRequestManagerTemplate<altitude::C3bTileRequestId,altitude::C3bRequestData>::createAndQueueRequest(void *a1@<X0>, uint64_t *a2@<X8>)
{
  (*(void (**)(void *))(*a1 + 64))(a1);
  unint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t v5 = *a2;
    size_t v6 = (std::__shared_weak_count *)a2[1];
    v7[0] = v5;
    v7[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v4, v7);
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      karo::JobManager::queueJob(v4, v7);
    }
  }
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::C3bTileRequestId,altitude::C3bRequestData>::clearRequest(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(void **)(a1 + 72);
  if (v4)
  {
    uint64_t v5 = a1 + 72;
    do
    {
      BOOL v6 = std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100]((uint64_t)(v4 + 4), a2);
      int v7 = v4 + 1;
      if (!v6)
      {
        int v7 = v4;
        uint64_t v5 = (uint64_t)v4;
      }
      unint64_t v4 = (void *)*v7;
    }
    while (*v7);
    if (v5 != a1 + 72 && !std::less<altitude::C3bTileRequestId>::operator()[abi:nn180100](a2, v5 + 32))
    {
      (*(void (**)(void))(**(void **)(v5 + 88) + 16))(*(void *)(v5 + 88));
      std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::erase((void *)(a1 + 64), v5);
    }
  }
  uint64_t v8 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v8);
}

void sub_1A21241A4(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::erase(void *a1, uint64_t a2)
{
  float64x2_t v3 = *(void **)(a2 + 8);
  if (v3)
  {
    do
    {
      unint64_t v4 = v3;
      float64x2_t v3 = (void *)*v3;
    }
    while (v3);
  }
  else
  {
    uint64_t v5 = (void *)a2;
    do
    {
      unint64_t v4 = (void *)v5[2];
      BOOL v6 = *v4 == (void)v5;
      uint64_t v5 = v4;
    }
    while (!v6);
  }
  if (*a1 == a2) {
    *a1 = v4;
  }
  int v7 = (uint64_t *)a1[1];
  --a1[2];
  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v7, (uint64_t *)a2);
  uint64_t v8 = *(std::__shared_weak_count **)(a2 + 96);
  if (!v8 || atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if ((*(char *)(a2 + 79) & 0x80000000) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  if (*(char *)(a2 + 79) < 0) {
LABEL_12:
  }
    operator delete(*(void **)(a2 + 56));
LABEL_13:
  operator delete((void *)a2);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::C3bTileRequestId,altitude::C3bRequestData>::removeFromRequests(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(void **)(a1 + 64);
  if (v4 != (void *)(a1 + 72))
  {
    while (v4[11] != a2)
    {
      uint64_t v5 = (void *)v4[1];
      if (v5)
      {
        do
        {
          BOOL v6 = v5;
          uint64_t v5 = (void *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          BOOL v6 = (void *)v4[2];
          BOOL v7 = *v6 == (void)v4;
          unint64_t v4 = v6;
        }
        while (!v7);
      }
      unint64_t v4 = v6;
      if (v6 == (void *)(a1 + 72)) {
        goto LABEL_12;
      }
    }
    std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::erase((void *)(a1 + 64), (uint64_t)v4);
  }
LABEL_12:
  uint64_t v8 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v8);
}

void sub_1A212434C(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::C3bTileRequestId,altitude::C3bRequestData>::pruneRequests(uint64_t a1, int a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  uint64_t v4 = *(void *)(a1 + 64);
  if (v4 != a1 + 72)
  {
    do
    {
      BOOL v7 = *(void **)(v4 + 8);
      uint64_t v8 = (void *)v4;
      if (v7)
      {
        do
        {
          uint64_t v9 = v7;
          BOOL v7 = (void *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          uint64_t v9 = (void *)v8[2];
          BOOL v10 = *v9 == (void)v8;
          uint64_t v8 = v9;
        }
        while (!v10);
      }
      uint64_t v11 = *(void *)(v4 + 88);
      if (atomic_load((unsigned int *)(v11 + 128))) {
        *(_DWORD *)(v11 + 180) = a2;
      }
      pthread_mutex_lock(*(pthread_mutex_t **)(v11 + 152));
      int v13 = *(_DWORD *)(v11 + 160);
      pthread_mutex_unlock(*(pthread_mutex_t **)(v11 + 152));
      if ((v13 & 1) != 0 && *(unsigned char *)(v11 + 176) && *(_DWORD *)(v11 + 180) != a2
        || (a2 - *(_DWORD *)(v11 + 180)) > *(_DWORD *)(v11 + 184))
      {
        (*(void (**)(uint64_t))(*(void *)v11 + 16))(v11);
        std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::erase((void *)(a1 + 64), v4);
      }
      uint64_t v4 = (uint64_t)v9;
    }
    while (v9 != (void *)(a1 + 72));
  }
  *(_DWORD *)(a1 + 88) = a2;
  uint64_t v5 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v5);
}

void sub_1A2124494(_Unwind_Exception *a1)
{
  pthread_mutex_unlock(*(pthread_mutex_t **)(v1 + 40));
  _Unwind_Resume(a1);
}

void altitude::C3bRequestManager::~C3bRequestManager(altitude::C3bRequestManager *this)
{
  altitude::C3bRequestManager::~C3bRequestManager(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF569898;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF567928;
  while (*((void *)this + 10))
    (*(void (**)(altitude::C3bRequestManager *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((char **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
}

void sub_1A21245D8(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(v1[9]);
  karo::AsyncRequestManager::~AsyncRequestManager((karo::AsyncRequestManager *)v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(char *a1)
{
  if (!a1) {
    return;
  }
  std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*(void *)a1);
  std::__tree<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::C3bTileRequestId,std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::C3bTileRequestId>,true>,std::allocator<std::__value_type<altitude::C3bTileRequestId,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void *)a1 + 1));
  uint64_t v2 = (std::__shared_weak_count *)*((void *)a1 + 12);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    if ((a1[79] & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if (a1[79] < 0) {
LABEL_5:
  }
    operator delete(*((void **)a1 + 7));
LABEL_6:
  operator delete(a1);
}

void altitude::C3bRequestManager::requestC3b(uint64_t a1, uint64_t a2, long long *a3, uint64_t a4, char a5, unsigned __int8 a6, unsigned int a7, unsigned int a8)
{
  int v13 = (_OWORD *)(a4 + 40);
  int v14 = *(_DWORD *)(a4 + 28);
  char v15 = *(unsigned char *)(a4 + 160);
  char v16 = *(unsigned char *)(a4 + 161);
  char v17 = *(unsigned char *)(a4 + 162);
  uint64_t v28 = *(void *)(a4 + 168);
  if (*(char *)(a4 + 63) < 0)
  {
    std::string::__init_copy_ctor_external(&v29, *(const std::string::value_type **)(a4 + 40), *(void *)(a4 + 48));
  }
  else
  {
    *(_OWORD *)&v29.__r_.__value_.__l.__data_ = *v13;
    v29.__r_.__value_.__r.__words[2] = *(void *)(a4 + 56);
  }
  if (*(char *)(a4 + 159) < 0) {
    std::string::__init_copy_ctor_external(&v30, *(const std::string::value_type **)(a4 + 136), *(void *)(a4 + 144));
  }
  else {
    std::string v30 = *(std::string *)(a4 + 136);
  }
  BOOL v31 = v14 == 1;
  char v32 = v15;
  char v33 = v16;
  char v34 = v17;
  char v35 = a5;
  __int16 v36 = 1;
  char v37 = 0;
  int v18 = *(_DWORD *)(a4 + 168);
  long long v24 = *a3;
  int v25 = v18;
  if (*(char *)(a4 + 63) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)(a4 + 40), *(void *)(a4 + 48));
  }
  else {
    std::string __p = *(std::string *)v13;
  }
  char v27 = 0;
  (*(void (**)(uint64_t, long long *, void, void, void, void, uint64_t *))(*(void *)a2 + 80))(a2, &v24, 0, a7, a8, 0, &v28);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v19 = *(void *)(a1 + 8);
  long long v20 = *(std::__shared_weak_count **)(a1 + 16);
  if (v20) {
    atomic_fetch_add_explicit(&v20->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v19) {
    atomic_store(a6, (unsigned __int8 *)(v19 + 504));
  }
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
    if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_19:
      if ((SHIBYTE(v29.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_23:
      operator delete(v29.__r_.__value_.__l.__data_);
      return;
    }
  }
  else if ((SHIBYTE(v30.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_19;
  }
  operator delete(v30.__r_.__value_.__l.__data_);
  if (SHIBYTE(v29.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_23;
  }
}

void sub_1A21248DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,void *a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
}

uint64_t altitude::C3bRequestManager::getResult(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _WORD *a6, _WORD *a7)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, void))(*(void *)a1 + 96))(&v74, a1, a2, 0);
  uint64_t v14 = v74;
  uint64_t v72 = v74;
  double v73 = v75;
  if (v75) {
    atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v14 + 40))(v14);
  if (v15)
  {
    (*(void (**)(long long *__return_ptr, uint64_t))(*(void *)v14 + 48))(&v70, v14);
    long long v16 = v70;
    long long v70 = 0uLL;
    char v17 = *(std::__shared_weak_count **)(a3 + 8);
    *(_OWORD *)a3 = v16;
    if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    int v18 = (std::__shared_weak_count *)*((void *)&v70 + 1);
    if (*((void *)&v70 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v70 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
    uint64_t v19 = v72;
    if (v72 + 296 != a4) {
      std::vector<std::shared_ptr<unsigned char>>::__assign_with_size[abi:nn180100]<std::shared_ptr<unsigned char>*,std::shared_ptr<unsigned char>*>(a4, *(uint64_t **)(v72 + 296), *(uint64_t **)(v72 + 304), (uint64_t)(*(void *)(v72 + 304) - *(void *)(v72 + 296)) >> 4);
    }
    *((void *)&v70 + 1) = 0;
    uint64_t v71 = 0;
    *(void *)&long long v70 = (char *)&v70 + 8;
    std::set<altitude::TileKey>::insert[abi:nn180100]<std::__tree_const_iterator<altitude::TileKey,std::__tree_node<altitude::TileKey,void *> *,long>>((uint64_t *)&v70, *(void **)(v19 + 368), (void *)(v19 + 376));
    uint64_t v20 = a5 + 8;
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a5 + 8));
    uint64_t v21 = (void *)*((void *)&v70 + 1);
    *(void *)a5 = v70;
    *(void *)(a5 + 8) = v21;
    uint64_t v22 = v71;
    *(void *)(a5 + 16) = v71;
    if (v22)
    {
      void v21[2] = v20;
      *(void *)&long long v70 = (char *)&v70 + 8;
      *((void *)&v70 + 1) = 0;
      uint64_t v71 = 0;
      uint64_t v21 = 0;
    }
    else
    {
      *(void *)a5 = v20;
    }
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v21);
    *a6 = *(_WORD *)(v19 + 506);
    *a7 = *(_WORD *)(v19 + 508);
    double v23 = (*(double *)(v19 + 528) - *(double *)(v19 + 512)) * 1000.0;
    uint64_t v24 = *(void *)(**(void **)(a1 + 32) + 688);
    if (!v24) {
      goto LABEL_44;
    }
    int v25 = (int)v23 + 1;
    uint64_t v26 = *(void *)(v24 + 216);
    char v27 = *(char **)(v24 + 224);
    if ((unint64_t)&v27[-v26] >= 0x51)
    {
      uint64_t v28 = &v27[-v26 - 4];
      if (v27 != (char *)(v26 + 4))
      {
        double v29 = (*(double *)(v19 + 528) - *(double *)(v19 + 512)) * 1000.0;
        memmove(*(void **)(v24 + 216), (const void *)(v26 + 4), (size_t)&v27[-v26 - 4]);
        double v23 = v29;
      }
      v27 -= 4;
      *(void *)(v24 + 224) = &v28[v26];
    }
    unint64_t v30 = *(void *)(v24 + 232);
    if ((unint64_t)v27 < v30)
    {
      *(_DWORD *)char v27 = v25;
      BOOL v31 = v27 + 4;
LABEL_43:
      *(void *)(v24 + 224) = v31;
LABEL_44:
      uint64_t v50 = *(void *)(a1 + 136);
      if (v50)
      {
        double v51 = *(double *)(v19 + 528);
        double v52 = *(double *)(v19 + 520);
        double v53 = *(double *)(v19 + 560);
        double v54 = *(double *)(v19 + 536);
        double v55 = (v53 - v54) * 1000.0;
        double v56 = *(double *)(v19 + 568);
        double v57 = *(double *)(v19 + 544);
        double v58 = (v56 - v57) * 1000.0;
        double v59 = *(double *)(v19 + 552);
        double v60 = (v54 - *(double *)(v19 + 512)) * 1000.0;
        double v61 = (v57 - v53) * 1000.0;
        double v62 = (v59 - v56) * 1000.0;
        double v66 = (*(double *)(v19 + 576) - v59) * 1000.0;
        double v67 = *(double *)(v19 + 584);
        double v68 = *(double *)(v19 + 592);
        double v69 = *(double *)(v19 + 600);
        gdc::Statistics::addSampleValue(v50, "C3bLoadJobTotalTime (ms)", 0xACB6353900000018, v23);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobMainTime (ms)", 0xA458119900000017, (v51 - v52) * 1000.0);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobWait0Time (ms)", 0xC40FFE0F00000018, v60);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobStep0Time (ms)", 0xC1585ADE00000018, v55);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobWait1Time (ms)", 0x2BCD953100000018uLL, v61);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobStep1Time (ms)", 0x2E9A31E000000018uLL, v58);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobWait2Time (ms)", 0xC0FA2E3200000018, v62);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobStep2Time (ms)", 0xC5AD8AE300000018, v66);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobDecodeTime (ms)", 0xB9E3537A00000019, v67);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobDecodeMeshTime (ms)", 0x40FA9F620000001DuLL, v68);
        gdc::Statistics::addSampleValue(*(void *)(a1 + 136), "C3bLoadJobDownloadC3bTime (ms)", 0x15ACBEBC0000001EuLL, v69);
      }
      goto LABEL_46;
    }
    char v32 = *(char **)(v24 + 216);
    uint64_t v33 = (v27 - v32) >> 2;
    unint64_t v34 = v33 + 1;
    if ((unint64_t)(v33 + 1) >> 62) {
      abort();
    }
    uint64_t v35 = v30 - (void)v32;
    if (v35 >> 1 > v34) {
      unint64_t v34 = v35 >> 1;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v36 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v36 = v34;
    }
    if (v36)
    {
      if (v36 >> 62) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      double v37 = v23;
      uint64_t v38 = operator new(4 * v36);
      double v23 = v37;
    }
    else
    {
      uint64_t v38 = 0;
    }
    double v39 = (int *)&v38[4 * v33];
    long double v40 = &v38[4 * v36];
    *double v39 = v25;
    BOOL v31 = v39 + 1;
    if (v27 != v32)
    {
      unint64_t v41 = v27 - v32 - 4;
      if (v41 < 0x2C)
      {
        double v42 = v27;
        goto LABEL_40;
      }
      if ((unint64_t)(v32 - v38) < 0x20)
      {
        double v42 = v27;
        do
        {
LABEL_40:
          int v48 = *((_DWORD *)v42 - 1);
          v42 -= 4;
          *--double v39 = v48;
        }
        while (v42 != v32);
        goto LABEL_41;
      }
      uint64_t v43 = (v41 >> 2) + 1;
      double v42 = &v27[-4 * (v43 & 0x7FFFFFFFFFFFFFF8)];
      uint64_t v44 = &v38[4 * v33 - 16];
      uint64_t v45 = v27 - 16;
      uint64_t v46 = v43 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v47 = *(_OWORD *)v45;
        *(v44 - 1) = *((_OWORD *)v45 - 1);
        *uint64_t v44 = v47;
        v44 -= 2;
        v45 -= 32;
        v46 -= 8;
      }
      while (v46);
      v39 -= v43 & 0x7FFFFFFFFFFFFFF8;
      if (v43 != (v43 & 0x7FFFFFFFFFFFFFF8)) {
        goto LABEL_40;
      }
    }
LABEL_41:
    *(void *)(v24 + 216) = v39;
    *(void *)(v24 + 224) = v31;
    *(void *)(v24 + 232) = v40;
    if (v32)
    {
      double v49 = v23;
      operator delete(v32);
      double v23 = v49;
    }
    goto LABEL_43;
  }
LABEL_46:
  double v63 = v73;
  if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
    std::__shared_weak_count::__release_weak(v63);
  }
  double v64 = v75;
  if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
    std::__shared_weak_count::__release_weak(v64);
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
  return v15;
}

void sub_1A2124FA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  pthread_mutex_unlock(*(pthread_mutex_t **)(v8 + 40));
  _Unwind_Resume(a1);
}

unsigned __int8 *md::RouteLineData::mapDataKeyFromTile@<X0>(unsigned __int8 a1@<W0>, unsigned __int8 *a2@<X1>, int a3@<W2>, unsigned __int8 *a4@<X8>)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  int32x2_t v6 = vrev64_s32(*(int32x2_t *)(a2 + 4));
  int v4 = *a2;
  int v7 = a2[1];
  int v8 = v4;
  int v9 = a3;
  return gdc::LayerDataRequestKey::LayerDataRequestKey(a4, a1, 15, (int *)&v6, 5);
}

void **std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    float64x2_t v3 = (char *)a1[1];
    int v4 = *a1;
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 24;
      int32x2_t v6 = v3 - 24;
      int v7 = v3 - 24;
      do
      {
        int v8 = *(void (***)(char *))v7;
        v7 -= 24;
        (*v8)(v6);
        v5 -= 24;
        BOOL v9 = v6 == v2;
        int32x2_t v6 = v7;
      }
      while (!v9);
      int v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void md::RouteLineData::~RouteLineData(md::RouteLineData *this)
{
  md::RouteLineData::~RouteLineData(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  void (**v9)(char *);
  BOOL v10;
  uint64_t vars8;

  *(void *)this = &unk_1EF532E10;
  *((void *)this + 79) = &unk_1EF532E50;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 97);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    float64x2_t v3 = (char *)*((void *)this + 93);
    if (!v3) {
      goto LABEL_10;
    }
  }
  else
  {
    float64x2_t v3 = (char *)*((void *)this + 93);
    if (!v3) {
      goto LABEL_10;
    }
  }
  int v4 = (char *)*((void *)this + 94);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    int32x2_t v6 = v4 - 24;
    int v7 = v4 - 24;
    int v8 = v4 - 24;
    do
    {
      BOOL v9 = *(void (***)(char *))v8;
      v8 -= 24;
      (*v9)(v7);
      v6 -= 24;
      uint64_t v10 = v7 == v3;
      int v7 = v8;
    }
    while (!v10);
    uint64_t v5 = (char *)*((void *)this + 93);
  }
  *((void *)this + 94) = v3;
  operator delete(v5);
LABEL_10:
  std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy(*((void **)this + 91));
  md::MapTileData::~MapTileData(this);
}

char *md::TransitTransferAnnotationLabelPart::debugCompositeClassName@<X0>(uint64_t a1@<X8>)
{
  uint64_t result = (char *)operator new(0x28uLL);
  *(void *)a1 = result;
  *(_OWORD *)(a1 + 8) = xmmword_1A28FD6A0;
  strcpy(result, "TransitTransferAnnotationLabelPart");
  return result;
}

uint64_t md::TransitTransferAnnotationLabelPart::needsCrossfade(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (*(unsigned char *)(a1[2] + 1223) == 2) {
    return 1;
  }
  uint64_t v5 = a1[72];
  uint64_t v6 = a1[73];
  if (v5 == v6) {
    return 0;
  }
  uint64_t v10 = v5 + 8;
  do
  {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t))(**(void **)(v10 - 8) + 760))(*(void *)(v10 - 8), a2, a3, a4);
    if (result) {
      break;
    }
    BOOL v11 = v10 == v6;
    v10 += 8;
  }
  while (!v11);
  return result;
}

uint64_t md::TransitTransferAnnotationLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, float32x2_t *a3, float32x2_t *a4, __n128 a5, __n128 a6, double a7)
{
  if (*(unsigned char *)(a1 + 696)) {
    return 17;
  }
  uint64_t result = md::StackLabelPart::layoutForStaging(a1, a2, a3, a4, a5, a6, a7);
  if (result == 37)
  {
    if (*(unsigned char *)(a1 + 695))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      if (*(unsigned char *)(v9 + 1223) != 3)
      {
        uint64_t v10 = *(unsigned __int8 *)(a1 + 694);
        if (~v10 + ((uint64_t)(*(void *)(a1 + 584) - *(void *)(a1 + 576)) >> 3) == v10)
        {
          if (*(unsigned char *)(a1 + 694))
          {
            unint64_t v11 = 0;
            uint64_t v12 = 8 * v10 + 8;
            while (1)
            {
              int v13 = (uint64_t *)(*(void *)(a1 + 576) + 8 * v11);
              uint64_t v14 = *v13;
              uint64_t v15 = *(uint64_t *)((char *)v13 + v12);
              unsigned __int8 v16 = atomic_load((unsigned __int8 *)(*(void *)(v14 + 640) + 143));
              if (v16)
              {
                unsigned __int8 v17 = atomic_load((unsigned __int8 *)(*(void *)(v15 + 640) + 143));
                if (v17)
                {
                  uint64_t v18 = *(void *)(v14 + 640);
                  uint64_t v19 = *(void *)(v15 + 640);
                  if ((md::LabelIcon::operator==(v18, v19) & 1) == 0)
                  {
                    uint64_t v20 = *(void *)(v19 + 16);
                    id v21 = *(id *)(v18 + 16);
                    LODWORD(v20) = [v21 compareTo:v20];

                    if (!v20)
                    {
                      uint64_t v22 = *(void *)(a1 + 16);
                      if (*(unsigned char *)(v22 + 1223) != 3) {
                        *(unsigned char *)(v22 + 1223) = 2;
                      }
                      *(unsigned char *)(a1 + 696) = 1;
                      return 17;
                    }
                  }
                  *(unsigned char *)(a1 + 695) = 0;
                }
              }
              ++v11;
              uint64_t result = 37;
              if (v11 >= *(unsigned __int8 *)(a1 + 694)) {
                return result;
              }
            }
          }
        }
        else
        {
          *(unsigned char *)(v9 + 1223) = 3;
          *(unsigned char *)(a1 + 695) = 0;
        }
      }
    }
    return 37;
  }
  return result;
}

void sub_1A21254D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::TransitTransferAnnotationLabelPart::~TransitTransferAnnotationLabelPart(md::TransitTransferAnnotationLabelPart *this)
{
  md::CompositeLabelPart::~CompositeLabelPart(this);
  uint64_t v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

void sub_1A21256AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

float md::StandardRouteOverlayCache::animationCompletionPercentage(VKPolylineOverlay *this, VKPolylineOverlay *a2)
{
  int v3 = a2;
  md::StandardRouteOverlayCache::getInternalOverlay((md::StandardRouteOverlayCache *)&v7, this, v3);
  if (v7)
  {
    if (*(unsigned char *)(v7 + 857))
    {
      float v4 = *(float *)(v7 + 832);
      uint64_t v5 = v8;
      if (!v8) {
        goto LABEL_10;
      }
    }
    else
    {
      float v4 = 1.0;
      uint64_t v5 = v8;
      if (!v8) {
        goto LABEL_10;
      }
    }
  }
  else
  {
    float v4 = 0.0;
    uint64_t v5 = v8;
    if (!v8) {
      goto LABEL_10;
    }
  }
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_10:

  return v4;
}

void sub_1A2125808(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::StandardRouteOverlayCache::getInternalOverlay(md::StandardRouteOverlayCache *this, VKPolylineOverlay *a2, void *a3)
{
  unint64_t v29 = a3;
  int8x8_t v5 = *(int8x8_t *)&a2[1]._isReadyForSnapping;
  if (v5)
  {
    unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * v29) + 8) ^ HIDWORD(v29));
    unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(v29) ^ (v6 >> 47) ^ v6);
    unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v5);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = v8;
      if (v8 >= *(void *)&v5) {
        unint64_t v10 = v8 % *(void *)&v5;
      }
    }
    else
    {
      unint64_t v10 = v8 & (*(void *)&v5 - 1);
    }
    unint64_t v11 = (void *)*((void *)a2[1]._composedRoute + v10);
    if (v11)
    {
      uint64_t v12 = (void *)*v11;
      if (v12)
      {
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v13 = *(void *)&v5 - 1;
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v8 == v14)
            {
              if (v12[2] == v29) {
                goto LABEL_42;
              }
            }
            else if ((v14 & v13) != v10)
            {
              goto LABEL_22;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v15 = v12[1];
          if (v8 == v15)
          {
            if (v12[2] == v29)
            {
LABEL_42:
              uint64_t v28 = v12[4];
              *(void *)this = v12[3];
              *((void *)this + 1) = v28;
              if (!v28) {
                goto LABEL_39;
              }
LABEL_38:
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v28 + 8), 1uLL, memory_order_relaxed);
              goto LABEL_39;
            }
          }
          else
          {
            if (v15 >= *(void *)&v5) {
              v15 %= *(void *)&v5;
            }
            if (v15 != v10) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  traffic = a2[1]._traffic;
  if (!traffic)
  {
LABEL_35:
    *(void *)this = 0;
    *((void *)this + 1) = 0;
    goto LABEL_39;
  }
  while (1)
  {
    unsigned __int8 v17 = (void *)*((void *)traffic + 3);
    uint64_t v20 = (void *)*v17;
    uint64_t v19 = v17 + 1;
    uint64_t v18 = v20;
    if (v20 != v19) {
      break;
    }
LABEL_24:
    traffic = *(GEOComposedRouteTraffic **)traffic;
    if (!traffic) {
      goto LABEL_35;
    }
  }
  while (1)
  {
    id v21 = *(id *)(v18[4] + 144);
    id v22 = (id)v29;
    double v23 = v22;
    if (v21 == v22) {
      break;
    }
    int v24 = [v21 isEqual:v22];

    if (v24) {
      goto LABEL_37;
    }
    int v25 = (void *)v18[1];
    if (v25)
    {
      do
      {
        uint64_t v26 = v25;
        int v25 = (void *)*v25;
      }
      while (v25);
    }
    else
    {
      do
      {
        uint64_t v26 = (void *)v18[2];
        BOOL v27 = *v26 == (void)v18;
        uint64_t v18 = v26;
      }
      while (!v27);
    }
    uint64_t v18 = v26;
    if (v26 == v19) {
      goto LABEL_24;
    }
  }

LABEL_37:
  uint64_t v28 = v18[5];
  *(void *)this = v18[4];
  *((void *)this + 1) = v28;
  if (v28) {
    goto LABEL_38;
  }
LABEL_39:
}

void sub_1A2125A70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::StandardRouteOverlayCache::persistentOverlays(md::StandardRouteOverlayCache *this)
{
  return (uint64_t)this + 72;
}

uint64_t md::StandardRouteOverlayCache::removeOverlay(uint64_t a1, void *a2, int a3)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  double v62 = v5;
  if (!v5) {
    goto LABEL_19;
  }
  unint64_t v6 = v5;
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  id v8 = v6;
  if ((isKindOfClass & 1) == 0)
  {
    unint64_t v15 = (void *)(a1 + 96);
    unsigned __int8 v16 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)(a1 + 96), (unint64_t)v8);
    if (v16)
    {
      unsigned __int8 v17 = v16;
      int8x8_t v18 = *(int8x8_t *)(a1 + 104);
      unint64_t v19 = v16[1];
      uint8x8_t v20 = (uint8x8_t)vcnt_s8(v18);
      v20.i16[0] = vaddlv_u8(v20);
      if (v20.u32[0] > 1uLL)
      {
        if (v19 >= *(void *)&v18) {
          v19 %= *(void *)&v18;
        }
      }
      else
      {
        v19 &= *(void *)&v18 - 1;
      }
      uint64_t v26 = *(void **)(*v15 + 8 * v19);
      do
      {
        BOOL v27 = v26;
        uint64_t v26 = (void *)*v26;
      }
      while (v26 != v16);
      if (v27 == (void *)(a1 + 112)) {
        goto LABEL_63;
      }
      unint64_t v28 = v27[1];
      if (v20.u32[0] > 1uLL)
      {
        if (v28 >= *(void *)&v18) {
          v28 %= *(void *)&v18;
        }
      }
      else
      {
        v28 &= *(void *)&v18 - 1;
      }
      if (v28 != v19)
      {
LABEL_63:
        if (!*v16) {
          goto LABEL_64;
        }
        unint64_t v30 = *(void *)(*v16 + 8);
        if (v20.u32[0] > 1uLL)
        {
          if (v30 >= *(void *)&v18) {
            v30 %= *(void *)&v18;
          }
        }
        else
        {
          v30 &= *(void *)&v18 - 1;
        }
        if (v30 != v19) {
LABEL_64:
        }
          *(void *)(*v15 + 8 * v19) = 0;
      }
      uint64_t v34 = *v16;
      if (*v16)
      {
        unint64_t v35 = *(void *)(v34 + 8);
        if (v20.u32[0] > 1uLL)
        {
          if (v35 >= *(void *)&v18) {
            v35 %= *(void *)&v18;
          }
        }
        else
        {
          v35 &= *(void *)&v18 - 1;
        }
        if (v35 != v19)
        {
          *(void *)(*v15 + 8 * v35) = v27;
          uint64_t v34 = *v16;
        }
      }
      *BOOL v27 = v34;
      *unsigned __int8 v16 = 0;
      --*(void *)(a1 + 120);
      unint64_t v36 = (std::__shared_weak_count *)v16[4];
      if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
        std::__shared_weak_count::__release_weak(v36);
      }
      operator delete(v17);
      goto LABEL_76;
    }
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    id v21 = (id)GEOGetVectorKitRouteLog_log;
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_INFO)) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 138412290;
    double v64 = v8;
    goto LABEL_17;
  }
  uint8x8_t v9 = (void *)(a1 + 136);
  unint64_t v10 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)(a1 + 136), (unint64_t)v8);
  if (!v10)
  {
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    id v21 = (id)GEOGetVectorKitRouteLog_log;
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_INFO)) {
      goto LABEL_18;
    }
    *(_DWORD *)buf = 138412290;
    double v64 = v8;
LABEL_17:
    _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_INFO, "Failed to removed overlay %@. It is isnt being tracked", buf, 0xCu);
LABEL_18:

LABEL_19:
    uint64_t v22 = 0;
    goto LABEL_126;
  }
  unint64_t v11 = v10;
  int8x8_t v12 = *(int8x8_t *)(a1 + 144);
  unint64_t v13 = v10[1];
  uint8x8_t v14 = (uint8x8_t)vcnt_s8(v12);
  v14.i16[0] = vaddlv_u8(v14);
  if (v14.u32[0] > 1uLL)
  {
    if (v13 >= *(void *)&v12) {
      v13 %= *(void *)&v12;
    }
  }
  else
  {
    v13 &= *(void *)&v12 - 1;
  }
  double v23 = *(void **)(*v9 + 8 * v13);
  do
  {
    int v24 = v23;
    double v23 = (void *)*v23;
  }
  while (v23 != v10);
  if (v24 == (void *)(a1 + 152)) {
    goto LABEL_48;
  }
  unint64_t v25 = v24[1];
  if (v14.u32[0] > 1uLL)
  {
    if (v25 >= *(void *)&v12) {
      v25 %= *(void *)&v12;
    }
  }
  else
  {
    v25 &= *(void *)&v12 - 1;
  }
  if (v25 != v13)
  {
LABEL_48:
    if (!*v10) {
      goto LABEL_49;
    }
    unint64_t v29 = *(void *)(*v10 + 8);
    if (v14.u32[0] > 1uLL)
    {
      if (v29 >= *(void *)&v12) {
        v29 %= *(void *)&v12;
      }
    }
    else
    {
      v29 &= *(void *)&v12 - 1;
    }
    if (v29 != v13) {
LABEL_49:
    }
      *(void *)(*v9 + 8 * v13) = 0;
  }
  uint64_t v31 = *v10;
  if (*v10)
  {
    unint64_t v32 = *(void *)(v31 + 8);
    if (v14.u32[0] > 1uLL)
    {
      if (v32 >= *(void *)&v12) {
        v32 %= *(void *)&v12;
      }
    }
    else
    {
      v32 &= *(void *)&v12 - 1;
    }
    if (v32 != v13)
    {
      *(void *)(*v9 + 8 * v32) = v24;
      uint64_t v31 = *v10;
    }
  }
  *int v24 = v31;
  *unint64_t v10 = 0;
  --*(void *)(a1 + 160);
  uint64_t v33 = (std::__shared_weak_count *)v10[4];
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  operator delete(v11);
  [*(id *)(a1 + 8) stopObserving:v8];
LABEL_76:

  double v37 = *(uint64_t **)(a1 + 56);
  if (v37)
  {
    uint64_t v38 = (uint64_t *)(a1 + 56);
    double v39 = *(void **)(a1 + 56);
    do
    {
      unint64_t v40 = v39[4];
      BOOL v41 = v40 >= (unint64_t)v62;
      if (v40 >= (unint64_t)v62) {
        double v42 = v39;
      }
      else {
        double v42 = v39 + 1;
      }
      if (v41) {
        uint64_t v38 = v39;
      }
      double v39 = (void *)*v42;
    }
    while (*v42);
    if (v38 != (uint64_t *)(a1 + 56) && (unint64_t)v62 >= v38[4])
    {
      uint64_t v43 = (uint64_t *)v38[1];
      if (v43)
      {
        do
        {
          uint64_t v44 = v43;
          uint64_t v43 = (uint64_t *)*v43;
        }
        while (v43);
      }
      else
      {
        uint64_t v45 = v38;
        do
        {
          uint64_t v44 = (uint64_t *)v45[2];
          BOOL v46 = *v44 == (void)v45;
          uint64_t v45 = v44;
        }
        while (!v46);
      }
      if (*(uint64_t **)(a1 + 48) == v38) {
        *(void *)(a1 + 48) = v44;
      }
      --*(void *)(a1 + 64);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v37, v38);
      operator delete(v38);
    }
  }
  if (a3)
  {
    long long v47 = *(uint64_t **)(a1 + 80);
    if (v47)
    {
      int v48 = (uint64_t *)(a1 + 80);
      double v49 = *(void **)(a1 + 80);
      do
      {
        unint64_t v50 = v49[4];
        BOOL v51 = v50 >= (unint64_t)v62;
        if (v50 >= (unint64_t)v62) {
          double v52 = v49;
        }
        else {
          double v52 = v49 + 1;
        }
        if (v51) {
          int v48 = v49;
        }
        double v49 = (void *)*v52;
      }
      while (*v52);
      if (v48 != (uint64_t *)(a1 + 80) && (unint64_t)v62 >= v48[4])
      {
        double v53 = (uint64_t *)v48[1];
        if (v53)
        {
          do
          {
            double v54 = v53;
            double v53 = (uint64_t *)*v53;
          }
          while (v53);
        }
        else
        {
          double v55 = v48;
          do
          {
            double v54 = (uint64_t *)v55[2];
            BOOL v46 = *v54 == (void)v55;
            double v55 = v54;
          }
          while (!v46);
        }
        if (*(uint64_t **)(a1 + 72) == v48) {
          *(void *)(a1 + 72) = v54;
        }
        --*(void *)(a1 + 88);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v47, v48);
        operator delete(v48);
      }
    }
  }
  uint64_t v56 = std::remove[abi:nn180100]<std::__wrap_iter<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>,objc_object  {objcproto14VKRouteOverlay}*>(*(void *)(a1 + 16), *(void *)(a1 + 24), &v62);
  if (*(void *)(a1 + 24) != v56)
  {
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    double v57 = (id)GEOGetVectorKitRouteLog_log;
    if (os_log_type_enabled(v57, OS_LOG_TYPE_INFO))
    {
      double v58 = "false";
      if (a3) {
        double v58 = "true";
      }
      uint64_t v59 = *(void *)(a1 + 64);
      uint64_t v60 = *(void *)(a1 + 88);
      *(_DWORD *)buf = 138413058;
      double v64 = v62;
      __int16 v65 = 2080;
      double v66 = v58;
      __int16 v67 = 1024;
      int v68 = v59;
      __int16 v69 = 1024;
      int v70 = v60;
      _os_log_impl(&dword_1A1780000, v57, OS_LOG_TYPE_INFO, "Removed overlay %@ isPersistent:%s overlaysInViewCount:%d persistentOverlaysCount:%d", buf, 0x22u);
    }

    std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::erase(a1 + 16, v56, *(void *)(a1 + 24));
  }
  uint64_t v22 = 1;
LABEL_126:

  return v22;
}

void sub_1A212619C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::remove[abi:nn180100]<std::__wrap_iter<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> *>,objc_object  {objcproto14VKRouteOverlay}*>(uint64_t a1, uint64_t a2, void **a3)
{
  if (a1 == a2)
  {
LABEL_5:
    uint64_t v5 = a2;
  }
  else
  {
    uint64_t v5 = a1;
    while ((geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(*(void **)(v5 + 8), a3) & 1) == 0)
    {
      v5 += 24;
      if (v5 == a2) {
        goto LABEL_5;
      }
    }
  }
  if (v5 != a2)
  {
    for (uint64_t i = v5 + 24; i != a2; i += 24)
    {
      if ((geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(*(void **)(i + 8), a3) & 1) == 0)
      {
        objc_storeStrong((id *)(v5 + 8), *(id *)(i + 8));
        unint64_t v7 = *(void **)(i + 8);
        *(void *)(i + 8) = 0;

        v5 += 24;
      }
    }
  }
  return v5;
}

void std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::erase(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2 != a3)
  {
    uint64_t v3 = a2;
    uint64_t v5 = a3;
    uint64_t v6 = *(void *)(a1 + 8);
    if (a3 != v6)
    {
      uint64_t v7 = 8 * ((a3 - a2) >> 3);
      do
      {
        objc_storeStrong((id *)(v3 + 8), *(id *)(v3 + v7 + 8));
        id v8 = *(void **)(v3 + v7 + 8);
        *(void *)(v3 + v7 + 8) = 0;

        v3 += 24;
      }
      while (v3 + v7 != v6);
      uint64_t v5 = *(void *)(a1 + 8);
    }
    if (v5 != v3)
    {
      uint64_t v9 = v5 - 24;
      unint64_t v10 = (void (***)(void))(v5 - 24);
      unint64_t v11 = (void (***)(void))(v5 - 24);
      do
      {
        int8x8_t v12 = *v11;
        v11 -= 3;
        (*v12)(v10);
        v9 -= 24;
        BOOL v13 = v10 == (void (***)(void))v3;
        unint64_t v10 = v11;
      }
      while (!v13);
    }
    *(void *)(a1 + 8) = v3;
  }
}

uint64_t geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(void *a1, void **a2)
{
  id v3 = a1;
  float v4 = *a2;
  id v5 = v3;
  id v6 = v4;
  if (v6 == v5) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = [v5 isEqual:v6];
  }

  return v7;
}

void sub_1A21263D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::RouteLineOverlay>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 200);
  *(void *)(a1 + 200) = 0;

  id v3 = *(void **)(a1 + 208);
  *(void *)(a1 + 208) = 0;

  float v4 = *(void **)(a1 + 216);
  *(void *)(a1 + 216) = 0;

  *(_WORD *)(a1 + 872) = 256;
  id v5 = *(void **)(a1 + 720);
  if (v5)
  {
    [v5 stop];
    id v6 = *(void **)(a1 + 720);
    *(void *)(a1 + 720) = 0;
  }
  id v7 = *(id *)(a1 + 168);
  [v7 setRouteRibbon:0];

  id v8 = *(void **)(a1 + 696);
  if (v8)
  {
    *(void *)(a1 + 704) = v8;
    operator delete(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 688);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  uint64_t v10 = *(void *)(a1 + 672);
  *(void *)(a1 + 672) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  uint64_t v11 = *(void *)(a1 + 664);
  *(void *)(a1 + 664) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = *(void *)(a1 + 592);
  if (v12)
  {
    *(void *)(a1 + 600) = v12;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 616) + 40))(*(void *)(a1 + 616), v12, *(void *)(a1 + 608) - v12);
  }
  uint64_t v13 = *(void *)(a1 + 560);
  if (v13)
  {
    *(void *)(a1 + 568) = v13;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 584) + 40))(*(void *)(a1 + 584), v13, *(void *)(a1 + 576) - v13);
  }
  uint8x8_t v14 = *(void **)(a1 + 528);
  if (v14)
  {
    if ((*v14)-- == 1)
    {
      md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v14 + 1));
      {
        operator new();
      }
      (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *(void *)(a1 + 528), 400);
      *(void *)(a1 + 528) = 0;
    }
  }
  unsigned __int8 v16 = *(id **)(a1 + 504);
  if (v16)
  {
    do
    {
      unsigned __int8 v17 = (id *)*v16;

      operator delete(v16);
      unsigned __int8 v16 = v17;
    }
    while (v17);
  }
  int8x8_t v18 = *(void **)(a1 + 488);
  *(void *)(a1 + 488) = 0;
  if (v18) {
    operator delete(v18);
  }
  std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::less<GEOComposedRouteSection * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,mdm::Allocator>>::destroy(a1 + 456, *(void *)(a1 + 464));
  uint64_t v19 = *(void *)(a1 + 448);
  *(void *)(a1 + 448) = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = *(void *)(a1 + 440);
  *(void *)(a1 + 440) = 0;
  if (v20)
  {
    uint64_t v21 = ggl::FragmentedPool<ggl::Debug::ExtendedMesh>::~FragmentedPool(v20);
    MEMORY[0x1A6239270](v21, 0x10A0C40D234DDC7);
  }
  uint64_t v22 = *(void *)(a1 + 432);
  *(void *)(a1 + 432) = 0;
  if (v22)
  {
    uint64_t v23 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v22);
    MEMORY[0x1A6239270](v23, 0x10A0C40D234DDC7);
  }
  uint64_t v24 = *(void *)(a1 + 424);
  *(void *)(a1 + 424) = 0;
  if (v24)
  {
    uint64_t v25 = ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>::~FragmentedPool(v24);
    MEMORY[0x1A6239270](v25, 0x10A0C40D234DDC7);
  }
  uint64_t v26 = *(void *)(a1 + 416);
  *(void *)(a1 + 416) = 0;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  uint64_t v27 = *(void *)(a1 + 408);
  *(void *)(a1 + 408) = 0;
  if (v27)
  {
    uint64_t v28 = ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::~FragmentedPool(v27);
    MEMORY[0x1A6239270](v28, 0x10A0C40D234DDC7);
  }
  uint64_t v29 = *(void *)(a1 + 400);
  *(void *)(a1 + 400) = 0;
  if (v29)
  {
    uint64_t v30 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v29);
    MEMORY[0x1A6239270](v30, 0x10A0C40D234DDC7);
  }
  uint64_t v31 = *(void *)(a1 + 392);
  *(void *)(a1 + 392) = 0;
  if (v31)
  {
    uint64_t v32 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::~FragmentedPool(v31);
    MEMORY[0x1A6239270](v32, 0x10A0C40D234DDC7);
  }
  uint64_t v33 = *(void *)(a1 + 384);
  *(void *)(a1 + 384) = 0;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
  }
  uint64_t v34 = *(void *)(a1 + 376);
  *(void *)(a1 + 376) = 0;
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
  }
  unint64_t v35 = *(md::ManeuverPointSet **)(a1 + 368);
  *(void *)(a1 + 368) = 0;
  if (v35)
  {
    md::ManeuverPointSet::~ManeuverPointSet(v35);
    MEMORY[0x1A6239270]();
  }
  uint64_t v36 = *(void *)(a1 + 360);
  *(void *)(a1 + 360) = 0;
  if (v36) {
    (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
  }
  uint64_t v37 = *(void *)(a1 + 352);
  *(void *)(a1 + 352) = 0;
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
  }
  uint64_t v38 = *(void *)(a1 + 344);
  *(void *)(a1 + 344) = 0;
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
  }
  double v39 = *(md::RouteLineSharedRenderStates **)(a1 + 336);
  *(void *)(a1 + 336) = 0;
  if (v39) {
    std::default_delete<md::RouteLineSharedResources>::operator()[abi:nn180100](v39);
  }
  unint64_t v40 = *(void **)(a1 + 312);
  if (v40)
  {
    BOOL v41 = *(void **)(a1 + 320);
    double v42 = *(void **)(a1 + 312);
    if (v41 != v40)
    {
      do
      {
        uint64_t v44 = *--v41;
        uint64_t v43 = v44;
        *BOOL v41 = 0;
        if (v44) {
          (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
        }
      }
      while (v41 != v40);
      double v42 = *(void **)(a1 + 312);
    }
    *(void *)(a1 + 320) = v40;
    operator delete(v42);
  }
  uint64_t v45 = *(void **)(a1 + 304);
  *(void *)(a1 + 304) = 0;
  if (v45) {
    std::default_delete<md::RouteLineArrowSharedResources>::operator()[abi:nn180100](v45);
  }
  uint64_t v46 = *(void *)(a1 + 296);
  *(void *)(a1 + 296) = 0;
  if (v46) {
    (*(void (**)(uint64_t))(*(void *)v46 + 8))(v46);
  }
  uint64_t v47 = *(void *)(a1 + 288);
  *(void *)(a1 + 288) = 0;
  if (v47) {
    (*(void (**)(uint64_t))(*(void *)v47 + 8))(v47);
  }
  int v48 = *(std::__shared_weak_count **)(a1 + 280);
  if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
    std::__shared_weak_count::__release_weak(v48);
  }
  double v49 = *(std::__shared_weak_count **)(a1 + 264);
  if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
    std::__shared_weak_count::__release_weak(v49);
  }
  unint64_t v50 = *(std::__shared_weak_count **)(a1 + 248);
  if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
    std::__shared_weak_count::__release_weak(v50);
  }

  *(void *)(a1 + 160) = off_1EF559738;
  BOOL v51 = *(void **)(a1 + 24);
}

void sub_1A2126B08(_Unwind_Exception *a1)
{
  id v3 = *(void **)(v1 + 696);
  if (v3)
  {
    *(void *)(v1 + 704) = v3;
    operator delete(v3);
  }
  float v4 = *(std::__shared_weak_count **)(v1 + 688);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  uint64_t v5 = *(void *)(v1 + 672);
  *(void *)(v1 + 672) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *(void *)(v1 + 664);
  *(void *)(v1 + 664) = 0;
  if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
    uint64_t v7 = *(void *)(v1 + 592);
    if (!v7)
    {
LABEL_10:
      uint64_t v8 = *(void *)(v1 + 560);
      if (!v8) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v7 = *(void *)(v1 + 592);
    if (!v7) {
      goto LABEL_10;
    }
  }
  *(void *)(v1 + 600) = v7;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 616) + 40))(*(void *)(v1 + 616), v7, *(void *)(v1 + 608) - v7);
  uint64_t v8 = *(void *)(v1 + 560);
  if (!v8)
  {
LABEL_12:
    geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>::~fast_shared_ptr((void *)(v1 + 528));
    uint64_t v9 = *(id **)(v1 + 504);
    if (v9)
    {
      do
      {
        uint64_t v10 = (id *)*v9;

        operator delete(v9);
        uint64_t v9 = v10;
      }
      while (v10);
    }
    uint64_t v11 = *(void **)(v1 + 488);
    *(void *)(v1 + 488) = 0;
    if (v11) {
      operator delete(v11);
    }
    std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::less<GEOComposedRouteSection * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,mdm::Allocator>>::destroy(v1 + 456, *(void *)(v1 + 464));
    uint64_t v12 = *(void *)(v1 + 448);
    *(void *)(v1 + 448) = 0;
    if (v12) {
      (*(void (**)(uint64_t))(*(void *)v12 + 8))(v12);
    }
    uint64_t v13 = *(void *)(v1 + 440);
    *(void *)(v1 + 440) = 0;
    if (v13)
    {
      uint64_t v14 = ggl::FragmentedPool<ggl::Debug::ExtendedMesh>::~FragmentedPool(v13);
      MEMORY[0x1A6239270](v14, 0x10A0C40D234DDC7);
    }
    uint64_t v15 = *(void *)(v1 + 432);
    *(void *)(v1 + 432) = 0;
    if (v15)
    {
      uint64_t v16 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v15);
      MEMORY[0x1A6239270](v16, 0x10A0C40D234DDC7);
    }
    uint64_t v17 = *(void *)(v1 + 424);
    *(void *)(v1 + 424) = 0;
    if (v17)
    {
      uint64_t v18 = ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>::~FragmentedPool(v17);
      MEMORY[0x1A6239270](v18, 0x10A0C40D234DDC7);
    }
    uint64_t v19 = *(void *)(v1 + 416);
    *(void *)(v1 + 416) = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
    uint64_t v20 = *(void *)(v1 + 408);
    *(void *)(v1 + 408) = 0;
    if (v20)
    {
      uint64_t v21 = ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::~FragmentedPool(v20);
      MEMORY[0x1A6239270](v21, 0x10A0C40D234DDC7);
    }
    uint64_t v22 = *(void *)(v1 + 400);
    *(void *)(v1 + 400) = 0;
    if (v22)
    {
      uint64_t v23 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v22);
      MEMORY[0x1A6239270](v23, 0x10A0C40D234DDC7);
    }
    uint64_t v24 = *(void *)(v1 + 392);
    *(void *)(v1 + 392) = 0;
    if (v24)
    {
      uint64_t v25 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::~FragmentedPool(v24);
      MEMORY[0x1A6239270](v25, 0x10A0C40D234DDC7);
    }
    uint64_t v26 = *(void *)(v1 + 384);
    *(void *)(v1 + 384) = 0;
    if (v26) {
      (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
    }
    uint64_t v27 = *(void *)(v1 + 376);
    *(void *)(v1 + 376) = 0;
    if (v27) {
      (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
    }
    uint64_t v28 = *(md::ManeuverPointSet **)(v1 + 368);
    *(void *)(v1 + 368) = 0;
    if (v28)
    {
      md::ManeuverPointSet::~ManeuverPointSet(v28);
      MEMORY[0x1A6239270]();
    }
    uint64_t v29 = *(void *)(v1 + 360);
    *(void *)(v1 + 360) = 0;
    if (v29) {
      (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
    }
    uint64_t v30 = *(void *)(v1 + 352);
    *(void *)(v1 + 352) = 0;
    if (v30) {
      (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
    }
    uint64_t v31 = *(void *)(v1 + 344);
    *(void *)(v1 + 344) = 0;
    if (v31) {
      (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
    }
    uint64_t v32 = *(md::RouteLineSharedRenderStates **)(v1 + 336);
    *(void *)(v1 + 336) = 0;
    if (v32) {
      std::default_delete<md::RouteLineSharedResources>::operator()[abi:nn180100](v32);
    }
    uint64_t v33 = *(void **)(v1 + 312);
    if (v33)
    {
      uint64_t v34 = *(void **)(v1 + 320);
      unint64_t v35 = *(void **)(v1 + 312);
      if (v34 != v33)
      {
        do
        {
          uint64_t v37 = *--v34;
          uint64_t v36 = v37;
          *uint64_t v34 = 0;
          if (v37) {
            (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
          }
        }
        while (v34 != v33);
        unint64_t v35 = *(void **)(v1 + 312);
      }
      *(void *)(v1 + 320) = v33;
      operator delete(v35);
    }
    uint64_t v38 = *(void **)(v1 + 304);
    *(void *)(v1 + 304) = 0;
    if (v38) {
      std::default_delete<md::RouteLineArrowSharedResources>::operator()[abi:nn180100](v38);
    }
    uint64_t v39 = *(void *)(v1 + 296);
    *(void *)(v1 + 296) = 0;
    if (v39) {
      (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
    }
    uint64_t v40 = *(void *)(v1 + 288);
    *(void *)(v1 + 288) = 0;
    if (v40) {
      (*(void (**)(uint64_t))(*(void *)v40 + 8))(v40);
    }
    BOOL v41 = *(std::__shared_weak_count **)(v1 + 280);
    if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
    double v42 = *(std::__shared_weak_count **)(v1 + 264);
    if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
    uint64_t v43 = *(std::__shared_weak_count **)(v1 + 248);
    if (v43)
    {
      if (!atomic_fetch_add(&v43->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
        std::__shared_weak_count::__release_weak(v43);
      }
    }

    *(void *)(v1 + 160) = off_1EF559738;
    _Unwind_Resume(a1);
  }
LABEL_11:
  *(void *)(v1 + 568) = v8;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 584) + 40))(*(void *)(v1 + 584), v8, *(void *)(v1 + 576) - v8);
  goto LABEL_12;
}

void std::__shared_ptr_emplace<md::RouteLineOverlay>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580330;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RouteLineOverlay>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580330;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::RouteLineOverlayGroup>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = (void *)(a1 + 32);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 32));
  *(v2 - 1) = v2;
  void *v2 = 0;
  v2[1] = 0;
  if (v2[8])
  {
    id v3 = *(void **)(a1 + 88);
    while (v3)
    {
      float v4 = v3;
      id v3 = (void *)*v3;
      uint64_t v5 = (std::__shared_weak_count *)v4[4];
      if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
      operator delete(v4);
    }
    *(void *)(a1 + 88) = 0;
    uint64_t v6 = *(void *)(a1 + 80);
    if (v6)
    {
      for (uint64_t i = 0; i != v6; ++i)
        *(void *)(*(void *)(a1 + 72) + 8 * i) = 0;
    }
    *(void *)(a1 + 96) = 0;
  }
  uint64_t v9 = *(void (****)(void))(a1 + 48);
  uint64_t v8 = *(void (****)(void))(a1 + 56);
  if (v8 != v9)
  {
    uint64_t v10 = v8 - 3;
    uint64_t v11 = v8 - 3;
    uint64_t v12 = v8 - 3;
    do
    {
      uint64_t v13 = *v12;
      v12 -= 3;
      (*v13)(v11);
      v10 -= 3;
      BOOL v14 = v11 == v9;
      uint64_t v11 = v12;
    }
    while (!v14);
  }
  *(void *)(a1 + 56) = v9;
  objc_storeWeak((id *)(a1 + 120), 0);
  uint64_t v15 = *(std::__shared_weak_count **)(a1 + 152);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
    uint64_t v16 = *(std::__shared_weak_count **)(a1 + 136);
    if (!v16) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v16 = *(std::__shared_weak_count **)(a1 + 136);
    if (!v16) {
      goto LABEL_22;
    }
  }
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
LABEL_22:
  objc_destroyWeak((id *)(a1 + 120));

  uint64_t v17 = *(void **)(a1 + 88);
  while (v17)
  {
    uint64_t v18 = v17;
    uint64_t v17 = (void *)*v17;
    uint64_t v19 = (std::__shared_weak_count *)v18[4];
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    operator delete(v18);
  }
  uint64_t v20 = *(void **)(a1 + 72);
  *(void *)(a1 + 72) = 0;
  if (v20) {
    operator delete(v20);
  }
  uint64_t v21 = *(void (****)(void))(a1 + 48);
  if (v21)
  {
    uint64_t v22 = *(void (****)(void))(a1 + 56);
    uint64_t v23 = *(void **)(a1 + 48);
    if (v22 != v21)
    {
      uint64_t v24 = v22 - 3;
      uint64_t v25 = v22 - 3;
      uint64_t v26 = v22 - 3;
      do
      {
        uint64_t v27 = *v26;
        v26 -= 3;
        (*v27)(v25);
        v24 -= 3;
        BOOL v14 = v25 == v21;
        uint64_t v25 = v26;
      }
      while (!v14);
      uint64_t v23 = *(void **)(a1 + 48);
    }
    *(void *)(a1 + 56) = v21;
    operator delete(v23);
  }
  uint64_t v28 = (void *)*v2;
  std::__tree<gdc::LayerDataWithWorld>::destroy(v28);
}

void std::__shared_ptr_emplace<md::RouteLineOverlayGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581360;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::RouteLineOverlayGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581360;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t md::StandardRouteOverlayCache::isStandard(md::StandardRouteOverlayCache *this)
{
  return 1;
}

float md::StandardRouteOverlayCache::routeLineHalfWidthAtZ(VKPolylineOverlay *this, VKPolylineOverlay *a2, float a3)
{
  uint64_t v5 = a2;
  md::StandardRouteOverlayCache::getInternalOverlay((md::StandardRouteOverlayCache *)&v14, this, v5);
  float v6 = 0.0;
  if (v14)
  {
    uint64_t v7 = *(void *)(v14 + 504);
    if (v7)
    {
      uint64_t v8 = *(void *)(v7 + 256);
      uint64_t v9 = *(std::__shared_weak_count **)(v7 + 264);
      if (v9) {
        atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v18 = v8;
      uint64_t v19 = v9;
      uint64_t v16 = 0;
      uint64_t v17 = 0;
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v20, v8, (uint64_t)v9);
      if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      uint64_t v10 = v17;
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
        if (!v21) {
          goto LABEL_12;
        }
      }
      else if (!v21)
      {
LABEL_12:
        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v20);
        goto LABEL_13;
      }
      md::RouteLineSection::halfWidthAtZoom(v20, a3);
      float v6 = v11;
      goto LABEL_12;
    }
  }
LABEL_13:
  uint64_t v12 = v15;
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }

  return v6;
}

void sub_1A212767C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

uint64_t md::StandardRouteOverlayCache::hasPolylineOverlay(md::StandardRouteOverlayCache *this, VKPolylineOverlay *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = (char *)*((void *)this + 6);
  uint64_t v5 = (char *)this + 56;
  if (v4 == (char *)this + 56)
  {
LABEL_24:
    uint64_t v15 = 0;
    goto LABEL_27;
  }
  while (1)
  {
    uint64_t v6 = (VKPolylineOverlay *)*((id *)v4 + 4);
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      break;
    }
    if (v6 == v3)
    {
      uint64_t v6 = v3;
      goto LABEL_26;
    }
LABEL_18:

    uint64_t v12 = (char *)*((void *)v4 + 1);
    if (v12)
    {
      do
      {
        uint64_t v13 = v12;
        uint64_t v12 = *(char **)v12;
      }
      while (v12);
    }
    else
    {
      do
      {
        uint64_t v13 = (char *)*((void *)v4 + 2);
        BOOL v14 = *(void *)v13 == (void)v4;
        uint64_t v4 = v13;
      }
      while (!v14);
    }
    uint64_t v4 = v13;
    if (v13 == v5) {
      goto LABEL_24;
    }
  }
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  uint64_t v7 = [(VKPolylineOverlay *)v6 polylines];
  uint64_t v8 = [v7 countByEnumeratingWithState:&v17 objects:v21 count:16];
  if (!v8)
  {
LABEL_16:

    goto LABEL_18;
  }
  uint64_t v9 = *(void *)v18;
LABEL_5:
  if (*(void *)v18 == v9)
  {
    uint64_t v10 = (VKPolylineOverlay **)*((void *)&v17 + 1);
    while (*v10 != v3)
    {
      ++v10;
      if (!--v8) {
        goto LABEL_15;
      }
    }
  }
  else
  {
    uint64_t v11 = 0;
    while (1)
    {
      if (*(void *)v18 != v9) {
        objc_enumerationMutation(v7);
      }
      if (*(VKPolylineOverlay **)(*((void *)&v17 + 1) + 8 * v11) == v3) {
        break;
      }
      if (v8 == ++v11)
      {
LABEL_15:
        uint64_t v8 = [v7 countByEnumeratingWithState:&v17 objects:v21 count:16];
        if (v8) {
          goto LABEL_5;
        }
        goto LABEL_16;
      }
    }
  }

LABEL_26:
  uint64_t v15 = 1;
LABEL_27:

  return v15;
}

void sub_1A21278A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::StandardRouteOverlayCache::~StandardRouteOverlayCache(md::StandardRouteOverlayCache *this)
{
  md::StandardRouteOverlayCache::~StandardRouteOverlayCache(this);
  JUMPOUT(0x1A6239270);
}

{
  void **v2;
  void (***v3)(void);
  void (***v4)(void);
  void (***v5)(void);
  void (***v6)(void);
  void (***v7)(void);
  void (**v8)(void);
  BOOL v9;
  void *v10;
  void *v11;
  std::__shared_weak_count *v12;
  void *v13;
  void *v14;
  void **v15;
  void *v16;
  void *v17;
  void *v18;
  std::__shared_weak_count *v19;
  void *v20;
  void (***v21)(void);
  void (***v22)(void);
  void *v23;
  void (***v24)(void);
  void (***v25)(void);
  void (***v26)(void);
  void (**v27)(void);
  void **v28;
  void *v29[2];

  *(void *)this = off_1EF546DA0;
  v29[0] = 0;
  v29[1] = 0;
  uint64_t v28 = v29;
  std::set<objc_object  {objcproto14VKRouteOverlay}*>::insert[abi:nn180100]<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(&v28, *((void **)this + 9), (void *)this + 10);
  uint64_t v2 = v28;
  if (v28 != v29)
  {
    do
    {
      uint64_t v13 = v2[4];
      (*(void (**)(md::StandardRouteOverlayCache *, void *, uint64_t))(*(void *)this + 96))(this, v13, 1);

      BOOL v14 = v2[1];
      if (v14)
      {
        do
        {
          uint64_t v15 = (void **)v14;
          BOOL v14 = (void *)*v14;
        }
        while (v14);
      }
      else
      {
        do
        {
          uint64_t v15 = (void **)v2[2];
          uint64_t v9 = *v15 == v2;
          uint64_t v2 = v15;
        }
        while (!v9);
      }
      uint64_t v2 = v15;
    }
    while (v15 != v29);
  }
  uint64_t v4 = (void (***)(void))*((void *)this + 2);
  id v3 = (void (***)(void))*((void *)this + 3);
  if (v3 != v4)
  {
    uint64_t v5 = v3 - 3;
    uint64_t v6 = v3 - 3;
    uint64_t v7 = v3 - 3;
    do
    {
      uint64_t v8 = *v7;
      v7 -= 3;
      (*v8)(v6);
      v5 -= 3;
      uint64_t v9 = v6 == v4;
      uint64_t v6 = v7;
    }
    while (!v9);
  }
  *((void *)this + 3) = v4;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v29[0]);
  uint64_t v10 = (void *)*((void *)this + 19);
  while (v10)
  {
    uint64_t v11 = v10;
    uint64_t v10 = (void *)*v10;
    uint64_t v12 = (std::__shared_weak_count *)v11[4];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v11);
  }
  uint64_t v16 = (void *)*((void *)this + 17);
  *((void *)this + 17) = 0;
  if (v16) {
    operator delete(v16);
  }
  long long v17 = (void *)*((void *)this + 14);
  while (v17)
  {
    long long v18 = v17;
    long long v17 = (void *)*v17;
    long long v19 = (std::__shared_weak_count *)v18[4];
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    operator delete(v18);
  }
  long long v20 = (void *)*((void *)this + 12);
  *((void *)this + 12) = 0;
  if (v20) {
    operator delete(v20);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 7));
  char v21 = (void (***)(void))*((void *)this + 2);
  if (v21)
  {
    uint64_t v22 = (void (***)(void))*((void *)this + 3);
    uint64_t v23 = (void *)*((void *)this + 2);
    if (v22 != v21)
    {
      uint64_t v24 = v22 - 3;
      uint64_t v25 = v22 - 3;
      uint64_t v26 = v22 - 3;
      do
      {
        uint64_t v27 = *v26;
        v26 -= 3;
        (*v27)(v25);
        v24 -= 3;
        uint64_t v9 = v25 == v21;
        uint64_t v25 = v26;
      }
      while (!v9);
      uint64_t v23 = (void *)*((void *)this + 2);
    }
    *((void *)this + 3) = v21;
    operator delete(v23);
  }
}

void sub_1A2127BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a11);
  std::unordered_map<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>::~unordered_map[abi:nn180100](v11 + 136);
  std::unordered_map<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>::~unordered_map[abi:nn180100](v11 + 96);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v11 + 80));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v11 + 56));
  std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100]((void **)(v11 + 16));

  _Unwind_Resume(a1);
}

void md::StandardRouteOverlayCache::onPolylineSkippedInGroup(md::StandardRouteOverlayCache *this, VKPolylineGroupOverlay *a2, VKPolylineOverlay *a3)
{
  uint64_t v5 = a2;
  uint64_t v6 = a3;
  uint64_t v16 = v5;
  uint64_t v7 = std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)this + 17, (unint64_t)v16);
  if (!v7)
  {

    goto LABEL_26;
  }
  uint64_t v9 = (void *)v7[3];
  uint64_t v8 = (std::__shared_weak_count *)v7[4];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (v9)
  {
    uint64_t v10 = v6;
    if (v10)
    {
      uint64_t v11 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v9 + 6, (unint64_t)v10);
      if (v11)
      {
        uint64_t v12 = v11[3];
        uint64_t v13 = (std::__shared_weak_count *)v11[4];
        if (v13)
        {
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
          if (v9[15] == v12)
          {
LABEL_19:
            if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
            goto LABEL_21;
          }
          atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_15:
          BOOL v14 = (std::__shared_weak_count *)v9[16];
          v9[15] = v12;
          v9[16] = v13;
          if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
            std::__shared_weak_count::__release_weak(v14);
          }
          if (!v13) {
            goto LABEL_21;
          }
          goto LABEL_19;
        }
        if (v9[15] != v12)
        {
          uint64_t v13 = 0;
          goto LABEL_15;
        }
      }
    }
    else if (v9[15])
    {
      uint64_t v13 = 0;
      uint64_t v12 = 0;
      goto LABEL_15;
    }
LABEL_21:

    uint64_t v15 = **(void **)(*((void *)this + 5) + 88);
    if (v15)
    {
      char v17 = 7;
      md::MapEngine::setNeedsTick(v15, &v17);
    }
  }
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_26:
}

void md::StandardRouteOverlayCache::onPolylineFocusedInGroup(md::StandardRouteOverlayCache *this, VKPolylineGroupOverlay *a2, VKPolylineOverlay *a3)
{
  uint64_t v3 = **(void **)(*((void *)this + 5) + 88);
  if (v3)
  {
    char v4 = 7;
    md::MapEngine::setNeedsTick(v3, &v4);
  }
}

void md::StandardRouteOverlayCache::onPolylineSelectedInGroup(md::StandardRouteOverlayCache *this, VKPolylineGroupOverlay *a2, VKPolylineOverlay *a3)
{
  uint64_t v5 = a2;
  uint64_t v6 = a3;
  long long v18 = v5;
  uint64_t v7 = std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)this + 17, (unint64_t)v18);
  if (!v7)
  {

    goto LABEL_35;
  }
  uint64_t v9 = (void *)v7[3];
  uint64_t v8 = (std::__shared_weak_count *)v7[4];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }

  if (v9)
  {
    uint64_t v10 = (std::__shared_weak_count *)v9[14];
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v11 = v6;
    if (v11)
    {
      uint64_t v12 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v9 + 6, (unint64_t)v11);
      if (!v12)
      {
LABEL_27:

        uint64_t v17 = **(void **)(*((void *)this + 5) + 88);
        if (v17)
        {
          char v19 = 7;
          md::MapEngine::setNeedsTick(v17, &v19);
        }
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        goto LABEL_32;
      }
      uint64_t v13 = v12[3];
      BOOL v14 = (std::__shared_weak_count *)v12[4];
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    else
    {
      BOOL v14 = 0;
      uint64_t v13 = 0;
    }
    uint64_t v15 = v9[13];
    if (v15 != v13)
    {
      if (v15) {
        *(unsigned char *)(v15 + 620) = 0;
      }
      if (v14) {
        atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v16 = (std::__shared_weak_count *)v9[14];
      v9[13] = v13;
      v9[14] = v14;
      if (v16)
      {
        if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        uint64_t v13 = v9[13];
      }
      if (v13) {
        *(unsigned char *)(v13 + 620) = 1;
      }
    }
    if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
    goto LABEL_27;
  }
LABEL_32:
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_35:
}

void md::StandardRouteOverlayCache::onPolylineRemovedFromGroup(md::StandardRouteOverlayCache *this, VKPolylineGroupOverlay *a2, VKPolylineOverlay *a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  uint64_t v6 = a3;
  if (GEOGetVectorKitRouteLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
  }
  uint64_t v7 = (id)GEOGetVectorKitRouteLog_log;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    uint64_t v8 = [(VKPolylineGroupOverlay *)v5 polylines];
    *(_DWORD *)buf = 138412802;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v5;
    __int16 v53 = 2048;
    uint64_t v54 = [v8 count];
    _os_log_impl(&dword_1A1780000, v7, OS_LOG_TYPE_INFO, "Removed polyline %@ from polylineGroupOverlay %@. PolylineOverlay count %zu", buf, 0x20u);
  }
  uint64_t v9 = v5;
  uint64_t v10 = std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)this + 17, (unint64_t)v9);
  if (v10)
  {
    uint64_t v12 = (uint64_t **)v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (v12)
    {
      uint64_t v13 = v6;
      BOOL v51 = v13;
      BOOL v14 = v12 + 6;
      uint64_t v15 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>(v12 + 6, (unint64_t)v13);
      if (v15)
      {
        uint64_t v16 = v15;
        unint64_t v17 = v15[3];
        uint64_t v18 = v15[4];
        *(void *)buf = v17;
        *(void *)&uint8_t buf[8] = v18;
        if (v18) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
        }
        char v19 = v12[1];
        if (v19)
        {
          long long v20 = (uint64_t *)(v12 + 1);
          char v21 = v12[1];
          do
          {
            unint64_t v22 = v21[4];
            BOOL v23 = v22 >= v17;
            if (v22 >= v17) {
              uint64_t v24 = (uint64_t **)v21;
            }
            else {
              uint64_t v24 = (uint64_t **)(v21 + 1);
            }
            if (v23) {
              long long v20 = v21;
            }
            char v21 = *v24;
          }
          while (*v24);
          if (v20 != (uint64_t *)(v12 + 1) && v17 >= v20[4])
          {
            uint64_t v25 = (uint64_t *)v20[1];
            if (v25)
            {
              do
              {
                uint64_t v26 = v25;
                uint64_t v25 = (uint64_t *)*v25;
              }
              while (v25);
            }
            else
            {
              uint64_t v27 = v20;
              do
              {
                uint64_t v26 = (uint64_t *)v27[2];
                BOOL v28 = *v26 == (void)v27;
                uint64_t v27 = v26;
              }
              while (!v28);
            }
            if (*v12 == v20) {
              *uint64_t v12 = v26;
            }
            v12[2] = (uint64_t *)((char *)v12[2] - 1);
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v19, v20);
            uint64_t v29 = (std::__shared_weak_count *)v20[5];
            if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
              std::__shared_weak_count::__release_weak(v29);
            }
            operator delete(v20);
          }
        }
        int8x8_t v30 = (int8x8_t)v12[7];
        unint64_t v31 = v16[1];
        uint8x8_t v32 = (uint8x8_t)vcnt_s8(v30);
        v32.i16[0] = vaddlv_u8(v32);
        if (v32.u32[0] > 1uLL)
        {
          if (v31 >= *(void *)&v30) {
            v31 %= *(void *)&v30;
          }
        }
        else
        {
          v31 &= *(void *)&v30 - 1;
        }
        uint64_t v33 = *(uint64_t **)(*v14 + 8 * v31);
        do
        {
          uint64_t v34 = (uint64_t **)v33;
          uint64_t v33 = (uint64_t *)*v33;
        }
        while (v33 != v16);
        if (v34 == v12 + 8) {
          goto LABEL_53;
        }
        unint64_t v35 = (unint64_t)v34[1];
        if (v32.u32[0] > 1uLL)
        {
          if (v35 >= *(void *)&v30) {
            v35 %= *(void *)&v30;
          }
        }
        else
        {
          v35 &= *(void *)&v30 - 1;
        }
        if (v35 != v31)
        {
LABEL_53:
          if (!*v16) {
            goto LABEL_54;
          }
          unint64_t v36 = *(void *)(*v16 + 8);
          if (v32.u32[0] > 1uLL)
          {
            if (v36 >= *(void *)&v30) {
              v36 %= *(void *)&v30;
            }
          }
          else
          {
            v36 &= *(void *)&v30 - 1;
          }
          if (v36 != v31) {
LABEL_54:
          }
            *(void *)(*v14 + 8 * v31) = 0;
        }
        uint64_t v37 = *v16;
        if (*v16)
        {
          unint64_t v38 = *(void *)(v37 + 8);
          if (v32.u32[0] > 1uLL)
          {
            if (v38 >= *(void *)&v30) {
              v38 %= *(void *)&v30;
            }
          }
          else
          {
            v38 &= *(void *)&v30 - 1;
          }
          if (v38 != v31)
          {
            *(void *)(*v14 + 8 * v38) = v34;
            uint64_t v37 = *v16;
          }
        }
        *uint64_t v34 = (uint64_t *)v37;
        *uint64_t v16 = 0;
        v12[9] = (uint64_t *)((char *)v12[9] - 1);
        uint64_t v39 = (std::__shared_weak_count *)v16[4];
        if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v39);
        }
        operator delete(v16);
        uint64_t v40 = v12[3];
        BOOL v41 = v12[4];
        if (v40 != v41)
        {
          while ((geo::_retain_ptr<VKPolylineOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==((void *)v40[1], (void **)&v51) & 1) == 0)
          {
            v40 += 3;
            if (v40 == v41)
            {
              uint64_t v40 = v41;
              break;
            }
          }
        }
        if (v40 != v41)
        {
          for (uint64_t i = v40 + 3; i != v41; i += 3)
          {
            if ((geo::_retain_ptr<VKPolylineOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==((void *)i[1], (void **)&v51) & 1) == 0)
            {
              objc_storeStrong((id *)v40 + 1, (id)i[1]);
              uint64_t v43 = (void *)i[1];
              i[1] = 0;

              v40 += 3;
            }
          }
        }
        uint64_t v44 = v12[4];
        if (v44 != v40)
        {
          uint64_t v45 = v44 - 3;
          uint64_t v46 = v45;
          uint64_t v47 = v45;
          do
          {
            int v48 = (void (**)(uint64_t *))*v47;
            v47 -= 3;
            (*v48)(v46);
            v45 -= 3;
            BOOL v28 = v46 == v40;
            uint64_t v46 = v47;
          }
          while (!v28);
          v12[4] = v40;
        }
        double v49 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8]
          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
          std::__shared_weak_count::__release_weak(v49);
        }
        uint64_t v13 = v51;
      }

      uint64_t v50 = **(void **)(*((void *)this + 5) + 88);
      if (v50)
      {
        buf[0] = 7;
        md::MapEngine::setNeedsTick(v50, buf);
      }
    }
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
  }
}

void sub_1A21286E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::StandardRouteOverlayCache::onPolylineAddedToGroup(md::StandardRouteOverlayCache *this, VKPolylineGroupOverlay *a2, VKPolylineOverlay *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  uint64_t v6 = a3;
  if (GEOGetVectorKitRouteLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
  }
  uint64_t v7 = (id)GEOGetVectorKitRouteLog_log;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    uint64_t v8 = [(VKPolylineGroupOverlay *)v5 polylines];
    *(_DWORD *)buf = 138412802;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v5;
    __int16 v16 = 2048;
    uint64_t v17 = [v8 count];
    _os_log_impl(&dword_1A1780000, v7, OS_LOG_TYPE_INFO, "Added polyline %@ to polylineGroupOverlay %@. PolylineOverlay count %zu", buf, 0x20u);
  }
  uint64_t v9 = v5;
  uint64_t v10 = std::__hash_table<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::__unordered_map_hasher<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::hash<md::mun::CollectionPoint const*>,std::equal_to<md::mun::CollectionPoint const*>,true>,std::__unordered_map_equal<md::mun::CollectionPoint const*,std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>,std::equal_to<md::mun::CollectionPoint const*>,std::hash<md::mun::CollectionPoint const*>,true>,std::allocator<std::__hash_value_type<md::mun::CollectionPoint const*,geo::small_vector<md::mun::CollectionPoint const*,6ul>>>>::find<md::mun::CollectionPoint const*>((void *)this + 17, (unint64_t)v9);
  if (v10)
  {
    uint64_t v12 = (md::RouteLineOverlayGroup *)v10[3];
    uint64_t v11 = (std::__shared_weak_count *)v10[4];
    *(void *)buf = v12;
    *(void *)&uint8_t buf[8] = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (v12)
    {
      md::RouteLineOverlayGroup::addPolyline(v12, v6);
      uint64_t v13 = **(void **)(*((void *)this + 5) + 88);
      if (v13)
      {
        char v14 = 7;
        md::MapEngine::setNeedsTick(v13, &v14);
      }
    }
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  else
  {
  }
}

void sub_1A2128918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);

  _Unwind_Resume(a1);
}

void ggl::FoggedDiffuseLandmark::LandmarkPipelineState::~LandmarkPipelineState(ggl::FoggedDiffuseLandmark::LandmarkPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  char v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  char v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::FoggedDiffuseLandmark::LandmarkPipelineState::LandmarkPipelineState(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4)
{
  {
    double v82 = a4;
    double v84 = a2;
    uint64_t v85 = a3;
    a2 = v84;
    a3 = v85;
    a4 = v82;
    if (v83)
    {
      {
        if (v83)
        {
          {
            {
              ggl::MeshTyped<ggl::Landmark::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::Landmark::defaultVboReflection;
            }
            ggl::MeshTyped<ggl::Landmark::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::Landmark::DefaultVbo>::attributesReflection(void)::r;
            unk_1EB32B758 = 1;
          }
          ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::Landmark::DefaultVbo>::typedReflection(void)::r;
          *(void *)algn_1E958FFB8 = &ggl::FoggedDiffuseLandmark::pipelineDataLandmarkPipelineDeviceStructs(void)::ref;
          qword_1E958FFC0 = 0;
          {
            ggl::FoggedDiffuseLandmark::pipelineDataLandmarkPipelineConstantStructs(void)::ref = (uint64_t)ggl::Fog::Skyfog::reflection(void)::reflection;
            unk_1E9590190 = ggl::Tile::View::reflection(void)::reflection;
            qword_1E9590198 = (uint64_t)ggl::Building::Scale::reflection(void)::reflection;
            unk_1E95901A0 = ggl::Building::Style::reflection(void)::reflection;
            qword_1E95901A8 = (uint64_t)ggl::Building::Gradient::reflection(void)::reflection;
            unk_1E95901B0 = ggl::Lighting::LightConfiguration::reflection(void)::reflection;
            qword_1E95901B8 = (uint64_t)ggl::Building::Fade::reflection(void)::reflection;
          }
          qword_1E958FFC8 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineDataLandmarkPipelineConstantStructs(void)::ref;
          *(_OWORD *)algn_1E958FFD0 = xmmword_1A28FD020;
        }
      }
      ggl::FoggedDiffuseLandmark::LandmarkPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup::typedReflection(void)::ref;
      ggl::FoggedDiffuseLandmarkShader::typedReflection(v83);
      qword_1E958FF60 = (uint64_t)&ggl::FoggedDiffuseLandmarkShader::typedReflection(void)::ref;
      {
        ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineAttributeStructBinding(void)::attr = 0;
        unk_1E958FFF0 = 0;
        qword_1E958FFF8 = (uint64_t)"";
        dword_1E9590000 = 0;
        qword_1E9590008 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineAttributeBinding_0(void)::attr;
        unk_1E9590010 = 3;
      }
      qword_1E958FF68 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineAttributeStructBinding(void)::attr;
      unk_1E958FF70 = 1;
      qword_1E958FF78 = 0;
      unk_1E958FF80 = 1;
      qword_1E958FF88 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineDeviceStructBinding(void)::ref;
      unk_1E958FF90 = 0;
      {
        ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantStructBinding(void)::ref = 0;
        unk_1E9590030 = 0;
        qword_1E9590038 = (uint64_t)"skyfog";
        dword_1E9590040 = 3;
        qword_1E9590048 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantSkyfogBinding(void)::reflection;
        *(_OWORD *)algn_1E9590050 = xmmword_1A28FD030;
        qword_1E9590060 = 1;
        unk_1E9590068 = "view";
        dword_1E9590070 = 3;
        qword_1E9590078 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantViewBinding(void)::reflection;
        unk_1E9590080 = vdupq_n_s64(2uLL);
        qword_1E9590090 = 2;
        unk_1E9590098 = "scale";
        dword_1E95900A0 = 3;
        qword_1E95900A8 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantScaleBinding(void)::reflection;
        *(_OWORD *)algn_1E95900B0 = xmmword_1A28FD040;
        qword_1E95900C0 = 3;
        unk_1E95900C8 = "style";
        dword_1E95900D0 = 3;
        qword_1E95900D8 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantStyleBinding(void)::reflection;
        unk_1E95900E0 = xmmword_1A28FD050;
        qword_1E95900F0 = 4;
        unk_1E95900F8 = "gradient";
        dword_1E9590100 = 3;
        qword_1E9590108 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantGradientBinding(void)::reflection;
        *(_OWORD *)algn_1E9590110 = xmmword_1A28FCF80;
        qword_1E9590120 = 5;
        unk_1E9590128 = "lightConfig";
        dword_1E9590130 = 3;
        qword_1E9590138 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantLightConfigBinding(void)::reflection;
        xmmword_1E9590140 = xmmword_1A28FD060;
        qword_1E9590150 = 6;
        unk_1E9590158 = "fade";
        dword_1E9590160 = 3;
        qword_1E9590168 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantFadeBinding(void)::reflection;
        unk_1E9590170 = 2;
      }
      qword_1E958FF98 = (uint64_t)&ggl::FoggedDiffuseLandmark::pipelineStateLandmarkPipelineConstantStructBinding(void)::ref;
      unk_1E958FFA0 = 7;
      a4 = v82;
      a2 = v84;
      a3 = v85;
    }
  }
  uint64_t v5 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)float64x2_t v88 = *(_OWORD *)a3;
  *(_OWORD *)&v88[12] = *(_OWORD *)(a3 + 12);
  long long v7 = *(_OWORD *)(a3 + 28);
  char v8 = *(unsigned char *)(a3 + 44);
  long long v86 = *a4;
  long long v87 = a4[1];
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_1EF55B208;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 40) = &ggl::FoggedDiffuseLandmark::LandmarkPipelineState::typedReflection(void)::ref;
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 116) = xmmword_1A28FC970;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 164) = xmmword_1A28FC970;
  *(void *)(a1 + 180) = 0;
  *(void *)(a1 + 196) = 0;
  *(void *)(a1 + 188) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 212) = xmmword_1A28FC970;
  *(void *)(a1 + 228) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 236) = 0;
  *(_OWORD *)(a1 + 256) = v86;
  *(_OWORD *)(a1 + 272) = v87;
  *(unsigned char *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0x100000001;
  *(unsigned char *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v88;
  *(_OWORD *)(a1 + 76) = *(_OWORD *)&v88[12];
  *(_OWORD *)(a1 + 92) = v7;
  *(unsigned char *)(a1 + 108) = v8;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *(unsigned char *)(a1 + 305) = 0;
  int8x16_t v9 = *(int8x16_t *)(a1 + 320);
  int8x16_t v10 = vceqzq_s8(*(int8x16_t *)(a1 + 304));
  int16x8_t v11 = vmovl_high_s8(v10);
  int32x4_t v12 = vmovl_s16(*(int16x4_t *)v11.i8);
  v13.i64[0] = v12.u32[0];
  v13.i64[1] = v12.u32[1];
  int8x16_t v14 = v13;
  int16x8_t v15 = vmovl_s8(*(int8x8_t *)v10.i8);
  int32x4_t v16 = vmovl_s16(*(int16x4_t *)v15.i8);
  *(void *)a1 = &unk_1EF55F730;
  v13.i64[0] = v16.u32[0];
  v13.i64[1] = v16.u32[1];
  int8x16_t v17 = v13;
  int32x4_t v18 = vmovl_high_s16(v11);
  v13.i64[0] = v18.u32[0];
  v13.i64[1] = v18.u32[1];
  int8x16_t v19 = v13;
  int32x4_t v20 = vmovl_high_s16(v15);
  v13.i64[0] = v20.u32[0];
  v13.i64[1] = v20.u32[1];
  int8x16_t v21 = v13;
  v13.i64[0] = v12.u32[2];
  v13.i64[1] = v12.u32[3];
  int8x16_t v22 = v13;
  v13.i64[0] = v16.u32[2];
  v13.i64[1] = v16.u32[3];
  int8x16_t v23 = v13;
  v13.i64[0] = v18.u32[2];
  v13.i64[1] = v18.u32[3];
  int8x16_t v24 = v13;
  v13.i64[0] = v20.u32[2];
  v13.i64[1] = v20.u32[3];
  int8x16_t v25 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v13);
  int8x16_t v26 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v24);
  int8x16_t v27 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v23);
  int8x16_t v28 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v19);
  int8x16_t v29 = vceqzq_s8(v9);
  int16x8_t v30 = vmovl_high_s8(v29);
  int32x4_t v31 = vmovl_s16(*(int16x4_t *)v30.i8);
  v13.i64[0] = v31.u32[0];
  v13.i64[1] = v31.u32[1];
  int8x16_t v32 = v13;
  int16x8_t v33 = vmovl_s8(*(int8x8_t *)v29.i8);
  int32x4_t v34 = vmovl_s16(*(int16x4_t *)v33.i8);
  v13.i64[0] = v34.u32[0];
  v13.i64[1] = v34.u32[1];
  int8x16_t v35 = v13;
  int32x4_t v36 = vmovl_high_s16(v30);
  v13.i64[0] = v36.u32[0];
  v13.i64[1] = v36.u32[1];
  int8x16_t v37 = v13;
  int32x4_t v38 = vmovl_high_s16(v33);
  v13.i64[0] = v38.u32[0];
  v13.i64[1] = v38.u32[1];
  int8x16_t v39 = v13;
  v13.i64[0] = v31.u32[2];
  v13.i64[1] = v31.u32[3];
  int8x16_t v40 = v13;
  v13.i64[0] = v34.u32[2];
  v13.i64[1] = v34.u32[3];
  int8x16_t v41 = v13;
  v13.i64[0] = v36.u32[2];
  v13.i64[1] = v36.u32[3];
  int8x16_t v42 = v13;
  v13.i64[0] = v38.u32[2];
  v13.i64[1] = v38.u32[3];
  int8x16_t v43 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v42);
  int8x16_t v44 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v32), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v14));
  int8x16_t v45 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v35), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v17));
  int8x16_t v46 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v37), v28);
  int8x16_t v47 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v39), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v21));
  int8x16_t v48 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v40), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v22));
  int8x16_t v49 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v41), v27);
  int8x16_t v50 = vorrq_s8(v43, v26);
  int8x16_t v51 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v13), v25);
  int8x16_t v52 = vceqzq_s8(*(int8x16_t *)(a1 + 336));
  int16x8_t v53 = vmovl_s8(*(int8x8_t *)v52.i8);
  int32x4_t v54 = vmovl_high_s16(v53);
  v13.i64[0] = v54.i32[2];
  v13.i64[1] = v54.i32[3];
  int8x16_t v55 = v13;
  int16x8_t v56 = vmovl_high_s8(v52);
  int32x4_t v57 = vmovl_high_s16(v56);
  v13.i64[0] = v57.i32[2];
  v13.i64[1] = v57.i32[3];
  int8x16_t v58 = v13;
  int32x4_t v59 = vmovl_s16(*(int16x4_t *)v53.i8);
  v13.i64[0] = v59.i32[2];
  v13.i64[1] = v59.i32[3];
  int8x16_t v60 = v13;
  int32x4_t v61 = vmovl_s16(*(int16x4_t *)v56.i8);
  v13.i64[0] = v61.i32[2];
  v13.i64[1] = v61.i32[3];
  int8x16_t v62 = v13;
  v13.i64[0] = v54.i32[0];
  v13.i64[1] = v54.i32[1];
  int8x16_t v63 = v13;
  v13.i64[0] = v57.i32[0];
  v13.i64[1] = v57.i32[1];
  int8x16_t v64 = v13;
  v13.i64[0] = v59.i32[0];
  v13.i64[1] = v59.i32[1];
  int8x16_t v65 = v13;
  v13.i64[0] = v61.i32[0];
  v13.i64[1] = v61.i32[1];
  int8x16_t v66 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v13);
  int8x16_t v67 = vceqzq_s8(*(int8x16_t *)(a1 + 352));
  int16x8_t v68 = vmovl_high_s8(v67);
  int32x4_t v69 = vmovl_s16(*(int16x4_t *)v68.i8);
  v13.i64[0] = v69.i32[0];
  v13.i64[1] = v69.i32[1];
  int8x16_t v70 = v13;
  int16x8_t v71 = vmovl_s8(*(int8x8_t *)v67.i8);
  int32x4_t v72 = vmovl_s16(*(int16x4_t *)v71.i8);
  v13.i64[0] = v72.i32[0];
  v13.i64[1] = v72.i32[1];
  int8x16_t v73 = v13;
  int32x4_t v74 = vmovl_high_s16(v68);
  v13.i64[0] = v74.i32[0];
  v13.i64[1] = v74.i32[1];
  int8x16_t v75 = v13;
  int32x4_t v76 = vmovl_high_s16(v71);
  v13.i64[0] = v76.i32[0];
  v13.i64[1] = v76.i32[1];
  int8x16_t v77 = v13;
  v13.i64[0] = v69.i32[2];
  v13.i64[1] = v69.i32[3];
  int8x16_t v78 = v13;
  v13.i64[0] = v72.i32[2];
  v13.i64[1] = v72.i32[3];
  int8x16_t v79 = v13;
  v13.i64[0] = v74.i32[2];
  v13.i64[1] = v74.i32[3];
  int8x16_t v80 = v13;
  v13.i64[0] = v76.i32[2];
  v13.i64[1] = v76.i32[3];
  *(void *)(a1 + 296) = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v73), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v65)), v45), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v70), v66), v44)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v77), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v63)), v47), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB40, v75), vbicq_s8((int8x16_t)xmmword_1A28FCA90, v64)),
                                               v46))),
                              (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v79), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v60)), v49), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v78), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v62)), v48)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v13), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v55)), v51), vorrq_s8(vorrq_s8(
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCB00, v80),
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v58)),
                                               v50)))));
  *(unsigned char *)(a1 + 288) = 1;
  return a1;
}

BOOL ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup::textureIsEnabled(ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup::constantDataIsEnabled(ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup *this, unint64_t a2)
{
  return a2 < 7;
}

void ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup::~LandmarkPipelineSetup(ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::RoadDataCache::getCacheKeyForKey@<X0>(uint64_t a1@<X0>, long long *a2@<X1>, uint64_t a3@<X8>)
{
  long long v4 = *a2;
  *(_OWORD *)a3 = *a2;
  uint64_t result = altitude::GeoResourceManager::getTileIdWithDataForTileId(*(void *)(*(void *)(a1 + 160) + 32), a2 + 1, v4);
  *(void *)(a3 + 16) = result;
  *(void *)(a3 + 24) = v6;
  return result;
}

void altitude::RoadDataCache::fetchData(uint64_t a1@<X1>, void *a2@<X8>)
{
  long long v4 = *(void **)a1;
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 8);
  if (v3) {
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (((*(uint64_t (**)(void *))(*v4 + 40))(v4) & 1) == 0)
  {
    *a2 = 0;
    a2[1] = 0;
    if (!v3) {
      return;
    }
    goto LABEL_9;
  }
  uint64_t v5 = v4[35];
  *a2 = v4[34];
  a2[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  if (v3)
  {
LABEL_9:
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

uint64_t altitude::GenericCacheNode<altitude::TileKey,altitude::RoadTileDataPrivate>::hasValidKey()
{
  return 1;
}

uint64_t altitude::GenericCacheNode<altitude::TileKey,altitude::RoadTileDataPrivate>::clear(uint64_t a1)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
  if (*(void *)(a1 + 120))
  {
    uint64_t v2 = *(void **)(a1 + 112);
    if (v2)
    {
      do
      {
        long long v7 = (void *)*v2;
        char v8 = (std::__shared_weak_count *)v2[7];
        if (v8) {
          std::__shared_weak_count::__release_weak(v8);
        }
        operator delete(v2);
        uint64_t v2 = v7;
      }
      while (v7);
    }
    *(void *)(a1 + 112) = 0;
    uint64_t v3 = *(void *)(a1 + 104);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(a1 + 96) + 8 * i) = 0;
    }
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v5 = *(pthread_mutex_t **)(a1 + 136);
  return pthread_mutex_unlock(v5);
}

BOOL altitude::RoadDataCache::hasDataAvailable(uint64_t a1, long long *a2)
{
  return altitude::GeoResourceManager::getTileIdWithDataForTileId(*(void *)(*(void *)(a1 + 160) + 32), a2 + 1, *(unsigned int *)a2) != 0;
}

void altitude::GenericCacheNode<altitude::TileKey,altitude::RoadTileDataPrivate>::requestCached(uint64_t a1@<X0>, _OWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, std::__shared_weak_count_vtbl **a5@<X8>)
{
  if (((*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1) & 1) == 0)
  {
    *a5 = 0;
    a5[1] = 0;
    a5[3] = 0;
    a5[4] = 0;
    a5[2] = (std::__shared_weak_count_vtbl *)off_1EF5677B0;
    return;
  }
  (*(void (**)(void **__return_ptr, uint64_t, _OWORD *))(*(void *)a1 + 144))(__p, a1, a2);
  long long v10 = a2[1];
  v59[0] = *a2;
  v59[1] = v10;
  long long v60 = *(_OWORD *)__p;
  long long v61 = v58;
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
  int8x8_t v11 = *(int8x8_t *)(a1 + 104);
  if (!*(void *)&v11) {
    goto LABEL_41;
  }
  unint64_t v12 = ((unint64_t)v61 << 58) | ((unint64_t)(DWORD1(v61) & 0x1FFFFFFF) << 29) | DWORD2(v61) & 0x1FFFFFFF;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v11);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    unint64_t v14 = ((unint64_t)v61 << 58) | ((unint64_t)(DWORD1(v61) & 0x1FFFFFFF) << 29) | DWORD2(v61) & 0x1FFFFFFF;
    if (v12 >= *(void *)&v11) {
      unint64_t v14 = v12 % *(void *)&v11;
    }
  }
  else
  {
    unint64_t v14 = v12 & (*(void *)&v11 - 1);
  }
  int16x8_t v15 = *(std::__shared_weak_count ***)(*(void *)(a1 + 96) + 8 * v14);
  if (!v15) {
    goto LABEL_41;
  }
  int32x4_t v16 = *v15;
  if (!*v15)
  {
LABEL_42:
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
    goto LABEL_43;
  }
  if (v13.u32[0] < 2uLL)
  {
    uint64_t v17 = *(void *)&v11 - 1;
    while (1)
    {
      uint64_t shared_owners = v16->__shared_owners_;
      if (shared_owners == v12)
      {
        if (LODWORD(v16[1].__shared_owners_) == v61
          && *(uint64_t *)((char *)&v16[1].__shared_owners_ + 4) == *(void *)((char *)&v61 + 4)
          && HIDWORD(v61) == HIDWORD(v16[1].__shared_weak_owners_)
          && LODWORD(v16->__shared_weak_owners_) == v60
          && *(uint64_t *)((char *)&v16->__shared_weak_owners_ + 4) == *(void *)((char *)&v60 + 4))
        {
          goto LABEL_31;
        }
      }
      else if ((shared_owners & v17) != v14)
      {
        goto LABEL_41;
      }
      int32x4_t v16 = (std::__shared_weak_count *)v16->__vftable;
      if (!v16) {
        goto LABEL_42;
      }
    }
  }
  while (1)
  {
    unint64_t v18 = v16->__shared_owners_;
    if (v18 == v12) {
      break;
    }
    if (v18 >= *(void *)&v11) {
      v18 %= *(void *)&v11;
    }
    if (v18 != v14) {
      goto LABEL_41;
    }
LABEL_13:
    int32x4_t v16 = (std::__shared_weak_count *)v16->__vftable;
    if (!v16) {
      goto LABEL_42;
    }
  }
  if (LODWORD(v16[1].__shared_owners_) != v61
    || *(uint64_t *)((char *)&v16[1].__shared_owners_ + 4) != *(void *)((char *)&v61 + 4)
    || HIDWORD(v61) != HIDWORD(v16[1].__shared_weak_owners_)
    || LODWORD(v16->__shared_weak_owners_) != v60
    || *(uint64_t *)((char *)&v16->__shared_weak_owners_ + 4) != *(void *)((char *)&v60 + 4))
  {
    goto LABEL_13;
  }
LABEL_31:
  if (((*(uint64_t (**)(uint64_t, long long *, uint64_t *))(*(void *)a1 + 128))(a1, &v60, &v16->__shared_weak_owners_) & 1) == 0)
  {
    std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 96), v16);
    int8x16_t v22 = __p[0];
    if (__p[0])
    {
      if ((_BYTE)v58)
      {
        int8x16_t v23 = (std::__shared_weak_count *)*((void *)__p[0] + 7);
        if (v23) {
          std::__shared_weak_count::__release_weak(v23);
        }
      }
      operator delete(v22);
    }
    goto LABEL_41;
  }
  int32x4_t v20 = (std::__shared_weak_count *)v16[2].__shared_owners_;
  if (!v20)
  {
LABEL_41:
    int32x4_t v16 = 0;
    goto LABEL_42;
  }
  int8x16_t v21 = v16[2].__vftable;
  atomic_fetch_add_explicit(&v20->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  int32x4_t v16 = std::__shared_weak_count::lock(v20);
  std::__shared_weak_count::__release_weak(v20);
  if (!v16) {
    goto LABEL_42;
  }
  pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
  if (v21)
  {
    __p[1] = 0;
    *(void *)&long long v58 = 0;
    __p[0] = off_1EF5677B0;
    *a5 = v21;
    a5[1] = (std::__shared_weak_count_vtbl *)v16;
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    a5[3] = 0;
    a5[4] = 0;
    a5[2] = (std::__shared_weak_count_vtbl *)off_1EF5677B0;
    goto LABEL_92;
  }
LABEL_43:
  (*(void (**)(void (***__return_ptr)(karo::AsyncRequestManager::RequestHandle *__hidden), uint64_t, _OWORD *, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 80))(&v54, a1, v59, a3, a4, 300, 1, 0);
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v54) == 4)
  {
    int8x16_t v51 = 0;
    int8x16_t v52 = 0;
    uint64_t v53 = 0;
    (*(void (**)(std::__shared_weak_count_vtbl **__return_ptr, uint64_t, std::__shared_weak_count_vtbl **, _OWORD *, void **))(*(void *)a1 + 136))(&v49, a1, &v55, v59, &v51);
    pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 136));
    int8x16_t v24 = std::__hash_table<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::__unordered_map_hasher<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::hash<altitude::TileKey>,std::equal_to<altitude::TileKey>,true>,std::__unordered_map_equal<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::equal_to<altitude::TileKey>,std::hash<altitude::TileKey>,true>,std::allocator<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>>>::__emplace_unique_key_args<altitude::TileKey,std::piecewise_construct_t const&,std::tuple<altitude::TileKey const&>,std::tuple<>>((float *)(a1 + 96), (int *)&v60, &v60);
    int8x16_t v26 = v49;
    int8x16_t v25 = v50;
    if (v50) {
      atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
    }
    int8x16_t v27 = (std::__shared_weak_count *)v24[7];
    v24[6] = v26;
    v24[7] = v25;
    if (v27) {
      std::__shared_weak_count::__release_weak(v27);
    }
    int8x16_t v28 = (int *)v51;
    if (v51 != v52)
    {
      do
      {
        int8x16_t v29 = std::__hash_table<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::__unordered_map_hasher<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::hash<altitude::TileKey>,std::equal_to<altitude::TileKey>,true>,std::__unordered_map_equal<altitude::TileKey,std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>,std::equal_to<altitude::TileKey>,std::hash<altitude::TileKey>,true>,std::allocator<std::__hash_value_type<altitude::TileKey,std::weak_ptr<karo::media::DigitalTerrainModel>>>>::__emplace_unique_key_args<altitude::TileKey,std::piecewise_construct_t const&,std::tuple<altitude::TileKey const&>,std::tuple<>>((float *)(a1 + 96), v28, v28);
        int32x4_t v31 = v49;
        int16x8_t v30 = v50;
        if (v50) {
          atomic_fetch_add_explicit(&v50->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        }
        int8x16_t v32 = (std::__shared_weak_count *)v29[7];
        v29[6] = v31;
        v29[7] = v30;
        if (v32) {
          std::__shared_weak_count::__release_weak(v32);
        }
        v28 += 8;
      }
      while (v28 != v52);
    }
    unsigned int v35 = *(_DWORD *)(a1 + 144) + 1;
    *(_DWORD *)(a1 + 144) = v35;
    if (v35 > 0x14)
    {
      *(_DWORD *)(a1 + 144) = 0;
      for (uint64_t i = *(void **)(a1 + 112); i; uint64_t i = (void *)*i)
      {
        while (1)
        {
          int8x16_t v37 = (std::__shared_weak_count *)i[7];
          if (!v37) {
            goto LABEL_71;
          }
          int32x4_t v38 = std::__shared_weak_count::lock(v37);
          if (!v38) {
            goto LABEL_71;
          }
          int8x16_t v39 = v38;
          uint64_t v40 = i[6];
          if (atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            break;
          }
          ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
          std::__shared_weak_count::__release_weak(v39);
          if (v40) {
            goto LABEL_68;
          }
LABEL_71:
          int8x16_t v41 = (void *)*i;
          std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::remove((uint64_t)__p, (void *)(a1 + 96), i);
          int8x16_t v42 = __p[0];
          if (__p[0])
          {
            if ((_BYTE)v58)
            {
              int8x16_t v43 = (std::__shared_weak_count *)*((void *)__p[0] + 7);
              if (v43) {
                std::__shared_weak_count::__release_weak(v43);
              }
            }
            operator delete(v42);
          }
          uint64_t i = v41;
          if (!v41) {
            goto LABEL_75;
          }
        }
        if (!v40) {
          goto LABEL_71;
        }
LABEL_68:
        ;
      }
    }
LABEL_75:
    int8x16_t v44 = v50;
    *a5 = v49;
    a5[1] = (std::__shared_weak_count_vtbl *)v44;
    if (v44) {
      atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    int8x16_t v45 = v55;
    int8x16_t v46 = v56;
    a5[2] = (std::__shared_weak_count_vtbl *)off_1EF5677B0;
    a5[3] = v45;
    a5[4] = (std::__shared_weak_count_vtbl *)v46;
    if (v46)
    {
      atomic_fetch_add_explicit(&v46->__shared_owners_, 1uLL, memory_order_relaxed);
      int8x16_t v45 = a5[3];
    }
    if (v45) {
      atomic_fetch_add((atomic_uint *volatile)&v45[3].~__shared_weak_count_0, 1u);
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 136));
    int8x16_t v47 = v50;
    if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
      std::__shared_weak_count::__release_weak(v47);
    }
    if (v51)
    {
      int8x16_t v52 = v51;
      operator delete(v51);
    }
  }
  else
  {
    *a5 = 0;
    a5[1] = 0;
    int16x8_t v33 = v55;
    int32x4_t v34 = v56;
    a5[2] = (std::__shared_weak_count_vtbl *)off_1EF5677B0;
    a5[3] = v33;
    a5[4] = (std::__shared_weak_count_vtbl *)v34;
    if (v34)
    {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
      int16x8_t v33 = a5[3];
    }
    if (v33) {
      atomic_fetch_add((atomic_uint *volatile)&v33[3].~__shared_weak_count_0, 1u);
    }
  }
  int32x4_t v54 = off_1EF5677B0;
  if (v55) {
    atomic_fetch_add((atomic_uint *volatile)&v55[3].~__shared_weak_count_0, 0xFFFFFFFF);
  }
  int8x16_t v48 = v56;
  if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
    std::__shared_weak_count::__release_weak(v48);
  }
  if (v16)
  {
LABEL_92:
    if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void altitude::RoadDataCache::createRequest()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

uint64_t std::__shared_ptr_pointer<altitude::RoadDataCacheJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::RoadDataCacheJob>,std::allocator<altitude::RoadDataCacheJob>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::RoadDataCacheJob *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::RoadDataCacheJob>,std::allocator<altitude::RoadDataCacheJob>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::RoadDataCacheJob::succeeded(altitude::RoadDataCacheJob *this)
{
  return *((unsigned __int8 *)this + 225);
}

void altitude::RoadDataCacheJob::jobStep(altitude::RoadDataCacheJob *this)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  atomic_load((unsigned int *)this + 4);
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 29) + 104))(&v6);
  if (v6) {
    operator new();
  }
  if (karo::AsyncRequestManager::RequestHandle::getStatus((karo::AsyncRequestManager::RequestHandle *)&v8))
  {
    uint64_t v2 = v10;
    v5[0] = v9;
    v5[1] = v10;
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::Job::addBlockingSubJob((uint64_t *)this, v5, 1, 0);
      if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
        std::__shared_weak_count::__release_weak(v2);
      }
    }
    else
    {
      karo::Job::addBlockingSubJob((uint64_t *)this, v5, 1, 0);
    }
  }
  else
  {
    (*(void (**)(altitude::RoadDataCacheJob *))(*(void *)this + 16))(this);
  }
  char v8 = off_1EF5677B0;
  if (v9) {
    atomic_fetch_add((atomic_uint *volatile)(v9 + 128), 0xFFFFFFFF);
  }
  uint64_t v3 = v10;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  long long v4 = v7;
  if (v7)
  {
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void sub_1A212A6A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__shared_ptr_pointer<altitude::RoadTileDataPrivate *,std::shared_ptr<altitude::RoadTileDataPrivate>::__shared_ptr_default_delete<altitude::RoadTileDataPrivate,altitude::RoadTileDataPrivate>,std::allocator<altitude::RoadTileDataPrivate>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (std::__shared_weak_count *)v1[14];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    uint64_t v3 = (std::__shared_weak_count *)v1[12];
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    uint64_t v4 = v1[1];
    if (v4)
    {
      uint64_t v5 = v1[2];
      uint64_t v6 = (void *)v1[1];
      if (v5 != v4)
      {
        do
        {
          long long v7 = *(std::__shared_weak_count **)(v5 - 8);
          if (v7) {
            std::__shared_weak_count::__release_weak(v7);
          }
          v5 -= 24;
        }
        while (v5 != v4);
        uint64_t v6 = (void *)v1[1];
      }
      v1[2] = v4;
      operator delete(v6);
    }
    pthread_mutex_destroy((pthread_mutex_t *)*v1);
    if (*v1) {
      MEMORY[0x1A6239270](*v1, 0x1000C40FA0F61DDLL);
    }
    *uint64_t v1 = 0;
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::RoadTileDataPrivate *,std::shared_ptr<altitude::RoadTileDataPrivate>::__shared_ptr_default_delete<altitude::RoadTileDataPrivate,altitude::RoadTileDataPrivate>,std::allocator<altitude::RoadTileDataPrivate>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void altitude::RoadDataCacheJob::~RoadDataCacheJob(altitude::RoadDataCacheJob *this)
{
  altitude::RoadDataCacheJob::~RoadDataCacheJob(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t v4;
  uint64_t vars8;

  *(void *)this = &unk_1EF5696B0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 37);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 35);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 35);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  *(void *)this = &unk_1EF56A2A8;
  if (*((char *)this + 223) < 0) {
    operator delete(*((void **)this + 25));
  }
  pthread_mutex_destroy(*((pthread_mutex_t **)this + 24));
  uint64_t v4 = *((void *)this + 24);
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x1000C40FA0F61DDLL);
  }
  *((void *)this + 24) = 0;
  karo::Job::~Job(this);
}

void altitude::RoadDataCache::~RoadDataCache(altitude::RoadDataCache *this)
{
  *(void *)this = &unk_1EF568CB8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  altitude::GenericCacheNode<altitude::TileKey,altitude::RoadTileDataPrivate>::~GenericCacheNode(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF568CB8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  altitude::GenericCacheNode<altitude::TileKey,altitude::RoadTileDataPrivate>::~GenericCacheNode(this);
}

void altitude::GenericCacheNode<altitude::TileKey,altitude::RoadTileDataPrivate>::~GenericCacheNode(karo::AsyncRequestManager *a1)
{
  *(void *)a1 = &unk_1EF5694A8;
  pthread_mutex_destroy(*((pthread_mutex_t **)a1 + 17));
  uint64_t v2 = *((void *)a1 + 17);
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40FA0F61DDLL);
  }
  *((void *)a1 + 17) = 0;
  uint64_t v3 = (void *)*((void *)a1 + 14);
  if (v3)
  {
    do
    {
      uint64_t v5 = (void *)*v3;
      uint64_t v6 = (std::__shared_weak_count *)v3[7];
      if (v6) {
        std::__shared_weak_count::__release_weak(v6);
      }
      operator delete(v3);
      uint64_t v3 = v5;
    }
    while (v5);
  }
  uint64_t v4 = (void *)*((void *)a1 + 12);
  *((void *)a1 + 12) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)a1 = &unk_1EF567B80;
  while (*((void *)a1 + 10))
    (*(void (**)(karo::AsyncRequestManager *, uint64_t))(*(void *)a1 + 48))(a1, *((void *)a1 + 8) + 32);
  std::__tree<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::KeyPair<altitude::TileKey>,std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::KeyPair<altitude::TileKey>>,true>,std::allocator<std::__value_type<altitude::KeyPair<altitude::TileKey>,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)a1 + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(a1);
}

__n128 altitude::GenericCacheNode<altitude::TileKey,altitude::RoadTileDataPrivate>::getCacheKeyForKey@<Q0>(uint64_t a1@<X1>, _OWORD *a2@<X8>)
{
  __n128 result = *(__n128 *)a1;
  long long v3 = *(_OWORD *)(a1 + 16);
  *a2 = *(_OWORD *)a1;
  a2[1] = v3;
  return result;
}

void md::VenueBuildingFeatureMarker::debugString(uint64_t a1@<X8>)
{
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  *(void *)(a1 + 24) = *((void *)v2 + 91);
  *(unsigned char *)(a1 + 23) = 0;
  *(unsigned char *)a1 = 0;
}

float md::VenueBuildingFeatureMarker::maxZoomRank(md::VenueBuildingFeatureMarker *this)
{
  return 21.0;
}

double md::VenueBuildingFeatureMarker::minZoomRank(md::VenueBuildingFeatureMarker *this)
{
  return 0.0;
}

void md::FeatureMarker::styleAttributes(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t md::FeatureMarker::venueComponentType(md::FeatureMarker *this)
{
  return 0;
}

void md::FeatureMarker::venueLookInsideFloorOrdinal(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t md::FeatureMarker::venueFloorOrdinal(md::FeatureMarker *this)
{
  return 0;
}

uint64_t md::FeatureMarker::venueComponentId(md::FeatureMarker *this)
{
  return 0;
}

uint64_t md::FeatureMarker::venueLevelId(md::FeatureMarker *this)
{
  return 0;
}

uint64_t md::VenueBuildingFeatureMarker::venueBuildingId(md::VenueBuildingFeatureMarker *this)
{
  return *((void *)this + 7);
}

uint64_t md::VenueBuildingFeatureMarker::venueId(md::VenueBuildingFeatureMarker *this)
{
  return *((void *)this + 9);
}

uint64_t md::VenueBuildingFeatureMarker::featureId(md::VenueBuildingFeatureMarker *this)
{
  return *((void *)this + 7);
}

void md::FeatureMarker::shortName(uint64_t a1@<X8>)
{
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  *(void *)(a1 + 24) = *((void *)v2 + 91);
  *(unsigned char *)(a1 + 23) = 0;
  *(unsigned char *)a1 = 0;
}

void md::VenueBuildingFeatureMarker::name(uint64_t a1@<X8>)
{
  uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    uint64_t v4 = a1;
    uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    a1 = v4;
    if (v3) {
      operator new();
    }
  }
  *(void *)(a1 + 24) = *((void *)v2 + 91);
  *(unsigned char *)(a1 + 23) = 0;
  *(unsigned char *)a1 = 0;
}

void md::VenueBuildingFeatureMarker::~VenueBuildingFeatureMarker(md::VenueBuildingFeatureMarker *this)
{
  *(void *)this = &unk_1EF5481D8;
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    *((void *)this + 15) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 5);
    uint64_t v5 = (void *)*((void *)this + 4);
    if (v4 != v3)
    {
      do
        md::VenueLevel::~VenueLevel((md::VenueLevel *)(v4 - 184));
      while (v4 != v3);
      uint64_t v5 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v3;
    operator delete(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  std::__shared_weak_count *v6;

  *(void *)this = &unk_1EF5481D8;
  uint64_t v2 = (void *)*((void *)this + 14);
  if (v2)
  {
    *((void *)this + 15) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 4);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 5);
    uint64_t v5 = (void *)*((void *)this + 4);
    if (v4 != v3)
    {
      do
        md::VenueLevel::~VenueLevel((md::VenueLevel *)(v4 - 184));
      while (v4 != v3);
      uint64_t v5 = (void *)*((void *)this + 4);
    }
    *((void *)this + 5) = v3;
    operator delete(v5);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6) {
    std::__shared_weak_count::__release_weak(v6);
  }
}

void md::VenueLevel::~VenueLevel(md::VenueLevel *this)
{
  uint64_t v2 = *((void *)this + 18);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 19);
    uint64_t v4 = (void *)*((void *)this + 18);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 24);
        if (v5)
        {
          *(void *)(v3 - 16) = v5;
          operator delete(v5);
        }
        v3 -= 40;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 18);
    }
    *((void *)this + 19) = v2;
    operator delete(v4);
  }
  if (*((unsigned char *)this + 112))
  {
    if (*((char *)this + 143) < 0) {
      operator delete(*((void **)this + 15));
    }
    *((unsigned char *)this + 112) = 0;
  }
  if (*((unsigned char *)this + 80))
  {
    if (*((char *)this + 111) < 0) {
      operator delete(*((void **)this + 11));
    }
    *((unsigned char *)this + 80) = 0;
  }
  if (*((unsigned char *)this + 48))
  {
    if (*((char *)this + 79) < 0) {
      operator delete(*((void **)this + 7));
    }
    *((unsigned char *)this + 48) = 0;
  }
  if (*((unsigned char *)this + 16))
  {
    if (*((char *)this + 47) < 0) {
      operator delete(*((void **)this + 3));
    }
    *((unsigned char *)this + 16) = 0;
  }
}

uint64_t *md::VenueBuilding::VenueBuilding(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1;
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v3 = (uint64_t *)*a2;
  int16x8_t v33 = (uint64_t *)a2[1];
  int64_t v4 = (int64_t)v33 - *a2;
  if (v33 != (uint64_t *)*a2)
  {
    unint64_t v5 = 0xD37A6F4DE9BD37A7 * (v4 >> 3);
    if (v5 >= 0x1642C8590B21643) {
      abort();
    }
    uint64_t v6 = (char *)operator new(v4);
    void *v2 = v6;
    v2[1] = v6;
    int32x4_t v31 = v2;
    v2[2] = &v6[184 * v5];
    long long v7 = v6;
    do
    {
      uint64_t v8 = *v3;
      *((_WORD *)v7 + 4) = *((_WORD *)v3 + 4);
      *(void *)long long v7 = v8;
      v7[16] = 0;
      if (*((unsigned char *)v3 + 16))
      {
        if (*((char *)v3 + 47) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)v7 + 1, (const std::string::value_type *)v3[3], v3[4]);
        }
        else
        {
          long long v9 = *(_OWORD *)(v3 + 3);
          *((void *)v7 + 5) = v3[5];
          *(_OWORD *)(v7 + 24) = v9;
        }
        v7[16] = 1;
      }
      v7[48] = 0;
      if (*((unsigned char *)v3 + 48))
      {
        if (*((char *)v3 + 79) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)(v7 + 56), (const std::string::value_type *)v3[7], v3[8]);
        }
        else
        {
          long long v10 = *(_OWORD *)(v3 + 7);
          *((void *)v7 + 9) = v3[9];
          *(_OWORD *)(v7 + 56) = v10;
        }
        v7[48] = 1;
      }
      v7[80] = 0;
      if (*((unsigned char *)v3 + 80))
      {
        if (*((char *)v3 + 111) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)(v7 + 88), (const std::string::value_type *)v3[11], v3[12]);
        }
        else
        {
          long long v11 = *(_OWORD *)(v3 + 11);
          *((void *)v7 + 13) = v3[13];
          *(_OWORD *)(v7 + 88) = v11;
        }
        v7[80] = 1;
      }
      v7[112] = 0;
      if (*((unsigned char *)v3 + 112))
      {
        if (*((char *)v3 + 143) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)v7 + 5, (const std::string::value_type *)v3[15], v3[16]);
        }
        else
        {
          long long v12 = *(_OWORD *)(v3 + 15);
          *((void *)v7 + 17) = v3[17];
          *(_OWORD *)(v7 + 120) = v12;
        }
        v7[112] = 1;
      }
      *((void *)v7 + 18) = 0;
      *((void *)v7 + 19) = 0;
      *((void *)v7 + 20) = 0;
      uint64_t v13 = v3[18];
      uint64_t v14 = v3[19];
      int64_t v15 = v14 - v13;
      if (v14 != v13)
      {
        unint64_t v16 = 0xCCCCCCCCCCCCCCCDLL * (v15 >> 3);
        if (v16 >= 0x666666666666667) {
          abort();
        }
        uint64_t v17 = (char *)operator new(v15);
        *((void *)v7 + 18) = v17;
        *((void *)v7 + 19) = v17;
        *((void *)v7 + 20) = &v17[40 * v16];
        unint64_t v18 = v17;
        do
        {
          *(_OWORD *)unint64_t v18 = *(_OWORD *)v13;
          *((void *)v18 + 3) = 0;
          *((void *)v18 + 4) = 0;
          *((void *)v18 + 2) = 0;
          int8x16_t v21 = *(unsigned char **)(v13 + 16);
          int32x4_t v20 = *(unsigned char **)(v13 + 24);
          int64_t v22 = v20 - v21;
          if (v20 != v21)
          {
            if (v22 < 0) {
              abort();
            }
            int8x16_t v23 = (char *)operator new(v20 - v21);
            *((void *)v18 + 2) = v23;
            *((void *)v18 + 3) = v23;
            int8x16_t v19 = &v23[8 * (v22 >> 3)];
            *((void *)v18 + 4) = v19;
            memcpy(v23, v21, v22);
            *((void *)v18 + 3) = v19;
          }
          v18 += 40;
          v13 += 40;
        }
        while (v13 != v14);
        *((void *)v7 + 19) = v18;
      }
      *(_OWORD *)(v7 + 168) = *(_OWORD *)(v3 + 21);
      v3 += 23;
      v7 += 184;
    }
    while (v3 != v33);
    v31[1] = v7;
    uint64_t v2 = v31;
  }
  long long v24 = *(_OWORD *)(a2 + 3);
  long long v25 = *(_OWORD *)(a2 + 5);
  long long v26 = *(_OWORD *)(a2 + 7);
  v2[9] = a2[9];
  *(_OWORD *)(v2 + 7) = v26;
  *(_OWORD *)(v2 + 5) = v25;
  *(_OWORD *)(v2 + 3) = v24;
  int8x16_t v27 = v2;
  v2[10] = 0;
  uint64_t v28 = (uint64_t)(v2 + 10);
  v27[11] = 0;
  v27[12] = 0;
  int8x16_t v29 = v27;
  if (v27 != a2) {
    std::vector<gm::Matrix<double,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<double,2,1>*,gm::Matrix<double,2,1>*>(v28, a2[10], (char *)a2[11], (a2[11] - a2[10]) >> 4);
  }
  *(_OWORD *)(v29 + 13) = *(_OWORD *)(a2 + 13);
  return v29;
}

void sub_1A212B3FC(_Unwind_Exception *a1)
{
  int64_t v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 88) = v4;
    operator delete(v4);
  }
  std::vector<md::VenueLevel>::~vector[abi:nn180100]((void **)v1);
  _Unwind_Resume(a1);
}

void sub_1A212B420(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void **a14, void **a15)
{
  if (v15[80])
  {
    if ((char)v15[111] < 0) {
      operator delete(*a13);
    }
    v15[80] = 0;
    if (!v15[48])
    {
LABEL_3:
      if (!v15[16]) {
        goto LABEL_14;
      }
      goto LABEL_11;
    }
  }
  else if (!v15[48])
  {
    goto LABEL_3;
  }
  if ((char)v15[79] < 0) {
    operator delete(*a14);
  }
  v15[48] = 0;
  if (!v15[16])
  {
LABEL_14:
    *(void *)(a11 + 8) = a10;
    _Unwind_Resume(exception_object);
  }
LABEL_11:
  if ((char)v15[47] < 0) {
    operator delete(*a15);
  }
  double v15[16] = 0;
  goto LABEL_14;
}

void **std::vector<md::VenueLevel>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    int64_t v4 = v2;
    if (v3 != v2)
    {
      do
        md::VenueLevel::~VenueLevel((md::VenueLevel *)(v3 - 184));
      while (v3 != v2);
      int64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void karo::util::Path::purify(std::string *this, uint64_t a2)
{
  v54[2] = *MEMORY[0x1E4F143B8];
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    *this = *(std::string *)a2;
  }
  int v3 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
  unint64_t v4 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  BOOL v5 = v3 < 0;
  std::string::size_type size = this->__r_.__value_.__l.__size_;
  if (v3 >= 0) {
    int64_t v7 = HIBYTE(this->__r_.__value_.__r.__words[2]);
  }
  else {
    int64_t v7 = this->__r_.__value_.__l.__size_;
  }
  uint64_t v8 = (std::string *)this->__r_.__value_.__r.__words[0];
  if (v3 >= 0) {
    long long v9 = this;
  }
  else {
    long long v9 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  if (v7 < 1)
  {
LABEL_41:
    int v20 = BYTE1(v8);
    goto LABEL_42;
  }
  long long v10 = (char *)v9 + v7;
  size_t v11 = v7;
  long long v12 = v9;
  while (1)
  {
    uint64_t v13 = memchr(v12, 92, v11);
    if (!v13) {
      goto LABEL_35;
    }
    if (*v13 == 92) {
      break;
    }
    long long v12 = (std::string *)(v13 + 1);
    size_t v11 = v10 - (unsigned char *)v12;
    if (v10 - (unsigned char *)v12 < 1) {
      goto LABEL_35;
    }
  }
  if (v13 != v10)
  {
    uint64_t v14 = v13 - (unsigned char *)v9;
    if (v13 - (unsigned char *)v9 != -1)
    {
      while (1)
      {
        int64_t v15 = v5 ? v8 : this;
        v15->__r_.__value_.__s.__data_[v14] = 47;
        int v16 = SHIBYTE(this->__r_.__value_.__r.__words[2]);
        unint64_t v4 = HIBYTE(this->__r_.__value_.__r.__words[2]);
        BOOL v5 = v16 < 0;
        uint64_t v8 = (std::string *)this->__r_.__value_.__r.__words[0];
        std::string::size_type size = this->__r_.__value_.__l.__size_;
        int64_t v7 = v16 >= 0 ? HIBYTE(this->__r_.__value_.__r.__words[2]) : this->__r_.__value_.__l.__size_;
        long long v9 = v16 >= 0 ? this : (std::string *)this->__r_.__value_.__r.__words[0];
        if (v7 < 1) {
          goto LABEL_41;
        }
        long long v10 = (char *)v9 + v7;
        size_t v17 = v7;
        unint64_t v18 = v9;
        while (1)
        {
          int8x16_t v19 = memchr(v18, 92, v17);
          if (!v19) {
            goto LABEL_35;
          }
          if (*v19 == 92) {
            break;
          }
          unint64_t v18 = (std::string *)(v19 + 1);
          size_t v17 = v10 - (unsigned char *)v18;
          if (v10 - (unsigned char *)v18 < 1) {
            goto LABEL_35;
          }
        }
        if (v19 != v10)
        {
          uint64_t v14 = v19 - (unsigned char *)v9;
          if (v19 - (unsigned char *)v9 != -1) {
            continue;
          }
        }
        break;
      }
    }
  }
LABEL_35:
  int v20 = BYTE1(v8);
  if (v7 > 1)
  {
    p_std::string::size_type size = &this->__r_.__value_.__l.__size_;
    int8x16_t v21 = (char *)v9 + v7;
    int64_t v22 = v9;
    while (1)
    {
      int8x16_t v23 = (char *)memchr(v22, 47, v7 - 1);
      if (!v23) {
        goto LABEL_42;
      }
      if (*(_WORD *)v23 == 12079) {
        break;
      }
      int64_t v22 = (std::string *)(v23 + 1);
      int64_t v7 = v10 - (unsigned char *)v22;
      if (v10 - (unsigned char *)v22 < 2) {
        goto LABEL_42;
      }
    }
    if (v23 != v21)
    {
      std::string::size_type v26 = v23 - (char *)v9;
      if (v23 - (char *)v9 != -1)
      {
        int8x16_t v27 = p_size;
        while (1)
        {
          if ((v4 & 0x80u) == 0) {
            unint64_t v28 = v4;
          }
          else {
            unint64_t v28 = size;
          }
          if (!v28) {
            goto LABEL_42;
          }
          if (!v26)
          {
            *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
            __dst.__r_.__value_.__s.__data_[0] = 0;
            if ((v4 & 0x80) == 0) {
              goto LABEL_66;
            }
            goto LABEL_80;
          }
          std::string::size_type v29 = v26 - 1;
          if ((char)v4 < 0)
          {
            if (v8->__r_.__value_.__s.__data_[v29] == 58) {
              goto LABEL_103;
            }
          }
          else
          {
            if (this->__r_.__value_.__s.__data_[v29] == 58) {
              goto LABEL_103;
            }
            std::string::size_type size = v4;
            uint64_t v8 = this;
          }
          if (size >= v26) {
            std::string::size_type size = v26;
          }
          if (size > 0x7FFFFFFFFFFFFFF7) {
LABEL_118:
          }
            abort();
          if (size >= 0x17) {
            break;
          }
          *((unsigned char *)&__dst.__r_.__value_.__s + 23) = size;
          p_dst = &__dst;
          if (size) {
            goto LABEL_78;
          }
LABEL_79:
          p_dst->__r_.__value_.__s.__data_[size] = 0;
          unint64_t v4 = HIBYTE(this->__r_.__value_.__r.__words[2]);
          if ((v4 & 0x80) == 0)
          {
LABEL_66:
            int16x8_t v30 = this;
            if (v26 >= v4) {
              goto LABEL_118;
            }
            goto LABEL_82;
          }
LABEL_80:
          unint64_t v4 = *v27;
          if (*v27 <= v26) {
            goto LABEL_118;
          }
          int16x8_t v30 = (std::string *)this->__r_.__value_.__r.__words[0];
LABEL_82:
          std::string::size_type v34 = v26 + 1;
          size_t v35 = v4 - (v26 + 1);
          if (v35 > 0x7FFFFFFFFFFFFFF7) {
            goto LABEL_118;
          }
          if (v35 >= 0x17)
          {
            uint64_t v37 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v35 | 7) != 0x17) {
              uint64_t v37 = v35 | 7;
            }
            uint64_t v38 = v37 + 1;
            p_p = operator new(v37 + 1);
            size_t v51 = v35;
            int64_t v52 = v38 | 0x8000000000000000;
            std::string __p = p_p;
          }
          else
          {
            HIBYTE(v52) = v4 - (v26 + 1);
            p_p = &__p;
            if (v4 == v34) {
              goto LABEL_90;
            }
          }
          memmove(p_p, (char *)v30 + v34, v35);
LABEL_90:
          *((unsigned char *)p_p + v35) = 0;
          if (v52 >= 0) {
            int8x16_t v39 = (const std::string::value_type *)&__p;
          }
          else {
            int8x16_t v39 = (const std::string::value_type *)__p;
          }
          if (v52 >= 0) {
            std::string::size_type v40 = HIBYTE(v52);
          }
          else {
            std::string::size_type v40 = v51;
          }
          int8x16_t v41 = std::string::append(&__dst, v39, v40);
          std::string::size_type v42 = v41->__r_.__value_.__r.__words[0];
          v54[0] = v41->__r_.__value_.__l.__size_;
          *(void *)((char *)v54 + 7) = *(std::string::size_type *)((char *)&v41->__r_.__value_.__r.__words[1] + 7);
          char v43 = HIBYTE(v41->__r_.__value_.__r.__words[2]);
          v41->__r_.__value_.__l.__size_ = 0;
          v41->__r_.__value_.__r.__words[2] = 0;
          v41->__r_.__value_.__r.__words[0] = 0;
          if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0) {
            operator delete(this->__r_.__value_.__l.__data_);
          }
          this->__r_.__value_.__r.__words[0] = v42;
          *int8x16_t v27 = v54[0];
          *(std::string::size_type *)((char *)v27 + 7) = *(void *)((char *)v54 + 7);
          *((unsigned char *)&this->__r_.__value_.__s + 23) = v43;
          if (SHIBYTE(v52) < 0) {
            operator delete(__p);
          }
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__dst.__r_.__value_.__l.__data_);
          }
          unint64_t v4 = HIBYTE(this->__r_.__value_.__r.__words[2]);
          uint64_t v8 = (std::string *)this->__r_.__value_.__r.__words[0];
          std::string::size_type size = this->__r_.__value_.__l.__size_;
          int v20 = BYTE1(this->__r_.__value_.__r.__words[0]);
LABEL_103:
          if ((v4 & 0x80u) == 0) {
            int8x16_t v44 = this;
          }
          else {
            int8x16_t v44 = v8;
          }
          if ((v4 & 0x80u) == 0) {
            unint64_t v45 = v4;
          }
          else {
            unint64_t v45 = size;
          }
          if (v45 > v26)
          {
            int8x16_t v46 = &v44->__r_.__value_.__s.__data_[v26 + 1];
            int8x16_t v47 = (char *)v44 + v45;
            while (1)
            {
              if (v47 - v46 < 2) {
                goto LABEL_42;
              }
              int8x16_t v48 = (char *)memchr(v46, 47, v47 - v46 - 1);
              if (!v48) {
                goto LABEL_42;
              }
              if (*(_WORD *)v48 == 12079) {
                break;
              }
              int8x16_t v46 = v48 + 1;
            }
            if (v48 != v47)
            {
              std::string::size_type v26 = v48 - (char *)v44;
              if (v48 - (char *)v44 != -1) {
                continue;
              }
            }
          }
          goto LABEL_42;
        }
        uint64_t v32 = (size & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((size | 7) != 0x17) {
          uint64_t v32 = size | 7;
        }
        uint64_t v33 = v32 + 1;
        p_dst = (std::string *)operator new(v32 + 1);
        __dst.__r_.__value_.__l.__size_ = size;
        __dst.__r_.__value_.__r.__words[2] = v33 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
LABEL_78:
        memmove(p_dst, v8, size);
        goto LABEL_79;
      }
    }
  }
LABEL_42:
  if ((v4 & 0x80) != 0)
  {
    if (size <= 2 || v8->__r_.__value_.__s.__data_[1] != 58) {
      return;
    }
    LOBYTE(v8) = v8->__r_.__value_.__s.__data_[0];
  }
  else if (v4 < 3 || v20 != 58)
  {
    return;
  }
  std::string::value_type v24 = __tolower((char)v8);
  if ((this->__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    long long v25 = this;
  }
  else {
    long long v25 = (std::string *)this->__r_.__value_.__r.__words[0];
  }
  v25->__r_.__value_.__s.__data_[0] = v24;
}

void karo::util::Path::removePrefix(void *a1, uint64_t a2, uint64_t a3)
{
  karo::util::Path::purify(&v23, a2);
  karo::util::Path::purify(&__p, a3);
  std::string::size_type v5 = HIBYTE(v23.__r_.__value_.__r.__words[2]);
  uint64_t v6 = (std::string *)v23.__r_.__value_.__r.__words[0];
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t v7 = &v23;
  }
  else {
    int64_t v7 = (std::string *)v23.__r_.__value_.__r.__words[0];
  }
  char v8 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = __p.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    int64_t v11 = (v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? HIBYTE(v23.__r_.__value_.__r.__words[2])
        : v23.__r_.__value_.__l.__size_;
    if (v11 < (uint64_t)size) {
      goto LABEL_15;
    }
    long long v12 = (std::string *)((char *)v7 + v11);
    int v13 = p_p->__r_.__value_.__s.__data_[0];
    uint64_t v14 = v7;
    while (1)
    {
      size_t v15 = v11 - size;
      if (v15 == -1) {
        goto LABEL_15;
      }
      int v16 = (std::string *)memchr(v14, v13, v15 + 1);
      if (!v16) {
        goto LABEL_15;
      }
      size_t v17 = v16;
      if (!memcmp(v16, p_p, size)) {
        break;
      }
      uint64_t v14 = (std::string *)((char *)&v17->__r_.__value_.__l.__data_ + 1);
      int64_t v11 = (char *)v12 - ((char *)&v17->__r_.__value_.__l.__data_ + 1);
      if (v11 < (uint64_t)size) {
        goto LABEL_15;
      }
    }
    if (v17 == v12 || v17 != v7)
    {
LABEL_15:
      *(std::string *)a1 = v23;
      memset(&v23, 0, sizeof(v23));
      if ((v8 & 0x80) == 0) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
  }
  if ((v5 & 0x80) != 0)
  {
    std::string::size_type v5 = v23.__r_.__value_.__l.__size_;
    if (v23.__r_.__value_.__l.__size_ < size) {
      goto LABEL_42;
    }
  }
  else
  {
    if (size > v5) {
      goto LABEL_42;
    }
    uint64_t v6 = &v23;
  }
  unint64_t v18 = v5 - size;
  if (v5 - size >= 0x7FFFFFFFFFFFFFF8) {
LABEL_42:
  }
    abort();
  if (v18 >= 0x17)
  {
    uint64_t v19 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v18 | 7) != 0x17) {
      uint64_t v19 = v18 | 7;
    }
    uint64_t v20 = v19 + 1;
    int8x16_t v21 = operator new(v19 + 1);
    a1[1] = v18;
    a1[2] = v20 | 0x8000000000000000;
    *a1 = v21;
    a1 = v21;
    goto LABEL_39;
  }
  *((unsigned char *)a1 + 23) = v18;
  if (v5 != size) {
LABEL_39:
  }
    memmove(a1, (char *)v6 + size, v5 - size);
  *((unsigned char *)a1 + v18) = 0;
  if ((*((unsigned char *)&__p.__r_.__value_.__s + 23) & 0x80) != 0) {
LABEL_16:
  }
    operator delete(__p.__r_.__value_.__l.__data_);
LABEL_17:
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v23.__r_.__value_.__l.__data_);
  }
}

void karo::util::Path::getNonDirectory(void **__dst, void **a2)
{
  *std::string __dst = 0;
  __dst[1] = 0;
  __dst[2] = 0;
  size_t v3 = *((unsigned __int8 *)a2 + 23);
  std::string::size_type v5 = (void **)*a2;
  size_t v4 = (size_t)a2[1];
  if ((v3 & 0x80u) == 0) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = (void **)*a2;
  }
  if ((v3 & 0x80u) == 0) {
    int64_t v7 = (char *)*((unsigned __int8 *)a2 + 23);
  }
  else {
    int64_t v7 = (char *)a2[1];
  }
  if (v7)
  {
    char v8 = (unsigned __int8 *)&v7[(void)v6];
    long long v9 = (unsigned __int8 *)v6;
    long long v10 = v8;
    do
    {
      int64_t v11 = v9;
      long long v12 = v9;
      while (1)
      {
        int v13 = *v12++;
        if (v13 == 47) {
          break;
        }
        int64_t v11 = v12;
        if (v12 == v8)
        {
          int64_t v11 = v10;
          goto LABEL_14;
        }
      }
      long long v9 = v11 + 1;
      long long v10 = v11;
    }
    while (v12 != v8);
LABEL_14:
    if (v11 != v8)
    {
      size_t v14 = v11 - (unsigned __int8 *)v6;
      if (v14 != -1)
      {
        if ((v3 & 0x80) != 0)
        {
          if (v4 <= v14) {
            goto LABEL_39;
          }
        }
        else
        {
          size_t v4 = *((unsigned __int8 *)a2 + 23);
          std::string::size_type v5 = a2;
          if (v14 >= v3) {
LABEL_39:
          }
            abort();
        }
        size_t v17 = v14 + 1;
        size_t v18 = v4 - (v14 + 1);
        if (v18 >= 0x7FFFFFFFFFFFFFF8) {
          goto LABEL_39;
        }
        if (v18 >= 0x17)
        {
          uint64_t v20 = (v18 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v18 | 7) != 0x17) {
            uint64_t v20 = v18 | 7;
          }
          uint64_t v21 = v20 + 1;
          p_dsta = (long long *)operator new(v20 + 1);
          *((void *)&__dsta + 1) = v18;
          unint64_t v23 = v21 | 0x8000000000000000;
          *(void *)&long long __dsta = p_dsta;
        }
        else
        {
          HIBYTE(v23) = v4 - (v14 + 1);
          p_dsta = &__dsta;
          if (v4 == v17) {
            goto LABEL_34;
          }
        }
        memmove(p_dsta, (char *)v5 + v17, v18);
LABEL_34:
        *((unsigned char *)p_dsta + v18) = 0;
        if (*((char *)__dst + 23) < 0) {
          operator delete(*__dst);
        }
        *(_OWORD *)std::string __dst = __dsta;
        unint64_t v15 = v23;
        goto LABEL_37;
      }
    }
  }
  if (__dst == a2) {
    return;
  }
  if ((v3 & 0x80) == 0)
  {
    *(_OWORD *)std::string __dst = *(_OWORD *)a2;
    unint64_t v15 = (unint64_t)a2[2];
LABEL_37:
    __dst[2] = (void *)v15;
    return;
  }
  int v16 = *a2;
  std::string::__assign_no_alias<true>(__dst, v16, v4);
}

void karo::util::Path::getFileSuffix(uint64_t a1, uint64_t a2)
{
  std::string::size_type v4 = *(unsigned __int8 *)(a2 + 23);
  int v5 = (char)v4;
  uint64_t v6 = *(const std::string::value_type **)a2;
  if ((v4 & 0x80u) == 0) {
    int64_t v7 = (unsigned __int8 *)a2;
  }
  else {
    int64_t v7 = (unsigned __int8 *)v6;
  }
  if ((v4 & 0x80u) != 0) {
    std::string::size_type v4 = *(void *)(a2 + 8);
  }
  if (!v4) {
    goto LABEL_22;
  }
  char v8 = &v7[v4];
  long long v9 = v7;
  long long v10 = (char *)&v7[v4];
  do
  {
    int64_t v11 = v9;
    long long v12 = v9;
    while (1)
    {
      int v13 = *v12++;
      if (v13 == 46) {
        break;
      }
      int64_t v11 = v12;
      if (v12 == v8)
      {
        int64_t v11 = (unsigned __int8 *)v10;
        goto LABEL_13;
      }
    }
    long long v9 = v11 + 1;
    long long v10 = (char *)v11;
  }
  while (v12 != v8);
LABEL_13:
  if (v11 == v8 || v11 - v7 == -1)
  {
LABEL_22:
    if (v5 < 0) {
      std::string::__init_copy_ctor_external(&__dst, v6, *(void *)(a2 + 8));
    }
    else {
      std::string __dst = *(std::string *)a2;
    }
    goto LABEL_30;
  }
  if (v4 >= v11 - v7) {
    std::string::size_type v14 = v11 - v7;
  }
  else {
    std::string::size_type v14 = v4;
  }
  if (v14 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_65;
  }
  if (v14 >= 0x17)
  {
    uint64_t v16 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v16 = v14 | 7;
    }
    uint64_t v17 = v16 + 1;
    p_dst = operator new(v16 + 1);
    __dst.__r_.__value_.__l.__size_ = v14;
    __dst.__r_.__value_.__r.__words[2] = v17 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v14;
    p_dst = &__dst;
    if (!v14) {
      goto LABEL_29;
    }
  }
  memmove(p_dst, v7, v14);
LABEL_29:
  *((unsigned char *)p_dst + v14) = 0;
LABEL_30:
  uint64_t v18 = *(unsigned __int8 *)(a2 + 23);
  if ((v18 & 0x80u) == 0) {
    uint64_t v19 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    uint64_t v19 = *(void *)(a2 + 8);
  }
  int v20 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = __dst.__r_.__value_.__l.__size_;
  }
  if (v19 != size) {
    goto LABEL_47;
  }
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    int64_t v22 = &__dst;
  }
  else {
    int64_t v22 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  if ((v18 & 0x80) != 0)
  {
    if (memcmp(*(const void **)a2, v22, *(void *)(a2 + 8))) {
      goto LABEL_47;
    }
  }
  else if (*(unsigned char *)(a2 + 23))
  {
    unint64_t v23 = (unsigned __int8 *)a2;
    while (*v23 == v22->__r_.__value_.__s.__data_[0])
    {
      ++v23;
      int64_t v22 = (std::string *)((char *)v22 + 1);
      if (!--v18) {
        goto LABEL_63;
      }
    }
LABEL_47:
    unint64_t v24 = size + 1;
    if (size + 1 <= 0x7FFFFFFFFFFFFFF7)
    {
      if (v24 >= 0x17)
      {
        uint64_t v26 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v24 | 7) != 0x17) {
          uint64_t v26 = v24 | 7;
        }
        uint64_t v27 = v26 + 1;
        p_p = (char *)operator new(v26 + 1);
        size_t v30 = size + 1;
        unint64_t v31 = v27 | 0x8000000000000000;
        std::string __p = p_p;
      }
      else
      {
        size_t v30 = 0;
        unint64_t v31 = 0;
        std::string __p = 0;
        p_p = (char *)&__p;
        HIBYTE(v31) = size + 1;
        if (!size) {
          goto LABEL_58;
        }
      }
      if (v20 >= 0) {
        unint64_t v28 = &__dst;
      }
      else {
        unint64_t v28 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      }
      memmove(p_p, v28, size);
LABEL_58:
      *(_WORD *)&p_p[size] = 46;
      karo::util::Path::removePrefix((void *)a1, a2, (uint64_t)&__p);
      if (SHIBYTE(v31) < 0) {
        operator delete(__p);
      }
      if ((*((unsigned char *)&__dst.__r_.__value_.__s + 23) & 0x80) != 0) {
        goto LABEL_61;
      }
      return;
    }
LABEL_65:
    abort();
  }
LABEL_63:
  *(unsigned char *)(a1 + 23) = 0;
  *(unsigned char *)a1 = 0;
  if ((v20 & 0x80) != 0) {
LABEL_61:
  }
    operator delete(__dst.__r_.__value_.__l.__data_);
}

unsigned __int8 **std::__function::__func<md::ita::PrepareSlices::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>,ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>)::$_1,std::allocator<md::ita::PrepareSlices::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>,ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*)>::operator()(unsigned __int8 **result, uint64_t a2, unsigned __int8 *a3, unint64_t **a4, unsigned char **a5, unsigned char **a6)
{
  uint64_t v6 = result;
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  int v7 = *a3;
  char v8 = *a4;
  long long v9 = *a5;
  if ((v7 - 4) >= 0xFFFFFFFD)
  {
    BOOL v11 = (v7 - 1) < 2;
    if (**(unsigned char **)result[1]) {
      int v10 = 0;
    }
    else {
      int v10 = v11;
    }
  }
  else
  {
    int v10 = 1;
  }
  long long v12 = *a6;
  int v13 = *result[2];
  int v14 = v13 ^ 1;
  if (!v8)
  {
    BOOL v25 = v14 == 0;
    if (!v9)
    {
      BOOL v26 = 0;
      int v27 = 0;
      BOOL v24 = 1;
      goto LABEL_31;
    }
    goto LABEL_26;
  }
  unint64_t v15 = *(void **)result[3];
  unint64_t v16 = *v8;
  unint64_t v17 = *v8;
  uint64_t v18 = v15[52];
  if (v17 < (v15[53] - v18) >> 3
    && ((uint64_t v19 = *(void *)(v18 + 8 * v17)) != 0 ? (v20 = HIDWORD(v16) == HIDWORD(v19)) : (v20 = 0), v20))
  {
    uint64_t v32 = 3 * v19;
    uint64_t v21 = (unsigned char *)v15[56];
    int64_t v22 = (unsigned char *)(v15[55] + v32);
  }
  else
  {
    uint64_t v21 = (unsigned char *)v15[56];
    int64_t v22 = v21;
  }
  if (v22 == v21) {
    unint64_t v23 = 0;
  }
  else {
    unint64_t v23 = v22;
  }
  if (v23)
  {
    __n128 result = (unsigned __int8 **)std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>((uint64_t)(v15 + 44), v16, v8);
    ++result[3];
    int v13 = *v6[2];
  }
  BOOL v24 = *v23 != 0;
  if (!v9 || !v13)
  {
    BOOL v26 = v23[1] != 0;
    BOOL v25 = v14 == 0;
    if (!v9)
    {
      int v27 = 0;
      goto LABEL_31;
    }
    if (!*v23) {
      goto LABEL_27;
    }
LABEL_26:
    BOOL v24 = *v9 != 0;
    goto LABEL_28;
  }
  BOOL v25 = v9[2] == 0;
  if (*v23) {
    goto LABEL_26;
  }
LABEL_27:
  BOOL v24 = 0;
LABEL_28:
  BOOL v26 = v9[1] != 0;
  int v27 = *v6[4];
  if (*v6[4]) {
    int v27 = v9[3] != 0;
  }
LABEL_31:
  if ((v26 & v25 & v27 & 1) == 0 && ((v10 | !v24) & 1) == 0 && (!v12 || (*v12 & *v6[5]) != 0))
  {
    unint64_t v28 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v29 = HIDWORD(*v28);
    uint64_t v30 = (*v28 << 32) | 1;
    v34[0] = &unk_1EF522868;
    v34[1] = v30;
    int v35 = v29;
    int8x16_t v39 = v37;
    int32x4_t v36 = (unsigned __int8 **)v34;
    v37[0] = &unk_1EF522868;
    v37[1] = v30;
    int v38 = v29;
    int v40 = 0;
    ecs2::Runtime::queueCommand(v31, (uint64_t)v37);
    if (v40 != -1) {
      ((void (*)(char *, void *))off_1EF58FB48[v40])(&v33, v37);
    }
    int v40 = -1;
    __n128 result = v36;
    if (v36 == v34)
    {
      return (unsigned __int8 **)(*(uint64_t (**)(void *))(v34[0] + 32))(v34);
    }
    else if (v36)
    {
      return (unsigned __int8 **)(*((uint64_t (**)(void))*v36 + 5))();
    }
  }
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)0>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)0> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t v3 = *(void *)(a1 + 12);
  std::string::size_type v4 = (void *)gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)0>>(a2);
  int v5 = *(_DWORD *)(a1 + 8);
  uint64_t v32 = v3;
  uint64_t v6 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v4 + 4, (uint64_t)&v32);
  if (v7)
  {
    int v13 = (char *)v4[11];
    unint64_t v12 = v4[12];
    if ((unint64_t)v13 >= v12)
    {
      unint64_t v15 = (char *)v4[10];
      uint64_t v16 = (v13 - v15) >> 2;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 62) {
        goto LABEL_34;
      }
      uint64_t v18 = v12 - (void)v15;
      if (v18 >> 1 > v17) {
        unint64_t v17 = v18 >> 1;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v19 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 62) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        BOOL v20 = operator new(4 * v19);
      }
      else
      {
        BOOL v20 = 0;
      }
      uint64_t v21 = &v20[4 * v16];
      int64_t v22 = &v20[4 * v19];
      _DWORD *v21 = v5;
      int v14 = v21 + 1;
      if (v13 != v15)
      {
        unint64_t v23 = v13 - v15 - 4;
        if (v23 < 0x2C) {
          goto LABEL_38;
        }
        if ((unint64_t)(v15 - v20) < 0x20) {
          goto LABEL_38;
        }
        uint64_t v24 = (v23 >> 2) + 1;
        BOOL v25 = &v20[4 * v16 - 16];
        BOOL v26 = v13 - 16;
        uint64_t v27 = v24 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v28 = *(_OWORD *)v26;
          *(v25 - 1) = *((_OWORD *)v26 - 1);
          _OWORD *v25 = v28;
          v25 -= 2;
          v26 -= 32;
          v27 -= 8;
        }
        while (v27);
        v21 -= v24 & 0x7FFFFFFFFFFFFFF8;
        v13 -= 4 * (v24 & 0x7FFFFFFFFFFFFFF8);
        if (v24 != (v24 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_38:
          do
          {
            int v29 = *((_DWORD *)v13 - 1);
            v13 -= 4;
            *--uint64_t v21 = v29;
          }
          while (v13 != v15);
        }
      }
      v4[10] = v21;
      v4[11] = v14;
      v4[12] = v22;
      if (v15) {
        operator delete(v15);
      }
    }
    else
    {
      *(_DWORD *)int v13 = v5;
      int v14 = v13 + 4;
    }
    v4[11] = v14;
    uint64_t v9 = v4[31];
  }
  else
  {
    char v8 = (_DWORD *)(v4[10] + (((uint64_t)v6 - v4[7]) >> 1));
    *char v8 = v5;
    uint64_t v9 = v4[31];
    if (v8 != (_DWORD *)v4[11])
    {
      int v10 = (void *)v4[16];
      if (v10)
      {
        while (1)
        {
          std::string::size_type v34 = &v32;
          uint64_t v35 = 1;
          uint64_t v33 = v9;
          uint64_t v11 = v10[6];
          if (!v11) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v11 + 48))(v11, &v33, &v34);
          int v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
LABEL_33:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_34:
        abort();
      }
      return;
    }
  }
  uint64_t v30 = (void *)v4[22];
  if (v30)
  {
    while (1)
    {
      std::string::size_type v34 = &v32;
      uint64_t v35 = 1;
      uint64_t v33 = v9;
      uint64_t v31 = v30[6];
      if (!v31) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v31 + 48))(v31, &v33, &v34);
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        return;
      }
    }
    goto LABEL_33;
  }
}

uint64_t std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)0>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)0> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t result, uint64_t a2)
{
  *(void *)a2 = &unk_1EF522868;
  uint64_t v2 = *(void *)(result + 8);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(result + 16);
  *(void *)(a2 + 8) = v2;
  return result;
}

void *std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)0>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)0> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x18uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF522868;
  result[1] = v3;
  *((_DWORD *)result + 4) = *(_DWORD *)(a1 + 16);
  return result;
}

void std::__function::__func<ecs2::AddComponent::AddComponent<md::ls::SliceAssignmentT<(md::SliceType)0>>(gdc::Entity,md::ls::SliceAssignmentT<(md::SliceType)0> &&)::{lambda(gdc::Registry &)#1},std::allocator<gdc::Registry &>,void ()(gdc::Registry)>::~__func()
{
}

__n128 std::__function::__func<md::ita::PrepareSlices::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>,ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>)::$_1,std::allocator<md::ita::PrepareSlices::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>,ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51F418;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareSlices::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>,ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>)::$_1,std::allocator<md::ita::PrepareSlices::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>,ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x38uLL);
  *(void *)uint64_t v2 = &unk_1EF51F418;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareSlices::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>,ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>)::$_1,std::allocator<md::ita::PrepareSlices::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>,ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>)::$_1>,void ()(md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*)>::~__func()
{
}

void md::ImageResourceDecoder::decode(const gdc::ResourceKey *a1@<X1>, const gdc::RawResourceSourceData *a2@<X2>, uint64_t *a3@<X8>)
{
  if (*(void *)a2) {
    id v6 = *(id *)(*(void *)a2 + 16);
  }
  else {
    id v6 = 0;
  }
  if (![v6 length])
  {
    *a3 = 0;
    a3[1] = 0;
    goto LABEL_55;
  }
  id v7 = v6;
  char v8 = CGDataProviderCreateWithData(0, (const void *)[v7 bytes], objc_msgSend(v7, "length"), 0);
  uint64_t v9 = CGImageSourceCreateWithDataProvider(v8, 0);
  image = CGImageSourceCreateImageAtIndex(v9, 0, 0);
  CFRelease(v9);
  CGDataProviderRelease(v8);
  int v10 = (std::__shared_weak_count *)operator new(0x48uLL);
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10[1].std::__shared_count = 0u;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582978;
  *(_OWORD *)&v10[1].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v10[2].__shared_owners_ = 0u;
  v10[1].__vftable = (std::__shared_weak_count_vtbl *)(int)CGImageGetWidth(image);
  v10[1].__shared_owners_ = (int)CGImageGetHeight(image);
  int BytesPerRow = CGImageGetBytesPerRow(image);
  int BitsPerComponent = CGImageGetBitsPerComponent(image);
  int v13 = v10[1].__vftable;
  if (!v13) {
    goto LABEL_50;
  }
  uint64_t shared_owners = v10[1].__shared_owners_;
  if (!shared_owners || BitsPerComponent <= 0) {
    goto LABEL_50;
  }
  size_t v15 = BytesPerRow;
  unint64_t v16 = shared_owners * BytesPerRow;
  unint64_t v17 = v10[2].__vftable;
  uint64_t v18 = (std::__shared_weak_count_vtbl *)v10[2].__shared_owners_;
  size_t v19 = v16 - ((char *)v18 - (char *)v17);
  size_t v56 = v15;
  unsigned int v57 = BitsPerComponent;
  if (v16 > (char *)v18 - (char *)v17)
  {
    uint64_t shared_weak_owners = v10[2].__shared_weak_owners_;
    if (shared_weak_owners - (uint64_t)v18 >= v19)
    {
      bzero(v18, v16 - ((char *)v18 - (char *)v17));
      size_t v15 = v56;
      int BitsPerComponent = v57;
      v10[2].__shared_owners_ = (uint64_t)v17 + v16;
      goto LABEL_41;
    }
    unint64_t v55 = (char *)v18 - (char *)v17;
    if ((v16 & 0x8000000000000000) != 0) {
      abort();
    }
    unint64_t v21 = shared_weak_owners - (void)v17;
    uint64_t v22 = 2 * v21;
    if (2 * v21 <= v16) {
      uint64_t v22 = v16;
    }
    if (v21 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v23 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v23 = v22;
    }
    size_t v53 = v23;
    uint64_t v24 = (std::__shared_weak_count_vtbl *)operator new(v23);
    int32x4_t v54 = (char *)v24 + v53;
    size_t v51 = v24;
    int64_t v52 = (char *)v24 + v16;
    BOOL v25 = (std::__shared_weak_count_vtbl *)((char *)v24 + v55);
    bzero((char *)v24 + v55, v19);
    if (v18 == v17)
    {
      size_t v15 = v56;
      int BitsPerComponent = v57;
      uint64_t v27 = (uint64_t)v54;
      BOOL v26 = v25;
      goto LABEL_39;
    }
    size_t v15 = v56;
    int BitsPerComponent = v57;
    if (v55 < 8)
    {
      BOOL v26 = v51;
      goto LABEL_36;
    }
    BOOL v26 = v51;
    if ((unint64_t)((char *)v17 - (char *)v51) >= 0x20)
    {
      if (v55 >= 0x20)
      {
        unint64_t v28 = v55 & 0xFFFFFFFFFFFFFFE0;
        p_get_deleter = (char *)&v18[-1].__get_deleter;
        uint64_t v30 = (char *)v51 + (char *)&v18[-1].__get_deleter - (char *)v17;
        unint64_t v31 = v55 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v32 = *(_OWORD *)p_get_deleter;
          *((_OWORD *)v30 - 1) = *((_OWORD *)p_get_deleter - 1);
          *(_OWORD *)uint64_t v30 = v32;
          v30 -= 32;
          p_get_deleter -= 32;
          v31 -= 32;
        }
        while (v31);
        if (v55 == v28) {
          goto LABEL_38;
        }
        if ((v55 & 0x18) == 0)
        {
          BOOL v25 = (std::__shared_weak_count_vtbl *)((char *)v25 - v28);
          uint64_t v18 = (std::__shared_weak_count_vtbl *)((char *)v18 - v28);
          goto LABEL_36;
        }
      }
      else
      {
        unint64_t v28 = 0;
      }
      unint64_t v33 = v28 - (v55 & 0xFFFFFFFFFFFFFFF8);
      std::string::size_type v34 = (char *)v18 - v28 - 8;
      uint64_t v35 = (char *)(v34 - (char *)v17);
      do
      {
        uint64_t v36 = *(void *)v34;
        v34 -= 8;
        *(void *)&v35[(void)v51] = v36;
        v35 -= 8;
        v33 += 8;
      }
      while (v33);
      if (v55 == (v55 & 0xFFFFFFFFFFFFFFF8)) {
        goto LABEL_38;
      }
      BOOL v25 = (std::__shared_weak_count_vtbl *)((char *)v25 - (v55 & 0xFFFFFFFFFFFFFFF8));
      uint64_t v18 = (std::__shared_weak_count_vtbl *)((char *)v18 - (v55 & 0xFFFFFFFFFFFFFFF8));
    }
LABEL_36:
    uint64_t v37 = (char *)&v25[-1].__on_zero_shared_weak + 7;
    do
    {
      char on_zero_shared_weak_high = HIBYTE(v18[-1].__on_zero_shared_weak);
      uint64_t v18 = (std::__shared_weak_count_vtbl *)((char *)v18 - 1);
      *v37-- = on_zero_shared_weak_high;
    }
    while (v18 != v17);
LABEL_38:
    uint64_t v18 = v17;
    uint64_t v27 = (uint64_t)v54;
LABEL_39:
    v10[2].__vftable = v26;
    v10[2].__shared_owners_ = (uint64_t)v52;
    v10[2].__shared_weak_owners_ = v27;
    if (v18)
    {
      operator delete(v18);
      size_t v15 = v56;
      int BitsPerComponent = v57;
    }
    goto LABEL_41;
  }
  if (v16 < (char *)v18 - (char *)v17) {
    v10[2].__shared_owners_ = (uint64_t)v17 + v16;
  }
LABEL_41:
  unint64_t v39 = v15 / (unint64_t)v13 / (BitsPerComponent >> 3);
  if (v39 == 1)
  {
    int v40 = 2;
  }
  else
  {
    if (v39 != 4)
    {
LABEL_50:
      *a3 = 0;
      a3[1] = 0;
      goto LABEL_51;
    }
    int v40 = 12;
  }
  LODWORD(v10[1].__shared_weak_owners_) = v40;
  CGImageAlphaInfo AlphaInfo = CGImageGetAlphaInfo(image);
  if (v39 == 4 && AlphaInfo == kCGImageAlphaPremultipliedLast) {
    bzero(v10[2].__vftable, v10[2].__shared_owners_ - (unint64_t)v10[2].__vftable);
  }
  std::string::size_type v42 = v10[2].__vftable;
  size_t v43 = (size_t)v10[1].__vftable;
  size_t v44 = v10[1].__shared_owners_;
  ColorSpace = CGImageGetColorSpace(image);
  uint32_t BitmapInfo = CGImageGetBitmapInfo(image);
  int8x16_t v47 = CGBitmapContextCreate(v42, v43, v44, v57, v56, ColorSpace, BitmapInfo);
  int8x16_t v48 = v47;
  if (!v47) {
    goto LABEL_50;
  }
  v59.size.width = (double)(unint64_t)v10[1].__vftable;
  v59.size.height = (double)(unint64_t)v10[1].__shared_owners_;
  v59.origin.CGFloat x = 0.0;
  v59.origin.CGFloat y = 0.0;
  CGContextDrawImage(v47, v59, image);
  CGContextRelease(v48);
  int8x16_t v49 = operator new(0xB8uLL);
  v49[1] = 0;
  v49[2] = 0;
  void *v49 = &unk_1EF57FAE0;
  uint64_t v50 = gdc::Resource::Resource((uint64_t)(v49 + 3), (uint64_t)a1);
  v49[21] = v10 + 1;
  v49[22] = v10;
  atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
  *a3 = v50;
  a3[1] = (uint64_t)v49;
LABEL_51:
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  if (image) {
    CFRelease(image);
  }
LABEL_55:
}

void sub_1A212CBE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,CFTypeRef cf)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a18);
  a20 = a14;
  if (cf) {
    CFRelease(cf);
  }

  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::ImageResource>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[22];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  long long v3 = (void *)a1[4];
  if (v3 != (void *)a1[6])
  {
    free(v3);
  }
}

void std::__shared_ptr_emplace<md::ImageResource>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FAE0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ImageResource>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FAE0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::Image>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    *(void *)(a1 + 56) = v2;
    operator delete(v2);
  }
}

void std::__shared_ptr_emplace<md::Image>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582978;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::Image>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582978;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::ImageResourceDecoder::~ImageResourceDecoder(md::ImageResourceDecoder *this)
{
  *(void *)this = &unk_1EF53D7F8;
  *((void *)this + 1) = &unk_1EF559798;

  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF53D7F8;
  *((void *)this + 1) = &unk_1EF559798;
}

md::LabelTrafficTile *md::LabelTrafficTile::LabelTrafficTile(md::LabelTrafficTile *this, const QuadTile *a2, geo::codec::VectorTile *a3, zilch::TrafficSkeletonTile *a4, const md::DynamicTrafficTileList *a5)
{
  uint64_t v5 = (uint64_t)a3;
  id v7 = this;
  uint64_t v159 = *MEMORY[0x1E4F143B8];
  unsigned __int8 level = a2->_level;
  int v9 = 1 << level;
  int v10 = (a2->_yIdx % v9 + v9) % v9;
  int v11 = (a2->_xIdx % v9 + v9) % v9;
  *((unsigned char *)this + 8) = a2->_type;
  *((unsigned char *)this + 9) = level;
  *((_DWORD *)this + 3) = v10;
  *((_DWORD *)this + 4) = v11;
  *((_DWORD *)this + 8) = vcvtmd_s64_f64((double)a2->_xIdx / (double)(1 << a2->_level));
  double v12 = 1.0 / (double)(1 << level);
  double v13 = v12 * (double)v11;
  double v14 = v12 * (double)((1 << level) + ~v10);
  *((double *)this + 5) = v13;
  *((double *)this + 6) = v14;
  *((double *)this + 7) = v13 + v12;
  *((double *)this + 8) = v14 + v12;
  *(void *)this = &unk_1EF536410;
  *((unsigned char *)this + 72) = a3 == 0;
  *((void *)this + 10) = 0;
  float64x2_t v100 = (void *)((char *)this + 80);
  *((void *)this + 11) = 0;
  *((void *)this + 12) = 0;
  unint64_t v16 = (geo::codec::VectorTile *)&md::SignedDistanceFieldGenerator::_hypotCache[32854];
  while (1)
  {
    uint64_t v17 = *((void *)v16 + 91);
    *((_OWORD *)v7 + 7) = 0u;
    *((void *)v7 + 13) = v17;
    *((_OWORD *)v7 + 8) = 0u;
    *((_OWORD *)v7 + 9) = 0u;
    if ((atomic_load_explicit(v15, memory_order_acquire) & 1) == 0
    {
      operator new();
    }
    *((void *)v7 + 20) = *((void *)v16 + 91);
    *((void *)v7 + 21) = 0;
    if ((atomic_load_explicit(v15, memory_order_acquire) & 1) == 0
    {
      operator new();
    }
    unint64_t v110 = (geo::codec::VectorTile *)v5;
    uint64_t v18 = *((void *)v16 + 91);
    *((void *)v7 + 25) = 0;
    *((void *)v7 + 22) = v18;
    *((void *)v7 + 23) = 0;
    *((_DWORD *)v7 + 48) = 1065353216;
    *((void *)v7 + 26) = 0;
    *((void *)v7 + 27) = 0;
    uint64_t v107 = (void *)((char *)v7 + 200);
    if ((atomic_load_explicit(v15, memory_order_acquire) & 1) == 0
    {
      operator new();
    }
    *((void *)v7 + 28) = *((void *)v16 + 91);
    uint64_t v19 = *(void *)a5;
    if (*((void *)a5 + 1) == *(void *)a5) {
      return v7;
    }
    uint64_t v20 = 0;
    uint64_t v116 = v7;
    while (2)
    {
      uint64_t v106 = v20;
      unint64_t v21 = (int8x8_t **)(v19 + 16 * v20);
      uint64_t updated = zilch::TrafficDynamicTile::feedUpdateTimeSeconds(*(zilch::TrafficDynamicTile **)&(*v21)[18]);
      uint64_t v23 = updated;
      uint64_t v24 = (uint64_t *)*((void *)v7 + 11);
      unint64_t v25 = *((void *)v7 + 12);
      if ((unint64_t)v24 >= v25)
      {
        uint64_t v26 = ((uint64_t)v24 - *v100) >> 3;
        unint64_t v27 = v26 + 1;
        if ((unint64_t)(v26 + 1) >> 61) {
          abort();
        }
        uint64_t v28 = v25 - *v100;
        if (v28 >> 2 > v27) {
          unint64_t v27 = v28 >> 2;
        }
        if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v5 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v5 = v27;
        }
        if (v5)
        {
          uint64_t v29 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v7 + 13) + 16))(*((void *)v7 + 13), 8 * v5, 8);
          uint64_t v30 = (uint64_t *)(v29 + 8 * v26);
          uint64_t v31 = v29 + 8 * v5;
          if (v29) {
            *uint64_t v30 = v23;
          }
        }
        else
        {
          uint64_t v31 = 0;
          uint64_t v30 = (uint64_t *)(8 * v26);
        }
        uint64_t v32 = *((void *)v7 + 10);
        uint64_t v33 = *((void *)v7 + 11);
        std::string::size_type v34 = v30;
        if (v33 == v32) {
          goto LABEL_32;
        }
        unint64_t v35 = v33 - v32 - 8;
        if (v35 < 0x38)
        {
          std::string::size_type v34 = v30;
        }
        else
        {
          std::string::size_type v34 = v30;
          if ((unint64_t)(v33 - (void)v30) >= 0x20)
          {
            uint64_t v36 = (v35 >> 3) + 1;
            uint64_t v37 = v33 - 8 * (v36 & 0x3FFFFFFFFFFFFFFCLL);
            int v38 = v30 - 2;
            unint64_t v39 = (long long *)(v33 - 16);
            uint64_t v40 = v36 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v41 = *v39;
              *((_OWORD *)v38 - 1) = *(v39 - 1);
              *(_OWORD *)int v38 = v41;
              v38 -= 4;
              v39 -= 2;
              v40 -= 4;
            }
            while (v40);
            std::string::size_type v34 = &v30[-(v36 & 0x3FFFFFFFFFFFFFFCLL)];
            uint64_t v33 = v37;
            if (v36 == (v36 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_32:
              size_t v15 = (atomic_uchar *)(v30 + 1);
              *((void *)v7 + 10) = v34;
              *((void *)v7 + 11) = v30 + 1;
              uint64_t v43 = *((void *)v7 + 12);
              *((void *)v7 + 12) = v31;
              if (v32) {
                (*(void (**)(void, uint64_t, uint64_t))(**((void **)v7 + 13) + 40))(*((void *)v7 + 13), v32, v43 - v32);
              }
              goto LABEL_34;
            }
          }
        }
        do
        {
          uint64_t v42 = *(void *)(v33 - 8);
          v33 -= 8;
          *--std::string::size_type v34 = v42;
        }
        while (v33 != v32);
        goto LABEL_32;
      }
      if (v24) {
        *uint64_t v24 = updated;
      }
      size_t v15 = (atomic_uchar *)(v24 + 1);
LABEL_34:
      unint64_t v44 = 0;
      *((void *)v7 + 11) = v15;
      while (1)
      {
        int8x8_t v45 = (*v21)[25];
        if (v44 >= (uint64_t)(*(void *)&(*v21)[26] - *(void *)&v45) >> 3) {
          break;
        }
        size_t v15 = (atomic_uchar *)*(id *)(*(void *)&v45 + 8 * v44);
        [(atomic_uchar *)v15 mercatorPoint];
        int v48 = 1 << a2->_level;
        double v49 = 1.0 / (double)v48;
        double v50 = v49 * (double)a2->_xIdx;
        if (v46 >= v50)
        {
          double v51 = v49 * (double)(v48 + ~a2->_yIdx);
          BOOL v52 = v46 >= v50 + v49 || v47 < v51;
          if (!v52 && v47 < v51 + v49)
          {
            uint64_t v5 = v15;
            int32x4_t v54 = (std::__shared_weak_count *)operator new(0x1A0uLL);
            v54->__shared_owners_ = 0;
            v54->__shared_weak_owners_ = 0;
            v54->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582240;
            unint64_t v55 = v54 + 1;
            long long v121 = 0uLL;
            md::TrafficIncidentLabelFeature::TrafficIncidentLabelFeature((uint64_t)&v54[1], (void *)v5, &v121);
            size_t v56 = (std::__shared_weak_count **)*((void *)v7 + 26);
            unint64_t v57 = *((void *)v7 + 27);
            *(void *)&long long v151 = v54 + 1;
            *((void *)&v151 + 1) = v54;
            if ((unint64_t)v56 < v57)
            {
              if (v56)
              {
                std::__shared_weak_count *v56 = v55;
                v56[1] = v54;
                atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              *((void *)v7 + 26) = v56 + 2;
              goto LABEL_71;
            }
            uint64_t v58 = ((uint64_t)v56 - *v107) >> 4;
            unint64_t v59 = v58 + 1;
            if ((unint64_t)(v58 + 1) >> 60) {
              abort();
            }
            uint64_t v60 = v57 - *v107;
            if (v60 >> 3 > v59) {
              unint64_t v59 = v60 >> 3;
            }
            if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF0) {
              uint64_t v61 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v61 = v59;
            }
            if (v61)
            {
              uint64_t v62 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v116 + 28) + 16))(*((void *)v116 + 28), 16 * v61, 8);
              int8x16_t v63 = (std::__shared_weak_count **)(v62 + 16 * v58);
              uint64_t v64 = v62 + 16 * v61;
              if (v62)
              {
                *int8x16_t v63 = v55;
                v63[1] = v54;
                atomic_fetch_add_explicit(&v54->__shared_owners_, 1uLL, memory_order_relaxed);
              }
            }
            else
            {
              uint64_t v64 = 0;
              int8x16_t v63 = (std::__shared_weak_count **)(16 * v58);
            }
            int8x16_t v65 = v63 + 2;
            int8x16_t v66 = (void *)*((void *)v116 + 25);
            int8x16_t v67 = (void *)*((void *)v116 + 26);
            if (v67 == v66)
            {
              *((void *)v116 + 25) = v63;
              *((void *)v116 + 26) = v65;
              uint64_t v70 = *((void *)v116 + 27);
              *((void *)v116 + 27) = v64;
            }
            else
            {
              do
              {
                long long v68 = *((_OWORD *)v67 - 1);
                v67 -= 2;
                *((_OWORD *)v63 - 1) = v68;
                v63 -= 2;
                *int8x16_t v67 = 0;
                v67[1] = 0;
              }
              while (v67 != v66);
              int8x16_t v67 = (void *)*((void *)v116 + 25);
              int32x4_t v69 = (void *)*((void *)v116 + 26);
              *((void *)v116 + 25) = v63;
              *((void *)v116 + 26) = v65;
              uint64_t v70 = *((void *)v116 + 27);
              *((void *)v116 + 27) = v64;
              while (v69 != v67)
              {
                int16x8_t v71 = (std::__shared_weak_count *)*(v69 - 1);
                if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
                  std::__shared_weak_count::__release_weak(v71);
                }
                v69 -= 2;
              }
            }
            if (v67) {
              (*(void (**)(void, void *, uint64_t))(**((void **)v116 + 28) + 40))(*((void *)v116 + 28), v67, v70 - (void)v67);
            }
            int32x4_t v54 = (std::__shared_weak_count *)*((void *)&v151 + 1);
            *((void *)v116 + 26) = v65;
            id v7 = v116;
            if (v54)
            {
LABEL_71:
              if (!atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
                std::__shared_weak_count::__release_weak(v54);
              }
            }
          }
        }

        ++v44;
      }
      if (!v110) {
        goto LABEL_8;
      }
      v139[0] = &unk_1EF572150;
      v139[1] = v7;
      uint64_t v140 = v139;
      unint64_t v16 = v110;
      uint64_t v108 = geo::codec::VectorTile::lines(v110);
      unint64_t v109 = geo::codec::VectorTile::linesCount(v110);
      uint64_t v72 = geo::codec::VectorTile::lineVertices(v110);
      if (!v72) {
        goto LABEL_149;
      }
      unint64_t v73 = 0;
      uint64_t v112 = 0;
      int v105 = 0;
      uint64_t v103 = *(void *)(v72 + 32);
      uint64_t v104 = v72;
      long long v125 = 0u;
      long long v126 = 0u;
      long long v123 = 0u;
      long long v124 = 0u;
      long long v121 = 0u;
      long long v122 = 0u;
      unsigned __int8 v127 = 3;
      uint64_t v129 = 0;
      int v128 = 0;
      int v130 = -1054867456;
      uint64_t v131 = 0;
      unint64_t v132 = 0xFFFFFFF6FFFFFFFFLL;
      float v133 = -10.0;
      long long v134 = 0u;
      long long v135 = 0u;
      uint64_t v136 = 0;
      unint64_t v137 = 0xFFFFFFFF00000000;
      float v74 = 0.0;
      __int16 v138 = 0;
      while (2)
      {
        if (v73 < zilch::TrafficSkeletonTile::size(a4))
        {
          uint64_t v75 = zilch::TrafficSkeletonTile::operator[]();
          long long v76 = *(_OWORD *)(v75 + 16);
          long long v118 = *(_OWORD *)v75;
          long long v119 = v76;
          uint64_t v120 = *(void *)(v75 + 32);
          long long v157 = 0u;
          long long v158 = 0u;
          long long v155 = 0u;
          long long v156 = 0u;
          long long v153 = 0u;
          long long v154 = 0u;
          long long v151 = 0u;
          long long v152 = 0u;
          unsigned int v77 = md::TrafficDynamicTileResource::flowForRoadId(*v21, v76, &v151);
          if (!v77) {
            goto LABEL_78;
          }
          unsigned int v78 = v118;
          if (v109 <= v118) {
            goto LABEL_78;
          }
          uint64_t v79 = v108 + 168 * v118;
          uint64_t v80 = v112;
          if (!v112) {
            uint64_t v80 = v108 + 168 * v118;
          }
          uint64_t v112 = v80;
          if (fabsf(*((float *)&v118 + 3)) < 0.000001
            || (uint64_t v5 = v77,
                std::__introsort<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**,false>((uint64_t)&v151, (uint64_t *)&v151 + v77, 126 - 2 * __clz(v77), 1), unint64_t v16 = (geo::codec::VectorTile *)DWORD1(v118), DWORD1(v118) > *(_DWORD *)(v79 + 100)))
          {
LABEL_78:
            ++v73;
            continue;
          }
          size_t v15 = 0;
          double v81 = (uint64_t *)(v103 + 16 * (DWORD1(v118) + *(_DWORD *)(v79 + 96)));
          uint64_t v113 = *v81;
          uint64_t v114 = v81[1];
          int8x8_t v111 = (char *)(*(void *)(v104 + 8) + 8 * *v81);
          float v82 = (float)(unint64_t)(v114 - 1);
          float64x2_t v102 = (unsigned __int8 *)(v108 + 168 * v78 + 153);
          uint64_t v83 = 8 * v5;
          while (2)
          {
            if (v16 <= *(_DWORD *)(v79 + 100))
            {
              uint64_t v5 = *(void *)((char *)&v151 + (void)v15);
              id v7 = (md::LabelTrafficTile *)*(unsigned int *)(v5 + 16);
              if (v7 <= 2
                && (uint64_t v117 = 0,
                    uint64_t v150 = 0,
                    uint64_t v149 = 0,
                    geo::codec::VectorTile::key(v110),
                    uint64_t v149 = GEOTileKeyMake(),
                    uint64_t v150 = v84,
                    (md::TrafficUtilities::buildStartOffset((float *)&v117 + 1, (float *)&v117, (std::__shared_weak_count **)v79, (uint64_t)&v118, v113, v114, v5, (uint64_t)v111, (uint64_t)&v149) & 1) != 0))
              {
                float v87 = *((float *)&v117 + 1);
                if (*((float *)&v117 + 1) < 0.0
                  || *((float *)&v117 + 1) > v82
                  || (float v88 = *(float *)&v117, *(float *)&v117 < 0.0)
                  || *(float *)&v117 > v82)
                {
                  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
                  }
                  id v7 = v116;
                  uint64_t v5 = (uint64_t)(id)GEOGetVectorKitVKDefaultLog_log;
                  if (os_log_type_enabled((os_log_t)v5, OS_LOG_TYPE_INFO))
                  {
                    *(_DWORD *)buf = 134219264;
                    *(double *)&uint8_t buf[4] = v87;
                    *(_WORD *)&buf[12] = 2048;
                    *(double *)&buf[14] = *(float *)&v117;
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    uint64_t v142 = v113;
                    __int16 v143 = 2048;
                    uint64_t v144 = v114;
                    __int16 v145 = 2048;
                    double v146 = *((float *)&v118 + 2);
                    __int16 v147 = 2048;
                    double v148 = *((float *)&v118 + 3);
                    _os_log_impl(&dword_1A1780000, (os_log_t)v5, OS_LOG_TYPE_INFO, "Skeleton traffic tile implicates bad section (start: %f, end: %f, valid: %lu,%lu, skeleton record: %f,%f)", buf, 0x3Eu);
                  }
                }
                else
                {
                  if (*((float *)&v118 + 3) > 0.0) {
                    unsigned int v89 = 1;
                  }
                  else {
                    unsigned int v89 = -1;
                  }
                  uint64_t v5 = DWORD2(v119);
                  if (v127 == v7
                    && v128 == DWORD2(v119)
                    && !(_BYTE)v138
                    && v129 == v89
                    && (!v131 || *v102 == *(unsigned __int8 *)(v131 + 153)))
                  {
                    BOOL v90 = !(void)v134 || HIBYTE(v138) == 0;
                    if (v90 && !(void)v135 && !HIDWORD(v137))
                    {
                      if ((void)v121 == *((void *)&v121 + 1)) {
                        goto LABEL_133;
                      }
                      if (v131 == v79 && SHIDWORD(v132) == (unint64_t)v16)
                      {
                        *(float *)&double v85 = v133;
                        if (*((float *)&v118 + 3) > 0.0)
                        {
                          if (v133 <= *((float *)&v117 + 1))
                          {
                            *(float *)&double v85 = *((float *)&v117 + 1) - v133;
                            goto LABEL_125;
                          }
                        }
                        else if (v133 >= *((float *)&v117 + 1))
                        {
                          *(float *)&double v85 = v133 - *((float *)&v117 + 1);
LABEL_125:
                          v86.i32[0] = 1.0;
                          if (*(float *)&v85 <= 1.0)
                          {
                            float v91 = ceilf(*((float *)&v117 + 1));
                            float v92 = floorf(*((float *)&v117 + 1));
                            float v93 = *((float *)&v118 + 3) > 0.0 ? v91 : v92;
                            *(double *)v86.i64 = vabds_f32(v93, *((float *)&v117 + 1));
                            if (*(double *)v86.i64 <= 0.01)
                            {
                              float32x2_t v95 = *(float32x2_t *)(v136 + 8 * (int)v93);
                            }
                            else
                            {
                              uint64_t v94 = (float32x2_t *)(v136 + 8 * (int)v92);
                              *(float32x2_t *)v86.i8 = vsub_f32(v94[1], *v94);
                              float32x2_t v95 = vmla_n_f32(*v94, *(float32x2_t *)v86.i8, *((float *)&v117 + 1) - v92);
                            }
                            double v85 = *(double *)(*((void *)&v121 + 1) - 8);
                            float32x2_t v96 = vsub_f32(*(float32x2_t *)&v85, v95);
                            LODWORD(v85) = 953267991;
                            if (vaddv_f32(vmul_f32(v96, v96)) < 0.0001)
                            {
LABEL_133:
                              id v7 = v116;
                              goto LABEL_144;
                            }
                          }
                        }
                      }
                    }
                  }
                  if (SHIDWORD(v129) >= 1)
                  {
                    *(void *)buf = v112;
                    *(void *)&uint8_t buf[8] = v16;
                    *(_DWORD *)&buf[16] = vcvtms_s32_f32(v74);
                    *(_DWORD *)&buf[20] = vcvtms_s32_f32(v133);
                    *(float *)&uint64_t v142 = v74 - floorf(v74);
                    *((float *)&v142 + 1) = v133 - floorf(v133);
                    if (!v140) {
                      goto LABEL_156;
                    }
                    unsigned int v97 = v89;
                    (*(void (**)(void *, unsigned char *))(*v140 + 48))(v140, buf);
                    unsigned int v89 = v97;
                  }
                  *((void *)&v121 + 1) = v121;
                  *(void *)&long long v123 = *((void *)&v122 + 1);
                  *((void *)&v124 + 1) = v124;
                  *(void *)&long long v126 = *((void *)&v125 + 1);
                  uint64_t v131 = v79;
                  LODWORD(v132) = v78;
                  unsigned __int8 v127 = v7;
                  int v128 = v5;
                  uint64_t v129 = v89;
                  float32x4_t v98 = (std::__shared_weak_count *)*((void *)&v134 + 1);
                  long long v134 = 0uLL;
                  if (v98 && !atomic_fetch_add(&v98->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
                    std::__shared_weak_count::__release_weak(v98);
                  }
                  uint64_t v5 = *((void *)&v135 + 1);
                  long long v135 = 0uLL;
                  id v7 = v116;
                  if (v5 && !atomic_fetch_add((atomic_ullong *volatile)(v5 + 8), 0xFFFFFFFFFFFFFFFFLL))
                  {
                    (*(void (**)(uint64_t))(*(void *)v5 + 16))(v5);
                    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v5);
                  }
                  HIDWORD(v137) = 0;
                  LOBYTE(v138) = 0;
                  float v87 = *((float *)&v117 + 1);
                  float v88 = *(float *)&v117;
                  unsigned int v78 = v118;
                  unint64_t v16 = (geo::codec::VectorTile *)DWORD1(v118);
                  uint64_t v112 = v79;
                  int v105 = DWORD1(v118);
                  float v74 = *((float *)&v117 + 1);
LABEL_144:
                  uint64_t v131 = v79;
                  unint64_t v132 = __PAIR64__(v16, v78);
                  float v133 = v88;
                  md::TrafficAccum::addPoints((float32x2_t **)&v121, v111, 0, 0, v114, 0, v87, v88, v85, v86);
                }
              }
              else
              {
                id v7 = v116;
              }
            }
            v15 += 8;
            if ((atomic_uchar *)v83 == v15) {
              goto LABEL_78;
            }
            continue;
          }
        }
        break;
      }
      if (v129 <= 0) {
        goto LABEL_148;
      }
      *(void *)&long long v151 = v112;
      *((void *)&v151 + 1) = v105;
      *(void *)&long long v152 = __PAIR64__(vcvtms_s32_f32(v133), vcvtms_s32_f32(v74));
      *((float *)&v152 + 2) = v74 - floorf(v74);
      *((float *)&v152 + 3) = v133 - floorf(v133);
      if (v140)
      {
        (*(void (**)(void *, long long *))(*v140 + 48))(v140, &v151);
LABEL_148:
        md::TrafficAccum::~TrafficAccum((md::TrafficAccum *)&v121);
LABEL_149:
        if (v140 == v139)
        {
          (*(void (**)(void *))(v139[0] + 32))(v139);
        }
        else if (v140)
        {
          (*(void (**)(void))(*v140 + 40))();
        }
LABEL_8:
        uint64_t v20 = v106 + 1;
        uint64_t v19 = *(void *)a5;
        if (v106 + 1 >= (unint64_t)((uint64_t)(*((void *)a5 + 1) - *(void *)a5) >> 4)) {
          return v7;
        }
        continue;
      }
      break;
    }
LABEL_156:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
LABEL_157:
      operator new();
  }
}

void sub_1A212DE88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, gss::FeatureAttributeSet *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  md::TrafficAccum::~TrafficAccum((md::TrafficAccum *)&a39);
  std::function<void ()(md::RoadPiece const&)>::~function(&a69);
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::~vector[abi:nn180100](a22);
  std::__hash_table<std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::__unordered_map_hasher<GeoCodecsFeature const*,std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::hash<GeoCodecsFeature const*>,std::equal_to<GeoCodecsFeature const*>,true>,std::__unordered_map_equal<GeoCodecsFeature const*,std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::equal_to<GeoCodecsFeature const*>,std::hash<GeoCodecsFeature const*>,true>,geo::StdAllocator<std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,mdm::Allocator>>::~__hash_table((uint64_t *)(a31 + 144));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a31 + 128);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a10);
  gss::FeatureAttributeSet::~FeatureAttributeSet(a12);
  _Unwind_Resume(a1);
}

void *std::function<void ()(md::RoadPiece const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::__hash_table<std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::__unordered_map_hasher<GeoCodecsFeature const*,std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::hash<GeoCodecsFeature const*>,std::equal_to<GeoCodecsFeature const*>,true>,std::__unordered_map_equal<GeoCodecsFeature const*,std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::equal_to<GeoCodecsFeature const*>,std::hash<GeoCodecsFeature const*>,true>,geo::StdAllocator<std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,mdm::Allocator>>::~__hash_table(uint64_t *a1)
{
  uint64_t v2 = (uint64_t *)a1[3];
  if (v2)
  {
    do
    {
      id v6 = (uint64_t *)*v2;
      uint64_t v7 = v2[3];
      if (v7)
      {
        uint64_t v8 = v2[4];
        uint64_t v5 = v2[3];
        if (v8 != v7)
        {
          uint64_t v9 = v2[4];
          do
          {
            uint64_t v11 = *(void *)(v9 - 32);
            v9 -= 32;
            uint64_t v10 = v11;
            if (v11)
            {
              *(void *)(v8 - 24) = v10;
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v8 - 8) + 40))(*(void *)(v8 - 8), v10, *(void *)(v8 - 16) - v10);
            }
            uint64_t v8 = v9;
          }
          while (v9 != v7);
          uint64_t v5 = v2[3];
        }
        v2[4] = v7;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[6] + 40))(v2[6], v5, v2[5] - v5);
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)a1[4] + 40))(a1[4], v2, 56);
      uint64_t v2 = v6;
    }
    while (v6);
  }
  uint64_t v3 = *a1;
  *a1 = 0;
  if (v3) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[2] + 40))(a1[2], v3, 8 * a1[1]);
  }
  return a1;
}

unint64_t std::__function::__func<md::LabelTrafficTile::LabelTrafficTile(geo::QuadTile const&,geo::codec::VectorTile *,zilch::TrafficSkeletonTile *,md::DynamicTrafficTileList const&)::$_0,std::allocator<md::LabelTrafficTile::LabelTrafficTile(geo::QuadTile const&,geo::codec::VectorTile *,zilch::TrafficSkeletonTile *,md::DynamicTrafficTileList const&)::$_0>,void ()(md::RoadPiece const&)>::operator()(uint64_t a1, unint64_t *a2)
{
  return md::TrafficRoads::addRoadPiece(*(void *)(a1 + 8) + 144, a2);
}

uint64_t std::__function::__func<md::LabelTrafficTile::LabelTrafficTile(geo::QuadTile const&,geo::codec::VectorTile *,zilch::TrafficSkeletonTile *,md::DynamicTrafficTileList const&)::$_0,std::allocator<md::LabelTrafficTile::LabelTrafficTile(geo::QuadTile const&,geo::codec::VectorTile *,zilch::TrafficSkeletonTile *,md::DynamicTrafficTileList const&)::$_0>,void ()(md::RoadPiece const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572150;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelTrafficTile::LabelTrafficTile(geo::QuadTile const&,geo::codec::VectorTile *,zilch::TrafficSkeletonTile *,md::DynamicTrafficTileList const&)::$_0,std::allocator<md::LabelTrafficTile::LabelTrafficTile(geo::QuadTile const&,geo::codec::VectorTile *,zilch::TrafficSkeletonTile *,md::DynamicTrafficTileList const&)::$_0>,void ()(md::RoadPiece const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572150;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelTrafficTile::LabelTrafficTile(geo::QuadTile const&,geo::codec::VectorTile *,zilch::TrafficSkeletonTile *,md::DynamicTrafficTileList const&)::$_0,std::allocator<md::LabelTrafficTile::LabelTrafficTile(geo::QuadTile const&,geo::codec::VectorTile *,zilch::TrafficSkeletonTile *,md::DynamicTrafficTileList const&)::$_0>,void ()(md::RoadPiece const&)>::~__func()
{
}

void md::LabelTrafficTile::~LabelTrafficTile(md::LabelTrafficTile *this)
{
  md::LabelTrafficTile::~LabelTrafficTile(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;

  *(void *)this = &unk_1EF536410;
  uint64_t v2 = *((void *)this + 25);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 26);
    std::string::size_type v4 = *((void *)this + 25);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v5->__on_zero_shared)(v5, v4);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      std::string::size_type v4 = *((void *)this + 25);
    }
    *((void *)this + 26) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 28) + 40))(*((void *)this + 28), v4, *((void *)this + 27) - v4);
  }
  std::__hash_table<std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::__unordered_map_hasher<GeoCodecsFeature const*,std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::hash<GeoCodecsFeature const*>,std::equal_to<GeoCodecsFeature const*>,true>,std::__unordered_map_equal<GeoCodecsFeature const*,std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,std::equal_to<GeoCodecsFeature const*>,std::hash<GeoCodecsFeature const*>,true>,geo::StdAllocator<std::__hash_value_type<GeoCodecsFeature const*,std::vector<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,geo::StdAllocator<std::vector<md::RoadPiece,geo::StdAllocator<md::RoadPiece,mdm::Allocator>>,mdm::Allocator>>>,mdm::Allocator>>::~__hash_table((uint64_t *)this + 18);
  id v6 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v7) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v7) {
      goto LABEL_16;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_16:
  uint64_t v8 = *((void *)this + 10);
  if (v8)
  {
    *((void *)this + 11) = v8;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 13) + 40))(*((void *)this + 13), v8, *((void *)this + 12) - v8);
  }
}

_OWORD *std::vector<std::weak_ptr<md::LabelTrafficTile>,geo::StdAllocator<std::weak_ptr<md::LabelTrafficTile>,mdm::Allocator>>::__push_back_slow_path<std::weak_ptr<md::LabelTrafficTile>>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 4;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 60) {
    abort();
  }
  uint64_t v5 = *(void *)(a1 + 16) - *(void *)a1;
  if (v5 >> 3 > v3) {
    unint64_t v3 = v5 >> 3;
  }
  BOOL v6 = (unint64_t)v5 >= 0x7FFFFFFFFFFFFFF0;
  uint64_t v7 = 0xFFFFFFFFFFFFFFFLL;
  if (!v6) {
    uint64_t v7 = v3;
  }
  if (v7)
  {
    uint64_t v9 = 16 * v7;
    uint64_t v10 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 16 * v7, 8);
    uint64_t v11 = (_OWORD *)(v10 + 16 * v2);
    uint64_t v7 = v10 + v9;
    if (v10)
    {
      _OWORD *v11 = *(_OWORD *)a2;
      *(void *)a2 = 0;
      *(void *)(a2 + 8) = 0;
    }
  }
  else
  {
    uint64_t v11 = (_OWORD *)(16 * v2);
  }
  double v12 = v11 + 1;
  double v13 = *(void **)a1;
  double v14 = *(void **)(a1 + 8);
  if (v14 == *(void **)a1)
  {
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v12;
    uint64_t v17 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v7;
  }
  else
  {
    do
    {
      long long v15 = *((_OWORD *)v14 - 1);
      v14 -= 2;
      *--uint64_t v11 = v15;
      *double v14 = 0;
      v14[1] = 0;
    }
    while (v14 != v13);
    double v14 = *(void **)a1;
    unint64_t v16 = *(void **)(a1 + 8);
    *(void *)a1 = v11;
    *(void *)(a1 + 8) = v12;
    uint64_t v17 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v7;
    while (v16 != v14)
    {
      uint64_t v18 = (std::__shared_weak_count *)*(v16 - 1);
      if (v18) {
        std::__shared_weak_count::__release_weak(v18);
      }
      v16 -= 2;
    }
  }
  if (v14) {
    (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v14, v17 - (void)v14);
  }
  return v12;
}

uint64_t std::__shared_ptr_emplace<md::LabelTrafficTile>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::LabelTrafficTile>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580250;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelTrafficTile>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580250;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::ElevatedTerrainHeightProvider::~ElevatedTerrainHeightProvider(md::ElevatedTerrainHeightProvider *this)
{
}

void md::Logic<md::AnchorLogic,md::AnchorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  unint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    double v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void geo::_retain_ptr<VKAnchorWrapper * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,md::_equal_objc_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5595F8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKAnchorWrapper * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,md::_equal_objc_ptr>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5595F8;

  return a1;
}

uint64_t std::__function::__func<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_1,std::allocator<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D7A0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_1,std::allocator<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF56D7A0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_1,std::allocator<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_0,std::allocator<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D758;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_0,std::allocator<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF56D758;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_0,std::allocator<md::AnchorLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::ResolvedDependencies const&,md::AnchorContext &)::$_0>,void ()(void)>::~__func()
{
}

uint64_t md::Logic<md::AnchorLogic,md::AnchorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::AnchorLogic,md::AnchorContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x63B6FE00C0848868 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext>,gdc::TypeList<md::NavigationContext>>::resolveDependencies(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::AnchorContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::AnchorContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555348;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0x20C4093837F09);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::AnchorContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555348;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x20C4093837F09);
  }
  return a1;
}

void md::AnchorLogic::~AnchorLogic(md::AnchorLogic *this)
{
  md::AnchorLogic::~AnchorLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  void (***v3)(void);
  void (***v4)(void);
  uint64_t v5;
  uint64_t i;
  void (***v7)(void);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  void *v17;
  uint64_t v18;

  *(void *)this = &unk_1EF5305A0;
  uint64_t v2 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  md::AnchorLogic::_resetExternalAnchors(*((md::AnchorLogic **)this + 24));
  uint64_t v3 = (void (***)(void))*((void *)this + 24);
  if (*((void *)this + 25))
  {
    if (v3)
    {
      do
      {
        uint64_t v4 = (void (***)(void))*v3;
        (*v3[2])();
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    *((void *)this + 24) = 0;
    uint64_t v5 = *((void *)this + 23);
    if (v5)
    {
      for (uint64_t i = 0; i != v5; ++i)
        *(void *)(*((void *)this + 22) + 8 * i) = 0;
      uint64_t v3 = (void (***)(void))*((void *)this + 24);
    }
    else
    {
      uint64_t v3 = 0;
    }
    *((void *)this + 25) = 0;
  }
  if (v3)
  {
    do
    {
      char v7 = (void (***)(void))*v3;
      (*v3[2])();
      operator delete(v3);
      uint64_t v3 = v7;
    }
    while (v7);
  }
  uint64_t v8 = (void *)*((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v8) {
    operator delete(v8);
  }
  char v9 = *((void *)this + 21);
  *((void *)this + 21) = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
  }
  uint64_t v10 = *((void *)this + 20);
  *((void *)this + 20) = 0;
  if (v10)
  {
    uint64_t v11 = *(void **)(v10 + 16);
    if (v11)
    {
      do
      {
        double v12 = (void *)*v11;
        operator delete(v11);
        uint64_t v11 = v12;
      }
      while (v12);
    }
    uint64_t v13 = *(void **)v10;
    *(void *)uint64_t v10 = 0;
    if (v13) {
      operator delete(v13);
    }
    MEMORY[0x1A6239270](v10, 0x10A0C4073C32F45);
  }
  double v14 = *((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v14)
  {
    long long v15 = *(void **)(v14 + 16);
    if (v15)
    {
      do
      {
        unint64_t v16 = (void *)*v15;
        operator delete(v15);
        long long v15 = v16;
      }
      while (v16);
    }
    uint64_t v17 = *(void **)v14;
    *(void *)double v14 = 0;
    if (v17) {
      operator delete(v17);
    }
    MEMORY[0x1A6239270](v14, 0x10A0C4073C32F45);
  }
  uint64_t v18 = *((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void sub_1A212ECF4(_Unwind_Exception *a1)
{
  std::unordered_set<geo::_retain_ptr<VKAnchorWrapper * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,md::_equal_objc_ptr>>::~unordered_set[abi:nn180100]((uint64_t)(v1 + 22));
  uint64_t v3 = v1[21];
  v1[21] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 16))(v3);
  }
  std::unique_ptr<md::MercatorTerrainHeightCache>::~unique_ptr[abi:nn180100](v1 + 20);
  std::unique_ptr<md::MercatorTerrainHeightCache>::~unique_ptr[abi:nn180100](v1 + 19);
  uint64_t v4 = v1[16];
  v1[16] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic((uint64_t)v1);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_set<geo::_retain_ptr<VKAnchorWrapper * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,md::_equal_objc_ptr>>::~unordered_set[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void (****)(void))(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = *v2;
      (*v2[2])();
      operator delete(v2);
      uint64_t v2 = (void (***)(void))v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t *std::unique_ptr<md::MercatorTerrainHeightCache>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(void **)(v2 + 16);
    if (v3)
    {
      do
      {
        uint64_t v4 = (void *)*v3;
        operator delete(v3);
        uint64_t v3 = v4;
      }
      while (v4);
    }
    uint64_t v5 = *(void **)v2;
    *(void *)uint64_t v2 = 0;
    if (v5) {
      operator delete(v5);
    }
    MEMORY[0x1A6239270](v2, 0x10A0C4073C32F45);
  }
  return a1;
}

void md::AnchorManager::removeAnchor(int8x8_t *this, unint64_t a2)
{
  int8x8_t v2 = this[5];
  if (v2)
  {
    unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
    unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
    unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v7 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
      if (v5 >= *(void *)&v2) {
        unint64_t v7 = v5 % *(void *)&v2;
      }
    }
    else
    {
      unint64_t v7 = v5 & (*(void *)&v2 - 1);
    }
    int8x8_t v8 = this[4];
    char v9 = *(md::Anchor ****)(*(void *)&v8 + 8 * v7);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (v10)
      {
        uint64_t v11 = *(void *)&v2 - 1;
        if (v6.u32[0] < 2uLL)
        {
          while (1)
          {
            double v12 = v10[1];
            if (v12 == (md::Anchor *)v5)
            {
              if (v10[2] == (md::Anchor *)a2) {
                goto LABEL_22;
              }
            }
            else if (((unint64_t)v12 & v11) != v7)
            {
              return;
            }
            uint64_t v10 = (md::Anchor **)*v10;
            if (!v10) {
              return;
            }
          }
        }
        do
        {
          uint64_t v13 = v10[1];
          if (v13 == (md::Anchor *)v5)
          {
            if (v10[2] == (md::Anchor *)a2)
            {
LABEL_22:
              if (v6.u32[0] > 1uLL)
              {
                if (v5 >= *(void *)&v2) {
                  v5 %= *(void *)&v2;
                }
              }
              else
              {
                v5 &= v11;
              }
              double v14 = *(md::Anchor ***)(*(void *)&v8 + 8 * v5);
              do
              {
                long long v15 = v14;
                double v14 = (md::Anchor **)*v14;
              }
              while (v14 != v10);
              if (v15 == (md::Anchor **)&this[6]) {
                goto LABEL_39;
              }
              unint64_t v16 = (unint64_t)v15[1];
              if (v6.u32[0] > 1uLL)
              {
                if (v16 >= *(void *)&v2) {
                  v16 %= *(void *)&v2;
                }
              }
              else
              {
                v16 &= v11;
              }
              if (v16 != v5)
              {
LABEL_39:
                if (!*v10) {
                  goto LABEL_40;
                }
                unint64_t v17 = *((void *)*v10 + 1);
                if (v6.u32[0] > 1uLL)
                {
                  if (v17 >= *(void *)&v2) {
                    v17 %= *(void *)&v2;
                  }
                }
                else
                {
                  v17 &= v11;
                }
                if (v17 != v5) {
LABEL_40:
                }
                  *(void *)(*(void *)&v8 + 8 * v5) = 0;
              }
              uint64_t v18 = *v10;
              if (*v10)
              {
                unint64_t v19 = *((void *)v18 + 1);
                if (v6.u32[0] > 1uLL)
                {
                  if (v19 >= *(void *)&v2) {
                    v19 %= *(void *)&v2;
                  }
                }
                else
                {
                  v19 &= v11;
                }
                if (v19 != v5)
                {
                  *(void *)(*(void *)&this[4] + 8 * v19) = v15;
                  uint64_t v18 = *v10;
                }
              }
              *long long v15 = v18;
              *uint64_t v10 = 0;
              --*(void *)&this[7];
              operator delete(v10);
              return;
            }
          }
          else
          {
            if ((unint64_t)v13 >= *(void *)&v2) {
              uint64_t v13 = (md::Anchor *)((unint64_t)v13 % *(void *)&v2);
            }
            if (v13 != (md::Anchor *)v7) {
              return;
            }
          }
          uint64_t v10 = (md::Anchor **)*v10;
        }
        while (v10);
      }
    }
  }
}

uint64_t std::__shared_ptr_pointer<md::MercatorAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::MercatorAnchor>,std::allocator<md::MercatorAnchor>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::MercatorAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::MercatorAnchor>,std::allocator<md::MercatorAnchor>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::MercatorTerrainAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::MercatorTerrainAnchor>,std::allocator<md::MercatorTerrainAnchor>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::MercatorTerrainAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::MercatorTerrainAnchor>,std::allocator<md::MercatorTerrainAnchor>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::GlobeMercatorAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::GlobeMercatorAnchor>,std::allocator<md::GlobeMercatorAnchor>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::GlobeMercatorAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::GlobeMercatorAnchor>,std::allocator<md::GlobeMercatorAnchor>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::GlobeMercatorTerrainAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::GlobeMercatorTerrainAnchor>,std::allocator<md::GlobeMercatorTerrainAnchor>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::GlobeMercatorTerrainAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::GlobeMercatorTerrainAnchor>,std::allocator<md::GlobeMercatorTerrainAnchor>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<md::GeocentricAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::GeocentricAnchor>,std::allocator<md::GeocentricAnchor>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<md::GeocentricAnchor *,std::shared_ptr<md::Anchor>::__shared_ptr_default_delete<md::Anchor,md::GeocentricAnchor>,std::allocator<md::GeocentricAnchor>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void md::AnchorManager::geocentricPointForAnchor(md::AnchorManager *this, md::GeocentricAnchor *a2)
{
  unint64_t v4 = (altitude::Anchor *)*((void *)a2 + 9);
  (*(void (**)(float64x2_t *__return_ptr, md::GeocentricAnchor *))(*(void *)a2 + 64))(v17, a2);
  float64x2_t v5 = vmulq_f64(v17[0], (float64x2_t)vdupq_n_s64(0x3F91DF46A2529D39uLL));
  float64x2_t v18 = v5;
  double v6 = v5.f64[1];
  if (!v4)
  {
    uint64_t v7 = *((void *)this + 2);
    if (!v7) {
      return;
    }
    float64x2_t v15 = v5;
    Anchor = (altitude::Anchor *)altitude::GlobeView::createAnchor(v7, v18.f64);
    unint64_t v4 = Anchor;
    if (*(_DWORD *)Anchor != 2)
    {
      *(_DWORD *)Anchor = 2;
      altitude::Anchor::update(Anchor);
    }
    float64x2_t v5 = v15;
    if (v15.f64[0] != *((double *)v4 + 1) || v6 != *((double *)v4 + 2) || *((double *)v4 + 3) != 0.0)
    {
      *(float64x2_t *)((char *)v4 + 8) = v15;
      *((void *)v4 + 3) = 0;
      *((_WORD *)v4 + 32) = 255;
      *((_DWORD *)v4 + 17) = 0;
      *((_DWORD *)v4 + 18) = 0;
      *((unsigned char *)v4 + 96) = 1;
      if (*(_DWORD *)v4 == 2)
      {
        altitude::Anchor::update(v4);
        float64x2_t v5 = v15;
      }
      else
      {
        __double2 v9 = __sincos_stret(v15.f64[0]);
        double v10 = 6378137.0 / sqrt(v9.__sinval * v9.__sinval * -0.00669437999 + 1.0);
        __double2 v11 = __sincos_stret(v6);
        *((double *)v4 + 4) = v10 * v9.__cosval * v11.__cosval;
        *((double *)v4 + 5) = v10 * v9.__cosval * v11.__sinval;
        float64x2_t v5 = v15;
        *((double *)v4 + 6) = v10 * (0.99330562 * v9.__sinval);
      }
    }
    *((void *)a2 + 9) = v4;
  }
  if (*(_DWORD *)v4 != 2)
  {
    *(_DWORD *)unint64_t v4 = 2;
    float64x2_t v16 = v5;
    altitude::Anchor::update(v4);
    float64x2_t v5 = v16;
  }
  if (v5.f64[0] != *((double *)v4 + 1) || v6 != *((double *)v4 + 2) || *((double *)v4 + 3) != 0.0)
  {
    *(float64x2_t *)((char *)v4 + 8) = v5;
    *((void *)v4 + 3) = 0;
    *((_WORD *)v4 + 32) = 255;
    *((_DWORD *)v4 + 17) = 0;
    *((_DWORD *)v4 + 18) = 0;
    *((unsigned char *)v4 + 96) = 1;
    if (*(_DWORD *)v4 == 2)
    {
      altitude::Anchor::update(v4);
    }
    else
    {
      __double2 v12 = __sincos_stret(v5.f64[0]);
      double v13 = 6378137.0 / sqrt(v12.__sinval * v12.__sinval * -0.00669437999 + 1.0);
      __double2 v14 = __sincos_stret(v6);
      *((double *)v4 + 4) = v13 * v12.__cosval * v14.__cosval;
      *((double *)v4 + 5) = v13 * v12.__cosval * v14.__sinval;
      *((double *)v4 + 6) = v13 * (0.99330562 * v12.__sinval);
    }
  }
}

uint64_t std::unique_ptr<std::__hash_node<geo::_retain_ptr<VKAnchorWrapper * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,md::_equal_objc_ptr>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<geo::_retain_ptr<VKAnchorWrapper * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,md::_equal_objc_ptr>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  int8x8_t v2 = *(void (****)(void))a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      (*v2[2])();
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t md::AnchorLogic::setGlobe(uint64_t this, altitude::GlobeView *a2)
{
  *(void *)(this + 144) = a2;
  uint64_t v2 = *(void *)(this + 128);
  if (v2)
  {
    if (*(void *)(v2 + 16))
    {
      *(void *)(v2 + 16) = 0;
      for (uint64_t i = *(uint64_t ***)(v2 + 48); i; uint64_t i = (uint64_t **)*i)
        this = (*(uint64_t (**)(uint64_t *))(*i[2] + 104))(i[2]);
    }
  }
  return this;
}

void ggl::ComputeSetup::~ComputeSetup(ggl::ComputeSetup *this)
{
  *(void *)this = &unk_1EF55AB40;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 22);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *((void *)this + 17);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = *((void *)this + 17);
    if (!v3) {
      goto LABEL_12;
    }
  }
  uint64_t v4 = *((void *)this + 18);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      double v6 = *(std::__shared_weak_count **)(v4 - 8);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 16;
    }
    while (v4 != v3);
    uint64_t v5 = *((void *)this + 17);
  }
  *((void *)this + 18) = v3;
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 20) + 40))(*((void *)this + 20), v5, *((void *)this + 19) - v5);
LABEL_12:
  uint64_t v7 = *((void *)this + 13);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 14);
    uint64_t v9 = *((void *)this + 13);
    if (v8 != v7)
    {
      do
      {
        double v10 = *(std::__shared_weak_count **)(v8 - 8);
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v10->__on_zero_shared)(v10, v9);
          std::__shared_weak_count::__release_weak(v10);
        }
        v8 -= 16;
      }
      while (v8 != v7);
      uint64_t v9 = *((void *)this + 13);
    }
    *((void *)this + 14) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 16) + 40))(*((void *)this + 16), v9, *((void *)this + 15) - v9);
  }
  uint64_t v11 = *((void *)this + 9);
  if (v11)
  {
    *((void *)this + 10) = v11;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 12) + 40))(*((void *)this + 12), v11, *((void *)this + 11) - v11);
  }
  uint64_t v12 = *((void *)this + 5);
  if (v12)
  {
    *((void *)this + 6) = v12;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v12, *((void *)this + 7) - v12);
  }
  uint64_t v13 = *((void *)this + 1);
  if (v13)
  {
    *((void *)this + 2) = v13;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v13, *((void *)this + 3) - v13);
  }
}

{
  uint64_t vars8;

  ggl::ComputeSetup::~ComputeSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::DownscaleTextureComputeShaderState::~DownscaleTextureComputeShaderState(ggl::DownscaleTextureComputeShaderState *this)
{
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 16))(v2, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)this = &unk_1EF55D4B8;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 16))(v2, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::DownscaleTextureComputeShaderSetup::~DownscaleTextureComputeShaderSetup(ggl::DownscaleTextureComputeShaderSetup *this)
{
  ggl::ComputeSetup::~ComputeSetup(this);
  JUMPOUT(0x1A6239270);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t a2, void *a3)
{
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      double v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            double v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          double v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  double v10 = operator new(0x20uLL);
  *double v10 = 0;
  v10[1] = a2;
  v10[2] = *a3;
  *((_WORD *)v10 + 12) = 0;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_44;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_44:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
      else {
        unint64_t v3 = a2;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
  }
  uint64_t v22 = *(void *)a1;
  uint64_t v23 = *(void **)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    *double v10 = *v23;
LABEL_58:
    void *v23 = v10;
    goto LABEL_59;
  }
  *double v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    uint64_t v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void md::mun::MuninMetadata::~MuninMetadata(md::mun::MuninMetadata *this)
{
  md::mun::MuninMetadata::~MuninMetadata(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  *(void *)this = &unk_1EF5502C0;
  uint64_t v2 = (void *)*((void *)this + 40);
  if (v2)
  {
    *((void *)this + 41) = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)*((void *)this + 34);
  if (v3)
  {
    do
    {
      uint64_t v4 = (void *)*v3;
      operator delete(v3);
      unint64_t v3 = v4;
    }
    while (v4);
  }
  uint64_t v5 = (void *)*((void *)this + 32);
  *((void *)this + 32) = 0;
  if (v5) {
    operator delete(v5);
  }
  double v6 = *((void *)this + 29);
  if (v6)
  {
    unint64_t v7 = *((void *)this + 30);
    uint8x8_t v8 = (void *)*((void *)this + 29);
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = *(void **)(v7 - 80);
        if (v9 != *(void **)(v7 - 64)) {
          free(v9);
        }
        if (*(unsigned char *)(v7 - 120)) {
          *(unsigned char *)(v7 - 120) = 0;
        }
        if (*(unsigned char *)(v7 - 160)) {
          *(unsigned char *)(v7 - 160) = 0;
        }
        v7 -= 168;
      }
      while (v7 != v6);
      uint8x8_t v8 = (void *)*((void *)this + 29);
    }
    *((void *)this + 30) = v6;
    operator delete(v8);
  }
  double v10 = (void *)*((void *)this + 26);
  if (v10)
  {
    do
    {
      unint64_t v11 = (void *)*v10;
      operator delete(v10);
      double v10 = v11;
    }
    while (v11);
  }
  uint64_t v12 = (void *)*((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v12) {
    operator delete(v12);
  }
  float v13 = *((void *)this + 21);
  if (v13)
  {
    float v14 = *((void *)this + 22);
    BOOL v15 = (void *)*((void *)this + 21);
    if (v14 != v13)
    {
      do
      {
        unint64_t v16 = v14 - 1864;
        unint64_t v17 = *(void **)(v14 - 1776);
        float64x2_t v18 = *(void **)(v14 - 1768);
        if (v17 != v18)
        {
          do
          {
            unint64_t v19 = (void *)v17[31];
            if (v19 != (void *)v17[33]) {
              free(v19);
            }
            v17 += 36;
          }
          while (v17 != v18);
          unint64_t v17 = *(void **)(v14 - 1776);
        }
        if (v17 != *(void **)(v14 - 1760)) {
          free(v17);
        }
        v14 -= 1864;
      }
      while (v16 != v13);
      BOOL v15 = (void *)*((void *)this + 21);
    }
    *((void *)this + 22) = v13;
    operator delete(v15);
  }
  *(void *)this = &unk_1EF558F70;
  if (*((unsigned char *)this + 112)) {
    *((unsigned char *)this + 112) = 0;
  }
  uint8x8_t v20 = (void *)*((void *)this + 4);
  if (v20 != *((void **)this + 6)) {
    free(v20);
  }
}

uint64_t md::mun::MuninMetadata::MuninMetadata(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v7 = a1;
  *(void *)a1 = &unk_1EF558F70;
  *(_DWORD *)(a1 + 8) = atomic_fetch_add(gdc::LayerData::nextId(void)::idGenerator, 1u) + 1;
  *(unsigned char *)(a1 + 16) = *(unsigned char *)a2;
  gdc::LayerDataKey::LayerDataKey(a1 + 24, a2 + 8);
  *(unsigned char *)(v7 + 112) = 0;
  if (*(unsigned char *)(a2 + 96))
  {
    *(_DWORD *)(v7 + 116) = *(_DWORD *)(a2 + 100);
    *(unsigned char *)(v7 + 112) = 1;
  }
  *(void *)(v7 + 120) = *(void *)(a2 + 104);
  *(void *)(v7 + 128) = 0;
  *(unsigned char *)(v7 + 160) = 1;
  *(void *)(v7 + 144) = 0;
  *(void *)(v7 + 152) = 0;
  *(void *)(v7 + 136) = 0;
  *(void *)uint64_t v7 = &unk_1EF5502C0;
  *(void *)(v7 + 176) = 0;
  *(void *)(v7 + 184) = 0;
  *(void *)(v7 + 168) = 0;
  uint64_t v9 = *a3;
  uint64_t v8 = a3[1];
  int64_t v10 = v8 - v9;
  if (v8 == v9)
  {
    uint64_t v12 = 0;
  }
  else
  {
    unint64_t v11 = 0x63FB9AEB1FDCD759 * (v10 >> 3);
    if (v11 >= 0x2328A701194539) {
      goto LABEL_142;
    }
    uint64_t v12 = (char *)operator new(v10);
    *(void *)(v7 + 168) = v12;
    *(void *)(v7 + 176) = v12;
    *(void *)(v7 + 184) = &v12[1864 * v11];
    do
    {
      *(void *)uint64_t v12 = *(void *)v9;
      long long v13 = *(_OWORD *)(v9 + 8);
      *((void *)v12 + 3) = *(void *)(v9 + 24);
      *(_OWORD *)(v12 + 8) = v13;
      uint64_t v14 = *(void *)(v9 + 32);
      *((_DWORD *)v12 + 10) = *(_DWORD *)(v9 + 40);
      *((void *)v12 + 4) = v14;
      *(void *)(v12 + 44) = *(void *)(v9 + 44);
      long long v15 = *(_OWORD *)(v9 + 56);
      long long v16 = *(_OWORD *)(v9 + 72);
      unint64_t v17 = v12 + 120;
      *((void *)v12 + 11) = v12 + 120;
      float64x2_t v18 = v12 + 88;
      *((_OWORD *)v18 - 2) = v15;
      *((_OWORD *)v18 - 1) = v16;
      v18[1] = v17;
      v18[2] = v17;
      v18[3] = 6;
      geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)v18, *(long long **)(v9 + 88), *(long long **)(v9 + 96));
      uint64_t v19 = *(void *)(v9 + 1848);
      *(void *)((char *)v18 + 1765) = *(void *)(v9 + 1853);
      v18[220] = v19;
      uint64_t v12 = (char *)(v18 + 222);
      v9 += 1864;
    }
    while (v9 != v8);
    *(void *)(v7 + 176) = v12;
  }
  long long v20 = 0uLL;
  *(_OWORD *)(v7 + 192) = 0u;
  *(_OWORD *)(v7 + 208) = 0u;
  uint64_t v21 = v7 + 192;
  *(_DWORD *)(v7 + 224) = 1065353216;
  *(void *)(v7 + 240) = 0;
  *(void *)(v7 + 248) = 0;
  *(void *)(v7 + 232) = 0;
  uint64_t v22 = *a4;
  uint64_t v23 = a4[1];
  int64_t v24 = v23 - *a4;
  uint64_t v135 = v7;
  if (v23 == *a4)
  {
    float v36 = 1.0;
  }
  else
  {
    unint64_t v25 = 0xCF3CF3CF3CF3CF3DLL * (v24 >> 3);
    if (v25 >= 0x186186186186187) {
      goto LABEL_142;
    }
    uint64_t v26 = (char *)operator new(v24);
    uint64_t v27 = 0;
    *(void *)(v7 + 232) = v26;
    *(void *)(v7 + 240) = v26;
    *(void *)(v7 + 248) = &v26[168 * v25];
    do
    {
      uint64_t v31 = &v26[v27];
      uint64_t v32 = v22 + v27;
      *(void *)uint64_t v31 = *(void *)(v22 + v27);
      v31[8] = 0;
      if (*(unsigned char *)(v22 + v27 + 8))
      {
        long long v33 = *(_OWORD *)(v32 + 32);
        *((_OWORD *)v31 + 1) = *(_OWORD *)(v32 + 16);
        *((_OWORD *)v31 + 2) = v33;
        v31[8] = 1;
      }
      v31[48] = 0;
      if (*(unsigned char *)(v32 + 48))
      {
        std::string::size_type v34 = &v26[v27];
        long long v35 = *(_OWORD *)(v22 + v27 + 56);
        *(_OWORD *)(v34 + 72) = *(_OWORD *)(v22 + v27 + 72);
        *(_OWORD *)(v34 + 56) = v35;
        v31[48] = 1;
      }
      uint64_t v28 = &v26[v27];
      uint64_t v29 = (uint64_t)&v26[v27 + 120];
      *((void *)v28 + 11) = v29;
      *((void *)v28 + 12) = v29;
      uint64_t v30 = (uint64_t)&v26[v27 + 88];
      *(void *)(v30 + 16) = v29;
      *(void *)(v30 + 24) = 1;
      geo::small_vector_base<md::mun::OrientedPlane>::append<md::mun::OrientedPlane const*>(v30, *(long long **)(v32 + 88), *(long long **)(v32 + 96));
      v27 += 168;
    }
    while (v32 + 168 != v23);
    *(void *)(v7 + 240) = &v26[v27];
    uint64_t v12 = *(char **)(v7 + 176);
    float v36 = *(float *)(v7 + 224);
    long long v20 = 0uLL;
  }
  *(_OWORD *)(v7 + 256) = v20;
  *(_OWORD *)(v7 + 272) = v20;
  *(_DWORD *)(v7 + 288) = 1065353216;
  *(_WORD *)(v7 + 296) = 255;
  *(_DWORD *)(v7 + 304) = 0;
  *(_DWORD *)(v7 + 300) = 0;
  *(void *)(v7 + 328) = 0;
  *(void *)(v7 + 336) = 0;
  *(void *)(v7 + 320) = 0;
  unint64_t prime = vcvtps_u32_f32((float)(unint64_t)(0x63FB9AEB1FDCD759 * ((uint64_t)&v12[-*(void *)(v7 + 168)] >> 3)) / v36);
  if (prime == 1)
  {
    unint64_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    unint64_t prime = std::__next_prime(prime);
  }
  int8x8_t v38 = *(int8x8_t *)(v7 + 200);
  if (prime > *(void *)&v38) {
    goto LABEL_24;
  }
  if (prime < *(void *)&v38)
  {
    unint64_t v39 = vcvtps_u32_f32((float)*(unint64_t *)(v7 + 216) / *(float *)(v7 + 224));
    if (*(void *)&v38 < 3uLL || (uint8x8_t v40 = (uint8x8_t)vcnt_s8(v38), v40.i16[0] = vaddlv_u8(v40), v40.u32[0] > 1uLL))
    {
      unint64_t v39 = std::__next_prime(v39);
    }
    else
    {
      uint64_t v41 = 1 << -(char)__clz(v39 - 1);
      if (v39 >= 2) {
        unint64_t v39 = v41;
      }
    }
    if (prime <= v39) {
      unint64_t prime = v39;
    }
    if (prime < *(void *)&v38) {
LABEL_24:
    }
      std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v21, prime);
  }
  uint64_t v42 = *(void *)(v7 + 168);
  if (*(void *)(v7 + 176) != v42)
  {
    uint64_t v43 = 0;
    unint64_t v44 = 0;
    do
    {
      *((_WORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v21, *(void *)(v42 + v43), (void *)(v42 + v43))+ 12) = v44++;
      uint64_t v42 = *(void *)(v7 + 168);
      v43 += 1864;
    }
    while (v44 < 0x63FB9AEB1FDCD759 * ((*(void *)(v7 + 176) - v42) >> 3));
  }
  unint64_t v45 = vcvtps_u32_f32((float)(0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(void *)(v7 + 240) - *(void *)(v7 + 232)) >> 3))/ *(float *)(v7 + 288));
  if (v45 == 1)
  {
    unint64_t v45 = 2;
  }
  else if ((v45 & (v45 - 1)) != 0)
  {
    unint64_t v45 = std::__next_prime(v45);
  }
  int8x8_t v46 = *(int8x8_t *)(v7 + 264);
  if (v45 > *(void *)&v46) {
    goto LABEL_43;
  }
  if (v45 < *(void *)&v46)
  {
    unint64_t v47 = vcvtps_u32_f32((float)*(unint64_t *)(v7 + 280) / *(float *)(v7 + 288));
    if (*(void *)&v46 < 3uLL || (uint8x8_t v48 = (uint8x8_t)vcnt_s8(v46), v48.i16[0] = vaddlv_u8(v48), v48.u32[0] > 1uLL))
    {
      unint64_t v47 = std::__next_prime(v47);
    }
    else
    {
      uint64_t v49 = 1 << -(char)__clz(v47 - 1);
      if (v47 >= 2) {
        unint64_t v47 = v49;
      }
    }
    if (v45 <= v47) {
      unint64_t v45 = v47;
    }
    if (v45 < *(void *)&v46) {
LABEL_43:
    }
      std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v7 + 256, v45);
  }
  uint64_t v50 = *(void *)(v7 + 232);
  if (*(void *)(v7 + 240) != v50)
  {
    uint64_t v51 = 0;
    unint64_t v52 = 0;
    do
    {
      *((_WORD *)std::__hash_table<std::__hash_value_type<unsigned long long,unsigned short>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned short>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned short>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v7 + 256, *(void *)(v50 + v51), (void *)(v50 + v51))+ 12) = v52++;
      uint64_t v50 = *(void *)(v7 + 232);
      v51 += 168;
    }
    while (v52 < 0xCF3CF3CF3CF3CF3DLL * ((*(void *)(v7 + 240) - v50) >> 3));
  }
  size_t v53 = *(int32x2_t **)(a2 + 16);
  __int32 v54 = v53[1].i32[0];
  int32x2_t v55 = *v53;
  *(unsigned char *)(v7 + 296) = -1;
  *(unsigned char *)(v7 + 297) = v54;
  *(int32x2_t *)(v7 + 300) = vrev64_s32(v55);
  bzero(v136, 0x960uLL);
  uint64_t v57 = *(void *)(v7 + 168);
  uint64_t v56 = *(void *)(v7 + 176);
  if (v57 == v56)
  {
    uint64_t v84 = *(void *)(v7 + 168);
  }
  else
  {
    uint64_t v133 = *(void *)(v7 + 176);
    do
    {
      int v59 = 1 << *(unsigned char *)(v7 + 297);
      double v60 = -1.0 / (double)v59;
      float v61 = (*(double *)(v57 + 56) + v60 * (double)*(int *)(v7 + 304)) * (double)v59;
      float v62 = (*(double *)(v57 + 64) + v60 * (double)(v59 + ~*(_DWORD *)(v7 + 300))) * (double)v59;
      int v63 = (int)(float)(v61 * 10.0);
      if (v63 >= 9) {
        int v63 = 9;
      }
      int v64 = v63 & ~(v63 >> 31);
      int v65 = (int)(float)(v62 * 10.0);
      if (v65 >= 9) {
        int v65 = 9;
      }
      int8x16_t v66 = &v136[240 * (v65 & ~(v65 >> 31)) + 24 * v64];
      int8x16_t v67 = (void *)*((void *)v66 + 1);
      unint64_t v68 = *((void *)v66 + 2);
      if ((unint64_t)v67 < v68)
      {
        *int8x16_t v67 = v57;
        uint64_t v58 = v67 + 1;
        uint64_t v7 = v135;
      }
      else
      {
        int32x4_t v69 = *(unsigned char **)v66;
        uint64_t v70 = (uint64_t)v67 - *(void *)v66;
        uint64_t v71 = v70 >> 3;
        unint64_t v72 = (v70 >> 3) + 1;
        if (v72 >> 61) {
          goto LABEL_142;
        }
        uint64_t v73 = v68 - (void)v69;
        if (v73 >> 2 > v72) {
          unint64_t v72 = v73 >> 2;
        }
        if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v74 = v72;
        }
        if (v74)
        {
          if (v74 >> 61) {
LABEL_143:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          uint64_t v75 = operator new(8 * v74);
        }
        else
        {
          uint64_t v75 = 0;
        }
        long long v76 = &v75[8 * v71];
        *long long v76 = v57;
        uint64_t v58 = v76 + 1;
        if (v67 == (void *)v69)
        {
          int32x4_t v69 = v67;
        }
        else
        {
          unint64_t v77 = (char *)(v67 - 1) - v69;
          if (v77 < 0x58) {
            goto LABEL_146;
          }
          if ((unint64_t)((char *)v67 - &v75[v70]) < 0x20) {
            goto LABEL_146;
          }
          uint64_t v78 = (v77 >> 3) + 1;
          uint64_t v79 = &v75[8 * v71 - 16];
          uint64_t v80 = (long long *)(v67 - 2);
          uint64_t v81 = v78 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v82 = *v80;
            *(v79 - 1) = *(v80 - 1);
            *uint64_t v79 = v82;
            v79 -= 2;
            v80 -= 2;
            v81 -= 4;
          }
          while (v81);
          v76 -= v78 & 0x3FFFFFFFFFFFFFFCLL;
          v67 -= v78 & 0x3FFFFFFFFFFFFFFCLL;
          if (v78 != (v78 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_146:
            do
            {
              uint64_t v83 = *--v67;
              *--long long v76 = v83;
            }
            while (v67 != (void *)v69);
            int32x4_t v69 = *(unsigned char **)v66;
          }
        }
        *(void *)int8x16_t v66 = v76;
        *((void *)v66 + 2) = &v75[8 * v74];
        if (v69) {
          operator delete(v69);
        }
        uint64_t v56 = v133;
        uint64_t v7 = v135;
      }
      *((void *)v66 + 1) = v58;
      v57 += 1864;
    }
    while (v57 != v56);
    uint64_t v57 = *(void *)(v7 + 168);
    uint64_t v84 = *(void *)(v7 + 176);
  }
  unint64_t v85 = 0x63FB9AEB1FDCD759 * ((v84 - v57) >> 3);
  int8x16_t v86 = *(unsigned char **)(v7 + 320);
  if (v85 <= (uint64_t)(*(void *)(v7 + 336) - (void)v86) >> 3) {
    goto LABEL_103;
  }
  if (v85 >> 61) {
LABEL_142:
  }
    abort();
  float v87 = *(unsigned char **)(v7 + 328);
  uint64_t v88 = 8 * v85;
  unsigned int v89 = (char *)operator new(8 * v85);
  uint64_t v90 = v87 - v86;
  float v91 = &v89[(v87 - v86) & 0xFFFFFFFFFFFFFFF8];
  float v92 = v91;
  if (v87 == v86) {
    goto LABEL_101;
  }
  if ((unint64_t)(v90 - 8) < 0x58)
  {
    float v92 = &v89[(v87 - v86) & 0xFFFFFFFFFFFFFFF8];
    do
    {
LABEL_100:
      uint64_t v99 = *((void *)v87 - 1);
      v87 -= 8;
      *((void *)v92 - 1) = v99;
      v92 -= 8;
    }
    while (v87 != v86);
    goto LABEL_101;
  }
  float v92 = &v89[(v87 - v86) & 0xFFFFFFFFFFFFFFF8];
  if ((unint64_t)(v87 - &v89[v90 & 0xFFFFFFFFFFFFFFF8]) < 0x20) {
    goto LABEL_100;
  }
  uint64_t v93 = v90 >> 3;
  unint64_t v94 = ((unint64_t)(v90 - 8) >> 3) + 1;
  float32x2_t v95 = &v89[8 * v93 - 16];
  float32x2_t v96 = (long long *)(v87 - 16);
  uint64_t v97 = v94 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v98 = *v96;
    *((_OWORD *)v95 - 1) = *(v96 - 1);
    *(_OWORD *)float32x2_t v95 = v98;
    v95 -= 32;
    v96 -= 2;
    v97 -= 4;
  }
  while (v97);
  float v92 = &v91[-8 * (v94 & 0x3FFFFFFFFFFFFFFCLL)];
  v87 -= 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
  if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_100;
  }
LABEL_101:
  *(void *)(v7 + 320) = v92;
  *(void *)(v7 + 328) = v91;
  *(void *)(v7 + 336) = &v89[v88];
  if (v86) {
    operator delete(v86);
  }
LABEL_103:
  uint64_t v100 = 0;
  float64x2_t v101 = (_DWORD *)(v7 + 320);
  uint64_t v131 = v7 + 344;
  float64x2_t v102 = *(void **)(v7 + 328);
  do
  {
    uint64_t v103 = 0;
    uint64_t v130 = v100;
    uint64_t v132 = 10 * v100;
    uint64_t v104 = v102;
    do
    {
      uint64_t v134 = v103;
      uint64_t v105 = v103 + v132;
      *(_WORD *)(v131 + 2 * v105) = (v104 - *v101) >> 3;
      uint64_t v106 = &v136[24 * v105];
      uint64_t v108 = *(uint64_t **)v106;
      uint64_t v107 = (uint64_t *)*((void *)v106 + 1);
      while (v108 != v107)
      {
        uint64_t v109 = *v108;
        unint64_t v110 = *(void *)(v7 + 336);
        if ((unint64_t)v104 < v110)
        {
          void *v104 = v109;
          float64x2_t v102 = v104 + 1;
          goto LABEL_109;
        }
        int8x8_t v111 = *(unsigned char **)v101;
        uint64_t v112 = (uint64_t)v104 - *(void *)v101;
        uint64_t v113 = v112 >> 3;
        unint64_t v114 = (v112 >> 3) + 1;
        if (v114 >> 61) {
          goto LABEL_142;
        }
        uint64_t v115 = v110 - (void)v111;
        if (v115 >> 2 > v114) {
          unint64_t v114 = v115 >> 2;
        }
        if ((unint64_t)v115 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v116 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v116 = v114;
        }
        if (v116)
        {
          if (v116 >> 61) {
            goto LABEL_143;
          }
          uint64_t v117 = operator new(8 * v116);
        }
        else
        {
          uint64_t v117 = 0;
        }
        long long v118 = &v117[8 * v113];
        *long long v118 = v109;
        float64x2_t v102 = v118 + 1;
        if (v104 == (void *)v111)
        {
          int8x8_t v111 = v104;
          uint64_t v7 = v135;
        }
        else
        {
          unint64_t v119 = (char *)(v104 - 1) - v111;
          if (v119 < 0x168
            || &v117[v112 - 8 - (v119 & 0xFFFFFFFFFFFFFFF8)] > &v117[v112 - 8]
            || (void *)((char *)v104 - (v119 & 0xFFFFFFFFFFFFFFF8) - 8) > v104 - 1
            || (unint64_t)((char *)v104 - v117 - v112) < 0x20)
          {
            uint64_t v120 = v104;
            uint64_t v7 = v135;
            do
            {
LABEL_125:
              uint64_t v121 = *--v120;
              *--long long v118 = v121;
            }
            while (v120 != (void *)v111);
            int8x8_t v111 = *(unsigned char **)v101;
            goto LABEL_128;
          }
          uint64_t v122 = (v119 >> 3) + 1;
          uint64_t v120 = &v104[-(v122 & 0x3FFFFFFFFFFFFFFCLL)];
          long long v123 = &v117[8 * v113 - 16];
          long long v124 = (long long *)(v104 - 2);
          uint64_t v125 = v122 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v126 = *v124;
            *(v123 - 1) = *(v124 - 1);
            _OWORD *v123 = v126;
            v123 -= 2;
            v124 -= 2;
            v125 -= 4;
          }
          while (v125);
          v118 -= v122 & 0x3FFFFFFFFFFFFFFCLL;
          uint64_t v7 = v135;
          if (v122 != (v122 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_125;
          }
        }
LABEL_128:
        *(void *)(v7 + 320) = v118;
        *(void *)(v7 + 328) = v102;
        *(void *)(v7 + 336) = &v117[8 * v116];
        if (v111) {
          operator delete(v111);
        }
LABEL_109:
        *(void *)(v7 + 328) = v102;
        ++v108;
        uint64_t v104 = v102;
      }
      uint64_t v103 = v134 + 1;
    }
    while (v134 != 9);
    uint64_t v100 = v130 + 1;
  }
  while (v130 != 9);
  uint64_t v127 = 2400;
  do
  {
    int v128 = *(void **)&v136[v127 - 24];
    if (v128)
    {
      *(void *)&v136[v127 - 16] = v128;
      operator delete(v128);
    }
    v127 -= 24;
  }
  while (v127);
  return v7;
}

unint64_t md::mun::MuninMetadata::_searchBounds(uint64_t a1, double a2, double a3, double a4)
{
  long double v8 = exp(a3 * 6.28318531 + -3.14159265);
  long double v9 = atan(v8) * 114.591559 + -90.0;
  long double v10 = cos(v9 * 0.034906585) * -559.82 + 111132.92;
  long double v11 = v10 + cos(v9 * 0.0698131701) * 1.175;
  long double v12 = v11 + cos(v9 * 0.104719755) * -0.0023;
  long double v13 = v9 * 0.00872664626;
  long double v14 = tan(v9 * 0.00872664626 + 0.78103484);
  double v15 = log(v14);
  long double v16 = tan(v13 + 0.789761487);
  long double v17 = fabs((log(v16) - v15) * 0.159154943) * a4 / v12;
  int v18 = 1 << *(unsigned char *)(a1 + 297);
  double v19 = -1.0 / (double)v18;
  float v21 = (a3 + v19 * (double)(v18 + ~*(_DWORD *)(a1 + 300)) - v17) * (double)v18;
  float v20 = (a2 + v19 * (double)*(int *)(a1 + 304) - v17) * (double)v18;
  return (int)(float)(v20 * 10.0) & ~((int)(float)(v20 * 10.0) >> 31) | ((unint64_t)((int)(float)(v21 * 10.0) & ~((int)(float)(v21 * 10.0) >> 31)) << 32);
}

uint64_t geo::optional<md::mun::CollectionPoint>::optional(uint64_t result, uint64_t a2)
{
  *(unsigned char *)uint64_t result = 1;
  *(void *)(result + 8) = *(void *)a2;
  long long v2 = *(_OWORD *)(a2 + 8);
  *(void *)(result + 32) = *(void *)(a2 + 24);
  *(_OWORD *)(result + 16) = v2;
  uint64_t v3 = *(void *)(a2 + 32);
  *(_DWORD *)(result + 48) = *(_DWORD *)(a2 + 40);
  *(void *)(result + 40) = v3;
  *(void *)(result + 52) = *(void *)(a2 + 44);
  long long v4 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)(result + 64) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(result + 80) = v4;
  uint64_t v5 = result + 128;
  *(void *)(result + 96) = result + 128;
  double v6 = *(long long **)(a2 + 88);
  *(void *)(result + 112) = result + 128;
  uint64_t v7 = *(long long **)(a2 + 104);
  *(void *)(result + 120) = *(void *)(a2 + 112);
  *(void *)(result + 104) = result + 128;
  if (v6 == v7)
  {
    *(void *)(result + 104) = v5 + *(void *)(a2 + 96) - (void)v6;
    long double v10 = *(long long **)(a2 + 96);
    if (v6 == v10) {
      goto LABEL_3;
    }
    uint64_t v11 = 0;
    long double v12 = (_OWORD *)(result + 424);
    uint64_t v13 = result + 408;
    while (1)
    {
      long long v15 = *v6;
      *(void *)(v5 + 16) = *((void *)v6 + 2);
      *(_OWORD *)uint64_t v5 = v15;
      uint64_t v16 = *((void *)v6 + 3);
      *(_DWORD *)(v5 + 32) = *((_DWORD *)v6 + 8);
      *(void *)(v5 + 24) = v16;
      *(void *)(v5 + 36) = *(void *)((char *)v6 + 36);
      long long v17 = *(long long *)((char *)v6 + 44);
      long long v18 = *(long long *)((char *)v6 + 60);
      long long v19 = *(long long *)((char *)v6 + 76);
      *(_OWORD *)(v5 + 92) = *(long long *)((char *)v6 + 92);
      *(_OWORD *)(v5 + 76) = v19;
      *(_OWORD *)(v5 + 60) = v18;
      *(_OWORD *)(v5 + 44) = v17;
      long long v20 = *(long long *)((char *)v6 + 108);
      long long v21 = *(long long *)((char *)v6 + 124);
      long long v22 = *(long long *)((char *)v6 + 140);
      *(_OWORD *)(v5 + 156) = *(long long *)((char *)v6 + 156);
      *(_OWORD *)(v5 + 140) = v22;
      *(_OWORD *)(v5 + 124) = v21;
      *(_OWORD *)(v5 + 108) = v20;
      long long v23 = *(long long *)((char *)v6 + 172);
      long long v24 = *(long long *)((char *)v6 + 188);
      long long v25 = *(long long *)((char *)v6 + 204);
      *(_OWORD *)(v5 + 220) = *(long long *)((char *)v6 + 220);
      *(_OWORD *)(v5 + 204) = v25;
      *(_OWORD *)(v5 + 188) = v24;
      *(_OWORD *)(v5 + 172) = v23;
      uint64_t v26 = (unsigned char *)(v5 + 280);
      *(void *)(v5 + 248) = v5 + 280;
      uint64_t v27 = (char *)*((void *)v6 + 31);
      *(unsigned char *)(v5 + 240) = *((unsigned char *)v6 + 240);
      *(void *)(v5 + 264) = v5 + 280;
      uint64_t v28 = (char *)*((void *)v6 + 33);
      *(void *)(v5 + 272) = *((void *)v6 + 34);
      *(_DWORD *)(v5 + 236) = *((_DWORD *)v6 + 59);
      *(void *)(v5 + 256) = v5 + 280;
      if (v27 == v28)
      {
        *(void *)(v5 + 256) = &v26[*((void *)v6 + 32) - (void)v27];
        uint64_t v29 = (char *)*((void *)v6 + 32);
        if (v27 != v29)
        {
          unint64_t v30 = v29 - v27;
          if ((unint64_t)(v29 - v27) >= 8 && (unint64_t)(result + 408 + 288 * v11 - (void)v27) >= 0x20)
          {
            if (v30 < 0x20)
            {
              unint64_t v31 = 0;
              goto LABEL_18;
            }
            unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFE0;
            uint64_t v32 = (long long *)(v27 + 16);
            long long v33 = v12;
            unint64_t v34 = v30 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v35 = *v32;
              *(v33 - 1) = *(v32 - 1);
              _OWORD *v33 = v35;
              v32 += 2;
              v33 += 2;
              v34 -= 32;
            }
            while (v34);
            if (v30 == v31) {
              goto LABEL_7;
            }
            if ((v30 & 0x18) != 0)
            {
LABEL_18:
              unint64_t v36 = v30 & 0xFFFFFFFFFFFFFFF8;
              v26 += v30 & 0xFFFFFFFFFFFFFFF8;
              unint64_t v37 = v31 - (v30 & 0xFFFFFFFFFFFFFFF8);
              int8x8_t v38 = (uint64_t *)&v27[v31];
              unint64_t v39 = (void *)(v13 + v31);
              do
              {
                uint64_t v40 = *v38++;
                *v39++ = v40;
                v37 += 8;
              }
              while (v37);
              if (v30 == v36) {
                goto LABEL_7;
              }
              v27 += v36;
            }
            else
            {
              v27 += v31;
              v26 += v31;
            }
          }
          do
          {
            char v41 = *v27++;
            *v26++ = v41;
          }
          while (v27 != v29);
        }
      }
      else
      {
        uint64_t v14 = *((void *)v6 + 32);
        *(void *)(v5 + 248) = v27;
        *(void *)(v5 + 256) = v14;
        *(long long *)((char *)v6 + 248) = 0uLL;
        *(long long *)((char *)v6 + 264) = 0uLL;
      }
LABEL_7:
      v5 += 288;
      v6 += 18;
      ++v11;
      v12 += 18;
      v13 += 288;
      if (v6 == v10) {
        goto LABEL_3;
      }
    }
  }
  uint64_t v8 = *(void *)(a2 + 96);
  *(void *)(result + 96) = v6;
  *(void *)(result + 104) = v8;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
LABEL_3:
  uint64_t v9 = *(void *)(a2 + 1848);
  *(void *)(result + 1861) = *(void *)(a2 + 1853);
  *(void *)(result + 1856) = v9;
  return result;
}

void md::mun::MuninMetadata::neighborsWithinRadius(uint64_t a1, double *a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v8 = (float64x2_t *)a2;
  double v10 = a2[1];
  int64_t v11 = md::mun::MuninMetadata::_searchBounds(a1, *a2, v10, a5);
  uint64_t v13 = v12;
  long double v14 = exp(v10 * 6.28318531 + -3.14159265);
  long double v15 = atan(v14) * 114.591559 + -90.0;
  double v16 = cos(v15 * 0.034906585);
  double v17 = cos(v15 * 0.0698131701);
  double v18 = cos(v15 * 0.104719755);
  long double v19 = v15 * 0.00872664626;
  long double v20 = tan(v15 * 0.00872664626 + 0.78103484);
  double v21 = log(v20);
  long double v22 = tan(v19 + 0.789761487);
  double v23 = log(v22);
  if (SHIDWORD(v11) <= SHIDWORD(v13) && (int)v11 <= (int)v13)
  {
    double v24 = fabs((v23 - v21) * 0.159154943) / (v16 * -559.82 + 111132.92 + v17 * 1.175 + v18 * -0.0023);
    double v25 = v24 * v24;
    double v26 = a5 * a5 * v25;
    uint64_t v87 = a1 + 344;
    uint64_t v78 = (int)v11;
    int v79 = v13 + 1;
    uint64_t v27 = v11 >> 32;
    int v77 = HIDWORD(v13) + 1;
    double v28 = 1.0 / v25;
    uint64_t v83 = a4;
    uint64_t v84 = v8;
    do
    {
      uint64_t v80 = v27;
      uint64_t v81 = 10 * v27;
      uint64_t v29 = v78;
      do
      {
        uint64_t v30 = v81 + v29;
        unint64_t v31 = *(unsigned __int16 *)(v87 + 2 * (v81 + v29));
        uint64_t v82 = v29;
        BOOL v33 = v27 == 9 && v29 == 9;
        uint64_t v86 = v30 + 1;
        BOOL v85 = v33;
        while (1)
        {
          if (v33)
          {
            if (v31 >= (uint64_t)(*(void *)(a1 + 328) - *(void *)(a1 + 320)) >> 3) {
              break;
            }
          }
          else if (v31 >= *(unsigned __int16 *)(v87 + 2 * v86))
          {
            break;
          }
          uint64_t v35 = *(void *)(a1 + 320);
          if (v31 >= (*(void *)(a1 + 328) - v35) >> 3) {
            break;
          }
          uint64_t v36 = *(void *)(v35 + 8 * v31);
          float64x2_t v37 = vsubq_f64(*(float64x2_t *)(v36 + 56), *v8);
          double v38 = vaddvq_f64(vmulq_f64(v37, v37));
          if (v38 > v26) {
            goto LABEL_17;
          }
          uint64_t v40 = *(void **)(a3 + 8);
          unint64_t v39 = *(void *)(a3 + 16);
          if ((unint64_t)v40 < v39)
          {
            *uint64_t v40 = v36;
            *(void *)(a3 + 8) = v40 + 1;
            if (a4) {
              goto LABEL_50;
            }
            goto LABEL_17;
          }
          char v41 = *(unsigned char **)a3;
          uint64_t v42 = (uint64_t)v40 - *(void *)a3;
          uint64_t v43 = v42 >> 3;
          unint64_t v44 = (v42 >> 3) + 1;
          if (v44 >> 61) {
            goto LABEL_73;
          }
          uint64_t v45 = v39 - (void)v41;
          if (v45 >> 2 > v44) {
            unint64_t v44 = v45 >> 2;
          }
          if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v46 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v46 = v44;
          }
          if (v46)
          {
            if (v46 >> 61) {
              goto LABEL_74;
            }
            unint64_t v47 = operator new(8 * v46);
          }
          else
          {
            unint64_t v47 = 0;
          }
          uint8x8_t v48 = &v47[8 * v43];
          void *v48 = v36;
          uint64_t v49 = v48 + 1;
          if (v40 == (void *)v41)
          {
            char v41 = v40;
            a4 = v83;
            goto LABEL_47;
          }
          unint64_t v50 = (char *)(v40 - 1) - v41;
          if (v50 >= 0x58)
          {
            unint64_t v51 = (char *)v40 - &v47[v42];
            a4 = v83;
            if (v51 >= 0x20)
            {
              uint64_t v52 = (v50 >> 3) + 1;
              size_t v53 = &v47[8 * v43 - 16];
              __int32 v54 = (long long *)(v40 - 2);
              uint64_t v55 = v52 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v56 = *v54;
                *(v53 - 1) = *(v54 - 1);
                _OWORD *v53 = v56;
                v53 -= 2;
                v54 -= 2;
                v55 -= 4;
              }
              while (v55);
              v48 -= v52 & 0x3FFFFFFFFFFFFFFCLL;
              v40 -= v52 & 0x3FFFFFFFFFFFFFFCLL;
              if (v52 == (v52 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_47;
              }
            }
          }
          else
          {
            a4 = v83;
          }
          do
          {
            uint64_t v57 = *--v40;
            *--uint8x8_t v48 = v57;
          }
          while (v40 != (void *)v41);
          char v41 = *(unsigned char **)a3;
LABEL_47:
          *(void *)a3 = v48;
          *(void *)(a3 + 8) = v49;
          *(void *)(a3 + 16) = &v47[8 * v46];
          if (v41) {
            operator delete(v41);
          }
          uint64_t v8 = v84;
          BOOL v33 = v85;
          *(void *)(a3 + 8) = v49;
          if (a4)
          {
LABEL_50:
            double v58 = v38 * v28;
            double v60 = *(double **)(a4 + 8);
            unint64_t v59 = *(void *)(a4 + 16);
            if ((unint64_t)v60 < v59)
            {
              *double v60 = v58;
              unint64_t v34 = v60 + 1;
            }
            else
            {
              float v61 = *(double **)a4;
              uint64_t v62 = (uint64_t)v60 - *(void *)a4;
              uint64_t v63 = v62 >> 3;
              unint64_t v64 = (v62 >> 3) + 1;
              if (v64 >> 61) {
LABEL_73:
              }
                abort();
              uint64_t v65 = v59 - (void)v61;
              if (v65 >> 2 > v64) {
                unint64_t v64 = v65 >> 2;
              }
              if ((unint64_t)v65 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v66 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v66 = v64;
              }
              if (v66)
              {
                if (v66 >> 61) {
LABEL_74:
                }
                  std::__throw_bad_array_new_length[abi:nn180100]();
                int8x16_t v67 = operator new(8 * v66);
              }
              else
              {
                int8x16_t v67 = 0;
              }
              unint64_t v68 = (double *)&v67[8 * v63];
              *unint64_t v68 = v58;
              unint64_t v34 = v68 + 1;
              if (v60 == v61)
              {
                a4 = v83;
              }
              else
              {
                unint64_t v69 = (char *)(v60 - 1) - (char *)v61;
                if (v69 < 0x58)
                {
                  a4 = v83;
                  goto LABEL_69;
                }
                unint64_t v70 = (char *)v60 - &v67[v62];
                a4 = v83;
                if (v70 < 0x20) {
                  goto LABEL_77;
                }
                uint64_t v71 = (v69 >> 3) + 1;
                unint64_t v72 = &v67[8 * v63 - 16];
                uint64_t v73 = v60 - 2;
                uint64_t v74 = v71 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v75 = *(_OWORD *)v73;
                  *(v72 - 1) = *((_OWORD *)v73 - 1);
                  _OWORD *v72 = v75;
                  v72 -= 2;
                  v73 -= 4;
                  v74 -= 4;
                }
                while (v74);
                v68 -= v71 & 0x3FFFFFFFFFFFFFFCLL;
                v60 -= v71 & 0x3FFFFFFFFFFFFFFCLL;
                if (v71 != (v71 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_77:
                  do
                  {
LABEL_69:
                    uint64_t v76 = *((void *)v60-- - 1);
                    *((void *)v68-- - 1) = v76;
                  }
                  while (v60 != v61);
                }
              }
              *(void *)a4 = v68;
              *(void *)(a4 + 8) = v34;
              *(void *)(a4 + 16) = &v67[8 * v66];
              if (v61) {
                operator delete(v61);
              }
              uint64_t v8 = v84;
              BOOL v33 = v85;
            }
            *(void *)(a4 + 8) = v34;
          }
LABEL_17:
          ++v31;
        }
        uint64_t v29 = v82 + 1;
        uint64_t v27 = v80;
      }
      while (v79 != v82 + 1);
      uint64_t v27 = v80 + 1;
    }
    while (v77 != v80 + 1);
  }
}

void md::mun::MuninMetadata::neighborsWithinRadius(uint64_t a1, double *a2, uint64_t a3, double **a4, double a5)
{
  uint64_t v8 = a2;
  long double v10 = *a2;
  long double v11 = a2[1];
  long double v12 = a2[2];
  double v13 = sqrt(v10 * v10 + v11 * v11);
  double v14 = atan2(v12, v13 * 0.996647189);
  long double v87 = atan2(v11, v10);
  __double2 v15 = __sincos_stret(v14);
  long double v16 = atan2(v12 + v15.__sinval * v15.__sinval * 42841.3115 * v15.__sinval, v13 + v15.__cosval * v15.__cosval * -42697.6727 * v15.__cosval);
  long double v17 = tan(v16 * 0.5 + 0.785398163);
  long double v18 = log(v17);
  v19.f64[0] = v87;
  v19.f64[1] = v18;
  __asm { FMOV            V0.2D, #0.5 }
  float64x2_t v24 = vmlaq_f64(_Q0, (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL), v19);
  int64_t v25 = md::mun::MuninMetadata::_searchBounds(a1, v24.f64[0], v24.f64[1], a5);
  if (SHIDWORD(v25) <= v27 && (int)v25 <= v26)
  {
    uint64_t v88 = a1 + 344;
    uint64_t v78 = (int)v25;
    double v29 = a5 * a5;
    int v79 = v26 + 1;
    uint64_t v30 = v25 >> 32;
    int v77 = v27 + 1;
    uint64_t v83 = v8;
    uint64_t v84 = a4;
    do
    {
      uint64_t v80 = v30;
      uint64_t v81 = 10 * v30;
      uint64_t v31 = v78;
      do
      {
        uint64_t v32 = v81 + v31;
        unint64_t v33 = *(unsigned __int16 *)(v88 + 2 * (v81 + v31));
        uint64_t v82 = v31;
        BOOL v35 = v30 == 9 && v31 == 9;
        uint64_t v86 = v32 + 1;
        BOOL v85 = v35;
        while (1)
        {
          if (v35)
          {
            if (v33 >= (uint64_t)(*(void *)(a1 + 328) - *(void *)(a1 + 320)) >> 3) {
              break;
            }
          }
          else if (v33 >= *(unsigned __int16 *)(v88 + 2 * v86))
          {
            break;
          }
          uint64_t v37 = *(void *)(a1 + 320);
          if (v33 >= (*(void *)(a1 + 328) - v37) >> 3) {
            break;
          }
          double v38 = *(float64x2_t **)(v37 + 8 * v33);
          float64x2_t v39 = vsubq_f64(v38[1], *(float64x2_t *)(v8 + 1));
          float64x2_t v40 = vmulq_f64(v39, v39);
          double v41 = v40.f64[0] + (v38->f64[1] - *v8) * (v38->f64[1] - *v8) + v40.f64[1];
          if (v41 > v29) {
            goto LABEL_19;
          }
          uint64_t v43 = *(float64x2_t ***)(a3 + 8);
          unint64_t v42 = *(void *)(a3 + 16);
          if ((unint64_t)v43 >= v42)
          {
            unint64_t v44 = *(float64x2_t ***)a3;
            uint64_t v45 = (uint64_t)v43 - *(void *)a3;
            uint64_t v46 = v45 >> 3;
            unint64_t v47 = (v45 >> 3) + 1;
            if (v47 >> 61) {
              goto LABEL_72;
            }
            uint64_t v48 = v42 - (void)v44;
            if (v48 >> 2 > v47) {
              unint64_t v47 = v48 >> 2;
            }
            if ((unint64_t)v48 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v49 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v49 = v47;
            }
            if (v49)
            {
              if (v49 >> 61) {
                goto LABEL_73;
              }
              unint64_t v50 = operator new(8 * v49);
            }
            else
            {
              unint64_t v50 = 0;
            }
            unint64_t v51 = (float64x2_t **)&v50[8 * v46];
            std::__shared_weak_count_vtbl *v51 = v38;
            uint64_t v52 = v51 + 1;
            if (v43 == v44)
            {
              unint64_t v44 = v43;
            }
            else
            {
              unint64_t v53 = (char *)(v43 - 1) - (char *)v44;
              if (v53 < 0x58) {
                goto LABEL_76;
              }
              if ((unint64_t)((char *)v43 - &v50[v45]) < 0x20) {
                goto LABEL_76;
              }
              uint64_t v54 = (v53 >> 3) + 1;
              uint64_t v55 = &v50[8 * v46 - 16];
              long long v56 = v43 - 2;
              uint64_t v57 = v54 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v58 = *(_OWORD *)v56;
                *(v55 - 1) = *((_OWORD *)v56 - 1);
                *uint64_t v55 = v58;
                v55 -= 2;
                v56 -= 4;
                v57 -= 4;
              }
              while (v57);
              v51 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
              v43 -= v54 & 0x3FFFFFFFFFFFFFFCLL;
              if (v54 != (v54 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_76:
                do
                {
                  unint64_t v59 = *--v43;
                  *--unint64_t v51 = v59;
                }
                while (v43 != v44);
                unint64_t v44 = *(float64x2_t ***)a3;
              }
            }
            *(void *)a3 = v51;
            *(void *)(a3 + 8) = v52;
            *(void *)(a3 + 16) = &v50[8 * v49];
            if (v44) {
              operator delete(v44);
            }
            uint64_t v8 = v83;
            a4 = v84;
            BOOL v35 = v85;
            *(void *)(a3 + 8) = v52;
            if (!v84) {
              goto LABEL_19;
            }
          }
          else
          {
            std::__shared_weak_count *v43 = v38;
            *(void *)(a3 + 8) = v43 + 1;
            if (!a4) {
              goto LABEL_19;
            }
          }
          float v61 = a4[1];
          unint64_t v60 = (unint64_t)a4[2];
          if ((unint64_t)v61 < v60)
          {
            *float v61 = v41;
            uint64_t v36 = v61 + 1;
          }
          else
          {
            uint64_t v62 = *a4;
            uint64_t v63 = (char *)v61 - (char *)*a4;
            uint64_t v64 = v63 >> 3;
            unint64_t v65 = (v63 >> 3) + 1;
            if (v65 >> 61) {
LABEL_72:
            }
              abort();
            uint64_t v66 = v60 - (void)v62;
            if (v66 >> 2 > v65) {
              unint64_t v65 = v66 >> 2;
            }
            if ((unint64_t)v66 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v67 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v67 = v65;
            }
            if (v67)
            {
              if (v67 >> 61) {
LABEL_73:
              }
                std::__throw_bad_array_new_length[abi:nn180100]();
              unint64_t v68 = operator new(8 * v67);
            }
            else
            {
              unint64_t v68 = 0;
            }
            unint64_t v69 = (double *)&v68[8 * v64];
            *unint64_t v69 = v41;
            uint64_t v36 = v69 + 1;
            if (v61 != v62)
            {
              unint64_t v70 = (char *)(v61 - 1) - (char *)v62;
              if (v70 < 0x58) {
                goto LABEL_77;
              }
              if ((unint64_t)((char *)v61 - &v68[v63]) < 0x20) {
                goto LABEL_77;
              }
              uint64_t v71 = (v70 >> 3) + 1;
              unint64_t v72 = &v68[8 * v64 - 16];
              uint64_t v73 = v61 - 2;
              uint64_t v74 = v71 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v75 = *(_OWORD *)v73;
                *(v72 - 1) = *((_OWORD *)v73 - 1);
                _OWORD *v72 = v75;
                v72 -= 2;
                v73 -= 4;
                v74 -= 4;
              }
              while (v74);
              v69 -= v71 & 0x3FFFFFFFFFFFFFFCLL;
              v61 -= v71 & 0x3FFFFFFFFFFFFFFCLL;
              if (v71 != (v71 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_77:
                do
                {
                  uint64_t v76 = *((void *)v61-- - 1);
                  *((void *)v69-- - 1) = v76;
                }
                while (v61 != v62);
              }
            }
            a4 = v84;
            float64x2_t *v84 = v69;
            v84[1] = v36;
            void v84[2] = (double *)&v68[8 * v67];
            if (v62) {
              operator delete(v62);
            }
            uint64_t v8 = v83;
            BOOL v35 = v85;
          }
          a4[1] = v36;
LABEL_19:
          ++v33;
        }
        uint64_t v31 = v82 + 1;
        uint64_t v30 = v80;
      }
      while (v79 != v82 + 1);
      uint64_t v30 = v80 + 1;
    }
    while (v77 != v80 + 1);
  }
}

double md::ARArrivalExternalMeshLabelPart::debugString@<D0>(uint64_t a1@<X8>)
{
  uint64_t v3 = (char *)operator new(0x20uLL);
  *(void *)a1 = v3;
  *(_OWORD *)(a1 + 8) = xmmword_1A28FD1A0;
  strcpy(v3, "ARArrivalExternalMeshLabelPart");
  return *(double *)"nalMeshLabelPart";
}

uint64_t md::ARArrivalExternalMeshLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 576);
  if (!v3) {
    return 26;
  }
  *(void *)(v3 + 120) = *(void *)(a1 + 608);
  *(_DWORD *)(v3 + 168) = *(_DWORD *)(*(void *)(a1 + 16) + 1064);
  md::ARArrivalExternalMeshLabelPart::collisionInfoFromTransform((float32x2_t *)v3, a2 + 440, (long long *)(v3 + 32), (float *)(a1 + 632), (float *)(a1 + 616));
  uint64_t v4 = *(void *)(a1 + 576);
  *(_DWORD *)(a1 + 688) = *(_DWORD *)(v4 + 8);
  *(_DWORD *)(a1 + 692) = *(_DWORD *)(v4 + 12);
  *(_DWORD *)(a1 + 696) = *(_DWORD *)(v4 + 16);
  *(_DWORD *)(a1 + 700) = *(_DWORD *)(v4 + 20);
  *(_DWORD *)(a1 + 704) = *(_DWORD *)(v4 + 24);
  *(_DWORD *)(a1 + 708) = *(_DWORD *)(v4 + 28);
  double v5 = *(double *)(v4 + 64);
  double v6 = *(double *)(v4 + 72);
  double v7 = v5 + v5;
  double v8 = (v5 + v5) * v5;
  double v9 = (v6 + v6) * v6;
  uint64_t v11 = *(void *)(v4 + 48);
  double v10 = *(double *)(v4 + 56);
  double v12 = (v10 + v10) * v5;
  double v13 = *(double *)(v4 + 80);
  uint64_t v14 = *(void *)(v4 + 88);
  double v15 = (v6 + v6) * v13;
  double v16 = v6 * (v10 + v10);
  double v17 = 1.0 - (v10 + v10) * v10;
  double v18 = v7 * v6;
  v45[0] = 1.0 - (v8 + v9);
  v45[1] = v15 + v12;
  v45[4] = v12 - v15;
  v45[5] = v17 - v9;
  v45[8] = v13 * v7 + v16;
  v45[9] = v18 - v13 * (v10 + v10);
  v45[2] = v16 - v13 * v7;
  v45[6] = v13 * (v10 + v10) + v18;
  v45[10] = v17 - v8;
  v45[3] = 0.0;
  v45[7] = 0.0;
  v45[11] = 0.0;
  long long v46 = *(_OWORD *)(v4 + 32);
  uint64_t v47 = v11;
  uint64_t v48 = 0x3FF0000000000000;
  long long v39 = 0u;
  long long v41 = 0u;
  long long v43 = 0u;
  long long v42 = 0u;
  long long v40 = 0u;
  long long v38 = 0u;
  long long v37 = 0u;
  uint64_t v44 = 0x3FF0000000000000;
  uint64_t v19 = *(void *)(v4 + 96);
  uint64_t v20 = *(void *)(v4 + 104);
  uint64_t v36 = v14;
  *(void *)&long long v39 = v19;
  *((void *)&v41 + 1) = v20;
  gm::operator*<double,4,4,4>((double *)v35, v45, (double *)&v36);
  long long v21 = v35[1];
  *(_OWORD *)(a1 + 712) = v35[0];
  *(_OWORD *)(a1 + 728) = v21;
  long long v22 = v35[3];
  *(_OWORD *)(a1 + 744) = v35[2];
  *(_OWORD *)(a1 + 760) = v22;
  long long v23 = v35[5];
  *(_OWORD *)(a1 + 776) = v35[4];
  *(_OWORD *)(a1 + 792) = v23;
  long long v24 = v35[7];
  *(_OWORD *)(a1 + 808) = v35[6];
  *(_OWORD *)(a1 + 824) = v24;
  md::CollisionObject::resetWithRects((void **)(a1 + 312), 1u);
  uint64_t v25 = *(void *)(a1 + 472);
  uint64_t v26 = *(unsigned int *)(a1 + 488);
  *(_DWORD *)(a1 + 488) = v26 + 1;
  int v27 = (_DWORD *)(v25 + 16 * v26);
  *int v27 = *(_DWORD *)(a1 + 632);
  v27[1] = *(_DWORD *)(a1 + 636);
  v27[2] = *(_DWORD *)(a1 + 640);
  v27[3] = *(_DWORD *)(a1 + 644);
  int8x16_t v28 = *(int8x16_t *)(a1 + 632);
  v29.i64[0] = *(void *)(a1 + 632);
  v29.i64[1] = *(void *)(a1 + 320);
  v30.i64[0] = *(void *)(a1 + 312);
  v30.i64[1] = *(void *)(a1 + 640);
  int8x16_t v31 = (int8x16_t)vcgtq_f32(v30, v29);
  int8x16_t v32 = vbslq_s8(v31, v28, *(int8x16_t *)(a1 + 312));
  *(int8x16_t *)(a1 + 312) = v32;
  v32.i32[0] = *(_DWORD *)(a1 + 616);
  *(_DWORD *)(a1 + 520) = v32.i32[0];
  v28.i32[0] = *(_DWORD *)(a1 + 620);
  *(_DWORD *)(a1 + 524) = v28.i32[0];
  *(_DWORD *)(a1 + 344) = v32.i32[0];
  *(_DWORD *)(a1 + 348) = v28.i32[0];
  md::CollisionObject::setupShapeData(a1 + 312, *(double *)v32.i64, *(double *)v28.i64, *(double *)v31.i64);
  unint64_t v33 = (_OWORD *)(a1 + 440);
  if (*(unsigned char *)(a1 + 464))
  {
    _OWORD *v33 = *(_OWORD *)(a1 + 688);
    *(void *)(a1 + 456) = *(void *)(a1 + 704);
  }
  else
  {
    _OWORD *v33 = *(_OWORD *)(a1 + 688);
    *(void *)(a1 + 456) = *(void *)(a1 + 704);
    *(unsigned char *)(a1 + 464) = 1;
  }
  *(void *)(a1 + 424) = a1 + 712;
  return 37;
}

uint64_t md::ARArrivalExternalMeshLabelPart::collisionInfoFromTransform(float32x2_t *a1, uint64_t a2, long long *a3, float *a4, float *a5)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  float64x2_t v8 = vcvtq_f64_f32(a1[2]);
  v35[0] = vcvtq_f64_f32(a1[1]);
  v35[1] = v8;
  v35[2] = vcvtq_f64_f32(a1[3]);
  double v9 = *((double *)a3 + 4);
  v8.f64[0] = *((float64_t *)a3 + 5);
  double v10 = v9 + v9;
  double v11 = (v9 + v9) * v9;
  float64_t v12 = (v8.f64[0] + v8.f64[0]) * v8.f64[0];
  uint64_t v14 = *((void *)a3 + 2);
  double v13 = *((double *)a3 + 3);
  double v15 = (v13 + v13) * v9;
  double v16 = *((double *)a3 + 6);
  double v17 = (void (**)(void **, double))*((void *)a3 + 7);
  float64_t v18 = (v8.f64[0] + v8.f64[0]) * v16;
  float64_t v19 = v8.f64[0] * (v13 + v13);
  double v20 = 1.0 - (v13 + v13) * v13;
  v8.f64[0] = v10 * v8.f64[0];
  *(double *)v36.i64 = 1.0 - (v11 + v12);
  *(double *)&v36.i64[1] = v18 + v15;
  *(double *)v38.i64 = v15 - v18;
  *(double *)&v38.i64[1] = v20 - v12;
  double v41 = v16 * v10 + v19;
  double v42 = v8.f64[0] - v16 * (v13 + v13);
  long long v37 = COERCE_UNSIGNED_INT64(v19 - v16 * v10);
  double v39 = v16 * (v13 + v13) + v8.f64[0];
  double v43 = v20 - v11;
  uint64_t v40 = 0;
  uint64_t v44 = 0;
  long long v45 = *a3;
  uint64_t v46 = v14;
  uint64_t v47 = 0x3FF0000000000000;
  long long v51 = 0u;
  long long v53 = 0u;
  long long v55 = 0u;
  long long v54 = 0u;
  long long v52 = 0u;
  long long v50 = 0u;
  long long v49 = 0u;
  uint64_t v56 = 0x3FF0000000000000;
  uint64_t v21 = *((void *)a3 + 8);
  v8.f64[0] = *((float64_t *)a3 + 9);
  uint64_t v48 = v17;
  *(void *)&long long v51 = v21;
  *((void *)&v53 + 1) = *(void *)&v8.f64[0];
  gm::operator*<double,4,4,4>((double *)v34, (double *)v36.i64, (double *)&v48);
  int64x2_t v36 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  long long v37 = xmmword_1A28FC720;
  int64x2_t v38 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  uint64_t v48 = (void (**)(void **, double))&unk_1EF57D5A8;
  *(void *)&long long v49 = &v36;
  *((void *)&v49 + 1) = v34;
  *(void *)&long long v50 = &v48;
  double v22 = gm::Box<double,3>::forEachCorner((uint64_t)v35, (uint64_t)&v48);
  if ((void (***)(void **, double))v50 == &v48)
  {
    v48[4]((void **)&v48, v22);
  }
  else if ((void)v50)
  {
    (*(void (**)(void, double))(*(void *)v50 + 40))(v50, v22);
  }
  v34[0] = xmmword_1A28FC750;
  uint64_t v48 = (void (**)(void **, double))&unk_1EF57DD40;
  *(void *)&long long v49 = a2;
  *((void *)&v49 + 1) = v34;
  *(void *)&long long v50 = &v48;
  double v23 = gm::Box<double,3>::forEachCorner((uint64_t)&v36, (uint64_t)&v48);
  uint64_t result = v50;
  if ((void (***)(void **, double))v50 == &v48)
  {
    uint64_t result = ((uint64_t (*)(void **, double))v48[4])((void **)&v48, v23);
  }
  else if ((void)v50)
  {
    uint64_t result = (*(uint64_t (**)(void, double))(*(void *)v50 + 40))(v50, v23);
  }
  long long v25 = v34[0];
  float v26 = (float)(*((float *)v34 + 2) - *(float *)v34) * 0.5;
  float v27 = (float)(*((float *)v34 + 3) - *((float *)v34 + 1)) * 0.5;
  float v28 = v26 + *(float *)v34;
  float v29 = v27 + *((float *)v34 + 1);
  *a5 = v26 + *(float *)v34;
  a5[1] = v29;
  float v30 = 3.4028e38;
  float v31 = -3.4028e38;
  if (*((float *)&v25 + 2) < *(float *)&v25)
  {
    float v32 = -3.4028e38;
    float v33 = 3.4028e38;
  }
  else
  {
    float v32 = -3.4028e38;
    float v33 = 3.4028e38;
    if (*((float *)&v25 + 3) >= *((float *)&v25 + 1))
    {
      float v33 = -v26;
      float v30 = -v27;
      float v32 = *((float *)&v25 + 2) - v28;
      float v31 = *((float *)&v25 + 3) - v29;
    }
  }
  *a4 = v33;
  a4[1] = v30;
  a4[2] = v32;
  a4[3] = v31;
  return result;
}

double md::ARArrivalExternalMeshLabelPart::updateForDisplay(md::ARArrivalExternalMeshLabelPart *this)
{
  *((void *)this + 78) = *((void *)this + 77);
  long long v1 = *((_OWORD *)this + 43);
  *(_OWORD *)((char *)this + 648) = *(_OWORD *)((char *)this + 632);
  *(_OWORD *)((char *)this + 664) = v1;
  *((void *)this + 85) = *((void *)this + 88);
  *((void *)this + 105) = *((void *)this + 89);
  long long v2 = *((_OWORD *)this + 46);
  *((_OWORD *)this + 53) = *((_OWORD *)this + 45);
  *((_OWORD *)this + 54) = v2;
  long long v3 = *((_OWORD *)this + 48);
  *((_OWORD *)this + 55) = *((_OWORD *)this + 47);
  *((_OWORD *)this + 56) = v3;
  long long v4 = *((_OWORD *)this + 50);
  *((_OWORD *)this + 57) = *((_OWORD *)this + 49);
  *((_OWORD *)this + 58) = v4;
  *((_OWORD *)this + 59) = *((_OWORD *)this + 51);
  *((void *)this + 120) = *((void *)this + 104);
  double result = *(float *)(*((void *)this + 2) + 768);
  *((double *)this + 76) = result;
  return result;
}

uint64_t md::ARArrivalExternalMeshLabelPart::layoutForStaging(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = md::ExternalMeshLabelPart::layoutForStaging((void *)a1);
  if (v4 == 37)
  {
    if (*(float *)(a1 + 656) < *(float *)(a1 + 648) || *(float *)(a1 + 660) < *(float *)(a1 + 652)) {
      md::ARArrivalExternalMeshLabelPart::collisionInfoFromTransform(*(float32x2_t **)(a1 + 576), *(void *)(a2 + 432), (long long *)(*(void *)(a1 + 592) + 16), (float *)(a1 + 648), (float *)(a1 + 624));
    }
    md::CollisionObject::resetWithRects((void **)(a1 + 72), 1u);
    uint64_t v5 = *(void *)(a1 + 232);
    uint64_t v6 = *(unsigned int *)(a1 + 248);
    *(_DWORD *)(a1 + 248) = v6 + 1;
    double v7 = (_DWORD *)(v5 + 16 * v6);
    *double v7 = *(_DWORD *)(a1 + 648);
    v7[1] = *(_DWORD *)(a1 + 652);
    void v7[2] = *(_DWORD *)(a1 + 656);
    void v7[3] = *(_DWORD *)(a1 + 660);
    float64x2_t v8 = (_OWORD *)(a1 + 664);
    HIDWORD(v9) = HIDWORD(*(void *)(a1 + 648));
    v10.i64[0] = *(void *)(a1 + 648);
    v10.i64[1] = *(void *)(a1 + 80);
    v11.i64[0] = *(void *)(a1 + 72);
    v11.i64[1] = *(void *)(a1 + 656);
    int8x16_t v12 = (int8x16_t)vcgtq_f32(v11, v10);
    int8x16_t v13 = vbslq_s8(v12, *(int8x16_t *)(a1 + 648), *(int8x16_t *)(a1 + 72));
    *(int8x16_t *)(a1 + 72) = v13;
    v13.i32[0] = *(_DWORD *)(a1 + 624);
    *(_DWORD *)(a1 + 280) = v13.i32[0];
    LODWORD(v9) = *(_DWORD *)(a1 + 628);
    *(_DWORD *)(a1 + 284) = LODWORD(v9);
    *(_DWORD *)(a1 + 104) = v13.i32[0];
    *(_DWORD *)(a1 + 108) = LODWORD(v9);
    md::CollisionObject::setupShapeData(a1 + 72, *(double *)v13.i64, v9, *(double *)v12.i64);
    if (*(unsigned char *)(a1 + 224))
    {
      *(_OWORD *)(a1 + 200) = *v8;
      *(void *)(a1 + 216) = *(void *)(a1 + 680);
    }
    else
    {
      *(_OWORD *)(a1 + 200) = *v8;
      *(void *)(a1 + 216) = *(void *)(a1 + 680);
      *(unsigned char *)(a1 + 224) = 1;
    }
    *(void *)(a1 + 184) = a1 + 840;
  }
  return v4;
}

void md::ARArrivalExternalMeshLabelPart::~ARArrivalExternalMeshLabelPart(md::ARArrivalExternalMeshLabelPart *this)
{
  md::ExternalMeshLabelPart::~ExternalMeshLabelPart(this);
  long long v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    long long v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  long long v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

void sub_1A2132348(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  int v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>,geo::StdAllocator<ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>,ggl::Allocator>>::__on_zero_shared_weak(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), a1, 256);
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>,geo::StdAllocator<ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>,ggl::Allocator>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 32))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>,geo::StdAllocator<ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E3A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>,geo::StdAllocator<ggl::VertexDataTyped<ggl::FlyoverCommon::PolarVertex>,ggl::Allocator>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E3A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::FlyoverCommon::PolarMesh::~PolarMesh(ggl::FlyoverCommon::PolarMesh *this)
{
  ggl::Mesh::~Mesh((ggl::FlyoverCommon::PolarMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::FlyoverCommon::PolarMesh *)((char *)this - 16));
}

void ggl::FlyoverCommon::PolarMesh::~PolarMesh(ggl::FlyoverCommon::PolarMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::FlyoverCommon::PolarVertex>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::FlyoverCommon::PolarVertex>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void md::NavContext::worldPoint(md::NavContext *this, const md::LabelPoint *a2)
{
  if ((_BYTE)this)
  {
    md::LabelPoint::mercatorPoint(a2);
  }
  else
  {
    if (!*((unsigned char *)a2 + 44))
    {
      long double v3 = *((double *)a2 + 3) * 6.28318531;
      long double v4 = exp(*((double *)a2 + 4) * 6.28318531 + -3.14159265);
      double v5 = atan(v4) * 2.0 + -1.57079633;
      long double v6 = fmod(v3, 6.28318531);
      double v7 = fmod(v6 + 6.28318531, 6.28318531) + -3.14159265;
      __double2 v8 = __sincos_stret(v5);
      double v9 = 6378137.0 / sqrt(v8.__sinval * v8.__sinval * -0.00669437999 + 1.0);
      __double2 v10 = __sincos_stret(v7);
      *(double *)a2 = v9 * v8.__cosval * v10.__cosval;
      *((double *)a2 + 1) = v9 * v8.__cosval * v10.__sinval;
      *((double *)a2 + 2) = v8.__sinval * 0.99330562 * v9;
      *((unsigned char *)a2 + 44) = 1;
    }
    md::LabelPoint::geocentricNormal(a2);
  }
}

uint64_t md::LineLabelFeature::debugString@<X0>(md::LineLabelFeature *a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, unsigned int a4@<W3>, void *a5@<X8>)
{
  double v9 = a5;
  {
    unsigned int v16 = a4;
    uint64_t v14 = a2;
    double v15 = a3;
    int8x16_t v13 = a1;
    a1 = v13;
    a2 = v14;
    a3 = v15;
    a4 = v16;
    int v12 = v11;
    double v9 = a5;
    if (v12) {
      operator new();
    }
  }
  uint64_t v20 = mdm::Allocator::instance(void)::alloc;
  HIBYTE(v19) = 4;
  strcpy(v18, "Road");
  uint64_t result = md::LineLabelFeature::debugRoadString(v9, a1, a2, a3, a4, (uint64_t)v18);
  if (SHIBYTE(v19) < 0) {
    return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v20 + 40))(v20, *(void *)v18, v19 & 0x7FFFFFFFFFFFFFFFLL);
  }
  return result;
}

void sub_1A2132B08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (SHIBYTE(a17) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a18 + 40))(a18, a15, a17 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::LineLabelFeature::debugRoadString(void *a1, md::LineLabelFeature *a2, uint64_t a3, unsigned int *a4, unsigned int a5, uint64_t a6)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v288);
  float v11 = *(float *)(a3 + 472);
  uint64_t v280 = a4;
  LODWORD(v308[0].__r_.__value_.__l.__data_) = *a4;
  HIDWORD(v308[0].__r_.__value_.__r.__words[1]) = -1;
  *(std::string::size_type *)((char *)v308[0].__r_.__value_.__r.__words + 4) = -1;
  v308[0].__r_.__value_.__r.__words[2] = 0;
  float64x2_t v283 = a2;
  uint64_t v277 = a3;
  unsigned int v279 = a5;
  md::LabelFeature::debugString(a2, a3, (unsigned int *)v308, a5, __p);
  if (SHIBYTE(__p[2]) >= 0) {
    int v12 = __p;
  }
  else {
    int v12 = (void **)__p[0];
  }
  if (SHIBYTE(__p[2]) >= 0) {
    uint64_t v13 = HIBYTE(__p[2]);
  }
  else {
    uint64_t v13 = (uint64_t)__p[1];
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)v12, v13);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"  Style MinVisibleZoom=", 23);
  uint64_t v14 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"  ", 2);
  int v15 = *(char *)(a6 + 23);
  if (v15 >= 0) {
    uint64_t v16 = a6;
  }
  else {
    uint64_t v16 = *(void *)a6;
  }
  if (v15 >= 0) {
    uint64_t v17 = *(unsigned __int8 *)(a6 + 23);
  }
  else {
    uint64_t v17 = *(void *)(a6 + 8);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, v16, v17);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)":\n", 2);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"    layoutZ=", 12);
  int __e = (int)v11;
  float64_t v18 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)" pathZ=", 7);
  uint64_t v19 = *((void *)a2 + 24);
  if ((int)v11 >= 0x17) {
    uint64_t v20 = 23;
  }
  else {
    uint64_t v20 = (int)v11;
  }
  int v21 = atomic_load((unsigned __int8 *)(v19 + 224 + v20));
  if (v21 == 254)
  {
    if (*(unsigned char *)(v19 + 289)) {
      unsigned int v22 = 24;
    }
    else {
      unsigned int v22 = 5;
    }
    double v23 = *(unsigned __int8 **)(v19 + 128);
    uint64_t v24 = *(void *)(v19 + 136) - (void)v23;
    if (v24)
    {
      uint64_t v25 = 0;
      unint64_t v26 = v24 / 112;
      if (v26 <= 1) {
        uint64_t v27 = 1;
      }
      else {
        uint64_t v27 = v26;
      }
      unsigned __int8 v28 = -1;
      float v29 = 1000.0;
      while (1)
      {
        int v31 = *v23;
        v23 += 112;
        int v30 = v31;
        if (v20 == v31) {
          break;
        }
        int v32 = v20 - v30;
        if (v32 >= 0) {
          unsigned int v33 = v32;
        }
        else {
          unsigned int v33 = -v32;
        }
        if (v33 <= v22)
        {
          float v34 = (float)v32;
          if (v32 < 0) {
            float v34 = (float)v32 * -0.8;
          }
          if (v34 < v29) {
            unsigned __int8 v28 = v25;
          }
          float v29 = fminf(v34, v29);
        }
        if (v27 == ++v25) {
          goto LABEL_41;
        }
      }
      unsigned __int8 v28 = v25;
    }
    else
    {
      unsigned __int8 v28 = -1;
    }
LABEL_41:
    atomic_store(v28, (unsigned __int8 *)(v19 + 224 + v20));
  }
  BOOL v35 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)"\n", 1);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)" travelDir=", 11);
  uint64_t v36 = *((void *)a2 + 24);
  unsigned int v37 = atomic_load((unsigned __int8 *)(v36 + 224 + v20));
  if (v37 == 254)
  {
    if (*(unsigned char *)(v36 + 289)) {
      unsigned int v38 = 24;
    }
    else {
      unsigned int v38 = 5;
    }
    double v39 = *(unsigned __int8 **)(v36 + 128);
    uint64_t v40 = *(void *)(v36 + 136) - (void)v39;
    if (v40)
    {
      uint64_t v41 = 0;
      unint64_t v42 = v40 / 112;
      if (v42 <= 1) {
        uint64_t v43 = 1;
      }
      else {
        uint64_t v43 = v42;
      }
      unsigned int v37 = -1;
      float v44 = 1000.0;
      while (1)
      {
        int v46 = *v39;
        v39 += 112;
        int v45 = v46;
        if (v20 == v46) {
          break;
        }
        int v47 = v20 - v45;
        if (v47 >= 0) {
          unsigned int v48 = v47;
        }
        else {
          unsigned int v48 = -v47;
        }
        if (v48 <= v38)
        {
          float v49 = (float)v47;
          if (v47 < 0) {
            float v49 = (float)v47 * -0.8;
          }
          if (v49 < v44) {
            unsigned int v37 = v41;
          }
          float v44 = fminf(v49, v44);
        }
        if (v43 == ++v41) {
          goto LABEL_66;
        }
      }
      unsigned int v37 = v41;
    }
    else
    {
      unsigned int v37 = -1;
    }
LABEL_66:
    atomic_store(v37, (unsigned __int8 *)(v36 + 224 + v20));
    if ((v37 & 0x80000000) != 0) {
      goto LABEL_124;
    }
  }
  else
  {
    unsigned int v37 = (char)v37;
    if ((char)v37 < 0) {
      goto LABEL_124;
    }
  }
  uint64_t v50 = *(void *)(v36 + 128);
  if (!v50 || (uint64_t v51 = *(void *)(v50 + 112 * v37 + 88) - *(void *)(v50 + 112 * v37 + 80)) == 0)
  {
LABEL_124:
    uint64_t v77 = 7;
    *((unsigned char *)&v308[0].__r_.__value_.__s + 23) = 7;
    LODWORD(v308[0].__r_.__value_.__l.__data_) = 1635151433;
    int v78 = 1684630625;
LABEL_125:
    *(_DWORD *)((char *)v308[0].__r_.__value_.__r.__words + 3) = v78;
    v308[0].__r_.__value_.__s.__data_[7] = 0;
    goto LABEL_126;
  }
  unint64_t v52 = 0;
  uint64_t v53 = v51 >> 3;
  int v54 = 4;
  do
  {
    v55.n128_f64[0] = md::LabelLineStore::lineStartForZoom((md::LabelLineStore *)__p, (unsigned __int8 *)v36, __e, v52);
LABEL_73:
    uint64_t v56 = __p[0];
    while (__p[0])
    {
      int v57 = (int)__p[5];
      if (LODWORD(__p[5]) != v56[63]) {
        break;
      }
      long long v58 = (uint64_t *)__p[3];
      if (!__p[3]) {
        break;
      }
      unsigned __int16 v59 = WORD1(__p[4]);
      if (SWORD1(__p[4]) < 0
        || (*(uint64_t (**)(__n128))(**(void **)__p[3] + 16))(v55) <= (unint64_t)v59)
      {
        break;
      }
      int v60 = *((unsigned __int8 *)v56 + 120);
      if (v54 == 4)
      {
        if (v60 == 7)
        {
          if (v57 == v56[63])
          {
            uint64_t v67 = *v58;
            if (*v58)
            {
              if (*(unsigned char *)(v67 + 32) == 1)
              {
                unint64_t v68 = *(uint64_t **)(v67 + 24);
                if (v68)
                {
                  uint64_t v69 = *v68;
                  if (v69)
                  {
                    int v54 = *(unsigned __int8 *)(v69 + 304);
                    goto LABEL_113;
                  }
                }
              }
            }
          }
LABEL_104:
          int v54 = 4;
          goto LABEL_113;
        }
        if (*((unsigned char *)v56 + 120)) {
          goto LABEL_104;
        }
        if (v57 != v56[63]) {
          goto LABEL_104;
        }
        uint64_t v61 = *v58;
        if (!*v58) {
          goto LABEL_104;
        }
        if (*(unsigned char *)(v61 + 32)) {
          goto LABEL_104;
        }
        uint64_t v62 = *(void *)(v61 + 16);
        if (!v62) {
          goto LABEL_104;
        }
        unsigned int v63 = *(unsigned __int8 *)(v62 + 153);
        if (v63 >= 3) {
          int v54 = 4;
        }
        else {
          int v54 = v63;
        }
      }
      else if (v60 == 7)
      {
        if (v57 != v56[63]) {
          goto LABEL_120;
        }
        uint64_t v70 = *v58;
        if (!*v58) {
          goto LABEL_120;
        }
        if (*(unsigned char *)(v70 + 32) != 1) {
          goto LABEL_120;
        }
        uint64_t v71 = *(uint64_t **)(v70 + 24);
        if (!v71) {
          goto LABEL_120;
        }
        uint64_t v72 = *v71;
        if (!v72 || *(unsigned __int8 *)(v72 + 304) != v54) {
          goto LABEL_120;
        }
      }
      else
      {
        if (*((unsigned char *)v56 + 120)) {
          goto LABEL_120;
        }
        if (v57 != v56[63]) {
          goto LABEL_120;
        }
        uint64_t v64 = *v58;
        if (!*v58) {
          goto LABEL_120;
        }
        if (*(unsigned char *)(v64 + 32)) {
          goto LABEL_120;
        }
        uint64_t v65 = *(void *)(v64 + 16);
        if (!v65) {
          goto LABEL_120;
        }
        unsigned int v66 = *(unsigned __int8 *)(v65 + 153);
        if (v66 >= 3) {
          unsigned int v66 = 4;
        }
        if (v66 != v54)
        {
LABEL_120:
          int v54 = 3;
          uint64_t v76 = (std::__shared_weak_count *)__p[1];
          if (__p[1]) {
            goto LABEL_118;
          }
          goto LABEL_70;
        }
      }
LABEL_113:
      if (!md::LabelLinePosition::getPointCoordinateAtOffset((uint64_t)__p, 1, (uint64_t)&__p[4]))
      {
        __p[3] = 0;
        goto LABEL_73;
      }
      uint64_t v73 = *((void *)__p[2] + 1);
      uint64_t v74 = *((void *)__p[2] + 2) - v73;
      long long v75 = (void *)(v73 + 16 * SLOWORD(__p[4]));
      if (SLOWORD(__p[4]) >= (unint64_t)(v74 >> 4)) {
        long long v75 = 0;
      }
      __p[3] = v75;
      uint64_t v56 = __p[0];
    }
    uint64_t v76 = (std::__shared_weak_count *)__p[1];
    if (__p[1])
    {
LABEL_118:
      if (!atomic_fetch_add(&v76->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, __n128))v76->__on_zero_shared)(v76, v55);
        std::__shared_weak_count::__release_weak(v76);
      }
    }
LABEL_70:
    ++v52;
  }
  while (v52 != v53);
  switch(v54)
  {
    case 1:
      uint64_t v77 = 11;
      *((unsigned char *)&v308[0].__r_.__value_.__s + 23) = 11;
      *(_DWORD *)((char *)v308[0].__r_.__value_.__r.__words + 7) = 1936683040;
      double v265 = "One way pos";
      goto LABEL_395;
    case 2:
      uint64_t v77 = 11;
      *((unsigned char *)&v308[0].__r_.__value_.__s + 23) = 11;
      *(_DWORD *)((char *)v308[0].__r_.__value_.__r.__words + 7) = 1734700576;
      double v265 = "One way neg";
LABEL_395:
      v308[0].__r_.__value_.__r.__words[0] = *(void *)v265;
      v308[0].__r_.__value_.__s.__data_[11] = 0;
      break;
    case 3:
      uint64_t v77 = 8;
      *((unsigned char *)&v308[0].__r_.__value_.__s + 23) = 8;
      strcpy((char *)v308, "Multiple");
      break;
    case 4:
      goto LABEL_124;
    default:
      uint64_t v77 = 7;
      *((unsigned char *)&v308[0].__r_.__value_.__s + 23) = 7;
      LODWORD(v308[0].__r_.__value_.__l.__data_) = 544175956;
      int v78 = 2036430624;
      goto LABEL_125;
  }
LABEL_126:
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)v308, v77);
  if (SHIBYTE(v308[0].__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v308[0].__r_.__value_.__l.__data_);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"\n", 1);
  unsigned int v79 = *v280;
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)__p);
  int v80 = (int)*(float *)(v277 + 472);
  uint64_t v81 = (char *)*((void *)v283 + 28);
  uint64_t v82 = (char *)v283 + 232;
  if (v81 != (char *)v283 + 232)
  {
    uint64_t v83 = 0;
    do
    {
      uint64_t v84 = (char *)*((void *)v81 + 1);
      BOOL v85 = v81;
      if (v84)
      {
        do
        {
          uint64_t v86 = v84;
          uint64_t v84 = *(char **)v84;
        }
        while (v84);
      }
      else
      {
        do
        {
          uint64_t v86 = (char *)*((void *)v85 + 2);
          BOOL v163 = *(void *)v86 == (void)v85;
          BOOL v85 = v86;
        }
        while (!v163);
      }
      v83 += ((unint64_t)*(unsigned int *)(*((void *)v81 + 5) + 16) >> v80) & 1;
      uint64_t v81 = v86;
    }
    while (v86 != v82);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"    Placements:count=", 21);
  long double v87 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v87, (uint64_t)" zCount=", 8);
  std::ostream::operator<<();
  if (((unint64_t)*((unsigned int *)v283 + 53) >> v80)) {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)" [PositionsLimited]", 19);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"\n", 1);
  if (v279)
  {
    if (!*((void *)v283 + 31)) {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"No Line Placements\n", 19);
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"Placements:\n", 12);
    uint64_t v88 = (char *)*((void *)v283 + 28);
    if (v88 != v82)
    {
      do
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"    [", 5);
        unsigned int v89 = *((_DWORD *)v88 + 8);
        if (v89)
        {
          std::to_string(v308, v89);
          uint64_t v90 = HIBYTE(v308[0].__r_.__value_.__r.__words[2]);
        }
        else
        {
          *((unsigned char *)&v308[0].__r_.__value_.__s + 23) = 7;
          strcpy((char *)v308, "UNKNOWN");
          uint64_t v90 = 7;
        }
        if ((v90 & 0x80u) == 0) {
          float v91 = v308;
        }
        else {
          float v91 = (std::string *)v308[0].__r_.__value_.__r.__words[0];
        }
        if ((v90 & 0x80u) == 0) {
          std::string::size_type size = v90;
        }
        else {
          std::string::size_type size = v308[0].__r_.__value_.__l.__size_;
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v91, size);
        (*(void (**)(std::string *__return_ptr))(**((void **)v88 + 5) + 216))(&v297);
        uint64_t v93 = std::string::insert(&v297, 0, "]: ", 3uLL);
        long long v94 = *(_OWORD *)&v93->__r_.__value_.__l.__data_;
        int64_t v299 = v93->__r_.__value_.__r.__words[2];
        long long v298 = v94;
        v93->__r_.__value_.__l.__size_ = 0;
        v93->__r_.__value_.__r.__words[2] = 0;
        v93->__r_.__value_.__r.__words[0] = 0;
        if (v299 >= 0) {
          float32x2_t v95 = &v298;
        }
        else {
          float32x2_t v95 = (long long *)v298;
        }
        if (v299 >= 0) {
          uint64_t v96 = HIBYTE(v299);
        }
        else {
          uint64_t v96 = *((void *)&v298 + 1);
        }
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v95, v96);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"\n", 1);
        if (SHIBYTE(v299) < 0)
        {
          operator delete((void *)v298);
          if ((SHIBYTE(v297.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
          {
LABEL_162:
            if ((SHIBYTE(v308[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_163;
            }
            goto LABEL_167;
          }
        }
        else if ((SHIBYTE(v297.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
          goto LABEL_162;
        }
        operator delete(v297.__r_.__value_.__l.__data_);
        if ((SHIBYTE(v308[0].__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
        {
LABEL_163:
          uint64_t v97 = (char *)*((void *)v88 + 1);
          if (v97) {
            goto LABEL_168;
          }
          goto LABEL_170;
        }
LABEL_167:
        operator delete(v308[0].__r_.__value_.__l.__data_);
        uint64_t v97 = (char *)*((void *)v88 + 1);
        if (v97)
        {
          do
          {
LABEL_168:
            long long v98 = v97;
            uint64_t v97 = *(char **)v97;
          }
          while (v97);
          goto LABEL_144;
        }
        do
        {
LABEL_170:
          long long v98 = (char *)*((void *)v88 + 2);
          BOOL v163 = *(void *)v98 == (void)v88;
          uint64_t v88 = v98;
        }
        while (!v163);
LABEL_144:
        uint64_t v88 = v98;
      }
      while (v98 != v82);
    }
  }
  uint64_t v99 = *(char **)v82;
  if (!*(void *)v82) {
    goto LABEL_184;
  }
  uint64_t v100 = (char *)v283 + 232;
  do
  {
    unsigned int v101 = *((_DWORD *)v99 + 8);
    BOOL v102 = v101 >= v79;
    if (v101 >= v79) {
      uint64_t v103 = (char **)v99;
    }
    else {
      uint64_t v103 = (char **)(v99 + 8);
    }
    if (v102) {
      uint64_t v100 = v99;
    }
    uint64_t v99 = *v103;
  }
  while (*v103);
  if (v100 != v82 && v79 >= *((_DWORD *)v100 + 8))
  {
    uint64_t v146 = *((void *)v100 + 5);
    uint64_t v145 = *((void *)v100 + 6);
    *(void *)&long long v298 = v146;
    *((void *)&v298 + 1) = v145;
    if (v145) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v145 + 8), 1uLL, memory_order_relaxed);
    }
    if (v146)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"Placement:", 10);
      if (v79)
      {
        std::to_string(v308, v79);
        unsigned int v147 = HIBYTE(v308[0].__r_.__value_.__r.__words[2]);
      }
      else
      {
        unsigned int v147 = 7;
        *((unsigned char *)&v308[0].__r_.__value_.__s + 23) = 7;
        strcpy((char *)v308, "UNKNOWN");
      }
      if ((v147 & 0x80u) == 0) {
        uint64_t v266 = v308;
      }
      else {
        uint64_t v266 = (std::string *)v308[0].__r_.__value_.__r.__words[0];
      }
      if ((v147 & 0x80u) == 0) {
        std::string::size_type v267 = v147;
      }
      else {
        std::string::size_type v267 = v308[0].__r_.__value_.__l.__size_;
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v266, v267);
      if (SHIBYTE(v308[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v308[0].__r_.__value_.__l.__data_);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)":\n    ", 6);
      (*(void (**)(std::string *__return_ptr, uint64_t, void))(*(void *)v146 + 216))(v308, v146, v279);
      if ((v308[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v268 = v308;
      }
      else {
        uint64_t v268 = (std::string *)v308[0].__r_.__value_.__r.__words[0];
      }
      if ((v308[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        std::string::size_type v269 = HIBYTE(v308[0].__r_.__value_.__r.__words[2]);
      }
      else {
        std::string::size_type v269 = v308[0].__r_.__value_.__l.__size_;
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)v268, v269);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(__p, (uint64_t)"\n", 1);
      if (SHIBYTE(v308[0].__r_.__value_.__r.__words[2]) < 0) {
        operator delete(v308[0].__r_.__value_.__l.__data_);
      }
    }
  }
  else
  {
LABEL_184:
    long long v298 = 0uLL;
  }
  if ((v306 & 0x10) != 0)
  {
    uint64_t v106 = v305;
    if (v305 < v302)
    {
      long long v305 = v302;
      uint64_t v106 = v302;
    }
    uint64_t v107 = (const void **)&v301;
  }
  else
  {
    if ((v306 & 8) == 0)
    {
      size_t v104 = 0;
      HIBYTE(v287) = 0;
      p_dst = (void **)&__dst;
      goto LABEL_200;
    }
    uint64_t v107 = (const void **)&__p[3];
    uint64_t v106 = __p[5];
  }
  uint64_t v108 = *v107;
  size_t v104 = v106 - (unsigned char *)*v107;
  if (v104 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v104 >= 0x17)
  {
    uint64_t v109 = (v104 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v104 | 7) != 0x17) {
      uint64_t v109 = v104 | 7;
    }
    uint64_t v110 = v109 + 1;
    p_dst = (void **)operator new(v109 + 1);
    size_t v286 = v104;
    int64_t v287 = v110 | 0x8000000000000000;
    std::string __dst = p_dst;
  }
  else
  {
    HIBYTE(v287) = (_BYTE)v106 - *(unsigned char *)v107;
    p_dst = (void **)&__dst;
    if (!v104) {
      goto LABEL_200;
    }
  }
  memmove(p_dst, v108, v104);
LABEL_200:
  *((unsigned char *)p_dst + v104) = 0;
  int8x8_t v111 = (std::__shared_weak_count *)*((void *)&v298 + 1);
  if (*((void *)&v298 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v298 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
    std::__shared_weak_count::__release_weak(v111);
  }
  uint64_t v112 = *MEMORY[0x1E4FBA418];
  __p[0] = *(void **)MEMORY[0x1E4FBA418];
  uint64_t v113 = *(void **)(MEMORY[0x1E4FBA418] + 24);
  *(void **)((char *)__p + *((void *)__p[0] - 3)) = v113;
  __p[1] = (void *)(MEMORY[0x1E4FBA470] + 16);
  if (v304 < 0) {
    operator delete(v303);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1A62391A0](&v307);
  if (v287 >= 0) {
    unint64_t v114 = (void **)&__dst;
  }
  else {
    unint64_t v114 = __dst;
  }
  if (v287 >= 0) {
    uint64_t v115 = HIBYTE(v287);
  }
  else {
    uint64_t v115 = v286;
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)v114, v115);
  if (SHIBYTE(v287) < 0) {
    operator delete(__dst);
  }
  if (md::LineLabelFeature::roadMetricsForZ(v283, __e, *(const md::LabelLayoutContext **)(v277 + 432)))
  {
    ldexp(1.0, __e);
    uint64_t v116 = v288[0];
    *(_DWORD *)((char *)&v288[1] + *(void *)(v288[0] - 24)) = *(_DWORD *)((unsigned char *)&v288[1]
                                                                            + *(void *)(v288[0] - 24)) & 0xFFFFFEFB | 4;
    *(void *)((char *)&v288[2] + *(void *)(v116 - 24)) = 0;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"   ", 3);
    if (((*(uint64_t (**)(md::LineLabelFeature *))(*(void *)v283 + 336))(v283) & 1) == 0)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)" vis=", 5);
      std::ostream::operator<<();
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)" spacing(vis,rnk)=pts:", 22);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"text(", 5);
    uint64_t v117 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v117, (uint64_t)",", 1);
    long long v118 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v118, (uint64_t)")=", 2);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)" shield(", 8);
    unint64_t v119 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v119, (uint64_t)",", 1);
    uint64_t v120 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v120, (uint64_t)")=", 2);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)" arrow(", 7);
    uint64_t v121 = (void *)std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v121, (uint64_t)")=", 2);
    std::ostream::operator<<();
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"\n", 1);
  }
  if (*((void *)v283 + 45) != *((void *)v283 + 44))
  {
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"    Shields:", 12);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"cnt=", 4);
    std::ostream::operator<<();
    uint64_t v122 = (long long *)*((void *)v283 + 44);
    for (uint64_t i = (long long *)*((void *)v283 + 45); v122 != i; v122 += 3)
    {
      __p[3] = *((void **)v122 + 3);
      if (*((char *)v122 + 23) < 0)
      {
        std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)__p, *(void **)v122, *((void *)v122 + 1));
      }
      else
      {
        long long v124 = *v122;
        __p[2] = *((void **)v122 + 2);
        *(_OWORD *)std::string __p = v124;
      }
      __p[4] = *((void **)v122 + 4);
      LODWORD(__p[5]) = *((_DWORD *)v122 + 10);
      BYTE4(__p[5]) = *((unsigned char *)v122 + 44);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)" ", 1);
      if (SHIBYTE(__p[2]) >= 0) {
        uint64_t v125 = __p;
      }
      else {
        uint64_t v125 = (void **)__p[0];
      }
      if (SHIBYTE(__p[2]) >= 0) {
        uint64_t v126 = HIBYTE(__p[2]);
      }
      else {
        uint64_t v126 = (uint64_t)__p[1];
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)v125, v126);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"(", 1);
      uint64_t v127 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v127, (uint64_t)")", 1);
      if (SHIBYTE(__p[2]) < 0) {
        (*(void (**)(void *, void *, unint64_t))(*(void *)__p[3] + 40))(__p[3], __p[0], (unint64_t)__p[2] & 0x7FFFFFFFFFFFFFFFLL);
      }
    }
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)"\n", 1);
  }
  uint64_t v128 = *((void *)v283 + 24);
  uint64_t v129 = (void *)[objc_alloc(MEMORY[0x1E4F28E78]) initWithString:@"SSLPM:\n"];
  uint64_t v130 = v129;
  LODWORD(v131) = (int)*(float *)(v277 + 472);
  if (v131 >= 0x17) {
    uint64_t v131 = 23;
  }
  else {
    uint64_t v131 = v131;
  }
  unsigned int v132 = atomic_load((unsigned __int8 *)(v128 + 224 + v131));
  uint64_t v271 = v112;
  long long v272 = v113;
  uint64_t v274 = v128;
  if (v132 == 254)
  {
    if (*(unsigned char *)(v128 + 289)) {
      unsigned int v133 = 24;
    }
    else {
      unsigned int v133 = 5;
    }
    uint64_t v134 = *(unsigned __int8 **)(v128 + 128);
    uint64_t v135 = *(void *)(v128 + 136) - (void)v134;
    if (v135)
    {
      uint64_t v136 = 0;
      unint64_t v137 = v135 / 112;
      if (v137 <= 1) {
        uint64_t v138 = 1;
      }
      else {
        uint64_t v138 = v137;
      }
      unsigned int v132 = -1;
      float v139 = 1000.0;
      while (1)
      {
        int v141 = *v134;
        v134 += 112;
        int v140 = v141;
        if (v131 == v141) {
          break;
        }
        int v142 = v131 - v140;
        if (v142 >= 0) {
          unsigned int v143 = v142;
        }
        else {
          unsigned int v143 = -v142;
        }
        if (v143 <= v133)
        {
          float v144 = (float)v142;
          if (v142 < 0) {
            float v144 = (float)v142 * -0.8;
          }
          if (v144 < v139) {
            unsigned int v132 = v136;
          }
          float v139 = fminf(v144, v139);
        }
        if (v138 == ++v136) {
          goto LABEL_265;
        }
      }
      unsigned int v132 = v136;
    }
    else
    {
      unsigned int v132 = -1;
    }
LABEL_265:
    atomic_store(v132, (unsigned __int8 *)(v128 + 224 + v131));
    if ((v132 & 0x80000000) != 0) {
      goto LABEL_358;
    }
  }
  else
  {
    unsigned int v132 = (char)v132;
    if ((char)v132 < 0) {
      goto LABEL_358;
    }
  }
  uint64_t v148 = *(void *)(v128 + 128) + 112 * v132;
  uint64_t v150 = *(void *)(v148 + 80);
  uint64_t v149 = (uint64_t *)(v148 + 80);
  long long v151 = v149 + 1;
  objc_msgSend(v129, "appendFormat:", @" LabelLineCount=%i\n", (unint64_t)(v149[1] - v150) >> 3);
  if (v279) {
    unint64_t v152 = 100;
  }
  else {
    unint64_t v152 = 4;
  }
  uint64_t v278 = v149;
  uint64_t v153 = *v149;
  if (*v151 != *v149)
  {
    unint64_t v154 = 0;
    unint64_t v155 = 0;
    uint64_t v270 = v152 | 1;
    long long v275 = v149 + 1;
    unint64_t v276 = v152;
    while (1)
    {
      uint64_t v157 = (int)v280[1];
      if ((v279 & 1) == 0 && v155 != v157)
      {
        long long v156 = v151;
        goto LABEL_272;
      }
      objc_msgSend(v130, "appendFormat:", @" LabelLine[%i] segments=%i", v155, (*(void *)(*(void *)(v153 + 8 * v155) + 16) - *(void *)(*(void *)(v153 + 8 * v155) + 8)) >> 4);
      if (v155 == v157) {
        break;
      }
      [v130 appendString:@"\n"];
      if (v154 >= v152) {
        goto LABEL_357;
      }
LABEL_328:
      long long v156 = v151;
      uint64_t v229 = *(void *)(v153 + 8 * v155);
      uint64_t v230 = *(uint64_t ***)(v229 + 40);
      unsigned __int8 v231 = *(uint64_t ***)(v229 + 48);
      if (v230 == v231) {
        goto LABEL_272;
      }
      *(void *)__ea = *(void *)(v229 + 48);
      uint64_t v284 = 0;
      while (v154 != v152)
      {
        __n128 v232 = *v230;
        float64_t v233 = (std::__shared_weak_count *)(*v230)[1];
        if (!v233) {
          goto LABEL_332;
        }
        uint64_t v234 = std::__shared_weak_count::lock(v233);
        if (!v234) {
          goto LABEL_332;
        }
        uint64_t v235 = v234;
        unint64_t v236 = v152;
        uint64_t v237 = *v232;
        if (atomic_fetch_add(&v234->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          if (!v237) {
            goto LABEL_330;
          }
        }
        else
        {
          ((void (*)(std::__shared_weak_count *))v234->__on_zero_shared)(v234);
          std::__shared_weak_count::__release_weak(v235);
          if (!v237) {
            goto LABEL_330;
          }
        }
        if ((md::LineLabelFeature *)v237 != v284)
        {
          objc_msgSend(v130, "appendFormat:", @" Tile=(%i.%i.%i)\n", (*(void *)(v237 + 4) >> 14) & 0x3FFFFFFLL, ((*(void *)(v237 + 4) >> 40) | (*(unsigned __int16 *)(v237 + 12) << 24)) & 0x3FFFFFF, (*(void *)(v237 + 4) >> 8) & 0x3F);
          uint64_t v284 = (md::LineLabelFeature *)v237;
        }
        uint64_t v238 = geo::codec::VectorTile::labelLineFeatureSections((geo::codec::VectorTile *)v237);
        uint64_t v239 = geo::codec::VectorTile::labelLineAttributes((geo::codec::VectorTile *)v237);
        uint64_t v240 = v232[2];
        if (v240)
        {
          uint64_t v241 = v239;
          [v130 appendFormat:@"  Line ID=%llu rng=(%.2f:%.2f)\n", *(void *)(v240 + 24), *(void *)(v240 + 8), *(void *)(v240 + 16)];
          if (*(_WORD *)(v240 + 42))
          {
            unint64_t v242 = 0;
            do
            {
              unint64_t v243 = v242 + *(unsigned int *)(v240 + 32);
              [v130 appendFormat:@"   Section fidx=%i rng=(%.2f:%.2f) rev=%i", *(unsigned int *)(v238 + 40 * v243), *(void *)(v238 + 40 * v243 + 8), *(void *)(v238 + 40 * v243 + 16), *(unsigned __int8 *)(v238 + 40 * v243 + 30)];
              if (*(unsigned char *)(v238 + 40 * v243 + 32)) {
                objc_msgSend(v130, "appendFormat:", @" sub=(%u:%u)\n", *(unsigned __int16 *)(v238 + 40 * v243 + 26), *(unsigned __int16 *)(v238 + 40 * v243 + 26)+ *(unsigned __int16 *)(v238 + 40 * v243 + 28)- 1);
              }
              else {
                [v130 appendString:@"\n"];
              }
              ++v242;
            }
            while (v242 < *(unsigned __int16 *)(v240 + 42));
          }
          if (*(_WORD *)(v240 + 40))
          {
            unint64_t v244 = 0;
            long long v156 = v275;
            do
            {
              uint64_t v245 = (unsigned __int8 *)(v241 + 24 * (v244 + *(unsigned int *)(v240 + 36)));
              [v130 appendFormat:@"   Attr type=%i rsn=%i rng=(%.2f:%.2f)\n", *v245, v245[1], *((void *)v245 + 1), *((void *)v245 + 2)];
              ++v244;
            }
            while (v244 < *(unsigned __int16 *)(v240 + 40));
            unint64_t v152 = v276;
          }
          else
          {
            long long v156 = v275;
            unint64_t v152 = v276;
          }
          goto LABEL_331;
        }
LABEL_330:
        unint64_t v152 = v236;
LABEL_331:
        unsigned __int8 v231 = *(uint64_t ***)__ea;
LABEL_332:
        ++v154;
        if (++v230 == v231) {
          goto LABEL_272;
        }
      }
      [v130 appendString:@"...\n"];
      unint64_t v154 = v270;
LABEL_272:
      ++v155;
      long long v151 = v156;
      uint64_t v153 = *v278;
      if (v155 >= (*v156 - *v278) >> 3) {
        goto LABEL_358;
      }
    }
    objc_msgSend(v130, "appendFormat:", @" (SELECTED) segment[%i]\n", v280[2]);
    uint64_t v158 = *(void *)(v153 + 8 * v155);
    uint64_t v159 = *(void **)(v158 + 8);
    uint64_t v160 = *(void **)(v158 + 16);
    if (v160 == v159) {
      unsigned int v161 = 0;
    }
    else {
      unsigned int v161 = *(unsigned char **)(v158 + 8);
    }
    if (v161[8])
    {
      signed int v162 = 0;
    }
    else
    {
      signed int v162 = ((*(unsigned int (**)(void))(**(void **)v161 + 16))() << 16) - 0x10000;
      uint64_t v159 = *(void **)(v158 + 8);
      uint64_t v160 = *(void **)(v158 + 16);
    }
    if (v159) {
      BOOL v163 = v160 == v159;
    }
    else {
      BOOL v163 = 1;
    }
    if (v163)
    {
      memset(__p, 0, sizeof(__p));
      LODWORD(__p[5]) = 2139095039;
    }
    else
    {
      uint64_t v164 = (*(uint64_t (**)(void, uint64_t))(*(void *)*v159 + 24))(*v159, (uint64_t)v162 >> 16);
      long long v165 = *(_OWORD *)v164;
      __p[2] = *(void **)(v164 + 16);
      *(_OWORD *)std::string __p = v165;
      *(_OWORD *)&__p[3] = *(_OWORD *)(v164 + 24);
      int v166 = *(_DWORD *)(v164 + 43);
      LODWORD(__p[5]) = *(_DWORD *)(v164 + 40);
      *(_DWORD *)((char *)&__p[5] + 3) = v166;
    }
    uint64_t v167 = *(void *)(v153 + 8 * v155);
    uint64_t v168 = *(void *)(v167 + 8);
    uint64_t v169 = *(void *)(v167 + 16) - v168;
    unint64_t v170 = ((v169 << 44) - 0x1000000000000) >> 48;
    unint64_t v171 = v169 >> 4;
    uint64_t v172 = (unsigned char *)(v168 + 16 * v170);
    if (v171 <= v170) {
      uint64_t v172 = 0;
    }
    if (v172[8])
    {
      signed int v173 = ((*(unsigned int (**)(void))(**(void **)v172 + 16))() << 16) - 0x10000;
      uint64_t v168 = *(void *)(v167 + 8);
      unint64_t v171 = (*(void *)(v167 + 16) - v168) >> 4;
      if (!v168) {
        goto LABEL_298;
      }
    }
    else
    {
      signed int v173 = 0;
      if (!v168) {
        goto LABEL_298;
      }
    }
    if (v171 > v170)
    {
      uint64_t v174 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v168 + 16 * v170) + 24))(*(void *)(v168 + 16 * v170), (uint64_t)v173 >> 16);
      long long v175 = *(_OWORD *)v174;
      v308[0].__r_.__value_.__r.__words[2] = *(void *)(v174 + 16);
      *(_OWORD *)&v308[0].__r_.__value_.__l.__data_ = v175;
      *(_OWORD *)&v308[1].__r_.__value_.__l.__data_ = *(_OWORD *)(v174 + 24);
      int v176 = *(_DWORD *)(v174 + 43);
      LODWORD(v308[1].__r_.__value_.__r.__words[2]) = *(_DWORD *)(v174 + 40);
      *(_DWORD *)((char *)&v308[1].__r_.__value_.__r.__words[2] + 3) = v176;
      goto LABEL_299;
    }
LABEL_298:
    memset(v308, 0, sizeof(v308));
    LODWORD(v308[1].__r_.__value_.__r.__words[2]) = 2139095039;
LABEL_299:
    if (!*(unsigned char *)(v274 + 290))
    {
      unint64_t v180 = v152;
      int v181 = (uint64_t *)md::LabelPoint::mercatorPoint((md::LabelPoint *)__p);
      unint64_t v182 = (uint64_t *)md::LabelPoint::mercatorPoint((md::LabelPoint *)v308);
      uint64_t v183 = *v181;
      uint64_t v184 = v181[1];
      uint64_t v185 = *v182;
      uint64_t v186 = v182[1];
      unsigned int v187 = *(md::LabelLineSegment ***)(*(void *)(v153 + 8 * v155) + 8);
      double v188 = 0.0;
      unint64_t v152 = v180;
      if (*(md::LabelLineSegment ***)(*(void *)(v153 + 8 * v155) + 16) != v187 && v187) {
        double v188 = md::LabelLineSegment::coincidentPointTolerance(*v187);
      }
      objc_msgSend(v130, "appendFormat:", @"Start=(%.10f,%.10f) End=(%.10f,%.10f) Eps=%.10f\n", v183, v184, v185, v186, *(void *)&v188);
LABEL_313:
      unint64_t v210 = v152;
      uint64_t v211 = *(void *)(v153 + 8 * v155);
      uint64_t v212 = *(void *)(v211 + 8);
      if (v212)
      {
        unint64_t v213 = (int)v280[2];
        if ((*(void *)(v211 + 16) - v212) >> 4 > v213)
        {
          uint64_t v214 = (unsigned char *)(v212 + 16 * v213);
          uint64_t v215 = "fwd";
          if (!v214[8]) {
            uint64_t v215 = "rev";
          }
          objc_msgSend(v130, "appendFormat:", @"Segment: dir=%s section=%i\n", v215, *(unsigned __int16 *)(*(void *)v214 + 44));
          uint64_t v216 = *(void *)(v153 + 8 * v155);
          if (*(unsigned char *)(v216 + 1) == 4)
          {
            uint64_t v217 = *(void *)(v216 + 8);
            if (v217)
            {
              unint64_t v218 = (int)v280[2];
              if ((*(void *)(v216 + 16) - v217) >> 4 > v218)
              {
                uint64_t v219 = *(void *)(v217 + 16 * v218);
                uint64_t v220 = *(void *)(*(void *)(v219 + 16) + 48);
                uint64_t v221 = (unsigned int *)(*(void *)(v220 + 48) + 8 * *(unsigned __int16 *)(v219 + 44));
                uint64_t v222 = v221[1];
                size_t v223 = 8 * v222;
                if (v222)
                {
                  uint64_t v224 = *(void *)(v220 + 80);
                  uint64_t v225 = *v221;
                  unint64_t v226 = (char *)operator new(8 * v222);
                  memcpy(v226, (const void *)(v224 + 8 * v225), v223);
                }
                else
                {
                  unint64_t v226 = 0;
                }
                uint64_t v227 = (float *)&v226[v223];
                unint64_t v228 = (float *)v226;
                if (v223)
                {
                  do
                  {
                    [v130 appendFormat:@" ExclRange=(%.2f,%.2f)\n", *v228, v228[1]];
                    v228 += 2;
                  }
                  while (v228 != v227);
                  if (v226) {
                    goto LABEL_326;
                  }
                }
                else if (v227)
                {
LABEL_326:
                  operator delete(v226);
                }
              }
            }
          }
        }
      }
      unint64_t v152 = v210;
      if (v154 >= v210)
      {
LABEL_357:
        [v130 appendString:@"...\n"];
        goto LABEL_358;
      }
      goto LABEL_328;
    }
    if (BYTE4(__p[5]))
    {
      if (v308[1].__r_.__value_.__s.__data_[20])
      {
LABEL_302:
        double v178 = *(double *)&v308[0].__r_.__value_.__l.__size_;
        double v177 = *(double *)&v308[0].__r_.__value_.__l.__data_;
        double v179 = *(double *)&v308[0].__r_.__value_.__r.__words[2];
        goto LABEL_309;
      }
    }
    else
    {
      long double v189 = *(double *)&__p[3] * 6.28318531;
      long double v190 = exp(*(double *)&__p[4] * 6.28318531 + -3.14159265);
      double v191 = atan(v190) * 2.0 + -1.57079633;
      long double v192 = fmod(v189, 6.28318531);
      double v193 = fmod(v192 + 6.28318531, 6.28318531) + -3.14159265;
      __double2 v194 = __sincos_stret(v191);
      double v195 = 6378137.0 / sqrt(v194.__sinval * v194.__sinval * -0.00669437999 + 1.0);
      __double2 v196 = __sincos_stret(v193);
      *(double *)std::string __p = v195 * v194.__cosval * v196.__cosval;
      *(double *)&__p[1] = v195 * v194.__cosval * v196.__sinval;
      *(double *)&__p[2] = v194.__sinval * 0.99330562 * v195;
      BYTE4(__p[5]) = 1;
      if (v308[1].__r_.__value_.__s.__data_[20]) {
        goto LABEL_302;
      }
    }
    long double v197 = *(double *)&v308[1].__r_.__value_.__l.__data_ * 6.28318531;
    long double v198 = exp(*(double *)&v308[1].__r_.__value_.__l.__size_ * 6.28318531 + -3.14159265);
    double v199 = atan(v198) * 2.0 + -1.57079633;
    long double v200 = fmod(v197, 6.28318531);
    double v201 = fmod(v200 + 6.28318531, 6.28318531) + -3.14159265;
    __double2 v202 = __sincos_stret(v199);
    double v203 = 6378137.0 / sqrt(v202.__sinval * v202.__sinval * -0.00669437999 + 1.0);
    __double2 v204 = __sincos_stret(v201);
    double v177 = v203 * v202.__cosval * v204.__cosval;
    double v178 = v203 * v202.__cosval * v204.__sinval;
    *(double *)&v308[0].__r_.__value_.__l.__data_ = v177;
    *(double *)&v308[0].__r_.__value_.__l.__size_ = v178;
    double v179 = v202.__sinval * 0.99330562 * v203;
    *(double *)&v308[0].__r_.__value_.__r.__words[2] = v179;
    v308[1].__r_.__value_.__s.__data_[20] = 1;
LABEL_309:
    double v205 = __p[0];
    unint64_t v206 = __p[1];
    uint64_t v207 = __p[2];
    uint64_t v208 = *(md::LabelLineSegment ***)(*(void *)(v153 + 8 * v155) + 8);
    double v209 = 0.0;
    if (*(md::LabelLineSegment ***)(*(void *)(v153 + 8 * v155) + 16) != v208 && v208) {
      double v209 = md::LabelLineSegment::coincidentPointTolerance(*v208);
    }
    objc_msgSend(v130, "appendFormat:", @"Start=(%.10f,%.10f,%.10f) End=(%.10f,%.10f,%.10f) Eps=%.10f\n", v205, v206, v207, *(void *)&v177, *(void *)&v178, *(void *)&v179, *(void *)&v209);
    goto LABEL_313;
  }
LABEL_358:
  id v246 = v130;
  unint64_t v247 = (const char *)[v246 UTF8String];
  size_t v248 = strlen(v247);
  if (v248 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  size_t v249 = v248;
  if (v248 >= 0x17)
  {
    uint64_t v251 = (v248 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v248 | 7) != 0x17) {
      uint64_t v251 = v248 | 7;
    }
    uint64_t v252 = v251 + 1;
    long long v250 = (long long *)operator new(v251 + 1);
    int64_t v299 = v252 | 0x8000000000000000;
    *(void *)&long long v298 = v250;
    *((void *)&v298 + 1) = v249;
    goto LABEL_365;
  }
  HIBYTE(v299) = v248;
  long long v250 = &v298;
  if (v248) {
LABEL_365:
  }
    memmove(v250, v247, v249);
  *((unsigned char *)v250 + v249) = 0;
  if (v299 >= 0) {
    uint64_t v253 = &v298;
  }
  else {
    uint64_t v253 = (long long *)v298;
  }
  if (v299 >= 0) {
    uint64_t v254 = HIBYTE(v299);
  }
  else {
    uint64_t v254 = *((void *)&v298 + 1);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v288, (uint64_t)v253, v254);
  if (SHIBYTE(v299) < 0) {
    operator delete((void *)v298);
  }

  if ((v295 & 0x10) != 0)
  {
    unint64_t v257 = v294;
    if (v294 < v291)
    {
      unint64_t v294 = v291;
      unint64_t v257 = v291;
    }
    uint64_t v258 = (const void **)&v290;
  }
  else
  {
    if ((v295 & 8) == 0)
    {
      size_t v255 = 0;
      uint64_t v256 = a1;
      *((unsigned char *)a1 + 23) = 0;
      goto LABEL_389;
    }
    uint64_t v258 = (const void **)v289;
    unint64_t v257 = v289[2];
  }
  size_t v259 = *v258;
  size_t v255 = v257 - (void)*v258;
  if (v255 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v255 >= 0x17)
  {
    uint64_t v260 = (v255 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v255 | 7) != 0x17) {
      uint64_t v260 = v255 | 7;
    }
    uint64_t v261 = v260 + 1;
    uint64_t v256 = operator new(v260 + 1);
    a1[1] = v255;
    a1[2] = v261 | 0x8000000000000000;
    *a1 = v256;
    goto LABEL_388;
  }
  uint64_t v256 = a1;
  *((unsigned char *)a1 + 23) = v255;
  if (v255)
  {
LABEL_388:
    double v262 = v259;
    double v263 = v256;
    memmove(v256, v262, v255);
    uint64_t v256 = v263;
  }
LABEL_389:
  *((unsigned char *)v256 + v255) = 0;
  v288[0] = v271;
  *(void *)((char *)v288 + *(void *)(v271 - 24)) = v272;
  v288[1] = MEMORY[0x1E4FBA470] + 16;
  if (v293 < 0) {
    operator delete(v292);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v296);
}

void sub_1A21349BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,char a39)
{
}

void md::LineLabelFeature::debugPopulateAttributeStrings(uint64_t a1, void *a2, uint64_t a3, unsigned int *a4)
{
  id v40 = a2;
  uint64_t v6 = *(void *)(a1 + 232);
  if (!v6) {
    goto LABEL_12;
  }
  unsigned int v7 = *a4;
  uint64_t v8 = a1 + 232;
  do
  {
    unsigned int v9 = *(_DWORD *)(v6 + 32);
    BOOL v10 = v9 >= v7;
    if (v9 >= v7) {
      float v11 = (uint64_t *)v6;
    }
    else {
      float v11 = (uint64_t *)(v6 + 8);
    }
    if (v10) {
      uint64_t v8 = v6;
    }
    uint64_t v6 = *v11;
  }
  while (*v11);
  if (v8 == a1 + 232 || v7 < *(_DWORD *)(v8 + 32))
  {
LABEL_12:
    uint64_t v43 = 0;
    float v44 = 0;
LABEL_13:
    unsigned int v12 = -1;
    unsigned int v13 = 1;
    goto LABEL_14;
  }
  unsigned int v33 = *(unsigned __int8 **)(v8 + 40);
  int v32 = *(std::__shared_weak_count **)(v8 + 48);
  uint64_t v43 = v33;
  float v44 = v32;
  if (v32) {
    atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v33) {
    goto LABEL_13;
  }
  float v34 = (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)v33 + 200))(v33);
  uint64_t v36 = v34;
  if ((*(void *)v34
     && *((_DWORD *)v34 + 10) == *(_DWORD *)(*(void *)v34 + 252)
     && (unsigned int v37 = (uint64_t *)*((void *)v34 + 3)) != 0
     && (*((__int16 *)v34 + 17) & 0x80000000) == 0
     || (md::LabelLineResolvedPosition::moveOntoPathForZoom((md::LabelLineResolvedPosition *)v34, v34[164], v35),
         *(void *)v36)
     && *((_DWORD *)v36 + 10) == *(_DWORD *)(*(void *)v36 + 252)
     && (unsigned int v37 = (uint64_t *)*((void *)v36 + 3)) != 0)
    && (*((__int16 *)v36 + 17) & 0x80000000) == 0
    && (uint64_t v38 = *v37) != 0)
  {
    unsigned int v12 = *(_DWORD *)(v38 + 40);
  }
  else
  {
    unsigned int v12 = -1;
  }
  unsigned int v13 = v33[9];
LABEL_14:
  uint64_t v14 = *(void *)(a1 + 272);
  if (v14 == *(void *)(a1 + 280))
  {
    if (*(void *)(a1 + 416))
    {
      unint64_t v26 = NSString;
      uint64_t v27 = md::HighlightHelper::debugAttributesToString((gss::Allocator *)(a1 + 416));
      unsigned __int8 v28 = [v26 stringWithFormat:@"{%@}[SINGLE]", v27];
      [v40 addObject:v28];
    }
  }
  else
  {
    uint64_t v15 = 0;
    unint64_t v16 = 0;
    uint64_t v17 = v12;
    unint64_t v18 = 0x6060C01000000uLL >> (8 * v13);
    if (v13 >= 7) {
      LOBYTE(v18) = 0;
    }
    uint64_t v19 = v18;
    do
    {
      md::LineLabelFeature::resolvedStyleAttributes(&v41, *(const FeatureStyleAttributes **)(v14 + v15), v16 == *(_DWORD *)(a1 + 304), v19);
      long long v42 = v41;
      uint64_t v20 = NSString;
      uint64_t v21 = md::HighlightHelper::debugAttributesToString((gss::Allocator *)&v42);
      unsigned int v22 = (void *)v21;
      double v23 = "";
      if (v17 == v16) {
        double v23 = "[ACTIVE]";
      }
      uint64_t v24 = [v20 stringWithFormat:@"{%@}%s", v21, v23];
      [v40 addObject:v24];

      uint64_t v25 = (std::__shared_weak_count *)*((void *)&v42 + 1);
      if (*((void *)&v42 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v42 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
      ++v16;
      uint64_t v14 = *(void *)(a1 + 272);
      v15 += 80;
    }
    while (v16 < 0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a1 + 280) - v14) >> 4));
  }
  float v29 = md::LabelFeature::debugClientAttributesToString((uint64_t *)(a1 + 416), *(void *)(a3 + 336));
  if (v29)
  {
    int v30 = [NSString stringWithFormat:@"{%@}[CLIENT]", v29];
    [v40 addObject:v30];
  }
  int v31 = v44;
  if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
}

void sub_1A2134F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::LineLabelFeature::debugDraw(md::LineLabelFeature *a1, uint64_t a2, float32x2_t *a3, atomic_uchar *a4)
{
  unint64_t v9 = (unint64_t)a1;
  int64_t v299 = (double *)md::LineLabelFeature::roadMetricsForZ(a1, (int)*(float *)(a2 + 472), *(const md::LabelLayoutContext **)(a2 + 432));
  if (!v299) {
    return;
  }
  BOOL v10 = *(unsigned __int8 **)(v9 + 192);
  long long v305 = (uint64_t *)(v9 + 192);
  unsigned __int8 v11 = atomic_load(v10 + 80);
  if (v11) {
    md::LabelLineStore::consumeWorkUnits((md::LabelLineStore *)v10);
  }
  uint64_t v311 = (float64x2_t *)(a2 + 1304);
  double v12 = *(double *)(*(void *)(a2 + 232) + 56) * *(float *)(a2 + 488);
  unint64_t v13 = (int)*(float *)(a2 + 472);
  double v309 = v12;
  if ((*(unsigned int (**)(unint64_t))(*(void *)v9 + 264))(v9) == 3)
  {
    if (v13 >= 0x17) {
      uint64_t v14 = 23;
    }
    else {
      uint64_t v14 = v13;
    }
  }
  else
  {
    uint64_t v29 = *v305;
    if (v13 >= 0x17) {
      uint64_t v14 = 23;
    }
    else {
      uint64_t v14 = v13;
    }
    unsigned int v30 = atomic_load((unsigned __int8 *)(v29 + 224 + v14));
    if (v30 == 254)
    {
      if (*(unsigned char *)(v29 + 289)) {
        unsigned int v31 = 24;
      }
      else {
        unsigned int v31 = 5;
      }
      int v32 = *(unsigned __int8 **)(v29 + 128);
      uint64_t v33 = *(void *)(v29 + 136) - (void)v32;
      if (v33)
      {
        uint64_t v34 = 0;
        unint64_t v35 = v33 / 112;
        if (v35 <= 1) {
          uint64_t v36 = 1;
        }
        else {
          uint64_t v36 = v35;
        }
        unsigned int v30 = -1;
        float v37 = 1000.0;
        while (1)
        {
          int v38 = *v32;
          v32 += 112;
          int v39 = v14 - v38;
          if (v14 == v38) {
            break;
          }
          if (v39 >= 0) {
            unsigned int v40 = v39;
          }
          else {
            unsigned int v40 = -v39;
          }
          if (v40 <= v31)
          {
            float v41 = (float)v39;
            if (v39 < 0) {
              float v41 = (float)v39 * -0.8;
            }
            if (v41 < v37) {
              unsigned int v30 = v34;
            }
            float v37 = fminf(v41, v37);
          }
          if (v36 == ++v34) {
            goto LABEL_118;
          }
        }
        unsigned int v30 = v34;
      }
      else
      {
        unsigned int v30 = -1;
      }
LABEL_118:
      atomic_store(v30, (unsigned __int8 *)(v29 + 224 + v14));
      if ((v30 & 0x80000000) != 0) {
        goto LABEL_121;
      }
    }
    else
    {
      unsigned int v30 = (char)v30;
      if ((char)v30 < 0) {
        goto LABEL_121;
      }
    }
    uint64_t v111 = *(void *)(v29 + 128);
    if (!v111 || *(unsigned __int8 *)(v111 + 112 * v30) < 8u) {
      goto LABEL_121;
    }
  }
  uint64_t v15 = *v305;
  uint64_t v16 = *v305 + 224;
  unsigned int v17 = atomic_load((unsigned __int8 *)(v16 + v14));
  if (v17 != 254)
  {
    unsigned int v17 = (char)v17;
    if ((char)v17 < 0) {
      goto LABEL_121;
    }
    goto LABEL_58;
  }
  if (*(unsigned char *)(v15 + 289)) {
    unsigned int v18 = 24;
  }
  else {
    unsigned int v18 = 5;
  }
  uint64_t v19 = *(unsigned __int8 **)(v15 + 128);
  uint64_t v20 = *(void *)(v15 + 136) - (void)v19;
  if (v20)
  {
    uint64_t v21 = 0;
    unint64_t v22 = v20 / 112;
    if (v22 <= 1) {
      uint64_t v23 = 1;
    }
    else {
      uint64_t v23 = v22;
    }
    unsigned int v17 = -1;
    float v24 = 1000.0;
    while (1)
    {
      int v25 = *v19;
      v19 += 112;
      int v26 = v14 - v25;
      if (v14 == v25) {
        break;
      }
      if (v26 >= 0) {
        unsigned int v27 = v26;
      }
      else {
        unsigned int v27 = -v26;
      }
      if (v27 <= v18)
      {
        float v28 = (float)v26;
        if (v26 < 0) {
          float v28 = (float)v26 * -0.8;
        }
        if (v28 < v24) {
          unsigned int v17 = v21;
        }
        float v24 = fminf(v28, v24);
      }
      if (v23 == ++v21) {
        goto LABEL_57;
      }
    }
    unsigned int v17 = v21;
  }
  else
  {
    unsigned int v17 = -1;
  }
LABEL_57:
  atomic_store(v17, (unsigned __int8 *)(v16 + v14));
  if ((v17 & 0x80000000) == 0)
  {
LABEL_58:
    uint64_t v42 = *(void *)(v15 + 128);
    if (v42)
    {
      uint64_t v43 = v42 + 112 * v17;
      unint64_t v13 = *(void *)(v43 + 80);
      float v44 = *(float *)(a2 + 176);
      float v45 = 0.5;
      a3[13].f32[0] = fabsf(v44 + v44) * 0.5;
      uint64_t v303 = (unint64_t *)(v43 + 80);
      uint64_t v301 = (void *)(v43 + 88);
      if (*(void *)(v43 + 88) != v13)
      {
        n128_u64 = (void *)v9;
        unint64_t v9 = 0;
        LODWORD(v46) = a2 + 440;
        double v5 = (atomic_uchar *)&v343;
        uint64_t v4 = 0xFFFFFFFFLL;
        uint64_t v47 = 2139095039;
        do
        {
          unsigned int v48 = *(std::__shared_weak_count **)(*v305 + 8);
          if (!v48) {
            goto LABEL_328;
          }
          uint64_t v307 = *((int *)a4 + 1);
          unint64_t v49 = *(void *)*v305;
          uint64_t v50 = std::__shared_weak_count::lock(v48);
          if (!v50) {
            goto LABEL_328;
          }
          uint64_t v51 = v50;
          unint64_t v52 = 0;
          uint64_t v53 = *(void *)(v13 + 8 * v9);
          if (*(void *)(v53 + 16) == *(void *)(v53 + 8)) {
            int v54 = 0;
          }
          else {
            int v54 = *(unsigned char **)(v53 + 8);
          }
          if (!v54[8]) {
            unint64_t v52 = ((*(unsigned int (**)(void))(**(void **)v54 + 16))() << 16) - 0x10000;
          }
          unint64_t v340 = v49;
          uint64_t v341 = v51;
          atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
          *(void *)&long long v342 = v53;
          unint64_t v343 = v52;
          int v344 = *(_DWORD *)(v49 + 252);
          if (*(void *)(v53 + 16) == *(void *)(v53 + 8)) {
            uint64_t v55 = 0;
          }
          else {
            uint64_t v55 = *(void *)(v53 + 8);
          }
          *((void *)&v342 + 1) = v55;
          if (!atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
            std::__shared_weak_count::__release_weak(v51);
          }
          uint64_t v56 = (const md::LabelPoint *)(*(uint64_t (**)(void, void))(***((void ***)&v342 + 1) + 24))(**((void **)&v342 + 1), SWORD1(v343));
          labelPointToWorldPoint(v56, (const LabelLayoutContext *)*(unsigned __int8 *)(a2 + 448), v12);
          double v312 = v57;
          double v314 = v58;
          *(double *)&long long v333 = v57;
          *((double *)&v333 + 1) = v58;
          double v316 = v59;
          *(double *)&long long v334 = v59;
          BOOL isDistanceClipped = md::LabelLayoutContext::isDistanceClipped(a2 + 440, (uint64_t)&v333);
          if (!isDistanceClipped)
          {
            float32x2_t v6 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v312), *(float64x2_t *)(a2 + 1336), v314), *(float64x2_t *)(a2 + 1368), v316), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v312+ *(double *)(a2 + 1360) * v314+ *(double *)(a2 + 1392) * v316)));
            a3[1] = v6;
            ggl::DebugConsole::drawSymbol(a3, 3);
          }
          while (1)
          {
            LODWORD(v327) = -1;
            if (!md::LabelLinePosition::getPointCoordinateAtOffset((uint64_t)&v340, 1, (uint64_t)&v327)) {
              break;
            }
            uint64_t v64 = *(void *)(*(void *)(v342 + 8) + 16 * (__int16)v327);
            uint64_t v65 = (*(uint64_t (**)(uint64_t, void))(*(void *)v64 + 24))(v64, SWORD1(v327));
            uint64_t v66 = v65;
            if (*(unsigned char *)(a2 + 448))
            {
              if (*(unsigned char *)(v65 + 45)) {
                _ZF = 1;
              }
              else {
                _ZF = *(unsigned char *)(v65 + 46) == 0;
              }
              if (!_ZF)
              {
                long double v68 = *(double *)v65;
                long double v69 = *(double *)(v65 + 8);
                long double v70 = *(double *)(v65 + 16);
                double v71 = sqrt(v68 * v68 + v69 * v69);
                double v72 = atan2(v70, v71 * 0.996647189);
                long double v317 = atan2(v69, v68);
                __double2 v73 = __sincos_stret(v72);
                long double v74 = v71 + v73.__cosval * v73.__cosval * -42697.6727 * v73.__cosval;
                double v12 = v309;
                long double v75 = atan2(v70 + v73.__sinval * v73.__sinval * 42841.3115 * v73.__sinval, v74);
                long double v76 = tan(v75 * 0.5 + 0.785398163);
                long double v77 = log(v76);
                v78.f64[0] = v317;
                v78.f64[1] = v77;
                __asm { FMOV            V1.2D, #0.5 }
                *(float64x2_t *)(v66 + 24) = vmlaq_f64(_Q1, (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL), v78);
                *(unsigned char *)(v66 + 45) = 1;
              }
              double v83 = *(double *)(v66 + 24);
              double v82 = *(double *)(v66 + 32);
              float v84 = *(float *)(v66 + 40);
              if (v84 == 3.4028e38) {
                float v84 = 0.0;
              }
              double v85 = v12 * v84;
            }
            else
            {
              if (*(unsigned char *)(v65 + 44))
              {
                double v87 = *(double *)v65;
                double v86 = *(double *)(v65 + 8);
                double v88 = *(double *)(v65 + 16);
              }
              else
              {
                long double v89 = *(double *)(v65 + 24) * 6.28318531;
                long double v90 = exp(*(double *)(v65 + 32) * 6.28318531 + -3.14159265);
                double v91 = atan(v90) * 2.0 + -1.57079633;
                long double v92 = fmod(v89, 6.28318531);
                double v93 = fmod(v92 + 6.28318531, 6.28318531) + -3.14159265;
                __double2 v94 = __sincos_stret(v91);
                double v95 = 6378137.0 / sqrt(v94.__sinval * v94.__sinval * -0.00669437999 + 1.0);
                __double2 v96 = __sincos_stret(v93);
                double v87 = v95 * v94.__cosval * v96.__cosval;
                double v86 = v95 * v94.__cosval * v96.__sinval;
                *(double *)uint64_t v66 = v87;
                *(double *)(v66 + 8) = v86;
                double v88 = v94.__sinval * 0.99330562 * v95;
                *(double *)(v66 + 16) = v88;
                *(unsigned char *)(v66 + 44) = 1;
              }
              double v97 = v87 * 2.45817226e-14;
              double v98 = v86 * 2.45817226e-14;
              double v99 = v88 * 2.4747391e-14;
              double v100 = sqrt(v97 * v97 + v98 * v98 + v99 * v99);
              float v101 = *(float *)(v66 + 40);
              if (v101 == 3.4028e38) {
                float v101 = 0.0;
              }
              double v102 = v12 * v101 / v100;
              double v83 = v87 + v102 * v97;
              double v82 = v86 + v102 * v98;
              double v85 = v88 + v102 * v99;
            }
            double v315 = v83;
            double v318 = v82;
            *(double *)&long long v327 = v83;
            *((double *)&v327 + 1) = v82;
            double v313 = v85;
            *(double *)&long long v328 = v85;
            BOOL v103 = md::LabelLayoutContext::isDistanceClipped(a2 + 440, (uint64_t)&v327);
            if (v103)
            {
              float32x2_t v104 = v6;
            }
            else
            {
              float32x2_t v104 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v315), *(float64x2_t *)(a2 + 1336), v318), *(float64x2_t *)(a2 + 1368), v313), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v315+ *(double *)(a2 + 1360) * v318+ *(double *)(a2 + 1392) * v313)));
              *(float32x2_t *)&long long v322 = v104;
              if (!isDistanceClipped)
              {
                if (v9 == v307)
                {
                  char v105 = 0;
                  int v106 = *((_DWORD *)a4 + 2);
                  BOOL v107 = v106 == (__int16)v343;
                  if (v106 == (__int16)v343) {
                    char v108 = -1;
                  }
                  else {
                    char v108 = 0;
                  }
                  if (v107) {
                    char v109 = 0;
                  }
                  else {
                    char v109 = -1;
                  }
                }
                else
                {
                  char v109 = 0;
                  char v108 = 0;
                  char v105 = -1;
                }
                a3[12].i8[0] = v108;
                a3[12].i8[1] = v105;
                a3[12].i8[2] = v109;
                a3[12].i8[3] = -1;
                a3[1] = v6;
                ggl::DebugConsole::drawLine((uint64_t)a3, (float *)&v322);
              }
            }
            if (md::LabelLinePosition::getPointCoordinateAtOffset((uint64_t)&v340, 1, (uint64_t)&v343))
            {
              uint64_t v61 = *(void *)(v342 + 8);
              uint64_t v62 = *(void *)(v342 + 16) - v61;
              uint64_t v63 = v61 + 16 * (__int16)v343;
              if ((__int16)v343 >= (unint64_t)(v62 >> 4)) {
                uint64_t v63 = 0;
              }
            }
            else
            {
              uint64_t v63 = 0;
            }
            *((void *)&v342 + 1) = v63;
            float32x2_t v6 = v104;
            BOOL isDistanceClipped = v103;
          }
          if (!isDistanceClipped)
          {
            a3[1] = v6;
            ggl::DebugConsole::drawSymbol(a3, 4);
          }
          uint64_t v110 = v341;
          if (v341 && !atomic_fetch_add(&v341->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v110->__on_zero_shared)(v110);
            std::__shared_weak_count::__release_weak(v110);
          }
          ++v9;
          unint64_t v13 = *v303;
        }
        while (v9 < (uint64_t)(*v301 - *v303) >> 3);
        float v44 = *(float *)(a2 + 176);
        unint64_t v9 = (unint64_t)n128_u64;
        float v45 = 0.5;
      }
      a3[13].f32[0] = fabsf(v44) * v45;
    }
  }
LABEL_121:
  uint64_t v47 = *(void *)(v9 + 224);
  int v46 = (__n128 *)(v9 + 232);
  if (v47 != v9 + 232)
  {
    unint64_t v13 = 1 << (int)*(float *)(a2 + 472);
    unint64_t v9 = 255;
    uint64_t v4 = 3;
    double v5 = a4;
    do
    {
      uint64_t v112 = v46;
      (*(void (**)(void, uint64_t, float32x2_t *))(**(void **)(v47 + 40) + 184))(*(void *)(v47 + 40), a2, a3);
      int v113 = *(_DWORD *)(v47 + 32);
      unsigned int v114 = *(_DWORD *)a4;
      a3[12].i8[0] = 0;
      BOOL v115 = v113 == v114;
      if (v113 == v114) {
        char v116 = 0;
      }
      else {
        char v116 = -1;
      }
      a3[12].i8[1] = v116;
      if (v115) {
        char v117 = -1;
      }
      else {
        char v117 = 0;
      }
      a3[12].i8[2] = v117;
      a3[12].i8[3] = -1;
      long long v118 = (const md::LabelPoint *)(*(uint64_t (**)(void))(**(void **)(v47 + 40) + 56))(*(void *)(v47 + 40));
      labelPointToWorldPoint(v118, (const LabelLayoutContext *)*(unsigned __int8 *)(a2 + 448), v12);
      float32x2_t v122 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v119), *(float64x2_t *)(a2 + 1336), v120), *(float64x2_t *)(a2 + 1368), v121), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v119+ *(double *)(a2 + 1360) * v120+ *(double *)(a2 + 1392) * v121)));
      if (v113 == *(_DWORD *)a4) {
        float v123 = 4.0;
      }
      else {
        float v123 = 2.0;
      }
      a3[13].f32[0] = fabsf(v123 * *(float *)(a2 + 176)) * 0.5;
      a3[1] = v122;
      if (*(unsigned char *)(*(void *)(v47 + 40) + 9) == 4) {
        char v124 = 1;
      }
      else {
        char v124 = 3;
      }
      ggl::DebugConsole::drawSymbol(a3, v124);
      if ((v13 & *(_DWORD *)(*(void *)(v47 + 40) + 12)) != 0) {
        ggl::DebugConsole::drawSymbol(a3, 0);
      }
      uint64_t v125 = *(__n128 **)(v47 + 8);
      int v46 = v112;
      if (v125)
      {
        do
        {
          uint64_t v126 = v125;
          uint64_t v125 = (__n128 *)v125->n128_u64[0];
        }
        while (v125);
      }
      else
      {
        do
        {
          uint64_t v126 = *(__n128 **)(v47 + 16);
          _ZF = v126->n128_u64[0] == v47;
          uint64_t v47 = (uint64_t)v126;
        }
        while (!_ZF);
      }
      uint64_t v47 = (uint64_t)v126;
    }
    while (v126 != v112);
  }
  uint64_t v127 = *(std::__shared_weak_count **)(*v305 + 8);
  if (!v127) {
    goto LABEL_328;
  }
  unint64_t v13 = *(void *)*v305;
  uint64_t v128 = std::__shared_weak_count::lock(v127);
  if (!v128) {
    goto LABEL_328;
  }
  unint64_t v325 = v13;
  unint64_t v326 = v128;
  unsigned int v129 = (int)*(float *)(a2 + 472);
  uint64_t v130 = (unsigned __int8 *)*v305;
  if (v129 >= 0x17) {
    uint64_t v131 = 23;
  }
  else {
    uint64_t v131 = v129;
  }
  unsigned int v132 = atomic_load(&v130[v131 + 224]);
  n128_u64 = v46->n128_u64;
  if (v132 == 254)
  {
    if (v130[289]) {
      unsigned int v133 = 24;
    }
    else {
      unsigned int v133 = 5;
    }
    uint64_t v134 = (unsigned __int8 *)*((void *)v130 + 16);
    uint64_t v135 = *((void *)v130 + 17) - (void)v134;
    if (v135)
    {
      uint64_t v136 = 0;
      unint64_t v137 = v135 / 112;
      if (v137 <= 1) {
        uint64_t v138 = 1;
      }
      else {
        uint64_t v138 = v137;
      }
      unsigned int v132 = -1;
      float v139 = 1000.0;
      while (1)
      {
        int v141 = *v134;
        v134 += 112;
        int v140 = v141;
        if (v131 == v141) {
          break;
        }
        int v142 = v131 - v140;
        if (v142 >= 0) {
          unsigned int v143 = v142;
        }
        else {
          unsigned int v143 = -v142;
        }
        if (v143 <= v133)
        {
          float v144 = (float)v142;
          if (v142 < 0) {
            float v144 = (float)v142 * -0.8;
          }
          if (v144 < v139) {
            unsigned int v132 = v136;
          }
          float v139 = fminf(v144, v139);
        }
        if (v138 == ++v136) {
          goto LABEL_173;
        }
      }
      unsigned int v132 = v136;
    }
    else
    {
      unsigned int v132 = -1;
    }
LABEL_173:
    atomic_store(v132, &v130[v131 + 224]);
    if ((v132 & 0x80000000) != 0) {
      goto LABEL_246;
    }
  }
  else
  {
    unsigned int v132 = (char)v132;
    if ((char)v132 < 0) {
      goto LABEL_246;
    }
  }
  uint64_t v145 = *((void *)v130 + 16);
  if (v145)
  {
    uint64_t v146 = v145 + 112 * v132;
    double v5 = *(atomic_uchar **)(v146 + 80);
    int v306 = (atomic_uchar **)(v146 + 80);
    char v304 = (void *)(v146 + 88);
    if (*(atomic_uchar **)(v146 + 88) != v5)
    {
      unint64_t v147 = 0;
      unsigned int v302 = v129;
      unint64_t v13 = 12;
      double v148 = 1.0;
      uint64_t v310 = a3;
      md::LabelLine::attributes((unint64_t *)&v336, *(void **)v5, &v325, v129);
      while (1)
      {
        int v46 = v336;
        uint64_t v149 = v337;
        size_t v319 = v337;
        if (v336 == v337)
        {
          if (v336) {
            goto LABEL_245;
          }
        }
        else
        {
          do
          {
            unint64_t v9 = v46->n128_u8[0];
            uint64_t v47 = *((unsigned __int8 *)&kAttributeDrawOptions + 12 * v9);
            if ((v47 - 1) <= 1)
            {
              uint64_t v150 = (char *)&kAttributeDrawOptions + 12 * v9;
              a3[12].i16[0] = *(_WORD *)(v150 + 1);
              a3[12].i8[2] = v150[3];
              a3[12].i8[3] = -1;
              long long v151 = v5;
              unint64_t v152 = v147;
              uint64_t v153 = *(void *)&v5[8 * v147];
              unint64_t v155 = v325;
              unint64_t v154 = v326;
              unint64_t v340 = v325;
              uint64_t v341 = v326;
              if (v326) {
                atomic_fetch_add_explicit(&v326->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              *(void *)&long long v342 = v153;
              unint64_t v343 = v46[1].n128_u64[1];
              int v344 = *(_DWORD *)(v155 + 252);
              uint64_t v157 = v153 + 8;
              uint64_t v156 = *(void *)(v153 + 8);
              unint64_t v158 = (*(void *)(v157 + 8) - v156) >> 4;
              uint64_t v159 = v156 + 16 * (__int16)v343;
              if (v158 <= (__int16)v343) {
                uint64_t v159 = 0;
              }
              *((void *)&v342 + 1) = v159;
              long long v334 = 0u;
              long long v335 = 0u;
              long long v333 = 0u;
              DWORD2(v335) = 2139095039;
              int LabelPoint = md::LabelLinePosition::getLabelPoint((md::LabelLinePosition *)&v340, (md::LabelPoint *)&v333);
              float32x2_t v161 = 0;
              if (LabelPoint)
              {
                if (*(unsigned char *)(a2 + 448))
                {
                  if (BYTE13(v335) || !BYTE14(v335))
                  {
                    double v172 = *((double *)&v334 + 1);
                    double v173 = *(double *)&v335;
                  }
                  else
                  {
                    long long v162 = v333;
                    double v163 = *(double *)&v334;
                    double v164 = sqrt(*(double *)&v333 * *(double *)&v333 + *((double *)&v333 + 1) * *((double *)&v333 + 1));
                    double v165 = atan2(*(long double *)&v334, v164 * 0.996647189);
                    double v166 = atan2(*((long double *)&v162 + 1), *(long double *)&v162);
                    __double2 v167 = __sincos_stret(v165);
                    long double v168 = v163 + v167.__sinval * v167.__sinval * 42841.3115 * v167.__sinval;
                    double v148 = 1.0;
                    long double v169 = atan2(v168, v164 + v167.__cosval * v167.__cosval * -42697.6727 * v167.__cosval);
                    long double v170 = tan(v169 * 0.5 + 0.785398163);
                    long double v171 = log(v170);
                    double v172 = v166 * 0.159154943 + 0.5;
                    double v173 = v171 * 0.159154943 + 0.5;
                    *((double *)&v334 + 1) = v172;
                    *(double *)&long long v335 = v173;
                    BYTE13(v335) = 1;
                  }
                  float v177 = *((float *)&v335 + 2);
                  if (*((float *)&v335 + 2) == 3.4028e38) {
                    float v177 = 0.0;
                  }
                  double v178 = v12 * v177;
                }
                else
                {
                  if (BYTE12(v335))
                  {
                    double v174 = *((double *)&v333 + 1);
                    double v175 = *(double *)&v333;
                    double v176 = *(double *)&v334;
                  }
                  else
                  {
                    long double v179 = *((double *)&v334 + 1) * 6.28318531;
                    long double v180 = exp(*(double *)&v335 * 6.28318531 + -3.14159265);
                    double v181 = atan(v180) * 2.0 + -1.57079633;
                    long double v182 = fmod(v179, 6.28318531);
                    double v183 = fmod(v182 + 6.28318531, 6.28318531) + -3.14159265;
                    __double2 v184 = __sincos_stret(v181);
                    double v185 = 6378137.0 / sqrt(v148 + v184.__sinval * v184.__sinval * -0.00669437999);
                    __double2 v186 = __sincos_stret(v183);
                    double v175 = v185 * v184.__cosval * v186.__cosval;
                    double v174 = v185 * v184.__cosval * v186.__sinval;
                    *(double *)&long long v333 = v175;
                    *((double *)&v333 + 1) = v174;
                    double v176 = v184.__sinval * 0.99330562 * v185;
                    *(double *)&long long v334 = v176;
                    BYTE12(v335) = 1;
                  }
                  double v187 = v175 * 2.45817226e-14;
                  double v188 = v174 * 2.45817226e-14;
                  double v189 = v176 * 2.4747391e-14;
                  double v190 = sqrt(v187 * v187 + v188 * v188 + v189 * v189);
                  float v191 = *((float *)&v335 + 2);
                  if (*((float *)&v335 + 2) == 3.4028e38) {
                    float v191 = 0.0;
                  }
                  double v192 = v12 * v191 / v190;
                  double v172 = v175 + v192 * v187;
                  double v173 = v174 + v192 * v188;
                  double v178 = v176 + v192 * v189;
                }
                float32x2_t v161 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v172), *(float64x2_t *)(a2 + 1336), v173), *(float64x2_t *)(a2 + 1368), v178), v148/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v172+ *(double *)(a2 + 1360) * v173+ *(double *)(a2 + 1392) * v178)));
              }
              double v193 = v46->n128_f64[1];
              double v194 = v46[1].n128_f64[0];
              uint64_t v195 = *(void *)&v151[8 * v152];
              if (v46->n128_u8[2]) {
                __double2 v196 = v46 + 2;
              }
              else {
                __double2 v196 = (__n128 *)((char *)v46 + 24);
              }
              *(void *)&long long v327 = v155;
              *((void *)&v327 + 1) = v154;
              if (v154) {
                atomic_fetch_add_explicit(&v154->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              *(void *)&long long v328 = v195;
              unint64_t v329 = v196->n128_u64[0];
              int v330 = *(_DWORD *)(v155 + 252);
              uint64_t v198 = v195 + 8;
              uint64_t v197 = *(void *)(v195 + 8);
              unint64_t v199 = (*(void *)(v198 + 8) - v197) >> 4;
              uint64_t v200 = v197 + 16 * (__int16)v329;
              if (v199 <= (__int16)v329) {
                uint64_t v200 = 0;
              }
              *((void *)&v328 + 1) = v200;
              long long v323 = 0u;
              long long v324 = 0u;
              long long v322 = 0u;
              DWORD2(v324) = 2139095039;
              float32x2_t v321 = 0;
              unint64_t v13 = 12;
              int v201 = md::LabelLinePosition::getLabelPoint((md::LabelLinePosition *)&v327, (md::LabelPoint *)&v322);
              float32x2_t v202 = 0;
              if (v201)
              {
                if (*(unsigned char *)(a2 + 448))
                {
                  if (BYTE13(v324) || !BYTE14(v324))
                  {
                    double v214 = *((double *)&v323 + 1);
                    double v215 = *(double *)&v324;
                  }
                  else
                  {
                    long long v203 = v322;
                    double v204 = *(double *)&v323;
                    double v205 = sqrt(*(double *)&v322 * *(double *)&v322 + *((double *)&v322 + 1) * *((double *)&v322 + 1));
                    double v206 = atan2(*(long double *)&v323, v205 * 0.996647189);
                    double v207 = atan2(*((long double *)&v203 + 1), *(long double *)&v203);
                    __double2 v208 = __sincos_stret(v206);
                    long double v209 = v204 + v208.__sinval * v208.__sinval * 42841.3115 * v208.__sinval;
                    double v148 = 1.0;
                    long double v210 = v205 + v208.__cosval * v208.__cosval * -42697.6727 * v208.__cosval;
                    double v12 = v309;
                    long double v211 = atan2(v209, v210);
                    long double v212 = tan(v211 * 0.5 + 0.785398163);
                    long double v213 = log(v212);
                    double v214 = v207 * 0.159154943 + 0.5;
                    double v215 = v213 * 0.159154943 + 0.5;
                    *((double *)&v323 + 1) = v214;
                    *(double *)&long long v324 = v215;
                    BYTE13(v324) = 1;
                  }
                  float v219 = *((float *)&v324 + 2);
                  if (*((float *)&v324 + 2) == 3.4028e38) {
                    float v219 = 0.0;
                  }
                  double v220 = v12 * v219;
                }
                else
                {
                  if (BYTE12(v324))
                  {
                    double v216 = *((double *)&v322 + 1);
                    double v217 = *(double *)&v322;
                    double v218 = *(double *)&v323;
                  }
                  else
                  {
                    long double v221 = *((double *)&v323 + 1) * 6.28318531;
                    long double v222 = exp(*(double *)&v324 * 6.28318531 + -3.14159265);
                    double v223 = atan(v222) * 2.0 + -1.57079633;
                    long double v224 = fmod(v221, 6.28318531);
                    double v225 = fmod(v224 + 6.28318531, 6.28318531) + -3.14159265;
                    __double2 v226 = __sincos_stret(v223);
                    double v227 = 6378137.0 / sqrt(v226.__sinval * v226.__sinval * -0.00669437999 + 1.0);
                    __double2 v228 = __sincos_stret(v225);
                    double v217 = v227 * v226.__cosval * v228.__cosval;
                    double v216 = v227 * v226.__cosval * v228.__sinval;
                    *(double *)&long long v322 = v217;
                    *((double *)&v322 + 1) = v216;
                    double v218 = v226.__sinval * 0.99330562 * v227;
                    double v148 = 1.0;
                    *(double *)&long long v323 = v218;
                    BYTE12(v324) = 1;
                  }
                  double v229 = v217 * 2.45817226e-14;
                  double v230 = v216 * 2.45817226e-14;
                  double v231 = v218 * 2.4747391e-14;
                  double v232 = sqrt(v229 * v229 + v230 * v230 + v231 * v231);
                  float v233 = *((float *)&v324 + 2);
                  if (*((float *)&v324 + 2) == 3.4028e38) {
                    float v233 = 0.0;
                  }
                  double v234 = v12 * v233 / v232;
                  double v214 = v217 + v234 * v229;
                  double v215 = v216 + v234 * v230;
                  double v220 = v218 + v234 * v231;
                }
                float32x2_t v202 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v214), *(float64x2_t *)(a2 + 1336), v215), *(float64x2_t *)(a2 + 1368), v220), v148/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v214+ *(double *)(a2 + 1360) * v215+ *(double *)(a2 + 1392) * v220)));
                float32x2_t v321 = v202;
              }
              if (v47 == 2)
              {
                if (LabelPoint)
                {
                  v310[1] = v161;
                  ggl::DebugConsole::drawSymbol(v310, *((_DWORD *)&kAttributeDrawOptions + 3 * v9 + 2));
                }
                if (v194 - v193 == 0.0) {
                  int v235 = 0;
                }
                else {
                  int v235 = v201;
                }
                if (v235 == 1)
                {
                  v310[1] = v202;
                  ggl::DebugConsole::drawSymbol(v310, *((_DWORD *)&kAttributeDrawOptions + 3 * v9 + 2));
                }
              }
              else if ((LabelPoint & v201) == 1)
              {
                uint64_t v47 = (uint64_t)v310;
                v310[13].f32[0] = fabsf(*(float *)(a2 + 176) * 5.0) * 0.5;
                v310[1] = v161;
                ggl::DebugConsole::drawLine((uint64_t)v310, (float *)&v321);
                v310[13].f32[0] = fabsf(*(float *)(a2 + 176)) * 0.5;
              }
              unint64_t v147 = v152;
              if (v154 && !atomic_fetch_add(&v154->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v154->__on_zero_shared)(v154);
                std::__shared_weak_count::__release_weak(v154);
              }
              unint64_t v236 = v341;
              a3 = v310;
              if (v341 && !atomic_fetch_add(&v341->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v236->__on_zero_shared)(v236);
                std::__shared_weak_count::__release_weak(v236);
              }
              double v5 = v151;
              uint64_t v149 = v319;
            }
            v46 += 3;
          }
          while (v46 != v149);
          int v46 = v336;
          if (v336)
          {
LABEL_245:
            uint64_t v337 = v46;
            (*(void (**)(uint64_t, __n128 *, uint64_t))(*(void *)v339 + 40))(v339, v46, v338 - (void)v46);
          }
        }
        ++v147;
        double v5 = *v306;
        if (v147 >= (uint64_t)(*v304 - (void)*v306) >> 3) {
          break;
        }
        md::LabelLine::attributes((unint64_t *)&v336, *(void **)&v5[8 * v147], &v325, v302);
      }
    }
  }
LABEL_246:
  uint64_t v4 = (uint64_t)v326;
  if (v326 && !atomic_fetch_add(&v326->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v4);
  }
  uint64_t v237 = *(std::__shared_weak_count **)(*v305 + 8);
  if (!v237 || (uint64_t v238 = std::__shared_weak_count::lock(v237)) == 0)
  {
LABEL_328:
    std::__throw_bad_weak_ptr[abi:nn180100]();
    goto LABEL_329;
  }
  uint64_t v4 = (uint64_t)v238;
  LODWORD(v46) = (int)*(float *)(a2 + 472);
  uint64_t v239 = (unsigned __int8 *)*v305;
  if (v46 >= 0x17) {
    uint64_t v240 = 23;
  }
  else {
    uint64_t v240 = v46;
  }
  unsigned int v241 = atomic_load(&v239[v240 + 224]);
  if (v241 == 254)
  {
    if (v239[289]) {
      unsigned int v242 = 24;
    }
    else {
      unsigned int v242 = 5;
    }
    unint64_t v243 = (unsigned __int8 *)*((void *)v239 + 16);
    uint64_t v244 = *((void *)v239 + 17) - (void)v243;
    if (v244)
    {
      uint64_t v245 = 0;
      unint64_t v246 = v244 / 112;
      if (v246 <= 1) {
        uint64_t v247 = 1;
      }
      else {
        uint64_t v247 = v246;
      }
      unsigned int v241 = -1;
      float v248 = 1000.0;
      while (1)
      {
        int v250 = *v243;
        v243 += 112;
        int v249 = v250;
        if (v240 == v250) {
          break;
        }
        int v251 = v240 - v249;
        if (v251 >= 0) {
          unsigned int v252 = v251;
        }
        else {
          unsigned int v252 = -v251;
        }
        if (v252 <= v242)
        {
          float v253 = (float)v251;
          if (v251 < 0) {
            float v253 = (float)v251 * -0.8;
          }
          if (v253 < v248) {
            unsigned int v241 = v245;
          }
          float v248 = fminf(v253, v248);
        }
        if (v247 == ++v245) {
          goto LABEL_278;
        }
      }
      unsigned int v241 = v245;
    }
    else
    {
      unsigned int v241 = -1;
    }
LABEL_278:
    atomic_store(v241, &v239[v240 + 224]);
    if ((v241 & 0x80000000) != 0) {
      goto LABEL_311;
    }
  }
  else
  {
    unsigned int v241 = (char)v241;
    if ((char)v241 < 0) {
      goto LABEL_311;
    }
  }
  uint64_t v254 = *((void *)v239 + 16);
  if (v254)
  {
    uint64_t v255 = v254 + 112 * v241;
    unint64_t v13 = *((int *)a4 + 1);
    uint64_t v47 = *(void *)(v255 + 80);
    if (v13 < (*(void *)(v255 + 88) - v47) >> 3)
    {
      long long v322 = 0uLL;
      *(void *)&long long v323 = 0;
      unint64_t v9 = 0x1EB34D000;
      {
LABEL_282:
        *((void *)&v323 + 1) = *(void *)(v9 + 728);
        uint64_t v336 = 0;
        uint64_t v337 = 0;
        uint64_t v338 = 0;
        if ((atomic_load_explicit(v5, memory_order_acquire) & 1) == 0
        {
          operator new();
        }
        uint64_t v339 = *(void *)(v9 + 728);
        md::LineLabelPlacer::populateBlocks(v305, (int)v46, *(void **)(v47 + 8 * v13), (uint64_t *)&v322, &v336);
        a3[12].i32[0] = -16777216;
        double v256 = COERCE_DOUBLE(vmul_n_f32((float32x2_t)0x41A0000041800000, *(float *)(a2 + 176)));
        *(double *)&a3[4] = v256;
        uint64_t v258 = *((void *)&v322 + 1);
        for (uint64_t i = v322; i != v258; i += 216)
        {
          unint64_t v259 = *(void *)(i + 8);
          if (!v259
            || *(_DWORD *)(i + 48) != *(_DWORD *)(v259 + 252)
            || !*(void *)(i + 32)
            || *(__int16 *)(i + 42) < 0)
          {
            md::LabelLineResolvedPosition::moveOntoPathForZoom((md::LabelLineResolvedPosition *)(i + 8), *(unsigned __int8 *)(i + 172), v256);
            unint64_t v259 = *(void *)(i + 8);
          }
          unint64_t v340 = v259;
          uint64_t v260 = *(std::__shared_weak_count **)(i + 16);
          uint64_t v341 = v260;
          if (v260) {
            atomic_fetch_add_explicit(&v260->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          long long v342 = *(_OWORD *)(i + 24);
          unint64_t v343 = *(void *)(i + 40);
          int v344 = *(_DWORD *)(i + 48);
          *(void *)&long long v335 = 0;
          long long v334 = 0u;
          long long v333 = 0u;
          DWORD2(v335) = 2139095039;
          WORD6(v335) = 0;
          BYTE14(v335) = 0;
          if (md::LabelLinePosition::getLabelPoint((md::LabelLinePosition *)&v340, (md::LabelPoint *)&v333))
          {
            labelPointToWorldPoint((const md::LabelPoint *)&v333, (const LabelLayoutContext *)*(unsigned __int8 *)(a2 + 448), v12);
            a3[1] = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v311[6], *v311, v261), v311[2], v262), v311[4], v263), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v261+ *(double *)(a2 + 1360) * v262+ *(double *)(a2 + 1392) * v263)));
            ggl::DebugConsole::drawSymbol(a3, 1);
          }
          md::LabelLinePosition::offsetDistance((md::LabelLinePosition *)&v340, 0, *(double *)(i + 184) - *(double *)(i + 176));
          unint64_t v329 = 0;
          long long v327 = 0u;
          long long v328 = 0u;
          int v330 = 2139095039;
          __int16 v331 = 0;
          char v332 = 0;
          if (md::LabelLinePosition::getLabelPoint((md::LabelLinePosition *)&v340, (md::LabelPoint *)&v327))
          {
            labelPointToWorldPoint((const md::LabelPoint *)&v327, (const LabelLayoutContext *)*(unsigned __int8 *)(a2 + 448), v12);
            a3[1] = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v311[6], *v311, v264), v311[2], v265), v311[4], v266), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v264+ *(double *)(a2 + 1360) * v265+ *(double *)(a2 + 1392) * v266)));
            ggl::DebugConsole::drawSymbol(a3, 1);
          }
          std::string::size_type v267 = v341;
          if (v341 && !atomic_fetch_add(&v341->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v267->__on_zero_shared)(v267);
            std::__shared_weak_count::__release_weak(v267);
          }
        }
        a3[4] = vmul_n_f32((float32x2_t)0x4120000041000000, *(float *)(a2 + 176));
        if (v336)
        {
          uint64_t v337 = v336;
          (*(void (**)(uint64_t, __n128 *, uint64_t))(*(void *)v339 + 40))(v339, v336, v338 - (void)v336);
        }
        uint64_t v268 = v322;
        if ((void)v322)
        {
          uint64_t v269 = *((void *)&v322 + 1);
          uint64_t v270 = v322;
          if (*((void *)&v322 + 1) != (void)v322)
          {
            do
            {
              uint64_t v271 = *(std::__shared_weak_count **)(v269 - 200);
              if (v271 && !atomic_fetch_add(&v271->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *, uint64_t))v271->__on_zero_shared)(v271, v270);
                std::__shared_weak_count::__release_weak(v271);
              }
              v269 -= 216;
            }
            while (v269 != v268);
            uint64_t v270 = v322;
          }
          *((void *)&v322 + 1) = v268;
          (*(void (**)(void, uint64_t, void))(**((void **)&v323 + 1) + 40))(*((void *)&v323 + 1), v270, v323 - v270);
        }
        goto LABEL_311;
      }
LABEL_329:
        operator new();
      goto LABEL_282;
    }
  }
LABEL_311:
  if (!atomic_fetch_add((atomic_ullong *volatile)(v4 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 16))(v4);
    std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v4);
  }
  uint64_t v272 = *n128_u64;
  if (*n128_u64)
  {
    unsigned int v273 = *(_DWORD *)a4;
    uint64_t v274 = n128_u64;
    do
    {
      unsigned int v275 = *(_DWORD *)(v272 + 32);
      _CF = v275 >= v273;
      if (v275 >= v273) {
        uint64_t v277 = (uint64_t *)v272;
      }
      else {
        uint64_t v277 = (uint64_t *)(v272 + 8);
      }
      if (_CF) {
        uint64_t v274 = (void *)v272;
      }
      uint64_t v272 = *v277;
    }
    while (*v277);
    if (v274 != n128_u64 && v273 >= *((_DWORD *)v274 + 8))
    {
      a3[12].i32[0] = -65536;
      a3[13].f32[0] = fabsf(*(float *)(a2 + 176) * 4.0) * 0.5;
      uint64_t v278 = (const md::LabelPoint *)(*(uint64_t (**)(void))(*(void *)v274[5] + 56))(v274[5]);
      labelPointToWorldPoint(v278, (const LabelLayoutContext *)*(unsigned __int8 *)(a2 + 448), v12);
      float32x2_t v320 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v279), *(float64x2_t *)(a2 + 1336), v280), *(float64x2_t *)(a2 + 1368), v281), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v279+ *(double *)(a2 + 1360) * v280+ *(double *)(a2 + 1392) * v281)));
      uint64_t v282 = md::LabelPoint::mercatorPoint(v278);
      double v283 = *(double *)v282;
      unint64_t v284 = *(void *)(v282 + 8);
      double v285 = 40075017.0;
      if (!*(unsigned char *)(*v305 + 290)) {
        double v285 = 1.0;
      }
      double v286 = *v299 / v285;
      int v287 = *((_DWORD *)v278 + 10);
      uint64_t v341 = 0;
      *(void *)&long long v342 = 0;
      unint64_t v340 = 0;
      *((double *)&v342 + 1) = v286 + v283;
      unint64_t v343 = v284;
      int v344 = v287;
      __int16 v345 = 256;
      char v346 = 1;
      labelPointToWorldPoint((const md::LabelPoint *)&v340, (const LabelLayoutContext *)*(unsigned __int8 *)(a2 + 448), v12);
      float v291 = *(float *)(a2 + 176);
      float32x2_t v292 = vsub_f32(vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v311[6], *v311, v288), v311[2], v289), v311[4], v290), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v288+ *(double *)(a2 + 1360) * v289+ *(double *)(a2 + 1392) * v290))), v320);
      *(float *)&unsigned int v293 = v320.f32[0] + (float)(v291 * 50.0);
      float v294 = v320.f32[1] + (float)(v291 * 50.0);
      float v295 = sqrtf(vaddv_f32(vmul_f32(v292, v292))) + *(float *)&v293;
      *(float *)&long long v333 = v295;
      *((float *)&v333 + 1) = v294;
      a3[1].i32[0] = v293;
      a3[1].f32[1] = v294;
      ggl::DebugConsole::drawLine((uint64_t)a3, (float *)&v333);
      float v296 = v291 * 10.0;
      *(float *)&unsigned int v297 = v294 - (float)(v291 * 10.0);
      *(void *)&long long v327 = __PAIR64__(v297, v293);
      float32_t v298 = v294 + v296;
      a3[1].i32[0] = v293;
      a3[1].f32[1] = v298;
      ggl::DebugConsole::drawLine((uint64_t)a3, (float *)&v327);
      *(void *)&long long v322 = __PAIR64__(v297, LODWORD(v295));
      a3[1].f32[0] = v295;
      a3[1].f32[1] = v298;
      ggl::DebugConsole::drawLine((uint64_t)a3, (float *)&v322);
    }
  }
}

void sub_1A2136CEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40)
{
  uint64_t v43 = *(void *)(v41 - 240);
  if (v43)
  {
    *(void *)(v41 - 232) = v43;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v41 - 216) + 40))(*(void *)(v41 - 216), v43, *(void *)(v41 - 224) - v43);
  }
  if (a33)
  {
    uint64_t v44 = a34;
    uint64_t v45 = a33;
    if (a34 != a33)
    {
      do
      {
        int v46 = *(std::__shared_weak_count **)(v44 - 200);
        if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v46->__on_zero_shared)(v46, v45);
          std::__shared_weak_count::__release_weak(v46);
        }
        v44 -= 216;
      }
      while (v44 != a33);
      uint64_t v45 = a33;
    }
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a36 + 40))(a36, v45, a35 - v45);
  }
  if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  _Unwind_Resume(exception_object);
}

void labelPointToWorldPoint(const md::LabelPoint *this, const LabelLayoutContext *a2, double a3)
{
  if ((_BYTE)a2)
  {
    md::LabelPoint::mercatorPoint(this);
  }
  else
  {
    if (!*((unsigned char *)this + 44))
    {
      long double v4 = *((double *)this + 3) * 6.28318531;
      long double v5 = exp(*((double *)this + 4) * 6.28318531 + -3.14159265);
      double v6 = atan(v5) * 2.0 + -1.57079633;
      long double v7 = fmod(v4, 6.28318531);
      double v8 = fmod(v7 + 6.28318531, 6.28318531) + -3.14159265;
      __double2 v9 = __sincos_stret(v6);
      double v10 = 6378137.0 / sqrt(v9.__sinval * v9.__sinval * -0.00669437999 + 1.0);
      __double2 v11 = __sincos_stret(v8);
      *(double *)this = v10 * v9.__cosval * v11.__cosval;
      *((double *)this + 1) = v10 * v9.__cosval * v11.__sinval;
      *((double *)this + 2) = v9.__sinval * 0.99330562 * v10;
      *((unsigned char *)this + 44) = 1;
    }
    md::LabelPoint::geocentricNormal(this);
  }
}

uint64_t md::LineLabelFeature::containsPixel(uint64_t a1, uint64_t a2, float32x2_t *a3, float *a4, uint64_t a5)
{
  double v10 = *(double *)(*(void *)(a2 + 232) + 56);
  float v11 = *(float *)(a2 + 488);
  unsigned int v12 = (int)*(float *)(a2 + 472);
  unint64_t v13 = *(unsigned __int8 **)(a1 + 192);
  unsigned __int8 v14 = atomic_load(v13 + 80);
  if (v14) {
    md::LabelLineStore::consumeWorkUnits((md::LabelLineStore *)v13);
  }
  uint64_t v15 = *(void *)(a1 + 192);
  if (v12 >= 0x17) {
    uint64_t v16 = 23;
  }
  else {
    uint64_t v16 = v12;
  }
  unsigned int v17 = atomic_load((unsigned __int8 *)(v15 + 224 + v16));
  if (v17 == 254)
  {
    if (*(unsigned char *)(v15 + 289)) {
      unsigned int v18 = 24;
    }
    else {
      unsigned int v18 = 5;
    }
    uint64_t v19 = *(unsigned __int8 **)(v15 + 128);
    uint64_t v20 = *(void *)(v15 + 136) - (void)v19;
    if (v20)
    {
      uint64_t v21 = 0;
      unint64_t v22 = v20 / 112;
      if (v22 <= 1) {
        uint64_t v23 = 1;
      }
      else {
        uint64_t v23 = v22;
      }
      unsigned int v17 = -1;
      float v24 = 1000.0;
      while (1)
      {
        int v26 = *v19;
        v19 += 112;
        int v25 = v26;
        if (v16 == v26) {
          break;
        }
        int v27 = v16 - v25;
        if (v27 >= 0) {
          unsigned int v28 = v27;
        }
        else {
          unsigned int v28 = -v27;
        }
        if (v28 <= v18)
        {
          float v29 = (float)v27;
          if (v27 < 0) {
            float v29 = (float)v27 * -0.8;
          }
          if (v29 < v24) {
            unsigned int v17 = v21;
          }
          float v24 = fminf(v29, v24);
        }
        if (v23 == ++v21) {
          goto LABEL_30;
        }
      }
      unsigned int v17 = v21;
    }
    else
    {
      unsigned int v17 = -1;
    }
LABEL_30:
    atomic_store(v17, (unsigned __int8 *)(v15 + 224 + v16));
    if ((v17 & 0x80000000) != 0) {
      return 0;
    }
  }
  else
  {
    unsigned int v17 = (char)v17;
    if ((char)v17 < 0) {
      return 0;
    }
  }
  uint64_t v30 = *(void *)(v15 + 128);
  if (!v30) {
    return 0;
  }
  uint64_t v31 = v30 + 112 * v17;
  uint64_t v32 = *(void *)(v31 + 80);
  uint64_t v125 = (uint64_t *)(v31 + 80);
  char v124 = (void *)(v31 + 88);
  if (*(void *)(v31 + 88) == v32) {
    return 0;
  }
  float v123 = a4;
  char v129 = 0;
  unint64_t v130 = 0;
  uint64_t v128 = 0;
  unint64_t v33 = 0;
  double v34 = v10 * v11;
  float v131 = *a4 * *a4;
  double v35 = 1.0;
  uint64_t v126 = a3;
  do
  {
    uint64_t v36 = *(double **)(a1 + 192);
    float v37 = (std::__shared_weak_count *)*((void *)v36 + 1);
    if (!v37 || (double v38 = *v36, (v39 = std::__shared_weak_count::lock(v37)) == 0))
    {
      std::__throw_bad_weak_ptr[abi:nn180100]();
      float32x2_t v122 = v121;
      std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v145);
      std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v142);
      _Unwind_Resume(v122);
    }
    unsigned int v40 = v39;
    uint64_t v41 = 0;
    double v145 = v38;
    uint64_t v146 = v39;
    double v142 = 0.0;
    double v143 = 0.0;
    double v42 = *(double *)(v32 + 8 * v33);
    if (*(void *)(*(void *)&v42 + 16) == *(void *)(*(void *)&v42 + 8)) {
      uint64_t v43 = 0;
    }
    else {
      uint64_t v43 = *(unsigned char **)(*(void *)&v42 + 8);
    }
    if (!v43[8]) {
      uint64_t v41 = ((*(unsigned int (**)(void))(**(void **)v43 + 16))() << 16) - 0x10000;
    }
    double v148 = v38;
    uint64_t v149 = v40;
    atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
    double v150 = v42;
    uint64_t v152 = v41;
    int v153 = *(_DWORD *)(*(void *)&v38 + 252);
    if (*(void *)(*(void *)&v42 + 16) == *(void *)(*(void *)&v42 + 8)) {
      uint64_t v44 = 0;
    }
    else {
      uint64_t v44 = *(void **)(*(void *)&v42 + 8);
    }
    long long v151 = v44;
    if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
    uint64_t v45 = *(std::__shared_weak_count **)&v143;
    if (v143 != 0.0 && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v143 + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
    int v46 = (const md::LabelPoint *)(*(uint64_t (**)(void, void))(*(void *)*v151 + 24))(*v151, SWORD1(v152));
    labelPointToWorldPoint(v46, (const LabelLayoutContext *)*(unsigned __int8 *)(a2 + 448), v34);
    double v132 = v47;
    double v135 = v48;
    double v145 = v47;
    uint64_t v146 = *(std::__shared_weak_count **)&v48;
    double v138 = v49;
    double v147 = v49;
    BOOL isDistanceClipped = md::LabelLayoutContext::isDistanceClipped(a2 + 440, (uint64_t)&v145);
    if (!isDistanceClipped) {
      float32x2_t v5 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v132), *(float64x2_t *)(a2 + 1336), v135), *(float64x2_t *)(a2 + 1368), v138), v35/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v132+ *(double *)(a2 + 1360) * v135+ *(double *)(a2 + 1392) * v138)));
    }
    while (1)
    {
      LODWORD(v142) = -1;
      if (!md::LabelLinePosition::getPointCoordinateAtOffset((uint64_t)&v148, 1, (uint64_t)&v142)) {
        break;
      }
      uint64_t v54 = *(void *)(*(void *)(*(void *)&v150 + 8) + 16 * SLOWORD(v142));
      uint64_t v55 = (*(uint64_t (**)(uint64_t, void))(*(void *)v54 + 24))(v54, SWORD1(v142));
      uint64_t v56 = v55;
      if (*(unsigned char *)(a2 + 448))
      {
        if (*(unsigned char *)(v55 + 45)) {
          _ZF = 1;
        }
        else {
          _ZF = *(unsigned char *)(v55 + 46) == 0;
        }
        if (!_ZF)
        {
          long double v58 = *(double *)v55;
          long double v59 = *(double *)(v55 + 8);
          long double v60 = *(double *)(v55 + 16);
          double v61 = sqrt(v58 * v58 + v59 * v59);
          long double v62 = atan2(v60, v61 * 0.996647189);
          long double v139 = atan2(v59, v58);
          double v63 = v62;
          double v35 = 1.0;
          __double2 v64 = __sincos_stret(v63);
          long double v65 = atan2(v60 + v64.__sinval * v64.__sinval * 42841.3115 * v64.__sinval, v61 + v64.__cosval * v64.__cosval * -42697.6727 * v64.__cosval);
          long double v66 = tan(v65 * 0.5 + 0.785398163);
          long double v67 = log(v66);
          v68.f64[0] = v139;
          v68.f64[1] = v67;
          __asm { FMOV            V1.2D, #0.5 }
          *(float64x2_t *)(v56 + 24) = vmlaq_f64(_Q1, (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL), v68);
          *(unsigned char *)(v56 + 45) = 1;
        }
        double v74 = *(double *)(v56 + 24);
        double v73 = *(double *)(v56 + 32);
        float v75 = *(float *)(v56 + 40);
        if (v75 == 3.4028e38) {
          float v75 = 0.0;
        }
        double v76 = v34 * v75;
      }
      else
      {
        if (*(unsigned char *)(v55 + 44))
        {
          double v78 = *(double *)v55;
          double v77 = *(double *)(v55 + 8);
          double v79 = *(double *)(v55 + 16);
        }
        else
        {
          long double v80 = *(double *)(v55 + 24) * 6.28318531;
          long double v81 = exp(*(double *)(v55 + 32) * 6.28318531 + -3.14159265);
          double v82 = atan(v81) * 2.0 + -1.57079633;
          long double v83 = fmod(v80, 6.28318531);
          double v84 = fmod(v83 + 6.28318531, 6.28318531) + -3.14159265;
          __double2 v85 = __sincos_stret(v82);
          double v86 = 6378137.0 / sqrt(v35 + v85.__sinval * v85.__sinval * -0.00669437999);
          __double2 v87 = __sincos_stret(v84);
          double v78 = v86 * v85.__cosval * v87.__cosval;
          double v77 = v86 * v85.__cosval * v87.__sinval;
          *(double *)uint64_t v56 = v78;
          *(double *)(v56 + 8) = v77;
          double v79 = v85.__sinval * 0.99330562 * v86;
          *(double *)(v56 + 16) = v79;
          *(unsigned char *)(v56 + 44) = 1;
        }
        double v88 = v78 * 2.45817226e-14;
        double v89 = v77 * 2.45817226e-14;
        double v90 = v79 * 2.4747391e-14;
        double v91 = sqrt(v88 * v88 + v89 * v89 + v90 * v90);
        float v92 = *(float *)(v56 + 40);
        if (v92 == 3.4028e38) {
          float v92 = 0.0;
        }
        double v93 = v34 * v92 / v91;
        double v74 = v78 + v93 * v88;
        double v73 = v77 + v93 * v89;
        double v76 = v79 + v93 * v90;
      }
      double v136 = v74;
      double v140 = v73;
      double v142 = v74;
      double v143 = v73;
      double v133 = v76;
      double v144 = v76;
      BOOL v94 = md::LabelLayoutContext::isDistanceClipped(a2 + 440, (uint64_t)&v142);
      if (!v94)
      {
        float32x2_t v95 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v136), *(float64x2_t *)(a2 + 1336), v140), *(float64x2_t *)(a2 + 1368), v133), v35/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v136+ *(double *)(a2 + 1360) * v140+ *(double *)(a2 + 1392) * v133)));
        if (isDistanceClipped)
        {
          __int32 v96 = v95.i32[1];
          *(float *)&unsigned __int32 v97 = v131;
        }
        else
        {
          float32x2_t v98 = vsub_f32(v95, v5);
          float32x2_t v99 = vmul_f32(v98, v98);
          __int32 v96 = v95.i32[1];
          *(float *)&unsigned __int32 v97 = v131;
          if (vaddv_f32(v99) > 0.00000011921)
          {
            float32x2_t v100 = vmul_f32(vsub_f32(*v126, v5), v98);
            float32x2_t v101 = vsub_f32(*v126, vmla_n_f32(v5, v98, fminf(fmaxf(vdiv_f32(vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v100, 1), v100), vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v99, 1), v99)).f32[0], 0.0), 1.0)));
            float32x2_t v102 = vmul_f32(v101, v101);
            if (vaddv_f32(v102) < v131)
            {
              unsigned __int32 v97 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v102, 1), v102).u32[0];
              uint64_t v128 = (__int16)v152;
              __int32 v96 = v95.i32[1];
              char v129 = 1;
              unint64_t v130 = v33;
            }
          }
        }
        v95.i32[1] = v96;
        float32x2_t v5 = v95;
        float v131 = *(float *)&v97;
      }
      if (md::LabelLinePosition::getPointCoordinateAtOffset((uint64_t)&v148, 1, (uint64_t)&v152))
      {
        uint64_t v51 = *(void *)(*(void *)&v150 + 8);
        uint64_t v52 = *(void *)(*(void *)&v150 + 16) - v51;
        uint64_t v53 = (void *)(v51 + 16 * (__int16)v152);
        if ((__int16)v152 >= (unint64_t)(v52 >> 4)) {
          uint64_t v53 = 0;
        }
      }
      else
      {
        uint64_t v53 = 0;
      }
      long long v151 = v53;
      BOOL isDistanceClipped = v94;
    }
    BOOL v103 = v149;
    if (v149 && !atomic_fetch_add(&v149->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
      std::__shared_weak_count::__release_weak(v103);
    }
    ++v33;
    uint64_t v32 = *v125;
  }
  while (v33 < (*v124 - *v125) >> 3);
  if ((v129 & 1) == 0) {
    return 0;
  }
  *(_DWORD *)(a5 + 8) = v128;
  uint64_t v104 = *(void *)(*(void *)(*(void *)(v32 + 8 * v130) + 8) + 16 * v128);
  if (*(unsigned char *)(v104 + 32)) {
    uint64_t v105 = 0;
  }
  else {
    uint64_t v105 = *(void *)(v104 + 16);
  }
  float v107 = v131;
  *(void *)(a5 + 16) = v105;
  *(_DWORD *)a5 = 0;
  *(_DWORD *)(a5 + 4) = v130;
  char v108 = *(void **)(a1 + 224);
  if (v108 != (void *)(a1 + 232))
  {
    float v109 = *v123 * *v123;
    do
    {
      uint64_t v110 = (*(uint64_t (**)(void))(*(void *)v108[5] + 200))(v108[5]);
      uint64_t v112 = v110;
      if (!*(void *)v110
        || *(_DWORD *)(v110 + 40) != *(_DWORD *)(*(void *)v110 + 252)
        || !*(void *)(v110 + 24)
        || *(__int16 *)(v110 + 34) < 0)
      {
        md::LabelLineResolvedPosition::moveOntoPathForZoom((md::LabelLineResolvedPosition *)v110, *(unsigned __int8 *)(v110 + 164), v111);
      }
      float v107 = v131;
      if (*(void *)(v112 + 16) == *(void *)(v32 + 8 * v130))
      {
        int v113 = (const md::LabelPoint *)(*(uint64_t (**)(void))(*(void *)v108[5] + 56))(v108[5]);
        labelPointToWorldPoint(v113, (const LabelLayoutContext *)*(unsigned __int8 *)(a2 + 448), v34);
        double v134 = v114;
        double v137 = v115;
        double v148 = v114;
        uint64_t v149 = *(std::__shared_weak_count **)&v115;
        double v141 = v116;
        double v150 = v116;
        if (md::LabelLayoutContext::isDistanceClipped(a2 + 440, (uint64_t)&v148))
        {
          float v107 = v131;
        }
        else
        {
          float32x2_t v117 = vsub_f32(*v126, vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v134), *(float64x2_t *)(a2 + 1336), v137), *(float64x2_t *)(a2 + 1368), v141), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v134+ *(double *)(a2 + 1360) * v137+ *(double *)(a2 + 1392) * v141))));
          float v118 = vaddv_f32(vmul_f32(v117, v117));
          float v107 = v131;
          if (v118 < v109)
          {
            *(_DWORD *)a5 = *((_DWORD *)v108 + 8);
            float v109 = v118;
          }
        }
      }
      double v119 = (void *)v108[1];
      if (v119)
      {
        do
        {
          double v120 = v119;
          double v119 = (void *)*v119;
        }
        while (v119);
      }
      else
      {
        do
        {
          double v120 = (void *)v108[2];
          _ZF = *v120 == (void)v108;
          char v108 = v120;
        }
        while (!_ZF);
      }
      char v108 = v120;
    }
    while (v120 != (void *)(a1 + 232));
  }
  float *v123 = sqrtf(v107);
  return 1;
}

void sub_1A2137BDC(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 - 200);
  _Unwind_Resume(a1);
}

void sub_1A2137D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t ggl::FragmentedPool<ggl::LandmarkDepth::BuildingPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  long double v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  long double v4 = *(void **)a1;
  float32x2_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  __double2 v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::LandmarkFlat::LandmarkPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  long double v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  long double v4 = *(void **)a1;
  float32x2_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  __double2 v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::SpecularLandmark::LandmarkPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  long double v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  long double v4 = *(void **)a1;
  float32x2_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  __double2 v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::FoggedSpecularLandmark::LandmarkPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  long double v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  long double v4 = *(void **)a1;
  float32x2_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  __double2 v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::LandmarkDepth::BuildingPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::LandmarkDepth::BuildingPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::LandmarkFlat::LandmarkPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::LandmarkFlat::LandmarkPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::SpecularLandmark::LandmarkPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::SpecularLandmark::LandmarkPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::FoggedSpecularLandmark::LandmarkPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::FoggedSpecularLandmark::LandmarkPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::DiffuseLandmark::BuildingPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  long double v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  long double v4 = *(void **)a1;
  float32x2_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  __double2 v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  long double v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  long double v4 = *(void **)a1;
  float32x2_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  __double2 v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *std::function<void ()(ggl::DiffuseLandmark::BuildingPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::DiffuseLandmark::BuildingPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::FoggedSpecularLandmark::LandmarkPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::FoggedSpecularLandmark::LandmarkPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::LandmarkFlat::LandmarkPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::LandmarkFlat::LandmarkPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::SpecularLandmark::LandmarkPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::SpecularLandmark::LandmarkPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::DiffuseLandmark::BuildingPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::DiffuseLandmark::BuildingPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::LandmarkDepth::BuildingPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::LandmarkDepth::BuildingPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_6,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_6>,ggl::RenderItem * ()(void)>::operator()()
{
}

void *std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_6,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_6>,ggl::RenderItem * ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF576830;
  return result;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_6,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_6>,ggl::RenderItem * ()(void)>::~__func()
{
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21FoggedDiffuseLandmark21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57B940;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21FoggedDiffuseLandmark21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57B940;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_21FoggedDiffuseLandmark21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_5,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_5>,ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A213991C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_ullong *a12, atomic_ullong *a13, atomic_ullong *a14)
{
  if (!atomic_fetch_add(a12, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (!atomic_fetch_add(a13, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (!atomic_fetch_add(a14, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_5,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_5>,ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup * ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5767E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_5,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_5>,ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5767E8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_5,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_5>,ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup * ()(void)>::~__func()
{
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_15DiffuseLandmark21BuildingPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57AFF8;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_15DiffuseLandmark21BuildingPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF57AFF8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_15DiffuseLandmark21BuildingPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_4,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_4>,ggl::DiffuseLandmark::BuildingPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A213A104(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_ullong *a12, atomic_ullong *a13, atomic_ullong *a14)
{
  if (!atomic_fetch_add(a12, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (!atomic_fetch_add(a13, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (!atomic_fetch_add(a14, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_4,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_4>,ggl::DiffuseLandmark::BuildingPipelineSetup * ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF5767A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_4,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_4>,ggl::DiffuseLandmark::BuildingPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF5767A0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_4,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_4>,ggl::DiffuseLandmark::BuildingPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_22FoggedSpecularLandmark21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF57BAF0;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_22FoggedSpecularLandmark21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_3,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_3>,ggl::FoggedSpecularLandmark::LandmarkPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A213A8C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_ullong *a12, atomic_ullong *a13, atomic_ullong *a14)
{
  if (!atomic_fetch_add(a12, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (!atomic_fetch_add(a13, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (!atomic_fetch_add(a14, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_3,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_3>,ggl::FoggedSpecularLandmark::LandmarkPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF576758;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_3,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_3>,ggl::FoggedSpecularLandmark::LandmarkPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_16SpecularLandmark21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF57B1A8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_16SpecularLandmark21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_2,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_2>,ggl::SpecularLandmark::LandmarkPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A213B060(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, atomic_ullong *a12, atomic_ullong *a13, atomic_ullong *a14)
{
  if (!atomic_fetch_add(a12, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  if (!atomic_fetch_add(a13, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (!atomic_fetch_add(a14, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  _Unwind_Resume(exception_object);
}

__n128 std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_2,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_2>,ggl::SpecularLandmark::LandmarkPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF576710;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_2,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_2>,ggl::SpecularLandmark::LandmarkPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_12LandmarkFlat21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF57AD28;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_12LandmarkFlat21LandmarkPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_1,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_1>,ggl::LandmarkFlat::LandmarkPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A213B64C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, atomic_ullong *a9, atomic_ullong *a10)
{
  if (!atomic_fetch_add(a9, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  if (!atomic_fetch_add(a10, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  _Unwind_Resume(exception_object);
}

void *std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_1,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_1>,ggl::LandmarkFlat::LandmarkPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF5766C8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_1,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_1>,ggl::LandmarkFlat::LandmarkPipelineSetup * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_13LandmarkDepth21BuildingPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF57AD70;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_13LandmarkDepth21BuildingPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_0,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_0>,ggl::LandmarkDepth::BuildingPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_0,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_0>,ggl::LandmarkDepth::BuildingPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF576680;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_0,std::allocator<md::LandmarkRenderResources::LandmarkRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,std::shared_ptr<ggl::ConstantDataTyped<ggl::Building::Fade>> &)::$_0>,ggl::LandmarkDepth::BuildingPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::FoggedDiffuseLandmark::LandmarkPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FoggedDiffuseLandmark::LandmarkPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5884E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FoggedDiffuseLandmark::LandmarkPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5884E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::DiffuseLandmark::BuildingPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DiffuseLandmark::BuildingPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584070;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DiffuseLandmark::BuildingPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584070;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::FoggedSpecularLandmark::LandmarkPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::FoggedSpecularLandmark::LandmarkPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5886A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::FoggedSpecularLandmark::LandmarkPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5886A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::SpecularLandmark::LandmarkPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::SpecularLandmark::LandmarkPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585880;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::SpecularLandmark::LandmarkPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585880;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::LandmarkFlat::LandmarkPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::LandmarkFlat::LandmarkPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5837E8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::LandmarkFlat::LandmarkPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5837E8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::LandmarkDepth::BuildingPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::LandmarkDepth::BuildingPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5839A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::LandmarkDepth::BuildingPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5839A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LandmarkRenderResources::~LandmarkRenderResources(md::LandmarkRenderResources *this)
{
  uint64_t v2 = (void *)*((void *)this + 42);
  if (v2)
  {
    *((void *)this + 43) = v2;
    operator delete(v2);
  }
  uint64_t v3 = *((void *)this + 38);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 39);
    uint64_t v5 = *((void *)this + 38);
    if (v4 != v3)
    {
      uint64_t v6 = *((void *)this + 39);
      do
      {
        uint64_t v8 = *(void **)(v6 - 24);
        v6 -= 24;
        uint64_t v7 = v8;
        if (v8)
        {
          *(void *)(v4 - 16) = v7;
          operator delete(v7);
        }
        uint64_t v4 = v6;
      }
      while (v6 != v3);
      uint64_t v5 = *((void *)this + 38);
    }
    *((void *)this + 39) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 41) + 40))(*((void *)this + 41), v5, *((void *)this + 40) - v5);
  }
  __double2 v9 = (void *)*((void *)this + 35);
  if (v9)
  {
    *((void *)this + 36) = v9;
    operator delete(v9);
  }
  double v10 = (std::__shared_weak_count *)*((void *)this + 33);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    float v11 = (std::__shared_weak_count *)*((void *)this + 31);
    if (!v11) {
      goto LABEL_19;
    }
  }
  else
  {
    float v11 = (std::__shared_weak_count *)*((void *)this + 31);
    if (!v11) {
      goto LABEL_19;
    }
  }
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_19:
  unsigned int v12 = (std::__shared_weak_count *)*((void *)this + 29);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    unint64_t v13 = (std::__shared_weak_count *)*((void *)this + 27);
    if (!v13) {
      goto LABEL_25;
    }
  }
  else
  {
    unint64_t v13 = (std::__shared_weak_count *)*((void *)this + 27);
    if (!v13) {
      goto LABEL_25;
    }
  }
  if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
LABEL_25:
  unsigned __int8 v14 = (std::__shared_weak_count *)*((void *)this + 25);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 23);
    if (!v15) {
      goto LABEL_31;
    }
  }
  else
  {
    uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 23);
    if (!v15) {
      goto LABEL_31;
    }
  }
  if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
LABEL_31:
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
    unsigned int v17 = (std::__shared_weak_count *)*((void *)this + 19);
    if (!v17) {
      goto LABEL_37;
    }
  }
  else
  {
    unsigned int v17 = (std::__shared_weak_count *)*((void *)this + 19);
    if (!v17) {
      goto LABEL_37;
    }
  }
  if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
LABEL_37:
  unsigned int v18 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
    uint64_t v19 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v19) {
      goto LABEL_43;
    }
  }
  else
  {
    uint64_t v19 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v19) {
      goto LABEL_43;
    }
  }
  if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
LABEL_43:
  uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  uint64_t v21 = *((void *)this + 11);
  *((void *)this + 11) = 0;
  if (v21)
  {
    uint64_t v22 = ggl::FragmentedPool<ggl::RenderItem>::~FragmentedPool(v21);
    MEMORY[0x1A6239270](v22, 0x10A0C40D234DDC7);
  }
  uint64_t v23 = *((void *)this + 10);
  *((void *)this + 10) = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  uint64_t v24 = *((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  uint64_t v25 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  uint64_t v26 = *((void *)this + 7);
  *((void *)this + 7) = 0;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  uint64_t v27 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  uint64_t v28 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v28)
  {
    uint64_t v29 = ggl::FragmentedPool<ggl::FoggedSpecularLandmark::LandmarkPipelineSetup>::~FragmentedPool(v28);
    MEMORY[0x1A6239270](v29, 0x10A0C40D234DDC7);
  }
  uint64_t v30 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v30)
  {
    uint64_t v31 = ggl::FragmentedPool<ggl::FoggedDiffuseLandmark::LandmarkPipelineSetup>::~FragmentedPool(v30);
    MEMORY[0x1A6239270](v31, 0x10A0C40D234DDC7);
  }
  uint64_t v32 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v32)
  {
    uint64_t v33 = ggl::FragmentedPool<ggl::LandmarkFlat::LandmarkPipelineSetup>::~FragmentedPool(v32);
    MEMORY[0x1A6239270](v33, 0x10A0C40D234DDC7);
  }
  uint64_t v34 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v34)
  {
    uint64_t v35 = ggl::FragmentedPool<ggl::SpecularLandmark::LandmarkPipelineSetup>::~FragmentedPool(v34);
    MEMORY[0x1A6239270](v35, 0x10A0C40D234DDC7);
  }
  uint64_t v36 = *((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v36)
  {
    uint64_t v37 = ggl::FragmentedPool<ggl::DiffuseLandmark::BuildingPipelineSetup>::~FragmentedPool(v36);
    MEMORY[0x1A6239270](v37, 0x10A0C40D234DDC7);
  }
  uint64_t v38 = *(void *)this;
  *(void *)this = 0;
  if (v38)
  {
    uint64_t v39 = ggl::FragmentedPool<ggl::LandmarkDepth::BuildingPipelineSetup>::~FragmentedPool(v38);
    MEMORY[0x1A6239270](v39, 0x10A0C40D234DDC7);
  }
}

void md::RealisticSatelliteMapEngineMode::~RealisticSatelliteMapEngineMode(md::RealisticSatelliteMapEngineMode *this)
{
  md::MapEngineMode::~MapEngineMode(this);
  JUMPOUT(0x1A6239270);
}

md::RealisticSatelliteMapEngineMode *md::RealisticSatelliteMapEngineMode::RealisticSatelliteMapEngineMode(md::RealisticSatelliteMapEngineMode *this)
{
  uint64_t v2 = md::MapEngineMode::MapEngineMode((uint64_t)this, 8);
  *(void *)uint64_t v2 = &unk_1EF542230;
  *(_WORD *)(v2 + 224) = 257;
  if (!*(unsigned char *)(v2 + 64)) {
    *((unsigned char *)this + 64) = 1;
  }
  *((void *)this + 9) = 0x3FE0C152382D7365;
  *(void *)this = &unk_1EF54D3A0;
  *((unsigned char *)this + 49) = 0;
  *((_DWORD *)this + 13) = 21;
  LOBYTE(v6) = 0;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 0, &v6)+ 17) = 0;
  LOBYTE(v6) = 1;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 1u, &v6)+ 17) = 0;
  LOBYTE(v6) = 4;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 4u, &v6)+ 17) = 0;
  LOBYTE(v6) = 6;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 6u, &v6)+ 17) = 0;
  LOBYTE(v6) = 7;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 7u, &v6)+ 17) = 0;
  LOBYTE(v6) = 5;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 5u, &v6)+ 17) = 1;
  LOBYTE(v6) = 3;
  *((unsigned char *)std::__hash_table<std::__hash_value_type<unsigned char,md::DataRequirement>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,md::DataRequirement>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,md::DataRequirement>>>::__emplace_unique_key_args<unsigned char,std::piecewise_construct_t const&,std::tuple<unsigned char const&>,std::tuple<>>((uint64_t)this + 144, 3u, &v6)+ 17) = 2;
  LODWORD(v6) = 65576;
  *(_DWORD *)((char *)std::__hash_table<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,gdc::IntTypeHash<md::MapDataType,unsigned short>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,md::MapDataTypeState>,std::equal_to<md::MapDataType>,gdc::IntTypeHash<md::MapDataType,unsigned short>,true>,std::allocator<std::__hash_value_type<md::MapDataType,md::MapDataTypeState>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((uint64_t)this + 80, 0x28u, &v6)+ 18) = 65538;
  uint64_t v21 = 0x79FE0BD9535D5C4DLL;
  uint64_t v22 = "md::AnchorLogic]";
  v23[0] = 15;
  *(void *)&long long v18 = 0x63B6FE00C0848868;
  *((void *)&v18 + 1) = "md::AnchorContext]";
  uint64_t v19 = 17;
  char v20 = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 2;
  long long v7 = xmmword_1E5A97998;
  long long v8 = unk_1E5A979A8;
  long long v9 = xmmword_1E5A979B8;
  *(void *)&long long v15 = &v16;
  *((void *)&v15 + 1) = 1;
  long long v16 = xmmword_1E5A98030;
  uint64_t v17 = 21;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v21, &v18, 0, (uint64_t)&v6, (uint64_t)&v15);
  *(void *)&long long v18 = 0x8E629317B3523E63;
  *((void *)&v18 + 1) = "md::CameraLogic]";
  uint64_t v19 = 15;
  *(void *)&long long v15 = 0x1AF456233693CD46;
  *((void *)&v15 + 1) = "md::CameraContext]";
  *(void *)&long long v16 = 17;
  BYTE8(v16) = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 1;
  long long v7 = xmmword_1E5A979C8;
  *(void *)&long long v8 = 20;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v18, &v15, 0, (uint64_t)&v6, (uint64_t)&v21);
  uint64_t v21 = 0x17767EADC5B287BLL;
  uint64_t v22 = "md::ElevationLogic]";
  v23[0] = 18;
  *(void *)&long long v18 = 0x8BD499FBD96FBB9ELL;
  *((void *)&v18 + 1) = "md::ElevationContext]";
  uint64_t v19 = 20;
  char v20 = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 2;
  long long v7 = xmmword_1E5A97A70;
  long long v8 = unk_1E5A97A80;
  long long v9 = xmmword_1E5A97A90;
  *(void *)&long long v15 = &v16;
  *((void *)&v15 + 1) = 1;
  long long v16 = xmmword_1E5A97AA0;
  uint64_t v17 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v21, &v18, 0, (uint64_t)&v6, (uint64_t)&v15);
  uint64_t v21 = 0x4AC7AB7561675F6;
  uint64_t v22 = "md::GridLogic]";
  v23[0] = 13;
  *(void *)&long long v18 = 0x336A901A15BB7353;
  *((void *)&v18 + 1) = "md::GridContext]";
  uint64_t v19 = 15;
  char v20 = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 1;
  long long v7 = xmmword_1E5A97DD0;
  *(void *)&long long v8 = 21;
  *(void *)&long long v15 = &v16;
  *((void *)&v15 + 1) = 1;
  long long v16 = xmmword_1E5A97CE0;
  uint64_t v17 = 24;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v21, &v18, 0, (uint64_t)&v6, (uint64_t)&v15);
  *(void *)&long long v15 = 0x5CBBA028798243FLL;
  *((void *)&v15 + 1) = "md::RouteOverlayLogic]";
  *(void *)&long long v16 = 21;
  *(void *)&long long v6 = 0x13043386C0978CC2;
  *((void *)&v6 + 1) = "md::RouteOverlayContext]";
  *(void *)&long long v7 = 23;
  BYTE8(v7) = 1;
  *(void *)&long long v18 = &v19;
  *((void *)&v18 + 1) = 0;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v15, &v6, 0, (uint64_t)&v18, (uint64_t)&v21);
  *(void *)&long long v18 = 0xAF46DE79C836B0D8;
  *((void *)&v18 + 1) = "md::TileSelectionLogic]";
  uint64_t v19 = 22;
  *(void *)&long long v15 = 0x64780CBD71DF7CF5;
  *((void *)&v15 + 1) = "md::TileSelectionContext]";
  *(void *)&long long v16 = 24;
  BYTE8(v16) = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 3;
  long long v9 = xmmword_1E5A97CB8;
  long long v10 = unk_1E5A97CC8;
  *(void *)&long long v11 = 21;
  long long v7 = xmmword_1E5A97C98;
  long long v8 = unk_1E5A97CA8;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v18, &v15, 0, (uint64_t)&v6, (uint64_t)&v21);
  uint64_t v3 = 0xCBF29CE484222325;
  uint64_t v4 = 0x26u;
  do
    uint64_t v3 = 0x100000001B3 * (v3 ^ aStdStringViewG_928[v4++]);
  while (v4 != 368);
  uint64_t v21 = v3;
  uint64_t v22 = "md::TileDependencyLogicImpl<md::TileDependencies<>, md::TileDependencies<md::TileDependency<md::MapDataType::Flyover, md::FlyoverTileDataResolverContext>, md::TileDependency<md::MapDataType::FlyoverMetadata, md::FlyoverTileDataResolverContext>, md::TileDependency<md::MapDataType::FlyoverDsm, md::FlyoverTileDataResolverContext>>>]";
  v23[0] = 330;
  *(void *)&long long v18 = 0x8677AD8BA9352C1DLL;
  *((void *)&v18 + 1) = "md::ResolvedTileSelectionContext]";
  uint64_t v19 = 32;
  char v20 = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 1;
  long long v7 = xmmword_1E5A97CE0;
  *(void *)&long long v8 = 24;
  *(void *)&long long v15 = &v16;
  *((void *)&v15 + 1) = 1;
  long long v16 = xmmword_1E5A97CF8;
  uint64_t v17 = 34;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v21, &v18, 0, (uint64_t)&v6, (uint64_t)&v15);
  *(void *)&long long v18 = 0x87BA2765F9E38E05;
  *((void *)&v18 + 1) = "md::PendingSceneLogic]";
  uint64_t v19 = 21;
  *(void *)&long long v15 = 0x9F2276D081C2CB20;
  *((void *)&v15 + 1) = "md::PendingSceneContext]";
  *(void *)&long long v16 = 23;
  BYTE8(v16) = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 5;
  long long v11 = xmmword_1E5A97D50;
  long long v12 = *(_OWORD *)&off_1E5A97D60;
  long long v13 = xmmword_1E5A97D70;
  uint64_t v14 = 25;
  long long v7 = xmmword_1E5A97D10;
  long long v8 = unk_1E5A97D20;
  long long v9 = xmmword_1E5A97D30;
  long long v10 = unk_1E5A97D40;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v18, &v15, 0, (uint64_t)&v6, (uint64_t)&v21);
  uint64_t v21 = 0x2B7C4502BD3C99C6;
  uint64_t v22 = "md::ResolvedSceneLogic]";
  v23[0] = 22;
  *(void *)&long long v18 = 0x99BED48DEFBBD82BLL;
  *((void *)&v18 + 1) = "md::SceneContext]";
  uint64_t v19 = 16;
  char v20 = 1;
  *(void *)&long long v15 = &v16;
  *((void *)&v15 + 1) = 1;
  long long v16 = xmmword_1E5A97DB8;
  uint64_t v17 = 23;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 2;
  long long v7 = xmmword_1E5A97D88;
  long long v8 = unk_1E5A97D98;
  long long v9 = xmmword_1E5A97DA8;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v21, &v18, 0, (uint64_t)&v15, (uint64_t)&v6);
  *(void *)&long long v15 = 0xD2443A61CED86C69;
  *((void *)&v15 + 1) = "md::SettingsLogic]";
  *(void *)&long long v16 = 17;
  *(void *)&long long v6 = 0xC97B9E962ADF4AD4;
  *((void *)&v6 + 1) = "md::SettingsContext]";
  *(void *)&long long v7 = 19;
  BYTE8(v7) = 1;
  *(void *)&long long v18 = &v19;
  *((void *)&v18 + 1) = 0;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v15, &v6, 0, (uint64_t)&v18, (uint64_t)&v21);
  *(void *)&long long v15 = 0x2FED70A4459DFCA1;
  *((void *)&v15 + 1) = "md::StyleLogic]";
  *(void *)&long long v16 = 14;
  *(void *)&long long v6 = 0xE42D19AFCA302E68;
  *((void *)&v6 + 1) = "md::StyleLogicContext]";
  *(void *)&long long v7 = 21;
  BYTE8(v7) = 1;
  *(void *)&long long v18 = &v19;
  *((void *)&v18 + 1) = 0;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v15, &v6, 0, (uint64_t)&v18, (uint64_t)&v21);
  uint64_t v21 = 0x20A1ED17D78F322BLL;
  uint64_t v22 = "md::LabelsLogic]";
  v23[0] = 15;
  *(void *)&long long v18 = 0xA588623CD4116DAELL;
  *((void *)&v18 + 1) = "md::LabelsContext]";
  uint64_t v19 = 17;
  char v20 = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 1;
  long long v7 = xmmword_1E5A97DD0;
  *(void *)&long long v8 = 21;
  *(void *)&long long v15 = &v16;
  *((void *)&v15 + 1) = 1;
  long long v16 = xmmword_1E5A97DE8;
  uint64_t v17 = 25;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v21, &v18, 0, (uint64_t)&v6, (uint64_t)&v15);
  *(void *)&long long v15 = 0x90C2E4CBBB63E301;
  *((void *)&v15 + 1) = "md::LayerDataLogic]";
  *(void *)&long long v16 = 18;
  *(void *)&long long v6 = 0x7851AF310F49C988;
  *((void *)&v6 + 1) = "md::LayerDataLogicContext]";
  *(void *)&long long v7 = 25;
  BYTE8(v7) = 1;
  *(void *)&long long v18 = &v19;
  *((void *)&v18 + 1) = 0;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v15, &v6, 0, (uint64_t)&v18, (uint64_t)&v21);
  *(void *)&long long v18 = 0x8B45D3D7944796A2;
  *((void *)&v18 + 1) = "md::PendingRegistryLogic]";
  uint64_t v19 = 24;
  *(void *)&long long v15 = 0xA8300AA8F44B09FFLL;
  *((void *)&v15 + 1) = "md::PendingRegistryContext]";
  *(void *)&long long v16 = 26;
  BYTE8(v16) = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 1;
  long long v7 = xmmword_1E5A97DB8;
  *(void *)&long long v8 = 23;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v18, &v15, 0, (uint64_t)&v6, (uint64_t)&v21);
  *(void *)&long long v18 = 0xBDB8C71631E0AA6CLL;
  *((void *)&v18 + 1) = "md::MapZoomLevelStyleLogic]";
  uint64_t v19 = 26;
  *(void *)&long long v15 = 0xF0AA2DB42EB710AFLL;
  *((void *)&v15 + 1) = "md::MapZoomLevelStyleLogicContext]";
  *(void *)&long long v16 = 33;
  BYTE8(v16) = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 2;
  long long v7 = xmmword_1E5A97A40;
  long long v8 = unk_1E5A97A50;
  long long v9 = xmmword_1E5A97A60;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v18, &v15, 0, (uint64_t)&v6, (uint64_t)&v21);
  *(void *)&long long v18 = 0xEA624BC935BAF297;
  *((void *)&v18 + 1) = "md::mun::MuninLogic]";
  uint64_t v19 = 19;
  *(void *)&long long v15 = 0x8EA84A1BD3791AFALL;
  *((void *)&v15 + 1) = "md::mun::MuninContext]";
  *(void *)&long long v16 = 21;
  BYTE8(v16) = 1;
  *(void *)&long long v6 = &v7;
  *((void *)&v6 + 1) = 3;
  long long v9 = xmmword_1E5A97EB0;
  long long v10 = unk_1E5A97EC0;
  *(void *)&long long v11 = 20;
  long long v7 = xmmword_1E5A97E90;
  long long v8 = unk_1E5A97EA0;
  uint64_t v21 = (uint64_t)v23;
  uint64_t v22 = 0;
  gdc::LogicExecutionGraphBuilder::addLogic((uint64_t)this + 232, (unint64_t *)&v18, &v15, 1, (uint64_t)&v6, (uint64_t)&v21);
  return this;
}

void sub_1A213CF10(_Unwind_Exception *a1)
{
  md::MapEngineMode::~MapEngineMode(v1);
  _Unwind_Resume(a1);
}

float md::PolygonLayoutCharacteristics::maxMiterOffset(md::PolygonLayoutCharacteristics *this)
{
  return 2.0;
}

void md::VenueLayerLayoutCharacteristics::getOverridePolygonDepthType(md::VenueLayerLayoutCharacteristics *this@<X0>, VKPolygonGroup *a2@<X1>, unsigned char *a3@<X8>)
{
  uint64_t v5 = a2;
  long long v6 = v5;
  if (*((unsigned char *)this + 9) && *(unsigned char *)(*((void *)this + 7) + 288))
  {
    if (!v5) {
      goto LABEL_17;
    }
    [(VKPolygonGroup *)v5 styleAttributes];
    if (v11)
    {
      uint64_t v12 = v11;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 40))(v14, v11, v13 - v11);
    }
    uint64_t v7 = v11;
    if (v11 == v12)
    {
LABEL_17:
      char v10 = 3;
    }
    else
    {
      char v8 = 0;
      do
      {
        if (*(_WORD *)(v7 + 4) == 113 && *(_DWORD *)v7 == 3) {
          char v8 = 1;
        }
        v7 += 8;
      }
      while (v7 != v12);
      char v10 = v8 & 1 ^ 3;
    }
    *a3 = 1;
    a3[1] = v10;
  }
  else
  {
    *a3 = 0;
  }
}

void sub_1A213D028(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float md::VenueLayerLayoutCharacteristics::tileScale(md::VenueLayerLayoutCharacteristics *this)
{
  return *(float *)(*((void *)this + 7) + 284);
}

uint64_t md::VenueLayerLayoutCharacteristics::focusState(md::VenueLayerLayoutCharacteristics *this, VKPolygonGroup *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = *(void **)(*((void *)this + 7) + 272);
  if (v5)
  {
    long long v6 = v3;
    uint64_t v7 = *((void *)this + 7);
    uint64_t v8 = [(VKPolygonGroup *)v6 buildingId];
    long long v9 = (void *)(v7 + 16);
    do
    {
      long long v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_13;
      }
      uint64_t v10 = v9[3];
      uint64_t v11 = *(void *)(v10 + 16);
      uint64_t v12 = *(void *)(v10 + 24);
      if (v11 != v12)
      {
        while (*(void *)(v11 + 24) != v8)
        {
          v11 += 120;
          if (v11 == v12)
          {
            uint64_t v11 = v12;
            break;
          }
        }
      }
    }
    while (v11 == v12);
    if (!v11)
    {
LABEL_13:
      if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
      }
      uint64_t v14 = (id)GEOGetVectorKitVKDefaultLog_log;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v16 = 134217984;
        uint64_t v17 = [(VKPolygonGroup *)v6 buildingId];
        _os_log_impl(&dword_1A1780000, v14, OS_LOG_TYPE_ERROR, "building is null, venueGroups is null or there is no corresponding building for this venue group, and the venueGourp.building ID is : %llu .", (uint8_t *)&v16, 0xCu);
      }

      goto LABEL_18;
    }
    if (*(void *)(v11 + 40) == *v5)
    {
      uint64_t v13 = 1;
      goto LABEL_19;
    }
LABEL_18:
    uint64_t v13 = 0;
LABEL_19:
  }
  else
  {
    uint64_t v13 = 0;
  }

  return v13;
}

void sub_1A213D1C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::VenueLayerLayoutCharacteristics::shouldLayoutPolygonGroup(int8x8_t **this, VKPolygonGroup *a2, unsigned int a3)
{
  uint64_t v5 = a2;
  int v6 = md::VenueLogicContext::displayedFloorOrdinalForVenueBuildingId(this[7], [(VKPolygonGroup *)v5 buildingId]);
  int v7 = [(VKPolygonGroup *)v5 layer];
  if (v7 == v6) {
    uint64_t v8 = 1;
  }
  else {
    uint64_t v8 = a3;
  }
  if (a3 && v7 != v6) {
    uint64_t v8 = [(VKPolygonGroup *)v5 layer] != v6;
  }
  if (*((unsigned char *)this + 9))
  {
    __int16 v9 = [(VKPolygonGroup *)v5 layer];
    if (v5)
    {
      [(VKPolygonGroup *)v5 styleAttributes];
      if (v14)
      {
        uint64_t v15 = v14;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 40))(v17, v14, v16 - v14);
      }
    }
    uint64_t v10 = v14;
    if (v14 != v15)
    {
      while (1)
      {
        int v11 = *(unsigned __int16 *)(v10 + 4);
        if (*(_DWORD *)v10 == 3 && v11 == 113)
        {
          uint64_t v8 = v6 >= v9;
          goto LABEL_22;
        }
        if (*(_DWORD *)v10 == 3 && v11 == 31) {
          break;
        }
        v10 += 8;
        if (v10 == v15) {
          goto LABEL_22;
        }
      }
      uint64_t v8 = 0;
    }
  }
LABEL_22:

  return v8;
}

void sub_1A213D32C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL md::VenueLayerLayoutCharacteristics::shouldCullPolygonGroup(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  id v7 = a3;
  uint64_t v8 = v7;
  if (v7) {
    BOOL shouldCullPolygonGroup = md::VenueLayerLayoutCharacteristics::shouldCullPolygonGroup(a1, a2, [v7 buildingId], objc_msgSend(v7, "layer"), objc_msgSend(v7, "cullingMask"), a4);
  }
  else {
    BOOL shouldCullPolygonGroup = 0;
  }

  return shouldCullPolygonGroup;
}

void sub_1A213D3E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL md::VenueLayerLayoutCharacteristics::shouldCullPolygonGroup(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 a4, int a5, int a6)
{
  if (*(unsigned char *)(a1 + 9))
  {
    if ((*(unsigned char *)(*(void *)(a2 + 232) + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      *(void *)&v18.f64[0] = &v26;
      uint64_t v27 = &v18;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v27, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    uint64_t v11 = *(void *)(a1 + 56);
    uint64_t v12 = (double *)(v11 + 144);
    uint64_t v13 = (void *)(v11 + 16);
    while (1)
    {
      uint64_t v13 = (void *)*v13;
      if (!v13) {
        break;
      }
      uint64_t v14 = v13[3];
      uint64_t v15 = *(void **)(v14 + 16);
      uint64_t v16 = *(void **)(v14 + 24);
      if (v15 != v16)
      {
        while (v15[3] != a3)
        {
          v15 += 15;
          if (v15 == v16)
          {
            uint64_t v15 = v16;
            break;
          }
        }
      }
      if (v15 != v16) {
        goto LABEL_13;
      }
    }
    uint64_t v15 = 0;
LABEL_13:
    md::VenueLayerLayoutCharacteristics::offsetLevel(v18.f64, a1, v12, a2 + 88, v15, a4);
    float64x2_t v18 = (float64x2_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v18), v19);
    float64x2_t v19 = (float64x2_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v20), v21);
    float64x2_t v20 = (float64x2_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v22), v23);
    float64x2_t v21 = (float64x2_t)vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v24), v25);
    a6 = ggl::CullingGrid::intersectedCellsForView((float *)&v18, 0.0);
  }
  return (a6 & a5) == 0;
}

void md::VenueLayerLayoutCharacteristics::offsetLevel(double *a1, uint64_t a2, double *a3, uint64_t a4, void *a5, unsigned __int16 a6)
{
  if (!a5) {
    return;
  }
  double v12 = COERCE_DOUBLE(md::VenueLogicContext::buildingElevation(*(md::VenueLogicContext **)(a2 + 56), a5[3], 1));
  uint64_t v14 = *(void *)(a2 + 56);
  unint64_t v15 = a5[3];
  int8x8_t v16 = *(int8x8_t *)(v14 + 48);
  if (!*(void *)&v16) {
    goto LABEL_22;
  }
  uint8x8_t v17 = (uint8x8_t)vcnt_s8(v16);
  v17.i16[0] = vaddlv_u8(v17);
  if (v17.u32[0] > 1uLL)
  {
    unint64_t v18 = a5[3];
    if (v15 >= *(void *)&v16) {
      unint64_t v18 = v15 % *(void *)&v16;
    }
  }
  else
  {
    unint64_t v18 = (*(void *)&v16 - 1) & v15;
  }
  float64x2_t v19 = *(void **)(*(void *)(v14 + 40) + 8 * v18);
  if (!v19 || (float64x2_t v20 = (void *)*v19) == 0)
  {
LABEL_22:
    float64x2_t v24 = (unsigned __int16 *)(a5 + 7);
    goto LABEL_23;
  }
  if (v17.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v16 - 1;
    while (1)
    {
      uint64_t v23 = v20[1];
      if (v15 == v23)
      {
        if (v20[2] == v15) {
          goto LABEL_51;
        }
      }
      else if ((v23 & v21) != v18)
      {
        goto LABEL_22;
      }
      float64x2_t v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_22;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v20[1];
    if (v15 == v22) {
      break;
    }
    if (v22 >= *(void *)&v16) {
      v22 %= *(void *)&v16;
    }
    if (v22 != v18) {
      goto LABEL_22;
    }
LABEL_12:
    float64x2_t v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_22;
    }
  }
  if (v20[2] != v15) {
    goto LABEL_12;
  }
LABEL_51:
  float64x2_t v24 = (unsigned __int16 *)(v20 + 3);
LABEL_23:
  uint64_t v25 = a5[1];
  if (*a5 != v25)
  {
    int v26 = *v24;
    uint64_t v27 = *a5 + 184;
    do
    {
      BOOL v28 = *(unsigned __int16 *)(v27 - 176) == v26 || v27 == v25;
      v27 += 184;
    }
    while (!v28);
  }
  int8x8_t v29 = *(int8x8_t *)(v14 + 312);
  if (!*(void *)&v29) {
    goto LABEL_56;
  }
  uint8x8_t v30 = (uint8x8_t)vcnt_s8(v29);
  v30.i16[0] = vaddlv_u8(v30);
  if (v30.u32[0] > 1uLL)
  {
    unint64_t v31 = a5[3];
    if (*(void *)&v29 <= v15) {
      unint64_t v31 = v15 % *(void *)&v29;
    }
  }
  else
  {
    unint64_t v31 = (*(void *)&v29 - 1) & v15;
  }
  uint64_t v32 = *(void **)(*(void *)(v14 + 304) + 8 * v31);
  if (!v32) {
    goto LABEL_56;
  }
  uint64_t v33 = (void *)*v32;
  if (!v33) {
    goto LABEL_56;
  }
  if (v30.u32[0] < 2uLL)
  {
    uint64_t v34 = *(void *)&v29 - 1;
    while (1)
    {
      uint64_t v36 = v33[1];
      if (v36 == v15)
      {
        if (v33[2] == v15) {
          goto LABEL_52;
        }
      }
      else if ((v36 & v34) != v31)
      {
        goto LABEL_56;
      }
      uint64_t v33 = (void *)*v33;
      if (!v33) {
        goto LABEL_56;
      }
    }
  }
  while (1)
  {
    unint64_t v35 = v33[1];
    if (v35 == v15) {
      break;
    }
    if (v35 >= *(void *)&v29) {
      v35 %= *(void *)&v29;
    }
    if (v35 != v31) {
      goto LABEL_56;
    }
LABEL_40:
    uint64_t v33 = (void *)*v33;
    if (!v33) {
      goto LABEL_56;
    }
  }
  if (v33[2] != v15) {
    goto LABEL_40;
  }
LABEL_52:
  uint64_t v37 = v33[3];
  uint64_t v38 = v33[4];
  if (v37 == v38)
  {
LABEL_56:
    uint64_t v39 = 0;
    goto LABEL_57;
  }
  while (*(unsigned __int16 *)(v37 + 32) != a6)
  {
    uint64_t v39 = 0;
    v37 += 56;
    if (v37 == v38) {
      goto LABEL_57;
    }
  }
  uint64_t v39 = v37;
LABEL_57:
  if (v13) {
    double v40 = v12;
  }
  else {
    double v40 = 0.0;
  }
  double v41 = COERCE_DOUBLE(md::VenueLogicContext::buildingElevation(*(md::VenueLogicContext **)(a2 + 56), v15, 1));
  if (v42)
  {
    uint64_t v43 = (void *)(v14 + 16);
    while (1)
    {
      uint64_t v43 = (void *)*v43;
      if (!v43) {
        break;
      }
      uint64_t v44 = v43[3];
      uint64_t v45 = *(uint64_t **)(v44 + 16);
      int v46 = *(uint64_t **)(v44 + 24);
      if (v45 != v46)
      {
        while (v45[3] != v15)
        {
          v45 += 15;
          if (v45 == v46)
          {
            uint64_t v45 = v46;
            break;
          }
        }
      }
      if (v45 != v46)
      {
        if (v45)
        {
          uint64_t v47 = *v45;
          uint64_t v48 = v45[1];
          if (v47 != v48)
          {
            while (*(unsigned __int16 *)(v47 + 8) != a6)
            {
              v47 += 184;
              if (v47 == v48) {
                goto LABEL_76;
              }
            }
            if (*(unsigned char *)(v47 + 168))
            {
              double v41 = *(double *)(v47 + 176) * *(float *)(v14 + 292);
              char v42 = 1;
            }
          }
        }
        break;
      }
    }
  }
  else
  {
    char v42 = 0;
  }
LABEL_76:
  double v49 = v41;
  if (!v42) {
    double v49 = v40;
  }
  if (*(unsigned char *)(a2 + 54)) {
    BOOL v50 = v39 == 0;
  }
  else {
    BOOL v50 = 1;
  }
  if (v50) {
    double v51 = v49 + 0.100000001;
  }
  else {
    double v51 = *(double *)(v39 + 16) + v40;
  }
  long double v52 = *(double *)(a4 + 96);
  long double v53 = *(double *)(a4 + 104);
  long double v54 = *(double *)(a4 + 112);
  double v55 = sqrt(v52 * v52 + v53 * v53);
  double v56 = atan2(v54, v55 * 0.996647189);
  double v57 = atan2(v53, v52);
  __double2 v58 = __sincos_stret(v56);
  double v59 = atan2(v54 + v58.__sinval * v58.__sinval * 42841.3115 * v58.__sinval, v55 + v58.__cosval * v58.__cosval * -42697.6727 * v58.__cosval);
  __double2 v60 = __sincos_stret(v59);
  double v61 = 6378137.0 / sqrt(v60.__sinval * v60.__sinval * -0.00669437999 + 1.0);
  double v62 = (v61 + v51) * v60.__cosval;
  __double2 v63 = __sincos_stret(v57);
  long long v64 = *(_OWORD *)(a4 + 112);
  long long v69 = *(_OWORD *)(a4 + 96);
  long long v70 = v64;
  long long v65 = *(_OWORD *)(a4 + 80);
  v68[4] = *(_OWORD *)(a4 + 64);
  v68[5] = v65;
  long long v66 = *(_OWORD *)(a4 + 16);
  v68[0] = *(_OWORD *)a4;
  v68[1] = v66;
  long long v67 = *(_OWORD *)(a4 + 48);
  v68[2] = *(_OWORD *)(a4 + 32);
  v68[3] = v67;
  *(double *)&long long v69 = v62 * v63.__cosval;
  *((double *)&v69 + 1) = v62 * v63.__sinval;
  *(double *)&long long v70 = (v51 + v61 * 0.99330562) * v60.__sinval;
  gm::operator*<double,4,4,4>(a1, a3, (double *)v68);
}

void md::VenueLayerLayoutCharacteristics::modifyMVCForPolygonGroup(uint64_t a1@<X0>, uint64_t a2@<X1>, _OWORD *a3@<X2>, uint64_t a4@<X3>, void *a5@<X4>, _OWORD *a6@<X8>)
{
  id v11 = a5;
  double v12 = v11;
  if (*(unsigned char *)(a1 + 9) && *(unsigned char *)(*(void *)(a1 + 56) + 288))
  {
    id v13 = v11;
    uint64_t v14 = [v13 buildingId];
    unint64_t v15 = (void *)(*(void *)(a1 + 56) + 16);
    do
    {
      unint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_16;
      }
      uint64_t v16 = v15[3];
      unint64_t v18 = *(void **)(v16 + 16);
      uint8x8_t v17 = *(void **)(v16 + 24);
      if (v18 != v17)
      {
        while (v18[3] != v14)
        {
          v18 += 15;
          if (v18 == v17)
          {
            unint64_t v18 = v17;
            break;
          }
        }
      }
    }
    while (v18 == v17);
    if (!v18)
    {
LABEL_16:
      long long v24 = a3[1];
      *a6 = *a3;
      a6[1] = v24;
      long long v25 = a3[3];
      a6[2] = a3[2];
      a6[3] = v25;
      goto LABEL_17;
    }
    unsigned __int16 v21 = [v13 layer];
    if ((*(unsigned char *)(*(void *)a2 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      *(void *)&v26[0].f64[0] = &v27;
      BOOL v28 = v26;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v28, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    md::VenueLayerLayoutCharacteristics::offsetLevel(v26[0].f64, a1, (double *)(*(void *)(a1 + 56) + 144), a4, v18, v21);
    float32x4_t v22 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v26[2]), v26[3]);
    *a6 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v26[0]), v26[1]);
    a6[1] = v22;
    float32x4_t v23 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v26[6]), v26[7]);
    a6[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v26[4]), v26[5]);
    a6[3] = v23;
LABEL_17:
  }
  else
  {
    long long v19 = a3[1];
    *a6 = *a3;
    a6[1] = v19;
    long long v20 = a3[3];
    a6[2] = a3[2];
    a6[3] = v20;
  }
}

void sub_1A213DB94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::VenueLayerLayoutCharacteristics::modifiesMVCForPolygonGroup(md::VenueLayerLayoutCharacteristics *this, const VKPolygonGroup *a2)
{
  return *(unsigned __int8 *)(*((void *)this + 7) + 288);
}

unint64_t md::VenueLayerLayoutCharacteristics::renderOrderForAttributes(uint64_t a1, int a2, uint64_t a3, int a4, unint64_t a5, unsigned int a6, int a7, void *a8, void *a9)
{
  int v16 = *(unsigned __int8 *)(a1 + 9);
  uint64_t v17 = (20 * (__int16)[a9 layer]) | 2;
  if (!v16) {
    uint64_t v17 = 2;
  }
  uint64_t v18 = 0x800000000;
  if (!a4) {
    uint64_t v18 = 0;
  }
  uint64_t v19 = 0x2000000;
  if (a2) {
    uint64_t v19 = 0;
  }
  uint64_t v20 = 0x20000;
  if (!a7) {
    uint64_t v20 = 0;
  }
  return (v19 & 0xFFFFFFFFFFFE01FFLL | (a3 << 26) | v18 & 0xFFFFFFFFFFFE01FFLL | ((unint64_t)a6 << 18) | v20 & 0xFFFFFFFFFFFE01FFLL | ((unint64_t)(a5 >> 4) << 9) | ((unint64_t)*(unsigned __int8 *)(a5 + 1) << 20) | (*a8 >> 3) & 0x1FELL)
       + v17;
}

uint64_t md::VenueLayerLayoutCharacteristics::shouldStencil(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  if (!*(unsigned char *)(a1 + 9) || !*(unsigned char *)(a1 + 55)) {
    return 0;
  }
  *a3 = -1;
  return 1;
}

uint64_t md::VenueLayerLayoutCharacteristics::commandBuffer(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

void md::VenueLayerLayoutCharacteristics::~VenueLayerLayoutCharacteristics(md::VenueLayerLayoutCharacteristics *this)
{
  *(void *)this = &unk_1EF54A500;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;

  *(void *)this = &unk_1EF54A500;
  uint64_t v2 = (void *)*((void *)this + 2);
  if (v2)
  {
    *((void *)this + 3) = v2;
    operator delete(v2);
  }
}

void geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559598;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKPolygonGroup * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559598;

  return a1;
}

md::VenueRenderLayer *md::VenueRenderLayer::_layoutDimmingOverlay(md::VenueRenderLayer *this, int8x8_t *a2)
{
  int8x8_t v2 = a2[1];
  if (!*(void *)&v2) {
    return this;
  }
  uint64_t v3 = this;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  unint64_t v5 = v4.u32[0];
  if (v4.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x4927EB92E562CC46;
    if (*(void *)&v2 <= 0x4927EB92E562CC46uLL) {
      uint64_t v6 = 0x4927EB92E562CC46uLL % *(void *)&v2;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v2 - 1) & 0x4927EB92E562CC46;
  }
  int8x8_t v7 = *a2;
  uint64_t v8 = *(void **)(*(void *)a2 + 8 * v6);
  if (!v8) {
    return this;
  }
  __int16 v9 = (void *)*v8;
  if (!v9) {
    return this;
  }
  uint64_t v10 = *(void *)&v2 - 1;
  if (v4.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == 0x4927EB92E562CC46)
      {
        if (v9[2] == 0x4927EB92E562CC46) {
          goto LABEL_22;
        }
      }
      else if ((v11 & v10) != v6)
      {
        return this;
      }
      __int16 v9 = (void *)*v9;
      if (!v9) {
        return this;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v9[1];
    if (v12 == 0x4927EB92E562CC46) {
      break;
    }
    if (v12 >= *(void *)&v2) {
      v12 %= *(void *)&v2;
    }
    if (v12 != v6) {
      return this;
    }
LABEL_16:
    __int16 v9 = (void *)*v9;
    if (!v9) {
      return this;
    }
  }
  if (v9[2] != 0x4927EB92E562CC46) {
    goto LABEL_16;
  }
LABEL_22:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x4927EB92E562CC46)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    if (v14)
    {
      if (*(float *)(v14 + 280) >= 0.00000011921)
      {
        if (v4.u32[0] > 1uLL)
        {
          uint64_t v15 = 0x3070CB6B3C7F21D3;
          if (*(void *)&v2 <= 0x3070CB6B3C7F21D3uLL) {
            uint64_t v15 = 0x3070CB6B3C7F21D3uLL % *(void *)&v2;
          }
        }
        else
        {
          uint64_t v15 = v10 & 0x3070CB6B3C7F21D3;
        }
        int v16 = *(void **)(*(void *)&v7 + 8 * v15);
        if (v16)
        {
          uint64_t v17 = (void *)*v16;
          if (v17)
          {
            if (v4.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v18 = v17[1];
                if (v18 == 0x3070CB6B3C7F21D3)
                {
                  if (v17[2] == 0x3070CB6B3C7F21D3) {
                    goto LABEL_45;
                  }
                }
                else if ((v18 & v10) != v15)
                {
                  return this;
                }
                uint64_t v17 = (void *)*v17;
                if (!v17) {
                  return this;
                }
              }
            }
            do
            {
              unint64_t v19 = v17[1];
              if (v19 == 0x3070CB6B3C7F21D3)
              {
                if (v17[2] == 0x3070CB6B3C7F21D3)
                {
LABEL_45:
                  uint64_t v20 = v17[5];
                  if (*(void *)(v20 + 8) == 0x3070CB6B3C7F21D3)
                  {
                    uint64_t v21 = *(void *)(v20 + 32);
                    if (v21)
                    {
                      uint64_t v22 = md::VenueRenderLayer::_venuesCommandBuffer(this, a2);
                      if (v5 >= 2)
                      {
                        unint64_t v24 = 0x1AF456233693CD46;
                        if (*(void *)&v2 <= 0x1AF456233693CD46uLL) {
                          unint64_t v24 = 0x1AF456233693CD46uLL % *(void *)&v2;
                        }
                        float32x4_t v23 = *(void **)(*(void *)&v7 + 8 * v24);
                        do
                        {
                          do
                            float32x4_t v23 = (void *)*v23;
                          while (v23[1] != 0x1AF456233693CD46);
                        }
                        while (v23[2] != 0x1AF456233693CD46);
                      }
                      else
                      {
                        float32x4_t v23 = *(void **)(*(void *)&v7 + 8 * (v10 & 0x1AF456233693CD46));
                        do
                        {
                          do
                            float32x4_t v23 = (void *)*v23;
                          while (v23[1] != 0x1AF456233693CD46);
                        }
                        while (v23[2] != 0x1AF456233693CD46);
                      }
                      long long v25 = *(float64x2_t **)(v23[5] + 32);
                      float32x2_t v26 = vcvt_f32_f64(v25[175]);
                      float32x2_t v27 = vcvt_f32_f64(v25[176]);
                      float32x2_t v28 = vcvt_f32_f64(v25[177]);
                      float32x2_t v29 = vcvt_f32_f64(v25[178]);
                      float32x2_t v30 = vcvt_f32_f64(v25[179]);
                      float32x2_t v31 = vcvt_f32_f64(v25[180]);
                      float32x2_t v32 = vcvt_f32_f64(v25[181]);
                      float32x2_t v33 = vcvt_f32_f64(v25[182]);
                      uint64_t v34 = **((void **)v3 + 47);
                      uint64_t v55 = 0;
                      uint64_t v56 = 0;
                      uint64_t v53 = 0;
                      uint64_t v54 = 0;
                      uint64_t v35 = *(void *)(v34 + 8);
                      double v57 = (std::__shared_weak_count *)v34;
                      uint64_t v58 = 0;
                      uint64_t v59 = v35;
                      __int16 v60 = 1;
                      if (v35) {
                        uint64_t v36 = *(void *)(v34 + 72);
                      }
                      else {
                        uint64_t v36 = 0;
                      }
                      uint64_t v61 = v36;
                      ggl::BufferMemory::operator=(&v53, (uint64_t)&v56);
                      ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v56);
                      uint64_t v37 = (void *)v55;
                      *(float32x2_t *)uint64_t v55 = v26;
                      v37[1] = v27;
                      void v37[2] = v28;
                      v37[3] = v29;
                      v37[4] = v30;
                      v37[5] = v31;
                      v37[6] = v32;
                      v37[7] = v33;
                      ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v53);
                      int v38 = *(_DWORD *)(v14 + 280);
                      uint64_t v39 = *(void *)(*((void *)v3 + 47) + 16);
                      uint64_t v55 = 0;
                      uint64_t v56 = 0;
                      uint64_t v53 = 0;
                      uint64_t v54 = 0;
                      uint64_t v40 = *(void *)(v39 + 8);
                      double v57 = (std::__shared_weak_count *)v39;
                      uint64_t v58 = 0;
                      uint64_t v59 = v40;
                      __int16 v60 = 1;
                      if (v40) {
                        uint64_t v41 = *(void *)(v39 + 72);
                      }
                      else {
                        uint64_t v41 = 0;
                      }
                      uint64_t v61 = v41;
                      ggl::BufferMemory::operator=(&v53, (uint64_t)&v56);
                      ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v56);
                      uint64_t v42 = v55;
                      *(_DWORD *)(v55 + 72) = 0;
                      *(void *)(v42 + 64) = 0;
                      *(_DWORD *)(v42 + 76) = v38;
                      ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v53);
                      ggl::GlobeAtmosphere::BasePipelineSetup::setConstantsConstantData(*(void **)(*(void *)(*((void *)v3 + 47) + 64) + 64), *(void **)(*(void *)(*((void *)v3 + 47) + 64) + 160), **((void **)v3 + 47), *(void *)(*((void *)v3 + 47) + 8));
                      uint64_t v43 = *(void *)(*((void *)v3 + 47) + 64);
                      md::GeometryLogic::createUnitTransformConstantData((md::GeometryLogic *)&v56);
                      uint64_t v44 = *(void *)(v43 + 64);
                      uint64_t v45 = *(void *)(v43 + 160);
                      int v46 = v57;
                      ggl::GlobeAtmosphere::BasePipelineSetup::setLightConfigConstantData(v44, v45, v56, (uint64_t)v57);
                      if (v46 && !atomic_fetch_add(&v46->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
                        std::__shared_weak_count::__release_weak(v46);
                      }
                      uint64_t v47 = v21 + 144;
                      uint64_t v48 = 144;
                      if (*(unsigned __int8 *)(v21 + 320) - 1 >= 3)
                      {
                        uint64_t v48 = 128;
                        uint64_t v47 = v21 + 128;
                      }
                      uint64_t v49 = *((void *)v3 + 47);
                      uint64_t v50 = *(void *)(v21 + v48);
                      uint64_t v51 = *(void *)(v47 + 8);
                      if (v51) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v51 + 8), 1uLL, memory_order_relaxed);
                      }
                      long double v52 = *(std::__shared_weak_count **)(v49 + 56);
                      *(void *)(v49 + 48) = v50;
                      *(void *)(v49 + 56) = v51;
                      if (v52)
                      {
                        if (!atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
                          std::__shared_weak_count::__release_weak(v52);
                        }
                      }
                      *(void *)(*(void *)(*((void *)v3 + 47) + 504) + 64) = *(void *)(*((void *)v3 + 47)
                                                                                                + 48);
                      *(void *)(*(void *)(*((void *)v3 + 47) + 504) + 64) = *(void *)(*((void *)v3 + 47)
                                                                                                + 48);
                      return (md::VenueRenderLayer *)ggl::CommandBuffer::pushRenderItem(v22, *(void *)(*((void *)v3 + 47) + 504));
                    }
                  }
                  return this;
                }
              }
              else
              {
                if (v19 >= *(void *)&v2) {
                  v19 %= *(void *)&v2;
                }
                if (v19 != v15) {
                  return this;
                }
              }
              uint64_t v17 = (void *)*v17;
            }
            while (v17);
          }
        }
      }
    }
  }
  return this;
}

void *md::VenueRenderLayer::_layoutVenueWalls(md::VenueRenderLayer *this, int8x8_t **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = md::VenueRenderLayer::_venuesCommandBuffer(this, a2[1]);
  uint8x8_t v4 = operator new(0x20uLL);
  *uint8x8_t v4 = &unk_1EF572DF8;
  v4[1] = this;
  v4[2] = a2;
  v4[3] = &v6;
  uint64_t v8 = v4;
  md::VenueRenderLayer::_forEachVisibleVenueGroup((uint64_t)this, (uint64_t)a2, (uint64_t)v7);
  __n128 result = v8;
  if (v8 == v7) {
    return (void *)(*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (void *)(*(uint64_t (**)(void *))(*v8 + 40))(v8);
  }
  return result;
}

void sub_1A213E47C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *md::VenueRenderLayer::_layoutOpenToBelowAreas(md::VenueRenderLayer *this, int8x8_t **a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = md::VenueRenderLayer::_venuesCommandBuffer(this, a2[1]);
  uint8x8_t v4 = operator new(0x20uLL);
  *uint8x8_t v4 = &unk_1EF572E40;
  v4[1] = this;
  v4[2] = a2;
  v4[3] = &v6;
  uint64_t v8 = v4;
  md::VenueRenderLayer::_forEachVisibleVenueGroup((uint64_t)this, (uint64_t)a2, (uint64_t)v7);
  __n128 result = v8;
  if (v8 == v7) {
    return (void *)(*(uint64_t (**)(void *))(v7[0] + 32))(v7);
  }
  if (v8) {
    return (void *)(*(uint64_t (**)(void *))(*v8 + 40))(v8);
  }
  return result;
}

void sub_1A213E5A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void md::VenueRenderLayer::_layoutVenueFootprints(md::VenueRenderLayer *this, int8x8_t *a2)
{
  uint64_t v4 = md::VenueRenderLayer::_venuesCommandBuffer(this, a2);
  int8x8_t v5 = a2[1];
  if (!*(void *)&v5) {
    return;
  }
  uint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v8 = 0x4927EB92E562CC46;
    if (*(void *)&v5 <= 0x4927EB92E562CC46uLL) {
      uint64_t v8 = 0x4927EB92E562CC46uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v8 = (*(void *)&v5 - 1) & 0x4927EB92E562CC46;
  }
  int8x8_t v9 = *a2;
  uint64_t v10 = *(void **)(*(void *)a2 + 8 * v8);
  if (!v10) {
    return;
  }
  uint64_t v11 = (void *)*v10;
  if (!*v10) {
    return;
  }
  uint64_t v12 = *(void *)&v5 - 1;
  if (v7.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v13 = v11[1];
      if (v13 == 0x4927EB92E562CC46)
      {
        if (v11[2] == 0x4927EB92E562CC46) {
          goto LABEL_22;
        }
      }
      else if ((v13 & v12) != v8)
      {
        return;
      }
      uint64_t v11 = (void *)*v11;
      if (!v11) {
        return;
      }
    }
  }
  while (1)
  {
    unint64_t v14 = v11[1];
    if (v14 == 0x4927EB92E562CC46) {
      break;
    }
    if (v14 >= *(void *)&v5) {
      v14 %= *(void *)&v5;
    }
    if (v14 != v8) {
      return;
    }
LABEL_16:
    uint64_t v11 = (void *)*v11;
    if (!v11) {
      return;
    }
  }
  if (v11[2] != 0x4927EB92E562CC46) {
    goto LABEL_16;
  }
LABEL_22:
  uint64_t v15 = v11[5];
  if (*(void *)(v15 + 8) != 0x4927EB92E562CC46) {
    return;
  }
  int v16 = *(int8x8_t **)(v15 + 32);
  if (!v16) {
    return;
  }
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v17 = 0x3070CB6B3C7F21D3;
    if (*(void *)&v5 <= 0x3070CB6B3C7F21D3uLL) {
      uint64_t v17 = 0x3070CB6B3C7F21D3uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v17 = v12 & 0x3070CB6B3C7F21D3;
  }
  uint64_t v18 = *(void **)(*(void *)&v9 + 8 * v17);
  if (!v18) {
    return;
  }
  unint64_t v19 = (void *)*v18;
  if (!v19) {
    return;
  }
  if (v7.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v20 = v19[1];
      if (v20 == 0x3070CB6B3C7F21D3)
      {
        if (v19[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_44;
        }
      }
      else if ((v20 & v12) != v17)
      {
        return;
      }
      unint64_t v19 = (void *)*v19;
      if (!v19) {
        return;
      }
    }
  }
  while (2)
  {
    unint64_t v21 = v19[1];
    if (v21 != 0x3070CB6B3C7F21D3)
    {
      if (v21 >= *(void *)&v5) {
        v21 %= *(void *)&v5;
      }
      if (v21 != v17) {
        return;
      }
      goto LABEL_38;
    }
    if (v19[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_38:
      unint64_t v19 = (void *)*v19;
      if (!v19) {
        return;
      }
      continue;
    }
    break;
  }
LABEL_44:
  uint64_t v22 = v19[5];
  if (*(void *)(v22 + 8) != 0x3070CB6B3C7F21D3 || !*(void *)(v22 + 32)) {
    return;
  }
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v23 = 0x1AF456233693CD46;
    if (*(void *)&v5 <= 0x1AF456233693CD46uLL) {
      uint64_t v23 = 0x1AF456233693CD46uLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v23 = v12 & 0x1AF456233693CD46;
  }
  unint64_t v24 = *(void **)(*(void *)&v9 + 8 * v23);
  __double2 v196 = v16;
  if (v24)
  {
    long long v25 = (void *)*v24;
    if (v25)
    {
      if (v7.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v26 = v25[1];
          if (v26 == 0x1AF456233693CD46)
          {
            if (v25[2] == 0x1AF456233693CD46) {
              goto LABEL_249;
            }
          }
          else if ((v26 & v12) != v23)
          {
            goto LABEL_65;
          }
          long long v25 = (void *)*v25;
          if (!v25) {
            goto LABEL_65;
          }
        }
      }
      do
      {
        unint64_t v27 = v25[1];
        if (v27 == 0x1AF456233693CD46)
        {
          if (v25[2] == 0x1AF456233693CD46)
          {
LABEL_249:
            uint64_t v193 = v25[5];
            if (*(void *)(v193 + 8) == 0x1AF456233693CD46) {
              uint64_t v194 = *(void *)(v193 + 32);
            }
            else {
              uint64_t v194 = 0;
            }
            goto LABEL_66;
          }
        }
        else
        {
          if (v27 >= *(void *)&v5) {
            v27 %= *(void *)&v5;
          }
          if (v27 != v23) {
            break;
          }
        }
        long long v25 = (void *)*v25;
      }
      while (v25);
    }
  }
LABEL_65:
  uint64_t v194 = 0;
LABEL_66:
  md::LayoutContext::zoomAtCentrePoint(a2);
  float32x2_t v29 = (uint64_t *)*((void *)this + 34);
  uint64_t v195 = (uint64_t *)*((void *)this + 35);
  if (v29 == v195) {
    return;
  }
  float32x2_t v30 = (char *)this + 384;
  float v31 = fminf(fmaxf((float)(v28 * 2.0) + -31.0, 0.0), 1.0);
  unint64_t v199 = v16 + 2;
  while (2)
  {
    uint64_t v200 = v29;
    uint64_t v32 = *v29;
    uint64_t v33 = *(void *)(*v29 + 384);
    uint64_t v34 = *(void *)(v32 + 216);
    uint64_t v35 = *(std::__shared_weak_count **)(v32 + 224);
    uint64_t v223 = v34;
    long double v224 = v35;
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)&long long v214 = 0;
    long double v211 = 0;
    *(void *)&long long v212 = 0;
    ggl::ResourceAccessor::accessConstantData((uint64_t)&v225, 0, v34, 0);
    ggl::BufferMemory::operator=((uint64_t *)&v211, (uint64_t)&v225);
    ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v225);
    long long v36 = *(_OWORD *)(v214 + 16);
    *(_OWORD *)double v220 = *(_OWORD *)v214;
    *(_OWORD *)&v220[16] = v36;
    float32x4_t v37 = *(float32x4_t *)(v214 + 48);
    float32x4_t v221 = *(float32x4_t *)(v214 + 32);
    float32x4_t v222 = v37;
    ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v211);
    int v201 = ggl::CullingGrid::intersectedCellsForView((float *)v220, 0.0);
    int v38 = *(uint64_t **)(v33 + 776);
    float32x2_t v202 = *(uint64_t **)(v33 + 784);
    if (v38 == v202) {
      goto LABEL_245;
    }
    double v39 = *(double *)(v194 + 3768) * 10.0 * (double)(1 << *(unsigned char *)(v33 + 169)) / *(double *)(v194 + 1368);
    *(float *)&double v39 = v39;
    float32x4_t v198 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v39, 0);
    uint64_t v40 = v199;
    int v41 = v201;
    uint64_t v197 = v32;
    while (2)
    {
      if (!*((unsigned char *)this + 393)
        && md::VenueLayerLayoutCharacteristics::shouldCullPolygonGroup((uint64_t)v30, v32, v38[8], *((_DWORD *)v38 + 15), *((_DWORD *)v38 + 14), v41))
      {
        goto LABEL_74;
      }
      uint64_t v42 = v40;
      do
      {
        uint64_t v42 = (int8x8_t *)*v42;
        if (!v42) {
          goto LABEL_74;
        }
        int8x8_t v43 = v42[3];
        uint64_t v44 = *(uint64_t **)(*(void *)&v43 + 16);
        uint64_t v45 = *(uint64_t **)(*(void *)&v43 + 24);
        if (v44 != v45)
        {
          while (v44[3] != v38[8])
          {
            v44 += 15;
            if (v44 == v45)
            {
              uint64_t v44 = v45;
              break;
            }
          }
        }
      }
      while (v44 == v45);
      if (!v44) {
        goto LABEL_74;
      }
      int v46 = *((__int16 *)v44 + 28);
      unsigned __int16 v47 = *((_WORD *)v44 + 28);
      int8x8_t v48 = v16[6];
      int v49 = v47;
      if (!*(void *)&v48) {
        goto LABEL_107;
      }
      unint64_t v50 = v44[3];
      uint8x8_t v51 = (uint8x8_t)vcnt_s8(v48);
      v51.i16[0] = vaddlv_u8(v51);
      if (v51.u32[0] > 1uLL)
      {
        unint64_t v52 = v44[3];
        if (v50 >= *(void *)&v48) {
          unint64_t v52 = v50 % *(void *)&v48;
        }
      }
      else
      {
        unint64_t v52 = (*(void *)&v48 - 1) & v50;
      }
      uint64_t v53 = *(uint64_t ****)(*(void *)&v16[5] + 8 * v52);
      int v49 = *((unsigned __int16 *)v44 + 28);
      if (!v53) {
        goto LABEL_107;
      }
      uint64_t v54 = *v53;
      int v49 = *((unsigned __int16 *)v44 + 28);
      if (!v54) {
        goto LABEL_107;
      }
      if (v51.u32[0] < 2uLL)
      {
        uint64_t v55 = *(void *)&v48 - 1;
        while (1)
        {
          double v57 = v54[1];
          if ((uint64_t *)v50 == v57)
          {
            if (v54[2] == (uint64_t *)v50) {
              goto LABEL_106;
            }
          }
          else if (((unint64_t)v57 & v55) != v52)
          {
            goto LABEL_105;
          }
          uint64_t v54 = (uint64_t **)*v54;
          if (!v54) {
            goto LABEL_105;
          }
        }
      }
      while (2)
      {
        unint64_t v56 = (unint64_t)v54[1];
        if (v50 != v56)
        {
          if (v56 >= *(void *)&v48) {
            v56 %= *(void *)&v48;
          }
          if (v56 != v52)
          {
LABEL_105:
            int v49 = *((unsigned __int16 *)v44 + 28);
            goto LABEL_107;
          }
          goto LABEL_95;
        }
        if (v54[2] != (uint64_t *)v50)
        {
LABEL_95:
          uint64_t v54 = (uint64_t **)*v54;
          if (!v54) {
            goto LABEL_105;
          }
          continue;
        }
        break;
      }
LABEL_106:
      int v49 = *((unsigned __int16 *)v54 + 12);
LABEL_107:
      uint64_t v59 = *v44;
      uint64_t v58 = v44[1];
      if (v59 == v58) {
        goto LABEL_110;
      }
      while (*(unsigned __int16 *)(v59 + 8) != v49)
      {
        v59 += 184;
        if (v59 == v58) {
          goto LABEL_110;
        }
      }
      if (v59 == v58) {
LABEL_110:
      }
        LOWORD(v49) = v47;
      int v60 = *((_DWORD *)v38 + 15);
      if (*((unsigned char *)this + 438)) {
        BOOL v61 = 1;
      }
      else {
        BOOL v61 = v60 == (__int16)v49;
      }
      if (v61 && v60 >= v46 && v60 <= (__int16)v49)
      {
        long long v64 = md::PolygonViewConstantsFrameCache::pop((md::PolygonViewConstantsFrameCache *)(*((void *)this + 46)
                                                                                           + 240));
        long long v65 = *(_OWORD *)&v220[16];
        float32x4_t v66 = v221;
        float32x4_t v67 = v222;
        uint64_t v68 = *v64;
        unint64_t v69 = *(void *)(*v64 + 8);
        uint64_t v70 = *(void *)(*v64 + 72);
        *(_OWORD *)uint64_t v70 = *(_OWORD *)v220;
        *(_OWORD *)(v70 + 16) = v65;
        *(float32x4_t *)(v70 + 32) = v66;
        *(float32x4_t *)(v70 + 48) = v67;
        unint64_t v71 = *(void *)(v68 + 64);
        if (v71 <= v69) {
          unint64_t v71 = v69;
        }
        *(void *)(v68 + 56) = 0;
        *(_DWORD *)(v70 + 64) = *(_DWORD *)(v32 + 368);
        if (v71 > v69) {
          unint64_t v69 = v71;
        }
        *(void *)(v68 + 64) = v69;
        uint64_t v72 = ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::pop(*(void *)(*((void *)this + 47) + 2728));
        uint64_t v73 = *(void *)(v72 + 64);
        *(void *)(v73 + 24) = 0;
        uint64_t v74 = *(void *)(v32 + 232);
        *(void *)(v73 + 16) = v74;
        uint64_t v75 = *(void *)(v72 + 160);
        uint64_t v76 = *(void *)(v32 + 240);
        if (v76) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v76 + 8), 1uLL, memory_order_relaxed);
        }
        double v77 = *(std::__shared_weak_count **)(v75 + 24);
        *(void *)(v75 + 16) = v74;
        *(void *)(v75 + 24) = v76;
        if (v77 && !atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
          std::__shared_weak_count::__release_weak(v77);
        }
        double v78 = md::PolygonViewConstantsFrameCache::pop((md::PolygonViewConstantsFrameCache *)(*((void *)this + 46)
                                                                                           + 240));
        double v79 = (std::__shared_weak_count *)v78[1];
        uint64_t v218 = *v78;
        float v219 = v79;
        if (v79) {
          atomic_fetch_add_explicit(&v79->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v80 = ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::pop(*(void *)(*((void *)this + 47) + 3448));
        long double v81 = md::PolygonViewConstantsFrameCache::pop((md::PolygonViewConstantsFrameCache *)(*((void *)this + 46)
                                                                                           + 240));
        double v82 = (void *)*v81;
        long double v83 = (std::__shared_weak_count *)v81[1];
        double v216 = (void *)*v81;
        double v217 = v83;
        if (v83) {
          atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        v84.i64[0] = *(void *)v220;
        float32x4_t v85 = v221;
        float32x4_t v86 = v222;
        int8x16_t v87 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v220[8], (float32x4_t)xmmword_1A28FD160);
        v84.i64[1] = *(void *)&v220[24];
        int8x16_t v88 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v220[8], (float32x4_t)xmmword_1A28FCDA0);
        unint64_t v89 = v82[1];
        double v90 = (float32x4_t *)v82[9];
        *double v90 = vmlaq_f32((float32x4_t)vextq_s8(v87, v87, 8uLL), (float32x4_t)xmmword_1A28FD160, v84);
        v90[1] = vmlaq_f32((float32x4_t)vextq_s8(v88, v88, 8uLL), (float32x4_t)xmmword_1A28FCDA0, v84);
        v90[2] = v85;
        v90[3] = v86;
        unint64_t v91 = v82[8];
        if (v91 <= v89) {
          unint64_t v91 = v89;
        }
        v82[7] = 0;
        v90[4].i32[0] = *(_DWORD *)(v32 + 368);
        if (v91 > v89) {
          unint64_t v89 = v91;
        }
        v82[8] = v89;
        float v92 = *(void **)(v72 + 64);
        *float v92 = v82;
        v92[1] = 0;
        double v93 = *(void **)(v72 + 160);
        if (v83) {
          atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        BOOL v94 = (std::__shared_weak_count *)v93[1];
        void *v93 = v82;
        v93[1] = v83;
        if (v94 && !atomic_fetch_add(&v94->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
          std::__shared_weak_count::__release_weak(v94);
        }
        v95.i64[0] = *(void *)v220;
        float32x4_t v96 = v221;
        int8x16_t v97 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v220[8], (float32x4_t)xmmword_1A28FD160);
        v95.i64[1] = *(void *)&v220[24];
        int8x16_t v98 = (int8x16_t)vmulq_f32(*(float32x4_t *)&v220[8], (float32x4_t)xmmword_1A28FCDA0);
        float32x4_t v99 = vmlaq_f32(v222, v221, v198);
        uint64_t v100 = v218;
        unint64_t v101 = *(void *)(v218 + 8);
        float32x2_t v102 = *(float32x4_t **)(v218 + 72);
        float32x4_t *v102 = vmlaq_f32((float32x4_t)vextq_s8(v97, v97, 8uLL), (float32x4_t)xmmword_1A28FD160, v95);
        v102[1] = vmlaq_f32((float32x4_t)vextq_s8(v98, v98, 8uLL), (float32x4_t)xmmword_1A28FCDA0, v95);
        v102[2] = v96;
        v102[3] = v99;
        if (*(void *)(v100 + 64) > v101) {
          unint64_t v101 = *(void *)(v100 + 64);
        }
        *(void *)(v100 + 56) = 0;
        *(void *)(v100 + 64) = v101;
        BOOL v103 = *(void **)(v80 + 64);
        *BOOL v103 = v100;
        v103[1] = 0;
        uint64_t v104 = *(void **)(v80 + 160);
        uint64_t v105 = v219;
        if (v219) {
          atomic_fetch_add_explicit(&v219->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        int v106 = (std::__shared_weak_count *)v104[1];
        void *v104 = v100;
        v104[1] = v105;
        if (v106 && !atomic_fetch_add(&v106->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v106->__on_zero_shared)(v106);
          std::__shared_weak_count::__release_weak(v106);
        }
        md::GeometryLogic::createUnitTransformConstantData((md::GeometryLogic *)&v225);
        uint64_t v107 = *(void *)(v80 + 64);
        char v108 = v225;
        uint64_t v109 = v226;
        *(void *)(v107 + 16) = v225;
        *(void *)(v107 + 24) = 0;
        uint64_t v110 = *(void *)(v80 + 160);
        if (v109) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v109 + 8), 1uLL, memory_order_relaxed);
        }
        double v111 = *(std::__shared_weak_count **)(v110 + 24);
        *(void *)(v110 + 16) = v108;
        *(void *)(v110 + 24) = v109;
        if (v111 && !atomic_fetch_add(&v111->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v111->__on_zero_shared)(v111);
          std::__shared_weak_count::__release_weak(v111);
        }
        uint64_t v112 = (std::__shared_weak_count *)v226;
        if ((void)v226 && !atomic_fetch_add((atomic_ullong *volatile)(v226 + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v112->__on_zero_shared)(v112);
          std::__shared_weak_count::__release_weak(v112);
        }
        long double v211 = &off_1EF55A458;
        *((void *)&v212 + 1) = "";
        *(_DWORD *)double v215 = 1065353216;
        memset(&v215[8], 0, 32);
        *(int64x2_t *)&v215[40] = vdupq_n_s64(1uLL);
        *(void *)&v215[56] = 0;
        uint64_t v113 = *((void *)this + 47);
        LODWORD(v214) = *(unsigned __int8 *)(v113 + 3672);
        uint64_t v114 = 20 * *((int *)v38 + 15);
        BOOL v115 = *((unsigned char *)this + 393) == 0;
        if (!*((unsigned char *)this + 393)) {
          uint64_t v114 = 0;
        }
        *((void *)&v214 + 1) = v114;
        unint64_t v116 = v113 + 2976;
        if (v115) {
          unint64_t v116 = v113 + 2736;
        }
        v213.n128_u64[0] = v116;
        v213.n128_u64[1] = v72;
        __n128 v209 = *(__n128 *)&v215[32];
        long long v210 = *(_OWORD *)&v215[48];
        long long v207 = *(_OWORD *)v215;
        long long v208 = *(_OWORD *)&v215[16];
        __n128 v117 = v213;
        *(void *)&long long v206 = v214;
        long long v204 = v212;
        uint64_t v118 = 20 * *((int *)v38 + 15) + 0x80000000BLL;
        if (v115) {
          uint64_t v118 = 0x80000000BLL;
        }
        *((void *)&v206 + 1) = v118;
        v205.n128_u64[0] = v113 + 3456;
        v205.n128_u64[1] = v80;
        uint64_t v119 = *v38;
        uint64_t v203 = v38[1];
        if (*v38 == v203)
        {
LABEL_238:
          float v191 = v217;
          if (v217 && !atomic_fetch_add(&v217->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v191->__on_zero_shared)(v191);
            std::__shared_weak_count::__release_weak(v191);
          }
          double v192 = v219;
          int v16 = v196;
          uint64_t v32 = v197;
          float32x2_t v30 = (char *)this + 384;
          uint64_t v40 = v199;
          if (v219 && !atomic_fetch_add(&v219->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v192->__on_zero_shared)(v192);
            std::__shared_weak_count::__release_weak(v192);
          }
          int v41 = v201;
          goto LABEL_74;
        }
        unsigned int v120 = 0;
        while (1)
        {
          uint64_t v122 = *((void *)this + 47);
          float v123 = (char **)(v122 + 3712);
          *(void *)(v122 + 3720) = *(void *)(v122 + 3712);
          char v124 = *(void **)(*v38 + 144 * v120 + 96);
          unint64_t v125 = v124[6] - v124[5];
          unint64_t v126 = v124[1];
          double v225 = 0;
          *(void *)&long long v226 = v125 / v126;
          if (v126 <= v125) {
            gm::MultiRange<unsigned long>::push_back(v123, &v225);
          }
          uint64_t v127 = ggl::Batcher::commit((long long **)v123, 0xC8u, v117);
          uint64_t v128 = *((void *)this + 47);
          double v225 = &off_1EF55A458;
          long long v226 = v212;
          __n128 v227 = v213;
          __n128 v231 = *(__n128 *)&v215[32];
          long long v232 = *(_OWORD *)&v215[48];
          long long v228 = v214;
          long long v229 = *(_OWORD *)v215;
          long long v230 = *(_OWORD *)&v215[16];
          char v129 = *(void **)(v128 + 3800);
          uint64_t v130 = v129[1];
          if (v130 == *(void *)(v128 + 3808))
          {
            char v129 = (void *)*v129;
            if (!v129)
            {
              char v129 = malloc_type_malloc(120 * v130 + 16, 0xB644C221uLL);
              void *v129 = 0;
              v129[1] = 0;
              **(void **)(v128 + 3800) = v129;
            }
            *(void *)(v128 + 3800) = v129;
            uint64_t v130 = v129[1];
          }
          float v131 = &v129[15 * v130];
          double v132 = v131 + 2;
          v129[1] = v130 + 1;
          v131[2] = &off_1EF55A458;
          __n128 v117 = v231;
          long long v133 = v232;
          long long v134 = v230;
          *(_OWORD *)(v131 + 9) = v229;
          long long v135 = v226;
          __n128 v136 = v227;
          *(_OWORD *)(v131 + 7) = v228;
          *(__n128 *)(v131 + 5) = v136;
          *(_OWORD *)(v131 + 3) = v135;
          *(_OWORD *)(v131 + 15) = v133;
          *(__n128 *)(v131 + 13) = v117;
          *(_OWORD *)(v131 + 11) = v134;
          v131[10] = v119;
          double v137 = *v127;
          v131[13] = *v127;
          v131[14] = (v127[1] - v137) >> 4;
          double v138 = *(void **)(v6 + 80);
          unint64_t v139 = *(void *)(v6 + 88);
          if ((unint64_t)v138 < v139)
          {
            if (v138) {
              *double v138 = v132;
            }
            double v140 = v138 + 1;
            goto LABEL_203;
          }
          uint64_t v141 = *(void *)(v6 + 72);
          uint64_t v142 = ((uint64_t)v138 - v141) >> 3;
          unint64_t v143 = v142 + 1;
          if ((unint64_t)(v142 + 1) >> 61) {
            goto LABEL_252;
          }
          uint64_t v144 = v139 - v141;
          if (v144 >> 2 > v143) {
            unint64_t v143 = v144 >> 2;
          }
          if ((unint64_t)v144 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v145 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v145 = v143;
          }
          if (v145)
          {
            uint64_t v146 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 96) + 16))(*(void *)(v6 + 96), 8 * v145, 8);
            double v147 = (void *)(v146 + 8 * v142);
            uint64_t v148 = v146 + 8 * v145;
            if (v146) {
              *double v147 = v132;
            }
          }
          else
          {
            uint64_t v148 = 0;
            double v147 = (void *)(8 * v142);
          }
          uint64_t v150 = *(void *)(v6 + 72);
          uint64_t v149 = *(void *)(v6 + 80);
          uint64_t v151 = v149 - v150;
          if (v149 == v150)
          {
            int v153 = v147;
            goto LABEL_201;
          }
          unint64_t v152 = v151 - 8;
          if ((unint64_t)(v151 - 8) < 0x38)
          {
            int v153 = v147;
          }
          else
          {
            int v153 = v147;
            if ((unint64_t)(v149 - (void)v147) >= 0x20)
            {
              uint64_t v154 = (v152 >> 3) + 1;
              unint64_t v155 = (__n128 *)(v147 - 2);
              uint64_t v156 = (__n128 *)(v149 - 16);
              uint64_t v157 = v154 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                __n128 v117 = *v156;
                v155[-1] = v156[-1];
                *unint64_t v155 = v117;
                v155 -= 2;
                v156 -= 2;
                v157 -= 4;
              }
              while (v157);
              int v153 = &v147[-(v154 & 0x3FFFFFFFFFFFFFFCLL)];
              v149 -= 8 * (v154 & 0x3FFFFFFFFFFFFFFCLL);
              if (v154 == (v154 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_200;
              }
            }
          }
          do
          {
            uint64_t v158 = *(void *)(v149 - 8);
            v149 -= 8;
            *--int v153 = v158;
          }
          while (v149 != v150);
LABEL_200:
          uint64_t v149 = *(void *)(v6 + 72);
LABEL_201:
          double v140 = v147 + 1;
          *(void *)(v6 + 72) = v153;
          *(void *)(v6 + 80) = v147 + 1;
          uint64_t v159 = *(void *)(v6 + 88);
          *(void *)(v6 + 88) = v148;
          if (v149) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 96) + 40))(*(void *)(v6 + 96), v149, v159 - v149);
          }
LABEL_203:
          *(void *)(v6 + 80) = v140;
          if (v31 < 1.0 || *((unsigned char *)this + 393)) {
            goto LABEL_169;
          }
          uint64_t v160 = *((void *)this + 47);
          double v225 = &off_1EF55A458;
          long long v226 = v204;
          __n128 v227 = v205;
          __n128 v231 = v209;
          long long v232 = v210;
          long long v228 = v206;
          long long v229 = v207;
          long long v230 = v208;
          float32x2_t v161 = *(void **)(v160 + 3800);
          uint64_t v162 = v161[1];
          if (v162 == *(void *)(v160 + 3808))
          {
            float32x2_t v161 = (void *)*v161;
            if (!v161)
            {
              float32x2_t v161 = malloc_type_malloc(120 * v162 + 16, 0xB644C221uLL);
              *float32x2_t v161 = 0;
              v161[1] = 0;
              **(void **)(v160 + 3800) = v161;
            }
            *(void *)(v160 + 3800) = v161;
            uint64_t v162 = v161[1];
          }
          double v163 = &v161[15 * v162];
          double v164 = v163 + 2;
          v161[1] = v162 + 1;
          v163[2] = &off_1EF55A458;
          __n128 v117 = v231;
          long long v165 = v232;
          long long v166 = v230;
          *(_OWORD *)(v163 + 9) = v229;
          long long v167 = v226;
          __n128 v168 = v227;
          *(_OWORD *)(v163 + 7) = v228;
          *(__n128 *)(v163 + 5) = v168;
          *(_OWORD *)(v163 + 3) = v167;
          *(_OWORD *)(v163 + 15) = v165;
          *(__n128 *)(v163 + 13) = v117;
          *(_OWORD *)(v163 + 11) = v166;
          v163[10] = v119;
          long double v169 = *v127;
          v163[13] = *v127;
          v163[14] = (v127[1] - v169) >> 4;
          long double v170 = *(void **)(v6 + 80);
          unint64_t v171 = *(void *)(v6 + 88);
          if ((unint64_t)v170 >= v171)
          {
            uint64_t v172 = *(void *)(v6 + 72);
            uint64_t v173 = ((uint64_t)v170 - v172) >> 3;
            unint64_t v174 = v173 + 1;
            if ((unint64_t)(v173 + 1) >> 61) {
LABEL_252:
            }
              abort();
            uint64_t v175 = v171 - v172;
            if (v175 >> 2 > v174) {
              unint64_t v174 = v175 >> 2;
            }
            if ((unint64_t)v175 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v176 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v176 = v174;
            }
            if (v176)
            {
              uint64_t v177 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 96) + 16))(*(void *)(v6 + 96), 8 * v176, 8);
              double v178 = (void *)(v177 + 8 * v173);
              uint64_t v179 = v177 + 8 * v176;
              if (v177) {
                void *v178 = v164;
              }
            }
            else
            {
              uint64_t v179 = 0;
              double v178 = (void *)(8 * v173);
            }
            uint64_t v181 = *(void *)(v6 + 72);
            uint64_t v180 = *(void *)(v6 + 80);
            uint64_t v182 = v180 - v181;
            if (v180 != v181)
            {
              unint64_t v183 = v182 - 8;
              if ((unint64_t)(v182 - 8) < 0x38)
              {
                __double2 v184 = v178;
              }
              else
              {
                __double2 v184 = v178;
                if ((unint64_t)(v180 - (void)v178) >= 0x20)
                {
                  uint64_t v185 = (v183 >> 3) + 1;
                  __double2 v186 = (__n128 *)(v178 - 2);
                  double v187 = (__n128 *)(v180 - 16);
                  uint64_t v188 = v185 & 0x3FFFFFFFFFFFFFFCLL;
                  do
                  {
                    __n128 v117 = *v187;
                    v186[-1] = v187[-1];
                    *__double2 v186 = v117;
                    v186 -= 2;
                    v187 -= 2;
                    v188 -= 4;
                  }
                  while (v188);
                  __double2 v184 = &v178[-(v185 & 0x3FFFFFFFFFFFFFFCLL)];
                  v180 -= 8 * (v185 & 0x3FFFFFFFFFFFFFFCLL);
                  if (v185 == (v185 & 0x3FFFFFFFFFFFFFFCLL))
                  {
LABEL_233:
                    uint64_t v180 = *(void *)(v6 + 72);
LABEL_234:
                    double v121 = v178 + 1;
                    *(void *)(v6 + 72) = v184;
                    *(void *)(v6 + 80) = v178 + 1;
                    uint64_t v190 = *(void *)(v6 + 88);
                    *(void *)(v6 + 88) = v179;
                    if (v180) {
                      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 96) + 40))(*(void *)(v6 + 96), v180, v190 - v180);
                    }
                    goto LABEL_168;
                  }
                }
              }
              do
              {
                uint64_t v189 = *(void *)(v180 - 8);
                v180 -= 8;
                *--__double2 v184 = v189;
              }
              while (v180 != v181);
              goto LABEL_233;
            }
            __double2 v184 = v178;
            goto LABEL_234;
          }
          if (v170) {
            *long double v170 = v164;
          }
          double v121 = v170 + 1;
LABEL_168:
          *(void *)(v6 + 80) = v121;
LABEL_169:
          ++v120;
          v119 += 144;
          if (v119 == v203) {
            goto LABEL_238;
          }
        }
      }
LABEL_74:
      v38 += 9;
      if (v38 != v202) {
        continue;
      }
      break;
    }
    uint64_t v35 = v224;
LABEL_245:
    if (v35)
    {
      if (!atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
        std::__shared_weak_count::__release_weak(v35);
      }
    }
    float32x2_t v29 = v200 + 1;
    if (v200 + 1 != v195) {
      continue;
    }
    break;
  }
}

void sub_1A213F72C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,char a61,uint64_t a62,uint64_t a63)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a59);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a61);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a72);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void md::VenueRenderLayer::_forEachVisibleVenueGroup(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v129 = *(id *)(*(void *)(a1 + 40) + 104);
  unint64_t v5 = *(int8x8_t **)(a2 + 8);
  int8x8_t v6 = v5[1];
  if (!*(void *)&v6)
  {
    uint64_t v9 = 0;
    uint64_t v127 = 0;
    uint64_t v128 = 0;
    goto LABEL_72;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v8 = 0x1AF456233693CD46;
    if (*(void *)&v6 <= 0x1AF456233693CD46uLL) {
      uint64_t v8 = 0x1AF456233693CD46uLL % *(void *)&v6;
    }
  }
  else
  {
    uint64_t v8 = (*(void *)&v6 - 1) & 0x1AF456233693CD46;
  }
  int8x8_t v10 = *v5;
  uint64_t v11 = *(void **)(*(void *)v5 + 8 * v8);
  if (!v11) {
    goto LABEL_25;
  }
  uint64_t v12 = (void *)*v11;
  if (!v12) {
    goto LABEL_25;
  }
  if (v7.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v14 = v12[1];
      if (v14 == 0x1AF456233693CD46)
      {
        if (v12[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v14 & (*(void *)&v6 - 1)) != v8)
      {
        goto LABEL_25;
      }
      uint64_t v12 = (void *)*v12;
      if (!v12) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v13 = v12[1];
    if (v13 == 0x1AF456233693CD46) {
      break;
    }
    if (v13 >= *(void *)&v6) {
      v13 %= *(void *)&v6;
    }
    if (v13 != v8) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v12 = (void *)*v12;
    if (!v12) {
      goto LABEL_25;
    }
  }
  if (v12[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v15 = v12[5];
  if (*(void *)(v15 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v128 = *(void *)(v15 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v128 = 0;
LABEL_26:
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v16 = 0x4927EB92E562CC46;
    if (*(void *)&v6 <= 0x4927EB92E562CC46uLL) {
      uint64_t v16 = 0x4927EB92E562CC46uLL % *(void *)&v6;
    }
  }
  else
  {
    uint64_t v16 = (*(void *)&v6 - 1) & 0x4927EB92E562CC46;
  }
  uint64_t v17 = *(void **)(*(void *)&v10 + 8 * v16);
  if (!v17) {
    goto LABEL_48;
  }
  uint64_t v18 = (void *)*v17;
  if (!v18) {
    goto LABEL_48;
  }
  if (v7.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v20 = v18[1];
      if (v20 == 0x4927EB92E562CC46)
      {
        if (v18[2] == 0x4927EB92E562CC46) {
          goto LABEL_46;
        }
      }
      else if ((v20 & (*(void *)&v6 - 1)) != v16)
      {
        goto LABEL_48;
      }
      uint64_t v18 = (void *)*v18;
      if (!v18) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v19 = v18[1];
    if (v19 != 0x4927EB92E562CC46)
    {
      if (v19 >= *(void *)&v6) {
        v19 %= *(void *)&v6;
      }
      if (v19 != v16) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v18[2] != 0x4927EB92E562CC46)
    {
LABEL_35:
      uint64_t v18 = (void *)*v18;
      if (!v18) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v21 = v18[5];
  if (*(void *)(v21 + 8) == 0x4927EB92E562CC46)
  {
    uint64_t v9 = *(int8x8_t **)(v21 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v9 = 0;
LABEL_49:
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v22 = 0xA60DDA5A69582425;
    if (*(void *)&v6 <= 0xA60DDA5A69582425) {
      unint64_t v22 = 0xA60DDA5A69582425 % *(void *)&v6;
    }
  }
  else
  {
    unint64_t v22 = (*(void *)&v6 - 1) & 0xA60DDA5A69582425;
  }
  unint64_t v23 = *(void **)(*(void *)&v10 + 8 * v22);
  if (!v23) {
    goto LABEL_71;
  }
  uint64_t v24 = (void *)*v23;
  if (!v24) {
    goto LABEL_71;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v25 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v27 = v24[1];
      if (v27 == 0xA60DDA5A69582425)
      {
        if (v24[2] == 0xA60DDA5A69582425) {
          goto LABEL_69;
        }
      }
      else if ((v27 & v25) != v22)
      {
        goto LABEL_71;
      }
      uint64_t v24 = (void *)*v24;
      if (!v24) {
        goto LABEL_71;
      }
    }
  }
  while (2)
  {
    unint64_t v26 = v24[1];
    if (v26 != 0xA60DDA5A69582425)
    {
      if (v26 >= *(void *)&v6) {
        v26 %= *(void *)&v6;
      }
      if (v26 != v22) {
        goto LABEL_71;
      }
      goto LABEL_58;
    }
    if (v24[2] != 0xA60DDA5A69582425)
    {
LABEL_58:
      uint64_t v24 = (void *)*v24;
      if (!v24) {
        goto LABEL_71;
      }
      continue;
    }
    break;
  }
LABEL_69:
  uint64_t v28 = v24[5];
  if (*(void *)(v28 + 8) == 0xA60DDA5A69582425)
  {
    uint64_t v127 = *(id **)(v28 + 32);
    goto LABEL_72;
  }
LABEL_71:
  uint64_t v127 = 0;
LABEL_72:
  md::LayoutContext::zoomAtCentrePoint(v5);
  uint64_t v30 = *(uint64_t **)(a1 + 272);
  unint64_t v126 = *(uint64_t **)(a1 + 280);
  if (v30 == v126) {
    goto LABEL_210;
  }
  float v31 = v29;
  uint64_t v32 = a1 + 384;
  float v33 = ceilf(v29);
  double v132 = (double *)&v9[18];
LABEL_75:
  uint64_t v34 = *(void *)(*v30 + 384);
  char v35 = *(unsigned char *)(v34 + 169);
  double v36 = *(double *)(v128 + 3768);
  double v37 = *(double *)(v128 + 1368);
  uint64_t v39 = *(void *)(*v30 + 216);
  uint64_t v38 = *(std::__shared_weak_count **)(*v30 + 224);
  uint64_t v138 = *v30;
  uint64_t v161 = v39;
  uint64_t v162 = v38;
  if (v38) {
    atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if ((*(unsigned char *)(v39 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    *(void *)&v140.f64[0] = v164;
    v148[0] = &v140;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v148, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  uint64_t v40 = *(float32x4_t **)(v39 + 72);
  float32x4_t v41 = v40[1];
  float32x4_t v157 = *v40;
  float32x4_t v158 = v41;
  float32x4_t v42 = v40[3];
  float32x4_t v159 = v40[2];
  float32x4_t v160 = v42;
  int v43 = ggl::CullingGrid::intersectedCellsForView(v157.f32, 0.0);
  unsigned int v44 = *(_DWORD *)(v34 + 744);
  v148[0] = &v161;
  [v129 size];
  v148[1] = v45;
  v148[2] = v46;
  int v47 = *(unsigned __int8 *)(v34 + 169);
  char v149 = *(unsigned char *)(v34 + 169);
  float v150 = v31;
  int v151 = 1065353216;
  __int32 v152 = v9[35].i32[1];
  double v153 = v36 * (double)(1 << v35) / v37;
  int v154 = v43;
  uint64_t v48 = (uint64_t)(float)v44;
  if (v48)
  {
    if (v48 < 513)
    {
      int v49 = 0;
      uint64_t i = 512;
    }
    else
    {
      int v49 = 0;
      for (uint64_t i = 512; i < v48; i *= 2)
        ++v49;
    }
    while (i > v48)
    {
      --v49;
      v48 *= 2;
    }
  }
  else
  {
    int v49 = 0;
  }
  float v155 = exp2f(v33 - (float)(v49 + v47)) * (float)v44;
  id v51 = *v127;
  [v51 textureManager];
  int v135 = v43;
  uint64_t v130 = v30;
  float64_t v52 = v140.f64[1];
  uint64_t v156 = **(void **)&v140.f64[0];
  if (*(void *)&v140.f64[1]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v140.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(float64_t))(**(void **)&v52 + 16))(COERCE_FLOAT64_T(*(void *)&v52));
    std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v52);
  }

  uint64_t v53 = *(void *)(v34 + 752);
  uint64_t v139 = *(void *)(v34 + 760);
  uint64_t v54 = v9 + 2;
  if (v53 == v139) {
    goto LABEL_207;
  }
  uint64_t v133 = v138 + 88;
  while (2)
  {
    if (!*(unsigned char *)(a1 + 393))
    {
      id v65 = *(id *)(v53 + 8);
      if (v65)
      {
        float32x4_t v66 = v65;
        BOOL shouldCullPolygonGroup = md::VenueLayerLayoutCharacteristics::shouldCullPolygonGroup(v32, v138, [v65 buildingId], objc_msgSend(v66, "layer"), objc_msgSend(v66, "cullingMask"), v135);

        if (shouldCullPolygonGroup) {
          goto LABEL_94;
        }
      }
    }
    id v55 = *(id *)(v53 + 8);
    uint64_t v56 = [v55 buildingId];

    double v57 = v54;
    do
    {
      double v57 = (int8x8_t *)*v57;
      if (!v57) {
        goto LABEL_94;
      }
      int8x8_t v58 = v57[3];
      int v60 = *(uint64_t **)(*(void *)&v58 + 16);
      uint64_t v59 = *(uint64_t **)(*(void *)&v58 + 24);
      if (v60 != v59)
      {
        while (v60[3] != v56)
        {
          v60 += 15;
          if (v60 == v59)
          {
            int v60 = v59;
            break;
          }
        }
      }
    }
    while (v60 == v59);
    if (!v60) {
      goto LABEL_94;
    }
    int8x8_t v61 = v9[6];
    if (!*(void *)&v61) {
      goto LABEL_127;
    }
    unint64_t v62 = v60[3];
    uint8x8_t v63 = (uint8x8_t)vcnt_s8(v61);
    v63.i16[0] = vaddlv_u8(v63);
    if (v63.u32[0] > 1uLL)
    {
      unint64_t v64 = v60[3];
      if (v62 >= *(void *)&v61) {
        unint64_t v64 = v62 % *(void *)&v61;
      }
    }
    else
    {
      unint64_t v64 = (*(void *)&v61 - 1) & v62;
    }
    uint64_t v68 = *(void **)(*(void *)&v9[5] + 8 * v64);
    if (!v68 || (unint64_t v69 = (void *)*v68) == 0)
    {
LABEL_127:
      uint64_t v73 = (unsigned __int16 *)(v60 + 7);
      goto LABEL_128;
    }
    if (v63.u32[0] < 2uLL)
    {
      uint64_t v70 = *(void *)&v61 - 1;
      while (1)
      {
        uint64_t v72 = v69[1];
        if (v62 == v72)
        {
          if (v69[2] == v62) {
            goto LABEL_206;
          }
        }
        else if ((v72 & v70) != v64)
        {
          goto LABEL_127;
        }
        unint64_t v69 = (void *)*v69;
        if (!v69) {
          goto LABEL_127;
        }
      }
    }
    while (2)
    {
      unint64_t v71 = v69[1];
      if (v62 != v71)
      {
        if (v71 >= *(void *)&v61) {
          v71 %= *(void *)&v61;
        }
        if (v71 != v64) {
          goto LABEL_127;
        }
        goto LABEL_117;
      }
      if (v69[2] != v62)
      {
LABEL_117:
        unint64_t v69 = (void *)*v69;
        if (!v69) {
          goto LABEL_127;
        }
        continue;
      }
      break;
    }
LABEL_206:
    uint64_t v73 = (unsigned __int16 *)(v69 + 3);
LABEL_128:
    uint64_t v75 = *v60;
    uint64_t v74 = v60[1];
    if (*v60 == v74)
    {
      BOOL v137 = 0;
    }
    else
    {
      int v76 = *v73;
      while (*(unsigned __int16 *)(v75 + 8) != v76)
      {
        v75 += 184;
        if (v75 == v74)
        {
          uint64_t v75 = v60[1];
          break;
        }
      }
      BOOL v137 = v75 != v74;
    }
    id v77 = *(id *)(v53 + 8);
    signed __int16 v78 = [v77 layer];

    int v136 = *((__int16 *)v60 + 28);
    int v79 = md::VenueLogicContext::displayedFloorOrdinalForVenueBuildingId(v9, v56);
    int v80 = v78;
    int v134 = v79;
    if (*(unsigned char *)(a1 + 438))
    {
      if ((*(unsigned char *)(*(void *)(v138 + 232) + 16) & 2) == 0
        && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
      {
        *(void *)&v140.f64[0] = &v163;
        v164[0] = &v140;
        std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v164, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
      }
      id v81 = *(id *)(v53 + 8);
      md::VenueLayerLayoutCharacteristics::offsetLevel(v140.f64, v32, v132, v133, v60, v80);
      float32x4_t v157 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v140), v141);
      float32x4_t v158 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v142), v143);
      float32x4_t v159 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v144), v145);
      float32x4_t v160 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v146), v147);

      double v82 = md::PolygonViewConstantsFrameCache::pop((md::PolygonViewConstantsFrameCache *)(*(void *)(a1 + 368) + 240));
      long double v83 = (void *)v148[0];
      uint64_t v85 = *v82;
      uint64_t v84 = v82[1];
      if (v84) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v84 + 8), 1uLL, memory_order_relaxed);
      }
      float32x4_t v86 = (std::__shared_weak_count *)v83[1];
      *long double v83 = v85;
      v83[1] = v84;
      if (v86 && !atomic_fetch_add(&v86->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
        std::__shared_weak_count::__release_weak(v86);
      }
      float32x4_t v87 = v158;
      float32x4_t v88 = v159;
      float32x4_t v89 = v160;
      uint64_t v90 = *(void *)v148[0];
      unint64_t v91 = *(void *)(*(void *)v148[0] + 8);
      float v92 = *(float32x4_t **)(*(void *)v148[0] + 72);
      *float v92 = v157;
      v92[1] = v87;
      v92[2] = v88;
      v92[3] = v89;
      if (*(void *)(v90 + 64) > v91) {
        unint64_t v91 = *(void *)(v90 + 64);
      }
      *(void *)(v90 + 56) = 0;
      *(void *)(v90 + 64) = v91;
      uint64_t v93 = v161;
      if ((*(unsigned char *)(v161 + 16) & 2) == 0
        && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
      {
        *(void *)&v140.f64[0] = &v163;
        v164[0] = &v140;
        goto LABEL_149;
      }
      goto LABEL_170;
    }
    char v94 = !v137;
    if (v78 != v79) {
      char v94 = 1;
    }
    if ((v94 & 1) == 0 && *(unsigned char *)(a1 + 393))
    {
      if ((*(unsigned char *)(*(void *)(v138 + 232) + 16) & 2) == 0
        && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
      {
        *(void *)&v140.f64[0] = &v163;
        v164[0] = &v140;
        std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v164, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
      }
      if (*(unsigned char *)(a1 + 438)) {
        unsigned __int16 v95 = v78;
      }
      else {
        unsigned __int16 v95 = v136;
      }
      id v96 = *(id *)(v53 + 8);
      md::VenueLayerLayoutCharacteristics::offsetLevel(v140.f64, v32, v132, v133, v60, v95);
      float32x4_t v157 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v140), v141);
      float32x4_t v158 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v142), v143);
      float32x4_t v159 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v144), v145);
      float32x4_t v160 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v146), v147);

      int8x16_t v97 = md::PolygonViewConstantsFrameCache::pop((md::PolygonViewConstantsFrameCache *)(*(void *)(a1 + 368) + 240));
      int8x16_t v98 = (void *)v148[0];
      uint64_t v100 = *v97;
      uint64_t v99 = v97[1];
      if (v99) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v99 + 8), 1uLL, memory_order_relaxed);
      }
      unint64_t v101 = (std::__shared_weak_count *)v98[1];
      *int8x16_t v98 = v100;
      v98[1] = v99;
      if (v101 && !atomic_fetch_add(&v101->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v101->__on_zero_shared)(v101);
        std::__shared_weak_count::__release_weak(v101);
      }
      int v154 = ggl::CullingGrid::intersectedCellsForView(v157.f32, 0.0);
      float32x4_t v102 = v158;
      float32x4_t v103 = v159;
      float32x4_t v104 = v160;
      uint64_t v105 = *(void *)v148[0];
      unint64_t v106 = *(void *)(*(void *)v148[0] + 8);
      uint64_t v107 = *(float32x4_t **)(*(void *)v148[0] + 72);
      *uint64_t v107 = v157;
      v107[1] = v102;
      v107[2] = v103;
      v107[3] = v104;
      if (*(void *)(v105 + 64) > v106) {
        unint64_t v106 = *(void *)(v105 + 64);
      }
      *(void *)(v105 + 56) = 0;
      *(void *)(v105 + 64) = v106;
      uint64_t v93 = v161;
      if ((*(unsigned char *)(v161 + 16) & 2) == 0
        && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
      {
        *(void *)&v140.f64[0] = &v163;
        v164[0] = &v140;
LABEL_149:
        std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, v164, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
      }
LABEL_170:
      uint64_t v108 = *(void *)v148[0];
      unint64_t v109 = *(void *)(*(void *)v148[0] + 8);
      *(_DWORD *)(*(void *)(*(void *)v148[0] + 72) + 64) = *(_DWORD *)(*(void *)(v93 + 72) + 64);
      if (*(void *)(v108 + 64) > v109) {
        unint64_t v109 = *(void *)(v108 + 64);
      }
      *(void *)(v108 + 56) = 0;
      *(void *)(v108 + 64) = v109;
    }
    id v110 = *(id *)(v53 + 8);
    double v111 = v110;
    if (v110)
    {
      BOOL v112 = md::VenueLayerLayoutCharacteristics::shouldCullPolygonGroup(v32, v138, [v110 buildingId], objc_msgSend(v110, "layer"), objc_msgSend(v110, "cullingMask"), v135);

      if (v112)
      {

        if (*(unsigned char *)(a1 + 438))
        {
          LOBYTE(v113) = 0;
          goto LABEL_197;
        }
        goto LABEL_94;
      }
    }
    uint64_t v114 = v32;
    id v115 = *(id *)(v53 + 8);
    int v116 = md::VenueLogicContext::displayedFloorOrdinalForVenueBuildingId(*(int8x8_t **)(a1 + 440), [v115 buildingId]);
    int v117 = [v115 layer];
    if (!*(unsigned char *)(a1 + 393)) {
      goto LABEL_189;
    }
    __int16 v118 = [v115 layer];
    if (v115)
    {
      [v115 styleAttributes];
      if (*(void *)&v140.f64[0])
      {
        v140.f64[1] = v140.f64[0];
        (*(void (**)(void, void, void))(**(void **)&v141.f64[1] + 40))(*(void *)&v141.f64[1], *(void *)&v140.f64[0], *(void *)&v141.f64[0] - *(void *)&v140.f64[0]);
      }
    }
    float64_t v119 = v140.f64[0];
    if (*(void *)&v140.f64[0] == *(void *)&v140.f64[1])
    {
LABEL_189:

      BOOL v113 = v137;
      if (v117 != v116) {
LABEL_194:
      }
        BOOL v113 = 0;
    }
    else
    {
      while (1)
      {
        int v120 = *(unsigned __int16 *)(*(void *)&v119 + 4);
        if (**(_DWORD **)&v119 == 3 && v120 == 113) {
          break;
        }
        if (**(_DWORD **)&v119 == 3 && v120 == 31)
        {

          goto LABEL_194;
        }
        *(void *)&v119 += 8;
        if (*(void *)&v119 == *(void *)&v140.f64[1]) {
          goto LABEL_189;
        }
      }

      BOOL v122 = v116 < v118;
      BOOL v113 = v137;
      if (v122) {
        goto LABEL_194;
      }
    }

    uint64_t v32 = v114;
    if (*(unsigned char *)(a1 + 438))
    {
      uint64_t v54 = v9 + 2;
LABEL_197:
      BOOL v122 = v80 >= v136 && v80 < v134;
      if (v122 || v113) {
        goto LABEL_204;
      }
LABEL_94:
      v53 += 24;
      if (v53 != v139) {
        continue;
      }
LABEL_207:
      unint64_t v125 = v162;
      if (v162)
      {
        if (!atomic_fetch_add(&v162->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v125->__on_zero_shared)(v125);
          std::__shared_weak_count::__release_weak(v125);
        }
      }
      uint64_t v30 = v130 + 1;
      if (v130 + 1 != v126) {
        goto LABEL_75;
      }
LABEL_210:
    }
    else
    {
      uint64_t v54 = v9 + 2;
      if (!v113) {
        goto LABEL_94;
      }
LABEL_204:
      id v123 = *(id *)(v53 + 8);
      *(void *)&v140.f64[0] = v123;
      uint64_t v124 = *(void *)(a3 + 24);
      if (v124)
      {
        (*(void (**)(uint64_t, float64x2_t *, void *))(*(void *)v124 + 48))(v124, &v140, v148);

        goto LABEL_94;
      }
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
    }
    break;
  }
}

void sub_1A21408D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v13 - 168);

  _Unwind_Resume(a1);
}

void *std::function<void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::VenueRenderLayer::_layoutOpenToBelowAreas(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::_layoutOpenToBelowAreas(md::LayoutContext const&)::$_0>,void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::operator()(uint64_t a1, id *a2, uint64_t a3)
{
  uint64_t v278 = *MEMORY[0x1E4F143B8];
  id v5 = *a2;
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v8 = **(void **)(a1 + 24);
  uint64_t v9 = (VKPolygonGroup *)v5;
  int8x8_t v10 = (md::VenueLayerLayoutCharacteristics *)(v7 + 384);
  LOBYTE(v263) = 0;
  BYTE1(v263) = md::VenueLayerLayoutCharacteristics::focusState((md::VenueLayerLayoutCharacteristics *)(v7 + 384), v9);
  uint64_t v11 = [(VKPolygonalItemGroup *)v9 styleQueries:&v263];
  uint64_t v12 = *(uint64_t **)v11;
  uint64_t v255 = v7;
  if (*(void *)(v11 + 8) == *(void *)v11) {
    goto LABEL_42;
  }
  uint64_t v13 = *v12;
  uint64_t v14 = (std::__shared_weak_count *)v12[1];
  uint64_t v258 = (void (**)(ggl::RenderItem *__hidden))*v12;
  *(void *)&long long v259 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v263, v13, (uint64_t)v14);
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
    if (!BYTE8(v265)) {
      goto LABEL_41;
    }
  }
  else if (!BYTE8(v265))
  {
    goto LABEL_41;
  }
  uint64_t v15 = (uint64_t)v263[3];
  if ((int)*(float *)(a3 + 28) >= 0x17) {
    unsigned int v16 = 23;
  }
  else {
    unsigned int v16 = (int)*(float *)(a3 + 28);
  }
  uint64_t v17 = *(float **)v15;
  if (!*(void *)v15)
  {
    BOOL v19 = 0;
    goto LABEL_21;
  }
  float v18 = *v17;
  BOOL v19 = *v17 == 1.0;
  if (!*(unsigned char *)(v15 + 10) || (v18 != 0.0 ? (BOOL v20 = v18 == 1.0) : (BOOL v20 = 1), v20))
  {
LABEL_21:
    unsigned int v21 = *(unsigned __int8 *)(v15 + v19 + 11);
    if (v21 != 2) {
      goto LABEL_24;
    }
  }
  if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd((uint64_t)v263[3], 0x93u, v16, 0)) {
    goto LABEL_25;
  }
  unsigned int v21 = 1;
LABEL_24:
  if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v15, 0x93u, v16, v21)) {
    goto LABEL_41;
  }
LABEL_25:
  if (v17)
  {
    float v22 = *v17;
    BOOL v23 = *v17 == 1.0;
    if (*(unsigned char *)(v15 + 10))
    {
      if (v22 != 0.0 && v22 != 1.0) {
        goto LABEL_35;
      }
    }
  }
  else
  {
    BOOL v23 = 0;
  }
  unsigned int v25 = *(unsigned __int8 *)(v15 + v23 + 11);
  if (v25 != 2) {
    goto LABEL_37;
  }
LABEL_35:
  if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v15, 0x92u, v16, 0) & 1) == 0)
  {
    unsigned int v25 = 1;
LABEL_37:
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v15, 0x92u, v16, v25)) {
      goto LABEL_38;
    }
LABEL_41:
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v263);
    uint64_t v7 = v255;
    goto LABEL_42;
  }
LABEL_38:
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v263);
  unint64_t v26 = *(void **)(v6 + 8);
  int8x8_t v27 = (int8x8_t)v26[1];
  uint64_t v7 = v255;
  if (v27)
  {
    uint8x8_t v28 = (uint8x8_t)vcnt_s8(v27);
    v28.i16[0] = vaddlv_u8(v28);
    if (v28.u32[0] > 1uLL)
    {
      uint64_t v29 = 0x3070CB6B3C7F21D3;
      if (*(void *)&v27 <= 0x3070CB6B3C7F21D3uLL) {
        uint64_t v29 = 0x3070CB6B3C7F21D3uLL % *(void *)&v27;
      }
    }
    else
    {
      uint64_t v29 = (*(void *)&v27 - 1) & 0x3070CB6B3C7F21D3;
    }
    uint64_t v53 = *(void **)(*v26 + 8 * v29);
    if (v53)
    {
      uint64_t v54 = (void *)*v53;
      if (v54)
      {
        if (v28.u32[0] < 2uLL)
        {
          uint64_t v55 = *(void *)&v27 - 1;
          while (1)
          {
            uint64_t v57 = v54[1];
            if (v57 == 0x3070CB6B3C7F21D3)
            {
              if (v54[2] == 0x3070CB6B3C7F21D3) {
                goto LABEL_168;
              }
            }
            else if ((v57 & v55) != v29)
            {
              goto LABEL_42;
            }
            uint64_t v54 = (void *)*v54;
            if (!v54) {
              goto LABEL_42;
            }
          }
        }
        do
        {
          unint64_t v56 = v54[1];
          if (v56 == 0x3070CB6B3C7F21D3)
          {
            if (v54[2] == 0x3070CB6B3C7F21D3)
            {
LABEL_168:
              uint64_t v100 = v54[5];
              if (*(void *)(v100 + 8) == 0x3070CB6B3C7F21D3 && *(void *)(v100 + 32))
              {
                uint64_t v101 = ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::pop(*(void *)(*(void *)(v255 + 376) + 2008));
                ggl::GlobeAtmosphere::BasePipelineSetup::setConstantsConstantData(*(void **)(v101 + 64), *(void **)(v101 + 160), **(void **)a3, *(void *)(*(void *)a3 + 8));
                md::GeometryLogic::createUnitTransformConstantData((md::GeometryLogic *)&v263);
                float32x4_t v102 = (std::__shared_weak_count *)v264;
                ggl::GlobeAtmosphere::BasePipelineSetup::setLightConfigConstantData(*(void *)(v101 + 64), *(void *)(v101 + 160), (uint64_t)v263, v264);
                if (v102 && !atomic_fetch_add(&v102->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v102->__on_zero_shared)(v102);
                  std::__shared_weak_count::__release_weak(v102);
                }
                unint64_t v103 = *(void *)(*(void *)(v101 + 64) + 32);
                *(void *)&long long v261 = 0;
                uint64_t v258 = 0;
                *(void *)&long long v259 = 0;
                uint64_t v104 = *(void *)(v103 + 8);
                double v263 = 0;
                long long v264 = v103;
                *(void *)&long long v265 = v104;
                WORD4(v265) = 1;
                if (v104) {
                  uint64_t v105 = *(void *)(v103 + 72);
                }
                else {
                  uint64_t v105 = 0;
                }
                uint64_t v7 = v255;
                *(void *)&long long v266 = v105;
                ggl::BufferMemory::operator=((uint64_t *)&v258, (uint64_t)&v263);
                ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v263);
                float32x4_t v222 = [(VKPolygonalItemGroup *)v9 origin];
                *(void *)(v261 + 16) = *v222;
                [(VKPolygonalItemGroup *)v9 size];
                uint64_t v223 = v261;
                *(_DWORD *)(v261 + 24) = v224;
                *(_DWORD *)(v223 + 28) = v225;
                ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v258);
                uint64_t v258 = &off_1EF55A458;
                *((void *)&v259 + 1) = "";
                long long v260 = 0uLL;
                *((void *)&v261 + 1) = 0;
                *(_DWORD *)double v262 = 1065353216;
                memset(&v262[8], 0, 32);
                *(int64x2_t *)&v262[40] = vdupq_n_s64(1uLL);
                *(void *)&v262[56] = 0;
                LODWORD(v261) = *(unsigned __int8 *)(*(void *)(v255 + 376) + 3673);
                int v226 = *(unsigned __int8 *)(v255 + 393);
                uint64_t v253 = a3;
                uint64_t v227 = 20 * (__int16)[(VKPolygonGroup *)v9 layer] + 0x800000003;
                if (!v226) {
                  uint64_t v227 = 0x800000003;
                }
                *((void *)&v261 + 1) = v227;
                *(void *)&long long v260 = *(void *)(v255 + 376) + 2016;
                *((void *)&v260 + 1) = v101;
                uint64_t v228 = [(VKPolygonalItemGroup *)v9 fillMeshes];
                long long v229 = *(uint64_t **)v228;
                unint64_t v257 = *(uint64_t **)(v228 + 8);
                if (*(uint64_t **)v228 != v257)
                {
                  unsigned int v230 = 0;
                  uint64_t v245 = v9;
                  do
                  {
                    uint64_t v231 = *(void *)(v7 + 376);
                    uint64_t v232 = *(unsigned int *)(v253 + 48);
                    unsigned int v273 = (void (**)(ggl::RenderItem *__hidden))&unk_1EF577370;
                    *(void *)&long long v275 = &v273;
                    float v233 = -[VKPolygonalItemGroup commitRangesToFillRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:](v9, "commitRangesToFillRenderItemBatcher:forMeshAtIndex:cullingMask:featureIdPredicate:", v231 + 3712, v230, v232, &v273, v245);
                    if ((void (***)(ggl::RenderItem *__hidden))v275 == &v273)
                    {
                      v273[4]((ggl::RenderItem *)&v273);
                    }
                    else if ((void)v275)
                    {
                      (*(void (**)(void))(*(void *)v275 + 40))(v275);
                    }
                    uint64_t v234 = *(void *)(v255 + 376);
                    uint64_t v235 = *v229;
                    double v263 = &off_1EF55A458;
                    long long v264 = v259;
                    long long v265 = v260;
                    long long v269 = *(_OWORD *)&v262[32];
                    long long v270 = *(_OWORD *)&v262[48];
                    long long v266 = v261;
                    long long v267 = *(_OWORD *)v262;
                    long long v268 = *(_OWORD *)&v262[16];
                    unint64_t v236 = *(void **)(v234 + 3800);
                    uint64_t v237 = v236[1];
                    if (v237 == *(void *)(v234 + 3808))
                    {
                      unint64_t v236 = (void *)*v236;
                      if (!v236)
                      {
                        unint64_t v236 = malloc_type_malloc(120 * v237 + 16, 0xB644C221uLL);
                        void *v236 = 0;
                        v236[1] = 0;
                        **(void **)(v234 + 3800) = v236;
                      }
                      *(void *)(v234 + 3800) = v236;
                      uint64_t v237 = v236[1];
                    }
                    uint64_t v238 = &v236[15 * v237];
                    v236[1] = v237 + 1;
                    v238[2] = &off_1EF55A458;
                    long long v239 = v269;
                    long long v240 = v270;
                    long long v241 = v268;
                    *(_OWORD *)(v238 + 9) = v267;
                    long long v242 = v264;
                    long long v243 = v265;
                    *(_OWORD *)(v238 + 7) = v266;
                    *(_OWORD *)(v238 + 5) = v243;
                    *(_OWORD *)(v238 + 3) = v242;
                    *(_OWORD *)(v238 + 15) = v240;
                    *(_OWORD *)(v238 + 13) = v239;
                    *(_OWORD *)(v238 + 11) = v241;
                    v238[10] = v235;
                    uint64_t v244 = *v233;
                    v238[13] = *v233;
                    v238[14] = (v233[1] - v244) >> 4;
                    uint64_t v9 = v245;
                    ggl::CommandBuffer::pushRenderItem(v8, (uint64_t)(v238 + 2));
                    ++v230;
                    v229 += 2;
                    uint64_t v7 = v255;
                  }
                  while (v229 != v257);
                }
                a3 = v253;
              }
              break;
            }
          }
          else
          {
            if (v56 >= *(void *)&v27) {
              v56 %= *(void *)&v27;
            }
            if (v56 != v29) {
              break;
            }
          }
          uint64_t v54 = (void *)*v54;
        }
        while (v54);
      }
    }
  }
LABEL_42:

  uint64_t v254 = **(void **)(a1 + 24);
  double v256 = v9;
  char v30 = md::VenueLayerLayoutCharacteristics::focusState(v10, v256);
  LOBYTE(v263) = 0;
  BYTE1(v263) = v30;
  uint64_t v31 = [(VKPolygonalItemGroup *)v256 styleQueries:&v263];
  uint64_t v32 = *(uint64_t **)v31;
  if (*(void *)(v31 + 8) == *(void *)v31) {
    goto LABEL_118;
  }
  uint64_t v33 = *v32;
  uint64_t v34 = (std::__shared_weak_count *)v32[1];
  uint64_t v258 = (void (**)(ggl::RenderItem *__hidden))*v32;
  *(void *)&long long v259 = v34;
  if (v34) {
    atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v263, v33, (uint64_t)v34);
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
    if (!BYTE8(v265)) {
      goto LABEL_117;
    }
  }
  else if (!BYTE8(v265))
  {
    goto LABEL_117;
  }
  float v35 = *(float *)(a3 + 28);
  uint64_t v36 = (uint64_t)v263[3];
  if ((int)v35 >= 0x17) {
    unsigned int v37 = 23;
  }
  else {
    unsigned int v37 = (int)v35;
  }
  uint64_t v38 = *(float **)v36;
  if (!*(void *)v36)
  {
    BOOL v40 = 0;
    goto LABEL_62;
  }
  float v39 = *v38;
  BOOL v40 = *v38 == 1.0;
  if (!*(unsigned char *)(v36 + 10) || (v39 != 0.0 ? (BOOL v41 = v39 == 1.0) : (BOOL v41 = 1), v41))
  {
LABEL_62:
    unsigned int v42 = *(unsigned __int8 *)(v36 + v40 + 11);
    if (v42 != 2) {
      goto LABEL_65;
    }
  }
  if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd((uint64_t)v263[3], 0x93u, v37, 0)) {
    goto LABEL_66;
  }
  unsigned int v42 = 1;
LABEL_65:
  if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v36, 0x93u, v37, v42)) {
    goto LABEL_117;
  }
LABEL_66:
  if (!v38)
  {
    BOOL v44 = 0;
    goto LABEL_75;
  }
  float v43 = *v38;
  BOOL v44 = *v38 == 1.0;
  if (!*(unsigned char *)(v36 + 10) || (v43 != 0.0 ? (BOOL v45 = v43 == 1.0) : (BOOL v45 = 1), v45))
  {
LABEL_75:
    unsigned int v46 = *(unsigned __int8 *)(v36 + v44 + 11);
    if (v46 != 2) {
      goto LABEL_78;
    }
  }
  if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v36, 0x92u, v37, 0)) {
    goto LABEL_79;
  }
  unsigned int v46 = 1;
LABEL_78:
  if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v36, 0x92u, v37, v46) & 1) == 0) {
    goto LABEL_117;
  }
LABEL_79:
  if (v38)
  {
    float v47 = *v38;
    BOOL v48 = *v38 == 1.0;
    if (*(unsigned char *)(v36 + 10) && v47 != 0.0 && v47 != 1.0) {
      goto LABEL_86;
    }
  }
  else
  {
    BOOL v48 = 0;
  }
  unsigned int v49 = *(unsigned __int8 *)(v36 + v48 + 11);
  if (v49 != 2) {
    goto LABEL_88;
  }
LABEL_86:
  if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v36, 0x5Bu, v37, 0) & 1) == 0)
  {
    unsigned int v49 = 1;
LABEL_88:
    if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v36, 0x5Bu, v37, v49))
    {
LABEL_125:
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v258, v36, 0x93u, v37, 2u, 0);
      int8x8_t v61 = v258;
      uint64_t v62 = (uint64_t)v263[3];
      if ((int)*(float *)(a3 + 28) >= 0x17) {
        unsigned int v63 = 23;
      }
      else {
        unsigned int v63 = (int)*(float *)(a3 + 28);
      }
      unint64_t v64 = *(float **)v62;
      if (*(void *)v62 && (float v65 = *v64, LODWORD(v64) = *v64 == 1.0, *(unsigned char *)(v62 + 10)) && v65 != 0.0 && v65 != 1.0
        || (v66 = *(unsigned __int8 *)(v62 + v64 + 11), float v65 = 0.0, v66 == 2))
      {
        float v249 = v65;
        LOBYTE(v258) = 1;
        LOBYTE(v273) = 1;
        uint64_t v67 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<gm::Matrix<float,2,1>>(v62, v63, 0, &v258);
        uint64_t v68 = (uint64_t)vmla_n_f32((float32x2_t)v67, vsub_f32(*(float32x2_t *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<gm::Matrix<float,2,1>>(v62, v63, 1u, &v273), (float32x2_t)v67), v249);
      }
      else
      {
        uint64_t v68 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<gm::Matrix<float,2,1>>((uint64_t)v263[3], v63, v66, 0);
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v263);
      float64x2_t v250 = *(float64x2_t *)(a3 + 8);
      uint64_t v69 = *(void *)(*(void *)(v7 + 376) + 2248);
      uint64_t v70 = *(void *)(v69 + 8);
      if (v70 == *(void *)v69)
      {
        uint64_t v82 = *(void *)(v69 + 88);
        if (!v82) {
          goto LABEL_296;
        }
        unint64_t v71 = (void (**)(ggl::RenderItem *__hidden))(*(uint64_t (**)(uint64_t))(*(void *)v82 + 48))(v82);
        uint64_t v72 = *(void (****)(ggl::RenderItem *__hidden))(v69 + 40);
        unint64_t v83 = *(void *)(v69 + 48);
        if ((unint64_t)v72 >= v83)
        {
          uint64_t v85 = *(void *)(v69 + 32);
          uint64_t v86 = ((uint64_t)v72 - v85) >> 3;
          unint64_t v87 = v86 + 1;
          if (!((unint64_t)(v86 + 1) >> 61))
          {
            uint64_t v88 = v83 - v85;
            if (v88 >> 2 > v87) {
              unint64_t v87 = v88 >> 2;
            }
            if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v89 = v87;
            }
            if (v89)
            {
              uint64_t v90 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v69 + 56) + 16))(*(void *)(v69 + 56), 8 * v89, 8);
              int v80 = (void (***)(ggl::RenderItem *__hidden))(v90 + 8 * v86);
              uint64_t v81 = v90 + 8 * v89;
              if (v90) {
                *int v80 = v71;
              }
            }
            else
            {
              uint64_t v81 = 0;
              int v80 = (void (***)(ggl::RenderItem *__hidden))(8 * v86);
            }
            uint64_t v84 = v80 + 1;
            uint64_t v106 = *(void *)(v69 + 32);
            uint64_t v91 = *(void *)(v69 + 40);
            if (v91 == v106) {
              goto LABEL_191;
            }
            unint64_t v107 = v91 - v106 - 8;
            if (v107 < 0x38)
            {
              uint64_t v109 = *(void *)(v69 + 40);
            }
            else if ((unint64_t)(v91 - (void)v80) < 0x20)
            {
              uint64_t v109 = *(void *)(v69 + 40);
            }
            else
            {
              uint64_t v108 = (v107 >> 3) + 1;
              uint64_t v109 = v91 - 8 * (v108 & 0x3FFFFFFFFFFFFFFCLL);
              id v110 = v80 - 2;
              double v111 = (long long *)(v91 - 16);
              uint64_t v112 = v108 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v113 = *v111;
                *((_OWORD *)v110 - 1) = *(v111 - 1);
                *(_OWORD *)id v110 = v113;
                v110 -= 4;
                v111 -= 2;
                v112 -= 4;
              }
              while (v112);
              v80 -= v108 & 0x3FFFFFFFFFFFFFFCLL;
              if (v108 == (v108 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_190;
              }
            }
            do
            {
              id v115 = *(void (***)(ggl::RenderItem *__hidden))(v109 - 8);
              v109 -= 8;
              *--int v80 = v115;
            }
            while (v109 != v106);
            goto LABEL_190;
          }
LABEL_298:
          abort();
        }
      }
      else
      {
        unint64_t v71 = *(void (***)(ggl::RenderItem *__hidden))(v70 - 8);
        *(void *)(v69 + 8) = v70 - 8;
        uint64_t v72 = *(void (****)(ggl::RenderItem *__hidden))(v69 + 40);
        unint64_t v73 = *(void *)(v69 + 48);
        if ((unint64_t)v72 >= v73)
        {
          uint64_t v74 = *(void *)(v69 + 32);
          uint64_t v75 = ((uint64_t)v72 - v74) >> 3;
          unint64_t v76 = v75 + 1;
          if (!((unint64_t)(v75 + 1) >> 61))
          {
            uint64_t v77 = v73 - v74;
            if (v77 >> 2 > v76) {
              unint64_t v76 = v77 >> 2;
            }
            if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v78 = v76;
            }
            if (v78)
            {
              uint64_t v79 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v69 + 56) + 16))(*(void *)(v69 + 56), 8 * v78, 8);
              int v80 = (void (***)(ggl::RenderItem *__hidden))(v79 + 8 * v75);
              uint64_t v81 = v79 + 8 * v78;
              if (v79) {
                *int v80 = v71;
              }
            }
            else
            {
              uint64_t v81 = 0;
              int v80 = (void (***)(ggl::RenderItem *__hidden))(8 * v75);
            }
            uint64_t v84 = v80 + 1;
            uint64_t v92 = *(void *)(v69 + 32);
            uint64_t v91 = *(void *)(v69 + 40);
            if (v91 == v92) {
              goto LABEL_191;
            }
            unint64_t v93 = v91 - v92 - 8;
            if (v93 < 0x38)
            {
              uint64_t v95 = *(void *)(v69 + 40);
            }
            else if ((unint64_t)(v91 - (void)v80) < 0x20)
            {
              uint64_t v95 = *(void *)(v69 + 40);
            }
            else
            {
              uint64_t v94 = (v93 >> 3) + 1;
              uint64_t v95 = v91 - 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
              id v96 = v80 - 2;
              int8x16_t v97 = (long long *)(v91 - 16);
              uint64_t v98 = v94 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v99 = *v97;
                *((_OWORD *)v96 - 1) = *(v97 - 1);
                *(_OWORD *)id v96 = v99;
                v96 -= 4;
                v97 -= 2;
                v98 -= 4;
              }
              while (v98);
              v80 -= v94 & 0x3FFFFFFFFFFFFFFCLL;
              if (v94 == (v94 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_190;
              }
            }
            do
            {
              uint64_t v114 = *(void (***)(ggl::RenderItem *__hidden))(v95 - 8);
              v95 -= 8;
              *--int v80 = v114;
            }
            while (v95 != v92);
LABEL_190:
            uint64_t v91 = *(void *)(v69 + 32);
LABEL_191:
            *(void *)(v69 + 32) = v80;
            *(void *)(v69 + 40) = v84;
            uint64_t v116 = *(void *)(v69 + 48);
            *(void *)(v69 + 48) = v81;
            if (v91) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v69 + 56) + 40))(*(void *)(v69 + 56), v91, v116 - v91);
            }
            goto LABEL_193;
          }
          goto LABEL_298;
        }
      }
      if (v72) {
        _OWORD *v72 = v71;
      }
      uint64_t v84 = v72 + 1;
LABEL_193:
      *(void *)(v69 + 40) = v84;
      double v263 = v71;
      uint64_t v117 = *(void *)(v69 + 120);
      if (!v117) {
        goto LABEL_296;
      }
      (*(void (**)(uint64_t, void (***)(ggl::RenderItem *__hidden)))(*(void *)v117 + 48))(v117, &v263);
      __int16 v118 = *(uint64_t **)a3;
      float64_t v119 = (uint64_t *)v71[8];
      v119[1] = 0;
      uint64_t v120 = *v118;
      uint64_t *v119 = *v118;
      double v121 = v71[20];
      uint64_t v122 = v118[1];
      if (v122) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v122 + 8), 1uLL, memory_order_relaxed);
      }
      id v123 = (std::__shared_weak_count *)*((void *)v121 + 1);
      *(void *)double v121 = v120;
      *((void *)v121 + 1) = v122;
      if (v123 && !atomic_fetch_add(&v123->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
        std::__shared_weak_count::__release_weak(v123);
      }
      uint64_t v124 = *(void *)(*(void *)(v7 + 376) + 2488);
      uint64_t v125 = *(void *)(v124 + 8);
      if (v125 == *(void *)v124)
      {
        uint64_t v137 = *(void *)(v124 + 88);
        if (!v137) {
          goto LABEL_296;
        }
        unint64_t v126 = (void (**)(ggl::RenderItem *__hidden))(*(uint64_t (**)(uint64_t))(*(void *)v137 + 48))(v137);
        uint64_t v127 = *(void (****)(ggl::RenderItem *__hidden))(v124 + 40);
        unint64_t v138 = *(void *)(v124 + 48);
        if ((unint64_t)v127 >= v138)
        {
          uint64_t v140 = *(void *)(v124 + 32);
          uint64_t v141 = ((uint64_t)v127 - v140) >> 3;
          unint64_t v142 = v141 + 1;
          if (!((unint64_t)(v141 + 1) >> 61))
          {
            uint64_t v143 = v138 - v140;
            if (v143 >> 2 > v142) {
              unint64_t v142 = v143 >> 2;
            }
            if ((unint64_t)v143 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v144 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v144 = v142;
            }
            if (v144)
            {
              uint64_t v145 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v124 + 56) + 16))(*(void *)(v124 + 56), 8 * v144, 8);
              int v135 = (void (***)(ggl::RenderItem *__hidden))(v145 + 8 * v141);
              uint64_t v136 = v145 + 8 * v144;
              if (v145) {
                *int v135 = v126;
              }
            }
            else
            {
              uint64_t v136 = 0;
              int v135 = (void (***)(ggl::RenderItem *__hidden))(8 * v141);
            }
            uint64_t v139 = v135 + 1;
            uint64_t v155 = *(void *)(v124 + 32);
            uint64_t v146 = *(void *)(v124 + 40);
            if (v146 == v155) {
              goto LABEL_248;
            }
            unint64_t v156 = v146 - v155 - 8;
            if (v156 < 0x38)
            {
              uint64_t v158 = *(void *)(v124 + 40);
            }
            else if ((unint64_t)(v146 - (void)v135) < 0x20)
            {
              uint64_t v158 = *(void *)(v124 + 40);
            }
            else
            {
              uint64_t v157 = (v156 >> 3) + 1;
              uint64_t v158 = v146 - 8 * (v157 & 0x3FFFFFFFFFFFFFFCLL);
              float32x4_t v159 = v135 - 2;
              float32x4_t v160 = (long long *)(v146 - 16);
              uint64_t v161 = v157 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v162 = *v160;
                *((_OWORD *)v159 - 1) = *(v160 - 1);
                *(_OWORD *)float32x4_t v159 = v162;
                v159 -= 4;
                v160 -= 2;
                v161 -= 4;
              }
              while (v161);
              v135 -= v157 & 0x3FFFFFFFFFFFFFFCLL;
              if (v157 == (v157 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_247;
              }
            }
            do
            {
              double v164 = *(void (***)(ggl::RenderItem *__hidden))(v158 - 8);
              v158 -= 8;
              *--int v135 = v164;
            }
            while (v158 != v155);
            goto LABEL_247;
          }
LABEL_299:
          abort();
        }
      }
      else
      {
        unint64_t v126 = *(void (***)(ggl::RenderItem *__hidden))(v125 - 8);
        *(void *)(v124 + 8) = v125 - 8;
        uint64_t v127 = *(void (****)(ggl::RenderItem *__hidden))(v124 + 40);
        unint64_t v128 = *(void *)(v124 + 48);
        if ((unint64_t)v127 >= v128)
        {
          uint64_t v129 = *(void *)(v124 + 32);
          uint64_t v130 = ((uint64_t)v127 - v129) >> 3;
          unint64_t v131 = v130 + 1;
          if (!((unint64_t)(v130 + 1) >> 61))
          {
            uint64_t v132 = v128 - v129;
            if (v132 >> 2 > v131) {
              unint64_t v131 = v132 >> 2;
            }
            if ((unint64_t)v132 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v133 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v133 = v131;
            }
            if (v133)
            {
              uint64_t v134 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v124 + 56) + 16))(*(void *)(v124 + 56), 8 * v133, 8);
              int v135 = (void (***)(ggl::RenderItem *__hidden))(v134 + 8 * v130);
              uint64_t v136 = v134 + 8 * v133;
              if (v134) {
                *int v135 = v126;
              }
            }
            else
            {
              uint64_t v136 = 0;
              int v135 = (void (***)(ggl::RenderItem *__hidden))(8 * v130);
            }
            uint64_t v139 = v135 + 1;
            uint64_t v147 = *(void *)(v124 + 32);
            uint64_t v146 = *(void *)(v124 + 40);
            if (v146 == v147) {
              goto LABEL_248;
            }
            unint64_t v148 = v146 - v147 - 8;
            if (v148 < 0x38)
            {
              uint64_t v150 = *(void *)(v124 + 40);
            }
            else if ((unint64_t)(v146 - (void)v135) < 0x20)
            {
              uint64_t v150 = *(void *)(v124 + 40);
            }
            else
            {
              uint64_t v149 = (v148 >> 3) + 1;
              uint64_t v150 = v146 - 8 * (v149 & 0x3FFFFFFFFFFFFFFCLL);
              int v151 = v135 - 2;
              __int32 v152 = (long long *)(v146 - 16);
              uint64_t v153 = v149 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v154 = *v152;
                *((_OWORD *)v151 - 1) = *(v152 - 1);
                *(_OWORD *)int v151 = v154;
                v151 -= 4;
                v152 -= 2;
                v153 -= 4;
              }
              while (v153);
              v135 -= v149 & 0x3FFFFFFFFFFFFFFCLL;
              if (v149 == (v149 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_247;
              }
            }
            do
            {
              char v163 = *(void (***)(ggl::RenderItem *__hidden))(v150 - 8);
              v150 -= 8;
              *--int v135 = v163;
            }
            while (v150 != v147);
LABEL_247:
            uint64_t v146 = *(void *)(v124 + 32);
LABEL_248:
            *(void *)(v124 + 32) = v135;
            *(void *)(v124 + 40) = v139;
            uint64_t v165 = *(void *)(v124 + 48);
            *(void *)(v124 + 48) = v136;
            if (v146) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v124 + 56) + 40))(*(void *)(v124 + 56), v146, v165 - v146);
            }
            goto LABEL_250;
          }
          goto LABEL_299;
        }
      }
      if (v127) {
        *uint64_t v127 = v126;
      }
      uint64_t v139 = v127 + 1;
LABEL_250:
      *(void *)(v124 + 40) = v139;
      double v263 = v126;
      uint64_t v166 = *(void *)(v124 + 120);
      if (v166)
      {
        (*(void (**)(uint64_t, void (***)(ggl::RenderItem *__hidden)))(*(void *)v166 + 48))(v166, &v263);
        uint32x4_t v167 = vmovl_u16((uint16x4_t)v61);
        float64x2_t v168 = vcvtq_f64_f32((float32x2_t)v68);
        long double v169 = *(uint64_t **)a3;
        long double v170 = (uint64_t *)v126[8];
        v170[1] = 0;
        uint64_t v171 = *v169;
        *long double v170 = *v169;
        uint64_t v172 = v126[20];
        uint64_t v173 = v169[1];
        unint64_t v174 = v256;
        if (v173) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v173 + 8), 1uLL, memory_order_relaxed);
        }
        float32x4_t v175 = vcvtq_f32_u32(v167);
        float32x4_t v176 = (float32x4_t)vdupq_n_s32(0x37800080u);
        float64x2_t v177 = vdivq_f64(v168, v250);
        double v178 = (std::__shared_weak_count *)*((void *)v172 + 1);
        *(void *)uint64_t v172 = v171;
        *((void *)v172 + 1) = v173;
        if (v178 && !atomic_fetch_add(&v178->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          float32x4_t v247 = v176;
          float32x4_t v251 = v175;
          float64x2_t v246 = v177;
          ((void (*)(std::__shared_weak_count *))v178->__on_zero_shared)(v178);
          std::__shared_weak_count::__release_weak(v178);
          float64x2_t v177 = v246;
          float32x4_t v176 = v247;
          float32x4_t v175 = v251;
          unint64_t v174 = v256;
        }
        float32x4_t v179 = vmulq_f32(v175, v176);
        float32x2_t v180 = vcvt_f32_f64(v177);
        uint64_t v181 = v126[8];
        *((void *)v181 + 2) = *((void *)v71[8] + 2);
        *((void *)v181 + 3) = 0;
        uint64_t v182 = v126[20];
        unint64_t v183 = (std::__shared_weak_count *)*((void *)v182 + 3);
        *((void *)v182 + 2) = 0;
        *((void *)v182 + 3) = 0;
        if (v183 && !atomic_fetch_add(&v183->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          float32x4_t v252 = v179;
          ((void (*)(std::__shared_weak_count *))v183->__on_zero_shared)(v183);
          std::__shared_weak_count::__release_weak(v183);
          float32x4_t v179 = v252;
          unint64_t v174 = v256;
        }
        __double2 v184 = (void *)*((void *)v71[8] + 2);
        unint64_t v185 = v184[1];
        uint64_t v186 = v184[9];
        *(float32x4_t *)uint64_t v186 = v179;
        *(float32x2_t *)(v186 + 16) = v180;
        if (v184[8] > v185) {
          unint64_t v185 = v184[8];
        }
        v184[7] = 0;
        v184[8] = v185;
        uint64_t v258 = &off_1EF55A458;
        *((void *)&v261 + 1) = 0;
        *(_DWORD *)double v262 = 1065353216;
        memset(&v262[8], 0, 32);
        *(int64x2_t *)&v262[40] = vdupq_n_s64(1uLL);
        *(void *)&v262[56] = 0;
        uint64_t v187 = *(void *)(v7 + 376);
        *((void *)&v259 + 1) = "";
        *(void *)&long long v260 = v187 + 2256;
        *((void *)&v260 + 1) = v71;
        LODWORD(v261) = *(unsigned __int8 *)(v187 + 3673);
        int v188 = *(unsigned __int8 *)(v7 + 393);
        uint64_t v189 = 20 * (__int16)[(VKPolygonGroup *)v174 layer] + 0x800000004;
        if (!v188) {
          uint64_t v189 = 0x800000004;
        }
        *((void *)&v261 + 1) = v189;
        unsigned int v273 = &off_1EF55A458;
        *((void *)&v276 + 1) = 0;
        *(_DWORD *)uint64_t v277 = 1065353216;
        memset(&v277[8], 0, 32);
        *(int64x2_t *)&v277[40] = vdupq_n_s64(1uLL);
        *(void *)&v277[56] = 0;
        uint64_t v190 = *(void *)(v7 + 376);
        *((void *)&v274 + 1) = "";
        *(void *)&long long v275 = v190 + 2496;
        *((void *)&v275 + 1) = v126;
        LODWORD(v276) = *(unsigned __int8 *)(v190 + 3673);
        int v191 = *(unsigned __int8 *)(v7 + 393);
        uint64_t v192 = 20 * (__int16)[(VKPolygonGroup *)v256 layer] + 0x800000005;
        if (!v191) {
          uint64_t v192 = 0x800000005;
        }
        *((void *)&v276 + 1) = v192;
        uint64_t v193 = [(VKPolygonGroup *)v256 strokeMeshes];
        uint64_t v194 = *(uint64_t **)v193;
        float v248 = *(uint64_t **)(v193 + 8);
        uint64_t v195 = v256;
        if (v194 != v248)
        {
          unsigned int v196 = 0;
          do
          {
            uint64_t v197 = *(void *)(v7 + 376);
            uint64_t v198 = *(unsigned int *)(a3 + 48);
            v271[0] = &unk_1EF577370;
            uint64_t v272 = v271;
            unint64_t v199 = [(VKPolygonalItemGroup *)v195 commitRangesToStrokeRenderItemBatcher:v197 + 3712 forMeshAtIndex:v196 cullingMask:v198 featureIdPredicate:v271];
            if (v272 == v271)
            {
              (*(void (**)(void *))(v271[0] + 32))(v271);
            }
            else if (v272)
            {
              (*(void (**)(void))(*v272 + 40))();
            }
            uint64_t v200 = *(void *)(v7 + 376);
            uint64_t v201 = *v194;
            double v263 = &off_1EF55A458;
            long long v264 = v259;
            long long v265 = v260;
            long long v269 = *(_OWORD *)&v262[32];
            long long v270 = *(_OWORD *)&v262[48];
            long long v266 = v261;
            long long v267 = *(_OWORD *)v262;
            long long v268 = *(_OWORD *)&v262[16];
            float32x2_t v202 = *(void **)(v200 + 3800);
            uint64_t v203 = v202[1];
            if (v203 == *(void *)(v200 + 3808))
            {
              float32x2_t v202 = (void *)*v202;
              if (!v202)
              {
                float32x2_t v202 = malloc_type_malloc(120 * v203 + 16, 0xB644C221uLL);
                *float32x2_t v202 = 0;
                v202[1] = 0;
                **(void **)(v200 + 3800) = v202;
              }
              *(void *)(v200 + 3800) = v202;
              uint64_t v203 = v202[1];
            }
            long long v204 = &v202[15 * v203];
            v202[1] = v203 + 1;
            v204[2] = &off_1EF55A458;
            long long v205 = v269;
            long long v206 = v270;
            long long v207 = v268;
            *(_OWORD *)(v204 + 9) = v267;
            long long v208 = v264;
            long long v209 = v265;
            *(_OWORD *)(v204 + 7) = v266;
            *(_OWORD *)(v204 + 5) = v209;
            *(_OWORD *)(v204 + 3) = v208;
            *(_OWORD *)(v204 + 15) = v206;
            *(_OWORD *)(v204 + 13) = v205;
            *(_OWORD *)(v204 + 11) = v207;
            v204[10] = v201;
            uint64_t v210 = *v199;
            v204[13] = *v199;
            v204[14] = (v199[1] - v210) >> 4;
            ggl::CommandBuffer::pushRenderItem(v254, (uint64_t)(v204 + 2));
            uint64_t v211 = *(void *)(v255 + 376);
            uint64_t v212 = *v194;
            double v263 = &off_1EF55A458;
            long long v264 = v274;
            long long v265 = v275;
            long long v269 = *(_OWORD *)&v277[32];
            long long v270 = *(_OWORD *)&v277[48];
            long long v266 = v276;
            long long v267 = *(_OWORD *)v277;
            long long v268 = *(_OWORD *)&v277[16];
            __n128 v213 = *(void **)(v211 + 3800);
            uint64_t v214 = v213[1];
            if (v214 == *(void *)(v211 + 3808))
            {
              __n128 v213 = (void *)*v213;
              if (!v213)
              {
                __n128 v213 = malloc_type_malloc(120 * v214 + 16, 0xB644C221uLL);
                *__n128 v213 = 0;
                v213[1] = 0;
                **(void **)(v211 + 3800) = v213;
              }
              *(void *)(v211 + 3800) = v213;
              uint64_t v214 = v213[1];
            }
            double v215 = &v213[15 * v214];
            v213[1] = v214 + 1;
            v215[2] = &off_1EF55A458;
            long long v216 = v269;
            long long v217 = v270;
            long long v218 = v268;
            *(_OWORD *)(v215 + 9) = v267;
            long long v219 = v264;
            long long v220 = v265;
            *(_OWORD *)(v215 + 7) = v266;
            *(_OWORD *)(v215 + 5) = v220;
            *(_OWORD *)(v215 + 3) = v219;
            *(_OWORD *)(v215 + 15) = v217;
            *(_OWORD *)(v215 + 13) = v216;
            *(_OWORD *)(v215 + 11) = v218;
            v215[10] = v212;
            uint64_t v221 = *v199;
            v215[13] = *v199;
            v215[14] = (v199[1] - v221) >> 4;
            ggl::CommandBuffer::pushRenderItem(v254, (uint64_t)(v215 + 2));
            uint64_t v7 = v255;
            ++v196;
            v194 += 2;
            uint64_t v195 = v256;
          }
          while (v194 != v248);
        }
        goto LABEL_118;
      }
LABEL_296:
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
      return;
    }
  }
  unsigned int v50 = v35 == 0.0;
  if (v38)
  {
    float v51 = *v38;
    BOOL v52 = *v38 == 1.0;
    if (*(unsigned char *)(v36 + 10) && v51 != 0.0 && v51 != 1.0)
    {
LABEL_114:
      LOBYTE(v258) = 1;
      LOBYTE(v273) = 1;
      char v59 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v36, 0x5Bu, v50, 0, &v258);
      char v60 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v36, 0x5Bu, v50, 1, &v273);
      if (v51 < 1.0) {
        char v60 = v59;
      }
      if (v60) {
        goto LABEL_117;
      }
      goto LABEL_122;
    }
  }
  else
  {
    BOOL v52 = 0;
  }
  int v58 = *(unsigned __int8 *)(v36 + v52 + 11);
  float v51 = 0.0;
  if (v58 == 2) {
    goto LABEL_114;
  }
  if (!*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v36, 0x5Bu, v50, v58, 0))
  {
LABEL_122:
    uint64_t v36 = (uint64_t)v263[3];
    if ((int)*(float *)(a3 + 28) >= 0x17) {
      unsigned int v37 = 23;
    }
    else {
      unsigned int v37 = (int)*(float *)(a3 + 28);
    }
    goto LABEL_125;
  }
LABEL_117:
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v263);
LABEL_118:
}

void sub_1A21421A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::featureIdPredicateAlways(void)::{lambda(unsigned long long)#1},std::allocator<md::featureIdPredicateAlways(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::operator()()
{
  return 1;
}

void std::__function::__func<md::featureIdPredicateAlways(void)::{lambda(unsigned long long)#1},std::allocator<md::featureIdPredicateAlways(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF577370;
}

void *std::__function::__func<md::featureIdPredicateAlways(void)::{lambda(unsigned long long)#1},std::allocator<md::featureIdPredicateAlways(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF577370;
  return result;
}

void std::__function::__func<md::featureIdPredicateAlways(void)::{lambda(unsigned long long)#1},std::allocator<md::featureIdPredicateAlways(void)::{lambda(unsigned long long)#1}>,BOOL ()(unsigned long long)>::~__func()
{
}

__n128 std::__function::__func<md::VenueRenderLayer::_layoutOpenToBelowAreas(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::_layoutOpenToBelowAreas(md::LayoutContext const&)::$_0>,void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572E40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::VenueRenderLayer::_layoutOpenToBelowAreas(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::_layoutOpenToBelowAreas(md::LayoutContext const&)::$_0>,void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF572E40;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::VenueRenderLayer::_layoutOpenToBelowAreas(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::_layoutOpenToBelowAreas(md::LayoutContext const&)::$_0>,void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::~__func()
{
}

void std::__function::__func<md::VenueRenderLayer::_layoutVenueWalls(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::_layoutVenueWalls(md::LayoutContext const&)::$_0>,void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::operator()(uint64_t a1, id *a2, uint64_t a3)
{
  id v5 = *a2;
  uint64_t v6 = *(void **)(a1 + 8);
  md::VenueRenderLayer::_layoutVenueWallGroupFills((uint64_t)v6, *(void *)(a1 + 16), v5, **(void **)(a1 + 24), a3);
  uint64_t v7 = *(void *)(a1 + 16);
  uint64_t v294 = **(void **)(a1 + 24);
  unsigned int v297 = (VKPolygonGroup *)v5;
  id v8 = *(id *)(v6[5] + 104);
  [v8 sizeInPixels];
  double v10 = v9;
  double v12 = v11;
  uint64_t v13 = *(void *)(v6[47] + 1256);
  uint64_t v14 = *(void *)(v13 + 8);
  if (v14 == *(void *)v13)
  {
    uint64_t v26 = *(void *)(v13 + 88);
    if (!v26)
    {
LABEL_336:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_340:
      __break(1u);
      return;
    }
    uint64_t v15 = (*(uint64_t (**)(uint64_t))(*(void *)v26 + 48))(v26);
    unsigned int v16 = *(uint64_t **)(v13 + 40);
    unint64_t v27 = *(void *)(v13 + 48);
    if ((unint64_t)v16 >= v27)
    {
      uint64_t v29 = *(void *)(v13 + 32);
      uint64_t v30 = ((uint64_t)v16 - v29) >> 3;
      unint64_t v31 = v30 + 1;
      if (!((unint64_t)(v30 + 1) >> 61))
      {
        uint64_t v32 = v27 - v29;
        if (v32 >> 2 > v31) {
          unint64_t v31 = v32 >> 2;
        }
        if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v33 = v31;
        }
        if (v33)
        {
          uint64_t v34 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v13 + 56) + 16))(*(void *)(v13 + 56), 8 * v33, 8);
          uint64_t v24 = (uint64_t *)(v34 + 8 * v30);
          uint64_t v25 = v34 + 8 * v33;
          if (v34) {
            *uint64_t v24 = v15;
          }
        }
        else
        {
          uint64_t v25 = 0;
          uint64_t v24 = (uint64_t *)(8 * v30);
        }
        uint8x8_t v28 = v24 + 1;
        uint64_t v44 = *(void *)(v13 + 32);
        uint64_t v35 = *(void *)(v13 + 40);
        if (v35 == v44) {
          goto LABEL_50;
        }
        unint64_t v45 = v35 - v44 - 8;
        if (v45 < 0x38)
        {
          uint64_t v47 = *(void *)(v13 + 40);
        }
        else if ((unint64_t)(v35 - (void)v24) < 0x20)
        {
          uint64_t v47 = *(void *)(v13 + 40);
        }
        else
        {
          uint64_t v46 = (v45 >> 3) + 1;
          uint64_t v47 = v35 - 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
          BOOL v48 = v24 - 2;
          unsigned int v49 = (long long *)(v35 - 16);
          uint64_t v50 = v46 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v51 = *v49;
            *((_OWORD *)v48 - 1) = *(v49 - 1);
            *(_OWORD *)BOOL v48 = v51;
            v48 -= 4;
            v49 -= 2;
            v50 -= 4;
          }
          while (v50);
          v24 -= v46 & 0x3FFFFFFFFFFFFFFCLL;
          if (v46 == (v46 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_49;
          }
        }
        do
        {
          uint64_t v53 = *(void *)(v47 - 8);
          v47 -= 8;
          *--uint64_t v24 = v53;
        }
        while (v47 != v44);
        goto LABEL_49;
      }
LABEL_338:
      abort();
    }
  }
  else
  {
    uint64_t v15 = *(void *)(v14 - 8);
    *(void *)(v13 + 8) = v14 - 8;
    unsigned int v16 = *(uint64_t **)(v13 + 40);
    unint64_t v17 = *(void *)(v13 + 48);
    if ((unint64_t)v16 >= v17)
    {
      uint64_t v18 = *(void *)(v13 + 32);
      uint64_t v19 = ((uint64_t)v16 - v18) >> 3;
      unint64_t v20 = v19 + 1;
      if (!((unint64_t)(v19 + 1) >> 61))
      {
        uint64_t v21 = v17 - v18;
        if (v21 >> 2 > v20) {
          unint64_t v20 = v21 >> 2;
        }
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v22 = v20;
        }
        if (v22)
        {
          uint64_t v23 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v13 + 56) + 16))(*(void *)(v13 + 56), 8 * v22, 8);
          uint64_t v24 = (uint64_t *)(v23 + 8 * v19);
          uint64_t v25 = v23 + 8 * v22;
          if (v23) {
            *uint64_t v24 = v15;
          }
        }
        else
        {
          uint64_t v25 = 0;
          uint64_t v24 = (uint64_t *)(8 * v19);
        }
        uint8x8_t v28 = v24 + 1;
        uint64_t v36 = *(void *)(v13 + 32);
        uint64_t v35 = *(void *)(v13 + 40);
        if (v35 == v36) {
          goto LABEL_50;
        }
        unint64_t v37 = v35 - v36 - 8;
        if (v37 < 0x38)
        {
          uint64_t v39 = *(void *)(v13 + 40);
        }
        else if ((unint64_t)(v35 - (void)v24) < 0x20)
        {
          uint64_t v39 = *(void *)(v13 + 40);
        }
        else
        {
          uint64_t v38 = (v37 >> 3) + 1;
          uint64_t v39 = v35 - 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
          BOOL v40 = v24 - 2;
          BOOL v41 = (long long *)(v35 - 16);
          uint64_t v42 = v38 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v43 = *v41;
            *((_OWORD *)v40 - 1) = *(v41 - 1);
            *(_OWORD *)BOOL v40 = v43;
            v40 -= 4;
            v41 -= 2;
            v42 -= 4;
          }
          while (v42);
          v24 -= v38 & 0x3FFFFFFFFFFFFFFCLL;
          if (v38 == (v38 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_49;
          }
        }
        do
        {
          uint64_t v52 = *(void *)(v39 - 8);
          v39 -= 8;
          *--uint64_t v24 = v52;
        }
        while (v39 != v36);
LABEL_49:
        uint64_t v35 = *(void *)(v13 + 32);
LABEL_50:
        *(void *)(v13 + 32) = v24;
        *(void *)(v13 + 40) = v28;
        uint64_t v54 = *(void *)(v13 + 48);
        *(void *)(v13 + 48) = v25;
        if (v35) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v13 + 56) + 40))(*(void *)(v13 + 56), v35, v54 - v35);
        }
        goto LABEL_52;
      }
      goto LABEL_338;
    }
  }
  if (v16) {
    *unsigned int v16 = v15;
  }
  uint8x8_t v28 = v16 + 1;
LABEL_52:
  *(void *)(v13 + 40) = v28;
  *(void *)uint64_t v307 = v15;
  uint64_t v55 = *(void *)(v13 + 120);
  if (!v55) {
    goto LABEL_336;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v55 + 48))(v55, v307);
  uint64_t v56 = *(void *)(v6[47] + 1280);
  uint64_t v57 = *(void *)(v56 + 8);
  if (v57 == *(void *)v56)
  {
    uint64_t v69 = *(void *)(v56 + 88);
    if (!v69)
    {
LABEL_337:
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_340;
    }
    uint64_t v58 = (*(uint64_t (**)(uint64_t))(*(void *)v69 + 48))(v69);
    char v59 = *(uint64_t **)(v56 + 40);
    unint64_t v70 = *(void *)(v56 + 48);
    if ((unint64_t)v59 >= v70)
    {
      uint64_t v72 = *(void *)(v56 + 32);
      uint64_t v73 = ((uint64_t)v59 - v72) >> 3;
      unint64_t v74 = v73 + 1;
      if (!((unint64_t)(v73 + 1) >> 61))
      {
        uint64_t v75 = v70 - v72;
        if (v75 >> 2 > v74) {
          unint64_t v74 = v75 >> 2;
        }
        if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v76 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v76 = v74;
        }
        if (v76)
        {
          uint64_t v77 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v56 + 56) + 16))(*(void *)(v56 + 56), 8 * v76, 8);
          uint64_t v67 = (uint64_t *)(v77 + 8 * v73);
          uint64_t v68 = v77 + 8 * v76;
          if (v77) {
            *uint64_t v67 = v58;
          }
        }
        else
        {
          uint64_t v68 = 0;
          uint64_t v67 = (uint64_t *)(8 * v73);
        }
        unint64_t v71 = v67 + 1;
        uint64_t v87 = *(void *)(v56 + 32);
        uint64_t v78 = *(void *)(v56 + 40);
        if (v78 == v87) {
          goto LABEL_102;
        }
        unint64_t v88 = v78 - v87 - 8;
        if (v88 < 0x38)
        {
          uint64_t v90 = *(void *)(v56 + 40);
        }
        else if ((unint64_t)(v78 - (void)v67) < 0x20)
        {
          uint64_t v90 = *(void *)(v56 + 40);
        }
        else
        {
          uint64_t v89 = (v88 >> 3) + 1;
          uint64_t v90 = v78 - 8 * (v89 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v91 = v67 - 2;
          uint64_t v92 = (long long *)(v78 - 16);
          uint64_t v93 = v89 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v94 = *v92;
            *((_OWORD *)v91 - 1) = *(v92 - 1);
            *(_OWORD *)uint64_t v91 = v94;
            v91 -= 4;
            v92 -= 2;
            v93 -= 4;
          }
          while (v93);
          v67 -= v89 & 0x3FFFFFFFFFFFFFFCLL;
          if (v89 == (v89 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_101;
          }
        }
        do
        {
          uint64_t v96 = *(void *)(v90 - 8);
          v90 -= 8;
          *--uint64_t v67 = v96;
        }
        while (v90 != v87);
        goto LABEL_101;
      }
LABEL_339:
      abort();
    }
  }
  else
  {
    uint64_t v58 = *(void *)(v57 - 8);
    *(void *)(v56 + 8) = v57 - 8;
    char v59 = *(uint64_t **)(v56 + 40);
    unint64_t v60 = *(void *)(v56 + 48);
    if ((unint64_t)v59 >= v60)
    {
      uint64_t v61 = *(void *)(v56 + 32);
      uint64_t v62 = ((uint64_t)v59 - v61) >> 3;
      unint64_t v63 = v62 + 1;
      if (!((unint64_t)(v62 + 1) >> 61))
      {
        uint64_t v64 = v60 - v61;
        if (v64 >> 2 > v63) {
          unint64_t v63 = v64 >> 2;
        }
        if ((unint64_t)v64 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v65 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v65 = v63;
        }
        if (v65)
        {
          uint64_t v66 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v56 + 56) + 16))(*(void *)(v56 + 56), 8 * v65, 8);
          uint64_t v67 = (uint64_t *)(v66 + 8 * v62);
          uint64_t v68 = v66 + 8 * v65;
          if (v66) {
            *uint64_t v67 = v58;
          }
        }
        else
        {
          uint64_t v68 = 0;
          uint64_t v67 = (uint64_t *)(8 * v62);
        }
        unint64_t v71 = v67 + 1;
        uint64_t v79 = *(void *)(v56 + 32);
        uint64_t v78 = *(void *)(v56 + 40);
        if (v78 == v79) {
          goto LABEL_102;
        }
        unint64_t v80 = v78 - v79 - 8;
        if (v80 < 0x38)
        {
          uint64_t v82 = *(void *)(v56 + 40);
        }
        else if ((unint64_t)(v78 - (void)v67) < 0x20)
        {
          uint64_t v82 = *(void *)(v56 + 40);
        }
        else
        {
          uint64_t v81 = (v80 >> 3) + 1;
          uint64_t v82 = v78 - 8 * (v81 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v83 = v67 - 2;
          uint64_t v84 = (long long *)(v78 - 16);
          uint64_t v85 = v81 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v86 = *v84;
            *((_OWORD *)v83 - 1) = *(v84 - 1);
            *(_OWORD *)unint64_t v83 = v86;
            v83 -= 4;
            v84 -= 2;
            v85 -= 4;
          }
          while (v85);
          v67 -= v81 & 0x3FFFFFFFFFFFFFFCLL;
          if (v81 == (v81 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_101;
          }
        }
        do
        {
          uint64_t v95 = *(void *)(v82 - 8);
          v82 -= 8;
          *--uint64_t v67 = v95;
        }
        while (v82 != v79);
LABEL_101:
        uint64_t v78 = *(void *)(v56 + 32);
LABEL_102:
        *(void *)(v56 + 32) = v67;
        *(void *)(v56 + 40) = v71;
        uint64_t v97 = *(void *)(v56 + 48);
        *(void *)(v56 + 48) = v68;
        if (v78) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v56 + 56) + 40))(*(void *)(v56 + 56), v78, v97 - v78);
        }
        goto LABEL_104;
      }
      goto LABEL_339;
    }
  }
  if (v59) {
    *char v59 = v58;
  }
  unint64_t v71 = v59 + 1;
LABEL_104:
  *(void *)(v56 + 40) = v71;
  *(void *)uint64_t v307 = v58;
  uint64_t v98 = *(void *)(v56 + 120);
  if (!v98) {
    goto LABEL_337;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v98 + 48))(v98, v307);
  long long v99 = *(void **)(v7 + 8);
  int8x8_t v100 = (int8x8_t)v99[1];
  if (!*(void *)&v100) {
    goto LABEL_128;
  }
  uint8x8_t v101 = (uint8x8_t)vcnt_s8(v100);
  v101.i16[0] = vaddlv_u8(v101);
  if (v101.u32[0] > 1uLL)
  {
    unint64_t v102 = 0xA60DDA5A69582425;
    if (*(void *)&v100 <= 0xA60DDA5A69582425) {
      unint64_t v102 = 0xA60DDA5A69582425 % *(void *)&v100;
    }
  }
  else
  {
    unint64_t v102 = (*(void *)&v100 - 1) & 0xA60DDA5A69582425;
  }
  unint64_t v103 = *(void **)(*v99 + 8 * v102);
  if (!v103) {
    goto LABEL_128;
  }
  uint64_t v104 = (void *)*v103;
  if (!v104) {
    goto LABEL_128;
  }
  if (v101.u32[0] < 2uLL)
  {
    uint64_t v105 = *(void *)&v100 - 1;
    while (1)
    {
      uint64_t v107 = v104[1];
      if (v107 == 0xA60DDA5A69582425)
      {
        if (v104[2] == 0xA60DDA5A69582425) {
          goto LABEL_126;
        }
      }
      else if ((v107 & v105) != v102)
      {
        goto LABEL_128;
      }
      uint64_t v104 = (void *)*v104;
      if (!v104) {
        goto LABEL_128;
      }
    }
  }
  while (1)
  {
    unint64_t v106 = v104[1];
    if (v106 == 0xA60DDA5A69582425) {
      break;
    }
    if (v106 >= *(void *)&v100) {
      v106 %= *(void *)&v100;
    }
    if (v106 != v102) {
      goto LABEL_128;
    }
LABEL_115:
    uint64_t v104 = (void *)*v104;
    if (!v104) {
      goto LABEL_128;
    }
  }
  if (v104[2] != 0xA60DDA5A69582425) {
    goto LABEL_115;
  }
LABEL_126:
  uint64_t v108 = v104[5];
  if (*(void *)(v108 + 8) == 0xA60DDA5A69582425)
  {
    uint64_t v109 = *(id **)(v108 + 32);
    goto LABEL_129;
  }
LABEL_128:
  uint64_t v109 = 0;
LABEL_129:
  id v110 = *(uint64_t **)a3;
  double v111 = *(uint64_t **)(v15 + 64);
  v111[1] = 0;
  uint64_t v112 = *v110;
  uint64_t *v111 = *v110;
  long long v113 = *(void **)(v15 + 160);
  uint64_t v114 = v110[1];
  if (v114) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v114 + 8), 1uLL, memory_order_relaxed);
  }
  id v115 = (std::__shared_weak_count *)v113[1];
  *long long v113 = v112;
  v113[1] = v114;
  if (v115 && !atomic_fetch_add(&v115->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v115->__on_zero_shared)(v115);
    std::__shared_weak_count::__release_weak(v115);
  }
  id v116 = *v109;
  **(void **)(v15 + 96) = *(void *)([v116 alphaAtlas] + 24);

  uint64_t v117 = *(uint64_t **)a3;
  __int16 v118 = *(uint64_t **)(v58 + 64);
  v118[1] = 0;
  uint64_t v119 = *v117;
  *__int16 v118 = *v117;
  uint64_t v120 = *(void **)(v58 + 160);
  uint64_t v121 = v117[1];
  if (v121) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v121 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v122 = (std::__shared_weak_count *)v120[1];
  *uint64_t v120 = v119;
  v120[1] = v121;
  if (v122 && !atomic_fetch_add(&v122->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v122->__on_zero_shared)(v122);
    std::__shared_weak_count::__release_weak(v122);
  }
  id v123 = *v109;
  **(void **)(v58 + 96) = *(void *)([v123 alphaAtlas] + 24);

  float v295 = v6;
  char v124 = md::VenueLayerLayoutCharacteristics::focusState((md::VenueLayerLayoutCharacteristics *)(v6 + 48), v297);
  v307[0] = 0;
  v307[1] = v124;
  uint64_t v125 = [(VKPolygonalItemGroup *)v297 styleQueries:v307];
  unsigned int v126 = v125[2] - *v125;
  uint64_t v127 = (v126 >> 4);
  if ((v126 >> 4))
  {
    uint64_t v128 = *(void *)(*(void *)(v15 + 64) + 16);
    *(_OWORD *)uint64_t v307 = 0uLL;
    uint64_t v129 = *(void *)(v128 + 8);
    *(void *)&long long v130 = 0;
    *(void *)&long long v131 = 0;
    *((void *)&v131 + 1) = v128;
    id v293 = v8;
    if (v129) {
      uint64_t v132 = *(void *)(v128 + 72);
    }
    else {
      uint64_t v132 = 0;
    }
    *(_OWORD *)uint64_t v307 = v131;
    *(void *)&v307[16] = 0;
    *(void *)&long long v308 = v129;
    *(void *)&long long v309 = v132;
    WORD4(v308) = 1;
    uint64_t v133 = *(void *)(*(void *)(v58 + 64) + 16);
    unint64_t v134 = *(void *)(v133 + 8);
    id v288 = v5;
    uint64_t v289 = v58;
    uint64_t v292 = v15;
    double v290 = v12;
    double v291 = v10;
    if (v134) {
      uint64_t v135 = *(void *)(v133 + 72);
    }
    else {
      uint64_t v135 = 0;
    }
    uint64_t v136 = 0;
    uint64_t v137 = 0;
    *((void *)&v130 + 1) = *(void *)(*(void *)(v58 + 64) + 16);
    *(_OWORD *)float32_t v298 = v130;
    float v138 = 1.0;
    unint64_t v299 = v134;
    *(void *)&long long v301 = v135;
    while (1)
    {
      long long v148 = *(_OWORD *)(*(void *)v125 + 16 * v137);
      long long v303 = v148;
      uint64_t v149 = (std::__shared_weak_count *)*((void *)&v148 + 1);
      if (*((void *)&v148 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v148 + 1) + 8), 1uLL, memory_order_relaxed);
        uint64_t v149 = (std::__shared_weak_count *)*((void *)&v303 + 1);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v304, v148, (uint64_t)v149);
      if (v149 && !atomic_fetch_add(&v149->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v149->__on_zero_shared)(v149);
        std::__shared_weak_count::__release_weak(v149);
        if (v305)
        {
LABEL_154:
          if (!v137)
          {
            uint64_t v150 = *(void *)(v304[0] + 24);
            if ((int)*(float *)(a3 + 28) >= 0x17) {
              unsigned int v151 = 23;
            }
            else {
              unsigned int v151 = (int)*(float *)(a3 + 28);
            }
            __int32 v152 = *(float **)v150;
            if (*(void *)v150
              && (float v153 = *v152, LODWORD(v152) = *v152 == v138, *(unsigned char *)(v150 + 10))
              && (v153 != 0.0 ? (BOOL v154 = v153 == v138) : (BOOL v154 = 1), !v154)
              || (int v155 = *(unsigned __int8 *)(v150 + v152 + 11), v153 = 0.0, v155 == 2))
            {
              LOBYTE(v303) = 1;
              char v306 = 1;
              char v156 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v150, 0x5Bu, v151, 0, &v303);
              char v157 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v150, 0x5Bu, v151, 1, &v306);
              if (v153 < v138) {
                char v157 = v156;
              }
              if (!v157)
              {
LABEL_306:
                gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v304);
                if ((void)v301 && v299)
                {
                  if (*(void *)v298 && *(unsigned char *)(*(void *)&v298[8] + 17) != 2) {
                    (*(void (**)(void))(**(void **)v298 + 64))(*(void *)v298);
                  }
                  uint64_t v280 = *(void *)(*(void *)&v298[8] + 56);
                  unint64_t v279 = *(void *)(*(void *)&v298[8] + 64);
                  if (v279 == v280) {
                    uint64_t v280 = *(void *)(*(void *)&v298[8] + 80) - *(void *)(*(void *)&v298[8] + 72);
                  }
                  if (v280) {
                    uint64_t v280 = 0;
                  }
                  if (v279 <= v299) {
                    unint64_t v279 = v299;
                  }
                  if (v279 == v280) {
                    unint64_t v279 = v280 + *(void *)(*(void *)&v298[8] + 80) - *(void *)(*(void *)&v298[8] + 72);
                  }
                  *(void *)(*(void *)&v298[8] + 56) = v280;
                  *(void *)(*(void *)&v298[8] + 64) = v279;
                }
                if ((void)v309)
                {
                  unint64_t v281 = *(void *)&v307[16];
                  unint64_t v282 = v308;
                  if ((void)v308 != *(void *)&v307[16])
                  {
                    double v283 = *(void **)&v307[8];
                    int v284 = BYTE8(v308);
                    int v285 = BYTE9(v308);
                    if (*(void *)v307 && *(unsigned char *)(*(void *)&v307[8] + 17) != 2) {
                      (*(void (**)(void))(**(void **)v307 + 64))(*(void *)v307);
                    }
                    if (v284 && !v285)
                    {
                      unint64_t v287 = v283[7];
                      unint64_t v286 = v283[8];
                      if (v286 == v287) {
                        unint64_t v287 = v283[10] - v283[9];
                      }
                      if (v281 < v287) {
                        unint64_t v287 = v281;
                      }
                      if (v286 <= v282) {
                        unint64_t v286 = v282;
                      }
                      if (v286 == v287) {
                        unint64_t v286 = v287 + v283[10] - v283[9];
                      }
                      v283[7] = v287;
                      v283[8] = v286;
                    }
                  }
                }
                break;
              }
            }
            else if (!*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v304[0] + 24), 0x5Bu, v151, v155, 0))
            {
              goto LABEL_306;
            }
          }
          float v158 = *(float *)(a3 + 32);
          uint64_t v159 = *(void *)(v304[0] + 24);
          if ((int)*(float *)(a3 + 28) >= 0x17) {
            unsigned int v160 = 23;
          }
          else {
            unsigned int v160 = (int)*(float *)(a3 + 28);
          }
          uint64_t v161 = *(float **)v159;
          if (*(void *)v159
            && (float v162 = *v161, LODWORD(v161) = *v161 == v138, *(unsigned char *)(v159 + 10))
            && (v162 != 0.0 ? (BOOL v163 = v162 == v138) : (BOOL v163 = 1), !v163)
            || (v164 = *(unsigned __int8 *)(v159 + v161 + 11), float v162 = 0.0, v164 == 2))
          {
            LOBYTE(v303) = 1;
            char v306 = 1;
            char v165 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v159, 0x145u, v160, 0, &v303);
            char v166 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v159, 0x145u, v160, 1, &v306);
            if (v162 < v138) {
              char v166 = v165;
            }
          }
          else
          {
            char v166 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v304[0] + 24), 0x145u, v160, v164, 0);
          }
          if (v166) {
            double v167 = 1.0;
          }
          else {
            double v167 = *(float *)(a3 + 36);
          }
          unint64_t v168 = *(void *)(v304[0] + 24);
          float v169 = fminf(fmaxf(*(float *)(a3 + 28), 0.0), 23.0);
          long double v170 = *(float **)v168;
          if (*(void *)v168
            && (float v171 = *v170, LODWORD(v170) = *v170 == v138, *(unsigned char *)(v168 + 10))
            && (v171 != 0.0 ? (BOOL v172 = v171 == v138) : (BOOL v172 = 1), !v172)
            || (v173 = *(unsigned __int8 *)(v168 + v170 + 11), float v171 = 0.0, v173 == 2))
          {
            LOBYTE(v303) = 1;
            char v306 = 1;
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v168, 0x141u, 0, (BOOL *)&v303, v169);
            float v175 = v174;
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v168, 0x141u, 1u, (BOOL *)&v306, v169);
            float v177 = v175 + (float)((float)(v176 - v175) * v171);
          }
          else
          {
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v304[0] + 24), 0x141u, v173, 0, v169);
            float v177 = v178;
          }
          double v179 = *(double *)(a3 + 40);
          unint64_t v180 = *(void *)(v304[0] + 24);
          float v181 = fminf(fmaxf(*(float *)(a3 + 28), 0.0), 23.0);
          uint64_t v182 = *(float **)v180;
          if (*(void *)v180
            && (float v183 = *v182, LODWORD(v182) = *v182 == v138, *(unsigned char *)(v180 + 10))
            && (v183 != 0.0 ? (BOOL v184 = v183 == v138) : (BOOL v184 = 1), !v184)
            || (v185 = *(unsigned __int8 *)(v180 + v182 + 11), float v183 = 0.0, v185 == 2))
          {
            LOBYTE(v303) = 1;
            char v306 = 1;
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v180, 0x14Fu, 0, (BOOL *)&v303, v181);
            float v187 = v186;
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v180, 0x14Fu, 1u, (BOOL *)&v306, v181);
            float v189 = v187 + (float)((float)(v188 - v187) * v183);
          }
          else
          {
            gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v304[0] + 24), 0x14Fu, v185, 0, v181);
            float v189 = v190;
          }
          float v191 = v167 * v158;
          double v192 = v191;
          float v144 = v177 * v179 * v191;
          double v193 = *(double *)(a3 + 40);
          float32x4_t v296 = 0u;
          float v194 = 0.0;
          if (v144 >= 0.00000011921)
          {
            unint64_t v196 = *(void *)(v304[0] + 24);
            float v197 = fminf(fmaxf(*(float *)(a3 + 28), 0.0), 23.0);
            uint64_t v198 = *(float **)v196;
            if (*(void *)v196
              && (float v199 = *v198, LODWORD(v198) = *v198 == v138, *(unsigned char *)(v196 + 10))
              && v199 != 0.0
              && v199 != v138
              || (v200 = *(unsigned __int8 *)(v196 + v198 + 11), float v199 = 0.0, v200 == 2))
            {
              LOBYTE(v303) = 1;
              char v306 = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v196, 2u, 0, (BOOL *)&v303, v197);
              float v202 = v201;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v196, 2u, 1u, (BOOL *)&v306, v197);
              float v203 = 1.0;
              float v195 = v202 + (float)((float)(v204 - v202) * v199);
            }
            else
            {
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v304[0] + 24), 2u, v200, 0, v197);
              float v195 = v205;
              float v203 = 1.0;
            }
            double v206 = v193;
            unint64_t v207 = *(void *)(v304[0] + 24);
            float v208 = fminf(fmaxf(*(float *)(a3 + 28), 0.0), 23.0);
            long long v209 = *(float **)v207;
            if (*(void *)v207
              && (float v210 = *v209, LODWORD(v209) = *v209 == v203, *(unsigned char *)(v207 + 10))
              && v210 != 0.0
              && v210 != v203
              || (v211 = *(unsigned __int8 *)(v207 + v209 + 11), float v210 = 0.0, v211 == 2))
            {
              LOBYTE(v303) = 1;
              char v306 = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v207, 0x140u, 0, (BOOL *)&v303, v208);
              float v213 = v212;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v207, 0x140u, 1u, (BOOL *)&v306, v208);
              float v215 = v213 + (float)((float)(v214 - v213) * v210);
            }
            else
            {
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v304[0] + 24), 0x140u, v211, 0, v208);
            }
            double v193 = v206;
            float v194 = *(double *)(a3 + 40) * v215;
            float v138 = 1.0;
            if (v195 > 0.0)
            {
              gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v303, *(void *)(v304[0] + 24), 3u, 2u, fminf(fmaxf(*(float *)(a3 + 28), 0.0), 23.0));
              float32x4_t v296 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(*(uint16x4_t *)&v303)), (float32x4_t)vdupq_n_s32(0x37800080u));
            }
          }
          else
          {
            float v195 = 0.0;
          }
          uint64_t v216 = *(void *)(v304[0] + 24);
          if ((int)*(float *)(a3 + 28) >= 0x17) {
            unsigned int v217 = 23;
          }
          else {
            unsigned int v217 = (int)*(float *)(a3 + 28);
          }
          long long v218 = *(float **)v216;
          if (!*(void *)v216)
          {
            BOOL v220 = 0;
            goto LABEL_238;
          }
          float v219 = *v218;
          BOOL v220 = *v218 == v138;
          if (!*(unsigned char *)(v216 + 10) || v219 == 0.0 || v219 == v138)
          {
LABEL_238:
            unsigned int v221 = *(unsigned __int8 *)(v216 + v220 + 11);
            if (v221 == 2) {
              goto LABEL_239;
            }
LABEL_241:
            int hasValueForKeyAtZAtEnd = gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v216, 0x13Fu, v217, v221);
            float v223 = 1.0;
            if (hasValueForKeyAtZAtEnd) {
              goto LABEL_242;
            }
LABEL_257:
            float v145 = v189 * v193 * v192;
            uint64_t v139 = v309;
            uint64_t v230 = 16 * v137;
            *(float32x4_t *)(v309 + v230) = v296;
            uint64_t v231 = (float *)(v139 + 4 * v137);
            v231[32] = v195;
            v231[40] = v144;
            v231[48] = v145;
            float v146 = v223 * v194;
            v231[56] = v146;
            uint64_t v142 = v301;
            *(float32x4_t *)(v301 + v230) = v296;
            *(float *)(v301 + 4 * v137 + 128) = v195;
            goto LABEL_148;
          }
LABEL_239:
          if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v304[0] + 24), 0x13Fu, v217, 0) & 1) == 0)
          {
            unsigned int v221 = 1;
            goto LABEL_241;
          }
LABEL_242:
          if (!v218)
          {
            BOOL v225 = 0;
            goto LABEL_248;
          }
          float v224 = *v218;
          BOOL v225 = *v218 == v138;
          if (!*(unsigned char *)(v216 + 10) || v224 == 0.0 || v224 == v138)
          {
LABEL_248:
            unsigned int v226 = *(unsigned __int8 *)(v216 + v225 + 11);
            float v224 = 0.0;
            if (v226 == 2) {
              goto LABEL_249;
            }
            int v228 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v216, 0x13Fu, v217, v226, 0);
          }
          else
          {
LABEL_249:
            LOBYTE(v303) = 1;
            char v306 = 1;
            int v227 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v216, 0x13Fu, v217, 0, &v303);
            int v228 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v216, 0x13Fu, v217, 1u, &v306);
            if (v224 < v138) {
              LOBYTE(v228) = v227;
            }
          }
          float v229 = 0.0;
          if ((_BYTE)v228) {
            float v229 = v138;
          }
          float v223 = 0.5;
          if (v228 != 2) {
            float v223 = v229;
          }
          goto LABEL_257;
        }
      }
      else if (v305)
      {
        goto LABEL_154;
      }
      uint64_t v139 = v309;
      uint64_t v140 = (void *)(v309 + v136);
      uint64_t v141 = (_DWORD *)(v309 + 4 * v137);
      *uint64_t v140 = 0;
      v140[1] = 0;
      v141[32] = 0;
      v141[40] = 0;
      v141[48] = 0;
      v141[56] = 0;
      uint64_t v142 = v301;
      uint64_t v143 = (void *)(v301 + v136);
      *uint64_t v143 = 0;
      v143[1] = 0;
      *(_DWORD *)(v301 + 4 * v137 + 128) = 0;
      float v144 = 0.0;
      float v145 = 0.0;
      float v146 = 0.0;
LABEL_148:
      uint64_t v147 = (float *)(v142 + 4 * v137);
      v147[40] = v144;
      v147[48] = v145;
      v147[56] = v146;
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v304);
      ++v137;
      v136 += 16;
      if (v127 == v137)
      {
        float v232 = v291;
        float v233 = v290;
        *(float *)(v139 + 256) = v232;
        *(float *)(v139 + 260) = v233;
        *(float *)(v142 + 256) = v232;
        *(float *)(v142 + 260) = v233;
        uint64_t v234 = v297;
        if (v299)
        {
          if (*(void *)v298 && *(unsigned char *)(*(void *)&v298[8] + 17) != 2) {
            (*(void (**)(void))(**(void **)v298 + 64))(*(void *)v298);
          }
          uint64_t v236 = *(void *)(*(void *)&v298[8] + 56);
          unint64_t v235 = *(void *)(*(void *)&v298[8] + 64);
          if (v235 == v236) {
            uint64_t v236 = *(void *)(*(void *)&v298[8] + 80) - *(void *)(*(void *)&v298[8] + 72);
          }
          if (v236) {
            uint64_t v236 = 0;
          }
          if (v235 <= v299) {
            unint64_t v235 = v299;
          }
          if (v235 == v236) {
            unint64_t v235 = v236 + *(void *)(*(void *)&v298[8] + 80) - *(void *)(*(void *)&v298[8] + 72);
          }
          *(void *)(*(void *)&v298[8] + 56) = v236;
          *(void *)(*(void *)&v298[8] + 64) = v235;
          uint64_t v234 = v297;
        }
        unint64_t v238 = *(void *)&v307[16];
        unint64_t v237 = v308;
        if ((void)v308 != *(void *)&v307[16])
        {
          long long v239 = *(void **)&v307[8];
          int v240 = BYTE8(v308);
          int v241 = BYTE9(v308);
          if (*(void *)v307 && *(unsigned char *)(*(void *)&v307[8] + 17) != 2)
          {
            (*(void (**)(void))(**(void **)v307 + 64))(*(void *)v307);
            uint64_t v234 = v297;
          }
          if (v240 && !v241)
          {
            unint64_t v243 = v239[7];
            unint64_t v242 = v239[8];
            if (v242 == v243) {
              unint64_t v243 = v239[10] - v239[9];
            }
            if (v238 < v243) {
              unint64_t v243 = v238;
            }
            if (v242 <= v237) {
              unint64_t v242 = v237;
            }
            if (v242 == v243) {
              unint64_t v242 = v243 + v239[10] - v239[9];
            }
            v239[7] = v243;
            v239[8] = v242;
            uint64_t v234 = v297;
          }
        }
        LODWORD(v301) = 0;
        *(_DWORD *)unsigned int v302 = 1065353216;
        memset(&v302[8], 0, 32);
        *(int64x2_t *)&v302[40] = vdupq_n_s64(1uLL);
        *(void *)&v302[56] = 0;
        uint64_t v244 = v295;
        *(void *)&v298[16] = "";
        *(void *)&long long v300 = v295[47] + 1288;
        *((void *)&v300 + 1) = v292;
        int v245 = *((unsigned __int8 *)v295 + 393);
        uint64_t v246 = 20 * (__int16)[(VKPolygonGroup *)v234 layer] + 0x80000000ALL;
        if (!v245) {
          uint64_t v246 = 0x80000000ALL;
        }
        *((void *)&v301 + 1) = v246;
        uint64_t v247 = [(VKPolygonGroup *)v297 venueWallHorizontalStrokeMeshes];
        float v248 = *(uint64_t **)v247;
        float v249 = *(uint64_t **)(v247 + 8);
        if (*(uint64_t **)v247 != v249)
        {
          unsigned int v250 = 0;
          do
          {
            float32x4_t v251 = [(VKPolygonalItemGroup *)v297 commitRangesToHorizontalVenueWallStrokeRenderItemBatcher:v244[47] + 3712 forMeshAtIndex:v250 cullingMask:*(unsigned int *)(a3 + 48)];
            uint64_t v252 = v244[47];
            uint64_t v253 = *v248;
            *(void *)uint64_t v307 = &off_1EF55A458;
            *(_OWORD *)&v307[8] = *(_OWORD *)&v298[8];
            long long v308 = v300;
            long long v312 = *(_OWORD *)&v302[32];
            long long v313 = *(_OWORD *)&v302[48];
            long long v309 = v301;
            long long v310 = *(_OWORD *)v302;
            long long v311 = *(_OWORD *)&v302[16];
            uint64_t v254 = *(void **)(v252 + 3800);
            uint64_t v255 = v254[1];
            if (v255 == *(void *)(v252 + 3808))
            {
              uint64_t v254 = (void *)*v254;
              if (!v254)
              {
                uint64_t v254 = malloc_type_malloc(120 * v255 + 16, 0xB644C221uLL);
                *uint64_t v254 = 0;
                v254[1] = 0;
                **(void **)(v252 + 3800) = v254;
              }
              *(void *)(v252 + 3800) = v254;
              uint64_t v255 = v254[1];
            }
            double v256 = &v254[15 * v255];
            v254[1] = v255 + 1;
            v256[2] = &off_1EF55A458;
            long long v257 = v312;
            long long v258 = v313;
            long long v259 = v311;
            *(_OWORD *)(v256 + 9) = v310;
            long long v260 = *(_OWORD *)&v307[8];
            long long v261 = v308;
            *(_OWORD *)(v256 + 7) = v309;
            *(_OWORD *)(v256 + 5) = v261;
            *(_OWORD *)(v256 + 3) = v260;
            *(_OWORD *)(v256 + 15) = v258;
            *(_OWORD *)(v256 + 13) = v257;
            *(_OWORD *)(v256 + 11) = v259;
            v256[10] = v253;
            uint64_t v262 = *v251;
            v256[13] = *v251;
            v256[14] = (v251[1] - v262) >> 4;
            ggl::CommandBuffer::pushRenderItem(v294, (uint64_t)(v256 + 2));
            uint64_t v244 = v295;
            ++v250;
            v248 += 2;
          }
          while (v248 != v249);
        }
        *((void *)&v300 + 1) = v289;
        uint64_t v263 = [(VKPolygonGroup *)v297 venueWallVerticalStrokeMeshes];
        long long v264 = *(uint64_t **)v263;
        long long v265 = *(uint64_t **)(v263 + 8);
        if (*(uint64_t **)v263 != v265)
        {
          unsigned int v266 = 0;
          do
          {
            long long v267 = [(VKPolygonalItemGroup *)v297 commitRangesToVerticalVenueWallStrokeRenderItemBatcher:v244[47] + 3712 forMeshAtIndex:v266 cullingMask:*(unsigned int *)(a3 + 48)];
            uint64_t v268 = v244[47];
            uint64_t v269 = *v264;
            *(void *)uint64_t v307 = &off_1EF55A458;
            *(_OWORD *)&v307[8] = *(_OWORD *)&v298[8];
            long long v308 = v300;
            long long v312 = *(_OWORD *)&v302[32];
            long long v313 = *(_OWORD *)&v302[48];
            long long v309 = v301;
            long long v310 = *(_OWORD *)v302;
            long long v311 = *(_OWORD *)&v302[16];
            long long v270 = *(void **)(v268 + 3800);
            uint64_t v271 = v270[1];
            if (v271 == *(void *)(v268 + 3808))
            {
              long long v270 = (void *)*v270;
              if (!v270)
              {
                long long v270 = malloc_type_malloc(120 * v271 + 16, 0xB644C221uLL);
                *long long v270 = 0;
                v270[1] = 0;
                **(void **)(v268 + 3800) = v270;
              }
              *(void *)(v268 + 3800) = v270;
              uint64_t v271 = v270[1];
            }
            uint64_t v272 = &v270[15 * v271];
            v270[1] = v271 + 1;
            v272[2] = &off_1EF55A458;
            long long v273 = v312;
            long long v274 = v313;
            long long v275 = v311;
            *(_OWORD *)(v272 + 9) = v310;
            long long v276 = *(_OWORD *)&v307[8];
            long long v277 = v308;
            *(_OWORD *)(v272 + 7) = v309;
            *(_OWORD *)(v272 + 5) = v277;
            *(_OWORD *)(v272 + 3) = v276;
            *(_OWORD *)(v272 + 15) = v274;
            *(_OWORD *)(v272 + 13) = v273;
            *(_OWORD *)(v272 + 11) = v275;
            v272[10] = v269;
            uint64_t v278 = *v267;
            v272[13] = *v267;
            v272[14] = (v267[1] - v278) >> 4;
            ggl::CommandBuffer::pushRenderItem(v294, (uint64_t)(v272 + 2));
            uint64_t v244 = v295;
            ++v266;
            v264 += 2;
          }
          while (v264 != v265);
        }
        id v8 = v293;
        break;
      }
    }
  }
}

void sub_1A2143C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
  _Unwind_Resume(a1);
}

void md::VenueRenderLayer::_layoutVenueWallGroupFills(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  double v9 = a3;
  uint64_t v10 = ggl::FragmentedPool<ggl::VenueWall::MeshPipelineSetup>::pop(*(void *)(*(void *)(a1 + 376) + 536));
  uint64_t v11 = ggl::FragmentedPool<ggl::VenueWall::MeshPipelineSetup>::pop(*(void *)(*(void *)(a1 + 376) + 536));
  uint64_t v12 = *(void *)(*(void *)(a1 + 376) + 992);
  uint64_t v13 = *(void *)(v12 + 8);
  uint64_t v496 = v10;
  if (v13 == *(void *)v12)
  {
    uint64_t v24 = *(void *)(v12 + 88);
    if (!v24)
    {
LABEL_553:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_559:
      __break(1u);
      return;
    }
    uint64_t v497 = (*(uint64_t (**)(uint64_t))(*(void *)v24 + 48))(v24);
    uint64_t v14 = *(uint64_t **)(v12 + 40);
    unint64_t v25 = *(void *)(v12 + 48);
    if ((unint64_t)v14 >= v25)
    {
      uint64_t v27 = *(void *)(v12 + 32);
      uint64_t v28 = ((uint64_t)v14 - v27) >> 3;
      unint64_t v29 = v28 + 1;
      if (!((unint64_t)(v28 + 1) >> 61))
      {
        uint64_t v30 = v25 - v27;
        if (v30 >> 2 > v29) {
          unint64_t v29 = v30 >> 2;
        }
        if ((unint64_t)v30 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v31 = v29;
        }
        if (v31)
        {
          uint64_t v32 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v12 + 56) + 16))(*(void *)(v12 + 56), 8 * v31, 8);
          uint64_t v22 = (uint64_t *)(v32 + 8 * v28);
          uint64_t v23 = v32 + 8 * v31;
          if (v32) {
            *uint64_t v22 = v497;
          }
        }
        else
        {
          uint64_t v23 = 0;
          uint64_t v22 = (uint64_t *)(8 * v28);
        }
        uint64_t v26 = v22 + 1;
        uint64_t v42 = *(void *)(v12 + 32);
        uint64_t v33 = *(void *)(v12 + 40);
        if (v33 == v42) {
          goto LABEL_50;
        }
        unint64_t v43 = v33 - v42 - 8;
        if (v43 < 0x38)
        {
          uint64_t v45 = *(void *)(v12 + 40);
        }
        else if ((unint64_t)(v33 - (void)v22) < 0x20)
        {
          uint64_t v45 = *(void *)(v12 + 40);
        }
        else
        {
          uint64_t v44 = (v43 >> 3) + 1;
          uint64_t v45 = v33 - 8 * (v44 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v46 = v22 - 2;
          uint64_t v47 = (long long *)(v33 - 16);
          uint64_t v48 = v44 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v49 = *v47;
            *((_OWORD *)v46 - 1) = *(v47 - 1);
            *(_OWORD *)uint64_t v46 = v49;
            v46 -= 4;
            v47 -= 2;
            v48 -= 4;
          }
          while (v48);
          v22 -= v44 & 0x3FFFFFFFFFFFFFFCLL;
          if (v44 == (v44 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_49;
          }
        }
        do
        {
          uint64_t v51 = *(void *)(v45 - 8);
          v45 -= 8;
          *--uint64_t v22 = v51;
        }
        while (v45 != v42);
        goto LABEL_49;
      }
LABEL_556:
      abort();
    }
  }
  else
  {
    uint64_t v497 = *(void *)(v13 - 8);
    *(void *)(v12 + 8) = v13 - 8;
    uint64_t v14 = *(uint64_t **)(v12 + 40);
    unint64_t v15 = *(void *)(v12 + 48);
    if ((unint64_t)v14 >= v15)
    {
      uint64_t v16 = *(void *)(v12 + 32);
      uint64_t v17 = ((uint64_t)v14 - v16) >> 3;
      unint64_t v18 = v17 + 1;
      if (!((unint64_t)(v17 + 1) >> 61))
      {
        uint64_t v19 = v15 - v16;
        if (v19 >> 2 > v18) {
          unint64_t v18 = v19 >> 2;
        }
        if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v20 = v18;
        }
        if (v20)
        {
          uint64_t v21 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v12 + 56) + 16))(*(void *)(v12 + 56), 8 * v20, 8);
          uint64_t v22 = (uint64_t *)(v21 + 8 * v17);
          uint64_t v23 = v21 + 8 * v20;
          if (v21) {
            *uint64_t v22 = v497;
          }
        }
        else
        {
          uint64_t v23 = 0;
          uint64_t v22 = (uint64_t *)(8 * v17);
        }
        uint64_t v26 = v22 + 1;
        uint64_t v34 = *(void *)(v12 + 32);
        uint64_t v33 = *(void *)(v12 + 40);
        if (v33 == v34) {
          goto LABEL_50;
        }
        unint64_t v35 = v33 - v34 - 8;
        if (v35 < 0x38)
        {
          uint64_t v37 = *(void *)(v12 + 40);
        }
        else if ((unint64_t)(v33 - (void)v22) < 0x20)
        {
          uint64_t v37 = *(void *)(v12 + 40);
        }
        else
        {
          uint64_t v36 = (v35 >> 3) + 1;
          uint64_t v37 = v33 - 8 * (v36 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v38 = v22 - 2;
          uint64_t v39 = (long long *)(v33 - 16);
          uint64_t v40 = v36 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v41 = *v39;
            *((_OWORD *)v38 - 1) = *(v39 - 1);
            *(_OWORD *)uint64_t v38 = v41;
            v38 -= 4;
            v39 -= 2;
            v40 -= 4;
          }
          while (v40);
          v22 -= v36 & 0x3FFFFFFFFFFFFFFCLL;
          if (v36 == (v36 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_49;
          }
        }
        do
        {
          uint64_t v50 = *(void *)(v37 - 8);
          v37 -= 8;
          *--uint64_t v22 = v50;
        }
        while (v37 != v34);
LABEL_49:
        uint64_t v33 = *(void *)(v12 + 32);
LABEL_50:
        *(void *)(v12 + 32) = v22;
        *(void *)(v12 + 40) = v26;
        uint64_t v52 = *(void *)(v12 + 48);
        *(void *)(v12 + 48) = v23;
        if (v33) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v12 + 56) + 40))(*(void *)(v12 + 56), v33, v52 - v33);
        }
        goto LABEL_52;
      }
      goto LABEL_556;
    }
  }
  if (v14) {
    *uint64_t v14 = v497;
  }
  uint64_t v26 = v14 + 1;
LABEL_52:
  *(void *)(v12 + 40) = v26;
  *(void *)v546 = v497;
  uint64_t v53 = *(void *)(v12 + 120);
  if (!v53) {
    goto LABEL_553;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v53 + 48))(v53, v546);
  uint64_t v54 = *(void *)(*(void *)(a1 + 376) + 1232);
  uint64_t v55 = *(void *)(v54 + 8);
  if (v55 == *(void *)v54)
  {
    uint64_t v67 = *(void *)(v54 + 88);
    if (!v67) {
      goto LABEL_554;
    }
    uint64_t v56 = (*(uint64_t (**)(uint64_t))(*(void *)v67 + 48))(v67);
    uint64_t v57 = *(uint64_t **)(v54 + 40);
    unint64_t v68 = *(void *)(v54 + 48);
    if ((unint64_t)v57 >= v68)
    {
      uint64_t v70 = *(void *)(v54 + 32);
      uint64_t v71 = ((uint64_t)v57 - v70) >> 3;
      unint64_t v72 = v71 + 1;
      if (!((unint64_t)(v71 + 1) >> 61))
      {
        uint64_t v73 = v68 - v70;
        if (v73 >> 2 > v72) {
          unint64_t v72 = v73 >> 2;
        }
        if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v74 = v72;
        }
        if (v74)
        {
          uint64_t v75 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v54 + 56) + 16))(*(void *)(v54 + 56), 8 * v74, 8);
          uint64_t v65 = (uint64_t *)(v75 + 8 * v71);
          uint64_t v66 = v75 + 8 * v74;
          if (v75) {
            *uint64_t v65 = v56;
          }
        }
        else
        {
          uint64_t v66 = 0;
          uint64_t v65 = (uint64_t *)(8 * v71);
        }
        uint64_t v69 = v65 + 1;
        uint64_t v85 = *(void *)(v54 + 32);
        uint64_t v76 = *(void *)(v54 + 40);
        if (v76 == v85) {
          goto LABEL_102;
        }
        unint64_t v86 = v76 - v85 - 8;
        if (v86 < 0x38)
        {
          uint64_t v88 = *(void *)(v54 + 40);
        }
        else if ((unint64_t)(v76 - (void)v65) < 0x20)
        {
          uint64_t v88 = *(void *)(v54 + 40);
        }
        else
        {
          uint64_t v87 = (v86 >> 3) + 1;
          uint64_t v88 = v76 - 8 * (v87 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v89 = v65 - 2;
          uint64_t v90 = (long long *)(v76 - 16);
          uint64_t v91 = v87 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v92 = *v90;
            *((_OWORD *)v89 - 1) = *(v90 - 1);
            *(_OWORD *)uint64_t v89 = v92;
            v89 -= 4;
            v90 -= 2;
            v91 -= 4;
          }
          while (v91);
          v65 -= v87 & 0x3FFFFFFFFFFFFFFCLL;
          if (v87 == (v87 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_101;
          }
        }
        do
        {
          uint64_t v94 = *(void *)(v88 - 8);
          v88 -= 8;
          *--uint64_t v65 = v94;
        }
        while (v88 != v85);
        goto LABEL_101;
      }
LABEL_557:
      abort();
    }
LABEL_66:
    if (v57) {
      *uint64_t v57 = v56;
    }
    uint64_t v69 = v57 + 1;
    goto LABEL_104;
  }
  uint64_t v56 = *(void *)(v55 - 8);
  *(void *)(v54 + 8) = v55 - 8;
  uint64_t v57 = *(uint64_t **)(v54 + 40);
  unint64_t v58 = *(void *)(v54 + 48);
  if ((unint64_t)v57 < v58) {
    goto LABEL_66;
  }
  uint64_t v59 = *(void *)(v54 + 32);
  uint64_t v60 = ((uint64_t)v57 - v59) >> 3;
  unint64_t v61 = v60 + 1;
  if ((unint64_t)(v60 + 1) >> 61) {
    goto LABEL_557;
  }
  uint64_t v62 = v58 - v59;
  if (v62 >> 2 > v61) {
    unint64_t v61 = v62 >> 2;
  }
  if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v63 = v61;
  }
  if (v63)
  {
    uint64_t v64 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v54 + 56) + 16))(*(void *)(v54 + 56), 8 * v63, 8);
    uint64_t v65 = (uint64_t *)(v64 + 8 * v60);
    uint64_t v66 = v64 + 8 * v63;
    if (v64) {
      *uint64_t v65 = v56;
    }
  }
  else
  {
    uint64_t v66 = 0;
    uint64_t v65 = (uint64_t *)(8 * v60);
  }
  uint64_t v69 = v65 + 1;
  uint64_t v77 = *(void *)(v54 + 32);
  uint64_t v76 = *(void *)(v54 + 40);
  if (v76 == v77) {
    goto LABEL_102;
  }
  unint64_t v78 = v76 - v77 - 8;
  if (v78 < 0x38)
  {
    uint64_t v80 = *(void *)(v54 + 40);
  }
  else if ((unint64_t)(v76 - (void)v65) < 0x20)
  {
    uint64_t v80 = *(void *)(v54 + 40);
  }
  else
  {
    uint64_t v79 = (v78 >> 3) + 1;
    uint64_t v80 = v76 - 8 * (v79 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v81 = v65 - 2;
    uint64_t v82 = (long long *)(v76 - 16);
    uint64_t v83 = v79 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v84 = *v82;
      *((_OWORD *)v81 - 1) = *(v82 - 1);
      *(_OWORD *)uint64_t v81 = v84;
      v81 -= 4;
      v82 -= 2;
      v83 -= 4;
    }
    while (v83);
    v65 -= v79 & 0x3FFFFFFFFFFFFFFCLL;
    if (v79 == (v79 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_101;
    }
  }
  do
  {
    uint64_t v93 = *(void *)(v80 - 8);
    v80 -= 8;
    *--uint64_t v65 = v93;
  }
  while (v80 != v77);
LABEL_101:
  uint64_t v76 = *(void *)(v54 + 32);
LABEL_102:
  *(void *)(v54 + 32) = v65;
  *(void *)(v54 + 40) = v69;
  uint64_t v95 = *(void *)(v54 + 48);
  *(void *)(v54 + 48) = v66;
  if (v76) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v54 + 56) + 40))(*(void *)(v54 + 56), v76, v95 - v76);
  }
LABEL_104:
  *(void *)(v54 + 40) = v69;
  *(void *)v546 = v56;
  uint64_t v96 = *(void *)(v54 + 120);
  if (!v96) {
    goto LABEL_554;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v96 + 48))(v96, v546);
  uint64_t v495 = ggl::FragmentedPool<ggl::VenueWallShadow::MeshPipelineSetup>::pop(*(void *)(*(void *)(a1 + 376) + 1520));
  uint64_t v494 = ggl::FragmentedPool<ggl::VenueWallShadow::MeshPipelineSetup>::pop(*(void *)(*(void *)(a1 + 376) + 1760));
  uint64_t v518 = a1;
  uint64_t v97 = *(void *)(*(void *)(a1 + 376) + 1984);
  uint64_t v98 = *(void *)(v97 + 8);
  if (v98 != *(void *)v97)
  {
    uint64_t v99 = *(void *)(v98 - 8);
    *(void *)(v97 + 8) = v98 - 8;
    int8x8_t v100 = *(uint64_t **)(v97 + 40);
    unint64_t v101 = *(void *)(v97 + 48);
    if ((unint64_t)v100 >= v101)
    {
      uint64_t v102 = *(void *)(v97 + 32);
      uint64_t v103 = ((uint64_t)v100 - v102) >> 3;
      unint64_t v104 = v103 + 1;
      if (!((unint64_t)(v103 + 1) >> 61))
      {
        uint64_t v105 = v101 - v102;
        if (v105 >> 2 > v104) {
          unint64_t v104 = v105 >> 2;
        }
        if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v106 = v104;
        }
        if (v106)
        {
          uint64_t v107 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v97 + 56) + 16))(*(void *)(v97 + 56), 8 * v106, 8);
          uint64_t v108 = (uint64_t *)(v107 + 8 * v103);
          uint64_t v109 = v107 + 8 * v106;
          if (v107) {
            uint64_t *v108 = v99;
          }
        }
        else
        {
          uint64_t v109 = 0;
          uint64_t v108 = (uint64_t *)(8 * v103);
        }
        uint64_t v112 = v108 + 1;
        uint64_t v120 = *(void *)(v97 + 32);
        uint64_t v119 = *(void *)(v97 + 40);
        if (v119 == v120) {
          goto LABEL_154;
        }
        unint64_t v121 = v119 - v120 - 8;
        if (v121 < 0x38)
        {
          uint64_t v123 = *(void *)(v97 + 40);
        }
        else if ((unint64_t)(v119 - (void)v108) < 0x20)
        {
          uint64_t v123 = *(void *)(v97 + 40);
        }
        else
        {
          uint64_t v122 = (v121 >> 3) + 1;
          uint64_t v123 = v119 - 8 * (v122 & 0x3FFFFFFFFFFFFFFCLL);
          char v124 = v108 - 2;
          uint64_t v125 = (long long *)(v119 - 16);
          uint64_t v126 = v122 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v127 = *v125;
            *((_OWORD *)v124 - 1) = *(v125 - 1);
            *(_OWORD *)char v124 = v127;
            v124 -= 4;
            v125 -= 2;
            v126 -= 4;
          }
          while (v126);
          v108 -= v122 & 0x3FFFFFFFFFFFFFFCLL;
          if (v122 == (v122 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_153;
          }
        }
        do
        {
          uint64_t v136 = *(void *)(v123 - 8);
          v123 -= 8;
          *--uint64_t v108 = v136;
        }
        while (v123 != v120);
LABEL_153:
        uint64_t v119 = *(void *)(v97 + 32);
LABEL_154:
        *(void *)(v97 + 32) = v108;
        *(void *)(v97 + 40) = v112;
        uint64_t v138 = *(void *)(v97 + 48);
        *(void *)(v97 + 48) = v109;
        if (v119) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v97 + 56) + 40))(*(void *)(v97 + 56), v119, v138 - v119);
        }
        goto LABEL_156;
      }
      goto LABEL_558;
    }
    goto LABEL_118;
  }
  uint64_t v110 = *(void *)(v97 + 88);
  if (!v110)
  {
LABEL_554:
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_559;
  }
  uint64_t v99 = (*(uint64_t (**)(uint64_t))(*(void *)v110 + 48))(v110);
  int8x8_t v100 = *(uint64_t **)(v97 + 40);
  unint64_t v111 = *(void *)(v97 + 48);
  if ((unint64_t)v100 >= v111)
  {
    uint64_t v113 = *(void *)(v97 + 32);
    uint64_t v114 = ((uint64_t)v100 - v113) >> 3;
    unint64_t v115 = v114 + 1;
    if (!((unint64_t)(v114 + 1) >> 61))
    {
      uint64_t v116 = v111 - v113;
      if (v116 >> 2 > v115) {
        unint64_t v115 = v116 >> 2;
      }
      if ((unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v117 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v117 = v115;
      }
      if (v117)
      {
        uint64_t v118 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v97 + 56) + 16))(*(void *)(v97 + 56), 8 * v117, 8);
        uint64_t v108 = (uint64_t *)(v118 + 8 * v114);
        uint64_t v109 = v118 + 8 * v117;
        if (v118) {
          uint64_t *v108 = v99;
        }
      }
      else
      {
        uint64_t v109 = 0;
        uint64_t v108 = (uint64_t *)(8 * v114);
      }
      uint64_t v112 = v108 + 1;
      uint64_t v128 = *(void *)(v97 + 32);
      uint64_t v119 = *(void *)(v97 + 40);
      if (v119 == v128) {
        goto LABEL_154;
      }
      unint64_t v129 = v119 - v128 - 8;
      if (v129 < 0x38)
      {
        uint64_t v131 = *(void *)(v97 + 40);
      }
      else if ((unint64_t)(v119 - (void)v108) < 0x20)
      {
        uint64_t v131 = *(void *)(v97 + 40);
      }
      else
      {
        uint64_t v130 = (v129 >> 3) + 1;
        uint64_t v131 = v119 - 8 * (v130 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v132 = v108 - 2;
        uint64_t v133 = (long long *)(v119 - 16);
        uint64_t v134 = v130 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v135 = *v133;
          *((_OWORD *)v132 - 1) = *(v133 - 1);
          *(_OWORD *)uint64_t v132 = v135;
          v132 -= 4;
          v133 -= 2;
          v134 -= 4;
        }
        while (v134);
        v108 -= v130 & 0x3FFFFFFFFFFFFFFCLL;
        if (v130 == (v130 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_153;
        }
      }
      do
      {
        uint64_t v137 = *(void *)(v131 - 8);
        v131 -= 8;
        *--uint64_t v108 = v137;
      }
      while (v131 != v128);
      goto LABEL_153;
    }
LABEL_558:
    abort();
  }
LABEL_118:
  if (v100) {
    *int8x8_t v100 = v99;
  }
  uint64_t v112 = v100 + 1;
LABEL_156:
  *(void *)(v97 + 40) = v112;
  *(void *)v546 = v99;
  uint64_t v139 = *(void *)(v97 + 120);
  if (!v139) {
    goto LABEL_554;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v139 + 48))(v139, v546);
  uint64_t v140 = *(void **)(a2 + 8);
  int8x8_t v141 = (int8x8_t)v140[1];
  if (!*(void *)&v141)
  {
    float v146 = 0;
    uint64_t v143 = a5;
    uint64_t v144 = v496;
    goto LABEL_182;
  }
  uint8x8_t v142 = (uint8x8_t)vcnt_s8(v141);
  v142.i16[0] = vaddlv_u8(v142);
  uint64_t v143 = a5;
  uint64_t v144 = v496;
  if (v142.u32[0] > 1uLL)
  {
    uint64_t v145 = 0x41E8D6E445F4145;
    if (*(void *)&v141 <= 0x41E8D6E445F4145uLL) {
      uint64_t v145 = 0x41E8D6E445F4145uLL % *(void *)&v141;
    }
  }
  else
  {
    uint64_t v145 = (*(void *)&v141 - 1) & 0x41E8D6E445F4145;
  }
  uint64_t v147 = *(void **)(*v140 + 8 * v145);
  if (!v147) {
    goto LABEL_181;
  }
  long long v148 = (void *)*v147;
  if (!v148) {
    goto LABEL_181;
  }
  if (v142.u32[0] < 2uLL)
  {
    uint64_t v149 = *(void *)&v141 - 1;
    while (1)
    {
      uint64_t v151 = v148[1];
      if (v151 == 0x41E8D6E445F4145)
      {
        if (v148[2] == 0x41E8D6E445F4145) {
          goto LABEL_179;
        }
      }
      else if ((v151 & v149) != v145)
      {
        goto LABEL_181;
      }
      long long v148 = (void *)*v148;
      if (!v148) {
        goto LABEL_181;
      }
    }
  }
  while (1)
  {
    unint64_t v150 = v148[1];
    if (v150 == 0x41E8D6E445F4145) {
      break;
    }
    if (v150 >= *(void *)&v141) {
      v150 %= *(void *)&v141;
    }
    if (v150 != v145) {
      goto LABEL_181;
    }
LABEL_168:
    long long v148 = (void *)*v148;
    if (!v148) {
      goto LABEL_181;
    }
  }
  if (v148[2] != 0x41E8D6E445F4145) {
    goto LABEL_168;
  }
LABEL_179:
  uint64_t v152 = v148[5];
  if (*(void *)(v152 + 8) == 0x41E8D6E445F4145)
  {
    float v146 = *(float64x2_t **)(v152 + 32);
    goto LABEL_182;
  }
LABEL_181:
  float v146 = 0;
LABEL_182:
  float v153 = *(uint64_t **)v143;
  BOOL v154 = *(uint64_t **)(v144 + 64);
  v154[1] = 0;
  uint64_t v155 = *v153;
  *BOOL v154 = *v153;
  char v156 = *(void **)(v144 + 160);
  uint64_t v157 = v153[1];
  if (v157) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v157 + 8), 1uLL, memory_order_relaxed);
  }
  float v158 = (std::__shared_weak_count *)v156[1];
  *char v156 = v155;
  v156[1] = v157;
  if (v158 && !atomic_fetch_add(&v158->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v158->__on_zero_shared)(v158);
    std::__shared_weak_count::__release_weak(v158);
  }
  uint64_t v159 = *(void *)(v144 + 64);
  *(void *)(v159 + 24) = 0;
  float64_t v160 = v146->f64[0];
  *(float64_t *)(v159 + 16) = v146->f64[0];
  uint64_t v161 = *(void *)(v144 + 160);
  float64_t v162 = v146->f64[1];
  if (v162 != 0.0) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v162 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v163 = *(std::__shared_weak_count **)(v161 + 24);
  *(float64_t *)(v161 + 16) = v160;
  *(float64_t *)(v161 + 24) = v162;
  if (v163 && !atomic_fetch_add(&v163->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v163->__on_zero_shared)(v163);
    std::__shared_weak_count::__release_weak(v163);
  }
  uint64_t v164 = *(void *)(v144 + 64);
  *(void *)(v164 + 32) = v99;
  *(void *)(v164 + 40) = 0;
  uint64_t v165 = *(void *)(v144 + 160);
  char v166 = *(std::__shared_weak_count **)(v165 + 40);
  *(void *)(v165 + 32) = 0;
  *(void *)(v165 + 40) = 0;
  if (v166 && !atomic_fetch_add(&v166->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v166->__on_zero_shared)(v166);
    std::__shared_weak_count::__release_weak(v166);
  }
  double v167 = *(uint64_t **)v143;
  unint64_t v168 = *(uint64_t **)(v11 + 64);
  v168[1] = 0;
  uint64_t v169 = *v167;
  uint64_t *v168 = *v167;
  long double v170 = *(void **)(v11 + 160);
  uint64_t v171 = v167[1];
  if (v171) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v171 + 8), 1uLL, memory_order_relaxed);
  }
  BOOL v172 = (std::__shared_weak_count *)v170[1];
  *long double v170 = v169;
  v170[1] = v171;
  if (v172 && !atomic_fetch_add(&v172->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v172->__on_zero_shared)(v172);
    std::__shared_weak_count::__release_weak(v172);
  }
  uint64_t v173 = *(void *)(v11 + 64);
  *(void *)(v173 + 24) = 0;
  float64_t v174 = v146->f64[0];
  *(float64_t *)(v173 + 16) = v146->f64[0];
  uint64_t v175 = *(void *)(v11 + 160);
  float64_t v176 = v146->f64[1];
  if (v176 != 0.0) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v176 + 8), 1uLL, memory_order_relaxed);
  }
  float v177 = *(std::__shared_weak_count **)(v175 + 24);
  *(float64_t *)(v175 + 16) = v174;
  *(float64_t *)(v175 + 24) = v176;
  if (v177 && !atomic_fetch_add(&v177->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v177->__on_zero_shared)(v177);
    std::__shared_weak_count::__release_weak(v177);
  }
  uint64_t v178 = *(void *)(v11 + 64);
  *(void *)(v178 + 32) = v99;
  *(void *)(v178 + 40) = 0;
  uint64_t v179 = *(void *)(v11 + 160);
  unint64_t v180 = *(std::__shared_weak_count **)(v179 + 40);
  *(void *)(v179 + 32) = 0;
  *(void *)(v179 + 40) = 0;
  if (v180 && !atomic_fetch_add(&v180->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
    std::__shared_weak_count::__release_weak(v180);
  }
  float v181 = *(uint64_t **)v143;
  uint64_t v182 = *(uint64_t **)(v497 + 64);
  v182[1] = 0;
  uint64_t v183 = *v181;
  *uint64_t v182 = *v181;
  BOOL v184 = *(void **)(v497 + 160);
  uint64_t v185 = v181[1];
  if (v185) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v185 + 8), 1uLL, memory_order_relaxed);
  }
  float v186 = (std::__shared_weak_count *)v184[1];
  *BOOL v184 = v183;
  v184[1] = v185;
  if (v186 && !atomic_fetch_add(&v186->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v186->__on_zero_shared)(v186);
    std::__shared_weak_count::__release_weak(v186);
  }
  uint64_t v187 = *(void *)(v497 + 64);
  *(void *)(v187 + 24) = 0;
  float64_t v188 = v146->f64[0];
  *(float64_t *)(v187 + 16) = v146->f64[0];
  uint64_t v189 = *(void *)(v497 + 160);
  float64_t v190 = v146->f64[1];
  if (v190 != 0.0) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v190 + 8), 1uLL, memory_order_relaxed);
  }
  float v191 = *(std::__shared_weak_count **)(v189 + 24);
  *(float64_t *)(v189 + 16) = v188;
  *(float64_t *)(v189 + 24) = v190;
  if (v191 && !atomic_fetch_add(&v191->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v191->__on_zero_shared)(v191);
    std::__shared_weak_count::__release_weak(v191);
  }
  double v192 = *(uint64_t **)v143;
  double v193 = *(uint64_t **)(v56 + 64);
  v193[1] = 0;
  uint64_t v194 = *v192;
  *double v193 = *v192;
  float v195 = *(void **)(v56 + 160);
  uint64_t v196 = v192[1];
  if (v196) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v196 + 8), 1uLL, memory_order_relaxed);
  }
  float v197 = (std::__shared_weak_count *)v195[1];
  void *v195 = v194;
  v195[1] = v196;
  if (v197 && !atomic_fetch_add(&v197->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
    std::__shared_weak_count::__release_weak(v197);
  }
  uint64_t v198 = *(void *)(v56 + 64);
  *(void *)(v198 + 24) = 0;
  float64_t v199 = v146->f64[0];
  *(float64_t *)(v198 + 16) = v146->f64[0];
  uint64_t v200 = *(void *)(v56 + 160);
  float64_t v201 = v146->f64[1];
  if (v201 != 0.0) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v201 + 8), 1uLL, memory_order_relaxed);
  }
  float v202 = *(std::__shared_weak_count **)(v200 + 24);
  *(float64_t *)(v200 + 16) = v199;
  *(float64_t *)(v200 + 24) = v201;
  if (v202 && !atomic_fetch_add(&v202->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v202->__on_zero_shared)(v202);
    std::__shared_weak_count::__release_weak(v202);
  }
  uint64_t v203 = *(void *)(v56 + 64);
  *(void *)(v203 + 32) = v99;
  *(void *)(v203 + 40) = 0;
  uint64_t v204 = *(void *)(v56 + 160);
  float v205 = *(std::__shared_weak_count **)(v204 + 40);
  *(void *)(v204 + 32) = 0;
  *(void *)(v204 + 40) = 0;
  if (v205 && !atomic_fetch_add(&v205->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v205->__on_zero_shared)(v205);
    std::__shared_weak_count::__release_weak(v205);
  }
  double v206 = *(uint64_t **)v143;
  unint64_t v207 = *(uint64_t **)(v495 + 64);
  v207[1] = 0;
  uint64_t v208 = *v206;
  *unint64_t v207 = *v206;
  long long v209 = *(void **)(v495 + 160);
  uint64_t v210 = v206[1];
  if (v210) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v210 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v211 = (std::__shared_weak_count *)v209[1];
  *long long v209 = v208;
  v209[1] = v210;
  if (v211 && !atomic_fetch_add(&v211->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v211->__on_zero_shared)(v211);
    std::__shared_weak_count::__release_weak(v211);
  }
  float v212 = *(uint64_t **)v143;
  float v213 = *(uint64_t **)(v494 + 64);
  v213[1] = 0;
  uint64_t v214 = *v212;
  *float v213 = *v212;
  float v215 = *(void **)(v494 + 160);
  uint64_t v216 = v212[1];
  if (v216) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v216 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v217 = (std::__shared_weak_count *)v215[1];
  *float v215 = v214;
  v215[1] = v216;
  if (v217 && !atomic_fetch_add(&v217->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v217->__on_zero_shared)(v217);
    std::__shared_weak_count::__release_weak(v217);
  }
  float64x2_t v513 = v146[3];
  char v218 = md::VenueLayerLayoutCharacteristics::focusState((md::VenueLayerLayoutCharacteristics *)(a1 + 384), v9);
  v546[0] = 0;
  v546[1] = v218;
  float v219 = [(VKPolygonalItemGroup *)v9 styleQueries:v546];
  unint64_t v502 = ((v219[2] - *v219) >> 4);
  if (!((v219[2] - *v219) >> 4)) {
    goto LABEL_552;
  }
  uint64_t v220 = *(void *)(*(void *)(v144 + 64) + 48);
  *(_OWORD *)v546 = 0uLL;
  uint64_t v221 = *(void *)(v220 + 8);
  *(void *)&long long v222 = 0;
  *(void *)&long long v223 = 0;
  *((void *)&v223 + 1) = v220;
  if (v221) {
    uint64_t v224 = *(void *)(v220 + 72);
  }
  else {
    uint64_t v224 = 0;
  }
  *(_OWORD *)v546 = v223;
  *(void *)&v546[16] = 0;
  *(void *)&long long v547 = v221;
  *(void *)&long long v548 = v224;
  WORD4(v547) = 1;
  uint64_t v225 = *(void *)(*(void *)(v56 + 64) + 48);
  uint64_t v226 = *(void *)(v225 + 8);
  if (v226) {
    uint64_t v227 = *(void *)(v225 + 72);
  }
  else {
    uint64_t v227 = 0;
  }
  *((void *)&v222 + 1) = *(void *)(*(void *)(v56 + 64) + 48);
  *(_OWORD *)v538 = v222;
  *(void *)&long long v539 = v226;
  *(void *)&long long v540 = v227;
  *(void *)&long long v228 = 0;
  *(void *)&long long v229 = 0;
  *((void *)&v229 + 1) = v99;
  if (*(void *)(v99 + 8)) {
    uint64_t v230 = *(void *)(v99 + 72);
  }
  else {
    uint64_t v230 = 0;
  }
  long long v535 = v229;
  *(void *)&long long v536 = *(void *)(v99 + 8);
  uint64_t v537 = v230;
  uint64_t v231 = *(void *)(*(void *)(v11 + 64) + 48);
  if (*(void *)(v231 + 8)) {
    uint64_t v232 = *(void *)(v231 + 72);
  }
  else {
    uint64_t v232 = 0;
  }
  uint64_t v491 = v56;
  *((void *)&v228 + 1) = *(void *)(*(void *)(v11 + 64) + 48);
  long long v532 = v228;
  *(void *)&long long v533 = *(void *)(v231 + 8);
  uint64_t v534 = v232;
  uint64_t v233 = *(void *)(*(void *)(v497 + 64) + 32);
  *(void *)&long long v234 = 0;
  *(void *)&long long v235 = 0;
  if (*(void *)(v233 + 8)) {
    uint64_t v236 = *(void *)(v233 + 72);
  }
  else {
    uint64_t v236 = 0;
  }
  *((void *)&v235 + 1) = *(void *)(*(void *)(v497 + 64) + 32);
  *(_OWORD *)v528 = v235;
  *(void *)&long long v529 = *(void *)(v233 + 8);
  *(void *)&long long v530 = v236;
  uint64_t v237 = *(void *)(*(void *)(v495 + 64) + 16);
  unint64_t v238 = *(void *)(v237 + 8);
  if (v238) {
    uint64_t v239 = *(void *)(v237 + 72);
  }
  else {
    uint64_t v239 = 0;
  }
  *((void *)&v234 + 1) = *(void *)(*(void *)(v495 + 64) + 16);
  *(_OWORD *)v523 = v234;
  unint64_t v524 = v238;
  *(void *)&long long v526 = v239;
  uint64_t v240 = *(void *)(*(void *)(v494 + 64) + 16);
  unint64_t v241 = *(void *)(v240 + 8);
  *(void *)&long long v242 = 0;
  if (v241) {
    uint64_t v243 = *(void *)(v240 + 72);
  }
  else {
    uint64_t v243 = 0;
  }
  uint64_t v493 = v11;
  *((void *)&v242 + 1) = *(void *)(*(void *)(v494 + 64) + 16);
  long long v519 = v242;
  unint64_t v520 = v241;
  uint64_t v522 = v243;
  uint64_t v244 = [(VKPolygonGroup *)v9 wallTexture];
  v500 = v9;
  v501 = v219;
  if (v244) {
    uint64_t v245 = v244;
  }
  else {
    uint64_t v245 = *(void *)(v143 + 56);
  }
  float v246 = *(float *)(v143 + 52);
  unsigned int v247 = *(_DWORD *)(v245 + 80);
  [(VKPolygonGroup *)v9 maximumSectionLength];
  uint64_t v248 = 0;
  uint64_t v249 = 0;
  uint64_t v250 = 0;
  char v515 = 0;
  float32x2_t v499 = vcvt_f32_f64(v513);
  float v251 = v246 / (float)v247;
  **(void **)(v496 + 96) = v245;
  **(void **)(v493 + 96) = v245;
  **(void **)(v497 + 96) = v245;
  **(void **)(v492 + 96) = *(void *)(v143 + 56);
  *(_DWORD *)(v224 + 448) = -1082130432;
  *(_DWORD *)(v224 + 456) = v252;
  *(float *)(v224 + 452) = v251;
  *(_DWORD *)(v232 + 448) = 1065353216;
  *(_DWORD *)(v232 + 456) = v252;
  *(float *)(v232 + 452) = v251;
  *(_DWORD *)(v236 + 456) = v252;
  *(float *)(v236 + 452) = v251;
  float v253 = 1.0;
  float v498 = 1.0 / sqrtf(vaddv_f32(vmul_f32(v499, v499)));
  float v254 = 23.0;
  float32x4_t v514 = (float32x4_t)vdupq_n_s32(0x37800080u);
  BOOL v255 = 1;
  while (2)
  {
    long long v284 = *(_OWORD *)(*v501 + 16 * v250);
    long long v542 = v284;
    int v285 = (std::__shared_weak_count *)*((void *)&v284 + 1);
    if (*((void *)&v284 + 1))
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v284 + 1) + 8), 1uLL, memory_order_relaxed);
      int v285 = (std::__shared_weak_count *)*((void *)&v542 + 1);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v543, v284, (uint64_t)v285);
    if (v285 && !atomic_fetch_add(&v285->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v285->__on_zero_shared)(v285);
      std::__shared_weak_count::__release_weak(v285);
      if (v544) {
        goto LABEL_283;
      }
      goto LABEL_299;
    }
    if (!v544)
    {
LABEL_299:
      uint64_t v294 = (void *)(v548 + v249);
      float v295 = (_DWORD *)(v548 + 4 * v250);
      void *v294 = 0;
      v294[1] = 0;
      v295[64] = 0;
      v295[96] = 0;
      v295[80] = 0;
      float32x4_t v296 = (void *)(v540 + v249);
      unsigned int v297 = (_DWORD *)(v540 + 4 * v250);
      void *v296 = 0;
      v296[1] = 0;
      v297[64] = 0;
      v297[80] = 0;
      v297[112] = 0;
      v297[96] = 0;
      *(void *)(v537 + 8 * v250) = 0x3F8000007FC00000;
      float32_t v298 = (void *)(v534 + v249);
      unint64_t v299 = (_DWORD *)(v534 + 4 * v250);
      *float32_t v298 = 0;
      v298[1] = 0;
      v299[64] = 0;
      v299[96] = 0;
      v299[80] = 0;
      long long v300 = (void *)(v530 + v249);
      long long v301 = (_DWORD *)(v530 + 4 * v250);
      void *v300 = 0;
      v300[1] = 0;
      v301[64] = 0;
      v301[80] = 0;
      v301[96] = 0;
      unsigned int v302 = (void *)(v526 + v249);
      *unsigned int v302 = 0;
      v302[1] = 0;
      float32x2_t v279 = 0;
      *(void *)(v526 + 8 * v250 + 256) = 0;
      uint64_t v282 = v522;
      uint64_t v283 = v522 + v249;
      *(_DWORD *)(v522 + v249) = 0;
      float v259 = 0.0;
      float v260 = 0.0;
      goto LABEL_277;
    }
LABEL_283:
    if (v250) {
      goto LABEL_302;
    }
    uint64_t v286 = *(void *)(v543[0] + 24);
    unsigned int v287 = (int)*(float *)(v143 + 28) >= 0x17 ? 23 : (int)*(float *)(v143 + 28);
    if ((id v288 = *(float **)v286) != 0
      && (float v289 = *v288, LODWORD(v288) = *v288 == v253, *(unsigned char *)(v286 + 10))
      && (v289 != 0.0 ? (BOOL v290 = v289 == v253) : (BOOL v290 = 1), !v290)
      || (v291 = *(unsigned __int8 *)(v286 + v288 + 11), float v289 = 0.0, v291 == 2))
    {
      LOBYTE(v542) = 1;
      char v545 = 1;
      char v292 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v286, 0x5Bu, v287, 0, &v542);
      char v293 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v286, 0x5Bu, v287, 1, &v545);
      if (v289 < v253) {
        char v293 = v292;
      }
    }
    else
    {
      char v293 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v543[0] + 24), 0x5Bu, v287, v291, 0);
    }
    if (v293)
    {
LABEL_302:
      gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v542, *(void *)(v543[0] + 24), 0xA1u, 2u, fminf(fmaxf(*(float *)(v143 + 28), 0.0), v254));
      uint16x4_t v303 = (uint16x4_t)v542;
      gss::RenderStyle<gss::PropertyID>::sampledValueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v542, *(void *)(v543[0] + 24), 0xA0u, 2u, fminf(fmaxf(*(float *)(v143 + 28), 0.0), v254));
      uint16x4_t v304 = (uint16x4_t)v542;
      float32x4_t v511 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v303)), v514);
      BOOL v305 = fabsf(v511.f32[3] + -1.0) > 0.00000011921;
      if ((int)*(float *)(v143 + 28) >= 0x17) {
        unsigned int v306 = 23;
      }
      else {
        unsigned int v306 = (int)*(float *)(v143 + 28);
      }
      gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v542, *(void *)(v543[0] + 24), 0x8Du, v306, 2u, 0);
      LOWORD(v307) = v542;
      unsigned int v508 = v307;
      LOWORD(v6) = WORD2(v542);
      LOWORD(v5) = WORD1(v542);
      float v308 = *(float *)(v143 + 28);
      unsigned int v309 = (int)v308;
      LOWORD(v308) = WORD3(v542);
      unsigned int v509 = LODWORD(v308);
      unsigned int v510 = LODWORD(v5);
      uint64_t v310 = *(void *)(v543[0] + 24);
      if (v309 >= 0x17) {
        unsigned int v311 = 23;
      }
      else {
        unsigned int v311 = v309;
      }
      long long v312 = *(float **)v310;
      if (*(void *)v310
        && (float v313 = *v312, LODWORD(v312) = *v312 == v253, *(unsigned char *)(v310 + 10))
        && (v313 != 0.0 ? (BOOL v314 = v313 == v253) : (BOOL v314 = 1), !v314)
        || (v315 = *(unsigned __int8 *)(v310 + v312 + 11), float v313 = 0.0, v315 == 2))
      {
        LOBYTE(v542) = 1;
        char v545 = 1;
        float v316 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v310, 0x8Bu, v311, 0, &v542);
        float v317 = v316
             + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v310, 0x8Bu, v311, 1u, &v545)- v316)* v313);
      }
      else
      {
        float v317 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v543[0] + 24), 0x8Bu, v311, v315, 0);
      }
      float v505 = v317;
      unsigned int v506 = LODWORD(v6);
      float v318 = *(float *)(v143 + 32);
      uint64_t v319 = *(void *)(v543[0] + 24);
      if ((int)*(float *)(v143 + 28) >= 0x17) {
        unsigned int v320 = 23;
      }
      else {
        unsigned int v320 = (int)*(float *)(v143 + 28);
      }
      float32x2_t v321 = *(float **)v319;
      uint16x4_t v507 = v304;
      if (*(void *)v319
        && (float v322 = *v321, LODWORD(v321) = *v321 == v253, *(unsigned char *)(v319 + 10))
        && v322 != 0.0
        && v322 != v253
        || (v323 = *(unsigned __int8 *)(v319 + v321 + 11), float v322 = 0.0, v323 == 2))
      {
        LOBYTE(v542) = 1;
        char v545 = 1;
        char v324 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v319, 0x145u, v320, 0, &v542);
        char v325 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v319, 0x145u, v320, 1, &v545);
        if (v322 < v253) {
          char v325 = v324;
        }
      }
      else
      {
        char v325 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v319, 0x145u, v320, v323, 0);
      }
      if (v325) {
        double v326 = 1.0;
      }
      else {
        double v326 = *(float *)(v143 + 36);
      }
      double v504 = *(double *)(v143 + 40);
      unint64_t v327 = *(void *)(v543[0] + 24);
      float v328 = fminf(fmaxf(*(float *)(v143 + 28), 0.0), v254);
      unint64_t v329 = *(float **)v327;
      if (*(void *)v327
        && (float v330 = *v329, LODWORD(v329) = *v329 == v253, *(unsigned char *)(v327 + 10))
        && v330 != 0.0
        && v330 != v253
        || (v331 = *(unsigned __int8 *)(v327 + v329 + 11), float v330 = 0.0, v331 == 2))
      {
        LOBYTE(v542) = 1;
        char v545 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v327, 0x141u, 0, (BOOL *)&v542, v328);
        float v333 = v332;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v327, 0x141u, 1u, (BOOL *)&v545, v328);
        float v334 = 23.0;
        float v336 = v333 + (float)((float)(v335 - v333) * v330);
      }
      else
      {
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v543[0] + 24), 0x141u, v331, 0, v328);
        float v336 = v337;
        float v334 = 23.0;
      }
      double v338 = *(double *)(v143 + 40);
      unint64_t v339 = *(void *)(v543[0] + 24);
      float v340 = fminf(fmaxf(*(float *)(v143 + 28), 0.0), v334);
      uint64_t v341 = *(float **)v339;
      if (*(void *)v339
        && (float v342 = *v341, LODWORD(v341) = *v341 == v253, *(unsigned char *)(v339 + 10))
        && v342 != 0.0
        && v342 != v253
        || (v343 = *(unsigned __int8 *)(v339 + v341 + 11), float v342 = 0.0, v343 == 2))
      {
        LOBYTE(v542) = 1;
        char v545 = 1;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v339, 0x14Fu, 0, (BOOL *)&v542, v340);
        float v345 = v344;
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v339, 0x14Fu, 1u, (BOOL *)&v545, v340);
        float v347 = v345 + (float)((float)(v346 - v345) * v342);
      }
      else
      {
        gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v543[0] + 24), 0x14Fu, v343, 0, v340);
        float v347 = v348;
      }
      float v6 = v326 * v318;
      float v5 = v336 * v338 * v6;
      double v503 = *(double *)(v143 + 40);
      double v349 = 0.0;
      if (v5 >= 0.00000011921)
      {
        unint64_t v350 = *(void *)(v543[0] + 24);
        float v351 = fminf(fmaxf(*(float *)(v143 + 28), 0.0), 23.0);
        double v352 = *(float **)v350;
        if (*(void *)v350
          && (float v353 = *v352, LODWORD(v352) = *v352 == v253, *(unsigned char *)(v350 + 10))
          && v353 != 0.0
          && v353 != v253
          || (v354 = *(unsigned __int8 *)(v350 + v352 + 11), float v353 = 0.0, v354 == 2))
        {
          LOBYTE(v542) = 1;
          char v545 = 1;
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v350, 0x140u, 0, (BOOL *)&v542, v351);
          float v356 = v355;
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v350, 0x140u, 1u, (BOOL *)&v545, v351);
          float v358 = v356 + (float)((float)(v357 - v356) * v353);
        }
        else
        {
          gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(v543[0] + 24), 0x140u, v354, 0, v351);
        }
        double v349 = *(double *)(v143 + 40) * v358;
      }
      uint64_t v359 = *(void *)(v543[0] + 24);
      if ((int)*(float *)(v143 + 28) >= 0x17) {
        unsigned int v360 = 23;
      }
      else {
        unsigned int v360 = (int)*(float *)(v143 + 28);
      }
      size_t v361 = *(float **)v359;
      if (!*(void *)v359)
      {
        BOOL v363 = 0;
        goto LABEL_365;
      }
      float v362 = *v361;
      BOOL v363 = *v361 == v253;
      if (!*(unsigned char *)(v359 + 10) || v362 == 0.0 || v362 == v253)
      {
LABEL_365:
        unsigned int v364 = *(unsigned __int8 *)(v359 + v363 + 11);
        if (v364 == 2) {
          goto LABEL_366;
        }
LABEL_368:
        if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v359, 0x13Fu, v360, v364)) {
          goto LABEL_369;
        }
        LOBYTE(v368) = 1;
        if (!v361)
        {
LABEL_375:
          BOOL v369 = 0;
          goto LABEL_376;
        }
LABEL_388:
        float v374 = *v361;
        BOOL v369 = *v361 == v253;
        if (!*(unsigned char *)(v359 + 10))
        {
LABEL_376:
          uint64_t v143 = a5;
          goto LABEL_391;
        }
        uint64_t v143 = a5;
        if (v374 == 0.0 || v374 == v253)
        {
LABEL_391:
          unsigned int v375 = *(unsigned __int8 *)(v359 + v369 + 11);
          float v374 = 0.0;
          if (v375 == 2) {
            goto LABEL_392;
          }
          float v377 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v359, 0x14Au, v360, v375, 0);
        }
        else
        {
LABEL_392:
          LOBYTE(v542) = 1;
          char v545 = 1;
          float v376 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v359, 0x14Au, v360, 0, &v542);
          float v377 = v376
               + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v359, 0x14Au, v360, 1u, &v545)- v376)* v374);
        }
        uint64_t v378 = *(void *)(v543[0] + 24);
        if ((int)*(float *)(v143 + 28) >= 0x17) {
          unsigned int v379 = 23;
        }
        else {
          unsigned int v379 = (int)*(float *)(v143 + 28);
        }
        uint64_t v380 = *(float **)v378;
        if (*(void *)v378
          && (float v381 = *v380, LODWORD(v380) = *v380 == v253, *(unsigned char *)(v378 + 10))
          && v381 != 0.0
          && v381 != v253
          || (unsigned int v382 = *(unsigned __int8 *)(v378 + v380 + 11), v381 = 0.0, v382 == 2))
        {
          LOBYTE(v542) = 1;
          char v545 = 1;
          float v383 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v378, 0x14Bu, v379, 0, &v542);
          float v384 = v383
               + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v378, 0x14Bu, v379, 1u, &v545)- v383)* v381);
        }
        else
        {
          float v384 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v543[0] + 24), 0x14Bu, v379, v382, 0);
        }
        float v254 = 23.0;
        float v253 = 1.0;
        if ((_BYTE)v368)
        {
          float v257 = 0.0;
          float v256 = 1.0;
          if (v368 == 2)
          {
            float v256 = 0.5;
            float v257 = -0.5;
          }
        }
        else
        {
          float v256 = 0.0;
          float v257 = -1.0;
        }
        float32x4_t v258 = vmulq_f32(vcvtq_f32_u32(vmovl_u16(v507)), v514);
        v515 |= v305;
        float v259 = (float)v510 * 0.000015259;
        float v260 = (float)v506 * 0.000015259;
        float v261 = v504;
        float v262 = (float)((float)(v505 * v261) * v498) * v6;
        float v264 = v349;
        float v265 = v377 * 40075017.0 / ((double)(unint64_t)(1 << *(unsigned char *)(v143 + 24)) * v384);
        float v266 = v256 * v264;
        float v267 = v257 * v264;
        BOOL v268 = v264 < 0.00000011921;
        if (v264 >= 0.00000011921) {
          float v269 = v5;
        }
        else {
          float v269 = 0.0;
        }
        if (v268) {
          float v270 = 0.0;
        }
        else {
          float v270 = v347 * v503 * v6;
        }
        uint64_t v271 = v548;
        uint64_t v272 = 16 * v250;
        *(float32x4_t *)(v548 + v272) = v511;
        uint64_t v273 = 4 * v250;
        long long v274 = (float *)(v271 + 4 * v250);
        v274[64] = v266;
        v274[96] = v269;
        v274[80] = v270;
        *(float32x4_t *)(v540 + v272) = v511;
        long long v275 = (float *)(v540 + 4 * v250);
        v275[64] = v267;
        v275[80] = v266;
        v275[112] = v269;
        v275[96] = v270;
        long long v276 = (float *)(v537 + v248);
        *long long v276 = v265;
        v276[1] = 1.0 - v377;
        *(float32x4_t *)(v534 + v272) = v511;
        float v277 = *(double *)(v143 + 40) * 0.200000003;
        if (!v268) {
          float v277 = v267;
        }
        uint64_t v278 = (float *)(v534 + v273);
        v278[64] = v277;
        v278[96] = v5;
        float v263 = v347 * v503 * v6;
        v278[80] = v263;
        *(float32x4_t *)(v530 + 16 * v250) = v258;
        float32x2_t v279 = vmul_n_f32(v499, v262);
        uint64_t v280 = (float *)(v530 + v273);
        v280[64] = v267;
        v280[80] = v266;
        v280[96] = v269;
        uint64_t v281 = v526 + v249;
        *(_DWORD *)(v281 + 8) = 0;
        *(void *)uint64_t v281 = 0;
        *(float *)(v281 + 12) = 1.0 - (float)((float)v509 * 0.000015259);
        *(float32x2_t *)(v526 + 8 * v250 + 256) = v279;
        uint64_t v282 = v522;
        uint64_t v283 = v522 + v272;
        *(float *)(v522 + v249) = (float)v508 * 0.000015259;
LABEL_277:
        *(float *)(v283 + 4) = v259;
        *(float *)(v283 + 8) = v260;
        *(_DWORD *)(v283 + 12) = 1065353216;
        *(float32x2_t *)(v282 + 8 * v250 + 256) = v279;
        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v543);
        BOOL v255 = ++v250 < v502;
        v249 += 16;
        v248 += 8;
        if (v502 == v250)
        {
          BOOL v255 = 0;
          uint64_t v385 = v496;
          goto LABEL_408;
        }
        continue;
      }
LABEL_366:
      if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(*(void *)(v543[0] + 24), 0x13Fu, v360, 0) & 1) == 0)
      {
        unsigned int v364 = 1;
        goto LABEL_368;
      }
LABEL_369:
      if (v361)
      {
        float v365 = *v361;
        BOOL v366 = *v361 == v253;
        if (*(unsigned char *)(v359 + 10))
        {
          uint64_t v367 = a5;
          if (v365 == 0.0 || v365 == v253)
          {
LABEL_379:
            unsigned int v370 = *(unsigned __int8 *)(v359 + v366 + 11);
            float v365 = 0.0;
            if (v370 == 2) {
              goto LABEL_380;
            }
            int v368 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v359, 0x13Fu, v360, v370, 0);
          }
          else
          {
LABEL_380:
            LOBYTE(v542) = 1;
            char v545 = 1;
            int v371 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v359, 0x13Fu, v360, 0, &v542);
            int v372 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v359, 0x13Fu, v360, 1u, &v545);
            if (v365 >= v253) {
              LOBYTE(v368) = v372;
            }
            else {
              LOBYTE(v368) = v371;
            }
          }
          float v373 = *(float *)(v367 + 28);
          uint64_t v359 = *(void *)(v543[0] + 24);
          size_t v361 = *(float **)v359;
          if ((int)v373 >= 0x17) {
            unsigned int v360 = 23;
          }
          else {
            unsigned int v360 = (int)v373;
          }
          if (!v361) {
            goto LABEL_375;
          }
          goto LABEL_388;
        }
      }
      else
      {
        BOOL v366 = 0;
      }
      uint64_t v367 = a5;
      goto LABEL_379;
    }
    break;
  }
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v543);
  uint64_t v385 = v496;
  if (!v522) {
    goto LABEL_422;
  }
LABEL_408:
  if (v520)
  {
    if ((void)v519 && *(unsigned char *)(*((void *)&v519 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v519 + 64))();
    }
    uint64_t v387 = *(void *)(*((void *)&v519 + 1) + 56);
    unint64_t v386 = *(void *)(*((void *)&v519 + 1) + 64);
    if (v386 == v387) {
      uint64_t v387 = *(void *)(*((void *)&v519 + 1) + 80) - *(void *)(*((void *)&v519 + 1) + 72);
    }
    if (v387) {
      uint64_t v387 = 0;
    }
    if (v386 <= v520) {
      unint64_t v386 = v520;
    }
    if (v386 == v387) {
      unint64_t v386 = v387 + *(void *)(*((void *)&v519 + 1) + 80) - *(void *)(*((void *)&v519 + 1) + 72);
    }
    *(void *)(*((void *)&v519 + 1) + 56) = v387;
    *(void *)(*((void *)&v519 + 1) + 64) = v386;
  }
LABEL_422:
  if ((void)v526 && v524)
  {
    if (*(void *)v523 && *(unsigned char *)(*(void *)&v523[8] + 17) != 2) {
      (*(void (**)(void))(**(void **)v523 + 64))();
    }
    uint64_t v389 = *(void *)(*(void *)&v523[8] + 56);
    unint64_t v388 = *(void *)(*(void *)&v523[8] + 64);
    if (v388 == v389) {
      uint64_t v389 = *(void *)(*(void *)&v523[8] + 80) - *(void *)(*(void *)&v523[8] + 72);
    }
    if (v389) {
      uint64_t v389 = 0;
    }
    if (v388 <= v524) {
      unint64_t v388 = v524;
    }
    if (v388 == v389) {
      unint64_t v388 = v389 + *(void *)(*(void *)&v523[8] + 80) - *(void *)(*(void *)&v523[8] + 72);
    }
    *(void *)(*(void *)&v523[8] + 56) = v389;
    *(void *)(*(void *)&v523[8] + 64) = v388;
  }
  if ((void)v530 && (void)v529)
  {
    if (*(void *)v528 && *(unsigned char *)(*(void *)&v528[8] + 17) != 2) {
      (*(void (**)(void))(**(void **)v528 + 64))();
    }
    uint64_t v391 = *(void *)(*(void *)&v528[8] + 56);
    unint64_t v390 = *(void *)(*(void *)&v528[8] + 64);
    if (v390 == v391) {
      uint64_t v391 = *(void *)(*(void *)&v528[8] + 80) - *(void *)(*(void *)&v528[8] + 72);
    }
    if (v391) {
      uint64_t v391 = 0;
    }
    if (v390 <= (unint64_t)v529) {
      unint64_t v390 = v529;
    }
    if (v390 == v391) {
      unint64_t v390 = v391 + *(void *)(*(void *)&v528[8] + 80) - *(void *)(*(void *)&v528[8] + 72);
    }
    *(void *)(*(void *)&v528[8] + 56) = v391;
    *(void *)(*(void *)&v528[8] + 64) = v390;
  }
  if (v534 && (void)v533)
  {
    if ((void)v532 && *(unsigned char *)(*((void *)&v532 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v532 + 64))();
    }
    uint64_t v393 = *(void *)(*((void *)&v532 + 1) + 56);
    unint64_t v392 = *(void *)(*((void *)&v532 + 1) + 64);
    if (v392 == v393) {
      uint64_t v393 = *(void *)(*((void *)&v532 + 1) + 80) - *(void *)(*((void *)&v532 + 1) + 72);
    }
    if (v393) {
      uint64_t v393 = 0;
    }
    if (v392 <= (unint64_t)v533) {
      unint64_t v392 = v533;
    }
    if (v392 == v393) {
      unint64_t v392 = v393 + *(void *)(*((void *)&v532 + 1) + 80) - *(void *)(*((void *)&v532 + 1) + 72);
    }
    *(void *)(*((void *)&v532 + 1) + 56) = v393;
    *(void *)(*((void *)&v532 + 1) + 64) = v392;
  }
  if (v537 && (void)v536)
  {
    if ((void)v535 && *(unsigned char *)(*((void *)&v535 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v535 + 64))();
    }
    uint64_t v395 = *(void *)(*((void *)&v535 + 1) + 56);
    unint64_t v394 = *(void *)(*((void *)&v535 + 1) + 64);
    if (v394 == v395) {
      uint64_t v395 = *(void *)(*((void *)&v535 + 1) + 80) - *(void *)(*((void *)&v535 + 1) + 72);
    }
    if (v395) {
      uint64_t v395 = 0;
    }
    if (v394 <= (unint64_t)v536) {
      unint64_t v394 = v536;
    }
    if (v394 == v395) {
      unint64_t v394 = v395 + *(void *)(*((void *)&v535 + 1) + 80) - *(void *)(*((void *)&v535 + 1) + 72);
    }
    *(void *)(*((void *)&v535 + 1) + 56) = v395;
    *(void *)(*((void *)&v535 + 1) + 64) = v394;
  }
  if ((void)v540 && (void)v539)
  {
    if (*(void *)v538 && *(unsigned char *)(*(void *)&v538[8] + 17) != 2) {
      (*(void (**)(void))(**(void **)v538 + 64))();
    }
    uint64_t v397 = *(void *)(*(void *)&v538[8] + 56);
    unint64_t v396 = *(void *)(*(void *)&v538[8] + 64);
    if (v396 == v397) {
      uint64_t v397 = *(void *)(*(void *)&v538[8] + 80) - *(void *)(*(void *)&v538[8] + 72);
    }
    if (v397) {
      uint64_t v397 = 0;
    }
    if (v396 <= (unint64_t)v539) {
      unint64_t v396 = v539;
    }
    if (v396 == v397) {
      unint64_t v396 = v397 + *(void *)(*(void *)&v538[8] + 80) - *(void *)(*(void *)&v538[8] + 72);
    }
    *(void *)(*(void *)&v538[8] + 56) = v397;
    *(void *)(*(void *)&v538[8] + 64) = v396;
  }
  if ((void)v548)
  {
    unint64_t v398 = *(void *)&v546[16];
    unint64_t v399 = v547;
    if ((void)v547 != *(void *)&v546[16])
    {
      long long v400 = *(void **)&v546[8];
      int v401 = BYTE8(v547);
      int v402 = BYTE9(v547);
      if (*(void *)v546 && *(unsigned char *)(*(void *)&v546[8] + 17) != 2) {
        (*(void (**)(void))(**(void **)v546 + 64))();
      }
      if (v401 && !v402)
      {
        unint64_t v404 = v400[7];
        unint64_t v403 = v400[8];
        if (v403 == v404) {
          unint64_t v404 = v400[10] - v400[9];
        }
        if (v398 < v404) {
          unint64_t v404 = v398;
        }
        if (v403 <= v399) {
          unint64_t v403 = v399;
        }
        if (v403 == v404) {
          unint64_t v403 = v404 + v400[10] - v400[9];
        }
        v400[7] = v404;
        v400[8] = v403;
      }
    }
  }
  double v9 = v500;
  if (!v255)
  {
    *(void *)&v538[16] = "";
    *(_DWORD *)v541 = 1065353216;
    memset(&v541[8], 0, 32);
    *(int64x2_t *)&v541[40] = vdupq_n_s64(1uLL);
    *(void *)&v541[56] = 0;
    int v405 = *(unsigned __int8 *)(v518 + 393);
    if (*(unsigned char *)(v518 + 393) && *(unsigned char *)(v518 + 439)) {
      uint64_t v406 = *(void *)(v518 + 376) + 760;
    }
    else {
      uint64_t v406 = *(void *)(v518 + 376) + 544;
    }
    LODWORD(v540) = 100;
    *(void *)&long long v539 = v406;
    *((void *)&v539 + 1) = v385;
    __int16 v407 = [(VKPolygonGroup *)v500 layer];
    uint64_t v408 = 2;
    if ((v515 & 1) == 0) {
      uint64_t v408 = -1;
    }
    uint64_t v409 = 20 * v407;
    if (!v405) {
      uint64_t v409 = 0;
    }
    *((void *)&v540 + 1) = v408 + 0x800000007 + v409;
    *(void *)&long long v536 = v539;
    *((void *)&v536 + 1) = v493;
    uint64_t v410 = *(void *)(v518 + 376);
    *(void *)&long long v533 = v410 + 1000;
    *((void *)&v533 + 1) = v497;
    LODWORD(v530) = 0;
    *(_DWORD *)v531 = 1065353216;
    memset(&v531[8], 0, 32);
    *(int64x2_t *)&v531[40] = vdupq_n_s64(1uLL);
    *(void *)&v531[56] = 0;
    *(void *)&v528[16] = "";
    *(void *)&long long v529 = v410 + 1528;
    int v411 = *(unsigned __int8 *)(v518 + 393);
    uint64_t v412 = 20 * (__int16)[(VKPolygonGroup *)v500 layer] + 0x800000007;
    if (!v411) {
      uint64_t v412 = 0x800000007;
    }
    *((void *)&v530 + 1) = v412;
    *((void *)&v529 + 1) = v495;
    LODWORD(v526) = 0;
    *(_DWORD *)v527 = 1065353216;
    memset(&v527[8], 0, 32);
    *(int64x2_t *)&v527[40] = vdupq_n_s64(1uLL);
    *(void *)&v527[56] = 0;
    *(void *)&v523[16] = "";
    *(void *)&long long v525 = *(void *)(v518 + 376) + 1768;
    int v413 = *(unsigned __int8 *)(v518 + 393);
    uint64_t v414 = 20 * (__int16)[(VKPolygonGroup *)v500 layer] + 0x800000008;
    if (!v413) {
      uint64_t v414 = 0x800000008;
    }
    *((void *)&v526 + 1) = v414;
    *((void *)&v525 + 1) = v494;
    uint64_t v415 = [(VKPolygonGroup *)v500 venueWallMeshes];
    float64x2_t v416 = *(uint64_t **)v415;
    v512 = *(uint64_t **)(v415 + 8);
    if (*(uint64_t **)v415 != v512)
    {
      unsigned int v417 = 0;
      do
      {
        size_t v418 = [(VKPolygonalItemGroup *)v500 commitRangesToVenueWallRenderItemBatcher:*(void *)(v518 + 376) + 3712 forMeshAtIndex:v417 cullingMask:*(unsigned int *)(a5 + 48)];
        uint64_t v419 = *(void *)(v518 + 376);
        uint64_t v420 = *v416;
        *(void *)v546 = &off_1EF55A458;
        *(_OWORD *)&v546[8] = *(_OWORD *)&v538[8];
        long long v547 = v539;
        long long v551 = *(_OWORD *)&v541[32];
        long long v552 = *(_OWORD *)&v541[48];
        long long v548 = v540;
        long long v549 = *(_OWORD *)v541;
        long long v550 = *(_OWORD *)&v541[16];
        int v421 = *(void **)(v419 + 3800);
        uint64_t v422 = v421[1];
        if (v422 == *(void *)(v419 + 3808))
        {
          int v421 = (void *)*v421;
          if (!v421)
          {
            int v421 = malloc_type_malloc(120 * v422 + 16, 0xB644C221uLL);
            *int v421 = 0;
            v421[1] = 0;
            **(void **)(v419 + 3800) = v421;
          }
          *(void *)(v419 + 3800) = v421;
          uint64_t v422 = v421[1];
        }
        float64x2_t v423 = &v421[15 * v422];
        v421[1] = v422 + 1;
        v423[2] = &off_1EF55A458;
        long long v424 = v551;
        long long v425 = v552;
        long long v426 = v550;
        *(_OWORD *)(v423 + 9) = v549;
        long long v427 = *(_OWORD *)&v546[8];
        long long v428 = v547;
        *(_OWORD *)(v423 + 7) = v548;
        *(_OWORD *)(v423 + 5) = v428;
        *(_OWORD *)(v423 + 3) = v427;
        *(_OWORD *)(v423 + 15) = v425;
        *(_OWORD *)(v423 + 13) = v424;
        *(_OWORD *)(v423 + 11) = v426;
        v423[10] = v420;
        uint64_t v429 = *v418;
        v423[13] = *v418;
        v423[14] = (v418[1] - v429) >> 4;
        ggl::CommandBuffer::pushRenderItem(a4, (uint64_t)(v423 + 2));
        uint64_t v430 = *(void *)(v518 + 376);
        uint64_t v431 = *v416;
        *(void *)v546 = &off_1EF55A458;
        *(_OWORD *)&v546[8] = *(_OWORD *)&v538[8];
        long long v547 = v536;
        long long v551 = *(_OWORD *)&v541[32];
        long long v552 = *(_OWORD *)&v541[48];
        long long v548 = v540;
        long long v549 = *(_OWORD *)v541;
        long long v550 = *(_OWORD *)&v541[16];
        id v432 = *(void **)(v430 + 3800);
        uint64_t v433 = v432[1];
        if (v433 == *(void *)(v430 + 3808))
        {
          id v432 = (void *)*v432;
          if (!v432)
          {
            id v432 = malloc_type_malloc(120 * v433 + 16, 0xB644C221uLL);
            *id v432 = 0;
            v432[1] = 0;
            **(void **)(v430 + 3800) = v432;
          }
          *(void *)(v430 + 3800) = v432;
          uint64_t v433 = v432[1];
        }
        v434 = &v432[15 * v433];
        v432[1] = v433 + 1;
        v434[2] = &off_1EF55A458;
        long long v435 = v551;
        long long v436 = v552;
        long long v437 = v550;
        *(_OWORD *)(v434 + 9) = v549;
        long long v438 = *(_OWORD *)&v546[8];
        long long v439 = v547;
        *(_OWORD *)(v434 + 7) = v548;
        *(_OWORD *)(v434 + 5) = v439;
        *(_OWORD *)(v434 + 3) = v438;
        *(_OWORD *)(v434 + 15) = v436;
        *(_OWORD *)(v434 + 13) = v435;
        *(_OWORD *)(v434 + 11) = v437;
        v434[10] = v431;
        uint64_t v440 = *v418;
        v434[13] = *v418;
        v434[14] = (v418[1] - v440) >> 4;
        ggl::CommandBuffer::pushRenderItem(a4, (uint64_t)(v434 + 2));
        uint64_t v441 = *(void *)(v518 + 376);
        uint64_t v442 = *v416;
        *(void *)v546 = &off_1EF55A458;
        *(_OWORD *)&v546[8] = *(_OWORD *)&v538[8];
        long long v547 = v533;
        long long v551 = *(_OWORD *)&v541[32];
        long long v552 = *(_OWORD *)&v541[48];
        long long v548 = v540;
        long long v549 = *(_OWORD *)v541;
        long long v550 = *(_OWORD *)&v541[16];
        v443 = *(void **)(v441 + 3800);
        uint64_t v444 = v443[1];
        if (v444 == *(void *)(v441 + 3808))
        {
          v443 = (void *)*v443;
          if (!v443)
          {
            v443 = malloc_type_malloc(120 * v444 + 16, 0xB644C221uLL);
            void *v443 = 0;
            v443[1] = 0;
            **(void **)(v441 + 3800) = v443;
          }
          *(void *)(v441 + 3800) = v443;
          uint64_t v444 = v443[1];
        }
        id v445 = &v443[15 * v444];
        v443[1] = v444 + 1;
        v445[2] = &off_1EF55A458;
        long long v446 = v551;
        long long v447 = v552;
        long long v448 = v550;
        *(_OWORD *)(v445 + 9) = v549;
        long long v449 = *(_OWORD *)&v546[8];
        long long v450 = v547;
        *(_OWORD *)(v445 + 7) = v548;
        *(_OWORD *)(v445 + 5) = v450;
        *(_OWORD *)(v445 + 3) = v449;
        *(_OWORD *)(v445 + 15) = v447;
        *(_OWORD *)(v445 + 13) = v446;
        *(_OWORD *)(v445 + 11) = v448;
        v445[10] = v442;
        uint64_t v451 = *v418;
        v445[13] = *v418;
        v445[14] = (v418[1] - v451) >> 4;
        ggl::CommandBuffer::pushRenderItem(a4, (uint64_t)(v445 + 2));
        uint64_t v452 = *(void *)(v518 + 376);
        uint64_t v453 = *v416;
        *(void *)v546 = &off_1EF55A458;
        *(_OWORD *)&v546[8] = *(_OWORD *)&v528[8];
        long long v547 = v529;
        long long v551 = *(_OWORD *)&v531[32];
        long long v552 = *(_OWORD *)&v531[48];
        long long v548 = v530;
        long long v549 = *(_OWORD *)v531;
        long long v550 = *(_OWORD *)&v531[16];
        id v454 = *(void **)(v452 + 3800);
        uint64_t v455 = v454[1];
        if (v455 == *(void *)(v452 + 3808))
        {
          id v454 = (void *)*v454;
          if (!v454)
          {
            id v454 = malloc_type_malloc(120 * v455 + 16, 0xB644C221uLL);
            *id v454 = 0;
            v454[1] = 0;
            **(void **)(v452 + 3800) = v454;
          }
          *(void *)(v452 + 3800) = v454;
          uint64_t v455 = v454[1];
        }
        v456 = &v454[15 * v455];
        v454[1] = v455 + 1;
        v456[2] = &off_1EF55A458;
        long long v457 = v551;
        long long v458 = v552;
        long long v459 = v550;
        *(_OWORD *)(v456 + 9) = v549;
        long long v460 = *(_OWORD *)&v546[8];
        long long v461 = v547;
        *(_OWORD *)(v456 + 7) = v548;
        *(_OWORD *)(v456 + 5) = v461;
        *(_OWORD *)(v456 + 3) = v460;
        *(_OWORD *)(v456 + 15) = v458;
        *(_OWORD *)(v456 + 13) = v457;
        *(_OWORD *)(v456 + 11) = v459;
        v456[10] = v453;
        uint64_t v462 = *v418;
        v456[13] = *v418;
        v456[14] = (v418[1] - v462) >> 4;
        ggl::CommandBuffer::pushRenderItem(a4, (uint64_t)(v456 + 2));
        uint64_t v463 = *(void *)(v518 + 376);
        uint64_t v464 = *v416;
        *(void *)v546 = &off_1EF55A458;
        *(_OWORD *)&v546[8] = *(_OWORD *)&v523[8];
        long long v547 = v525;
        long long v551 = *(_OWORD *)&v527[32];
        long long v552 = *(_OWORD *)&v527[48];
        long long v548 = v526;
        long long v549 = *(_OWORD *)v527;
        long long v550 = *(_OWORD *)&v527[16];
        uint64_t v465 = *(void **)(v463 + 3800);
        uint64_t v466 = v465[1];
        if (v466 == *(void *)(v463 + 3808))
        {
          uint64_t v465 = (void *)*v465;
          if (!v465)
          {
            uint64_t v465 = malloc_type_malloc(120 * v466 + 16, 0xB644C221uLL);
            *uint64_t v465 = 0;
            v465[1] = 0;
            **(void **)(v463 + 3800) = v465;
          }
          *(void *)(v463 + 3800) = v465;
          uint64_t v466 = v465[1];
        }
        v467 = &v465[15 * v466];
        v465[1] = v466 + 1;
        v467[2] = &off_1EF55A458;
        long long v468 = v551;
        long long v469 = v552;
        long long v470 = v550;
        *(_OWORD *)(v467 + 9) = v549;
        long long v471 = *(_OWORD *)&v546[8];
        long long v472 = v547;
        *(_OWORD *)(v467 + 7) = v548;
        *(_OWORD *)(v467 + 5) = v472;
        *(_OWORD *)(v467 + 3) = v471;
        *(_OWORD *)(v467 + 15) = v469;
        *(_OWORD *)(v467 + 13) = v468;
        *(_OWORD *)(v467 + 11) = v470;
        v467[10] = v464;
        uint64_t v473 = *v418;
        v467[13] = *v418;
        v467[14] = (v418[1] - v473) >> 4;
        ggl::CommandBuffer::pushRenderItem(a4, (uint64_t)(v467 + 2));
        ++v417;
        v416 += 2;
      }
      while (v416 != v512);
    }
    *(void *)&long long v521 = v539;
    *((void *)&v521 + 1) = v492;
    uint64_t v474 = [(VKPolygonGroup *)v500 venueWallEndMeshes];
    __n128 v475 = *(uint64_t **)v474;
    __n128 v476 = *(uint64_t **)(v474 + 8);
    uint64_t v477 = v518;
    if (*(uint64_t **)v474 != v476)
    {
      unsigned int v478 = 0;
      do
      {
        __n128 v479 = [(VKPolygonalItemGroup *)v500 commitRangesToVenueWallEndCapRenderItemBatcher:*(void *)(v477 + 376) + 3712 forMeshAtIndex:v478 cullingMask:*(unsigned int *)(a5 + 48)];
        uint64_t v480 = *(void *)(v477 + 376);
        uint64_t v481 = *v475;
        *(void *)v546 = &off_1EF55A458;
        *(_OWORD *)&v546[8] = *(_OWORD *)&v538[8];
        long long v547 = v521;
        long long v551 = *(_OWORD *)&v541[32];
        long long v552 = *(_OWORD *)&v541[48];
        long long v548 = v540;
        long long v549 = *(_OWORD *)v541;
        long long v550 = *(_OWORD *)&v541[16];
        uint64_t v482 = *(void **)(v480 + 3800);
        uint64_t v483 = v482[1];
        if (v483 == *(void *)(v480 + 3808))
        {
          uint64_t v482 = (void *)*v482;
          if (!v482)
          {
            uint64_t v482 = malloc_type_malloc(120 * v483 + 16, 0xB644C221uLL);
            *uint64_t v482 = 0;
            v482[1] = 0;
            **(void **)(v480 + 3800) = v482;
          }
          *(void *)(v480 + 3800) = v482;
          uint64_t v483 = v482[1];
        }
        v484 = &v482[15 * v483];
        v482[1] = v483 + 1;
        v484[2] = &off_1EF55A458;
        long long v485 = v551;
        long long v486 = v552;
        long long v487 = v550;
        *(_OWORD *)(v484 + 9) = v549;
        long long v488 = *(_OWORD *)&v546[8];
        long long v489 = v547;
        *(_OWORD *)(v484 + 7) = v548;
        *(_OWORD *)(v484 + 5) = v489;
        *(_OWORD *)(v484 + 3) = v488;
        *(_OWORD *)(v484 + 15) = v486;
        *(_OWORD *)(v484 + 13) = v485;
        *(_OWORD *)(v484 + 11) = v487;
        v484[10] = v481;
        uint64_t v490 = *v479;
        v484[13] = *v479;
        v484[14] = (v479[1] - v490) >> 4;
        ggl::CommandBuffer::pushRenderItem(a4, (uint64_t)(v484 + 2));
        uint64_t v477 = v518;
        ++v478;
        v475 += 2;
      }
      while (v475 != v476);
    }
    double v9 = v500;
  }
LABEL_552:
}

void sub_1A2146C28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::VenueWall::MeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::VenueWallShadow::MeshPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        unint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    *uint64_t v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

__n128 std::__function::__func<md::VenueRenderLayer::_layoutVenueWalls(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::_layoutVenueWalls(md::LayoutContext const&)::$_0>,void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572DF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::VenueRenderLayer::_layoutVenueWalls(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::_layoutVenueWalls(md::LayoutContext const&)::$_0>,void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF572DF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::VenueRenderLayer::_layoutVenueWalls(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::_layoutVenueWalls(md::LayoutContext const&)::$_0>,void ()(VKVenueGroup const*,md::VenueRenderLayer::VenueGroupLayoutData const&)>::~__func()
{
}

__n128 std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF572F18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF572F18;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_2,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_2>,void ()(md::StyleManagerEvent)>::~__func()
{
}

uint64_t std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572ED0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572ED0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF572E88;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF572E88;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::VenueRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

void md::VenueRenderLayer::~VenueRenderLayer(md::VenueRenderLayer *this)
{
  md::VenueRenderLayer::~VenueRenderLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  md::CVenueRenderResources *v3;
  md::PolygonRenderResources *v4;
  uint64_t vars8;

  *(void *)this = off_1EF536A88;
  *((void *)this + 57) = &unk_1EF5596D8;

  *((void *)this + 48) = &unk_1EF54A500;
  uint64_t v2 = (void *)*((void *)this + 50);
  if (v2)
  {
    *((void *)this + 51) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (md::CVenueRenderResources *)*((void *)this + 47);
  *((void *)this + 47) = 0;
  if (v3)
  {
    md::CVenueRenderResources::~CVenueRenderResources(v3);
    MEMORY[0x1A6239270]();
  }
  uint64_t v4 = (md::PolygonRenderResources *)*((void *)this + 46);
  *((void *)this + 46) = 0;
  if (v4)
  {
    md::PolygonRenderResources::~PolygonRenderResources(v4);
    MEMORY[0x1A6239270]();
  }
  md::CartographicTiledVectorRenderLayer<md::MapTileDataRenderable<md::VenueTileData>>::~CartographicTiledVectorRenderLayer(this);
}

void md::CVenueRenderResources::~CVenueRenderResources(md::CVenueRenderResources *this)
{
  uint64_t v2 = (void *)*((void *)this + 474);
  do
  {
    if (v2[1])
    {
      unint64_t v3 = 0;
      uint64_t v4 = v2 + 2;
      unint64_t v5 = v2 + 2;
      uint64_t v6 = (void (***)(void))(v2 + 2);
      do
      {
        uint64_t v7 = (void (**)(void *))*v6;
        v6 += 15;
        (*v7)(v5);
        ++v3;
        v4 += 15;
        unint64_t v5 = v6;
      }
      while (v3 < v2[1]);
    }
    v2[1] = 0;
    uint64_t v2 = (void *)*v2;
  }
  while (v2);
  unint64_t v8 = (void **)*((void *)this + 474);
  *((void *)this + 475) = v8;
  uint64_t v9 = *v8;
  *unint64_t v8 = 0;
  if (v9)
  {
    do
    {
      uint64_t v10 = (void *)*v9;
      free(v9);
      uint64_t v9 = v10;
    }
    while (v10);
    unint64_t v8 = (void **)*((void *)this + 474);
  }
  free(v8);
  uint64_t v11 = (void *)*((void *)this + 471);
  if (v11)
  {
    *((void *)this + 472) = v11;
    operator delete(v11);
  }
  uint64_t v12 = *((void *)this + 467);
  if (v12)
  {
    uint64_t v13 = *((void *)this + 468);
    uint64_t v14 = *((void *)this + 467);
    if (v13 != v12)
    {
      uint64_t v15 = *((void *)this + 468);
      do
      {
        uint64_t v17 = *(void **)(v15 - 24);
        v15 -= 24;
        uint64_t v16 = v17;
        if (v17)
        {
          *(void *)(v13 - 16) = v16;
          operator delete(v16);
        }
        uint64_t v13 = v15;
      }
      while (v15 != v12);
      uint64_t v14 = *((void *)this + 467);
    }
    *((void *)this + 468) = v12;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 470) + 40))(*((void *)this + 470), v14, *((void *)this + 469) - v14);
  }
  uint64_t v18 = (void *)*((void *)this + 464);
  if (v18)
  {
    *((void *)this + 465) = v18;
    operator delete(v18);
  }
  md::VenueFootprintRenderResources::~VenueFootprintRenderResources((md::CVenueRenderResources *)((char *)this + 2712));
  md::VenueOpenToBelowRenderResources::~VenueOpenToBelowRenderResources((md::CVenueRenderResources *)((char *)this + 1992));
  md::VenueWallRenderResources::~VenueWallRenderResources((md::CVenueRenderResources *)((char *)this + 520));
  md::VenueDimmingOverlayRenderResources::~VenueDimmingOverlayRenderResources(this);
}

void md::VenueFootprintRenderResources::~VenueFootprintRenderResources(md::VenueFootprintRenderResources *this)
{
  *((void *)this + 93) = &unk_1EF55D4B8;
  uint64_t v2 = *((void *)this + 94);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 16))(v2, *((void *)this + 96));
    *((void *)this + 96) = 3735927469;
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 95);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *((void *)this + 92);
  *((void *)this + 92) = 0;
  if (v4)
  {
    uint64_t v5 = ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::~FragmentedPool(v4);
    MEMORY[0x1A6239270](v5, 0x10A0C40D234DDC7);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *((void *)this + 63) = &unk_1EF55D4B8;
  uint64_t v7 = *((void *)this + 64);
  if (v7)
  {
    (*(void (**)(uint64_t, void))(*(void *)v7 + 16))(v7, *((void *)this + 66));
    *((void *)this + 66) = 3735927469;
  }
  unint64_t v8 = (std::__shared_weak_count *)*((void *)this + 65);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v9 = *((void *)this + 62);
  *((void *)this + 62) = 0;
  if (v9)
  {
    uint64_t v10 = ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::~FragmentedPool(v9);
    MEMORY[0x1A6239270](v10, 0x10A0C40D234DDC7);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 61);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  *((void *)this + 33) = &unk_1EF55D4B8;
  uint64_t v12 = *((void *)this + 34);
  if (v12)
  {
    (*(void (**)(uint64_t, void))(*(void *)v12 + 16))(v12, *((void *)this + 36));
    *((void *)this + 36) = 3735927469;
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = *((void *)this + 32);
  *((void *)this + 32) = 0;
  if (v14)
  {
    uint64_t v15 = ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::~FragmentedPool(v14);
    MEMORY[0x1A6239270](v15, 0x10A0C40D234DDC7);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  *((void *)this + 3) = &unk_1EF55D4B8;
  uint64_t v17 = *((void *)this + 4);
  if (v17)
  {
    (*(void (**)(uint64_t, void))(*(void *)v17 + 16))(v17, *((void *)this + 6));
    *((void *)this + 6) = 3735927469;
  }
  uint64_t v18 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  uint64_t v19 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v19)
  {
    uint64_t v20 = ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::~FragmentedPool(v19);
    MEMORY[0x1A6239270](v20, 0x10A0C40D234DDC7);
  }
  uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v21)
  {
    if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
  }
}

void md::VenueOpenToBelowRenderResources::~VenueOpenToBelowRenderResources(md::VenueOpenToBelowRenderResources *this)
{
  *((void *)this + 63) = &unk_1EF55D4B8;
  uint64_t v2 = *((void *)this + 64);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 16))(v2, *((void *)this + 66));
    *((void *)this + 66) = 3735927469;
  }
  unint64_t v3 = (std::__shared_weak_count *)*((void *)this + 65);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *((void *)this + 62);
  *((void *)this + 62) = 0;
  if (v4)
  {
    uint64_t v5 = ggl::FragmentedPool<ggl::VenueOpenToBelowShadow::MeshPipelineSetup>::~FragmentedPool(v4);
    MEMORY[0x1A6239270](v5, 0x10A0C40D234DDC7);
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 61);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *((void *)this + 33) = &unk_1EF55D4B8;
  uint64_t v7 = *((void *)this + 34);
  if (v7)
  {
    (*(void (**)(uint64_t, void))(*(void *)v7 + 16))(v7, *((void *)this + 36));
    *((void *)this + 36) = 3735927469;
  }
  unint64_t v8 = (std::__shared_weak_count *)*((void *)this + 35);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v9 = *((void *)this + 32);
  *((void *)this + 32) = 0;
  if (v9)
  {
    uint64_t v10 = ggl::FragmentedPool<ggl::VenueOpenToBelowShadowAlpha::MeshPipelineSetup>::~FragmentedPool(v9);
    MEMORY[0x1A6239270](v10, 0x10A0C40D234DDC7);
  }
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 31);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
  *((void *)this + 3) = &unk_1EF55D4B8;
  uint64_t v12 = *((void *)this + 4);
  if (v12)
  {
    (*(void (**)(uint64_t, void))(*(void *)v12 + 16))(v12, *((void *)this + 6));
    *((void *)this + 6) = 3735927469;
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v14)
  {
    uint64_t v15 = ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::~FragmentedPool(v14);
    MEMORY[0x1A6239270](v15, 0x10A0C40D234DDC7);
  }
  uint64_t v16 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v16)
  {
    if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

void md::VenueWallRenderResources::~VenueWallRenderResources(md::VenueWallRenderResources *this)
{
  uint64_t v2 = *((void *)this + 183);
  *((void *)this + 183) = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Building::Gradient>>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  *((void *)this + 156) = &unk_1EF55D4B8;
  uint64_t v4 = *((void *)this + 157);
  if (v4)
  {
    (*(void (**)(uint64_t, void))(*(void *)v4 + 16))(v4, *((void *)this + 159));
    *((void *)this + 159) = 3735927469;
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 158);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  uint64_t v6 = *((void *)this + 155);
  *((void *)this + 155) = 0;
  if (v6)
  {
    uint64_t v7 = ggl::FragmentedPool<ggl::VenueWallShadow::MeshPipelineSetup>::~FragmentedPool(v6);
    MEMORY[0x1A6239270](v7, 0x10A0C40D234DDC7);
  }
  unint64_t v8 = (std::__shared_weak_count *)*((void *)this + 154);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  *((void *)this + 126) = &unk_1EF55D4B8;
  uint64_t v9 = *((void *)this + 127);
  if (v9)
  {
    (*(void (**)(uint64_t, void))(*(void *)v9 + 16))(v9, *((void *)this + 129));
    *((void *)this + 129) = 3735927469;
  }
  uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 128);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v11 = *((void *)this + 125);
  *((void *)this + 125) = 0;
  if (v11)
  {
    uint64_t v12 = ggl::FragmentedPool<ggl::VenueWallShadow::MeshPipelineSetup>::~FragmentedPool(v11);
    MEMORY[0x1A6239270](v12, 0x10A0C40D234DDC7);
  }
  uint64_t v13 = (std::__shared_weak_count *)*((void *)this + 124);
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *((void *)this + 96) = &unk_1EF55D4B8;
  uint64_t v14 = *((void *)this + 97);
  if (v14)
  {
    (*(void (**)(uint64_t, void))(*(void *)v14 + 16))(v14, *((void *)this + 99));
    *((void *)this + 99) = 3735927469;
  }
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 98);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  uint64_t v16 = *((void *)this + 95);
  *((void *)this + 95) = 0;
  if (v16)
  {
    uint64_t v17 = ggl::FragmentedPool<ggl::Venue3DStroke::VerticalVenue3DStrokePipelineSetup>::~FragmentedPool(v16);
    MEMORY[0x1A6239270](v17, 0x10A0C40D234DDC7);
  }
  uint64_t v18 = (std::__shared_weak_count *)*((void *)this + 94);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  uint64_t v19 = *((void *)this + 92);
  *((void *)this + 92) = 0;
  if (v19)
  {
    uint64_t v20 = ggl::FragmentedPool<ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineSetup>::~FragmentedPool(v19);
    MEMORY[0x1A6239270](v20, 0x10A0C40D234DDC7);
  }
  uint64_t v21 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  uint64_t v22 = *((void *)this + 89);
  *((void *)this + 89) = 0;
  if (v22)
  {
    uint64_t v23 = ggl::FragmentedPool<ggl::VenueWall::WallEndCapMeshPipelineSetup>::~FragmentedPool(v22);
    MEMORY[0x1A6239270](v23, 0x10A0C40D234DDC7);
  }
  uint64_t v24 = (std::__shared_weak_count *)*((void *)this + 88);
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  *((void *)this + 60) = &unk_1EF55D4B8;
  uint64_t v25 = *((void *)this + 61);
  if (v25)
  {
    (*(void (**)(uint64_t, void))(*(void *)v25 + 16))(v25, *((void *)this + 63));
    *((void *)this + 63) = 3735927469;
  }
  uint64_t v26 = (std::__shared_weak_count *)*((void *)this + 62);
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
    std::__shared_weak_count::__release_weak(v26);
  }
  uint64_t v27 = *((void *)this + 59);
  *((void *)this + 59) = 0;
  if (v27)
  {
    uint64_t v28 = ggl::FragmentedPool<ggl::VenueWall::WallTopMeshPipelineSetup>::~FragmentedPool(v27);
    MEMORY[0x1A6239270](v28, 0x10A0C40D234DDC7);
  }
  long long v29 = (std::__shared_weak_count *)*((void *)this + 58);
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  *((void *)this + 30) = &unk_1EF55D4B8;
  uint64_t v30 = *((void *)this + 31);
  if (v30)
  {
    (*(void (**)(uint64_t, void))(*(void *)v30 + 16))(v30, *((void *)this + 33));
    *((void *)this + 33) = 3735927469;
  }
  unint64_t v31 = (std::__shared_weak_count *)*((void *)this + 32);
  if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
    std::__shared_weak_count::__release_weak(v31);
  }
  *((void *)this + 3) = &unk_1EF55D4B8;
  uint64_t v32 = *((void *)this + 4);
  if (v32)
  {
    (*(void (**)(uint64_t, void))(*(void *)v32 + 16))(v32, *((void *)this + 6));
    *((void *)this + 6) = 3735927469;
  }
  uint64_t v33 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  uint64_t v34 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v34)
  {
    uint64_t v35 = ggl::FragmentedPool<ggl::VenueWall::MeshPipelineSetup>::~FragmentedPool(v34);
    MEMORY[0x1A6239270](v35, 0x10A0C40D234DDC7);
  }
  uint64_t v36 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v36)
  {
    if (!atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
      std::__shared_weak_count::__release_weak(v36);
    }
  }
}

void md::VenueDimmingOverlayRenderResources::~VenueDimmingOverlayRenderResources(md::VenueDimmingOverlayRenderResources *this)
{
  uint64_t v2 = *((void *)this + 64);
  *((void *)this + 64) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 63);
  *((void *)this + 63) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  *((void *)this + 36) = &unk_1EF55D4B8;
  uint64_t v4 = *((void *)this + 37);
  if (v4)
  {
    (*(void (**)(uint64_t, void))(*(void *)v4 + 16))(v4, *((void *)this + 39));
    *((void *)this + 39) = 3735927469;
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 38);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  *((void *)this + 9) = &unk_1EF55D4B8;
  uint64_t v6 = *((void *)this + 10);
  if (v6)
  {
    (*(void (**)(uint64_t, void))(*(void *)v6 + 16))(v6, *((void *)this + 12));
    *((void *)this + 12) = 3735927469;
  }
  uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v10) {
      goto LABEL_23;
    }
  }
  else
  {
    uint64_t v10 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v10) {
      goto LABEL_23;
    }
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
LABEL_23:
  uint64_t v11 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
    uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v12) {
      return;
    }
  }
  else
  {
    uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v12) {
      return;
    }
  }
  if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Building::Gradient>>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::VenueWallShadow::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Venue3DStroke::VerticalVenue3DStrokePipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Venue3DStroke::HorizontalVenue3DStrokePipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::VenueWall::WallEndCapMeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::VenueWall::WallTopMeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::VenueWall::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::VenueOpenToBelowShadow::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::VenueOpenToBelowShadowAlpha::MeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::PolygonSolidFill::CompressedMeshPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  uint64_t v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t gss::QueryableLocker<gss::PropertyID>::hasTargetValueForKeyAtZ(uint64_t a1, unsigned int a2)
{
  if (a2 >= 0x17) {
    unsigned int v3 = 23;
  }
  else {
    unsigned int v3 = a2;
  }
  unsigned int v4 = *(unsigned __int8 *)(a1 + 12);
  if (v4 == 2)
  {
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(a1, 0x5Du, v3, 0)) {
      return 1;
    }
    unsigned int v4 = 1;
  }
  return gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(a1, 0x5Du, v3, v4);
}

void sub_1A214A0F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A214A38C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A214A5C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A214A818(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A214AA68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A214AD1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A214AFB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A214B064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint64_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)VKPolylineGroupOverlay;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void *md::ModelTileDebugData::ModelTileDebugData(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (void *)a1;
  *(_OWORD *)(a1 + 112) = 0u;
  uint64_t v95 = (geo::codec::VectorTile **)(a1 + 112);
  *(_OWORD *)(a1 + 128) = 0u;
  *(void *)(a1 + 224) = 0;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  if (v4)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
    uint64_t v5 = *(std::__shared_weak_count **)(a1 + 120);
    *(void *)(a1 + 112) = v3;
    *(void *)(a1 + 120) = v4;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
  else
  {
    *(void *)(a1 + 112) = v3;
    *(void *)(a1 + 120) = 0;
  }
  uint64_t v6 = (_DWORD *)geo::codec::VectorTile::key(*v95);
  exp2((double)((*v6 >> 8) & 0x3F));
  unint64_t v93 = geo::codec::VectorTile::linesCount(*v95);
  uint64_t v7 = *v95;
  uint64_t v98 = v2;
  if (v93)
  {
    geo::codec::VectorTile::lines(v7);
    operator new();
  }
  uint64_t v8 = (std::__shared_weak_count *)v2[15];
  int8x8_t v100 = *v95;
  unint64_t v101 = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = geo::codec::VectorTile::poisCount(v7);
  if (v9)
  {
    v2[7] += v9;
    operator new();
  }
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  uint64_t v96 = geo::codec::VectorTile::polygonsCount(*v95);
  if (v96)
  {
    v2[4] += v96;
    uint64_t v10 = v2[18];
    if (!v10) {
      operator new();
    }
    uint64_t v94 = geo::codec::VectorTile::polygons(*v95);
    for (uint64_t i = 0; i != v96; ++i)
    {
      uint64_t v12 = v94 + (i << 7);
      if (*(_DWORD *)(v12 + 100))
      {
        unint64_t v13 = 0;
        do
        {
          v99[0] = 0;
          uint64_t v14 = geo::codec::multiSectionFeaturePoints((void *)v12, v13, v99);
          uint64_t v15 = v99[0];
          v2[5] += v99[0];
          v15 *= 2;
          v99[0] = v15 - 2;
          uint64_t v16 = **(void **)(v10 + 64);
          unint64_t v17 = *(void *)(v16 + 8);
          unint64_t v18 = (*(void *)(v16 + 48) - *(void *)(v16 + 40)) / v17;
          uint64_t v19 = v18 + v15;
          unint64_t v20 = v17 * (v18 + v15);
          uint64_t v21 = *(void *)(v16 + 72);
          unint64_t v22 = *(void *)(v16 + 80) - v21;
          if (v20 != v22)
          {
            if (v20 <= v22)
            {
              if (v20 < v22) {
                *(void *)(v16 + 80) = v21 + v20;
              }
            }
            else
            {
              std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v16 + 72, v20 - v22);
            }
            uint64_t v23 = *(std::__shared_weak_count **)(v16 + 32);
            *(void *)(v16 + 24) = 0;
            *(void *)(v16 + 32) = 0;
            if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
              std::__shared_weak_count::__release_weak(v23);
            }
            *(void *)(v16 + 120) = 0;
            *(_DWORD *)(v16 + 112) = 0;
            uint64_t v24 = *(void *)(v16 + 80) - *(void *)(v16 + 72);
            *(void *)(v16 + 40) = 0;
            *(void *)(v16 + 48) = v24;
            *(void *)(v16 + 56) = 0;
            *(void *)(v16 + 64) = v24;
            uint64_t v16 = **(void **)(v10 + 64);
            unint64_t v17 = *(void *)(v16 + 8);
            unint64_t v20 = v17 * v19;
          }
          unint64_t v25 = v17 * v18;
          if (v20 == v25) {
            unint64_t v26 = 0;
          }
          else {
            unint64_t v26 = *(void *)(v16 + 72) + v25;
          }
          unint64_t v27 = v99[0];
          uint64_t v28 = v14;
          if (v99[0] >= 2uLL)
          {
            long long v29 = (void *)(v26 + 16);
            unint64_t v30 = 1;
            uint64_t v28 = v14;
            do
            {
              *(v29 - 2) = *v28;
              *(v29 - 1) = 0x3F80000000000000;
              uint64_t v31 = v28[1];
              ++v28;
              void *v29 = v31;
              v29[1] = 0x3F80000000000000;
              v29 += 4;
              v30 += 2;
            }
            while (v27 > v30);
          }
          uint64_t v32 = (void *)(v26 + 16 * v27);
          void *v32 = *v28;
          v32[1] = 0x3F80000000000000;
          v32[2] = *v14;
          v32[3] = 0x3F80000000000000;
          if (v26 && v20 != v25)
          {
            unint64_t v34 = *(void *)(v16 + 56);
            unint64_t v33 = *(void *)(v16 + 64);
            if (v33 == v34) {
              unint64_t v34 = *(void *)(v16 + 80) - *(void *)(v16 + 72);
            }
            if (v25 >= v34) {
              unint64_t v25 = v34;
            }
            if (v33 > v20) {
              unint64_t v20 = *(void *)(v16 + 64);
            }
            if (v20 == v25) {
              unint64_t v20 = v25 + *(void *)(v16 + 80) - *(void *)(v16 + 72);
            }
            *(void *)(v16 + 56) = v25;
            *(void *)(v16 + 64) = v20;
          }
          ++v13;
        }
        while (v13 < *(unsigned int *)(v12 + 100));
      }
    }
  }
  unint64_t v35 = geo::codec::VectorTile::totalBuildingFootprintsCount(*v95);
  unint64_t v36 = v35;
  if (v35)
  {
    v2[4] += v35;
    uint64_t v37 = v2[18];
    if (!v37) {
      operator new();
    }
    unint64_t v38 = 0;
    do
    {
      uint64_t v39 = geo::codec::buildingFootprintFeatureAtIndex((uint64_t)v95, v38);
      if (*(_DWORD *)(v39 + 100))
      {
        unint64_t v40 = 0;
        do
        {
          v99[0] = 0;
          uint64_t v41 = geo::codec::multiSectionFeaturePoints((void *)v39, v40, v99);
          uint64_t v42 = v99[0];
          v2[5] += v99[0];
          v42 *= 2;
          v99[0] = v42 - 2;
          uint64_t v43 = **(void **)(v37 + 64);
          unint64_t v44 = *(void *)(v43 + 8);
          unint64_t v45 = (*(void *)(v43 + 48) - *(void *)(v43 + 40)) / v44;
          uint64_t v46 = v45 + v42;
          unint64_t v47 = v44 * (v45 + v42);
          uint64_t v48 = *(void *)(v43 + 72);
          unint64_t v49 = *(void *)(v43 + 80) - v48;
          if (v47 != v49)
          {
            if (v47 <= v49)
            {
              if (v47 < v49) {
                *(void *)(v43 + 80) = v48 + v47;
              }
            }
            else
            {
              std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v43 + 72, v47 - v49);
            }
            uint64_t v50 = *(std::__shared_weak_count **)(v43 + 32);
            *(void *)(v43 + 24) = 0;
            *(void *)(v43 + 32) = 0;
            if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
              std::__shared_weak_count::__release_weak(v50);
            }
            *(void *)(v43 + 120) = 0;
            *(_DWORD *)(v43 + 112) = 0;
            uint64_t v51 = *(void *)(v43 + 80) - *(void *)(v43 + 72);
            *(void *)(v43 + 40) = 0;
            *(void *)(v43 + 48) = v51;
            *(void *)(v43 + 56) = 0;
            *(void *)(v43 + 64) = v51;
            uint64_t v43 = **(void **)(v37 + 64);
            unint64_t v44 = *(void *)(v43 + 8);
            unint64_t v47 = v44 * v46;
          }
          unint64_t v52 = v44 * v45;
          if (v47 == v52) {
            unint64_t v53 = 0;
          }
          else {
            unint64_t v53 = *(void *)(v43 + 72) + v52;
          }
          unint64_t v54 = v99[0];
          uint64_t v55 = v41;
          if (v99[0] >= 2uLL)
          {
            uint64_t v56 = (void *)(v53 + 16);
            unint64_t v57 = 1;
            uint64_t v55 = v41;
            do
            {
              *(v56 - 2) = *v55;
              *(v56 - 1) = 0x3F80000000000000;
              uint64_t v58 = v55[1];
              ++v55;
              void *v56 = v58;
              v56[1] = 0x3F80000000000000;
              v56 += 4;
              v57 += 2;
            }
            while (v54 > v57);
          }
          uint64_t v59 = (void *)(v53 + 16 * v54);
          *uint64_t v59 = *v55;
          v59[1] = 0x3F80000000000000;
          _OWORD v59[2] = *v41;
          v59[3] = 0x3F80000000000000;
          if (v53 && v47 != v52)
          {
            unint64_t v61 = *(void *)(v43 + 56);
            unint64_t v60 = *(void *)(v43 + 64);
            if (v60 == v61) {
              unint64_t v61 = *(void *)(v43 + 80) - *(void *)(v43 + 72);
            }
            if (v52 >= v61) {
              unint64_t v52 = v61;
            }
            if (v60 > v47) {
              unint64_t v47 = *(void *)(v43 + 64);
            }
            if (v47 == v52) {
              unint64_t v47 = v52 + *(void *)(v43 + 80) - *(void *)(v43 + 72);
            }
            *(void *)(v43 + 56) = v52;
            *(void *)(v43 + 64) = v47;
          }
          ++v40;
          uint64_t v2 = v98;
        }
        while (v40 < *(unsigned int *)(v39 + 100));
      }
      ++v38;
    }
    while (v38 != v36);
  }
  uint64_t v62 = geo::codec::VectorTile::totalThreeDBuildingsCount(*v95);
  uint64_t v63 = v62;
  if (v62)
  {
    v98[4] += v62;
    if (!v98[18]) {
      operator new();
    }
    unint64_t v64 = 0;
    do
    {
      uint64_t v65 = geo::codec::threeDBuildingFeatureAtIndex((uint64_t)v95, v64);
      uint64_t v66 = (geo *)geo::A3DFileCreate(*(geo **)(v65 + 80), (const unsigned __int8 *)(*(void *)(v65 + 88) - *(void *)(v65 + 80)));
      unint64_t v68 = v66;
      if (v66)
      {
        uint64_t v69 = *(geo **)v66;
        uint64_t v70 = (const unsigned __int8 *)*((void *)v66 + 1);
        unsigned int v71 = geo::A3DGetMetadataHeaderCount(*(geo **)v66, v70);
        if (v71)
        {
          uint64_t v72 = geo::A3DGetMetadataHeaders(v69, v70);
          if (v72)
          {
            uint64_t v73 = 0;
            uint64_t v74 = 0;
            uint64_t v75 = v71;
            do
            {
              if (!*(unsigned char *)v72)
              {
                v73 += *(unsigned int *)(v72 + 5);
                ++v74;
              }
              v72 += 17;
              --v75;
            }
            while (v75);
            if (v74) {
              operator new[]();
            }
          }
        }
      }
      geo::A3DFileDelete(v68, v67);
      ++v64;
    }
    while (v64 != v63);
  }
  unint64_t v76 = geo::codec::VectorTile::venuesCount(*v95);
  if (v76)
  {
    v98[6] += v76;
    operator new();
  }
  if ((geo::codec::VectorTile::hasComputedJunctions(*v95) & 1) == 0 && geo::codec::VectorTile::junctionsCount(*v95))
  {
    geo::codec::VectorTile::lines(*v95);
    geo::codec::VectorTile::pointsOnRoad(*v95);
    geo::codec::VectorTile::junctions(*v95);
    operator new();
  }
  uint64_t v77 = geo::codec::VectorTile::lineCrossingsCount(*v95);
  v98[10] = v77;
  if (v77)
  {
    geo::codec::VectorTile::lines(*v95);
    geo::codec::VectorTile::linesCount(*v95);
    geo::codec::VectorTile::lineCrossings(*v95);
    operator new();
  }
  uint64_t v97 = geo::codec::VectorTile::coastlinesCount(*v95);
  if (v97)
  {
    v98[12] += v97;
    operator new();
  }
  if (geo::codec::VectorTile::transitLinkCount(*v95)) {
    operator new();
  }
  uint64_t v78 = geo::codec::VectorTile::daVinciMetaData(*v95);
  if (v78)
  {
    uint64_t v79 = operator new(0x60uLL);
    v79[1] = 0;
    v79[2] = 0;
    *uint64_t v79 = &unk_1EF583AF8;
    uint64_t v80 = ggl::TextureData2D::TextureData2D((uint64_t)(v79 + 3), *(unsigned __int16 *)(v78 + 8), *(unsigned __int16 *)(v78 + 8), 1u, 12, 0);
    v99[0] = v79 + 3;
    v99[1] = v79;
    uint64_t v81 = (*(uint64_t (**)(void *, void))(v79[3] + 16))(v80, 0);
    LODWORD(v82) = *(unsigned __int16 *)(v78 + 8);
    if (*(_WORD *)(v78 + 8))
    {
      uint64_t v83 = 0;
      unsigned int v84 = 0;
      int v85 = -1;
      do
      {
        if (v82)
        {
          unint64_t v86 = 0;
          uint64_t v87 = v81 + 3 + (4 * v82 * (v82 + v85));
          do
          {
            unsigned int v88 = *(unsigned __int8 *)(*(void *)(v78 + 24) + v83 * v82 + v86);
            int v89 = ((v88 >> 1) & 1) - 1;
            if ((v88 & 3) != 0) {
              char v90 = -1;
            }
            else {
              char v90 = 64;
            }
            *(unsigned char *)(v87 - 3) = v89;
            *(unsigned char *)(v87 - 2) = v90;
            *(_WORD *)(v87 - 1) = -256;
            ++v86;
            unint64_t v82 = *(unsigned __int16 *)(v78 + 8);
            v87 += 4;
          }
          while (v86 < v82);
        }
        ++v84;
        --v85;
        ++v83;
      }
      while (v84 < v82);
    }
    uint64_t v91 = operator new(0x58uLL);
    v91[1] = 0;
    uint64_t v91[2] = 0;
    *uint64_t v91 = &unk_1EF583858;
    v91[5] = 0;
    v91[6] = 0;
    *((_DWORD *)v91 + 14) = 0;
    v91[3] = &unk_1EF55AE58;
    v91[4] = 0;
    *((_DWORD *)v91 + 17) = 1;
    *(void *)((char *)v91 + 60) = 0x100000001;
    v91[9] = 0;
    v91[10] = 0;
    int8x8_t v100 = (geo::codec::VectorTile *)(v91 + 3);
    unint64_t v101 = (std::__shared_weak_count *)v91;
    operator new();
  }
  return v98;
}

void sub_1A214D828(_Unwind_Exception *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, ...)
{
  va_start(va, a15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v15 - 136);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  uint64_t v17 = a15[28];
  a15[28] = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  uint64_t v18 = a15[27];
  a15[27] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  }
  uint64_t v19 = a15[26];
  a15[26] = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  uint64_t v20 = a15[25];
  a15[25] = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  }
  uint64_t v21 = a15[24];
  a15[24] = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  uint64_t v22 = a15[23];
  a15[23] = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
  }
  uint64_t v23 = a15[22];
  a15[22] = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  uint64_t v24 = a15[21];
  a15[21] = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
  }
  uint64_t v25 = a15[20];
  a15[20] = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  uint64_t v26 = a15[19];
  a15[19] = 0;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 8))(v26);
  }
  uint64_t v27 = a15[18];
  a15[18] = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  uint64_t v28 = *a3;
  *a3 = 0;
  if (v28) {
    (*(void (**)(uint64_t))(*(void *)v28 + 8))(v28);
  }
  uint64_t v29 = *a4;
  *a4 = 0;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a11);
  _Unwind_Resume(a1);
}

void ggl::PolygonStroke::MeshPipelineState::~MeshPipelineState(ggl::PolygonStroke::MeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::PolygonStroke::MeshPipelineSetup::textureIsEnabled(ggl::PolygonStroke::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::PolygonStroke::MeshPipelineSetup::constantDataIsEnabled(ggl::PolygonStroke::MeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 3;
}

void ggl::PolygonStroke::MeshPipelineSetup::~MeshPipelineSetup(ggl::PolygonStroke::MeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__node_insert_unique(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned __int8 *)(a2 + 16);
  uint64_t v5 = *(unsigned __int8 *)(a2 + 17);
  unint64_t v6 = (v5
      + ((v4 - 0x61C8864680B583EBLL) << 6)
      + ((unint64_t)(v4 - 0x61C8864680B583EBLL) >> 2)
      - 0x61C8864680B583EBLL) ^ (v4 - 0x61C8864680B583EBLL);
  uint64_t v7 = *(int *)(a2 + 20);
  uint64_t v8 = *(int *)(a2 + 24);
  unint64_t v9 = (v7 + (v6 << 6) + (v6 >> 2) - 0x61C8864680B583EBLL) ^ v6;
  unint64_t v10 = (v8 + (v9 << 6) + (v9 >> 2) - 0x61C8864680B583EBLL) ^ v9;
  *(void *)(a2 + 8) = v10;
  unint64_t v11 = *(void *)(a1 + 8);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      uint64_t v13 = (v8 + (v9 << 6) + (v9 >> 2) - 0x61C8864680B583EBLL) ^ v9;
      if (v11 <= v10) {
        uint64_t v13 = v10 % v11;
      }
    }
    else
    {
      uint64_t v13 = (v11 - 1) & v10;
    }
    uint64_t v14 = *(uint64_t ***)(*(void *)a1 + 8 * v13);
    if (v14)
    {
      uint64_t v15 = *v14;
      if (v15)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v15[1];
            if (v17 == v10)
            {
              if (*((unsigned __int8 *)v15 + 16) == v4
                && *((unsigned __int8 *)v15 + 17) == v5
                && *((_DWORD *)v15 + 5) == v7
                && *((_DWORD *)v15 + 6) == v8)
              {
                return 0;
              }
            }
            else if ((v17 & (v11 - 1)) != v13)
            {
              goto LABEL_28;
            }
            uint64_t v15 = (uint64_t *)*v15;
            if (!v15) {
              goto LABEL_28;
            }
          }
        }
        do
        {
          unint64_t v16 = v15[1];
          if (v16 == v10)
          {
            if (*((unsigned __int8 *)v15 + 16) == v4
              && *((unsigned __int8 *)v15 + 17) == v5
              && *((_DWORD *)v15 + 5) == v7
              && *((_DWORD *)v15 + 6) == v8)
            {
              return 0;
            }
          }
          else
          {
            if (v16 >= v11) {
              v16 %= v11;
            }
            if (v16 != v13) {
              break;
            }
          }
          uint64_t v15 = (uint64_t *)*v15;
        }
        while (v15);
      }
    }
  }
LABEL_28:
  float v19 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v20 = *(float *)(a1 + 32);
  if (!v11 || (float)(v20 * (float)v11) < v19)
  {
    BOOL v21 = 1;
    if (v11 >= 3) {
      BOOL v21 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v22 = v21 | (2 * v11);
    unint64_t v23 = vcvtps_u32_f32(v19 / v20);
    if (v22 <= v23) {
      size_t prime = v23;
    }
    else {
      size_t prime = v22;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v11 = *(void *)(a1 + 8);
    }
    if (prime > v11) {
      goto LABEL_40;
    }
    if (prime < v11)
    {
      unint64_t v25 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v11 < 3 || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
      {
        unint64_t v25 = std::__next_prime(v25);
      }
      else
      {
        uint64_t v27 = 1 << -(char)__clz(v25 - 1);
        if (v25 >= 2) {
          unint64_t v25 = v27;
        }
      }
      if (prime <= v25) {
        size_t prime = v25;
      }
      if (prime < v11) {
LABEL_40:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
  }
  int8x8_t v28 = *(int8x8_t *)(a1 + 8);
  unint64_t v29 = *(void *)(a2 + 8);
  uint8x8_t v30 = (uint8x8_t)vcnt_s8(v28);
  v30.i16[0] = vaddlv_u8(v30);
  if (v30.u32[0] > 1uLL)
  {
    if (v29 >= *(void *)&v28) {
      v29 %= *(void *)&v28;
    }
  }
  else
  {
    v29 &= *(void *)&v28 - 1;
  }
  uint64_t v31 = *(void **)(*(void *)a1 + 8 * v29);
  if (v31)
  {
    *(void *)a2 = *v31;
LABEL_63:
    *uint64_t v31 = a2;
    goto LABEL_64;
  }
  *(void *)a2 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = a2;
  *(void *)(*(void *)a1 + 8 * v29) = a1 + 16;
  if (*(void *)a2)
  {
    unint64_t v32 = *(void *)(*(void *)a2 + 8);
    if (v30.u32[0] > 1uLL)
    {
      if (v32 >= *(void *)&v28) {
        v32 %= *(void *)&v28;
      }
    }
    else
    {
      v32 &= *(void *)&v28 - 1;
    }
    uint64_t v31 = (void *)(*(void *)a1 + 8 * v32);
    goto LABEL_63;
  }
LABEL_64:
  ++*(void *)(a1 + 24);
  return 1;
}

void md::mun::MuninMetadataContainer::~MuninMetadataContainer(md::mun::MuninMetadataContainer *this)
{
  uint64_t v2 = (void *)*((void *)this + 77);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 75);
  *((void *)this + 75) = 0;
  if (v4) {
    operator delete(v4);
  }
  if (*((void *)this + 74))
  {
    uint64_t v5 = (md::mun::MuninMetadataContainer *)*((void *)this + 73);
    uint64_t v6 = *((void *)this + 72);
    uint64_t v7 = *(void *)v5;
    *(void *)(v7 + 8) = *(void *)(v6 + 8);
    **(void **)(v6 + 8) = v7;
    *((void *)this + 74) = 0;
    if (v5 != (md::mun::MuninMetadataContainer *)((char *)this + 576))
    {
      do
      {
        uint64_t v17 = (md::mun::MuninMetadataContainer *)*((void *)v5 + 1);
        uint64_t v18 = (void *)*((void *)v5 + 14);
        float v19 = (void *)*((void *)v5 + 15);
        if (v18 != v19)
        {
          do
          {
            float v20 = (void *)v18[31];
            if (v20 != (void *)v18[33]) {
              free(v20);
            }
            v18 += 36;
          }
          while (v18 != v19);
          uint64_t v18 = (void *)*((void *)v5 + 14);
        }
        if (v18 != *((void **)v5 + 16)) {
          free(v18);
        }
        operator delete(v5);
        uint64_t v5 = v17;
      }
      while (v17 != (md::mun::MuninMetadataContainer *)((char *)this + 576));
    }
  }
  std::mutex::~mutex((std::mutex *)this + 8);
  uint64_t v8 = *((void *)this + 62);
  *((void *)this + 62) = 0;
  if (v8)
  {
    unint64_t v9 = *(void **)(v8 + 40);
    if (v9)
    {
      do
      {
        BOOL v21 = (void *)*v9;
        unint64_t v22 = (void *)v9[3];
        if (v22 != (void *)v9[5]) {
          free(v22);
        }
        operator delete(v9);
        unint64_t v9 = v21;
      }
      while (v21);
    }
    unint64_t v10 = *(void **)(v8 + 24);
    *(void *)(v8 + 24) = 0;
    if (v10) {
      operator delete(v10);
    }
    std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v8 + 8));
    MEMORY[0x1A6239270](v8, 0x10A0C408DBFAB7ELL);
  }
  unint64_t v11 = (geo::read_write_lock *)pthread_rwlock_destroy((pthread_rwlock_t *)((char *)this + 296));
  if (v11) {
    geo::read_write_lock::logFailure(v11, (uint64_t)"destruction", v12);
  }
  uint64_t v13 = (geo::read_write_lock *)pthread_rwlock_destroy((pthread_rwlock_t *)((char *)this + 96));
  if (v13) {
    geo::read_write_lock::logFailure(v13, (uint64_t)"destruction", v14);
  }
  std::__tree<gdc::LayerDataWithWorld>::destroy(*((void **)this + 10));
  std::__tree<gdc::LayerDataWithWorld>::destroy(*((void **)this + 7));
  uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
    unint64_t v16 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v16) {
      return;
    }
  }
  else
  {
    unint64_t v16 = (std::__shared_weak_count *)*((void *)this + 1);
    if (!v16) {
      return;
    }
  }
  std::__shared_weak_count::__release_weak(v16);
}

void md::mun::MuninMetadataContainer::addActiveMetadataPoint(std::mutex *this, const md::mun::CollectionPoint *a2)
{
  unint64_t v82 = this + 8;
  std::mutex::lock(this + 8);
  *(void *)&long long v83 = *(void *)a2;
  *((void *)&v83 + 1) = *(void *)a2;
  long long v84 = *(_OWORD *)((char *)a2 + 8);
  uint64_t v85 = *((void *)a2 + 3);
  uint64_t v86 = *((void *)a2 + 4);
  int v87 = *((_DWORD *)a2 + 10);
  uint64_t v88 = *(void *)((char *)a2 + 44);
  long long v89 = *(_OWORD *)((char *)a2 + 56);
  long long v90 = *(_OWORD *)((char *)a2 + 72);
  uint64_t v91 = (long long *)v95;
  long long v92 = (long long *)v95;
  unint64_t v93 = (long long *)v95;
  uint64_t v94 = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)&v91, *((long long **)a2 + 11), *((long long **)a2 + 12));
  *(void *)((char *)v96 + 5) = *(void *)((char *)a2 + 1853);
  v96[0] = *((void *)a2 + 231);
  long long v97 = v83;
  long long v98 = v84;
  uint64_t v99 = v85;
  uint64_t v100 = v86;
  int v101 = v87;
  uint64_t v102 = v88;
  long long v103 = v89;
  long long v104 = v90;
  uint64_t v105 = v109;
  uint64_t v106 = (long long *)v109;
  uint64_t v107 = (long long *)v109;
  uint64_t v108 = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)&v105, v91, v92);
  uint64_t v4 = (char *)&this[9];
  unint64_t v5 = (unint64_t)&v98;
  *(void *)((char *)v110 + 5) = *(void *)((char *)v96 + 5);
  v110[0] = v96[0];
  uint64_t v111 = 0;
  unint64_t v6 = *(void *)&this[9].__m_.__opaque[24];
  if (!v6) {
    goto LABEL_21;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8((int8x8_t)v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v8 = v97;
    if ((unint64_t)v97 >= v6) {
      unint64_t v8 = (unint64_t)v97 % v6;
    }
  }
  else
  {
    unint64_t v8 = (v6 - 1) & v97;
  }
  unint64_t v9 = *(void **)(*(void *)&this[9].__m_.__opaque[16] + 8 * v8);
  if (!v9 || (unint64_t v10 = (void *)*v9) == 0)
  {
LABEL_21:
    uint64_t v14 = operator new(0x768uLL);
    *uint64_t v14 = 0;
    v14[1] = 0;
    long long v15 = v98;
    *((_OWORD *)v14 + 1) = v97;
    *((_OWORD *)v14 + 2) = v15;
    uint64_t v16 = v100;
    v14[6] = v99;
    v14[7] = v16;
    *((_DWORD *)v14 + 16) = v101;
    *(void *)((char *)v14 + 68) = v102;
    long long v17 = v104;
    *((_OWORD *)v14 + 5) = v103;
    *((_OWORD *)v14 + 6) = v17;
    v14[14] = v14 + 18;
    v14[15] = v14 + 18;
    v14[16] = v14 + 18;
    v14[17] = 6;
    geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)(v14 + 14), (long long *)v105, v106);
    v14[234] = v110[0];
    *(void *)((char *)v14 + 1877) = *(void *)((char *)v110 + 5);
    uint64_t v18 = v111;
    v14[236] = v111;
    uint64_t sig = this[9].__m_.__sig;
    *(void *)(sig + 8) = v14;
    this[9].__m_.__uint64_t sig = (uint64_t)v14;
    *uint64_t v14 = sig;
    v14[1] = v4;
    ++*(void *)&this[9].__m_.__opaque[8];
    *(void *)this[10].__m_.__opaque += v18;
    if ((char *)this[10].__m_.__sig == v4) {
      this[10].__m_.__uint64_t sig = (uint64_t)v14;
    }
    unint64_t v20 = v97;
    unint64_t v21 = *(void *)&this[9].__m_.__opaque[24];
    if (v21)
    {
      uint8x8_t v22 = (uint8x8_t)vcnt_s8((int8x8_t)v21);
      v22.i16[0] = vaddlv_u8(v22);
      if (v22.u32[0] > 1uLL)
      {
        unint64_t v5 = v97;
        if ((unint64_t)v97 >= v21) {
          unint64_t v5 = (unint64_t)v97 % v21;
        }
      }
      else
      {
        unint64_t v5 = (v21 - 1) & v97;
      }
      unint64_t v23 = *(void **)(*(void *)&this[9].__m_.__opaque[16] + 8 * v5);
      if (v23)
      {
        uint64_t v24 = (void *)*v23;
        if (v24)
        {
          if (v22.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v26 = v24[1];
              if (v26 == (void)v97)
              {
                if (v24[2] == (void)v97) {
                  goto LABEL_104;
                }
              }
              else if ((v26 & (v21 - 1)) != v5)
              {
                goto LABEL_44;
              }
              uint64_t v24 = (void *)*v24;
              if (!v24) {
                goto LABEL_44;
              }
            }
          }
          do
          {
            unint64_t v25 = v24[1];
            if (v25 == (void)v97)
            {
              if (v24[2] == (void)v97) {
                goto LABEL_104;
              }
            }
            else
            {
              if (v25 >= v21) {
                v25 %= v21;
              }
              if (v25 != v5) {
                break;
              }
            }
            uint64_t v24 = (void *)*v24;
          }
          while (v24);
        }
      }
    }
LABEL_44:
    uint64_t v27 = operator new(0x20uLL);
    *uint64_t v27 = 0;
    v27[1] = v20;
    v27[2] = v20;
    v27[3] = v14;
    float v28 = (float)(unint64_t)(*(void *)&this[9].__m_.__opaque[40] + 1);
    float v29 = *(float *)&this[9].__m_.__opaque[48];
    if (v21 && (float)(v29 * (float)v21) >= v28)
    {
LABEL_94:
      uint64_t v53 = *(void *)&this[9].__m_.__opaque[16];
      unint64_t v54 = *(void **)(v53 + 8 * v5);
      if (v54)
      {
        *uint64_t v27 = *v54;
      }
      else
      {
        *uint64_t v27 = *(void *)&this[9].__m_.__opaque[32];
        *(void *)&this[9].__m_.__opaque[32] = v27;
        *(void *)(v53 + 8 * v5) = (char *)this + 616;
        if (!*v27)
        {
LABEL_103:
          ++*(void *)&this[9].__m_.__opaque[40];
          goto LABEL_104;
        }
        unint64_t v55 = *(void *)(*v27 + 8);
        if ((v21 & (v21 - 1)) != 0)
        {
          if (v55 >= v21) {
            v55 %= v21;
          }
        }
        else
        {
          v55 &= v21 - 1;
        }
        unint64_t v54 = (void *)(*(void *)&this[9].__m_.__opaque[16] + 8 * v55);
      }
      *unint64_t v54 = v27;
      goto LABEL_103;
    }
    BOOL v30 = 1;
    if (v21 >= 3) {
      BOOL v30 = (v21 & (v21 - 1)) != 0;
    }
    unint64_t v31 = v30 | (2 * v21);
    unint64_t v32 = vcvtps_u32_f32(v28 / v29);
    if (v31 <= v32) {
      size_t prime = v32;
    }
    else {
      size_t prime = v31;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v21 = *(void *)&this[9].__m_.__opaque[24];
    }
    if (prime <= v21)
    {
      if (prime >= v21) {
        goto LABEL_81;
      }
      unint64_t v46 = vcvtps_u32_f32((float)*(unint64_t *)&this[9].__m_.__opaque[40] / *(float *)&this[9].__m_.__opaque[48]);
      if (v21 < 3 || (uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v21), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
      {
        unint64_t v46 = std::__next_prime(v46);
      }
      else
      {
        uint64_t v48 = 1 << -(char)__clz(v46 - 1);
        if (v46 >= 2) {
          unint64_t v46 = v48;
        }
      }
      if (prime <= v46) {
        size_t prime = v46;
      }
      if (prime >= v21)
      {
        unint64_t v21 = *(void *)&this[9].__m_.__opaque[24];
LABEL_81:
        if ((v21 & (v21 - 1)) != 0)
        {
          if (v20 >= v21) {
            unint64_t v5 = v20 % v21;
          }
          else {
            unint64_t v5 = v20;
          }
        }
        else
        {
          unint64_t v5 = (v21 - 1) & v20;
        }
        goto LABEL_94;
      }
      if (!prime)
      {
        uint64_t v73 = *(void **)&this[9].__m_.__opaque[16];
        *(void *)&this[9].__m_.__opaque[16] = 0;
        if (v73) {
          operator delete(v73);
        }
        unint64_t v21 = 0;
        *(void *)&this[9].__m_.__opaque[24] = 0;
        goto LABEL_81;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v34 = operator new(8 * prime);
    unint64_t v35 = *(void **)&this[9].__m_.__opaque[16];
    *(void *)&this[9].__m_.__opaque[16] = v34;
    if (v35) {
      operator delete(v35);
    }
    uint64_t v36 = 0;
    *(void *)&this[9].__m_.__opaque[24] = prime;
    do
      *(void *)(*(void *)&this[9].__m_.__opaque[16] + 8 * v36++) = 0;
    while (prime != v36);
    uint64_t v37 = *(void **)&this[9].__m_.__opaque[32];
    if (!v37)
    {
LABEL_80:
      unint64_t v21 = prime;
      goto LABEL_81;
    }
    unint64_t v38 = &this[9].__m_.__opaque[32];
    size_t v39 = v37[1];
    size_t v40 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v41 = v39 & v40;
      *(void *)(*(void *)&this[9].__m_.__opaque[16] + 8 * v41) = v38;
      for (uint64_t i = (void *)*v37; *v37; uint64_t i = (void *)*v37)
      {
        size_t v43 = i[1] & v40;
        if (v43 == v41)
        {
          uint64_t v37 = i;
        }
        else
        {
          uint64_t v44 = *(void *)&this[9].__m_.__opaque[16];
          if (*(void *)(v44 + 8 * v43))
          {
            void *v37 = *i;
            uint64_t v45 = 8 * v43;
            *uint64_t i = **(void **)(*(void *)&this[9].__m_.__opaque[16] + v45);
            **(void **)(*(void *)&this[9].__m_.__opaque[16] + v45) = i;
          }
          else
          {
            *(void *)(v44 + 8 * v43) = v37;
            uint64_t v37 = i;
            size_t v41 = v43;
          }
        }
      }
      goto LABEL_80;
    }
    if (v39 >= prime) {
      v39 %= prime;
    }
    *(void *)(*(void *)&this[9].__m_.__opaque[16] + 8 * v39) = v38;
    unint64_t v49 = (void *)*v37;
    if (!*v37) {
      goto LABEL_80;
    }
    while (1)
    {
      size_t v51 = v49[1];
      if (v51 >= prime) {
        v51 %= prime;
      }
      if (v51 != v39)
      {
        uint64_t v52 = *(void *)&this[9].__m_.__opaque[16];
        if (!*(void *)(v52 + 8 * v51))
        {
          *(void *)(v52 + 8 * v51) = v37;
          goto LABEL_85;
        }
        void *v37 = *v49;
        uint64_t v50 = 8 * v51;
        void *v49 = **(void **)(*(void *)&this[9].__m_.__opaque[16] + v50);
        **(void **)(*(void *)&this[9].__m_.__opaque[16] + v50) = v49;
        unint64_t v49 = v37;
      }
      size_t v51 = v39;
LABEL_85:
      uint64_t v37 = v49;
      unint64_t v49 = (void *)*v49;
      size_t v39 = v51;
      if (!v49) {
        goto LABEL_80;
      }
    }
  }
  if (v7.u32[0] < 2uLL)
  {
    unint64_t v11 = v6 - 1;
    while (1)
    {
      uint64_t v13 = v10[1];
      if (v13 == (void)v97)
      {
        if (v10[2] == (void)v97) {
          goto LABEL_122;
        }
      }
      else if ((v13 & v11) != v8)
      {
        goto LABEL_21;
      }
      unint64_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v10[1];
    if (v12 == (void)v97) {
      break;
    }
    if (v12 >= v6) {
      v12 %= v6;
    }
    if (v12 != v8) {
      goto LABEL_21;
    }
LABEL_11:
    unint64_t v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_21;
    }
  }
  if (v10[2] != (void)v97) {
    goto LABEL_11;
  }
LABEL_122:
  uint64_t v63 = (char *)v10[3];
  unint64_t v64 = operator new(0x768uLL);
  *unint64_t v64 = 0;
  v64[1] = 0;
  long long v65 = v98;
  *((_OWORD *)v64 + 1) = v97;
  *((_OWORD *)v64 + 2) = v65;
  uint64_t v66 = v100;
  v64[6] = v99;
  v64[7] = v66;
  *((_DWORD *)v64 + 16) = v101;
  *(void *)((char *)v64 + 68) = v102;
  long long v67 = v104;
  *((_OWORD *)v64 + 5) = v103;
  *((_OWORD *)v64 + 6) = v67;
  v64[14] = v64 + 18;
  v64[15] = v64 + 18;
  v64[16] = v64 + 18;
  v64[17] = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)(v64 + 14), (long long *)v105, v106);
  v64[234] = v110[0];
  *(void *)((char *)v64 + 1877) = *(void *)((char *)v110 + 5);
  uint64_t v68 = v111;
  v64[236] = v111;
  uint64_t v69 = this[9].__m_.__sig;
  *(void *)(v69 + 8) = v64;
  this[9].__m_.__uint64_t sig = (uint64_t)v64;
  *unint64_t v64 = v69;
  v64[1] = v4;
  uint64_t v70 = *(void *)&this[9].__m_.__opaque[8];
  *(void *)&this[9].__m_.__opaque[8] = v70 + 1;
  unsigned int v71 = (char *)this[10].__m_.__sig;
  if (v71 == v63)
  {
    uint64_t v72 = *((void *)v63 + 1);
    goto LABEL_135;
  }
  uint64_t v72 = (uint64_t)v64;
  if (v71 == v4) {
LABEL_135:
  }
    this[10].__m_.__uint64_t sig = v72;
  unint64_t v74 = *((void *)v63 + 236);
  unint64_t v75 = *(void *)this[10].__m_.__opaque;
  BOOL v76 = v75 >= v74;
  unint64_t v77 = v75 - v74;
  if (!v76) {
    unint64_t v77 = 0;
  }
  *(void *)this[10].__m_.__opaque = v77 + v68;
  uint64_t v78 = *(void *)v63;
  *(void *)(v78 + 8) = *((void *)v63 + 1);
  **((void **)v63 + 1) = v78;
  *(void *)&this[9].__m_.__opaque[8] = v70;
  uint64_t v80 = (void *)*((void *)v63 + 14);
  uint64_t v79 = (void *)*((void *)v63 + 15);
  if (v80 != v79)
  {
    do
    {
      uint64_t v81 = (void *)v80[31];
      if (v81 != (void *)v80[33]) {
        free(v81);
      }
      v80 += 36;
    }
    while (v80 != v79);
    uint64_t v80 = (void *)*((void *)v63 + 14);
  }
  if (v80 != *((void **)v63 + 16)) {
    free(v80);
  }
  operator delete(v63);
  v10[3] = v64;
LABEL_104:
  uint64_t v56 = (long long *)v105;
  unint64_t v57 = v106;
  if (v105 == v106)
  {
    uint64_t v58 = v82;
  }
  else
  {
    uint64_t v58 = v82;
    do
    {
      uint64_t v59 = (void *)*((void *)v56 + 31);
      if (v59 != *((void **)v56 + 33)) {
        free(v59);
      }
      v56 += 18;
    }
    while (v56 != v57);
    uint64_t v56 = (long long *)v105;
  }
  if (v56 != v107) {
    free(v56);
  }
  unint64_t v61 = v91;
  unint64_t v60 = v92;
  if (v91 != v92)
  {
    do
    {
      uint64_t v62 = (void *)*((void *)v61 + 31);
      if (v62 != *((void **)v61 + 33)) {
        free(v62);
      }
      v61 += 18;
    }
    while (v61 != v60);
    unint64_t v61 = v91;
  }
  if (v61 != v93) {
    free(v61);
  }
  std::mutex::unlock(v58);
}

void sub_1A214EC50(_Unwind_Exception *a1, uint64_t a2, std::mutex *a3, ...)
{
  va_start(va, a3);
  operator delete(v3);
  std::pair<unsigned long long,md::mun::CollectionPoint>::~pair(&STACK[0x760]);
  std::pair<unsigned long long,md::mun::CollectionPoint>::~pair(va);
  std::mutex::unlock(a3);
  _Unwind_Resume(a1);
}

void *std::pair<unsigned long long,md::mun::CollectionPoint>::~pair(void *a1)
{
  uint64_t v2 = (void *)a1[12];
  uint64_t v3 = (void *)a1[13];
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = (void *)v2[31];
      if (v4 != (void *)v2[33]) {
        free(v4);
      }
      v2 += 36;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)a1[12];
  }
  if (v2 != (void *)a1[14]) {
    free(v2);
  }
  return a1;
}

void md::mun::MuninMetadataContainer::nearestMetadataTiles(uint64_t a1, uint64_t a2, double *a3, double a4)
{
  uint64_t v5 = atomic_load((unsigned __int8 *)(a2 + 24));
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (v5)
  {
    double v8 = *a3;
    long double v9 = cos(v8 + v8) * -559.82 + 111132.92;
    long double v10 = v9 + cos(v8 * 4.0) * 1.175;
    long double v11 = v10 + cos(v8 * 6.0) * -0.0023;
    double v12 = v8 * 0.5;
    long double v13 = tan(v8 * 0.5 + 0.78103484);
    double v14 = log(v13);
    long double v15 = tan(v12 + 0.789761487);
    long double v16 = fabs((log(v15) - v14) * 0.159154943) * a4 / v11;
    double v17 = a3[1];
    long double v18 = tan(v12 + 0.785398163);
    long double v19 = log(v18);
    double v20 = v17 * 0.159154943 + 0.5;
    long double v21 = v19 * 0.159154943 + 0.5;
    int v22 = 1 << v5;
    signed int v23 = vcvtmd_s64_f64((v20 - v16) * (double)(1 << v5));
    int v24 = v22 + ~vcvtmd_s64_f64((v16 + v21) * (double)v22);
    unsigned int v25 = vcvtmd_s64_f64((v21 - v16) * (double)(1 << v5));
    signed int v26 = vcvtmd_s64_f64((v16 + v20) * (double)(1 << v5));
    signed int v35 = v23;
    if (v24 <= (int)((1 << v5) + ~v25) && v23 <= v26)
    {
      int v28 = v26 + 1;
      uint64_t v29 = v24;
      unsigned int v34 = v22 - v25;
      do
      {
        unint64_t v30 = ((((v5 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14) << 6)
             + (((v5 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14) >> 2)
             - 0x61C8864680B583EBLL
             + v29) ^ (v5 + 0x53A3C687B1BC605ALL) ^ 0x9E3779B97F4A7D14;
        uint64_t v31 = v35 - 0x61C8864680B583EBLL + (v30 >> 2) + (v30 << 6);
        signed int v32 = v35;
        do
        {
          unint64_t v33 = operator new(0x28uLL);
          unsigned __int8 v33[16] = -1;
          v33[17] = v5;
          *((_DWORD *)v33 + 5) = v29;
          *((_DWORD *)v33 + 6) = v32;
          *(void *)unint64_t v33 = 0;
          *((void *)v33 + 1) = v31 ^ v30;
          if ((std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__node_insert_unique(a1, (uint64_t)v33) & 1) == 0)operator delete(v33); {
          ++v32;
          }
          ++v31;
        }
        while (v28 != v32);
        ++v29;
      }
      while (v34 != v29);
    }
  }
}

void sub_1A214EF94(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;
  operator delete(v3);
  uint64_t v5 = *(void **)(v1 + 16);
  if (v5)
  {
    do
    {
      unint64_t v6 = (void *)*v5;
      operator delete(v5);
      uint64_t v5 = v6;
    }
    while (v6);
  }
  uint8x8_t v7 = *(void **)v1;
  *(void *)uint64_t v1 = 0;
  if (v7) {
    operator delete(v7);
  }
  _Unwind_Resume(a1);
}

uint64_t md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0::~$_0(uint64_t a1)
{
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 24));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

void std::__function::__func<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0,std::allocator<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      if (*(void *)(a1 + 8)) {
        operator new();
      }
      if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1A214F19C(_Unwind_Exception *exception_object)
{
  if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0,std::allocator<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0>,void ()(void)>::destroy_deallocate(uint64_t a1)
{
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete((void *)a1);
}

void std::__function::__func<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0,std::allocator<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0>,void ()(void)>::destroy(uint64_t a1)
{
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2)
  {
    std::__shared_weak_count::__release_weak(v2);
  }
}

uint64_t *std::__function::__func<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0,std::allocator<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *a2 = &unk_1EF578BE8;
  a2[1] = v4;
  a2[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 16), 1uLL, memory_order_relaxed);
  }
  a2[4] = 0;
  a2[3] = a2 + 4;
  uint64_t v5 = a2 + 3;
  a2[5] = 0;
  __n128 result = std::set<std::shared_ptr<md::mun::MuninMetadata>>::insert[abi:nn180100]<std::__tree_const_iterator<std::shared_ptr<md::mun::MuninMetadata>,std::__tree_node<std::shared_ptr<md::mun::MuninMetadata>,void *> *,long>>(a2 + 3, *(void **)(a1 + 24), (void *)(a1 + 32));
  void v5[3] = *(void *)(a1 + 48);
  return result;
}

void *std::__function::__func<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0,std::allocator<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x38uLL);
  uint64_t v3 = v2;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  void *v2 = &unk_1EF578BE8;
  v2[1] = v5;
  v2[2] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 16), 1uLL, memory_order_relaxed);
  }
  v2[4] = 0;
  v2[5] = 0;
  v2[3] = v2 + 4;
  std::set<std::shared_ptr<md::mun::MuninMetadata>>::insert[abi:nn180100]<std::__tree_const_iterator<std::shared_ptr<md::mun::MuninMetadata>,std::__tree_node<std::shared_ptr<md::mun::MuninMetadata>,void *> *,long>>(v2 + 3, *(void **)(a1 + 24), (void *)(a1 + 32));
  v3[6] = *(void *)(a1 + 48);
  return v3;
}

void std::__function::__func<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0,std::allocator<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF578BE8;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0,std::allocator<md::mun::MuninMetadataContainer::updateCurrentMetadata(gdc::LayerDataCollector const*)::$_0>,void ()(void)>::~__func(uint64_t a1)
{
  *(void *)a1 = &unk_1EF578BE8;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(a1 + 32));
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t geo::optional<md::mun::CollectionPoint>::operator=(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    if (*(unsigned char *)a1)
    {
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(void *)(a1 + 32) = *(void *)(a2 + 32);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = *(void *)(a2 + 72);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      if (a1 != a2)
      {
        uint64_t v4 = (void **)(a1 + 96);
        uint64_t v5 = a1 + 128;
        unint64_t v6 = *(void **)(a1 + 96);
        uint8x8_t v7 = *(void **)(a1 + 104);
        if (v6 != v7)
        {
          do
          {
            double v8 = (void *)v6[31];
            if (v8 != (void *)v6[33]) {
              free(v8);
            }
            v6 += 36;
          }
          while (v6 != v7);
          unint64_t v6 = *v4;
        }
        if (v6 != *(void **)(a1 + 112)) {
          free(v6);
        }
        *(void *)(a1 + 96) = v5;
        *(void *)(a1 + 104) = v5;
        *(void *)(a1 + 112) = v5;
        *(void *)(a1 + 120) = 6;
        geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>(a1 + 96, *(long long **)(a2 + 96), *(long long **)(a2 + 104));
      }
      uint64_t v16 = *(void *)(a2 + 1856);
      *(void *)(a1 + 1861) = *(void *)(a2 + 1861);
      *(void *)(a1 + 1856) = v16;
    }
    else
    {
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      long long v12 = *(_OWORD *)(a2 + 16);
      *(void *)(a1 + 32) = *(void *)(a2 + 32);
      *(_OWORD *)(a1 + 16) = v12;
      uint64_t v13 = *(void *)(a2 + 40);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
      *(void *)(a1 + 40) = v13;
      *(void *)(a1 + 52) = *(void *)(a2 + 52);
      long long v14 = *(_OWORD *)(a2 + 80);
      *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
      *(_OWORD *)(a1 + 80) = v14;
      *(void *)(a1 + 96) = a1 + 128;
      *(void *)(a1 + 104) = a1 + 128;
      *(void *)(a1 + 112) = a1 + 128;
      *(void *)(a1 + 120) = 6;
      geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>(a1 + 96, *(long long **)(a2 + 96), *(long long **)(a2 + 104));
      uint64_t v15 = *(void *)(a2 + 1856);
      *(void *)(a1 + 1861) = *(void *)(a2 + 1861);
      *(void *)(a1 + 1856) = v15;
      *(unsigned char *)a1 = 1;
    }
  }
  else if (*(unsigned char *)a1)
  {
    long double v9 = *(void **)(a1 + 96);
    long double v10 = *(void **)(a1 + 104);
    if (v9 != v10)
    {
      do
      {
        long double v11 = (void *)v9[31];
        if (v11 != (void *)v9[33]) {
          free(v11);
        }
        v9 += 36;
      }
      while (v9 != v10);
      long double v9 = *(void **)(a1 + 96);
    }
    if (v9 != *(void **)(a1 + 112)) {
      free(v9);
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

{
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  long long v8;
  uint64_t v9;
  long long v10;
  uint64_t v11;
  long long *v12;
  long long *v13;
  uint64_t v14;
  uint64_t v15;
  long long *v17;
  uint64_t v18;
  _OWORD *v19;
  uint64_t v20;
  uint64_t v21;
  long long v22;
  uint64_t v23;
  long long v24;
  long long v25;
  long long v26;
  long long v27;
  long long v28;
  long long v29;
  long long v30;
  long long v31;
  long long v32;
  unsigned char *v33;
  char *v34;
  char *v35;
  char *v36;
  unint64_t v37;
  unint64_t v38;
  long long *v39;
  _OWORD *v40;
  unint64_t v41;
  long long v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t *v45;
  void *v46;
  uint64_t v47;
  char v48;

  if (*(unsigned char *)a2)
  {
    if (*(unsigned char *)a1)
    {
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
      *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
      *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
      *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
      *(void *)(a1 + 16) = *(void *)(a2 + 16);
      *(void *)(a1 + 24) = *(void *)(a2 + 24);
      *(void *)(a1 + 32) = *(void *)(a2 + 32);
      *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
      *(void *)(a1 + 64) = *(void *)(a2 + 64);
      *(void *)(a1 + 72) = *(void *)(a2 + 72);
      *(void *)(a1 + 80) = *(void *)(a2 + 80);
      *(void *)(a1 + 88) = *(void *)(a2 + 88);
      if (a1 != a2) {
        geo::small_vector_base<md::mun::PhotoInfo>::move(a1 + 96, (uint64_t *)(a2 + 96), a1 + 128);
      }
      uint64_t v4 = *(void *)(a2 + 1856);
      *(void *)(a1 + 1861) = *(void *)(a2 + 1861);
      *(void *)(a1 + 1856) = v4;
      return a1;
    }
    *(void *)(a1 + 8) = *(void *)(a2 + 8);
    double v8 = *(_OWORD *)(a2 + 16);
    *(void *)(a1 + 32) = *(void *)(a2 + 32);
    *(_OWORD *)(a1 + 16) = v8;
    long double v9 = *(void *)(a2 + 40);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    *(void *)(a1 + 40) = v9;
    *(void *)(a1 + 52) = *(void *)(a2 + 52);
    long double v10 = *(_OWORD *)(a2 + 80);
    *(_OWORD *)(a1 + 64) = *(_OWORD *)(a2 + 64);
    *(_OWORD *)(a1 + 80) = v10;
    long double v11 = a1 + 128;
    *(void *)(a1 + 96) = a1 + 128;
    long long v12 = *(long long **)(a2 + 96);
    *(void *)(a1 + 112) = a1 + 128;
    uint64_t v13 = *(long long **)(a2 + 112);
    *(void *)(a1 + 120) = *(void *)(a2 + 120);
    *(void *)(a1 + 104) = a1 + 128;
    if (v12 != v13)
    {
      long long v14 = *(void *)(a2 + 104);
      *(void *)(a1 + 96) = v12;
      *(void *)(a1 + 104) = v14;
      *(_OWORD *)(a2 + 96) = 0u;
      *(_OWORD *)(a2 + 112) = 0u;
LABEL_14:
      uint64_t v15 = *(void *)(a2 + 1856);
      *(void *)(a1 + 1861) = *(void *)(a2 + 1861);
      *(void *)(a1 + 1856) = v15;
      *(unsigned char *)a1 = 1;
      return a1;
    }
    *(void *)(a1 + 104) = v11 + *(void *)(a2 + 104) - (void)v12;
    double v17 = *(long long **)(a2 + 104);
    if (v12 == v17) {
      goto LABEL_14;
    }
    long double v18 = 0;
    long double v19 = (_OWORD *)(a1 + 424);
    double v20 = a1 + 408;
    while (1)
    {
      int v22 = *v12;
      *(void *)(v11 + 16) = *((void *)v12 + 2);
      *(_OWORD *)long double v11 = v22;
      signed int v23 = *((void *)v12 + 3);
      *(_DWORD *)(v11 + 32) = *((_DWORD *)v12 + 8);
      *(void *)(v11 + 24) = v23;
      *(void *)(v11 + 36) = *(void *)((char *)v12 + 36);
      int v24 = *(long long *)((char *)v12 + 44);
      unsigned int v25 = *(long long *)((char *)v12 + 60);
      signed int v26 = *(long long *)((char *)v12 + 76);
      *(_OWORD *)(v11 + 92) = *(long long *)((char *)v12 + 92);
      *(_OWORD *)(v11 + 76) = v26;
      *(_OWORD *)(v11 + 60) = v25;
      *(_OWORD *)(v11 + 44) = v24;
      uint64_t v27 = *(long long *)((char *)v12 + 108);
      int v28 = *(long long *)((char *)v12 + 124);
      uint64_t v29 = *(long long *)((char *)v12 + 140);
      *(_OWORD *)(v11 + 156) = *(long long *)((char *)v12 + 156);
      *(_OWORD *)(v11 + 140) = v29;
      *(_OWORD *)(v11 + 124) = v28;
      *(_OWORD *)(v11 + 108) = v27;
      unint64_t v30 = *(long long *)((char *)v12 + 172);
      uint64_t v31 = *(long long *)((char *)v12 + 188);
      signed int v32 = *(long long *)((char *)v12 + 204);
      *(_OWORD *)(v11 + 220) = *(long long *)((char *)v12 + 220);
      *(_OWORD *)(v11 + 204) = v32;
      *(_OWORD *)(v11 + 188) = v31;
      *(_OWORD *)(v11 + 172) = v30;
      unint64_t v33 = (unsigned char *)(v11 + 280);
      *(void *)(v11 + 248) = v11 + 280;
      unsigned int v34 = (char *)*((void *)v12 + 31);
      *(unsigned char *)(v11 + 240) = *((unsigned char *)v12 + 240);
      *(void *)(v11 + 264) = v11 + 280;
      signed int v35 = (char *)*((void *)v12 + 33);
      *(void *)(v11 + 272) = *((void *)v12 + 34);
      *(_DWORD *)(v11 + 236) = *((_DWORD *)v12 + 59);
      *(void *)(v11 + 256) = v11 + 280;
      if (v34 == v35)
      {
        *(void *)(v11 + 256) = &v33[*((void *)v12 + 32) - (void)v34];
        uint64_t v36 = (char *)*((void *)v12 + 32);
        if (v34 != v36)
        {
          uint64_t v37 = v36 - v34;
          if ((unint64_t)(v36 - v34) >= 8 && (unint64_t)(a1 + 408 + 288 * v18 - (void)v34) >= 0x20)
          {
            if (v37 < 0x20)
            {
              unint64_t v38 = 0;
              goto LABEL_34;
            }
            unint64_t v38 = v37 & 0xFFFFFFFFFFFFFFE0;
            size_t v39 = (long long *)(v34 + 16);
            size_t v40 = v19;
            size_t v41 = v37 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              uint64_t v42 = *v39;
              *(v40 - 1) = *(v39 - 1);
              *size_t v40 = v42;
              v39 += 2;
              v40 += 2;
              v41 -= 32;
            }
            while (v41);
            if (v37 == v38) {
              goto LABEL_23;
            }
            if ((v37 & 0x18) != 0)
            {
LABEL_34:
              size_t v43 = v37 & 0xFFFFFFFFFFFFFFF8;
              v33 += v37 & 0xFFFFFFFFFFFFFFF8;
              uint64_t v44 = v38 - (v37 & 0xFFFFFFFFFFFFFFF8);
              uint64_t v45 = (uint64_t *)&v34[v38];
              unint64_t v46 = (void *)(v20 + v38);
              do
              {
                uint8x8_t v47 = *v45++;
                *v46++ = v47;
                v44 += 8;
              }
              while (v44);
              if (v37 == v43) {
                goto LABEL_23;
              }
              v34 += v43;
            }
            else
            {
              v34 += v38;
              v33 += v38;
            }
          }
          do
          {
            uint64_t v48 = *v34++;
            *v33++ = v48;
          }
          while (v34 != v36);
        }
      }
      else
      {
        long double v21 = *((void *)v12 + 32);
        *(void *)(v11 + 248) = v34;
        *(void *)(v11 + 256) = v21;
        *(long long *)((char *)v12 + 248) = 0uLL;
        *(long long *)((char *)v12 + 264) = 0uLL;
      }
LABEL_23:
      v11 += 288;
      v12 += 18;
      ++v18;
      v19 += 18;
      v20 += 288;
      if (v12 == v17) {
        goto LABEL_14;
      }
    }
  }
  if (*(unsigned char *)a1)
  {
    uint64_t v5 = *(void **)(a1 + 96);
    unint64_t v6 = *(void **)(a1 + 104);
    if (v5 != v6)
    {
      do
      {
        uint8x8_t v7 = (void *)v5[31];
        if (v7 != (void *)v5[33]) {
          free(v7);
        }
        v5 += 36;
      }
      while (v5 != v6);
      uint64_t v5 = *(void **)(a1 + 96);
    }
    if (v5 != *(void **)(a1 + 112)) {
      free(v5);
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void md::mun::MuninMetadataContainer::activePoint(md::mun::MuninMetadataContainer *this, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = (std::mutex *)(a2 + 512);
  std::mutex::lock((std::mutex *)(a2 + 512));
  int8x8_t v7 = *(int8x8_t *)(a2 + 608);
  if (!*(void *)&v7) {
    goto LABEL_38;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    unint64_t v9 = a3;
    if (*(void *)&v7 <= a3) {
      unint64_t v9 = a3 % *(void *)&v7;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v7 - 1) & a3;
  }
  long double v10 = *(void **)(*(void *)(a2 + 600) + 8 * v9);
  if (!v10) {
    goto LABEL_38;
  }
  long double v11 = (void *)*v10;
  if (!*v10) {
    goto LABEL_38;
  }
  if (v8.u32[0] < 2uLL)
  {
    uint64_t v12 = *(void *)&v7 - 1;
    while (1)
    {
      uint64_t v14 = v11[1];
      if (v14 == a3)
      {
        if (v11[2] == a3) {
          goto LABEL_22;
        }
      }
      else if ((v14 & v12) != v9)
      {
        goto LABEL_38;
      }
      long double v11 = (void *)*v11;
      if (!v11) {
        goto LABEL_38;
      }
    }
  }
  while (1)
  {
    unint64_t v13 = v11[1];
    if (v13 == a3) {
      break;
    }
    if (v13 >= *(void *)&v7) {
      v13 %= *(void *)&v7;
    }
    if (v13 != v9) {
      goto LABEL_38;
    }
LABEL_11:
    long double v11 = (void *)*v11;
    if (!v11) {
      goto LABEL_38;
    }
  }
  if (v11[2] != a3) {
    goto LABEL_11;
  }
LABEL_22:
  uint64_t v15 = (char *)v11[3];
  uint64_t v16 = (char *)operator new(0x768uLL);
  *(void *)uint64_t v16 = 0;
  *((void *)v16 + 1) = 0;
  *((_OWORD *)v16 + 1) = *((_OWORD *)v15 + 1);
  long long v17 = *((_OWORD *)v15 + 2);
  *((void *)v16 + 6) = *((void *)v15 + 6);
  *((_OWORD *)v16 + 2) = v17;
  int v18 = *((_DWORD *)v15 + 16);
  *((void *)v16 + 7) = *((void *)v15 + 7);
  *((_DWORD *)v16 + 16) = v18;
  *(void *)(v16 + 68) = *(void *)(v15 + 68);
  long long v19 = *((_OWORD *)v15 + 5);
  long long v20 = *((_OWORD *)v15 + 6);
  *((void *)v16 + 14) = v16 + 144;
  *((_OWORD *)v16 + 5) = v19;
  *((_OWORD *)v16 + 6) = v20;
  *((void *)v16 + 15) = v16 + 144;
  *((void *)v16 + 16) = v16 + 144;
  *((void *)v16 + 17) = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)(v16 + 112), *((long long **)v15 + 14), *((long long **)v15 + 15));
  long double v21 = (char *)(a2 + 576);
  uint64_t v22 = *((void *)v15 + 234);
  *(void *)(v16 + 1877) = *(void *)(v15 + 1877);
  *((void *)v16 + 234) = v22;
  *((void *)v16 + 236) = *((void *)v15 + 236);
  uint64_t v23 = *(void *)(a2 + 576);
  *(void *)(v23 + 8) = v16;
  *(void *)(a2 + 576) = v16;
  *(void *)uint64_t v16 = v23;
  *((void *)v16 + 1) = a2 + 576;
  uint64_t v24 = *(void *)(a2 + 592);
  *(void *)(a2 + 592) = v24 + 1;
  unsigned int v25 = *(char **)(a2 + 640);
  if (v25 == v15)
  {
    signed int v26 = (char *)*((void *)v15 + 1);
    goto LABEL_26;
  }
  signed int v26 = v16;
  if (v25 == v21) {
LABEL_26:
  }
    *(void *)(a2 + 640) = v26;
  uint64_t v27 = *(void *)v15;
  *(void *)(v27 + 8) = *((void *)v15 + 1);
  **((void **)v15 + 1) = v27;
  *(void *)(a2 + 592) = v24;
  int v28 = (void *)*((void *)v15 + 14);
  uint64_t v29 = (void *)*((void *)v15 + 15);
  if (v28 != v29)
  {
    do
    {
      unint64_t v30 = (void *)v28[31];
      if (v30 != (void *)v28[33]) {
        free(v30);
      }
      v28 += 36;
    }
    while (v28 != v29);
    int v28 = (void *)*((void *)v15 + 14);
  }
  if (v28 != *((void **)v15 + 16)) {
    free(v28);
  }
  operator delete(v15);
  void v11[3] = v16;
  if (v21 == v16)
  {
LABEL_38:
    *(unsigned char *)this = 0;
    goto LABEL_39;
  }
  long long v37 = *((_OWORD *)v16 + 2);
  uint64_t v41 = *(void *)(v16 + 68);
  long long v31 = *((_OWORD *)v16 + 6);
  long long v42 = *((_OWORD *)v16 + 5);
  uint64_t v36 = *((void *)v16 + 3);
  uint64_t v32 = *((void *)v16 + 7);
  uint64_t v38 = *((void *)v16 + 6);
  uint64_t v39 = v32;
  int v40 = *((_DWORD *)v16 + 16);
  long long v43 = v31;
  uint64_t v44 = v48;
  uint64_t v45 = v48;
  unint64_t v46 = v48;
  uint64_t v47 = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)&v44, *((long long **)v16 + 14), *((long long **)v16 + 15));
  *(void *)((char *)v49 + 5) = *(void *)(v16 + 1877);
  v49[0] = *((void *)v16 + 234);
  geo::optional<md::mun::CollectionPoint>::optional((uint64_t)this, (uint64_t)&v36);
  unint64_t v33 = v44;
  unsigned int v34 = v45;
  if (v44 != v45)
  {
    do
    {
      signed int v35 = (void *)v33[31];
      if (v35 != (void *)v33[33]) {
        free(v35);
      }
      v33 += 36;
    }
    while (v33 != v34);
    unint64_t v33 = v44;
  }
  if (v33 != (void *)v46) {
    free(v33);
  }
LABEL_39:
  std::mutex::unlock(v6);
}

void sub_1A214F9CC(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void md::mun::CollectionPoint::~CollectionPoint(md::mun::CollectionPoint *this)
{
  uint64_t v2 = (void *)*((void *)this + 11);
  uint64_t v3 = (void *)*((void *)this + 12);
  if (v2 != v3)
  {
    do
    {
      uint64_t v4 = (void *)v2[31];
      if (v4 != (void *)v2[33]) {
        free(v4);
      }
      v2 += 36;
    }
    while (v2 != v3);
    uint64_t v2 = (void *)*((void *)this + 11);
  }
  if (v2 != *((void **)this + 13)) {
    free(v2);
  }
}

char *std::vector<md::mun::CollectionPoint>::__push_back_slow_path<md::mun::CollectionPoint const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0x63FB9AEB1FDCD759 * ((a1[1] - *a1) >> 3);
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) > 0x2328A701194538) {
    abort();
  }
  if (0xC7F735D63FB9AEB2 * ((a1[2] - *a1) >> 3) > v3) {
    unint64_t v3 = 0xC7F735D63FB9AEB2 * ((a1[2] - *a1) >> 3);
  }
  if ((unint64_t)(0x63FB9AEB1FDCD759 * ((a1[2] - *a1) >> 3)) >= 0x119453808CA29CLL) {
    unint64_t v6 = 0x2328A701194538;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x2328A701194538) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int8x8_t v7 = (char *)operator new(1864 * v6);
  }
  else
  {
    int8x8_t v7 = 0;
  }
  long double v21 = &v7[1864 * v2];
  uint64_t v22 = &v7[1864 * v6];
  *(void *)long double v21 = *(void *)a2;
  *(_OWORD *)(v21 + 8) = *(_OWORD *)(a2 + 8);
  uint64_t v8 = *(void *)(a2 + 32);
  *((void *)v21 + 3) = *(void *)(a2 + 24);
  *((void *)v21 + 4) = v8;
  *((_DWORD *)v21 + 10) = *(_DWORD *)(a2 + 40);
  *(void *)(v21 + 44) = *(void *)(a2 + 44);
  long long v9 = *(_OWORD *)(a2 + 56);
  long long v10 = *(_OWORD *)(a2 + 72);
  *(int64x2_t *)(v21 + 88) = vdupq_n_s64((unint64_t)(v21 + 120));
  *(_OWORD *)(v21 + 56) = v9;
  *(_OWORD *)(v21 + 72) = v10;
  *((void *)v21 + 13) = v21 + 120;
  *((void *)v21 + 14) = 6;
  geo::small_vector_base<md::mun::PhotoInfo>::append<md::mun::PhotoInfo const*>((uint64_t)(v21 + 88), *(long long **)(a2 + 88), *(long long **)(a2 + 96));
  *((void *)v21 + 231) = *(void *)(a2 + 1848);
  *(void *)(v21 + 1853) = *(void *)(a2 + 1853);
  uint64_t v11 = (uint64_t)v21;
  uint64_t v12 = v21 + 1864;
  uint64_t v14 = (char *)*a1;
  unint64_t v13 = (char *)a1[1];
  if (v13 == (char *)*a1)
  {
    *a1 = (uint64_t)v21;
    a1[1] = (uint64_t)v12;
    a1[2] = (uint64_t)v22;
  }
  else
  {
    do
    {
      v13 -= 1864;
      uint64_t v11 = std::construct_at[abi:nn180100]<md::mun::CollectionPoint,md::mun::CollectionPoint,md::mun::CollectionPoint*>(v11 - 1864, (uint64_t)v13);
    }
    while (v13 != v14);
    unint64_t v13 = (char *)*a1;
    uint64_t v15 = (char *)a1[1];
    *a1 = v11;
    a1[1] = (uint64_t)v12;
    a1[2] = (uint64_t)v22;
    if (v15 != v13)
    {
      do
      {
        uint64_t v16 = v15 - 1864;
        long long v17 = (void *)*((void *)v15 - 222);
        int v18 = (void *)*((void *)v15 - 221);
        if (v17 != v18)
        {
          do
          {
            long long v19 = (void *)v17[31];
            if (v19 != (void *)v17[33]) {
              free(v19);
            }
            v17 += 36;
          }
          while (v17 != v18);
          long long v17 = (void *)*((void *)v15 - 222);
        }
        if (v17 != *((void **)v15 - 220)) {
          free(v17);
        }
        v15 -= 1864;
      }
      while (v16 != v13);
    }
  }
  if (v13) {
    operator delete(v13);
  }
  return v21 + 1864;
}

void sub_1A214FCA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::__split_buffer<md::mun::CollectionPoint>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::mun::MuninMetadataContainer::navigationGraphAccessor(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (pthread_rwlock_t *)(a1 + 296);
  uint64_t v5 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 296));
  if (v5) {
    geo::read_write_lock::logFailure(v5, (uint64_t)"read lock", v6);
  }
  if (*(void *)(a1 + 496))
  {
    uint64_t v10 = *(void *)(a1 + 496);
    uint64_t v7 = *(void *)(a2 + 24);
    if (!v7)
    {
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
      return;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v7 + 48))(v7, &v10);
  }
  uint64_t v8 = (geo::read_write_lock *)pthread_rwlock_unlock(v4);
  if (v8) {
    geo::read_write_lock::logFailure(v8, (uint64_t)"unlock", v9);
  }
}

void sub_1A214FD6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, pthread_rwlock_t *a9)
{
}

uint64_t *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelSpacingDedupingGroup::prepareForCollision(md::LabelManager *)::$_1 &,md::LabelBase **>(uint64_t *result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v3 = *a2;
  uint64_t v4 = *result;
  int v5 = *(unsigned __int8 *)(*a2 + 820);
  int v6 = *(unsigned __int8 *)(*result + 820);
  if ((v5 == 2) == (v6 == 2))
  {
    if (*(float *)(v3 + 668) >= *(float *)(v4 + 668)) {
      goto LABEL_3;
    }
LABEL_7:
    BOOL v8 = v5 == 2;
    uint64_t v9 = *a3;
    if ((v8 ^ (*(unsigned char *)(*a3 + 820) == 2)))
    {
      if (*(unsigned char *)(*a3 + 820) != 2) {
        goto LABEL_9;
      }
    }
    else if (*(float *)(v9 + 668) >= *(float *)(v3 + 668))
    {
LABEL_9:
      *__n128 result = v3;
      *a2 = v4;
      uint64_t v10 = *a3;
      if ((v6 == 2) != (*(unsigned char *)(*a3 + 820) == 2))
      {
        if (*(unsigned char *)(*a3 + 820) != 2) {
          return result;
        }
      }
      else if (*(float *)(v10 + 668) >= *(float *)(v4 + 668))
      {
        return result;
      }
      *a2 = v10;
      *a3 = v4;
      return result;
    }
    *__n128 result = v9;
    *a3 = v4;
    return result;
  }
  if (v5 == 2) {
    goto LABEL_7;
  }
LABEL_3:
  uint64_t v7 = *a3;
  if ((v5 == 2) != (*(unsigned char *)(*a3 + 820) == 2))
  {
    if (*(unsigned char *)(*a3 + 820) != 2) {
      return result;
    }
  }
  else if (*(float *)(v7 + 668) >= *(float *)(v3 + 668))
  {
    return result;
  }
  *a2 = v7;
  *a3 = v3;
  uint64_t v11 = *a2;
  uint64_t v12 = *result;
  int v13 = *(unsigned __int8 *)(*a2 + 820);
  if ((v13 == 2) != (*(unsigned char *)(*result + 820) == 2))
  {
    if (v13 == 2) {
      goto LABEL_21;
    }
  }
  else if (*(float *)(v11 + 668) < *(float *)(v12 + 668))
  {
LABEL_21:
    *__n128 result = v11;
    *a2 = v12;
  }
  return result;
}

uint64_t *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelSpacingDedupingGroup::prepareForCollision(md::LabelManager *)::$_1 &,md::LabelBase **,0>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelSpacingDedupingGroup::prepareForCollision(md::LabelManager *)::$_1 &,md::LabelBase **>(a1, a2, a3);
  uint64_t v11 = *a4;
  uint64_t v12 = *a3;
  int v13 = *(unsigned __int8 *)(*a4 + 820);
  if ((v13 == 2) != (*(unsigned char *)(*a3 + 820) == 2))
  {
    if (v13 != 2) {
      goto LABEL_14;
    }
  }
  else if (*(float *)(v11 + 668) >= *(float *)(v12 + 668))
  {
    goto LABEL_14;
  }
  *a3 = v11;
  *a4 = v12;
  uint64_t v14 = *a3;
  uint64_t v15 = *a2;
  int v16 = *(unsigned __int8 *)(*a3 + 820);
  if ((v16 == 2) != (*(unsigned char *)(*a2 + 820) == 2))
  {
    if (v16 != 2) {
      goto LABEL_14;
    }
  }
  else if (*(float *)(v14 + 668) >= *(float *)(v15 + 668))
  {
    goto LABEL_14;
  }
  *a2 = v14;
  *a3 = v15;
  uint64_t v17 = *a2;
  uint64_t v18 = *a1;
  int v19 = *(unsigned __int8 *)(*a2 + 820);
  if ((v19 == 2) == (*(unsigned char *)(*a1 + 820) == 2))
  {
    if (*(float *)(v17 + 668) >= *(float *)(v18 + 668)) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (v19 == 2)
  {
LABEL_13:
    *a1 = v17;
    *a2 = v18;
  }
LABEL_14:
  uint64_t v20 = *a5;
  uint64_t v21 = *a4;
  int v22 = *(unsigned __int8 *)(*a5 + 820);
  if ((v22 == 2) != (*(unsigned char *)(*a4 + 820) == 2))
  {
    if (v22 != 2) {
      return result;
    }
  }
  else if (*(float *)(v20 + 668) >= *(float *)(v21 + 668))
  {
    return result;
  }
  *a4 = v20;
  *a5 = v21;
  uint64_t v23 = *a4;
  uint64_t v24 = *a3;
  int v25 = *(unsigned __int8 *)(*a4 + 820);
  if ((v25 == 2) != (*(unsigned char *)(*a3 + 820) == 2))
  {
    if (v25 != 2) {
      return result;
    }
  }
  else if (*(float *)(v23 + 668) >= *(float *)(v24 + 668))
  {
    return result;
  }
  *a3 = v23;
  *a4 = v24;
  uint64_t v26 = *a3;
  uint64_t v27 = *a2;
  int v28 = *(unsigned __int8 *)(*a3 + 820);
  if ((v28 == 2) != (*(unsigned char *)(*a2 + 820) == 2))
  {
    if (v28 != 2) {
      return result;
    }
  }
  else if (*(float *)(v26 + 668) >= *(float *)(v27 + 668))
  {
    return result;
  }
  *a2 = v26;
  *a3 = v27;
  uint64_t v29 = *a2;
  uint64_t v30 = *a1;
  int v31 = *(unsigned __int8 *)(*a2 + 820);
  if ((v31 == 2) == (*(unsigned char *)(*a1 + 820) == 2))
  {
    if (*(float *)(v29 + 668) >= *(float *)(v30 + 668)) {
      return result;
    }
    goto LABEL_30;
  }
  if (v31 == 2)
  {
LABEL_30:
    *a1 = v29;
    *a2 = v30;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelSpacingDedupingGroup::prepareForCollision(md::LabelManager *)::$_1 &,md::LabelBase **>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      int v8 = *(unsigned __int8 *)(v6 + 820);
      if ((v8 == 2) != (*(unsigned char *)(*a1 + 820) == 2))
      {
        if (v8 != 2) {
          return result;
        }
      }
      else if (*(float *)(v6 + 668) >= *(float *)(v7 + 668))
      {
        return result;
      }
      *a1 = v6;
      *(a2 - 1) = v7;
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelSpacingDedupingGroup::prepareForCollision(md::LabelManager *)::$_1 &,md::LabelBase **>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      uint64_t v23 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelSpacingDedupingGroup::prepareForCollision(md::LabelManager *)::$_1 &,md::LabelBase **>(a1, a1 + 1, a1 + 2);
      uint64_t v24 = *(a2 - 1);
      uint64_t v25 = a1[2];
      int v26 = *(unsigned __int8 *)(v24 + 820);
      if ((v26 == 2) != (*(unsigned char *)(v25 + 820) == 2))
      {
        if (v26 != 2) {
          return 1;
        }
      }
      else if (*(float *)(v24 + 668) >= *(float *)(v25 + 668))
      {
        return 1;
      }
      uint64_t *v23 = v24;
      *(a2 - 1) = v25;
      uint64_t v27 = *v23;
      uint64_t v28 = a1[1];
      int v29 = *(unsigned __int8 *)(*v23 + 820);
      if ((v29 == 2) != (*(unsigned char *)(v28 + 820) == 2))
      {
        if (v29 != 2) {
          return 1;
        }
        a1[1] = v27;
        a1[2] = v28;
        uint64_t v30 = *a1;
        if (*(unsigned char *)(*a1 + 820) != 2) {
          goto LABEL_49;
        }
        float v31 = *(float *)(v27 + 668);
      }
      else
      {
        float v31 = *(float *)(v27 + 668);
        if (v31 >= *(float *)(v28 + 668)) {
          return 1;
        }
        a1[1] = v27;
        a1[2] = v28;
        uint64_t v30 = *a1;
        if ((v29 == 2) != (*(unsigned char *)(*a1 + 820) == 2))
        {
          if (v29 != 2) {
            return 1;
          }
          goto LABEL_49;
        }
      }
      if (v31 >= *(float *)(v30 + 668)) {
        return 1;
      }
LABEL_49:
      *a1 = v27;
      a1[1] = v30;
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelSpacingDedupingGroup::prepareForCollision(md::LabelManager *)::$_1 &,md::LabelBase **,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v9 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelSpacingDedupingGroup::prepareForCollision(md::LabelManager *)::$_1 &,md::LabelBase **>(a1, a1 + 1, a1 + 2);
      uint64_t v10 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v11 = 0;
      int v12 = 0;
      break;
  }
  while (1)
  {
    uint64_t v14 = *v10;
    uint64_t v15 = *v9;
    char v16 = *(unsigned char *)(*v10 + 820);
    if ((v16 == 2) != (*(unsigned char *)(*v9 + 820) == 2))
    {
      if (v16 != 2) {
        goto LABEL_9;
      }
      *uint64_t v10 = v15;
      int v13 = a1;
      if (v9 != a1) {
        goto LABEL_17;
      }
    }
    else
    {
      float v17 = *(float *)(v14 + 668);
      if (v17 >= *(float *)(v15 + 668)) {
        goto LABEL_9;
      }
      *uint64_t v10 = v15;
      int v13 = a1;
      if (v9 != a1)
      {
        uint64_t v18 = v11;
        if (v16 == 2)
        {
LABEL_17:
          uint64_t v19 = v11;
          while (1)
          {
            uint64_t v20 = *(uint64_t *)((char *)a1 + v19 + 8);
            if (*(unsigned char *)(v20 + 820) == 2 && *(float *)(v14 + 668) >= *(float *)(v20 + 668)) {
              break;
            }
            *(uint64_t *)((char *)a1 + v19 + 16) = v20;
            v19 -= 8;
            if (v19 == -16) {
              goto LABEL_7;
            }
          }
          uint64_t v21 = (char *)a1 + v19;
        }
        else
        {
          while (1)
          {
            uint64_t v22 = *(uint64_t *)((char *)a1 + v18 + 8);
            if (*(unsigned char *)(v22 + 820) == 2)
            {
              int v13 = v9;
              goto LABEL_8;
            }
            if (v17 >= *(float *)(v22 + 668)) {
              break;
            }
            --v9;
            *(uint64_t *)((char *)a1 + v18 + 16) = v22;
            v18 -= 8;
            if (v18 == -16)
            {
LABEL_7:
              int v13 = a1;
              goto LABEL_8;
            }
          }
          uint64_t v21 = (char *)a1 + v18;
        }
        int v13 = (uint64_t *)(v21 + 16);
      }
    }
LABEL_8:
    *int v13 = v14;
    if (++v12 == 8) {
      return v10 + 1 == a2;
    }
LABEL_9:
    uint64_t v9 = v10;
    v11 += 8;
    if (++v10 == a2) {
      return 1;
    }
  }
}

void md::LabelSpacingDedupingGroup::~LabelSpacingDedupingGroup(md::LabelSpacingDedupingGroup *this)
{
  *(void *)this = &unk_1EF5467B0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF539178;
  uint64_t v3 = *((void *)this + 5);
  if (v3)
  {
    *((void *)this + 6) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v3, *((void *)this + 7) - v3);
  }
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v4, *((void *)this + 3) - v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  uint64_t v4;

  *(void *)this = &unk_1EF5467B0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v2) {
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF539178;
  uint64_t v3 = *((void *)this + 5);
  if (v3)
  {
    *((void *)this + 6) = v3;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v3, *((void *)this + 7) - v3);
  }
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    *((void *)this + 2) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 4) + 40))(*((void *)this + 4), v4, *((void *)this + 3) - v4);
  }
}

void sub_1A21507EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A215091C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2150A4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2150BB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  uint64_t v10 = v9;

  a9.super_class = (Class)VKNotificationObserver;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_1A2150C50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2150DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_1A2151860(_Unwind_Exception *a1)
{
  (*(void (**)(void *, uint64_t, uint64_t))(*v1[14] + 40))(v1[14], v2, 64);

  _Unwind_Resume(a1);
}

void sub_1A21519A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A2151A58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A2151B0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A2151BC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A2151C74(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf) {
    CFRelease(cf);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A2151DB8(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A2151E1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A2151E68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2151EB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2151EF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2151F40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2151F88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2152030(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21520EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21521B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A21522E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void sub_1A2152378(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A215246C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex::unlock(v10);

  _Unwind_Resume(a1);
}

void sub_1A2152520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)VKIconManager;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

float VKShieldColorsFromHexString(void *a1)
{
  uint64_t v1 = (NSString *)[a1 copy];
  if ([(NSString *)v1 hasPrefix:@"#"])
  {
    uint64_t v2 = [(NSString *)v1 substringFromIndex:1];

    uint64_t v1 = (NSString *)v2;
  }
  if ([(NSString *)v1 length] == 8)
  {
    colorFromStringInRange(v1, (const _NSRange *)6, 2);
    uint64_t v3 = -[NSString substringWithRange:](v1, "substringWithRange:", 0, 6);

    uint64_t v1 = (NSString *)v3;
  }
  float v4 = 0.0;
  if ([(NSString *)v1 length] == 6)
  {
    float v4 = colorFromStringInRange(v1, 0, 2);
    colorFromStringInRange(v1, (const _NSRange *)2, 2);
    colorFromStringInRange(v1, (const _NSRange *)4, 2);
  }

  return v4;
}

void sub_1A215267C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double colorFromStringInRange(NSString *a1, const _NSRange *a2, uint64_t a3)
{
  unsigned int v8 = 0;
  uint64_t v3 = (void *)MEMORY[0x1E4F28FE8];
  float v4 = -[NSString substringWithRange:](a1, "substringWithRange:", a2, a3);
  int v5 = [v3 scannerWithString:v4];

  [v5 scanHexInt:&v8];
  double v6 = (float)((float)v8 * 0.0039216);

  return v6;
}

void sub_1A2152740(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A2152750(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

__CFString *VKSizeGroupToString(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 8) {
    return @"ExtraExtraExtraSmall";
  }
  else {
    return (__CFString *)*((void *)&off_1E5A8FDF8 + a1 - 1);
  }
}

uint64_t md::TrafficUtilities::buildStartOffset(float *a1, float *a2, std::__shared_weak_count **this, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  float v17 = *(float *)(a4 + 8);
  float v18 = *(float *)(a4 + 12) + v17;
  float v19 = floorf(v18);
  float v20 = v18 - v19;
  float v21 = ceilf(v18);
  if ((float)(v21 - v18) < 0.001) {
    float v18 = v21;
  }
  if (v20 >= 0.001) {
    float v22 = v18;
  }
  else {
    float v22 = v19;
  }
  *a1 = geo::codec::roadFeatureMapOriginalToEvaluatedIndex(this, (const GeoCodecsRoadFeature *)*(unsigned int *)(a4 + 4), *(float *)(a4 + 8));
  float v23 = geo::codec::roadFeatureMapOriginalToEvaluatedIndex(this, (const GeoCodecsRoadFeature *)*(unsigned int *)(a4 + 4), v22);
  *a2 = v23;
  float v25 = *a1;
  if (*a1 < 0.0 || v23 < 0.0)
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v28 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      uint64_t v32 = GEOStringFromTileKey();
      double v33 = *(float *)(a4 + 8);
      double v34 = *(float *)(a4 + 12);
      int v127 = 138413826;
      uint64_t v128 = v32;
      __int16 v129 = 2048;
      double v130 = v17;
      __int16 v131 = 2048;
      double v132 = v22;
      __int16 v133 = 2048;
      uint64_t v134 = a5;
      __int16 v135 = 2048;
      uint64_t v136 = a6;
      __int16 v137 = 2048;
      double v138 = v33;
      __int16 v139 = 2048;
      double v140 = v34;
      _os_log_impl(&dword_1A1780000, v28, OS_LOG_TYPE_INFO, "Skeleton traffic tile %@ implicates bad section (start: %f, end: %f, valid: %lu,%lu, skeleton record: %f,%f)", (uint8_t *)&v127, 0x48u);
    }
    goto LABEL_49;
  }
  unint64_t v26 = a6 - 1;
  if (!a6) {
    unint64_t v26 = 0;
  }
  if (v25 > (float)v26 || v23 > (float)v26)
  {
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v28 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
    {
      int v29 = GEOStringFromTileKey();
      double v30 = *a1;
      double v31 = *a2;
      int v127 = 138413058;
      uint64_t v128 = v29;
      __int16 v129 = 2048;
      double v130 = v30;
      __int16 v131 = 2048;
      double v132 = v31;
      __int16 v133 = 2048;
      uint64_t v134 = a6;
      _os_log_impl(&dword_1A1780000, v28, OS_LOG_TYPE_INFO, "Skeleton traffic tile %@ implicates flow start/end offsets out of range  start: %f end:%f  section leuint64_t n = %ld", (uint8_t *)&v127, 0x2Au);
    }
LABEL_49:

    return 0;
  }
  if (v25 == v23) {
    return 0;
  }
  float v36 = *(float *)(a7 + 8);
  if (v36 != 0.0 || *(float *)(a7 + 12) != 1.0)
  {
    float v37 = *(float *)(a4 + 28);
    float v38 = *(float *)(a4 + 32) - v37;
    if (v38 >= 1.0)
    {
      float v40 = *(float *)(a7 + 12);
    }
    else
    {
      if (v38 <= 0.0)
      {
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        uint64_t v28 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
        {
          unsigned int v71 = GEOStringFromTileKey();
          double v72 = *(float *)(a4 + 28);
          double v73 = *(float *)(a4 + 32);
          int v127 = 138412802;
          uint64_t v128 = v71;
          __int16 v129 = 2048;
          double v130 = v72;
          __int16 v131 = 2048;
          double v132 = v73;
          _os_log_impl(&dword_1A1780000, v28, OS_LOG_TYPE_INFO, "Skeleton traffic tile %@ implicates inverted road offsets: %f->%f ", (uint8_t *)&v127, 0x20u);
        }
        goto LABEL_49;
      }
      if (v38 <= 0.00000011921) {
        float v39 = 1.0;
      }
      else {
        float v39 = 1.0 / v38;
      }
      float v36 = fminf(fmaxf(v39 * (float)(v36 - v37), 0.0), 1.0);
      float v40 = fminf(fmaxf((float)(*(float *)(a7 + 12) - v37) * v39, 0.0), 1.0);
    }
    if (v36 >= v40) {
      return 0;
    }
    float v41 = fmaxf(v23, v25);
    float v42 = fminf(v23, v25);
    signed int v43 = vcvtms_s32_f32(v42);
    int v44 = vcvtps_s32_f32(v41);
    uint64_t v45 = v43;
    if (v43 >= v44)
    {
      float32x2_t v46 = *(float32x2_t *)(a8 + 8 * v43);
      uint64_t v47 = v44;
      float v49 = 0.0;
      goto LABEL_51;
    }
    float32x2_t v46 = *(float32x2_t *)(a8 + 8 * v43);
    uint64_t v47 = v44;
    unint64_t v48 = v44 - v45;
    float v49 = 0.0;
    uint64_t v50 = v45;
    float32x2_t v51 = *(float32x2_t *)(a8 + 8 * v45);
    if (v48 >= 8)
    {
      v24.i64[1] = *(void *)(a8 + 8 * v45);
      int8x16_t v52 = (int8x16_t)vdupq_lane_s32((int32x2_t)v46, 0);
      unint64_t v53 = v48 & 0xFFFFFFFFFFFFFFF8;
      unint64_t v54 = (_OWORD *)(a8 + 8 * v45 + 40);
      float32x4_t v55 = 0uLL;
      unint64_t v56 = v48 & 0xFFFFFFFFFFFFFFF8;
      float32x4_t v57 = 0uLL;
      do
      {
        uint64_t v58 = (const float *)(v54 - 2);
        float32x4x2_t v142 = vld2q_f32(v58);
        int32x4_t v60 = *(int32x4_t *)v54;
        int8x16_t v59 = *((int8x16_t *)v54 + 1);
        v54 += 4;
        float32x4_t v61 = (float32x4_t)vuzp1q_s32(v60, (int32x4_t)v59);
        float32x4_t v62 = (float32x4_t)vuzp2q_s32(v60, (int32x4_t)v59);
        float32x4_t v63 = vsubq_f32(v142.val[0], (float32x4_t)vextq_s8(v52, (int8x16_t)v142.val[0], 0xCuLL));
        float32x4_t v64 = vsubq_f32(v61, (float32x4_t)vextq_s8((int8x16_t)v142.val[0], (int8x16_t)v61, 0xCuLL));
        float32x4_t v65 = vsubq_f32(v142.val[1], (float32x4_t)vextq_s8(v24, (int8x16_t)v142.val[1], 0xCuLL));
        v142.val[0] = vsubq_f32(v62, (float32x4_t)vextq_s8((int8x16_t)v142.val[1], (int8x16_t)v62, 0xCuLL));
        float32x4_t v55 = vaddq_f32(vsqrtq_f32(vmlaq_f32(vmulq_f32(v63, v63), v65, v65)), v55);
        float32x4_t v57 = vaddq_f32(vsqrtq_f32(vmlaq_f32(vmulq_f32(v64, v64), v142.val[0], v142.val[0])), v57);
        int8x16_t v24 = (int8x16_t)v62;
        int8x16_t v52 = (int8x16_t)v61;
        v56 -= 8;
      }
      while (v56);
      float32x4_t v66 = vaddq_f32(v57, v55);
      float v49 = vaddv_f32((float32x2_t)*(_OWORD *)&vpaddq_f32(v66, v66));
      if (v48 == v53)
      {
LABEL_51:
        float32x2_t v74 = vsub_f32(*(float32x2_t *)(a8 + 8 * ((int)v45 + 1)), v46);
        float32x2_t v75 = vsub_f32(*(float32x2_t *)(a8 + 8 * v47), *(float32x2_t *)(a8 + 8 * (v44 - 1)));
        float v76 = (float)(v49 + (float)(sqrtf(vaddv_f32(vmul_f32(v75, v75))) * (float)(v41 - (float)v44)))
            + (float)(sqrtf(vaddv_f32(vmul_f32(v74, v74))) * (float)((float)(int)v45 - v42));
        float v77 = v76 * v36;
        if (v23 <= v25)
        {
          signed int v84 = vcvtps_s32_f32(v25);
          float v85 = (float)(v25 - ceilf(v25)) + 1.0;
          float32x2_t v86 = vsub_f32(*(float32x2_t *)(a8 + 8 * v84 - 8), *(float32x2_t *)(a8 + 8 * v84));
          float v87 = sqrtf(vaddv_f32(vmul_f32(v86, v86))) * v85;
          if (v87 > v77)
          {
            float v82 = fmaxf(v25 - (float)((float)(v85 * v77) / v87), v23);
            float v83 = v76 * v40;
            goto LABEL_68;
          }
          uint64_t v95 = (float32x2_t *)(a8 + 8 * v84 - 8);
          int v96 = v84 - 1;
          while (1)
          {
            float v97 = (float)v96;
            if (v23 >= (float)v96) {
              break;
            }
            float v98 = v87;
            float32x2_t v99 = *v95;
            float32x2_t v100 = v95[-1];
            --v95;
            float32x2_t v101 = vsub_f32(v100, v99);
            float v102 = sqrtf(vaddv_f32(vmul_f32(v101, v101)));
            float v87 = v102 + v98;
            --v96;
            if ((float)(v102 + v98) > v77)
            {
              float v82 = fmaxf(v97 + (float)((float)(v98 - v77) / v102), v23);
              goto LABEL_65;
            }
          }
        }
        else
        {
          signed int v78 = vcvtms_s32_f32(v25);
          float v79 = (float)(floorf(v25) - v25) + 1.0;
          float32x2_t v80 = vsub_f32(*(float32x2_t *)(a8 + 8 * v78 + 8), *(float32x2_t *)(a8 + 8 * v78));
          float v81 = sqrtf(vaddv_f32(vmul_f32(v80, v80))) * v79;
          if (v81 > v77)
          {
            float v82 = fminf((float)((float)(v79 * v77) / v81) + v25, v23);
            float v83 = v76 * v40;
LABEL_66:
            signed int v103 = vcvtms_s32_f32(v25);
            float v104 = (float)(floorf(v25) - v25) + 1.0;
            float32x2_t v105 = vsub_f32(*(float32x2_t *)(a8 + 8 * v103 + 8), *(float32x2_t *)(a8 + 8 * v103));
            float v106 = sqrtf(vaddv_f32(vmul_f32(v105, v105))) * v104;
            if (v106 <= v83)
            {
              signed int v112 = v103;
              uint64_t v113 = (float32x2_t *)(a8 + 8 * v103 + 16);
              int v114 = v112 + 1;
              while (1)
              {
                float v115 = (float)v114;
                if (v23 <= (float)v114) {
                  break;
                }
                float v116 = v106;
                float32x2_t v117 = vsub_f32(*v113, v113[-1]);
                float v118 = sqrtf(vaddv_f32(vmul_f32(v117, v117)));
                float v106 = v118 + v116;
                ++v113;
                ++v114;
                if ((float)(v118 + v116) > v83)
                {
                  float v23 = fminf((float)((float)(v83 - v116) / v118) + v115, v23);
                  break;
                }
              }
            }
            else
            {
              float v23 = fminf((float)((float)(v104 * v83) / v106) + v25, v23);
            }
LABEL_79:
            *a1 = v82;
            *a2 = v23;
            return 1;
          }
          signed int v88 = v78;
          long long v89 = (float32x2_t *)(a8 + 8 * v78 + 16);
          int v90 = v88 + 1;
          while (1)
          {
            float v91 = (float)v90;
            if (v23 <= (float)v90) {
              break;
            }
            float v92 = v81;
            float32x2_t v93 = vsub_f32(*v89, v89[-1]);
            float v94 = sqrtf(vaddv_f32(vmul_f32(v93, v93)));
            float v81 = v94 + v92;
            ++v89;
            ++v90;
            if ((float)(v94 + v92) > v77)
            {
              float v82 = fminf((float)((float)(v77 - v92) / v94) + v91, v23);
              goto LABEL_65;
            }
          }
        }
        float v82 = v23;
LABEL_65:
        float v83 = v76 * v40;
        if (v23 > v25) {
          goto LABEL_66;
        }
LABEL_68:
        signed int v107 = vcvtps_s32_f32(v25);
        float v108 = (float)(v25 - ceilf(v25)) + 1.0;
        float32x2_t v109 = vsub_f32(*(float32x2_t *)(a8 + 8 * v107 - 8), *(float32x2_t *)(a8 + 8 * v107));
        float v110 = sqrtf(vaddv_f32(vmul_f32(v109, v109))) * v108;
        if (v110 <= v83)
        {
          uint64_t v119 = (float32x2_t *)(a8 + 8 * v107 - 8);
          int v120 = v107 - 1;
          while (1)
          {
            float v121 = (float)v120;
            if (v23 >= (float)v120) {
              break;
            }
            float v122 = v110;
            float32x2_t v123 = *v119;
            float32x2_t v124 = v119[-1];
            --v119;
            float32x2_t v125 = vsub_f32(v124, v123);
            float v126 = sqrtf(vaddv_f32(vmul_f32(v125, v125)));
            float v110 = v126 + v122;
            --v120;
            if ((float)(v126 + v122) > v83)
            {
              float v111 = v121 + (float)((float)(v122 - v83) / v126);
              goto LABEL_78;
            }
          }
        }
        else
        {
          float v111 = v25 - (float)((float)(v108 * v83) / v110);
LABEL_78:
          float v23 = fmaxf(v111, v23);
        }
        goto LABEL_79;
      }
      uint64_t v50 = v53 + v45;
      float32x2_t v51 = (float32x2_t)vextq_s8(v59, v59, 8uLL).u64[0];
    }
    uint64_t v67 = v44 - v50;
    uint64_t v68 = (float32x2_t *)(a8 + 8 * v50 + 8);
    do
    {
      float32x2_t v69 = *v68++;
      float32x2_t v70 = vsub_f32(v69, v51);
      float v49 = sqrtf(vaddv_f32(vmul_f32(v70, v70))) + v49;
      float32x2_t v51 = v69;
      --v67;
    }
    while (v67);
    goto LABEL_51;
  }
  return 1;
}

void sub_1A2152FBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  uint64_t v9 = (uint64_t *)result;
LABEL_2:
  uint64_t v10 = a2 - 1;
  uint64_t v11 = v9;
  while (1)
  {
    uint64_t v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    unint64_t v13 = a2 - v11;
    if (v5 || !v4)
    {
      switch(v13)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v81 = *v11;
          if (*(float *)(*v10 + 8) < *(float *)(*v11 + 8))
          {
            uint64_t *v11 = *v10;
            *uint64_t v10 = v81;
          }
          return result;
        case 3uLL:
          uint64_t v82 = *v11;
          uint64_t v83 = v11[1];
          float v84 = *(float *)(v83 + 8);
          float v85 = *(float *)(*v11 + 8);
          uint64_t v86 = *v10;
          float v87 = *(float *)(*v10 + 8);
          if (v84 >= v85)
          {
            if (v87 < v84)
            {
              v11[1] = v86;
              *uint64_t v10 = v83;
              uint64_t v136 = *v11;
              uint64_t v135 = v11[1];
              if (*(float *)(v135 + 8) < *(float *)(*v11 + 8))
              {
                uint64_t *v11 = v135;
                v11[1] = v136;
              }
            }
          }
          else
          {
            if (v87 >= v84)
            {
              uint64_t *v11 = v83;
              v11[1] = v82;
              if (*(float *)(*v10 + 8) >= v85) {
                return result;
              }
              v11[1] = *v10;
            }
            else
            {
              uint64_t *v11 = v86;
            }
            *uint64_t v10 = v82;
          }
          return result;
        case 4uLL:
          signed int v88 = v11 + 1;
          long long v89 = (uint64_t *)v11[1];
          int v90 = v11 + 2;
          uint64_t v91 = v11[2];
          float v92 = (uint64_t *)*v11;
          float v93 = *((float *)v89 + 2);
          float v94 = *(float *)(*v11 + 8);
          float v95 = *(float *)(v91 + 8);
          if (v93 >= v94)
          {
            if (v95 >= v93) {
              goto LABEL_167;
            }
            uint64_t *v88 = v91;
            *int v90 = (uint64_t)v89;
            int v96 = v11;
            float v97 = (uint64_t **)(v11 + 1);
            BOOL result = (uint64_t)v89;
            if (v95 >= v94) {
              goto LABEL_168;
            }
          }
          else
          {
            int v96 = v11;
            float v97 = (uint64_t **)(v11 + 2);
            BOOL result = *v11;
            if (v95 >= v93)
            {
              uint64_t *v11 = (uint64_t)v89;
              v11[1] = (uint64_t)v92;
              int v96 = v11 + 1;
              float v97 = (uint64_t **)(v11 + 2);
              BOOL result = (uint64_t)v92;
              if (v95 >= v94)
              {
LABEL_167:
                long long v89 = (uint64_t *)v91;
LABEL_168:
                if (*(float *)(*v10 + 8) < *((float *)v89 + 2))
                {
                  *int v90 = *v10;
                  *uint64_t v10 = (uint64_t)v89;
                  uint64_t v140 = *v90;
                  uint64_t v141 = *v88;
                  float v142 = *(float *)(v140 + 8);
                  if (v142 < *(float *)(v141 + 8))
                  {
                    v11[1] = v140;
                    unsigned char v11[2] = v141;
                    uint64_t v143 = *v11;
                    if (v142 < *(float *)(*v11 + 8))
                    {
                      uint64_t *v11 = v140;
                      v11[1] = v143;
                    }
                  }
                }
                return result;
              }
            }
          }
          *int v96 = v91;
          *float v97 = v92;
          long long v89 = (uint64_t *)result;
          goto LABEL_168;
        case 5uLL:
          return (uint64_t)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**,0>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1);
        default:
          JUMPOUT(0);
      }
    }
    if (v12 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v109 = (v13 - 2) >> 1;
        int64_t v110 = v109;
        do
        {
          if (v109 >= v110)
          {
            uint64_t v112 = (2 * v110) | 1;
            uint64_t v113 = &v11[v112];
            if (2 * v110 + 2 < (uint64_t)v13 && *(float *)(*v113 + 8) < *(float *)(v113[1] + 8))
            {
              ++v113;
              uint64_t v112 = 2 * v110 + 2;
            }
            int v114 = &v11[v110];
            uint64_t v115 = *v113;
            uint64_t v116 = *v114;
            float v117 = *(float *)(*v114 + 8);
            if (*(float *)(*v113 + 8) >= v117)
            {
              do
              {
                float v118 = v113;
                *int v114 = v115;
                if (v109 < v112) {
                  break;
                }
                uint64_t v119 = 2 * v112;
                uint64_t v112 = (2 * v112) | 1;
                uint64_t v113 = &v11[v112];
                uint64_t v120 = v119 + 2;
                if (v120 < (uint64_t)v13)
                {
                  BOOL result = *v113;
                  if (*(float *)(*v113 + 8) < *(float *)(v113[1] + 8))
                  {
                    ++v113;
                    uint64_t v112 = v120;
                  }
                }
                uint64_t v115 = *v113;
                int v114 = v118;
              }
              while (*(float *)(*v113 + 8) >= v117);
              *float v118 = v116;
            }
          }
          BOOL v111 = v110-- <= 0;
        }
        while (!v111);
        uint64_t v121 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v122 = 0;
          uint64_t v123 = *v11;
          float32x2_t v124 = v11;
          do
          {
            float32x2_t v125 = v124;
            v124 += v122 + 1;
            uint64_t v126 = 2 * v122;
            uint64_t v122 = (2 * v122) | 1;
            uint64_t v127 = v126 + 2;
            if (v127 < v121 && *(float *)(*v124 + 8) < *(float *)(v124[1] + 8))
            {
              ++v124;
              uint64_t v122 = v127;
            }
            *float32x2_t v125 = *v124;
          }
          while (v122 <= (uint64_t)((unint64_t)(v121 - 2) >> 1));
          if (v124 == --a2)
          {
            *float32x2_t v124 = v123;
          }
          else
          {
            *float32x2_t v124 = *a2;
            *a2 = v123;
            uint64_t v128 = (char *)v124 - (char *)v11 + 8;
            if (v128 >= 9)
            {
              unint64_t v129 = (((unint64_t)v128 >> 3) - 2) >> 1;
              double v130 = &v11[v129];
              uint64_t v131 = *v130;
              uint64_t v132 = *v124;
              float v133 = *(float *)(*v124 + 8);
              if (*(float *)(*v130 + 8) < v133)
              {
                do
                {
                  uint64_t v134 = v130;
                  *float32x2_t v124 = v131;
                  if (!v129) {
                    break;
                  }
                  unint64_t v129 = (v129 - 1) >> 1;
                  double v130 = &v11[v129];
                  uint64_t v131 = *v130;
                  float32x2_t v124 = v134;
                }
                while (*(float *)(*v130 + 8) < v133);
                *uint64_t v134 = v132;
              }
            }
          }
          BOOL v111 = v121-- <= 2;
        }
        while (!v111);
      }
      return result;
    }
    unint64_t v14 = v13 >> 1;
    uint64_t v15 = &v11[v13 >> 1];
    uint64_t v16 = *v10;
    float v17 = *(float *)(*v10 + 8);
    if ((unint64_t)v12 >= 0x401)
    {
      uint64_t v18 = *v15;
      uint64_t v19 = *v11;
      float v20 = *(float *)(*v15 + 8);
      float v21 = *(float *)(*v11 + 8);
      if (v20 >= v21)
      {
        if (v17 < v20)
        {
          *uint64_t v15 = v16;
          *uint64_t v10 = v18;
          uint64_t v26 = *v11;
          if (*(float *)(*v15 + 8) < *(float *)(*v11 + 8))
          {
            uint64_t *v11 = *v15;
            *uint64_t v15 = v26;
          }
        }
      }
      else
      {
        if (v17 < v20)
        {
          uint64_t *v11 = v16;
          goto LABEL_22;
        }
        uint64_t *v11 = v18;
        *uint64_t v15 = v19;
        if (*(float *)(*v10 + 8) < v21)
        {
          *uint64_t v15 = *v10;
LABEL_22:
          *uint64_t v10 = v19;
        }
      }
      uint64_t v28 = &v11[v14];
      uint64_t v31 = *(v28 - 1);
      int v29 = v28 - 1;
      uint64_t v30 = v31;
      uint64_t v32 = v11[1];
      float v33 = *(float *)(v31 + 8);
      float v34 = *(float *)(v32 + 8);
      uint64_t v35 = *(a2 - 2);
      float v36 = *(float *)(v35 + 8);
      if (v33 >= v34)
      {
        if (v36 < v33)
        {
          uint64_t *v29 = v35;
          *(a2 - 2) = v30;
          uint64_t v37 = v11[1];
          if (*(float *)(*v29 + 8) < *(float *)(v37 + 8))
          {
            v11[1] = *v29;
            uint64_t *v29 = v37;
          }
        }
      }
      else
      {
        if (v36 < v33)
        {
          v11[1] = v35;
          goto LABEL_34;
        }
        v11[1] = v30;
        uint64_t *v29 = v32;
        uint64_t v38 = *(a2 - 2);
        if (*(float *)(v38 + 8) < v34)
        {
          uint64_t *v29 = v38;
LABEL_34:
          *(a2 - 2) = v32;
        }
      }
      float v39 = &v11[v14];
      uint64_t v42 = v39[1];
      float v40 = v39 + 1;
      uint64_t v41 = v42;
      uint64_t v43 = v11[2];
      float v44 = *(float *)(v42 + 8);
      float v45 = *(float *)(v43 + 8);
      uint64_t v46 = *(a2 - 3);
      float v47 = *(float *)(v46 + 8);
      if (v44 >= v45)
      {
        if (v47 < v44)
        {
          *float v40 = v46;
          *(a2 - 3) = v41;
          uint64_t v48 = v11[2];
          if (*(float *)(*v40 + 8) < *(float *)(v48 + 8))
          {
            unsigned char v11[2] = *v40;
            *float v40 = v48;
          }
        }
      }
      else
      {
        if (v47 < v44)
        {
          unsigned char v11[2] = v46;
          goto LABEL_43;
        }
        unsigned char v11[2] = v41;
        *float v40 = v43;
        uint64_t v49 = *(a2 - 3);
        if (*(float *)(v49 + 8) < v45)
        {
          *float v40 = v49;
LABEL_43:
          *(a2 - 3) = v43;
        }
      }
      uint64_t v50 = *v15;
      uint64_t v51 = *v29;
      float v52 = *(float *)(*v15 + 8);
      float v53 = *(float *)(*v29 + 8);
      uint64_t v54 = *v40;
      float v55 = *(float *)(*v40 + 8);
      if (v52 >= v53)
      {
        if (v55 >= v52) {
          goto LABEL_52;
        }
        *uint64_t v15 = v54;
        *float v40 = v50;
        float v40 = &v11[v13 >> 1];
        uint64_t v50 = v51;
        if (v55 >= v53)
        {
          uint64_t v50 = v54;
          goto LABEL_52;
        }
      }
      else if (v55 >= v52)
      {
        uint64_t *v29 = v50;
        *uint64_t v15 = v51;
        int v29 = &v11[v13 >> 1];
        uint64_t v50 = v54;
        if (v55 >= v53)
        {
          uint64_t v50 = v51;
LABEL_52:
          uint64_t v56 = *v11;
          uint64_t *v11 = v50;
          *uint64_t v15 = v56;
          goto LABEL_53;
        }
      }
      uint64_t *v29 = v54;
      *float v40 = v51;
      goto LABEL_52;
    }
    uint64_t v22 = *v11;
    uint64_t v23 = *v15;
    float v24 = *(float *)(*v11 + 8);
    float v25 = *(float *)(*v15 + 8);
    if (v24 >= v25)
    {
      if (v17 < v24)
      {
        uint64_t *v11 = v16;
        *uint64_t v10 = v22;
        uint64_t v27 = *v15;
        if (*(float *)(*v11 + 8) < *(float *)(*v15 + 8))
        {
          *uint64_t v15 = *v11;
          uint64_t *v11 = v27;
        }
      }
      goto LABEL_53;
    }
    if (v17 < v24)
    {
      *uint64_t v15 = v16;
LABEL_31:
      *uint64_t v10 = v23;
      goto LABEL_53;
    }
    *uint64_t v15 = v22;
    uint64_t *v11 = v23;
    if (*(float *)(*v10 + 8) < v25)
    {
      uint64_t *v11 = *v10;
      goto LABEL_31;
    }
LABEL_53:
    --a3;
    uint64_t v57 = *v11;
    if (a4)
    {
      float v58 = *(float *)(v57 + 8);
LABEL_56:
      int8x16_t v59 = v11;
      do
      {
        int32x4_t v60 = v59;
        uint64_t v62 = v59[1];
        ++v59;
        uint64_t v61 = v62;
      }
      while (*(float *)(v62 + 8) < v58);
      float32x4_t v63 = a2;
      if (v60 == v11)
      {
        float32x4_t v63 = a2;
        do
        {
          if (v59 >= v63) {
            break;
          }
          uint64_t v65 = *--v63;
        }
        while (*(float *)(v65 + 8) >= v58);
      }
      else
      {
        do
          uint64_t v64 = *--v63;
        while (*(float *)(v64 + 8) >= v58);
      }
      if (v59 < v63)
      {
        uint64_t v66 = *v63;
        uint64_t v67 = v59;
        uint64_t v68 = v63;
        do
        {
          *uint64_t v67 = v66;
          *uint64_t v68 = v61;
          do
          {
            int32x4_t v60 = v67;
            uint64_t v69 = v67[1];
            ++v67;
            uint64_t v61 = v69;
          }
          while (*(float *)(v69 + 8) < v58);
          do
          {
            uint64_t v70 = *--v68;
            uint64_t v66 = v70;
          }
          while (*(float *)(v70 + 8) >= v58);
        }
        while (v67 < v68);
      }
      if (v60 != v11) {
        uint64_t *v11 = *v60;
      }
      *int32x4_t v60 = v57;
      if (v59 < v63) {
        goto LABEL_75;
      }
      BOOL v71 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**>(v11, v60);
      uint64_t v11 = v60 + 1;
      BOOL result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**>(v60 + 1, a2);
      if (result)
      {
        a2 = v60;
        if (v71) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v71)
      {
LABEL_75:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**,false>(v9, v60, a3, a4 & 1);
        a4 = 0;
        uint64_t v11 = v60 + 1;
      }
    }
    else
    {
      float v58 = *(float *)(v57 + 8);
      if (*(float *)(*(v11 - 1) + 8) < v58) {
        goto LABEL_56;
      }
      if (v58 < *(float *)(*v10 + 8))
      {
        do
        {
          uint64_t v72 = v11[1];
          ++v11;
        }
        while (v58 >= *(float *)(v72 + 8));
      }
      else
      {
        double v73 = v11 + 1;
        do
        {
          uint64_t v11 = v73;
          if (v73 >= a2) {
            break;
          }
          ++v73;
        }
        while (v58 >= *(float *)(*v11 + 8));
      }
      float32x2_t v74 = a2;
      if (v11 < a2)
      {
        float32x2_t v74 = a2;
        do
          uint64_t v75 = *--v74;
        while (v58 < *(float *)(v75 + 8));
      }
      if (v11 < v74)
      {
        uint64_t v76 = *v11;
        uint64_t v77 = *v74;
        do
        {
          uint64_t *v11 = v77;
          *float32x2_t v74 = v76;
          do
          {
            uint64_t v78 = v11[1];
            ++v11;
            uint64_t v76 = v78;
          }
          while (v58 >= *(float *)(v78 + 8));
          do
          {
            uint64_t v79 = *--v74;
            uint64_t v77 = v79;
          }
          while (v58 < *(float *)(v79 + 8));
        }
        while (v11 < v74);
      }
      float32x2_t v80 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        uint64_t *v9 = *v80;
      }
      a4 = 0;
      *float32x2_t v80 = v57;
    }
  }
  float v98 = v11 + 1;
  BOOL v100 = v11 == a2 || v98 == a2;
  if (a4)
  {
    if (!v100)
    {
      uint64_t v101 = 8;
      float v102 = v11;
      do
      {
        uint64_t v105 = *v102;
        uint64_t v104 = v102[1];
        float v102 = v98;
        float v106 = *(float *)(v104 + 8);
        if (v106 < *(float *)(v105 + 8))
        {
          uint64_t v107 = v101;
          do
          {
            *(uint64_t *)((char *)v11 + v107) = v105;
            uint64_t v108 = v107 - 8;
            if (v107 == 8)
            {
              signed int v103 = v11;
              goto LABEL_118;
            }
            uint64_t v105 = *(uint64_t *)((char *)v11 + v107 - 16);
            v107 -= 8;
          }
          while (v106 < *(float *)(v105 + 8));
          signed int v103 = (uint64_t *)((char *)v11 + v108);
LABEL_118:
          *signed int v103 = v104;
        }
        float v98 = v102 + 1;
        v101 += 8;
      }
      while (v102 + 1 != a2);
    }
  }
  else if (!v100)
  {
    do
    {
      uint64_t v138 = *v9;
      uint64_t v137 = v9[1];
      uint64_t v9 = v98;
      float v139 = *(float *)(v137 + 8);
      if (v139 < *(float *)(v138 + 8))
      {
        do
        {
          *float v98 = v138;
          uint64_t v138 = *(v98 - 2);
          --v98;
        }
        while (v139 < *(float *)(v138 + 8));
        *float v98 = v137;
      }
      float v98 = v9 + 1;
    }
    while (v9 + 1 != a2);
  }
  return result;
}

uint64_t *std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**,0>(uint64_t *result, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v5 = *a2;
  uint64_t v6 = *result;
  float v7 = *(float *)(*a2 + 8);
  float v8 = *(float *)(*result + 8);
  uint64_t v9 = *a3;
  float v10 = *(float *)(*a3 + 8);
  if (v7 >= v8)
  {
    if (v10 >= v7)
    {
      uint64_t v5 = *a3;
    }
    else
    {
      *a2 = v9;
      *a3 = v5;
      uint64_t v11 = *result;
      if (*(float *)(*a2 + 8) < *(float *)(*result + 8))
      {
        *BOOL result = *a2;
        *a2 = v11;
        uint64_t v5 = *a3;
      }
    }
  }
  else
  {
    if (v10 < v7)
    {
      *BOOL result = v9;
LABEL_9:
      *a3 = v6;
      uint64_t v5 = v6;
      goto LABEL_11;
    }
    *BOOL result = v5;
    *a2 = v6;
    uint64_t v5 = *a3;
    if (*(float *)(*a3 + 8) < v8)
    {
      *a2 = v5;
      goto LABEL_9;
    }
  }
LABEL_11:
  if (*(float *)(*a4 + 8) < *(float *)(v5 + 8))
  {
    *a3 = *a4;
    *a4 = v5;
    uint64_t v12 = *a2;
    if (*(float *)(*a3 + 8) < *(float *)(*a2 + 8))
    {
      *a2 = *a3;
      *a3 = v12;
      uint64_t v13 = *result;
      if (*(float *)(*a2 + 8) < *(float *)(*result + 8))
      {
        *BOOL result = *a2;
        *a2 = v13;
      }
    }
  }
  uint64_t v14 = *a4;
  if (*(float *)(*a5 + 8) < *(float *)(*a4 + 8))
  {
    *a4 = *a5;
    *a5 = v14;
    uint64_t v15 = *a3;
    if (*(float *)(*a4 + 8) < *(float *)(*a3 + 8))
    {
      *a3 = *a4;
      *a4 = v15;
      uint64_t v16 = *a2;
      if (*(float *)(*a3 + 8) < *(float *)(*a2 + 8))
      {
        *a2 = *a3;
        *a3 = v16;
        uint64_t v17 = *result;
        if (*(float *)(*a2 + 8) < *(float *)(*result + 8))
        {
          *BOOL result = *a2;
          *a2 = v17;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2 = 1;
  switch(a2 - a1)
  {
    case 0:
    case 1:
      return v2;
    case 2:
      uint64_t v3 = *(a2 - 1);
      uint64_t v4 = *a1;
      if (*(float *)(v3 + 8) < *(float *)(*a1 + 8))
      {
        *a1 = v3;
        *(a2 - 1) = v4;
      }
      return 1;
    case 3:
      uint64_t v14 = *a1;
      uint64_t v15 = a1[1];
      float v16 = *(float *)(v15 + 8);
      float v17 = *(float *)(*a1 + 8);
      uint64_t v18 = *(a2 - 1);
      float v19 = *(float *)(v18 + 8);
      if (v16 >= v17)
      {
        if (v19 < v16)
        {
          a1[1] = v18;
          *(a2 - 1) = v15;
          uint64_t v41 = *a1;
          uint64_t v40 = a1[1];
          if (*(float *)(v40 + 8) < *(float *)(*a1 + 8))
          {
            *a1 = v40;
            a1[1] = v41;
          }
        }
      }
      else
      {
        if (v19 >= v16)
        {
          *a1 = v15;
          a1[1] = v14;
          uint64_t v47 = *(a2 - 1);
          if (*(float *)(v47 + 8) >= v17) {
            return 1;
          }
          a1[1] = v47;
        }
        else
        {
          *a1 = v18;
        }
        *(a2 - 1) = v14;
      }
      return 1;
    case 4:
      float v20 = a1 + 1;
      uint64_t v21 = a1[1];
      uint64_t v22 = a1 + 2;
      uint64_t v23 = a1[2];
      uint64_t v24 = *a1;
      float v25 = *(float *)(v21 + 8);
      float v26 = *(float *)(*a1 + 8);
      float v27 = *(float *)(v23 + 8);
      if (v25 >= v26)
      {
        if (v27 >= v25) {
          goto LABEL_35;
        }
        uint64_t *v20 = v23;
        *uint64_t v22 = v21;
        uint64_t v28 = a1;
        int v29 = a1 + 1;
        uint64_t v30 = v21;
        if (v27 >= v26) {
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v28 = a1;
        int v29 = a1 + 2;
        uint64_t v30 = *a1;
        if (v27 >= v25)
        {
          *a1 = v21;
          a1[1] = v24;
          uint64_t v28 = a1 + 1;
          int v29 = a1 + 2;
          uint64_t v30 = v24;
          if (v27 >= v26)
          {
LABEL_35:
            uint64_t v21 = v23;
LABEL_36:
            uint64_t v42 = *(a2 - 1);
            if (*(float *)(v42 + 8) < *(float *)(v21 + 8))
            {
              *uint64_t v22 = v42;
              *(a2 - 1) = v21;
              uint64_t v43 = *v22;
              uint64_t v44 = *v20;
              float v45 = *(float *)(v43 + 8);
              if (v45 < *(float *)(v44 + 8))
              {
                a1[1] = v43;
                a1[2] = v44;
                uint64_t v46 = *a1;
                if (v45 < *(float *)(*a1 + 8))
                {
                  *a1 = v43;
                  a1[1] = v46;
                }
              }
            }
            return 1;
          }
        }
      }
      *uint64_t v28 = v23;
      uint64_t *v29 = v24;
      uint64_t v21 = v30;
      goto LABEL_36;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::TrafficUtilities::enumerateTrafficRoadPiecesForTile(geo::codec::VectorTile &,zilch::TrafficSkeletonTile const&,std::shared_ptr<md::TrafficDynamicTileResource> const&,std::function<void ()(md::RoadPiece const&)> const&)::$_0 &,zilch::TrafficDynamicTile::Flow const**,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      uint64_t v6 = a1 + 2;
      uint64_t v5 = a1[2];
      uint64_t v7 = a1[1];
      uint64_t v8 = *a1;
      float v9 = *(float *)(v7 + 8);
      float v10 = *(float *)(*a1 + 8);
      float v11 = *(float *)(v5 + 8);
      if (v9 < v10)
      {
        uint64_t v12 = a1;
        uint64_t v13 = a1 + 2;
        if (v11 >= v9)
        {
          *a1 = v7;
          a1[1] = v8;
          uint64_t v12 = a1 + 1;
          uint64_t v13 = a1 + 2;
          if (v11 >= v10) {
            goto LABEL_19;
          }
        }
LABEL_18:
        *uint64_t v12 = v5;
        *uint64_t v13 = v8;
        goto LABEL_19;
      }
      if (v11 < v9)
      {
        a1[1] = v5;
        uint64_t *v6 = v7;
        uint64_t v12 = a1;
        uint64_t v13 = a1 + 1;
        if (v11 < v10) {
          goto LABEL_18;
        }
      }
LABEL_19:
      uint64_t v31 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      int v32 = 0;
      for (uint64_t i = 24; ; i += 8)
      {
        uint64_t v35 = *v31;
        uint64_t v36 = *v6;
        float v37 = *(float *)(*v31 + 8);
        if (v37 < *(float *)(v36 + 8))
        {
          uint64_t v38 = i;
          do
          {
            *(uint64_t *)((char *)a1 + v38) = v36;
            uint64_t v39 = v38 - 8;
            if (v38 == 8)
            {
              float v34 = a1;
              goto LABEL_22;
            }
            uint64_t v36 = *(uint64_t *)((char *)a1 + v38 - 16);
            v38 -= 8;
          }
          while (v37 < *(float *)(v36 + 8));
          float v34 = (uint64_t *)((char *)a1 + v39);
LABEL_22:
          *float v34 = v35;
          if (++v32 == 8) {
            break;
          }
        }
        uint64_t v6 = v31++;
        if (v31 == a2) {
          return 1;
        }
      }
      return v31 + 1 == a2;
  }
}

uint64_t (***md::LabelClusterTree::labelMarkerForClusterNode@<X0>(uint64_t a1@<X0>, void *a2@<X8>))(void)
{
  BOOL result = *(uint64_t (****)(void))(a1 + 8);
  if (result) {
    return (uint64_t (***)(void))(**result)(result);
  }
  *a2 = 0;
  a2[1] = 0;
  return result;
}

void md::LabelClusterTree::~LabelClusterTree(md::LabelClusterTree *this)
{
  *(void *)this = &unk_1EF536320;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    uint64_t v3 = (void *)*((void *)this + 7);
    uint64_t v4 = *((void *)this + 6);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        void *v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 8))(v5, v4);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *((void *)this + 6);
    }
    *((void *)this + 7) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), v4, *((void *)this + 8) - v4);
  }
  uint64_t v7 = (void *)*((void *)this + 2);
  if (v7)
  {
    uint64_t v8 = (void *)*((void *)this + 3);
    uint64_t v9 = *((void *)this + 2);
    if (v8 != v7)
    {
      do
      {
        uint64_t v11 = *--v8;
        uint64_t v10 = v11;
        *uint64_t v8 = 0;
        if (v11) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 8))(v10, v9);
        }
      }
      while (v8 != v7);
      uint64_t v9 = *((void *)this + 2);
    }
    *((void *)this + 3) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v9, *((void *)this + 4) - v9);
  }
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *(void *)this = &unk_1EF536320;
  uint64_t v2 = (void *)*((void *)this + 6);
  if (v2)
  {
    uint64_t v3 = (void *)*((void *)this + 7);
    uint64_t v4 = *((void *)this + 6);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        void *v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v5 + 8))(v5, v4);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *((void *)this + 6);
    }
    *((void *)this + 7) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), v4, *((void *)this + 8) - v4);
  }
  uint64_t v7 = (void *)*((void *)this + 2);
  if (v7)
  {
    uint64_t v8 = (void *)*((void *)this + 3);
    uint64_t v9 = *((void *)this + 2);
    if (v8 != v7)
    {
      do
      {
        uint64_t v11 = *--v8;
        uint64_t v10 = v11;
        *uint64_t v8 = 0;
        if (v11) {
          (*(void (**)(uint64_t, uint64_t))(*(void *)v10 + 8))(v10, v9);
        }
      }
      while (v8 != v7);
      uint64_t v9 = *((void *)this + 2);
    }
    *((void *)this + 3) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 5) + 40))(*((void *)this + 5), v9, *((void *)this + 4) - v9);
  }
}

void *std::function<md::ClusterNode * ()(std::pair<md::ClusterNode *,md::ClusterNode *> &,double)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::LabelClusterTree::generateClusters(std::shared_ptr<md::LabelClusterTree> const&,NSArray *,md::LabelManager *)::$_0,std::allocator<md::LabelClusterTree::generateClusters(std::shared_ptr<md::LabelClusterTree> const&,NSArray *,md::LabelManager *)::$_0>,md::ClusterNode * ()(std::pair<md::ClusterNode *,md::ClusterNode *> &,double)>::operator()(uint64_t a1, void *a2)
{
  md::LabelPoint::lerped((md::LabelPoint *)&v2, (const md::LabelPoint *)(*a2 + 16), 0.5, a2[1] + 16);
  operator new();
}

void geo::_retain_ptr<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A018;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<objc_object  {objcproto25VKCustomFeatureAnnotation}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A018;

  return a1;
}

id md::ClusterTreeClusterNode::annotation(id *this)
{
  return this[16];
}

uint64_t md::ClusterNode::waypointStoreClusterNode(md::ClusterNode *this)
{
  return 0;
}

uint64_t md::ClusterTreeClusterNode::setupClusterNode(md::ClusterTreeClusterNode *this, char a2, float a3)
{
  *((unsigned char *)this + 80) = 1;
  *((unsigned char *)this + 180) = a2;
  if ((a2 & 1) == 0) {
    *((float *)this + 3) = a3;
  }
  md::ClusterTreeClusterNode::updateDescendantNode(this, *((md::ClusterTreeNode **)this + 18));
  uint64_t v4 = (md::ClusterTreeNode *)*((void *)this + 19);
  return md::ClusterTreeClusterNode::updateDescendantNode(this, v4);
}

uint64_t md::ClusterTreeClusterNode::updateDescendantNode(md::ClusterTreeClusterNode *this, md::ClusterTreeNode *a2)
{
  *((_DWORD *)a2 + 2) = *((_DWORD *)this + 3);
  *((void *)a2 + 9) = this;
  if (*((unsigned char *)a2 + 80) == 1)
  {
    if (((*(uint64_t (**)(md::ClusterTreeNode *))(*(void *)a2 + 32))(a2) & 1) == 0)
    {
      *((_DWORD *)this + 44) += *((_DWORD *)a2 + 44);
      *((unsigned char *)this + 181) |= *((unsigned char *)a2 + 181);
    }
  }
  else if (!*((unsigned char *)a2 + 80))
  {
    if ((*(uint64_t (**)(md::ClusterTreeNode *))(*(void *)a2 + 32))(a2))
    {
      ++*((_DWORD *)this + 44);
      if (*((unsigned char *)this + 180)) {
        char v4 = 2;
      }
      else {
        char v4 = 1;
      }
      *((unsigned char *)a2 + 80) = v4;
    }
    else
    {
      *((unsigned char *)a2 + 80) = 2;
      md::ClusterTreeClusterNode::updateDescendantNode(this, *((md::ClusterTreeNode **)a2 + 18));
      md::ClusterTreeClusterNode::updateDescendantNode(this, *((md::ClusterTreeNode **)a2 + 19));
    }
  }
  int v5 = *((_DWORD *)a2 + 21);
  if (v5 != -1)
  {
    int v6 = *((_DWORD *)this + 21);
    if (v6 == -1) {
      *((_DWORD *)this + 21) = v5;
    }
    else {
      *((unsigned char *)this + 181) |= v6 != v5;
    }
  }
  int v7 = *((_DWORD *)a2 + 22);
  if (v7 != -1 && *((_DWORD *)this + 22) == -1) {
    *((_DWORD *)this + 22) = v7;
  }
  uint64_t result = (*(uint64_t (**)(md::ClusterTreeNode *))(*(void *)a2 + 32))(a2);
  if (result)
  {
    uint64_t v11 = *((void *)this + 20);
    if (!v11 || *(_DWORD *)(v11 + 96) > *((_DWORD *)a2 + 24)) {
      *((void *)this + 20) = a2;
    }
  }
  else
  {
    uint64_t v9 = *((void *)a2 + 20);
    uint64_t v10 = *((void *)this + 20);
    if (!v10 || v9 && *(_DWORD *)(v10 + 96) > *(_DWORD *)(v9 + 96)) {
      *((void *)this + 20) = v9;
    }
  }
  return result;
}