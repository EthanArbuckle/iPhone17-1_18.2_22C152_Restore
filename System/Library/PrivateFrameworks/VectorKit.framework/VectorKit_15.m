void sub_1A1F5DD3C(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<arComponents::NeedsPropagateActive>(int8x8_t *a1)
{
  unint64_t v10 = 0xA081D0B61327224CLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xA081D0B61327224CLL;
    if (*(void *)&v1 <= 0xA081D0B61327224CLL) {
      unint64_t v3 = 0xA081D0B61327224CLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xA081D0B61327224CLL;
  }
  v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xA081D0B61327224CLL)
      {
        if (v5[2] == 0xA081D0B61327224CLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xA081D0B61327224CLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xA081D0B61327224CLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1F5DFAC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void propagateAnimationStatusToAnimatedEntity(gdc::Registry *,long long,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_1::operator()(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = **(void **)(a1 + 8);
  unint64_t v7 = (void *)gdc::Registry::storage<arComponents::AnimationEntityStatus<(VKAnimationState)1>>(**(int8x8_t ***)a1);
  unint64_t v55 = a3;
  uint64_t v8 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v7 + 4, (uint64_t)&v55);
  if (v9)
  {
    v15 = (char *)v7[11];
    unint64_t v14 = v7[12];
    if ((unint64_t)v15 >= v14)
    {
      v17 = (char *)v7[10];
      uint64_t v18 = (v15 - v17) >> 3;
      unint64_t v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 61) {
        goto LABEL_57;
      }
      uint64_t v20 = v14 - (void)v17;
      if (v20 >> 2 > v19) {
        unint64_t v19 = v20 >> 2;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v19;
      }
      if (v21)
      {
        if (v21 >> 61) {
          goto LABEL_58;
        }
        v22 = operator new(8 * v21);
      }
      else
      {
        v22 = 0;
      }
      v23 = &v22[8 * v18];
      v24 = &v22[8 * v21];
      void *v23 = v6;
      v16 = v23 + 1;
      if (v15 != v17)
      {
        unint64_t v25 = v15 - v17 - 8;
        if (v25 < 0x58) {
          goto LABEL_61;
        }
        if ((unint64_t)(v17 - v22) < 0x20) {
          goto LABEL_61;
        }
        uint64_t v26 = (v25 >> 3) + 1;
        v27 = &v22[8 * v18 - 16];
        v28 = v15 - 16;
        uint64_t v29 = v26 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v30 = *(_OWORD *)v28;
          *(v27 - 1) = *((_OWORD *)v28 - 1);
          _OWORD *v27 = v30;
          v27 -= 2;
          v28 -= 32;
          v29 -= 4;
        }
        while (v29);
        v23 -= v26 & 0x3FFFFFFFFFFFFFFCLL;
        v15 -= 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
        if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_61:
          do
          {
            uint64_t v31 = *((void *)v15 - 1);
            v15 -= 8;
            *--v23 = v31;
          }
          while (v15 != v17);
        }
      }
      v7[10] = v23;
      v7[11] = v16;
      v7[12] = v24;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      *(void *)v15 = v6;
      v16 = v15 + 8;
    }
    v7[11] = v16;
    uint64_t v11 = v7[31];
  }
  else
  {
    unint64_t v10 = (void *)((char *)v8 + v7[10] - v7[7]);
    *unint64_t v10 = v6;
    uint64_t v11 = v7[31];
    if (v10 != (void *)v7[11])
    {
      v12 = (void *)v7[16];
      if (v12)
      {
        while (1)
        {
          v57 = &v55;
          uint64_t v58 = 1;
          uint64_t v56 = v11;
          uint64_t v13 = v12[6];
          if (!v13) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v13 + 48))(v13, &v56, &v57);
          v12 = (void *)*v12;
          if (!v12) {
            goto LABEL_32;
          }
        }
LABEL_56:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_57:
        abort();
      }
      goto LABEL_32;
    }
  }
  for (i = (void *)v7[22]; i; i = (void *)*i)
  {
    v57 = &v55;
    uint64_t v58 = 1;
    uint64_t v56 = v11;
    uint64_t v33 = i[6];
    if (!v33) {
      goto LABEL_56;
    }
    (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v33 + 48))(v33, &v56, &v57);
  }
LABEL_32:
  v34 = (void *)gdc::Registry::storage<arComponents::AnimationEntityStatus<(VKAnimationState)3>>(**(int8x8_t ***)a1);
  gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)3>>::remove(v34, a3);
  uint64_t v35 = *(void *)(a1 + 16);
  v37 = *(void **)(v35 + 8);
  unint64_t v36 = *(void *)(v35 + 16);
  if ((unint64_t)v37 < v36)
  {
    void *v37 = a2;
    v38 = v37 + 1;
    goto LABEL_55;
  }
  v39 = *(unsigned char **)v35;
  uint64_t v40 = (uint64_t)v37 - *(void *)v35;
  uint64_t v41 = v40 >> 3;
  unint64_t v42 = (v40 >> 3) + 1;
  if (v42 >> 61) {
    goto LABEL_57;
  }
  uint64_t v43 = v36 - (void)v39;
  if (v43 >> 2 > v42) {
    unint64_t v42 = v43 >> 2;
  }
  if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v44 = v42;
  }
  if (!v44)
  {
    v45 = 0;
    goto LABEL_44;
  }
  if (v44 >> 61) {
LABEL_58:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  v45 = operator new(8 * v44);
LABEL_44:
  v46 = &v45[8 * v41];
  v47 = &v45[8 * v44];
  void *v46 = a2;
  v38 = v46 + 1;
  if (v37 == (void *)v39)
  {
    v39 = v37;
  }
  else
  {
    unint64_t v48 = (char *)v37 - v39 - 8;
    if (v48 < 0x58) {
      goto LABEL_62;
    }
    if ((unint64_t)((char *)v37 - v45 - v40) < 0x20) {
      goto LABEL_62;
    }
    uint64_t v49 = (v48 >> 3) + 1;
    v50 = &v45[8 * v41 - 16];
    v51 = (long long *)(v37 - 2);
    uint64_t v52 = v49 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v53 = *v51;
      *(v50 - 1) = *(v51 - 1);
      _OWORD *v50 = v53;
      v50 -= 2;
      v51 -= 2;
      v52 -= 4;
    }
    while (v52);
    v46 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
    v37 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
    if (v49 != (v49 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_62:
      do
      {
        uint64_t v54 = *--v37;
        *--v46 = v54;
      }
      while (v37 != (void *)v39);
      v39 = *(unsigned char **)v35;
    }
  }
  *(void *)uint64_t v35 = v46;
  *(void *)(v35 + 8) = v38;
  *(void *)(v35 + 16) = v47;
  if (v39) {
    operator delete(v39);
  }
LABEL_55:
  *(void *)(v35 + 8) = v38;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::NeedsPropagateActive>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  unint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  unint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return propagateAnimationStatusToAnimatedEntity(gdc::Registry *,long long,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_2::operator()();
}

void propagateAnimationStatusToAnimatedEntity(gdc::Registry *,long long,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_2::operator()(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v6 = **(void **)(a1 + 8);
  unint64_t v7 = (void *)gdc::Registry::storage<arComponents::AnimationEntityStatus<(VKAnimationState)3>>(**(int8x8_t ***)a1);
  unint64_t v55 = a3;
  uint64_t v8 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v7 + 4, (uint64_t)&v55);
  if (v9)
  {
    uint64_t v15 = (char *)v7[11];
    unint64_t v14 = v7[12];
    if ((unint64_t)v15 >= v14)
    {
      unint64_t v17 = (char *)v7[10];
      uint64_t v18 = (v15 - v17) >> 3;
      unint64_t v19 = v18 + 1;
      if ((unint64_t)(v18 + 1) >> 61) {
        goto LABEL_57;
      }
      uint64_t v20 = v14 - (void)v17;
      if (v20 >> 2 > v19) {
        unint64_t v19 = v20 >> 2;
      }
      if ((unint64_t)v20 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v21 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v21 = v19;
      }
      if (v21)
      {
        if (v21 >> 61) {
          goto LABEL_58;
        }
        v22 = operator new(8 * v21);
      }
      else
      {
        v22 = 0;
      }
      v23 = &v22[8 * v18];
      v24 = &v22[8 * v21];
      void *v23 = v6;
      uint64_t v16 = v23 + 1;
      if (v15 != v17)
      {
        unint64_t v25 = v15 - v17 - 8;
        if (v25 < 0x58) {
          goto LABEL_61;
        }
        if ((unint64_t)(v17 - v22) < 0x20) {
          goto LABEL_61;
        }
        uint64_t v26 = (v25 >> 3) + 1;
        v27 = &v22[8 * v18 - 16];
        v28 = v15 - 16;
        uint64_t v29 = v26 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v30 = *(_OWORD *)v28;
          *(v27 - 1) = *((_OWORD *)v28 - 1);
          _OWORD *v27 = v30;
          v27 -= 2;
          v28 -= 32;
          v29 -= 4;
        }
        while (v29);
        v23 -= v26 & 0x3FFFFFFFFFFFFFFCLL;
        v15 -= 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
        if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_61:
          do
          {
            uint64_t v31 = *((void *)v15 - 1);
            v15 -= 8;
            *--v23 = v31;
          }
          while (v15 != v17);
        }
      }
      v7[10] = v23;
      v7[11] = v16;
      v7[12] = v24;
      if (v17) {
        operator delete(v17);
      }
    }
    else
    {
      *(void *)uint64_t v15 = v6;
      uint64_t v16 = v15 + 8;
    }
    v7[11] = v16;
    uint64_t v11 = v7[31];
  }
  else
  {
    unint64_t v10 = (void *)((char *)v8 + v7[10] - v7[7]);
    *unint64_t v10 = v6;
    uint64_t v11 = v7[31];
    if (v10 != (void *)v7[11])
    {
      v12 = (void *)v7[16];
      if (v12)
      {
        while (1)
        {
          v57 = &v55;
          uint64_t v58 = 1;
          uint64_t v56 = v11;
          uint64_t v13 = v12[6];
          if (!v13) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v13 + 48))(v13, &v56, &v57);
          v12 = (void *)*v12;
          if (!v12) {
            goto LABEL_32;
          }
        }
LABEL_56:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_57:
        abort();
      }
      goto LABEL_32;
    }
  }
  for (i = (void *)v7[22]; i; i = (void *)*i)
  {
    v57 = &v55;
    uint64_t v58 = 1;
    uint64_t v56 = v11;
    uint64_t v33 = i[6];
    if (!v33) {
      goto LABEL_56;
    }
    (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v33 + 48))(v33, &v56, &v57);
  }
LABEL_32:
  v34 = (void *)gdc::Registry::storage<arComponents::AnimationEntityStatus<(VKAnimationState)1>>(**(int8x8_t ***)a1);
  gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)1>>::remove(v34, a3);
  uint64_t v35 = *(void *)(a1 + 16);
  v37 = *(void **)(v35 + 8);
  unint64_t v36 = *(void *)(v35 + 16);
  if ((unint64_t)v37 < v36)
  {
    void *v37 = a2;
    v38 = v37 + 1;
    goto LABEL_55;
  }
  v39 = *(unsigned char **)v35;
  uint64_t v40 = (uint64_t)v37 - *(void *)v35;
  uint64_t v41 = v40 >> 3;
  unint64_t v42 = (v40 >> 3) + 1;
  if (v42 >> 61) {
    goto LABEL_57;
  }
  uint64_t v43 = v36 - (void)v39;
  if (v43 >> 2 > v42) {
    unint64_t v42 = v43 >> 2;
  }
  if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v44 = v42;
  }
  if (!v44)
  {
    v45 = 0;
    goto LABEL_44;
  }
  if (v44 >> 61) {
LABEL_58:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  v45 = operator new(8 * v44);
LABEL_44:
  v46 = &v45[8 * v41];
  v47 = &v45[8 * v44];
  void *v46 = a2;
  v38 = v46 + 1;
  if (v37 == (void *)v39)
  {
    v39 = v37;
  }
  else
  {
    unint64_t v48 = (char *)v37 - v39 - 8;
    if (v48 < 0x58) {
      goto LABEL_62;
    }
    if ((unint64_t)((char *)v37 - v45 - v40) < 0x20) {
      goto LABEL_62;
    }
    uint64_t v49 = (v48 >> 3) + 1;
    v50 = &v45[8 * v41 - 16];
    v51 = (long long *)(v37 - 2);
    uint64_t v52 = v49 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v53 = *v51;
      *(v50 - 1) = *(v51 - 1);
      _OWORD *v50 = v53;
      v50 -= 2;
      v51 -= 2;
      v52 -= 4;
    }
    while (v52);
    v46 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
    v37 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
    if (v49 != (v49 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_62:
      do
      {
        uint64_t v54 = *--v37;
        *--v46 = v54;
      }
      while (v37 != (void *)v39);
      v39 = *(unsigned char **)v35;
    }
  }
  *(void *)uint64_t v35 = v46;
  *(void *)(v35 + 8) = v38;
  *(void *)(v35 + 16) = v47;
  if (v39) {
    operator delete(v39);
  }
LABEL_55:
  *(void *)(v35 + 8) = v38;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::NeedsPropagateFinished>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  unint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  unint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator()();
}

void processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator()(uint64_t a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(void *)a3;
  double v9 = (float)(a4 + (float)((float)(a5 - a4) * *(float *)(a2 + 8)));
  double v24 = **(double **)a1 * v9;
  if (GEOGetVectorKitARAnimationLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitARAnimationLog_onceToken, &__block_literal_global_45);
  }
  unint64_t v10 = (id)GEOGetVectorKitARAnimationLog_log;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    int v11 = *(_DWORD *)(a3 + 12);
    double v12 = *(float *)(a2 + 8);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v11;
    __int16 v29 = 2048;
    double v30 = v12;
    _os_log_impl(&dword_1A1780000, v10, OS_LOG_TYPE_INFO, "Animating : Translation applied: %d  progress : %f", buf, 0x12u);
  }

  if (fabs(v9) > 0.01)
  {
    uint64_t v13 = **(int8x8_t ***)(a1 + 8);
    v26[0] = &unk_1EF57E178;
    v26[1] = &v24;
    v27 = v26;
    unint64_t v14 = (void *)gdc::Registry::storage<arComponents::UpRelativeTranslationToApply>(v13);
    uint64_t v15 = v14[4];
    if (v8 >> 39 < (v14[5] - v15) >> 3
      && (uint64_t v16 = *(void *)(v15 + 8 * (v8 >> 39))) != 0
      && (v17 = *(unsigned __int16 *)(v16 + 2 * (HIDWORD(v8) & 0x7F)), uint64_t v19 = v14[7],
                                                                       uint64_t v18 = v14[8],
                                                                       v17 < (v18 - v19) >> 3)
      && ((uint64_t v20 = v19 + 8 * v17, v20 != v18) ? (v21 = *(_DWORD *)(v20 + 4) == HIDWORD(v8)) : (v21 = 0),
          v21 && (uint64_t v23 = v14[10]) != 0 && v23 + 8 * v17 != v14[11]))
    {
      buf[0] = 0;
      if (v27)
      {
        (*(void (**)(void *))(*v27 + 48))(v27);
LABEL_15:
        if (v27 == v26)
        {
          (*(void (**)(void *))(v26[0] + 32))(v26);
        }
        else if (v27)
        {
          (*(void (**)(void *))(*v27 + 40))(v27);
        }
        return;
      }
    }
    else
    {
      *(void *)buf = 0;
      LOBYTE(v25) = 1;
      if (v27)
      {
        (*(void (**)(void *, uint8_t *, uint64_t *))(*v27 + 48))(v27, buf, &v25);
        uint64_t v25 = *(void *)buf;
        v22 = (void *)gdc::Registry::storage<arComponents::UpRelativeTranslationToApply>(v13);
        gdc::ComponentStorageWrapper<md::ls::CheckIfReadyToProcess>::emplace(v22, v8, &v25);
        goto LABEL_15;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
}

void sub_1A1F5EC08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::function<void ()(arComponents::UpRelativeTranslationToApply &,BOOL)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>>>(int8x8_t *a1)
{
  unint64_t v10 = 0x87509A21B3A53B5ALL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0x87509A21B3A53B5ALL;
    if (*(void *)&v1 <= 0x87509A21B3A53B5ALL) {
      unint64_t v3 = 0x87509A21B3A53B5ALL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0x87509A21B3A53B5ALL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x87509A21B3A53B5ALL)
      {
        if (v5[2] == 0x87509A21B3A53B5ALL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x87509A21B3A53B5ALL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x87509A21B3A53B5ALL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1F5EE58(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator()(int8x8_t ***a1, float *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(void *)a4;
  if (GEOGetVectorKitARAnimationLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitARAnimationLog_onceToken, &__block_literal_global_45);
  }
  double v9 = (id)GEOGetVectorKitARAnimationLog_log;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    int v10 = *(_DWORD *)(a4 + 12);
    double v11 = *(float *)(a3 + 8);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v10;
    *(_WORD *)&uint8_t buf[8] = 2048;
    *(double *)&buf[10] = v11;
    _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_DEBUG, "Animating : Rotation applied: %d  progress : %f", buf, 0x12u);
  }

  float v12 = *(float *)(a3 + 8);
  float v13 = a2[1] + (float)(v12 * (float)(a2[4] - a2[1]));
  float v14 = a2[2] + (float)((float)(a2[5] - a2[2]) * v12);
  __float2 v15 = __sincosf_stret((float)(*a2 + (float)(v12 * (float)(a2[3] - *a2))) * 0.5);
  __float2 v16 = __sincosf_stret(v13 * 0.5);
  __float2 v17 = __sincosf_stret(v14 * 0.5);
  v30[0] = (float)((float)(v16.__sinval * v15.__cosval) * v17.__cosval)
         + (float)((float)(v16.__cosval * v15.__sinval) * v17.__sinval);
  v30[1] = -(float)((float)((float)(v16.__sinval * v15.__cosval) * v17.__sinval)
                  - (float)((float)(v16.__cosval * v15.__sinval) * v17.__cosval));
  v30[2] = -(float)((float)((float)(v16.__sinval * v15.__sinval) * v17.__cosval)
                  - (float)((float)(v16.__cosval * v15.__cosval) * v17.__sinval));
  v30[3] = (float)((float)(v16.__cosval * v15.__cosval) * v17.__cosval)
         + (float)((float)(v16.__sinval * v15.__sinval) * v17.__sinval);
  uint64_t v18 = **a1;
  v34[0] = &unk_1EF57E130;
  v34[1] = v30;
  uint64_t v35 = v34;
  uint64_t v19 = (void *)gdc::Registry::storage<arComponents::RotationToApply>(v18);
  uint64_t v20 = v19[4];
  if (v8 >> 39 >= (v19[5] - v20) >> 3
    || (uint64_t v21 = *(void *)(v20 + 8 * (v8 >> 39))) == 0
    || (v22 = *(unsigned __int16 *)(v21 + 2 * (HIDWORD(v8) & 0x7F)), v24 = v19[7], uint64_t v23 = v19[8], v22 >= (v23 - v24) >> 3)
    || ((uint64_t v25 = v24 + 8 * v22, v25 != v23) ? (v26 = *(_DWORD *)(v25 + 4) == HIDWORD(v8)) : (v26 = 0),
        !v26 || (uint64_t v29 = v19[10]) == 0 || v29 + 16 * v22 == v19[11]))
  {
    *(_OWORD *)buf = xmmword_1A28FCDD0;
    LOBYTE(v31) = 1;
    if (v35)
    {
      (*(void (**)(void *, unsigned char *, uint64_t *))(*v35 + 48))(v35, buf, &v31);
      uint64_t v31 = *(void *)buf;
      int v32 = *(_DWORD *)&buf[8];
      int v33 = *(_DWORD *)&buf[12];
      v27 = (void *)gdc::Registry::storage<arComponents::RotationToApply>(v18);
      gdc::ComponentStorageWrapper<arComponents::RotationToApply>::emplace(v27, v8, &v31);
      goto LABEL_14;
    }
LABEL_23:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  buf[0] = 0;
  if (!v35) {
    goto LABEL_23;
  }
  (*(void (**)(void *))(*v35 + 48))(v35);
LABEL_14:
  uint64_t result = (uint64_t)v35;
  if (v35 == v34) {
    return (*(uint64_t (**)(void *))(v34[0] + 32))(v34);
  }
  if (v35) {
    return (*(uint64_t (**)(void))(*v35 + 40))();
  }
  return result;
}

void sub_1A1F5F1F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::function<void ()(arComponents::RotationToApply &,BOOL)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator()(int8x8_t ***a1, uint64_t a2, uint64_t a3, float a4, float a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = *(void *)a3;
  float v24 = a4 + (float)(*(float *)(a2 + 8) * (float)(a5 - a4));
  if (GEOGetVectorKitARAnimationLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitARAnimationLog_onceToken, &__block_literal_global_45);
  }
  double v9 = (id)GEOGetVectorKitARAnimationLog_log;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    int v10 = *(_DWORD *)(a3 + 12);
    double v11 = *(float *)(a2 + 8);
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v10;
    __int16 v29 = 2048;
    double v30 = v11;
    _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_INFO, "Animating : Scale applied: %d  progress : %f", buf, 0x12u);
  }

  float v12 = **a1;
  v26[0] = &unk_1EF57E0E8;
  v26[1] = &v24;
  v27 = v26;
  float v13 = (void *)gdc::Registry::storage<arComponents::ScaleToApply>(v12);
  uint64_t v14 = v13[4];
  if (v8 >> 39 >= (v13[5] - v14) >> 3
    || (uint64_t v15 = *(void *)(v14 + 8 * (v8 >> 39))) == 0
    || (v16 = *(unsigned __int16 *)(v15 + 2 * (HIDWORD(v8) & 0x7F)), uint64_t v18 = v13[7], v17 = v13[8], v16 >= (v17 - v18) >> 3)
    || ((uint64_t v19 = v18 + 8 * v16, v19 != v17) ? (v20 = *(_DWORD *)(v19 + 4) == HIDWORD(v8)) : (v20 = 0),
        !v20 || (uint64_t v23 = v13[10]) == 0 || v23 + 8 * v16 == v13[11]))
  {
    *(void *)buf = 0x3FF0000000000000;
    LOBYTE(v25) = 1;
    if (v27)
    {
      (*(void (**)(void *, uint8_t *, uint64_t *))(*v27 + 48))(v27, buf, &v25);
      uint64_t v25 = *(void *)buf;
      uint64_t v21 = (void *)gdc::Registry::storage<arComponents::ScaleToApply>(v12);
      gdc::ComponentStorageWrapper<md::ls::CheckIfReadyToProcess>::emplace(v21, v8, &v25);
      goto LABEL_14;
    }
LABEL_23:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  buf[0] = 0;
  if (!v27) {
    goto LABEL_23;
  }
  (*(void (**)(void *))(*v27 + 48))(v27);
LABEL_14:
  uint64_t result = (uint64_t)v27;
  if (v27 == v26) {
    return (*(uint64_t (**)(void *))(v26[0] + 32))(v26);
  }
  if (v27) {
    return (*(uint64_t (**)(void))(*v27 + 40))();
  }
  return result;
}

void sub_1A1F5F4BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::function<void ()(arComponents::ScaleToApply &,BOOL)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<arComponents::ScaleToApply>(int8x8_t *a1)
{
  uint64_t v10 = 0x79E9DCF970528A97;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x79E9DCF970528A97;
    if (*(void *)&v1 <= 0x79E9DCF970528A97uLL) {
      uint64_t v3 = 0x79E9DCF970528A97uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x79E9DCF970528A97;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x79E9DCF970528A97)
      {
        if (v5[2] == 0x79E9DCF970528A97) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x79E9DCF970528A97) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x79E9DCF970528A97) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1F5F70C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void *std::function<void ()(arComponents::ScaleToApply &,BOOL)>::~function(void *a1)
{
  uint8x8_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<arComponents::ScaleToApply>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::ScaleToApply>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(void *)(v14 + 8 * v7) = *(void *)(v15 - 8);
  a1[11] = v15 - 8;
  unint64_t v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    unint64_t v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::ScaleToApply>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::ScaleToApply>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

double std::__function::__func<processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::ScaleToApply &,BOOL)#1},std::allocator<processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::ScaleToApply &,BOOL)#1}>,void ()(arComponents::ScaleToApply &,BOOL)>::operator()(uint64_t a1, double *a2)
{
  double result = *a2 * **(float **)(a1 + 8);
  *a2 = result;
  return result;
}

uint64_t std::__function::__func<processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::ScaleToApply &,BOOL)#1},std::allocator<processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::ScaleToApply &,BOOL)#1}>,void ()(arComponents::ScaleToApply &,BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57E0E8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::ScaleToApply &,BOOL)#1},std::allocator<processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::ScaleToApply &,BOOL)#1}>,void ()(arComponents::ScaleToApply &,BOOL)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF57E0E8;
  result[1] = v3;
  return result;
}

void std::__function::__func<processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::ScaleToApply &,BOOL)#1},std::allocator<processScaleAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::ScaleToApply &,BOOL)#1}>,void ()(arComponents::ScaleToApply &,BOOL)>::~__func()
{
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float>>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(void *)(v14 + 8 * v7) = *(void *)(a1[11] - 8);
  a1[11] -= 8;
  uint64_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    uint64_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)2,float>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t gdc::Registry::storage<arComponents::RotationToApply>(int8x8_t *a1)
{
  uint64_t v10 = 0x23D8CDD6E36C6DAFLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x23D8CDD6E36C6DAFLL;
    if (*(void *)&v1 <= 0x23D8CDD6E36C6DAFuLL) {
      uint64_t v3 = 0x23D8CDD6E36C6DAFuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x23D8CDD6E36C6DAFLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x23D8CDD6E36C6DAFLL)
      {
        if (v5[2] == 0x23D8CDD6E36C6DAFLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x23D8CDD6E36C6DAFLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x23D8CDD6E36C6DAFLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1F5FDE8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void gdc::ComponentStorageWrapper<arComponents::RotationToApply>::emplace(void *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v26 = a2;
  uint64_t v5 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(a1 + 4, (uint64_t)&v26);
  if (v6)
  {
    float v12 = (char *)a1[11];
    unint64_t v11 = a1[12];
    if ((unint64_t)v12 >= v11)
    {
      uint64_t v15 = (char *)a1[10];
      uint64_t v16 = (v12 - v15) >> 4;
      unint64_t v17 = v16 + 1;
      if ((unint64_t)(v16 + 1) >> 60) {
        goto LABEL_30;
      }
      uint64_t v18 = v11 - (void)v15;
      if (v18 >> 3 > v17) {
        unint64_t v17 = v18 >> 3;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v19 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v19 = v17;
      }
      if (v19)
      {
        if (v19 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v20 = (char *)operator new(16 * v19);
      }
      else
      {
        uint64_t v20 = 0;
      }
      uint64_t v21 = &v20[16 * v16];
      *(void *)uint64_t v21 = *a3;
      *((_DWORD *)v21 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)v21 + 3) = *((_DWORD *)a3 + 3);
      uint64_t v14 = v21 + 16;
      if (v12 != v15)
      {
        do
        {
          uint64_t v22 = *((void *)v12 - 2);
          v12 -= 16;
          int v23 = *((_DWORD *)v12 + 2);
          *((void *)v21 - 2) = v22;
          v21 -= 16;
          *((_DWORD *)v21 + 2) = v23;
          *((_DWORD *)v21 + 3) = *((_DWORD *)v12 + 3);
        }
        while (v12 != v15);
        float v12 = (char *)a1[10];
      }
      a1[10] = v21;
      a1[11] = v14;
      a1[12] = &v20[16 * v19];
      if (v12) {
        operator delete(v12);
      }
    }
    else
    {
      uint64_t v13 = *a3;
      *((_DWORD *)v12 + 2) = *((_DWORD *)a3 + 2);
      *(void *)float v12 = v13;
      *((_DWORD *)v12 + 3) = *((_DWORD *)a3 + 3);
      uint64_t v14 = v12 + 16;
    }
    a1[11] = v14;
    uint64_t v8 = a1[31];
  }
  else
  {
    unint64_t v7 = (_DWORD *)(a1[10] + 2 * ((void)v5 - a1[7]));
    *unint64_t v7 = *(_DWORD *)a3;
    v7[1] = *((_DWORD *)a3 + 1);
    v7[2] = *((_DWORD *)a3 + 2);
    v7[3] = *((_DWORD *)a3 + 3);
    uint64_t v8 = a1[31];
    if (v7 != (_DWORD *)a1[11])
    {
      uint64_t v9 = (void *)a1[16];
      if (v9)
      {
        while (1)
        {
          v28 = &v26;
          uint64_t v29 = 1;
          uint64_t v27 = v8;
          uint64_t v10 = v9[6];
          if (!v10) {
            break;
          }
          (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v10 + 48))(v10, &v27, &v28);
          uint64_t v9 = (void *)*v9;
          if (!v9) {
            return;
          }
        }
LABEL_29:
        std::__throw_bad_function_call[abi:nn180100]();
LABEL_30:
        abort();
      }
      return;
    }
  }
  float v24 = (void *)a1[22];
  if (v24)
  {
    while (1)
    {
      v28 = &v26;
      uint64_t v29 = 1;
      uint64_t v27 = v8;
      uint64_t v25 = v24[6];
      if (!v25) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v25 + 48))(v25, &v27, &v28);
      float v24 = (void *)*v24;
      if (!v24) {
        return;
      }
    }
    goto LABEL_29;
  }
}

void *std::function<void ()(arComponents::RotationToApply &,BOOL)>::~function(void *a1)
{
  uint8x8_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<arComponents::RotationToApply>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::RotationToApply>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = (_DWORD *)(a1[10] + 16 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = (_DWORD *)a1[11];
  int v16 = *(v15 - 4);
  v15 -= 4;
  *uint64_t v14 = v16;
  v14[1] = v15[1];
  v14[2] = v15[2];
  v14[3] = v15[3];
  a1[11] = v15;
  unint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    unint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::RotationToApply>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::RotationToApply>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

float std::__function::__func<processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::RotationToApply &,BOOL)#1},std::allocator<processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::RotationToApply &,BOOL)#1}>,void ()(arComponents::RotationToApply &,BOOL)>::operator()(uint64_t a1, float *a2)
{
  uint64_t v2 = *(float **)(a1 + 8);
  float v3 = v2[1];
  float v5 = a2[2];
  float v4 = a2[3];
  float v6 = v2[2];
  float v7 = v2[3];
  float v8 = a2[1];
  float v9 = (float)((float)(v8 * v7) - (float)((float)(*a2 * v6) - (float)(v3 * v4))) + (float)(v5 * *v2);
  float v10 = (float)((float)((float)(v6 * v4) + (float)(*a2 * v3)) - (float)(v8 * *v2)) + (float)(v5 * v7);
  float v11 = (float)((float)(*a2 * *v2) + (float)(v8 * v3)) + (float)(v5 * v6);
  *a2 = (float)((float)((float)(*v2 * v4) + (float)(*a2 * v7)) + (float)(v8 * v6)) - (float)(v5 * v3);
  a2[1] = v9;
  float result = -(float)(v11 - (float)(v7 * v4));
  a2[2] = v10;
  a2[3] = result;
  return result;
}

uint64_t std::__function::__func<processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::RotationToApply &,BOOL)#1},std::allocator<processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::RotationToApply &,BOOL)#1}>,void ()(arComponents::RotationToApply &,BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57E130;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::RotationToApply &,BOOL)#1},std::allocator<processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::RotationToApply &,BOOL)#1}>,void ()(arComponents::RotationToApply &,BOOL)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_1EF57E130;
  result[1] = v3;
  return result;
}

void std::__function::__func<processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::RotationToApply &,BOOL)#1},std::allocator<processRotationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::RotationToApply &,BOOL)#1}>,void ()(arComponents::RotationToApply &,BOOL)>::~__func()
{
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>>>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = (_DWORD *)(a1[10] + 24 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = (_DWORD *)a1[11];
  int v16 = *(v15 - 6);
  v15 -= 6;
  *uint64_t v14 = v16;
  v14[1] = v15[1];
  v14[2] = v15[2];
  v14[3] = v15[3];
  v14[4] = v15[4];
  v14[5] = v15[5];
  a1[11] = v15;
  unint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    unint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)1,gm::Matrix<float,3,1>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t gdc::Registry::storage<arComponents::UpRelativeTranslationToApply>(int8x8_t *a1)
{
  uint64_t v10 = 0x12D112A384BC02BDLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x12D112A384BC02BDLL;
    if (*(void *)&v1 <= 0x12D112A384BC02BDuLL) {
      uint64_t v3 = 0x12D112A384BC02BDuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x12D112A384BC02BDLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x12D112A384BC02BDLL)
      {
        if (v5[2] == 0x12D112A384BC02BDLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x12D112A384BC02BDLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x12D112A384BC02BDLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1F60780(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void *std::function<void ()(arComponents::UpRelativeTranslationToApply &,BOOL)>::~function(void *a1)
{
  uint8x8_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<arComponents::UpRelativeTranslationToApply>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::UpRelativeTranslationToApply>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(void *)(v14 + 8 * v7) = *(void *)(v15 - 8);
  a1[11] = v15 - 8;
  int v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    int v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::UpRelativeTranslationToApply>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::UpRelativeTranslationToApply>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

double std::__function::__func<processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::UpRelativeTranslationToApply &,BOOL)#1},std::allocator<processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::UpRelativeTranslationToApply &,BOOL)#1}>,void ()(arComponents::UpRelativeTranslationToApply &,BOOL)>::operator()(uint64_t a1, double *a2)
{
  double result = *a2 + **(double **)(a1 + 8);
  *a2 = result;
  return result;
}

uint64_t std::__function::__func<processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::UpRelativeTranslationToApply &,BOOL)#1},std::allocator<processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::UpRelativeTranslationToApply &,BOOL)#1}>,void ()(arComponents::UpRelativeTranslationToApply &,BOOL)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57E178;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::UpRelativeTranslationToApply &,BOOL)#1},std::allocator<processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::UpRelativeTranslationToApply &,BOOL)#1}>,void ()(arComponents::UpRelativeTranslationToApply &,BOOL)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF57E178;
  result[1] = v3;
  return result;
}

void std::__function::__func<processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::UpRelativeTranslationToApply &,BOOL)#1},std::allocator<processTranslationAnimations(gdc::Registry *,std::unordered_map<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>> &,gdc::CameraType const&)::$_0::operator() const(gdc::Entity,arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>> &,arComponents::AnimationDuration &,arComponents::AnimationInfo &)::{lambda(arComponents::UpRelativeTranslationToApply &,BOOL)#1}>,void ()(arComponents::UpRelativeTranslationToApply &,BOOL)>::~__func()
{
}

uint64_t gdc::Registry::storage<arComponents::AnimationEntityStatus<(VKAnimationState)3>>(int8x8_t *a1)
{
  uint64_t v10 = 0x24F0F36C0DDEC215;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x24F0F36C0DDEC215;
    if (*(void *)&v1 <= 0x24F0F36C0DDEC215uLL) {
      uint64_t v3 = 0x24F0F36C0DDEC215uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x24F0F36C0DDEC215;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x24F0F36C0DDEC215)
      {
        if (v5[2] == 0x24F0F36C0DDEC215) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x24F0F36C0DDEC215) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x24F0F36C0DDEC215) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1F60CB4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<arComponents::AnimationEntityStatus<(VKAnimationState)1>>(int8x8_t *a1)
{
  uint64_t v10 = 0x21CF515ED2058BBDLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x21CF515ED2058BBDLL;
    if (*(void *)&v1 <= 0x21CF515ED2058BBDuLL) {
      uint64_t v3 = 0x21CF515ED2058BBDuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x21CF515ED2058BBDLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x21CF515ED2058BBDLL)
      {
        if (v5[2] == 0x21CF515ED2058BBDLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x21CF515ED2058BBDLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x21CF515ED2058BBDLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1F60F24(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)1>>::remove(void *a1, unint64_t a2)
{
  unint64_t v21 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(void *)(v14 + 8 * v7) = *(void *)(v15 - 8);
  a1[11] = v15 - 8;
  int v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v23[0] = &v21;
    v23[1] = 1;
    uint64_t v22 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v22, v23);
    int v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)1>>::contains(v19, v20);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)1>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)1>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)3>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)3>>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(void *)(v14 + 8 * v7) = *(void *)(v15 - 8);
  a1[11] = v15 - 8;
  int v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    int v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)3>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::AnimationEntityStatus<(VKAnimationState)3>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::NeedsPropagateActive>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::NeedsPropagateActive>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::NeedsPropagateFinished>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::NeedsPropagateFinished>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void md::ARAnimationLogic::createAnimations(void)::$_0::operator()(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v87[3] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *a1;
  if (GEOGetVectorKitARAnimationLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitARAnimationLog_onceToken, &__block_literal_global_45);
  }
  uint64_t v8 = (id)GEOGetVectorKitARAnimationLog_log;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
  {
    int v9 = *(_DWORD *)(a4 + 12);
    double v10 = *(float *)a3;
    *(_DWORD *)buf = 67109376;
    *(_DWORD *)&buf[4] = v9;
    LOWORD(v87[0]) = 2048;
    *(double *)((char *)v87 + 2) = v10;
    _os_log_impl(&dword_1A1780000, v8, OS_LOG_TYPE_INFO, "Animating : Starting animation: %d duration: %f", buf, 0x12u);
  }

  uint64_t v11 = [[VKTimedAnimation alloc] initWithDuration:*(float *)a3];
  *(_DWORD *)(a3 + 8) = 0;
  [(VKTimedAnimation *)v11 setTimingFunction:*(void *)(a3 + 16)];
  int v76 = *((_DWORD *)std::__hash_table<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::__unordered_map_hasher<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::hash<gdc::EntityId>,std::equal_to<gdc::EntityId>,true>,std::__unordered_map_equal<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::equal_to<gdc::EntityId>,std::hash<gdc::EntityId>,true>,std::allocator<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>>>::__emplace_unique_key_args<gdc::EntityId,std::piecewise_construct_t const&,std::tuple<gdc::EntityId const&>,std::tuple<>>((uint64_t *)(v7 + 128), *(void *)a4, (void *)a4)+ 12);
  int v83 = v76;
  uint64_t v13 = *(void *)(v7 + 176);
  float v12 = *(std::__shared_weak_count **)(v7 + 184);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v80[0] = MEMORY[0x1E4F143A8];
  v80[1] = 3321888768;
  v80[2] = ___ZZN2md16ARAnimationLogic16createAnimationsEvENK3__0clEN3gdc6EntityERN12arComponents17AnimationDurationERNS4_13AnimationInfoE_block_invoke;
  v80[3] = &__block_descriptor_56_ea8_32c73_ZTSNSt3__18weak_ptrIN2md16ARAnimationLogic25ARAnimationLogicWeakProxyEEE_e8_v12__0f8l;
  v80[4] = v13;
  v81 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v82 = a2;
  -[VKTimedAnimation setStepHandler:](v11, "setStepHandler:", v80, v7 + 128);
  v77[0] = MEMORY[0x1E4F143A8];
  v77[1] = 3321888768;
  v77[2] = ___ZZN2md16ARAnimationLogic16createAnimationsEvENK3__0clEN3gdc6EntityERN12arComponents17AnimationDurationERNS4_13AnimationInfoE_block_invoke_54;
  v77[3] = &__block_descriptor_56_ea8_32c73_ZTSNSt3__18weak_ptrIN2md16ARAnimationLogic25ARAnimationLogicWeakProxyEEE_e8_v12__0B8l;
  v77[4] = v13;
  v78 = v12;
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v79 = a2;
  [(VKAnimation *)v11 setCompletionHandler:v77];
  md::AnimationRunner::runAnimation(*(md::MapEngine ***)(v7 + 168), &v11->super);
  uint64_t v14 = (void *)gdc::Registry::storage<arComponents::AnimationState<(VKAnimationState)1>>(*(int8x8_t **)(v7 + 120));
  uint64_t v84 = a2;
  uint64_t v15 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v14 + 4, (uint64_t)&v84);
  if (v16)
  {
    unint64_t v21 = (unsigned char *)v14[11];
    unint64_t v20 = v14[12];
    if ((unint64_t)v21 >= v20)
    {
      int v23 = (char *)v14[10];
      uint64_t v24 = v21 - v23;
      uint64_t v25 = v21 - v23 + 1;
      if (v25 < 0) {
        goto LABEL_91;
      }
      unint64_t v26 = v20 - (void)v23;
      if (2 * v26 > v25) {
        uint64_t v25 = 2 * v26;
      }
      if (v26 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v27 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v27 = v25;
      }
      if (v27) {
        v28 = (char *)operator new(v27);
      }
      else {
        v28 = 0;
      }
      uint64_t v29 = &v28[v24];
      uint64_t v22 = (uint64_t)&v28[v24 + 1];
      double v30 = (char *)(v23 - v21);
      if (v23 == v21) {
        double v30 = 0;
      }
      v14[10] = &v30[(void)v29];
      v14[11] = v22;
      v14[12] = &v28[v27];
      if (v23) {
        operator delete(v23);
      }
    }
    else
    {
      uint64_t v22 = (uint64_t)(v21 + 1);
    }
    v14[11] = v22;
    uint64_t v17 = v14[31];
  }
  else
  {
    uint64_t v17 = v14[31];
    if (v14[10] + (((uint64_t)v15 - v14[7]) >> 3) != v14[11])
    {
      uint64_t v18 = (void *)v14[16];
      if (v18)
      {
        while (1)
        {
          *(void *)buf = &v84;
          v87[0] = 1;
          uint64_t v85 = v17;
          uint64_t v19 = v18[6];
          if (!v19) {
            goto LABEL_90;
          }
          (*(void (**)(uint64_t, uint64_t *, uint8_t *))(*(void *)v19 + 48))(v19, &v85, buf);
          uint64_t v18 = (void *)*v18;
          if (!v18) {
            goto LABEL_36;
          }
        }
      }
      goto LABEL_36;
    }
  }
  uint64_t v31 = (void *)v14[22];
  if (v31)
  {
    while (1)
    {
      *(void *)buf = &v84;
      v87[0] = 1;
      uint64_t v85 = v17;
      uint64_t v32 = v31[6];
      if (!v32) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint8_t *))(*(void *)v32 + 48))(v32, &v85, buf);
      uint64_t v31 = (void *)*v31;
      if (!v31) {
        goto LABEL_36;
      }
    }
LABEL_90:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
LABEL_36:
  int v33 = (void *)gdc::Registry::storage<arComponents::NeedsPropagateActive>(*(int8x8_t **)(v7 + 120));
  uint64_t v84 = a2;
  v34 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v33 + 4, (uint64_t)&v84);
  if (v35)
  {
    uint64_t v40 = (unsigned char *)v33[11];
    unint64_t v39 = v33[12];
    if ((unint64_t)v40 >= v39)
    {
      unint64_t v42 = (char *)v33[10];
      uint64_t v43 = v40 - v42;
      uint64_t v44 = v40 - v42 + 1;
      if (v44 < 0) {
        goto LABEL_91;
      }
      unint64_t v45 = v39 - (void)v42;
      if (2 * v45 > v44) {
        uint64_t v44 = 2 * v45;
      }
      if (v45 >= 0x3FFFFFFFFFFFFFFFLL) {
        size_t v46 = 0x7FFFFFFFFFFFFFFFLL;
      }
      else {
        size_t v46 = v44;
      }
      if (v46) {
        v47 = (char *)operator new(v46);
      }
      else {
        v47 = 0;
      }
      unint64_t v48 = &v47[v43];
      uint64_t v41 = (uint64_t)&v47[v43 + 1];
      uint64_t v49 = (char *)(v42 - v40);
      if (v42 == v40) {
        uint64_t v49 = 0;
      }
      v33[10] = &v49[(void)v48];
      v33[11] = v41;
      v33[12] = &v47[v46];
      if (v42) {
        operator delete(v42);
      }
    }
    else
    {
      uint64_t v41 = (uint64_t)(v40 + 1);
    }
    v33[11] = v41;
    uint64_t v36 = v33[31];
  }
  else
  {
    uint64_t v36 = v33[31];
    if (v33[10] + (((uint64_t)v34 - v33[7]) >> 3) != v33[11])
    {
      uint64_t v37 = (void *)v33[16];
      if (v37)
      {
        while (1)
        {
          *(void *)buf = &v84;
          v87[0] = 1;
          uint64_t v85 = v36;
          uint64_t v38 = v37[6];
          if (!v38) {
            goto LABEL_90;
          }
          (*(void (**)(uint64_t, uint64_t *, uint8_t *))(*(void *)v38 + 48))(v38, &v85, buf);
          uint64_t v37 = (void *)*v37;
          if (!v37) {
            goto LABEL_61;
          }
        }
      }
      goto LABEL_61;
    }
  }
  for (i = (void *)v33[22]; i; i = (void *)*i)
  {
    *(void *)buf = &v84;
    v87[0] = 1;
    uint64_t v85 = v36;
    uint64_t v51 = i[6];
    if (!v51) {
      goto LABEL_90;
    }
    (*(void (**)(uint64_t, uint64_t *, uint8_t *))(*(void *)v51 + 48))(v51, &v85, buf);
  }
LABEL_61:
  *(_DWORD *)(a4 + 8) = v76;
  uint64_t v52 = std::__hash_table<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::__unordered_map_hasher<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::hash<gdc::EntityId>,std::equal_to<gdc::EntityId>,true>,std::__unordered_map_equal<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::equal_to<gdc::EntityId>,std::hash<gdc::EntityId>,true>,std::allocator<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>>>::__emplace_unique_key_args<gdc::EntityId,std::piecewise_construct_t const&,std::tuple<gdc::EntityId const&>,std::tuple<>>(v74, *(void *)a4, (void *)a4);
  long long v53 = (id *)std::__hash_table<std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::__unordered_map_hasher<int,std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,VKTimedAnimation * {__strong}>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)(v52 + 12), v76, &v83);
  objc_storeStrong(v53 + 3, v11);
  uint64_t v54 = (char **)a1[1];
  uint64_t v56 = v54[1];
  unint64_t v55 = (unint64_t)v54[2];
  if ((unint64_t)v56 < v55)
  {
    *(void *)uint64_t v56 = a2;
    v57 = v56 + 8;
    goto LABEL_83;
  }
  uint64_t v58 = *v54;
  uint64_t v59 = v56 - *v54;
  uint64_t v60 = v59 >> 3;
  unint64_t v61 = (v59 >> 3) + 1;
  if (v61 >> 61) {
LABEL_91:
  }
    abort();
  uint64_t v62 = v55 - (void)v58;
  if (v62 >> 2 > v61) {
    unint64_t v61 = v62 >> 2;
  }
  if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v63 = v61;
  }
  if (v63)
  {
    if (v63 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    v64 = operator new(8 * v63);
  }
  else
  {
    v64 = 0;
  }
  v65 = &v64[8 * v60];
  v66 = &v64[8 * v63];
  *(void *)v65 = a2;
  v57 = v65 + 8;
  if (v56 != v58)
  {
    unint64_t v67 = v56 - v58 - 8;
    if (v67 < 0x58) {
      goto LABEL_95;
    }
    if ((unint64_t)(v56 - v64 - v59) < 0x20) {
      goto LABEL_95;
    }
    uint64_t v68 = (v67 >> 3) + 1;
    v69 = &v64[8 * v60 - 16];
    v70 = v56 - 16;
    uint64_t v71 = v68 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v72 = *(_OWORD *)v70;
      *(v69 - 1) = *((_OWORD *)v70 - 1);
      _OWORD *v69 = v72;
      v69 -= 2;
      v70 -= 32;
      v71 -= 4;
    }
    while (v71);
    v65 -= 8 * (v68 & 0x3FFFFFFFFFFFFFFCLL);
    v56 -= 8 * (v68 & 0x3FFFFFFFFFFFFFFCLL);
    if (v68 != (v68 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_95:
      do
      {
        uint64_t v73 = *((void *)v56 - 1);
        v56 -= 8;
        *((void *)v65 - 1) = v73;
        v65 -= 8;
      }
      while (v56 != v58);
    }
    uint64_t v56 = *v54;
  }
  *uint64_t v54 = v65;
  v54[1] = v57;
  v54[2] = v66;
  if (v56) {
    operator delete(v56);
  }
LABEL_83:
  v54[1] = v57;
  if (v78) {
    std::__shared_weak_count::__release_weak(v78);
  }
  if (v81) {
    std::__shared_weak_count::__release_weak(v81);
  }
  if (v12) {
    std::__shared_weak_count::__release_weak(v12);
  }
}

void sub_1A1F61A94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, std::__shared_weak_count *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a17)
  {
    std::__shared_weak_count::__release_weak(a17);
    size_t v27 = a24;
    if (!a24)
    {
LABEL_3:
      if (!v25) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  else
  {
    size_t v27 = a24;
    if (!a24) {
      goto LABEL_3;
    }
  }
  std::__shared_weak_count::__release_weak(v27);
  if (!v25)
  {
LABEL_5:

    _Unwind_Resume(a1);
  }
LABEL_4:
  std::__shared_weak_count::__release_weak(v25);
  goto LABEL_5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationState<(VKAnimationState)0>>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::ReadyToStartAnimation>::remove();
}

uint64_t gdc::ComponentStorageWrapper<arComponents::ReadyToStartAnimation>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v21, v22);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return (uint64_t)std::__hash_table<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::__unordered_map_hasher<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::hash<gdc::EntityId>,std::equal_to<gdc::EntityId>,true>,std::__unordered_map_equal<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::equal_to<gdc::EntityId>,std::hash<gdc::EntityId>,true>,std::allocator<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>>>::__emplace_unique_key_args<gdc::EntityId,std::piecewise_construct_t const&,std::tuple<gdc::EntityId const&>,std::tuple<>>(v17, v18, v19);
}

unsigned __int16 *std::__hash_table<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::__unordered_map_hasher<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::hash<gdc::EntityId>,std::equal_to<gdc::EntityId>,true>,std::__unordered_map_equal<gdc::EntityId,std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,std::equal_to<gdc::EntityId>,std::hash<gdc::EntityId>,true>,std::allocator<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>>>::__emplace_unique_key_args<gdc::EntityId,std::piecewise_construct_t const&,std::tuple<gdc::EntityId const&>,std::tuple<>>(uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = (unsigned __int16 *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = *((void *)v10 + 1);
            if (v12 == a2)
            {
              if (__PAIR64__(v10[9], v10[8]) == __PAIR64__(WORD1(a2), (unsigned __int16)a2)
                && *((_DWORD *)v10 + 5) == HIDWORD(a2))
              {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_25;
            }
            unint64_t v10 = *(unsigned __int16 **)v10;
            if (!v10) {
              goto LABEL_25;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (__PAIR64__(v10[9], v10[8]) == __PAIR64__(WORD1(a2), (unsigned __int16)a2)
              && *((_DWORD *)v10 + 5) == HIDWORD(a2))
            {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = *(unsigned __int16 **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_25:
  uint64_t v13 = a1 + 2;
  unint64_t v10 = (unsigned __int16 *)operator new(0x40uLL);
  *(void *)unint64_t v10 = 0;
  *((void *)v10 + 1) = v5;
  *((void *)v10 + 2) = *a3;
  *(_OWORD *)(v10 + 12) = 0u;
  *(_OWORD *)(v10 + 20) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
    goto LABEL_75;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = a1[1];
  }
  if (prime > v7)
  {
LABEL_38:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v20 = operator new(8 * prime);
    uint64_t v21 = (void *)*a1;
    *a1 = (uint64_t)v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v22++) = 0;
    while (prime != v22);
    int v23 = (void *)*v13;
    if (!*v13) {
      goto LABEL_62;
    }
    size_t v24 = v23[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*a1 + 8 * v26) = v13;
      for (i = (void *)*v23; *v23; i = (void *)*v23)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          int v23 = i;
        }
        else if (*(void *)(*a1 + 8 * v28))
        {
          void *v23 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*a1 + v29);
          **(void **)(*a1 + v29) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v28) = v23;
          int v23 = i;
          size_t v26 = v28;
        }
      }
LABEL_62:
      unint64_t v7 = prime;
      goto LABEL_63;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*a1 + 8 * v24) = v13;
    int v33 = (void *)*v23;
    if (!*v23) {
      goto LABEL_62;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*a1 + 8 * v35))
        {
          *(void *)(*a1 + 8 * v35) = v23;
          goto LABEL_67;
        }
        void *v23 = *v33;
        uint64_t v34 = 8 * v35;
        *int v33 = **(void **)(*a1 + v34);
        **(void **)(*a1 + v34) = v33;
        int v33 = v23;
      }
      size_t v35 = v24;
LABEL_67:
      int v23 = v33;
      int v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_62;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_63;
  }
  unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      uint64_t v40 = (void *)*a1;
      *a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_63;
    }
    goto LABEL_38;
  }
  unint64_t v7 = a1[1];
LABEL_63:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_75:
  uint64_t v36 = *a1;
  uint64_t v37 = *(void **)(*a1 + 8 * v5);
  if (v37)
  {
    *(void *)unint64_t v10 = *v37;
LABEL_83:
    void *v37 = v10;
    goto LABEL_84;
  }
  *(void *)unint64_t v10 = *v13;
  *uint64_t v13 = v10;
  *(void *)(v36 + 8 * v5) = v13;
  if (*(void *)v10)
  {
    unint64_t v38 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    uint64_t v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_83;
  }
LABEL_84:
  ++a1[3];
  return v10;
}

void sub_1A1F621C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZZN2md16ARAnimationLogic16createAnimationsEvENK3__0clEN3gdc6EntityERN12arComponents17AnimationDurationERNS4_13AnimationInfoE_block_invoke(void *a1, float a2)
{
  unint64_t v3 = (std::__shared_weak_count *)a1[5];
  if (v3)
  {
    unint64_t v5 = std::__shared_weak_count::lock(v3);
    if (v5)
    {
      uint64_t v6 = v5;
      uint64_t v7 = a1[4];
      if (v7)
      {
        uint64_t v8 = *(void *)(v7 + 16);
        if (v8)
        {
          uint64_t v9 = *(int8x8_t **)(v8 + 120);
          if (v9)
          {
            unint64_t v10 = a1[6];
            if (v9[5].u16[0] == (unsigned __int16)v10)
            {
              int8x8_t v11 = v9[6];
              if (HIDWORD(v10) < (unint64_t)((uint64_t)(*(void *)&v9[7] - *(void *)&v11) >> 3))
              {
                uint64_t v12 = (unsigned __int16 *)(*(void *)&v11 + 8 * HIDWORD(v10));
                if (*v12 == (unsigned __int16)v10 && v12[1] == WORD1(v10) && *((_DWORD *)v12 + 1) == HIDWORD(v10))
                {
                  uint64_t v13 = (void *)gdc::Registry::storage<arComponents::AnimationDuration>(v9);
                  uint64_t v14 = v13[4];
                  if (v10 >> 39 < (v13[5] - v14) >> 3)
                  {
                    uint64_t v15 = *(void *)(v14 + 8 * (v10 >> 39));
                    if (v15)
                    {
                      unint64_t v16 = *(unsigned __int16 *)(v15 + 2 * (HIDWORD(v10) & 0x7F));
                      uint64_t v18 = v13[7];
                      uint64_t v17 = v13[8];
                      if (v16 < (v17 - v18) >> 3)
                      {
                        uint64_t v19 = v18 + 8 * v16;
                        if (v19 != v17 && *(_DWORD *)(v19 + 4) == HIDWORD(v10))
                        {
                          uint64_t v21 = v13[10];
                          if (v21)
                          {
                            if (v21 + 24 * v16 != v13[11]) {
                              *(float *)(v21 + 24 * v16 + 8) = a2;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_1A1F6236C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ___ZZN2md16ARAnimationLogic16createAnimationsEvENK3__0clEN3gdc6EntityERN12arComponents17AnimationDurationERNS4_13AnimationInfoE_block_invoke_54(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[5];
  if (v2)
  {
    unint64_t v3 = std::__shared_weak_count::lock(v2);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = a1[4];
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 16);
        if (v6)
        {
          uint64_t v7 = *(int8x8_t **)(v6 + 120);
          if (v7)
          {
            unint64_t v8 = a1[6];
            if (v7[5].u16[0] == (unsigned __int16)v8)
            {
              int8x8_t v9 = v7[6];
              if (HIDWORD(v8) < (unint64_t)((uint64_t)(*(void *)&v7[7] - *(void *)&v9) >> 3))
              {
                unint64_t v10 = (unsigned __int16 *)(*(void *)&v9 + 8 * HIDWORD(v8));
                if (*v10 == (unsigned __int16)v8 && v10[1] == WORD1(v8) && *((_DWORD *)v10 + 1) == HIDWORD(v8))
                {
                  int8x8_t v11 = (void *)gdc::Registry::storage<arComponents::AnimationState<(VKAnimationState)1>>(v7);
                  gdc::ComponentStorageWrapper<arComponents::AnimationState<(VKAnimationState)1>>::remove(v11, v8);
                  uint64_t v12 = (void *)gdc::Registry::storage<arComponents::AnimationState<(VKAnimationState)3>>(*(int8x8_t **)(v6 + 120));
                  gdc::ComponentStorageWrapper<md::components::Collapsible>::emplace(v12, v8);
                }
              }
            }
          }
        }
      }
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1A1F624B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void *std::__hash_table<std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::__unordered_map_hasher<int,std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,VKTimedAnimation * {__strong}>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    int8x8_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = (void *)(a1 + 16);
  unint64_t v10 = operator new(0x20uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v10[3] = 0;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_34;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  size_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *unint64_t v10 = *v24;
LABEL_58:
    void *v24 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *v13;
  *uint64_t v13 = v10;
  *(void *)(v23 + 8 * v3) = v13;
  if (*v10)
  {
    unint64_t v25 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    size_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A1F627AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<int,VKTimedAnimation * {__strong}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,VKTimedAnimation * {__strong}>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<int,VKTimedAnimation * {__strong}>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<int,VKTimedAnimation * {__strong}>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(id **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {

    }
    operator delete(v2);
  }
  return a1;
}

void __destroy_helper_block_ea8_32c73_ZTSNSt3__18weak_ptrIN2md16ARAnimationLogic25ARAnimationLogicWeakProxyEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_32c73_ZTSNSt3__18weak_ptrIN2md16ARAnimationLogic25ARAnimationLogicWeakProxyEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::EntityId,std::unordered_map<int,VKTimedAnimation * {__strong}>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      unint64_t v3 = (id *)v2[5];
      if (v3)
      {
        do
        {
          uint64_t v4 = (id *)*v3;

          operator delete(v3);
          unint64_t v3 = v4;
        }
        while (v4);
      }
      uint64_t v5 = (void *)v2[3];
      v2[3] = 0;
      if (v5) {
        operator delete(v5);
      }
    }
    operator delete(v2);
  }
  return a1;
}

void std::__shared_ptr_emplace<md::ARAnimationLogic::ARAnimationLogicWeakProxy>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 32);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void std::__shared_ptr_emplace<md::ARAnimationLogic::ARAnimationLogicWeakProxy>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580170;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ARAnimationLogic::ARAnimationLogicWeakProxy>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580170;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL gdc::ComponentStorageWrapper<arComponents::ReadyToStartAnimation>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::ReadyToStartAnimation>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::TimeBasedStart>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::TimeBasedStart>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  float v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    float v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::TimeBasedStart>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::TimeBasedStart>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationState<(VKAnimationState)0>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::AnimationState<(VKAnimationState)0>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>>>::remove(void *a1, unint64_t a2)
{
  unint64_t v20 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  float v14 = (_DWORD *)(a1[10] + 24 * v7);
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = (_DWORD *)a1[11];
  int v16 = *(v15 - 6);
  v15 -= 6;
  *float v14 = v16;
  v14[1] = v15[1];
  v14[2] = v15[2];
  v14[3] = v15[3];
  v14[4] = v15[4];
  v14[5] = v15[5];
  a1[11] = v15;
  unint64_t v17 = (void *)a1[28];
  if (!v17) {
    return 1;
  }
  uint64_t v18 = a1[31];
  while (1)
  {
    v22[0] = &v20;
    v22[1] = 1;
    uint64_t v21 = v18;
    uint64_t v19 = v17[6];
    if (!v19) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v19 + 48))(v19, &v21, v22);
    unint64_t v17 = (void *)*v17;
    if (!v17) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>>>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::AnimationTarget<(arComponents::AnimationProperty)0,gm::Matrix<float,3,1>>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationDependencyOn>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationDependencyOn>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(void *)(v14 + 8 * v7) = *(void *)(a1[11] - 8);
  a1[11] -= 8;
  uint64_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    uint64_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationDependencyOn>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::AnimationDependencyOn>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationGroupProgress>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationGroupProgress>::remove(void *a1, unint64_t a2)
{
  unint64_t v19 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  *(_DWORD *)(v14 + 4 * v7) = *(_DWORD *)(v15 - 4);
  a1[11] = v15 - 4;
  uint64_t v16 = (void *)a1[28];
  if (!v16) {
    return 1;
  }
  uint64_t v17 = a1[31];
  while (1)
  {
    v21[0] = &v19;
    v21[1] = 1;
    uint64_t v20 = v17;
    uint64_t v18 = v16[6];
    if (!v18) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v18 + 48))(v18, &v20, v21);
    uint64_t v16 = (void *)*v16;
    if (!v16) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationGroupProgress>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::AnimationGroupProgress>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::CreateJumpAndRotateAnimation>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::CreateJumpAndRotateAnimation>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void stopAndReleaseAnimation(unint64_t a1, int a2, void *a3, uint64_t a4)
{
  int v42 = a2;
  uint64_t v7 = std::__hash_table<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::__unordered_map_hasher<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,true>,std::__unordered_map_equal<gdc::Entity,std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>,std::equal_to<gdc::Entity>,std::hash<gdc::Entity>,true>,std::allocator<std::__hash_value_type<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>::find<gdc::Entity>(a3, a1);
  if (!v7) {
    return;
  }
  uint64_t v8 = v7;
  *(_OWORD *)__p = 0u;
  long long v40 = 0u;
  float v41 = *((float *)v7 + 14);
  size_t prime = v7[4];
  if (prime != 1)
  {
    if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(v7[4]);
      uint64_t v34 = __p[1];
      BOOL v35 = (void *)prime >= __p[1];
      if ((void *)prime > __p[1]) {
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v34 = 0;
      BOOL v35 = 1;
      if (prime) {
        goto LABEL_4;
      }
    }
    if (v35) {
      goto LABEL_5;
    }
    unint64_t v36 = vcvtps_u32_f32((float)*((unint64_t *)&v40 + 1) / v41);
    if ((unint64_t)v34 < 3
      || (uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v34), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
    {
      unint64_t v36 = std::__next_prime(v36);
    }
    else
    {
      uint64_t v38 = 1 << -(char)__clz(v36 - 1);
      if (v36 >= 2) {
        unint64_t v36 = v38;
      }
    }
    if (prime <= v36) {
      size_t prime = v36;
    }
    if (prime >= (unint64_t)v34) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  size_t prime = 2;
LABEL_4:
  std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)__p, prime);
LABEL_5:
  for (uint64_t i = v8[5]; i; uint64_t i = *(void *)i)
  {
    unint64_t v11 = *(int *)(i + 16);
    unint64_t v12 = (unint64_t)__p[1];
    if (__p[1])
    {
      uint8x8_t v13 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
      v13.i16[0] = vaddlv_u8(v13);
      if (v13.u32[0] > 1uLL)
      {
        unint64_t v4 = *(int *)(i + 16);
        if (__p[1] <= (void *)v11) {
          unint64_t v4 = v11 % (unint64_t)__p[1];
        }
      }
      else
      {
        unint64_t v4 = ((unint64_t)__p[1] - 1) & v11;
      }
      uint64_t v14 = (uint64_t **)*((void *)__p[0] + v4);
      if (v14)
      {
        uint64_t v15 = *v14;
        if (v15)
        {
          if (v13.u32[0] < 2uLL)
          {
            while (1)
            {
              unint64_t v17 = v15[1];
              if (v17 == v11)
              {
                if (*((_DWORD *)v15 + 4) == v11) {
                  goto LABEL_64;
                }
              }
              else if ((v17 & ((unint64_t)__p[1] - 1)) != v4)
              {
                goto LABEL_26;
              }
              uint64_t v15 = (uint64_t *)*v15;
              if (!v15) {
                goto LABEL_26;
              }
            }
          }
          do
          {
            unint64_t v16 = v15[1];
            if (v16 == v11)
            {
              if (*((_DWORD *)v15 + 4) == v11) {
                goto LABEL_64;
              }
            }
            else
            {
              if ((void *)v16 >= __p[1]) {
                v16 %= (unint64_t)__p[1];
              }
              if (v16 != v4) {
                break;
              }
            }
            uint64_t v15 = (uint64_t *)*v15;
          }
          while (v15);
        }
      }
    }
LABEL_26:
    uint64_t v18 = operator new(0x20uLL);
    uint64_t v43 = v18;
    uint64_t v44 = &v40;
    *uint64_t v18 = 0;
    v18[1] = v11;
    *((_DWORD *)v18 + 4) = *(_DWORD *)(i + 16);
    v18[3] = *(id *)(i + 24);
    char v45 = 1;
    float v19 = (float)(unint64_t)(*((void *)&v40 + 1) + 1);
    if (!v12 || (float)(v41 * (float)v12) < v19)
    {
      BOOL v20 = (v12 & (v12 - 1)) != 0;
      if (v12 < 3) {
        BOOL v20 = 1;
      }
      unint64_t v21 = v20 | (2 * v12);
      unint64_t v22 = vcvtps_u32_f32(v19 / v41);
      if (v21 <= v22) {
        size_t v23 = v22;
      }
      else {
        size_t v23 = v21;
      }
      if (v23 == 1)
      {
        size_t v23 = 2;
      }
      else if ((v23 & (v23 - 1)) != 0)
      {
        size_t v23 = std::__next_prime(v23);
      }
      size_t v24 = __p[1];
      if ((void *)v23 > __p[1]) {
        goto LABEL_38;
      }
      if ((void *)v23 < __p[1])
      {
        unint64_t v25 = vcvtps_u32_f32((float)*((unint64_t *)&v40 + 1) / v41);
        if (__p[1] < (void *)3
          || (uint8x8_t v26 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
        {
          unint64_t v25 = std::__next_prime(v25);
        }
        else
        {
          uint64_t v27 = 1 << -(char)__clz(v25 - 1);
          if (v25 >= 2) {
            unint64_t v25 = v27;
          }
        }
        if (v23 <= v25) {
          size_t v23 = v25;
        }
        if (v23 < (unint64_t)v24) {
LABEL_38:
        }
          std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)__p, v23);
      }
      unint64_t v12 = (unint64_t)__p[1];
      if (((unint64_t)__p[1] & ((unint64_t)__p[1] - 1)) != 0)
      {
        if (__p[1] <= (void *)v11) {
          unint64_t v4 = v11 % (unint64_t)__p[1];
        }
        else {
          unint64_t v4 = v11;
        }
      }
      else
      {
        unint64_t v4 = ((unint64_t)__p[1] - 1) & v11;
      }
    }
    size_t v28 = __p[0];
    uint64_t v29 = (void *)*((void *)__p[0] + v4);
    if (v29)
    {
      *uint64_t v18 = *v29;
    }
    else
    {
      *uint64_t v18 = v40;
      *(void *)&long long v40 = v18;
      v28[v4] = &v40;
      if (!*v18) {
        goto LABEL_63;
      }
      unint64_t v30 = *(void *)(*v18 + 8);
      if ((v12 & (v12 - 1)) != 0)
      {
        if (v30 >= v12) {
          v30 %= v12;
        }
      }
      else
      {
        v30 &= v12 - 1;
      }
      uint64_t v29 = (char *)__p[0] + 8 * v30;
    }
    *uint64_t v29 = v18;
LABEL_63:
    ++*((void *)&v40 + 1);
LABEL_64:
    ;
  }
  objc_msgSend((id)std::__hash_table<std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::__unordered_map_hasher<int,std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,VKTimedAnimation * {__strong}>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,VKTimedAnimation * {__strong}>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)__p, a2, &v42)[3], "stopAnimation:", a4);
  uint8x8_t v31 = (id *)v40;
  if ((void)v40)
  {
    do
    {
      uint64_t v32 = (id *)*v31;

      operator delete(v31);
      uint8x8_t v31 = v32;
    }
    while (v32);
  }
  int v33 = __p[0];
  __p[0] = 0;
  if (v33) {
    operator delete(v33);
  }
}

void sub_1A1F635DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A1F635F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::unordered_map<int,VKTimedAnimation * {__strong}>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (id *)*v2;

      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  unint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<arComponents::StopAnimationRequest<(arComponents::StopAnimationType)1>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::StopAnimationRequest<(arComponents::StopAnimationType)1>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationState<(VKAnimationState)1>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::AnimationState<(VKAnimationState)1>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationGroupAssociation>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationGroupAssociation>::remove(void *a1, unint64_t a2)
{
  unint64_t v18 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  uint64_t v14 = a1[10];
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  *(void *)(v14 + 8 * v7) = *(void *)(a1[11] - 8);
  a1[11] -= 8;
  uint64_t v15 = (void *)a1[28];
  if (!v15) {
    return 1;
  }
  uint64_t v16 = a1[31];
  while (1)
  {
    v20[0] = &v18;
    v20[1] = 1;
    uint64_t v19 = v16;
    uint64_t v17 = v15[6];
    if (!v17) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v17 + 48))(v17, &v19, v20);
    uint64_t v15 = (void *)*v15;
    if (!v15) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationGroupAssociation>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::AnimationGroupAssociation>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<arComponents::AnimationDuration>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::AnimationDuration>::remove(void *a1, unint64_t a2)
{
  unint64_t v24 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (*(_DWORD *)(v11 + 4) != v10 || v11 == v8) {
    return 0;
  }
  uint64_t v14 = a1[10] + 24 * v7;
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  uint64_t v15 = a1[11];
  int v16 = *(_DWORD *)(v15 - 16);
  *(void *)uint64_t v14 = *(void *)(v15 - 24);
  *(_DWORD *)(v14 + 8) = v16;
  uint64_t v17 = MEMORY[0x1A6239EB0](*(void *)(v15 - 8));
  unint64_t v18 = *(void **)(v14 + 16);
  *(void *)(v14 + 16) = v17;

  uint64_t v19 = a1[11];
  uint64_t v20 = v19 - 24;

  a1[11] = v20;
  unint64_t v21 = (void *)a1[28];
  if (!v21) {
    return 1;
  }
  uint64_t v22 = a1[31];
  while (1)
  {
    v26[0] = &v24;
    v26[1] = 1;
    uint64_t v25 = v22;
    uint64_t v23 = v21[6];
    if (!v23) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v23 + 48))(v23, &v25, v26);
    unint64_t v21 = (void *)*v21;
    if (!v21) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::AnimationDuration>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::AnimationDuration>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<arComponents::AnimationDuration>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *gdc::ComponentStorageWrapper<arComponents::AnimationDuration>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 13));
  uint64_t v2 = a1[10];
  if (v2)
  {
    uint64_t v3 = a1[11];
    uint64_t v4 = (void *)a1[10];
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = v3 - 24;

        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = (void *)a1[10];
    }
    a1[11] = v2;
    operator delete(v4);
  }
  uint64_t v6 = (void *)a1[7];
  if (v6)
  {
    a1[8] = v6;
    operator delete(v6);
  }
  unint64_t v7 = (void *)a1[4];
  if (v7)
  {
    uint64_t v8 = (void *)a1[5];
    uint64_t v9 = (void *)a1[4];
    if (v8 != v7)
    {
      do
      {
        uint64_t v11 = *--v8;
        uint64_t v10 = v11;
        *uint64_t v8 = 0;
        if (v11) {
          MEMORY[0x1A6239270](v10, 0x1000C40104B78CFLL);
        }
      }
      while (v8 != v7);
      uint64_t v9 = (void *)a1[4];
    }
    a1[5] = v7;
    operator delete(v9);
  }
  return a1;
}

BOOL gdc::ComponentStorageWrapper<arComponents::StopAnimationRequest<(arComponents::StopAnimationType)0>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::StopAnimationRequest<(arComponents::StopAnimationType)0>>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::ARAnimationLogic,md::ARAnimationContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ARAnimationLogic,md::ARAnimationContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x148CB13E59522D82 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

void *md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>(void *result, uint64_t a2, unint64_t a3)
{
  if (!a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    goto LABEL_71;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v4 = 0x37F8C546A65FE3EELL;
    if (a3 <= 0x37F8C546A65FE3EELL) {
      uint64_t v4 = 0x37F8C546A65FE3EELL % a3;
    }
  }
  else
  {
    uint64_t v4 = (a3 - 1) & 0x37F8C546A65FE3EELL;
  }
  uint64_t v7 = *(void **)(a2 + 8 * v4);
  if (!v7) {
    goto LABEL_25;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_25;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v10 = v8[1];
      if (v10 == 0x37F8C546A65FE3EELL)
      {
        if (v8[2] == 0x37F8C546A65FE3EELL) {
          goto LABEL_23;
        }
      }
      else if ((v10 & (a3 - 1)) != v4)
      {
        goto LABEL_25;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v8[1];
    if (v9 == 0x37F8C546A65FE3EELL) {
      break;
    }
    if (v9 >= a3) {
      v9 %= a3;
    }
    if (v9 != v4) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_25;
    }
  }
  if (v8[2] != 0x37F8C546A65FE3EELL) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v11 = v8[5];
  if (*(void *)(v11 + 8) == 0x37F8C546A65FE3EELL)
  {
    uint64_t v6 = *(void *)(v11 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v6 = 0;
LABEL_26:
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v12 = 0x1AF456233693CD46;
    if (a3 <= 0x1AF456233693CD46) {
      uint64_t v12 = 0x1AF456233693CD46 % a3;
    }
  }
  else
  {
    uint64_t v12 = (a3 - 1) & 0x1AF456233693CD46;
  }
  uint8x8_t v13 = *(void **)(a2 + 8 * v12);
  if (!v13) {
    goto LABEL_48;
  }
  uint64_t v14 = (void *)*v13;
  if (!v14) {
    goto LABEL_48;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v16 = v14[1];
      if (v16 == 0x1AF456233693CD46)
      {
        if (v14[2] == 0x1AF456233693CD46) {
          goto LABEL_46;
        }
      }
      else if ((v16 & (a3 - 1)) != v12)
      {
        goto LABEL_48;
      }
      uint64_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v15 = v14[1];
    if (v15 != 0x1AF456233693CD46)
    {
      if (v15 >= a3) {
        v15 %= a3;
      }
      if (v15 != v12) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v14[2] != 0x1AF456233693CD46)
    {
LABEL_35:
      uint64_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v17 = v14[5];
  if (*(void *)(v17 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v5 = *(void *)(v17 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v5 = 0;
LABEL_49:
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v18 = 0xF409241CDA31AF08;
    if (a3 <= 0xF409241CDA31AF08) {
      unint64_t v18 = 0xF409241CDA31AF08 % a3;
    }
  }
  else
  {
    unint64_t v18 = (a3 - 1) & 0xF409241CDA31AF08;
  }
  uint64_t v19 = *(void **)(a2 + 8 * v18);
  if (!v19) {
    goto LABEL_71;
  }
  uint64_t v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_71;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v22 = v20[1];
      if (v22 == 0xF409241CDA31AF08)
      {
        if (v20[2] == 0xF409241CDA31AF08) {
          goto LABEL_69;
        }
      }
      else if ((v22 & (a3 - 1)) != v18)
      {
        goto LABEL_71;
      }
      uint64_t v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_71;
      }
    }
  }
  while (1)
  {
    unint64_t v21 = v20[1];
    if (v21 == 0xF409241CDA31AF08) {
      break;
    }
    if (v21 >= a3) {
      v21 %= a3;
    }
    if (v21 != v18) {
      goto LABEL_71;
    }
LABEL_58:
    uint64_t v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_71;
    }
  }
  if (v20[2] != 0xF409241CDA31AF08) {
    goto LABEL_58;
  }
LABEL_69:
  uint64_t v23 = v20[5];
  if (*(void *)(v23 + 8) != 0xF409241CDA31AF08)
  {
LABEL_71:
    uint64_t v24 = 0;
    goto LABEL_72;
  }
  uint64_t v24 = *(void *)(v23 + 32);
LABEL_72:
  *double result = v6;
  result[1] = v5;
  result[2] = v24;
  return result;
}

uint64_t md::Logic<md::ARAnimationLogic,md::ARAnimationContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARAnimationLogic,md::ARAnimationContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARAnimationLogic,md::ARAnimationContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ARAnimationLogic,md::ARAnimationContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x148CB13E59522D82)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>::buildRequiredTuple<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v6, v3);
    }
  }
  return result;
}

void md::Logic<md::ARAnimationLogic,md::ARAnimationContext,md::LogicDependencies<gdc::TypeList<md::ARLogicContext,md::CameraContext,md::LabelsExternalMeshContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A1F64384(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::ARAnimationContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ARAnimationContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555758;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ARAnimationContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555758;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::ARAnimationLogic::didBecomeInactive(int8x8_t **this)
{
  uint64_t v2 = (void *)gdc::Registry::storage<arComponents::AnimationInfo>(this[15]);
  uint64_t v3 = v2[7];
  uint64_t v4 = v2[8];
  if (v3 != v4)
  {
    uint64_t v5 = v2[10];
    do
    {
      stopAndReleaseAnimation(*(void *)v5, *(_DWORD *)(v5 + 8), this + 16, 0);
      v3 += 8;
      v5 += 16;
    }
    while (v3 != v4);
  }
  uint64_t v6 = (void *)gdc::Registry::storage<arComponents::AnimationInfo>(this[15]);
  uint64_t v7 = v6;
  if (v6[29] && (uint64_t v8 = (void *)v6[28]) != 0)
  {
    uint64_t v9 = v6[31];
    uint64_t v10 = v6[7];
    uint64_t v11 = (v6[8] - v10) >> 3;
    while (1)
    {
      v15[0] = v10;
      v15[1] = v11;
      uint64_t v14 = v9;
      uint64_t v12 = v8[6];
      if (!v12) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v12 + 48))(v12, &v14, v15);
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_9;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    md::ARAnimationLogic::~ARAnimationLogic(v13);
  }
  else
  {
LABEL_9:
    v7[8] = v7[7];
    v7[11] = v7[10];
  }
}

void md::ARAnimationLogic::~ARAnimationLogic(md::ARAnimationLogic *this)
{
  md::ARAnimationLogic::~ARAnimationLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  void *v3;
  void *v4;
  void *v5;
  id *v6;
  id *v7;
  void *v8;

  *(void *)this = &unk_1EF535800;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (void *)*((void *)this + 18);
    if (!v3) {
      goto LABEL_6;
    }
  }
  else
  {
    uint64_t v3 = (void *)*((void *)this + 18);
    if (!v3) {
      goto LABEL_6;
    }
  }
  do
  {
    uint64_t v5 = (void *)*v3;
    uint64_t v6 = (id *)v3[5];
    if (v6)
    {
      do
      {
        uint64_t v7 = (id *)*v6;

        operator delete(v6);
        uint64_t v6 = v7;
      }
      while (v7);
    }
    uint64_t v8 = (void *)v3[3];
    v3[3] = 0;
    if (v8) {
      operator delete(v8);
    }
    operator delete(v3);
    uint64_t v3 = v5;
  }
  while (v5);
LABEL_6:
  uint64_t v4 = (void *)*((void *)this + 16);
  *((void *)this + 16) = 0;
  if (v4) {
    operator delete(v4);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

uint64_t md::LabelStyle::styleName(uint64_t this, uint64_t *a2)
{
  uint64_t v3 = this;
  uint64_t v4 = *a2;
  if (v4)
  {
    uint64_t v5 = (std::__shared_weak_count *)a2[1];
    if (v5) {
      atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v18, v4, (uint64_t)v5);
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
      if (v19)
      {
LABEL_7:
        uint64_t v6 = *(void *)(v18[0] + 24);
        uint64_t v7 = *(void *)(v6 + 16);
        uint64_t v8 = *(std::__shared_weak_count **)(v6 + 24);
        uint64_t v17 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (!v7)
        {
          {
            operator new();
          }
          *(void *)(v3 + 24) = mdm::Allocator::instance(void)::alloc;
          *(unsigned char *)(v3 + 23) = 0;
          *(unsigned char *)uint64_t v3 = 0;
          if (!v8) {
            return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v18);
          }
          goto LABEL_31;
        }
        uint64_t v9 = *(const char **)(v7 + 104);
        if (v9) {
          uint64_t v10 = v9;
        }
        else {
          uint64_t v10 = "";
        }
        {
          operator new();
        }
        uint64_t v11 = mdm::Allocator::instance(void)::alloc;
        *(void *)(v3 + 24) = mdm::Allocator::instance(void)::alloc;
        size_t v12 = strlen(v10);
        if (v12 >= 0x7FFFFFFFFFFFFFF8) {
          abort();
        }
        size_t v13 = v12;
        if (v12 >= 0x17)
        {
          uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v12 | 7) != 0x17) {
            uint64_t v14 = v12 | 7;
          }
          uint64_t v15 = v14 + 1;
          uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v11 + 16))(v11, v14 + 1, 1);
          *(void *)(v3 + 8) = v13;
          *(void *)(v3 + 16) = v15 | 0x8000000000000000;
          *(void *)uint64_t v3 = v16;
          uint64_t v3 = v16;
        }
        else
        {
          *(unsigned char *)(v3 + 23) = v12;
          if (!v12)
          {
LABEL_30:
            *(unsigned char *)(v3 + v13) = 0;
            uint64_t v8 = v17;
            if (!v17) {
              return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v18);
            }
LABEL_31:
            if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
              std::__shared_weak_count::__release_weak(v8);
            }
            return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v18);
          }
        }
        memmove((void *)v3, v10, v13);
        goto LABEL_30;
      }
    }
    else if (v19)
    {
      goto LABEL_7;
    }
    {
      operator new();
    }
    *(void *)(v3 + 24) = mdm::Allocator::instance(void)::alloc;
    *(unsigned char *)(v3 + 23) = 0;
    *(unsigned char *)uint64_t v3 = 0;
    return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v18);
  }
  {
    if (this) {
      operator new();
    }
  }
  *(void *)(v3 + 24) = mdm::Allocator::instance(void)::alloc;
  *(unsigned char *)(v3 + 23) = 21;
  strcpy((char *)v3, "<<NO STYLE RESOLVED>>");
  return this;
}

void sub_1A1F64AF8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)va1);
  _Unwind_Resume(a1);
}

void sub_1A1F64B14(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::function<BOOL ()(unsigned char)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_3,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_3>,BOOL ()(unsigned char)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF56D3F8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_3,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_3>,BOOL ()(unsigned char)>::~__func()
{
}

void *std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_2,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_2>,BOOL ()(unsigned char)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF56D3B0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_2,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_2>,BOOL ()(unsigned char)>::~__func()
{
}

void *std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_1,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_1>,BOOL ()(unsigned char)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF56D368;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_1,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_1>,BOOL ()(unsigned char)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_0,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_0>,BOOL ()(unsigned char)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D320;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_0,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_0>,BOOL ()(unsigned char)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF56D320;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_0,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_0>,BOOL ()(unsigned char)>::~__func()
{
}

uint64_t **std::unique_ptr<md::LabelStyleGroupInfo>::~unique_ptr[abi:nn180100](uint64_t **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C4034E03FFCLL);
  }
  return a1;
}

uint64_t std::pair<std::pair<md::LabelStyle::StyleQueryOptions,md::LabelStyleGroupType>,std::unique_ptr<md::LabelStyleGroupInfo>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(uint64_t **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v2)
  {
    uint64_t v3 = *v2;
    *uint64_t v2 = 0;
    if (v3) {
      (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
    }
    MEMORY[0x1A6239270](v2, 0x1020C4034E03FFCLL);
  }
  return a1;
}

uint64_t *md::LabelStyle::prepareStyleGroup<md::LabelComponentStyleGroup>(uint64_t a1)
{
  __int16 v30 = 6;
  char v31 = 5;
  uint64_t v2 = *(void *)(a1 + 336);
  uint64_t v3 = *(void *)(a1 + 344);
  if (v2 != v3)
  {
    while (1)
    {
      BOOL v4 = *(unsigned char *)v2 == 6 && *(unsigned char *)(v2 + 1) == 0;
      if (v4 && *(unsigned char *)(v2 + 2) == 5) {
        break;
      }
      v2 += 16;
      if (v2 == v3) {
        goto LABEL_13;
      }
    }
  }
  if (v2 == v3) {
LABEL_13:
  }
    operator new();
  uint64_t v6 = *(uint64_t **)(v2 + 8);
  if (!*((unsigned char *)v6 + 12))
  {
    uint64_t v8 = *v6;
    *((unsigned char *)v6 + 12) = 1;
    if (*(void *)a1)
    {
      uint64_t v9 = (uint64_t *)md::LabelStyle::styleQueryForComponent((unsigned __int8 **)a1, 6, 0);
      uint64_t v10 = *v9;
      if (*v9)
      {
        uint64_t v11 = (std::__shared_weak_count *)v9[1];
        v27[0] = *v9;
        v27[1] = v11;
        if (v11) {
          atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v28, v10, (uint64_t)v11);
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        if (v29)
        {
          unsigned int v12 = (int)*(float *)(a1 + 104);
          float v13 = *(float *)(a1 + 88);
          *(void *)(v8 + 8) = 0;
          *(void *)(v8 + 16) = 0;
          if (v12 >= 0x17) {
            unsigned int v14 = 23;
          }
          else {
            unsigned int v14 = v12;
          }
          uint64_t v15 = *(void *)(v28[0] + 24);
          unsigned int v16 = *(unsigned __int8 *)(v15 + 12);
          if (v16 == 2)
          {
            LOBYTE(v27[0]) = 1;
            char v32 = 1;
            float v17 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v15, 0x1BCu, v14, 0, v27);
            gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v15, 0x1BCu, v14, 1u, &v32);
          }
          else
          {
            float v17 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v28[0] + 24), 0x1BCu, v14, v16, 0);
          }
          *(float *)(v8 + 8) = v17 * v13;
          uint64_t v18 = *(void *)(v28[0] + 24);
          unsigned int v19 = *(unsigned __int8 *)(v18 + 12);
          if (v19 == 2)
          {
            LOBYTE(v27[0]) = 1;
            char v32 = 1;
            float v20 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v18, 0x1BBu, v14, 0, v27);
            gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v18, 0x1BBu, v14, 1u, &v32);
          }
          else
          {
            float v20 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v28[0] + 24), 0x1BBu, v14, v19, 0);
          }
          *(float *)(v8 + 12) = v20 * v13;
          uint64_t v21 = *(void *)(v28[0] + 24);
          unsigned int v22 = *(unsigned __int8 *)(v21 + 12);
          if (v22 == 2)
          {
            LOBYTE(v27[0]) = 1;
            char v32 = 1;
            int v23 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v21, 0x1BDu, v14, 0, v27);
            gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v21, 0x1BDu, v14, 1u, &v32);
          }
          else
          {
            int v23 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v28[0] + 24), 0x1BDu, v14, v22, 0);
          }
          *(_DWORD *)(v8 + 16) = v23;
          uint64_t v24 = *(void *)(v28[0] + 24);
          unsigned int v25 = *(unsigned __int8 *)(v24 + 12);
          if (v25 == 2)
          {
            LOBYTE(v27[0]) = 1;
            char v32 = 1;
            int v26 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v24, 0xE9u, v14, 0, v27);
            gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v24, 0xE9u, v14, 1u, &v32);
          }
          else
          {
            int v26 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v28[0] + 24), 0xE9u, v14, v25, 0);
          }
          *(unsigned char *)(v8 + 20) = gss::MaskToLabelPosition((unsigned __int16)v26);
        }
        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v28);
      }
    }
  }
  return v6;
}

void sub_1A1F652D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A1F652E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::unique_ptr<md::LabelStyleGroupInfo>::~unique_ptr[abi:nn180100]((uint64_t **)va);
  _Unwind_Resume(a1);
}

void md::LabelStyle::prepareDisplayCoreStyleGroup(md::LabelStyle *this)
{
  uint64_t v2 = operator new(0x90uLL);
  v2[1] = 0;
  v2[2] = 0;
  *uint64_t v2 = &unk_1EF581EC0;
  *((_DWORD *)v2 + 34) = 1065353216;
  *((unsigned char *)v2 + 128) = 0;
  memset_pattern16(v2 + 3, &unk_1A28FFCA0, 0x60uLL);
  v2[15] = 0;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 50);
  *((void *)this + 49) = v2 + 3;
  *((void *)this + 50) = v2;
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = *(void *)this;
    if (!*(void *)this) {
      return;
    }
  }
  else
  {
    uint64_t v4 = *(void *)this;
    if (!*(void *)this) {
      return;
    }
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 1);
  v11[0] = v4;
  v11[1] = v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v12, v4, (uint64_t)v5);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (v13)
  {
    uint64_t v6 = 0;
    uint64_t v7 = *((void *)this + 49);
    do
    {
      uint64_t v9 = *(void *)(v12[0] + 24);
      unsigned int v10 = *(unsigned __int8 *)(v9 + 12);
      if (v10 == 2)
      {
        LOBYTE(v11[0]) = 1;
        char v14 = 1;
        int v8 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v9, 0x159u, v6, 0, v11);
        gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v9, 0x159u, v6, 1u, &v14);
      }
      else
      {
        int v8 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v12[0] + 24), 0x159u, v6, v10, 0);
      }
      *(_DWORD *)(v7 + 4 * v6) = v8;
      *(void *)(v7 + 96) |= 1 << v6++;
    }
    while (v6 != 24);
  }
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v12);
}

void sub_1A1F6550C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__shared_ptr_emplace<md::LabelDisplayCoreStyleGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581EC0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelDisplayCoreStyleGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581EC0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<md::LabelDisplayTextStyleGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581F30;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelDisplayTextStyleGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581F30;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LabelStyle::prepareDisplayIconStyleGroup(md::LabelStyle *this)
{
  uint64_t v2 = operator new(0x178uLL);
  v2[1] = 0;
  v2[2] = 0;
  *uint64_t v2 = &unk_1EF581EF8;
  v2[15] = 0;
  *((unsigned char *)v2 + 128) = 1;
  v2[29] = 0;
  *((unsigned char *)v2 + 240) = 1;
  v2[43] = 0;
  *((unsigned char *)v2 + 352) = 1;
  *((_DWORD *)v2 + 92) = 0;
  v2[45] = 0;
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 56);
  *((void *)this + 55) = v2 + 3;
  *((void *)this + 56) = v2;
  if (!v3 || atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (*(void *)this) {
      goto LABEL_4;
    }
LABEL_24:
    uint64_t v20 = *((void *)this + 55);
    uint64_t v21 = *(void *)(v20 + 96);
    uint64_t v22 = *(void *)(v20 + 208);
    uint64_t v23 = *(void *)(v20 + 320);
    *(_OWORD *)uint64_t v20 = 0u;
    *(_OWORD *)(v20 + 16) = 0u;
    *(_OWORD *)(v20 + 32) = 0u;
    *(_OWORD *)(v20 + 48) = 0u;
    *(_OWORD *)(v20 + 64) = 0u;
    *(_OWORD *)(v20 + 80) = 0u;
    *(_OWORD *)(v20 + 112) = 0u;
    *(_OWORD *)(v20 + 128) = 0u;
    *(_OWORD *)(v20 + 144) = 0u;
    *(_OWORD *)(v20 + 160) = 0u;
    *(_OWORD *)(v20 + 176) = 0u;
    *(_OWORD *)(v20 + 192) = 0u;
    *(_OWORD *)(v20 + 224) = 0u;
    *(_OWORD *)(v20 + 240) = 0u;
    *(_OWORD *)(v20 + 256) = 0u;
    *(_OWORD *)(v20 + 272) = 0u;
    *(_OWORD *)(v20 + 288) = 0u;
    *(_OWORD *)(v20 + 304) = 0u;
    *(void *)(v20 + 96) = v21 & 0xFFFFFFFFFF000000;
    *(void *)(v20 + 208) = v22 & 0xFFFFFFFFFF000000;
    *(void *)(v20 + 320) = v23 & 0xFFFFFFFFFF000000;
    return;
  }
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v3);
  if (!*(void *)this) {
    goto LABEL_24;
  }
LABEL_4:
  uint64_t v4 = (uint64_t *)md::LabelStyle::styleQueryForComponent((unsigned __int8 **)this, 1, 0);
  uint64_t v5 = *v4;
  if (*v4)
  {
    uint64_t v6 = (std::__shared_weak_count *)v4[1];
    v24[0] = *v4;
    v24[1] = v6;
    if (v6) {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v25, v5, (uint64_t)v6);
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    if (v26)
    {
      uint64_t v7 = 0;
      int v8 = (float *)*((void *)this + 55);
      float v9 = *((float *)this + 22);
      do
      {
        uint64_t v11 = *(void *)(v25[0] + 24);
        unsigned int v12 = *(unsigned __int8 *)(v11 + 12);
        if (v12 == 2)
        {
          LOBYTE(v24[0]) = 1;
          char v27 = 1;
          float v13 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v11, 0x5Eu, v7, 0, v24);
          gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v11, 0x5Eu, v7, 1u, &v27);
        }
        else
        {
          float v13 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v25[0] + 24), 0x5Eu, v7, v12, 0);
        }
        v8[v7] = v13 * v9;
        uint64_t v14 = 1 << v7;
        *((void *)v8 + 12) |= 1 << v7;
        uint64_t v15 = *(void *)(v25[0] + 24);
        unsigned int v16 = *(unsigned __int8 *)(v15 + 12);
        if (v16 == 2)
        {
          LOBYTE(v24[0]) = 1;
          char v27 = 1;
          float v17 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v15, 0x61u, v7, 0, v24);
          gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v15, 0x61u, v7, 1u, &v27);
        }
        else
        {
          float v17 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v25[0] + 24), 0x61u, v7, v16, 0);
        }
        v8[v7 + 28] = v17 * v9;
        *((void *)v8 + 26) |= v14;
        uint64_t v18 = *(void *)(v25[0] + 24);
        unsigned int v19 = *(unsigned __int8 *)(v18 + 12);
        if (v19 == 2)
        {
          LOBYTE(v24[0]) = 1;
          char v27 = 1;
          float v10 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v18, 0x194u, v7, 0, v24);
          gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v18, 0x194u, v7, 1u, &v27);
        }
        else
        {
          float v10 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v25[0] + 24), 0x194u, v7, v19, 0);
        }
        v8[v7 + 56] = v10 * v9;
        *((void *)v8 + 40) |= v14;
        ++v7;
      }
      while (v7 != 24);
    }
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v25);
  }
}

void sub_1A1F659A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__shared_ptr_emplace<md::LabelDisplayIconStyleGroup>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581EF8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelDisplayIconStyleGroup>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581EF8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LabelStyle::populateDebugNode(md::LabelStyle *this, gdc::DebugTreeNode *a2, const md::LabelManager *a3)
{
  uint64_t v4 = this;
  *((unsigned char *)&v224.__r_.__value_.__s + 23) = 4;
  strcpy((char *)&v224, "Name");
  md::LabelStyle::styleName((uint64_t)__src, (uint64_t *)this);
  if ((__src[23] & 0x80000000) == 0)
  {
    uint64_t v5 = __src;
    size_t v6 = __src[23];
    if (__src[23] < 0x17uLL) {
      goto LABEL_3;
    }
LABEL_7:
    uint64_t v8 = (v6 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v8 = v6 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (long long *)operator new(v8 + 1);
    *((void *)&__dst + 1) = v6;
    unint64_t v219 = v9 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_10;
  }
  size_t v6 = *(void *)&__src[8];
  if (*(void *)&__src[8] > 0x7FFFFFFFFFFFFFF7uLL) {
    abort();
  }
  uint64_t v5 = *(unsigned char **)__src;
  if (*(void *)&__src[8] >= 0x17uLL) {
    goto LABEL_7;
  }
LABEL_3:
  HIBYTE(v219) = v6;
  p_dst = &__dst;
  if (v6) {
LABEL_10:
  }
    memmove(p_dst, v5, v6);
  *((unsigned char *)p_dst + v6) = 0;
  long long v221 = 0uLL;
  unint64_t v222 = 0;
  int v223 = 4;
  std::string::size_type v10 = SHIBYTE(v219);
  if ((v10 & 0x80000000) != 0)
  {
    std::string::__assign_no_alias<true>(&v221, (void *)__dst, *((size_t *)&__dst + 1));
  }
  else
  {
    long long v221 = __dst;
    unint64_t v222 = v219;
  }
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)&v224, (uint64_t)v220);
  if (SHIBYTE(v222) < 0)
  {
    operator delete((void *)v221);
    if ((v10 & 0x80000000) == 0)
    {
LABEL_16:
      if ((__src[23] & 0x80000000) == 0) {
        goto LABEL_17;
      }
      goto LABEL_22;
    }
  }
  else if ((v10 & 0x80000000) == 0)
  {
    goto LABEL_16;
  }
  operator delete((void *)__dst);
  if ((__src[23] & 0x80000000) == 0)
  {
LABEL_17:
    if ((SHIBYTE(v224.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_18;
    }
LABEL_23:
    operator delete(v224.__r_.__value_.__l.__data_);
    uint64_t v11 = *(void *)v4;
    if (!*(void *)v4) {
      goto LABEL_59;
    }
    goto LABEL_24;
  }
LABEL_22:
  (*(void (**)(uint64_t, void, uint64_t))(*(void *)v217 + 40))(v217, *(void *)__src, *(void *)&__src[16] & 0x7FFFFFFFFFFFFFFFLL);
  if (SHIBYTE(v224.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_23;
  }
LABEL_18:
  uint64_t v11 = *(void *)v4;
  if (!*(void *)v4) {
    goto LABEL_59;
  }
LABEL_24:
  v109 = v4;
  gss::StylesheetQuery<gss::PropertyID>::debugClientAttributes((uint64_t *)&v224, v11);
  __src[23] = 17;
  strcpy(__src, "Client Attributes");
  v110 = a2;
  ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__src);
  int v13 = WORD1(v224.__r_.__value_.__r.__words[1]);
  if (WORD1(v224.__r_.__value_.__r.__words[1]))
  {
    uint64_t v14 = (uint64_t)ChildNode;
    uint64_t v15 = 0;
    unsigned int v16 = 0;
    unsigned int v17 = WORD1(v224.__r_.__value_.__r.__words[1]);
    do
    {
      if (v16 < v17)
      {
        uint64_t v15 = (int *)(v224.__r_.__value_.__r.__words[0] + 4 * v16);
        std::string::size_type v10 = v224.__r_.__value_.__r.__words[0] + LOWORD(v224.__r_.__value_.__r.__words[1]) + 2 * v16;
      }
      uint64_t v18 = gss::to_string(*v15);
      size_t v19 = strlen(v18);
      if (v19 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      size_t v20 = v19;
      if (v19 >= 0x17)
      {
        uint64_t v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v19 | 7) != 0x17) {
          uint64_t v22 = v19 | 7;
        }
        uint64_t v23 = v22 + 1;
        uint64_t v21 = operator new(v22 + 1);
        *(void *)&__src[8] = v20;
        *(void *)&__src[16] = v23 | 0x8000000000000000;
        *(void *)__src = v21;
      }
      else
      {
        __src[23] = v19;
        uint64_t v21 = __src;
        if (!v19) {
          goto LABEL_40;
        }
      }
      memmove(v21, v18, v20);
LABEL_40:
      v21[v20] = 0;
      uint64_t v24 = *(unsigned __int16 *)v10;
      memset(&v214[4], 0, 24);
      int v215 = 0;
      v214[0] = v24;
      gdc::DebugTreeNode::addProperty(v14, (uint64_t)__src, (uint64_t)v214);
      if ((__src[23] & 0x80000000) != 0) {
        operator delete(*(void **)__src);
      }
      unsigned int v17 = WORD1(v224.__r_.__value_.__r.__words[1]);
      if (v16 + 1 < WORD1(v224.__r_.__value_.__r.__words[1])) {
        ++v16;
      }
      else {
        unsigned int v16 = WORD1(v224.__r_.__value_.__r.__words[1]);
      }
    }
    while (v16 != v13);
  }
  __src[23] = 18;
  strcpy(__src, "Feature Attributes");
  unsigned int v25 = gdc::DebugTreeNode::createChildNode((uint64_t)v110, (long long *)__src);
  uint64_t v4 = v109;
  uint64_t v26 = *(void *)(*(void *)v109 + 240);
  uint64_t v27 = *(void *)(*(void *)v109 + 248);
  if (v26 != v27)
  {
    uint64_t v28 = (uint64_t)v25;
    do
    {
      char v29 = gss::to_string(*(_DWORD *)v26);
      size_t v30 = strlen(v29);
      if (v30 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      size_t v31 = v30;
      if (v30 >= 0x17)
      {
        uint64_t v33 = (v30 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v30 | 7) != 0x17) {
          uint64_t v33 = v30 | 7;
        }
        uint64_t v34 = v33 + 1;
        char v32 = operator new(v33 + 1);
        *(void *)&__src[8] = v31;
        *(void *)&__src[16] = v34 | 0x8000000000000000;
        *(void *)__src = v32;
      }
      else
      {
        __src[23] = v30;
        char v32 = __src;
        if (!v30) {
          goto LABEL_53;
        }
      }
      memmove(v32, v29, v31);
LABEL_53:
      v32[v31] = 0;
      uint64_t v35 = *(unsigned __int16 *)(v26 + 4);
      memset(&v212[4], 0, 24);
      int v213 = 0;
      v212[0] = v35;
      gdc::DebugTreeNode::addProperty(v28, (uint64_t)__src, (uint64_t)v212);
      if ((__src[23] & 0x80000000) != 0) {
        operator delete(*(void **)__src);
      }
      v26 += 8;
    }
    while (v26 != v27);
  }
  if (!v224.__r_.__value_.__s.__data_[14] && v224.__r_.__value_.__r.__words[0])
  {
    uint64_t v36 = gss::Allocator::instance((gss::Allocator *)v25);
    (*(void (**)(uint64_t, std::string::size_type, void))(*(void *)v36 + 40))(v36, v224.__r_.__value_.__r.__words[0], WORD2(v224.__r_.__value_.__r.__words[1]));
  }
  a2 = v110;
LABEL_59:
  __src[23] = 18;
  strcpy(__src, "Visible Zoom Range");
  uint8x8_t v37 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__src);
  uint64_t v38 = *((unsigned __int8 *)v4 + 112);
  __src[23] = 3;
  strcpy(__src, "Min");
  int v211 = 0;
  memset(&v210[4], 0, 24);
  v210[0] = v38;
  gdc::DebugTreeNode::addProperty((uint64_t)v37, (uint64_t)__src, (uint64_t)v210);
  uint64_t v39 = *((unsigned __int8 *)v4 + 113);
  __src[23] = 3;
  strcpy(__src, "Max");
  int v209 = 0;
  memset(&v208[4], 0, 24);
  v208[0] = v39;
  gdc::DebugTreeNode::addProperty((uint64_t)v37, (uint64_t)__src, (uint64_t)v208);
  uint64_t v40 = *(void *)v4;
  __src[23] = 10;
  strcpy(__src, "Is Default");
  int v207 = 0;
  memset(&v206[4], 0, 24);
  v206[0] = v40 == 0;
  gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)__src, (uint64_t)v206);
  __src[23] = 12;
  strcpy(__src, "Font Options");
  float v41 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__src);
  uint64_t v42 = *((void *)v4 + 35);
  if (v42)
  {
    if (vabds_f32(*(float *)(v42 + 8), *((float *)v4 + 26)) >= 0.01)
    {
      md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)v4, v42, 0);
      uint64_t v42 = *((void *)v4 + 35);
    }
  }
  else
  {
    uint64_t v42 = md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>((uint64_t)v4, 0);
    *((void *)v4 + 35) = v42;
  }
  uint64_t v43 = *(void *)v42;
  __src[23] = 11;
  strcpy(__src, "Family Name");
  if (*(char *)(v43 + 95) < 0) {
    std::string::__init_copy_ctor_external(&v224, *(const std::string::value_type **)(v43 + 72), *(void *)(v43 + 80));
  }
  else {
    std::string v224 = *(std::string *)(v43 + 72);
  }
  memset(&__p, 0, sizeof(__p));
  int v205 = 4;
  if (SHIBYTE(v224.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__assign_no_alias<true>(&__p, v224.__r_.__value_.__l.__data_, v224.__r_.__value_.__l.__size_);
  }
  else {
    std::string __p = v224;
  }
  gdc::DebugTreeNode::addProperty((uint64_t)v41, (uint64_t)__src, (uint64_t)v203);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v224.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_71;
    }
  }
  else if ((SHIBYTE(v224.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_71;
  }
  operator delete(v224.__r_.__value_.__l.__data_);
LABEL_71:
  float v44 = *(float *)(v43 + 100);
  __src[23] = 9;
  strcpy(__src, "Font Size");
  uint64_t v201 = 0;
  uint64_t v199 = 0;
  uint64_t v200 = 0;
  int v202 = 2;
  double v198 = v44;
  gdc::DebugTreeNode::addProperty((uint64_t)v41, (uint64_t)__src, (uint64_t)v197);
  float v45 = *(float *)(v43 + 96);
  __src[23] = 14;
  strcpy(__src, "Font Expansion");
  uint64_t v195 = 0;
  uint64_t v193 = 0;
  uint64_t v194 = 0;
  int v196 = 2;
  double v192 = v45;
  gdc::DebugTreeNode::addProperty((uint64_t)v41, (uint64_t)__src, (uint64_t)v191);
  uint64_t v46 = *(unsigned __int8 *)(v43 + 109);
  __src[23] = 13;
  strcpy(__src, "Is Upper Case");
  int v190 = 0;
  memset(&v189[4], 0, 24);
  v189[0] = v46;
  gdc::DebugTreeNode::addProperty((uint64_t)v41, (uint64_t)__src, (uint64_t)v189);
  uint64_t v47 = *(unsigned __int8 *)(v43 + 110);
  __src[23] = 12;
  strcpy(__src, "Is Down Case");
  int v188 = 0;
  memset(&v187[4], 0, 24);
  v187[0] = v47;
  gdc::DebugTreeNode::addProperty((uint64_t)v41, (uint64_t)__src, (uint64_t)v187);
  uint64_t v48 = *(unsigned __int8 *)(v43 + 111);
  __src[23] = 13;
  strcpy(__src, "Is Title Case");
  int v186 = 0;
  memset(&v185[4], 0, 24);
  v185[0] = v48;
  gdc::DebugTreeNode::addProperty((uint64_t)v41, (uint64_t)__src, (uint64_t)v185);
  uint64_t v49 = *(unsigned __int8 *)(v43 + 108);
  __src[23] = 17;
  strcpy(__src, "Is Raised Initial");
  int v184 = 0;
  memset(&v183[4], 0, 24);
  v183[0] = v49;
  gdc::DebugTreeNode::addProperty((uint64_t)v41, (uint64_t)__src, (uint64_t)v183);
  uint64_t v50 = *(unsigned __int8 *)(v43 + 112);
  __src[23] = 14;
  strcpy(__src, "Has Small Caps");
  int v182 = 0;
  memset(&v181[4], 0, 24);
  v181[0] = v50;
  gdc::DebugTreeNode::addProperty((uint64_t)v41, (uint64_t)__src, (uint64_t)v181);
  __src[23] = 16;
  strcpy(__src, "Line Style Group");
  uint64_t v51 = gdc::DebugTreeNode::createChildNode((uint64_t)a2, (long long *)__src);
  uint64_t v52 = (char *)operator new(0x19uLL);
  *(void *)__src = v52;
  *(_OWORD *)&__src[8] = xmmword_1A28FCDB0;
  strcpy(v52, "Road Crossing Threshold");
  uint64_t v53 = *((void *)v4 + 33);
  if (!v53)
  {
    uint64_t v54 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v53 = *v54;
    *((void *)v4 + 33) = *v54;
  }
  uint64_t v55 = *(int *)(v53 + 8);
  int v180 = 0;
  memset(&v179[4], 0, 24);
  v179[0] = v55;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v179);
  operator delete(v52);
  __src[23] = 9;
  strcpy(__src, "Road Rank");
  uint64_t v56 = *((void *)v4 + 33);
  if (!v56)
  {
    v57 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v56 = *v57;
    *((void *)v4 + 33) = *v57;
  }
  float v58 = *(float *)(v56 + 16);
  uint64_t v177 = 0;
  uint64_t v175 = 0;
  uint64_t v176 = 0;
  int v178 = 2;
  double v174 = v58;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v173);
  uint64_t v59 = *((void *)v4 + 33);
  __src[23] = 11;
  strcpy(__src, "Shield Rank");
  if (!v59)
  {
    uint64_t v60 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v59 = *v60;
    *((void *)v4 + 33) = *v60;
  }
  float v61 = *(float *)(v59 + 20);
  uint64_t v171 = 0;
  uint64_t v169 = 0;
  uint64_t v170 = 0;
  int v172 = 2;
  double v168 = v61;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v167);
  uint64_t v62 = *((void *)v4 + 33);
  __src[23] = 18;
  strcpy(__src, "Road Label Spacing");
  if (!v62)
  {
    unint64_t v63 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v62 = *v63;
    *((void *)v4 + 33) = *v63;
  }
  float v64 = *(float *)(v62 + 24);
  uint64_t v165 = 0;
  uint64_t v163 = 0;
  uint64_t v164 = 0;
  int v166 = 2;
  double v162 = v64;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v161);
  uint64_t v65 = *((void *)v4 + 33);
  __src[23] = 13;
  strcpy(__src, "Arrow Spacing");
  if (!v65)
  {
    v66 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v65 = *v66;
    *((void *)v4 + 33) = *v66;
  }
  float v67 = *(float *)(v65 + 28);
  uint64_t v159 = 0;
  uint64_t v157 = 0;
  uint64_t v158 = 0;
  int v160 = 2;
  double v156 = v67;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v155);
  uint64_t v68 = *((void *)v4 + 33);
  __src[23] = 14;
  strcpy(__src, "Shield Spacing");
  if (!v68)
  {
    v69 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v68 = *v69;
    *((void *)v4 + 33) = *v69;
  }
  float v70 = *(float *)(v68 + 32);
  uint64_t v153 = 0;
  uint64_t v151 = 0;
  uint64_t v152 = 0;
  int v154 = 2;
  double v150 = v70;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v149);
  uint64_t v71 = *((void *)v4 + 33);
  __src[23] = 16;
  strcpy(__src, "Multi Shield Gap");
  if (!v71)
  {
    long long v72 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v71 = *v72;
    *((void *)v4 + 33) = *v72;
  }
  float v73 = *(float *)(v71 + 36);
  uint64_t v147 = 0;
  uint64_t v145 = 0;
  uint64_t v146 = 0;
  int v148 = 2;
  double v144 = v73;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v143);
  uint64_t v74 = *((void *)v4 + 33);
  __src[23] = 20;
  strcpy(__src, "Road With Shield Gap");
  if (!v74)
  {
    v75 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v74 = *v75;
    *((void *)v4 + 33) = *v75;
  }
  float v76 = *(float *)(v74 + 40);
  uint64_t v140 = 0;
  uint64_t v141 = 0;
  uint64_t v139 = 0;
  int v142 = 2;
  double v138 = v76;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v137);
  uint64_t v77 = *((void *)v4 + 33);
  __src[23] = 12;
  strcpy(__src, "Arrow Height");
  if (!v77)
  {
    v78 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v77 = *v78;
    *((void *)v4 + 33) = *v78;
  }
  float v79 = *(float *)(v77 + 48);
  uint64_t v134 = 0;
  uint64_t v135 = 0;
  uint64_t v133 = 0;
  int v136 = 2;
  double v132 = v79;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v131);
  uint64_t v80 = *((void *)v4 + 33);
  __src[23] = 14;
  strcpy(__src, "Arrows Visible");
  if (v80)
  {
    if (*(unsigned char *)(v80 + 56))
    {
LABEL_91:
      BOOL v81 = *(unsigned __int8 *)(v80 + 57) != 0;
      goto LABEL_96;
    }
  }
  else
  {
    uint64_t v82 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v80 = *v82;
    *((void *)v4 + 33) = *v82;
    if (*(unsigned char *)(v80 + 56)) {
      goto LABEL_91;
    }
  }
  BOOL v81 = 0;
LABEL_96:
  int v130 = 0;
  memset(&v129[4], 0, 24);
  v129[0] = v81;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v129);
  uint64_t v83 = *((void *)v4 + 33);
  __src[23] = 15;
  strcpy(__src, "Shields Visible");
  if (v83)
  {
    if (*(unsigned char *)(v83 + 56))
    {
LABEL_98:
      BOOL v84 = *(unsigned __int8 *)(v83 + 58) != 0;
      goto LABEL_101;
    }
  }
  else
  {
    uint64_t v85 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v83 = *v85;
    *((void *)v4 + 33) = *v85;
    if (*(unsigned char *)(v83 + 56)) {
      goto LABEL_98;
    }
  }
  BOOL v84 = 0;
LABEL_101:
  int v128 = 0;
  memset(&v127[4], 0, 24);
  v127[0] = v84;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v127);
  uint64_t v86 = *((void *)v4 + 33);
  __src[23] = 18;
  strcpy(__src, "Road Names Visible");
  if (v86)
  {
    if (*(unsigned char *)(v86 + 56))
    {
LABEL_103:
      BOOL v87 = *(unsigned __int8 *)(v86 + 60) != 0;
      goto LABEL_106;
    }
  }
  else
  {
    v88 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v86 = *v88;
    *((void *)v4 + 33) = *v88;
    if (*(unsigned char *)(v86 + 56)) {
      goto LABEL_103;
    }
  }
  BOOL v87 = 0;
LABEL_106:
  int v126 = 0;
  memset(&v125[4], 0, 24);
  v125[0] = v87;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v125);
  uint64_t v89 = *((void *)v4 + 33);
  __src[23] = 15;
  strcpy(__src, "Offset Position");
  if (!v89)
  {
    v90 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v89 = *v90;
    *((void *)v4 + 33) = *v90;
  }
  uint64_t v91 = *(unsigned __int8 *)(v89 + 61);
  char v92 = v91;
  char v93 = 5;
  uint64_t v94 = 0x7468676952;
  uint64_t v95 = v91;
  uint64_t v96 = v91;
  switch((int)v91)
  {
    case 0:
      break;
    case 1:
      uint64_t v95 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      char v93 = 8;
      uint64_t v94 = 0x7468676952706F54;
      break;
    case 2:
      uint64_t v95 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      char v93 = 3;
      uint64_t v94 = 7368532;
      break;
    case 3:
      uint64_t v95 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      char v93 = 7;
      uint64_t v94 = 0x7466654C706F54;
      break;
    case 4:
      uint64_t v95 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      uint64_t v94 = 1952867660;
      char v93 = v92;
      break;
    case 5:
      uint64_t v96 = 0;
      char v93 = 10;
      uint64_t v94 = 0x654C6D6F74746F42;
      uint64_t v91 = 102;
      uint64_t v95 = 29696;
      break;
    case 6:
      uint64_t v95 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      uint64_t v94 = 0x6D6F74746F42;
      char v93 = v92;
      break;
    case 7:
      char v93 = 11;
      uint64_t v94 = 0x69526D6F74746F42;
      uint64_t v91 = 103;
      uint64_t v96 = 7602176;
      uint64_t v95 = 26624;
      break;
    case 8:
      uint64_t v95 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      char v93 = 6;
      uint64_t v94 = 0x7265746E6543;
      break;
    case 9:
      uint64_t v95 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      char v93 = 4;
      uint64_t v94 = 1701736270;
      break;
    case 10:
      uint64_t v95 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      char v93 = 8;
      uint64_t v94 = 0x656C676E41747845;
      break;
    default:
      uint64_t v95 = 0;
      uint64_t v94 = 0;
      uint64_t v96 = 0;
      uint64_t v91 = 0;
      char v93 = 0;
      break;
  }
  int v124 = 4;
  uint64_t v121 = v94;
  uint64_t v122 = v96 | v95 | v91;
  uint64_t v123 = 0;
  HIBYTE(v123) = v93;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v120);
  uint64_t v97 = *((void *)v4 + 33);
  __src[23] = 11;
  strcpy(__src, "Arrow Layer");
  if (!v97)
  {
    v98 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v97 = *v98;
    *((void *)v4 + 33) = *v98;
  }
  uint64_t v99 = *(char *)(v97 + 63);
  uint64_t v117 = 0;
  uint64_t v118 = 0;
  int v119 = 1;
  uint64_t v116 = 0;
  uint64_t v115 = v99;
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v114);
  uint64_t v100 = *((void *)v4 + 33);
  __src[23] = 15;
  strcpy(__src, "Arrow Icon Name");
  if (v100)
  {
    int v101 = *(char *)(v100 + 95);
    if ((v101 & 0x80000000) == 0) {
      goto LABEL_124;
    }
  }
  else
  {
    v105 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)v4);
    uint64_t v100 = *v105;
    *((void *)v4 + 33) = *v105;
    int v101 = *(char *)(v100 + 95);
    if ((v101 & 0x80000000) == 0)
    {
LABEL_124:
      v102 = (const void *)(v100 + 72);
      std::string::size_type v103 = v101;
      if (v101 < 0x17uLL) {
        goto LABEL_125;
      }
LABEL_130:
      uint64_t v106 = (v103 & 0x7FFFFFFFFFFFFFF8) + 8;
      if ((v103 | 7) != 0x17) {
        uint64_t v106 = v103 | 7;
      }
      uint64_t v107 = v106 + 1;
      v104 = operator new(v106 + 1);
      v224.__r_.__value_.__l.__size_ = v103;
      v224.__r_.__value_.__r.__words[2] = v107 | 0x8000000000000000;
      v224.__r_.__value_.__r.__words[0] = (std::string::size_type)v104;
      goto LABEL_133;
    }
  }
  std::string::size_type v103 = *(void *)(v100 + 80);
  if (v103 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  v102 = *(const void **)(v100 + 72);
  if (v103 >= 0x17) {
    goto LABEL_130;
  }
LABEL_125:
  *((unsigned char *)&v224.__r_.__value_.__s + 23) = v103;
  v104 = &v224;
  if (v103) {
LABEL_133:
  }
    memmove(v104, v102, v103);
  *((unsigned char *)v104 + v103) = 0;
  memset(&v112, 0, sizeof(v112));
  int v113 = 4;
  int v108 = SHIBYTE(v224.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(v224.__r_.__value_.__r.__words[2]) < 0) {
    std::string::__assign_no_alias<true>(&v112, v224.__r_.__value_.__l.__data_, v224.__r_.__value_.__l.__size_);
  }
  else {
    std::string v112 = v224;
  }
  gdc::DebugTreeNode::addProperty((uint64_t)v51, (uint64_t)__src, (uint64_t)v111);
  if (SHIBYTE(v112.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v112.__r_.__value_.__l.__data_);
    if ((v108 & 0x80000000) == 0)
    {
LABEL_139:
      if ((__src[23] & 0x80000000) == 0) {
        return;
      }
LABEL_143:
      operator delete(*(void **)__src);
      return;
    }
  }
  else if ((v108 & 0x80000000) == 0)
  {
    goto LABEL_139;
  }
  operator delete(v224.__r_.__value_.__l.__data_);
  if ((__src[23] & 0x80000000) != 0) {
    goto LABEL_143;
  }
}

void sub_1A1F66C74(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void sub_1A1F66C88(_Unwind_Exception *a1)
{
  (*(void (**)(void, void, uint64_t))(**(void **)(v1 - 232) + 40))(*(void *)(v1 - 232), *(void *)(v1 - 256), *(void *)(v1 - 240) & 0x7FFFFFFFFFFFFFFFLL);
  _Unwind_Resume(a1);
}

void sub_1A1F66CD4(_Unwind_Exception *a1)
{
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)(v1 - 128));
  _Unwind_Resume(a1);
}

void gss::StylesheetQuery<gss::PropertyID>::debugClientAttributes(uint64_t *a1, uint64_t a2)
{
  *(uint64_t *)((char *)a1 + 7) = 0;
  *a1 = 0;
  *((unsigned char *)a1 + 15) = 1;
  uint64_t v3 = *(std::__shared_weak_count **)(a2 + 16);
  if (!v3) {
    return;
  }
  uint64_t v5 = std::__shared_weak_count::lock(v3);
  uint64_t v36 = v5;
  if (!v5) {
    return;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v35 = v6;
  if (!v6)
  {
    uint64_t v15 = v5;
LABEL_55:
    if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
    return;
  }
  std::string __p = 0;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v7 = *(void *)(v6 + 520);
  uint64_t v8 = *(std::__shared_weak_count **)(v6 + 528);
  if (v8
    && (atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed),
        !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    if (v7) {
      goto LABEL_7;
    }
  }
  else if (v7)
  {
LABEL_7:
    uint64_t v9 = *(void *)(v35 + 520);
    std::string::size_type v10 = *(std::__shared_weak_count **)(v35 + 528);
    uint8x8_t v37 = (unsigned char *)v9;
    uint64_t v38 = v10;
    if (v10) {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::ClientStyleState<gss::PropertyID>::appendSourceClientStyleAttributes(v9, (unint64_t *)&__p);
    if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
      std::__shared_weak_count::__release_weak(v10);
    }
    unsigned int v11 = *(unsigned __int16 *)(a2 + 282);
    uint8x8_t v37 = (unsigned char *)(a2 + 272);
    LODWORD(v38) = 0;
    char v39 = 0;
    char v40 = 0;
    if (v11)
    {
      unsigned int v12 = 0;
      uint64_t v13 = 0;
      do
      {
        ++v13;
        unsigned int v14 = v12 + 1;
        if (v12 + 1 < v11) {
          ++v12;
        }
        else {
          unsigned int v12 = v11;
        }
      }
      while (v14 < v11);
    }
    else
    {
      uint64_t v13 = 0;
    }
    std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v33, &v37, a2 + 272, v11, v13);
    goto LABEL_44;
  }
  memset(v30, 0, sizeof(v30));
  char v31 = 1;
  gss::DisplayStyle::applyDisplayStyle(gss::DisplayStyleDay, (uint64_t *)v30);
  uint8x8_t v37 = v30;
  LODWORD(v38) = 0;
  char v39 = 0;
  char v40 = 0;
  if (*(_WORD *)&v30[10])
  {
    int v16 = 0;
    uint64_t v17 = 0;
    do
    {
      ++v17;
      unsigned int v18 = v16 + 1;
      if (v16 + 1 < *(unsigned __int16 *)&v30[10]) {
        ++v16;
      }
      else {
        int v16 = *(unsigned __int16 *)&v30[10];
      }
    }
    while (v18 < *(unsigned __int16 *)&v30[10]);
  }
  else
  {
    uint64_t v17 = 0;
  }
  std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v33, &v37, (uint64_t)v30, *(unsigned __int16 *)&v30[10], v17);
  unsigned int v19 = *(unsigned __int16 *)(a2 + 282);
  uint8x8_t v37 = (unsigned char *)(a2 + 272);
  LODWORD(v38) = 0;
  char v39 = 0;
  char v40 = 0;
  if (v19)
  {
    unsigned int v20 = 0;
    uint64_t v21 = 0;
    do
    {
      ++v21;
      unsigned int v22 = v20 + 1;
      if (v20 + 1 < v19) {
        ++v20;
      }
      else {
        unsigned int v20 = v19;
      }
    }
    while (v22 < v19);
  }
  else
  {
    uint64_t v21 = 0;
  }
  std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v33, &v37, a2 + 272, v19, v21);
  if (v30[14]) {
    BOOL v24 = 1;
  }
  else {
    BOOL v24 = *(void *)v30 == 0;
  }
  if (!v24)
  {
    uint64_t v25 = gss::Allocator::instance(v23);
    (*(void (**)(uint64_t, void, void))(*(void *)v25 + 40))(v25, *(void *)v30, *(unsigned __int16 *)&v30[12]);
  }
LABEL_44:
  gss::ResolveMultiAttributeVectorToMap((unsigned int **)&__p, (uint64_t *)&v37);
  if (&v37 == (unsigned char **)a1)
  {
    if (!*((unsigned char *)a1 + 14) && *a1)
    {
      uint64_t v29 = gss::Allocator::instance(v26);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v29 + 40))(v29, *a1, *((unsigned __int16 *)a1 + 6));
    }
  }
  else
  {
    if (!*((unsigned char *)a1 + 14) && *a1)
    {
      uint64_t v27 = gss::Allocator::instance(v26);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v27 + 40))(v27, *a1, *((unsigned __int16 *)a1 + 6));
      *a1 = 0;
    }
    uint64_t v28 = v38;
    *a1 = (uint64_t)v37;
    *((_DWORD *)a1 + 2) = v28;
    *((_WORD *)a1 + 6) = WORD2(v28);
    *((_WORD *)a1 + 7) = HIWORD(v38);
  }
  if (__p)
  {
    uint64_t v33 = __p;
    operator delete(__p);
  }
  uint64_t v15 = v36;
  if (v36) {
    goto LABEL_55;
  }
}

void sub_1A1F670CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16)
{
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)&a16);
  if (__p) {
    operator delete(__p);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  gss::QueryOverrides::~QueryOverrides(v16);
  _Unwind_Resume(a1);
}

void non-virtual thunk to'md::MapNavLabeler::worldTraitsDidChange(md::MapNavLabeler *this)
{
  int v1 = *(unsigned __int8 *)(*(void *)(*((void *)this + 1) + 232) + 31);
  if (*((unsigned __int8 *)this + 812) != v1)
  {
    *((unsigned char *)this + 812) = v1;
    md::LabelNavEtaLabeler::clearETALabels(*((md::LabelNavEtaLabeler **)this + 84));
  }
}

void non-virtual thunk to'md::MapNavLabeler::setRouteLine(md::MapNavLabeler *this, VKRouteLine *a2)
{
  uint64_t v4 = a2;
  uint64_t v3 = (md::RouteLineSupport *)*((void *)this + 7);
  if (v3) {
    md::RouteLineSupport::setRouteLine(v3, v4);
  }
}

void sub_1A1F671B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'md::MapNavLabeler::setNavMode(uint64_t result, char a2)
{
  *(unsigned char *)(result + 122) = a2;
  return result;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::setLabelMode(uint64_t result, int a2)
{
  int v2 = a2 == 2;
  if (*(unsigned __int8 *)(result + 120) != v2)
  {
    uint64_t v3 = result;
    *(unsigned char *)(result + 120) = v2;
    uint64_t v4 = *(void *)(result + 56);
    if (*(unsigned __int8 *)(v4 + 252) != v2)
    {
      *(unsigned char *)(v4 + 252) = v2;
      if (a2 != 2) {
        *(void *)(v4 + 224) = 0;
      }
    }
    double result = *(void *)(result + 680);
    if (*(unsigned __int8 *)(result + 136) != v2)
    {
      *(unsigned char *)(result + 136) = v2;
      double result = md::LabelNavEtaLabeler::clearEtaFeatures((md::LabelNavEtaLabeler *)result);
      int v2 = *(unsigned __int8 *)(v3 + 120);
    }
    if (!v2)
    {
      uint64_t v5 = *(void *)(v3 + 56);
      if (*MEMORY[0x1E4F64198] != *(_DWORD *)(v5 + 212)
        || vabds_f32(*(float *)(MEMORY[0x1E4F64198] + 4), *(float *)(v5 + 216)) >= 0.00000011921)
      {
        *(void *)(v5 + 212) = *MEMORY[0x1E4F64198];
        md::RouteLineSupport::resolveCurrentRouteLeg((md::RouteLineSupport *)v5);
      }
      [*(id *)(v3 + 48) clearSceneIsMemoryWarning:0];
      uint64_t v6 = *(md::LabelNavEtaLabeler **)(v3 + 680);
      return md::LabelNavEtaLabeler::clearEtaFeatures(v6);
    }
  }
  return result;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::setRouteLabelBoundingRects(uint64_t a1, long long **a2)
{
  uint64_t result = a1 + 696;
  if ((long long **)result != a2) {
    uint64_t result = std::vector<md::LabelBoundingRect,geo::StdAllocator<md::LabelBoundingRect,mdm::Allocator>>::__assign_with_size[abi:nn180100]<md::LabelBoundingRect*,md::LabelBoundingRect*>(result, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
  }
  *(unsigned char *)(a1 + 760) = 1;
  return result;
}

uint64_t std::vector<md::LabelBoundingRect,geo::StdAllocator<md::LabelBoundingRect,mdm::Allocator>>::__assign_with_size[abi:nn180100]<md::LabelBoundingRect*,md::LabelBoundingRect*>(uint64_t result, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *(void *)(result + 16);
  uint64_t v9 = *(void *)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 4) >= a4)
  {
    uint64_t v17 = (uint64_t *)(result + 8);
    uint64_t v16 = *(void *)(result + 8);
    if (0xAAAAAAAAAAAAAAABLL * ((v16 - v9) >> 4) >= a4)
    {
      for (uint64_t i = *(void *)result; a2 != a3; a2 += 3)
      {
        long long v26 = *a2;
        *(void *)(i + 16) = *((void *)a2 + 2);
        *(_OWORD *)uint64_t i = v26;
        *(_DWORD *)(i + 24) = *((_DWORD *)a2 + 6);
        *(_DWORD *)(i + 28) = *((_DWORD *)a2 + 7);
        *(_DWORD *)(i + 32) = *((_DWORD *)a2 + 8);
        *(_DWORD *)(i + 36) = *((_DWORD *)a2 + 9);
        *(unsigned char *)(i + 40) = *((unsigned char *)a2 + 40);
        i += 48;
      }
      uint64_t v24 = i - v9;
    }
    else
    {
      unsigned int v18 = &a2[(v16 - v9) >> 4];
      if (v16 != v9)
      {
        do
        {
          long long v19 = *a2;
          *(void *)(v9 + 16) = *((void *)a2 + 2);
          *(_OWORD *)uint64_t v9 = v19;
          *(_DWORD *)(v9 + 24) = *((_DWORD *)a2 + 6);
          *(_DWORD *)(v9 + 28) = *((_DWORD *)a2 + 7);
          *(_DWORD *)(v9 + 32) = *((_DWORD *)a2 + 8);
          *(_DWORD *)(v9 + 36) = *((_DWORD *)a2 + 9);
          *(unsigned char *)(v9 + 40) = *((unsigned char *)a2 + 40);
          a2 += 3;
          v9 += 48;
        }
        while (a2 != v18);
        uint64_t v9 = *v17;
      }
      uint64_t v20 = v9;
      if (v18 != a3)
      {
        uint64_t v21 = 0;
        do
        {
          if (v9 + v21 * 16)
          {
            uint64_t v22 = v9 + v21 * 16;
            *(void *)uint64_t v22 = *(void *)&v18[v21];
            *(_OWORD *)(v22 + 8) = *(long long *)((char *)&v18[v21] + 8);
            long long v23 = *(long long *)((char *)&v18[v21 + 1] + 8);
            *(unsigned char *)(v22 + 40) = BYTE8(v18[v21 + 2]);
            *(_OWORD *)(v22 + 24) = v23;
          }
          v21 += 3;
        }
        while (&v18[v21] != a3);
        uint64_t v20 = v9 + v21 * 16;
      }
      uint64_t v24 = v20 - v9;
    }
  }
  else
  {
    if (v9)
    {
      *(void *)(result + 8) = v9;
      (*(void (**)(void))(**(void **)(result + 24) + 40))(*(void *)(result + 24));
      uint64_t v8 = 0;
      *(void *)uint64_t v7 = 0;
      *(void *)(v7 + 8) = 0;
      *(void *)(v7 + 16) = 0;
    }
    if (a4 > 0x555555555555555) {
      goto LABEL_32;
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    unint64_t v12 = v10 >= 0x2AAAAAAAAAAAAAALL ? 0x555555555555555 : v11;
    if (v12 > 0x555555555555555) {
LABEL_32:
    }
      abort();
    uint64_t v13 = 48 * v12;
    uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v7 + 24) + 16))(*(void *)(v7 + 24), 48 * v12, 8);
    uint64_t v9 = result;
    *(void *)uint64_t v7 = result;
    *(void *)(v7 + 8) = result;
    *(void *)(v7 + 16) = result + v13;
    uint64_t v14 = result;
    if (a2 != a3)
    {
      uint64_t v14 = result;
      do
      {
        if (v14)
        {
          *(void *)uint64_t v14 = *(void *)a2;
          *(_OWORD *)(v14 + 8) = *(long long *)((char *)a2 + 8);
          long long v15 = *(long long *)((char *)a2 + 24);
          *(unsigned char *)(v14 + 40) = *((unsigned char *)a2 + 40);
          *(_OWORD *)(v14 + 24) = v15;
        }
        a2 += 3;
        v14 += 48;
      }
      while (a2 != a3);
    }
    uint64_t v24 = v14 - result;
    uint64_t v17 = (uint64_t *)(v7 + 8);
  }
  uint64_t *v17 = v9 + v24;
  return result;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::setIsNavCameraDetached(uint64_t this, int a2)
{
  if (*(unsigned __int8 *)(this + 121) != a2)
  {
    *(unsigned char *)(this + 121) = a2;
    uint64_t v2 = *(void *)(this + 16);
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v2 + 3058));
    if (v3)
    {
      uint64_t v4 = *(void *)(v2 + 136);
      if (v4)
      {
        this = *(void *)(v4 + 56);
        if (this)
        {
          uint64_t v6 = v2;
          char v5 = 9;
          return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)this + 48))(this, &v6, &v5);
        }
      }
    }
  }
  return this;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::computeRoutePositionForPOI(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  v5[0] = &unk_1EF5303F0;
  v5[1] = v3;
  v5[2] = a1 - 8;
  v5[3] = v3 + 440;
  v5[4] = a1 + 352;
  return [*(id *)(a1 + 48) computeRoutePositionForPOIAtPixel:a2 currentPosition:a3 context:v5];
}

void md::NavContext::~NavContext(md::NavContext *this)
{
}

void non-virtual thunk to'md::MapNavLabeler::resolveRouteLegWhen(const PolylineCoordinate **this@<X0>, PolylineCoordinate *a2@<X1>, md::RouteLineSupport *a3@<X8>)
{
}

double non-virtual thunk to'md::MapNavLabeler::routeUserOffsetInMeters(md::MapNavLabeler *this)
{
  return *((double *)this + 101);
}

uint64_t non-virtual thunk to'md::MapNavLabeler::routeUserOffset(md::MapNavLabeler *this)
{
  return (uint64_t)this + 800;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::isNavCameraDetached(md::MapNavLabeler *this)
{
  return *((unsigned __int8 *)this + 121);
}

uint64_t non-virtual thunk to'md::MapNavLabeler::currentRouteLeg(md::MapNavLabeler *this)
{
  return *(void *)(*((void *)this + 7) + 224);
}

float non-virtual thunk to'md::MapNavLabeler::currentRoadSignOffset(id *this)
{
  uint64_t v2 = this - 1;
  if (((*((uint64_t (**)(char *))*(this - 1) + 44))((char *)this - 8) & 1) != 0
    || (unint64_t)*(unsigned __int8 *)(*((void *)this[2] + 42) + 163) << 16 == 393216
    || (v4 = (*((uint64_t (**)(id *))*v2 + 47))(v2), double v3 = 0.0, v4))
  {
    objc_msgSend(this[6], "currentRoadSignPixelHeight", v3);
    *(float *)&double v3 = *(float *)&v3 / *((float *)this[2] + 44);
  }
  return *(float *)&v3;
}

BOOL non-virtual thunk to'md::MapNavLabeler::isNavApplicationStateActive(md::MapNavLabeler *this)
{
  return (unint64_t)*(unsigned __int8 *)(*(void *)(*((void *)this + 2) + 336) + 163) << 16 == 0x20000;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::navMode(md::MapNavLabeler *this)
{
  return *((unsigned __int8 *)this + 122);
}

void md::MapNavLabeler::styleManagerDidChange(md::MapNavLabeler *this)
{
  uint64_t v2 = (void *)*((void *)this + 7);
  uint64_t v3 = *(void *)(*((void *)this + 3) + 336);
  uint64_t v5 = *(void *)(v3 + 184);
  int v4 = *(std::__shared_weak_count **)(v3 + 192);
  uint64_t v7 = v5;
  uint64_t v8 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  [v2 setStyleManager:&v7];
  uint64_t v6 = v8;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *((unsigned char *)this + 826) = 1;
}

void sub_1A1F6788C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t md::MapNavLabeler::externalRouteFeatures(md::MapNavLabeler *this)
{
  return *((void *)this + 8) + 288;
}

uint64_t md::MapNavLabeler::externalRouteWaypointFeatures(md::MapNavLabeler *this)
{
  return *((void *)this + 8) + 88;
}

uint64_t md::MapNavLabeler::routeAnnotationFeatures(md::MapNavLabeler *this)
{
  return *((void *)this + 9) + 112;
}

void md::MapNavLabeler::setRouteLine(md::MapNavLabeler *this, VKRouteLine *a2)
{
  int v4 = a2;
  uint64_t v3 = (md::RouteLineSupport *)*((void *)this + 8);
  if (v3) {
    md::RouteLineSupport::setRouteLine(v3, v4);
  }
}

void sub_1A1F67918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t md::MapNavLabeler::setIsNavCameraDetached(uint64_t this, int a2)
{
  if (*(unsigned __int8 *)(this + 129) != a2)
  {
    *(unsigned char *)(this + 129) = a2;
    uint64_t v2 = *(void *)(this + 24);
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v2 + 3058));
    if (v3)
    {
      uint64_t v4 = *(void *)(v2 + 136);
      if (v4)
      {
        this = *(void *)(v4 + 56);
        if (this)
        {
          uint64_t v6 = v2;
          char v5 = 9;
          return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)this + 48))(this, &v6, &v5);
        }
      }
    }
  }
  return this;
}

uint64_t md::MapNavLabeler::setCurrentLocationText(id *this, NSString *a2)
{
  return [this[7] setCurrentLocationText:a2];
}

void md::MapNavLabeler::setTrafficFeatures(md::RouteAnnotationSupport **this, NSArray *a2)
{
}

void md::MapNavLabeler::setFocusedPolyline(id *this, VKPolylineOverlay *a2)
{
  uint64_t v7 = a2;
  objc_msgSend(this[7], "setRoute:");
  unsigned __int8 v3 = (unsigned __int8 *)this[8];
  int v4 = v7 != 0;
  if (!*(void *)(*((void *)v3 + 1) + 184) && v3[254] != v4)
  {
    v3[254] = v4;
    char v5 = (md::WaypointStore *)*((void *)v3 + 9);
    if (v5)
    {
      int v6 = *((unsigned __int8 *)v5 + 49);
      if (v6 != v4)
      {
        if (*((unsigned char *)v5 + 48))
        {
          *((unsigned char *)v5 + 49) = v4;
          if ((v6 != 0) != (v7 != 0)) {
            md::WaypointStore::updateWaypointsForSelection(v5);
          }
        }
        else
        {
          *((unsigned char *)v5 + 49) = v4;
        }
      }
    }
  }
}

void sub_1A1F67A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t md::MapNavLabeler::setRouteOverlayCache(uint64_t this, const md::RouteOverlayCache *a2)
{
  if (*(const md::RouteOverlayCache **)(this + 104) != a2)
  {
    *(void *)(this + 104) = a2;
    *(void *)(*(void *)(this + 688) + 104) = a2;
  }
  return this;
}

uint64_t md::MapNavLabeler::routeUserOffset(md::MapNavLabeler *this)
{
  return (uint64_t)this + 808;
}

uint64_t md::MapNavLabeler::routeSupport(md::MapNavLabeler *this)
{
  return *((void *)this + 8);
}

void md::MapNavLabeler::resolveRouteLegWhen(const PolylineCoordinate **this@<X0>, PolylineCoordinate *a2@<X1>, md::RouteLineSupport *a3@<X8>)
{
}

double md::MapNavLabeler::routeUserOffsetInMeters(md::MapNavLabeler *this)
{
  return *((double *)this + 102);
}

uint64_t md::MapNavLabeler::isNavCameraDetached(md::MapNavLabeler *this)
{
  return *((unsigned __int8 *)this + 129);
}

uint64_t md::MapNavLabeler::currentRouteLeg(md::MapNavLabeler *this)
{
  return *(void *)(*((void *)this + 8) + 224);
}

float md::MapNavLabeler::currentRoadSignOffset(id *this)
{
  if (((*((uint64_t (**)(id *))*this + 44))(this) & 1) != 0
    || (unint64_t)*(unsigned __int8 *)(*((void *)this[3] + 42) + 163) << 16 == 393216
    || (v3 = (*((uint64_t (**)(id *))*this + 47))(this), double v2 = 0.0, v3))
  {
    objc_msgSend(this[7], "currentRoadSignPixelHeight", v2);
    *(float *)&double v2 = *(float *)&v2 / *((float *)this[3] + 44);
  }
  return *(float *)&v2;
}

uint64_t md::MapNavLabeler::computeRoutePositionForPOI(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 24);
  v5[0] = &unk_1EF5303F0;
  v5[1] = v3;
  v5[2] = a1;
  v5[3] = v3 + 440;
  v5[4] = a1 + 360;
  return [*(id *)(a1 + 56) computeRoutePositionForPOIAtPixel:a2 currentPosition:a3 context:v5];
}

uint64_t md::MapNavLabeler::isNavHighZoomActive(md::MapNavLabeler *this)
{
  uint64_t result = (*(uint64_t (**)(md::MapNavLabeler *))(*(void *)this + 352))(this);
  if (result) {
    return *((unsigned __int8 *)this + 130) == 1;
  }
  return result;
}

BOOL md::MapNavLabeler::isEtaActive(md::MapNavLabeler *this)
{
  return *((void *)this + 13) && *(void *)(*((void *)this + 86) + 24) != 0;
}

uint64_t md::MapNavLabeler::setRouteLabelBoundingRects(uint64_t a1, long long **a2)
{
  uint64_t result = a1 + 704;
  if ((long long **)result != a2) {
    uint64_t result = std::vector<md::LabelBoundingRect,geo::StdAllocator<md::LabelBoundingRect,mdm::Allocator>>::__assign_with_size[abi:nn180100]<md::LabelBoundingRect*,md::LabelBoundingRect*>(result, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
  }
  *(unsigned char *)(a1 + 768) = 1;
  return result;
}

uint64_t md::MapNavLabeler::navMode(md::MapNavLabeler *this)
{
  return *((unsigned __int8 *)this + 130);
}

uint64_t md::MapNavLabeler::setNavMode(uint64_t result, char a2)
{
  *(unsigned char *)(result + 130) = a2;
  return result;
}

uint64_t md::MapNavLabeler::setLabelMode(uint64_t result, int a2)
{
  int v2 = a2 == 2;
  if (*(unsigned __int8 *)(result + 128) != v2)
  {
    uint64_t v3 = result;
    *(unsigned char *)(result + 128) = v2;
    uint64_t v4 = *(void *)(result + 64);
    if (*(unsigned __int8 *)(v4 + 252) != v2)
    {
      *(unsigned char *)(v4 + 252) = v2;
      if (a2 != 2) {
        *(void *)(v4 + 224) = 0;
      }
    }
    uint64_t result = *(void *)(result + 688);
    if (*(unsigned __int8 *)(result + 136) != v2)
    {
      *(unsigned char *)(result + 136) = v2;
      uint64_t result = md::LabelNavEtaLabeler::clearEtaFeatures((md::LabelNavEtaLabeler *)result);
      int v2 = *(unsigned __int8 *)(v3 + 128);
    }
    if (!v2)
    {
      uint64_t v5 = *(void *)(v3 + 64);
      if (*MEMORY[0x1E4F64198] != *(_DWORD *)(v5 + 212)
        || vabds_f32(*(float *)(MEMORY[0x1E4F64198] + 4), *(float *)(v5 + 216)) >= 0.00000011921)
      {
        *(void *)(v5 + 212) = *MEMORY[0x1E4F64198];
        md::RouteLineSupport::resolveCurrentRouteLeg((md::RouteLineSupport *)v5);
      }
      [*(id *)(v3 + 56) clearSceneIsMemoryWarning:0];
      int v6 = *(md::LabelNavEtaLabeler **)(v3 + 688);
      return md::LabelNavEtaLabeler::clearEtaFeatures(v6);
    }
  }
  return result;
}

void md::MapNavLabeler::debugDraw(md::MapNavLabeler *this, NSMutableString *a2, float32x2_t *a3)
{
  j = a2;
  if ([*((id *)this + 7) needsDebugDraw])
  {
    uint64_t v5 = *((void *)this + 3);
    *(void *)&long long v121 = &unk_1EF5303F0;
    *((void *)&v121 + 1) = v5;
    *(void *)&long long v122 = this;
    *((void *)&v122 + 1) = v5 + 440;
    uint64_t v123 = (char *)this + 360;
    [*((id *)this + 7) debugDraw:j overlayConsole:a3 navContext:&v121];
  }
  if (*(unsigned char *)(*((void *)this + 9) + 232))
  {
    v114 = (void *)*((void *)this + 9);
    int v6 = j;
    uint64_t v123 = 0;
    long long v121 = 0u;
    long long v122 = 0u;
    uint64_t v118 = 0;
    {
      operator new();
    }
    uint64_t v119 = mdm::Allocator::instance(void)::alloc;
    uint64_t v120 = 0;
    uint64_t v117 = &v118;
    uint64_t v8 = v114[10];
    uint64_t v7 = v114[11];
    uint64_t v9 = v7 - v8;
    v111 = j;
    if (v7 != v8)
    {
      uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 48, 8);
      *(void *)uint64_t v10 = 0;
      *(void *)(v10 + 8) = 0;
      *(void *)(v10 + 32) = 0;
      *(void *)(v10 + 40) = 0;
      *(void *)(v10 + 16) = &v118;
      uint64_t v118 = (uint64_t *)v10;
      if (*v117) {
        uint64_t v117 = (uint64_t **)*v117;
      }
      *(unsigned char *)(v10 + 24) = 1;
      ++v120;
      *(void *)(v10 + 40) = v9 >> 3;
    }
    v110 = this;
    int v113 = v6;
    uint64_t v11 = (id *)v114[6];
    unint64_t v12 = (id *)v114[7];
    if (v11 == v12)
    {
      char v13 = 0;
      goto LABEL_42;
    }
    char v13 = 0;
    while (1)
    {
      id v14 = *v11;
      uint64_t v15 = [v14 trafficFeatureType];
      uint64_t v16 = v118;
      if (!v118)
      {
LABEL_12:
        uint64_t v17 = [v14 trafficFeatureType];
        uint64_t v18 = v17;
        long long v19 = v118;
        uint64_t v20 = &v118;
        uint64_t v21 = &v118;
        if (v118)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v21 = (uint64_t **)v19;
              uint64_t v28 = v19[4];
              if (v17 >= v28) {
                break;
              }
              long long v19 = *v21;
              uint64_t v20 = v21;
              if (!*v21) {
                goto LABEL_25;
              }
            }
            if (v28 >= v17) {
              break;
            }
            long long v19 = v21[1];
            if (!v19)
            {
              uint64_t v20 = v21 + 1;
              goto LABEL_25;
            }
          }
          uint64_t v29 = (uint64_t *)v21;
          uint64_t v31 = 1;
        }
        else
        {
LABEL_25:
          uint64_t v29 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v119 + 16))(v119, 48, 8);
          v29[4] = v18;
          v29[5] = 0;
          *uint64_t v29 = 0;
          v29[1] = 0;
          v29[2] = (uint64_t)v21;
          *uint64_t v20 = v29;
          size_t v30 = v29;
          if (*v117)
          {
            uint64_t v117 = (uint64_t **)*v117;
            size_t v30 = *v20;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v118, v30);
          ++v120;
          uint64_t v31 = 1;
        }
        goto LABEL_39;
      }
      while (1)
      {
        uint64_t v22 = v16[4];
        if (v15 < v22) {
          goto LABEL_15;
        }
        if (v22 >= v15) {
          break;
        }
        ++v16;
LABEL_15:
        uint64_t v16 = (uint64_t *)*v16;
        if (!v16) {
          goto LABEL_12;
        }
      }
      uint64_t v23 = [v14 trafficFeatureType];
      uint64_t v24 = v23;
      uint64_t v25 = v118;
      long long v26 = &v118;
      uint64_t v27 = &v118;
      if (v118)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v27 = (uint64_t **)v25;
            uint64_t v32 = v25[4];
            if (v23 >= v32) {
              break;
            }
            uint64_t v25 = *v27;
            long long v26 = v27;
            if (!*v27) {
              goto LABEL_33;
            }
          }
          if (v32 >= v23) {
            break;
          }
          uint64_t v25 = v27[1];
          if (!v25)
          {
            long long v26 = v27 + 1;
            goto LABEL_33;
          }
        }
        uint64_t v29 = (uint64_t *)v27;
      }
      else
      {
LABEL_33:
        uint64_t v29 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v119 + 16))(v119, 48, 8);
        v29[4] = v24;
        v29[5] = 0;
        *uint64_t v29 = 0;
        v29[1] = 0;
        v29[2] = (uint64_t)v27;
        *long long v26 = v29;
        uint64_t v33 = v29;
        if (*v117)
        {
          uint64_t v117 = (uint64_t **)*v117;
          uint64_t v33 = *v26;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v118, v33);
        ++v120;
      }
      uint64_t v31 = v29[5] + 1;
LABEL_39:
      v29[5] = v31;
      uint64_t v34 = [v14 navigationState];
      unsigned int v35 = [v14 navigationState];
      v13 |= v34 != 0;
      ++*((void *)&v121 + v35);

      if (++v11 == v12)
      {
LABEL_42:
        [(NSMutableString *)v113 appendFormat:@"RouteAnnotationSupport\n"];
        [(NSMutableString *)v113 appendFormat:@"\tFeatureCount:%lu\n", ((uint64_t)(v114[11] - v114[10]) >> 3) + ((uint64_t)(v114[7] - v114[6]) >> 3)];
        uint64_t v36 = (uint64_t *)v117;
        if (v117 != &v118)
        {
          do
          {
            uint8x8_t v37 = +[VKTrafficFeature stringForFeatureType:v36[4]];
            [(NSMutableString *)v113 appendFormat:@"\t\t%@:%lu\n", v37, v36[5]];

            uint64_t v38 = (uint64_t *)v36[1];
            if (v38)
            {
              do
              {
                char v39 = (uint64_t **)v38;
                uint64_t v38 = (uint64_t *)*v38;
              }
              while (v38);
            }
            else
            {
              do
              {
                char v39 = (uint64_t **)v36[2];
                BOOL v40 = *v39 == v36;
                uint64_t v36 = (uint64_t *)v39;
              }
              while (!v40);
            }
            uint64_t v36 = (uint64_t *)v39;
          }
          while (v39 != &v118);
        }
        if (v13)
        {
          [(NSMutableString *)v113 appendFormat:@"\tNavigationStates\n"];
          uint64_t v41 = +[VKTrafficFeature stringForNavState:0];
          uint64_t v42 = (void *)v41;
          if ((void)v121) {
            [(NSMutableString *)v113 appendFormat:@"\t\t%@:%lu\n", v41, (void)v121];
          }

          uint64_t v43 = +[VKTrafficFeature stringForNavState:1];
          float v44 = (void *)v43;
          if (*((void *)&v121 + 1)) {
            [(NSMutableString *)v113 appendFormat:@"\t\t%@:%lu\n", v43, *((void *)&v121 + 1)];
          }

          uint64_t v45 = +[VKTrafficFeature stringForNavState:2];
          uint64_t v46 = (void *)v45;
          if ((void)v122) {
            [(NSMutableString *)v113 appendFormat:@"\t\t%@:%lu\n", v45, (void)v122];
          }

          uint64_t v47 = +[VKTrafficFeature stringForNavState:3];
          uint64_t v48 = (void *)v47;
          if (*((void *)&v122 + 1)) {
            [(NSMutableString *)v113 appendFormat:@"\t\t%@:%lu\n", v47, *((void *)&v122 + 1)];
          }

          uint64_t v49 = +[VKTrafficFeature stringForNavState:4];
          uint64_t v50 = (void *)v49;
          if (v123) {
            [(NSMutableString *)v113 appendFormat:@"\t\t%@:%lu\n", v49, v123];
          }
        }
        a3[12].i32[0] = -1;
        uint64_t v51 = (void *)v114[14];
        for (uint64_t i = (void *)v114[15]; v51 != i; v51 += 2)
        {
          uint64_t v53 = *v51;
          int v116 = 0;
          uint64_t v54 = (float *)(*(uint64_t (**)(uint64_t, int *))(*(void *)v53 + 112))(v53, &v116);
          uint64_t v55 = md::LabelPoint::mercatorPoint((md::LabelPoint *)v54);
          uint64_t v56 = *v114;
          float v57 = v54[10];
          if (v57 == 3.4028e38) {
            float v57 = 0.0;
          }
          double v58 = v57;
          long long v59 = *(_OWORD *)v55;
          double v60 = *(double *)(v55 + 8);
          double v61 = v58 * *(float *)(v56 + 488);
          if (*(unsigned char *)(v56 + 448))
          {
            double v62 = v61 * 0.0000000249532021;
          }
          else
          {
            long double v63 = *(double *)&v59 * 6.28318531;
            long double v64 = exp(v60 * 6.28318531 + -3.14159265);
            double v65 = atan(v64) * 2.0 + -1.57079633;
            long double v66 = fmod(v63, 6.28318531);
            double v67 = fmod(v66 + 6.28318531, 6.28318531) + -3.14159265;
            __double2 v68 = __sincos_stret(v65);
            double v69 = 6378137.0 / sqrt(v68.__sinval * v68.__sinval * -0.00669437999 + 1.0);
            double v70 = (v69 + v61) * v68.__cosval;
            __double2 v71 = __sincos_stret(v67);
            *(double *)&long long v59 = v70 * v71.__cosval;
            double v60 = v70 * v71.__sinval;
            double v62 = (v61 + v69 * 0.99330562) * v68.__sinval;
          }
          float32x2_t v72 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(v56 + 1400), *(float64x2_t *)(v56 + 1304), *(double *)&v59), *(float64x2_t *)(v56 + 1336), v60), *(float64x2_t *)(v56 + 1368), v62), 1.0/ (*(double *)(v56 + 1424)+ *(double *)(v56 + 1328) * *(double *)&v59+ *(double *)(v56 + 1360) * v60+ *(double *)(v56 + 1392) * v62)));
          if (v72.f32[0] >= *(float *)(v56 + 1544)
            && v72.f32[0] < *(float *)(v56 + 1552)
            && v72.f32[1] >= *(float *)(v56 + 1548)
            && v72.f32[1] < *(float *)(v56 + 1556))
          {
            float32x2_t v112 = v72;
            double v73 = (*(double (**)(void, float))(**(void **)(*(void *)(v56 + 168) + 32) + 72))(*(void *)(*(void *)(v56 + 168) + 32), v72.f32[1]);
            unsigned int v74 = vabdd_f64(v73, (*(double (**)(void))(*(void *)*v51 + 632))(*v51))
                / 0xFA;
            if (v74 >= 2) {
              unsigned int v74 = 2;
            }
            int v75 = dword_1A28FFD28[v74];
            a3[1] = v112;
            ggl::DebugConsole::drawSymbol(a3, v75);
          }
        }
        a3[12].i32[0] = -16776961;
        float v76 = (id *)v114[10];
        uint64_t v77 = (id *)v114[11];
        for (j = v111; v76 != v77; ++v76)
        {
          id v78 = *v76;
          [v78 mercatorPoint];
          uint64_t v81 = *v114;
          double v83 = v82 * *(float *)(*v114 + 488);
          if (*(unsigned char *)(*v114 + 448))
          {
            double v84 = v83 * 0.0000000249532021;
          }
          else
          {
            long double v85 = v79 * 6.28318531;
            long double v86 = exp(v80 * 6.28318531 + -3.14159265);
            double v87 = atan(v86) * 2.0 + -1.57079633;
            long double v88 = fmod(v85, 6.28318531);
            double v89 = fmod(v88 + 6.28318531, 6.28318531) + -3.14159265;
            __double2 v90 = __sincos_stret(v87);
            double v91 = 6378137.0 / sqrt(v90.__sinval * v90.__sinval * -0.00669437999 + 1.0);
            double v92 = (v91 + v83) * v90.__cosval;
            __double2 v93 = __sincos_stret(v89);
            double v79 = v92 * v93.__cosval;
            double v80 = v92 * v93.__sinval;
            double v84 = (v83 + v91 * 0.99330562) * v90.__sinval;
          }
          float32x2_t v94 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(v81 + 1400), *(float64x2_t *)(v81 + 1304), v79), *(float64x2_t *)(v81 + 1336), v80), *(float64x2_t *)(v81 + 1368), v84), 1.0/ (*(double *)(v81 + 1424)+ *(double *)(v81 + 1328) * v79+ *(double *)(v81 + 1360) * v80+ *(double *)(v81 + 1392) * v84)));
          if (v94.f32[0] >= *(float *)(v81 + 1544)
            && v94.f32[0] < *(float *)(v81 + 1552)
            && v94.f32[1] >= *(float *)(v81 + 1548)
            && v94.f32[1] < *(float *)(v81 + 1556))
          {
            a3[1] = v94;
            ggl::DebugConsole::drawSymbol(a3, 0);
          }
        }
        std::__tree<std::__value_type<VKTrafficFeatureType,unsigned long>,std::__map_value_compare<VKTrafficFeatureType,std::__value_type<VKTrafficFeatureType,unsigned long>,std::less<VKTrafficFeatureType>,true>,geo::StdAllocator<std::__value_type<VKTrafficFeatureType,unsigned long>,mdm::Allocator>>::destroy((uint64_t)&v117, v118);

        this = v110;
        break;
      }
    }
  }
  uint64_t v95 = *((void *)this + 8);
  if (*(unsigned char *)(v95 + 249))
  {
    uint64_t v96 = j;
    uint64_t v97 = *(double **)(v95 + 8);
    double v98 = v97[74];
    long double v99 = v97[72] * 6.28318531;
    long double v100 = exp(v97[73] * 6.28318531 + -3.14159265);
    double v101 = atan(v100);
    long double v102 = fmod(v99, 6.28318531);
    double v103 = fmod(v102 + 6.28318531, 6.28318531);
    [(NSMutableString *)v96 appendString:@"RouteLineSupport:\n"];
    [(NSMutableString *)v96 appendFormat:@"\tMapType:%d\n", *(unsigned int *)(*(void *)(v95 + 8) + 3548)];
    [(NSMutableString *)v96 appendFormat:@"\tEye:%.8f,%.8f,%.2f\n", v101 * 114.591559 + -90.0, v103 * 57.2957795 + -180.0, v98 * 40075017.0];
    [(NSMutableString *)v96 appendFormat:@"\tWaypoints:%lu\n", (uint64_t)(*(void *)(v95 + 96) - *(void *)(v95 + 88)) >> 4];
    v104 = *(void **)(v95 + 40);
    v105 = (void *)(v95 + 48);
    if (v104 != v105)
    {
      do
      {
        uint64_t v106 = [(id)v104[4] route];
        uint64_t v107 = [v106 uniqueRouteID];
        [(NSMutableString *)v96 appendFormat:@"\tRoute:%@\n", v107];

        [(NSMutableString *)v96 appendFormat:@"\t\tClusteringZoomRange:%f-%f\n", *(float *)(v104[5] + 280), *(float *)(v104[5] + 284)];
        int v108 = (void *)v104[1];
        if (v108)
        {
          do
          {
            v109 = v108;
            int v108 = (void *)*v108;
          }
          while (v108);
        }
        else
        {
          do
          {
            v109 = (void *)v104[2];
            BOOL v40 = *v109 == (void)v104;
            v104 = v109;
          }
          while (!v40);
        }
        v104 = v109;
      }
      while (v109 != v105);
    }
  }
}

void sub_1A1F68A38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,void *a28)
{
  std::__tree<std::__value_type<VKTrafficFeatureType,unsigned long>,std::__map_value_compare<VKTrafficFeatureType,std::__value_type<VKTrafficFeatureType,unsigned long>,std::less<VKTrafficFeatureType>,true>,geo::StdAllocator<std::__value_type<VKTrafficFeatureType,unsigned long>,mdm::Allocator>>::destroy((uint64_t)&a27, a28);

  _Unwind_Resume(a1);
}

void md::MapNavLabeler::populateDebugNode(void *a1, uint64_t a2)
{
  __p[23] = 13;
  strcpy(__p, "MapNavLabeler");
  ChildNode = gdc::DebugTreeNode::createChildNode(a2, (long long *)__p);
  uint64_t v4 = a1[3];
  uint64_t v5 = *(unsigned int *)(v4 + 3560);
  float v6 = *(float *)(v4 + 3564);
  __p[23] = 15;
  strcpy(__p, "RouteUserOffset");
  double v7 = v6;
  uint64_t v8 = (char *)operator new(0x80uLL);
  __dst.__r_.__value_.__l.__size_ = (std::string::size_type)(v8 + 128);
  __dst.__r_.__value_.__r.__words[2] = (std::string::size_type)(v8 + 128);
  *((void *)v8 + 1) = v5;
  *((void *)v8 + 5) = 0;
  *((void *)v8 + 6) = 0;
  *((void *)v8 + 4) = 0;
  *((_DWORD *)v8 + 14) = 1;
  *((double *)v8 + 10) = v7;
  *((void *)v8 + 12) = 0;
  *((void *)v8 + 13) = 0;
  *((void *)v8 + 14) = 0;
  *((_DWORD *)v8 + 30) = 2;
  __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__p, (uint64_t *)&__dst);
  if (v8[119] < 0)
  {
    operator delete(*((void **)v8 + 12));
    if ((v8[55] & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((v8[55] & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(*((void **)v8 + 4));
LABEL_3:
  operator delete(v8);
  uint64_t v9 = a1[13];
  __p[23] = 18;
  strcpy(__p, "ETA Labeler Active");
  if (v9) {
    LODWORD(v9) = *(void *)(a1[86] + 24) != 0;
  }
  int v91 = 0;
  memset(&v90[4], 0, 24);
  v90[0] = v9;
  gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)__p, (uint64_t)v90);
  if (a1[13] && *(void *)(a1[86] + 24))
  {
    std::basic_ostringstream<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::basic_ostringstream[abi:nn180100]((uint64_t)__p);
    md::LabelNavEtaLabeler::describeDebugState(a1[86], __p, 1);
    *(void *)&v79[0] = operator new(0x19uLL);
    *(long long *)((char *)v79 + 8) = xmmword_1A28FCDB0;
    strcpy(*(char **)&v79[0], "ETA Labeler Debug State");
    if ((v88 & 0x10) != 0)
    {
      unint64_t v12 = v87;
      if (v87 < v83)
      {
        unint64_t v87 = v83;
        unint64_t v12 = v83;
      }
      char v13 = (const void **)&v82;
    }
    else
    {
      if ((v88 & 8) == 0)
      {
        std::string::size_type v10 = 0;
        uint64_t v72 = v86;
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = 0;
        p_dst = &__dst;
        goto LABEL_24;
      }
      char v13 = (const void **)v81;
      unint64_t v12 = v81[2];
    }
    id v14 = *v13;
    std::string::size_type v10 = v12 - (void)*v13;
    uint64_t v72 = v86;
    if (v10 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    if (v10 >= 0x17)
    {
      uint64_t v15 = (v10 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v10 | 7) != 0x17) {
        uint64_t v15 = v10 | 7;
      }
      uint64_t v16 = v15 + 1;
      p_dst = (std::string *)(*(uint64_t (**)(void))(*(void *)v86 + 16))();
      __dst.__r_.__value_.__l.__size_ = v10;
      __dst.__r_.__value_.__r.__words[2] = v16 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    }
    else
    {
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v10;
      p_dst = &__dst;
      if (!v10)
      {
LABEL_24:
        p_dst->__r_.__value_.__s.__data_[v10] = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
        {
          size_t size = __dst.__r_.__value_.__l.__size_;
          if (__dst.__r_.__value_.__l.__size_ > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          uint64_t v17 = (std::string *)__dst.__r_.__value_.__r.__words[0];
          if (__dst.__r_.__value_.__l.__size_ < 0x17)
          {
LABEL_26:
            HIBYTE(v74) = size;
            long long v19 = v73;
            if (!size)
            {
LABEL_34:
              v19[size] = 0;
              long long v76 = 0uLL;
              unint64_t v77 = 0;
              int v78 = 4;
              int v22 = SHIBYTE(v74);
              if (SHIBYTE(v74) < 0)
              {
                std::string::__assign_no_alias<true>(&v76, v73[0], (size_t)v73[1]);
              }
              else
              {
                long long v76 = *(_OWORD *)v73;
                unint64_t v77 = v74;
              }
              gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v79, (uint64_t)v75);
              if (SHIBYTE(v77) < 0)
              {
                operator delete((void *)v76);
                if ((v22 & 0x80000000) == 0)
                {
LABEL_39:
                  if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                    goto LABEL_40;
                  }
                  goto LABEL_92;
                }
              }
              else if ((v22 & 0x80000000) == 0)
              {
                goto LABEL_39;
              }
              operator delete(v73[0]);
              if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
              {
LABEL_40:
                if ((SBYTE7(v79[1]) & 0x80000000) == 0)
                {
LABEL_41:
                  *(void *)std::string __p = off_1EF57F578;
                  double v89 = &off_1EF57F5A0;
                  *(void *)&__p[8] = &unk_1EF57F2D0;
                  if (SHIBYTE(v85) < 0) {
                    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v86 + 40))(v86, v84, v85 & 0x7FFFFFFFFFFFFFFFLL);
                  }
                  std::streambuf::~streambuf();
                  std::ostream::~ostream();
                  MEMORY[0x1A62391A0](&v89);
                  goto LABEL_44;
                }
LABEL_93:
                operator delete(*(void **)&v79[0]);
                goto LABEL_41;
              }
LABEL_92:
              (*(void (**)(uint64_t, std::string::size_type, std::string::size_type))(*(void *)v72 + 40))(v72, __dst.__r_.__value_.__r.__words[0], __dst.__r_.__value_.__r.__words[2] & 0x7FFFFFFFFFFFFFFFLL);
              if ((SBYTE7(v79[1]) & 0x80000000) == 0) {
                goto LABEL_41;
              }
              goto LABEL_93;
            }
LABEL_33:
            memmove(v19, v17, size);
            goto LABEL_34;
          }
        }
        else
        {
          uint64_t v17 = &__dst;
          size_t size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if (HIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0x17uLL) {
            goto LABEL_26;
          }
        }
        uint64_t v20 = (size & 0x7FFFFFFFFFFFFFF8) + 8;
        if ((size | 7) != 0x17) {
          uint64_t v20 = size | 7;
        }
        uint64_t v21 = v20 + 1;
        long long v19 = operator new(v20 + 1);
        v73[1] = (void *)size;
        unint64_t v74 = v21 | 0x8000000000000000;
        v73[0] = v19;
        goto LABEL_33;
      }
    }
    memmove(p_dst, v14, v10);
    goto LABEL_24;
  }
LABEL_44:
  uint64_t v68 = (uint64_t)ChildNode;
  double v69 = a1;
  uint64_t v23 = (void *)a1[9];
  strcpy((char *)v79, "RouteAnnotationSupport");
  BYTE7(v79[1]) = 22;
  uint64_t v24 = gdc::DebugTreeNode::createChildNode((uint64_t)ChildNode, v79);
  __p[23] = 15;
  strcpy(__p, "TrafficFeatures");
  uint64_t v70 = (uint64_t)v24;
  uint64_t v25 = gdc::DebugTreeNode::createChildNode((uint64_t)v24, (long long *)__p);
  long long v26 = (id *)v23[6];
  uint64_t v27 = (id *)v23[7];
  if (v26 != v27)
  {
    uint64_t v28 = (uint64_t)v25;
    do
    {
      id v29 = *v26;
      size_t v30 = [v29 uniqueIdentifier];
      if (v30)
      {
        id v31 = [v29 uniqueIdentifier];
        uint64_t v32 = (const char *)[v31 UTF8String];
      }
      else
      {
        uint64_t v32 = "";
      }

      size_t v33 = strlen(v32);
      if (v33 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      size_t v34 = v33;
      if (v33 >= 0x17)
      {
        uint64_t v36 = (v33 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v33 | 7) != 0x17) {
          uint64_t v36 = v33 | 7;
        }
        uint64_t v37 = v36 + 1;
        unsigned int v35 = operator new(v36 + 1);
        *(void *)&__p[8] = v34;
        *(void *)&__p[16] = v37 | 0x8000000000000000;
        *(void *)std::string __p = v35;
      }
      else
      {
        __p[23] = v33;
        unsigned int v35 = __p;
        if (!v33) {
          goto LABEL_57;
        }
      }
      memmove(v35, v32, v34);
LABEL_57:
      v35[v34] = 0;
      uint64_t v38 = gdc::DebugTreeNode::createChildNode(v28, (long long *)__p);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      objc_msgSend(v29, "populateDebugNode:", v38, v68, v69, v70);

      ++v26;
    }
    while (v26 != v27);
  }
  __p[23] = 16;
  strcpy(__p, "TrafficIncidents");
  char v39 = gdc::DebugTreeNode::createChildNode(v70, (long long *)__p);
  BOOL v40 = (id *)v23[10];
  uint64_t v41 = (id *)v23[11];
  if (v40 != v41)
  {
    uint64_t v42 = (uint64_t)v39;
    do
    {
      id v43 = *v40;
      float v44 = [v43 uniqueIdentifier];
      if (v44)
      {
        id v45 = [v43 uniqueIdentifier];
        uint64_t v46 = (const char *)[v45 UTF8String];
      }
      else
      {
        uint64_t v46 = "";
      }

      size_t v47 = strlen(v46);
      if (v47 > 0x7FFFFFFFFFFFFFF7) {
        abort();
      }
      size_t v48 = v47;
      if (v47 >= 0x17)
      {
        uint64_t v50 = (v47 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v47 | 7) != 0x17) {
          uint64_t v50 = v47 | 7;
        }
        uint64_t v51 = v50 + 1;
        uint64_t v49 = operator new(v50 + 1);
        *(void *)&__p[8] = v48;
        *(void *)&__p[16] = v51 | 0x8000000000000000;
        *(void *)std::string __p = v49;
      }
      else
      {
        __p[23] = v47;
        uint64_t v49 = __p;
        if (!v47) {
          goto LABEL_74;
        }
      }
      memmove(v49, v46, v48);
LABEL_74:
      v49[v48] = 0;
      objc_msgSend(v43, "populateDebugNode:", gdc::DebugTreeNode::createChildNode(v42, (long long *)__p));
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }

      ++v40;
    }
    while (v40 != v41);
  }
  __p[23] = 13;
  strcpy(__p, "LabelFeatures");
  uint64_t v52 = gdc::DebugTreeNode::createChildNode(v70, (long long *)__p);
  uint64_t v53 = (uint64_t *)v23[14];
  uint64_t v54 = (uint64_t *)v23[15];
  if (v53 != v54)
  {
    uint64_t v55 = (uint64_t)v52;
    unint64_t v56 = 1;
    do
    {
      uint64_t v57 = *v53;
      __p[23] = 7;
      strcpy(__p, "Feature");
      std::to_string(&__dst, v56);
      double v58 = gdc::DebugTreeNode::createChildNode(v55, (long long *)__p, (long long *)&__dst);
      (*(void (**)(uint64_t, char *, void))(*(void *)v57 + 464))(v57, v58, *v23);
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__dst.__r_.__value_.__l.__data_);
      }
      v53 += 2;
      ++v56;
    }
    while (v53 != v54);
  }
  if (SBYTE7(v79[1]) < 0) {
    operator delete(*(void **)&v79[0]);
  }
  long long v59 = (void *)v69[8];
  BYTE7(v79[1]) = 16;
  strcpy((char *)v79, "RouteLineSupport");
  double v60 = gdc::DebugTreeNode::createChildNode(v68, v79);
  if (v59[11] != v59[12])
  {
    __p[23] = 14;
    strcpy(__p, "RouteWaypoints");
    double v61 = gdc::DebugTreeNode::createChildNode((uint64_t)v60, (long long *)__p);
    double v62 = (uint64_t *)v59[11];
    long double v63 = (uint64_t *)v59[12];
    if (v62 != v63)
    {
      uint64_t v64 = (uint64_t)v61;
      unint64_t v65 = 1;
      do
      {
        uint64_t v66 = *v62;
        __p[23] = 8;
        strcpy(__p, "Waypoint");
        std::to_string(&__dst, v65);
        double v67 = gdc::DebugTreeNode::createChildNode(v64, (long long *)__p, (long long *)&__dst);
        (*(void (**)(uint64_t, char *, void))(*(void *)v66 + 464))(v66, v67, v59[1]);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__dst.__r_.__value_.__l.__data_);
        }
        v62 += 2;
        ++v65;
      }
      while (v62 != v63);
    }
  }
}

void sub_1A1F694C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32,uint64_t a33,char a34)
{
  if (a32 < 0) {
    operator delete(__p);
  }
  std::basic_ostringstream<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::~basic_ostringstream((uint64_t)&a34);
  _Unwind_Resume(a1);
}

void sub_1A1F69538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,void *a37,uint64_t a38,int a39,__int16 a40,char a41,char a42)
{
  if (a35 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void md::Labeler::debugString(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t md::Labeler::debugHighlightLabelAtPixel()
{
  return 0;
}

void md::Labeler::labelMarkerForLabel(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void md::Labeler::roadMarkerForSelectionAtPixel(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

BOOL md::MapNavLabeler::isLabelHitAtPixel(int a1, md::NavLabelMarker *this, float *a3)
{
  if (*((unsigned char *)this + 224) != 1) {
    return 0;
  }
  uint64_t v4 = md::NavLabelMarker::navRoadLabel((id *)this);
  uint64_t v5 = v4;
  if (v4 && *(void *)[v4 label])
  {
    float v6 = (float **)[v5 label];
    uint64_t v8 = *v6;
    double v7 = (std::__shared_weak_count *)v6[1];
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }

    if (!v8 || (*a3 <= v8[86] ? (v9 = *a3 >= v8[84]) : (v9 = 0), (float v10 = a3[1], v10 > v8[87]) || v10 < v8[85])) {
      BOOL v9 = 0;
    }
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  else
  {

    return 0;
  }
  return v9;
}

void sub_1A1F6972C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::MapNavLabeler::getLabelMarkers(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[3];
  uint64_t v5 = *(std::__shared_weak_count **)(v4 + 16);
  uint64_t v56 = *(void *)(v4 + 8);
  if (!v5 || (uint64_t v57 = std::__shared_weak_count::lock(v5)) == 0)
  {
    std::__throw_bad_weak_ptr[abi:nn180100]();
LABEL_74:
      operator new();
    goto LABEL_4;
  }
  uint64_t v50 = a2;
  uint64_t v52 = 0;
  uint64_t v53 = 0;
  unint64_t v54 = 0;
  int v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
LABEL_4:
  uint64_t v55 = *((void *)v2 + 91);
  if (a1[13])
  {
    if (*(void *)(a1[86] + 24))
    {
      uint64_t v7 = a1[81];
      uint64_t v8 = a1[82];
      if (v7 != v8)
      {
        while (1)
        {
          long long v58 = (unint64_t)off_1EF559858;
          *((void *)&v58 + 1) = *(id *)(v7 + 8);

          id v10 = *((id *)&v58 + 1);
          uint64_t v11 = v10;
          unint64_t v12 = v53;
          unint64_t v13 = v54;
          if ((unint64_t)v53 < v54)
          {
            if (v53)
            {
              *uint64_t v53 = v10;
              uint64_t v11 = 0;
            }
            BOOL v9 = v53 + 1;
            goto LABEL_9;
          }
          id v14 = v52;
          uint64_t v15 = v53 - v52;
          unint64_t v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 61) {
            abort();
          }
          if ((uint64_t)(v54 - (void)v52) >> 2 > v16) {
            unint64_t v16 = (uint64_t)(v54 - (void)v52) >> 2;
          }
          uint64_t v17 = v54 - (unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v16;
          if (v17)
          {
            uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v55 + 16))(v55, 8 * v17, 8);
            long long v19 = (id *)(v18 + 8 * v15);
            uint64_t v20 = v18 + 8 * v17;
            long long v21 = 0uLL;
            if (v18)
            {
              *long long v19 = v11;
              uint64_t v11 = 0;
            }
          }
          else
          {
            uint64_t v20 = 0;
            long long v19 = (id *)(8 * v15);
            long long v21 = 0uLL;
          }
          BOOL v9 = v19 + 1;
          if (v53 != v52) {
            break;
          }
          uint64_t v52 = v19;
          unint64_t v54 = v20;
          if (v53) {
            goto LABEL_36;
          }
LABEL_9:
          uint64_t v53 = v9;

          *(void *)&long long v58 = off_1EF559858;
          v7 += 24;
          if (v7 == v8) {
            goto LABEL_41;
          }
        }
        unint64_t v22 = (char *)v53 - (char *)v52 - 8;
        if (v22 > 0x57
          && ((unint64_t v23 = ((char *)v52 - (char *)v53 + 7) & 0xFFFFFFFFFFFFFFF8, (id *)((char *)v53 + v23) >= v19)
           || (id *)((char *)v19 + v23) >= v53))
        {
          uint64_t v27 = 0;
          uint64_t v28 = (v22 >> 3) + 1;
          uint64_t v24 = &v53[-(v28 & 0x3FFFFFFFFFFFFFFCLL)];
          uint64_t v29 = v28 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            size_t v30 = &v53[v27];
            long long v32 = *(_OWORD *)&v53[v27 - 4];
            long long v31 = *(_OWORD *)&v53[v27 - 2];
            size_t v33 = &v19[v27];
            *((_OWORD *)v30 - 2) = v21;
            *((_OWORD *)v30 - 1) = v21;
            *((_OWORD *)v33 - 2) = v32;
            *((_OWORD *)v33 - 1) = v31;
            v27 -= 4;
            v29 -= 4;
          }
          while (v29);
          v19 -= v28 & 0x3FFFFFFFFFFFFFFCLL;
          if (v28 == (v28 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_30;
          }
        }
        else
        {
          uint64_t v24 = v53;
        }
        do
        {
          uint64_t v25 = *--v24;
          id *v24 = 0;
          *--long long v19 = v25;
        }
        while (v24 != v52);
        id v14 = v52;
        unint64_t v12 = v53;
        unint64_t v13 = v54;
LABEL_30:
        uint64_t v52 = v19;
        unint64_t v54 = v20;
        if (v12 != v14)
        {
          do
          {
            long long v26 = *--v12;
          }
          while (v12 != v14);
          unint64_t v12 = v14;
        }
        if (!v12) {
          goto LABEL_9;
        }
LABEL_36:
        (*(void (**)(uint64_t, id *, unint64_t))(*(void *)v55 + 40))(v55, v12, v13 - (void)v12);
        goto LABEL_9;
      }
    }
  }
LABEL_41:
  size_t v34 = v52;
  if (v52 == v53) {
    goto LABEL_64;
  }
  do
  {
    id v35 = *v34;
    uint64_t v36 = (float *)a1[3];
    uint64_t v37 = [v35 label];
    uint64_t v38 = *(float **)v37;
    if (v36[380] <= *(float *)(*(void *)v37 + 336)
      || v36[378] >= v38[86]
      || v36[381] <= v38[85]
      || v36[379] >= v38[87])
    {
      goto LABEL_43;
    }
    char v39 = [v35 navFeature];
    float v40 = *(float *)(a1[3] + 176);
    uint64_t v41 = (std::__shared_weak_count *)operator new(0x140uLL);
    v41->__shared_owners_ = 0;
    v41->__shared_weak_owners_ = 0;
    v41->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FD10;
    uint64_t v42 = v41 + 1;
    objc_initWeak(&location, v39);
    md::NavLabelMarker::NavLabelMarker((uint64_t)&v41[1], &v56, &location, v40);
    objc_storeWeak(&location, 0);
    objc_destroyWeak(&location);
    shared_weak_owners = (std::__shared_weak_count *)v41[1].__shared_weak_owners_;
    if (!shared_weak_owners)
    {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v41->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v41[1].__shared_owners_ = (uint64_t)v42;
      v41[1].__shared_weak_owners_ = (uint64_t)v41;
LABEL_52:
      if (!atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
        std::__shared_weak_count::__release_weak(v41);
      }
      goto LABEL_54;
    }
    if (shared_weak_owners->__shared_owners_ == -1)
    {
      atomic_fetch_add_explicit(&v41->__shared_owners_, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v41->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      v41[1].__shared_owners_ = (uint64_t)v42;
      v41[1].__shared_weak_owners_ = (uint64_t)v41;
      std::__shared_weak_count::__release_weak(shared_weak_owners);
      goto LABEL_52;
    }
LABEL_54:
    *(void *)&long long v44 = v41 + 1;
    *((void *)&v44 + 1) = v41;
    long long v51 = v44;
    long long v58 = v44;

    id v45 = *(long long **)(v50 + 8);
    if ((unint64_t)v45 >= *(void *)(v50 + 16))
    {
      uint64_t v46 = std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>(v50, &v58);
    }
    else
    {
      if (v45)
      {
        long long *v45 = v51;
        if (*((void *)&v51 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v51 + 1) + 8), 1uLL, memory_order_relaxed);
        }
      }
      uint64_t v46 = v45 + 1;
    }
    *(void *)(v50 + 8) = v46;
    if (*((void *)&v51 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v51 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      (*(void (**)(void))(**((void **)&v51 + 1) + 16))(*((void *)&v51 + 1));
      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v51 + 1));
    }
LABEL_43:

    ++v34;
  }
  while (v34 != v53);
  size_t v34 = v52;
LABEL_64:
  if (v34)
  {
    for (uint64_t i = v53; i != v34; --i)
    {
      size_t v48 = *(i - 1);
    }
    (*(void (**)(uint64_t, id *, unint64_t))(*(void *)v55 + 40))(v55, v34, v54 - (void)v34);
  }
  uint64_t v49 = v57;
  if (v57)
  {
    if (!atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
  }
}

void sub_1A1F69D48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a19);

  std::vector<VKLabelNavRoadLabel * {__strong},geo::StdAllocator<VKLabelNavRoadLabel * {__strong},mdm::Allocator>>::~vector[abi:nn180100](&a13);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<VKLabelNavRoadLabel * {__strong},geo::StdAllocator<VKLabelNavRoadLabel * {__strong},mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 8);
        v3 -= 8;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<md::NavLabelMarker>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::NavLabelMarker>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FD10;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::NavLabelMarker>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FD10;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = off_1EF559858;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = off_1EF559858;

  return a1;
}

uint64_t md::Labeler::adoptSelectedLabelMarker()
{
  return 0;
}

void md::MapNavLabeler::setSelectedLabelMarker(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  if (*a2)
  {
    if (*(unsigned char *)(v3 + 224) == 1)
    {
      uint64_t v4 = a2[1];
      if (v4) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v5 = *(std::__shared_weak_count **)(a1 + 120);
      *(void *)(a1 + 112) = v3;
      *(void *)(a1 + 120) = v4;
      if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
        std::__shared_weak_count::__release_weak(v5);
      }
      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 112) + 288));
      [WeakRetained setIsPicked:1];
    }
  }
  else
  {
    uint64_t v6 = *(void *)(a1 + 112);
    if (v6)
    {
      id v9 = objc_loadWeakRetained((id *)(v6 + 288));
      [v9 setIsPicked:0];

      uint64_t v7 = *(std::__shared_weak_count **)(a1 + 120);
      *(void *)(a1 + 112) = 0;
      *(void *)(a1 + 120) = 0;
      if (v7)
      {
        if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
    }
  }
}

void sub_1A1F6A118(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void md::Labeler::labelMarkerForCustomFeatureAnnotation(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

void md::MapNavLabeler::labelMarkerForSelectionAtPixel(void *a1@<X0>, float *a2@<X1>, void *a3@<X8>)
{
  if (((*(uint64_t (**)(void *))(*a1 + 352))(a1) & 1) == 0 && (!a1[13] || !*(void *)(a1[86] + 24))) {
    goto LABEL_26;
  }
  uint64_t v6 = a1[81];
  uint64_t v7 = a1[82];
  if (v6 == v7) {
    goto LABEL_26;
  }
  while (1)
  {
    uint64_t v27 = off_1EF559858;
    uint64_t v28 = 0;
    uint64_t v28 = (std::__shared_weak_count *)*(id *)(v6 + 8);
    uint64_t v8 = v28;
    uint64_t v9 = [(std::__shared_weak_count *)v8 label];

    uint64_t v10 = *(void *)v9;
    if (*(unsigned char *)(*(void *)v9 + 327))
    {
      if (*(unsigned char *)(v10 + 325)
        && *(unsigned char *)(v10 + 326)
        && !*(unsigned char *)(v10 + 264)
        && *(float *)(v10 + 268) >= 1.0
        && *a2 <= *(float *)(v10 + 344)
        && *a2 >= *(float *)(v10 + 336))
      {
        float v11 = a2[1];
        if (v11 <= *(float *)(v10 + 348) && v11 >= *(float *)(v10 + 340)) {
          break;
        }
      }
    }
    uint64_t v27 = off_1EF559858;

    v6 += 24;
    if (v6 == v7) {
      goto LABEL_26;
    }
  }
  id v13 = [(std::__shared_weak_count *)v28 navFeature];
  uint64_t v27 = off_1EF559858;

  if (!v13)
  {
LABEL_26:
    id v13 = 0;
    *a3 = 0;
    a3[1] = 0;
LABEL_27:

    return;
  }
  uint64_t v14 = a1[14];
  if (v14)
  {
    id WeakRetained = objc_loadWeakRetained((id *)(v14 + 288));

    if (v13 == WeakRetained)
    {
      uint64_t v24 = a1[15];
      *a3 = a1[14];
      a3[1] = v24;
      if (v24) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
      }
      goto LABEL_27;
    }
  }
  uint64_t v16 = a1[3];
  uint64_t v17 = *(std::__shared_weak_count **)(v16 + 16);
  uint64_t v27 = *(uint64_t (***)())(v16 + 8);
  if (v17)
  {
    uint64_t v28 = std::__shared_weak_count::lock(v17);
    if (v28)
    {
      float v18 = *(float *)(a1[3] + 176);
      long long v19 = (std::__shared_weak_count *)operator new(0x140uLL);
      v19->__shared_owners_ = 0;
      v19->__shared_weak_owners_ = 0;
      v19->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FD10;
      uint64_t v20 = v19 + 1;
      objc_initWeak(&location, v13);
      md::NavLabelMarker::NavLabelMarker((uint64_t)&v19[1], (uint64_t *)&v27, &location, v18);
      objc_storeWeak(&location, 0);
      objc_destroyWeak(&location);
      *(void *)&long long v21 = v19 + 1;
      *((void *)&v21 + 1) = v19;
      shared_weak_owners = (std::__shared_weak_count *)v19[1].__shared_weak_owners_;
      if (shared_weak_owners)
      {
        if (shared_weak_owners->__shared_owners_ != -1)
        {
LABEL_31:
          *(_OWORD *)a3 = v21;
          unint64_t v23 = v28;
          if (v28)
          {
            if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
              std::__shared_weak_count::__release_weak(v23);
            }
          }
          goto LABEL_27;
        }
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v19[1].__shared_owners_ = (uint64_t)v20;
        v19[1].__shared_weak_owners_ = (uint64_t)v19;
        long long v25 = v21;
        std::__shared_weak_count::__release_weak(shared_weak_owners);
        long long v21 = v25;
      }
      else
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        atomic_fetch_add_explicit(&v19->__shared_weak_owners_, 1uLL, memory_order_relaxed);
        v19[1].__shared_owners_ = (uint64_t)v20;
        v19[1].__shared_weak_owners_ = (uint64_t)v19;
      }
      if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        long long v26 = v21;
        ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
        std::__shared_weak_count::__release_weak(v19);
        long long v21 = v26;
      }
      goto LABEL_31;
    }
  }
  std::__throw_bad_weak_ptr[abi:nn180100]();
  __break(1u);
}

void sub_1A1F6A494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, id location)
{
  objc_storeWeak(&location, 0);
  objc_destroyWeak(&location);
  std::__shared_weak_count::~__shared_weak_count(v15);
  operator delete(v17);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a11);

  _Unwind_Resume(a1);
}

void sub_1A1F6A4DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void md::MapNavLabeler::updateOcclusionQueries(id *this)
{
  if ((*((unsigned int (**)(id *))*this + 44))(this))
  {
    uint64_t v2 = (uint64_t **)[this[7] activeSigns];
    uint64_t v3 = *v2;
    uint64_t v4 = v2[1];
    if (*v2 != v4)
    {
      do
      {
        uint64_t v5 = *v3;
        if (*(unsigned char *)(*v3 + 24) && !*(unsigned char *)(v5 + 26))
        {
          uint64_t v6 = *((void *)this[3] + 45);
          if (!*(void *)(v5 + 8))
          {
            uint64_t v8 = operator new(0x138uLL);
            v8[1] = 0;
            v8[2] = 0;
            *uint64_t v8 = &unk_1EF57FD48;
            double v9 = md::OcclusionQuery::OcclusionQuery((uint64_t)(v8 + 3), 14, 0);
            uint64_t v10 = *(std::__shared_weak_count **)(v5 + 16);
            *(void *)(v5 + 8) = v11;
            *(void *)(v5 + 16) = v8;
            if (v10)
            {
              if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *, double))v10->__on_zero_shared)(v10, v9);
                std::__shared_weak_count::__release_weak(v10);
              }
            }
          }
          unsigned __int8 v7 = atomic_load((unsigned __int8 *)(*(void *)(v5 + 8) + 286));
          if (v7)
          {
            *(unsigned char *)(v5 + 24) = 0;
            *(unsigned char *)(v5 + 26) = 1;
            md::OcclusionTest::setupAntennaeTest(**(void **)(v5 + 8), (void *)(v5 + 208), 0);
            md::OcclusionManager::addQuery(v6, (long long *)(v5 + 8));
          }
        }
        v3 += 2;
      }
      while (v3 != v4);
    }
  }
}

void sub_1A1F6A684(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

float std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<md::AvoidanceRectWithPriority const*>,std::__wrap_iter<md::AvoidanceRectWithPriority const*>>(uint64_t *a1, uint64_t a2, long long *a3, long long *a4, uint64_t a5)
{
  if (a5 < 1) {
    return *(float *)&v17;
  }
  uint64_t v6 = a3;
  uint64_t v8 = *a1;
  unint64_t v9 = a1[1];
  uint64_t v10 = (a2 - *a1) / 24;
  uint64_t v11 = *a1 + 24 * v10;
  uint64_t v12 = a1[2];
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - v9) >> 3)) < a5)
  {
    unint64_t v13 = a5 - 0x5555555555555555 * ((uint64_t)(v9 - v8) >> 3);
    if (v13 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((v12 - v8) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x555555555555555) {
      uint64_t v15 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      uint64_t v15 = v13;
    }
    if (v15) {
      uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 24 * v15, 4);
    }
    else {
      uint64_t v16 = 0;
    }
    uint64_t v21 = v16 + 24 * v10;
    uint64_t v22 = 24 * a5;
    uint64_t v23 = v21 + 24 * a5;
    uint64_t v24 = v21;
    do
    {
      if (v24)
      {
        long long v17 = *v6;
        *(void *)(v24 + 16) = *((void *)v6 + 2);
        *(_OWORD *)uint64_t v24 = v17;
      }
      v24 += 24;
      uint64_t v6 = (long long *)((char *)v6 + 24);
      v22 -= 24;
    }
    while (v22);
    uint64_t v25 = *a1;
    if (*a1 == v11)
    {
      uint64_t v27 = v16 + 24 * v10;
    }
    else
    {
      uint64_t v26 = v11;
      do
      {
        uint64_t v27 = v21 - 24;
        long long v17 = *(_OWORD *)(v26 - 24);
        *(void *)(v21 - 8) = *(void *)(v26 - 8);
        *(_OWORD *)(v21 - 24) = v17;
        v26 -= 24;
        v21 -= 24;
      }
      while (v26 != v25);
    }
    for (uint64_t i = a1[1]; v11 != i; v11 += 24)
    {
      long long v17 = *(_OWORD *)v11;
      *(void *)(v23 + 16) = *(void *)(v11 + 16);
      *(_OWORD *)uint64_t v23 = v17;
      v23 += 24;
    }
    uint64_t v29 = *a1;
    *a1 = v27;
    a1[1] = v23;
    a1[2] = v16 + 24 * v15;
    if (v29)
    {
      size_t v30 = *(void (**)(void))(*(void *)a1[3] + 40);
      v30();
    }
    return *(float *)&v17;
  }
  if ((uint64_t)(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v9 - v11) >> 3)) >= a5)
  {
    float v18 = (long long *)((char *)a3 + 24 * a5);
    uint64_t v20 = a1[1];
LABEL_36:
    uint64_t v31 = v11 + 24 * a5;
    long long v32 = (long long *)(v20 - 24 * a5);
    uint64_t v33 = v20;
    if ((unint64_t)v32 < v9)
    {
      uint64_t v33 = v20;
      do
      {
        if (v33)
        {
          long long v17 = *v32;
          *(void *)(v33 + 16) = *((void *)v32 + 2);
          *(_OWORD *)uint64_t v33 = v17;
        }
        long long v32 = (long long *)((char *)v32 + 24);
        v33 += 24;
      }
      while ((unint64_t)v32 < v9);
    }
    a1[1] = v33;
    if (v20 != v31)
    {
      uint64_t v34 = v20 - 12;
      uint64_t v35 = 8 * ((v20 - v31) >> 3);
      do
      {
        *(_DWORD *)(v34 - 12) = *(_DWORD *)(v11 + v35 - 24);
        *(_DWORD *)(v34 - 8) = *(_DWORD *)(v11 + v35 - 20);
        *(_DWORD *)(v34 - 4) = *(_DWORD *)(v11 + v35 - 16);
        LODWORD(v17) = *(_DWORD *)(v11 + v35 - 12);
        *(_DWORD *)uint64_t v34 = v17;
        int v36 = *(_DWORD *)(v11 + v35 - 8);
        *(unsigned char *)(v34 + 8) = *(unsigned char *)(v11 + v35 - 4);
        *(_DWORD *)(v34 + 4) = v36;
        v34 -= 24;
        v35 -= 24;
      }
      while (v35);
    }
    if (v18 != a3)
    {
      do
      {
        *(_DWORD *)uint64_t v11 = *(_DWORD *)v6;
        *(_DWORD *)(v11 + 4) = *((_DWORD *)v6 + 1);
        *(_DWORD *)(v11 + 8) = *((_DWORD *)v6 + 2);
        LODWORD(v17) = *((_DWORD *)v6 + 3);
        *(_DWORD *)(v11 + 12) = v17;
        int v37 = *((_DWORD *)v6 + 4);
        *(unsigned char *)(v11 + 20) = *((unsigned char *)v6 + 20);
        *(_DWORD *)(v11 + 16) = v37;
        uint64_t v6 = (long long *)((char *)v6 + 24);
        v11 += 24;
      }
      while (v6 != v18);
    }
    return *(float *)&v17;
  }
  float v18 = (long long *)((char *)a3 + 8 * ((uint64_t)(v9 - v11) >> 3));
  if (v18 == a4)
  {
    uint64_t v20 = a1[1];
  }
  else
  {
    long long v19 = (long long *)((char *)a3 + 8 * ((uint64_t)(v9 - v11) >> 3));
    uint64_t v20 = a1[1];
    do
    {
      if (v20)
      {
        long long v17 = *v19;
        *(void *)(v20 + 16) = *((void *)v19 + 2);
        *(_OWORD *)uint64_t v20 = v17;
      }
      long long v19 = (long long *)((char *)v19 + 24);
      v20 += 24;
    }
    while (v19 != a4);
  }
  a1[1] = v20;
  if ((uint64_t)(v9 - v11) >= 1) {
    goto LABEL_36;
  }
  return *(float *)&v17;
}

void std::__function::__func<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_1,std::allocator<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_1>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)int v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LabelsNavLayout", "", v1, 2u);
  }
}

void std::__function::__func<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_1,std::allocator<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56FD08;
}

void *std::__function::__func<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_1,std::allocator<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_1>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF56FD08;
  return result;
}

void std::__function::__func<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_1,std::allocator<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_0,std::allocator<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_0>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)int v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsNavLayout", "", v1, 2u);
  }
}

void std::__function::__func<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_0,std::allocator<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56FCC0;
}

void *std::__function::__func<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_0,std::allocator<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_0>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF56FCC0;
  return result;
}

void std::__function::__func<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_0,std::allocator<md::MapNavLabeler::layoutForDisplay(md::LayoutContext const&)::$_0>,void ()(void)>::~__func()
{
}

uint64_t *std::vector<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = (void (***)(void, void))*a1;
  if (*a1)
  {
    uint64_t v3 = (void (***)(void, void))a1[1];
    uint64_t v4 = (void (***)(void, void))*a1;
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 3;
      uint64_t v6 = v3 - 3;
      unsigned __int8 v7 = v3 - 3;
      do
      {
        uint64_t v8 = *v7;
        v7 -= 3;
        (*v8)(v6, (uint64_t)v4);
        v5 -= 3;
        BOOL v9 = v6 == v2;
        uint64_t v6 = v7;
      }
      while (!v9);
      uint64_t v4 = (void (***)(void, void))*a1;
    }
    a1[1] = (uint64_t)v2;
    (*(void (**)(uint64_t, void (***)(void, void), uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - (void)v4);
  }
  return a1;
}

void md::MapNavLabeler::~MapNavLabeler(md::MapNavLabeler *this)
{
  md::MapNavLabeler::~MapNavLabeler(this);
  JUMPOUT(0x1A6239270);
}

{
  char *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::__shared_weak_count *v13;
  uint64_t v14;
  VKLabelNavArtworkCache *v15;
  md::LabelNavEtaLabeler *v16;
  void (***v17)(void, void);
  void (***v18)(void, void);
  uint64_t v19;
  void (***v20)(void, void);
  void (***v21)(void, void);
  void (***v22)(void, void);
  void (**v23)(void, uint64_t);
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  std::__shared_weak_count *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  std::__shared_weak_count *v31;
  void *v32;
  void *v33;
  std::__shared_weak_count *v34;
  void *v35;
  void *v36;
  void *v37;
  std::__shared_weak_count *v38;
  void *v39;
  std::__shared_weak_count *v40;
  md::RouteAnnotationSupport *v41;
  uint64_t v42;

  *(void *)this = &unk_1EF5324A0;
  *((void *)this + 1) = &unk_1EF5326D8;
  uint64_t v2 = (char *)this + 16;
  *((void *)this + 2) = &unk_1EF5327C0;
  uint64_t v3 = *((void *)this + 3);
  *(void *)(*(void *)(v3 + 168) + 32) = *(void *)(*(void *)(v3 + 168) + 80);
  uint64_t v4 = *(void *)(v3 + 168);
  uint64_t v5 = *(void **)(v4 + 8);
  uint64_t v6 = *(void **)v4;
  if (*(void **)v4 != v5)
  {
    while ((char *)*v6 != v2)
    {
      if (++v6 == v5)
      {
        uint64_t v6 = *(void **)(v4 + 8);
        break;
      }
    }
  }
  unsigned __int8 v7 = v6 + 1;
  uint64_t v8 = v6 == v5 || v7 == v5;
  if (v8)
  {
    if (v6 != v5) {
      goto LABEL_24;
    }
LABEL_11:
    BOOL v9 = *((void *)this + 97);
    if (!v9) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  do
  {
    if ((char *)*v7 != v2) {
      *v6++ = *v7;
    }
    ++v7;
  }
  while (v7 != v5);
  if (v6 == *(void **)(v4 + 8)) {
    goto LABEL_11;
  }
LABEL_24:
  *(void *)(v4 + 8) = v6;
  BOOL v9 = *((void *)this + 97);
  if (v9)
  {
LABEL_12:
    *((void *)this + 98) = v9;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 100) + 40))(*((void *)this + 100), v9, *((void *)this + 99) - v9);
  }
LABEL_13:
  uint64_t v10 = *((void *)this + 92);
  if (v10)
  {
    uint64_t v11 = *((void *)this + 93);
    uint64_t v12 = *((void *)this + 92);
    if (v11 != v10)
    {
      do
      {
        unint64_t v13 = *(std::__shared_weak_count **)(v11 - 32);
        if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v13->__on_zero_shared)(v13, v12);
          std::__shared_weak_count::__release_weak(v13);
        }
        v11 -= 40;
      }
      while (v11 != v10);
      uint64_t v12 = *((void *)this + 92);
    }
    *((void *)this + 93) = v10;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 95) + 40))(*((void *)this + 95), v12, *((void *)this + 94) - v12);
  }
  unint64_t v14 = *((void *)this + 88);
  if (v14)
  {
    *((void *)this + 89) = v14;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 91) + 40))(*((void *)this + 91), v14, *((void *)this + 90) - v14);
  }
  uint64_t v15 = (VKLabelNavArtworkCache *)*((void *)this + 87);
  *((void *)this + 87) = 0;
  if (v15)
  {
    VKLabelNavArtworkCache::~VKLabelNavArtworkCache(v15);
    MEMORY[0x1A6239270]();
  }
  uint64_t v16 = (md::LabelNavEtaLabeler *)*((void *)this + 86);
  *((void *)this + 86) = 0;
  if (v16)
  {
    md::LabelNavEtaLabeler::~LabelNavEtaLabeler(v16);
    MEMORY[0x1A6239270]();
  }
  long long v17 = (void (***)(void, void))*((void *)this + 81);
  if (v17)
  {
    float v18 = (void (***)(void, void))*((void *)this + 82);
    long long v19 = *((void *)this + 81);
    if (v18 != v17)
    {
      uint64_t v20 = v18 - 3;
      uint64_t v21 = v18 - 3;
      uint64_t v22 = v18 - 3;
      do
      {
        uint64_t v23 = *v22;
        v22 -= 3;
        (*v23)(v21, v19);
        v20 -= 3;
        uint64_t v8 = v21 == v17;
        uint64_t v21 = v22;
      }
      while (!v8);
      long long v19 = *((void *)this + 81);
    }
    *((void *)this + 82) = v17;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 84) + 40))(*((void *)this + 84), v19, *((void *)this + 83) - v19);
  }
  uint64_t v24 = *((void *)this + 77);
  if (v24)
  {
    uint64_t v25 = *((void *)this + 78);
    uint64_t v26 = *((void *)this + 77);
    if (v25 != v24)
    {
      do
      {
        uint64_t v27 = *(std::__shared_weak_count **)(v25 - 8);
        if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v27->__on_zero_shared)(v27, v26);
          std::__shared_weak_count::__release_weak(v27);
        }
        v25 -= 16;
      }
      while (v25 != v24);
      uint64_t v26 = *((void *)this + 77);
    }
    *((void *)this + 78) = v24;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 80) + 40))(*((void *)this + 80), v26, *((void *)this + 79) - v26);
  }
  uint64_t v28 = *((void *)this + 73);
  if (v28)
  {
    uint64_t v29 = *((void *)this + 74);
    size_t v30 = *((void *)this + 73);
    if (v29 != v28)
    {
      do
      {
        uint64_t v31 = *(std::__shared_weak_count **)(v29 - 8);
        if (v31 && !atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v31->__on_zero_shared)(v31, v30);
          std::__shared_weak_count::__release_weak(v31);
        }
        v29 -= 16;
      }
      while (v29 != v28);
      size_t v30 = *((void *)this + 73);
    }
    *((void *)this + 74) = v28;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 76) + 40))(*((void *)this + 76), v30, *((void *)this + 75) - v30);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 70));
  long long v32 = (void *)*((void *)this + 66);
  while (v32)
  {
    uint64_t v33 = v32;
    long long v32 = (void *)*v32;
    uint64_t v34 = (std::__shared_weak_count *)v33[6];
    if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
    operator delete(v33);
  }
  uint64_t v35 = (void *)*((void *)this + 64);
  *((void *)this + 64) = 0;
  if (v35) {
    operator delete(v35);
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 42));
  int v36 = (void *)*((void *)this + 38);
  while (v36)
  {
    int v37 = v36;
    int v36 = (void *)*v36;
    uint64_t v38 = (std::__shared_weak_count *)v37[6];
    if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
    operator delete(v37);
  }
  char v39 = (void *)*((void *)this + 36);
  *((void *)this + 36) = 0;
  if (v39) {
    operator delete(v39);
  }
  float v40 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  *((void *)this + 10) = &unk_1EF5595D8;

  uint64_t v41 = (md::RouteAnnotationSupport *)*((void *)this + 9);
  *((void *)this + 9) = 0;
  if (v41)
  {
    md::RouteAnnotationSupport::~RouteAnnotationSupport(v41);
    MEMORY[0x1A6239270]();
  }
  uint64_t v42 = *((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v42) {
    (*(void (**)(uint64_t))(*(void *)v42 + 16))(v42);
  }

  *((void *)this + 4) = &unk_1EF559918;
}

void md::RouteAnnotationSupport::~RouteAnnotationSupport(md::RouteAnnotationSupport *this)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 25);
  if (v2)
  {
    do
    {
      uint64_t v3 = (uint64_t *)*v2;

      (*(void (**)(void, uint64_t *, uint64_t))(**((void **)this + 26) + 40))(*((void *)this + 26), v2, 32);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *((void *)this + 22);
  *((void *)this + 22) = 0;
  if (v4) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 24) + 40))(*((void *)this + 24), v4, 8 * *((void *)this + 23));
  }
  uint64_t v5 = *((void *)this + 18);
  if (v5)
  {
    *((void *)this + 19) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 21) + 40))(*((void *)this + 21), v5, *((void *)this + 20) - v5);
  }
  uint64_t v6 = *((void *)this + 14);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 15);
    uint64_t v8 = *((void *)this + 14);
    if (v7 != v6)
    {
      do
      {
        BOOL v9 = *(std::__shared_weak_count **)(v7 - 8);
        if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v9->__on_zero_shared)(v9, v8);
          std::__shared_weak_count::__release_weak(v9);
        }
        v7 -= 16;
      }
      while (v7 != v6);
      uint64_t v8 = *((void *)this + 14);
    }
    *((void *)this + 15) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 17) + 40))(*((void *)this + 17), v8, *((void *)this + 16) - v8);
  }
  uint64_t v10 = *((void *)this + 10);
  if (v10)
  {
    uint64_t v11 = *((void *)this + 11);
    uint64_t v12 = *((void *)this + 10);
    if (v11 != v10)
    {
      do
      {
        unint64_t v13 = *(void **)(v11 - 8);
        v11 -= 8;
      }
      while (v11 != v10);
      uint64_t v12 = *((void *)this + 10);
    }
    *((void *)this + 11) = v10;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 13) + 40))(*((void *)this + 13), v12, *((void *)this + 12) - v12);
  }
  uint64_t v14 = *((void *)this + 6);
  if (v14)
  {
    uint64_t v15 = *((void *)this + 7);
    uint64_t v16 = *((void *)this + 6);
    if (v15 != v14)
    {
      do
      {
        long long v17 = *(void **)(v15 - 8);
        v15 -= 8;
      }
      while (v15 != v14);
      uint64_t v16 = *((void *)this + 6);
    }
    *((void *)this + 7) = v14;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), v16, *((void *)this + 8) - v16);
  }
  float v18 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  *((void *)this + 1) = &unk_1EF559E78;
}

void geo::_retain_ptr<LabelNavRouteLabeler * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559918;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<LabelNavRouteLabeler * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559918;

  return a1;
}

uint64_t md::MuninRoadFeature::MuninRoadFeature(uint64_t a1, uint64_t *a2, int a3)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  if (a2)
  {
    *(void *)a1 = a2;
    uint64_t v6 = (std::__shared_weak_count *)a2[1];
    if (v6 && (uint64_t v6 = std::__shared_weak_count::lock(v6)) != 0) {
      uint64_t v7 = *a2;
    }
    else {
      uint64_t v7 = 0;
    }
    uint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v6;
    if (v8)
    {
      if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
  }
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  {
    operator new();
  }
  uint64_t v9 = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = v9;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  {
    operator new();
  }
  *(void *)(a1 + 80) = mdm::Allocator::instance(void)::alloc;
  {
    operator new();
  }
  uint64_t v10 = mdm::Allocator::instance(void)::alloc;
  __n128 v21 = 0uLL;
  uint64_t v22 = 0;
  {
    operator new();
  }
  uint64_t v23 = mdm::Allocator::instance(void)::alloc;
  v11.n128_f64[0] = md::LabelFeature::textFromFeature((unint64_t)&v15, *(uint64_t **)a1, a3, (uint64_t)&v21, 0);
  uint64_t v12 = v15;
  unint64_t v13 = v16;
  if ((v16 & 0x8000000000000000) != 0)
  {
    if (!*((void *)&v15 + 1)) {
      goto LABEL_26;
    }
    uint64_t v17 = v10;
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)&v15, (void *)v15, *((unint64_t *)&v15 + 1));
  }
  else
  {
    if (!HIBYTE(v16)) {
      goto LABEL_26;
    }
    uint64_t v17 = v10;
  }
  uint64_t v20 = v23;
  if (SHIBYTE(v22) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external(&v18, (void *)v21.n128_u64[0], v21.n128_u64[1]);
  }
  else
  {
    __n128 v18 = v21;
    uint64_t v19 = v22;
  }
  if (*(char *)(a1 + 47) < 0) {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), *(void *)(a1 + 24), *(void *)(a1 + 40) & 0x7FFFFFFFFFFFFFFFLL);
  }
  *(_OWORD *)(a1 + 24) = v15;
  *(void *)(a1 + 40) = v16;
  HIBYTE(v16) = 0;
  LOBYTE(v15) = 0;
  if (*(char *)(a1 + 79) < 0) {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 80) + 40))(*(void *)(a1 + 80), *(void *)(a1 + 56), *(void *)(a1 + 72) & 0x7FFFFFFFFFFFFFFFLL);
  }
  __n128 v11 = v18;
  *(__n128 *)(a1 + 56) = v18;
  *(void *)(a1 + 72) = v19;
LABEL_26:
  if (SHIBYTE(v22) < 0)
  {
    (*(void (**)(uint64_t, unint64_t, uint64_t, __n128))(*(void *)v23 + 40))(v23, v21.n128_u64[0], v22 & 0x7FFFFFFFFFFFFFFFLL, v11);
    if ((v13 & 0x8000000000000000) == 0) {
      return a1;
    }
LABEL_30:
    (*(void (**)(uint64_t, uint64_t, unint64_t, __n128))(*(void *)v10 + 40))(v10, v12, v13 & 0x7FFFFFFFFFFFFFFFLL, v11);
    return a1;
  }
  if ((v13 & 0x8000000000000000) != 0) {
    goto LABEL_30;
  }
  return a1;
}

void sub_1A1F6BB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  if (SHIBYTE(a11) < 0)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
    if (SHIBYTE(a19) < 0)
    {
LABEL_5:
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a20 + 40))(a20, a17, a19 & 0x7FFFFFFFFFFFFFFFLL);
      if ((v23 & 0x8000000000000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_11;
    }
  }
  else if (SHIBYTE(a19) < 0)
  {
    goto LABEL_5;
  }
  if ((v23 & 0x8000000000000000) == 0)
  {
LABEL_6:
    if (*(char *)(v20 + 79) < 0) {
      goto LABEL_7;
    }
    goto LABEL_12;
  }
LABEL_11:
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v21 + 40))(v21, v22, v23 & 0x7FFFFFFFFFFFFFFFLL);
  if (*(char *)(v20 + 79) < 0)
  {
LABEL_7:
    (*(void (**)(void, void, uint64_t))(**(void **)(v20 + 80) + 40))(*(void *)(v20 + 80), *(void *)(v20 + 56), *(void *)(v20 + 72) & 0x7FFFFFFFFFFFFFFFLL);
    if ((*(char *)(v20 + 47) & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_13;
  }
LABEL_12:
  if ((*(char *)(v20 + 47) & 0x80000000) == 0)
  {
LABEL_8:
    uint64_t v25 = *(std::__shared_weak_count **)(v20 + 16);
    if (!v25) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
LABEL_13:
  (*(void (**)(void, void, uint64_t))(**(void **)(v20 + 48) + 40))(*(void *)(v20 + 48), *(void *)(v20 + 24), *(void *)(v20 + 40) & 0x7FFFFFFFFFFFFFFFLL);
  uint64_t v25 = *(std::__shared_weak_count **)(v20 + 16);
  if (!v25) {
    goto LABEL_16;
  }
LABEL_14:
  if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
LABEL_16:
  _Unwind_Resume(a1);
}

void sub_1A1F6BF38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1F6C140(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (SHIBYTE(a11) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A1F6C250(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (SHIBYTE(a11) < 0) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a12 + 40))(a12, a9, a11 & 0x7FFFFFFFFFFFFFFFLL);
  }
  _Unwind_Resume(exception_object);
}

void sub_1A1F6C598(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  unint64_t v13 = v12;
  std::__shared_weak_count::~__shared_weak_count(v13);
  operator delete(v15);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a9);

  _Unwind_Resume(a1);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::EarthCorona::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::EarthCorona::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::EarthCorona::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::EarthCorona::BaseMesh::~BaseMesh(ggl::EarthCorona::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::EarthCorona::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::EarthCorona::BaseMesh *)((char *)this - 16));
}

void ggl::EarthCorona::BaseMesh::~BaseMesh(ggl::EarthCorona::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::EarthCorona::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::EarthCorona::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void ggl::EarthCorona::BasePipelineState::~BasePipelineState(ggl::EarthCorona::BasePipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::EarthCorona::BasePipelineState::BasePipelineState(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4)
{
  {
    uint64_t v10 = a4;
    uint64_t v12 = a2;
    uint64_t v13 = a3;
    a2 = v12;
    a3 = v13;
    a4 = v10;
    if (v11)
    {
      {
        if (v11)
        {
          {
            {
              ggl::MeshTyped<ggl::EarthCorona::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::EarthCorona::defaultVboReflection;
            }
            ggl::MeshTyped<ggl::EarthCorona::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::EarthCorona::DefaultVbo>::attributesReflection(void)::r;
            *(void *)algn_1E957D530 = 1;
          }
          ggl::EarthCorona::BasePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::EarthCorona::DefaultVbo>::typedReflection(void)::r;
          *(void *)algn_1E958F618 = &ggl::EarthCorona::pipelineDataBasePipelineDeviceStructs(void)::ref;
          qword_1E958F620 = 0;
          {
            ggl::EarthCorona::pipelineDataBasePipelineConstantStructs(void)::ref = (uint64_t)ggl::EarthCorona::Base::reflection(void)::reflection;
          }
          qword_1E958F628 = (uint64_t)&ggl::EarthCorona::pipelineDataBasePipelineConstantStructs(void)::ref;
          *(int64x2_t *)algn_1E958F630 = vdupq_n_s64(1uLL);
        }
      }
      ggl::EarthCorona::BasePipelineState::typedReflection(void)::ref = (uint64_t)&ggl::EarthCorona::BasePipelineSetup::typedReflection(void)::ref;
      ggl::EarthCoronaShader::typedReflection(v11);
      qword_1E958F5C0 = (uint64_t)&ggl::EarthCoronaShader::typedReflection(void)::ref;
      {
        ggl::EarthCorona::pipelineStateBasePipelineAttributeStructBinding(void)::attr = 0;
        unk_1E958F650 = 0;
        qword_1E958F658 = (uint64_t)"";
        dword_1E958F660 = 0;
        qword_1E958F668 = (uint64_t)&ggl::EarthCorona::pipelineStateBasePipelineAttributeBinding_0(void)::attr;
        unk_1E958F670 = 1;
      }
      qword_1E958F5C8 = (uint64_t)&ggl::EarthCorona::pipelineStateBasePipelineAttributeStructBinding(void)::attr;
      unk_1E958F5D0 = 1;
      qword_1E958F5D8 = 0;
      unk_1E958F5E0 = 1;
      qword_1E958F5E8 = (uint64_t)&ggl::EarthCorona::pipelineStateBasePipelineDeviceStructBinding(void)::ref;
      unk_1E958F5F0 = 0;
      {
        ggl::EarthCorona::pipelineStateBasePipelineConstantStructBinding(void)::ref = 0;
        unk_1E958F690 = 0;
        qword_1E958F698 = (uint64_t)"base";
        dword_1E958F6A0 = 3;
        qword_1E958F6A8 = (uint64_t)&ggl::EarthCorona::pipelineStateBasePipelineConstantBaseBinding(void)::reflection;
        unk_1E958F6B0 = 7;
      }
      qword_1E958F5F8 = (uint64_t)&ggl::EarthCorona::pipelineStateBasePipelineConstantStructBinding(void)::ref;
      unk_1E958F600 = 1;
      a4 = v10;
      a2 = v12;
      a3 = v13;
    }
  }
  uint64_t v5 = *a2;
  uint64_t v6 = (std::__shared_weak_count *)a2[1];
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)unint64_t v16 = *(_OWORD *)a3;
  *(_OWORD *)&v16[12] = *(_OWORD *)(a3 + 12);
  long long v7 = *(_OWORD *)(a3 + 28);
  char v8 = *(unsigned char *)(a3 + 44);
  long long v14 = *a4;
  long long v15 = a4[1];
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_1EF55B208;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 40) = &ggl::EarthCorona::BasePipelineState::typedReflection(void)::ref;
  *(void *)(a1 + 48) = v5;
  *(void *)(a1 + 56) = v6;
  if (v6) {
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 116) = xmmword_1A28FC970;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 164) = xmmword_1A28FC970;
  *(void *)(a1 + 180) = 0;
  *(void *)(a1 + 196) = 0;
  *(void *)(a1 + 188) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 212) = xmmword_1A28FC970;
  *(void *)(a1 + 228) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 236) = 0;
  *(_OWORD *)(a1 + 256) = v14;
  *(_OWORD *)(a1 + 272) = v15;
  *(unsigned char *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0x100000001;
  *(unsigned char *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v16;
  *(_OWORD *)(a1 + 76) = *(_OWORD *)&v16[12];
  *(_OWORD *)(a1 + 92) = v7;
  *(unsigned char *)(a1 + 108) = v8;
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  *(void *)a1 = &unk_1EF55A658;
  return a1;
}

BOOL ggl::EarthCorona::BasePipelineSetup::textureIsEnabled(ggl::EarthCorona::BasePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::EarthCorona::BasePipelineSetup::constantDataIsEnabled(ggl::EarthCorona::BasePipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::EarthCorona::BasePipelineSetup::~BasePipelineSetup(ggl::EarthCorona::BasePipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void altitude::GEOTileDataPrivate::~GEOTileDataPrivate(altitude::GEOTileDataPrivate *this)
{
  altitude::GEOTileDataPrivate::~GEOTileDataPrivate(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;

  *(void *)this = &unk_1EF569EF0;
  uint64_t v2 = (void *)*((void *)this + 5);
  if (v2)
  {
    *((void *)this + 5) = 0;
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v4) {
      goto LABEL_9;
    }
  }
  else
  {
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 11);
    if (!v4) {
      goto LABEL_9;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_9:
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 9);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 7);
    if (!v6) {
      return;
    }
  }
  else
  {
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 7);
    if (!v6) {
      return;
    }
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

unint64_t altitude::GEOTileDataPrivate::altitudeTileKey(altitude::GEOTileDataPrivate *this)
{
  return *((unsigned int *)this + 8) | ((unint64_t)*((unsigned int *)this + 7) << 32);
}

_DWORD *altitude::GEOTileDataPrivate::geoTileKey@<X0>(_DWORD *this@<X0>, uint64_t a2@<X8>)
{
  int v2 = this[6];
  int v3 = this[8];
  int v4 = (1 << v2) + ~this[7];
  *(unsigned char *)a2 = -1;
  *(unsigned char *)(a2 + 1) = v2;
  *(_DWORD *)(a2 + 4) = v4;
  *(_DWORD *)(a2 + 8) = v3;
  return this;
}

uint64_t altitude::GEOTileDataPrivate::vectorTile(altitude::GEOTileDataPrivate *this)
{
  return *((void *)this + 5);
}

double VKPointForVKLocationCoordinate2D(double a1, double a2)
{
  long double v3 = tan(a1 * 0.00872664626 + 0.785398163);
  log(v3);
  return a2 * 0.00277777778 + 0.5;
}

long double VKLocationCoordinate2DForVKPoint(double a1, double a2)
{
  if (a2 > 1.0)
  {
    double v2 = floor(a2);
LABEL_5:
    a2 = a2 - v2;
    goto LABEL_6;
  }
  if (a2 < 0.0)
  {
    double v2 = ceil(a2);
    a2 = a2 + 1.0;
    goto LABEL_5;
  }
LABEL_6:
  long double v3 = exp(a2 * -6.28318531 + 3.14159265);
  return atan(v3) * -114.591559 + 90.0;
}

double VKWorldBoundsFromGEOTileKey(uint64_t a1, unint64_t a2)
{
  *(void *)&long long v3 = a1;
  BYTE8(v3) = a2;
  return 1.0
       / (double)(1 << SBYTE6(a1))
       * (double)(((*(void *)((char *)&v3 + 1) >> 46) | ((a2 >> 8) << 18)) & 0x3FFFFFF);
}

uint64_t VKPointInPolygon(float *a1, unint64_t a2, double a3, double a4)
{
  if (a2 < 2) {
    return 0;
  }
  uint64_t v5 = 0;
  unsigned int v6 = 0;
  double v7 = a1[1];
  if (v7 <= a4) {
    int v8 = 3;
  }
  else {
    int v8 = 0;
  }
  if (v7 > a4) {
    int v9 = 1;
  }
  else {
    int v9 = 2;
  }
  if (*a1 > a3) {
    int v9 = v8;
  }
  uint64_t v10 = a1;
  do
  {
    int v12 = v9;
    if (a2 - 1 == v5) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = v5 + 1;
    }
    long long v14 = &a1[2 * v13];
    float v15 = v14[1];
    double v16 = *v14;
    if (v15 <= a4) {
      int v9 = 3;
    }
    else {
      int v9 = 0;
    }
    if (v15 > a4) {
      int v17 = 1;
    }
    else {
      int v17 = 2;
    }
    if (v16 <= a3) {
      int v9 = v17;
    }
    int v11 = v9 - v12;
    switch(v9 - v12)
    {
      case -3:
        int v11 = 1;
        break;
      case -2:
      case 2:
        if (v16 + (a4 - v15) * (float)((float)(*v10 - *v14) / (float)(v10[1] - v15)) > a3) {
          int v11 = v12 - v9;
        }
        break;
      case 3:
        int v11 = -1;
        break;
      default:
        break;
    }
    v6 += v11;
    ++v5;
    uint64_t v10 = v14;
  }
  while (a2 != v5);
  return (v6 >> 2) & 1;
}

void *std::function<void ()(md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &)>::~function(void *a1)
{
  double v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::ita::PrepareStyleConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &>)::$_0,std::allocator<md::ita::PrepareStyleConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &)>::operator()(uint64_t a1, double a2, double a3, double _D2, uint64_t a5, double **a6, unint64_t *a7)
{
  int v8 = *a6;
  int v9 = **(void ***)(a1 + 8);
  unint64_t v10 = *a7;
  unint64_t v11 = *a7;
  uint64_t v12 = v9[195];
  if (v11 < (v9[196] - v12) >> 3
    && ((uint64_t v13 = *(void *)(v12 + 8 * v11)) != 0 ? (_ZF = HIDWORD(v10) == HIDWORD(v13)) : (_ZF = 0), _ZF))
  {
    uint64_t v16 = v9[198] + 20 * v13;
    uint64_t v15 = v9[199];
  }
  else
  {
    uint64_t v15 = v9[199];
    uint64_t v16 = v15;
  }
  if (v16 == v15) {
    int v17 = 0;
  }
  else {
    int v17 = (float *)v16;
  }
  if (v17)
  {
    __n128 v18 = std::__hash_table<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,md::Counter>,std::hash<geo::handle<md::CachedKey<md::StyleCacheKey>>>,std::equal_to<geo::handle<md::CachedKey<md::StyleCacheKey>>>,true>,std::__unordered_map_equal<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,md::Counter>,std::equal_to<geo::handle<md::CachedKey<md::StyleCacheKey>>>,std::hash<geo::handle<md::CachedKey<md::StyleCacheKey>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::CachedKey<md::StyleCacheKey>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::CachedKey<md::StyleCacheKey>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::CachedKey<md::StyleCacheKey>> const&>,std::tuple<>>((uint64_t)(v9 + 182), v10, a7);
    ++v18[3];
  }
  if (*(unsigned char *)v17)
  {
    uint64_t v19 = *(void *)(a1 + 16);
LABEL_19:
    LODWORD(_D2) = *(_DWORD *)v19;
    _H8 = *(_WORD *)(v19 + 4);
    goto LABEL_20;
  }
  if (!**(unsigned char **)(a1 + 32) || !v8 || !**(unsigned char **)(a1 + 40))
  {
    uint64_t v19 = *(void *)(a1 + 48);
    goto LABEL_19;
  }
  double v20 = v8[3];
  double v21 = v8[4];
  double v22 = v8[5];
  double v23 = v8[6];
  double v24 = v21 + v21;
  double v25 = (v21 + v21) * v21;
  double v26 = (v22 + v22) * v22;
  double v27 = v20 + v20;
  double v28 = (v20 + v20) * v21;
  double v29 = (v22 + v22) * v23;
  double v30 = v22 * (v20 + v20);
  double v31 = 1.0 - (v20 + v20) * v20;
  double v32 = v24 * v22;
  v226[0] = 1.0 - (v25 + v26);
  v226[1] = v29 + v28;
  v226[4] = v28 - v29;
  v226[5] = v31 - v26;
  v226[8] = v23 * v24 + v30;
  v226[9] = v32 - v23 * v27;
  v226[2] = v30 - v23 * v24;
  v226[6] = v23 * v27 + v32;
  v226[10] = v31 - v25;
  v226[3] = 0.0;
  v226[7] = 0.0;
  memset(&v226[11], 0, 32);
  v226[15] = 1.0;
  gm::Matrix<double,4,4>::inverted<int,void>(v227.f64, v226);
  uint64_t v33 = *(__int16 **)(a1 + 48);
  _H0 = *v33;
  __asm { FCVT            D0, H0 }
  _H1 = v33[1];
  __asm { FCVT            D1, H1 }
  _H2 = v33[2];
  __asm { FCVT            D2, H2 }
  _H3 = v33[3];
  __asm { FCVT            D3, H3 }
  _Q4 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v227, _D0), v229, _D1), v231, _D2), v233, _D3);
  _D0 = v228 * _D0 + v230 * _D1 + v232 * _D2 + v234 * _D3;
  _D1 = _Q4.f64[1];
  __asm
  {
    FCVT            H1, D1
    FCVT            H2, D4
  }
  WORD1(_D2) = LOWORD(_D1);
  __asm { FCVT            H8, D0 }
LABEL_20:
  _S9 = **(_DWORD **)(a1 + 24);
  __asm { FCVT            S0, H8 }
  int v225 = LODWORD(_D2);
  *(void *)(v17 + 1) = vcvtq_f32_f16(*(float16x4_t *)&_D2).u64[0];
  *((_DWORD *)v17 + 3) = _S0;
  *((_DWORD *)v17 + 4) = _S9;
  uint64_t v50 = **(void **)(a1 + 8);
  long long v51 = (void **)(v50 + 1376);
  uint64_t v52 = std::__hash_table<std::__hash_value_type<md::StyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,std::__unordered_map_hasher<md::StyleCacheKey,std::__hash_value_type<md::StyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,md::StyleCacheKeyHasher,std::equal_to<md::StyleCacheKey>,true>,std::__unordered_map_equal<md::StyleCacheKey,std::__hash_value_type<md::StyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,std::equal_to<md::StyleCacheKey>,md::StyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::StyleCacheKey,geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>>>::find<md::StyleCacheKey>((void *)(v50 + 1376), v17);
  if (v52)
  {
    unint64_t v53 = *((void *)v52 + 5);
    if (v53)
    {
      v227.f64[0] = *((float64_t *)v52 + 5);
      uint64_t v54 = *(void *)(v50 + 1264);
      if (v53 < (unint64_t)((*(void *)(v50 + 1272) - v54) >> 3))
      {
        uint64_t v55 = *(void *)(v54 + 8 * v53);
        if (v55 && HIDWORD(v53) == HIDWORD(v55))
        {
          uint64_t v57 = *(void *)(v50 + 1288);
          long long v58 = (void *)(v57 + 24 * v55);
          if (v58 != *(void **)(v50 + 1296) && v57 != 0)
          {
            double v60 = std::__hash_table<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,md::Counter>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,true>,std::__unordered_map_equal<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,md::Counter>,std::equal_to<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,std::hash<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::ConstantDataResource<ggl::DaVinci::Style>> const&>,std::tuple<>>(v50 + 1160, v53, &v227);
            ++v60[3];
            double v61 = (void *)*v58;
            if (v61)
            {
              unint64_t v222 = v61[1];
              uint64_t v223 = v61[9];
              __asm { FCVT            H0, S9 }
              *(_DWORD *)uint64_t v223 = v225;
              *(_WORD *)(v223 + 4) = _H8;
              *(_WORD *)(v223 + 6) = _H0;
              if (v61[8] > v222) {
                unint64_t v222 = v61[8];
              }
              v61[7] = 0;
              v61[8] = v222;
            }
          }
        }
      }
      return;
    }
  }
  float64x2_t v227 = 0uLL;
  double v228 = 0.0;
  uint64_t v62 = *(void *)(v50 + 1248);
  if (*(void *)(v50 + 1240) == v62)
  {
    uint64_t v65 = (-1431655765 * ((*(void *)(v50 + 1296) - *(void *)(v50 + 1288)) >> 3)) | 0x100000000;
    uint64_t v66 = *(uint64_t **)(v50 + 1272);
    unint64_t v67 = *(void *)(v50 + 1280);
    if ((unint64_t)v66 >= v67)
    {
      double v69 = *(char **)(v50 + 1264);
      uint64_t v70 = ((char *)v66 - v69) >> 3;
      unint64_t v71 = v70 + 1;
      if ((unint64_t)(v70 + 1) >> 61) {
        goto LABEL_371;
      }
      uint64_t v72 = v67 - (void)v69;
      if (v72 >> 2 > v71) {
        unint64_t v71 = v72 >> 2;
      }
      if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v73 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v73 = v71;
      }
      if (v73)
      {
        if (v73 >> 61) {
          goto LABEL_370;
        }
        unint64_t v74 = (char *)operator new(8 * v73);
      }
      else
      {
        unint64_t v74 = 0;
      }
      int v75 = (uint64_t *)&v74[8 * v70];
      long long v76 = &v74[8 * v73];
      uint64_t *v75 = v65;
      uint64_t v68 = v75 + 1;
      if (v66 != (uint64_t *)v69)
      {
        unint64_t v77 = (char *)v66 - v69 - 8;
        if (v77 < 0x58) {
          goto LABEL_374;
        }
        if ((unint64_t)(v69 - v74) < 0x20) {
          goto LABEL_374;
        }
        uint64_t v78 = (v77 >> 3) + 1;
        double v79 = &v74[8 * v70 - 16];
        double v80 = v66 - 2;
        uint64_t v81 = v78 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v82 = *(_OWORD *)v80;
          *((_OWORD *)v79 - 1) = *((_OWORD *)v80 - 1);
          *(_OWORD *)double v79 = v82;
          v79 -= 32;
          v80 -= 4;
          v81 -= 4;
        }
        while (v81);
        v75 -= v78 & 0x3FFFFFFFFFFFFFFCLL;
        v66 -= v78 & 0x3FFFFFFFFFFFFFFCLL;
        if (v78 != (v78 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_374:
          do
          {
            uint64_t v83 = *--v66;
            *--int v75 = v83;
          }
          while (v66 != (uint64_t *)v69);
        }
        uint64_t v66 = *(uint64_t **)(v50 + 1264);
      }
      *(void *)(v50 + 1264) = v75;
      *(void *)(v50 + 1272) = v68;
      *(void *)(v50 + 1280) = v76;
      if (v66) {
        operator delete(v66);
      }
    }
    else
    {
      uint64_t *v66 = v65;
      uint64_t v68 = v66 + 1;
    }
    *(void *)(v50 + 1272) = v68;
    unint64_t v64 = *(v68 - 1);
  }
  else
  {
    uint64_t v63 = *(void *)(v62 - 8);
    *(void *)(v50 + 1248) = v62 - 8;
    *(_DWORD *)(*(void *)(v50 + 1264) + 8 * v63) = -1431655765
                                                   * ((*(void *)(v50 + 1296) - *(void *)(v50 + 1288)) >> 3);
    *(_DWORD *)(*(void *)(v50 + 1264) + 8 * v63 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(v50 + 1264)
                                                                                             + 8 * v63
                                                                                             + 4) << 32)
                                                        + 0x100000000) >> 32;
    unint64_t v64 = v63 | ((unint64_t)*(unsigned int *)(*(void *)(v50 + 1264) + 8 * v63 + 4) << 32);
  }
  uint64_t v84 = *(float64x2_t **)(v50 + 1296);
  unint64_t v85 = *(void *)(v50 + 1304);
  if ((unint64_t)v84 >= v85)
  {
    int v88 = *(float64x2_t **)(v50 + 1288);
    unint64_t v89 = 0xAAAAAAAAAAAAAAABLL * (((char *)v84 - (char *)v88) >> 3) + 1;
    if (v89 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_371;
    }
    unint64_t v90 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v85 - (void)v88) >> 3);
    if (2 * v90 > v89) {
      unint64_t v89 = 2 * v90;
    }
    if (v90 >= 0x555555555555555) {
      unint64_t v91 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v91 = v89;
    }
    if (v91 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_370;
    }
    double v92 = (char *)operator new(24 * v91);
    __double2 v93 = (float64x2_t *)&v92[8 * (((char *)v84 - (char *)v88) >> 3)];
    *__double2 v93 = v227;
    double v94 = v228;
    v93[1].f64[0] = v228;
    if (v94 != 0.0)
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v94 + 8), 1uLL, memory_order_relaxed);
      uint64_t v84 = *(float64x2_t **)(v50 + 1296);
      int v88 = *(float64x2_t **)(v50 + 1288);
    }
    uint64_t v95 = &v92[24 * v91];
    unint64_t v87 = (char *)&v93[1].f64[1];
    if (v84 == v88)
    {
      *(void *)(v50 + 1288) = v93;
      *(void *)(v50 + 1296) = v87;
      *(void *)(v50 + 1304) = v95;
    }
    else
    {
      do
      {
        float64x2_t v96 = *(float64x2_t *)((char *)v84 - 24);
        uint64_t v84 = (float64x2_t *)((char *)v84 - 24);
        *(float64x2_t *)((char *)v93 - 24) = v96;
        __double2 v93 = (float64x2_t *)((char *)v93 - 24);
        v93[1].f64[0] = v84[1].f64[0];
        v84->f64[1] = 0.0;
        v84[1].f64[0] = 0.0;
      }
      while (v84 != v88);
      int v88 = *(float64x2_t **)(v50 + 1288);
      uint64_t v97 = *(float64x2_t **)(v50 + 1296);
      *(void *)(v50 + 1288) = v93;
      *(void *)(v50 + 1296) = v87;
      for (*(void *)(v50 + 1304) = v95; v97 != v88; uint64_t v97 = (float64x2_t *)((char *)v97 - 24))
      {
        double v98 = *(std::__shared_weak_count **)&v97[-1].f64[1];
        if (v98 && !atomic_fetch_add(&v98->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v98->__on_zero_shared)(v98);
          std::__shared_weak_count::__release_weak(v98);
        }
      }
    }
    if (v88) {
      operator delete(v88);
    }
  }
  else
  {
    *uint64_t v84 = v227;
    double v86 = v228;
    v84[1].f64[0] = v228;
    if (v86 != 0.0) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v86 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v87 = (char *)&v84[1].f64[1];
  }
  *(void *)(v50 + 1296) = v87;
  unint64_t v99 = *(void *)(v50 + 1320);
  unint64_t v100 = *(void *)(v50 + 1328);
  if (v99 < v100)
  {
    *(void *)unint64_t v99 = v64;
    v99 += 8;
    unint64_t v101 = v99;
    goto LABEL_105;
  }
  long double v102 = *(unsigned char **)(v50 + 1312);
  uint64_t v103 = (uint64_t)(v99 - (void)v102) >> 3;
  unint64_t v104 = v103 + 1;
  if ((unint64_t)(v103 + 1) >> 61) {
LABEL_371:
  }
    abort();
  uint64_t v105 = v100 - (void)v102;
  if (v105 >> 2 > v104) {
    unint64_t v104 = v105 >> 2;
  }
  if ((unint64_t)v105 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v106 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v106 = v104;
  }
  if (v106)
  {
    if (v106 >> 61) {
      goto LABEL_370;
    }
    uint64_t v107 = operator new(8 * v106);
  }
  else
  {
    uint64_t v107 = 0;
  }
  int v108 = &v107[8 * v103];
  v109 = &v107[8 * v106];
  *int v108 = v64;
  unint64_t v101 = (unint64_t)(v108 + 1);
  if ((unsigned char *)v99 != v102)
  {
    unint64_t v110 = v99 - (void)v102 - 8;
    if (v110 < 0x58) {
      goto LABEL_375;
    }
    if ((unint64_t)(v102 - v107) < 0x20) {
      goto LABEL_375;
    }
    uint64_t v111 = (v110 >> 3) + 1;
    float32x2_t v112 = &v107[8 * v103 - 16];
    int v113 = (long long *)(v99 - 16);
    uint64_t v114 = v111 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v115 = *v113;
      *(v112 - 1) = *(v113 - 1);
      *float32x2_t v112 = v115;
      v112 -= 2;
      v113 -= 2;
      v114 -= 4;
    }
    while (v114);
    v108 -= v111 & 0x3FFFFFFFFFFFFFFCLL;
    v99 -= 8 * (v111 & 0x3FFFFFFFFFFFFFFCLL);
    if (v111 != (v111 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_375:
      do
      {
        uint64_t v116 = *(void *)(v99 - 8);
        v99 -= 8;
        *--int v108 = v116;
      }
      while ((unsigned char *)v99 != v102);
    }
  }
  *(void *)(v50 + 1312) = v108;
  *(void *)(v50 + 1320) = v101;
  *(void *)(v50 + 1328) = v109;
  if (v102) {
    operator delete(v102);
  }
LABEL_105:
  uint64_t v117 = (uint64_t *)(v50 + 1160);
  *(void *)(v50 + 1320) = v101;
  unint64_t v118 = *(void *)(v50 + 1168);
  if (v118)
  {
    uint8x8_t v119 = (uint8x8_t)vcnt_s8((int8x8_t)v118);
    v119.i16[0] = vaddlv_u8(v119);
    if (v119.u32[0] > 1uLL)
    {
      unint64_t v101 = v64;
      if (v64 >= v118) {
        unint64_t v101 = v64 % v118;
      }
    }
    else
    {
      unint64_t v101 = (v118 - 1) & v64;
    }
    uint64_t v120 = *(void **)(*v117 + 8 * v101);
    if (v120)
    {
      long long v121 = (void *)*v120;
      if (v121)
      {
        if (v119.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v123 = v121[1];
            if (v123 == v64)
            {
              if (v121[2] == v64) {
                goto LABEL_164;
              }
            }
            else if ((v123 & (v118 - 1)) != v101)
            {
              goto LABEL_126;
            }
            long long v121 = (void *)*v121;
            if (!v121) {
              goto LABEL_126;
            }
          }
        }
        do
        {
          unint64_t v122 = v121[1];
          if (v122 == v64)
          {
            if (v121[2] == v64) {
              goto LABEL_164;
            }
          }
          else
          {
            if (v122 >= v118) {
              v122 %= v118;
            }
            if (v122 != v101) {
              break;
            }
          }
          long long v121 = (void *)*v121;
        }
        while (v121);
      }
    }
  }
LABEL_126:
  unint64_t v99 = (unint64_t)operator new(0x30uLL);
  *(void *)unint64_t v99 = 0;
  *(void *)(v99 + 8) = v64;
  *(void *)(v99 + 16) = v64;
  *(_OWORD *)(v99 + 24) = xmmword_1A28FCC60;
  *(unsigned char *)(v99 + 40) = 0;
  float v124 = (float)(unint64_t)(*(void *)(v50 + 1184) + 1);
  float v125 = *(float *)(v50 + 1192);
  if (!v118 || (float)(v125 * (float)v118) < v124)
  {
    BOOL v126 = 1;
    if (v118 >= 3) {
      BOOL v126 = (v118 & (v118 - 1)) != 0;
    }
    unint64_t v127 = v126 | (2 * v118);
    unint64_t v128 = vcvtps_u32_f32(v124 / v125);
    if (v127 <= v128) {
      size_t prime = v128;
    }
    else {
      size_t prime = v127;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v118 = *(void *)(v50 + 1168);
    }
    if (prime > v118) {
      goto LABEL_138;
    }
    if (prime < v118)
    {
      unint64_t v130 = vcvtps_u32_f32((float)*(unint64_t *)(v50 + 1184) / *(float *)(v50 + 1192));
      if (v118 < 3 || (uint8x8_t v131 = (uint8x8_t)vcnt_s8((int8x8_t)v118), v131.i16[0] = vaddlv_u8(v131), v131.u32[0] > 1uLL))
      {
        unint64_t v130 = std::__next_prime(v130);
      }
      else
      {
        uint64_t v132 = 1 << -(char)__clz(v130 - 1);
        if (v130 >= 2) {
          unint64_t v130 = v132;
        }
      }
      if (prime <= v130) {
        size_t prime = v130;
      }
      if (prime < v118) {
LABEL_138:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v50 + 1160, prime);
    }
    unint64_t v118 = *(void *)(v50 + 1168);
    if ((v118 & (v118 - 1)) != 0)
    {
      if (v64 >= v118) {
        unint64_t v101 = v64 % v118;
      }
      else {
        unint64_t v101 = v64;
      }
    }
    else
    {
      unint64_t v101 = (v118 - 1) & v64;
    }
  }
  uint64_t v133 = *v117;
  uint64_t v134 = *(unint64_t **)(*v117 + 8 * v101);
  if (v134)
  {
    *(void *)unint64_t v99 = *v134;
LABEL_162:
    *uint64_t v134 = v99;
    goto LABEL_163;
  }
  *(void *)unint64_t v99 = *(void *)(v50 + 1176);
  *(void *)(v50 + 1176) = v99;
  *(void *)(v133 + 8 * v101) = v50 + 1176;
  if (*(void *)v99)
  {
    unint64_t v135 = *(void *)(*(void *)v99 + 8);
    if ((v118 & (v118 - 1)) != 0)
    {
      if (v135 >= v118) {
        v135 %= v118;
      }
    }
    else
    {
      v135 &= v118 - 1;
    }
    uint64_t v134 = (unint64_t *)(*v117 + 8 * v135);
    goto LABEL_162;
  }
LABEL_163:
  ++*(void *)(v50 + 1184);
LABEL_164:
  int v136 = *(std::__shared_weak_count **)&v228;
  if (v228 != 0.0 && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v228 + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v136->__on_zero_shared)(v136);
    std::__shared_weak_count::__release_weak(v136);
  }
  float v137 = v17[1];
  float v138 = v17[2];
  uint64_t v139 = 0x9E3779B97F4A7C15;
  unint64_t v140 = LODWORD(v137) - 0x61C8864680B583EBLL;
  if (v137 == 0.0) {
    unint64_t v140 = 0x9E3779B97F4A7C15;
  }
  uint64_t v141 = LODWORD(v138) - 0x61C8864680B583EBLL;
  if (v138 == 0.0) {
    uint64_t v141 = 0x9E3779B97F4A7C15;
  }
  unint64_t v142 = ((v140 >> 2) + (v140 << 6) + v141) ^ v140;
  float v143 = v17[3];
  float v144 = v17[4];
  uint64_t v145 = LODWORD(v143) - 0x61C8864680B583EBLL;
  if (v143 == 0.0) {
    uint64_t v145 = 0x9E3779B97F4A7C15;
  }
  unint64_t v146 = (v145 + (v142 << 6) + (v142 >> 2)) ^ v142;
  if (v144 != 0.0) {
    uint64_t v139 = LODWORD(v144) - 0x61C8864680B583EBLL;
  }
  unint64_t v147 = (v139 + (v146 << 6) + (v146 >> 2)) ^ v146;
  unint64_t v148 = *(void *)(v50 + 1384);
  if (v148)
  {
    uint8x8_t v149 = (uint8x8_t)vcnt_s8((int8x8_t)v148);
    v149.i16[0] = vaddlv_u8(v149);
    if (v149.u32[0] > 1uLL)
    {
      unint64_t v99 = (v139 + (v146 << 6) + (v146 >> 2)) ^ v146;
      if (v147 >= v148) {
        unint64_t v99 = v147 % v148;
      }
    }
    else
    {
      unint64_t v99 = v147 & (v148 - 1);
    }
    double v150 = (uint64_t *)*((void *)*v51 + v99);
    if (v150)
    {
      uint64_t v151 = *v150;
      if (*v150)
      {
        if (v149.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v152 = *(void *)(v151 + 8);
            if (v152 == v147)
            {
              if (vabds_f32(*(float *)(v151 + 20), v137) < 0.000001
                && vabds_f32(*(float *)(v151 + 24), v138) < 0.000001
                && vabds_f32(*(float *)(v151 + 28), v143) < 0.000001
                && vabds_f32(*(float *)(v151 + 32), v144) < 0.000001)
              {
                goto LABEL_271;
              }
            }
            else if ((v152 & (v148 - 1)) != v99)
            {
              goto LABEL_204;
            }
            uint64_t v151 = *(void *)v151;
            if (!v151) {
              goto LABEL_204;
            }
          }
        }
        do
        {
          unint64_t v153 = *(void *)(v151 + 8);
          if (v153 == v147)
          {
            if (vabds_f32(*(float *)(v151 + 20), v137) < 0.000001
              && vabds_f32(*(float *)(v151 + 24), v138) < 0.000001
              && vabds_f32(*(float *)(v151 + 28), v143) < 0.000001
              && vabds_f32(*(float *)(v151 + 32), v144) < 0.000001)
            {
              goto LABEL_271;
            }
          }
          else
          {
            if (v153 >= v148) {
              v153 %= v148;
            }
            if (v153 != v99) {
              break;
            }
          }
          uint64_t v151 = *(void *)v151;
        }
        while (v151);
      }
    }
  }
LABEL_204:
  uint64_t v151 = (uint64_t)operator new(0x30uLL);
  *(void *)uint64_t v151 = 0;
  *(void *)(v151 + 8) = v147;
  int v154 = *((_DWORD *)v17 + 4);
  *(_OWORD *)(v151 + 16) = *(_OWORD *)v17;
  *(_DWORD *)(v151 + 32) = v154;
  *(void *)(v151 + 40) = 0;
  float v155 = (float)(unint64_t)(*(void *)(v50 + 1400) + 1);
  float v156 = *(float *)(v50 + 1408);
  if (!v148 || (float)(v156 * (float)v148) < v155)
  {
    BOOL v157 = 1;
    if (v148 >= 3) {
      BOOL v157 = (v148 & (v148 - 1)) != 0;
    }
    unint64_t v158 = v157 | (2 * v148);
    unint64_t v159 = vcvtps_u32_f32(v155 / v156);
    if (v158 <= v159) {
      size_t v160 = v159;
    }
    else {
      size_t v160 = v158;
    }
    if (v160 == 1)
    {
      size_t v160 = 2;
    }
    else if ((v160 & (v160 - 1)) != 0)
    {
      size_t v160 = std::__next_prime(v160);
      unint64_t v148 = *(void *)(v50 + 1384);
    }
    if (v160 <= v148)
    {
      if (v160 >= v148) {
        goto LABEL_256;
      }
      unint64_t v172 = vcvtps_u32_f32((float)*(unint64_t *)(v50 + 1400) / *(float *)(v50 + 1408));
      if (v148 < 3 || (uint8x8_t v173 = (uint8x8_t)vcnt_s8((int8x8_t)v148), v173.i16[0] = vaddlv_u8(v173), v173.u32[0] > 1uLL))
      {
        unint64_t v172 = std::__next_prime(v172);
      }
      else
      {
        uint64_t v174 = 1 << -(char)__clz(v172 - 1);
        if (v172 >= 2) {
          unint64_t v172 = v174;
        }
      }
      if (v160 <= v172) {
        size_t v160 = v172;
      }
      if (v160 >= v148) {
        goto LABEL_256;
      }
      if (!v160)
      {
        int v178 = *v51;
        void *v51 = 0;
        if (v178) {
          operator delete(v178);
        }
        *(void *)(v50 + 1384) = 0;
        goto LABEL_256;
      }
    }
    if (v160 >> 61) {
      goto LABEL_370;
    }
    v161 = operator new(8 * v160);
    double v162 = *v51;
    void *v51 = v161;
    if (v162) {
      operator delete(v162);
    }
    uint64_t v163 = 0;
    *(void *)(v50 + 1384) = v160;
    do
      *((void *)*v51 + v163++) = 0;
    while (v160 != v163);
    uint64_t v164 = *(void **)(v50 + 1392);
    if (!v164) {
      goto LABEL_256;
    }
    uint64_t v165 = v50 + 1392;
    size_t v166 = v164[1];
    size_t v167 = v160 - 1;
    if ((v160 & (v160 - 1)) == 0)
    {
      size_t v168 = v166 & v167;
      *((void *)*v51 + v168) = v165;
      while (1)
      {
        uint64_t v169 = (void *)*v164;
        if (!*v164) {
          break;
        }
        size_t v170 = v169[1] & v167;
        if (v170 == v168)
        {
          uint64_t v164 = (void *)*v164;
        }
        else if (*((void *)*v51 + v170))
        {
          *uint64_t v164 = *v169;
          uint64_t v171 = 8 * v170;
          *uint64_t v169 = **(void **)((char *)*v51 + v171);
          **(void **)((char *)*v51 + v171) = v169;
        }
        else
        {
          *((void *)*v51 + v170) = v164;
          uint64_t v164 = v169;
          size_t v168 = v170;
        }
      }
LABEL_256:
      unint64_t v148 = *(void *)(v50 + 1384);
      if ((v148 & (v148 - 1)) != 0)
      {
        if (v147 >= v148) {
          unint64_t v99 = v147 % v148;
        }
        else {
          unint64_t v99 = v147;
        }
      }
      else
      {
        unint64_t v99 = (v148 - 1) & v147;
      }
      goto LABEL_261;
    }
    if (v166 >= v160) {
      v166 %= v160;
    }
    *((void *)*v51 + v166) = v165;
    uint64_t v175 = (void *)*v164;
    if (!*v164) {
      goto LABEL_256;
    }
    while (1)
    {
      size_t v177 = v175[1];
      if (v177 >= v160) {
        v177 %= v160;
      }
      if (v177 != v166)
      {
        if (!*((void *)*v51 + v177))
        {
          *((void *)*v51 + v177) = v164;
          goto LABEL_242;
        }
        *uint64_t v164 = *v175;
        uint64_t v176 = 8 * v177;
        *uint64_t v175 = **(void **)((char *)*v51 + v176);
        **(void **)((char *)*v51 + v176) = v175;
        uint64_t v175 = v164;
      }
      size_t v177 = v166;
LABEL_242:
      uint64_t v164 = v175;
      uint64_t v175 = (void *)*v175;
      size_t v166 = v177;
      if (!v175) {
        goto LABEL_256;
      }
    }
  }
LABEL_261:
  v179 = *v51;
  int v180 = (uint64_t *)*((void *)*v51 + v99);
  if (v180)
  {
    *(void *)uint64_t v151 = *v180;
LABEL_269:
    *int v180 = v151;
    goto LABEL_270;
  }
  *(void *)uint64_t v151 = *(void *)(v50 + 1392);
  *(void *)(v50 + 1392) = v151;
  v179[v99] = v50 + 1392;
  if (*(void *)v151)
  {
    unint64_t v181 = *(void *)(*(void *)v151 + 8);
    if ((v148 & (v148 - 1)) != 0)
    {
      if (v181 >= v148) {
        v181 %= v148;
      }
    }
    else
    {
      v181 &= v148 - 1;
    }
    int v180 = (uint64_t *)((char *)*v51 + 8 * v181);
    goto LABEL_269;
  }
LABEL_270:
  ++*(void *)(v50 + 1400);
LABEL_271:
  *(void *)(v151 + 40) = v64;
  unint64_t v182 = *(void *)(v50 + 1424);
  if (v182)
  {
    uint8x8_t v183 = (uint8x8_t)vcnt_s8((int8x8_t)v182);
    v183.i16[0] = vaddlv_u8(v183);
    if (v183.u32[0] > 1uLL)
    {
      uint64_t v151 = v64;
      if (v64 >= v182) {
        uint64_t v151 = v64 % v182;
      }
    }
    else
    {
      uint64_t v151 = (v182 - 1) & v64;
    }
    int v184 = *(void ***)(*(void *)(v50 + 1416) + 8 * v151);
    if (v184)
    {
      v185 = *v184;
      if (*v184)
      {
        if (v183.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v187 = v185[1];
            if (v187 == v64)
            {
              if (v185[2] == v64) {
                goto LABEL_292;
              }
            }
            else if ((v187 & (v182 - 1)) != v151)
            {
              goto LABEL_293;
            }
            v185 = (void *)*v185;
            if (!v185) {
              goto LABEL_293;
            }
          }
        }
        do
        {
          unint64_t v186 = v185[1];
          if (v186 == v64)
          {
            if (v185[2] == v64)
            {
LABEL_292:
              unint64_t v188 = v64;
              goto LABEL_360;
            }
          }
          else
          {
            if (v186 >= v182) {
              v186 %= v182;
            }
            if (v186 != v151) {
              break;
            }
          }
          v185 = (void *)*v185;
        }
        while (v185);
      }
    }
  }
LABEL_293:
  v185 = operator new(0x30uLL);
  void *v185 = 0;
  v185[1] = v64;
  v185[3] = 0;
  v185[4] = 0;
  v185[2] = v64;
  *((_DWORD *)v185 + 10) = 0;
  float v189 = (float)(unint64_t)(*(void *)(v50 + 1440) + 1);
  float v190 = *(float *)(v50 + 1448);
  if (!v182 || (float)(v190 * (float)v182) < v189)
  {
    BOOL v191 = 1;
    if (v182 >= 3) {
      BOOL v191 = (v182 & (v182 - 1)) != 0;
    }
    unint64_t v192 = v191 | (2 * v182);
    unint64_t v193 = vcvtps_u32_f32(v189 / v190);
    if (v192 <= v193) {
      size_t v194 = v193;
    }
    else {
      size_t v194 = v192;
    }
    if (v194 == 1)
    {
      size_t v194 = 2;
    }
    else if ((v194 & (v194 - 1)) != 0)
    {
      size_t v194 = std::__next_prime(v194);
      unint64_t v182 = *(void *)(v50 + 1424);
    }
    if (v194 <= v182)
    {
      if (v194 >= v182) {
        goto LABEL_345;
      }
      unint64_t v207 = vcvtps_u32_f32((float)*(unint64_t *)(v50 + 1440) / *(float *)(v50 + 1448));
      if (v182 < 3 || (uint8x8_t v208 = (uint8x8_t)vcnt_s8((int8x8_t)v182), v208.i16[0] = vaddlv_u8(v208), v208.u32[0] > 1uLL))
      {
        unint64_t v207 = std::__next_prime(v207);
      }
      else
      {
        uint64_t v209 = 1 << -(char)__clz(v207 - 1);
        if (v207 >= 2) {
          unint64_t v207 = v209;
        }
      }
      if (v194 <= v207) {
        size_t v194 = v207;
      }
      if (v194 >= v182) {
        goto LABEL_345;
      }
      if (!v194)
      {
        v214 = *(void **)(v50 + 1416);
        *(void *)(v50 + 1416) = 0;
        if (v214) {
          operator delete(v214);
        }
        *(void *)(v50 + 1424) = 0;
        goto LABEL_345;
      }
    }
    if (!(v194 >> 61))
    {
      uint64_t v195 = operator new(8 * v194);
      int v196 = *(void **)(v50 + 1416);
      *(void *)(v50 + 1416) = v195;
      if (v196) {
        operator delete(v196);
      }
      uint64_t v197 = 0;
      *(void *)(v50 + 1424) = v194;
      do
        *(void *)(*(void *)(v50 + 1416) + 8 * v197++) = 0;
      while (v194 != v197);
      double v198 = *(void **)(v50 + 1432);
      if (!v198) {
        goto LABEL_345;
      }
      uint64_t v199 = v50 + 1432;
      size_t v200 = v198[1];
      size_t v201 = v194 - 1;
      if ((v194 & (v194 - 1)) == 0)
      {
        size_t v202 = v200 & v201;
        *(void *)(*(void *)(v50 + 1416) + 8 * v202) = v199;
        while (1)
        {
          v203 = (void *)*v198;
          if (!*v198) {
            break;
          }
          size_t v204 = v203[1] & v201;
          if (v204 == v202)
          {
            double v198 = (void *)*v198;
          }
          else
          {
            uint64_t v205 = *(void *)(v50 + 1416);
            if (*(void *)(v205 + 8 * v204))
            {
              *double v198 = *v203;
              uint64_t v206 = 8 * v204;
              void *v203 = **(void **)(*(void *)(v50 + 1416) + v206);
              **(void **)(*(void *)(v50 + 1416) + v206) = v203;
            }
            else
            {
              *(void *)(v205 + 8 * v204) = v198;
              double v198 = v203;
              size_t v202 = v204;
            }
          }
        }
LABEL_345:
        unint64_t v182 = *(void *)(v50 + 1424);
        if ((v182 & (v182 - 1)) != 0)
        {
          if (v64 >= v182) {
            uint64_t v151 = v64 % v182;
          }
          else {
            uint64_t v151 = v64;
          }
        }
        else
        {
          uint64_t v151 = (v182 - 1) & v64;
        }
        goto LABEL_350;
      }
      if (v200 >= v194) {
        v200 %= v194;
      }
      *(void *)(*(void *)(v50 + 1416) + 8 * v200) = v199;
      v210 = (void *)*v198;
      if (!*v198) {
        goto LABEL_345;
      }
      while (1)
      {
        size_t v212 = v210[1];
        if (v212 >= v194) {
          v212 %= v194;
        }
        if (v212 != v200)
        {
          uint64_t v213 = *(void *)(v50 + 1416);
          if (!*(void *)(v213 + 8 * v212))
          {
            *(void *)(v213 + 8 * v212) = v198;
            goto LABEL_331;
          }
          *double v198 = *v210;
          uint64_t v211 = 8 * v212;
          void *v210 = **(void **)(*(void *)(v50 + 1416) + v211);
          **(void **)(*(void *)(v50 + 1416) + v211) = v210;
          v210 = v198;
        }
        size_t v212 = v200;
LABEL_331:
        double v198 = v210;
        v210 = (void *)*v210;
        size_t v200 = v212;
        if (!v210) {
          goto LABEL_345;
        }
      }
    }
LABEL_370:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_350:
  uint64_t v215 = *(void *)(v50 + 1416);
  v216 = *(void **)(v215 + 8 * v151);
  if (v216)
  {
    void *v185 = *v216;
    unint64_t v188 = v64;
  }
  else
  {
    void *v185 = *(void *)(v50 + 1432);
    *(void *)(v50 + 1432) = v185;
    *(void *)(v215 + 8 * v151) = v50 + 1432;
    unint64_t v188 = v64;
    if (!*v185) {
      goto LABEL_359;
    }
    unint64_t v217 = *(void *)(*v185 + 8);
    if ((v182 & (v182 - 1)) != 0)
    {
      if (v217 >= v182) {
        v217 %= v182;
      }
    }
    else
    {
      v217 &= v182 - 1;
    }
    v216 = (void *)(*(void *)(v50 + 1416) + 8 * v217);
  }
  void *v216 = v185;
LABEL_359:
  ++*(void *)(v50 + 1440);
LABEL_360:
  *((unsigned char *)v185 + 24) = *(unsigned char *)v17;
  *((float *)v185 + 7) = v17[1];
  *((float *)v185 + 8) = v17[2];
  *((float *)v185 + 9) = v17[3];
  *((float *)v185 + 10) = v17[4];
  v218 = **(void ***)(a1 + 8);
  uint64_t v219 = v218[159];
  uint64_t v220 = v218[158];
  *(void *)&v227.f64[0] = v64;
  if (v188 < (v219 - v220) >> 3)
  {
    uint64_t v221 = *(void *)(v220 + 8 * v188);
    if (v221)
    {
      if (HIDWORD(v64) == HIDWORD(v221) && v218[161] + 24 * v221 != v218[162]) {
        operator new();
      }
    }
  }
}

void sub_1A1F6EFEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  uint64_t v31 = v29[3];
  v29[3] = 0;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  operator delete(v29);
  _Unwind_Resume(a1);
}

__n128 std::__function::__func<md::ita::PrepareStyleConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &>)::$_0,std::allocator<md::ita::PrepareStyleConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF520468;
  __n128 result = *(__n128 *)(a1 + 8);
  long long v3 = *(_OWORD *)(a1 + 24);
  *(_OWORD *)(a2 + 40) = *(_OWORD *)(a1 + 40);
  *(_OWORD *)(a2 + 24) = v3;
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::ita::PrepareStyleConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &>)::$_0,std::allocator<md::ita::PrepareStyleConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &)>::__clone(uint64_t a1)
{
  double v2 = (char *)operator new(0x38uLL);
  *(void *)double v2 = &unk_1EF520468;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  *(_OWORD *)(v2 + 24) = *(_OWORD *)(a1 + 24);
  __n128 result = *(__n128 *)(a1 + 40);
  *(__n128 *)(v2 + 40) = result;
  return result;
}

void std::__function::__func<md::ita::PrepareStyleConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &>)::$_0,std::allocator<md::ita::PrepareStyleConstantDataHandle::operator()(ecs2::Query<md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &>)::$_0>,void ()(md::ls::MeshRenderableID const&,md::ls::OrientedBox const*,md::ls::StyleDataKeyHandle &)>::~__func()
{
}

void ggl::BuildingTopDepth::CompressedMeshPipelineState::~CompressedMeshPipelineState(ggl::BuildingTopDepth::CompressedMeshPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  double v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  double v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::BuildingTopDepth::CompressedMeshPipelineSetup::textureIsEnabled(ggl::BuildingTopDepth::CompressedMeshPipelineSetup *this)
{
  return 0;
}

BOOL ggl::BuildingTopDepth::CompressedMeshPipelineSetup::constantDataIsEnabled(ggl::BuildingTopDepth::CompressedMeshPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::BuildingTopDepth::CompressedMeshPipelineSetup::~CompressedMeshPipelineSetup(ggl::BuildingTopDepth::CompressedMeshPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void md::LayoutContext::~LayoutContext(md::LayoutContext *this)
{
  if (*((unsigned char *)this + 728))
  {
    if (*((unsigned char *)this + 576)) {
      *((unsigned char *)this + 576) = 0;
    }
    if (*((unsigned char *)this + 560)) {
      *((unsigned char *)this + 560) = 0;
    }
  }
  uint64_t v2 = *((void *)this + 6);
  if (!v2)
  {
    *((void *)this + 6) = 0;
    double v7 = (std::__shared_weak_count *)*((void *)this + 5);
    if (!v7) {
      goto LABEL_16;
    }
    goto LABEL_14;
  }
  uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 24))(v2);
  uint64_t v4 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  uint64_t v8 = v4;
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v3 + 48))(v3, &v8);
  uint64_t v5 = v8;
  uint64_t v8 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  double v7 = (std::__shared_weak_count *)*((void *)this + 5);
  if (v7)
  {
LABEL_14:
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
LABEL_16:
}

uint64_t md::LayoutContext::debugConsoleForId(void **a1, uint64_t a2)
{
  if (!*a1 || (objc_opt_respondsToSelector() & 1) == 0) {
    return 0;
  }
  uint64_t v4 = *a1;
  return [v4 debugConsoleForId:a2];
}

uint64_t ggl::FragmentedPool<ggl::MaskingOverlay::MaskingPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::MaskingOverlay::FillPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  int v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14MaskingOverlay17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF57AE90;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14MaskingOverlay17FillPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::MaskingOverlay::FillPipelineSetup * ()(void)>::operator()()
{
}

void ggl::ConstantDataTyped<ggl::MaskingOverlay::Fill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::MaskingOverlay::Fill>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::MaskingOverlay::Fill>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::MaskingOverlay::Fill>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586140;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::MaskingOverlay::Fill>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586140;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::__function::__func<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::MaskingOverlay::FillPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF576D88;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,ggl::MaskingOverlay::FillPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::MaskingOverlay::FillPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::MaskingOverlay::FillPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D60;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::MaskingOverlay::FillPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D60;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14MaskingOverlay20MaskingPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EF57AED8;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_14MaskingOverlay20MaskingPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::MaskingOverlay::MaskingPipelineSetup * ()(void)>::operator()()
{
}

void *std::__function::__func<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::MaskingOverlay::MaskingPipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF576D40;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::MaskingOverlayRenderable::SharedResources::SharedResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::MaskingOverlay::MaskingPipelineSetup * ()(void)>::~__func()
{
}

uint64_t std::__shared_ptr_emplace<ggl::MaskingOverlay::MaskingPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::MaskingOverlay::MaskingPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::MaskingOverlay::MaskingPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583D98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::MaskingOverlayRenderable::buildRenderItems(md::MaskingOverlayRenderable *this)
{
  unint64_t v2 = *((void *)this + 20) + 1;
  uint64_t v3 = (char *)*((void *)this + 8);
  uint64_t v4 = (char *)*((void *)this + 9);
  uint64_t v5 = v4;
  unint64_t v6 = (v4 - v3) >> 3;
  unint64_t v7 = v2 - v6;
  if (v2 <= v6)
  {
    if (v2 < v6)
    {
      double v26 = &v3[8 * v2];
      if (v4 != v26)
      {
        do
        {
          uint64_t v28 = *((void *)v5 - 1);
          v5 -= 8;
          uint64_t v27 = v28;
          *(void *)uint64_t v5 = 0;
          if (v28) {
            (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
          }
        }
        while (v5 != v26);
      }
      *((void *)this + 9) = v26;
    }
  }
  else
  {
    uint64_t v8 = *((void *)this + 10);
    if (v7 <= (v8 - (uint64_t)v4) >> 3)
    {
      bzero(v4, 8 * v7);
      *((void *)this + 9) = &v4[8 * v7];
    }
    else
    {
      if (v2 >> 61) {
        abort();
      }
      uint64_t v9 = v8 - (void)v3;
      if (v9 >> 2 > v2) {
        unint64_t v2 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v2 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v2 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v10 = 8 * v2;
      unint64_t v11 = (char *)operator new(8 * v2);
      uint64_t v12 = &v11[8 * v6];
      double v29 = &v11[v10];
      bzero(v12, 8 * v7);
      uint64_t v13 = &v12[8 * v7];
      if (v4 == v3)
      {
        *((void *)this + 8) = v12;
        *((void *)this + 9) = v13;
        *((void *)this + 10) = v29;
      }
      else
      {
        unint64_t v14 = v4 - v3 - 8;
        if (v14 <= 0x77) {
          goto LABEL_39;
        }
        if (&v4[-(v14 & 0xFFFFFFFFFFFFFFF8) - 8] < v12 && &v11[v4 - v3 - (v14 & 0xFFFFFFFFFFFFFFF8) - 8] < v4) {
          goto LABEL_39;
        }
        uint64_t v16 = (v14 >> 3) + 1;
        uint64_t v5 = &v4[-8 * (v16 & 0x3FFFFFFFFFFFFFFCLL)];
        int v17 = &v11[8 * v6 - 16];
        __n128 v18 = v4 - 32;
        uint64_t v19 = v16 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v21 = *(_OWORD *)v18;
          long long v20 = *((_OWORD *)v18 + 1);
          *(_OWORD *)__n128 v18 = 0uLL;
          *((_OWORD *)v18 + 1) = 0uLL;
          v18 -= 32;
          *((_OWORD *)v17 - 1) = v21;
          *(_OWORD *)int v17 = v20;
          v17 -= 32;
          v19 -= 4;
        }
        while (v19);
        v12 -= 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
        if (v16 != (v16 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_39:
          do
          {
            uint64_t v22 = *((void *)v5 - 1);
            v5 -= 8;
            *(void *)uint64_t v5 = 0;
            *((void *)v12 - 1) = v22;
            v12 -= 8;
          }
          while (v5 != v3);
        }
        uint64_t v5 = (char *)*((void *)this + 8);
        double v23 = (char *)*((void *)this + 9);
        *((void *)this + 8) = v12;
        *((void *)this + 9) = v13;
        *((void *)this + 10) = v29;
        while (v23 != v5)
        {
          uint64_t v25 = *((void *)v23 - 1);
          v23 -= 8;
          uint64_t v24 = v25;
          *(void *)double v23 = 0;
          if (v25) {
            (*(void (**)(uint64_t))(*(void *)v24 + 8))(v24);
          }
        }
      }
      if (v5) {
        operator delete(v5);
      }
    }
  }
  std::vector<BOOL>::resize((uint64_t)this + 88, *((void *)this + 20) + 1);
  operator new();
}

void sub_1A1F70880(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  MEMORY[0x1A6239270](v13, 0x10F1C4093A39A99);
  std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::MaskingOverlayRenderableConfig::~MaskingOverlayRenderableConfig(md::MaskingOverlayRenderableConfig *this)
{
  int v1 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void md::MaskingOverlayRenderable::layoutFill(md::MaskingOverlayRenderable *this, const md::LayoutContext *a2, int a3)
{
  **((void **)this + 11) &= ~1uLL;
  if (!*((void *)this + 14) || !*((void *)this + 15)) {
    return;
  }
  unint64_t v6 = (void *)*((void *)a2 + 1);
  int8x8_t v7 = (int8x8_t)v6[1];
  if (!*(void *)&v7)
  {
    uint64_t v10 = 0;
    uint8x8_t v11 = (uint8x8_t)vcnt_s8(0);
    v11.i16[0] = vaddlv_u8(v11);
    BOOL v12 = v11.u32[0] < 2uLL;
    if (v11.u32[0] < 2uLL) {
      goto LABEL_30;
    }
    goto LABEL_36;
  }
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v7);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    uint64_t v9 = 0x1AF456233693CD46uLL % *(void *)&v7;
    if (*(void *)&v7 > 0x1AF456233693CD46uLL) {
      uint64_t v9 = 0x1AF456233693CD46;
    }
  }
  else
  {
    uint64_t v9 = (*(void *)&v7 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v13 = *(void **)(*v6 + 8 * v9);
  if (!v13) {
    goto LABEL_28;
  }
  unint64_t v14 = (void *)*v13;
  if (!v14) {
    goto LABEL_28;
  }
  if (v8.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v16 = v14[1];
      if (v16 == 0x1AF456233693CD46)
      {
        if (v14[2] == 0x1AF456233693CD46) {
          goto LABEL_26;
        }
      }
      else if ((v16 & (*(void *)&v7 - 1)) != v9)
      {
        goto LABEL_28;
      }
      unint64_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_28;
      }
    }
  }
  while (1)
  {
    unint64_t v15 = v14[1];
    if (v15 == 0x1AF456233693CD46) {
      break;
    }
    if (v15 >= *(void *)&v7) {
      v15 %= *(void *)&v7;
    }
    if (v15 != v9) {
      goto LABEL_28;
    }
LABEL_15:
    unint64_t v14 = (void *)*v14;
    if (!v14) {
      goto LABEL_28;
    }
  }
  if (v14[2] != 0x1AF456233693CD46) {
    goto LABEL_15;
  }
LABEL_26:
  uint64_t v17 = v14[5];
  if (*(void *)(v17 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v10 = *(void *)(v17 + 32);
    goto LABEL_29;
  }
LABEL_28:
  uint64_t v10 = 0;
LABEL_29:
  uint8x8_t v18 = (uint8x8_t)vcnt_s8(v7);
  v18.i16[0] = vaddlv_u8(v18);
  BOOL v12 = v18.u32[0] < 2uLL;
  if (v18.u32[0] < 2uLL)
  {
LABEL_30:
    uint64_t v19 = *(void *)&v7 - 1;
    for (uint64_t i = **(void ***)(*v6 + 8 * ((*(void *)&v7 - 1) & 0x1AF456233693CD46));
          i[1] != 0x1AF456233693CD46 || i[2] != 0x1AF456233693CD46;
    BOOL v12 = 1;
    goto LABEL_41;
  }
  unint64_t v21 = 0x1AF456233693CD46;
  if (*(void *)&v7 <= 0x1AF456233693CD46uLL) {
LABEL_36:
  }
    unint64_t v21 = 0x1AF456233693CD46uLL % *(void *)&v7;
  uint64_t i = **(void ***)(*v6 + 8 * v21);
  uint64_t v19 = *(void *)&v7 - 1;
  while (i[1] != 0x1AF456233693CD46 || i[2] != 0x1AF456233693CD46)
    uint64_t i = (void *)*i;
LABEL_41:
  uint64_t v22 = *(void *)(i[5] + 32);
  if (v12)
  {
    double v23 = *(void **)(*v6 + 8 * (v19 & 0xE42D19AFCA302E68));
    do
    {
      do
        double v23 = (void *)*v23;
      while (v23[1] != 0xE42D19AFCA302E68);
    }
    while (v23[2] != 0xE42D19AFCA302E68);
  }
  else
  {
    unint64_t v24 = 0xE42D19AFCA302E68;
    if (*(void *)&v7 <= 0xE42D19AFCA302E68) {
      unint64_t v24 = 0xE42D19AFCA302E68 % *(void *)&v7;
    }
    double v23 = *(void **)(*v6 + 8 * v24);
    do
    {
      do
        double v23 = (void *)*v23;
      while (v23[1] != 0xE42D19AFCA302E68);
    }
    while (v23[2] != 0xE42D19AFCA302E68);
  }
  float v25 = *(float *)(v22 + 3076);
  float v26 = *(float *)(v22 + 3080);
  float v27 = *(float *)(*(void *)(v23[5] + 32) + 108);
  uint64_t v28 = *((void *)this + 16);
  double v29 = (std::__shared_weak_count *)*((void *)this + 17);
  __p.__r_.__value_.__r.__words[0] = v28;
  __p.__r_.__value_.__l.__size_ = (std::string::size_type)v29;
  if (v29) {
    atomic_fetch_add_explicit(&v29->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker(__y, v28, (uint64_t)v29);
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
    if (v154) {
      goto LABEL_56;
    }
    goto LABEL_71;
  }
  if (!v154)
  {
LABEL_71:
    BOOL v39 = 0;
    uint64_t v40 = 0;
    float v41 = 0.0;
    goto LABEL_115;
  }
LABEL_56:
  float v30 = fmaxf(v26 + v25, 1.0);
  uint64_t v31 = *(void *)(__y[0] + 24);
  if ((int)v30 >= 0x17) {
    unsigned int v32 = 23;
  }
  else {
    unsigned int v32 = (int)v30;
  }
  uint64_t v33 = *(float **)v31;
  if (*(void *)v31
    && (float v34 = *v33, LODWORD(v33) = *v33 == 1.0, *(unsigned char *)(v31 + 10))
    && (v34 != 0.0 ? (BOOL v35 = v34 == 1.0) : (BOOL v35 = 1), !v35)
    || (int v36 = *(unsigned __int8 *)(v31 + v33 + 11), v34 = 0.0, v36 == 2))
  {
    __p.__r_.__value_.__s.__data_[0] = 1;
    v151.__r_.__value_.__s.__data_[0] = 1;
    char v37 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v31, 0x5Bu, v32, 0, &__p);
    char v38 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v31, 0x5Bu, v32, 1, &v151);
    if (v34 < 1.0) {
      char v38 = v37;
    }
  }
  else
  {
    char v38 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(__y[0] + 24), 0x5Bu, v32, v36, 0);
  }
  BOOL v39 = v38 != 0;
  if (v38)
  {
    memset(&__p, 0, sizeof(__p));
    gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<std::string>(&v151, *(void *)(__y[0] + 24), 0x88u, v32, 2);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v151;
    std::string::size_type size = HIBYTE(v151.__r_.__value_.__r.__words[2]);
    if ((v151.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
      std::string::size_type size = v151.__r_.__value_.__l.__size_;
    }
    if (size)
    {
      id v43 = (void *)*((void *)a2 + 1);
      unint64_t v44 = v43[1];
      if ((v44 & (v44 - 1)) != 0)
      {
        unint64_t v47 = 0xA60DDA5A69582425;
        if (v44 <= 0xA60DDA5A69582425) {
          unint64_t v47 = 0xA60DDA5A69582425 % v44;
        }
        id v45 = *(void **)(*v43 + 8 * v47);
        do
        {
          do
            id v45 = (void *)*v45;
          while (v45[1] != 0xA60DDA5A69582425);
        }
        while (v45[2] != 0xA60DDA5A69582425);
      }
      else
      {
        id v45 = *(void **)(*v43 + 8 * ((v44 - 1) & 0xA60DDA5A69582425));
        do
        {
          do
            id v45 = (void *)*v45;
          while (v45[1] != 0xA60DDA5A69582425);
        }
        while (v45[2] != 0xA60DDA5A69582425);
      }
      id v48 = **(id **)(v45[5] + 32);
      uint64_t v49 = v48;
      if (v48)
      {
        [v48 textureManager];
        uint64_t v50 = v149;
      }
      else
      {
        uint64_t v50 = 0;
        uint8x8_t v149 = 0;
        double v150 = 0;
      }
      long long v51 = (std::__shared_weak_count *)operator new(0x58uLL);
      v51->__shared_owners_ = 0;
      v51->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583858;
      v51[1].__shared_weak_owners_ = 0;
      v51[2].__vftable = 0;
      v51[1].__shared_owners_ = 0;
      LODWORD(v51[2].__shared_owners_) = 0;
      v51->__shared_weak_owners_ = 0;
      v51[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55AE58;
      *(_OWORD *)((char *)&v51[2].__shared_owners_ + 4) = xmmword_1A28FD500;
      *(std::__shared_weak_count_vtbl **)((char *)&v51[3].__vftable + 4) = (std::__shared_weak_count_vtbl *)0x100000001;
      HIDWORD(v51[3].__shared_owners_) = 0;
      v148[0] = (uint64_t)&v51[1];
      v148[1] = (uint64_t)v51;
      md::TextureManager::texture(&v151, v50, (uint64_t)&__p, v148, 0, v27);
      if (!atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
        std::__shared_weak_count::__release_weak(v51);
      }
      uint64_t v52 = v150;
      if (v150 && !atomic_fetch_add(&v150->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
        std::__shared_weak_count::__release_weak(v52);
      }

      unint64_t v53 = (md::SharedResource *)v151.__r_.__value_.__r.__words[0];
      if (v151.__r_.__value_.__r.__words[0])
      {
        uint64_t v54 = md::LayoutContext::frameState(a2);
        md::SharedResource::addFrameRef(v53, *(void *)(v54 + 624));
        uint64_t v40 = *((void *)v53 + 4);
        uint64_t v55 = (std::__shared_weak_count *)v151.__r_.__value_.__l.__size_;
        if (!v151.__r_.__value_.__l.__size_) {
          goto LABEL_105;
        }
LABEL_103:
        if (!atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
          std::__shared_weak_count::__release_weak(v55);
        }
      }
      else
      {
        uint64_t v40 = 0;
        uint64_t v55 = (std::__shared_weak_count *)v151.__r_.__value_.__l.__size_;
        if (v151.__r_.__value_.__l.__size_) {
          goto LABEL_103;
        }
      }
    }
    else
    {
      uint64_t v40 = 0;
    }
LABEL_105:
    unint64_t v56 = *(void *)(__y[0] + 24);
    float v57 = fminf(fmaxf(v30, 0.0), 23.0);
    long long v58 = *(float **)v56;
    if (*(void *)v56
      && (float v59 = *v58, LODWORD(v58) = *v58 == 1.0, *(unsigned char *)(v56 + 10))
      && (v59 != 0.0 ? (BOOL v60 = v59 == 1.0) : (BOOL v60 = 1), !v60)
      || (v61 = *(unsigned __int8 *)(v56 + v58 + 11), float v59 = 0.0, v61 == 2))
    {
      v151.__r_.__value_.__s.__data_[0] = 1;
      LOBYTE(v149) = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v56, 0xC2u, 0, (BOOL *)&v151, v57);
      float v63 = v62;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v56, 0xC2u, 1u, (BOOL *)&v149, v57);
      float v41 = v63 + (float)((float)(v64 - v63) * v59);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        goto LABEL_114;
      }
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(__y[0] + 24), 0xC2u, v61, 0, v57);
      float v41 = v83;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_114:
      }
        operator delete(__p.__r_.__value_.__l.__data_);
    }
LABEL_115:
    uint64_t v65 = +[VKDebugSettings sharedSettings];
    [v65 maskingOverlayOpacityFactor];
    float v67 = v66;

    float v46 = v41 * v67;
  }
  else
  {
    uint64_t v40 = 0;
    float v46 = 0.0;
  }
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)__y);
  if (!v39 || !v40) {
    return;
  }
  uint64_t v68 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v69 = *(void *)(v68 + 8);
  if (v69 == *(void *)v68)
  {
    uint64_t v80 = *(void *)(v68 + 88);
    if (!v80)
    {
LABEL_215:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_216:
      abort();
    }
    uint64_t v70 = (*(uint64_t (**)(uint64_t))(*(void *)v80 + 48))(v80);
    unint64_t v71 = *(uint64_t **)(v68 + 40);
    unint64_t v81 = *(void *)(v68 + 48);
    if ((unint64_t)v71 < v81)
    {
LABEL_130:
      if (v71) {
        *unint64_t v71 = v70;
      }
      long long v82 = v71 + 1;
      goto LABEL_169;
    }
    uint64_t v84 = *(void *)(v68 + 32);
    uint64_t v85 = ((uint64_t)v71 - v84) >> 3;
    unint64_t v75 = v85 + 1;
    if ((unint64_t)(v85 + 1) >> 61) {
      goto LABEL_216;
    }
    uint64_t v86 = v81 - v84;
    if (v86 >> 2 > v75) {
      unint64_t v75 = v86 >> 2;
    }
    if ((unint64_t)v86 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v75 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v75)
    {
      uint64_t v87 = 8 * v75;
      uint64_t v88 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v68 + 56) + 16))(*(void *)(v68 + 56), 8 * v75, 8);
      double v79 = (uint64_t *)(v88 + 8 * v85);
      unint64_t v75 = v88 + v87;
      if (v88) {
        *double v79 = v70;
      }
    }
    else
    {
      double v79 = (uint64_t *)(8 * v85);
    }
    long long v82 = v79 + 1;
    uint64_t v98 = *(void *)(v68 + 32);
    uint64_t v89 = *(void *)(v68 + 40);
    if (v89 == v98) {
      goto LABEL_167;
    }
    unint64_t v99 = v89 - v98 - 8;
    if (v99 < 0x38)
    {
      uint64_t v101 = *(void *)(v68 + 40);
    }
    else if ((unint64_t)(v89 - (void)v79) < 0x20)
    {
      uint64_t v101 = *(void *)(v68 + 40);
    }
    else
    {
      uint64_t v100 = (v99 >> 3) + 1;
      uint64_t v101 = v89 - 8 * (v100 & 0x3FFFFFFFFFFFFFFCLL);
      long double v102 = v79 - 2;
      uint64_t v103 = (long long *)(v89 - 16);
      uint64_t v104 = v100 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v105 = *v103;
        *((_OWORD *)v102 - 1) = *(v103 - 1);
        *(_OWORD *)long double v102 = v105;
        v102 -= 4;
        v103 -= 2;
        v104 -= 4;
      }
      while (v104);
      v79 -= v100 & 0x3FFFFFFFFFFFFFFCLL;
      if (v100 == (v100 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_166;
      }
    }
    do
    {
      uint64_t v107 = *(void *)(v101 - 8);
      v101 -= 8;
      *--double v79 = v107;
    }
    while (v101 != v98);
LABEL_166:
    uint64_t v89 = *(void *)(v68 + 32);
    goto LABEL_167;
  }
  uint64_t v70 = *(void *)(v69 - 8);
  *(void *)(v68 + 8) = v69 - 8;
  unint64_t v71 = *(uint64_t **)(v68 + 40);
  unint64_t v72 = *(void *)(v68 + 48);
  if ((unint64_t)v71 < v72) {
    goto LABEL_130;
  }
  uint64_t v73 = *(void *)(v68 + 32);
  uint64_t v74 = ((uint64_t)v71 - v73) >> 3;
  unint64_t v75 = v74 + 1;
  if ((unint64_t)(v74 + 1) >> 61) {
    goto LABEL_216;
  }
  uint64_t v76 = v72 - v73;
  if (v76 >> 2 > v75) {
    unint64_t v75 = v76 >> 2;
  }
  if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v75 = 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v75)
  {
    uint64_t v77 = 8 * v75;
    uint64_t v78 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v68 + 56) + 16))(*(void *)(v68 + 56), 8 * v75, 8);
    double v79 = (uint64_t *)(v78 + 8 * v74);
    unint64_t v75 = v78 + v77;
    if (v78) {
      *double v79 = v70;
    }
  }
  else
  {
    double v79 = (uint64_t *)(8 * v74);
  }
  long long v82 = v79 + 1;
  uint64_t v90 = *(void *)(v68 + 32);
  uint64_t v89 = *(void *)(v68 + 40);
  if (v89 != v90)
  {
    unint64_t v91 = v89 - v90 - 8;
    if (v91 < 0x38)
    {
      uint64_t v93 = *(void *)(v68 + 40);
    }
    else if ((unint64_t)(v89 - (void)v79) < 0x20)
    {
      uint64_t v93 = *(void *)(v68 + 40);
    }
    else
    {
      uint64_t v92 = (v91 >> 3) + 1;
      uint64_t v93 = v89 - 8 * (v92 & 0x3FFFFFFFFFFFFFFCLL);
      double v94 = v79 - 2;
      uint64_t v95 = (long long *)(v89 - 16);
      uint64_t v96 = v92 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v97 = *v95;
        *((_OWORD *)v94 - 1) = *(v95 - 1);
        *(_OWORD *)double v94 = v97;
        v94 -= 4;
        v95 -= 2;
        v96 -= 4;
      }
      while (v96);
      v79 -= v92 & 0x3FFFFFFFFFFFFFFCLL;
      if (v92 == (v92 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_166;
      }
    }
    do
    {
      uint64_t v106 = *(void *)(v93 - 8);
      v93 -= 8;
      *--double v79 = v106;
    }
    while (v93 != v90);
    goto LABEL_166;
  }
LABEL_167:
  *(void *)(v68 + 32) = v79;
  *(void *)(v68 + 40) = v82;
  uint64_t v108 = *(void *)(v68 + 48);
  *(void *)(v68 + 48) = v75;
  if (v89) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v68 + 56) + 40))(*(void *)(v68 + 56), v89, v108 - v89);
  }
LABEL_169:
  *(void *)(v68 + 40) = v82;
  __y[0] = v70;
  uint64_t v109 = *(void *)(v68 + 120);
  if (!v109) {
    goto LABEL_215;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v109 + 48))(v109, __y);
  unint64_t v110 = *(void **)(v70 + 64);
  v110[1] = 0;
  uint64_t v111 = *((void *)this + 4);
  void *v110 = v111;
  float32x2_t v112 = *(void **)(v70 + 160);
  uint64_t v113 = *((void *)this + 5);
  if (v113) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v113 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v114 = (std::__shared_weak_count *)v112[1];
  *float32x2_t v112 = v111;
  v112[1] = v113;
  if (v114 && !atomic_fetch_add(&v114->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v114->__on_zero_shared)(v114);
    std::__shared_weak_count::__release_weak(v114);
  }
  uint64_t v115 = *(void *)(v70 + 64);
  *(void *)(v115 + 24) = 0;
  uint64_t v116 = *((void *)this + 6);
  *(void *)(v115 + 16) = v116;
  uint64_t v117 = *(void *)(v70 + 160);
  uint64_t v118 = *((void *)this + 7);
  if (v118) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v118 + 8), 1uLL, memory_order_relaxed);
  }
  uint8x8_t v119 = *(std::__shared_weak_count **)(v117 + 24);
  *(void *)(v117 + 16) = v116;
  *(void *)(v117 + 24) = v118;
  if (v119 && !atomic_fetch_add(&v119->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
    std::__shared_weak_count::__release_weak(v119);
  }
  uint64_t v120 = *((void *)this + 3);
  uint64_t v122 = *(void *)(v120 + 16);
  long long v121 = *(std::__shared_weak_count **)(v120 + 24);
  if (v121) {
    atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (v122 && **(void **)(v122 + 40) == *(void *)(v70 + 8))
  {
    uint64_t v124 = *(void *)(v70 + 16);
    if (v124 && v124 != v122) {
      ggl::PipelineSetup::resetData(v70);
    }
    if (v121) {
      atomic_fetch_add_explicit(&v121->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v123 = *(std::__shared_weak_count **)(v70 + 24);
    *(void *)(v70 + 16) = v122;
    *(void *)(v70 + 24) = v121;
    if (v123) {
      goto LABEL_192;
    }
  }
  else
  {
    uint64_t v123 = *(std::__shared_weak_count **)(v70 + 24);
    *(void *)(v70 + 16) = 0;
    *(void *)(v70 + 24) = 0;
    if (!v123) {
      goto LABEL_194;
    }
LABEL_192:
    if (!atomic_fetch_add(&v123->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
      std::__shared_weak_count::__release_weak(v123);
    }
  }
LABEL_194:
  if (v121 && !atomic_fetch_add(&v121->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v121->__on_zero_shared)(v121);
    std::__shared_weak_count::__release_weak(v121);
  }
  **(void **)(v70 + 96) = v40;
  float v125 = (void *)*((void *)a2 + 1);
  unint64_t v126 = v125[1];
  if ((v126 & (v126 - 1)) != 0)
  {
    unint64_t v128 = 0xE42D19AFCA302E68;
    if (v126 <= 0xE42D19AFCA302E68) {
      unint64_t v128 = 0xE42D19AFCA302E68 % v126;
    }
    unint64_t v127 = *(void **)(*v125 + 8 * v128);
    do
    {
      do
        unint64_t v127 = (void *)*v127;
      while (v127[1] != 0xE42D19AFCA302E68);
    }
    while (v127[2] != 0xE42D19AFCA302E68);
  }
  else
  {
    unint64_t v127 = *(void **)(*v125 + 8 * ((v126 - 1) & 0xE42D19AFCA302E68));
    do
    {
      do
        unint64_t v127 = (void *)*v127;
      while (v127[1] != 0xE42D19AFCA302E68);
    }
    while (v127[2] != 0xE42D19AFCA302E68);
  }
  float v129 = *(float *)(*(void *)(v127[5] + 32) + 108);
  unint64_t v130 = *(void **)(*(void *)(v70 + 64) + 32);
  unint64_t v131 = v130[1];
  uint64_t v132 = v130[9];
  *(_DWORD *)(v132 + 20) = 0;
  uint64_t v133 = *(double **)(v10 + 5584);
  if (!v133) {
    uint64_t v133 = (double *)v10;
  }
  double v134 = v133[471];
  *(double *)&unint64_t v135 = v134 * v133[173];
  double v136 = *(double *)&v135 * (double)(1 << *((unsigned char *)this + 1));
  LODWORD(v135) = *(_DWORD *)(v40 + 80);
  LODWORD(v134) = *(_DWORD *)(v40 + 84);
  double v137 = v133[171] * v129 / v136;
  double v138 = v137 / (double)v135;
  double v139 = v137 / (double)*(unint64_t *)&v134;
  double v140 = modf(v138 * (double)*((int *)this + 2), (long double *)__y);
  long double v141 = modf(v139 * (double)*((int *)this + 1), (long double *)__y);
  float v142 = v140;
  *(float *)&long double v141 = v141;
  *(float *)uint64_t v132 = v142;
  *(_DWORD *)(v132 + 4) = LODWORD(v141);
  *(float *)&long double v141 = v138;
  float v143 = v139;
  *(_DWORD *)(v132 + 8) = LODWORD(v141);
  *(float *)(v132 + 12) = v143;
  *(float *)(v132 + 16) = v46;
  unint64_t v144 = v130[8];
  if (v144 <= v131) {
    unint64_t v144 = v131;
  }
  v130[7] = 0;
  v130[8] = v144;
  uint64_t v145 = (void *)*((void *)this + 3);
  uint64_t v146 = 5;
  if (*((void *)this + 14) == 1) {
    uint64_t v146 = 4;
  }
  uint64_t v147 = **((void **)this + 8);
  *(void *)(v147 + 24) = v145[v146];
  *(void *)(v147 + 32) = v70;
  *(_DWORD *)(v147 + 40) = a3;
  *(void *)(v147 + 64) = *v145;
  **((void **)this + 11) |= 1uLL;
  *((void *)this + 21) = 0;
}

void sub_1A1F717F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,char a24)
{
  if (a22 < 0) {
    operator delete(__p);
  }
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&a24);
  _Unwind_Resume(a1);
}

void md::MaskingOverlayRenderable::collectRenderItems(void *a1, int a2, uint64_t a3)
{
  if (a2 != 1) {
    goto LABEL_9;
  }
  uint64_t v6 = a1[8];
  uint64_t v5 = a1[9];
  if ((unint64_t)(v5 - v6) < 9) {
    return;
  }
  uint64_t v7 = a1[11];
  unint64_t v8 = 1;
  while (1)
  {
    if ((*(void *)(v7 + 8 * (v8 >> 6)) & (1 << v8)) == 0) {
      goto LABEL_5;
    }
    uint64_t v11 = *(void *)(v6 + 8 * v8);
    uint64_t v9 = *(void *)(a3 + 24);
    if (!v9) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 48))(v9, &v11);
    uint64_t v7 = a1[11];
    *(void *)(v7 + 8 * (v8 >> 6)) &= ~(1 << v8);
    uint64_t v6 = a1[8];
    uint64_t v5 = a1[9];
LABEL_5:
    if (++v8 >= (v5 - v6) >> 3) {
      return;
    }
  }
  while (1)
  {
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_9:
    if ((*(unsigned char *)a1[11] & 1) == 0) {
      break;
    }
    uint64_t v11 = *(void *)a1[8];
    uint64_t v10 = *(void *)(a3 + 24);
    if (v10)
    {
      (*(void (**)(uint64_t, uint64_t *))(*(void *)v10 + 48))(v10, &v11);
      *(void *)a1[11] &= ~1uLL;
      return;
    }
  }
}

void md::Logic<md::LabelsLogic,md::LabelsContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    BOOL v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

__n128 std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_2,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_2>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56D998;
  __n128 result = *(__n128 *)(a1 + 8);
  *(_OWORD *)(a2 + 24) = *(_OWORD *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_2,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_2>,void ()(md::StyleManagerEvent)>::__clone(uint64_t a1)
{
  unint64_t v2 = (char *)operator new(0x28uLL);
  *(void *)unint64_t v2 = &unk_1EF56D998;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  return result;
}

void std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_2,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_2>,void ()(md::StyleManagerEvent)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_1,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D950;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_1,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF56D950;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_1,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D908;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF56D908;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0>,void ()(void)>::~__func()
{
}

uint64_t md::Logic<md::LabelsLogic,md::LabelsContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::LabelsLogic,md::LabelsContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0xA588623CD4116DAELL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    v8[0] = md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    v8[1] = v7;
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v8, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::LabelsContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::LabelsContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5553C0;
  uint64_t v1 = a1[4];
  if (v1)
  {
    uint64_t v2 = *(std::__shared_weak_count **)(v1 + 8);
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    MEMORY[0x1A6239270](v1, 0x20C40960023A9);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::LabelsContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5553C0;
  uint64_t v2 = a1[4];
  if (v2)
  {
    uint64_t v3 = *(std::__shared_weak_count **)(v2 + 8);
    if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
    MEMORY[0x1A6239270](v2, 0x20C40960023A9);
  }
  return a1;
}

void md::LabelsLogic::createDebugNode(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = (void *)a3;
  md::LogicBase::createDebugNode(a1, a3);
  uint64_t v5 = *(uint64_t ***)(a1 + 192);
  if (v5)
  {
    float v57 = v4;
    while (1)
    {
      unint64_t v6 = *((unsigned __int8 *)v5 + 16);
      uint64_t v7 = "<Invalid>";
      if (v6 <= 6) {
        uint64_t v7 = off_1E5A99FA0[v6];
      }
      unint64_t v8 = v5[3];
      size_t v9 = strlen(v7);
      if (v9 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      std::string::size_type v10 = v9;
      if (v9 >= 0x17) {
        break;
      }
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v9;
      p_dst = &__dst;
      if (v9) {
        goto LABEL_14;
      }
LABEL_15:
      p_dst->__r_.__value_.__s.__data_[v10] = 0;
      if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__init_copy_ctor_external(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = __dst;
      }
      LOBYTE(v61) = 0;
      memset(v62, 0, sizeof(v62));
      char v63 = 0;
      BYTE7(v166[1]) = 11;
      strcpy((char *)v166, "Layout Zoom");
      float v14 = *((float *)v8 + 118);
      uint64_t v161 = 0;
      uint64_t v162 = 0;
      uint64_t v160 = 0;
      int v163 = 2;
      double v159 = v14;
      gdc::DebugTreeNode::addProperty((uint64_t)&__p, (uint64_t)v166, (uint64_t)v158);
      unint64_t v15 = (id)v8[27];
      dispatch_time_t v16 = dispatch_time(0, 500000000);
      intptr_t v17 = dispatch_semaphore_wait(v15, v16);

      if (!v17)
      {
        uint64_t v19 = (char *)operator new(0x20uLL);
        *(void *)&v166[0] = v19;
        *(long long *)((char *)v166 + 8) = xmmword_1A28FD190;
        strcpy(v19, "Is Background Update Running");
        uint64_t v20 = *((unsigned __int8 *)v8 + 3385);
        memset(&v156[4], 0, 24);
        int v157 = 0;
        v156[0] = v20;
        gdc::DebugTreeNode::addProperty((uint64_t)&__p, (uint64_t)v166, (uint64_t)v156);
        operator delete(v19);
        unint64_t v21 = (char *)operator new(0x20uLL);
        *(void *)&v166[0] = v21;
        *(long long *)((char *)v166 + 8) = xmmword_1A28FCDC0;
        strcpy(v21, "Route traffic features active");
        unsigned int v22 = (*(uint64_t (**)(void))(**(void **)(v8[21] + 48) + 16))(*(void *)(v8[21] + 48));
        memset(&v154[4], 0, 24);
        int v155 = 0;
        v154[0] = v22;
        gdc::DebugTreeNode::addProperty((uint64_t)&__p, (uint64_t)v166, (uint64_t)v154);
        operator delete(v21);
        BYTE7(v166[1]) = 14;
        strcpy((char *)v166, "Loading Counts");
        ChildNode = gdc::DebugTreeNode::createChildNode((uint64_t)&__p, v166);
        BYTE7(v166[1]) = 5;
        strcpy((char *)v166, "image");
        uint64_t v24 = atomic_load((unsigned int *)(v8[33] + 140));
        uint64_t v150 = 0;
        uint64_t v151 = 0;
        uint64_t v152 = 0;
        int v153 = 1;
        uint64_t v149 = v24;
        gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v166, (uint64_t)v148);
        if (SBYTE7(v166[1]) < 0) {
          operator delete(*(void **)&v166[0]);
        }
        BYTE7(v166[1]) = 8;
        strcpy((char *)v166, "textData");
        uint64_t v25 = atomic_load((unsigned int *)(v8[34] + 56));
        uint64_t v144 = 0;
        uint64_t v145 = 0;
        uint64_t v146 = 0;
        int v147 = 1;
        uint64_t v143 = v25;
        gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v166, (uint64_t)v142);
        if (SBYTE7(v166[1]) < 0) {
          operator delete(*(void **)&v166[0]);
        }
        BYTE7(v166[1]) = 10;
        strcpy((char *)v166, "glyphImage");
        uint64_t v26 = atomic_load((unsigned int *)(v8[35] + 64));
        uint64_t v138 = 0;
        uint64_t v139 = 0;
        uint64_t v140 = 0;
        int v141 = 1;
        uint64_t v137 = v26;
        gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v166, (uint64_t)v136);
        if (SBYTE7(v166[1]) < 0) {
          operator delete(*(void **)&v166[0]);
        }
        BYTE7(v166[1]) = 15;
        strcpy((char *)v166, "totalGlyphCount");
        uint64_t v27 = (*(uint64_t (**)(void))(**(void **)v8[35] + 24))(*(void *)v8[35]);
        uint64_t v132 = 0;
        uint64_t v133 = 0;
        uint64_t v134 = 0;
        int v135 = 1;
        uint64_t v131 = v27;
        gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v166, (uint64_t)v130);
        uint64_t v28 = (char *)operator new(0x28uLL);
        *(void *)&v166[0] = v28;
        *(long long *)((char *)v166 + 8) = xmmword_1A28FD520;
        strcpy(v28, "glyphsUsingLargeScaleFactorCount");
        uint64_t v29 = (*(uint64_t (**)(void))(**(void **)v8[35] + 32))(*(void *)v8[35]);
        uint64_t v126 = 0;
        uint64_t v127 = 0;
        uint64_t v128 = 0;
        int v129 = 1;
        uint64_t v125 = v29;
        gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v166, (uint64_t)v124);
        operator delete(v28);
        BYTE7(v166[1]) = 19;
        strcpy((char *)v166, "Staging Glyph Cache");
        float v30 = gdc::DebugTreeNode::createChildNode((uint64_t)&__p, v166);
        BYTE7(v166[1]) = 9;
        strcpy((char *)v166, "cacheHits");
        uint64_t v31 = *(unsigned int *)(v8[393] + 144);
        uint64_t v121 = 0;
        uint64_t v122 = 0;
        uint64_t v120 = 0;
        int v123 = 1;
        uint64_t v119 = v31;
        gdc::DebugTreeNode::addProperty((uint64_t)v30, (uint64_t)v166, (uint64_t)v118);
        uint64_t v32 = *(unsigned int *)(v8[393] + 148);
        BYTE7(v166[1]) = 11;
        strcpy((char *)v166, "cacheMisses");
        uint64_t v115 = 0;
        uint64_t v116 = 0;
        uint64_t v114 = 0;
        int v117 = 1;
        uint64_t v113 = v32;
        gdc::DebugTreeNode::addProperty((uint64_t)v30, (uint64_t)v166, (uint64_t)v112);
        uint64_t v33 = *(unsigned int *)(v8[393] + 152);
        BYTE7(v166[1]) = 15;
        strcpy((char *)v166, "cachedItemCount");
        uint64_t v109 = 0;
        uint64_t v110 = 0;
        uint64_t v108 = 0;
        int v111 = 1;
        uint64_t v107 = v33;
        gdc::DebugTreeNode::addProperty((uint64_t)v30, (uint64_t)v166, (uint64_t)v106);
        BYTE7(v166[1]) = 19;
        strcpy((char *)v166, "Display Glyph Cache");
        float v34 = gdc::DebugTreeNode::createChildNode((uint64_t)&__p, v166);
        BOOL v35 = *(unsigned int **)(v8[38] + 128);
        BYTE7(v166[1]) = 9;
        strcpy((char *)v166, "cacheHits");
        uint64_t v36 = v35[36];
        uint64_t v103 = 0;
        uint64_t v104 = 0;
        uint64_t v102 = 0;
        int v105 = 1;
        uint64_t v101 = v36;
        gdc::DebugTreeNode::addProperty((uint64_t)v34, (uint64_t)v166, (uint64_t)v100);
        uint64_t v37 = v35[37];
        BYTE7(v166[1]) = 11;
        strcpy((char *)v166, "cacheMisses");
        uint64_t v97 = 0;
        uint64_t v98 = 0;
        uint64_t v96 = 0;
        int v99 = 1;
        uint64_t v95 = v37;
        gdc::DebugTreeNode::addProperty((uint64_t)v34, (uint64_t)v166, (uint64_t)v94);
        uint64_t v38 = v35[38];
        BYTE7(v166[1]) = 15;
        strcpy((char *)v166, "cachedItemCount");
        uint64_t v91 = 0;
        uint64_t v92 = 0;
        uint64_t v90 = 0;
        int v93 = 1;
        uint64_t v89 = v38;
        gdc::DebugTreeNode::addProperty((uint64_t)v34, (uint64_t)v166, (uint64_t)v88);
        BYTE7(v166[1]) = 8;
        strcpy((char *)v166, "Renderer");
        BOOL v39 = gdc::DebugTreeNode::createChildNode((uint64_t)&__p, v166);
        BYTE7(v166[1]) = 11;
        strcpy((char *)v166, "descriptors");
        uint64_t v40 = *(unsigned int *)(v8[41] + 1808);
        uint64_t v85 = 0;
        uint64_t v86 = 0;
        uint64_t v84 = 0;
        int v87 = 1;
        uint64_t v83 = v40;
        gdc::DebugTreeNode::addProperty((uint64_t)v39, (uint64_t)v166, (uint64_t)v82);
        uint64_t v41 = (*(_DWORD *)(v8[41] + 1812) + *(_DWORD *)(v8[41] + 1816));
        BYTE7(v166[1]) = 11;
        strcpy((char *)v166, "renderItems");
        uint64_t v79 = 0;
        uint64_t v80 = 0;
        uint64_t v78 = 0;
        int v81 = 1;
        uint64_t v77 = v41;
        gdc::DebugTreeNode::addProperty((uint64_t)v39, (uint64_t)v166, (uint64_t)v76);
        uint64_t v42 = *(unsigned int *)(v8[41] + 1812);
        BYTE7(v166[1]) = 17;
        strcpy((char *)v166, "glyph renderItems");
        uint64_t v73 = 0;
        uint64_t v74 = 0;
        uint64_t v72 = 0;
        int v75 = 1;
        uint64_t v71 = v42;
        gdc::DebugTreeNode::addProperty((uint64_t)v39, (uint64_t)v166, (uint64_t)v70);
        uint64_t v43 = *(unsigned int *)(v8[41] + 1816);
        BYTE7(v166[1]) = 16;
        strcpy((char *)v166, "icon renderItems");
        uint64_t v67 = 0;
        uint64_t v68 = 0;
        uint64_t v66 = 0;
        int v69 = 1;
        uint64_t v65 = v43;
        gdc::DebugTreeNode::addProperty((uint64_t)v39, (uint64_t)v166, (uint64_t)v64);
        uint64_t v44 = v8[32];
        char v171 = 15;
        strcpy((char *)&v170, "Texture Atlases");
        id v45 = gdc::DebugTreeNode::createChildNode((uint64_t)&__p, &v170);
        char v171 = 5;
        strcpy((char *)&v170, "atlas");
        uint64_t v4 = v57;
        (*(void (**)(long long *__return_ptr))(**(void **)(v44 + 8) + 48))(&v164);
        long long v167 = 0uLL;
        uint64_t v168 = 0;
        int v169 = 4;
        if (SHIBYTE(v165) < 0)
        {
          std::string::__assign_no_alias<true>(&v167, (void *)v164, *((size_t *)&v164 + 1));
        }
        else
        {
          long long v167 = v164;
          uint64_t v168 = v165;
        }
        gdc::DebugTreeNode::addProperty((uint64_t)v45, (uint64_t)&v170, (uint64_t)v166);
        if (SHIBYTE(v168) < 0)
        {
          operator delete((void *)v167);
          if (SHIBYTE(v165) < 0) {
            goto LABEL_34;
          }
        }
        else
        {
          if ((SHIBYTE(v165) & 0x80000000) == 0) {
            goto LABEL_31;
          }
LABEL_34:
          operator delete((void *)v164);
        }
LABEL_31:
        char v171 = 5;
        strcpy((char *)&v170, "atlas");
        (*(void (**)(long long *__return_ptr))(**(void **)(v44 + 16) + 48))(&v164);
        long long v167 = 0uLL;
        uint64_t v168 = 0;
        int v169 = 4;
        if (SHIBYTE(v165) < 0)
        {
          std::string::__assign_no_alias<true>(&v167, (void *)v164, *((size_t *)&v164 + 1));
        }
        else
        {
          long long v167 = v164;
          uint64_t v168 = v165;
        }
        gdc::DebugTreeNode::addProperty((uint64_t)v45, (uint64_t)&v170, (uint64_t)v166);
        if (SHIBYTE(v168) < 0)
        {
          operator delete((void *)v167);
          if ((SHIBYTE(v165) & 0x80000000) == 0) {
            goto LABEL_38;
          }
        }
        else if ((SHIBYTE(v165) & 0x80000000) == 0)
        {
LABEL_38:
          (*(void (**)(uint64_t, std::string *, uint64_t))(*(void *)v8[30] + 288))(v8[30], &__p, a2);
          float v46 = (id)v8[27];
          dispatch_semaphore_signal(v46);

          goto LABEL_39;
        }
        operator delete((void *)v164);
        goto LABEL_38;
      }
      uint8x8_t v18 = (char *)operator new(0x30uLL);
      *(void *)&v166[0] = v18;
      *(long long *)((char *)v166 + 8) = xmmword_1A28FD510;
      strcpy(v18, "<<Unable to lock label background state>>");
      gdc::DebugTreeNode::createChildNode((uint64_t)&__p, v166);
      operator delete(v18);
LABEL_39:
      gdc::DebugTreeNode::addChildNode(v4, (long long *)&__p);
      unint64_t v47 = *(void ***)((char *)&v62[1] + 9);
      if (*(void *)((char *)&v62[1] + 9))
      {
        uint64_t v48 = *(void *)((char *)&v62[2] + 1);
        uint64_t v49 = *(void **)((char *)&v62[1] + 9);
        if (*(void *)((char *)&v62[2] + 1) != *(void *)((char *)&v62[1] + 9))
        {
          do
          {
            uint64_t v50 = *(void *)(v48 - 24);
            if (v50)
            {
              uint64_t v51 = *(void *)(v48 - 16);
              uint64_t v52 = *(void **)(v48 - 24);
              if (v51 != v50)
              {
                do
                {
                  if (*(char *)(v51 - 1) < 0) {
                    operator delete(*(void **)(v51 - 24));
                  }
                  v51 -= 24;
                }
                while (v51 != v50);
                uint64_t v52 = *(void **)(v48 - 24);
              }
              *(void *)(v48 - 16) = v50;
              operator delete(v52);
            }
            uint64_t v53 = *(void *)(v48 - 48);
            if (v53)
            {
              uint64_t v54 = *(void *)(v48 - 40);
              uint64_t v55 = *(void **)(v48 - 48);
              if (v54 != v53)
              {
                do
                {
                  if (*(char *)(v54 - 9) < 0) {
                    operator delete(*(void **)(v54 - 32));
                  }
                  v54 -= 64;
                }
                while (v54 != v53);
                uint64_t v55 = *(void **)(v48 - 48);
              }
              *(void *)(v48 - 40) = v53;
              operator delete(v55);
            }
            unint64_t v56 = (void **)(v48 - 80);
            if (*(char *)(v48 - 57) < 0) {
              operator delete(*v56);
            }
            v48 -= 80;
          }
          while (v56 != v47);
          uint64_t v49 = *(void **)((char *)&v62[1] + 9);
        }
        *(void *)((char *)&v62[2] + 1) = v47;
        operator delete(v49);
      }
      std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)((char *)v62 + 1));
      if (SLOBYTE(v62[0]) < 0)
      {
        operator delete(v61);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_3;
        }
LABEL_67:
        if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_4;
        }
LABEL_68:
        operator delete(__dst.__r_.__value_.__l.__data_);
        uint64_t v5 = (uint64_t **)*v5;
        if (!v5) {
          return;
        }
      }
      else
      {
        if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
          goto LABEL_67;
        }
LABEL_3:
        operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_68;
        }
LABEL_4:
        uint64_t v5 = (uint64_t **)*v5;
        if (!v5) {
          return;
        }
      }
    }
    uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v9 | 7) != 0x17) {
      uint64_t v12 = v9 | 7;
    }
    uint64_t v13 = v12 + 1;
    p_dst = (std::string *)operator new(v12 + 1);
    __dst.__r_.__value_.__l.__size_ = v10;
    __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
LABEL_14:
    memmove(p_dst, v7, v10);
    goto LABEL_15;
  }
}

void sub_1A1F72BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,gdc::DebugTreeNode *a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,void *__p,uint64_t a45,int a46,__int16 a47,char a48,char a49,char a50)
{
  operator delete(v50);
  gdc::DebugTreeNode::~DebugTreeNode((gdc::DebugTreeNode *)&a50);
  if (a49 < 0) {
    operator delete(__p);
  }
  gdc::DebugTreeNode::~DebugTreeNode(a37);
  _Unwind_Resume(a1);
}

void md::LabelsLogic::~LabelsLogic(md::LabelsLogic *this)
{
  md::LabelsLogic::~LabelsLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void **v2;
  void **v3;
  md::LabelManager **i;
  void *v5;
  void *v6;
  std::__shared_weak_count *v7;
  uint64_t v8;
  uint64_t j;
  std::__shared_weak_count *v10;
  void *v11;
  void *v12;
  std::__shared_weak_count *v13;
  void *v14;
  std::__shared_weak_count *v15;
  md::LabelManagerCreationParams *v16;
  uint64_t v17;
  id *v18;
  std::__shared_weak_count *v19;
  std::__shared_weak_count *v20;

  *(void *)this = &unk_1EF530B00;
  uint64_t v2 = (void **)((char *)this + 192);
  uint64_t v3 = (void **)((char *)this + 176);
  for (uint64_t i = (md::LabelManager **)((char *)this + 192); ; md::LabelManager::willShutdown(i[3]))
  {
    uint64_t i = (md::LabelManager **)*i;
    if (!i) {
      break;
    }
  }
  if (*((void *)this + 25))
  {
    uint64_t v5 = *v2;
    while (v5)
    {
      unint64_t v6 = v5;
      uint64_t v5 = (void *)*v5;
      uint64_t v7 = (std::__shared_weak_count *)v6[4];
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
      operator delete(v6);
    }
    *((void *)this + 24) = 0;
    unint64_t v8 = *((void *)this + 23);
    if (v8)
    {
      for (j = 0; j != v8; ++j)
        *((void *)*v3 + j) = 0;
    }
    *((void *)this + 25) = 0;
  }
  std::string::size_type v10 = (std::__shared_weak_count *)*((void *)this + 30);
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v11 = *v2;
  while (v11)
  {
    uint64_t v12 = v11;
    uint64_t v11 = (void *)*v11;
    uint64_t v13 = (std::__shared_weak_count *)v12[4];
    if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
      std::__shared_weak_count::__release_weak(v13);
    }
    operator delete(v12);
  }
  float v14 = *v3;
  *uint64_t v3 = 0;
  if (v14) {
    operator delete(v14);
  }
  unint64_t v15 = (std::__shared_weak_count *)*((void *)this + 21);
  if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  dispatch_time_t v16 = (md::LabelManagerCreationParams *)*((void *)this + 19);
  *((void *)this + 19) = 0;
  if (v16)
  {
    md::LabelManagerCreationParams::~LabelManagerCreationParams(v16);
    MEMORY[0x1A6239270]();
  }
  intptr_t v17 = *((void *)this + 18);
  *((void *)this + 18) = 0;
  if (v17)
  {
    uint8x8_t v18 = *(id **)(v17 + 40);
    *(void *)(v17 + 40) = 0;
    if (v18)
    {
      md::LabelSettingsData::~LabelSettingsData(v18);
      MEMORY[0x1A6239270]();
    }
    uint64_t v19 = *(std::__shared_weak_count **)(v17 + 32);
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    MEMORY[0x1A6239270](v17, 0x20C40A759441BLL);
  }
  uint64_t v20 = (std::__shared_weak_count *)*((void *)this + 16);
  if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void sub_1A1F72FDC(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 232);
  std::unordered_map<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>::~unordered_map[abi:nn180100](v2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 160);
  std::unique_ptr<md::LabelManagerCreationParams>::~unique_ptr[abi:nn180100]((md::LabelManagerCreationParams **)(v1 + 152));
  std::unique_ptr<md::LabelSettings>::~unique_ptr[abi:nn180100]((uint64_t *)(v1 + 144));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 120);
  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic(v1);
  _Unwind_Resume(a1);
}

void md::LabelManagerCreationParams::~LabelManagerCreationParams(md::LabelManagerCreationParams *this)
{
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }

  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 10);
    if (!v4) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 10);
    if (!v4) {
      goto LABEL_10;
    }
  }
  if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
LABEL_10:
  *((void *)this + 2) = &unk_1EF559798;
}

md::LabelManagerCreationParams **std::unique_ptr<md::LabelManagerCreationParams>::~unique_ptr[abi:nn180100](md::LabelManagerCreationParams **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::LabelManagerCreationParams::~LabelManagerCreationParams(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

uint64_t *std::unique_ptr<md::LabelSettings>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = *(id **)(v2 + 40);
    *(void *)(v2 + 40) = 0;
    if (v3)
    {
      md::LabelSettingsData::~LabelSettingsData(v3);
      MEMORY[0x1A6239270]();
    }
    uint64_t v4 = *(std::__shared_weak_count **)(v2 + 32);
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    MEMORY[0x1A6239270](v2, 0x20C40A759441BLL);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<md::LabelManager>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<md::LabelManager>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F958;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelManager>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57F958;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<md::LabelManagerDelegates>::__on_zero_shared(void *a1)
{
  uint64_t v2 = a1 + 39;
  uint64_t v3 = (void *)a1[42];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = (void *)a1[38];
  if (v4 == a1 + 35)
  {
    (*(void (**)(void *))(a1[35] + 32))(a1 + 35);
  }
  else if (v4)
  {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  uint64_t v5 = (void *)a1[34];
  if (v5 == a1 + 31)
  {
    (*(void (**)(void *))(a1[31] + 32))(a1 + 31);
  }
  else if (v5)
  {
    (*(void (**)(void *))(*v5 + 40))(v5);
  }
  unint64_t v6 = (void *)a1[30];
  if (v6 == a1 + 27)
  {
    (*(void (**)(void *))(a1[27] + 32))(a1 + 27);
  }
  else if (v6)
  {
    (*(void (**)(void *))(*v6 + 40))(v6);
  }
  uint64_t v7 = (void *)a1[26];
  if (v7 == a1 + 23)
  {
    (*(void (**)(void *))(a1[23] + 32))(a1 + 23);
  }
  else if (v7)
  {
    (*(void (**)(void *))(*v7 + 40))(v7);
  }
  unint64_t v8 = (void *)a1[22];
  if (v8 == a1 + 19)
  {
    (*(void (**)(void *))(a1[19] + 32))(a1 + 19);
  }
  else if (v8)
  {
    (*(void (**)(void *))(*v8 + 40))(v8);
  }
  size_t v9 = (void *)a1[18];
  if (v9 == a1 + 15)
  {
    (*(void (**)(void *))(a1[15] + 32))(a1 + 15);
  }
  else if (v9)
  {
    (*(void (**)(void *))(*v9 + 40))(v9);
  }
  std::string::size_type v10 = (void *)a1[14];
  if (v10 == a1 + 11)
  {
    (*(void (**)(void *))(a1[11] + 32))(a1 + 11);
  }
  else if (v10)
  {
    (*(void (**)(void *))(*v10 + 40))(v10);
  }
  uint64_t v11 = a1 + 3;
  uint64_t v12 = (void *)a1[10];
  if (v12 == a1 + 7)
  {
    (*(void (**)(void *))(a1[7] + 32))(a1 + 7);
  }
  else if (v12)
  {
    (*(void (**)(void *))(*v12 + 40))(v12);
  }
  uint64_t result = a1[6];
  if ((void *)result == v11)
  {
    unint64_t v15 = *(uint64_t (**)(void *))(*v11 + 32);
    return v15(a1 + 3);
  }
  else if (result)
  {
    float v14 = *(uint64_t (**)(void))(*(void *)result + 40);
    return v14();
  }
  return result;
}

void std::__shared_ptr_emplace<md::LabelManagerDelegates>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581280;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelManagerDelegates>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581280;
  std::__shared_weak_count::~__shared_weak_count(this);
}

md::LabelManager *md::LabelsLogic::setLabelMode(md::LabelManager *result, unsigned int a2)
{
  uint64_t v4 = *MEMORY[0x1E4F143B8];
  if (*((unsigned __int8 *)result + 3553) != a2)
  {
    *((unsigned char *)result + 3553) = a2;
    v2[0] = &unk_1EF56E058;
    v2[1] = result;
    v2[2] = a2;
    uint64_t v3 = (md::LabelManager *)v2;
    md::LabelManager::queueCommand(result, 7, 1, v2);
    uint64_t result = v3;
    if (v3 == (md::LabelManager *)v2)
    {
      return (md::LabelManager *)(*(uint64_t (**)(void *))(v2[0] + 32))(v2);
    }
    else if (v3)
    {
      return (md::LabelManager *)(*(uint64_t (**)(void))(*(void *)v3 + 40))();
    }
  }
  return result;
}

void sub_1A1F738B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (a13) {
    (*(void (**)(void))(*a13 + 40))();
  }
  _Unwind_Resume(exception_object);
}

void *md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0::~$_0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0,std::allocator<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0>,void ()(md::LabelManager const*,md::NeedsLayoutReason)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t std::__function::__func<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0,std::allocator<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0>,void ()(md::LabelManager const*,md::NeedsLayoutReason)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56DA28;
  uint64_t v4 = a2 + 1;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
  }
  else
  {
    a2[4] = 0;
  }
  a2[5] = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0,std::allocator<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0>,void ()(md::LabelManager const*,md::NeedsLayoutReason)>::~__func(void *a1)
{
  *a1 = &unk_1EF56DA28;
  uint64_t v1 = a1 + 1;
  uint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0,std::allocator<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0>,void ()(md::LabelManager const*,md::NeedsLayoutReason)>::~__func(void *a1)
{
  *a1 = &unk_1EF56DA28;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

void *md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0::~$_0(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0,std::allocator<md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0>,void ()(md::LabelManager *)>::destroy(uint64_t a1)
{
  uint64_t v1 = a1 + 8;
  uint64_t result = *(void *)(a1 + 32);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t std::__function::__func<md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0,std::allocator<md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0>,void ()(md::LabelManager *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF56D9E0;
  uint64_t v4 = a2 + 1;
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (result == a1 + 8)
    {
      a2[4] = v4;
      uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 32) + 24))(*(void *)(a1 + 32));
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v4);
      a2[4] = result;
    }
  }
  else
  {
    a2[4] = 0;
  }
  a2[5] = *(void *)(a1 + 40);
  return result;
}

void std::__function::__func<md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0,std::allocator<md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0>,void ()(md::LabelManager *)>::~__func(void *a1)
{
  *a1 = &unk_1EF56D9E0;
  uint64_t v1 = a1 + 1;
  uint64_t v2 = (void *)a1[4];
  if (v2 == v1)
  {
    (*(void (**)(void *))(*v1 + 32))(v1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0,std::allocator<md::LabelsLogic::setDidLayoutCallback(std::function<void ()(md::LabelManager *)>)::$_0>,void ()(md::LabelManager *)>::~__func(void *a1)
{
  *a1 = &unk_1EF56D9E0;
  uint64_t v2 = a1 + 1;
  uint64_t v3 = (void *)a1[4];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  return a1;
}

__n128 std::__function::__func<md::LabelsLogic::labelManagerSource(gdc::WorldType)::$_0,std::allocator<md::LabelsLogic::labelManagerSource(gdc::WorldType)::$_0>,std::shared_ptr<md::LabelManager> ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF57D638;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::LabelsLogic::labelManagerSource(gdc::WorldType)::$_0,std::allocator<md::LabelsLogic::labelManagerSource(gdc::WorldType)::$_0>,std::shared_ptr<md::LabelManager> ()(void)>::~__func()
{
}

void ggl::BuildingFacadeDepth::BuildingPipelineState::~BuildingPipelineState(ggl::BuildingFacadeDepth::BuildingPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

uint64_t ggl::BuildingFacadeDepth::BuildingPipelineSetup::textureIsEnabled(ggl::BuildingFacadeDepth::BuildingPipelineSetup *this)
{
  return 0;
}

BOOL ggl::BuildingFacadeDepth::BuildingPipelineSetup::constantDataIsEnabled(ggl::BuildingFacadeDepth::BuildingPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

void ggl::BuildingFacadeDepth::BuildingPipelineSetup::~BuildingPipelineSetup(ggl::BuildingFacadeDepth::BuildingPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void ggl::StandardPostchain::SSAOPipelineState::~SSAOPipelineState(ggl::StandardPostchain::SSAOPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::StandardPostchain::SSAOPipelineSetup::textureIsEnabled(ggl::StandardPostchain::SSAOPipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::StandardPostchain::SSAOPipelineSetup::constantDataIsEnabled(ggl::StandardPostchain::SSAOPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

void ggl::StandardPostchain::SSAOPipelineSetup::~SSAOPipelineSetup(ggl::StandardPostchain::SSAOPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t altitude::DebugRenderUtil::flush(altitude::DebugRenderUtil *this, ggl::CommandBuffer *a2, const RenderTargetFormat *a3)
{
  uint64_t v3 = (char *)*((void *)this + 3);
  uint64_t v4 = (char *)this + 32;
  if (v3 == (char *)this + 32)
  {
    char v6 = 0;
  }
  else
  {
    char v6 = 0;
    do
    {
      char v7 = (*(uint64_t (**)(void, ggl::CommandBuffer *, const RenderTargetFormat *))(**((void **)v3 + 5)
                                                                                               + 24))(*((void *)v3 + 5), a2, a3);
      unint64_t v8 = (char *)*((void *)v3 + 1);
      if (v8)
      {
        do
        {
          size_t v9 = v8;
          unint64_t v8 = *(char **)v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          size_t v9 = (char *)*((void *)v3 + 2);
          BOOL v10 = *(void *)v9 == (void)v3;
          uint64_t v3 = v9;
        }
        while (!v10);
      }
      v6 |= v7;
      uint64_t v3 = v9;
    }
    while (v9 != v4);
  }
  return v6 & 1;
}

void altitude::DebugRenderUtil::~DebugRenderUtil(altitude::DebugRenderUtil *this)
{
  *(void *)this = &unk_1EF569000;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::__tree<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::__map_value_compare<altitude::DebugRenderFeatureId,std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::less<altitude::DebugRenderFeatureId>,true>,std::allocator<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>>>::destroy(*((void **)this + 4));
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;

  *(void *)this = &unk_1EF569000;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  std::__tree<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::__map_value_compare<altitude::DebugRenderFeatureId,std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::less<altitude::DebugRenderFeatureId>,true>,std::allocator<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>>>::destroy(*((void **)this + 4));
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void std::__tree<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::__map_value_compare<altitude::DebugRenderFeatureId,std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::less<altitude::DebugRenderFeatureId>,true>,std::allocator<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::__map_value_compare<altitude::DebugRenderFeatureId,std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::less<altitude::DebugRenderFeatureId>,true>,std::allocator<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>>>::destroy(*a1);
    std::__tree<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::__map_value_compare<altitude::DebugRenderFeatureId,std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>,std::less<altitude::DebugRenderFeatureId>,true>,std::allocator<std::__value_type<altitude::DebugRenderFeatureId,std::unique_ptr<altitude::DebugRenderFeature>>>>::destroy(a1[1]);
    uint64_t v2 = a1[5];
    a1[5] = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    operator delete(a1);
  }
}

void altitude::SphereColorFeature::createDrawable(altitude::SphereColorFeature *this)
{
  uint64_t v1 = *(void *)(*((void *)this + 1) + 16);
  if (v1) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v1 + 8), 1uLL, memory_order_relaxed);
  }
  operator new();
}

uint64_t std::__shared_ptr_emplace<ggl::Drawable>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (std::__shared_weak_count *)a1[6];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = a1[4];
  a1[4] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t result = a1[3];
  a1[3] = 0;
  if (result)
  {
    uint64_t v5 = *(uint64_t (**)(void))(*(void *)result + 8);
    return v5();
  }
  return result;
}

void std::__shared_ptr_emplace<ggl::Drawable>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589A20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Drawable>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589A20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::ShadedColor::Props>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::ShadedColor::Props>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::ShadedColor::Props>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::ShadedColor::Props>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585B58;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::ShadedColor::Props>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF585B58;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL altitude::DebugRenderFeature::onFlush(altitude::DebugRenderFeature *this, ggl::CommandBuffer *a2)
{
  unint64_t v4 = *((void *)this + 8);
  if (v4 != *((void *)this + 9))
  {
    unint64_t v4 = *((void *)this + 9);
    do
    {
      uint64_t v5 = (__n128 *)*((void *)this + 3);
      if ((unint64_t)v5 >= *((void *)this + 4))
      {
        unint64_t v8 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)this + 16, *(__n128 *)(v4 - 16));
      }
      else
      {
        unint64_t v7 = *(void *)(v4 - 16);
        unint64_t v6 = *(void *)(v4 - 8);
        v5->n128_u64[0] = v7;
        v5->n128_u64[1] = v6;
        if (v6) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
        }
        unint64_t v8 = v5 + 1;
      }
      *((void *)this + 3) = v8;
      uint64_t v9 = *((void *)this + 9);
      BOOL v10 = *(std::__shared_weak_count **)(v9 - 8);
      if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
      unint64_t v4 = v9 - 16;
      *((void *)this + 9) = v9 - 16;
    }
    while (*((void *)this + 8) != v9 - 16);
  }
  unint64_t v11 = *((void *)this + 5);
  uint64_t v12 = (uint64_t **)*((void *)this + 6);
  if ((uint64_t **)v11 == v12)
  {
    int64x2_t v16 = vdupq_n_s64(v4);
    int64x2_t v15 = vdupq_n_s64(v11);
  }
  else
  {
    uint64_t v13 = (uint64_t **)*((void *)this + 5);
    do
    {
      float v14 = *v13;
      v13 += 2;
      ggl::CommandBuffer::pushRenderItem((uint64_t)a2, *v14);
    }
    while (v13 != v12);
    int64x2_t v15 = *(int64x2_t *)((char *)this + 40);
    int64x2_t v16 = *((int64x2_t *)this + 4);
  }
  BOOL result = v11 != (void)v12;
  *(int64x2_t *)((char *)this + 40) = v16;
  *((int64x2_t *)this + 4) = v15;
  uint64_t v18 = *((void *)this + 7);
  *((void *)this + 7) = *((void *)this + 10);
  *((void *)this + 10) = v18;
  return result;
}

uint64_t altitude::DebugRenderFeatureT<(altitude::DebugRenderFeatureId)0>::id()
{
  return 0;
}

void altitude::SphereColorFeature::~SphereColorFeature(altitude::SphereColorFeature *this)
{
  *(void *)this = &unk_1EF56A1C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::DebugRenderFeature::~DebugRenderFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF56A1C8;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 14);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 12);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  altitude::DebugRenderFeature::~DebugRenderFeature(this);
}

void altitude::DebugRenderFeature::~DebugRenderFeature(altitude::DebugRenderFeature *this)
{
  *(void *)this = &unk_1EF569EB8;
  uint64_t v2 = *((void *)this + 8);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 9);
    unint64_t v4 = (void *)*((void *)this + 8);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(std::__shared_weak_count **)(v3 - 8);
        if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
          std::__shared_weak_count::__release_weak(v5);
        }
        v3 -= 16;
      }
      while (v3 != v2);
      unint64_t v4 = (void *)*((void *)this + 8);
    }
    *((void *)this + 9) = v2;
    operator delete(v4);
  }
  uint64_t v6 = *((void *)this + 5);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 6);
    unint64_t v8 = (void *)*((void *)this + 5);
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = *(std::__shared_weak_count **)(v7 - 8);
        if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
          std::__shared_weak_count::__release_weak(v9);
        }
        v7 -= 16;
      }
      while (v7 != v6);
      unint64_t v8 = (void *)*((void *)this + 5);
    }
    *((void *)this + 6) = v6;
    operator delete(v8);
  }
  uint64_t v10 = *((void *)this + 2);
  if (v10)
  {
    uint64_t v11 = *((void *)this + 3);
    uint64_t v12 = (void *)*((void *)this + 2);
    if (v11 != v10)
    {
      do
      {
        uint64_t v13 = *(std::__shared_weak_count **)(v11 - 8);
        if (v13)
        {
          if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        v11 -= 16;
      }
      while (v11 != v10);
      uint64_t v12 = (void *)*((void *)this + 2);
    }
    *((void *)this + 3) = v10;
    operator delete(v12);
  }
}

void altitude::DebugRenderFeature::createDrawable(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t std::__shared_ptr_emplace<ggl::ShadedColor::P3NPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ShadedColor::P3NPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583580;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ShadedColor::P3NPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583580;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::DebugRenderUtil::Global>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::DebugRenderUtil::Global>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DebugRenderUtil::Global>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DebugRenderUtil::Global>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586220;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::DebugRenderUtil::Global>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586220;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::DebugRenderUtil::P3NMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::DebugRenderUtil::P3NMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583EE8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::DebugRenderUtil::P3NMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583EE8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::DebugRenderUtil::P3NVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::DebugRenderUtil::P3NVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::DebugRenderUtil::P3NVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DebugRenderUtil::P3NVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DebugRenderUtil::P3NVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5849A0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::DebugRenderUtil::P3NVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5849A0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

__n128 std::__function::__func<md::FrameGraphBuilder::createResource(md::FrameGraphAttachmentDescriptor const&,geo::StringLiteral,unsigned long)::$_0,std::allocator<md::FrameGraphBuilder::createResource(md::FrameGraphAttachmentDescriptor const&,geo::StringLiteral,unsigned long)::$_0>,md::FrameGraphLogicalResource * ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF573038;
  __n128 result = *(__n128 *)(a1 + 8);
  *(void *)(a2 + 24) = *(void *)(a1 + 24);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::FrameGraphBuilder::createResource(md::FrameGraphAttachmentDescriptor const&,geo::StringLiteral,unsigned long)::$_0,std::allocator<md::FrameGraphBuilder::createResource(md::FrameGraphAttachmentDescriptor const&,geo::StringLiteral,unsigned long)::$_0>,md::FrameGraphLogicalResource * ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF573038;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<md::FrameGraphBuilder::createResource(md::FrameGraphAttachmentDescriptor const&,geo::StringLiteral,unsigned long)::$_0,std::allocator<md::FrameGraphBuilder::createResource(md::FrameGraphAttachmentDescriptor const&,geo::StringLiteral,unsigned long)::$_0>,md::FrameGraphLogicalResource * ()(void)>::~__func()
{
}

unsigned __int8 **std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *>(unsigned __int8 **a1, unsigned __int8 **a2, unsigned __int8 **a3, unsigned __int8 **a4)
{
  __n128 result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *>(a1, a2, a3);
  uint64_t v9 = *a4;
  uint64_t v10 = *a3;
  unsigned int v11 = **a4;
  unsigned int v12 = **a3;
  BOOL v13 = v11 >= v12;
  if (v11 == v12) {
    BOOL v13 = *((void *)v9 + 3) + (unint64_t)*((unsigned int *)v9 + 5) >= *((void *)v10 + 3)
  }
                                                                             + (unint64_t)*((unsigned int *)v10
                                                                                                 + 5);
  if (!v13)
  {
    *a3 = v9;
    *a4 = v10;
    float v14 = *a3;
    int64x2_t v15 = *a2;
    unsigned int v16 = **a3;
    unsigned int v17 = **a2;
    BOOL v18 = v16 >= v17;
    if (v16 == v17) {
      BOOL v18 = *((void *)v14 + 3) + (unint64_t)*((unsigned int *)v14 + 5) >= *((void *)v15 + 3)
    }
                                                                                 + (unint64_t)*((unsigned int *)v15 + 5);
    if (!v18)
    {
      *a2 = v14;
      *a3 = v15;
      uint64_t v19 = *a2;
      uint64_t v20 = *a1;
      unsigned int v21 = **a2;
      unsigned int v22 = **a1;
      BOOL v23 = v21 >= v22;
      if (v21 == v22) {
        BOOL v23 = *((void *)v19 + 3) + (unint64_t)*((unsigned int *)v19 + 5) >= *((void *)v20 + 3)
      }
                                                                                   + (unint64_t)*((unsigned int *)v20 + 5);
      if (!v23)
      {
        *a1 = v19;
        *a2 = v20;
      }
    }
  }
  return result;
}

unsigned __int8 **std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *,0>(unsigned __int8 **a1, unsigned __int8 **a2, unsigned __int8 **a3, unsigned __int8 **a4, unsigned __int8 **a5)
{
  __n128 result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *>(a1, a2, a3, a4);
  unsigned int v11 = *a5;
  unsigned int v12 = *a4;
  unsigned int v13 = **a5;
  unsigned int v14 = **a4;
  BOOL v15 = v13 >= v14;
  if (v13 == v14) {
    BOOL v15 = *((void *)v11 + 3) + (unint64_t)*((unsigned int *)v11 + 5) >= *((void *)v12 + 3)
  }
                                                                               + (unint64_t)*((unsigned int *)v12 + 5);
  if (!v15)
  {
    *a4 = v11;
    *a5 = v12;
    unsigned int v16 = *a4;
    unsigned int v17 = *a3;
    unsigned int v18 = **a4;
    unsigned int v19 = **a3;
    BOOL v20 = v18 >= v19;
    if (v18 == v19) {
      BOOL v20 = *((void *)v16 + 3) + (unint64_t)*((unsigned int *)v16 + 5) >= *((void *)v17 + 3)
    }
                                                                                 + (unint64_t)*((unsigned int *)v17 + 5);
    if (!v20)
    {
      *a3 = v16;
      *a4 = v17;
      unsigned int v21 = *a3;
      unsigned int v22 = *a2;
      unsigned int v23 = **a3;
      unsigned int v24 = **a2;
      BOOL v25 = v23 >= v24;
      if (v23 == v24) {
        BOOL v25 = *((void *)v21 + 3) + (unint64_t)*((unsigned int *)v21 + 5) >= *((void *)v22 + 3)
      }
                                                                                   + (unint64_t)*((unsigned int *)v22 + 5);
      if (!v25)
      {
        *a2 = v21;
        *a3 = v22;
        uint64_t v26 = *a2;
        uint64_t v27 = *a1;
        unsigned int v28 = **a2;
        unsigned int v29 = **a1;
        BOOL v30 = v28 >= v29;
        if (v28 == v29) {
          BOOL v30 = *((void *)v26 + 3) + (unint64_t)*((unsigned int *)v26 + 5) >= *((void *)v27 + 3)
        }
                                                                                     + (unint64_t)*((unsigned int *)v27 + 5);
        if (!v30)
        {
          *a1 = v26;
          *a2 = v27;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *>(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v6 = *(a2 - 1);
      uint64_t v7 = *a1;
      unsigned int v8 = *v6;
      unsigned int v9 = **a1;
      BOOL v10 = v8 >= v9;
      if (v8 == v9) {
        BOOL v10 = *((void *)v6 + 3) + (unint64_t)*((unsigned int *)v6 + 5) >= *((void *)v7 + 3)
      }
                                                                                 + (unint64_t)*((unsigned int *)v7 + 5);
      if (!v10)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *,0>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      unsigned int v11 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_1 &,std::unique_ptr<md::FrameGraphLogicalResource> *>(a1, a1 + 1, a1 + 2);
      unsigned int v12 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v13 = 0;
      int v14 = 0;
      break;
  }
  while (2)
  {
    BOOL v15 = *v12;
    unsigned int v16 = *v11;
    unsigned int v17 = **v12;
    unsigned int v18 = **v11;
    BOOL v19 = v17 >= v18;
    if (v17 == v18) {
      BOOL v19 = *((void *)v15 + 3) + (unint64_t)*((unsigned int *)v15 + 5) >= *((void *)v16 + 3)
    }
                                                                                 + (unint64_t)*((unsigned int *)v16 + 5);
    if (v19) {
      goto LABEL_9;
    }
    uint64_t v20 = 0;
    unsigned __int8 *v12 = 0;
    for (uint64_t i = v13; ; i -= 8)
    {
      unsigned int v22 = (char *)a1 + i;
      *((void *)v22 + 2) = 0;
      *((void *)v22 + 3) = v16;
      if (v20)
      {
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v20 + 72));
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v20 + 48));
        MEMORY[0x1A6239270](v20, 0x1070C4044CBF76DLL);
      }
      if (i == -16)
      {
        unsigned int v11 = a1;
        goto LABEL_24;
      }
      unsigned int v16 = *(unsigned __int8 **)((char *)a1 + i + 8);
      unsigned int v23 = *v15;
      unsigned int v24 = *v16;
      if (v23 != v24) {
        break;
      }
      if (*((void *)v15 + 3) + (unint64_t)*((unsigned int *)v15 + 5) >= *((void *)v16 + 3)
                                                                                + (unint64_t)*((unsigned int *)v16 + 5))
        goto LABEL_24;
LABEL_15:
      --v11;
      uint64_t v20 = *((void *)v22 + 2);
    }
    if (v23 < v24) {
      goto LABEL_15;
    }
    unsigned int v11 = (unsigned __int8 **)((char *)a1 + i + 16);
LABEL_24:
    BOOL v25 = *v11;
    *unsigned int v11 = v15;
    if (v25)
    {
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)v25 + 9));
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)v25 + 6));
      MEMORY[0x1A6239270](v25, 0x1070C4044CBF76DLL);
    }
    if (++v14 == 8) {
      return v12 + 1 == a2;
    }
LABEL_9:
    unsigned int v11 = v12;
    v13 += 8;
    if (++v12 != a2) {
      continue;
    }
    return 1;
  }
}

unsigned __int8 **std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_0 &,std::unique_ptr<md::FrameGraphPass> *>(unsigned __int8 **result, unsigned __int8 **a2, unsigned __int8 **a3, unsigned __int8 **a4)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *result;
  unsigned int v6 = **a2;
  unsigned int v7 = **result;
  unsigned int v8 = *a3;
  unsigned int v9 = **a3;
  if (v6 >= v7)
  {
    if (v9 >= v6)
    {
      uint64_t v4 = *a3;
    }
    else
    {
      *a2 = v8;
      *a3 = v4;
      BOOL v10 = *result;
      if (**a2 < **result)
      {
        *BOOL result = *a2;
        *a2 = v10;
        uint64_t v4 = *a3;
      }
    }
  }
  else
  {
    if (v9 < v6)
    {
      *BOOL result = v8;
LABEL_9:
      *a3 = v5;
      uint64_t v4 = v5;
      goto LABEL_11;
    }
    *BOOL result = v4;
    *a2 = v5;
    uint64_t v4 = *a3;
    if (**a3 < v7)
    {
      *a2 = v4;
      goto LABEL_9;
    }
  }
LABEL_11:
  if (**a4 < *v4)
  {
    *a3 = *a4;
    *a4 = v4;
    unsigned int v11 = *a2;
    if (**a3 < **a2)
    {
      *a2 = *a3;
      *a3 = v11;
      unsigned int v12 = *result;
      if (**a2 < **result)
      {
        *BOOL result = *a2;
        *a2 = v12;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_0 &,std::unique_ptr<md::FrameGraphPass> *>(unsigned __int8 **a1, unsigned __int8 **a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 1);
      unsigned int v7 = *a1;
      if (*v6 < **a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      unsigned int v8 = *a1;
      unsigned int v9 = a1[1];
      unsigned int v10 = *v9;
      unsigned int v11 = **a1;
      unsigned int v12 = *(a2 - 1);
      unsigned int v13 = *v12;
      if (v10 >= v11)
      {
        if (v13 < v10)
        {
          a1[1] = v12;
          *(a2 - 1) = v9;
          float v34 = *a1;
          uint64_t v33 = a1[1];
          if (*v33 < **a1)
          {
            *a1 = v33;
            a1[1] = v34;
          }
        }
      }
      else if (v13 >= v10)
      {
        *a1 = v9;
        a1[1] = v8;
        id v45 = *(a2 - 1);
        if (*v45 < v11)
        {
          a1[1] = v45;
          *(a2 - 1) = v8;
        }
      }
      else
      {
        *a1 = v12;
        *(a2 - 1) = v8;
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_0 &,std::unique_ptr<md::FrameGraphPass> *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      unsigned int v23 = a1 + 1;
      unsigned int v24 = a1 + 2;
      BOOL v25 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::FrameGraphBuilder::build(md::FrameGraphResourceRegistry *)::$_0 &,std::unique_ptr<md::FrameGraphPass> *>(a1, a1 + 1, a1 + 2, a1 + 3);
      uint64_t v26 = *(a2 - 1);
      uint64_t v27 = a1[3];
      if (*v26 < *v27)
      {
        *BOOL v25 = v26;
        *(a2 - 1) = v27;
        unsigned int v28 = *v25;
        unsigned int v29 = *v24;
        unsigned int v30 = **v25;
        if (v30 < **v24)
        {
          void *v24 = v28;
          *BOOL v25 = v29;
          uint64_t v31 = *v23;
          if (v30 < **v23)
          {
            a1[1] = v28;
            a1[2] = v31;
            uint64_t v32 = *a1;
            if (v30 < **a1)
            {
              *a1 = v28;
              a1[1] = v32;
            }
          }
        }
      }
      return 1;
    default:
      int v14 = a1 + 2;
      BOOL v15 = a1[2];
      unsigned int v16 = a1[1];
      unsigned int v17 = *a1;
      unsigned int v18 = *v16;
      unsigned int v19 = **a1;
      unsigned int v20 = *v15;
      if (v18 >= v19)
      {
        if (v20 >= v18) {
          goto LABEL_23;
        }
        a1[1] = v15;
        *int v14 = v16;
        unsigned int v21 = a1;
        unsigned int v22 = a1 + 1;
      }
      else
      {
        unsigned int v21 = a1;
        unsigned int v22 = a1 + 2;
        if (v20 < v18) {
          goto LABEL_22;
        }
        *a1 = v16;
        a1[1] = v17;
        unsigned int v21 = a1 + 1;
        unsigned int v22 = a1 + 2;
      }
      if (v20 >= v19) {
        goto LABEL_23;
      }
LABEL_22:
      *unsigned int v21 = v15;
      char *v22 = v17;
LABEL_23:
      BOOL v35 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v36 = 0;
      int v37 = 0;
      break;
  }
  while (1)
  {
    uint64_t v38 = *v35;
    BOOL v39 = *v14;
    if (**v35 < *v39)
    {
      uint64_t v40 = 0;
      *BOOL v35 = 0;
      for (uint64_t i = v36; ; i -= 8)
      {
        uint64_t v42 = (char *)a1 + i;
        *((void *)v42 + 2) = 0;
        *((void *)v42 + 3) = v39;
        if (v40)
        {
          std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v40 + 112));
          std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v40 + 88));
          std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v40 + 64));
          if (*(char *)(v40 + 47) < 0) {
            operator delete(*(void **)(v40 + 24));
          }
          MEMORY[0x1A6239270](v40, 0x1032C4041C7693DLL);
        }
        if (i == -16)
        {
          uint64_t v43 = a1;
          goto LABEL_39;
        }
        BOOL v39 = *(unsigned __int8 **)((char *)a1 + i + 8);
        if (*v38 >= *v39) {
          break;
        }
        uint64_t v40 = *((void *)v42 + 2);
      }
      uint64_t v43 = (unsigned __int8 **)((char *)a1 + i + 16);
LABEL_39:
      uint64_t v44 = *v43;
      *uint64_t v43 = v38;
      if (v44)
      {
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)v44 + 14));
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)v44 + 11));
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)v44 + 8));
        if ((char)v44[47] < 0) {
          operator delete(*((void **)v44 + 3));
        }
        MEMORY[0x1A6239270](v44, 0x1032C4041C7693DLL);
      }
      if (++v37 == 8) {
        return v35 + 1 == a2;
      }
    }
    int v14 = v35;
    v36 += 8;
    if (++v35 == a2) {
      return 1;
    }
  }
}

void *md::RouteWaypointLabelFeature::additionalIconAttributeValues@<X0>(void *this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  *(unsigned char *)(a2 + 24) = 0;
  if (*((unsigned char *)this + 728))
  {
    *(void *)a2 = 0;
    *(void *)(a2 + 8) = 0;
    *(void *)(a2 + 16) = 0;
    uint64_t v3 = (unsigned char *)this[88];
    uint64_t v4 = (unsigned char *)this[89];
    int64_t v5 = v4 - v3;
    if (v4 != v3)
    {
      if (v5 < 0) {
        abort();
      }
      unsigned int v6 = (char *)operator new(v4 - v3);
      *(void *)a2 = v6;
      unsigned int v7 = &v6[4 * (v5 >> 2)];
      *(void *)(a2 + 16) = v7;
      this = memcpy(v6, v3, v5);
      *(void *)(a2 + 8) = v7;
    }
    *(unsigned char *)(a2 + 24) = 1;
  }
  return this;
}

md::BalloonLabelPart *md::RouteWaypointLabelFeature::newIconPart(md::RouteWaypointLabelFeature *this, const md::PartCreationContext *a2)
{
  if (*((unsigned char *)this + 697) == 2)
  {
    {
      operator new();
    }
    uint64_t v3 = (md::LabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                               + 16))(mdm::Allocator::instance(void)::alloc, 912, 8);
    long long v7 = 0u;
    md::IconLabelPart::IconLabelPart((uint64_t)v3, &v7);
    *(void *)uint64_t v4 = &unk_1EF5382A0;
    *(_OWORD *)(v4 + 768) = 0u;
    *(void *)(v4 + 784) = -1;
    *(void *)(v4 + 792) = -1;
    *(void *)(v4 + 800) = -1;
    *(_OWORD *)(v4 + 808) = 0u;
    *(void *)(v4 + 824) = -1;
    *(void *)(v4 + 832) = -1;
    *(void *)(v4 + 840) = -1;
    *(_OWORD *)(v4 + 848) = xmmword_1A28FC750;
    *(_OWORD *)(v4 + 864) = xmmword_1A28FCDA0;
    *(_OWORD *)(v4 + 880) = xmmword_1A28FC750;
    *(void *)(v4 + 904) = 0;
    *(void *)(v4 + 896) = 0;
    *(unsigned char *)(v4 + 660) = 8;
    {
        operator new();
    }
    int64_t v5 = (md::CompositeLabelPart *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                        + 16))(mdm::Allocator::instance(void)::alloc, 648, 8);
    md::WorldSpaceLabelPart::WorldSpaceLabelPart(v5, v3, *((void *)a2 + 1), 50, 1);
    return v5;
  }
  else
  {
    return md::PointLabelFeature::newIconPart(this, a2);
  }
}

void sub_1A1F769D8(mdm::Allocator *a1)
{
  uint64_t v3 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v1, 648);
  _Unwind_Resume((_Unwind_Exception *)a1);
}

uint64_t md::RouteWaypointLabelFeature::populateAdditionalStyleAttributes(unsigned __int8 *a1, uint64_t a2)
{
  uint64_t result = md::PointLabelFeature::populateAdditionalStyleAttributes(a1, a2);
  if (a1[699])
  {
    uint64_t v5 = a1[698];
    unsigned int v6 = *(void **)(a2 + 8);
    unint64_t v7 = *(void *)(a2 + 16);
    if ((unint64_t)v6 < v7)
    {
      if (v6) {
        *unsigned int v6 = ((v5 << 32) | 0x10002) + 7;
      }
      unsigned int v8 = v6 + 1;
LABEL_28:
      *(void *)(a2 + 8) = v8;
      goto LABEL_29;
    }
    uint64_t v9 = ((uint64_t)v6 - *(void *)a2) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      goto LABEL_85;
    }
    uint64_t v11 = v7 - *(void *)a2;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v10)
    {
      uint64_t v12 = 8 * v10;
      uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a2 + 24) + 16))(*(void *)(a2 + 24), 8 * v10, 4);
      unsigned int v13 = (void *)(result + 8 * v9);
      unint64_t v10 = result + v12;
      if (result) {
        *unsigned int v13 = ((v5 << 32) | 0x10002) + 7;
      }
    }
    else
    {
      unsigned int v13 = (void *)(8 * v9);
    }
    unsigned int v8 = v13 + 1;
    uint64_t v15 = *(void *)a2;
    uint64_t v14 = *(void *)(a2 + 8);
    if (v14 == *(void *)a2)
    {
LABEL_26:
      *(void *)a2 = v13;
      *(void *)(a2 + 8) = v8;
      uint64_t v24 = *(void *)(a2 + 16);
      *(void *)(a2 + 16) = v10;
      if (v14) {
        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 24) + 40))(*(void *)(a2 + 24), v14, v24 - v14);
      }
      goto LABEL_28;
    }
    unint64_t v16 = v14 - *(void *)a2 - 8;
    if (v16 < 0x38)
    {
      uint64_t v18 = *(void *)(a2 + 8);
    }
    else if ((unint64_t)(v14 - (void)v13) < 0x20)
    {
      uint64_t v18 = *(void *)(a2 + 8);
    }
    else
    {
      uint64_t v17 = (v16 >> 3) + 1;
      uint64_t v18 = v14 - 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
      unsigned int v19 = v13 - 2;
      unsigned int v20 = (long long *)(v14 - 16);
      uint64_t v21 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *v20;
        *(v19 - 1) = *(v20 - 1);
        *unsigned int v19 = v22;
        v19 -= 2;
        v20 -= 2;
        v21 -= 4;
      }
      while (v21);
      v13 -= v17 & 0x3FFFFFFFFFFFFFFCLL;
      if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_25;
      }
    }
    do
    {
      uint64_t v23 = *(void *)(v18 - 8);
      v18 -= 8;
      *--unsigned int v13 = v23;
    }
    while (v18 != v15);
LABEL_25:
    uint64_t v14 = *(void *)a2;
    goto LABEL_26;
  }
LABEL_29:
  if (!a1[701])
  {
    unsigned int v28 = *(uint64_t **)(a2 + 8);
    goto LABEL_58;
  }
  uint64_t v25 = a1[700];
  uint64_t v26 = *(void **)(a2 + 8);
  unint64_t v27 = *(void *)(a2 + 16);
  if ((unint64_t)v26 >= v27)
  {
    uint64_t v29 = ((uint64_t)v26 - *(void *)a2) >> 3;
    unint64_t v30 = v29 + 1;
    if ((unint64_t)(v29 + 1) >> 61) {
      goto LABEL_85;
    }
    uint64_t v31 = v27 - *(void *)a2;
    if (v31 >> 2 > v30) {
      unint64_t v30 = v31 >> 2;
    }
    if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v30 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v30)
    {
      uint64_t v32 = 8 * v30;
      uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a2 + 24) + 16))(*(void *)(a2 + 24), 8 * v30, 4);
      uint64_t v33 = (void *)(result + 8 * v29);
      unint64_t v30 = result + v32;
      if (result) {
        *uint64_t v33 = ((v25 << 32) | 0x10002) + 82;
      }
    }
    else
    {
      uint64_t v33 = (void *)(8 * v29);
    }
    unsigned int v28 = v33 + 1;
    uint64_t v35 = *(void *)a2;
    uint64_t v34 = *(void *)(a2 + 8);
    if (v34 == *(void *)a2) {
      goto LABEL_55;
    }
    unint64_t v36 = v34 - *(void *)a2 - 8;
    if (v36 < 0x38)
    {
      uint64_t v38 = *(void *)(a2 + 8);
    }
    else if ((unint64_t)(v34 - (void)v33) < 0x20)
    {
      uint64_t v38 = *(void *)(a2 + 8);
    }
    else
    {
      uint64_t v37 = (v36 >> 3) + 1;
      uint64_t v38 = v34 - 8 * (v37 & 0x3FFFFFFFFFFFFFFCLL);
      BOOL v39 = v33 - 2;
      uint64_t v40 = (long long *)(v34 - 16);
      uint64_t v41 = v37 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v42 = *v40;
        *(v39 - 1) = *(v40 - 1);
        _OWORD *v39 = v42;
        v39 -= 2;
        v40 -= 2;
        v41 -= 4;
      }
      while (v41);
      v33 -= v37 & 0x3FFFFFFFFFFFFFFCLL;
      if (v37 == (v37 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_54;
      }
    }
    do
    {
      uint64_t v43 = *(void *)(v38 - 8);
      v38 -= 8;
      *--uint64_t v33 = v43;
    }
    while (v38 != v35);
LABEL_54:
    uint64_t v34 = *(void *)a2;
LABEL_55:
    *(void *)a2 = v33;
    *(void *)(a2 + 8) = v28;
    uint64_t v44 = *(void *)(a2 + 16);
    *(void *)(a2 + 16) = v30;
    if (v34) {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 24) + 40))(*(void *)(a2 + 24), v34, v44 - v34);
    }
    goto LABEL_57;
  }
  if (v26) {
    *uint64_t v26 = ((v25 << 32) | 0x10002) + 82;
  }
  unsigned int v28 = v26 + 1;
LABEL_57:
  *(void *)(a2 + 8) = v28;
LABEL_58:
  uint64_t v45 = a1[696];
  unint64_t v46 = *(void *)(a2 + 16);
  if ((unint64_t)v28 < v46)
  {
    if (v28) {
      uint64_t *v28 = (v45 << 32) | 0x10002;
    }
    unint64_t v47 = v28 + 1;
    goto LABEL_84;
  }
  uint64_t v48 = ((uint64_t)v28 - *(void *)a2) >> 3;
  if ((unint64_t)(v48 + 1) >> 61) {
LABEL_85:
  }
    abort();
  uint64_t v49 = v46 - *(void *)a2;
  uint64_t v50 = v49 >> 2;
  if (v49 >> 2 <= (unint64_t)(v48 + 1)) {
    uint64_t v50 = v48 + 1;
  }
  BOOL v51 = (unint64_t)v49 >= 0x7FFFFFFFFFFFFFF8;
  uint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v51) {
    uint64_t v52 = v50;
  }
  if (v52)
  {
    uint64_t v53 = 8 * v52;
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 24) + 16))(*(void *)(a2 + 24), 8 * v52, 4);
    uint64_t v54 = (uint64_t *)(result + 8 * v48);
    uint64_t v52 = result + v53;
    if (result) {
      *uint64_t v54 = (v45 << 32) | 0x10002;
    }
  }
  else
  {
    uint64_t v54 = (uint64_t *)(8 * v48);
  }
  unint64_t v47 = v54 + 1;
  uint64_t v56 = *(void *)a2;
  uint64_t v55 = *(void *)(a2 + 8);
  if (v55 == *(void *)a2) {
    goto LABEL_82;
  }
  unint64_t v57 = v55 - *(void *)a2 - 8;
  if (v57 < 0x38)
  {
    uint64_t v59 = *(void *)(a2 + 8);
  }
  else if ((unint64_t)(v55 - (void)v54) < 0x20)
  {
    uint64_t v59 = *(void *)(a2 + 8);
  }
  else
  {
    uint64_t v58 = (v57 >> 3) + 1;
    uint64_t v59 = v55 - 8 * (v58 & 0x3FFFFFFFFFFFFFFCLL);
    BOOL v60 = v54 - 2;
    unsigned int v61 = (long long *)(v55 - 16);
    uint64_t v62 = v58 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v63 = *v61;
      *((_OWORD *)v60 - 1) = *(v61 - 1);
      *(_OWORD *)BOOL v60 = v63;
      v60 -= 4;
      v61 -= 2;
      v62 -= 4;
    }
    while (v62);
    v54 -= v58 & 0x3FFFFFFFFFFFFFFCLL;
    if (v58 == (v58 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_81;
    }
  }
  do
  {
    uint64_t v64 = *(void *)(v59 - 8);
    v59 -= 8;
    *--uint64_t v54 = v64;
  }
  while (v59 != v56);
LABEL_81:
  uint64_t v55 = *(void *)a2;
LABEL_82:
  *(void *)a2 = v54;
  *(void *)(a2 + 8) = v47;
  uint64_t v65 = *(void *)(a2 + 16);
  *(void *)(a2 + 16) = v52;
  if (v55) {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 24) + 40))(*(void *)(a2 + 24), v55, v65 - v55);
  }
LABEL_84:
  *(void *)(a2 + 8) = v47;
  return result;
}

void md::RouteWaypointLabelFeature::populateDebugNode(md::RouteWaypointLabelFeature *this, gdc::DebugTreeNode *a2, const md::LabelManager *a3)
{
  md::LabelFeature::populateDebugNode(this, a2, (unint64_t)a3);
  uint64_t v5 = (void *)*((void *)this + 85);
  if (v5)
  {
    char v22 = 8;
    strcpy(v21, "LegIndex");
    id v6 = v5;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    int v20 = 1;
    uint64_t v17 = 0;
    LODWORD(v16) = [v6 legIndex];
    uint64_t v16 = v16;
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v21, (uint64_t)v15);
  }
  if (*((unsigned char *)this + 701))
  {
    char v22 = 7;
    strcpy(v21, "LegWhen");
    unint64_t v7 = gss::to_string(*((unsigned __int8 *)this + 700));
    memset(&__p, 0, sizeof(__p));
    int v14 = 4;
    if (v7)
    {
      std::string::__assign_external(&__p, v7);
    }
    else
    {
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 6;
      strcpy((char *)&__p, "<null>");
    }
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v21, (uint64_t)v12);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  if (*((unsigned char *)this + 699))
  {
    char v22 = 4;
    strcpy(v21, "When");
    unsigned int v8 = gss::to_string(*((unsigned __int8 *)this + 698));
    memset(&v10, 0, sizeof(v10));
    int v11 = 4;
    if (v8)
    {
      std::string::__assign_external(&v10, v8);
    }
    else
    {
      *((unsigned char *)&v10.__r_.__value_.__s + 23) = 6;
      strcpy((char *)&v10, "<null>");
    }
    gdc::DebugTreeNode::addProperty((uint64_t)a2, (uint64_t)v21, (uint64_t)v9);
    if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v10.__r_.__value_.__l.__data_);
    }
  }
}

void sub_1A1F770CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::RouteWaypointLabelFeature::debugString(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int *a3@<X2>, char a4@<W3>, std::string *a5@<X8>)
{
  md::LabelFeature::debugString((unsigned char *)a1, a2, a3, a4, a5);
  std::string::append(a5, "RouteWaypoint:\n", 0xFuLL);
  memset(&v48, 0, sizeof(v48));
  unint64_t v7 = *(void **)(a1 + 680);
  if (v7)
  {
    id v8 = v7;
    std::to_string(&__dst, [v8 legIndex]);
    uint64_t v9 = std::string::insert(&__dst, 0, " LegIndex=", 0xAuLL);
    long long v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    int64_t v47 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    if (v47 >= 0) {
      int v11 = __p;
    }
    else {
      int v11 = (void **)__p[0];
    }
    if (v47 >= 0) {
      std::string::size_type v12 = HIBYTE(v47);
    }
    else {
      std::string::size_type v12 = (std::string::size_type)__p[1];
    }
    std::string::append(&v48, (const std::string::value_type *)v11, v12);
    if (SHIBYTE(v47) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_10;
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_10:

      goto LABEL_11;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    goto LABEL_10;
  }
LABEL_11:
  if (!*(unsigned char *)(a1 + 701)) {
    goto LABEL_28;
  }
  unsigned int v13 = gss::to_string(*(unsigned __int8 *)(a1 + 700));
  size_t v14 = strlen(v13);
  if (v14 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  std::string::size_type v15 = v14;
  if (v14 >= 0x17)
  {
    uint64_t v17 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v17 = v14 | 7;
    }
    uint64_t v18 = v17 + 1;
    p_dst = operator new(v17 + 1);
    __dst.__r_.__value_.__l.__size_ = v15;
    __dst.__r_.__value_.__r.__words[2] = v18 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_19;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v14;
  p_dst = &__dst;
  if (v14) {
LABEL_19:
  }
    memmove(p_dst, v13, v15);
  *((unsigned char *)p_dst + v15) = 0;
  uint64_t v19 = std::string::insert(&__dst, 0, " LegWhen=", 9uLL);
  long long v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  int64_t v47 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  if (v47 >= 0) {
    uint64_t v21 = __p;
  }
  else {
    uint64_t v21 = (void **)__p[0];
  }
  if (v47 >= 0) {
    std::string::size_type v22 = HIBYTE(v47);
  }
  else {
    std::string::size_type v22 = (std::string::size_type)__p[1];
  }
  std::string::append(&v48, (const std::string::value_type *)v21, v22);
  if (SHIBYTE(v47) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_28:
      if (!*(unsigned char *)(a1 + 699)) {
        goto LABEL_53;
      }
      goto LABEL_29;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_28;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
  if (!*(unsigned char *)(a1 + 699)) {
    goto LABEL_53;
  }
LABEL_29:
  uint64_t v23 = gss::to_string(*(unsigned __int8 *)(a1 + 698));
  size_t v24 = strlen(v23);
  if (v24 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  std::string::size_type v25 = v24;
  if (v24 >= 0x17)
  {
    uint64_t v27 = (v24 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v24 | 7) != 0x17) {
      uint64_t v27 = v24 | 7;
    }
    uint64_t v28 = v27 + 1;
    uint64_t v26 = operator new(v27 + 1);
    __dst.__r_.__value_.__l.__size_ = v25;
    __dst.__r_.__value_.__r.__words[2] = v28 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v26;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v24;
    uint64_t v26 = &__dst;
    if (!v24) {
      goto LABEL_37;
    }
  }
  memmove(v26, v23, v25);
LABEL_37:
  *((unsigned char *)v26 + v25) = 0;
  uint64_t v29 = std::string::insert(&__dst, 0, " When=", 6uLL);
  long long v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  int64_t v47 = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)std::string __p = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  if (v47 >= 0) {
    uint64_t v31 = __p;
  }
  else {
    uint64_t v31 = (void **)__p[0];
  }
  if (v47 >= 0) {
    std::string::size_type v32 = HIBYTE(v47);
  }
  else {
    std::string::size_type v32 = (std::string::size_type)__p[1];
  }
  std::string::append(&v48, (const std::string::value_type *)v31, v32);
  if (SHIBYTE(v47) < 0)
  {
    operator delete(__p[0]);
    if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_53;
    }
  }
  else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_53;
  }
  operator delete(__dst.__r_.__value_.__l.__data_);
LABEL_53:
  int v33 = SHIBYTE(v48.__r_.__value_.__r.__words[2]);
  if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    size_t size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
  }
  else {
    size_t size = v48.__r_.__value_.__l.__size_;
  }
  if (size)
  {
    unint64_t v35 = size + 2;
    if (size + 2 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    if (v35 > 0x16)
    {
      uint64_t v37 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v35 | 7) != 0x17) {
        uint64_t v37 = v35 | 7;
      }
      uint64_t v38 = v37 + 1;
      unint64_t v36 = operator new(v37 + 1);
      __dst.__r_.__value_.__l.__size_ = size + 2;
      __dst.__r_.__value_.__r.__words[2] = v38 | 0x8000000000000000;
      __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v36;
    }
    else
    {
      memset(&__dst, 0, sizeof(__dst));
      unint64_t v36 = &__dst;
      *((unsigned char *)&__dst.__r_.__value_.__s + 23) = size + 2;
    }
    *unint64_t v36 = 8224;
    BOOL v39 = v36 + 1;
    if (v33 >= 0) {
      uint64_t v40 = &v48;
    }
    else {
      uint64_t v40 = (std::string *)v48.__r_.__value_.__r.__words[0];
    }
    memmove(v39, v40, size);
    *((unsigned char *)v39 + size) = 0;
    uint64_t v41 = std::string::append(&__dst, "\n", 1uLL);
    std::string::size_type v42 = v41->__r_.__value_.__r.__words[2];
    *(_OWORD *)std::string __p = *(_OWORD *)&v41->__r_.__value_.__l.__data_;
    int64_t v47 = v42;
    v41->__r_.__value_.__l.__size_ = 0;
    v41->__r_.__value_.__r.__words[2] = 0;
    v41->__r_.__value_.__r.__words[0] = 0;
    if (v47 >= 0) {
      uint64_t v43 = __p;
    }
    else {
      uint64_t v43 = (void **)__p[0];
    }
    if (v47 >= 0) {
      std::string::size_type v44 = HIBYTE(v47);
    }
    else {
      std::string::size_type v44 = (std::string::size_type)__p[1];
    }
    std::string::append(a5, (const std::string::value_type *)v43, v44);
    if (SHIBYTE(v47) < 0)
    {
      operator delete(__p[0]);
      if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        goto LABEL_74;
      }
    }
    else if ((SHIBYTE(__dst.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_74:
      LOBYTE(v33) = *((unsigned char *)&v48.__r_.__value_.__s + 23);
      goto LABEL_75;
    }
    operator delete(__dst.__r_.__value_.__l.__data_);
    goto LABEL_74;
  }
LABEL_75:
  if ((v33 & 0x80) != 0) {
    operator delete(v48.__r_.__value_.__l.__data_);
  }
}

void sub_1A1F7752C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a15 < 0)
  {
    operator delete(__p);
    if (a24 < 0)
    {
LABEL_5:
      operator delete(a19);
      if ((*(char *)(v24 + 23) & 0x80000000) == 0) {
        goto LABEL_6;
      }
      goto LABEL_8;
    }
  }
  else if (a24 < 0)
  {
    goto LABEL_5;
  }
  if ((*(char *)(v24 + 23) & 0x80000000) == 0) {
LABEL_6:
  }
    _Unwind_Resume(a1);
LABEL_8:
  operator delete(*(void **)v24);
  _Unwind_Resume(a1);
}

BOOL md::RouteWaypointLabelFeature::isOnRouteFeature(md::RouteWaypointLabelFeature *this)
{
  return *((unsigned char *)this + 697) != 0;
}

uint64_t md::RouteWaypointLabelFeature::isRouteFeature(md::RouteWaypointLabelFeature *this)
{
  return 1;
}

uint64_t md::RouteWaypointLabelFeature::labelFeatureType(md::RouteWaypointLabelFeature *this)
{
  int v1 = *((unsigned __int8 *)this + 697);
  if (v1 == 2) {
    unsigned int v2 = 21;
  }
  else {
    unsigned int v2 = 20;
  }
  if (v1 == 3) {
    return 22;
  }
  else {
    return v2;
  }
}

uint64_t md::RouteWaypointLabelFeature::facingVector(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 697) == 2) {
    return *(void *)(a1 + 736);
  }
  else {
    return 0;
  }
}

uint64_t md::RouteWaypointLabelFeature::updateDynamicStyling(id *this, md::LabelManager *a2, md::Label *a3)
{
  int v5 = objc_msgSend(this[85], "isOnSelectedRoute", a3);
  int v6 = *((unsigned __int8 *)this + 696);
  BOOL v7 = v6 != v5;
  if (v6 != v5) {
    *((unsigned char *)this + 696) = v5;
  }
  if ((((*(uint64_t (**)(void))(**(void **)(*((void *)a2 + 21) + 32) + 8))(*(void *)(*((void *)a2 + 21) + 32)) & 1) != 0
     || (*(unsigned int (**)(void))(**(void **)(*((void *)a2 + 21) + 32) + 32))(*(void *)(*((void *)a2 + 21) + 32)))
    && *((unsigned char *)this + 696))
  {
    unint64_t v8 = (*(uint64_t (**)(void))(**(void **)(*((void *)a2 + 21) + 32) + 48))(*(void *)(*((void *)a2 + 21) + 32));
    if ([this[85] legIndex] <= v8)
    {
      if ([this[85] legIndex] >= v8) {
        unsigned __int8 v9 = 1;
      }
      else {
        unsigned __int8 v9 = 2;
      }
      if (!*((unsigned char *)this + 701)) {
        goto LABEL_17;
      }
    }
    else
    {
      unsigned __int8 v9 = 0;
      if (!*((unsigned char *)this + 701))
      {
LABEL_17:
        *((_WORD *)this + 350) = v9 | 0x100;
        BOOL v7 = 1;
LABEL_18:
        int v11 = [this[85] when];
        int v12 = v11 == 2;
        if (v11 == 3) {
          int v12 = 2;
        }
        if (!*((unsigned char *)this + 699) || v12 != *((unsigned __int8 *)this + 698))
        {
          *((_WORD *)this + 349) = v12 | 0x100;
LABEL_30:
          (*((void (**)(id *, md::LabelManager *))*this + 67))(this, a2);
          return 0;
        }
        goto LABEL_29;
      }
    }
    if (*((unsigned __int8 *)this + 700) == v9) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  if ([this[85] legIndex])
  {
    int v10 = 0;
    if (!*((unsigned char *)this + 701)) {
      goto LABEL_25;
    }
  }
  else
  {
    [this[85] legIndex];
    int v10 = 1;
    if (!*((unsigned char *)this + 701))
    {
LABEL_25:
      *((_WORD *)this + 350) = v10 | 0x100;
      BOOL v7 = 1;
      goto LABEL_26;
    }
  }
  if (*((unsigned __int8 *)this + 700) != v10) {
    goto LABEL_25;
  }
LABEL_26:
  if (!*((unsigned char *)this + 699) || *((unsigned char *)this + 698))
  {
    *((_WORD *)this + 349) = 256;
    goto LABEL_30;
  }
LABEL_29:
  if (v7) {
    goto LABEL_30;
  }
  return 0;
}

uint64_t md::RouteWaypointLabelFeature::newRootPart(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5)
{
  uint64_t v6 = md::PointLabelFeature::newRootPart(a1, a2, a3, a4, a5);
  uint64_t v7 = v6;
  if (v6 && *(_DWORD *)(a1[63] + 84) != 0x7FFFFFFF) {
    (*(void (**)(uint64_t, void))(*(void *)v6 + 824))(v6, (unsigned __int16)~*(_WORD *)(a1[63] + 84));
  }
  return v7;
}

void md::RouteWaypointLabelFeature::~RouteWaypointLabelFeature(md::RouteWaypointLabelFeature *this)
{
  *(void *)this = &unk_1EF546A18;
  if (*((unsigned char *)this + 728))
  {
    unsigned int v2 = (void *)*((void *)this + 88);
    if (v2)
    {
      *((void *)this + 89) = v2;
      operator delete(v2);
    }
  }
  *((void *)this + 84) = &unk_1EF559898;

  md::PointLabelFeature::~PointLabelFeature(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF546A18;
  if (*((unsigned char *)this + 728))
  {
    unsigned int v2 = (void *)*((void *)this + 88);
    if (v2)
    {
      *((void *)this + 89) = v2;
      operator delete(v2);
    }
  }
  *((void *)this + 84) = &unk_1EF559898;

  md::PointLabelFeature::~PointLabelFeature(this);
}

void geo::_retain_ptr<VKRouteWaypointInfo * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559898;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKRouteWaypointInfo * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559898;

  return a1;
}

uint64_t md::LabelExternalPointFeature::isCluster(md::LabelExternalPointFeature *this)
{
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 38);
  if (!v2 || v2->__shared_owners_ == -1) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  uint64_t v4 = *((void *)this + 37);
  if (!v3) {
    uint64_t v4 = 0;
  }
  if (v4 && (uint64_t v5 = *((void *)this + 36)) != 0)
  {
    uint64_t v6 = ((*(unsigned int (**)(uint64_t))(*(void *)v5 + 32))(v5) >> 2) & 1;
    if (!v3) {
      return v6;
    }
  }
  else
  {
    uint64_t v6 = 0;
    if (!v3) {
      return v6;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return v6;
}

void sub_1A1F77B8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::vector<unsigned int>::__assign_with_size[abi:nn180100]<unsigned int *,unsigned int *>(void *result, char *__src, char *a3, size_t __sz)
{
  uint64_t v6 = __src;
  uint64_t v7 = result;
  uint64_t v8 = result[2];
  unsigned __int8 v9 = (char *)*result;
  if (__sz > (v8 - *result) >> 2)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      uint64_t v8 = 0;
      *uint64_t v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (__sz >> 62) {
      goto LABEL_22;
    }
    uint64_t v10 = v8 >> 1;
    if (v8 >> 1 <= __sz) {
      uint64_t v10 = __sz;
    }
    BOOL v11 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL;
    unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    if (!v11) {
      unint64_t v12 = v10;
    }
    if (v12 >> 62) {
LABEL_22:
    }
      abort();
    uint64_t v13 = 4 * v12;
    uint64_t result = operator new(4 * v12);
    unsigned __int8 v9 = (char *)result;
    *uint64_t v7 = result;
    v7[1] = result;
    v7[2] = (char *)result + v13;
    size_t v14 = a3 - v6;
    if (v14) {
      uint64_t result = memcpy(result, v6, v14);
    }
    std::string::size_type v15 = (void **)(v7 + 1);
    goto LABEL_21;
  }
  std::string::size_type v15 = (void **)(result + 1);
  uint64_t v16 = (unsigned char *)result[1];
  unint64_t v17 = (v16 - v9) >> 2;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_21;
    }
    uint64_t v19 = (void *)*result;
LABEL_20:
    uint64_t result = memmove(v19, __src, v14);
    goto LABEL_21;
  }
  uint64_t v18 = &__src[4 * v17];
  if (v16 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v16 - v9);
    unsigned __int8 v9 = (char *)*v15;
  }
  size_t v14 = a3 - v18;
  if (v14)
  {
    uint64_t v19 = v9;
    __src = v18;
    goto LABEL_20;
  }
LABEL_21:
  unsigned __int8 *v15 = &v9[v14];
  return result;
}

uint64_t md::RouteWaypointLabelFeature::RouteWaypointLabelFeature(uint64_t a1, void *a2, char a3, char a4, uint64_t *a5, uint64_t a6)
{
  id v11 = a2;
  md::PointLabelFeature::PointLabelFeature((md::PointLabelFeatureBase *)a1, a5, 0, a6);
  *(void *)a1 = &unk_1EF546A18;
  id v12 = v11;
  *(void *)(a1 + 672) = &unk_1EF559898;
  *(void *)(a1 + 680) = v12;
  *(unsigned char *)(a1 + 696) = a3;
  *(unsigned char *)(a1 + 697) = a4;
  uint64_t v13 = (void *)(a1 + 704);
  *(unsigned char *)(a1 + 704) = 0;
  *(unsigned char *)(a1 + 728) = 0;
  *(unsigned char *)(a1 + 736) = 0;
  *(unsigned char *)(a1 + 748) = 0;
  *(_DWORD *)(a1 + 698) = 0;
  if (md::LabelExternalPointFeature::isCluster((md::LabelExternalPointFeature *)*a5))
  {
    uint64_t v14 = *a5;
    std::string::size_type v15 = *(std::__shared_weak_count **)(*a5 + 304);
    if (v15)
    {
      if (v15->__shared_owners_ != -1)
      {
        uint64_t v16 = std::__shared_weak_count::lock(v15);
        unint64_t v17 = v16;
        if (v16) {
          _ZF = *(void *)(v14 + 296) == 0;
        }
        else {
          _ZF = 1;
        }
        if (_ZF)
        {
          if (!v16) {
            goto LABEL_22;
          }
        }
        else
        {
          uint64_t v19 = *(void *)(v14 + 288);
          if (v19)
          {
            uint64_t v20 = (*(uint64_t (**)(uint64_t))(*(void *)v19 + 80))(v19);
            if (v20)
            {
              if (*(unsigned char *)(a1 + 728))
              {
                if (v13 != (void *)(v20 + 144)) {
                  std::vector<unsigned int>::__assign_with_size[abi:nn180100]<unsigned int *,unsigned int *>((void *)(a1 + 704), *(char **)(v20 + 144), *(char **)(v20 + 152), (uint64_t)(*(void *)(v20 + 152) - *(void *)(v20 + 144)) >> 2);
                }
              }
              else
              {
                *uint64_t v13 = 0;
                *(void *)(a1 + 712) = 0;
                *(void *)(a1 + 720) = 0;
                std::string::size_type v22 = *(unsigned char **)(v20 + 144);
                uint64_t v21 = *(unsigned char **)(v20 + 152);
                int64_t v23 = v21 - v22;
                if (v21 != v22)
                {
                  if (v23 < 0) {
                    abort();
                  }
                  uint64_t v24 = (char *)operator new(v21 - v22);
                  *(void *)(a1 + 704) = v24;
                  *(void *)(a1 + 712) = v24;
                  std::string::size_type v25 = &v24[4 * (v23 >> 2)];
                  *(void *)(a1 + 720) = v25;
                  memcpy(v24, v22, v23);
                  *(void *)(a1 + 712) = v25;
                }
                *(unsigned char *)(a1 + 728) = 1;
              }
            }
          }
        }
        if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
  }
LABEL_22:
  if (*(unsigned char *)(a1 + 697) == 2)
  {
    [v12 routeCoordinate];
    double v76 = v26;
    double v28 = v27;
    double v30 = v29;
    [v12 adjacentRouteCoordinate];
    double v33 = v31;
    double v35 = v34;
    if (vabdd_f64(v28, v31) < 0.00000000999999994 && vabdd_f64(v76, v32) < 0.00000000999999994
      || v76 < -180.0
      || v76 > 180.0
      || v28 < -90.0
      || v28 > 90.0
      || v32 < -180.0
      || v32 > 180.0
      || v31 < -90.0
      || v31 > 90.0)
    {
      if (*(unsigned char *)(*(void *)(a6 + 232) + 17))
      {
        float v36 = 0.0;
        float v37 = 1.0;
        float v38 = -0.0;
      }
      else
      {
        double v42 = md::LabelPoint::geocentricNormal((md::LabelPoint *)(a1 + 192));
        double v44 = -(v42 * v43);
        double v46 = -(v45 * v43);
        double v47 = v45 * v45 + v42 * v42;
        double v48 = 1.0 / sqrt(v44 * v44 + v46 * v46 + v47 * v47);
        double v49 = v48 * v44;
        float v36 = v48 * v47;
        float v38 = v48 * v46;
        float v37 = v49;
      }
      int v50 = *(unsigned __int8 *)(a1 + 748);
      *(float *)(a1 + 736) = v37;
      *(float *)(a1 + 740) = v38;
      *(float *)(a1 + 744) = v36;
      if (!v50) {
        *(unsigned char *)(a1 + 748) = 1;
      }
    }
    else
    {
      double v75 = v32;
      memset(v80, 0, sizeof(v80));
      float v81 = 3.4028e38;
      memset(v82, 0, 3);
      memset(v77, 0, sizeof(v77));
      float v78 = 3.4028e38;
      memset(v79, 0, 3);
      if (fabs(v28) <= 85.0511169)
      {
        long double v51 = tan(v28 * 0.00872664626 + 0.785398163);
        long double v52 = log(v51);
        v53.f64[0] = v76;
        v53.f64[1] = v52;
        __asm { FMOV            V1.2D, #0.5 }
        *(float64x2_t *)&v80[24] = vmlaq_f64(_Q1, (float64x2_t)xmmword_1A28FCBE0, v53);
        *(_WORD *)((char *)v82 + 1) = 257;
      }
      else
      {
        __double2 v39 = __sincos_stret(v28 * 0.0174532925);
        double v40 = 6378137.0 / sqrt(v39.__sinval * v39.__sinval * -0.00669437999 + 1.0);
        __double2 v41 = __sincos_stret(v76 * 0.0174532925);
        *(double *)uint64_t v80 = v40 * v39.__cosval * v41.__cosval;
        *(double *)&v80[8] = v40 * v39.__cosval * v41.__sinval;
        *(double *)&v80[16] = v39.__sinval * 0.99330562 * v40;
        LOBYTE(v82[0]) = 1;
      }
      if (v30 != 1.79769313e308)
      {
        float v58 = v30;
        float v81 = v58;
      }
      if (fabs(v33) <= 85.0511169)
      {
        long double v62 = tan(v33 * 0.00872664626 + 0.785398163);
        long double v63 = log(v62);
        v64.f64[0] = v75;
        v64.f64[1] = v63;
        __asm { FMOV            V1.2D, #0.5 }
        *(float64x2_t *)&v77[24] = vmlaq_f64(_Q1, (float64x2_t)xmmword_1A28FCBE0, v64);
        *(_WORD *)((char *)v79 + 1) = 257;
      }
      else
      {
        __double2 v59 = __sincos_stret(v33 * 0.0174532925);
        double v60 = 6378137.0 / sqrt(v59.__sinval * v59.__sinval * -0.00669437999 + 1.0);
        __double2 v61 = __sincos_stret(v75 * 0.0174532925);
        *(double *)uint64_t v77 = v60 * v59.__cosval * v61.__cosval;
        *(double *)&v77[8] = v60 * v59.__cosval * v61.__sinval;
        *(double *)&v77[16] = v59.__sinval * 0.99330562 * v60;
        LOBYTE(v79[0]) = 1;
      }
      if (v35 != 1.79769313e308)
      {
        float v66 = v35;
        float v78 = v66;
      }
      md::LabelPoint::vectorToPoint((md::LabelPoint *)v80, (const md::LabelPoint *)v77, *(unsigned char *)(*(void *)(a6 + 232) + 17) == 0);
      double v70 = 1.0 / sqrt(v67 * v67 + v68 * v68 + v69 * v69);
      float v71 = v70 * v67;
      float v72 = v70 * v68;
      float v73 = v70 * v69;
      if (!*(unsigned char *)(a1 + 748)) {
        *(unsigned char *)(a1 + 748) = 1;
      }
      *(float *)(a1 + 736) = v71;
      *(float *)(a1 + 740) = v72;
      *(float *)(a1 + 744) = v73;
    }
  }

  return a1;
}

void sub_1A1F782F0(_Unwind_Exception *a1)
{
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
  if (*(unsigned char *)(v1 + 728))
  {
    uint64_t v7 = *v4;
    if (*v4)
    {
      *(void *)(v1 + 712) = v7;
      operator delete(v7);
    }
  }
  *(void *)(v1 + 672) = v3;

  md::PointLabelFeature::~PointLabelFeature((md::PointLabelFeature *)v1);
  _Unwind_Resume(a1);
}

void altitude::RenderableGroup::addRenderable(altitude::RenderableGroup *this, altitude::Renderable *a2)
{
  uint64_t v5 = (void *)*((void *)this + 7);
  unint64_t v4 = *((void *)this + 8);
  uint64_t v6 = (char *)v5;
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v8 = (char *)*((void *)this + 6);
    uint64_t v9 = ((char *)v5 - v8) >> 3;
    unint64_t v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61) {
      abort();
    }
    uint64_t v11 = v4 - (void)v8;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v13 = (char *)operator new(8 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[8 * v9];
    std::string::size_type v15 = &v13[8 * v12];
    *(void *)uint64_t v14 = a2;
    uint64_t v7 = v14 + 8;
    if (v5 == (void *)v8)
    {
      *((void *)this + 6) = v14;
      *((void *)this + 7) = v7;
      *((void *)this + 8) = v15;
    }
    else
    {
      unint64_t v16 = (char *)v5 - v8 - 8;
      if (v16 <= 0x77
        || (char *)v5 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8 < v14
        && &v13[(char *)v5 - v8 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < (char *)v5)
      {
        goto LABEL_35;
      }
      uint64_t v17 = (v16 >> 3) + 1;
      uint64_t v6 = (char *)&v5[-(v17 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v18 = &v13[8 * v9 - 16];
      uint64_t v19 = (long long *)(v5 - 4);
      uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *v19;
        long long v21 = v19[1];
        *uint64_t v19 = 0uLL;
        v19[1] = 0uLL;
        v19 -= 2;
        *((_OWORD *)v18 - 1) = v22;
        *(_OWORD *)uint64_t v18 = v21;
        v18 -= 32;
        v20 -= 4;
      }
      while (v20);
      v14 -= 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
      if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_35:
        do
        {
          uint64_t v23 = *((void *)v6 - 1);
          v6 -= 8;
          *(void *)uint64_t v6 = 0;
          *((void *)v14 - 1) = v23;
          v14 -= 8;
        }
        while (v6 != v8);
      }
      uint64_t v6 = (char *)*((void *)this + 6);
      uint64_t v24 = (char *)*((void *)this + 7);
      *((void *)this + 6) = v14;
      *((void *)this + 7) = v7;
      *((void *)this + 8) = v15;
      while (v24 != v6)
      {
        uint64_t v26 = *((void *)v24 - 1);
        v24 -= 8;
        uint64_t v25 = v26;
        *(void *)uint64_t v24 = 0;
        if (v26) {
          (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
        }
      }
    }
    if (v6) {
      operator delete(v6);
    }
  }
  else
  {
    void *v5 = a2;
    uint64_t v7 = v5 + 1;
  }
  *((void *)this + 7) = v7;
  int v27 = *((unsigned __int8 *)this + 120);
  altitude::Renderable::setDrapesEnabled(a2, v27);
}

void altitude::RenderableGroup::~RenderableGroup(altitude::RenderableGroup *this)
{
  altitude::RenderableGroup::~RenderableGroup(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  char *v3;
  char *v4;
  char *v5;
  std::__shared_weak_count *v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  std::__shared_weak_count *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;

  *(void *)this = &unk_1EF5690C0;
  unsigned int v2 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (char *)*((void *)this + 12);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = (char *)*((void *)this + 12);
    if (!v3) {
      goto LABEL_12;
    }
  }
  unint64_t v4 = (char *)*((void *)this + 13);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = (std::__shared_weak_count *)*((void *)v4 - 1);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 16;
    }
    while (v4 != v3);
    uint64_t v5 = (char *)*((void *)this + 12);
  }
  *((void *)this + 13) = v3;
  operator delete(v5);
LABEL_12:
  uint64_t v7 = *((void *)this + 9);
  if (v7)
  {
    uint64_t v8 = *((void *)this + 10);
    uint64_t v9 = (void *)*((void *)this + 9);
    if (v8 != v7)
    {
      do
      {
        unint64_t v10 = *(std::__shared_weak_count **)(v8 - 8);
        if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
        v8 -= 16;
      }
      while (v8 != v7);
      uint64_t v9 = (void *)*((void *)this + 9);
    }
    *((void *)this + 10) = v7;
    operator delete(v9);
  }
  uint64_t v11 = (void *)*((void *)this + 6);
  if (v11)
  {
    unint64_t v12 = (void *)*((void *)this + 7);
    uint64_t v13 = (void *)*((void *)this + 6);
    if (v12 != v11)
    {
      do
      {
        std::string::size_type v15 = *--v12;
        uint64_t v14 = v15;
        unsigned __int8 *v12 = 0;
        if (v15) {
          (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
        }
      }
      while (v12 != v11);
      uint64_t v13 = (void *)*((void *)this + 6);
    }
    *((void *)this + 7) = v11;
    operator delete(v13);
  }
  *(void *)this = &unk_1EF562D20;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

void ggl::NamedBase<std::string>::~NamedBase(uint64_t a1)
{
  *(void *)a1 = &unk_1EF562D20;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::NamedBase<std::string>::~NamedBase(uint64_t a1)
{
  *(void *)a1 = &unk_1EF562D20;
  if (*(char *)(a1 + 31) < 0) {
    operator delete(*(void **)(a1 + 8));
  }
  return a1;
}

void altitude::RenderableGroup::takeOwnership(void *a1, long long *a2)
{
  if (*(void *)a2)
  {
    uint64_t v5 = (char *)a1[10];
    unint64_t v4 = a1[11];
    if ((unint64_t)v5 >= v4)
    {
      uint64_t v8 = (char *)a1[9];
      uint64_t v9 = (v5 - v8) >> 4;
      unint64_t v10 = v9 + 1;
      if ((unint64_t)(v9 + 1) >> 60) {
        abort();
      }
      uint64_t v11 = v4 - (void)v8;
      if (v11 >> 3 > v10) {
        unint64_t v10 = v11 >> 3;
      }
      BOOL v12 = (unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0;
      unint64_t v13 = 0xFFFFFFFFFFFFFFFLL;
      if (!v12) {
        unint64_t v13 = v10;
      }
      if (v13 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v14 = 16 * v13;
      std::string::size_type v15 = (char *)operator new(16 * v13);
      unint64_t v16 = &v15[16 * v9];
      long long v17 = *a2;
      *(_OWORD *)unint64_t v16 = *a2;
      if (*((void *)&v17 + 1))
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v17 + 1) + 8), 1uLL, memory_order_relaxed);
        uint64_t v8 = (char *)a1[9];
        uint64_t v5 = (char *)a1[10];
      }
      uint64_t v18 = &v15[v14];
      uint64_t v7 = v16 + 16;
      if (v5 == v8)
      {
        a1[9] = v16;
        a1[10] = v7;
        a1[11] = v18;
      }
      else
      {
        do
        {
          long long v19 = *((_OWORD *)v5 - 1);
          v5 -= 16;
          *((_OWORD *)v16 - 1) = v19;
          v16 -= 16;
          *(void *)uint64_t v5 = 0;
          *((void *)v5 + 1) = 0;
        }
        while (v5 != v8);
        uint64_t v8 = (char *)a1[9];
        uint64_t v20 = (char *)a1[10];
        a1[9] = v16;
        a1[10] = v7;
        for (a1[11] = v18; v20 != v8; v20 -= 16)
        {
          long long v21 = (std::__shared_weak_count *)*((void *)v20 - 1);
          if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
        }
      }
      if (v8) {
        operator delete(v8);
      }
    }
    else
    {
      uint64_t v6 = *((void *)a2 + 1);
      *(void *)uint64_t v5 = *(void *)a2;
      *((void *)v5 + 1) = v6;
      if (v6) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v7 = v5 + 16;
    }
    a1[10] = v7;
  }
}

void altitude::RenderableGroup::dropOwnership(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unint64_t v4 = *(void **)(a1 + 72);
    uint64_t v3 = *(void **)(a1 + 80);
    if (v4 != v3)
    {
      while (*v4 != a2)
      {
        v4 += 2;
        if (v4 == v3)
        {
          unint64_t v4 = *(void **)(a1 + 80);
          break;
        }
      }
    }
    uint64_t v5 = v4 + 2;
    if (v4 + 2 != v3)
    {
      do
      {
        unint64_t v4 = v5;
        long long v6 = *(_OWORD *)v5;
        void *v5 = 0;
        v5[1] = 0;
        uint64_t v7 = (std::__shared_weak_count *)*(v5 - 1);
        *((_OWORD *)v5 - 1) = v6;
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        uint64_t v5 = v4 + 2;
      }
      while (v4 + 2 != v3);
      uint64_t v3 = *(void **)(a1 + 80);
    }
    for (; v3 != v4; v3 -= 2)
    {
      uint64_t v8 = (std::__shared_weak_count *)*(v3 - 1);
      if (v8)
      {
        if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
    *(void *)(a1 + 80) = v4;
  }
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::PolylineOverlayRibbon::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

void non-virtual thunk to'ggl::PolylineOverlayRibbon::BaseMesh::~BaseMesh(ggl::PolylineOverlayRibbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh((ggl::PolylineOverlayRibbon::BaseMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::PolylineOverlayRibbon::BaseMesh *)((char *)this - 16));
}

void ggl::PolylineOverlayRibbon::BaseMesh::~BaseMesh(ggl::PolylineOverlayRibbon::BaseMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::PolylineOverlayRibbon::DefaultVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::PolylineOverlayRibbon::DefaultVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::PolylineOverlayRibbon::BakedWidthMesh::~BakedWidthMesh(ggl::PolylineOverlayRibbon::BakedWidthMesh *this)
{
  ggl::Mesh::~Mesh((ggl::PolylineOverlayRibbon::BakedWidthMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::PolylineOverlayRibbon::BakedWidthMesh *)((char *)this - 16));
}

void ggl::PolylineOverlayRibbon::BakedWidthMesh::~BakedWidthMesh(ggl::PolylineOverlayRibbon::BakedWidthMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::PolylineOverlayRibbon::BakedWidthVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::PolylineOverlayRibbon::BakedWidthVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::PolylineOverlayRibbon::BakedWidthMesh::BakedWidthMesh(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  {
    std::string::size_type v15 = a3;
    uint64_t v22 = a2;
    a2 = v22;
    a3 = v15;
    if (v16)
    {
      {
        ggl::MeshTyped<ggl::PolylineOverlayRibbon::BakedWidthVbo>::attributesReflection(void)::r = (uint64_t)&ggl::PolylineOverlayRibbon::bakedWidthVboReflection;
      }
      ggl::MeshTyped<ggl::PolylineOverlayRibbon::BakedWidthVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::PolylineOverlayRibbon::BakedWidthVbo>::attributesReflection(void)::r;
      *(void *)algn_1E958F768 = 1;
      a3 = v15;
      a2 = v22;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EF5606B0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1EF5606D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = &ggl::MeshTyped<ggl::PolylineOverlayRibbon::BakedWidthVbo>::typedReflection(void)::r;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  {
    uint64_t v20 = a3;
    a3 = v20;
    uint64_t v6 = a1 + 64;
    if (v17) {
      operator new();
    }
  }
  uint64_t v7 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = a1 + 120;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v7;
  {
    long long v21 = a3;
    uint64_t v23 = v6;
    uint64_t v8 = a1 + 120;
    a3 = v21;
    int v19 = v18;
    uint64_t v6 = v23;
    if (v19) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = v8;
  *(void *)a1 = &unk_1EF562620;
  *(void *)(a1 + 16) = &unk_1EF562640;
  uint64_t v9 = a3[1];
  uint64_t v24 = *a3;
  uint64_t v25 = (std::__shared_weak_count *)v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(v6, &v24, &v26, 1uLL);
  unint64_t v10 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v12 = *a4;
  uint64_t v11 = a4[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v13 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 104) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)a1 = &unk_1EF55F8C8;
  *(void *)(a1 + 16) = &unk_1EF55F8E8;
  return a1;
}

void non-virtual thunk to'ggl::PolylineOverlayRibbon::ElevatedMesh::~ElevatedMesh(ggl::PolylineOverlayRibbon::ElevatedMesh *this)
{
  ggl::Mesh::~Mesh((ggl::PolylineOverlayRibbon::ElevatedMesh *)((char *)this - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::PolylineOverlayRibbon::ElevatedMesh *)((char *)this - 16));
}

void ggl::PolylineOverlayRibbon::ElevatedMesh::~ElevatedMesh(ggl::PolylineOverlayRibbon::ElevatedMesh *this)
{
  ggl::Mesh::~Mesh(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'ggl::MeshTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>::~MeshTyped(uint64_t a1)
{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
  JUMPOUT(0x1A6239270);
}

{
  ggl::Mesh::~Mesh((ggl::Mesh *)(a1 - 16));
}

void ggl::MeshTyped<ggl::PolylineOverlayRibbon::ElevatedVbo>::~MeshTyped(ggl::Mesh *a1)
{
  ggl::Mesh::~Mesh(a1);
  JUMPOUT(0x1A6239270);
}

void md::MultipleShieldLabelPart::debugCompositeClassName(char *a1@<X8>)
{
  a1[23] = 15;
  strcpy(a1, "MultipleShields");
}

uint64_t md::MultipleShieldLabelPart::clone(md::MultipleShieldLabelPart *this)
{
  {
    operator new();
  }
  uint64_t v2 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 704, 8);
  md::LabelPart::LabelPart((md::LabelPart *)v2, this);
  *(void *)uint64_t v2 = &unk_1EF538820;
  *(void *)(v2 + 576) = 0;
  *(void *)(v2 + 592) = 0;
  *(void *)(v2 + 584) = 0;
  {
    operator new();
  }
  *(void *)(v2 + 600) = mdm::Allocator::instance(void)::alloc;
  *(unsigned char *)(v2 + 608) = 0;
  *(unsigned char *)(v2 + 616) = 0;
  *(_WORD *)(v2 + 628) = 1;
  *(unsigned char *)(v2 + 630) = 0;
  uint64_t v3 = (void *)*((void *)this + 72);
  for (uint64_t i = (void *)*((void *)this + 73); v3 != i; ++v3)
  {
    uint64_t v5 = (md::LabelPart *)(*(uint64_t (**)(void))(*(void *)*v3 + 888))(*v3);
    if (v5) {
      md::CompositeLabelPart::addLabelPart(v2, v5);
    }
  }
  *(void *)uint64_t v2 = &unk_1EF5435A0;
  *(void *)(v2 + 632) = *((void *)this + 79);
  uint64_t v6 = *((void *)this + 80);
  *(void *)(v2 + 640) = v6;
  if (v6) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v6 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v7 = *((void *)this + 81);
  *(void *)(v2 + 655) = *(void *)((char *)this + 655);
  *(void *)(v2 + 648) = v7;
  *(void *)(v2 + 664) = *((void *)this + 83);
  uint64_t v8 = *((void *)this + 84);
  *(void *)(v2 + 672) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v9 = *((void *)this + 85);
  *(void *)(v2 + 687) = *(void *)((char *)this + 687);
  *(void *)(v2 + 680) = v9;
  *(unsigned char *)(v2 + 696) = *((unsigned char *)this + 696);
  return v2;
}

void sub_1A1F7981C(mdm::Allocator *a1)
{
  uint64_t v3 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v1, 704);
  _Unwind_Resume((_Unwind_Exception *)a1);
}

void md::MultipleShieldLabelPart::setPosition(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v3 = a1 + 632;
  uint64_t v4 = 664;
  if (a2) {
    uint64_t v3 = a1 + 664;
  }
  else {
    uint64_t v4 = 632;
  }
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + v4) = v6;
  uint64_t v7 = *(std::__shared_weak_count **)(v3 + 8);
  *(void *)(v3 + 8) = v5;
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t md::MultipleShieldLabelPart::setUseExternalLayoutOptions(uint64_t result, int a2, char a3)
{
  uint64_t v3 = result + 632;
  if (a2) {
    uint64_t v3 = result + 664;
  }
  *(unsigned char *)(v3 + 30) = a3;
  return result;
}

uint64_t md::MultipleShieldLabelPart::setLayoutInReverse(uint64_t result, int a2, char a3)
{
  uint64_t v3 = result + 632;
  if (a2) {
    uint64_t v3 = result + 664;
  }
  *(unsigned char *)(v3 + 29) = a3;
  return result;
}

uint64_t md::MultipleShieldLabelPart::setLayoutStartOffset(uint64_t result, int a2, float a3)
{
  uint64_t v3 = result + 632;
  if (a2) {
    uint64_t v3 = result + 664;
  }
  *(float *)(v3 + 20) = a3;
  return result;
}

uint64_t md::MultipleShieldLabelPart::setAlignment(uint64_t result, int a2, char a3)
{
  uint64_t v3 = result + 632;
  if (a2) {
    uint64_t v3 = result + 664;
  }
  *(unsigned char *)(v3 + 28) = a3;
  return result;
}

uint64_t md::MultipleShieldLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4)
{
  (*(void (**)(std::mutex **__return_ptr))(**(void **)(a1 + 664) + 32))(&v20);
  if (v20) {
    BOOL v11 = v21 == 0;
  }
  else {
    BOOL v11 = 0;
  }
  if (v11)
  {
    if (*(_DWORD *)(a1 + 688)) {
      uint64_t v12 = 37;
    }
    else {
      uint64_t v12 = 31;
    }
  }
  else
  {
    int8x16_t v19 = (int8x16_t)xmmword_1A28FC750;
    uint64_t v12 = md::MultipleShieldLabelPart::placeShieldsOnPath(a1, 1, a2 + 440, a2, a3, a4, &v19);
    if (v12 == 37)
    {
      md::CollisionObject::resetWithRects((void **)(a1 + 312), 1u);
      uint64_t v13 = *(void *)(a1 + 472);
      uint64_t v14 = *(unsigned int *)(a1 + 488);
      *(_DWORD *)(a1 + 488) = v14 + 1;
      int8x16_t v15 = v19;
      *(int8x16_t *)(v13 + 16 * v14) = v19;
      int8x16_t v9 = *(int8x16_t *)(a1 + 312);
      v16.i64[0] = v15.i64[0];
      v16.i64[1] = *(void *)(a1 + 320);
      v17.i64[0] = *(void *)(a1 + 312);
      v17.i64[1] = v15.i64[1];
      int8x16_t v10 = (int8x16_t)vcgtq_f32(v17, v16);
      int8x16_t v8 = vbslq_s8(v10, v15, v9);
      *(int8x16_t *)(a1 + 312) = v8;
      *(_DWORD *)(a1 + 688) = *(_DWORD *)(a2 + 1616);
    }
  }
  *(_DWORD *)(a1 + 520) = a4->i32[0];
  *(_DWORD *)(a1 + 524) = a4->i32[1];
  *(_DWORD *)(a1 + 344) = a4->i32[0];
  v8.i32[0] = a4->i32[1];
  *(_DWORD *)(a1 + 348) = v8.i32[0];
  md::CollisionObject::setupShapeData(a1 + 312, *(double *)v8.i64, *(double *)v9.i64, *(double *)v10.i64);
  if (v21) {
    std::mutex::unlock(v20);
  }
  return v12;
}

void sub_1A1F79AFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, char a12)
{
  if (a12) {
    std::mutex::unlock(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::MultipleShieldLabelPart::updateForDisplay(uint64_t this)
{
  uint64_t v1 = this;
  uint64_t v2 = *(uint64_t **)(this + 576);
  for (uint64_t i = *(uint64_t **)(this + 584); v2 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 112))(v4))
    uint64_t v4 = *v2++;
  *(_DWORD *)(v1 + 680) = *(_DWORD *)(v1 + 648);
  if (*(unsigned char *)(v1 + 696))
  {
    *(unsigned char *)(v1 + 696) = 0;
    uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v1 + 632) + 24);
    return v5();
  }
  return this;
}

uint64_t md::MultipleShieldLabelPart::prepareForDisplay(uint64_t this, LabelManager *a2)
{
  uint64_t v2 = this;
  uint64_t v3 = *(uint64_t **)(this + 576);
  for (uint64_t i = *(uint64_t **)(this + 584);
        v3 != i;
        this = (*(uint64_t (**)(uint64_t, LabelManager *))(*(void *)v6 + 104))(v6, a2))
  {
    uint64_t v6 = *v3++;
  }
  if (!*(unsigned char *)(v2 + 662))
  {
    uint64_t v7 = *(uint64_t (**)(void))(**(void **)(v2 + 632) + 24);
    return v7();
  }
  return this;
}

void md::MultipleShieldLabelPart::~MultipleShieldLabelPart(md::MultipleShieldLabelPart *this)
{
  *(void *)this = &unk_1EF5435A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 84);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 80);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  md::CompositeLabelPart::~CompositeLabelPart(this);
  {
    operator new();
  }
  uint64_t v4 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
  v4();
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF5435A0;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 84);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 80);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 80);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::CompositeLabelPart::~CompositeLabelPart(this);
}

void md::MaterialTextureManager::purge(pthread_rwlock_t *this)
{
  uint64_t v2 = (geo::read_write_lock *)pthread_rwlock_wrlock(this);
  if (v2) {
    geo::read_write_lock::logFailure(v2, (uint64_t)"write lock", v3);
  }
  if (*(void *)&this[1].__opaque[16])
  {
    uint64_t v4 = *(void **)&this[1].__opaque[8];
    while (v4)
    {
      uint64_t v5 = v4;
      uint64_t v4 = (void *)*v4;
      uint64_t v6 = (std::__shared_weak_count *)v5[5];
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      operator delete(v5);
    }
    *(void *)&this[1].__opaque[8] = 0;
    uint64_t v7 = *(void *)this[1].__opaque;
    if (v7)
    {
      for (uint64_t i = 0; i != v7; ++i)
        *(void *)(this[1].__sig + 8 * i) = 0;
    }
    *(void *)&this[1].__opaque[16] = 0;
  }
  if (*(void *)&this[1].__opaque[56])
  {
    int8x16_t v9 = *(void **)&this[1].__opaque[48];
    while (v9)
    {
      int8x16_t v10 = v9;
      int8x16_t v9 = (void *)*v9;
      BOOL v11 = (std::__shared_weak_count *)v10[5];
      if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      operator delete(v10);
    }
    *(void *)&this[1].__opaque[48] = 0;
    uint64_t v12 = *(void *)&this[1].__opaque[40];
    if (v12)
    {
      for (uint64_t j = 0; j != v12; ++j)
        *(void *)(*(void *)&this[1].__opaque[32] + 8 * j) = 0;
    }
    *(void *)&this[1].__opaque[56] = 0;
  }
  uint64_t v14 = (geo::read_write_lock *)pthread_rwlock_unlock(this);
  if (v14)
  {
    geo::read_write_lock::logFailure(v14, (uint64_t)"unlock", v15);
  }
}

void geo::read_write_lock::~read_write_lock(pthread_rwlock_t *this)
{
  uint64_t v1 = (geo::read_write_lock *)pthread_rwlock_destroy(this);
  if (v1) {
    geo::read_write_lock::logFailure(v1, (uint64_t)"destruction", v2);
  }
}

{
  geo::read_write_lock *v1;
  const char *v2;

  uint64_t v1 = (geo::read_write_lock *)pthread_rwlock_destroy(this);
  if (v1) {
    geo::read_write_lock::logFailure(v1, (uint64_t)"destruction", v2);
  }
}

uint64_t std::__function::__func<md::MaterialTextureManager::_textureFromMaterial(std::shared_ptr<gms::Material<ggl::Texture2D>> const&,unsigned long long const&,gms::PropertyKey const&,unsigned char,std::shared_ptr<ggl::SamplerState> &,BOOL)::$_0,std::allocator<md::MaterialTextureManager::_textureFromMaterial(std::shared_ptr<gms::Material<ggl::Texture2D>> const&,unsigned long long const&,gms::PropertyKey const&,unsigned char,std::shared_ptr<ggl::SamplerState> &,BOOL)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)v4, **(void **)(a1 + 8));
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 24))(v2, v4);
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  if (v6) {
    return (*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

void sub_1A1F7A204(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19)
{
  if (a19 == v19 + 48)
  {
    (*(void (**)(uint64_t))(a16 + 32))(v19 + 48);
    _Unwind_Resume(exception_object);
  }
  if (a19) {
    (*(void (**)(void))(*(void *)a19 + 40))();
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::MaterialTextureManager::_textureFromMaterial(std::shared_ptr<gms::Material<ggl::Texture2D>> const&,unsigned long long const&,gms::PropertyKey const&,unsigned char,std::shared_ptr<ggl::SamplerState> &,BOOL)::$_0,std::allocator<md::MaterialTextureManager::_textureFromMaterial(std::shared_ptr<gms::Material<ggl::Texture2D>> const&,unsigned long long const&,gms::PropertyKey const&,unsigned char,std::shared_ptr<ggl::SamplerState> &,BOOL)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF575A68;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::MaterialTextureManager::_textureFromMaterial(std::shared_ptr<gms::Material<ggl::Texture2D>> const&,unsigned long long const&,gms::PropertyKey const&,unsigned char,std::shared_ptr<ggl::SamplerState> &,BOOL)::$_0,std::allocator<md::MaterialTextureManager::_textureFromMaterial(std::shared_ptr<gms::Material<ggl::Texture2D>> const&,unsigned long long const&,gms::PropertyKey const&,unsigned char,std::shared_ptr<ggl::SamplerState> &,BOOL)::$_0>,void ()(ggl::ResourceAccessor *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF575A68;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::MaterialTextureManager::_textureFromMaterial(std::shared_ptr<gms::Material<ggl::Texture2D>> const&,unsigned long long const&,gms::PropertyKey const&,unsigned char,std::shared_ptr<ggl::SamplerState> &,BOOL)::$_0,std::allocator<md::MaterialTextureManager::_textureFromMaterial(std::shared_ptr<gms::Material<ggl::Texture2D>> const&,unsigned long long const&,gms::PropertyKey const&,unsigned char,std::shared_ptr<ggl::SamplerState> &,BOOL)::$_0>,void ()(ggl::ResourceAccessor *)>::~__func()
{
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<md::MaterialTextureManager::TextureKey,std::shared_ptr<md::SharedTexture2D>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::MaterialTextureManager::TextureKey,std::shared_ptr<md::SharedTexture2D>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = (std::__shared_weak_count *)v2[5];
      if (v3)
      {
        if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
        }
      }
    }
    operator delete(v2);
  }
  return a1;
}

void std::allocate_shared[abi:nn180100]<md::ColorRampTexture,std::allocator<md::ColorRampTexture>,unsigned int const&,float const&,std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>> &,md::SharedResourcesManager *&,void>(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5 = operator new(0x50uLL);
  v5[1] = 0;
  v5[2] = 0;
  void *v5 = &unk_1EF5801E0;
  void v5[3] = 0;
  v5[4] = 0;
  void v5[5] = a3;
  *((_DWORD *)v5 + 12) = 0;
  v5[7] = 0;
  __double2 v39 = 0;
  uint64_t v40 = 0;
  float v38 = &v39;
  if (a2)
  {
    uint64_t v6 = 0;
    uint64_t v7 = &v39;
    while (1)
    {
      int8x16_t v8 = &v39;
      if (v7 == &v39) {
        goto LABEL_9;
      }
      int8x16_t v9 = v6;
      int8x16_t v10 = &v39;
      if (v6)
      {
        do
        {
          int8x16_t v8 = (uint64_t **)v9;
          int8x16_t v9 = (uint64_t *)v9[1];
        }
        while (v9);
      }
      else
      {
        do
        {
          int8x16_t v8 = (uint64_t **)v10[2];
          BOOL v11 = *v8 == (uint64_t *)v10;
          int8x16_t v10 = v8;
        }
        while (v11);
      }
      float v12 = *((float *)a2 + 4);
      if (*((float *)v8 + 7) < v12)
      {
LABEL_9:
        uint64_t v13 = v6 ? v8 : &v39;
        uint64_t v14 = v6 ? v8 + 1 : &v39;
      }
      else
      {
        uint64_t v13 = &v39;
        uint64_t v14 = &v39;
        if (v6)
        {
          uint64_t v14 = &v39;
          while (1)
          {
            while (1)
            {
              uint64_t v13 = (uint64_t **)v6;
              float v16 = *((float *)v6 + 7);
              if (v12 >= v16) {
                break;
              }
              uint64_t v6 = (uint64_t *)*v6;
              uint64_t v14 = v13;
              if (!*v13) {
                goto LABEL_16;
              }
            }
            if (v16 >= v12) {
              break;
            }
            uint64_t v14 = (uint64_t **)(v6 + 1);
            uint64_t v6 = (uint64_t *)v6[1];
            if (!v6) {
              goto LABEL_16;
            }
          }
        }
      }
      if (!*v14)
      {
LABEL_16:
        int8x16_t v15 = operator new(0x30uLL);
        v15[7] = *((_DWORD *)a2 + 4);
        *((_OWORD *)v15 + 2) = *(_OWORD *)((char *)a2 + 20);
        *(void *)int8x16_t v15 = 0;
        *((void *)v15 + 1) = 0;
        *((void *)v15 + 2) = v13;
        *uint64_t v14 = (uint64_t *)v15;
        if (*v38)
        {
          float v38 = (uint64_t **)*v38;
          int8x16_t v15 = *v14;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v39, (uint64_t *)v15);
        ++v40;
      }
      a2 = (uint64_t *)*a2;
      if (!a2) {
        break;
      }
      uint64_t v7 = v38;
      uint64_t v6 = v39;
    }
  }
  float32x4_t v17 = operator new(0x60uLL);
  v17[1] = 0;
  v17[2] = 0;
  void *v17 = &unk_1EF583AF8;
  int v18 = ggl::TextureData2D::TextureData2D((uint64_t)(v17 + 3), 256, 1, 1u, 12, 1);
  uint64_t v19 = (*(uint64_t (**)(void *, void))(v17[3] + 16))(v18, 0);
  uint64_t v20 = v39;
  if (v39)
  {
    do
    {
      char v21 = (float32x4_t *)v20;
      uint64_t v20 = (uint64_t *)v20[1];
    }
    while (v20);
  }
  else
  {
    uint64_t v22 = &v39;
    do
    {
      char v21 = (float32x4_t *)v22[2];
      BOOL v11 = v21->i64[0] == (void)v22;
      uint64_t v22 = (uint64_t **)v21;
    }
    while (v11);
  }
  float v23 = v21[1].f32[3];
  *((_DWORD *)v5 + 16) = 1008981770;
  *((float *)v5 + 17) = v23;
  float v24 = log2f(v23);
  unint64_t v25 = 0;
  *((_DWORD *)v5 + 18) = -1059808648;
  *((float *)v5 + 19) = v24;
  float32x4_t v37 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  while (1)
  {
    float v27 = exp2f(*((float *)v5 + 18)+ (float)((float)((float)(*((float *)v5 + 19) - *((float *)v5 + 18)) * (float)v25) * 0.0039216));
    double v28 = v39;
    double v29 = (float32x4_t *)&v39;
    if (!v39) {
      goto LABEL_43;
    }
    double v29 = (float32x4_t *)&v39;
    do
    {
      double v30 = v28 + 1;
      if (v27 < *((float *)v28 + 7))
      {
        double v30 = v28;
        double v29 = (float32x4_t *)v28;
      }
      double v28 = (uint64_t *)*v30;
    }
    while (*v30);
    double v31 = (float32x4_t *)v29->i64[0];
    if (v29->i64[0])
    {
      do
      {
        double v32 = v31;
        double v31 = (float32x4_t *)v31->i64[1];
      }
      while (v31);
    }
    else
    {
LABEL_43:
      double v32 = v29;
      do
      {
        double v33 = v32;
        double v32 = (float32x4_t *)v32[1].i64[0];
      }
      while ((float32x4_t *)v32->i64[0] == v33);
    }
    int16x8_t v26 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(vmlaq_n_f32(v32[2], vsubq_f32(v29[2], v32[2]), (float)(v27 - v32[1].f32[3]) / (float)(v29[1].f32[3] - v32[1].f32[3])), v37));
    *(int16x4_t *)v26.i8 = vmovn_s32((int32x4_t)v26);
    *(_DWORD *)(v19 + 4 * v25++) = vmovn_s16(v26).u32[0];
    if (v25 == 255)
    {
      int16x8_t v34 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(v21[2], (float32x4_t)vdupq_n_s32(0x437F0000u)));
      *(int16x4_t *)v34.i8 = vmovn_s32((int32x4_t)v34);
      *(_DWORD *)(v19 + 1020) = vmovn_s16(v34).u32[0];
      double v35 = (char *)operator new(0x58uLL);
      *((void *)v35 + 1) = 0;
      *((void *)v35 + 2) = 0;
      *(void *)double v35 = &unk_1EF583858;
      *((void *)v35 + 5) = 0;
      *((void *)v35 + 6) = 0;
      *((_DWORD *)v35 + 14) = 0;
      *((void *)v35 + 3) = &unk_1EF55AE58;
      *((void *)v35 + 4) = 0;
      *(void *)&long long v36 = 0x100000001;
      *((void *)&v36 + 1) = 0x100000001;
      *(_OWORD *)(v35 + 60) = v36;
      *(void *)(v35 + 76) = 1;
      *((_DWORD *)v35 + 21) = 0;
      operator new();
    }
  }
}

void sub_1A1F7AA30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, void *a19)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a16);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a19);
  uint64_t shared_owners = v19[2].__shared_owners_;
  v19[2].__shared_owners_ = 0;
  if (shared_owners) {
    (*(void (**)(uint64_t))(*(void *)shared_owners + 8))(shared_owners);
  }
  uint64_t v22 = (std::__shared_weak_count *)v19[1].__shared_owners_;
  if (v22) {
    std::__shared_weak_count::__release_weak(v22);
  }
  std::__shared_weak_count::~__shared_weak_count(v19);
  operator delete(v23);
  _Unwind_Resume(a1);
}

uint64_t geo::optional<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::~optional(uint64_t a1)
{
  if (*(unsigned char *)a1)
  {
    uint64_t v2 = *(void **)(a1 + 24);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v4 = *(void **)(a1 + 8);
    *(void *)(a1 + 8) = 0;
    if (v4) {
      operator delete(v4);
    }
    *(unsigned char *)a1 = 0;
  }
  return a1;
}

void std::__shared_ptr_emplace<md::ColorRampTexture>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  *(void *)(a1 + 56) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3)
  {
    std::__shared_weak_count::__release_weak(v3);
  }
}

void std::__shared_ptr_emplace<md::ColorRampTexture>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5801E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::ColorRampTexture>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5801E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::DrapingTaskScheduler::~DrapingTaskScheduler(md::DrapingTaskScheduler *this)
{
  uint64_t v2 = (void *)*((void *)this + 3);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      uint64_t v4 = (void *)v2[8];
      while (v4)
      {
        uint64_t v6 = v4;
        uint64_t v4 = (void *)*v4;
        uint64_t v7 = (std::__shared_weak_count *)v6[9];
        if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
        operator delete(v6);
      }
      uint64_t v5 = (void *)v2[6];
      v2[6] = 0;
      if (v5) {
        operator delete(v5);
      }
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int8x16_t v8 = (void *)*((void *)this + 1);
  *((void *)this + 1) = 0;
  if (v8) {
    operator delete(v8);
  }
}

void *std::__function::__func<md::DrapingTaskScheduler::reset(void)::$_0,std::allocator<md::DrapingTaskScheduler::reset(void)::$_0>,void ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF5750D8;
  return result;
}

void std::__function::__func<md::DrapingTaskScheduler::reset(void)::$_0,std::allocator<md::DrapingTaskScheduler::reset(void)::$_0>,void ()(void)>::~__func()
{
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::OverlayKey,std::shared_ptr<md::DrapingTaskInfo>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = (std::__shared_weak_count *)v2[9];
      if (v3)
      {
        if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
        }
      }
    }
    operator delete(v2);
  }
  return a1;
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::FoundationKey,md::DrapingTaskEntry>,void *>>>>::reset[abi:nn180100](uint64_t a1)
{
  uint64_t v1 = *(void **)a1;
  *(void *)a1 = 0;
  if (v1)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v2 = (void *)v1[8];
      while (v2)
      {
        uint64_t v3 = v2;
        uint64_t v2 = (void *)*v2;
        uint64_t v4 = (std::__shared_weak_count *)v3[9];
        if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
        operator delete(v3);
      }
      uint64_t v5 = (void *)v1[6];
      v1[6] = 0;
      if (v5) {
        operator delete(v5);
      }
    }
    operator delete(v1);
  }
}

uint64_t md::SectionPointsSource::size(md::SectionPointsSource *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 56))();
}

uint64_t md::SectionPointsSource::speed(md::SectionPointsSource *this)
{
  return *(unsigned __int8 *)((*(uint64_t (**)(void))(**((void **)this + 1) + 48))(*((void *)this + 1))
                            + 44);
}

uint64_t md::SectionPointsSource::operator[](uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 48))();
}

void md::SectionPointsSource::~SectionPointsSource(md::SectionPointsSource *this)
{
}

void ggl::ConstantDataTyped<ggl::SinglePassRouteLine::ClipParams>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::SinglePassRouteLine::ClipParams>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::ClipParams>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::ClipParams>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586990;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::ClipParams>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586990;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::SinglePassRouteLine::DrawAnimationDescription>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::SinglePassRouteLine::DrawAnimationDescription>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::DrawAnimationDescription>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::DrawAnimationDescription>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5869C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::DrawAnimationDescription>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5869C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::SinglePassRouteLine::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::SinglePassRouteLine::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586A00;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::SinglePassRouteLine::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586A00;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__shared_ptr_emplace<ggl::RouteLine::BaseMesh>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::RouteLine::BaseMesh>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589E80;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::RouteLine::BaseMesh>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589E80;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::RouteLineDrawAnimation::rebuildAnimationSegments(md::RouteLineDrawAnimation *this, VKRouteLine *a2, PolylineCoordinate a3)
{
  uint64_t v5 = a2;
  uint64_t v6 = v5;
  *(_OWORD *)((char *)this + 120) = 0u;
  uint64_t v7 = (_OWORD *)((char *)this + 120);
  *((void *)this + 9) = 0x3FF0000000000000;
  *((_OWORD *)this + 5) = 0u;
  int8x16_t v8 = (_OWORD *)((char *)this + 80);
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 136) = 0u;
  *((void *)this + 19) = 0x3FF0000000000000;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((void *)this + 24) = 0x3FF0000000000000;
  *((_DWORD *)this + 52) = -1;
  if (v5)
  {
    [(VKRouteLine *)v5 sections];
    int8x16_t v9 = v98;
    *((float *)this + 53) = (float)(unint64_t)((v98 - __p) >> 3);
    if (__p)
    {
      int8x16_t v10 = __p;
      if (v98 != __p)
      {
        BOOL v11 = v98;
        do
        {
          uint64_t v13 = (void *)*((void *)v11 - 1);
          v11 -= 8;
          float v12 = v13;
          if (v13)
          {
            BOOL v56 = (*v12)-- == 1;
            if (v56)
            {
              md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v12 + 1));
              {
                operator new();
              }
              (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *((void *)v9 - 1), 400);
              *((void *)v9 - 1) = 0;
            }
          }
          int8x16_t v9 = v11;
        }
        while (v11 != __p);
        int8x16_t v10 = __p;
      }
      uint64_t v98 = __p;
      operator delete(v10);
    }
    unint64_t v14 = 0;
    float offset = a3.offset;
    uint64_t v92 = (void **)((char *)this + 40);
    *((void *)this + 6) = *((void *)this + 5);
    double v94 = (void **)((char *)this + 48);
    double v16 = 0.0;
    uint64_t v89 = v6;
    while (1)
    {
      [(VKRouteLine *)v6 sections];
      int v18 = v98;
      unint64_t v19 = (v98 - __p) >> 3;
      if (__p)
      {
        uint64_t v20 = __p;
        if (v98 != __p)
        {
          char v21 = v98;
          do
          {
            float v23 = (void *)*((void *)v21 - 1);
            v21 -= 8;
            uint64_t v22 = v23;
            if (v23)
            {
              BOOL v56 = (*v22)-- == 1;
              if (v56)
              {
                md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v22 + 1));
                {
                  operator new();
                }
                (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 40))(mdm::Allocator::instance(void)::alloc, *((void *)v18 - 1), 400);
                *((void *)v18 - 1) = 0;
              }
            }
            int v18 = v21;
          }
          while (v21 != __p);
          uint64_t v20 = __p;
          uint64_t v6 = v89;
        }
        uint64_t v98 = __p;
        operator delete(v20);
      }
      if (v19 <= v14) {
        break;
      }
      [(VKRouteLine *)v6 sections];
      float v24 = v98;
      uint64_t v25 = *(void *)&__p[8 * v14];
      if (v25) {
        uint64_t v26 = v25 + 8;
      }
      else {
        uint64_t v26 = 0;
      }
      double v27 = *(double *)(v26 + 208);
      float32x4_t v17 = __p;
      if (v98 != __p)
      {
        double v28 = v98;
        do
        {
          double v30 = (void *)*((void *)v28 - 1);
          v28 -= 8;
          double v29 = v30;
          if (v30)
          {
            BOOL v56 = (*v29)-- == 1;
            if (v56)
            {
              md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v29 + 1));
              {
                  operator new();
              }
              (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *((void *)v24 - 1), 400);
              *((void *)v24 - 1) = 0;
            }
          }
          float v24 = v28;
        }
        while (v28 != __p);
        float32x4_t v17 = __p;
      }
      double v16 = v27 + v16;
      uint64_t v98 = __p;
      operator delete(v17);
      ++v14;
    }
    if (v6)
    {
      unint64_t v31 = 0;
      double v95 = 0.0;
      double v93 = 1.0 / v16;
      while (1)
      {
        [(VKRouteLine *)v6 sections];
        double v32 = v98;
        unint64_t v33 = (v98 - __p) >> 3;
        if (!__p) {
          goto LABEL_64;
        }
        if (v98 == __p) {
          break;
        }
        int16x8_t v34 = v98;
        do
        {
          long long v36 = (void *)*((void *)v34 - 1);
          v34 -= 8;
          double v35 = v36;
          if (v36)
          {
            BOOL v56 = (*v35)-- == 1;
            if (v56)
            {
              md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v35 + 1));
              {
                operator new();
              }
              (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *((void *)v32 - 1), 400);
              *((void *)v32 - 1) = 0;
            }
          }
          double v32 = v34;
        }
        while (v34 != __p);
        uint64_t v98 = __p;
        operator delete(__p);
        if (v33 <= v31) {
          goto LABEL_120;
        }
LABEL_65:
        [(VKRouteLine *)v6 sections];
        float32x4_t v37 = *(void **)&__p[8 * v31];
        uint64_t v96 = v37;
        if (v37) {
          ++*v37;
        }
        float v38 = v98;
        __double2 v39 = __p;
        if (v98 != __p)
        {
          uint64_t v40 = v98;
          do
          {
            double v42 = (void *)*((void *)v40 - 1);
            v40 -= 8;
            __double2 v41 = v42;
            if (v42)
            {
              BOOL v56 = (*v41)-- == 1;
              if (v56)
              {
                md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v41 + 1));
                {
                  operator new();
                }
                (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 40))(mdm::Allocator::instance(void)::alloc, *((void *)v38 - 1), 400);
                *((void *)v38 - 1) = 0;
              }
            }
            float v38 = v40;
          }
          while (v40 != __p);
          float32x4_t v37 = v96;
          __double2 v39 = __p;
        }
        uint64_t v98 = __p;
        operator delete(v39);
        for (unint64_t i = 1; ; ++i)
        {
          uint64_t v45 = v37 ? (uint64_t)(v37 + 1) : 0;
          unint64_t v46 = (*(uint64_t (**)(uint64_t))(*(void *)v45 + 56))(v45);
          float32x4_t v37 = v96;
          uint64_t v47 = v96 ? (uint64_t)(v96 + 1) : 0;
          if (v46 <= i) {
            break;
          }
          uint64_t v48 = (*(uint64_t (**)(void, unint64_t))(**(void **)(v47 + 72) + 32))(*(void *)(v47 + 72), i - 1);
          float v49 = *(float *)v48;
          float v50 = *(float *)(v48 + 4);
          float v51 = *(float *)(v48 + 8);
          unsigned int v52 = *(_DWORD *)(v48 + 12);
          float v53 = *(float *)(v48 + 16);
          float v54 = *(float *)(v48 + 32);
          uint64_t v55 = (float *)(*(uint64_t (**)(void, unint64_t))(**(void **)(v47 + 72) + 32))(*(void *)(v47 + 72), i);
          if (v52 >= a3.index)
          {
            BOOL v56 = v53 < offset && v52 == a3.index;
            if (!v56)
            {
              double v57 = (float)(v55[8] - v54);
              if (v57 > 0.0000001)
              {
                double v58 = v49;
                double v59 = v50;
                double v60 = v51;
                double v61 = *v55;
                double v62 = v55[1];
                double v63 = v55[2];
                double v64 = (v95 + v54) * v93;
                double v65 = v57 + v54;
                double v66 = (v65 + v95) * v93;
                double v67 = *(double *)(v47 + 208);
                double v68 = v54 / v67;
                double v70 = (double *)*((void *)this + 6);
                unint64_t v69 = *((void *)this + 7);
                double v71 = v65 / v67;
                if ((unint64_t)v70 < v69)
                {
                  double *v70 = v68;
                  v70[1] = v71;
                  v70[2] = v64;
                  v70[3] = v66;
                  v70[4] = v58;
                  v70[5] = v59;
                  v70[6] = v60;
                  v70[7] = v61;
                  unsigned char v70[8] = v62;
                  v70[9] = v63;
                  double v44 = (char *)(v70 + 11);
                  *((_DWORD *)v70 + 20) = v31;
                  float offset = a3.offset;
                }
                else
                {
                  float v72 = (double *)*v92;
                  uint64_t v73 = 0x2E8BA2E8BA2E8BA3 * (((char *)v70 - (unsigned char *)*v92) >> 3);
                  unint64_t v74 = v73 + 1;
                  if ((unint64_t)(v73 + 1) > 0x2E8BA2E8BA2E8BALL) {
                    abort();
                  }
                  unint64_t v75 = 0x2E8BA2E8BA2E8BA3 * ((uint64_t)(v69 - (void)v72) >> 3);
                  if (2 * v75 > v74) {
                    unint64_t v74 = 2 * v75;
                  }
                  if (v75 >= 0x1745D1745D1745DLL) {
                    unint64_t v76 = 0x2E8BA2E8BA2E8BALL;
                  }
                  else {
                    unint64_t v76 = v74;
                  }
                  if (v76)
                  {
                    double v90 = v71;
                    double v91 = v54 / v67;
                    if (v76 > 0x2E8BA2E8BA2E8BALL) {
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    }
                    double v77 = v58;
                    float v78 = (char *)operator new(88 * v76);
                    double v58 = v77;
                    double v71 = v90;
                    double v68 = v91;
                  }
                  else
                  {
                    float v78 = 0;
                  }
                  uint64_t v79 = &v78[88 * v73];
                  *(double *)uint64_t v79 = v68;
                  *((double *)v79 + 1) = v71;
                  *((double *)v79 + 2) = v64;
                  *((double *)v79 + 3) = v66;
                  *((double *)v79 + 4) = v58;
                  *((double *)v79 + 5) = v59;
                  *((double *)v79 + 6) = v60;
                  *((double *)v79 + 7) = v61;
                  *((double *)v79 + 8) = v62;
                  *((double *)v79 + 9) = v63;
                  *((_DWORD *)v79 + 20) = v31;
                  uint64_t v80 = (double *)v79;
                  if (v70 == v72)
                  {
                    float offset = a3.offset;
                  }
                  else
                  {
                    float offset = a3.offset;
                    do
                    {
                      long long v81 = *(_OWORD *)(v70 - 11);
                      *(_OWORD *)(v80 - 9) = *(_OWORD *)(v70 - 9);
                      *(_OWORD *)(v80 - 11) = v81;
                      long long v82 = *(_OWORD *)(v70 - 7);
                      long long v83 = *(_OWORD *)(v70 - 5);
                      long long v84 = *(_OWORD *)(v70 - 3);
                      *(v80 - 1) = *(v70 - 1);
                      *(_OWORD *)(v80 - 3) = v84;
                      *(_OWORD *)(v80 - 5) = v83;
                      *(_OWORD *)(v80 - 7) = v82;
                      v80 -= 11;
                      v70 -= 11;
                    }
                    while (v70 != v72);
                    double v70 = (double *)*v92;
                  }
                  double v44 = v79 + 88;
                  *((void *)this + 5) = v80;
                  *((void *)this + 6) = v79 + 88;
                  *((void *)this + 7) = &v78[88 * v76];
                  uint64_t v6 = v89;
                  if (v70) {
                    operator delete(v70);
                  }
                }
                *double v94 = v44;
              }
            }
          }
        }
        double v85 = *(double *)(v47 + 208);
        if (v96)
        {
          BOOL v56 = (*v96)-- == 1;
          if (v56)
          {
            md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v96 + 1));
            {
              operator new();
            }
            (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v96, 400);
          }
        }
        double v95 = v85 + v95;
        ++v31;
      }
      uint64_t v98 = __p;
      operator delete(__p);
LABEL_64:
      if (v33 <= v31) {
        goto LABEL_120;
      }
      goto LABEL_65;
    }
LABEL_120:
    int8x16_t v8 = (_OWORD *)((char *)this + 80);
    uint64_t v7 = (_OWORD *)((char *)this + 120);
  }
  else
  {
    *((_DWORD *)this + 53) = 0;
    uint64_t v92 = (void **)((char *)this + 40);
    *((void *)this + 6) = *((void *)this + 5);
    double v94 = (void **)((char *)this + 48);
  }
  uint64_t v86 = *v92;
  if (*v94 != *v92)
  {
    uint64_t v87 = v86[6];
    long long v88 = *((_OWORD *)v86 + 2);
    *((void *)this + 9) = 0x3FF0000000000000;
    *int8x16_t v8 = 0u;
    v8[1] = 0u;
    *((void *)this + 14) = 0x3FF0000000000000;
    *uint64_t v7 = 0u;
    v7[1] = 0u;
    *(_OWORD *)((char *)this + 152) = xmmword_1A28FCBD0;
    *(_OWORD *)((char *)this + 168) = v88;
    *((void *)this + 23) = v87;
    *((void *)this + 24) = 0x3FF0000000000000;
    *(float *)&uint64_t v87 = *((double *)v86 + 2);
    *((_DWORD *)this + 55) = v87;
  }
}

void sub_1A1F7C128(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>::~fast_shared_ptr(void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    if ((*v2)-- == 1)
    {
      md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v2 + 1));
      uint64_t v4 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
      {
        uint64_t v4 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
        if (v6) {
          operator new();
        }
      }
      (*(void (**)(void, void, uint64_t))(**((void **)v4 + 91) + 40))(*((void *)v4 + 91), *a1, 400);
      *a1 = 0;
    }
  }
  return a1;
}

float md::RouteLineDrawAnimation::update(md::RouteLineDrawAnimation *this, float result, int *a3)
{
  double v3 = result;
  float v4 = *((float *)this + 55) + (1.0 - *((float *)this + 55)) * result;
  *((float *)this + 50) = v4;
  uint64_t v5 = *((void *)this + 5);
  uint64_t v6 = -1171354717 * ((unint64_t)(*((void *)this + 6) - v5) >> 3);
  if (!v6) {
    return 1.0;
  }
  uint64_t v7 = 0;
  for (unint64_t i = (double *)(v5 + 24); ; i += 11)
  {
    double v9 = *(i - 1);
    if (v9 <= v3)
    {
      double v10 = *i;
      if (*i >= v3) {
        break;
      }
    }
    if (v6 == ++v7)
    {
      *a3 = *((_DWORD *)this + 51);
      return result;
    }
  }
  if (*((_DWORD *)this + 52) == v7)
  {
    int v11 = *((_DWORD *)this + 51);
  }
  else
  {
    int v11 = *(_DWORD *)(v5 + 88 * v7 + 80);
    *((_DWORD *)this + 51) = v11;
    *((_DWORD *)this + 52) = v7;
  }
  *a3 = v11;
  double v12 = (v3 - v10) / (v10 - v9);
  uint64_t v13 = v5 + 88 * v7;
  double v14 = *(double *)(v13 + 32);
  double v15 = v12 + 1.0;
  double v16 = *(double *)(v13 + 56);
  double v17 = (v16 - v14) * v15;
  double v18 = v16 - (v14 + v17);
  float64x2_t v19 = *(float64x2_t *)(v13 + 40);
  float64x2_t v20 = *(float64x2_t *)(v13 + 64);
  float64x2_t v21 = vmulq_n_f64(vsubq_f64(v20, v19), v15);
  float64x2_t v22 = vsubq_f64(v20, vaddq_f64(v21, v19));
  v20.f64[0] = 1.0 / sqrt(vmulq_f64(v22, v22).f64[0] + v18 * v18);
  float64_t v23 = v20.f64[0] * v18;
  v22.f64[0] = v20.f64[0] * v22.f64[0];
  v20.f64[0] = 1.0 / sqrt(v23 * v23 + v22.f64[0] * v22.f64[0]);
  float64_t v24 = -(v23 * v20.f64[0]);
  v22.f64[0] = sqrt(v24 * v24 + v20.f64[0] * v22.f64[0] * (v20.f64[0] * v22.f64[0])) + v20.f64[0] * v22.f64[0];
  v20.f64[0] = 1.0 / sqrt(v24 * v24 + v22.f64[0] * v22.f64[0]);
  float64_t v25 = v20.f64[0] * v24;
  v22.f64[0] = v20.f64[0] * v22.f64[0];
  *((void *)this + 9) = 0x3FF0000000000000;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 14) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 152) = xmmword_1A28FCBD0;
  *((double *)this + 21) = v17;
  *((float64x2_t *)this + 11) = v21;
  *((void *)this + 24) = 0x3FF0000000000000;
  float32x2_t v26 = vcvt_f32_f64(*(float64x2_t *)(v13 + 32));
  *(float *)v20.f64 = *(double *)(v13 + 48);
  double v27 = **(void ***)(*((void *)this + 3) + 64);
  uint64_t v28 = v27[1];
  double v29 = (float32x2_t *)v27[9];
  *double v29 = v26;
  v29[1].i32[0] = LODWORD(v20.f64[0]);
  v29[6] = v26;
  v29[7].i32[0] = LODWORD(v20.f64[0]);
  v29[12] = v26;
  v29[13].i32[0] = LODWORD(v20.f64[0]);
  v29[18] = v26;
  v29[19].i32[0] = LODWORD(v20.f64[0]);
  v29[24] = v26;
  v29[25].i32[0] = LODWORD(v20.f64[0]);
  v29[30] = v26;
  v29[31].i32[0] = LODWORD(v20.f64[0]);
  v20.f64[0] = v22.f64[0] * (v25 * -2.0);
  float64_t v30 = v25 * (v25 * -2.0);
  v21.f64[0] = -1.0 - v30;
  v22.f64[0] = v22.f64[0] * (v25 + v25);
  double v31 = 1.0 - v25 * (v25 + v25);
  double v32 = -1.0 - v30 + v20.f64[0];
  float64_t v33 = v30 + 1.0;
  float64_t v34 = v30 + 1.0 + v20.f64[0];
  double v35 = v31 + v20.f64[0];
  *(float *)v21.f64 = v21.f64[0] * 0.25;
  *(float *)v20.f64 = v20.f64[0] * 0.25;
  v29[2].i16[0] = (int)(float)((float)(*(float *)v21.f64 * 32768.0) + -0.5);
  v29[2].i16[1] = (int)(float)((float)(*(float *)v20.f64 * 32768.0) + -0.5);
  *(float *)&double v31 = v31 * 0.25;
  int v36 = (int)(float)((float)(*(float *)&v31 * 32768.0) + -0.5);
  *(float *)&double v31 = v22.f64[0] * 0.25;
  int v37 = (int)(float)((float)(*(float *)&v31 * 32768.0) + -0.5);
  v29[8].i16[0] = v36;
  v29[8].i16[1] = v37;
  *(float *)&double v31 = v32 * 0.25;
  int v38 = (int)(float)((float)(*(float *)&v31 * 32768.0) + -0.5);
  *(float *)&double v31 = v34 * 0.25;
  int v39 = (int)(float)((float)(*(float *)&v31 * 32768.0) + -0.5);
  v29[14].i16[0] = v38;
  v29[14].i16[1] = v39;
  v29[20].i16[0] = v36;
  v29[20].i16[1] = v37;
  *(float *)&double v31 = v35 * 0.25;
  *(float *)&float64_t v33 = (v33 + v22.f64[0]) * 0.25;
  v29[26].i16[0] = (int)(float)((float)(*(float *)&v31 * 32768.0) + -0.5);
  v29[26].i16[1] = (int)(float)((float)(*(float *)&v33 * 32768.0) + -0.5);
  unint64_t v40 = 6 * v28;
  v29[32].i16[0] = v38;
  v29[32].i16[1] = v39;
  if (v40)
  {
    unint64_t v41 = v27[8];
    if (v41 <= v40) {
      unint64_t v41 = v40;
    }
    v27[7] = 0;
    v27[8] = v41;
  }
  return *(double *)(v5 + 88 * v7) + (*(double *)(v5 + 88 * v7 + 8) - *(double *)(v5 + 88 * v7)) * v15;
}

void md::RouteLineOverlay::RouteLineOverlay(md::RouteLineOverlay *this, VKPolylineOverlay *a2, char a3, double a4)
{
  uint64_t v6 = a2;
  *(void *)this = 0;
  *((void *)this + 17) = off_1EF559738;
  *((void *)this + 18) = 0;
  long long v7 = 0uLL;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((unsigned char *)this + 208) = 1;
  *(_OWORD *)((char *)this + 216) = 0u;
  *((void *)this + 55) = 0;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((void *)this + 53) = 0;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *(_OWORD *)((char *)this + 328) = 0u;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *(_OWORD *)((char *)this + 392) = 0u;
  *(_OWORD *)((char *)this + 408) = 0u;
  {
    long long v7 = 0uLL;
    if (v6) {
      operator new();
    }
  }
  *((void *)this + 56) = mdm::Allocator::instance(void)::alloc;
  *((void *)this + 57) = 0;
  *((void *)this + 54) = (char *)this + 440;
  *((_OWORD *)this + 29) = v7;
  *((_OWORD *)this + 30) = v7;
  *((_DWORD *)this + 124) = 1065353216;
  *((void *)this + 63) = 0;
  *((_DWORD *)this + 128) = -1;
  *((void *)this + 65) = 0;
  *((_DWORD *)this + 132) = 0;
  *((void *)this + 67) = 0;
  *((void *)this + 69) = 0;
  *((void *)this + 68) = 0;
  int8x16_t v8 = (gss::Allocator *)gss::Allocator::instance((gss::Allocator *)v6);
  *((void *)this + 70) = v8;
  *((void *)this + 71) = 0;
  *((void *)this + 73) = 0;
  *((void *)this + 72) = 0;
  *((void *)this + 74) = gss::Allocator::instance(v8);
  memset_pattern16((char *)this + 600, &unk_1A28FFCB0, 0x10uLL);
  *(_DWORD *)((char *)this + 619) = 0;
  *((_DWORD *)this + 154) = 0;
  *(_WORD *)((char *)this + 623) = 1;
  *((unsigned char *)this + 625) = a3;
  *((unsigned char *)this + 632) = 0;
  *((_DWORD *)this + 208) = 0;
  *((_WORD *)this + 424) = 0;
  *((_DWORD *)this + 213) = 0;
  *((_OWORD *)this + 40) = 0u;
  *((_OWORD *)this + 41) = 0u;
  *((_OWORD *)this + 42) = 0u;
  *((_OWORD *)this + 43) = 0u;
  float64_t v33 = (char *)this + 656;
  double v9 = operator new(0xA8uLL);
  v9[1] = 0;
  v9[2] = 0;
  *double v9 = &unk_1EF589E80;
  double v10 = v9 + 3;
  {
    {
      ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::RouteLine::defaultVboReflection;
    }
    ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::attributesReflection(void)::r;
    unk_1EB32B798 = 1;
  }
  v9[11] = 0;
  int v11 = (char *)(v9 + 11);
  v9[7] = 0;
  v9[8] = 0;
  *((_DWORD *)v9 + 18) = 0;
  v9[3] = &unk_1EF5606B0;
  v9[4] = "/AnimatedEndCap";
  v9[5] = &unk_1EF5606D0;
  v9[6] = 0;
  v9[10] = &ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::typedReflection(void)::r;
  v9[12] = 0;
  v9[13] = 0;
  {
    operator new();
  }
  uint64_t v12 = ggl::Allocator::instance(void)::alloc;
  v9[18] = 0;
  v9[15] = 0;
  v9[16] = 0;
  v9[14] = v12;
  {
    operator new();
  }
  v9[19] = ggl::Allocator::instance(void)::alloc;
  v9[20] = 0;
  v9[17] = v9 + 18;
  v9[3] = &unk_1EF562C60;
  v9[5] = &unk_1EF562C80;
  uint64_t v13 = v9[11];
  unint64_t v14 = *(void *)(v9[10] + 8);
  uint64_t v15 = v9[12];
  unint64_t v16 = (v15 - v13) >> 4;
  unint64_t v17 = v14 - v16;
  if (v14 <= v16)
  {
    if (v14 < v16)
    {
      for (uint64_t i = v13 + 16 * v14; v15 != i; v15 -= 16)
      {
        float64x2_t v19 = *(std::__shared_weak_count **)(v15 - 8);
        if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, unint64_t))v19->__on_zero_shared)(v19, v17);
          std::__shared_weak_count::__release_weak(v19);
        }
      }
      v9[12] = i;
    }
  }
  else
  {
    std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__append((uint64_t)(v9 + 11), v17);
  }
  *double v10 = &unk_1EF562E50;
  v9[5] = &unk_1EF562E70;
  {
    operator new();
  }
  uint64_t v20 = ggl::Allocator::instance(void)::alloc;
  uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)ggl::Allocator::instance(void)::alloc + 16))(ggl::Allocator::instance(void)::alloc, 256, 8);
  *(void *)uint64_t v21 = &unk_1EF585340;
  *(void *)(v21 + 8) = 0;
  *(void *)(v21 + 16) = 0;
  *(void *)(v21 + 24) = v20;
  *(void *)(v21 + 32) = &unk_1EF55A1F0;
  *(void *)(v21 + 40) = 48;
  *(_DWORD *)(v21 + 48) = 6;
  long long v22 = 0uLL;
  *(_OWORD *)(v21 + 56) = 0u;
  *(_OWORD *)(v21 + 72) = 0u;
  *(_OWORD *)(v21 + 88) = 0u;
  *(_OWORD *)(v21 + 104) = 0u;
  *(void *)(v21 + 120) = 0;
  {
    long long v22 = 0uLL;
    if (v32) {
      operator new();
    }
  }
  *(void *)(v21 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(v21 + 136) = 0;
  *(_OWORD *)(v21 + 200) = v22;
  *(_OWORD *)(v21 + 184) = v22;
  *(_OWORD *)(v21 + 168) = v22;
  *(void *)(v21 + 216) = 0;
  *(void *)(v21 + 224) = -1;
  *(_OWORD *)(v21 + 152) = xmmword_1A28FCCA0;
  *(_DWORD *)(v21 + 144) = 0;
  *(void *)(v21 + 240) = "/AnimatedEndCap";
  *(void *)(v21 + 248) = &ggl::RouteLine::defaultVboReflection;
  *(void *)(v21 + 32) = &unk_1EF55D008;
  *(void *)(v21 + 232) = &unk_1EF55D028;
  float64_t v23 = *(void **)v11;
  float64_t v24 = *(std::__shared_weak_count **)(*(void *)v11 + 8);
  void *v23 = v21 + 32;
  v23[1] = v21;
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  *((void *)this + 82) = v10;
  float64_t v25 = (std::__shared_weak_count *)*((void *)this + 83);
  *((void *)this + 83) = v9;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
    std::__shared_weak_count::__release_weak(v25);
  }
  uint64_t v26 = **(void **)(*(void *)v33 + 64);
  unint64_t v27 = 6 * *(void *)(v26 + 8);
  uint64_t v28 = *(void *)(v26 + 72);
  unint64_t v29 = *(void *)(v26 + 80) - v28;
  if (v27 != v29)
  {
    if (v27 <= v29)
    {
      if (v27 < v29) {
        *(void *)(v26 + 80) = v28 + v27;
      }
    }
    else
    {
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v26 + 72, v27 - v29);
    }
    float64_t v30 = *(std::__shared_weak_count **)(v26 + 32);
    *(void *)(v26 + 24) = 0;
    *(void *)(v26 + 32) = 0;
    if (v30)
    {
      if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
        std::__shared_weak_count::__release_weak(v30);
      }
    }
    *(void *)(v26 + 120) = 0;
    *(_DWORD *)(v26 + 112) = 0;
    uint64_t v31 = *(void *)(v26 + 80) - *(void *)(v26 + 72);
    *(void *)(v26 + 40) = 0;
    *(void *)(v26 + 48) = v31;
    *(void *)(v26 + 56) = 0;
    *(void *)(v26 + 64) = v31;
    uint64_t v26 = **(void **)(*(void *)v33 + 64);
  }
  uint64_t v34 = *(void *)(v26 + 72);
  *(_DWORD *)(v34 + 8) = 0;
  *(void *)uint64_t v34 = 0;
  *(_DWORD *)(v34 + 56) = 0;
  *(void *)(v34 + 48) = 0;
  *(_DWORD *)(v34 + 104) = 0;
  *(void *)(v34 + 96) = 0;
  *(_DWORD *)(v34 + 152) = 0;
  *(void *)(v34 + 144) = 0;
  *(_DWORD *)(v34 + 200) = 0;
  *(void *)(v34 + 192) = 0;
  *(_DWORD *)(v34 + 248) = 0;
  *(void *)(v34 + 240) = 0;
  *(void *)(v34 + 16) = 0x800000000000E000;
  *(void *)(v34 + 64) = 0x7FFF000000001FFFLL;
  *(void *)(v34 + 112) = 0x80007FFF1FFFE000;
  *(void *)(v34 + 160) = 0x7FFF000000001FFFLL;
  *(void *)(v34 + 208) = 0x7FFF7FFF1FFF1FFFLL;
  *(void *)(v34 + 256) = 0x80007FFF1FFFE000;
  *(_WORD *)(v34 + 36) = 771;
  *(_DWORD *)(v34 + 32) = 0;
  *(void *)(v34 + 24) = 0x3FECCCCD00000000;
  *(_WORD *)(v34 + 84) = 771;
  *(void *)(v34 + 72) = 0x3FECCCCD00000000;
  *(_DWORD *)(v34 + 80) = 0;
  *(_WORD *)(v34 + 132) = 771;
  *(void *)(v34 + 120) = 0x3FECCCCD00000000;
  *(_DWORD *)(v34 + 128) = 0;
  *(_WORD *)(v34 + 180) = 771;
  *(void *)(v34 + 168) = 0x3FECCCCD00000000;
  *(_DWORD *)(v34 + 176) = 0;
  *(_WORD *)(v34 + 228) = 771;
  *(void *)(v34 + 216) = 0x3FECCCCD00000000;
  *(_DWORD *)(v34 + 224) = 0;
  *(_WORD *)(v34 + 276) = 771;
  *(void *)(v34 + 264) = 0x3FECCCCD00000000;
  *(_DWORD *)(v34 + 272) = 0;
  *((void *)this + 88) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 712) = 0u;
  *(_OWORD *)((char *)this + 728) = 0u;
  *((void *)this + 93) = 0x3FF0000000000000;
  *((_OWORD *)this + 47) = 0u;
  *((_OWORD *)this + 48) = 0u;
  *((void *)this + 98) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 792) = 0u;
  *(_OWORD *)((char *)this + 808) = 0u;
  *((void *)this + 103) = 0x3FF0000000000000;
  operator new();
}

void sub_1A1F7DFF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, gss::FeatureAttributeSet *a17, gss::FeatureAttributeSet *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  if (v27) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a16 + 40))(a16, v27, a15 - v27);
  }
  if (a21) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a24 + 40))(a24, a21, a23 - a21);
  }
  if (v25) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v26 + 40))(v26, v25, a20 - v25);
  }
  md::RouteLineDrawAnimation::~RouteLineDrawAnimation((id *)(v24 + 632));
  gss::FeatureAttributeSet::~FeatureAttributeSet(a18);
  gss::FeatureAttributeSet::~FeatureAttributeSet(a17);
  geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>::~fast_shared_ptr((void *)(v24 + 504));
  std::unordered_set<GEOComposedRouteSection * {__strong}>::~unordered_set[abi:nn180100](v24 + 464);
  std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::less<GEOComposedRouteSection * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,mdm::Allocator>>::destroy(v24 + 432, *(void *)(v24 + 440));
  uint64_t v29 = *(void *)(v24 + 424);
  *(void *)(v24 + 424) = 0;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  }
  std::unique_ptr<ggl::FragmentedPool<ggl::Debug::ExtendedMesh>>::~unique_ptr[abi:nn180100]((uint64_t *)(v24 + 416));
  std::unique_ptr<ggl::FragmentedPool<ggl::RenderItem>>::~unique_ptr[abi:nn180100]((uint64_t *)(v24 + 408));
  std::unique_ptr<ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>>::~unique_ptr[abi:nn180100]((uint64_t *)(v24 + 400));
  uint64_t v30 = *(void *)(v24 + 392);
  *(void *)(v24 + 392) = 0;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  }
  std::unique_ptr<ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>>::~unique_ptr[abi:nn180100]((uint64_t *)(v24 + 384));
  std::unique_ptr<ggl::FragmentedPool<ggl::RenderItem>>::~unique_ptr[abi:nn180100]((uint64_t *)(v24 + 376));
  std::unique_ptr<ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>>::~unique_ptr[abi:nn180100]((uint64_t *)(v24 + 368));
  uint64_t v31 = *(void *)(v24 + 360);
  *(void *)(v24 + 360) = 0;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  uint64_t v32 = *(void *)(v24 + 352);
  *(void *)(v24 + 352) = 0;
  if (v32) {
    (*(void (**)(uint64_t))(*(void *)v32 + 8))(v32);
  }
  std::unique_ptr<md::ManeuverPointSet>::~unique_ptr[abi:nn180100]((md::ManeuverPointSet **)(v24 + 344));
  uint64_t v33 = *(void *)(v24 + 336);
  *(void *)(v24 + 336) = 0;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
  }
  uint64_t v34 = *(void *)(v24 + 328);
  *(void *)(v24 + 328) = 0;
  if (v34) {
    (*(void (**)(uint64_t))(*(void *)v34 + 8))(v34);
  }
  uint64_t v35 = *(void *)(v24 + 320);
  *(void *)(v24 + 320) = 0;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }
  int v36 = *(md::RouteLineSharedRenderStates **)(v24 + 312);
  *(void *)(v24 + 312) = 0;
  if (v36) {
    std::default_delete<md::RouteLineSharedResources>::operator()[abi:nn180100](v36);
  }
  std::vector<std::unique_ptr<md::RouteLineArrowLayer>>::~vector[abi:nn180100]((void *)(v24 + 288));
  int v37 = *(void **)(v24 + 280);
  *(void *)(v24 + 280) = 0;
  if (v37) {
    std::default_delete<md::RouteLineArrowSharedResources>::operator()[abi:nn180100](v37);
  }
  uint64_t v38 = *(void *)(v24 + 272);
  *(void *)(v24 + 272) = 0;
  if (v38) {
    (*(void (**)(uint64_t))(*(void *)v38 + 8))(v38);
  }
  uint64_t v39 = *(void *)(v24 + 264);
  *(void *)(v24 + 264) = 0;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v24 + 248);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v24 + 232);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a12);

  *(void *)(v24 + 136) = a13;
  _Unwind_Resume(a1);
}

void md::RouteLineDrawAnimation::~RouteLineDrawAnimation(id *this)
{
  id v2 = this[5];
  if (v2)
  {
    this[6] = v2;
    operator delete(v2);
  }
  double v3 = (std::__shared_weak_count *)this[4];
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  id v4 = this[2];
  this[2] = 0;
  if (v4) {
    (*(void (**)(id))(*(void *)v4 + 8))(v4);
  }
  id v5 = this[1];
  this[1] = 0;
  if (v5) {
    (*(void (**)(id))(*(void *)v5 + 8))(v5);
  }
}

uint64_t std::unordered_set<GEOComposedRouteSection * {__strong}>::~unordered_set[abi:nn180100](uint64_t a1)
{
  id v2 = *(id **)(a1 + 16);
  if (v2)
  {
    do
    {
      double v3 = (id *)*v2;

      operator delete(v2);
      id v2 = v3;
    }
    while (v3);
  }
  id v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

uint64_t std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::less<GEOComposedRouteSection * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::less<GEOComposedRouteSection * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::less<GEOComposedRouteSection * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    uint64_t v4 = *(void *)(a2 + 40);
    *(void *)(a2 + 40) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }

    id v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Debug::ExtendedMesh>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Debug::ExtendedMesh>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

uint64_t *std::unique_ptr<ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::~FragmentedPool(v2);
    MEMORY[0x1A6239270](v3, 0x10A0C40D234DDC7);
  }
  return a1;
}

md::ManeuverPointSet **std::unique_ptr<md::ManeuverPointSet>::~unique_ptr[abi:nn180100](md::ManeuverPointSet **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::ManeuverPointSet::~ManeuverPointSet(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void *std::vector<std::unique_ptr<md::RouteLineArrowLayer>>::~vector[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    uint64_t v3 = (void *)a1[1];
    uint64_t v4 = (void *)*a1;
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void md::ManeuverPointSet::~ManeuverPointSet(md::ManeuverPointSet *this)
{
  uint64_t v2 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = *((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  uint64_t v5 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  }
  long long v7 = (std::__shared_weak_count *)*((void *)this + 1);
  if (v7)
  {
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

uint64_t ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  double v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  double v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  double v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Debug::ExtendedMesh>::~FragmentedPool(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 40);
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void **)(a1 + 8);
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = *(void *)(a1 + 120);
  if (v6 == a1 + 96)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 96) + 32))(a1 + 96);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7 == a1 + 64)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 64) + 32))(a1 + 64);
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8)
    {
LABEL_19:
      *(void *)(a1 + 40) = v8;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v8, *(void *)(a1 + 48) - v8);
    }
  }
  else
  {
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      goto LABEL_19;
    }
  }
  double v9 = *(void **)a1;
  if (*(void *)a1)
  {
    *(void *)(a1 + 8) = v9;
    (*(void (**)(void, void *, void))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v9, *(void *)(a1 + 16) - (void)v9);
  }
  return a1;
}

void geo::_retain_ptr<VKPolylineOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = off_1EF559738;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKPolylineOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = off_1EF559738;

  return a1;
}

void ggl::ImageCopy::Pos2DUVPipelineState::~Pos2DUVPipelineState(ggl::ImageCopy::Pos2DUVPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

BOOL ggl::ImageCopy::Pos2DUVPipelineSetup::textureIsEnabled(ggl::ImageCopy::Pos2DUVPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

uint64_t ggl::ImageCopy::Pos2DUVPipelineSetup::constantDataIsEnabled(ggl::ImageCopy::Pos2DUVPipelineSetup *this)
{
  return 0;
}

void ggl::ImageCopy::Pos2DUVPipelineSetup::~Pos2DUVPipelineSetup(ggl::ImageCopy::Pos2DUVPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

uint64_t md::LabelNavEtaLabeler::onRouteContextStateDidChange(uint64_t this, VKRouteContext *a2)
{
  if (a2) {
    *(unsigned char *)(this + 253) = 1;
  }
  return this;
}

uint64_t buildStringForRouteSet(unsigned char *a1, void *a2)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v22);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"[", 1);
  uint64_t v6 = (void *)*a2;
  uint64_t v4 = a2 + 1;
  uint64_t v5 = v6;
  if (v6 != v4)
  {
    do
    {
      id v7 = (id)v5[4];
      std::ostream::operator<<();
      uint64_t v8 = (void *)*v4;
      double v9 = v4;
      if (*v4)
      {
        do
        {
          double v10 = v8;
          uint64_t v8 = (void *)v8[1];
        }
        while (v8);
      }
      else
      {
        do
        {
          double v10 = (void *)v9[2];
          BOOL v11 = *v10 == (void)v9;
          double v9 = v10;
        }
        while (v11);
      }
      if (v7 != (id)v10[4]) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)", ", 2);
      }

      uint64_t v12 = (void *)v5[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v5[2];
          BOOL v11 = *v13 == (void)v5;
          uint64_t v5 = v13;
        }
        while (!v11);
      }
      uint64_t v5 = v13;
    }
    while (v13 != v4);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"]", 1);
  if ((v29 & 0x10) != 0)
  {
    unint64_t v15 = v28;
    if (v28 < v25)
    {
      unint64_t v28 = v25;
      unint64_t v15 = v25;
    }
    unint64_t v16 = (const void **)&v24;
  }
  else
  {
    if ((v29 & 8) == 0)
    {
      size_t v14 = 0;
      a1[23] = 0;
      goto LABEL_31;
    }
    unint64_t v16 = (const void **)v23;
    unint64_t v15 = v23[2];
  }
  unint64_t v17 = *v16;
  size_t v14 = v15 - (void)*v16;
  if (v14 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v14 >= 0x17)
  {
    uint64_t v18 = (v14 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v18 = v14 | 7;
    }
    uint64_t v19 = v18 + 1;
    uint64_t v20 = operator new(v18 + 1);
    *((void *)a1 + 1) = v14;
    *((void *)a1 + 2) = v19 | 0x8000000000000000;
    *(void *)a1 = v20;
    a1 = v20;
    goto LABEL_30;
  }
  a1[23] = v14;
  if (v14) {
LABEL_30:
  }
    memmove(a1, v17, v14);
LABEL_31:
  a1[v14] = 0;
  v22[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v22 + *(void *)(v22[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v22[1] = MEMORY[0x1E4FBA470] + 16;
  if (v27 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v30);
}

void sub_1A1F7F81C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    uint64_t v4 = *(void *)(a2 + 40);
    if (v4)
    {
      *(void *)(a2 + 48) = v4;
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 64) + 40))(*(void *)(a2 + 64), v4, *(void *)(a2 + 56) - v4);
    }
    uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

uint64_t *md::RouteRangeAnnotationRequest::addAnnotatableSection(uint64_t *result, _OWORD *a2)
{
  uint64_t v3 = result;
  uint64_t v5 = result + 3;
  uint64_t v4 = result[3];
  if (v4)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v6 = (uint64_t *)v4;
        unsigned int v7 = *(_DWORD *)(v4 + 32);
        if (v7 < 2) {
          break;
        }
        uint64_t v4 = *v6;
        uint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_8;
        }
      }
      if (v7) {
        break;
      }
      uint64_t v4 = v6[1];
      if (!v4)
      {
        uint64_t v5 = v6 + 1;
        goto LABEL_8;
      }
    }
    uint64_t v8 = (uint64_t)v6;
  }
  else
  {
    uint64_t v6 = result + 3;
LABEL_8:
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)result[4] + 16))(result[4], 72, 8);
    *(_DWORD *)(v8 + 32) = 1;
    *(void *)(v8 + 48) = 0;
    *(void *)(v8 + 56) = 0;
    *(void *)(v8 + 40) = 0;
    double v9 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      double v9 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v24) {
        operator new();
      }
    }
    *(void *)(v8 + 64) = *((void *)v9 + 91);
    *(void *)uint64_t v8 = 0;
    *(void *)(v8 + 8) = 0;
    *(void *)(v8 + 16) = v6;
    uint64_t *v5 = v8;
    uint64_t v10 = *(void *)v3[2];
    BOOL v11 = (uint64_t *)v8;
    if (v10)
    {
      v3[2] = v10;
      BOOL v11 = (uint64_t *)*v5;
    }
    uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v3[3], v11);
    ++v3[5];
  }
  uint64_t v12 = *(_OWORD **)(v8 + 48);
  unint64_t v13 = *(void *)(v8 + 56);
  if ((unint64_t)v12 >= v13)
  {
    uint64_t v15 = *(void *)(v8 + 40);
    uint64_t v16 = ((uint64_t)v12 - v15) >> 4;
    unint64_t v17 = v16 + 1;
    if ((unint64_t)(v16 + 1) >> 60) {
      abort();
    }
    uint64_t v18 = v13 - v15;
    if (v18 >> 3 > v17) {
      unint64_t v17 = v18 >> 3;
    }
    if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
    }
    if (v17)
    {
      uint64_t v19 = 2 * v17;
      uint64_t result = (uint64_t *)(*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v8 + 64) + 16))(*(void *)(v8 + 64), 16 * v17, 4);
      uint64_t v20 = &result[2 * v16];
      unint64_t v17 = (unint64_t)&result[v19];
      if (result) {
        *(_OWORD *)uint64_t v20 = *a2;
      }
    }
    else
    {
      uint64_t v20 = (uint64_t *)(16 * v16);
    }
    size_t v14 = v20 + 2;
    uint64_t v22 = *(void *)(v8 + 40);
    uint64_t v21 = *(void *)(v8 + 48);
    if (v21 != v22)
    {
      do
      {
        *((_OWORD *)v20 - 1) = *(_OWORD *)(v21 - 16);
        v20 -= 2;
        v21 -= 16;
      }
      while (v21 != v22);
      uint64_t v21 = *(void *)(v8 + 40);
    }
    *(void *)(v8 + 40) = v20;
    *(void *)(v8 + 48) = v14;
    uint64_t v23 = *(void *)(v8 + 56);
    *(void *)(v8 + 56) = v17;
    if (v21) {
      uint64_t result = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v8 + 64) + 40))(*(void *)(v8 + 64), v21, v23 - v21);
    }
  }
  else
  {
    if (v12) {
      _OWORD *v12 = *a2;
    }
    size_t v14 = v12 + 1;
  }
  *(void *)(v8 + 48) = v14;
  return result;
}

uint64_t md::RouteRangeAnnotationRequest::operator==(id *a1, uint64_t a2)
{
  id v4 = *a1;
  id v5 = *(id *)a2;
  if (v4 == v5) {
    uint64_t v6 = [a1[1] isEqual:*(void *)(a2 + 8)];
  }
  else {
    uint64_t v6 = 0;
  }

  return v6;
}

void sub_1A1F7FBF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::RouteRangeAnnotationRequest::to_string(md::RouteRangeAnnotationRequest *this, id *a2)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v44);
  id v4 = [a2[1] etaDescription];
  id v5 = [v4 etaText];
  if (v5)
  {
    uint64_t v6 = [a2[1] etaDescription];
    unsigned int v7 = [v6 etaText];
    uint64_t v8 = [v7 stringByReplacingOccurrencesOfString:@"\n" withString:@"\\n"];
  }
  else
  {
    uint64_t v8 = &stru_1EF593218;
  }

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)"{ route:", 8);
  id v9 = *a2;
  uint64_t v10 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)", route.end:(", 13);
  id v11 = *a2;
  [v11 endRouteCoordinate];
  GEOPolylineCoordinateAsFullString();
  id v12 = objc_claimAutoreleasedReturnValue();
  unint64_t v13 = (const char *)[v12 UTF8String];
  size_t v14 = strlen(v13);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)v13, v14);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"), annotation.start:(", 21);
  [a2[1] start];
  GEOPolylineCoordinateAsFullString();
  id v15 = objc_claimAutoreleasedReturnValue();
  uint64_t v16 = (const char *)[v15 UTF8String];
  size_t v17 = strlen(v16);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)v16, v17);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"), annotation.end:(", 19);
  [a2[1] end];
  GEOPolylineCoordinateAsFullString();
  id v18 = objc_claimAutoreleasedReturnValue();
  uint64_t v19 = (const char *)[v18 UTF8String];
  size_t v20 = strlen(v19);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)v19, v20);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"), annotation.type:", 19);
  uint64_t v21 = [a2[1] etaDescription];
  unint64_t v22 = [v21 routeEtaType];

  if (v22 > 6) {
    uint64_t v23 = @"VKRouteEtaUnknown";
  }
  else {
    uint64_t v23 = (__CFString *)*((void *)&off_1E5A8E9B8 + v22);
  }
  int v24 = (const char *)[(__CFString *)v23 UTF8String];
  size_t v25 = strlen(v24);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)v24, v25);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)", annotation.text:\"", 19);
  uint64_t v26 = v8;
  char v27 = (const char *)[(__CFString *)v26 UTF8String];
  size_t v28 = strlen(v27);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)v27, v28);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v10, (uint64_t)"\", sections:", 12);
  int v29 = (id *)a2[2];
  if (v29 != a2 + 3)
  {
    uint64_t v30 = 0;
    do
    {
      uint64_t v31 = (id *)v29[1];
      uint64_t v32 = v29;
      if (v31)
      {
        do
        {
          uint64_t v33 = v31;
          uint64_t v31 = (id *)*v31;
        }
        while (v31);
      }
      else
      {
        do
        {
          uint64_t v33 = (id *)v32[2];
          BOOL v34 = *v33 == v32;
          uint64_t v32 = v33;
        }
        while (!v34);
      }
      v30 += ((unsigned char *)v29[6] - (unsigned char *)v29[5]) >> 4;
      int v29 = v33;
    }
    while (v33 != a2 + 3);
  }
  uint64_t v35 = (void *)std::ostream::operator<<();
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)" }", 2);

  if ((v51 & 0x10) != 0)
  {
    unint64_t v37 = v50;
    if (v50 < v47)
    {
      unint64_t v50 = v47;
      unint64_t v37 = v47;
    }
    uint64_t v38 = (const void **)&v46;
  }
  else
  {
    if ((v51 & 8) == 0)
    {
      size_t v36 = 0;
      *((unsigned char *)this + 23) = 0;
      goto LABEL_31;
    }
    uint64_t v38 = (const void **)v45;
    unint64_t v37 = v45[2];
  }
  uint64_t v39 = *v38;
  size_t v36 = v37 - (void)*v38;
  if (v36 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (v36 >= 0x17)
  {
    uint64_t v40 = (v36 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v36 | 7) != 0x17) {
      uint64_t v40 = v36 | 7;
    }
    uint64_t v41 = v40 + 1;
    double v42 = (md::RouteRangeAnnotationRequest *)operator new(v40 + 1);
    *((void *)this + 1) = v36;
    *((void *)this + 2) = v41 | 0x8000000000000000;
    *(void *)this = v42;
    this = v42;
    goto LABEL_30;
  }
  *((unsigned char *)this + 23) = v36;
  if (v36) {
LABEL_30:
  }
    memmove(this, v39, v36);
LABEL_31:
  *((unsigned char *)this + v36) = 0;

  v44[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v44 + *(void *)(v44[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v44[1] = MEMORY[0x1E4FBA470] + 16;
  if (v49 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v52);
}

void sub_1A1F800C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::ostringstream::~ostringstream((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,mdm::Allocator>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,mdm::Allocator>>::destroy(result, *a2);
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,mdm::Allocator>>::destroy(v3, a2[1]);
    std::__destroy_at[abi:nn180100]<std::pair<GEOComposedRoute * const {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::linear_map::RouteLabelState,std::equal_to<md>,std::allocator<std::pair<md,md::RouteRangeAnnotationRequest>>,std::vector<std::allocator,std::pair<md,md::RouteRangeAnnotationRequest>>>>,0>((uint64_t)(a2 + 4));
    id v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

uint64_t std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,mdm::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,mdm::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,mdm::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(a2 + 40, *(void *)(a2 + 48));

    id v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

void std::default_delete<md::RouteSimplifier>::operator()[abi:nn180100](uint64_t a1)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 96));
  uint64_t v2 = *(void **)(a1 + 64);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    id v4 = (std::__shared_weak_count *)v3[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
  }
  id v5 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v5) {
    operator delete(v5);
  }
  std::__tree<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::__map_value_compare<GEOComposedRoute const* {__strong},std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::less<GEOComposedRoute const* {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>>>::destroy(*(void **)(a1 + 16));
  JUMPOUT(0x1A6239270);
}

void std::__tree<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::__map_value_compare<GEOComposedRoute const* {__strong},std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::less<GEOComposedRoute const* {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::__map_value_compare<GEOComposedRoute const* {__strong},std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::less<GEOComposedRoute const* {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>>>::destroy(*a1);
    std::__tree<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::__map_value_compare<GEOComposedRoute const* {__strong},std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>,std::less<GEOComposedRoute const* {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute const* {__strong},std::shared_ptr<md::ProgressiveLodRibbon>>>>::destroy(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[6];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }

    operator delete(a1);
  }
}

void std::__destroy_at[abi:nn180100]<std::pair<GEOComposedRoute * const {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,GEOComposedRoute * const {__strong}::_retain_ptr<VKLabelNavRouteEta * {__strong},GEOComposedRoute * const {__strong}::_retain_objc_arc,GEOComposedRoute * const {__strong}::_release_objc_arc,GEOComposedRoute * const {__strong}::_hash_objc,GEOComposedRoute * const {__strong}::_equal_objc>,std::equal_to<md>,std::allocator<std::pair<md,GEOComposedRoute * const {__strong}::_equal_objc>>,std::vector<std::allocator,std::pair<md,GEOComposedRoute * const {__strong}::_equal_objc>>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    id v4 = *(void **)(a1 + 8);
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 24;
      do
      {
        *(void *)(v3 - 24) = &unk_1EF559818;

        std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v3 - 56, *(void *)(v3 - 48));
        uint64_t v6 = *(void **)(v3 - 72);
        v3 -= 72;

        v5 -= 72;
      }
      while (v3 != v2);
      id v4 = *(void **)(a1 + 8);
    }
    *(void *)(a1 + 16) = v2;
    operator delete(v4);
  }
  unsigned int v7 = *(void **)a1;
}

void geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559818;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559818;

  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<GEOComposedRoute * const {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::linear_map::RouteLabelState,std::equal_to<md>,std::allocator<std::pair<md,md::RouteRangeAnnotationRequest>>,std::vector<std::allocator,std::pair<md,md::RouteRangeAnnotationRequest>>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(void *)(a1 + 16);
    id v4 = *(void **)(a1 + 8);
    if (v3 != v2)
    {
      uint64_t v5 = v3 - 384;
      do
      {
        md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)(v5 + 48));
        std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v5 + 16, *(void *)(v5 + 24));

        BOOL v6 = v5 == v2;
        v5 -= 384;
      }
      while (!v6);
      id v4 = *(void **)(a1 + 8);
    }
    *(void *)(a1 + 16) = v2;
    operator delete(v4);
  }
  unsigned int v7 = *(void **)a1;
}

void md::RouteLabelState::~RouteLabelState(md::RouteLabelState *this)
{
  uint64_t v2 = *((void *)this + 38);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 39);
    uint64_t v4 = *((void *)this + 38);
    if (v3 != v2)
    {
      do
      {
        uint64_t v5 = *(void **)(v3 - 24);
        if (v5)
        {
          do
          {
            BOOL v6 = (void *)*v5;
            operator delete(v5);
            uint64_t v5 = v6;
          }
          while (v6);
        }
        unsigned int v7 = *(void **)(v3 - 40);
        *(void *)(v3 - 40) = 0;
        if (v7) {
          operator delete(v7);
        }
        v3 -= 72;
      }
      while (v3 != v2);
      uint64_t v4 = *((void *)this + 38);
    }
    *((void *)this + 39) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 41) + 40))(*((void *)this + 41), v4, *((void *)this + 40) - v4);
  }
  uint64_t v8 = *((void *)this + 6);
  if (v8)
  {
    uint64_t v9 = *((void *)this + 7);
    uint64_t v10 = *((void *)this + 6);
    if (v9 != v8)
    {
      do
      {
        id v11 = *(std::__shared_weak_count **)(v9 - 8);
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v11->__on_zero_shared)(v11, v10);
          std::__shared_weak_count::__release_weak(v11);
        }
        v9 -= 16;
      }
      while (v9 != v8);
      uint64_t v10 = *((void *)this + 6);
    }
    *((void *)this + 7) = v8;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 9) + 40))(*((void *)this + 9), v10, *((void *)this + 8) - v10);
  }
  id v12 = (void *)*((void *)this + 2);
  if (v12)
  {
    do
    {
      unint64_t v13 = (void *)*v12;
      operator delete(v12);
      id v12 = v13;
    }
    while (v13);
  }
  size_t v14 = *(void **)this;
  *(void *)this = 0;
  if (v14) {
    operator delete(v14);
  }
}

void geo::_retain_ptr<LabelNavRouteContextObserverProxy * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559D18;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<LabelNavRouteContextObserverProxy * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559D18;

  return a1;
}

void md::LabelNavEtaLabeler::~LabelNavEtaLabeler(md::LabelNavEtaLabeler *this)
{
  uint64_t v2 = (char *)this + 576;
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy((uint64_t)this + 672, *((void *)this + 85));
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy((uint64_t)this + 640, *((void *)this + 81));
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy((uint64_t)this + 608, *((void *)this + 77));
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy((uint64_t)v2, *((void *)this + 73));
  uint64_t v3 = *((void *)this + 69);
  if (v3)
  {
    uint64_t v4 = *((void *)this + 70);
    uint64_t v5 = (void *)*((void *)this + 69);
    if (v4 != v3)
    {
      do
      {
        if (*(unsigned char *)(v4 - 6)) {
          *(unsigned char *)(v4 - 6) = 0;
        }
        std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v4 - 40, *(void *)(v4 - 32));

        v4 -= 56;
      }
      while (v4 != v3);
      uint64_t v5 = (void *)*((void *)this + 69);
    }
    *((void *)this + 70) = v3;
    operator delete(v5);
  }
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)this + 520, *((void *)this + 66));
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)this + 488, *((void *)this + 62));
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>>,mdm::Allocator>>::destroy((uint64_t)this + 456, *((void **)this + 58));
  std::__tree<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::__map_value_compare<VKRouteInfo * {__strong},std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,std::less<VKRouteInfo * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKRouteInfo * {__strong},md::PolylineOverlayInfo>,mdm::Allocator>>::destroy((uint64_t)this + 416, *((void *)this + 53));
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)this + 384, *((void *)this + 49));
  std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::destroy((uint64_t)this + 352, *((void *)this + 45));
  uint64_t v6 = *((void *)this + 40);
  if (v6)
  {
    uint64_t v7 = *((void *)this + 41);
    uint64_t v8 = *((void *)this + 40);
    if (v7 != v6)
    {
      do
      {
        uint64_t v9 = *(void **)(v7 - 8);
        v7 -= 8;
      }
      while (v7 != v6);
      uint64_t v8 = *((void *)this + 40);
    }
    *((void *)this + 41) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 43) + 40))(*((void *)this + 43), v8, *((void *)this + 42) - v8);
  }
  uint64_t v10 = *((void *)this + 36);
  if (v10)
  {
    uint64_t v11 = *((void *)this + 37);
    uint64_t v12 = *((void *)this + 36);
    if (v11 != v10)
    {
      do
      {
        unint64_t v13 = *(void **)(v11 - 8);
        v11 -= 8;
      }
      while (v11 != v10);
      uint64_t v12 = *((void *)this + 36);
    }
    *((void *)this + 37) = v10;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 39) + 40))(*((void *)this + 39), v12, *((void *)this + 38) - v12);
  }
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>>,mdm::Allocator>>::destroy((uint64_t)this + 256, *((void **)this + 33));
  uint64_t v14 = *((void *)this + 27);
  if (v14)
  {
    *((void *)this + 28) = v14;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 30) + 40))(*((void *)this + 30), v14, *((void *)this + 29) - v14);
  }
  uint64_t v15 = *((void *)this + 23);
  if (v15)
  {
    uint64_t v16 = *((void *)this + 24);
    uint64_t v17 = *((void *)this + 23);
    if (v16 != v15)
    {
      do
      {
        id v18 = *(std::__shared_weak_count **)(v16 - 8);
        if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, uint64_t))v18->__on_zero_shared)(v18, v17);
          std::__shared_weak_count::__release_weak(v18);
        }
        v16 -= 16;
      }
      while (v16 != v15);
      uint64_t v17 = *((void *)this + 23);
    }
    *((void *)this + 24) = v15;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 26) + 40))(*((void *)this + 26), v17, *((void *)this + 25) - v17);
  }
  uint64_t v19 = (void (***)(void, void))*((void *)this + 19);
  if (v19)
  {
    size_t v20 = (void (***)(void, void))*((void *)this + 20);
    uint64_t v21 = *((void *)this + 19);
    if (v20 != v19)
    {
      unint64_t v22 = v20 - 3;
      uint64_t v23 = v20 - 3;
      int v24 = v20 - 3;
      do
      {
        size_t v25 = *v24;
        v24 -= 3;
        (*v25)(v23, v21);
        v22 -= 3;
        BOOL v26 = v23 == v19;
        uint64_t v23 = v24;
      }
      while (!v26);
      uint64_t v21 = *((void *)this + 19);
    }
    *((void *)this + 20) = v19;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 22) + 40))(*((void *)this + 22), v21, *((void *)this + 21) - v21);
  }
  *((void *)this + 14) = &unk_1EF559D18;

  char v27 = (void *)*((void *)this + 10);
  if (v27)
  {
    *((void *)this + 11) = v27;
    operator delete(v27);
  }
  size_t v28 = (void *)*((void *)this + 7);
  if (v28)
  {
    *((void *)this + 8) = v28;
    operator delete(v28);
  }
  uint64_t v29 = *((void *)this + 6);
  *((void *)this + 6) = 0;
  if (v29) {
    std::default_delete<md::RouteSimplifier>::operator()[abi:nn180100](v29);
  }
  uint64_t v30 = *((void *)this + 5);
  *((void *)this + 5) = 0;
  if (v30) {
    (*(void (**)(uint64_t))(*(void *)v30 + 8))(v30);
  }
  *((void *)this + 2) = &unk_1EF5595D8;
}

void gatherRoutesFromContext(VKRouteContext *a1, void *a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = v3;
  a1->_routeInfo = 0;
  p_routeInfo = (objc_class *)&a1->_routeInfo;
  *(void *)&a1->_useType = 0;
  a1->super.Class isa = (Class)&a1->_routeInfo;
  if (!v3) {
    goto LABEL_67;
  }
  uint64_t v6 = [v3 routeInfo];
  uint64_t v7 = [v6 route];
  uint64_t v8 = v7;
  if (!*(void *)&a1->_useType)
  {
    uint64_t v21 = *(VKRouteInfo **)p_routeInfo;
    goto LABEL_30;
  }
  Class isa = a1->super.isa;
  routeInfo = a1->_routeInfo;
  a1->super.Class isa = p_routeInfo;
  routeInfo->_etaDescription = 0;
  *(void *)p_routeInfo = 0;
  *(void *)&a1->_useType = 0;
  if (*((void *)isa + 1)) {
    uint64_t v11 = (VKRouteInfo *)*((void *)isa + 1);
  }
  else {
    uint64_t v11 = (VKRouteInfo *)isa;
  }
  if (!v11)
  {
    uint64_t v21 = 0;
LABEL_30:
    unint64_t v22 = &a1->_routeInfo;
    uint64_t v23 = &a1->_routeInfo;
    if (v21)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v23 = (VKRouteInfo **)v21;
          unint64_t trafficAnnotations = (unint64_t)v21->_trafficAnnotations;
          if ((unint64_t)v7 >= trafficAnnotations) {
            break;
          }
          uint64_t v21 = *v23;
          unint64_t v22 = v23;
          if (!*v23) {
            goto LABEL_37;
          }
        }
        if (trafficAnnotations >= (unint64_t)v7) {
          break;
        }
        uint64_t v21 = v23[1];
        if (!v21)
        {
          unint64_t v22 = v23 + 1;
          goto LABEL_37;
        }
      }
    }
    else
    {
LABEL_37:
      size_t v25 = (uint64_t *)operator new(0x28uLL);
      uint64_t v25[4] = (uint64_t)v8;
      *size_t v25 = 0;
      v25[1] = 0;
      v25[2] = (uint64_t)v23;
      void *v22 = (VKRouteInfo *)v25;
      BOOL v26 = *(objc_class **)a1->super.isa;
      if (v26)
      {
        a1->super.Class isa = v26;
        size_t v25 = (uint64_t *)*v22;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)a1->_routeInfo, v25);
      ++*(void *)&a1->_useType;
    }
    goto LABEL_48;
  }
  etaDescription = v11->_etaDescription;
  if (etaDescription)
  {
    unint64_t v13 = (VKRouteInfo *)etaDescription->super.isa;
    if ((VKRouteInfo *)etaDescription->super.isa == v11)
    {
      etaDescription->super.Class isa = 0;
      while (1)
      {
        char v27 = (VKRouteEtaDescription *)etaDescription->_etaText._vptr$_retain_ptr;
        if (!v27) {
          break;
        }
        do
        {
          etaDescription = v27;
          char v27 = (VKRouteEtaDescription *)v27->super.isa;
        }
        while (v27);
      }
    }
    else
    {
      for (etaDescription->_etaText._vptr$_retain_ptr = 0;
            v13;
            unint64_t v13 = (VKRouteInfo *)etaDescription->_etaText._vptr$_retain_ptr)
      {
        do
        {
          etaDescription = (VKRouteEtaDescription *)v13;
          unint64_t v13 = (VKRouteInfo *)v13->super.isa;
        }
        while (v13);
      }
    }
  }
  uint64_t v14 = *(VKRouteInfo **)p_routeInfo;
  uint64_t v15 = &a1->_routeInfo;
  uint64_t v16 = &a1->_routeInfo;
  if (*(void *)p_routeInfo)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v16 = (VKRouteInfo **)v14;
        unint64_t v17 = (unint64_t)v14->_trafficAnnotations;
        if ((unint64_t)v7 >= v17) {
          break;
        }
        uint64_t v14 = *v16;
        uint64_t v15 = v16;
        if (!*v16) {
          goto LABEL_19;
        }
      }
      if (v17 >= (unint64_t)v7) {
        break;
      }
      uint64_t v14 = v16[1];
      if (!v14)
      {
        uint64_t v15 = v16 + 1;
        goto LABEL_19;
      }
    }
    std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy(v11);
    if (!etaDescription) {
      goto LABEL_48;
    }
    goto LABEL_45;
  }
LABEL_19:
  objc_storeStrong((id *)&v11->_trafficAnnotations, v7);
  v11->super.Class isa = 0;
  v11->_route = 0;
  v11->_etaDescription = (VKRouteEtaDescription *)v16;
  _DWORD *v15 = v11;
  id v18 = *(objc_class **)a1->super.isa;
  if (v18)
  {
    a1->super.Class isa = v18;
    uint64_t v11 = *v15;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)a1->_routeInfo, (uint64_t *)v11);
  ++*(void *)&a1->_useType;
  if (!etaDescription) {
    goto LABEL_48;
  }
  obuint64_t j = etaDescription->_etaText._obj;
  if (obj)
  {
    size_t v20 = (VKRouteEtaDescription *)obj->super.isa;
    if ((VKRouteEtaDescription *)obj->super.isa == etaDescription)
    {
      obj->super.Class isa = 0;
      while (1)
      {
        uint64_t v41 = (NSString *)obj[1].super.isa;
        if (!v41) {
          break;
        }
        do
        {
          obuint64_t j = v41;
          uint64_t v41 = (NSString *)v41->super.isa;
        }
        while (v41);
      }
    }
    else
    {
      for (obj[1].super.isa = 0; v20; size_t v20 = (VKRouteEtaDescription *)obj[1].super.isa)
      {
        do
        {
          obuint64_t j = (NSString *)v20;
          size_t v20 = (VKRouteEtaDescription *)v20->super.isa;
        }
        while (v20);
      }
    }
    std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy(etaDescription);
    etaDescription = (VKRouteEtaDescription *)obj;
LABEL_45:
    for (uint64_t i = etaDescription->_etaText._obj; i; uint64_t i = (NSString *)i[2].super.isa)
      etaDescription = (VKRouteEtaDescription *)i;
  }
  std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy(etaDescription);
LABEL_48:

  long long v44 = 0u;
  long long v45 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  uint64_t v29 = objc_msgSend(v4, "alternateRoutes", 0);
  uint64_t v30 = [v29 countByEnumeratingWithState:&v42 objects:v46 count:16];
  if (v30)
  {
    uint64_t v31 = *(void *)v43;
    do
    {
      for (uint64_t j = 0; j != v30; ++j)
      {
        if (*(void *)v43 != v31) {
          objc_enumerationMutation(v29);
        }
        uint64_t v33 = [*(id *)(*((void *)&v42 + 1) + 8 * j) route];
        uint64_t v34 = (uint64_t)v33;
        uint64_t v35 = *(VKRouteInfo **)p_routeInfo;
        size_t v36 = &a1->_routeInfo;
        unint64_t v37 = &a1->_routeInfo;
        if (*(void *)p_routeInfo)
        {
          while (1)
          {
            while (1)
            {
              unint64_t v37 = (VKRouteInfo **)v35;
              unint64_t v38 = (unint64_t)v35->_trafficAnnotations;
              if ((unint64_t)v33 >= v38) {
                break;
              }
              uint64_t v35 = *v37;
              size_t v36 = v37;
              if (!*v37) {
                goto LABEL_62;
              }
            }
            if (v38 >= (unint64_t)v33) {
              break;
            }
            uint64_t v35 = v37[1];
            if (!v35)
            {
              size_t v36 = v37 + 1;
              goto LABEL_62;
            }
          }
        }
        else
        {
LABEL_62:
          uint64_t v39 = (uint64_t *)operator new(0x28uLL);
          v39[4] = v34;
          uint64_t *v39 = 0;
          v39[1] = 0;
          v39[2] = (uint64_t)v37;
          *size_t v36 = (VKRouteInfo *)v39;
          uint64_t v40 = *(objc_class **)a1->super.isa;
          if (v40)
          {
            a1->super.Class isa = v40;
            uint64_t v39 = (uint64_t *)*v36;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)a1->_routeInfo, v39);
          ++*(void *)&a1->_useType;
        }
      }
      uint64_t v30 = [v29 countByEnumeratingWithState:&v42 objects:v46 count:16];
    }
    while (v30);
  }

LABEL_67:
}

void sub_1A1F81018(_Unwind_Exception *a1)
{
  std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy(*v4);
  _Unwind_Resume(a1);
}

uint64_t ****std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<GEOComposedRoute * {__strong},std::__tree_node<GEOComposedRoute * {__strong},void *> *,long> &,std::__tree_const_iterator<GEOComposedRoute * {__strong},std::__tree_node<GEOComposedRoute * {__strong},void *> *,long> &,std::__tree_const_iterator<GEOComposedRoute * {__strong},std::__tree_node<GEOComposedRoute * {__strong},void *> *,long> &,std::__tree_const_iterator<GEOComposedRoute * {__strong},std::__tree_node<GEOComposedRoute * {__strong},void *> *,long> &,std::insert_iterator<std::set<GEOComposedRoute * {__strong}>> &>(uint64_t ****result, uint64_t ****a2, uint64_t ****a3, uint64_t a4, void *a5, uint64_t ****a6)
{
  uint64_t v7 = result;
  uint64_t v8 = *a2;
  uint64_t v9 = *a3;
  if (*a2 == *a3)
  {
LABEL_39:
    long long v27 = *(_OWORD *)a6;
    uint64_t v9 = v8;
    goto LABEL_41;
  }
  for (uint64_t i = *(void **)a4; *(void *)a4 != *a5; uint64_t i = *(void **)a4)
  {
    uint64_t v15 = (uint64_t *)v8[4];
    unint64_t v16 = i[4];
    if ((unint64_t)v15 >= v16)
    {
      if (v16 >= (unint64_t)v15)
      {
        uint64_t v23 = v8[1];
        if (v23)
        {
          do
          {
            int v24 = (uint64_t ***)v23;
            uint64_t v23 = (uint64_t **)*v23;
          }
          while (v23);
        }
        else
        {
          do
          {
            int v24 = (uint64_t ***)v8[2];
            BOOL v20 = *v24 == (uint64_t **)v8;
            uint64_t v8 = v24;
          }
          while (!v20);
        }
        *a2 = v24;
        size_t v25 = *(void **)a4;
        BOOL v26 = *(void **)(*(void *)a4 + 8);
        if (v26)
        {
          do
          {
            unint64_t v22 = v26;
            BOOL v26 = (void *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            unint64_t v22 = (void *)v25[2];
            BOOL v20 = *v22 == (void)v25;
            size_t v25 = v22;
          }
          while (!v20);
        }
      }
      else
      {
        uint64_t v21 = (void *)i[1];
        if (v21)
        {
          do
          {
            unint64_t v22 = v21;
            uint64_t v21 = (void *)*v21;
          }
          while (v21);
        }
        else
        {
          do
          {
            unint64_t v22 = (void *)i[2];
            BOOL v20 = *v22 == (void)i;
            uint64_t i = v22;
          }
          while (!v20);
        }
      }
      *(void *)a4 = v22;
    }
    else
    {
      uint64_t result = std::insert_iterator<std::set<GEOComposedRoute * {__strong}>>::operator=[abi:nn180100](a6, v15);
      unint64_t v17 = *a2;
      id v18 = (*a2)[1];
      if (v18)
      {
        do
        {
          uint64_t v19 = (uint64_t ***)v18;
          id v18 = (uint64_t **)*v18;
        }
        while (v18);
      }
      else
      {
        do
        {
          uint64_t v19 = (uint64_t ***)v17[2];
          BOOL v20 = *v19 == (uint64_t **)v17;
          unint64_t v17 = v19;
        }
        while (!v20);
      }
      *a2 = v19;
    }
    uint64_t v8 = *a2;
    uint64_t v9 = *a3;
    if (*a2 == *a3) {
      goto LABEL_39;
    }
  }
  long long v27 = *(_OWORD *)a6;
  long long v30 = *(_OWORD *)a6;
  if (v8 != v9)
  {
    do
    {
      uint64_t result = std::insert_iterator<std::set<GEOComposedRoute * {__strong}>>::operator=[abi:nn180100]((uint64_t ****)&v30, (uint64_t *)v8[4]);
      size_t v28 = v8[1];
      if (v28)
      {
        do
        {
          uint64_t v29 = (uint64_t ***)v28;
          size_t v28 = (uint64_t **)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          uint64_t v29 = (uint64_t ***)v8[2];
          BOOL v20 = *v29 == (uint64_t **)v8;
          uint64_t v8 = v29;
        }
        while (!v20);
      }
      uint64_t v8 = v29;
    }
    while (v29 != v9);
    long long v27 = v30;
  }
LABEL_41:
  *uint64_t v7 = v9;
  *(_OWORD *)(v7 + 1) = v27;
  return result;
}

void ___ZL36GEOGetVectorKitLabelNavEtaLabelerLogv_block_invoke()
{
  os_log_t v0 = os_log_create("com.apple.VectorKit", "LabelNavEtaLabeler");
  uint64_t v1 = (void *)GEOGetVectorKitLabelNavEtaLabelerLog(void)::log;
  GEOGetVectorKitLabelNavEtaLabelerLog(void)::log = (uint64_t)v0;
}

uint64_t ****std::insert_iterator<std::set<GEOComposedRoute * {__strong}>>::operator=[abi:nn180100](uint64_t ****a1, uint64_t *a2)
{
  uint64_t v4 = *a1;
  uint64_t v5 = (uint64_t **)a1[1];
  uint64_t v6 = (uint64_t **)(*a1 + 1);
  if (v6 != v5)
  {
    unint64_t v7 = (unint64_t)v5[4];
    if (v7 <= (unint64_t)a2)
    {
      if (v7 >= (unint64_t)a2)
      {
        unint64_t v16 = (uint64_t *)a1[1];
        goto LABEL_44;
      }
      uint64_t v11 = v5 + 1;
      uint64_t v12 = v5[1];
      if (v12)
      {
        do
        {
          uint64_t v11 = (uint64_t **)v12;
          uint64_t v12 = (uint64_t *)*v12;
          uint64_t v5 = v11;
          unint64_t v13 = v11;
        }
        while (v12);
      }
      else
      {
        unint64_t v13 = (uint64_t **)a1[1];
        do
        {
          uint64_t v19 = (uint64_t *)v13;
          unint64_t v13 = (uint64_t **)v13[2];
        }
        while (*v13 != v19);
      }
      if (v13 == v6 || v13[4] > a2) {
        goto LABEL_21;
      }
      BOOL v20 = *v6;
      if (!*v6) {
        goto LABEL_24;
      }
      while (1)
      {
        while (1)
        {
          uint64_t v5 = (uint64_t **)v20;
          unint64_t v21 = v20[4];
          if (v21 <= (unint64_t)a2) {
            break;
          }
          BOOL v20 = *v5;
          uint64_t v6 = v5;
          if (!*v5) {
            goto LABEL_41;
          }
        }
        if (v21 >= (unint64_t)a2) {
          break;
        }
        uint64_t v6 = v5 + 1;
        BOOL v20 = v5[1];
        if (!v20) {
          goto LABEL_41;
        }
      }
LABEL_50:
      uint64_t v11 = v6;
      goto LABEL_21;
    }
  }
  uint64_t v8 = *v5;
  if (*v4 == v5)
  {
    uint64_t v10 = (uint64_t *)a1[1];
    goto LABEL_16;
  }
  if (v8)
  {
    uint64_t v9 = *v5;
    do
    {
      uint64_t v10 = v9;
      uint64_t v9 = (uint64_t *)v9[1];
    }
    while (v9);
  }
  else
  {
    uint64_t v14 = (uint64_t *)a1[1];
    do
    {
      uint64_t v10 = (uint64_t *)v14[2];
      BOOL v15 = *v10 == (void)v14;
      uint64_t v14 = v10;
    }
    while (v15);
  }
  if (v10[4] < (unint64_t)a2)
  {
LABEL_16:
    BOOL v15 = v8 == 0;
    if (v8) {
      uint64_t v11 = (uint64_t **)(v10 + 1);
    }
    else {
      uint64_t v11 = (uint64_t **)a1[1];
    }
    if (!v15) {
      uint64_t v5 = (uint64_t **)v10;
    }
LABEL_21:
    unint64_t v16 = *v11;
    uint64_t v6 = v11;
    if (*v11) {
      goto LABEL_44;
    }
    goto LABEL_41;
  }
  unint64_t v17 = *v6;
  if (*v6)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v5 = (uint64_t **)v17;
        unint64_t v18 = v17[4];
        if (v18 <= (unint64_t)a2) {
          break;
        }
        unint64_t v17 = *v5;
        uint64_t v6 = v5;
        if (!*v5) {
          goto LABEL_41;
        }
      }
      if (v18 >= (unint64_t)a2) {
        goto LABEL_50;
      }
      uint64_t v6 = v5 + 1;
      unint64_t v17 = v5[1];
      if (!v17) {
        goto LABEL_41;
      }
    }
  }
LABEL_24:
  uint64_t v5 = (uint64_t **)(*a1 + 1);
LABEL_41:
  unint64_t v16 = (uint64_t *)operator new(0x28uLL);
  v16[4] = (uint64_t)a2;
  uint64_t *v16 = 0;
  v16[1] = 0;
  v16[2] = (uint64_t)v5;
  *uint64_t v6 = v16;
  unint64_t v22 = **v4;
  uint64_t v23 = v16;
  if (v22)
  {
    void *v4 = (uint64_t **)v22;
    uint64_t v23 = *v6;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[1], v23);
  v4[2] = (uint64_t **)((char *)v4[2] + 1);
LABEL_44:
  a1[1] = (uint64_t ***)v16;
  int v24 = (uint64_t *)v16[1];
  if (v24)
  {
    do
    {
      size_t v25 = v24;
      int v24 = (uint64_t *)*v24;
    }
    while (v24);
  }
  else
  {
    do
    {
      size_t v25 = (uint64_t *)v16[2];
      BOOL v15 = *v25 == (void)v16;
      unint64_t v16 = v25;
    }
    while (!v15);
  }
  a1[1] = (uint64_t ***)v25;
  return a1;
}

void md::LabelNavEtaLabeler::recreateRouteCollider(md::LabelNavEtaLabeler *this, VKRouteContext *a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2;
  uint64_t v47 = 0;
  uint64_t v48 = 0;
  char v49 = 0;
  unint64_t v38 = v2;
  if (v2)
  {
    id v3 = [(VKRouteContext *)v2 routeInfo];

    if (v3)
    {
      uint64_t v4 = [(VKRouteContext *)v38 routeInfo];
      uint64_t v5 = [v4 route];

      if ([v5 pointCount] < 2)
      {
        unint64_t v7 = 0;
      }
      else
      {
        uint64_t v6 = (char *)operator new(8uLL);
        *(void *)uint64_t v6 = v5;
        unint64_t v7 = v6 + 8;
        uint64_t v48 = v6 + 8;
        char v49 = v6 + 8;
        uint64_t v47 = v6;
      }
    }
    else
    {
      unint64_t v7 = 0;
    }
    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    uint64_t v8 = [(VKRouteContext *)v38 alternateRoutes];
    uint64_t v9 = [v8 countByEnumeratingWithState:&v43 objects:v50 count:16];
    if (v9)
    {
      uint64_t v10 = *(void **)v44;
      std::string __p = *(void **)v44;
      uint64_t v41 = v8;
      do
      {
        uint64_t v11 = 0;
        uint64_t v42 = v9;
        do
        {
          if (*(void **)v44 != v10) {
            objc_enumerationMutation(v8);
          }
          uint64_t v12 = [*(id *)(*((void *)&v43 + 1) + 8 * v11) route];
          if ([v12 pointCount] >= 2)
          {
            if (v7 < v49)
            {
              *(void *)unint64_t v7 = v12;
              unint64_t v13 = v7 + 8;
LABEL_38:
              uint64_t v48 = v13;
              unint64_t v7 = v13;
              goto LABEL_39;
            }
            uint64_t v14 = (char *)v47;
            int64_t v15 = v7 - (unsigned char *)v47;
            uint64_t v16 = (v7 - (unsigned char *)v47) >> 3;
            unint64_t v17 = v16 + 1;
            if ((unint64_t)(v16 + 1) >> 61) {
              abort();
            }
            uint64_t v18 = v49 - (unsigned char *)v47;
            if ((v49 - (unsigned char *)v47) >> 2 > v17) {
              unint64_t v17 = v18 >> 2;
            }
            if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
              unint64_t v19 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v19 = v17;
            }
            if (v19)
            {
              if (v19 >> 61) {
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              BOOL v20 = (char *)operator new(8 * v19);
            }
            else
            {
              BOOL v20 = 0;
            }
            unint64_t v21 = &v20[8 * v16];
            unint64_t v22 = &v20[8 * v19];
            *(void *)unint64_t v21 = v12;
            unint64_t v13 = v21 + 8;
            int64_t v23 = v7 - v14;
            if (v7 == v14)
            {
              uint64_t v47 = &v20[8 * v16];
              uint64_t v48 = v21 + 8;
              char v49 = v22;
            }
            else
            {
              unint64_t v24 = v23 - 8;
              if ((unint64_t)(v23 - 8) <= 0x77
                || (unint64_t v25 = v24 >> 3, &v7[-8 * (v24 >> 3) - 8] < v21) && &v20[v15 - (v24 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
              {
                BOOL v26 = v7;
                goto LABEL_32;
              }
              unint64_t v30 = v25 + 1;
              uint64_t v31 = (v25 + 1) & 0x3FFFFFFFFFFFFFFCLL;
              BOOL v26 = &v7[-8 * v31];
              uint64_t v32 = &v20[8 * v16 - 16];
              uint64_t v33 = v7 - 32;
              uint64_t v34 = v31;
              do
              {
                long long v36 = *(_OWORD *)v33;
                long long v35 = *((_OWORD *)v33 + 1);
                *(_OWORD *)uint64_t v33 = 0uLL;
                *((_OWORD *)v33 + 1) = 0uLL;
                v33 -= 32;
                *((_OWORD *)v32 - 1) = v36;
                *(_OWORD *)uint64_t v32 = v35;
                v32 -= 32;
                v34 -= 4;
              }
              while (v34);
              v21 -= 8 * v31;
              if (v30 != v31)
              {
                do
                {
LABEL_32:
                  uint64_t v27 = *((void *)v26 - 1);
                  v26 -= 8;
                  *(void *)BOOL v26 = 0;
                  *((void *)v21 - 1) = v27;
                  v21 -= 8;
                }
                while (v26 != v14);
              }
              unint64_t v7 = (char *)v47;
              size_t v28 = v48;
              uint64_t v47 = v21;
              uint64_t v48 = v13;
              char v49 = v22;
              if (v28 != v7)
              {
                uint64_t v10 = __p;
                uint64_t v8 = v41;
                uint64_t v9 = v42;
                do
                {
                  uint64_t v29 = (void *)*((void *)v28 - 1);
                  v28 -= 8;
                }
                while (v28 != v7);
                if (!v7) {
                  goto LABEL_38;
                }
LABEL_37:
                operator delete(v7);
                goto LABEL_38;
              }
            }
            uint64_t v10 = __p;
            uint64_t v8 = v41;
            uint64_t v9 = v42;
            if (!v7) {
              goto LABEL_38;
            }
            goto LABEL_37;
          }
LABEL_39:

          ++v11;
        }
        while (v11 != v9);
        uint64_t v37 = [v8 countByEnumeratingWithState:&v43 objects:v50 count:16];
        uint64_t v9 = v37;
      }
      while (v37);
    }
  }
  if (*((unsigned char *)this + 450)) {
    operator new();
  }
  operator new();
}

void sub_1A1F83210(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,md::DynamicTrafficTileList *a23,void *__p,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,char a39)
{
  _Unwind_Resume(a1);
}

void md::LabelNavEtaLabeler::prepareAnnotatableSectionsRoutes(md::LabelNavEtaLabeler *this)
{
  v86[2] = *(void **)MEMORY[0x1E4F143B8];
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)this + 384, *((void *)this + 49));
  *((void *)this + 51) = 0;
  *((void *)this + 48) = (char *)this + 392;
  *((void *)this + 49) = 0;
  double v59 = this;
  if (!*((void *)this + 3)) {
    return;
  }
  if (GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken, &__block_literal_global_6571);
  }
  uint64_t v2 = (void *)GEOGetVectorKitLabelNavEtaLabelerLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetVectorKitLabelNavEtaLabelerLog(void)::log, OS_LOG_TYPE_INFO))
  {
    id v3 = *((id *)this + 3);
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v3;
    uint64_t v4 = v2;
    _os_log_impl(&dword_1A1780000, v4, OS_LOG_TYPE_INFO, "Updating annotatable sections for routes in routeContext:%p", (uint8_t *)&buf, 0xCu);
  }
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v81 = 0x4812000000;
  long long v82 = __Block_byref_object_copy__6579;
  long long v83 = __Block_byref_object_dispose__6580;
  long long v84 = "";
  v86[0] = 0;
  v86[1] = 0;
  double v85 = v86;
  unsigned int v5 = [*((id *)this + 3) totalRouteCount];
  if (v5)
  {
    uint64_t v6 = 1;
    do
    {
      id v7 = *((id *)this + 3);
      v69[0] = MEMORY[0x1E4F143A8];
      v69[1] = 3221225472;
      v69[2] = ___ZN2md18LabelNavEtaLabeler32prepareAnnotatableSectionsRoutesEv_block_invoke;
      v69[3] = &unk_1E5A8E998;
      int v70 = v6;
      v69[4] = &buf;
      v69[5] = this;
      [v7 forEachSectionWithShareCount:v6 dothis:v69];

      uint64_t v6 = (v6 + 1);
    }
    while (v6 <= v5);
  }
  id v8 = *((id *)this + 3);
  double v57 = [v8 routeInfo];

  if (v57)
  {
    uint64_t v9 = *((void *)&buf + 1);
    uint64_t v10 = [v57 route];
    uint64_t v11 = (uint64_t)v10;
    unint64_t v13 = (uint64_t **)(v9 + 56);
    uint64_t v12 = *(uint64_t **)(v9 + 56);
    if (v12)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v14 = (uint64_t **)v12;
          unint64_t v15 = v12[4];
          if ((unint64_t)v10 >= v15) {
            break;
          }
          uint64_t v12 = *v14;
          unint64_t v13 = v14;
          if (!*v14) {
            goto LABEL_17;
          }
        }
        if (v15 >= (unint64_t)v10) {
          break;
        }
        uint64_t v12 = v14[1];
        if (!v12)
        {
          unint64_t v13 = v14 + 1;
          goto LABEL_17;
        }
      }

      uint64_t v16 = (uint64_t *)v14;
    }
    else
    {
      uint64_t v14 = (uint64_t **)(v9 + 56);
LABEL_17:
      uint64_t v16 = (uint64_t *)operator new(0x48uLL);
      v16[6] = 0;
      v16[4] = v11;
      {
        operator new();
      }
      v16[7] = mdm::Allocator::instance(void)::alloc;
      v16[8] = 0;
      v16[5] = (uint64_t)(v16 + 6);
      uint64_t *v16 = 0;
      v16[1] = 0;
      v16[2] = (uint64_t)v14;
      *unint64_t v13 = v16;
      uint64_t v17 = **(void **)(v9 + 48);
      uint64_t v18 = v16;
      if (v17)
      {
        *(void *)(v9 + 48) = v17;
        uint64_t v18 = *v13;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v9 + 56), v18);
      ++*(void *)(v9 + 64);
    }
    unint64_t v19 = [v57 route];
    BOOL v20 = md::LabelNavEtaLabeler::annotatableSectionsForRoute(v59, v19);

    if (GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken, &__block_literal_global_6571);
    }
    unint64_t v21 = (id)GEOGetVectorKitLabelNavEtaLabelerLog(void)::log;
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_INFO)) {
      goto LABEL_33;
    }
    unint64_t v22 = [v57 route];
    int64_t v23 = [v57 route];
    [v23 endRouteCoordinate];
    GEOPolylineCoordinateAsFullString();
    id v24 = objc_claimAutoreleasedReturnValue();
    uint64_t v25 = [v24 UTF8String];
    buildStringForAnnotatableSections(v67, v16 + 5);
    int v26 = v68;
    uint64_t v27 = (void **)v67[0];
    buildStringForAnnotatableSections(__p, v20);
    size_t v28 = v67;
    if (v26 < 0) {
      size_t v28 = v27;
    }
    if (v66 >= 0) {
      uint64_t v29 = __p;
    }
    else {
      uint64_t v29 = (void **)__p[0];
    }
    *(_DWORD *)float v72 = 134218754;
    uint64_t v73 = v22;
    __int16 v74 = 2080;
    uint64_t v75 = v25;
    __int16 v76 = 2080;
    double v77 = v28;
    __int16 v78 = 2080;
    uint64_t v79 = v29;
    _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_INFO, "main:%p end:(%s) shareSections:%s annotatableSections:%s", v72, 0x2Au);
    if (v66 < 0)
    {
      operator delete(__p[0]);
      if ((v68 & 0x80000000) == 0) {
        goto LABEL_32;
      }
    }
    else if ((v68 & 0x80000000) == 0)
    {
LABEL_32:

LABEL_33:
      goto LABEL_34;
    }
    operator delete(v67[0]);
    goto LABEL_32;
  }
LABEL_34:
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  unint64_t v30 = [*((id *)v59 + 3) alternateRoutes];
  uint64_t v31 = [v30 countByEnumeratingWithState:&v61 objects:v71 count:16];
  if (v31)
  {
    uint64_t v32 = *(void *)v62;
    do
    {
      uint64_t v58 = v31;
      for (uint64_t i = 0; i != v58; ++i)
      {
        if (*(void *)v62 != v32) {
          objc_enumerationMutation(v30);
        }
        uint64_t v34 = *(void **)(*((void *)&v61 + 1) + 8 * i);
        uint64_t v35 = *((void *)&buf + 1);
        long long v36 = [v34 route];
        uint64_t v37 = (uint64_t)v36;
        uint64_t v39 = (uint64_t **)(v35 + 56);
        unint64_t v38 = *(uint64_t **)(v35 + 56);
        if (v38)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v40 = (uint64_t **)v38;
              unint64_t v41 = v38[4];
              if ((unint64_t)v36 >= v41) {
                break;
              }
              unint64_t v38 = *v40;
              uint64_t v39 = v40;
              if (!*v40) {
                goto LABEL_46;
              }
            }
            if (v41 >= (unint64_t)v36) {
              break;
            }
            unint64_t v38 = v40[1];
            if (!v38)
            {
              uint64_t v39 = v40 + 1;
              goto LABEL_46;
            }
          }

          uint64_t v42 = (uint64_t *)v40;
        }
        else
        {
          uint64_t v40 = (uint64_t **)(v35 + 56);
LABEL_46:
          uint64_t v42 = (uint64_t *)operator new(0x48uLL);
          v42[6] = 0;
          v42[4] = v37;
          {
            operator new();
          }
          v42[7] = mdm::Allocator::instance(void)::alloc;
          v42[8] = 0;
          v42[5] = (uint64_t)(v42 + 6);
          *uint64_t v42 = 0;
          v42[1] = 0;
          v42[2] = (uint64_t)v40;
          uint64_t *v39 = v42;
          uint64_t v43 = **(void **)(v35 + 48);
          long long v44 = v42;
          if (v43)
          {
            *(void *)(v35 + 48) = v43;
            long long v44 = *v39;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v35 + 56), v44);
          ++*(void *)(v35 + 64);
        }
        long long v45 = [v34 route];
        long long v46 = md::LabelNavEtaLabeler::annotatableSectionsForRoute(v59, v45);

        if (GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken != -1) {
          dispatch_once(&GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken, &__block_literal_global_6571);
        }
        uint64_t v47 = (id)GEOGetVectorKitLabelNavEtaLabelerLog(void)::log;
        if (os_log_type_enabled(v47, OS_LOG_TYPE_INFO))
        {
          double v60 = [v34 route];
          uint64_t v48 = [v34 route];
          [v48 endRouteCoordinate];
          GEOPolylineCoordinateAsFullString();
          id v49 = objc_claimAutoreleasedReturnValue();
          uint64_t v50 = [v49 UTF8String];
          buildStringForAnnotatableSections(v67, v42 + 5);
          uint64_t v51 = v32;
          uint64_t v52 = v30;
          int v53 = v68;
          float v54 = (void **)v67[0];
          buildStringForAnnotatableSections(__p, v46);
          uint64_t v55 = v67;
          if (v53 < 0) {
            uint64_t v55 = v54;
          }
          BOOL v56 = __p;
          if (v66 < 0) {
            BOOL v56 = (void **)__p[0];
          }
          *(_DWORD *)float v72 = 134218754;
          uint64_t v73 = v60;
          __int16 v74 = 2080;
          uint64_t v75 = v50;
          __int16 v76 = 2080;
          double v77 = v55;
          __int16 v78 = 2080;
          uint64_t v79 = v56;
          _os_log_impl(&dword_1A1780000, v47, OS_LOG_TYPE_INFO, "alternate:%p end:(%s) shareSections:%s annotatableSections:%s", v72, 0x2Au);
          if (v66 < 0) {
            operator delete(__p[0]);
          }
          unint64_t v30 = v52;
          if (v68 < 0) {
            operator delete(v67[0]);
          }

          uint64_t v32 = v51;
        }
      }
      uint64_t v31 = [v30 countByEnumeratingWithState:&v61 objects:v71 count:16];
    }
    while (v31);
  }

  _Block_object_dispose(&buf, 8);
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>>>::destroy(v86[0]);
}

void sub_1A1F83E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0) {
    operator delete(__p);
  }

  _Block_object_dispose((const void *)(v38 - 192), 8);
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>>>::destroy(*(void **)(v38 - 136));
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__6579(void *result, void *a2)
{
  result[6] = a2[6];
  uint64_t v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  uint64_t v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *uint64_t v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__6580(uint64_t a1)
{
}

void ___ZN2md18LabelNavEtaLabeler32prepareAnnotatableSectionsRoutesEv_block_invoke(uint64_t a1, id *a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(unsigned int *)(a1 + 48);
  if (v5 < 2)
  {
    unsigned int v7 = 0;
  }
  else
  {
    uint64_t v6 = 0;
    unsigned int v7 = 0;
    unsigned int v8 = -1;
    uint64_t v9 = a2;
    while (1)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        break;
      }
      id v86 = [*v9 route];
      unsigned int v10 = [v86 expectedTime];

      if (v10 < v8)
      {
        id v87 = [*v9 route];
        unsigned int v8 = [v87 expectedTime];

        unsigned int v7 = v6;
      }
      ++v6;
      v9 += 3;
      if (v5 == v6) {
        goto LABEL_9;
      }
    }
    unsigned int v7 = v6;
  }
LABEL_9:
  id v88 = a2[3 * v7];
  unint64_t v11 = [v88 route];
  uint64_t v12 = (void *)v11;
  unint64_t v13 = *(uint64_t **)(v4 + 392);
  if (v13)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v15 = v13;
        unint64_t v16 = v13[4];
        if (v11 >= v16) {
          break;
        }
        unint64_t v13 = (uint64_t *)*v15;
        uint64_t v14 = v15;
        if (!*v15) {
          goto LABEL_16;
        }
      }
      if (v16 >= v11) {
        break;
      }
      unint64_t v13 = (uint64_t *)v15[1];
      if (!v13)
      {
        uint64_t v14 = v15 + 1;
        goto LABEL_16;
      }
    }
    uint64_t v17 = (uint64_t)v15;
  }
  else
  {
    uint64_t v14 = (uint64_t *)(v4 + 392);
    unint64_t v15 = (uint64_t *)(v4 + 392);
LABEL_16:
    uint64_t v17 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 400) + 16))(*(void *)(v4 + 400), 72, 8);
    *(void *)(v17 + 48) = 0;
    *(void *)(v17 + 32) = v12;
    {
      operator new();
    }
    *(void *)(v17 + 56) = mdm::Allocator::instance(void)::alloc;
    *(void *)(v17 + 64) = 0;
    *(void *)(v17 + 40) = v17 + 48;
    *(void *)uint64_t v17 = 0;
    *(void *)(v17 + 8) = 0;
    *(void *)(v17 + 16) = v15;
    *uint64_t v14 = v17;
    uint64_t v18 = **(void **)(v4 + 384);
    unint64_t v19 = (uint64_t *)v17;
    if (v18)
    {
      *(void *)(v4 + 384) = v18;
      unint64_t v19 = (uint64_t *)*v14;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 392), v19);
    uint64_t v12 = 0;
    ++*(void *)(v4 + 408);
  }
  unint64_t v21 = (uint64_t *)(v17 + 48);
  uint64_t v20 = *(void *)(v17 + 48);
  if (v20)
  {
    unsigned int v22 = *(_DWORD *)(a1 + 48);
    while (1)
    {
      while (1)
      {
        int64_t v23 = (uint64_t *)v20;
        unsigned int v24 = *(_DWORD *)(v20 + 32);
        if (v22 >= v24) {
          break;
        }
        uint64_t v20 = *v23;
        unint64_t v21 = v23;
        if (!*v23) {
          goto LABEL_29;
        }
      }
      if (v24 >= v22) {
        break;
      }
      uint64_t v20 = v23[1];
      if (!v20)
      {
        unint64_t v21 = v23 + 1;
        goto LABEL_29;
      }
    }
    uint64_t v25 = (uint64_t)v23;
  }
  else
  {
    int64_t v23 = (uint64_t *)(v17 + 48);
LABEL_29:
    uint64_t v25 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v17 + 56) + 16))(*(void *)(v17 + 56), 72, 8);
    *(_DWORD *)(v25 + 32) = *(_DWORD *)(a1 + 48);
    *(void *)(v25 + 48) = 0;
    *(void *)(v25 + 56) = 0;
    *(void *)(v25 + 40) = 0;
    {
      operator new();
    }
    *(void *)(v25 + 64) = mdm::Allocator::instance(void)::alloc;
    *(void *)uint64_t v25 = 0;
    *(void *)(v25 + 8) = 0;
    *(void *)(v25 + 16) = v23;
    *unint64_t v21 = v25;
    uint64_t v26 = **(void **)(v17 + 40);
    uint64_t v27 = (uint64_t *)v25;
    if (v26)
    {
      *(void *)(v17 + 40) = v26;
      uint64_t v27 = (uint64_t *)*v21;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v17 + 48), v27);
    ++*(void *)(v17 + 64);
  }
  size_t v28 = &a2[3 * v7];
  int v29 = *((_DWORD *)v28 + 2);
  int v30 = *((_DWORD *)v28 + 3);
  int v31 = *((_DWORD *)v28 + 4);
  int v32 = *((_DWORD *)v28 + 5);
  uint64_t v33 = *(_DWORD **)(v25 + 48);
  unint64_t v34 = *(void *)(v25 + 56);
  if ((unint64_t)v33 >= v34)
  {
    uint64_t v36 = *(void *)(v25 + 40);
    uint64_t v37 = ((uint64_t)v33 - v36) >> 4;
    unint64_t v38 = v37 + 1;
    if ((unint64_t)(v37 + 1) >> 60) {
      abort();
    }
    uint64_t v39 = v34 - v36;
    if (v39 >> 3 > v38) {
      unint64_t v38 = v39 >> 3;
    }
    if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFF0) {
      uint64_t v40 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v40 = v38;
    }
    if (v40)
    {
      uint64_t v41 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v25 + 64) + 16))(*(void *)(v25 + 64), 16 * v40, 4);
      uint64_t v42 = (_DWORD *)(v41 + 16 * v37);
      uint64_t v43 = v41 + 16 * v40;
      if (v41)
      {
        *uint64_t v42 = v29;
        v42[1] = v30;
        v42[2] = v31;
        v42[3] = v32;
      }
    }
    else
    {
      uint64_t v43 = 0;
      uint64_t v42 = (_DWORD *)(16 * v37);
    }
    uint64_t v35 = v42 + 4;
    uint64_t v45 = *(void *)(v25 + 40);
    uint64_t v44 = *(void *)(v25 + 48);
    if (v44 != v45)
    {
      do
      {
        *((_OWORD *)v42 - 1) = *(_OWORD *)(v44 - 16);
        v42 -= 4;
        v44 -= 16;
      }
      while (v44 != v45);
      uint64_t v44 = *(void *)(v25 + 40);
    }
    *(void *)(v25 + 40) = v42;
    *(void *)(v25 + 48) = v35;
    uint64_t v46 = *(void *)(v25 + 56);
    *(void *)(v25 + 56) = v43;
    if (v44) {
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v25 + 64) + 40))(*(void *)(v25 + 64), v44, v46 - v44);
    }
  }
  else
  {
    if (v33)
    {
      *uint64_t v33 = v29;
      v33[1] = v30;
      v33[2] = v31;
      v33[3] = v32;
    }
    uint64_t v35 = v33 + 4;
  }
  *(void *)(v25 + 48) = v35;

  if (*(_DWORD *)(a1 + 48))
  {
    unint64_t v47 = 0;
    do
    {
      uint64_t v49 = *(void *)(*(void *)(a1 + 32) + 8);
      unint64_t v50 = [a2[3 * v47] route];
      uint64_t v51 = (void *)v50;
      int v53 = (uint64_t **)(v49 + 56);
      uint64_t v52 = *(uint64_t **)(v49 + 56);
      if (v52)
      {
        while (1)
        {
          while (1)
          {
            float v54 = (uint64_t **)v52;
            unint64_t v55 = v52[4];
            if (v50 >= v55) {
              break;
            }
            uint64_t v52 = *v54;
            int v53 = v54;
            if (!*v54) {
              goto LABEL_64;
            }
          }
          if (v55 >= v50) {
            break;
          }
          uint64_t v52 = v54[1];
          if (!v52)
          {
            int v53 = v54 + 1;
            goto LABEL_64;
          }
        }
        BOOL v56 = (uint64_t *)v54;
      }
      else
      {
        float v54 = (uint64_t **)(v49 + 56);
LABEL_64:
        BOOL v56 = (uint64_t *)operator new(0x48uLL);
        v56[6] = 0;
        v56[4] = (uint64_t)v51;
        {
          operator new();
        }
        v56[7] = mdm::Allocator::instance(void)::alloc;
        v56[8] = 0;
        v56[5] = (uint64_t)(v56 + 6);
        *BOOL v56 = 0;
        v56[1] = 0;
        v56[2] = (uint64_t)v54;
        *int v53 = v56;
        uint64_t v57 = **(void **)(v49 + 48);
        uint64_t v58 = v56;
        if (v57)
        {
          *(void *)(v49 + 48) = v57;
          uint64_t v58 = *v53;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v49 + 56), v58);
        uint64_t v51 = 0;
        ++*(void *)(v49 + 64);
      }
      double v60 = v56 + 6;
      uint64_t v59 = v56[6];
      if (v59)
      {
        unsigned int v61 = *(_DWORD *)(a1 + 48);
        while (1)
        {
          while (1)
          {
            long long v62 = (uint64_t *)v59;
            unsigned int v63 = *(_DWORD *)(v59 + 32);
            if (v61 >= v63) {
              break;
            }
            uint64_t v59 = *v62;
            double v60 = v62;
            if (!*v62) {
              goto LABEL_77;
            }
          }
          if (v63 >= v61) {
            break;
          }
          uint64_t v59 = v62[1];
          if (!v59)
          {
            double v60 = v62 + 1;
            goto LABEL_77;
          }
        }
        uint64_t v64 = (uint64_t)v62;
      }
      else
      {
        long long v62 = v56 + 6;
LABEL_77:
        uint64_t v64 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v56[7] + 16))(v56[7], 72, 8);
        *(_DWORD *)(v64 + 32) = *(_DWORD *)(a1 + 48);
        *(void *)(v64 + 48) = 0;
        *(void *)(v64 + 56) = 0;
        *(void *)(v64 + 40) = 0;
        {
          operator new();
        }
        *(void *)(v64 + 64) = mdm::Allocator::instance(void)::alloc;
        *(void *)uint64_t v64 = 0;
        *(void *)(v64 + 8) = 0;
        *(void *)(v64 + 16) = v62;
        *double v60 = v64;
        uint64_t v65 = *(void *)v56[5];
        char v66 = (uint64_t *)v64;
        if (v65)
        {
          v56[5] = v65;
          char v66 = (uint64_t *)*v60;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v56[6], v66);
        ++v56[8];
      }
      double v67 = &a2[3 * v47];
      int v68 = *((_DWORD *)v67 + 2);
      int v69 = *((_DWORD *)v67 + 3);
      int v70 = *((_DWORD *)v67 + 4);
      int v71 = *((_DWORD *)v67 + 5);
      float v72 = *(_DWORD **)(v64 + 48);
      unint64_t v73 = *(void *)(v64 + 56);
      if ((unint64_t)v72 >= v73)
      {
        uint64_t v74 = *(void *)(v64 + 40);
        uint64_t v75 = ((uint64_t)v72 - v74) >> 4;
        unint64_t v76 = v75 + 1;
        if ((unint64_t)(v75 + 1) >> 60) {
          abort();
        }
        uint64_t v77 = v73 - v74;
        if (v77 >> 3 > v76) {
          unint64_t v76 = v77 >> 3;
        }
        if ((unint64_t)v77 >= 0x7FFFFFFFFFFFFFF0) {
          uint64_t v78 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v78 = v76;
        }
        if (v78)
        {
          uint64_t v79 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v64 + 64) + 16))(*(void *)(v64 + 64), 16 * v78, 4);
          uint64_t v80 = (_DWORD *)(v79 + 16 * v75);
          uint64_t v81 = v79 + 16 * v78;
          if (v79)
          {
            *uint64_t v80 = v68;
            v80[1] = v69;
            v80[2] = v70;
            v80[3] = v71;
          }
        }
        else
        {
          uint64_t v81 = 0;
          uint64_t v80 = (_DWORD *)(16 * v75);
        }
        uint64_t v83 = *(void *)(v64 + 40);
        uint64_t v82 = *(void *)(v64 + 48);
        long long v84 = v80;
        if (v82 != v83)
        {
          do
          {
            *((_OWORD *)v84 - 1) = *(_OWORD *)(v82 - 16);
            v84 -= 4;
            v82 -= 16;
          }
          while (v82 != v83);
          uint64_t v82 = *(void *)(v64 + 40);
        }
        uint64_t v48 = v80 + 4;
        *(void *)(v64 + 40) = v84;
        *(void *)(v64 + 48) = v80 + 4;
        uint64_t v85 = *(void *)(v64 + 56);
        *(void *)(v64 + 56) = v81;
        if (v82) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v64 + 64) + 40))(*(void *)(v64 + 64), v82, v85 - v82);
        }
      }
      else
      {
        if (v72)
        {
          *float v72 = v68;
          v72[1] = v69;
          v72[2] = v70;
          v72[3] = v71;
        }
        uint64_t v48 = v72 + 4;
      }
      *(void *)(v64 + 48) = v48;

      ++v47;
    }
    while (v47 < *(unsigned int *)(a1 + 48));
  }
}

void sub_1A1F848AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t *md::LabelNavEtaLabeler::annotatableSectionsForRoute(md::LabelNavEtaLabeler *this, GEOComposedRoute *a2)
{
  uint64_t v3 = a2;
  {
    unint64_t v15 = v3;
    uint64_t v3 = v15;
    if (v14)
    {
      qword_1E957ECE8 = 0;
      qword_1E957ECF0 = mdm::Allocator::instance(v15);
      unk_1E957ECF8 = 0;
      md::LabelNavEtaLabeler::annotatableSectionsForRoute(GEOComposedRoute *)const::empty = (uint64_t)&qword_1E957ECE8;
      __cxa_atexit((void (*)(void *))std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::~map[abi:nn180100], &md::LabelNavEtaLabeler::annotatableSectionsForRoute(GEOComposedRoute *)const::empty, &dword_1A1780000);
      uint64_t v3 = v15;
    }
  }
  uint64_t v4 = (void *)*((void *)this + 49);
  if (v4)
  {
    uint64_t v5 = (char *)this + 392;
    uint64_t v6 = (char *)this + 392;
    do
    {
      unint64_t v7 = v4[4];
      BOOL v8 = v7 >= (unint64_t)v3;
      if (v7 >= (unint64_t)v3) {
        uint64_t v9 = v4;
      }
      else {
        uint64_t v9 = v4 + 1;
      }
      if (v8) {
        uint64_t v6 = (char *)v4;
      }
      uint64_t v4 = (void *)*v9;
    }
    while (*v9);
    unsigned int v10 = &md::LabelNavEtaLabeler::annotatableSectionsForRoute(GEOComposedRoute *)const::empty;
    if (v6 != v5)
    {
      unint64_t v11 = *((void *)v6 + 4);
      uint64_t v12 = (uint64_t *)(v6 + 40);
      if (v11 <= (unint64_t)v3) {
        unsigned int v10 = v12;
      }
    }
  }
  else
  {
    unsigned int v10 = &md::LabelNavEtaLabeler::annotatableSectionsForRoute(GEOComposedRoute *)const::empty;
  }

  return v10;
}

uint64_t buildStringForAnnotatableSections(void *a1, void *a2)
{
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v130);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v130, (uint64_t)"[\n", 2);
  uint64_t v3 = (void *)*a2;
  uint64_t v126 = a2 + 1;
  if ((void *)*a2 != a2 + 1)
  {
    do
    {
      uint64_t v6 = v3[5];
      uint64_t v7 = v3[6];
      uint64_t v128 = v3;
      uint64_t v129 = v6;
      uint64_t v127 = v7;
      while (v6 != v7)
      {
        MEMORY[0x1A6238CF0](v139, v130);
        if (!v139[0]) {
          goto LABEL_39;
        }
        BOOL v8 = (char *)v130 + *(void *)(v130[0] - 24);
        uint64_t v9 = *((void *)v8 + 5);
        int v10 = *((_DWORD *)v8 + 2);
        int v11 = *((_DWORD *)v8 + 36);
        if (v11 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)));
          uint64_t v12 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
          int v11 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v8 + 36) = v11;
        }
        if ((v10 & 0xB0) == 0x20) {
          unint64_t v13 = "";
        }
        else {
          unint64_t v13 = "\t{ start:(";
        }
        if (!v9) {
          goto LABEL_38;
        }
        uint64_t v14 = *((void *)v8 + 3);
        BOOL v15 = v14 <= 10;
        uint64_t v16 = v14 - 10;
        int64_t v17 = v15 ? 0 : v16;
        if (v13 - "\t{ start:(" >= 1
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v9 + 96))(v9, "\t{ start:(", v13 - "\t{ start:(") != v13 - "\t{ start:(")
        {
          goto LABEL_38;
        }
        if (v17 >= 1)
        {
          if ((unint64_t)v17 >= 0x17)
          {
            uint64_t v19 = (v17 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v17 | 7) != 0x17) {
              uint64_t v19 = v17 | 7;
            }
            uint64_t v20 = v19 + 1;
            p_b = (std::locale::__imp *)operator new(v19 + 1);
            size_t v141 = v17;
            int64_t v142 = v20 | 0x8000000000000000;
            __b.__locale_ = p_b;
          }
          else
          {
            HIBYTE(v142) = v17;
            p_b = (std::locale::__imp *)&__b;
          }
          memset(p_b, v11, v17);
          *((unsigned char *)p_b + v17) = 0;
          if (v142 >= 0) {
            locale = &__b;
          }
          else {
            locale = __b.__locale_;
          }
          uint64_t v22 = (*(uint64_t (**)(uint64_t, void *, int64_t))(*(void *)v9 + 96))(v9, locale, v17);
          uint64_t v23 = v22;
          if (SHIBYTE(v142) < 0)
          {
            operator delete(__b.__locale_);
            if (v23 != v17) {
              goto LABEL_38;
            }
          }
          else if (v22 != v17)
          {
            goto LABEL_38;
          }
        }
        uint64_t v24 = "\t{ start:(" - v13 + 10;
        if (v24 < 1
          || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v9 + 96))(v9, v13, "\t{ start:(" - v13 + 10) == v24)
        {
          *((void *)v8 + 3) = 0;
          goto LABEL_39;
        }
LABEL_38:
        std::ios_base::clear((std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)), *(_DWORD *)((char *)&v131[1] + *(void *)(v130[0] - 24)) | 5);
LABEL_39:
        MEMORY[0x1A6238D00](v139);
        GEOPolylineCoordinateAsFullString();
        id v25 = objc_claimAutoreleasedReturnValue();
        uint64_t v26 = (const char *)[v25 UTF8String];
        int64_t v27 = strlen(v26);
        MEMORY[0x1A6238CF0](v139, v130);
        if (!v139[0]) {
          goto LABEL_69;
        }
        size_t v28 = (char *)v130 + *(void *)(v130[0] - 24);
        uint64_t v29 = *((void *)v28 + 5);
        int v30 = *((_DWORD *)v28 + 2);
        int v31 = *((_DWORD *)v28 + 36);
        if (v31 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)));
          int v32 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
          int v31 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v32->__vftable[2].~facet_0)(v32, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v28 + 36) = v31;
        }
        uint64_t v33 = &v26[v27];
        if ((v30 & 0xB0) == 0x20) {
          unint64_t v34 = &v26[v27];
        }
        else {
          unint64_t v34 = v26;
        }
        if (!v29) {
          goto LABEL_68;
        }
        int64_t v35 = *((void *)v28 + 3);
        BOOL v15 = v35 <= v27;
        int64_t v36 = v35 - v27;
        size_t v37 = v15 ? 0 : v36;
        if (v34 - v26 >= 1
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v29 + 96))(v29, v26, v34 - v26) != v34 - v26)
        {
          goto LABEL_68;
        }
        if ((uint64_t)v37 >= 1)
        {
          if (v37 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          if (v37 >= 0x17)
          {
            uint64_t v39 = (v37 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v37 | 7) != 0x17) {
              uint64_t v39 = v37 | 7;
            }
            uint64_t v40 = v39 + 1;
            unint64_t v38 = (std::locale::__imp *)operator new(v39 + 1);
            size_t v141 = v37;
            int64_t v142 = v40 | 0x8000000000000000;
            __b.__locale_ = v38;
          }
          else
          {
            HIBYTE(v142) = v37;
            unint64_t v38 = (std::locale::__imp *)&__b;
          }
          memset(v38, v31, v37);
          *((unsigned char *)v38 + v37) = 0;
          if (v142 >= 0) {
            uint64_t v41 = &__b;
          }
          else {
            uint64_t v41 = __b.__locale_;
          }
          uint64_t v42 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v29 + 96))(v29, v41, v37);
          uint64_t v43 = v42;
          if (SHIBYTE(v142) < 0)
          {
            operator delete(__b.__locale_);
            if (v43 != v37) {
              goto LABEL_68;
            }
          }
          else if (v42 != v37)
          {
            goto LABEL_68;
          }
        }
        if (v33 - v34 < 1
          || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v29 + 96))(v29, v34, v33 - v34) == v33 - v34)
        {
          *((void *)v28 + 3) = 0;
          goto LABEL_69;
        }
LABEL_68:
        std::ios_base::clear((std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)), *(_DWORD *)((char *)&v131[1] + *(void *)(v130[0] - 24)) | 5);
LABEL_69:
        uint64_t v44 = MEMORY[0x1A6238D00](v139);
        MEMORY[0x1A6238CF0](v44, v130);
        if (!v139[0]) {
          goto LABEL_98;
        }
        uint64_t v45 = (char *)v130 + *(void *)(v130[0] - 24);
        uint64_t v46 = *((void *)v45 + 5);
        int v47 = *((_DWORD *)v45 + 2);
        int v48 = *((_DWORD *)v45 + 36);
        if (v48 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)));
          uint64_t v49 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
          int v48 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v49->__vftable[2].~facet_0)(v49, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v45 + 36) = v48;
        }
        if ((v47 & 0xB0) == 0x20) {
          unint64_t v50 = "";
        }
        else {
          unint64_t v50 = "), end:(";
        }
        if (!v46) {
          goto LABEL_97;
        }
        uint64_t v51 = *((void *)v45 + 3);
        BOOL v15 = v51 <= 8;
        uint64_t v52 = v51 - 8;
        int64_t v53 = v15 ? 0 : v52;
        if (v50 - "), end:(" >= 1 {
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v46 + 96))(v46, "), end:(", v50 - "), end:(") != v50 - "), end:(")
        }
        {
          goto LABEL_97;
        }
        if (v53 >= 1)
        {
          if ((unint64_t)v53 >= 0x17)
          {
            uint64_t v55 = (v53 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v53 | 7) != 0x17) {
              uint64_t v55 = v53 | 7;
            }
            uint64_t v56 = v55 + 1;
            float v54 = (std::locale::__imp *)operator new(v55 + 1);
            size_t v141 = v53;
            int64_t v142 = v56 | 0x8000000000000000;
            __b.__locale_ = v54;
          }
          else
          {
            HIBYTE(v142) = v53;
            float v54 = (std::locale::__imp *)&__b;
          }
          memset(v54, v48, v53);
          *((unsigned char *)v54 + v53) = 0;
          if (v142 >= 0) {
            uint64_t v57 = &__b;
          }
          else {
            uint64_t v57 = __b.__locale_;
          }
          uint64_t v58 = (*(uint64_t (**)(uint64_t, void *, int64_t))(*(void *)v46 + 96))(v46, v57, v53);
          uint64_t v59 = v58;
          if (SHIBYTE(v142) < 0)
          {
            operator delete(__b.__locale_);
            if (v59 != v53) {
              goto LABEL_97;
            }
          }
          else if (v58 != v53)
          {
            goto LABEL_97;
          }
        }
        uint64_t v60 = "), end:(" - v50 + 8;
        if (v60 < 1
          || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v46 + 96))(v46, v50, "), end:(" - v50 + 8) == v60)
        {
          *((void *)v45 + 3) = 0;
          goto LABEL_98;
        }
LABEL_97:
        std::ios_base::clear((std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)), *(_DWORD *)((char *)&v131[1] + *(void *)(v130[0] - 24)) | 5);
LABEL_98:
        MEMORY[0x1A6238D00](v139);
        GEOPolylineCoordinateAsFullString();
        id v61 = objc_claimAutoreleasedReturnValue();
        long long v62 = (const char *)[v61 UTF8String];
        int64_t v63 = strlen(v62);
        MEMORY[0x1A6238CF0](v139, v130);
        if (!v139[0]) {
          goto LABEL_128;
        }
        uint64_t v64 = (char *)v130 + *(void *)(v130[0] - 24);
        uint64_t v65 = *((void *)v64 + 5);
        int v66 = *((_DWORD *)v64 + 2);
        int v67 = *((_DWORD *)v64 + 36);
        if (v67 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)));
          int v68 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
          int v67 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v68->__vftable[2].~facet_0)(v68, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v64 + 36) = v67;
        }
        int v69 = &v62[v63];
        if ((v66 & 0xB0) == 0x20) {
          int v70 = &v62[v63];
        }
        else {
          int v70 = v62;
        }
        if (!v65) {
          goto LABEL_127;
        }
        int64_t v71 = *((void *)v64 + 3);
        BOOL v15 = v71 <= v63;
        int64_t v72 = v71 - v63;
        size_t v73 = v15 ? 0 : v72;
        if (v70 - v62 >= 1
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v65 + 96))(v65, v62, v70 - v62) != v70 - v62)
        {
          goto LABEL_127;
        }
        if ((uint64_t)v73 >= 1)
        {
          if (v73 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          if (v73 >= 0x17)
          {
            uint64_t v75 = (v73 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v73 | 7) != 0x17) {
              uint64_t v75 = v73 | 7;
            }
            uint64_t v76 = v75 + 1;
            uint64_t v74 = (std::locale::__imp *)operator new(v75 + 1);
            size_t v141 = v73;
            int64_t v142 = v76 | 0x8000000000000000;
            __b.__locale_ = v74;
          }
          else
          {
            HIBYTE(v142) = v73;
            uint64_t v74 = (std::locale::__imp *)&__b;
          }
          memset(v74, v67, v73);
          *((unsigned char *)v74 + v73) = 0;
          if (v142 >= 0) {
            uint64_t v77 = &__b;
          }
          else {
            uint64_t v77 = __b.__locale_;
          }
          uint64_t v78 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v65 + 96))(v65, v77, v73);
          uint64_t v79 = v78;
          if (SHIBYTE(v142) < 0)
          {
            operator delete(__b.__locale_);
            if (v79 != v73) {
              goto LABEL_127;
            }
          }
          else if (v78 != v73)
          {
            goto LABEL_127;
          }
        }
        if (v69 - v70 < 1
          || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v65 + 96))(v65, v70, v69 - v70) == v69 - v70)
        {
          *((void *)v64 + 3) = 0;
          goto LABEL_128;
        }
LABEL_127:
        std::ios_base::clear((std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)), *(_DWORD *)((char *)&v131[1] + *(void *)(v130[0] - 24)) | 5);
LABEL_128:
        uint64_t v80 = MEMORY[0x1A6238D00](v139);
        MEMORY[0x1A6238CF0](v80, v130);
        if (!v139[0]) {
          goto LABEL_157;
        }
        uint64_t v81 = (char *)v130 + *(void *)(v130[0] - 24);
        uint64_t v82 = *((void *)v81 + 5);
        int v83 = *((_DWORD *)v81 + 2);
        int v84 = *((_DWORD *)v81 + 36);
        if (v84 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)));
          uint64_t v85 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
          int v84 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v85->__vftable[2].~facet_0)(v85, 32);
          std::locale::~locale(&__b);
          *((_DWORD *)v81 + 36) = v84;
        }
        if ((v83 & 0xB0) == 0x20) {
          id v86 = "";
        }
        else {
          id v86 = "), weight:";
        }
        if (!v82) {
          goto LABEL_156;
        }
        uint64_t v87 = *((void *)v81 + 3);
        BOOL v15 = v87 <= 10;
        uint64_t v88 = v87 - 10;
        int64_t v89 = v15 ? 0 : v88;
        if (v86 - "), weight:" >= 1 {
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v82 + 96))(v82, "), weight:", v86 - "), weight:") != v86 - "), weight:")
        }
        {
          goto LABEL_156;
        }
        if (v89 >= 1)
        {
          if ((unint64_t)v89 >= 0x17)
          {
            uint64_t v91 = (v89 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v89 | 7) != 0x17) {
              uint64_t v91 = v89 | 7;
            }
            uint64_t v92 = v91 + 1;
            double v90 = (std::locale::__imp *)operator new(v91 + 1);
            size_t v141 = v89;
            int64_t v142 = v92 | 0x8000000000000000;
            __b.__locale_ = v90;
          }
          else
          {
            HIBYTE(v142) = v89;
            double v90 = (std::locale::__imp *)&__b;
          }
          memset(v90, v84, v89);
          *((unsigned char *)v90 + v89) = 0;
          if (v142 >= 0) {
            double v93 = &__b;
          }
          else {
            double v93 = __b.__locale_;
          }
          uint64_t v94 = (*(uint64_t (**)(uint64_t, void *, int64_t))(*(void *)v82 + 96))(v82, v93, v89);
          uint64_t v95 = v94;
          if (SHIBYTE(v142) < 0)
          {
            operator delete(__b.__locale_);
            if (v95 != v89) {
              goto LABEL_156;
            }
          }
          else if (v94 != v89)
          {
            goto LABEL_156;
          }
        }
        uint64_t v96 = "), weight:" - v86 + 10;
        if (v96 < 1
          || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v82 + 96))(v82, v86, "), weight:" - v86 + 10) == v96)
        {
          *((void *)v81 + 3) = 0;
          goto LABEL_157;
        }
LABEL_156:
        std::ios_base::clear((std::ios_base *)((char *)v130 + *(void *)(v130[0] - 24)), *(_DWORD *)((char *)&v131[1] + *(void *)(v130[0] - 24)) | 5);
LABEL_157:
        MEMORY[0x1A6238D00](v139);
        uint64_t v97 = (void *)std::ostream::operator<<();
        MEMORY[0x1A6238CF0](v139, v97);
        if (v139[0])
        {
          uint64_t v98 = (char *)v97 + *(void *)(*v97 - 24);
          uint64_t v99 = *((void *)v98 + 5);
          int v100 = *((_DWORD *)v98 + 2);
          int v101 = *((_DWORD *)v98 + 36);
          if (v101 == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)v97 + *(void *)(*v97 - 24)));
            uint64_t v102 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
            int v101 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v102->__vftable[2].~facet_0)(v102, 32);
            std::locale::~locale(&__b);
            *((_DWORD *)v98 + 36) = v101;
          }
          if ((v100 & 0xB0) == 0x20) {
            uint64_t v103 = "";
          }
          else {
            uint64_t v103 = " }\n";
          }
          if (!v99) {
            goto LABEL_7;
          }
          uint64_t v104 = *((void *)v98 + 3);
          BOOL v15 = v104 <= 3;
          uint64_t v105 = v104 - 3;
          size_t v106 = v15 ? 0 : v105;
          if (v103 - " }\n" >= 1
            && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v99 + 96))(v99, " }\n", v103 - " }\n") != v103 - " }\n")
          {
            goto LABEL_7;
          }
          if ((uint64_t)v106 >= 1)
          {
            if (v106 > 0x7FFFFFFFFFFFFFF7) {
              abort();
            }
            if (v106 >= 0x17)
            {
              uint64_t v108 = (v106 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v106 | 7) != 0x17) {
                uint64_t v108 = v106 | 7;
              }
              uint64_t v109 = v108 + 1;
              uint64_t v107 = (std::locale::__imp *)operator new(v108 + 1);
              size_t v141 = v106;
              int64_t v142 = v109 | 0x8000000000000000;
              __b.__locale_ = v107;
            }
            else
            {
              HIBYTE(v142) = v106;
              uint64_t v107 = (std::locale::__imp *)&__b;
            }
            memset(v107, v101, v106);
            *((unsigned char *)v107 + v106) = 0;
            if (v142 >= 0) {
              uint64_t v110 = &__b;
            }
            else {
              uint64_t v110 = __b.__locale_;
            }
            uint64_t v111 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v99 + 96))(v99, v110, v106);
            uint64_t v112 = v111;
            if (SHIBYTE(v142) < 0)
            {
              operator delete(__b.__locale_);
              if (v112 != v106) {
                goto LABEL_7;
              }
            }
            else if (v111 != v106)
            {
              goto LABEL_7;
            }
          }
          uint64_t v113 = " }\n" - v103 + 3;
          if (v113 >= 1
            && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v99 + 96))(v99, v103, " }\n" - v103 + 3) != v113)
          {
LABEL_7:
            std::ios_base::clear((std::ios_base *)((char *)v97 + *(void *)(*v97 - 24)), *(_DWORD *)((char *)v97 + *(void *)(*v97 - 24) + 32) | 5);
            goto LABEL_8;
          }
          *((void *)v98 + 3) = 0;
        }
LABEL_8:
        MEMORY[0x1A6238D00](v139);

        uint64_t v6 = v129 + 16;
        v129 += 16;
        uint64_t v7 = v127;
      }
      uint64_t v114 = v128;
      uint64_t v115 = (void *)v128[1];
      if (v115)
      {
        do
        {
          uint64_t v116 = v115;
          uint64_t v115 = (void *)*v115;
        }
        while (v115);
      }
      else
      {
        do
        {
          uint64_t v116 = (void *)v114[2];
          BOOL v117 = *v116 == (void)v114;
          uint64_t v114 = v116;
        }
        while (!v117);
      }
      uint64_t v3 = v116;
    }
    while (v116 != v126);
  }
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v130, (uint64_t)"]", 1);
  if ((v137 & 0x10) != 0)
  {
    unint64_t v118 = v136;
    if (v136 < v133)
    {
      unint64_t v136 = v133;
      unint64_t v118 = v133;
    }
    uint64_t v119 = (const void **)&v132;
  }
  else
  {
    if ((v137 & 8) == 0)
    {
      size_t v4 = 0;
      uint64_t v5 = a1;
      *((unsigned char *)a1 + 23) = 0;
      goto LABEL_204;
    }
    uint64_t v119 = (const void **)v131;
    unint64_t v118 = v131[2];
  }
  uint64_t v5 = a1;
  uint64_t v120 = *v119;
  size_t v4 = v118 - (void)*v119;
  if (v4 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  if (v4 >= 0x17)
  {
    uint64_t v121 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v121 = v4 | 7;
    }
    uint64_t v122 = v121 + 1;
    int v123 = operator new(v121 + 1);
    a1[1] = v4;
    a1[2] = v122 | 0x8000000000000000;
    *a1 = v123;
    uint64_t v5 = v123;
    goto LABEL_203;
  }
  *((unsigned char *)a1 + 23) = v4;
  if (v4) {
LABEL_203:
  }
    memmove(v5, v120, v4);
LABEL_204:
  *((unsigned char *)v5 + v4) = 0;
  v130[0] = *MEMORY[0x1E4FBA418];
  *(void *)((char *)v130 + *(void *)(v130[0] - 24)) = *(void *)(MEMORY[0x1E4FBA418] + 24);
  v130[1] = MEMORY[0x1E4FBA470] + 16;
  if (v135 < 0) {
    operator delete(__p);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1A62391A0](&v138);
}

void sub_1A1F85B64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>>>::destroy(*a1);
    std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRoute * {__strong},std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>>>>::destroy(a1[1]);
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(a1 + 5), a1[6]);

    operator delete(a1);
  }
}

uint64_t std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::~map[abi:nn180100](uint64_t a1)
{
  return a1;
}

void md::LabelNavEtaLabeler::calculatePositioningFrame(float32x2_t *a1, uint64_t a2, uint64_t a3, void *a4, PolylineCoordinate a5, PolylineCoordinate a6)
{
  int v11 = a4;
  uint64_t v12 = *(float64x2_t **)(a3 + 24);
  uint64_t v33 = v11;
  PolylineCoordinate v34 = a5;
  double v30 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a2 + 48), v11, &v34);
  double v31 = v13;
  double v32 = v14;
  double v15 = v12[55].f64[1];
  double v16 = v12[57].f64[1];
  double v17 = v12[61].f64[1];
  double v18 = v12[59].f64[1];
  float64x2_t v26 = v12[54];
  float64x2_t v27 = v12[56];
  float64x2_t v28 = v12[58];
  float64x2_t v29 = v12[60];
  PolylineCoordinate v34 = a6;
  double v19 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a2 + 48), v33, &v34);
  float32x2_t v20 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v29, v26, v30), v27, v31), v28, v32), 1.0 / (v17 + v15 * v30 + v16 * v31 + v18 * v32)));
  float32x2_t v23 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v12[60], v12[54], v19), v12[56], v21), v12[58], v22), 1.0 / (v12[61].f64[1] + v12[55].f64[1] * v19 + v12[57].f64[1] * v21 + v12[59].f64[1] * v22)));
  *a1 = vmul_f32(vadd_f32(v23, v20), (float32x2_t)0x3F0000003F000000);
  if (*(void *)&v20 == *(void *)&v23)
  {
    float32x2_t v24 = (float32x2_t)1065353216;
  }
  else
  {
    float32x2_t v25 = vsub_f32(v23, v20);
    float32x2_t v24 = vmul_n_f32(v25, 1.0 / sqrtf(vaddv_f32(vmul_f32(v25, v25))));
  }
  a1[1] = v24;
  a1[2].f32[0] = -v24.f32[1];
  a1[2].i32[1] = v24.i32[0];
}

void sub_1A1F85EB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float md::LabelNavEtaLabeler::scoreEtaLabelPosition(uint64_t a1, void *a2, float *a3, float a4)
{
  if (a4 >= 0.0)
  {
    float v9 = a3[1];
    float v8 = *a3 - a4;
    float v5 = v9 - a4;
    float v7 = *a3 + a4;
    float v6 = v9 + a4;
  }
  else
  {
    float v5 = 3.4028e38;
    float v6 = -3.4028e38;
    float v7 = -3.4028e38;
    float v8 = 3.4028e38;
  }
  v29[0] = v8;
  v29[1] = v5;
  v29[2] = v7;
  v29[3] = v6;
  unint64_t v10 = a2[19];
  BOOL v11 = v10 > 4;
  uint64_t v12 = (1 << v10) & 0x19;
  BOOL v13 = v11 || v12 == 0;
  if (v13) {
    return 3.4028e38;
  }
  double v14 = *(void **)(a1 + 456);
  double v15 = (void *)(a1 + 464);
  if (v14 == (void *)(a1 + 464)) {
    return 3.4028e38;
  }
  unint64_t v16 = COERCE_UNSIGNED_INT(v8 + (float)((float)(v7 - v8) * 0.5)) | ((unint64_t)COERCE_UNSIGNED_INT(v5+ (float)((float)(v6 - v5) * 0.5)) << 32);
  float v17 = 3.4028e38;
  do
  {
    double v19 = (void *)v14[5];
    double v18 = (void *)v14[6];
    while (v19 != v18)
    {
      if (v19 + 6 != a2)
      {
        unint64_t v21 = v19[25];
        BOOL v22 = v21 > 4 || ((1 << v21) & 0x19) == 0;
        if (!v22 && v21 == a2[19])
        {
          int v30 = 2139095039;
          float32x2_t v24 = (uint64_t **)v19[12];
          float32x2_t v23 = (uint64_t **)v19[13];
          if (v24 == v23)
          {
            float v20 = 3.4028e38;
          }
          else
          {
            do
            {
              float32x2_t v25 = *v24;
              v24 += 2;
              md::PolylineCollider::enumerateSegmentsIntersectingBounds<md::LabelNavEtaLabeler::routeNearestDistSquaredToRectCenter(md::RouteLabelState const&,gm::Box<float,2> const&)::$_0>(v25, 0, v29, (float *)&v30, v16);
            }
            while (v24 != v23);
            float v20 = *(float *)&v30;
          }
          float v17 = fminf(v20, v17);
        }
      }
      v19 += 48;
    }
    float64x2_t v26 = (void *)v14[1];
    if (v26)
    {
      do
      {
        float64x2_t v27 = v26;
        float64x2_t v26 = (void *)*v26;
      }
      while (v26);
    }
    else
    {
      do
      {
        float64x2_t v27 = (void *)v14[2];
        BOOL v13 = *v27 == (void)v14;
        double v14 = v27;
      }
      while (!v13);
    }
    double v14 = v27;
  }
  while (v27 != v15);
  return v17;
}

uint64_t md::LabelNavEtaLabeler::scoreEtaLabelRect(uint64_t result, void *a2, const md::RouteLabelState *a3, float *a4, float *a5)
{
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(unsigned char *)(result + 20) = 1;
  float v6 = (void *)a2[57];
  uint64_t v92 = a2 + 58;
  if (v6 != a2 + 58)
  {
    float v7 = 0.0;
    double v93 = a3;
    uint64_t v94 = result;
    while (1)
    {
      uint64_t v8 = v6[5];
      uint64_t v9 = v6[6];
      uint64_t v95 = v9;
      uint64_t v96 = v6;
      if (v8 != v9) {
        break;
      }
LABEL_5:
      unint64_t v10 = (void *)v6[1];
      if (v10)
      {
        do
        {
          BOOL v11 = v10;
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          BOOL v11 = (void *)v6[2];
          BOOL v22 = *v11 == (void)v6;
          float v6 = v11;
        }
        while (!v22);
      }
      float v6 = v11;
      if (v11 == v92) {
        goto LABEL_91;
      }
    }
    while (1)
    {
      double v18 = (const md::RouteLabelState *)(v8 + 48);
      unint64_t v19 = *(void *)(v8 + 200);
      BOOL v20 = v19 > 4;
      uint64_t v21 = (1 << v19) & 0x19;
      BOOL v22 = v20 || v21 == 0;
      if (v22) {
        goto LABEL_78;
      }
      float v108 = 0.0;
      float32x2_t v23 = *(uint64_t ***)(v8 + 96);
      float32x2_t v24 = *(uint64_t ***)(v8 + 104);
      if (v23 != v24) {
        break;
      }
      float v52 = 0.0;
      if (*(unsigned char *)(v8 + 196)) {
        goto LABEL_73;
      }
LABEL_77:
      float v7 = *(float *)result + v52;
      *(float *)uint64_t result = v7;
LABEL_78:
      if (v18 != a3)
      {
        if (*(unsigned char *)(v8 + 136))
        {
          unint64_t v55 = *(void *)(v8 + 200);
          if (v55 > 4 || ((1 << v55) & 0x19) == 0 || v55 == *((void *)a3 + 19))
          {
            float v56 = *(float *)(v8 + 148);
            if (v56 <= *a4
              || (v57 = *(float *)(v8 + 140), float v58 = a4[2], v57 >= v58)
              || (float v59 = *(float *)(v8 + 152), v60 = a4[1], v59 <= v60)
              || (float v61 = *(float *)(v8 + 144), v62 = a4[3], v61 >= v62))
            {
              float v12 = 3.4028e38;
              float v13 = -3.4028e38;
              float v14 = -3.4028e38;
              float v15 = 3.4028e38;
            }
            else
            {
              float v15 = fmaxf(v57, *a4);
              float v14 = fminf(v58, v56);
              float v12 = fmaxf(v61, v60);
              float v13 = fminf(v62, v59);
            }
            BOOL v16 = v13 < v12 || v14 < v15;
            float v17 = (float)(v14 - v15) * (float)(v13 - v12);
            if (v16) {
              float v17 = 0.0;
            }
            *(float *)(result + 4) = v17 + *(float *)(result + 4);
          }
        }
      }
      v8 += 384;
      if (v8 == v9) {
        goto LABEL_5;
      }
    }
    uint64_t v97 = v8;
    do
    {
      float32x2_t v25 = *v23;
      md::RouteLabelState::RouteLabelState((md::RouteLabelState *)v98, v18);
      uint64_t v109 = &v108;
      md::RouteLabelState::RouteLabelState((md::RouteLabelState *)&v110, (const md::RouteLabelState *)v98);
      md::PolylineCollider::enumerateSegmentsIntersectingBounds<md::LabelNavEtaLabeler::routeRectOverlap(md::RouteLabelState const&,gm::Box<float,2> const&)::$_0>(v25, 0, a4, (uint64_t)&v109);
      uint64_t v26 = v116;
      if (v116)
      {
        uint64_t v27 = v117;
        uint64_t v28 = v116;
        if (v117 != v116)
        {
          do
          {
            float64x2_t v29 = *(void **)(v27 - 24);
            if (v29)
            {
              do
              {
                int v30 = (void *)*v29;
                operator delete(v29);
                float64x2_t v29 = v30;
              }
              while (v30);
            }
            double v31 = *(void **)(v27 - 40);
            *(void *)(v27 - 40) = 0;
            if (v31) {
              operator delete(v31);
            }
            v27 -= 72;
          }
          while (v27 != v26);
          uint64_t v28 = v116;
        }
        uint64_t v117 = v26;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v119 + 40))(v119, v28, v118 - v28);
      }
      uint64_t v32 = v112;
      if (v112)
      {
        uint64_t v33 = v113;
        uint64_t v34 = v112;
        if (v113 != v112)
        {
          do
          {
            int64_t v35 = *(std::__shared_weak_count **)(v33 - 8);
            if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *, uint64_t))v35->__on_zero_shared)(v35, v34);
              std::__shared_weak_count::__release_weak(v35);
            }
            v33 -= 16;
          }
          while (v33 != v32);
          uint64_t v34 = v112;
        }
        uint64_t v113 = v32;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v115 + 40))(v115, v34, v114 - v34);
      }
      int64_t v36 = __p;
      if (__p)
      {
        do
        {
          size_t v37 = (void *)*v36;
          operator delete(v36);
          int64_t v36 = v37;
        }
        while (v37);
      }
      unint64_t v38 = v110;
      uint64_t v110 = 0;
      if (v38) {
        operator delete(v38);
      }
      uint64_t v39 = v104;
      if (v104)
      {
        uint64_t v40 = v105;
        uint64_t v41 = v104;
        if (v105 != v104)
        {
          do
          {
            uint64_t v42 = *(void **)(v40 - 24);
            if (v42)
            {
              do
              {
                uint64_t v43 = (void *)*v42;
                operator delete(v42);
                uint64_t v42 = v43;
              }
              while (v43);
            }
            uint64_t v44 = *(void **)(v40 - 40);
            *(void *)(v40 - 40) = 0;
            if (v44) {
              operator delete(v44);
            }
            v40 -= 72;
          }
          while (v40 != v39);
          uint64_t v41 = v104;
        }
        uint64_t v105 = v39;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v107 + 40))(v107, v41, v106 - v41);
      }
      uint64_t v45 = v100;
      if (v100)
      {
        uint64_t v46 = v101;
        uint64_t v47 = v100;
        if (v101 != v100)
        {
          do
          {
            int v48 = *(std::__shared_weak_count **)(v46 - 8);
            if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *, uint64_t))v48->__on_zero_shared)(v48, v47);
              std::__shared_weak_count::__release_weak(v48);
            }
            v46 -= 16;
          }
          while (v46 != v45);
          uint64_t v47 = v100;
        }
        uint64_t v101 = v45;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v103 + 40))(v103, v47, v102 - v47);
      }
      uint64_t v49 = v99;
      if (v99)
      {
        do
        {
          unint64_t v50 = (void *)*v49;
          operator delete(v49);
          uint64_t v49 = v50;
        }
        while (v50);
      }
      uint64_t v51 = v98[0];
      v98[0] = 0;
      if (v51) {
        operator delete(v51);
      }
      v23 += 2;
    }
    while (v23 != v24);
    float v52 = v108;
    a3 = v93;
    uint64_t result = v94;
    float v6 = v96;
    uint64_t v8 = v97;
    uint64_t v9 = v95;
    if (!*(unsigned char *)(v97 + 196)) {
      goto LABEL_77;
    }
LABEL_73:
    unint64_t v53 = *(void *)(v8 + 200);
    float v54 = v52 * 4.0;
    if (((1 << v53) & 0x19) == 0) {
      float v54 = v52;
    }
    if (v53 <= 4) {
      float v52 = v54;
    }
    goto LABEL_77;
  }
  float v7 = 0.0;
LABEL_91:
  int64_t v63 = (float *)a2[27];
  uint64_t v64 = (float *)a2[28];
  if (v63 == v64)
  {
    float v68 = a4[2];
    float v69 = a4[3];
    float v67 = 0.0;
    float v65 = *a4;
    float v66 = a4[1];
  }
  else
  {
    float v65 = *a4;
    float v66 = a4[1];
    float v67 = 0.0;
    float v68 = a4[2];
    float v69 = a4[3];
    do
    {
      float v70 = v63[2];
      if (v70 <= v65 || *v63 >= v68 || (float v71 = v63[3], v71 <= v66) || (v72 = v63[1], v72 >= v69))
      {
        float v75 = 3.4028e38;
        float v76 = -3.4028e38;
        float v74 = -3.4028e38;
        float v73 = 3.4028e38;
      }
      else
      {
        float v73 = fmaxf(*v63, v65);
        float v74 = fminf(v68, v70);
        float v75 = fmaxf(v72, v66);
        float v76 = fminf(v69, v71);
      }
      BOOL v77 = v76 < v75 || v74 < v73;
      float v78 = (float)(v74 - v73) * (float)(v76 - v75);
      if (v77) {
        float v78 = 0.0;
      }
      float v67 = v67 + (float)(v78 * v63[4]);
      v63 += 6;
    }
    while (v63 != v64);
  }
  *(float *)(result + 8) = v67;
  float v79 = (float)(v69 - v66) * (float)(v68 - v65);
  if (v68 <= *a5 || (v80 = a5[2], v65 >= v80) || (v81 = a5[1], v69 <= v81) || (float v82 = a5[3], v66 >= v82))
  {
    float v85 = 3.4028e38;
    float v86 = -3.4028e38;
    float v84 = -3.4028e38;
    float v83 = 3.4028e38;
  }
  else
  {
    float v83 = fmaxf(v65, *a5);
    float v84 = fminf(v80, v68);
    float v85 = fmaxf(v66, v81);
    float v86 = fminf(v82, v69);
  }
  BOOL v87 = v86 < v85 || v84 < v83;
  float v88 = (float)(v84 - v83) * (float)(v86 - v85);
  if (v87) {
    float v88 = 0.0;
  }
  float v89 = fmaxf(v79 - v88, 0.0);
  *(float *)(result + 12) = v89;
  if (*((void *)a3 + 19) == 1)
  {
    *(float *)(result + 16) = (float)((float)(v89 + v67) + (float)(v7 + *(float *)(result + 4))) / v79;
    *(unsigned char *)(result + 20) = 1;
  }
  return result;
}

void sub_1A1F867B0(_Unwind_Exception *a1)
{
  md::RouteLabelState::~RouteLabelState(v2);
  md::RouteLabelState::~RouteLabelState(v1);
  _Unwind_Resume(a1);
}

md::RouteLabelState *md::RouteLabelState::RouteLabelState(md::RouteLabelState *this, const md::RouteLabelState *a2)
{
  uint64_t v3 = (uint64_t)this;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  size_t prime = *((void *)a2 + 1);
  if (prime != 1)
  {
    if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      int8x8_t v82 = *(int8x8_t *)(v3 + 8);
      BOOL v83 = prime >= *(void *)&v82;
      if (prime > *(void *)&v82) {
        goto LABEL_3;
      }
    }
    else
    {
      int8x8_t v82 = 0;
      BOOL v83 = 1;
      if (prime) {
        goto LABEL_3;
      }
    }
    if (v83) {
      goto LABEL_4;
    }
    unint64_t v84 = vcvtps_u32_f32((float)*(unint64_t *)(v3 + 24) / *(float *)(v3 + 32));
    if (*(void *)&v82 < 3uLL || (uint8x8_t v85 = (uint8x8_t)vcnt_s8(v82), v85.i16[0] = vaddlv_u8(v85), v85.u32[0] > 1uLL))
    {
      unint64_t v84 = std::__next_prime(v84);
    }
    else
    {
      uint64_t v86 = 1 << -(char)__clz(v84 - 1);
      if (v84 >= 2) {
        unint64_t v84 = v86;
      }
    }
    if (prime <= v84) {
      size_t prime = v84;
    }
    if (prime >= *(void *)&v82) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  size_t prime = 2;
LABEL_3:
  std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v3, prime);
LABEL_4:
  float v5 = (uint64_t *)*((void *)a2 + 2);
  if (!v5) {
    goto LABEL_67;
  }
  float v6 = (void *)(v3 + 16);
  unint64_t v7 = *(void *)(v3 + 8);
  while (1)
  {
LABEL_9:
    while (1)
    {
      unint64_t v8 = *((unsigned __int8 *)v5 + 16);
      if (v7)
      {
        uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
        v9.i16[0] = vaddlv_u8(v9);
        if (v9.u32[0] > 1uLL)
        {
          uint64_t v3 = *((unsigned __int8 *)v5 + 16);
          if (v7 <= v8) {
            uint64_t v3 = v8 % v7;
          }
        }
        else
        {
          uint64_t v3 = (v7 - 1) & v8;
        }
        unint64_t v10 = *(uint64_t ****)(*(void *)this + 8 * v3);
        if (v10)
        {
          BOOL v11 = *v10;
          if (v11) {
            break;
          }
        }
      }
LABEL_31:
      float v14 = operator new(0x28uLL);
      *float v14 = 0;
      v14[1] = v8;
      long long v15 = *((_OWORD *)v5 + 1);
      *((_DWORD *)v14 + 8) = *((_DWORD *)v5 + 8);
      *((_OWORD *)v14 + 1) = v15;
      float v16 = (float)(unint64_t)(*((void *)this + 3) + 1);
      float v17 = *((float *)this + 8);
      if (!v7 || (float)(v17 * (float)v7) < v16)
      {
        BOOL v18 = (v7 & (v7 - 1)) != 0;
        if (v7 < 3) {
          BOOL v18 = 1;
        }
        unint64_t v19 = v18 | (2 * v7);
        unint64_t v20 = vcvtps_u32_f32(v16 / v17);
        if (v19 <= v20) {
          size_t v21 = v20;
        }
        else {
          size_t v21 = v19;
        }
        if (v21 == 1)
        {
          size_t v21 = 2;
        }
        else if ((v21 & (v21 - 1)) != 0)
        {
          size_t v21 = std::__next_prime(v21);
          unint64_t v7 = *((void *)this + 1);
        }
        if (v21 > v7) {
          goto LABEL_43;
        }
        if (v21 < v7)
        {
          unint64_t v22 = vcvtps_u32_f32((float)*((unint64_t *)this + 3) / *((float *)this + 8));
          if (v7 < 3 || (uint8x8_t v23 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
          {
            unint64_t v22 = std::__next_prime(v22);
          }
          else
          {
            uint64_t v24 = 1 << -(char)__clz(v22 - 1);
            if (v22 >= 2) {
              unint64_t v22 = v24;
            }
          }
          if (v21 <= v22) {
            size_t v21 = v22;
          }
          if (v21 < v7) {
LABEL_43:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)this, v21);
        }
        unint64_t v7 = *((void *)this + 1);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v8) {
            uint64_t v3 = v8 % v7;
          }
          else {
            uint64_t v3 = v8;
          }
        }
        else
        {
          uint64_t v3 = (v7 - 1) & v8;
        }
      }
      uint64_t v25 = *(void *)this;
      uint64_t v26 = *(void **)(*(void *)this + 8 * v3);
      if (v26)
      {
        *float v14 = *v26;
        uint64_t v3 = (uint64_t)this;
      }
      else
      {
        *float v14 = *v6;
        *float v6 = v14;
        *(void *)(v25 + 8 * v3) = v6;
        uint64_t v3 = (uint64_t)this;
        if (!*v14) {
          goto LABEL_8;
        }
        unint64_t v27 = *(void *)(*v14 + 8);
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v27 >= v7) {
            v27 %= v7;
          }
        }
        else
        {
          v27 &= v7 - 1;
        }
        uint64_t v26 = (void *)(*(void *)this + 8 * v27);
      }
      *uint64_t v26 = v14;
LABEL_8:
      ++*(void *)(v3 + 24);
      float v5 = (uint64_t *)*v5;
      if (!v5) {
        goto LABEL_67;
      }
    }
    if (v9.u32[0] < 2uLL) {
      break;
    }
    while (1)
    {
      unint64_t v12 = (unint64_t)v11[1];
      if (v12 == v8) {
        break;
      }
      if (v12 >= v7) {
        v12 %= v7;
      }
      if (v12 != v3) {
        goto LABEL_31;
      }
LABEL_19:
      BOOL v11 = (uint64_t **)*v11;
      if (!v11) {
        goto LABEL_31;
      }
    }
    if (*((unsigned __int8 *)v11 + 16) != v8) {
      goto LABEL_19;
    }
    uint64_t v3 = (uint64_t)this;
    float v5 = (uint64_t *)*v5;
    if (!v5) {
      goto LABEL_67;
    }
  }
  while (1)
  {
    float v13 = v11[1];
    if (v13 == (uint64_t *)v8) {
      break;
    }
    if (((unint64_t)v13 & (v7 - 1)) != v3) {
      goto LABEL_31;
    }
LABEL_26:
    BOOL v11 = (uint64_t **)*v11;
    if (!v11) {
      goto LABEL_31;
    }
  }
  if (*((unsigned __int8 *)v11 + 16) != v8) {
    goto LABEL_26;
  }
  uint64_t v3 = (uint64_t)this;
  float v5 = (uint64_t *)*v5;
  if (v5) {
    goto LABEL_9;
  }
LABEL_67:
  char v28 = *((unsigned char *)a2 + 40);
  *(void *)(v3 + 48) = 0;
  *(unsigned char *)(v3 + 40) = v28;
  *(void *)(v3 + 56) = 0;
  uint64_t v29 = *((void *)a2 + 9);
  *(void *)(v3 + 64) = 0;
  *(void *)(v3 + 72) = v29;
  int v30 = (char *)*((void *)a2 + 6);
  double v31 = (char *)*((void *)a2 + 7);
  uint64_t v32 = (md::RouteLabelState *)v3;
  uint64_t v33 = v31 - v30;
  if (v31 != v30)
  {
    if (v33 < 0) {
      abort();
    }
    uint64_t v34 = (void *)(*(uint64_t (**)(uint64_t, int64_t, uint64_t))(*(void *)v29 + 16))(v29, v31 - v30, 8);
    *((void *)this + 6) = v34;
    *((void *)this + 7) = v34;
    *((void *)this + 8) = &v34[2 * (v33 >> 4)];
    do
    {
      if (v34)
      {
        uint64_t v35 = *((void *)v30 + 1);
        void *v34 = *(void *)v30;
        v34[1] = v35;
        if (v35) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v35 + 8), 1uLL, memory_order_relaxed);
        }
      }
      v30 += 16;
      v34 += 2;
    }
    while (v30 != v31);
    *((void *)this + 7) = v34;
    uint64_t v32 = this;
  }
  *((_OWORD *)v32 + 5) = *((_OWORD *)a2 + 5);
  long long v36 = *((_OWORD *)a2 + 6);
  long long v37 = *((_OWORD *)a2 + 7);
  long long v38 = *((_OWORD *)a2 + 9);
  *((_OWORD *)v32 + 8) = *((_OWORD *)a2 + 8);
  *((_OWORD *)v32 + 9) = v38;
  *((_OWORD *)v32 + 6) = v36;
  *((_OWORD *)v32 + 7) = v37;
  long long v39 = *((_OWORD *)a2 + 11);
  long long v40 = *((_OWORD *)a2 + 12);
  long long v41 = *((_OWORD *)a2 + 14);
  *((_OWORD *)v32 + 13) = *((_OWORD *)a2 + 13);
  *((_OWORD *)v32 + 14) = v41;
  *((_OWORD *)v32 + 11) = v39;
  *((_OWORD *)v32 + 12) = v40;
  long long v42 = *((_OWORD *)a2 + 15);
  long long v43 = *((_OWORD *)a2 + 16);
  long long v44 = *((_OWORD *)a2 + 18);
  *((_OWORD *)v32 + 17) = *((_OWORD *)a2 + 17);
  *((_OWORD *)v32 + 18) = v44;
  *((_OWORD *)v32 + 15) = v42;
  *((_OWORD *)v32 + 16) = v43;
  *((_OWORD *)v32 + 10) = *((_OWORD *)a2 + 10);
  *((void *)v32 + 38) = 0;
  *((void *)v32 + 39) = 0;
  uint64_t v45 = *((void *)a2 + 41);
  *((void *)v32 + 40) = 0;
  *((void *)v32 + 41) = v45;
  uint64_t v46 = (long long *)*((void *)a2 + 38);
  BOOL v87 = (long long *)*((void *)a2 + 39);
  uint64_t v47 = v32;
  if (v87 != v46)
  {
    unint64_t v48 = 0x8E38E38E38E38E39 * (((char *)v87 - (char *)v46) >> 3);
    if (v48 >= 0x38E38E38E38E38FLL) {
      abort();
    }
    uint64_t v49 = (*(uint64_t (**)(uint64_t))(*(void *)v45 + 16))(v45);
    *((void *)v47 + 38) = v49;
    *((void *)v47 + 39) = v49;
    *((void *)v47 + 40) = v49 + 8 * (((char *)v87 - (char *)v46) >> 3);
    uint64_t v50 = v49;
    while (2)
    {
      if (v50)
      {
        long long v51 = *v46;
        *(_OWORD *)(v50 + 12) = *(long long *)((char *)v46 + 12);
        *(_OWORD *)(v50 + 32) = 0u;
        float v52 = (uint64_t *)(v50 + 32);
        *(_OWORD *)uint64_t v50 = v51;
        *(_OWORD *)(v50 + 48) = 0u;
        *(_DWORD *)(v50 + 64) = *((_DWORD *)v46 + 16);
        size_t v53 = *((void *)v46 + 5);
        if (v53 == 1)
        {
          size_t v53 = 2;
          goto LABEL_82;
        }
        if ((v53 & (v53 - 1)) != 0)
        {
          size_t v53 = std::__next_prime(*((void *)v46 + 5));
          unint64_t v48 = *(void *)(v50 + 40);
          BOOL v77 = v53 >= v48;
          if (v53 > v48) {
            goto LABEL_82;
          }
        }
        else
        {
          unint64_t v48 = 0;
          BOOL v77 = 1;
          if (v53) {
            goto LABEL_82;
          }
        }
        if (!v77)
        {
          unint64_t v78 = vcvtps_u32_f32((float)*(unint64_t *)(v50 + 56) / *(float *)(v50 + 64));
          if (v48 < 3 || (uint8x8_t v79 = (uint8x8_t)vcnt_s8((int8x8_t)v48), v79.i16[0] = vaddlv_u8(v79), v79.u32[0] > 1uLL))
          {
            unint64_t v78 = std::__next_prime(v78);
          }
          else
          {
            uint64_t v80 = 1 << -(char)__clz(v78 - 1);
            if (v78 >= 2) {
              unint64_t v78 = v80;
            }
          }
          if (v53 <= v78) {
            size_t v53 = v78;
          }
          if (v53 < v48) {
LABEL_82:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v50 + 32, v53);
        }
        float v54 = (uint64_t *)*((void *)v46 + 6);
        if (v54)
        {
          unint64_t v55 = (void *)(v50 + 48);
          do
          {
            unint64_t v56 = *((unsigned __int8 *)v54 + 16);
            unint64_t v57 = *(void *)(v50 + 40);
            if (v57)
            {
              uint8x8_t v58 = (uint8x8_t)vcnt_s8((int8x8_t)v57);
              v58.i16[0] = vaddlv_u8(v58);
              if (v58.u32[0] > 1uLL)
              {
                unint64_t v48 = *((unsigned __int8 *)v54 + 16);
                if (v57 <= v56) {
                  unint64_t v48 = v56 % v57;
                }
              }
              else
              {
                unint64_t v48 = (v57 - 1) & v56;
              }
              float v59 = *(uint64_t ****)(*v52 + 8 * v48);
              if (v59)
              {
                float v60 = *v59;
                if (v60)
                {
                  if (v58.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      float v61 = v60[1];
                      if (v61 == (uint64_t *)v56)
                      {
                        if (*((unsigned __int8 *)v60 + 16) == v56) {
                          goto LABEL_143;
                        }
                      }
                      else if (((unint64_t)v61 & (v57 - 1)) != v48)
                      {
                        goto LABEL_105;
                      }
                      float v60 = (uint64_t **)*v60;
                      if (!v60) {
                        goto LABEL_105;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v62 = (unint64_t)v60[1];
                    if (v62 == v56)
                    {
                      if (*((unsigned __int8 *)v60 + 16) == v56) {
                        goto LABEL_143;
                      }
                    }
                    else
                    {
                      if (v62 >= v57) {
                        v62 %= v57;
                      }
                      if (v62 != v48) {
                        break;
                      }
                    }
                    float v60 = (uint64_t **)*v60;
                  }
                  while (v60);
                }
              }
            }
LABEL_105:
            int64_t v63 = (char *)operator new(0x30uLL);
            *(void *)int64_t v63 = 0;
            *((void *)v63 + 1) = v56;
            long long v64 = *((_OWORD *)v54 + 1);
            *(_OWORD *)(v63 + 28) = *(_OWORD *)((char *)v54 + 28);
            *((_OWORD *)v63 + 1) = v64;
            float v65 = (float)(unint64_t)(*(void *)(v50 + 56) + 1);
            float v66 = *(float *)(v50 + 64);
            if (v57 && (float)(v66 * (float)v57) >= v65)
            {
              unint64_t v56 = v48;
            }
            else
            {
              BOOL v67 = (v57 & (v57 - 1)) != 0;
              if (v57 < 3) {
                BOOL v67 = 1;
              }
              unint64_t v68 = v67 | (2 * v57);
              unint64_t v69 = vcvtps_u32_f32(v65 / v66);
              if (v68 <= v69) {
                size_t v70 = v69;
              }
              else {
                size_t v70 = v68;
              }
              if (v70 == 1)
              {
                size_t v70 = 2;
              }
              else if ((v70 & (v70 - 1)) != 0)
              {
                size_t v70 = std::__next_prime(v70);
                unint64_t v57 = *(void *)(v50 + 40);
              }
              if (v70 > v57) {
                goto LABEL_118;
              }
              if (v70 < v57)
              {
                unint64_t v71 = vcvtps_u32_f32((float)*(unint64_t *)(v50 + 56) / *(float *)(v50 + 64));
                if (v57 < 3
                  || (uint8x8_t v72 = (uint8x8_t)vcnt_s8((int8x8_t)v57), v72.i16[0] = vaddlv_u8(v72), v72.u32[0] > 1uLL))
                {
                  unint64_t v71 = std::__next_prime(v71);
                }
                else
                {
                  uint64_t v73 = 1 << -(char)__clz(v71 - 1);
                  if (v71 >= 2) {
                    unint64_t v71 = v73;
                  }
                }
                if (v70 <= v71) {
                  size_t v70 = v71;
                }
                if (v70 < v57) {
LABEL_118:
                }
                  std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v50 + 32, v70);
              }
              unint64_t v57 = *(void *)(v50 + 40);
              if ((v57 & (v57 - 1)) != 0)
              {
                if (v57 <= v56) {
                  v56 %= v57;
                }
              }
              else
              {
                unint64_t v56 = (v57 - 1) & v56;
              }
            }
            uint64_t v74 = *v52;
            float v75 = *(void **)(*v52 + 8 * v56);
            if (v75)
            {
              *(void *)int64_t v63 = *v75;
            }
            else
            {
              *(void *)int64_t v63 = *v55;
              *unint64_t v55 = v63;
              *(void *)(v74 + 8 * v56) = v55;
              if (!*(void *)v63) {
                goto LABEL_142;
              }
              unint64_t v76 = *(void *)(*(void *)v63 + 8);
              if ((v57 & (v57 - 1)) != 0)
              {
                if (v76 >= v57) {
                  v76 %= v57;
                }
              }
              else
              {
                v76 &= v57 - 1;
              }
              float v75 = (void *)(*v52 + 8 * v76);
            }
            void *v75 = v63;
LABEL_142:
            ++*(void *)(v50 + 56);
LABEL_143:
            float v54 = (uint64_t *)*v54;
          }
          while (v54);
        }
      }
      uint64_t v46 = (long long *)((char *)v46 + 72);
      v50 += 72;
      if (v46 != v87) {
        continue;
      }
      break;
    }
    uint64_t v47 = this;
    *((void *)this + 39) = v50;
  }
  return v47;
}

void sub_1A1F87128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void sub_1A1F87168()
{
  operator delete(v0);
  JUMPOUT(0x1A1F8717CLL);
}

void md::PolylineCollider::enumerateSegmentsIntersectingBounds<md::LabelNavEtaLabeler::routeRectOverlap(md::RouteLabelState const&,gm::Box<float,2> const&)::$_0>(uint64_t *a1, unsigned int a2, float *a3, uint64_t a4)
{
  uint64_t v7 = *a1;
  uint64_t v8 = *a1 + 32 * a2;
  if (*(unsigned char *)(v8 + 2) != 1)
  {
    uint64_t v12 = *(unsigned __int16 *)(v7 + 32 * a2);
    if (!*(_WORD *)(v7 + 32 * a2)) {
      return;
    }
    float v13 = *(unsigned __int16 **)(v7 + 32 * a2 + 24);
    uint64_t v14 = a1[3];
    while (1)
    {
      unsigned int v15 = *v13++;
      float v16 = (float *)(v14 + 8 * v15);
      float v18 = *v16;
      float v17 = v16[1];
      float v19 = v16[2];
      float v20 = v19 - *v16;
      float v21 = vabds_f32(v19, *v16);
      float v22 = *a3;
      if (v21 >= 1.0e-10)
      {
        float v26 = (float)(v22 - v18) * (float)(1.0 / v20);
        float v27 = (float)(a3[2] - v18) * (float)(1.0 / v20);
        float v28 = fminf(v26, v27);
        float v29 = fmaxf(v26, v27);
        float v25 = fmaxf(v28, 0.0);
        float v24 = fminf(v29, 1.0);
        if (v25 > v24) {
          goto LABEL_10;
        }
      }
      else
      {
        if (v18 < v22 || v18 > a3[2]) {
          goto LABEL_10;
        }
        float v24 = 1.0;
        float v25 = 0.0;
      }
      float v30 = v16[3] - v17;
      if (fabsf(v30) >= 1.0e-10)
      {
        float v32 = (float)(a3[1] - v17) * (float)(1.0 / v30);
        float v33 = (float)(a3[3] - v17) * (float)(1.0 / v30);
        float v25 = fmaxf(v25, fminf(v32, v33));
        float v24 = fminf(fmaxf(v32, v33), v24);
        if (v25 > v24) {
          goto LABEL_10;
        }
      }
      else if (v17 < a3[1] || v17 > a3[3])
      {
        goto LABEL_10;
      }
      **(float **)a4 = **(float **)a4
                     + (float)(sqrtf((float)((float)((float)(v24 - v25) * v20) * (float)((float)(v24 - v25) * v20))+ (float)((float)((float)(v24 - v25) * v30) * (float)((float)(v24 - v25) * v30)))* *(float *)(a4 + 92));
LABEL_10:
      if (!--v12) {
        return;
      }
    }
  }
  if (*(float *)(v8 + 12) > *a3)
  {
    float v10 = *(float *)(v8 + 4);
    uint64_t v9 = v8 + 4;
    if (v10 < a3[2] && *(float *)(v7 + 32 * a2 + 16) > a3[1] && *(float *)(v9 + 4) < a3[3])
    {
      long long v36 = *(float **)a4;
      md::RouteLabelState::RouteLabelState((md::RouteLabelState *)v37, (const md::RouteLabelState *)(a4 + 8));
      md::PolylineCollider::enumerateSegmentsIntersectingBounds<md::LabelNavEtaLabeler::routeRectOverlap(md::RouteLabelState const&,gm::Box<float,2> const&)::$_0>(a1, (2 * a2) | 1, a3, &v36);
      md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)v37);
      uint64_t v34 = *(float **)a4;
      md::RouteLabelState::RouteLabelState((md::RouteLabelState *)v35, (const md::RouteLabelState *)(a4 + 8));
      md::PolylineCollider::enumerateSegmentsIntersectingBounds<md::LabelNavEtaLabeler::routeRectOverlap(md::RouteLabelState const&,gm::Box<float,2> const&)::$_0>(a1, 2 * a2 + 2, a3, &v34);
      md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)v35);
    }
  }
}

void sub_1A1F87410(_Unwind_Exception *a1)
{
  md::RouteLabelState::~RouteLabelState(v1);
  _Unwind_Resume(a1);
}

uint64_t *md::PolylineCollider::enumerateSegmentsIntersectingBounds<md::LabelNavEtaLabeler::routeNearestDistSquaredToRectCenter(md::RouteLabelState const&,gm::Box<float,2> const&)::$_0>(uint64_t *result, unsigned int a2, float *a3, float *a4, uint64_t a5)
{
  uint64_t v8 = result;
  uint64_t v9 = a2;
  uint64_t v10 = *result;
  if (*(unsigned char *)(*result + 32 * a2 + 2) != 1)
  {
LABEL_7:
    uint64_t v15 = *(unsigned __int16 *)(v10 + 32 * v9);
    if (!*(_WORD *)(v10 + 32 * v9)) {
      return result;
    }
    float v16 = *(unsigned __int16 **)(v10 + 32 * v9 + 24);
    uint64_t v17 = v8[3];
    float v18 = *a3;
    while (1)
    {
      unsigned int v19 = *v16++;
      float v20 = (float *)(v17 + 8 * v19);
      float v21 = *v20;
      float v22 = v20[1];
      float v23 = v20[2];
      float v24 = v23 - *v20;
      if (vabds_f32(v23, *v20) >= 1.0e-10)
      {
        float v28 = (float)(v18 - v21) * (float)(1.0 / v24);
        float v29 = (float)(a3[2] - v21) * (float)(1.0 / v24);
        float v30 = fminf(v28, v29);
        float v31 = fmaxf(v28, v29);
        float v27 = fmaxf(v30, 0.0);
        float v26 = fminf(v31, 1.0);
        if (v27 > v26) {
          goto LABEL_10;
        }
      }
      else
      {
        if (v21 < v18 || v21 > a3[2]) {
          goto LABEL_10;
        }
        float v26 = 1.0;
        float v27 = 0.0;
      }
      float v32 = v20[3] - v22;
      if (fabsf(v32) < 1.0e-10)
      {
        if (v22 < a3[1] || v22 > a3[3]) {
          goto LABEL_10;
        }
LABEL_27:
        float v36 = v27 * v24;
        float v37 = v27 * v32;
        float v38 = v36 + v21;
        float v39 = v37 + v22;
        float v40 = -(float)(v36 - (float)(v26 * v24));
        float v41 = -(float)(v37 - (float)(v26 * v32));
        float v42 = (float)(v40 * v40) + (float)(v41 * v41);
        float v43 = 0.0;
        if (v42 > 1.0e-15) {
          float v43 = fminf(fmaxf((float)((float)((float)(*(float *)&a5 - v38) * v40)+ (float)((float)(*((float *)&a5 + 1) - v39) * v41))/ v42, 0.0), 1.0);
        }
        *a4 = fminf(*a4, (float)((float)(*(float *)&a5 - (float)(v38 + (float)(v43 * v40)))* (float)(*(float *)&a5 - (float)(v38 + (float)(v43 * v40))))+ (float)((float)(*((float *)&a5 + 1) - (float)(v39 + (float)(v43 * v41)))* (float)(*((float *)&a5 + 1) - (float)(v39 + (float)(v43 * v41)))));
        float v18 = *a3;
        goto LABEL_10;
      }
      float v34 = (float)(a3[1] - v22) * (float)(1.0 / v32);
      float v35 = (float)(a3[3] - v22) * (float)(1.0 / v32);
      float v27 = fmaxf(v27, fminf(v34, v35));
      float v26 = fminf(fmaxf(v34, v35), v26);
      if (v27 <= v26) {
        goto LABEL_27;
      }
LABEL_10:
      if (!--v15) {
        return result;
      }
    }
  }
  while (1)
  {
    uint64_t v11 = v10 + 32 * v9;
    if (*(float *)(v11 + 12) <= *a3) {
      return result;
    }
    float v13 = *(float *)(v11 + 4);
    uint64_t v12 = v11 + 4;
    if (v13 >= a3[2] || *(float *)(v10 + 32 * v9 + 16) <= a3[1] || *(float *)(v12 + 4) >= a3[3]) {
      return result;
    }
    int v14 = 2 * a2;
    uint64_t result = (uint64_t *)md::PolylineCollider::enumerateSegmentsIntersectingBounds<md::LabelNavEtaLabeler::routeNearestDistSquaredToRectCenter(md::RouteLabelState const&,gm::Box<float,2> const&)::$_0>(v8, (2 * a2) | 1, a3, a4, a5);
    uint64_t v9 = (v14 + 2);
    uint64_t v10 = *v8;
    a2 = v14 + 2;
    if (*(unsigned char *)(*v8 + 32 * v9 + 2) != 1) {
      goto LABEL_7;
    }
  }
}

void *std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>(uint64_t a1, unsigned __int8 a2, unsigned char *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((unsigned __int8 *)v10 + 16) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int8 *)v10 + 16) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = operator new(0x28uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((unsigned char *)v10 + 16) = *a3;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_34;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v22 = *(void *)a1;
  float v23 = *(void **)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    *uint64_t v10 = *v23;
LABEL_58:
    void *v23 = v10;
    goto LABEL_59;
  }
  *uint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    float v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A1F87964(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::LabelNavEtaLabeler::describeDebugState(uint64_t a1, void *a2, int a3)
{
  unint64_t v3 = *(void **)(a1 + 488);
  v365 = (void *)(a1 + 496);
  if (v3 == (void *)(a1 + 496)) {
    goto LABEL_2;
  }
  while (2)
  {
    id v27 = *(id *)(a1 + 24);
    float v28 = [v27 routeInfo];
    [v28 route];

    uint64_t v30 = v3[5];
    uint64_t v29 = v3[6];
    v367 = v3;
    uint64_t v369 = v29;
    while (v30 != v29)
    {
      MEMORY[0x1A6238CF0](v384, a2);
      if (!LOBYTE(v384[0].__locale_)) {
        goto LABEL_41;
      }
      float v31 = (char *)a2 + *(void *)(*a2 - 24);
      uint64_t v32 = *((void *)v31 + 5);
      int v33 = *((_DWORD *)v31 + 2);
      int v34 = *((_DWORD *)v31 + 36);
      if (v34 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
        float v35 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
        int v34 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v35->__vftable[2].~facet_0)(v35, 32);
        std::locale::~locale(__b);
        *((_DWORD *)v31 + 36) = v34;
      }
      if ((v33 & 0xB0) == 0x20) {
        float v36 = "";
      }
      else {
        float v36 = "AnnotationRequest: ";
      }
      if (!v32) {
        goto LABEL_40;
      }
      uint64_t v37 = *((void *)v31 + 3);
      BOOL v38 = v37 <= 19;
      uint64_t v39 = v37 - 19;
      int64_t v40 = v38 ? 0 : v39;
      if (v36 - "AnnotationRequest: " >= 1
        && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v32 + 96))(v32, "AnnotationRequest: ", v36 - "AnnotationRequest: ") != v36 - "AnnotationRequest: ")
      {
        goto LABEL_40;
      }
      if (v40 >= 1)
      {
        if ((unint64_t)v40 >= 0x17)
        {
          uint64_t v42 = (v40 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v40 | 7) != 0x17) {
            uint64_t v42 = v40 | 7;
          }
          uint64_t v43 = v42 + 1;
          float v41 = (std::locale::__imp *)operator new(v42 + 1);
          __b[1].__locale_ = (std::locale::__imp *)v40;
          __b[2].__locale_ = (std::locale::__imp *)(v43 | 0x8000000000000000);
          __b[0].__locale_ = v41;
        }
        else
        {
          HIBYTE(__b[2].__locale_) = v40;
          float v41 = (std::locale::__imp *)__b;
        }
        memset(v41, v34, v40);
        *((unsigned char *)v41 + v40) = 0;
        if (SHIBYTE(__b[2].__locale_) >= 0) {
          locale = __b;
        }
        else {
          locale = __b[0].__locale_;
        }
        uint64_t v45 = (*(uint64_t (**)(uint64_t, void *, int64_t))(*(void *)v32 + 96))(v32, locale, v40);
        uint64_t v46 = v45;
        if (SHIBYTE(__b[2].__locale_) < 0)
        {
          operator delete(__b[0].__locale_);
          if (v46 != v40) {
            goto LABEL_40;
          }
        }
        else if (v45 != v40)
        {
          goto LABEL_40;
        }
      }
      uint64_t v47 = "AnnotationRequest: " - v36 + 19;
      if (v47 < 1
        || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v32 + 96))(v32, v36, "AnnotationRequest: " - v36 + 19) == v47)
      {
        *((void *)v31 + 3) = 0;
        goto LABEL_41;
      }
LABEL_40:
      std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
LABEL_41:
      MEMORY[0x1A6238D00](v384);
      unint64_t v48 = [*(id *)(v30 + 8) etaDescription];
      [v48 routeEtaType];

      uint64_t v49 = (void *)std::ostream::operator<<();
      MEMORY[0x1A6238CF0](v384, v49);
      uint64_t v373 = v30;
      if (!LOBYTE(v384[0].__locale_)) {
        goto LABEL_70;
      }
      uint64_t v50 = (char *)v49 + *(void *)(*v49 - 24);
      uint64_t v51 = *((void *)v50 + 5);
      int v52 = *((_DWORD *)v50 + 2);
      int v53 = *((_DWORD *)v50 + 36);
      if (v53 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)v49 + *(void *)(*v49 - 24)));
        float v54 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
        int v53 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v54->__vftable[2].~facet_0)(v54, 32);
        std::locale::~locale(__b);
        *((_DWORD *)v50 + 36) = v53;
      }
      if ((v52 & 0xB0) == 0x20) {
        unint64_t v55 = "";
      }
      else {
        unint64_t v55 = " selected:";
      }
      if (!v51) {
        goto LABEL_69;
      }
      uint64_t v56 = *((void *)v50 + 3);
      BOOL v38 = v56 <= 10;
      uint64_t v57 = v56 - 10;
      int64_t v58 = v38 ? 0 : v57;
      if (v55 - " selected:" >= 1
        && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v51 + 96))(v51, " selected:", v55 - " selected:") != v55 - " selected:")
      {
        goto LABEL_69;
      }
      if (v58 >= 1)
      {
        if ((unint64_t)v58 >= 0x17)
        {
          uint64_t v60 = (v58 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v58 | 7) != 0x17) {
            uint64_t v60 = v58 | 7;
          }
          uint64_t v61 = v60 + 1;
          float v59 = (std::locale::__imp *)operator new(v60 + 1);
          __b[1].__locale_ = (std::locale::__imp *)v58;
          __b[2].__locale_ = (std::locale::__imp *)(v61 | 0x8000000000000000);
          __b[0].__locale_ = v59;
        }
        else
        {
          HIBYTE(__b[2].__locale_) = v58;
          float v59 = (std::locale::__imp *)__b;
        }
        memset(v59, v53, v58);
        *((unsigned char *)v59 + v58) = 0;
        if (SHIBYTE(__b[2].__locale_) >= 0) {
          unint64_t v62 = __b;
        }
        else {
          unint64_t v62 = __b[0].__locale_;
        }
        uint64_t v63 = (*(uint64_t (**)(uint64_t, void *, int64_t))(*(void *)v51 + 96))(v51, v62, v58);
        uint64_t v64 = v63;
        if (SHIBYTE(__b[2].__locale_) < 0)
        {
          operator delete(__b[0].__locale_);
          if (v64 != v58) {
            goto LABEL_69;
          }
        }
        else if (v63 != v58)
        {
          goto LABEL_69;
        }
      }
      uint64_t v65 = " selected:" - v55 + 10;
      if (v65 < 1
        || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v51 + 96))(v51, v55, " selected:" - v55 + 10) == v65)
      {
        *((void *)v50 + 3) = 0;
        uint64_t v30 = v373;
        goto LABEL_70;
      }
LABEL_69:
      std::ios_base::clear((std::ios_base *)((char *)v49 + *(void *)(*v49 - 24)), *(_DWORD *)((char *)v49 + *(void *)(*v49 - 24) + 32) | 5);
      uint64_t v30 = v373;
LABEL_70:
      MEMORY[0x1A6238D00](v384);
      std::ostream::operator<<();
      float v66 = [*(id *)(v30 + 8) etaDescription];
      BOOL v67 = [v66 etaText];

      if (v67)
      {
        MEMORY[0x1A6238CF0](__b, a2);
        if (LOBYTE(__b[0].__locale_))
        {
          uint64_t v68 = (uint64_t)a2 + *(void *)(*a2 - 24);
          uint64_t v69 = *(void *)(v68 + 40);
          int v70 = *(_DWORD *)(v68 + 8);
          int v71 = *(_DWORD *)(v68 + 144);
          if (v71 == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
            uint8x8_t v72 = std::locale::use_facet(v384, MEMORY[0x1E4FBA258]);
            int v71 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v72->__vftable[2].~facet_0)(v72, 32);
            std::locale::~locale(v384);
            *(_DWORD *)(v68 + 144) = v71;
          }
          if ((v70 & 0xB0) == 0x20) {
            uint64_t v73 = "";
          }
          else {
            uint64_t v73 = " eta:";
          }
          if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v69, (uint64_t)" eta:", (uint64_t)v73, (uint64_t)"", v68, (char)v71))std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5); {
        }
          }
        MEMORY[0x1A6238D00](__b);
        uint64_t v74 = [*(id *)(v30 + 8) etaDescription];
        id v75 = [v74 etaText];
        unint64_t v76 = (const char *)[v75 UTF8String];
        size_t v77 = strlen(v76);
        MEMORY[0x1A6238CF0](__b, a2);
        if (LOBYTE(__b[0].__locale_))
        {
          uint64_t v78 = (uint64_t)a2 + *(void *)(*a2 - 24);
          uint64_t v79 = *(void *)(v78 + 40);
          int v80 = *(_DWORD *)(v78 + 8);
          int v81 = *(_DWORD *)(v78 + 144);
          if (v81 == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
            int8x8_t v82 = std::locale::use_facet(v384, MEMORY[0x1E4FBA258]);
            int v81 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v82->__vftable[2].~facet_0)(v82, 32);
            std::locale::~locale(v384);
            *(_DWORD *)(v78 + 144) = v81;
          }
          if ((v80 & 0xB0) == 0x20) {
            uint64_t v83 = (uint64_t)&v76[v77];
          }
          else {
            uint64_t v83 = (uint64_t)v76;
          }
          uint64_t v84 = std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v79, (uint64_t)v76, v83, (uint64_t)&v76[v77], v78, (char)v81);
          uint64_t v30 = v373;
          if (!v84) {
            std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
          }
        }
        MEMORY[0x1A6238D00](__b);
      }
      MEMORY[0x1A6238CF0](v384, a2);
      if (LOBYTE(v384[0].__locale_))
      {
        uint8x8_t v85 = (char *)a2 + *(void *)(*a2 - 24);
        uint64_t v86 = *((void *)v85 + 5);
        int v87 = *((_DWORD *)v85 + 2);
        int v88 = *((_DWORD *)v85 + 36);
        if (v88 == -1)
        {
          std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
          float v89 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
          int v88 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v89->__vftable[2].~facet_0)(v89, 32);
          std::locale::~locale(__b);
          *((_DWORD *)v85 + 36) = v88;
        }
        if ((v87 & 0xB0) == 0x20) {
          double v90 = "";
        }
        else {
          double v90 = "\n";
        }
        if (!v86) {
          goto LABEL_117;
        }
        uint64_t v91 = *((void *)v85 + 3);
        BOOL v38 = v91 <= 1;
        uint64_t v92 = v91 - 1;
        size_t v93 = v38 ? 0 : v92;
        if (v90 - "\n" >= 1
          && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v86 + 96))(v86, "\n", v90 - "\n") != v90 - "\n")
        {
          goto LABEL_117;
        }
        if ((uint64_t)v93 >= 1)
        {
          if (v93 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          if (v93 >= 0x17)
          {
            uint64_t v95 = (v93 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v93 | 7) != 0x17) {
              uint64_t v95 = v93 | 7;
            }
            uint64_t v96 = v95 + 1;
            uint64_t v94 = (std::locale::__imp *)operator new(v95 + 1);
            __b[1].__locale_ = (std::locale::__imp *)v93;
            __b[2].__locale_ = (std::locale::__imp *)(v96 | 0x8000000000000000);
            __b[0].__locale_ = v94;
          }
          else
          {
            HIBYTE(__b[2].__locale_) = v93;
            uint64_t v94 = (std::locale::__imp *)__b;
          }
          memset(v94, v88, v93);
          *((unsigned char *)v94 + v93) = 0;
          if (SHIBYTE(__b[2].__locale_) >= 0) {
            uint64_t v97 = __b;
          }
          else {
            uint64_t v97 = __b[0].__locale_;
          }
          uint64_t v98 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v86 + 96))(v86, v97, v93);
          uint64_t v99 = v98;
          if (SHIBYTE(__b[2].__locale_) < 0)
          {
            operator delete(__b[0].__locale_);
            if (v99 != v93)
            {
LABEL_117:
              std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
              uint64_t v30 = v373;
              goto LABEL_118;
            }
          }
          else if (v98 != v93)
          {
            goto LABEL_117;
          }
        }
        uint64_t v100 = "\n" - v90 + 1;
        if (v100 < 1
          || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v86 + 96))(v86, v90, "\n" - v90 + 1) == v100)
        {
          *((void *)v85 + 3) = 0;
          uint64_t v30 = v373;
          goto LABEL_118;
        }
        goto LABEL_117;
      }
LABEL_118:
      MEMORY[0x1A6238D00](v384);
      uint64_t v101 = *(void **)(v30 + 16);
      v376 = (void *)(v30 + 24);
      if (v101 != (void *)(v30 + 24))
      {
        do
        {
          uint64_t v113 = v101[5];
          uint64_t v112 = v101[6];
          v378 = v101;
          uint64_t v379 = v112;
          while (v113 != v112)
          {
            MEMORY[0x1A6238CF0](v384, a2);
            if (!LOBYTE(v384[0].__locale_)) {
              goto LABEL_170;
            }
            uint64_t v114 = (char *)a2 + *(void *)(*a2 - 24);
            uint64_t v115 = *((void *)v114 + 5);
            int v116 = *((_DWORD *)v114 + 2);
            int v117 = *((_DWORD *)v114 + 36);
            if (v117 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
              uint64_t v118 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
              int v117 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v118->__vftable[2].~facet_0)(v118, 32);
              std::locale::~locale(__b);
              *((_DWORD *)v114 + 36) = v117;
            }
            if ((v116 & 0xB0) == 0x20) {
              uint64_t v119 = "";
            }
            else {
              uint64_t v119 = "  ";
            }
            if (!v115) {
              goto LABEL_169;
            }
            uint64_t v120 = *((void *)v114 + 3);
            BOOL v38 = v120 <= 2;
            uint64_t v121 = v120 - 2;
            size_t v122 = v38 ? 0 : v121;
            if (v119 - "  " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v115 + 96))(v115, "  ", v119 - "  ") != v119 - "  ")
            {
              goto LABEL_169;
            }
            if ((uint64_t)v122 >= 1)
            {
              if (v122 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v122 >= 0x17)
              {
                uint64_t v124 = (v122 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v122 | 7) != 0x17) {
                  uint64_t v124 = v122 | 7;
                }
                uint64_t v125 = v124 + 1;
                int v123 = (std::locale::__imp *)operator new(v124 + 1);
                __b[1].__locale_ = (std::locale::__imp *)v122;
                __b[2].__locale_ = (std::locale::__imp *)(v125 | 0x8000000000000000);
                __b[0].__locale_ = v123;
              }
              else
              {
                HIBYTE(__b[2].__locale_) = v122;
                int v123 = (std::locale::__imp *)__b;
              }
              memset(v123, v117, v122);
              *((unsigned char *)v123 + v122) = 0;
              if (SHIBYTE(__b[2].__locale_) >= 0) {
                uint64_t v126 = __b;
              }
              else {
                uint64_t v126 = __b[0].__locale_;
              }
              uint64_t v127 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v115 + 96))(v115, v126, v122);
              uint64_t v128 = v127;
              if (SHIBYTE(__b[2].__locale_) < 0)
              {
                operator delete(__b[0].__locale_);
                if (v128 != v122) {
                  goto LABEL_169;
                }
              }
              else if (v127 != v122)
              {
                goto LABEL_169;
              }
            }
            uint64_t v129 = "  " - v119 + 2;
            if (v129 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v115 + 96))(v115, v119, "  " - v119 + 2) == v129)
            {
              *((void *)v114 + 3) = 0;
              goto LABEL_170;
            }
LABEL_169:
            std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
LABEL_170:
            MEMORY[0x1A6238D00](v384);
            GEOPolylineCoordinateAsFullString();
            id v381 = objc_claimAutoreleasedReturnValue();
            unint64_t v130 = (const char *)[v381 UTF8String];
            int64_t v131 = strlen(v130);
            MEMORY[0x1A6238CF0](v384, a2);
            if (!LOBYTE(v384[0].__locale_)) {
              goto LABEL_200;
            }
            uint64_t v132 = (char *)a2 + *(void *)(*a2 - 24);
            uint64_t v133 = *((void *)v132 + 5);
            int v134 = *((_DWORD *)v132 + 2);
            int v135 = *((_DWORD *)v132 + 36);
            if (v135 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
              unint64_t v136 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
              int v135 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v136->__vftable[2].~facet_0)(v136, 32);
              std::locale::~locale(__b);
              *((_DWORD *)v132 + 36) = v135;
            }
            int v137 = &v130[v131];
            if ((v134 & 0xB0) == 0x20) {
              uint64_t v138 = &v130[v131];
            }
            else {
              uint64_t v138 = v130;
            }
            if (!v133) {
              goto LABEL_199;
            }
            int64_t v139 = *((void *)v132 + 3);
            BOOL v38 = v139 <= v131;
            int64_t v140 = v139 - v131;
            size_t v141 = v38 ? 0 : v140;
            if (v138 - v130 >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v133 + 96))(v133, v130, v138 - v130) != v138 - v130)
            {
              goto LABEL_199;
            }
            if ((uint64_t)v141 >= 1)
            {
              if (v141 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v141 >= 0x17)
              {
                uint64_t v143 = (v141 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v141 | 7) != 0x17) {
                  uint64_t v143 = v141 | 7;
                }
                uint64_t v144 = v143 + 1;
                int64_t v142 = (std::locale::__imp *)operator new(v143 + 1);
                __b[1].__locale_ = (std::locale::__imp *)v141;
                __b[2].__locale_ = (std::locale::__imp *)(v144 | 0x8000000000000000);
                __b[0].__locale_ = v142;
              }
              else
              {
                HIBYTE(__b[2].__locale_) = v141;
                int64_t v142 = (std::locale::__imp *)__b;
              }
              memset(v142, v135, v141);
              *((unsigned char *)v142 + v141) = 0;
              if (SHIBYTE(__b[2].__locale_) >= 0) {
                uint64_t v145 = __b;
              }
              else {
                uint64_t v145 = __b[0].__locale_;
              }
              uint64_t v146 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v133 + 96))(v133, v145, v141);
              uint64_t v147 = v146;
              if (SHIBYTE(__b[2].__locale_) < 0)
              {
                operator delete(__b[0].__locale_);
                if (v147 != v141) {
                  goto LABEL_199;
                }
              }
              else if (v146 != v141)
              {
                goto LABEL_199;
              }
            }
            if (v137 - v138 < 1
              || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v133 + 96))(v133, v138, v137 - v138) == v137 - v138)
            {
              *((void *)v132 + 3) = 0;
              goto LABEL_200;
            }
LABEL_199:
            std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
LABEL_200:
            MEMORY[0x1A6238D00](v384);
            MEMORY[0x1A6238CF0](v384, a2);
            if (!LOBYTE(v384[0].__locale_)) {
              goto LABEL_230;
            }
            unint64_t v148 = (char *)a2 + *(void *)(*a2 - 24);
            uint64_t v149 = *((void *)v148 + 5);
            int v150 = *((_DWORD *)v148 + 2);
            int v151 = *((_DWORD *)v148 + 36);
            if (v151 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
              uint64_t v152 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
              int v151 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v152->__vftable[2].~facet_0)(v152, 32);
              std::locale::~locale(__b);
              *((_DWORD *)v148 + 36) = v151;
            }
            if ((v150 & 0xB0) == 0x20) {
              int v153 = "";
            }
            else {
              int v153 = " - ";
            }
            if (!v149) {
              goto LABEL_229;
            }
            uint64_t v154 = *((void *)v148 + 3);
            BOOL v38 = v154 <= 3;
            uint64_t v155 = v154 - 3;
            size_t v156 = v38 ? 0 : v155;
            if (v153 - " - " >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v149 + 96))(v149, " - ", v153 - " - ") != v153 - " - ")
            {
              goto LABEL_229;
            }
            if ((uint64_t)v156 >= 1)
            {
              if (v156 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v156 >= 0x17)
              {
                uint64_t v158 = (v156 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v156 | 7) != 0x17) {
                  uint64_t v158 = v156 | 7;
                }
                uint64_t v159 = v158 + 1;
                int v157 = (std::locale::__imp *)operator new(v158 + 1);
                __b[1].__locale_ = (std::locale::__imp *)v156;
                __b[2].__locale_ = (std::locale::__imp *)(v159 | 0x8000000000000000);
                __b[0].__locale_ = v157;
              }
              else
              {
                HIBYTE(__b[2].__locale_) = v156;
                int v157 = (std::locale::__imp *)__b;
              }
              memset(v157, v151, v156);
              *((unsigned char *)v157 + v156) = 0;
              if (SHIBYTE(__b[2].__locale_) >= 0) {
                uint64_t v160 = __b;
              }
              else {
                uint64_t v160 = __b[0].__locale_;
              }
              uint64_t v161 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v149 + 96))(v149, v160, v156);
              uint64_t v162 = v161;
              if (SHIBYTE(__b[2].__locale_) < 0)
              {
                operator delete(__b[0].__locale_);
                if (v162 != v156) {
                  goto LABEL_229;
                }
              }
              else if (v161 != v156)
              {
                goto LABEL_229;
              }
            }
            uint64_t v163 = " - " - v153 + 3;
            if (v163 < 1
              || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v149 + 96))(v149, v153, " - " - v153 + 3) == v163)
            {
              *((void *)v148 + 3) = 0;
              goto LABEL_230;
            }
LABEL_229:
            std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
LABEL_230:
            MEMORY[0x1A6238D00](v384);
            GEOPolylineCoordinateAsFullString();
            id v164 = objc_claimAutoreleasedReturnValue();
            uint64_t v165 = (const char *)[v164 UTF8String];
            int64_t v166 = strlen(v165);
            MEMORY[0x1A6238CF0](v384, a2);
            if (!LOBYTE(v384[0].__locale_)) {
              goto LABEL_260;
            }
            long long v167 = (char *)a2 + *(void *)(*a2 - 24);
            uint64_t v168 = *((void *)v167 + 5);
            int v169 = *((_DWORD *)v167 + 2);
            int v170 = *((_DWORD *)v167 + 36);
            if (v170 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
              char v171 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
              int v170 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v171->__vftable[2].~facet_0)(v171, 32);
              std::locale::~locale(__b);
              *((_DWORD *)v167 + 36) = v170;
            }
            unint64_t v172 = &v165[v166];
            if ((v169 & 0xB0) == 0x20) {
              uint8x8_t v173 = &v165[v166];
            }
            else {
              uint8x8_t v173 = v165;
            }
            if (!v168) {
              goto LABEL_259;
            }
            int64_t v174 = *((void *)v167 + 3);
            BOOL v38 = v174 <= v166;
            int64_t v175 = v174 - v166;
            size_t v176 = v38 ? 0 : v175;
            if (v173 - v165 >= 1
              && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v168 + 96))(v168, v165, v173 - v165) != v173 - v165)
            {
              goto LABEL_259;
            }
            if ((uint64_t)v176 >= 1)
            {
              if (v176 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              if (v176 >= 0x17)
              {
                uint64_t v178 = (v176 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v176 | 7) != 0x17) {
                  uint64_t v178 = v176 | 7;
                }
                uint64_t v179 = v178 + 1;
                size_t v177 = (std::locale::__imp *)operator new(v178 + 1);
                __b[1].__locale_ = (std::locale::__imp *)v176;
                __b[2].__locale_ = (std::locale::__imp *)(v179 | 0x8000000000000000);
                __b[0].__locale_ = v177;
              }
              else
              {
                HIBYTE(__b[2].__locale_) = v176;
                size_t v177 = (std::locale::__imp *)__b;
              }
              memset(v177, v170, v176);
              *((unsigned char *)v177 + v176) = 0;
              if (SHIBYTE(__b[2].__locale_) >= 0) {
                int v180 = __b;
              }
              else {
                int v180 = __b[0].__locale_;
              }
              uint64_t v181 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v168 + 96))(v168, v180, v176);
              uint64_t v182 = v181;
              if (SHIBYTE(__b[2].__locale_) < 0)
              {
                operator delete(__b[0].__locale_);
                if (v182 != v176) {
                  goto LABEL_259;
                }
              }
              else if (v181 != v176)
              {
                goto LABEL_259;
              }
            }
            if (v172 - v173 < 1
              || (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v168 + 96))(v168, v173, v172 - v173) == v172 - v173)
            {
              *((void *)v167 + 3) = 0;
              goto LABEL_260;
            }
LABEL_259:
            std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
LABEL_260:
            MEMORY[0x1A6238D00](v384);
            MEMORY[0x1A6238CF0](v384, a2);
            if (LOBYTE(v384[0].__locale_))
            {
              uint8x8_t v183 = (char *)a2 + *(void *)(*a2 - 24);
              uint64_t v184 = *((void *)v183 + 5);
              int v185 = *((_DWORD *)v183 + 2);
              int v186 = *((_DWORD *)v183 + 36);
              if (v186 == -1)
              {
                std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
                uint64_t v187 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
                int v186 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v187->__vftable[2].~facet_0)(v187, 32);
                std::locale::~locale(__b);
                *((_DWORD *)v183 + 36) = v186;
              }
              if ((v185 & 0xB0) == 0x20) {
                unint64_t v188 = "";
              }
              else {
                unint64_t v188 = "\n";
              }
              if (!v184) {
                goto LABEL_137;
              }
              uint64_t v189 = *((void *)v183 + 3);
              BOOL v38 = v189 <= 1;
              uint64_t v190 = v189 - 1;
              size_t v191 = v38 ? 0 : v190;
              if (v188 - "\n" >= 1
                && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v184 + 96))(v184, "\n", v188 - "\n") != v188 - "\n")
              {
                goto LABEL_137;
              }
              if ((uint64_t)v191 >= 1)
              {
                if (v191 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                if (v191 >= 0x17)
                {
                  uint64_t v193 = (v191 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v191 | 7) != 0x17) {
                    uint64_t v193 = v191 | 7;
                  }
                  uint64_t v194 = v193 + 1;
                  unint64_t v192 = (std::locale::__imp *)operator new(v193 + 1);
                  __b[1].__locale_ = (std::locale::__imp *)v191;
                  __b[2].__locale_ = (std::locale::__imp *)(v194 | 0x8000000000000000);
                  __b[0].__locale_ = v192;
                }
                else
                {
                  HIBYTE(__b[2].__locale_) = v191;
                  unint64_t v192 = (std::locale::__imp *)__b;
                }
                memset(v192, v186, v191);
                *((unsigned char *)v192 + v191) = 0;
                if (SHIBYTE(__b[2].__locale_) >= 0) {
                  uint64_t v195 = __b;
                }
                else {
                  uint64_t v195 = __b[0].__locale_;
                }
                uint64_t v196 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v184 + 96))(v184, v195, v191);
                uint64_t v197 = v196;
                if (SHIBYTE(__b[2].__locale_) < 0)
                {
                  operator delete(__b[0].__locale_);
                  if (v197 != v191) {
                    goto LABEL_137;
                  }
                }
                else if (v196 != v191)
                {
                  goto LABEL_137;
                }
              }
              uint64_t v198 = "\n" - v188 + 1;
              if (v198 >= 1
                && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v184 + 96))(v184, v188, "\n" - v188 + 1) != v198)
              {
LABEL_137:
                std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
                goto LABEL_138;
              }
              *((void *)v183 + 3) = 0;
            }
LABEL_138:
            MEMORY[0x1A6238D00](v384);

            v113 += 16;
            uint64_t v112 = v379;
          }
          uint64_t v199 = v378;
          size_t v200 = (void *)v378[1];
          if (v200)
          {
            do
            {
              size_t v201 = v200;
              size_t v200 = (void *)*v200;
            }
            while (v200);
          }
          else
          {
            do
            {
              size_t v201 = (void *)v199[2];
              BOOL v202 = *v201 == (void)v199;
              uint64_t v199 = v201;
            }
            while (!v202);
          }
          uint64_t v101 = v201;
        }
        while (v201 != v376);
      }
      MEMORY[0x1A6238CF0](v384, a2);
      if (!LOBYTE(v384[0].__locale_)) {
        goto LABEL_10;
      }
      uint64_t v102 = (char *)a2 + *(void *)(*a2 - 24);
      uint64_t v103 = *((void *)v102 + 5);
      int v104 = *((_DWORD *)v102 + 2);
      int v105 = *((_DWORD *)v102 + 36);
      if (v105 == -1)
      {
        std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
        uint64_t v106 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
        int v105 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v106->__vftable[2].~facet_0)(v106, 32);
        std::locale::~locale(__b);
        *((_DWORD *)v102 + 36) = v105;
      }
      if ((v104 & 0xB0) == 0x20) {
        uint64_t v107 = "";
      }
      else {
        uint64_t v107 = "\n";
      }
      if (!v103) {
        goto LABEL_9;
      }
      uint64_t v108 = *((void *)v102 + 3);
      BOOL v38 = v108 <= 1;
      uint64_t v109 = v108 - 1;
      size_t v110 = v38 ? 0 : v109;
      if (v107 - "\n" >= 1
        && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v103 + 96))(v103, "\n", v107 - "\n") != v107 - "\n")
      {
        goto LABEL_9;
      }
      if ((uint64_t)v110 >= 1)
      {
        if (v110 > 0x7FFFFFFFFFFFFFF7) {
          abort();
        }
        if (v110 >= 0x17)
        {
          uint64_t v203 = (v110 & 0xFFFFFFFFFFFFFFF8) + 8;
          if ((v110 | 7) != 0x17) {
            uint64_t v203 = v110 | 7;
          }
          uint64_t v204 = v203 + 1;
          uint64_t v111 = (std::locale::__imp *)operator new(v203 + 1);
          __b[1].__locale_ = (std::locale::__imp *)v110;
          __b[2].__locale_ = (std::locale::__imp *)(v204 | 0x8000000000000000);
          __b[0].__locale_ = v111;
        }
        else
        {
          HIBYTE(__b[2].__locale_) = v110;
          uint64_t v111 = (std::locale::__imp *)__b;
        }
        memset(v111, v105, v110);
        *((unsigned char *)v111 + v110) = 0;
        if (SHIBYTE(__b[2].__locale_) >= 0) {
          uint64_t v205 = __b;
        }
        else {
          uint64_t v205 = __b[0].__locale_;
        }
        uint64_t v206 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v103 + 96))(v103, v205, v110);
        uint64_t v207 = v206;
        if ((SHIBYTE(__b[2].__locale_) & 0x80000000) == 0)
        {
          if (v206 == v110) {
            goto LABEL_305;
          }
LABEL_9:
          std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
          goto LABEL_10;
        }
        operator delete(__b[0].__locale_);
        if (v207 != v110) {
          goto LABEL_9;
        }
      }
LABEL_305:
      uint64_t v208 = "\n" - v107 + 1;
      if (v208 >= 1
        && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v103 + 96))(v103, v107, "\n" - v107 + 1) != v208)
      {
        goto LABEL_9;
      }
      *((void *)v102 + 3) = 0;
LABEL_10:
      MEMORY[0x1A6238D00](v384);
      uint64_t v30 = v373 + 48;
      uint64_t v29 = v369;
    }
    uint64_t v209 = v367;
    v210 = (void *)v367[1];
    if (v210)
    {
      do
      {
        uint64_t v211 = v210;
        v210 = (void *)*v210;
      }
      while (v210);
    }
    else
    {
      do
      {
        uint64_t v211 = (void *)v209[2];
        BOOL v202 = *v211 == (void)v209;
        uint64_t v209 = v211;
      }
      while (!v202);
    }
    unint64_t v3 = v211;
    if (v211 != v365) {
      continue;
    }
    break;
  }
LABEL_2:
  uint64_t v4 = *(void *)(a1 + 288);
  if (*(void *)(a1 + 296) != v4)
  {
    unint64_t v5 = 0;
    do
    {
      id v6 = *(id *)(v4 + 8 * v5);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"Route Idx ", 10);
      unint64_t v7 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)": ", 2);
      uint8x8_t v8 = [v6 displayEtaDescription];
      id v9 = [v8 etaText];
      uint64_t v10 = (const char *)[v9 UTF8String];
      size_t v11 = strlen(v10);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)v10, v11);
      LOBYTE(__b[0].__locale_) = 10;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v7, (uint64_t)__b, 1);

      ++v5;
      uint64_t v4 = *(void *)(a1 + 288);
    }
    while (v5 < (*(void *)(a1 + 296) - v4) >> 3);
  }
  uint64_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\n", 1);
  float v13 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)"-- current placements --\n", 25);
  *(void *)((char *)v13 + *(void *)(*v13 - 24) + 24) = 4;
  float v14 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v13, (uint64_t)"Idx", 3);
  *(void *)((char *)v14 + *(void *)(*v14 - 24) + 24) = 10;
  BOOL v15 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v14, (uint64_t)"Lat", 3);
  *(void *)((char *)v15 + *(void *)(*v15 - 24) + 24) = 10;
  unint64_t v16 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v15, (uint64_t)"Long", 4);
  *(void *)((char *)v16 + *(void *)(*v16 - 24) + 24) = 8;
  unint64_t v17 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v16, (uint64_t)"Orient", 6);
  *(void *)((char *)v17 + *(void *)(*v17 - 24) + 24) = 8;
  float v18 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v17, (uint64_t)"Avoid", 5);
  *(void *)((char *)v18 + *(void *)(*v18 - 24) + 24) = 8;
  unint64_t v19 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v18, (uint64_t)"Clipped", 7);
  *(void *)((char *)v19 + *(void *)(*v19 - 24) + 24) = 8;
  uint8x8_t v20 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v19, (uint64_t)"Labels", 6);
  *(void *)((char *)v20 + *(void *)(*v20 - 24) + 24) = 8;
  uint64_t v21 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v20, (uint64_t)"Route", 5);
  *(void *)((char *)v21 + *(void *)(*v21 - 24) + 24) = 8;
  uint64_t v22 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v21, (uint64_t)"Balance", 7);
  v372 = v22 + 3;
  *(void *)((char *)v22 + *(void *)(*v22 - 24) + 24) = 8;
  float v23 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v22, (uint64_t)"MinDist", 7);
  v371 = v23 + 2;
  *(void *)((char *)v23 + *(void *)(*v23 - 24) + 24) = 8;
  unint64_t v24 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v23, (uint64_t)"Shr Cnt", 7);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n", 1);
  uint64_t v25 = *(void *)(a1 + 288);
  if (*(void *)(a1 + 296) != v25)
  {
    unint64_t v26 = 0;
    do
    {
      id v212 = *(id *)(v25 + 8 * v26);
      uint64_t v213 = [v212 routeInfo];
      *(void *)((char *)v372 + *(void *)(*a2 - 24)) = 4;
      std::ostream::operator<<();
      if (v213)
      {
        v214 = md::LabelNavEtaLabeler::routeLabelStatesForRouteInfo((md::LabelNavEtaLabeler *)a1, v213);
        if (!v214 || (uint64_t v215 = *(void *)v214, *(void *)v214 == *((void *)v214 + 1)))
        {
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"no route label state\n", 21);
        }
        else
        {
          v216 = [(VKRouteInfo *)v213 route];
          objc_msgSend(v216, "pointWithAltitudeCorrectionAtRouteCoordinate:", objc_msgSend(v212, "routeOffset"));

          if (*(unsigned char *)(v215 + 156))
          {
            uint64_t v217 = *a2;
            *(void *)((char *)v372 + *(void *)(*a2 - 24)) = 10;
            *(_DWORD *)((char *)a2 + *(void *)(v217 - 24) + 8) = *(_DWORD *)((unsigned char *)a2 + *(void *)(v217 - 24) + 8) & 0xFFFFFEFB | 4;
            *(void *)((char *)v371 + *(void *)(v217 - 24)) = 4;
            v218 = (void *)std::ostream::operator<<();
            *(void *)((char *)v218 + *(void *)(*v218 - 24) + 24) = 10;
            uint64_t v219 = (void *)std::ostream::operator<<();
            *(void *)((char *)v219 + *(void *)(*v219 - 24) + 24) = 8;
            switch([v212 orientation])
            {
              case 0u:
                HIBYTE(__b[2].__locale_) = 4;
                strcpy((char *)__b, "None");
                uint64_t v220 = 4;
                break;
              case 1u:
                HIBYTE(__b[2].__locale_) = 13;
                uint64_t v221 = "ArrowDownLeft";
                goto LABEL_335;
              case 2u:
                HIBYTE(__b[2].__locale_) = 14;
                strcpy((char *)__b, "ArrowDownRight");
                uint64_t v220 = 14;
                break;
              case 3u:
                HIBYTE(__b[2].__locale_) = 15;
                strcpy((char *)__b, "ArrowDownMiddle");
                uint64_t v220 = 15;
                break;
              case 4u:
                HIBYTE(__b[2].__locale_) = 9;
                strcpy((char *)__b, "ArrowLeft");
                uint64_t v220 = 9;
                break;
              case 5u:
                HIBYTE(__b[2].__locale_) = 10;
                strcpy((char *)__b, "ArrowRight");
                uint64_t v220 = 10;
                break;
              case 6u:
                HIBYTE(__b[2].__locale_) = 17;
                strcpy((char *)__b, "HalfArrowDownLeft");
                uint64_t v220 = 17;
                break;
              case 7u:
                HIBYTE(__b[2].__locale_) = 18;
                strcpy((char *)__b, "HalfArrowDownRight");
                uint64_t v220 = 18;
                break;
              case 8u:
                HIBYTE(__b[2].__locale_) = 21;
                strcpy((char *)__b, "ArrowDownDiagonalLeft");
                uint64_t v220 = 21;
                break;
              case 9u:
                strcpy((char *)__b, "ArrowDownDiagonalRight");
                HIBYTE(__b[2].__locale_) = 22;
                uint64_t v220 = 22;
                break;
              case 0xAu:
                HIBYTE(__b[2].__locale_) = 13;
                uint64_t v221 = "ArrowUpMiddle";
LABEL_335:
                __b[0] = *(std::locale *)v221;
                *(std::locale::__imp **)((char *)&__b[0].__locale_ + 5) = *(std::locale::__imp **)(v221 + 5);
                BYTE5(__b[1].__locale_) = 0;
                uint64_t v220 = 13;
                break;
              case 0xBu:
                HIBYTE(__b[2].__locale_) = 19;
                strcpy((char *)__b, "ArrowUpDiagonalLeft");
                uint64_t v220 = 19;
                break;
              case 0xCu:
                HIBYTE(__b[2].__locale_) = 20;
                strcpy((char *)__b, "ArrowUpDiagonalRight");
                uint64_t v220 = 20;
                break;
              case 0xDu:
                HIBYTE(__b[2].__locale_) = 7;
                strcpy((char *)__b, "NoArrow");
                uint64_t v220 = 7;
                break;
              default:
                uint64_t v220 = 0;
                HIBYTE(__b[2].__locale_) = 0;
                LOBYTE(__b[0].__locale_) = 0;
                break;
            }
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v219, (uint64_t)__b, v220);
            if (SHIBYTE(__b[2].__locale_) < 0) {
              operator delete(__b[0].__locale_);
            }
            *(void *)((char *)v372 + *(void *)(*a2 - 24)) = 8;
            unint64_t v222 = (void *)std::ostream::operator<<();
            *(void *)((char *)v222 + *(void *)(*v222 - 24) + 24) = 8;
            uint64_t v223 = (void *)std::ostream::operator<<();
            *(void *)((char *)v223 + *(void *)(*v223 - 24) + 24) = 8;
            std::string v224 = (void *)std::ostream::operator<<();
            *(void *)((char *)v224 + *(void *)(*v224 - 24) + 24) = 8;
            int v225 = (void *)std::ostream::operator<<();
            *(void *)((char *)v225 + *(void *)(*v225 - 24) + 24) = 8;
            if (*(float *)(v215 + 164) == 3.4028e38) {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"Max", 3);
            }
            else {
              std::ostream::operator<<();
            }
            *(void *)((char *)v372 + *(void *)(*a2 - 24)) = 8;
            if (*(float *)(v215 + 160) == 3.4028e38) {
              std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"Max", 3);
            }
            else {
              std::ostream::operator<<();
            }
            *(void *)((char *)v372 + *(void *)(*a2 - 24)) = 8;
            std::ostream::operator<<();
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\n", 1);
          }
        }
      }
      else
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"no route info\n", 14);
      }

      ++v26;
      uint64_t v25 = *(void *)(a1 + 288);
    }
    while (v26 < (*(void *)(a1 + 296) - v25) >> 3);
  }
  *(void *)((char *)a2 + *(void *)(*a2 - 24) + 24) = 0;
  v226 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\n-- last search results --\n", 27);
  *(void *)((char *)v226 + *(void *)(*v226 - 24) + 24) = 12;
  CACurrentMediaTime();
  uint64_t v227 = *(void *)(a1 + 288);
  if (*(void *)(a1 + 296) != v227)
  {
    uint64_t v228 = 0;
    v370 = a2 + 1;
    while (1)
    {
      id v368 = *(id *)(v227 + 8 * v228);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\nRoute ", 7);
      float64x2_t v229 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v229, (uint64_t)": ", 2);
      double v230 = [v368 routeInfo];
      uint64_t v366 = v228;
      if (!v230)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"no route info\n", 14);
        goto LABEL_350;
      }
      float64x2_t v231 = md::LabelNavEtaLabeler::routeLabelStatesForRouteInfo((md::LabelNavEtaLabeler *)a1, v230);
      uint64_t v374 = *(void *)v231;
      if (*(double *)(*(void *)v231 + 208) == 0.0)
      {
        float64x2_t v233 = a2;
        double v234 = "no last search\n";
        uint64_t v235 = 15;
      }
      else
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"last search was ", 16);
        double v232 = (void *)std::ostream::operator<<();
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v232, (uint64_t)" seconds ago. did find = ", 25);
        float64x2_t v233 = (void *)std::ostream::operator<<();
        double v234 = "\n";
        uint64_t v235 = 1;
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v233, (uint64_t)v234, v235);
      if (a3)
      {
        uint64_t v236 = *a2;
        *(_DWORD *)((char *)v370 + *(void *)(*a2 - 24)) &= 0xFFFFFEFB;
        *(void *)((char *)v371 + *(void *)(v236 - 24)) = 10;
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"Screen Projection Matrix :\n", 27);
        uint64_t v237 = 0;
        uint64_t v238 = v374 + 224;
        v382 = v230;
        do
        {
          for (uint64_t i = 0; ; i += 32)
          {
            std::ostream::operator<<();
            if (i == 96) {
              break;
            }
            MEMORY[0x1A6238CF0](v384, a2);
            if (LOBYTE(v384[0].__locale_))
            {
              v240 = (char *)a2 + *(void *)(*a2 - 24);
              uint64_t v241 = *((void *)v240 + 5);
              int v242 = *((_DWORD *)v240 + 2);
              int v243 = *((_DWORD *)v240 + 36);
              if (v243 == -1)
              {
                std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
                v244 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
                int v243 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v244->__vftable[2].~facet_0)(v244, 32);
                std::locale::~locale(__b);
                *((_DWORD *)v240 + 36) = v243;
              }
              if ((v242 & 0xB0) == 0x20) {
                v245 = "";
              }
              else {
                v245 = ", ";
              }
              if (!v241) {
                goto LABEL_359;
              }
              uint64_t v246 = *((void *)v240 + 3);
              BOOL v38 = v246 <= 2;
              uint64_t v247 = v246 - 2;
              size_t v248 = v38 ? 0 : v247;
              if (v245 - ", " >= 1
                && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v241 + 96))(v241, ", ", v245 - ", ") != v245 - ", ")
              {
                goto LABEL_359;
              }
              if ((uint64_t)v248 >= 1)
              {
                if (v248 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                if (v248 >= 0x17)
                {
                  uint64_t v250 = (v248 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v248 | 7) != 0x17) {
                    uint64_t v250 = v248 | 7;
                  }
                  uint64_t v251 = v250 + 1;
                  v249 = (std::locale::__imp *)operator new(v250 + 1);
                  __b[1].__locale_ = (std::locale::__imp *)v248;
                  __b[2].__locale_ = (std::locale::__imp *)(v251 | 0x8000000000000000);
                  __b[0].__locale_ = v249;
                }
                else
                {
                  HIBYTE(__b[2].__locale_) = v248;
                  v249 = (std::locale::__imp *)__b;
                }
                memset(v249, v243, v248);
                *((unsigned char *)v249 + v248) = 0;
                if (SHIBYTE(__b[2].__locale_) >= 0) {
                  v252 = __b;
                }
                else {
                  v252 = __b[0].__locale_;
                }
                uint64_t v253 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v241 + 96))(v241, v252, v248);
                uint64_t v254 = v253;
                if (SHIBYTE(__b[2].__locale_) < 0)
                {
                  operator delete(__b[0].__locale_);
                  if (v254 != v248) {
                    goto LABEL_359;
                  }
                }
                else if (v253 != v248)
                {
                  goto LABEL_359;
                }
              }
              uint64_t v255 = ", " - v245 + 2;
              if (v255 >= 1
                && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v241 + 96))(v241, v245, ", " - v245 + 2) != v255)
              {
LABEL_359:
                double v230 = v382;
                std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
                goto LABEL_360;
              }
              *((void *)v240 + 3) = 0;
              double v230 = v382;
            }
LABEL_360:
            MEMORY[0x1A6238D00](v384);
          }
          MEMORY[0x1A6238CF0](__b, a2);
          if (LOBYTE(__b[0].__locale_))
          {
            uint64_t v256 = (uint64_t)a2 + *(void *)(*a2 - 24);
            uint64_t v257 = *(void *)(v256 + 40);
            int v258 = *(_DWORD *)(v256 + 8);
            int v259 = *(_DWORD *)(v256 + 144);
            if (v259 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
              v260 = std::locale::use_facet(v384, MEMORY[0x1E4FBA258]);
              int v259 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v260->__vftable[2].~facet_0)(v260, 32);
              std::locale::~locale(v384);
              *(_DWORD *)(v256 + 144) = v259;
            }
            if ((v258 & 0xB0) == 0x20) {
              v261 = "";
            }
            else {
              v261 = "\n";
            }
            if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v257, (uint64_t)"\n", (uint64_t)v261, (uint64_t)"", v256, (char)v259))std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5); {
          }
            }
          MEMORY[0x1A6238D00](__b);
          ++v237;
          v238 += 8;
        }
        while (v237 != 4);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"\n", 1);
        v262 = v372;
        uint64_t v263 = *a2;
        *(_DWORD *)((char *)v370 + *(void *)(*a2 - 24)) = *(_DWORD *)((unsigned char *)v370 + *(void *)(*a2 - 24)) & 0xFFFFFEFB | 4;
        *(void *)((char *)v371 + *(void *)(v263 - 24)) = 4;
        if (*(void *)(v374 + 360) != *(void *)(v374 + 352))
        {
          *(void *)((char *)v372 + *(void *)(v263 - 24)) = 10;
          v264 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a2, (uint64_t)"Lat", 3);
          *(void *)((char *)v372 + *(void *)(*v264 - 24)) = 10;
          v265 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v264, (uint64_t)"Long", 4);
          *(void *)((char *)v372 + *(void *)(*v265 - 24)) = 8;
          v266 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v265, (uint64_t)"Orient", 6);
          *(void *)((char *)v372 + *(void *)(*v266 - 24)) = 8;
          v267 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v266, (uint64_t)"Avoid", 5);
          *(void *)((char *)v372 + *(void *)(*v267 - 24)) = 8;
          v268 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v267, (uint64_t)"Clipped", 7);
          *(void *)((char *)v372 + *(void *)(*v268 - 24)) = 8;
          v269 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v268, (uint64_t)"Labels", 6);
          *(void *)((char *)v372 + *(void *)(*v269 - 24)) = 8;
          v270 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v269, (uint64_t)"Route", 5);
          *(void *)((char *)v372 + *(void *)(*v270 - 24)) = 8;
          v271 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v270, (uint64_t)"Balance", 7);
          *(void *)((char *)v372 + *(void *)(*v271 - 24)) = 8;
          v272 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v271, (uint64_t)"MinDist", 7);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v272, (uint64_t)"\n", 1);
          v273 = *(void **)(v374 + 64);
          if (v273) {
            break;
          }
        }
      }
LABEL_350:

      uint64_t v228 = v366 + 1;
      uint64_t v227 = *(void *)(a1 + 288);
      if (v366 + 1 >= (unint64_t)((*(void *)(a1 + 296) - v227) >> 3)) {
        return;
      }
    }
    if (*(void *)(v374 + 352) == *(void *)(v374 + 360))
    {
      do
        v273 = (void *)*v273;
      while (v273);
      goto LABEL_350;
    }
    while (2)
    {
      v377 = v273;
      uint64_t v275 = *(void *)(v374 + 352);
      uint64_t v274 = *(void *)(v374 + 360);
      uint64_t v380 = v274;
LABEL_408:
      if (v275 == v274)
      {
        v273 = (void *)*v377;
        if (!*v377) {
          goto LABEL_350;
        }
        continue;
      }
      break;
    }
    v276 = [(VKRouteInfo *)v230 route];
    PolylineCoordinate v277 = *(PolylineCoordinate *)v275;
    PolylineCoordinate v278 = *(PolylineCoordinate *)(v275 + 8);
    unint64_t ClosestCoordinateBetweenVertices = md::LabelNavEtaLabeler::findClosestCoordinateBetweenVertices(a1, (float64x2_t *)(v374 + 224), v276, v277, v278, *(float *)(v275 + 16));

    v280 = [(VKRouteInfo *)v230 route];
    [v280 pointWithAltitudeCorrectionAtRouteCoordinate:ClosestCoordinateBetweenVertices];

    int8x8_t v281 = *(int8x8_t *)(v275 + 40);
    if (!*(void *)&v281) {
      goto LABEL_480;
    }
    unint64_t v282 = *((unsigned __int8 *)v377 + 16);
    uint8x8_t v283 = (uint8x8_t)vcnt_s8(v281);
    v283.i16[0] = vaddlv_u8(v283);
    if (v283.u32[0] > 1uLL)
    {
      unint64_t v284 = *((unsigned __int8 *)v377 + 16);
      if (*(void *)&v281 <= v282) {
        unint64_t v284 = v282 % *(void *)&v281;
      }
    }
    else
    {
      unint64_t v284 = (v281.i32[0] - 1) & v282;
    }
    v285 = *(uint64_t ****)(*(void *)(v275 + 32) + 8 * v284);
    if (!v285) {
      goto LABEL_480;
    }
    v286 = *v285;
    if (!*v285) {
      goto LABEL_480;
    }
    if (v283.u32[0] < 2uLL)
    {
      uint64_t v287 = *(void *)&v281 - 1;
      while (1)
      {
        v289 = v286[1];
        if (v289 == (uint64_t *)v282)
        {
          if (*((unsigned __int8 *)v286 + 16) == v282) {
            goto LABEL_430;
          }
        }
        else if (((unint64_t)v289 & v287) != v284)
        {
          goto LABEL_480;
        }
        v286 = (uint64_t **)*v286;
        if (!v286) {
          goto LABEL_480;
        }
      }
    }
    while (1)
    {
      unint64_t v288 = (unint64_t)v286[1];
      if (v288 == v282)
      {
        if (*((unsigned __int8 *)v286 + 16) == v282)
        {
LABEL_430:
          uint64_t v290 = *a2;
          *(void *)((char *)v262 + *(void *)(*a2 - 24)) = 10;
          *(_DWORD *)((char *)v370 + *(void *)(v290 - 24)) = *(_DWORD *)((unsigned char *)v370 + *(void *)(v290 - 24)) & 0xFFFFFEFB | 4;
          *(void *)((char *)v371 + *(void *)(v290 - 24)) = 4;
          v291 = (void *)std::ostream::operator<<();
          *(void *)((char *)v291 + *(void *)(*v291 - 24) + 24) = 10;
          v292 = (void *)std::ostream::operator<<();
          *(void *)((char *)v292 + *(void *)(*v292 - 24) + 24) = 8;
          switch(*((unsigned char *)v377 + 16))
          {
            case 0:
              HIBYTE(v384[2].__locale_) = 4;
              strcpy((char *)v384, "None");
              uint64_t v293 = 4;
              break;
            case 1:
              HIBYTE(v384[2].__locale_) = 13;
              v294 = "ArrowDownLeft";
              goto LABEL_444;
            case 2:
              HIBYTE(v384[2].__locale_) = 14;
              strcpy((char *)v384, "ArrowDownRight");
              uint64_t v293 = 14;
              break;
            case 3:
              HIBYTE(v384[2].__locale_) = 15;
              strcpy((char *)v384, "ArrowDownMiddle");
              uint64_t v293 = 15;
              break;
            case 4:
              HIBYTE(v384[2].__locale_) = 9;
              strcpy((char *)v384, "ArrowLeft");
              uint64_t v293 = 9;
              break;
            case 5:
              HIBYTE(v384[2].__locale_) = 10;
              strcpy((char *)v384, "ArrowRight");
              uint64_t v293 = 10;
              break;
            case 6:
              HIBYTE(v384[2].__locale_) = 17;
              strcpy((char *)v384, "HalfArrowDownLeft");
              uint64_t v293 = 17;
              break;
            case 7:
              HIBYTE(v384[2].__locale_) = 18;
              strcpy((char *)v384, "HalfArrowDownRight");
              uint64_t v293 = 18;
              break;
            case 8:
              HIBYTE(v384[2].__locale_) = 21;
              strcpy((char *)v384, "ArrowDownDiagonalLeft");
              uint64_t v293 = 21;
              break;
            case 9:
              strcpy((char *)v384, "ArrowDownDiagonalRight");
              HIBYTE(v384[2].__locale_) = 22;
              uint64_t v293 = 22;
              break;
            case 0xA:
              HIBYTE(v384[2].__locale_) = 13;
              v294 = "ArrowUpMiddle";
LABEL_444:
              v384[0] = *(std::locale *)v294;
              *(std::locale::__imp **)((char *)&v384[0].__locale_ + 5) = *(std::locale::__imp **)(v294 + 5);
              BYTE5(v384[1].__locale_) = 0;
              uint64_t v293 = 13;
              break;
            case 0xB:
              HIBYTE(v384[2].__locale_) = 19;
              strcpy((char *)v384, "ArrowUpDiagonalLeft");
              uint64_t v293 = 19;
              break;
            case 0xC:
              HIBYTE(v384[2].__locale_) = 20;
              strcpy((char *)v384, "ArrowUpDiagonalRight");
              uint64_t v293 = 20;
              break;
            case 0xD:
              HIBYTE(v384[2].__locale_) = 7;
              strcpy((char *)v384, "NoArrow");
              uint64_t v293 = 7;
              break;
            default:
              uint64_t v293 = 0;
              HIBYTE(v384[2].__locale_) = 0;
              LOBYTE(v384[0].__locale_) = 0;
              break;
          }
          MEMORY[0x1A6238CF0](v385, v292);
          if (v385[0])
          {
            v295 = (char *)v292 + *(void *)(*v292 - 24);
            uint64_t v296 = *((void *)v295 + 5);
            int v297 = *((_DWORD *)v295 + 2);
            int v298 = *((_DWORD *)v295 + 36);
            if (v298 == -1)
            {
              std::ios_base::getloc((const std::ios_base *)((char *)v292 + *(void *)(*v292 - 24)));
              v299 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
              int v298 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v299->__vftable[2].~facet_0)(v299, 32);
              std::locale::~locale(__b);
              *((_DWORD *)v295 + 36) = v298;
            }
            v300 = (char *)v384 + v293;
            if ((v297 & 0xB0) == 0x20) {
              v301 = (std::locale *)((char *)v384 + v293);
            }
            else {
              v301 = v384;
            }
            if (!v296) {
              goto LABEL_476;
            }
            uint64_t v302 = *((void *)v295 + 3);
            BOOL v38 = v302 <= v293;
            uint64_t v303 = v302 - v293;
            size_t v304 = v38 ? 0 : v303;
            if ((char *)v301 - (char *)v384 >= 1
              && (*(uint64_t (**)(uint64_t, std::locale *, int64_t))(*(void *)v296 + 96))(v296, v384, (char *)v301 - (char *)v384) != (char *)v301 - (char *)v384)
            {
              goto LABEL_476;
            }
            if ((uint64_t)v304 >= 1)
            {
              if (v304 > 0x7FFFFFFFFFFFFFF7) {
                abort();
              }
              v364 = v301;
              if (v304 >= 0x17)
              {
                uint64_t v306 = (v304 & 0xFFFFFFFFFFFFFFF8) + 8;
                if ((v304 | 7) != 0x17) {
                  uint64_t v306 = v304 | 7;
                }
                uint64_t v307 = v306 + 1;
                v305 = (std::locale::__imp *)operator new(v306 + 1);
                __b[1].__locale_ = (std::locale::__imp *)v304;
                __b[2].__locale_ = (std::locale::__imp *)(v307 | 0x8000000000000000);
                __b[0].__locale_ = v305;
              }
              else
              {
                HIBYTE(__b[2].__locale_) = v304;
                v305 = (std::locale::__imp *)__b;
              }
              memset(v305, v298, v304);
              *((unsigned char *)v305 + v304) = 0;
              if (SHIBYTE(__b[2].__locale_) >= 0) {
                v308 = __b;
              }
              else {
                v308 = __b[0].__locale_;
              }
              uint64_t v309 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v296 + 96))(v296, v308, v304);
              uint64_t v310 = v309;
              v301 = v364;
              if (SHIBYTE(__b[2].__locale_) < 0)
              {
                operator delete(__b[0].__locale_);
                if (v310 != v304) {
                  goto LABEL_476;
                }
              }
              else if (v309 != v304)
              {
                goto LABEL_476;
              }
            }
            if (v300 - (char *)v301 < 1
              || (*(uint64_t (**)(uint64_t, std::locale *, int64_t))(*(void *)v296 + 96))(v296, v301, v300 - (char *)v301) == v300 - (char *)v301)
            {
              *((void *)v295 + 3) = 0;
              v262 = v372;
              double v230 = v382;
            }
            else
            {
LABEL_476:
              double v230 = v382;
              std::ios_base::clear((std::ios_base *)((char *)v292 + *(void *)(*v292 - 24)), *(_DWORD *)((char *)v292 + *(void *)(*v292 - 24) + 32) | 5);
              v262 = v372;
            }
          }
          MEMORY[0x1A6238D00](v385);
          if (SHIBYTE(v384[2].__locale_) < 0) {
            operator delete(v384[0].__locale_);
          }
          *(void *)((char *)v262 + *(void *)(*a2 - 24)) = 8;
          v311 = (void *)std::ostream::operator<<();
          *(void *)((char *)v311 + *(void *)(*v311 - 24) + 24) = 8;
          v312 = (void *)std::ostream::operator<<();
          *(void *)((char *)v312 + *(void *)(*v312 - 24) + 24) = 8;
          v313 = (void *)std::ostream::operator<<();
          *(void *)((char *)v313 + *(void *)(*v313 - 24) + 24) = 8;
          v314 = (void *)std::ostream::operator<<();
          *(void *)((char *)v314 + *(void *)(*v314 - 24) + 24) = 8;
LABEL_480:
          if (*(float *)(v275 + 24) == 3.4028e38)
          {
            MEMORY[0x1A6238CF0](v384, a2);
            if (LOBYTE(v384[0].__locale_))
            {
              v315 = (char *)a2 + *(void *)(*a2 - 24);
              uint64_t v316 = *((void *)v315 + 5);
              int v317 = *((_DWORD *)v315 + 2);
              int v318 = *((_DWORD *)v315 + 36);
              if (v318 == -1)
              {
                std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
                v319 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
                int v318 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v319->__vftable[2].~facet_0)(v319, 32);
                std::locale::~locale(__b);
                *((_DWORD *)v315 + 36) = v318;
              }
              if ((v317 & 0xB0) == 0x20) {
                v320 = "";
              }
              else {
                v320 = "Max";
              }
              if (!v316) {
                goto LABEL_511;
              }
              uint64_t v321 = *((void *)v315 + 3);
              BOOL v38 = v321 <= 3;
              uint64_t v322 = v321 - 3;
              size_t v323 = v38 ? 0 : v322;
              if (v320 - "Max" >= 1
                && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v316 + 96))(v316, "Max", v320 - "Max") != v320 - "Max")
              {
                goto LABEL_511;
              }
              if ((uint64_t)v323 >= 1)
              {
                if (v323 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                if (v323 >= 0x17)
                {
                  uint64_t v325 = (v323 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v323 | 7) != 0x17) {
                    uint64_t v325 = v323 | 7;
                  }
                  uint64_t v326 = v325 + 1;
                  v324 = (std::locale::__imp *)operator new(v325 + 1);
                  __b[1].__locale_ = (std::locale::__imp *)v323;
                  __b[2].__locale_ = (std::locale::__imp *)(v326 | 0x8000000000000000);
                  __b[0].__locale_ = v324;
                }
                else
                {
                  HIBYTE(__b[2].__locale_) = v323;
                  v324 = (std::locale::__imp *)__b;
                }
                memset(v324, v318, v323);
                *((unsigned char *)v324 + v323) = 0;
                if (SHIBYTE(__b[2].__locale_) >= 0) {
                  v327 = __b;
                }
                else {
                  v327 = __b[0].__locale_;
                }
                uint64_t v328 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v316 + 96))(v316, v327, v323);
                uint64_t v329 = v328;
                if (SHIBYTE(__b[2].__locale_) < 0)
                {
                  operator delete(__b[0].__locale_);
                  if (v329 != v323) {
                    goto LABEL_511;
                  }
                }
                else if (v328 != v323)
                {
                  goto LABEL_511;
                }
              }
              uint64_t v330 = "Max" - v320 + 3;
              if (v330 < 1
                || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v316 + 96))(v316, v320, "Max" - v320 + 3) == v330)
              {
                *((void *)v315 + 3) = 0;
                double v230 = v382;
              }
              else
              {
LABEL_511:
                double v230 = v382;
                std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
              }
            }
            MEMORY[0x1A6238D00](v384);
          }
          else
          {
            std::ostream::operator<<();
          }
          *(void *)((char *)v262 + *(void *)(*a2 - 24)) = 8;
          if (*(float *)(v275 + 20) == 3.4028e38)
          {
            MEMORY[0x1A6238CF0](v384, a2);
            if (LOBYTE(v384[0].__locale_))
            {
              v331 = (char *)a2 + *(void *)(*a2 - 24);
              uint64_t v332 = *((void *)v331 + 5);
              int v333 = *((_DWORD *)v331 + 2);
              int v334 = *((_DWORD *)v331 + 36);
              if (v334 == -1)
              {
                std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
                v335 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
                int v334 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v335->__vftable[2].~facet_0)(v335, 32);
                std::locale::~locale(__b);
                *((_DWORD *)v331 + 36) = v334;
              }
              if ((v333 & 0xB0) == 0x20) {
                v336 = "";
              }
              else {
                v336 = "Max";
              }
              if (!v332) {
                goto LABEL_544;
              }
              uint64_t v337 = *((void *)v331 + 3);
              BOOL v38 = v337 <= 3;
              uint64_t v338 = v337 - 3;
              size_t v339 = v38 ? 0 : v338;
              if (v336 - "Max" >= 1
                && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v332 + 96))(v332, "Max", v336 - "Max") != v336 - "Max")
              {
                goto LABEL_544;
              }
              if ((uint64_t)v339 >= 1)
              {
                if (v339 > 0x7FFFFFFFFFFFFFF7) {
                  abort();
                }
                if (v339 >= 0x17)
                {
                  uint64_t v341 = (v339 & 0xFFFFFFFFFFFFFFF8) + 8;
                  if ((v339 | 7) != 0x17) {
                    uint64_t v341 = v339 | 7;
                  }
                  uint64_t v342 = v341 + 1;
                  v340 = (std::locale::__imp *)operator new(v341 + 1);
                  __b[1].__locale_ = (std::locale::__imp *)v339;
                  __b[2].__locale_ = (std::locale::__imp *)(v342 | 0x8000000000000000);
                  __b[0].__locale_ = v340;
                }
                else
                {
                  HIBYTE(__b[2].__locale_) = v339;
                  v340 = (std::locale::__imp *)__b;
                }
                memset(v340, v334, v339);
                *((unsigned char *)v340 + v339) = 0;
                if (SHIBYTE(__b[2].__locale_) >= 0) {
                  v343 = __b;
                }
                else {
                  v343 = __b[0].__locale_;
                }
                uint64_t v344 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v332 + 96))(v332, v343, v339);
                uint64_t v345 = v344;
                if (SHIBYTE(__b[2].__locale_) < 0)
                {
                  operator delete(__b[0].__locale_);
                  if (v345 != v339) {
                    goto LABEL_544;
                  }
                }
                else if (v344 != v339)
                {
                  goto LABEL_544;
                }
              }
              uint64_t v346 = "Max" - v336 + 3;
              if (v346 < 1
                || (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v332 + 96))(v332, v336, "Max" - v336 + 3) == v346)
              {
                *((void *)v331 + 3) = 0;
                double v230 = v382;
              }
              else
              {
LABEL_544:
                double v230 = v382;
                std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
              }
            }
            MEMORY[0x1A6238D00](v384);
          }
          else
          {
            std::ostream::operator<<();
          }
          MEMORY[0x1A6238CF0](v384, a2);
          if (!LOBYTE(v384[0].__locale_)) {
            goto LABEL_407;
          }
          v347 = (char *)a2 + *(void *)(*a2 - 24);
          uint64_t v348 = *((void *)v347 + 5);
          int v349 = *((_DWORD *)v347 + 2);
          int v350 = *((_DWORD *)v347 + 36);
          if (v350 == -1)
          {
            std::ios_base::getloc((const std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)));
            v351 = std::locale::use_facet(__b, MEMORY[0x1E4FBA258]);
            int v350 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v351->__vftable[2].~facet_0)(v351, 32);
            std::locale::~locale(__b);
            *((_DWORD *)v347 + 36) = v350;
          }
          if ((v349 & 0xB0) == 0x20) {
            v352 = "";
          }
          else {
            v352 = "\n";
          }
          if (!v348) {
            goto LABEL_406;
          }
          uint64_t v353 = *((void *)v347 + 3);
          BOOL v38 = v353 <= 1;
          uint64_t v354 = v353 - 1;
          size_t v355 = v38 ? 0 : v354;
          if (v352 - "\n" >= 1
            && (*(uint64_t (**)(uint64_t, const char *, int64_t))(*(void *)v348 + 96))(v348, "\n", v352 - "\n") != v352 - "\n")
          {
            goto LABEL_406;
          }
          if ((uint64_t)v355 < 1) {
            goto LABEL_572;
          }
          if (v355 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          if (v355 >= 0x17)
          {
            uint64_t v357 = (v355 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v355 | 7) != 0x17) {
              uint64_t v357 = v355 | 7;
            }
            uint64_t v358 = v357 + 1;
            v356 = (std::locale::__imp *)operator new(v357 + 1);
            __b[1].__locale_ = (std::locale::__imp *)v355;
            __b[2].__locale_ = (std::locale::__imp *)(v358 | 0x8000000000000000);
            __b[0].__locale_ = v356;
          }
          else
          {
            HIBYTE(__b[2].__locale_) = v355;
            v356 = (std::locale::__imp *)__b;
          }
          memset(v356, v350, v355);
          *((unsigned char *)v356 + v355) = 0;
          if (SHIBYTE(__b[2].__locale_) >= 0) {
            v359 = __b;
          }
          else {
            v359 = __b[0].__locale_;
          }
          uint64_t v360 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v348 + 96))(v348, v359, v355);
          uint64_t v361 = v360;
          if (SHIBYTE(__b[2].__locale_) < 0)
          {
            operator delete(__b[0].__locale_);
            if (v361 != v355) {
              goto LABEL_406;
            }
LABEL_572:
            uint64_t v362 = "\n" - v352 + 1;
            if (v362 >= 1
              && (*(uint64_t (**)(uint64_t, char *, int64_t))(*(void *)v348 + 96))(v348, v352, "\n" - v352 + 1) != v362)
            {
              goto LABEL_406;
            }
            *((void *)v347 + 3) = 0;
            double v230 = v382;
            goto LABEL_407;
          }
          if (v360 == v355) {
            goto LABEL_572;
          }
LABEL_406:
          double v230 = v382;
          std::ios_base::clear((std::ios_base *)((char *)a2 + *(void *)(*a2 - 24)), *(_DWORD *)((char *)a2 + *(void *)(*a2 - 24) + 32) | 5);
LABEL_407:
          MEMORY[0x1A6238D00](v384);
          v275 += 72;
          uint64_t v274 = v380;
          goto LABEL_408;
        }
      }
      else
      {
        if (v288 >= *(void *)&v281) {
          v288 %= *(void *)&v281;
        }
        if (v288 != v284) {
          goto LABEL_480;
        }
      }
      v286 = (uint64_t **)*v286;
      if (!v286) {
        goto LABEL_480;
      }
    }
  }
}

void sub_1A1F8B500(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,char a30)
{
  _Unwind_Resume(a1);
}

void sub_1A1F8B5E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1F8B610()
{
  std::locale::~locale((std::locale *)(v0 - 144));
  JUMPOUT(0x1A1F8B628);
}

void sub_1A1F8B620(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30)
{
  if (a28 < 0) {
    operator delete(__p);
  }
  JUMPOUT(0x1A1F8B86CLL);
}

void sub_1A1F8B638(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::locale a23)
{
}

void sub_1A1F8B648(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::locale a23)
{
}

void sub_1A1F8B690()
{
}

void sub_1A1F8B698()
{
  JUMPOUT(0x1A1F8B6A0);
}

void sub_1A1F8B6D8(_Unwind_Exception *a1)
{
  MEMORY[0x1A6238D00](v1 - 144);
  _Unwind_Resume(a1);
}

void sub_1A1F8B6E4(_Unwind_Exception *a1)
{
  MEMORY[0x1A6238D00](v3 - 144);

  _Unwind_Resume(a1);
}

void sub_1A1F8B6F4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,std::locale a23)
{
}

void sub_1A1F8B704()
{
}

void sub_1A1F8B72C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1F8B748()
{
  MEMORY[0x1A6238D00](v0 - 144);
  JUMPOUT(0x1A1F8B86CLL);
}

void sub_1A1F8B778()
{
}

void sub_1A1F8B780()
{
}

void sub_1A1F8B794()
{
}

void sub_1A1F8B7A4()
{
  JUMPOUT(0x1A1F8B86CLL);
}

void sub_1A1F8B7BC()
{
  if (*(char *)(v0 - 121) < 0) {
    operator delete(*(void **)(v0 - 144));
  }
  JUMPOUT(0x1A1F8B7F4);
}

void sub_1A1F8B7D4()
{
  std::locale::~locale((std::locale *)(v0 - 144));
  JUMPOUT(0x1A1F8B7F4);
}

void sub_1A1F8B7E8()
{
}

void sub_1A1F8B7F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  MEMORY[0x1A6238D00](va);
  JUMPOUT(0x1A1F8B86CLL);
}

void sub_1A1F8B808()
{
  if (*(char *)(v0 - 121) < 0) {
    operator delete(*(void **)(v0 - 144));
  }
  JUMPOUT(0x1A1F8B8D0);
}

void sub_1A1F8B838()
{
  if (*(char *)(v0 - 121) < 0) {
    operator delete(*(void **)(v0 - 144));
  }
  JUMPOUT(0x1A1F8B8E4);
}

void sub_1A1F8B868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

void sub_1A1F8B878()
{
  std::locale::~locale((std::locale *)(v0 - 144));
  JUMPOUT(0x1A1F8B8F4);
}

void sub_1A1F8B890()
{
  std::locale::~locale((std::locale *)(v0 - 144));
  JUMPOUT(0x1A1F8B8E4);
}

void sub_1A1F8B8A0()
{
  std::locale::~locale((std::locale *)(v0 - 144));
  JUMPOUT(0x1A1F8B8D0);
}

void sub_1A1F8B8CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  MEMORY[0x1A6238D00](va);
  JUMPOUT(0x1A1F8B914);
}

void sub_1A1F8B8F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  MEMORY[0x1A6238D00](va);

  JUMPOUT(0x1A1F8B914);
}

char *md::LabelNavEtaLabeler::routeLabelStatesForRouteInfo(md::LabelNavEtaLabeler *this, VKRouteInfo *a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = [(VKRouteInfo *)v3 route];
  unint64_t v5 = (void *)*((void *)this + 58);
  if (!v5) {
    goto LABEL_12;
  }
  id v6 = (char *)this + 464;
  unint64_t v7 = (char *)this + 464;
  do
  {
    unint64_t v8 = v5[4];
    BOOL v9 = v8 >= (unint64_t)v4;
    if (v8 >= (unint64_t)v4) {
      uint64_t v10 = v5;
    }
    else {
      uint64_t v10 = v5 + 1;
    }
    if (v9) {
      unint64_t v7 = (char *)v5;
    }
    unint64_t v5 = (void *)*v10;
  }
  while (*v10);
  if (v7 != v6 && (unint64_t)v4 >= *((void *)v7 + 4))
  {

    size_t v11 = v7 + 40;
  }
  else
  {
LABEL_12:

    size_t v11 = 0;
  }

  return v11;
}

void sub_1A1F8BA1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t md::LabelNavEtaLabeler::findClosestCoordinateBetweenVertices(uint64_t a1, float64x2_t *a2, void *a3, PolylineCoordinate a4, PolylineCoordinate a5, float a6)
{
  PolylineCoordinate v7 = a4;
  PolylineCoordinate v73 = a5;
  PolylineCoordinate v74 = a4;
  id v10 = a3;
  size_t v11 = v10;
  if (a6 == 0.0)
  {
    float offset = v7.offset;
    unsigned int index = v7.index;
  }
  else
  {
    BOOL v15 = (const GEOComposedRoute *)v10;
    double v69 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v15, &v74);
    double v70 = v16;
    double v71 = v17;
    float64x2_t v65 = *a2;
    float64x2_t v66 = a2[2];
    float64x2_t v67 = a2[4];
    float64x2_t v68 = a2[6];
    double v18 = a2[1].f64[1];
    double v19 = a2[3].f64[1];
    double v20 = a2[5].f64[1];
    double v21 = a2[7].f64[1];
    double v62 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v15, &v73);
    double v63 = v22;
    double v64 = v23;
    double v24 = a2[1].f64[1];
    double v25 = a2[3].f64[1];
    double v26 = a2[7].f64[1];
    double v27 = a2[5].f64[1];
    float64x2_t v58 = *a2;
    float64x2_t v59 = a2[2];
    float64x2_t v60 = a2[4];
    float64x2_t v61 = a2[6];

    PolylineCoordinate v75 = v7;
    double v28 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v15, &v75);
    float32x2_t v29 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v68, v65, v69), v66, v70), v67, v71), 1.0 / (v21 + v18 * v69 + v19 * v70 + v20 * v71)));
    float32x2_t v30 = vmla_n_f32(v29, vsub_f32(vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v61, v58, v62), v59, v63), v60, v64), 1.0 / (v26 + v24 * v62 + v25 * v63 + v27 * v64))), v29), a6);
    unsigned int v31 = v7.index + 1;
    float32x2_t v34 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(a2[6], *a2, v28), a2[2], v32), a2[4], v33), 1.0 / (a2[7].f64[1] + a2[1].f64[1] * v28 + a2[3].f64[1] * v32 + a2[5].f64[1] * v33)));
    if (v7.index + 1 <= a5.index)
    {
      unsigned int index = 0;
      float offset = -1.0;
      float v35 = 3.4028e38;
      do
      {
        float32x2_t v46 = v34;
        v75.unsigned int index = v31;
        v75.float offset = 0.0;
        double v47 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v15, &v75);
        float32x2_t v34 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(a2[6], *a2, v47), a2[2], v48), a2[4], v49), 1.0 / (a2[7].f64[1] + a2[1].f64[1] * v47 + a2[3].f64[1] * v48 + a2[5].f64[1] * v49)));
        float32x2_t v50 = vsub_f32(v34, v46);
        float32x2_t v51 = vmul_f32(v50, v50);
        float v52 = 0.0;
        if (vaddv_f32(v51) > 1.0e-15)
        {
          float32x2_t v53 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v51, 1), v51);
          float32x2_t v54 = vmul_f32(v50, vsub_f32(v30, v46));
          float v52 = fminf(fmaxf(vdiv_f32(vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v54, 1), v54), v53).f32[0], 0.0), 1.0);
        }
        float32x2_t v55 = vsub_f32(v30, vmla_n_f32(v46, v50, v52));
        float v56 = vaddv_f32(vmul_f32(v55, v55));
        if (v56 < v35)
        {
          float v57 = (float)(v7.offset + (float)v7.index)
              + (float)(v52 * (float)((float)v31 - (float)(v7.offset + (float)v7.index)));
          unsigned int index = vcvtms_u32_f32(v57);
          float offset = v57 - floorf(v57);
          if (offset >= 1.0)
          {
            index += vcvtms_u32_f32(offset);
            float offset = offset - floorf(offset);
          }
          float v35 = v56;
        }
        PolylineCoordinate v7 = (PolylineCoordinate)v31++;
      }
      while (v31 <= a5.index);
    }
    else
    {
      unsigned int index = 0;
      float offset = -1.0;
      float v35 = 3.4028e38;
    }
    if (a5.offset != 0.0)
    {
      PolylineCoordinate v75 = a5;
      double v36 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v15, &v75);
      float32x2_t v39 = vsub_f32(vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(a2[6], *a2, v36), a2[2], v37), a2[4], v38), 1.0 / (a2[7].f64[1] + a2[1].f64[1] * v36 + a2[3].f64[1] * v37 + a2[5].f64[1] * v38))), v34);
      float32x2_t v40 = vmul_f32(v39, v39);
      float v41 = 0.0;
      if (vaddv_f32(v40) > 1.0e-15)
      {
        float32x2_t v42 = vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v40, 1), v40);
        float32x2_t v43 = vmul_f32(v39, vsub_f32(v30, v34));
        float v41 = fminf(fmaxf(vdiv_f32(vadd_f32((float32x2_t)vdup_lane_s32((int32x2_t)v43, 1), v43), v42).f32[0], 0.0), 1.0);
      }
      float32x2_t v44 = vsub_f32(v30, vmla_n_f32(v34, v39, v41));
      if (vaddv_f32(vmul_f32(v44, v44)) < v35)
      {
        float v45 = (float)(v7.offset + (float)v7.index)
            + (float)((float)((float)((float)a5.index - (float)(v7.offset + (float)v7.index)) + a5.offset) * v41);
        unsigned int index = vcvtms_u32_f32(v45);
        float offset = v45 - floorf(v45);
        if (offset >= 1.0)
        {
          index += vcvtms_u32_f32(offset);
          float offset = offset - floorf(offset);
        }
      }
    }
  }

  return index | ((unint64_t)LODWORD(offset) << 32);
}

void sub_1A1F8BEAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *md::LabelNavEtaLabeler::featuresForRoute(md::LabelNavEtaLabeler *this, VKRouteInfo *a2)
{
  uint64_t v3 = a2;
  uint64_t v4 = [(VKRouteInfo *)v3 route];
  unint64_t v5 = (void *)*((void *)this + 33);
  if (!v5) {
    goto LABEL_12;
  }
  id v6 = (char *)this + 264;
  PolylineCoordinate v7 = (char *)this + 264;
  do
  {
    unint64_t v8 = v5[4];
    BOOL v9 = v8 >= (unint64_t)v4;
    if (v8 >= (unint64_t)v4) {
      id v10 = v5;
    }
    else {
      id v10 = v5 + 1;
    }
    if (v9) {
      PolylineCoordinate v7 = (char *)v5;
    }
    unint64_t v5 = (void *)*v10;
  }
  while (*v10);
  if (v7 != v6 && (unint64_t)v4 >= *((void *)v7 + 4))
  {

    size_t v11 = v7 + 40;
  }
  else
  {
LABEL_12:

    size_t v11 = 0;
  }

  return v11;
}

void sub_1A1F8BF60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType const&>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    BOOL v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      id v10 = (void *)*v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            id v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          id v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  float v13 = operator new(0x18uLL);
  *float v13 = 0;
  v13[1] = v5;
  v13[2] = a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v23 = *(void *)a1;
  double v24 = *(void **)(*(void *)a1 + 8 * v5);
  if (v24)
  {
    *float v13 = *v24;
LABEL_58:
    void *v24 = v13;
    goto LABEL_59;
  }
  *float v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  *(void *)(v23 + 8 * v5) = a1 + 16;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    double v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A1F8C230(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType>(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    BOOL v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      id v10 = (void *)*v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            id v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          id v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  float v13 = operator new(0x18uLL);
  *float v13 = 0;
  v13[1] = v5;
  v13[2] = a3;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
  }
  else
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_35;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_35:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v5) {
        v5 %= v7;
      }
    }
    else
    {
      v5 &= v7 - 1;
    }
  }
  uint64_t v23 = *(void *)a1;
  double v24 = *(void **)(*(void *)a1 + 8 * v5);
  if (v24)
  {
    *float v13 = *v24;
LABEL_58:
    void *v24 = v13;
    goto LABEL_59;
  }
  *float v13 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v13;
  *(void *)(v23 + 8 * v5) = a1 + 16;
  if (*v13)
  {
    unint64_t v25 = *(void *)(*v13 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    double v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
}

void sub_1A1F8C504(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::LabelNavEtaLabeler::updateLabelPositions(uint64_t a1, void *a2, long long **a3)
{
  uint64_t v629 = *MEMORY[0x1E4F143B8];
  id v5 = *(id *)(a1 + 24);
  v572 = [v5 routeInfo];

  v614 = 0;
  int v6 = geo::_retain_ptr<VKRouteContext * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(*(void **)(a1 + 24), &v614);
  if (v572) {
    int v7 = v6;
  }
  else {
    int v7 = 1;
  }
  if (v7 == 1)
  {
    md::LabelNavEtaLabeler::clearEtaFeatures((md::LabelNavEtaLabeler *)a1);
    goto LABEL_22;
  }
  uint8x8_t v8 = (uint64_t *)(a1 + 576);
  BOOL v9 = (uint64_t *)(a1 + 608);
  uint64_t v10 = a1 + 584;
  uint64_t v11 = *(void *)(a1 + 584);
  long long v12 = *(_OWORD *)(a1 + 608);
  *(void *)(a1 + 608) = *(void *)(a1 + 576);
  *(void *)(a1 + 616) = v11;
  *(_OWORD *)(a1 + 576) = v12;
  uint64_t v13 = *(void *)(a1 + 632);
  uint64_t v14 = *(void *)(a1 + 600);
  *(void *)(a1 + 632) = v14;
  *(void *)(a1 + 600) = v13;
  float v15 = (void *)(v11 + 16);
  if (!v14) {
    float v15 = (void *)(a1 + 608);
  }
  void *v15 = a1 + 616;
  if (v13) {
    BOOL v16 = (uint64_t *)(*(void *)(a1 + 584) + 16);
  }
  else {
    BOOL v16 = (uint64_t *)(a1 + 576);
  }
  uint64_t *v16 = v10;
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy(a1 + 576, *(void *)(a1 + 584));
  *(void *)(a1 + 600) = 0;
  *(void *)(a1 + 576) = v10;
  *(void *)(a1 + 584) = 0;
  v569 = (id **)(a1 + 672);
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy(a1 + 672, *(void *)(a1 + 680));
  *(void *)(a1 + 696) = 0;
  v571 = (id **)(a1 + 680);
  *(void *)(a1 + 672) = a1 + 680;
  *(void *)(a1 + 680) = 0;
  unint64_t v17 = (id **)(a1 + 640);
  std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::destroy(a1 + 640, *(void *)(a1 + 648));
  *(void *)(a1 + 664) = 0;
  v581 = (id **)(a1 + 648);
  *(void *)(a1 + 640) = a1 + 648;
  v590 = (md::LabelNavEtaLabeler *)a1;
  *(void *)(a1 + 648) = 0;
  unint64_t v18 = +[VKDebugSettings sharedSettings];
  if ([v18 forceEtaLabelPlacement])
  {

LABEL_14:
    unint64_t v20 = +[VKDebugSettings sharedSettings];
    [v20 setForceEtaLabelPlacement:0];

    *(unsigned char *)(a1 + 449) = 0;
    int v580 = 1;
    goto LABEL_15;
  }
  int v19 = *(unsigned __int8 *)(a1 + 449);

  if (v19) {
    goto LABEL_14;
  }
  int v580 = 0;
LABEL_15:
  id v21 = v572;
  uint64_t v22 = v21;
  uint64_t v23 = *(void **)(a1 + 424);
  if (!v23)
  {
LABEL_21:

    unint64_t v25 = [v22 route];
    md::LabelNavEtaLabeler::extinguishLabels((md::LabelNavEtaLabeler *)a1, v25);

    goto LABEL_22;
  }
  while (1)
  {
    unint64_t v24 = v23[4];
    if (v24 <= (unint64_t)v21) {
      break;
    }
LABEL_17:
    uint64_t v23 = (void *)*v23;
    if (!v23) {
      goto LABEL_21;
    }
  }
  if (v24 < (unint64_t)v21)
  {
    ++v23;
    goto LABEL_17;
  }

  if ((long long **)(a1 + 216) != a3) {
    std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>>::__assign_with_size[abi:nn180100]<md::AvoidanceRectWithPriority*,md::AvoidanceRectWithPriority*>(a1 + 216, *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a3[1] - (char *)*a3) >> 3));
  }
  *(float *)(a1 + 248) = 0.01 / *(float *)(a2[1] + 176);
  uint64_t v27 = a2[3];
  double v26 = (float32x2_t *)a2[4];
  float32x2_t v28 = vdiv_f32((float32x2_t)0x4000000040000000, *(float32x2_t *)(v27 + 1064));
  __asm { FMOV            V2.2S, #-1.0 }
  double v32 = *(double *)&v26[17];
  float64x2_t v33 = vcvtq_f64_f32(vmla_f32(_D2, v26[4], v28));
  float64x2_t v34 = vcvtq_f64_f32(vmla_f32(_D2, v26[5], v28));
  *(float64x2_t *)v627 = v33;
  *(float64x2_t *)&v627[16] = v34;
  geo::Frustum<double>::Frustum(v613, (double *)(v27 + 736), (double *)v627, v32);
  id v568 = v22;
  *(_OWORD *)v610 = 0u;
  *(_OWORD *)std::string __p = 0u;
  int v612 = 1065353216;
  if (!*(unsigned char *)(a1 + 704))
  {
    std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType const&>((uint64_t)v610, 1uLL, 1);
    std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType const&>((uint64_t)v610, 2uLL, 2);
  }
  v584 = (float *)(a1 + 424);
  std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType>((uint64_t)v610, 4uLL, 4);

  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy(a1 + 488, *(void *)(a1 + 496));
  *(void *)(a1 + 512) = 0;
  v586 = (uint64_t **)(a1 + 496);
  *(void *)(a1 + 488) = a1 + 496;
  *(void *)(a1 + 496) = 0;
  std::__tree<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::__map_value_compare<GEOComposedRoute * {__strong},std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,std::less<GEOComposedRoute * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRoute * {__strong},std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>>,mdm::Allocator>>::destroy(a1 + 520, *(void *)(a1 + 528));
  *(void *)(a1 + 544) = 0;
  v570 = (void *)(a1 + 528);
  *(void *)(a1 + 520) = a1 + 528;
  *(void *)(a1 + 528) = 0;
  v625[0] = &unk_1EF573A58;
  v625[1] = v610;
  v626 = v625;
  md::LabelNavEtaLabeler::extractAndSortAnnotations(a1, v568, v625);
  v577 = (void *)(a1 + 520);
  if (v626 == v625)
  {
    (*(void (**)(void *))(v625[0] + 32))(v625);
  }
  else if (v626)
  {
    (*(void (**)(void))(*v626 + 40))();
  }
  long long v608 = 0u;
  long long v609 = 0u;
  long long v606 = 0u;
  long long v607 = 0u;
  id v35 = *(id *)(a1 + 24);
  double v36 = [v35 alternateRoutes];

  uint64_t v594 = a1 + 616;
  uint64_t v37 = [v36 countByEnumeratingWithState:&v606 objects:v624 count:16];
  if (v37)
  {
    uint64_t v38 = *(void *)v607;
    do
    {
      for (uint64_t i = 0; i != v37; ++i)
      {
        if (*(void *)v607 != v38) {
          objc_enumerationMutation(v36);
        }
        float32x2_t v40 = *(void **)(*((void *)&v606 + 1) + 8 * i);
        memset(v627, 0, sizeof(v627));
        LODWORD(v628) = 1065353216;
        std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType const&>((uint64_t)v627, 1uLL, 1);
        std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType const&>((uint64_t)v627, 2uLL, 2);
        std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType const&>((uint64_t)v627, 3uLL, 3);
        std::__hash_table<VKRouteEtaType,std::hash<VKRouteEtaType>,std::equal_to<VKRouteEtaType>,std::allocator<VKRouteEtaType>>::__emplace_unique_key_args<VKRouteEtaType,VKRouteEtaType>((uint64_t)v627, 4uLL, 4);
        v622[0] = &unk_1EF573AA0;
        v622[1] = v627;
        v623 = v622;
        md::LabelNavEtaLabeler::extractAndSortAnnotations((uint64_t)v590, v40, v622);
        if (v623 == v622)
        {
          (*(void (**)(void *))(v622[0] + 32))(v622);
          float v41 = *(void **)&v627[16];
          if (!*(void *)&v627[16]) {
            goto LABEL_43;
          }
          do
          {
LABEL_42:
            float32x2_t v42 = (void *)*v41;
            operator delete(v41);
            float v41 = v42;
          }
          while (v42);
          goto LABEL_43;
        }
        if (v623) {
          (*(void (**)(void))(*v623 + 40))();
        }
        float v41 = *(void **)&v627[16];
        if (*(void *)&v627[16]) {
          goto LABEL_42;
        }
LABEL_43:
        float32x2_t v43 = *(void **)v627;
        *(void *)v627 = 0;
        if (v43) {
          operator delete(v43);
        }
      }
      uint64_t v37 = [v36 countByEnumeratingWithState:&v606 objects:v624 count:16];
    }
    while (v37);
  }

  uint64_t v44 = *v9;
  float v45 = *v569;
  uint64_t v618 = *v8;
  uint64_t v617 = v10;
  uint64_t v616 = v44;
  uint64_t v615 = v594;
  *(void *)&buf[0] = v569;
  *((void *)&buf[0] + 1) = v45;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::insert_iterator<std::set<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>> &>((uint64_t)v627, (uint64_t)&v618, &v617, (uint64_t)&v616, &v615, (uint64_t *)buf);
  uint64_t v46 = *v8;
  double v47 = *v17;
  uint64_t v618 = *v9;
  uint64_t v617 = v594;
  uint64_t v616 = v46;
  uint64_t v615 = v10;
  *(void *)&buf[0] = v17;
  *((void *)&buf[0] + 1) = v47;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::insert_iterator<std::set<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>> &>((uint64_t)v627, (uint64_t)&v618, &v617, (uint64_t)&v616, &v615, (uint64_t *)buf);
  double v48 = *v17;
  double v49 = v590;
  if (*v17 != (id *)v581)
  {
    float32x2_t v50 = (uint64_t *)((char *)v590 + 464);
    float32x2_t v51 = (uint64_t *)((char *)v590 + 264);
    while (1)
    {
      id v52 = v48[4];
      float32x2_t v53 = (void *)*v50;
      if (!*v50) {
        goto LABEL_62;
      }
      float32x2_t v54 = v50;
      do
      {
        unint64_t v55 = v53[4];
        _CF = v55 >= (unint64_t)v52;
        if (v55 >= (unint64_t)v52) {
          float v57 = v53;
        }
        else {
          float v57 = v53 + 1;
        }
        if (_CF) {
          float32x2_t v54 = v53;
        }
        float32x2_t v53 = (void *)*v57;
      }
      while (*v57);
      if (v54 == v50 || (unint64_t)v52 < v54[4]) {
LABEL_62:
      }
        float32x2_t v54 = v50;

      id v58 = v48[4];
      float64x2_t v59 = (void *)*v51;
      if (!*v51) {
        goto LABEL_74;
      }
      float64x2_t v60 = v51;
      do
      {
        unint64_t v61 = v59[4];
        BOOL v62 = v61 >= (unint64_t)v58;
        if (v61 >= (unint64_t)v58) {
          double v63 = v59;
        }
        else {
          double v63 = v59 + 1;
        }
        if (v62) {
          float64x2_t v60 = v59;
        }
        float64x2_t v59 = (void *)*v63;
      }
      while (*v63);
      if (v60 == v51 || (unint64_t)v58 < v60[4]) {
LABEL_74:
      }
        float64x2_t v60 = v51;

      double v64 = v590;
      float64x2_t v65 = v48 + 4;
      if (v54 == (uint64_t *)((char *)v590 + 464)) {
        goto LABEL_129;
      }
      uint64_t v66 = v54[5];
      if (v66 == v54[6]) {
        goto LABEL_122;
      }
      while (1)
      {
        char v67 = md::RouteRangeAnnotationRequest::operator==(v48 + 4, v66);
        uint64_t v68 = v54[6];
        if (v67) {
          break;
        }
        v66 += 384;
        if (v66 == v68) {
          goto LABEL_128;
        }
      }
      if (v66 == v68)
      {
LABEL_122:
        uint64_t v68 = v66;
        goto LABEL_128;
      }
      uint64_t v69 = v66 + 384;
      if (v66 + 384 != v68) {
        break;
      }
      if (v68 != v66)
      {
LABEL_124:
        uint64_t v99 = v68 - 384;
        do
        {
          md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)(v99 + 48));
          std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v99 + 16, *(void *)(v99 + 24));

          _ZF = v99 == v66;
          v99 -= 384;
        }
        while (!_ZF);
      }
LABEL_127:
      v54[6] = v66;
      uint64_t v68 = v66;
      double v64 = v590;
      float64x2_t v65 = v48 + 4;
LABEL_128:
      if (v54[5] == v68)
      {
        uint64_t v103 = (uint64_t *)v54[1];
        int v104 = v54;
        if (v103)
        {
          do
          {
            int v105 = v103;
            uint64_t v103 = (uint64_t *)*v103;
          }
          while (v103);
        }
        else
        {
          do
          {
            int v105 = (uint64_t *)v104[2];
            _ZF = *v105 == (void)v104;
            int v104 = v105;
          }
          while (!_ZF);
        }
        if (*((uint64_t **)v64 + 57) == v54) {
          *((void *)v64 + 57) = v105;
        }
        --*((void *)v64 + 60);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v64 + 58), v54);
        std::__destroy_at[abi:nn180100]<std::pair<GEOComposedRoute * const {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,geo::linear_map::RouteLabelState,std::equal_to<md>,std::allocator<std::pair<md,md::RouteRangeAnnotationRequest>>,std::vector<std::allocator,std::pair<md,md::RouteRangeAnnotationRequest>>>>,0>((uint64_t)(v54 + 4));
        (*(void (**)(void, uint64_t *, uint64_t))(**((void **)v64 + 59) + 40))(*((void *)v64 + 59), v54, 64);
        if (v60 == v51) {
          goto LABEL_165;
        }
LABEL_130:
        uint64_t v100 = v60[5];
        if (v100 == v60[6]) {
          goto LABEL_151;
        }
        while (1)
        {
          char v101 = md::RouteRangeAnnotationRequest::operator==(v65, v100);
          uint64_t v102 = v60[6];
          if (v101) {
            break;
          }
          v100 += 72;
          if (v100 == v102) {
            goto LABEL_156;
          }
        }
        if (v100 == v102)
        {
LABEL_151:
          uint64_t v102 = v100;
          goto LABEL_156;
        }
        if (v100 + 72 == v102)
        {
          uint64_t v114 = v100;
          if (v102 == v100)
          {
LABEL_155:
            v60[6] = v114;
            uint64_t v102 = v114;
            double v64 = v590;
            float64x2_t v65 = v48 + 4;
LABEL_156:
            if (v60[5] == v102)
            {
              uint64_t v118 = (uint64_t *)v60[1];
              uint64_t v119 = v60;
              if (v118)
              {
                do
                {
                  uint64_t v120 = v118;
                  uint64_t v118 = (uint64_t *)*v118;
                }
                while (v118);
              }
              else
              {
                do
                {
                  uint64_t v120 = (uint64_t *)v119[2];
                  _ZF = *v120 == (void)v119;
                  uint64_t v119 = v120;
                }
                while (!_ZF);
              }
              if (*((uint64_t **)v64 + 32) == v60) {
                *((void *)v64 + 32) = v120;
              }
              --*((void *)v64 + 35);
              std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v64 + 33), v60);
              std::__destroy_at[abi:nn180100]<std::pair<GEOComposedRoute * const {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,GEOComposedRoute * const {__strong}::_retain_ptr<VKLabelNavRouteEta * {__strong},GEOComposedRoute * const {__strong}::_retain_objc_arc,GEOComposedRoute * const {__strong}::_release_objc_arc,GEOComposedRoute * const {__strong}::_hash_objc,GEOComposedRoute * const {__strong}::_equal_objc>,std::equal_to<md>,std::allocator<std::pair<md,GEOComposedRoute * const {__strong}::_equal_objc>>,std::vector<std::allocator,std::pair<md,GEOComposedRoute * const {__strong}::_equal_objc>>>>,0>((uint64_t)(v60 + 4));
              (*(void (**)(void, uint64_t *, uint64_t))(**((void **)v64 + 34) + 40))(*((void *)v64 + 34), v60, 64);
            }
            goto LABEL_165;
          }
        }
        else
        {
          do
          {
            uint64_t v106 = *(void *)(v100 + 72);
            *(void *)(v100 + 72) = 0;
            uint64_t v107 = *(void **)v100;
            *(void *)uint64_t v100 = v106;

            uint64_t v108 = *(void *)(v100 + 80);
            *(void *)(v100 + 80) = 0;
            uint64_t v109 = *(void **)(v100 + 8);
            *(void *)(v100 + 8) = v108;

            uint64_t v110 = v100 + 24;
            std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v100 + 16, *(void *)(v100 + 24));
            uint64_t v111 = *(void *)(v100 + 96);
            *(void *)(v100 + 16) = *(void *)(v100 + 88);
            *(void *)(v100 + 24) = v111;
            uint64_t v112 = *(void *)(v100 + 112);
            *(void *)(v100 + 40) = v112;
            if (v112)
            {
              *(void *)(v111 + 16) = v110;
              *(void *)(v100 + 88) = v100 + 96;
              *(void *)(v100 + 96) = 0;
              *(void *)(v100 + 112) = 0;
            }
            else
            {
              *(void *)(v100 + 16) = v110;
            }
            objc_storeStrong((id *)(v100 + 56), *(id *)(v100 + 128));
            uint64_t v113 = *(void **)(v100 + 128);
            *(void *)(v100 + 128) = 0;

            uint64_t v114 = v100 + 72;
            uint64_t v115 = v100 + 144;
            v100 += 72;
          }
          while (v115 != v102);
          uint64_t v102 = v60[6];
          if (v102 == v114) {
            goto LABEL_155;
          }
        }
        uint64_t v116 = v102 - 24;
        do
        {
          *(void *)(v102 - 24) = &unk_1EF559818;

          std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v102 - 56, *(void *)(v102 - 48));
          int v117 = *(void **)(v102 - 72);
          v102 -= 72;

          v116 -= 72;
        }
        while (v102 != v114);
        goto LABEL_155;
      }
LABEL_129:
      if (v60 != v51) {
        goto LABEL_130;
      }
LABEL_165:
      if (GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken, &__block_literal_global_6571);
      }
      uint64_t v121 = (id)GEOGetVectorKitLabelNavEtaLabelerLog(void)::log;
      if (os_log_type_enabled(v121, OS_LOG_TYPE_INFO))
      {
        md::RouteRangeAnnotationRequest::to_string((md::RouteRangeAnnotationRequest *)v627, v65);
        size_t v122 = v627;
        if ((v627[23] & 0x80u) != 0) {
          size_t v122 = *(uint8_t **)v627;
        }
        LODWORD(buf[0]) = 136315138;
        *(void *)((char *)buf + 4) = v122;
        _os_log_impl(&dword_1A1780000, v121, OS_LOG_TYPE_INFO, "RouteRangeAnnotationRequest dropped - %s", (uint8_t *)buf, 0xCu);
        if ((char)v627[23] < 0) {
          operator delete(*(void **)v627);
        }
      }

      int v123 = (id *)v48[1];
      if (v123)
      {
        do
        {
          uint64_t v124 = (id **)v123;
          int v123 = (id *)*v123;
        }
        while (v123);
      }
      else
      {
        do
        {
          uint64_t v124 = (id **)v48[2];
          _ZF = *v124 == v48;
          double v48 = (id *)v124;
        }
        while (!_ZF);
      }
      double v48 = (id *)v124;
      float32x2_t v50 = (uint64_t *)((char *)v590 + 464);
      double v49 = v590;
      if (v124 == v581) {
        goto LABEL_178;
      }
    }
    while (1)
    {
      uint64_t v71 = *(void *)v69;
      *(void *)uint64_t v69 = 0;
      uint8x8_t v72 = *(void **)v66;
      *(void *)uint64_t v66 = v71;

      uint64_t v73 = *(void *)(v69 + 8);
      *(void *)(v69 + 8) = 0;
      PolylineCoordinate v74 = *(void **)(v66 + 8);
      *(void *)(v66 + 8) = v73;

      uint64_t v75 = v66 + 24;
      std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v66 + 16, *(void *)(v66 + 24));
      *(void *)(v66 + 16) = *(void *)(v69 + 16);
      uint64_t v76 = *(void *)(v69 + 24);
      *(void *)(v66 + 24) = v76;
      uint64_t v77 = *(void *)(v69 + 40);
      *(void *)(v66 + 40) = v77;
      if (v77)
      {
        *(void *)(v76 + 16) = v75;
        *(void *)(v69 + 16) = v69 + 24;
        *(void *)(v69 + 24) = 0;
        *(void *)(v69 + 40) = 0;
        if (*(void *)(v66 + 72)) {
          goto LABEL_91;
        }
      }
      else
      {
        *(void *)(v66 + 16) = v75;
        if (*(void *)(v66 + 72))
        {
LABEL_91:
          uint64_t v78 = *(void **)(v66 + 64);
          if (v78)
          {
            do
            {
              uint64_t v79 = (void *)*v78;
              operator delete(v78);
              uint64_t v78 = v79;
            }
            while (v79);
          }
          *(void *)(v66 + 64) = 0;
          uint64_t v80 = *(void *)(v66 + 56);
          if (v80)
          {
            for (uint64_t j = 0; j != v80; ++j)
              *(void *)(*(void *)(v66 + 48) + 8 * j) = 0;
          }
          *(void *)(v66 + 72) = 0;
        }
      }
      uint64_t v82 = *(void *)(v69 + 48);
      *(void *)(v69 + 48) = 0;
      uint64_t v83 = *(void **)(v66 + 48);
      *(void *)(v66 + 48) = v82;
      if (v83) {
        operator delete(v83);
      }
      uint64_t v84 = *(void *)(v69 + 64);
      unint64_t v85 = *(void *)(v69 + 56);
      *(void *)(v66 + 64) = v84;
      *(void *)(v66 + 56) = v85;
      *(void *)(v69 + 56) = 0;
      uint64_t v86 = *(void *)(v69 + 72);
      *(void *)(v66 + 72) = v86;
      *(_DWORD *)(v66 + 80) = *(_DWORD *)(v69 + 80);
      if (v86)
      {
        unint64_t v87 = *(void *)(v84 + 8);
        if ((v85 & (v85 - 1)) != 0)
        {
          if (v87 >= v85) {
            v87 %= v85;
          }
        }
        else
        {
          v87 &= v85 - 1;
        }
        *(void *)(*(void *)(v66 + 48) + 8 * v87) = v66 + 64;
        *(void *)(v69 + 64) = 0;
        *(void *)(v69 + 72) = 0;
      }
      int v88 = (uint64_t *)(v66 + 96);
      uint64_t v89 = *(void *)(v66 + 96);
      *(unsigned char *)(v66 + 88) = *(unsigned char *)(v69 + 88);
      if (v89)
      {
        uint64_t v90 = *(void *)(v66 + 104);
        uint64_t v91 = v89;
        if (v90 != v89)
        {
          do
          {
            uint64_t v92 = *(std::__shared_weak_count **)(v90 - 8);
            if (v92 && !atomic_fetch_add(&v92->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *, uint64_t))v92->__on_zero_shared)(v92, v91);
              std::__shared_weak_count::__release_weak(v92);
            }
            v90 -= 16;
          }
          while (v90 != v89);
          uint64_t v91 = *v88;
        }
        *(void *)(v66 + 104) = v89;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v66 + 120) + 40))(*(void *)(v66 + 120), v91, *(void *)(v66 + 112) - v91);
        uint64_t *v88 = 0;
        *(void *)(v66 + 104) = 0;
        *(void *)(v66 + 112) = 0;
      }
      *(_OWORD *)(v66 + 96) = *(_OWORD *)(v69 + 96);
      *(void *)(v66 + 112) = *(void *)(v69 + 112);
      *(void *)(v69 + 104) = 0;
      *(void *)(v69 + 112) = 0;
      *(void *)(v69 + 96) = 0;
      *(unsigned char *)(v66 + 136) = *(unsigned char *)(v69 + 136);
      *(void *)(v66 + 128) = *(void *)(v69 + 128);
      *(_DWORD *)(v66 + 140) = *(_DWORD *)(v69 + 140);
      *(_DWORD *)(v66 + 144) = *(_DWORD *)(v69 + 144);
      *(_DWORD *)(v66 + 148) = *(_DWORD *)(v69 + 148);
      *(_DWORD *)(v66 + 152) = *(_DWORD *)(v69 + 152);
      *(_OWORD *)(v66 + 172) = *(_OWORD *)(v69 + 172);
      *(_OWORD *)(v66 + 188) = *(_OWORD *)(v69 + 188);
      *(_DWORD *)(v66 + 204) = *(_DWORD *)(v69 + 204);
      *(_OWORD *)(v66 + 156) = *(_OWORD *)(v69 + 156);
      *(unsigned char *)(v66 + 216) = *(unsigned char *)(v69 + 216);
      *(void *)(v66 + 208) = *(void *)(v69 + 208);
      *(void *)(v66 + 224) = *(void *)(v69 + 224);
      *(void *)(v66 + 232) = *(void *)(v69 + 232);
      *(void *)(v66 + 240) = *(void *)(v69 + 240);
      *(void *)(v66 + 248) = *(void *)(v69 + 248);
      *(void *)(v66 + 256) = *(void *)(v69 + 256);
      *(void *)(v66 + 264) = *(void *)(v69 + 264);
      *(void *)(v66 + 272) = *(void *)(v69 + 272);
      *(void *)(v66 + 280) = *(void *)(v69 + 280);
      *(void *)(v66 + 288) = *(void *)(v69 + 288);
      *(void *)(v66 + 296) = *(void *)(v69 + 296);
      *(void *)(v66 + 304) = *(void *)(v69 + 304);
      *(void *)(v66 + 312) = *(void *)(v69 + 312);
      *(void *)(v66 + 320) = *(void *)(v69 + 320);
      *(void *)(v66 + 328) = *(void *)(v69 + 328);
      *(void *)(v66 + 336) = *(void *)(v69 + 336);
      *(void *)(v66 + 344) = *(void *)(v69 + 344);
      uint64_t v93 = *(void *)(v66 + 352);
      if (v93)
      {
        uint64_t v94 = (uint64_t *)(v66 + 352);
        uint64_t v95 = *(void *)(v66 + 360);
        uint64_t v70 = *(void *)(v66 + 352);
        if (v95 != v93)
        {
          do
          {
            uint64_t v96 = *(void **)(v95 - 24);
            if (v96)
            {
              do
              {
                uint64_t v97 = (void *)*v96;
                operator delete(v96);
                uint64_t v96 = v97;
              }
              while (v97);
            }
            uint64_t v98 = *(void **)(v95 - 40);
            *(void *)(v95 - 40) = 0;
            if (v98) {
              operator delete(v98);
            }
            v95 -= 72;
          }
          while (v95 != v93);
          uint64_t v70 = *v94;
        }
        *(void *)(v66 + 360) = v93;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v66 + 376) + 40))(*(void *)(v66 + 376), v70, *(void *)(v66 + 368) - v70);
        *uint64_t v94 = 0;
        *(void *)(v66 + 360) = 0;
        *(void *)(v66 + 368) = 0;
      }
      *(_OWORD *)(v66 + 352) = *(_OWORD *)(v69 + 352);
      *(void *)(v66 + 368) = *(void *)(v69 + 368);
      *(void *)(v69 + 352) = 0;
      *(void *)(v69 + 360) = 0;
      *(void *)(v69 + 368) = 0;
      v69 += 384;
      v66 += 384;
      float32x2_t v51 = (uint64_t *)((char *)v590 + 264);
      if (v69 == v68)
      {
        uint64_t v68 = v54[6];
        if (v68 != v66) {
          goto LABEL_124;
        }
        goto LABEL_127;
      }
    }
  }
LABEL_178:
  uint64_t v125 = (void *)*v577;
  if ((void *)*v577 != v570)
  {
    v573 = (void *)((char *)v49 + 392);
    while (1)
    {
      uint64_t v126 = v125[5];
      v574 = v125;
      uint64_t v579 = v125[6];
      if (v126 != v579) {
        break;
      }
LABEL_478:
      int v318 = v574;
      v319 = (void *)v574[1];
      if (v319)
      {
        do
        {
          v320 = v319;
          v319 = (void *)*v319;
        }
        while (v319);
      }
      else
      {
        do
        {
          v320 = (void *)v318[2];
          _ZF = *v320 == (void)v318;
          int v318 = v320;
        }
        while (!_ZF);
      }
      uint64_t v125 = v320;
      if (v320 == v570) {
        goto LABEL_484;
      }
    }
    uint64_t v127 = 0;
    char v582 = 0;
    while (1)
    {
      v587 = (void **)(v126 + 16);
      std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v126 + 16, *(void *)(v126 + 24));
      *(void *)(v126 + 40) = 0;
      *(void *)(v126 + 16) = v126 + 24;
      *(void *)(v126 + 24) = 0;
      v595 = (uint64_t *)(v126 + 24);
      uint64_t v128 = [*(id *)(v126 + 8) etaDescription];
      uint64_t v129 = [v128 routeEtaType];

      uint64_t v591 = v126;
      if (!v129)
      {
        id v136 = (id)v574[4];
        {
          if (v317)
          {
            qword_1E957ECE8 = 0;
            qword_1E957ECF0 = mdm::Allocator::instance(v317);
            unk_1E957ECF8 = 0;
            md::LabelNavEtaLabeler::annotatableSectionsForRoute(GEOComposedRoute *)const::empty = (uint64_t)&qword_1E957ECE8;
            __cxa_atexit((void (*)(void *))std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::~map[abi:nn180100], &md::LabelNavEtaLabeler::annotatableSectionsForRoute(GEOComposedRoute *)const::empty, &dword_1A1780000);
          }
        }
        int v137 = (void *)*v573;
        if (!*v573) {
          goto LABEL_206;
        }
        uint64_t v138 = v573;
        do
        {
          unint64_t v139 = v137[4];
          BOOL v140 = v139 >= (unint64_t)v136;
          if (v139 >= (unint64_t)v136) {
            size_t v141 = v137;
          }
          else {
            size_t v141 = v137 + 1;
          }
          if (v140) {
            uint64_t v138 = v137;
          }
          int v137 = (void *)*v141;
        }
        while (*v141);
        if (v138 == v573)
        {
LABEL_206:
          uint64_t v144 = &md::LabelNavEtaLabeler::annotatableSectionsForRoute(GEOComposedRoute *)const::empty;
        }
        else
        {
          unint64_t v142 = v138[4];
          uint64_t v143 = v138 + 5;
          if (v142 <= (unint64_t)v136) {
            uint64_t v144 = v143;
          }
          else {
            uint64_t v144 = &md::LabelNavEtaLabeler::annotatableSectionsForRoute(GEOComposedRoute *)const::empty;
          }
        }

        uint64_t v147 = *v144;
        uint64_t v146 = v144 + 1;
        uint64_t v145 = (void *)v147;
        if ((uint64_t *)v147 == v146) {
          goto LABEL_297;
        }
        while (2)
        {
          uint64_t v148 = v145[5];
          uint64_t v149 = v145[6];
          if (v148 != v149)
          {
            uint64_t v150 = v149 - v148;
            if (v149 - v148 < 0) {
              abort();
            }
            unsigned int v151 = *((_DWORD *)v145 + 8);
            uint64_t v152 = v145[8];
            uint64_t v153 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v152 + 16))(v152, v149 - v148, 4);
            uint64_t v154 = (_OWORD *)v153;
            uint64_t v155 = 0;
            do
            {
              if (v153 + v155) {
                *(_OWORD *)(v153 + v155) = *(_OWORD *)(v148 + v155);
              }
              v155 += 16;
            }
            while (v148 + v155 != v149);
            size_t v156 = v595;
            while (1)
            {
              uint64_t v157 = *v156;
              uint64_t v158 = v156;
              if (!*v156) {
                break;
              }
              while (1)
              {
                size_t v156 = (uint64_t *)v157;
                unsigned int v159 = *(_DWORD *)(v157 + 32);
                if (v159 > v151) {
                  break;
                }
                if (v159 >= v151)
                {
                  uint64_t v160 = (uint64_t)v156;
                  goto LABEL_255;
                }
                uint64_t v157 = v156[1];
                if (!v157)
                {
                  uint64_t v158 = v156 + 1;
                  goto LABEL_222;
                }
              }
            }
LABEL_222:
            uint64_t v160 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v591 + 32) + 16))(*(void *)(v591 + 32), 72, 8);
            *(_DWORD *)(v160 + 32) = v151;
            *(void *)(v160 + 48) = 0;
            *(void *)(v160 + 56) = 0;
            *(void *)(v160 + 40) = 0;
            {
              operator new();
            }
            *(void *)(v160 + 64) = mdm::Allocator::instance(void)::alloc;
            *(void *)uint64_t v160 = 0;
            *(void *)(v160 + 8) = 0;
            *(void *)(v160 + 16) = v156;
            *uint64_t v158 = v160;
            uint64_t v161 = (void *)**v587;
            uint64_t v162 = v160;
            if (v161)
            {
              *v587 = v161;
              uint64_t v162 = *v158;
            }
            uint64_t v163 = *v595;
            _ZF = v162 == *v595;
            *(unsigned char *)(v162 + 24) = _ZF;
            if (!_ZF)
            {
              do
              {
                id v164 = *(uint64_t **)(v162 + 16);
                if (*((unsigned char *)v164 + 24)) {
                  break;
                }
                uint64_t v165 = v164[2];
                int64_t v166 = *(uint64_t **)v165;
                if (*(uint64_t **)v165 == v164)
                {
                  uint64_t v169 = *(void *)(v165 + 8);
                  if (!v169 || (int v170 = *(unsigned __int8 *)(v169 + 24), v167 = (unsigned char *)(v169 + 24), v170))
                  {
                    if (*v164 == v162)
                    {
                      char v171 = *(uint64_t ***)(v162 + 16);
                    }
                    else
                    {
                      char v171 = (uint64_t **)v164[1];
                      unint64_t v172 = *v171;
                      v164[1] = (uint64_t)*v171;
                      if (v172)
                      {
                        v172[2] = (uint64_t)v164;
                        uint64_t v165 = v164[2];
                      }
                      v171[2] = (uint64_t *)v165;
                      *(void *)(v164[2] + 8 * (*(void *)v164[2] != (void)v164)) = v171;
                      *char v171 = v164;
                      v164[2] = (uint64_t)v171;
                      uint64_t v165 = (uint64_t)v171[2];
                      id v164 = *(uint64_t **)v165;
                    }
                    *((unsigned char *)v171 + 24) = 1;
                    *(unsigned char *)(v165 + 24) = 0;
                    uint64_t v175 = v164[1];
                    *(void *)uint64_t v165 = v175;
                    if (v175) {
                      *(void *)(v175 + 16) = v165;
                    }
                    v164[2] = *(void *)(v165 + 16);
                    *(void *)(*(void *)(v165 + 16) + 8 * (**(void **)(v165 + 16) != v165)) = v164;
                    v164[1] = v165;
                    goto LABEL_253;
                  }
                }
                else if (!v166 || (int v168 = *((unsigned __int8 *)v166 + 24), v167 = v166 + 3, v168))
                {
                  if (*v164 == v162)
                  {
                    uint64_t v173 = *(void *)(v162 + 8);
                    *id v164 = v173;
                    if (v173)
                    {
                      *(void *)(v173 + 16) = v164;
                      uint64_t v165 = v164[2];
                    }
                    *(void *)(v162 + 16) = v165;
                    *(void *)(v164[2] + 8 * (*(void *)v164[2] != (void)v164)) = v162;
                    *(void *)(v162 + 8) = v164;
                    v164[2] = v162;
                    uint64_t v165 = *(void *)(v162 + 16);
                  }
                  else
                  {
                    uint64_t v162 = *(void *)(v162 + 16);
                  }
                  *(unsigned char *)(v162 + 24) = 1;
                  *(unsigned char *)(v165 + 24) = 0;
                  id v164 = *(uint64_t **)(v165 + 8);
                  uint64_t v174 = *v164;
                  *(void *)(v165 + 8) = *v164;
                  if (v174) {
                    *(void *)(v174 + 16) = v165;
                  }
                  v164[2] = *(void *)(v165 + 16);
                  *(void *)(*(void *)(v165 + 16) + 8 * (**(void **)(v165 + 16) != v165)) = v164;
                  *id v164 = v165;
LABEL_253:
                  *(void *)(v165 + 16) = v164;
                  break;
                }
                *((unsigned char *)v164 + 24) = 1;
                uint64_t v162 = v165;
                *(unsigned char *)(v165 + 24) = v165 == v163;
                *long long v167 = 1;
              }
              while (v165 != v163);
            }
            ++*(void *)(v591 + 40);
LABEL_255:
            size_t v176 = v155;
            unint64_t v177 = v155 >> 4;
            uint64_t v178 = *(char **)(v160 + 40);
            uint64_t v179 = *(void *)(v160 + 56);
            if (v177 > (v179 - (uint64_t)v178) >> 4)
            {
              if (v178)
              {
                *(void *)(v160 + 48) = v178;
                (*(void (**)(void, char *))(**(void **)(v160 + 64) + 40))(*(void *)(v160 + 64), v178);
                uint64_t v179 = 0;
                *(void *)(v160 + 40) = 0;
                *(void *)(v160 + 48) = 0;
                *(void *)(v160 + 56) = 0;
              }
              if ((v176 & 0x8000000000000000) != 0) {
                goto LABEL_862;
              }
              uint64_t v180 = v179 >> 3;
              if (v179 >> 3 <= v177) {
                uint64_t v180 = v177;
              }
              unint64_t v181 = (unint64_t)v179 >= 0x7FFFFFFFFFFFFFF0 ? 0xFFFFFFFFFFFFFFFLL : v180;
              if (v181 >> 60) {
LABEL_862:
              }
                abort();
              uint64_t v182 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v160 + 64) + 16))(*(void *)(v160 + 64), 16 * v181, 4);
              uint64_t v178 = (char *)v182;
              *(void *)(v160 + 48) = v182;
              uint64_t v183 = v160 + 48;
              *(void *)(v183 - 8) = v182;
              *(void *)(v183 + 8) = v182 + 16 * v181;
              uint64_t v184 = (char *)v182;
              if (v176)
              {
                uint64_t v185 = 16 * v177;
                int v186 = v154;
                uint64_t v184 = (char *)v182;
                do
                {
                  if (v184) {
                    *(_OWORD *)uint64_t v184 = *v186;
                  }
                  ++v186;
                  v184 += 16;
                  v185 -= 16;
                }
                while (v185);
              }
              goto LABEL_274;
            }
            unint64_t v188 = *(char **)(v160 + 48);
            uint64_t v183 = v160 + 48;
            uint64_t v187 = v188;
            size_t v189 = v188 - v178;
            unint64_t v190 = (v188 - v178) >> 4;
            if (v190 >= v177)
            {
              if (v176) {
                memmove(v178, v154, v176);
              }
            }
            else
            {
              if (v187 != v178)
              {
                memmove(v178, v154, v189);
                uint64_t v178 = *(char **)v183;
              }
              uint64_t v184 = v178;
              if (v190 != v177)
              {
                uint64_t v193 = &v154[v190];
                uint64_t v184 = v178;
                uint64_t v194 = 16 * v177 - 16 * v190;
                do
                {
                  if (v184) {
                    *(_OWORD *)uint64_t v184 = *v193;
                  }
                  ++v193;
                  v184 += 16;
                  v194 -= 16;
                }
                while (v194);
              }
LABEL_274:
              size_t v176 = v184 - v178;
            }
            *(void *)uint64_t v183 = &v178[v176];
            if (v154) {
              (*(void (**)(uint64_t, _OWORD *, uint64_t))(*(void *)v152 + 40))(v152, v154, v150);
            }
          }
          size_t v191 = (uint64_t *)v145[1];
          if (v191)
          {
            do
            {
              unint64_t v192 = v191;
              size_t v191 = (uint64_t *)*v191;
            }
            while (v191);
          }
          else
          {
            do
            {
              unint64_t v192 = (uint64_t *)v145[2];
              _ZF = *v192 == (void)v145;
              uint64_t v145 = v192;
            }
            while (!_ZF);
          }
          uint64_t v145 = v192;
          if (v192 == v146) {
            goto LABEL_297;
          }
          continue;
        }
      }
      unint64_t v130 = [*(id *)(v126 + 8) etaDescription];
      uint64_t v131 = [v130 routeEtaType];

      if (v131 == 4 && v127)
      {
        uint64_t v132 = [*(id *)(v127 + 8) etaDescription];
        uint64_t v133 = [*(id *)(v126 + 8) etaDescription];
        uint64_t v134 = [v132 compare:v133];

        double v49 = v590;
        *(void *)v627 = [*(id *)(v127 + 8) start];
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)(a2[1] + 168) + 32) + 88))(&v618);
        *(void *)&buf[0] = [*(id *)(v126 + 8) start];
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)(a2[1] + 168) + 32) + 88))(&v617);
        if ((_BYTE)v618 && (_BYTE)v617)
        {
          int v135 = BYTE1(v618) == BYTE1(v617);
          if (!v134) {
            goto LABEL_292;
          }
        }
        else
        {
          int v135 = (v618 != 0) ^ (v617 == 0);
          if (!v134)
          {
LABEL_292:
            if (v135)
            {
              uint64_t v195 = [*(id *)(v126 + 8) start];
              uint64_t v196 = [*(id *)(v126 + 8) end];
              *(void *)v627 = v195;
              *(void *)&v627[8] = v196;
              md::RouteRangeAnnotationRequest::addAnnotatableSection((uint64_t *)v127, v627);
              goto LABEL_184;
            }
          }
        }
      }
      if (v582)
      {
        uint64_t v197 = [*(id *)(v126 + 8) etaDescription];
        uint64_t v198 = [v197 routeEtaType];

        _ZF = v198 == 4;
        double v49 = v590;
        if (_ZF)
        {
          char v582 = 1;
          goto LABEL_184;
        }
      }
      uint64_t v199 = objc_msgSend(*(id *)(v126 + 8), "start", v568);
      uint64_t v200 = [*(id *)(v126 + 8) end];
      *(void *)v627 = v199;
      *(void *)&v627[8] = v200;
      md::RouteRangeAnnotationRequest::addAnnotatableSection((uint64_t *)v126, v627);
LABEL_297:
      size_t v201 = (id *)v591;
      objc_msgSend(*(id *)(v591 + 8), "etaDescription", v568);
      v203 = uint64_t v202 = 0x555555555555555;
      uint64_t v204 = [v203 routeEtaType];

      BOOL v205 = v204 == 4;
      id v206 = *(id *)v591;
      uint64_t v207 = v206;
      uint64_t v208 = (uint64_t *)((char *)v590 + 496);
      uint64_t v209 = *v586;
      v210 = (uint64_t **)((char *)v590 + 496);
      if (*v586)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v208 = v209;
            unint64_t v211 = v209[4];
            if ((unint64_t)v206 >= v211) {
              break;
            }
            uint64_t v209 = (uint64_t *)*v208;
            v210 = (uint64_t **)v208;
            if (!*v208) {
              goto LABEL_304;
            }
          }
          if (v211 >= (unint64_t)v206) {
            break;
          }
          uint64_t v209 = (uint64_t *)v208[1];
          if (!v209)
          {
            v210 = (uint64_t **)(v208 + 1);
            goto LABEL_304;
          }
        }
        id v212 = v208;
      }
      else
      {
LABEL_304:
        id v212 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v590 + 63) + 16))(*((void *)v590 + 63), 72, 8);
        v212[4] = (uint64_t)v207;
        v212[5] = 0;
        v212[6] = 0;
        void v212[7] = 0;
        uint64_t v213 = (void **)((char *)v590 + 488);
        {
          uint64_t v213 = (void **)((char *)v590 + 488);
          if (v315) {
            operator new();
          }
        }
        v212[8] = mdm::Allocator::instance(void)::alloc;
        *id v212 = 0;
        v212[1] = 0;
        v212[2] = (uint64_t)v208;
        void *v210 = v212;
        v214 = (void *)**v213;
        uint64_t v215 = v212;
        if (v214)
        {
          *uint64_t v213 = v214;
          uint64_t v215 = *v210;
        }
        v216 = *v586;
        _ZF = v215 == *v586;
        *((unsigned char *)v215 + 24) = _ZF;
        if (!_ZF)
        {
          do
          {
            uint64_t v217 = v215[2];
            if (*(unsigned char *)(v217 + 24)) {
              break;
            }
            v218 = *(uint64_t **)(v217 + 16);
            uint64_t v219 = *v218;
            if (*v218 == v217)
            {
              uint64_t v222 = v218[1];
              if (!v222 || (int v223 = *(unsigned __int8 *)(v222 + 24), v220 = (unsigned char *)(v222 + 24), v223))
              {
                if (*(uint64_t **)v217 == v215)
                {
                  std::string v224 = (uint64_t *)v215[2];
                }
                else
                {
                  std::string v224 = *(uint64_t **)(v217 + 8);
                  uint64_t v225 = *v224;
                  *(void *)(v217 + 8) = *v224;
                  if (v225)
                  {
                    *(void *)(v225 + 16) = v217;
                    v218 = *(uint64_t **)(v217 + 16);
                  }
                  v224[2] = (uint64_t)v218;
                  *(void *)(*(void *)(v217 + 16) + 8 * (**(void **)(v217 + 16) != v217)) = v224;
                  *std::string v224 = v217;
                  *(void *)(v217 + 16) = v224;
                  v218 = (uint64_t *)v224[2];
                  uint64_t v217 = *v218;
                }
                *((unsigned char *)v224 + 24) = 1;
                *((unsigned char *)v218 + 24) = 0;
                uint64_t v228 = *(void *)(v217 + 8);
                uint64_t *v218 = v228;
                if (v228) {
                  *(void *)(v228 + 16) = v218;
                }
                *(void *)(v217 + 16) = v218[2];
                *(void *)(v218[2] + 8 * (*(void *)v218[2] != (void)v218)) = v217;
                *(void *)(v217 + 8) = v218;
                goto LABEL_335;
              }
            }
            else if (!v219 || (int v221 = *(unsigned __int8 *)(v219 + 24), v220 = (unsigned char *)(v219 + 24), v221))
            {
              if (*(uint64_t **)v217 == v215)
              {
                uint64_t v226 = v215[1];
                *(void *)uint64_t v217 = v226;
                if (v226)
                {
                  *(void *)(v226 + 16) = v217;
                  v218 = *(uint64_t **)(v217 + 16);
                }
                v215[2] = (uint64_t)v218;
                *(void *)(*(void *)(v217 + 16) + 8 * (**(void **)(v217 + 16) != v217)) = v215;
                v215[1] = v217;
                *(void *)(v217 + 16) = v215;
                v218 = (uint64_t *)v215[2];
              }
              else
              {
                uint64_t v215 = (uint64_t *)v215[2];
              }
              *((unsigned char *)v215 + 24) = 1;
              *((unsigned char *)v218 + 24) = 0;
              uint64_t v217 = v218[1];
              uint64_t v227 = *(uint64_t **)v217;
              v218[1] = *(void *)v217;
              if (v227) {
                v227[2] = (uint64_t)v218;
              }
              *(void *)(v217 + 16) = v218[2];
              *(void *)(v218[2] + 8 * (*(void *)v218[2] != (void)v218)) = v217;
              *(void *)uint64_t v217 = v218;
LABEL_335:
              v218[2] = v217;
              break;
            }
            *(unsigned char *)(v217 + 24) = 1;
            uint64_t v215 = v218;
            *((unsigned char *)v218 + 24) = v218 == v216;
            *uint64_t v220 = 1;
          }
          while (v218 != v216);
        }
        uint64_t v207 = 0;
        ++*((void *)v590 + 64);
      }
      double v230 = (void *)v212[6];
      unint64_t v229 = v212[7];
      if ((unint64_t)v230 >= v229)
      {
        uint64_t v268 = v212[5];
        unint64_t v269 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v230 - v268) >> 4);
        unint64_t v270 = v269 + 1;
        if (v269 + 1 > 0x555555555555555) {
          abort();
        }
        unint64_t v271 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v229 - v268) >> 4);
        if (2 * v271 > v270) {
          unint64_t v270 = 2 * v271;
        }
        if (v271 < 0x2AAAAAAAAAAAAAALL) {
          uint64_t v202 = v270;
        }
        v628 = v212 + 8;
        if (v202) {
          uint64_t v272 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v212[8] + 16))(v212[8], 48 * v202, 8);
        }
        else {
          uint64_t v272 = 0;
        }
        uint64_t v274 = (void *)(v272 + 48 * v269);
        *(void *)v627 = v272;
        *(void *)&v627[8] = v274;
        *(void *)&v627[16] = v274;
        *(void *)&v627[24] = v272 + 48 * v202;
        if (v272)
        {
          *uint64_t v274 = *(id *)v591;
          uint64_t v275 = (void *)(v272 + 48 * v269);
          id v276 = *(id *)(v591 + 8);
          v275[2] = 0;
          PolylineCoordinate v277 = v275 + 2;
          uint64_t v278 = *(void *)(v591 + 32);
          v275[3] = 0;
          v275 += 3;
          *(v275 - 2) = v276;
          v275[1] = v278;
          v275[2] = 0;
          *PolylineCoordinate v277 = (uint64_t)v275;
          std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>(v277, *(void **)(v591 + 16), v595);
          uint64_t v274 = *(void **)&v627[8];
          v279 = *(void **)&v627[16];
        }
        else
        {
          v279 = v274;
        }
        v273 = v279 + 6;
        uint64_t v280 = v212[5];
        uint64_t v281 = v212[6];
        if (v281 == v280)
        {
          v212[5] = (uint64_t)v274;
          v212[6] = (uint64_t)v273;
          uint64_t v289 = v212[7];
          void v212[7] = *(void *)&v627[24];
        }
        else
        {
          unint64_t v282 = 0;
          do
          {
            uint8x8_t v283 = &v274[v282 / 8];
            uint64_t v284 = v281 + v282;
            long long v285 = *(_OWORD *)(v281 + v282 - 48);
            *(void *)(v284 - 48) = 0;
            *(void *)(v284 - 40) = 0;
            *((_OWORD *)v283 - 3) = v285;
            *(v283 - 4) = *(void *)(v281 + v282 - 32);
            uint64_t v286 = (uint64_t)&v274[v282 / 8 - 3];
            *(_OWORD *)(v283 - 3) = *(_OWORD *)(v281 + v282 - 24);
            uint64_t v287 = *(void *)(v281 + v282 - 8);
            *(v283 - 1) = v287;
            if (v287)
            {
              *(void *)(*(void *)v286 + 16) = v286;
              *(void *)(v284 - 32) = v284 - 24;
              *(void *)(v284 - 24) = 0;
              *(void *)(v284 - 8) = 0;
            }
            else
            {
              *(v283 - 4) = v286;
            }
            v282 -= 48;
          }
          while (v281 + v282 != v280);
          uint64_t v281 = v212[5];
          uint64_t v288 = v212[6];
          v212[5] = (uint64_t)&v274[v282 / 8];
          v212[6] = (uint64_t)v273;
          uint64_t v289 = v212[7];
          void v212[7] = *(void *)&v627[24];
          while (v288 != v281)
          {
            std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v288 - 32, *(void *)(v288 - 24));

            uint64_t v290 = *(void **)(v288 - 48);
            v288 -= 48;
          }
        }
        if (v281) {
          (*(void (**)(void, uint64_t, uint64_t))(*(void *)*v628 + 40))(*v628, v281, v289 - v281);
        }
      }
      else
      {
        v576 = v207;
        v578 = v212;
        BOOL v575 = v204 == 4;
        if (v230)
        {
          *double v230 = *(id *)v591;
          id v231 = *(id *)(v591 + 8);
          v230[2] = 0;
          double v232 = (uint64_t **)(v230 + 2);
          uint64_t v233 = *(void *)(v591 + 32);
          v230[3] = 0;
          double v234 = v230 + 3;
          v230[1] = v231;
          v230[4] = v233;
          uint64_t v235 = v230 + 4;
          v230[5] = 0;
          v230[2] = v230 + 3;
          uint64_t v236 = *(uint64_t **)(v591 + 16);
          if (v236 != v595)
          {
            v588 = v230;
            while (1)
            {
              uint64_t v237 = *v234;
              uint64_t v238 = v234;
              if (*v232 != v234)
              {
                v239 = (uint64_t *)*v234;
                v240 = v234;
                if (v237)
                {
                  do
                  {
                    uint64_t v238 = v239;
                    v239 = (uint64_t *)v239[1];
                  }
                  while (v239);
                }
                else
                {
                  do
                  {
                    uint64_t v238 = (uint64_t *)v240[2];
                    _ZF = *v238 == (void)v240;
                    v240 = v238;
                  }
                  while (_ZF);
                }
                unsigned int v241 = *((_DWORD *)v236 + 8);
                if (*((_DWORD *)v238 + 8) >= v241) {
                  break;
                }
              }
              if (v237) {
                int v242 = v238;
              }
              else {
                int v242 = v234;
              }
              if (v237) {
                int v243 = v238 + 1;
              }
              else {
                int v243 = v234;
              }
              if (!*v243) {
                goto LABEL_363;
              }
LABEL_401:
              v266 = (uint64_t *)v236[1];
              if (v266)
              {
                do
                {
                  v267 = v266;
                  v266 = (uint64_t *)*v266;
                }
                while (v266);
              }
              else
              {
                do
                {
                  v267 = (uint64_t *)v236[2];
                  _ZF = *v267 == (void)v236;
                  uint64_t v236 = v267;
                }
                while (!_ZF);
              }
              uint64_t v236 = v267;
              if (v267 == v595) {
                goto LABEL_414;
              }
            }
            int v243 = v234;
            int v242 = v234;
            if (v237)
            {
              while (1)
              {
                while (1)
                {
                  int v242 = (uint64_t *)v237;
                  unsigned int v244 = *(_DWORD *)(v237 + 32);
                  if (v241 >= v244) {
                    break;
                  }
                  uint64_t v237 = *v242;
                  int v243 = v242;
                  if (!*v242) {
                    goto LABEL_363;
                  }
                }
                if (v244 >= v241) {
                  goto LABEL_401;
                }
                uint64_t v237 = v242[1];
                if (!v237)
                {
                  int v243 = v242 + 1;
                  break;
                }
              }
            }
LABEL_363:
            uint64_t v245 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v235 + 16))(*v235, 72, 8);
            *(void *)v627 = v245;
            *(void *)&v627[8] = v235;
            uint64_t v246 = v235;
            v627[16] = 0;
            *(_DWORD *)(v245 + 32) = *((_DWORD *)v236 + 8);
            *(void *)(v245 + 40) = 0;
            *(void *)(v245 + 48) = 0;
            uint64_t v247 = v236[8];
            *(void *)(v245 + 56) = 0;
            *(void *)(v245 + 64) = v247;
            v249 = (char *)v236[5];
            size_t v248 = (char *)v236[6];
            uint64_t v250 = v248 - v249;
            if (v248 != v249)
            {
              if (v250 < 0) {
                abort();
              }
              uint64_t v251 = (_OWORD *)(*(uint64_t (**)(uint64_t, int64_t, uint64_t))(*(void *)v247 + 16))(v247, v248 - v249, 4);
              *(void *)(v245 + 40) = v251;
              *(void *)(v245 + 48) = v251;
              *(void *)(v245 + 56) = &v251[v250 >> 4];
              do
              {
                if (v251) {
                  *uint64_t v251 = *(_OWORD *)v249;
                }
                v249 += 16;
                ++v251;
              }
              while (v249 != v248);
              *(void *)(v245 + 48) = v251;
            }
            *(void *)uint64_t v245 = 0;
            *(void *)(v245 + 8) = 0;
            *(void *)(v245 + 16) = v242;
            *int v243 = v245;
            v252 = (uint64_t *)**v232;
            if (v252)
            {
              *double v232 = v252;
              uint64_t v245 = *v243;
            }
            uint64_t v253 = *v234;
            _ZF = v245 == *v234;
            *(unsigned char *)(v245 + 24) = _ZF;
            size_t v201 = (id *)v591;
            double v230 = v588;
            uint64_t v235 = v246;
            if (!_ZF)
            {
              do
              {
                uint64_t v254 = *(uint64_t **)(v245 + 16);
                if (*((unsigned char *)v254 + 24)) {
                  break;
                }
                uint64_t v255 = v254[2];
                uint64_t v256 = *(uint64_t **)v255;
                if (*(uint64_t **)v255 == v254)
                {
                  uint64_t v259 = *(void *)(v255 + 8);
                  if (!v259 || (v260 = *(unsigned __int8 *)(v259 + 24), uint64_t v257 = (unsigned char *)(v259 + 24), v260))
                  {
                    if (*v254 == v245)
                    {
                      v261 = *(uint64_t ***)(v245 + 16);
                    }
                    else
                    {
                      v261 = (uint64_t **)v254[1];
                      v262 = *v261;
                      v254[1] = (uint64_t)*v261;
                      if (v262)
                      {
                        v262[2] = (uint64_t)v254;
                        uint64_t v255 = v254[2];
                      }
                      v261[2] = (uint64_t *)v255;
                      *(void *)(v254[2] + 8 * (*(void *)v254[2] != (void)v254)) = v261;
                      char *v261 = v254;
                      v254[2] = (uint64_t)v261;
                      uint64_t v255 = (uint64_t)v261[2];
                      uint64_t v254 = *(uint64_t **)v255;
                    }
                    *((unsigned char *)v261 + 24) = 1;
                    *(unsigned char *)(v255 + 24) = 0;
                    uint64_t v265 = v254[1];
                    *(void *)uint64_t v255 = v265;
                    if (v265) {
                      *(void *)(v265 + 16) = v255;
                    }
                    v254[2] = *(void *)(v255 + 16);
                    *(void *)(*(void *)(v255 + 16) + 8 * (**(void **)(v255 + 16) != v255)) = v254;
                    v254[1] = v255;
                    goto LABEL_399;
                  }
                }
                else if (!v256 || (v258 = *((unsigned __int8 *)v256 + 24), uint64_t v257 = v256 + 3, v258))
                {
                  if (*v254 == v245)
                  {
                    uint64_t v263 = *(void *)(v245 + 8);
                    *uint64_t v254 = v263;
                    if (v263)
                    {
                      *(void *)(v263 + 16) = v254;
                      uint64_t v255 = v254[2];
                    }
                    *(void *)(v245 + 16) = v255;
                    *(void *)(v254[2] + 8 * (*(void *)v254[2] != (void)v254)) = v245;
                    *(void *)(v245 + 8) = v254;
                    v254[2] = v245;
                    uint64_t v255 = *(void *)(v245 + 16);
                  }
                  else
                  {
                    uint64_t v245 = *(void *)(v245 + 16);
                  }
                  *(unsigned char *)(v245 + 24) = 1;
                  *(unsigned char *)(v255 + 24) = 0;
                  uint64_t v254 = *(uint64_t **)(v255 + 8);
                  uint64_t v264 = *v254;
                  *(void *)(v255 + 8) = *v254;
                  if (v264) {
                    *(void *)(v264 + 16) = v255;
                  }
                  v254[2] = *(void *)(v255 + 16);
                  *(void *)(*(void *)(v255 + 16) + 8 * (**(void **)(v255 + 16) != v255)) = v254;
                  *uint64_t v254 = v255;
LABEL_399:
                  *(void *)(v255 + 16) = v254;
                  break;
                }
                *((unsigned char *)v254 + 24) = 1;
                uint64_t v245 = v255;
                *(unsigned char *)(v255 + 24) = v255 == v253;
                *uint64_t v257 = 1;
              }
              while (v255 != v253);
            }
            ++v588[5];
            goto LABEL_401;
          }
        }
LABEL_414:
        v273 = v230 + 6;
        uint64_t v207 = v576;
        id v212 = v578;
        v578[6] = (uint64_t)(v230 + 6);
        BOOL v205 = v575;
      }
      v212[6] = (uint64_t)v273;

      id v291 = *v201;
      v292 = v291;
      uint64_t v293 = (uint64_t **)((char *)v590 + 496);
      v294 = *v586;
      v295 = (uint64_t **)((char *)v590 + 496);
      if (*v586)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v293 = (uint64_t **)v294;
            unint64_t v296 = v294[4];
            if ((unint64_t)v291 >= v296) {
              break;
            }
            v294 = *v293;
            v295 = v293;
            if (!*v293) {
              goto LABEL_438;
            }
          }
          if (v296 >= (unint64_t)v291) {
            break;
          }
          v294 = v293[1];
          if (!v294)
          {
            v295 = v293 + 1;
            goto LABEL_438;
          }
        }
        int v297 = (uint64_t *)v293;
      }
      else
      {
LABEL_438:
        int v297 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v590 + 63) + 16))(*((void *)v590 + 63), 72, 8);
        v297[4] = (uint64_t)v292;
        v297[5] = 0;
        v297[6] = 0;
        v297[7] = 0;
        int v298 = (void **)((char *)v590 + 488);
        {
          int v298 = (void **)((char *)v590 + 488);
          if (v316) {
            operator new();
          }
        }
        v297[8] = mdm::Allocator::instance(void)::alloc;
        *int v297 = 0;
        v297[1] = 0;
        v297[2] = (uint64_t)v293;
        char *v295 = v297;
        v299 = (void *)**v298;
        v300 = v297;
        if (v299)
        {
          *int v298 = v299;
          v300 = *v295;
        }
        v301 = *v586;
        _ZF = v300 == *v586;
        *((unsigned char *)v300 + 24) = _ZF;
        if (!_ZF)
        {
          do
          {
            uint64_t v302 = v300[2];
            if (*(unsigned char *)(v302 + 24)) {
              break;
            }
            uint64_t v303 = *(uint64_t **)(v302 + 16);
            uint64_t v304 = *v303;
            if (*v303 == v302)
            {
              uint64_t v307 = v303[1];
              if (!v307 || (int v308 = *(unsigned __int8 *)(v307 + 24), v305 = (unsigned char *)(v307 + 24), v308))
              {
                if (*(uint64_t **)v302 == v300)
                {
                  uint64_t v309 = (uint64_t *)v300[2];
                }
                else
                {
                  uint64_t v309 = *(uint64_t **)(v302 + 8);
                  uint64_t v310 = *v309;
                  *(void *)(v302 + 8) = *v309;
                  if (v310)
                  {
                    *(void *)(v310 + 16) = v302;
                    uint64_t v303 = *(uint64_t **)(v302 + 16);
                  }
                  v309[2] = (uint64_t)v303;
                  *(void *)(*(void *)(v302 + 16) + 8 * (**(void **)(v302 + 16) != v302)) = v309;
                  *uint64_t v309 = v302;
                  *(void *)(v302 + 16) = v309;
                  uint64_t v303 = (uint64_t *)v309[2];
                  uint64_t v302 = *v303;
                }
                *((unsigned char *)v309 + 24) = 1;
                *((unsigned char *)v303 + 24) = 0;
                uint64_t v313 = *(void *)(v302 + 8);
                *uint64_t v303 = v313;
                if (v313) {
                  *(void *)(v313 + 16) = v303;
                }
                *(void *)(v302 + 16) = v303[2];
                *(void *)(v303[2] + 8 * (*(void *)v303[2] != (void)v303)) = v302;
                *(void *)(v302 + 8) = v303;
                goto LABEL_469;
              }
            }
            else if (!v304 || (int v306 = *(unsigned __int8 *)(v304 + 24), v305 = (unsigned char *)(v304 + 24), v306))
            {
              if (*(uint64_t **)v302 == v300)
              {
                uint64_t v311 = v300[1];
                *(void *)uint64_t v302 = v311;
                if (v311)
                {
                  *(void *)(v311 + 16) = v302;
                  uint64_t v303 = *(uint64_t **)(v302 + 16);
                }
                v300[2] = (uint64_t)v303;
                *(void *)(*(void *)(v302 + 16) + 8 * (**(void **)(v302 + 16) != v302)) = v300;
                v300[1] = v302;
                *(void *)(v302 + 16) = v300;
                uint64_t v303 = (uint64_t *)v300[2];
              }
              else
              {
                v300 = (uint64_t *)v300[2];
              }
              *((unsigned char *)v300 + 24) = 1;
              *((unsigned char *)v303 + 24) = 0;
              uint64_t v302 = v303[1];
              v312 = *(uint64_t **)v302;
              v303[1] = *(void *)v302;
              if (v312) {
                v312[2] = (uint64_t)v303;
              }
              *(void *)(v302 + 16) = v303[2];
              *(void *)(v303[2] + 8 * (*(void *)v303[2] != (void)v303)) = v302;
              *(void *)uint64_t v302 = v303;
LABEL_469:
              v303[2] = v302;
              break;
            }
            *(unsigned char *)(v302 + 24) = 1;
            v300 = v303;
            *((unsigned char *)v303 + 24) = v303 == v301;
            unsigned char *v305 = 1;
          }
          while (v303 != v301);
        }
        v292 = 0;
        ++*((void *)v590 + 64);
      }
      uint64_t v314 = v297[6];

      uint64_t v126 = v591;
      v582 |= v205;
      uint64_t v127 = v314 - 48;
      double v49 = v590;
LABEL_184:
      v126 += 48;
      if (v126 == v579) {
        goto LABEL_478;
      }
    }
  }
LABEL_484:
  uint64_t v321 = *((void *)v49 + 70);
  for (uint64_t k = *((void *)v49 + 69); v321 != k; v321 -= 56)
  {
    if (*(unsigned char *)(v321 - 6)) {
      *(unsigned char *)(v321 - 6) = 0;
    }
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v321 - 40, *(void *)(v321 - 32));
  }
  size_t v323 = v590;
  *((void *)v590 + 70) = k;
  if (!*((unsigned char *)v590 + 136)) {
    goto LABEL_564;
  }
  id m = v568;
  uint64_t v325 = [m route];
  uint64_t v326 = (uint64_t)v325;
  v327 = (uint64_t **)((char *)v590 + 496);
  uint64_t v328 = *v586;
  uint64_t v329 = (uint64_t **)((char *)v590 + 496);
  if (*v586)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v329 = (uint64_t **)v328;
        unint64_t v330 = v328[4];
        if ((unint64_t)v325 >= v330) {
          break;
        }
        uint64_t v328 = *v329;
        v327 = v329;
        if (!*v329) {
          goto LABEL_496;
        }
      }
      if (v330 >= (unint64_t)v325) {
        break;
      }
      uint64_t v328 = v329[1];
      if (!v328)
      {
        v327 = v329 + 1;
        goto LABEL_496;
      }
    }

    uint64_t v332 = (uint64_t *)v329;
    size_t v323 = v590;
  }
  else
  {
LABEL_496:
    v331 = v327;
    uint64_t v332 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v590 + 63) + 16))(*((void *)v590 + 63), 72, 8);
    v332[4] = v326;
    v332[5] = 0;
    v332[6] = 0;
    v332[7] = 0;
    int v333 = (void **)((char *)v590 + 488);
    int v334 = v331;
    {
      int v334 = v331;
      int v333 = (void **)((char *)v590 + 488);
      if (v567) {
        operator new();
      }
    }
    v332[8] = mdm::Allocator::instance(void)::alloc;
    *uint64_t v332 = 0;
    v332[1] = 0;
    v332[2] = (uint64_t)v329;
    *int v334 = v332;
    v335 = (void *)**v333;
    v336 = v332;
    if (v335)
    {
      *int v333 = v335;
      v336 = *v334;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v590 + 62), v336);
    ++*((void *)v590 + 64);
  }
  if (v332[5] == v332[6]) {
    goto LABEL_563;
  }
  uint64_t v337 = *(void *)(*(void *)(a2[1] + 168) + 32);
  uint64_t v338 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)v337 + 64))(v337);
  unint64_t v339 = v332[5];
  if (v339 == v332[6]) {
    goto LABEL_563;
  }
  id v583 = m;
  v592 = v332;
  v596 = (unint64_t *)((char *)v323 + 552);
  uint64_t v340 = *(unsigned int *)v338;
  float v341 = v338[1];
  while (2)
  {
    unint64_t v344 = v339;
    uint64_t v345 = objc_msgSend(*(id *)(v339 + 8), "etaDescription", v568);
    uint64_t v346 = [v345 routeEtaType];

    uint64_t v347 = v592[6] - v339;
    if (v347)
    {
      unint64_t v348 = 0xAAAAAAAAAAAAAAABLL * (v347 >> 4);
      do
      {
        unint64_t v349 = v339 + 48 * (v348 >> 1);
        int v350 = [*(id *)(v349 + 8) etaDescription];
        uint64_t v351 = [v350 routeEtaType];

        if (v351 > v346)
        {
          v348 >>= 1;
        }
        else
        {
          unint64_t v339 = v349 + 48;
          v348 += ~(v348 >> 1);
        }
      }
      while (v348);
    }
    _ZF = (unint64_t)v346 > 4 || ((1 << v346) & 0x19) == 0;
    if (!_ZF || v339 <= v344) {
      goto LABEL_511;
    }
    char v352 = 0;
    uint64_t v353 = (uint64_t *)(v344 + 24);
    uint64_t v354 = v339;
    while (1)
    {
      uint64_t v357 = [(id)*(v353 - 2) start];
      uint64_t v358 = v353 - 3;
      if (v340 <= v357
        && (v340 == v357 ? (BOOL v359 = v341 < *((float *)&v357 + 1)) : (BOOL v359 = 1), v359)
        || (uint64_t v360 = [(id)*(v353 - 2) end], v340 >= v360)
        && (v340 == v360 ? (BOOL v361 = v341 <= *((float *)&v360 + 1)) : (BOOL v361 = 0), !v361))
      {
        uint64_t v362 = [(id)*(v353 - 2) start];
        if (v340 < v362 || v340 == v362 && v341 < *((float *)&v362 + 1))
        {
          v363 = (_WORD *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v596, (uint64_t)(v353 - 3));
          if (v352) {
            __int16 v355 = 256;
          }
          else {
            __int16 v355 = 259;
          }
          _WORD *v363 = v355;
          char v352 = 1;
          goto LABEL_522;
        }
        *(_WORD *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v596, (uint64_t)(v353 - 3)) = 258;
        goto LABEL_542;
      }
      *(_WORD *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v596, (uint64_t)(v353 - 3)) = 257;
      v364 = [(id)*(v353 - 2) etaDescription];
      uint64_t v365 = [v364 routeEtaType];

      if (v365 == 2) {
        break;
      }
LABEL_522:
      v356 = v353 + 3;
      v353 += 6;
      if (v356 == (uint64_t *)v339)
      {
        uint64_t v358 = (uint64_t *)v339;
        goto LABEL_545;
      }
    }
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(v353 - 1), *v353);
    v353[2] = 0;
    *(v353 - 1) = (uint64_t)v353;
    *uint64_t v353 = 0;
    uint64_t v366 = [(id)*(v353 - 2) end];
    *(_DWORD *)v627 = v340;
    *(float *)&v627[4] = v341;
    *(void *)&v627[8] = v366;
    md::RouteRangeAnnotationRequest::addAnnotatableSection(v353 - 3, v627);
    id v367 = *((id *)v590 + 3);
    id v368 = [v367 routeInfo];
    uint64_t v369 = [v368 route];

    objc_msgSend(v369, "distanceFromPoint:toPoint:", v340 | ((unint64_t)LODWORD(v341) << 32), objc_msgSend((id)*(v353 - 2), "end"));
    if (v370 < 200.0)
    {
      *(_WORD *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v596, (uint64_t)(v353 - 3)) = 258;

LABEL_542:
      uint64_t v354 = (uint64_t)(v353 - 3);
      goto LABEL_522;
    }

LABEL_545:
    if (v354 != v339) {
      *(_WORD *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v596, v354) = 260;
    }
    if (v358 != (uint64_t *)v339)
    {
      v371 = [(id)v358[1] etaDescription];
      BOOL v372 = [v371 routeEtaType] != 2;

      uint64_t v373 = (uint64_t)(v358 + 6);
      char v374 = v373 == v339 || v372;
      if ((v374 & 1) == 0)
      {
        do
        {
          *(_WORD *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v596, v373) = 256;
          v373 += 48;
        }
        while (v373 != v339);
      }
    }
LABEL_511:
    if (v339 != v592[6]) {
      continue;
    }
    break;
  }
  uint64_t v375 = v592[5];
  for (id m = v583; v375 != v339; v375 += 48)
  {
    *(void *)v627 = [*(id *)(v375 + 8) start];
    (*(void (**)(_OWORD *__return_ptr))(**(void **)(*(void *)(a2[1] + 168) + 32) + 88))(buf);
    unint64_t v376 = geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v596, v375);
    if (LOBYTE(buf[0]))
    {
      if (!*(unsigned char *)(v376 + 2)) {
        *(unsigned char *)(v376 + 2) = 1;
      }
      *(unsigned char *)(v376 + 3) = BYTE1(buf[0]);
    }
    else if (*(unsigned char *)(v376 + 2))
    {
      *(unsigned char *)(v376 + 2) = 0;
    }
  }
LABEL_563:

LABEL_564:
  v377 = *v569;
  if (*v569 != (id *)v571)
  {
    do
    {
      if (GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken, &__block_literal_global_6571);
      }
      v378 = (id)GEOGetVectorKitLabelNavEtaLabelerLog(void)::log;
      if (os_log_type_enabled(v378, OS_LOG_TYPE_INFO))
      {
        md::RouteRangeAnnotationRequest::to_string((md::RouteRangeAnnotationRequest *)v627, v377 + 4);
        uint64_t v379 = (v627[23] & 0x80u) == 0 ? v627 : *(uint8_t **)v627;
        LODWORD(buf[0]) = 136315138;
        *(void *)((char *)buf + 4) = v379;
        _os_log_impl(&dword_1A1780000, v378, OS_LOG_TYPE_INFO, "RouteRangeAnnotationRequest added - %s", (uint8_t *)buf, 0xCu);
        if ((char)v627[23] < 0) {
          operator delete(*(void **)v627);
        }
      }

      uint64_t v380 = (id *)v377[1];
      if (v380)
      {
        do
        {
          id v381 = (id **)v380;
          uint64_t v380 = (id *)*v380;
        }
        while (v380);
      }
      else
      {
        do
        {
          id v381 = (id **)v377[2];
          _ZF = *v381 == v377;
          v377 = (id *)v381;
        }
        while (!_ZF);
      }
      v377 = (id *)v381;
    }
    while (v381 != v571);
  }
  md::LabelNavEtaLabeler::setupRouteLabelingState((uint64_t)v590, (uint64_t)a2, (uint64_t)v613, v568, 1u, 0, v580);
  long long v604 = 0u;
  long long v605 = 0u;
  long long v602 = 0u;
  long long v603 = 0u;
  id v382 = *((id *)v590 + 3);
  v383 = [v382 alternateRoutes];

  uint64_t v384 = [v383 countByEnumeratingWithState:&v602 objects:v621 count:16];
  if (v384)
  {
    uint64_t v385 = *(void *)v603;
    do
    {
      for (uint64_t n = 0; n != v384; ++n)
      {
        if (*(void *)v603 != v385) {
          objc_enumerationMutation(v383);
        }
        md::LabelNavEtaLabeler::setupRouteLabelingState((uint64_t)v590, (uint64_t)a2, (uint64_t)v613, *(void **)(*((void *)&v602 + 1) + 8 * n), 0, objc_msgSend(*(id *)(*((void *)&v602 + 1) + 8 * n), "etaComparisionToMain", v568), v580);
      }
      uint64_t v384 = [v383 countByEnumeratingWithState:&v602 objects:v621 count:16];
    }
    while (v384);
  }

  double v387 = CACurrentMediaTime();
  id v388 = v568;
  v389 = v388;
  v390 = *(void **)v584;
  if (!*(void *)v584) {
    goto LABEL_599;
  }
  v391 = (float *)((char *)v590 + 424);
  do
  {
    unint64_t v392 = v390[4];
    BOOL v393 = v392 >= (unint64_t)v388;
    if (v392 >= (unint64_t)v388) {
      v394 = v390;
    }
    else {
      v394 = v390 + 1;
    }
    if (v393) {
      v391 = (float *)v390;
    }
    v390 = (void *)*v394;
  }
  while (*v394);
  if (v391 != v584 && *((void *)v391 + 4) <= (unint64_t)v388)
  {
    float v448 = v391[10];

    v395 = v590;
    if (v448 >= 1.0) {
      md::LabelNavEtaLabeler::updateEtaFeature((uint64_t)v590, a2, (uint64_t)v613, v389, 1u, v580, v387);
    }
  }
  else
  {
LABEL_599:

    v395 = v590;
  }
  long long v600 = 0u;
  long long v601 = 0u;
  long long v598 = 0u;
  long long v599 = 0u;
  id v396 = *((id *)v395 + 3);
  v397 = [v396 alternateRoutes];

  uint64_t v398 = [v397 countByEnumeratingWithState:&v598 objects:v620 count:16];
  if (v398)
  {
    uint64_t v399 = *(void *)v599;
    do
    {
      uint64_t v400 = 0;
      do
      {
        if (*(void *)v599 != v399) {
          objc_enumerationMutation(v397);
        }
        id v401 = *(id *)(*((void *)&v598 + 1) + 8 * v400);
        v402 = v401;
        for (iuint64_t i = (void *)((char *)v590 + 424); ; ++ii)
        {
          do
          {
            iuint64_t i = (void *)*ii;
            if (!ii)
            {

              v405 = [v402 route];
              md::LabelNavEtaLabeler::extinguishLabels(v590, v405);
LABEL_611:

              goto LABEL_612;
            }
            unint64_t v404 = ii[4];
          }
          while (v404 > (unint64_t)v401);
          if (v404 >= (unint64_t)v401) {
            break;
          }
        }

        v406 = v402;
        v405 = v406;
        v407 = (float *)((char *)v590 + 424);
        v408 = *(void **)v584;
        if (!*(void *)v584) {
          goto LABEL_611;
        }
        do
        {
          unint64_t v409 = v408[4];
          BOOL v410 = v409 >= (unint64_t)v406;
          if (v409 >= (unint64_t)v406) {
            v411 = v408;
          }
          else {
            v411 = v408 + 1;
          }
          if (v410) {
            v407 = (float *)v408;
          }
          v408 = (void *)*v411;
        }
        while (*v411);
        if (v407 == v584 || *((void *)v407 + 4) > (unint64_t)v406) {
          goto LABEL_611;
        }
        float v412 = v407[10];

        if (v412 >= 1.0) {
          md::LabelNavEtaLabeler::updateEtaFeature((uint64_t)v590, a2, (uint64_t)v613, v405, 0, v580, v387);
        }
LABEL_612:
        ++v400;
      }
      while (v400 != v398);
      uint64_t v413 = [v397 countByEnumeratingWithState:&v598 objects:v620 count:16];
      uint64_t v398 = v413;
    }
    while (v413);
  }

  v597 = (char *)v590 + 705;
  unsigned int v414 = *(unsigned __int16 *)((char *)v590 + 705);
  id v415 = v389;
  float v416 = *(float *)(a2[3] + 32);
  id v417 = v415;
  uint64_t v418 = *(void *)(*(void *)(a2[1] + 168) + 32);
  uint64_t v419 = (*(uint64_t (**)(uint64_t))(*(void *)v418 + 80))(v418);
  if (!v419) {
    goto LABEL_640;
  }
  id v420 = v417;
  v423 = *(void **)(v419 + 48);
  uint64_t v422 = v419 + 48;
  v421 = v423;
  if (!v423) {
    goto LABEL_639;
  }
  v424 = (void *)v422;
  do
  {
    unint64_t v425 = v421[4];
    BOOL v426 = v425 >= (unint64_t)v420;
    if (v425 >= (unint64_t)v420) {
      v427 = v421;
    }
    else {
      v427 = v421 + 1;
    }
    if (v426) {
      v424 = v421;
    }
    v421 = (void *)*v427;
  }
  while (*v427);
  if (v424 == (void *)v422 || v424[4] > (unint64_t)v420)
  {
LABEL_639:

    goto LABEL_640;
  }
  uint64_t v558 = *(void *)(v424[5] + 280);

  if (v416 >= *(float *)&v558) {
    BOOL v428 = v416 <= *((float *)&v558 + 1);
  }
  else {
LABEL_640:
  }
    BOOL v428 = 0;

  v429 = [v417 route];
  uint64_t v430 = [v429 legs];
  unint64_t v431 = [(id)v430 count];

  v432 = [*((id *)v590 + 3) alternateRoutes];
  LODWORD(v431) = v431 < 2;
  LOBYTE(v430) = [v432 count] != 0;

  char v433 = v431 | v430;
  if (v431) {
    LOBYTE(v434) = 4;
  }
  else {
    LOBYTE(v434) = 3;
  }
  unsigned __int8 v435 = 1;
  if ((v433 & 1) == 0)
  {
    char v436 = *((unsigned char *)v590 + 136) || v428;
    unsigned __int8 v435 = *((unsigned char *)v590 + 136) ? 2 : 1;
    LOBYTE(v434) = *((unsigned char *)v590 + 136) ? 5 : 1;
    if ((v436 & 1) == 0)
    {
      v437 = (VKRouteInfo *)v417;
      v438 = [(VKRouteInfo *)v437 route];
      v439 = (void *)*((void *)v590 + 33);
      if (!v439) {
        goto LABEL_666;
      }
      v440 = (void *)((char *)v590 + 264);
      do
      {
        unint64_t v441 = v439[4];
        BOOL v442 = v441 >= (unint64_t)v438;
        if (v441 >= (unint64_t)v438) {
          v443 = v439;
        }
        else {
          v443 = v439 + 1;
        }
        if (v442) {
          v440 = v439;
        }
        v439 = (void *)*v443;
      }
      while (*v443);
      if (v440 != (void *)((char *)v590 + 264) && (unint64_t)v438 >= v440[4])
      {

        v559 = md::LabelNavEtaLabeler::routeLabelStatesForRouteInfo(v590, v437);
        uint64_t v560 = v440[5];
        if (v560 == v440[6])
        {
          unsigned __int8 v435 = 2;
          LOBYTE(v434) = 2;
        }
        else
        {
          v561 = (uint64_t *)v559;
          LOBYTE(v434) = 2;
          while (1)
          {
            v562 = objc_msgSend(*(id *)(v560 + 8), "etaDescription", v568);
            uint64_t v563 = [v562 routeEtaType];

            if (v563 == 3 && !*(void *)(v560 + 56))
            {
              uint64_t v564 = *v561;
              if (*v561 != v561[1])
              {
                while (1)
                {
                  char v565 = md::RouteRangeAnnotationRequest::operator==((id *)v560, v564);
                  uint64_t v566 = v561[1];
                  if (v565) {
                    break;
                  }
                  v564 += 384;
                  if (v564 == v566) {
                    goto LABEL_851;
                  }
                }
                if (v564 != v566 && *(_DWORD *)(v564 + 128) != -1) {
                  break;
                }
              }
            }
LABEL_851:
            v560 += 72;
            unsigned __int8 v435 = 2;
            if (v560 == v440[6]) {
              goto LABEL_667;
            }
          }
          LOBYTE(v434) = 2;
          unsigned __int8 v435 = 1;
        }
      }
      else
      {
LABEL_666:

        unsigned int v434 = v414 >> 8;
        unsigned __int8 v435 = v414;
      }
    }
  }
LABEL_667:

  BOOL v444 = *((unsigned __int8 *)v590 + 705) == v435 && *((unsigned __int8 *)v590 + 706) == v434;
  char v445 = v444;
  char v593 = v445;
  if (!v444)
  {
    if (GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitLabelNavEtaLabelerLog(void)::onceToken, &__block_literal_global_6571);
    }
    v446 = (id)GEOGetVectorKitLabelNavEtaLabelerLog(void)::log;
    if (os_log_type_enabled(v446, OS_LOG_TYPE_INFO))
    {
      if (v435 > 2u) {
        v447 = "<Invalid>";
      }
      else {
        v447 = off_1E5A8E9F0[v435];
      }
      unint64_t v449 = *v597;
      if (v449 > 2) {
        v450 = "<Invalid>";
      }
      else {
        v450 = off_1E5A8E9F0[v449];
      }
      *(_DWORD *)v627 = 136315394;
      *(void *)&v627[4] = v447;
      *(_WORD *)&v627[12] = 2080;
      *(void *)&v627[14] = v450;
      _os_log_impl(&dword_1A1780000, v446, OS_LOG_TYPE_INFO, "EtaLabelingState changed - Mode:%s from:%s", v627, 0x16u);
    }

    *((unsigned char *)v590 + 705) = v435;
    *((unsigned char *)v590 + 706) = v434;
  }
  if (v435)
  {
    uint64_t v451 = *((void *)v590 + 37) - *((void *)v590 + 36);
    if (v451)
    {
      uint64_t v452 = 0;
      unint64_t v453 = v451 >> 3;
      v589 = (uint64_t **)((char *)v590 + 360);
      if (v453 <= 1) {
        uint64_t v454 = 1;
      }
      else {
        uint64_t v454 = v453;
      }
      while (1)
      {
        id v455 = *(id *)(*((void *)v590 + 36) + 8 * v452);
        id v456 = [v455 routeInfo];
        if (v456 != v417) {
          goto LABEL_693;
        }
        v468 = [v455 displayEtaDescription];
        unint64_t v469 = [v468 routeEtaType];
        if (v469 > 4 || ((1 << v469) & 0x19) == 0) {
          break;
        }

        v471 = [v455 displayEtaDescription];
        if ([v471 routeEtaType] == 3)
        {
          BOOL v472 = *v597 == 1;

          if (v472) {
            goto LABEL_733;
          }
        }
        else
        {
        }
        objc_msgSend(v455, "displayEtaDescription", v568);
        id v456 = (id)objc_claimAutoreleasedReturnValue();
        if ([v456 routeEtaType]) {
          goto LABEL_693;
        }
        BOOL v482 = *v597 == 2;

        if (v482)
        {
LABEL_733:
          if (v455)
          {
            [v455 updateRoadSignWithNavContext:a2 artworkCache:*((void *)v590 + 18)];
            if (v593) {
              goto LABEL_774;
            }
          }
          else
          {
            memset(v627, 0, 24);
            if (v593)
            {
LABEL_774:
              *(void *)v627 = off_1EF559858;

              goto LABEL_728;
            }
          }
          v489 = *v589;
          if (*v589)
          {
            v490 = (char *)v590 + 360;
            v491 = *v589;
            do
            {
              unint64_t v492 = v491[4];
              BOOL v493 = v492 >= (unint64_t)v455;
              if (v492 >= (unint64_t)v455) {
                v494 = (uint64_t **)v491;
              }
              else {
                v494 = (uint64_t **)(v491 + 1);
              }
              if (v493) {
                v490 = (char *)v491;
              }
              v491 = *v494;
            }
            while (*v494);
            if (v490 != (char *)v589 && (unint64_t)v455 >= *((void *)v490 + 4))
            {
              v495 = (char *)*((void *)v490 + 1);
              v496 = v490;
              if (v495)
              {
                do
                {
                  v497 = v495;
                  v495 = *(char **)v495;
                }
                while (v495);
              }
              else
              {
                do
                {
                  v497 = (char *)*((void *)v496 + 2);
                  _ZF = *(void *)v497 == (void)v496;
                  v496 = v497;
                }
                while (!_ZF);
              }
              if (*((char **)v590 + 44) == v490) {
                *((void *)v590 + 44) = v497;
              }
              --*((void *)v590 + 47);
              std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v489, (uint64_t *)v490);
              *((void *)v490 + 5) = off_1EF559858;

              (*(void (**)(void, char *, uint64_t))(**((void **)v590 + 46) + 40))(*((void *)v590 + 46), v490, 64);
            }
          }
          id v498 = *(id *)&v627[8];
          v499 = v498;
          if (v498)
          {
            id v500 = v498;
          }
          else
          {
            id v500 = [v455 label];
          }
          id v501 = v500;

          if (*(void *)(*(void *)[v501 label] + 160))
          {
            v502 = *(unsigned char **)[v501 label];
            v502[297] = 0;
            if (v502[296]) {
              v502[298] = 0;
            }
            id v503 = v501;
            *(void *)&buf[0] = off_1EF559858;
            *((void *)&buf[0] + 1) = v503;
            unint64_t v504 = *((void *)v590 + 20);
            if (v504 >= *((void *)v590 + 21))
            {
              uint64_t v506 = std::vector<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::__push_back_slow_path<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>((uint64_t *)v590 + 19, (uint64_t)buf);
            }
            else
            {
              if (v504)
              {
                *(void *)unint64_t v504 = off_1EF559858;
                *(void *)(v504 + 8) = 0;
                objc_storeStrong((id *)(v504 + 8), *((id *)&buf[0] + 1));
                v505 = (void *)*((void *)&buf[0] + 1);
                *((void *)&buf[0] + 1) = 0;
              }
              uint64_t v506 = v504 + 24;
            }
            *((void *)v590 + 20) = v506;
            *(void *)&buf[0] = off_1EF559858;
          }
          goto LABEL_774;
        }
LABEL_694:
        v458 = (void *)*((void *)v590 + 41);
        unint64_t v457 = *((void *)v590 + 42);
        if ((unint64_t)v458 >= v457)
        {
          uint64_t v460 = *((void *)v590 + 40);
          uint64_t v461 = ((uint64_t)v458 - v460) >> 3;
          if ((unint64_t)(v461 + 1) >> 61) {
            abort();
          }
          uint64_t v462 = v457 - v460;
          uint64_t v463 = v462 >> 2;
          if (v462 >> 2 <= (unint64_t)(v461 + 1)) {
            uint64_t v463 = v461 + 1;
          }
          if ((unint64_t)v462 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v464 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v464 = v463;
          }
          if (v464)
          {
            uint64_t v465 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v590 + 43) + 16))(*((void *)v590 + 43), 8 * v464, 8);
            v466 = (void *)(v465 + 8 * v461);
            uint64_t v467 = v465 + 8 * v464;
            if (v465) {
              void *v466 = v455;
            }
          }
          else
          {
            uint64_t v467 = 0;
            v466 = (void *)(8 * v461);
          }
          v459 = v466 + 1;
          v473 = (char *)*((void *)v590 + 40);
          v474 = (char *)*((void *)v590 + 41);
          if (v474 == v473)
          {
            *((void *)v590 + 40) = v466;
            *((void *)v590 + 41) = v459;
            uint64_t v480 = *((void *)v590 + 42);
            *((void *)v590 + 42) = v467;
          }
          else
          {
            unint64_t v475 = v474 - v473 - 8;
            if (v475 <= 0x57
              || (unint64_t v476 = (v473 - v474 + 7) & 0xFFFFFFFFFFFFFFF8, &v474[v476] < (char *)v466)
              && (char *)v466 + v476 < v474)
            {
              v477 = (char *)*((void *)v590 + 41);
              goto LABEL_720;
            }
            uint64_t v483 = (v475 >> 3) + 1;
            v477 = &v474[-8 * (v483 & 0x3FFFFFFFFFFFFFFCLL)];
            v484 = v466 - 2;
            v485 = (long long *)(v474 - 32);
            uint64_t v486 = v483 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v488 = *v485;
              long long v487 = v485[1];
              long long *v485 = 0uLL;
              v485[1] = 0uLL;
              v485 -= 2;
              *(v484 - 1) = v488;
              _OWORD *v484 = v487;
              v484 -= 2;
              v486 -= 4;
            }
            while (v486);
            v466 -= v483 & 0x3FFFFFFFFFFFFFFCLL;
            if (v483 != (v483 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_720:
                uint64_t v478 = *((void *)v477 - 1);
                v477 -= 8;
                *(void *)v477 = 0;
                *--v466 = v478;
              }
              while (v477 != v473);
            }
            v474 = (char *)*((void *)v590 + 40);
            v479 = (char *)*((void *)v590 + 41);
            *((void *)v590 + 40) = v466;
            *((void *)v590 + 41) = v459;
            uint64_t v480 = *((void *)v590 + 42);
            *((void *)v590 + 42) = v467;
            while (v479 != v474)
            {
              v481 = (void *)*((void *)v479 - 1);
              v479 -= 8;
            }
          }
          if (v474) {
            (*(void (**)(void, char *, uint64_t))(**((void **)v590 + 43) + 40))(*((void *)v590 + 43), v474, v480 - (void)v474);
          }
          goto LABEL_727;
        }
        if (v458) {
          void *v458 = v455;
        }
        v459 = v458 + 1;
LABEL_727:
        *((void *)v590 + 41) = v459;
LABEL_728:

        if (++v452 == v454) {
          goto LABEL_775;
        }
      }

      id v456 = v417;
LABEL_693:

      goto LABEL_694;
    }
LABEL_775:
    uint64_t v507 = *((void *)v590 + 41) - *((void *)v590 + 40);
    if (v507)
    {
      uint64_t v508 = 0;
      unint64_t v509 = v507 >> 3;
      v510 = (uint64_t *)((char *)v590 + 152);
      uint64_t v511 = v509 <= 1 ? 1 : v509;
      v512 = (uint64_t **)((char *)v590 + 360);
      do
      {
        id v513 = *(id *)(*((void *)v590 + 40) + 8 * v508);
        v514 = v513;
        if (v513)
        {
          [v513 updateRoadSignWithNavContext:a2 artworkCache:*((void *)v590 + 18)];
          if (*(void *)&v627[8])
          {
            id v515 = *(id *)&v627[8];
            BOOL v516 = *(unsigned char *)(*(void *)[v515 label] + 297) == 0;

            if (v516)
            {
              v527 = (void *)*((void *)v590 + 20);
              if ((unint64_t)v527 >= *((void *)v590 + 21))
              {
                uint64_t v530 = std::vector<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::__push_back_slow_path<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> const&>(v510, (uint64_t)v627);
              }
              else
              {
                if (v527)
                {
                  void *v527 = off_1EF559858;
                  v527[1] = 0;
                  id v528 = *(id *)&v627[8];
                  v529 = (void *)v527[1];
                  v527[1] = v528;
                }
                uint64_t v530 = (uint64_t)(v527 + 3);
              }
              *((void *)v590 + 20) = v530;
            }
            else if ([v514 hasLabel])
            {
              id v517 = *(id *)&v627[8];
              BOOL v518 = *(void *)(*(void *)[v517 label] + 160) == 0;

              if (!v518)
              {
                v519 = *v512;
                v520 = (uint64_t **)((char *)v590 + 360);
                v521 = (uint64_t **)((char *)v590 + 360);
                if (*v512)
                {
                  while (1)
                  {
                    while (1)
                    {
                      v521 = (uint64_t **)v519;
                      unint64_t v522 = v519[4];
                      if ((unint64_t)v514 >= v522) {
                        break;
                      }
                      v519 = *v521;
                      v520 = v521;
                      if (!*v521) {
                        goto LABEL_792;
                      }
                    }
                    if (v522 >= (unint64_t)v514) {
                      break;
                    }
                    v519 = v521[1];
                    if (!v519)
                    {
                      v520 = v521 + 1;
                      goto LABEL_792;
                    }
                  }
                }
                else
                {
LABEL_792:
                  v523 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v590 + 46) + 16))(*((void *)v590 + 46), 64, 8);
                  v523[4] = (uint64_t)v514;
                  v523[5] = (uint64_t)off_1EF559858;
                  v523[6] = 0;
                  id v524 = *(id *)&v627[8];
                  v525 = (void *)v523[6];
                  v523[6] = (uint64_t)v524;

                  uint64_t *v523 = 0;
                  v523[1] = 0;
                  v523[2] = (uint64_t)v521;
                  *v520 = v523;
                  uint64_t v526 = **((void **)v590 + 44);
                  if (v526)
                  {
                    *((void *)v590 + 44) = v526;
                    v523 = *v520;
                  }
                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v590 + 45), v523);
                  ++*((void *)v590 + 47);
                }
              }
            }
          }
        }
        else
        {
          *(void *)&v627[8] = 0;
          *(void *)&v627[16] = 0;
        }
        *(void *)v627 = off_1EF559858;

        ++v508;
      }
      while (v508 != v511);
      v531 = (id *)*((void *)v590 + 40);
      v532 = (id *)*((void *)v590 + 41);
      if (v531 != v532)
      {
        while (1)
        {
          if (objc_msgSend(*v531, "hasLabelWithAnchor", v568))
          {
            id v534 = [*v531 label];
            *(void *)v627 = off_1EF559858;
            *(void *)&v627[8] = v534;
            unint64_t v535 = *((void *)v590 + 20);
            if (v535 >= *((void *)v590 + 21))
            {
              uint64_t v537 = std::vector<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::__push_back_slow_path<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(v510, (uint64_t)v627);
            }
            else
            {
              if (v535)
              {
                *(void *)unint64_t v535 = off_1EF559858;
                *(void *)(v535 + 8) = 0;
                objc_storeStrong((id *)(v535 + 8), *(id *)&v627[8]);
                v536 = *(void **)&v627[8];
                *(void *)&v627[8] = 0;
              }
              uint64_t v537 = v535 + 24;
            }
            *((void *)v590 + 20) = v537;
            *(void *)v627 = off_1EF559858;
          }
          v538 = *v512;
          if (!*v512) {
            goto LABEL_807;
          }
          id v539 = *v531;
          v540 = (char *)v590 + 360;
          do
          {
            unint64_t v541 = v538[4];
            BOOL v542 = v541 >= (unint64_t)v539;
            if (v541 >= (unint64_t)v539) {
              v543 = (uint64_t **)v538;
            }
            else {
              v543 = (uint64_t **)(v538 + 1);
            }
            if (v542) {
              v540 = (char *)v538;
            }
            v538 = *v543;
          }
          while (*v543);
          if (v540 == (char *)v512 || (unint64_t)v539 < *((void *)v540 + 4)) {
            goto LABEL_807;
          }
          if (![v539 hasLabelWithAnchor]) {
            goto LABEL_839;
          }
          v544 = [*v531 label];
          uint64_t v545 = *(void *)(*(void *)[v544 label] + 288);
          if (!v545) {
            break;
          }
          uint64_t v546 = *(void *)(v545 + 640);
          if (!v546) {
            break;
          }
          unsigned __int8 v547 = atomic_load((unsigned __int8 *)(v546 + 143));
          BOOL v548 = (v547 & 1) == 0;

          if (v548) {
            goto LABEL_839;
          }
          v549 = (char *)*((void *)v540 + 1);
          v550 = v540;
          if (v549)
          {
            do
            {
              v551 = v549;
              v549 = *(char **)v549;
            }
            while (v549);
          }
          else
          {
            do
            {
              v551 = (char *)*((void *)v550 + 2);
              _ZF = *(void *)v551 == (void)v550;
              v550 = v551;
            }
            while (!_ZF);
          }
          if (*((char **)v590 + 44) == v540) {
            *((void *)v590 + 44) = v551;
          }
          --*((void *)v590 + 47);
          std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v590 + 45), (uint64_t *)v540);
          *((void *)v540 + 5) = off_1EF559858;

          (*(void (**)(void, char *, uint64_t))(**((void **)v590 + 46) + 40))(*((void *)v590 + 46), v540, 64);
LABEL_807:
          if (++v531 == v532) {
            goto LABEL_843;
          }
        }

LABEL_839:
        *((unsigned char *)v590 + 252) = 1;
        v552 = (void *)*((void *)v590 + 20);
        if ((unint64_t)v552 >= *((void *)v590 + 21))
        {
          uint64_t v533 = std::vector<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::__push_back_slow_path<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> const&>(v510, (uint64_t)(v540 + 40));
        }
        else
        {
          if (v552)
          {
            void *v552 = off_1EF559858;
            v552[1] = 0;
            id v553 = *((id *)v540 + 6);
            v554 = (void *)v552[1];
            v552[1] = v553;
          }
          uint64_t v533 = (uint64_t)(v552 + 3);
        }
        *((void *)v590 + 20) = v533;
        goto LABEL_807;
      }
    }
  }
LABEL_843:
  v555 = __p[0];
  if (__p[0])
  {
    do
    {
      v556 = (void *)*v555;
      operator delete(v555);
      v555 = v556;
    }
    while (v556);
  }
  v557 = v610[0];
  v610[0] = 0;
  if (v557) {
    operator delete(v557);
  }
LABEL_22:
}

void sub_1A1F901FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100]((uint64_t)&a57);
  _Unwind_Resume(a1);
}

uint64_t geo::_retain_ptr<VKRouteContext * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::operator==(void *a1, void **a2)
{
  id v3 = a1;
  uint64_t v4 = *a2;
  id v5 = v3;
  id v6 = v4;
  if (v6 == v5) {
    uint64_t v7 = 1;
  }
  else {
    uint64_t v7 = [v5 isEqual:v6];
  }

  return v7;
}

void sub_1A1F90734(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::LabelNavEtaLabeler::extinguishLabels(md::LabelNavEtaLabeler *this, GEOComposedRoute *a2)
{
  id v3 = a2;
  uint64_t v4 = (void *)*((void *)this + 33);
  if (v4)
  {
    id v5 = (uint64_t *)((char *)this + 264);
    do
    {
      unint64_t v6 = v4[4];
      BOOL v7 = v6 >= (unint64_t)v3;
      if (v6 >= (unint64_t)v3) {
        uint8x8_t v8 = v4;
      }
      else {
        uint8x8_t v8 = v4 + 1;
      }
      if (v7) {
        id v5 = v4;
      }
      uint64_t v4 = (void *)*v8;
    }
    while (*v8);
    if (v5 != (uint64_t *)((char *)this + 264) && v5[4] <= (unint64_t)v3)
    {
      float v15 = v3;
      for (uint64_t i = v5[5]; i != v5[6]; i += 72)
      {
        id v10 = *(id *)(i + 56);
        std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::__erase_unique<VKLabelNavRouteEta * {__strong}>((uint64_t)this + 352, (unint64_t)v10);
      }
      uint64_t v11 = (uint64_t *)v5[1];
      if (v11)
      {
        do
        {
          long long v12 = v11;
          uint64_t v11 = (uint64_t *)*v11;
        }
        while (v11);
      }
      else
      {
        uint64_t v13 = v5;
        do
        {
          long long v12 = (uint64_t *)v13[2];
          BOOL v14 = *v12 == (void)v13;
          uint64_t v13 = v12;
        }
        while (!v14);
      }
      if (*((uint64_t **)this + 32) == v5) {
        *((void *)this + 32) = v12;
      }
      --*((void *)this + 35);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 33), v5);
      std::__destroy_at[abi:nn180100]<std::pair<GEOComposedRoute * const {__strong},geo::linear_map<md::RouteRangeAnnotationRequest,GEOComposedRoute * const {__strong}::_retain_ptr<VKLabelNavRouteEta * {__strong},GEOComposedRoute * const {__strong}::_retain_objc_arc,GEOComposedRoute * const {__strong}::_release_objc_arc,GEOComposedRoute * const {__strong}::_hash_objc,GEOComposedRoute * const {__strong}::_equal_objc>,std::equal_to<md>,std::allocator<std::pair<md,GEOComposedRoute * const {__strong}::_equal_objc>>,std::vector<std::allocator,std::pair<md,GEOComposedRoute * const {__strong}::_equal_objc>>>>,0>((uint64_t)(v5 + 4));
      (*(void (**)(void, uint64_t *, uint64_t))(**((void **)this + 34) + 40))(*((void *)this + 34), v5, 64);
      id v3 = v15;
    }
  }
}

void sub_1A1F908B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>>::__assign_with_size[abi:nn180100]<md::AvoidanceRectWithPriority*,md::AvoidanceRectWithPriority*>(uint64_t result, long long *a2, long long *a3, unint64_t a4)
{
  uint64_t v7 = result;
  uint64_t v8 = *(void *)(result + 16);
  uint64_t v9 = *(void *)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)result) >> 3) >= a4)
  {
    unint64_t v17 = (uint64_t *)(result + 8);
    uint64_t v16 = *(void *)(result + 8);
    if (0xAAAAAAAAAAAAAAABLL * ((v16 - v9) >> 3) >= a4)
    {
      for (uint64_t i = *(void *)result; a2 != a3; a2 = (long long *)((char *)a2 + 24))
      {
        *(_DWORD *)uint64_t i = *(_DWORD *)a2;
        *(_DWORD *)(i + 4) = *((_DWORD *)a2 + 1);
        *(_DWORD *)(i + 8) = *((_DWORD *)a2 + 2);
        *(_DWORD *)(i + 12) = *((_DWORD *)a2 + 3);
        int v24 = *((_DWORD *)a2 + 4);
        *(unsigned char *)(i + 20) = *((unsigned char *)a2 + 20);
        *(_DWORD *)(i + 16) = v24;
        i += 24;
      }
      uint64_t v22 = i - v9;
    }
    else
    {
      unint64_t v18 = (long long *)((char *)a2 + 8 * ((v16 - v9) >> 3));
      if (v16 != v9)
      {
        do
        {
          *(_DWORD *)uint64_t v9 = *(_DWORD *)a2;
          *(_DWORD *)(v9 + 4) = *((_DWORD *)a2 + 1);
          *(_DWORD *)(v9 + 8) = *((_DWORD *)a2 + 2);
          *(_DWORD *)(v9 + 12) = *((_DWORD *)a2 + 3);
          int v19 = *((_DWORD *)a2 + 4);
          *(unsigned char *)(v9 + 20) = *((unsigned char *)a2 + 20);
          *(_DWORD *)(v9 + 16) = v19;
          a2 = (long long *)((char *)a2 + 24);
          v9 += 24;
        }
        while (a2 != v18);
        uint64_t v9 = *v17;
      }
      uint64_t v20 = v9;
      if (v18 != a3)
      {
        uint64_t v20 = v9;
        do
        {
          if (v20)
          {
            long long v21 = *v18;
            *(void *)(v20 + 16) = *((void *)v18 + 2);
            *(_OWORD *)uint64_t v20 = v21;
          }
          unint64_t v18 = (long long *)((char *)v18 + 24);
          v20 += 24;
        }
        while (v18 != a3);
      }
      uint64_t v22 = v20 - v9;
    }
  }
  else
  {
    if (v9)
    {
      *(void *)(result + 8) = v9;
      (*(void (**)(void))(**(void **)(result + 24) + 40))(*(void *)(result + 24));
      uint64_t v8 = 0;
      *(void *)uint64_t v7 = 0;
      *(void *)(v7 + 8) = 0;
      *(void *)(v7 + 16) = 0;
    }
    if (a4 > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_31;
    }
    unint64_t v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v11 = 2 * v10;
    if (2 * v10 <= a4) {
      uint64_t v11 = a4;
    }
    unint64_t v12 = v10 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v11;
    if (v12 > 0xAAAAAAAAAAAAAAALL) {
LABEL_31:
    }
      abort();
    uint64_t v13 = 24 * v12;
    uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v7 + 24) + 16))(*(void *)(v7 + 24), 24 * v12, 4);
    uint64_t v9 = result;
    *(void *)uint64_t v7 = result;
    *(void *)(v7 + 8) = result;
    *(void *)(v7 + 16) = result + v13;
    uint64_t v14 = result;
    if (a2 != a3)
    {
      uint64_t v14 = result;
      do
      {
        if (v14)
        {
          long long v15 = *a2;
          *(void *)(v14 + 16) = *((void *)a2 + 2);
          *(_OWORD *)uint64_t v14 = v15;
        }
        a2 = (long long *)((char *)a2 + 24);
        v14 += 24;
      }
      while (a2 != a3);
    }
    uint64_t v22 = v14 - result;
    unint64_t v17 = (uint64_t *)(v7 + 8);
  }
  uint64_t *v17 = v9 + v22;
  return result;
}

float64x2_t *geo::Frustum<double>::Frustum(float64x2_t *a1, double *a2, double *a3, double a4)
{
  double v5 = a2[1];
  double v7 = a2[4];
  double v6 = a2[5];
  double v9 = a2[8];
  double v8 = a2[9];
  double v11 = a2[12];
  double v10 = a2[13];
  double v12 = a2[2];
  double v13 = a2[3];
  double v14 = a2[6];
  double v15 = a2[7];
  double v16 = a2[10];
  double v17 = a2[11];
  double v18 = a2[14];
  double v19 = a2[15];
  double v20 = a3[1];
  double v21 = *a2 - *a3 * v13;
  double v22 = v7 - *a3 * v15;
  v23.f64[0] = v9 - *a3 * v17;
  v23.f64[1] = v11 - *a3 * v19;
  double v24 = a3[2];
  double v25 = a3[3];
  double v26 = -(*a2 - v24 * v13);
  double v27 = -(v7 - v24 * v15);
  double v28 = -(v11 - v24 * v19);
  v29.f64[0] = -(v9 - v24 * v17);
  v29.f64[1] = v28;
  double v30 = v5 - v20 * v13;
  double v31 = v6 - v20 * v15;
  v32.f64[0] = v8 - v20 * v17;
  v32.f64[1] = v10 - v20 * v19;
  double v33 = v12 - v13 * a4;
  double v34 = v14 - v15 * a4;
  v35.f64[0] = v16 - v17 * a4;
  double v36 = -(v5 - v25 * v13);
  double v37 = -(v6 - v25 * v15);
  v38.f64[0] = -(v8 - v25 * v17);
  v38.f64[1] = -(v10 - v25 * v19);
  v35.f64[1] = v18 - v19 * a4;
  double v39 = 1.0 / sqrt(v33 * v33 + v34 * v34 + v35.f64[0] * v35.f64[0]);
  double v40 = v13 - v12;
  double v41 = v15 - v14;
  v42.f64[0] = v17 - v16;
  v42.f64[1] = v19 - v18;
  a1->f64[0] = v39 * v33;
  a1->f64[1] = v39 * v34;
  a1[1] = vmulq_n_f64(v35, v39);
  double v43 = 1.0 / sqrt(v40 * v40 + v41 * v41 + v42.f64[0] * v42.f64[0]);
  a1[2].f64[0] = v43 * v40;
  a1[2].f64[1] = v43 * v41;
  a1[3] = vmulq_n_f64(v42, v43);
  double v44 = 1.0 / sqrt(v30 * v30 + v31 * v31 + v32.f64[0] * v32.f64[0]);
  a1[4].f64[0] = v44 * v30;
  a1[4].f64[1] = v44 * v31;
  a1[5] = vmulq_n_f64(v32, v44);
  double v45 = 1.0 / sqrt(v36 * v36 + v37 * v37 + v38.f64[0] * v38.f64[0]);
  a1[6].f64[0] = v45 * v36;
  a1[6].f64[1] = v45 * v37;
  a1[7] = vmulq_n_f64(v38, v45);
  double v46 = 1.0 / sqrt(v21 * v21 + v22 * v22 + v23.f64[0] * v23.f64[0]);
  a1[8].f64[0] = v46 * v21;
  a1[8].f64[1] = v46 * v22;
  a1[9] = vmulq_n_f64(v23, v46);
  double v47 = 1.0 / sqrt(v26 * v26 + v27 * v27 + v29.f64[0] * v29.f64[0]);
  a1[10].f64[0] = v47 * v26;
  a1[10].f64[1] = v47 * v27;
  a1[11] = vmulq_n_f64(v29, v47);
  geo::Frustum<double>::calculateCorners(a1->f64, a2, a4);
  return a1;
}

void md::LabelNavEtaLabeler::extractAndSortAnnotations(uint64_t a1, void *a2, void *a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  uint64_t v31 = 0;
  float64x2_t v32 = &v31;
  uint64_t v33 = 0x5012000000;
  double v34 = __Block_byref_object_copy__59;
  float64x2_t v35 = __Block_byref_object_dispose__60;
  double v36 = "";
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v37 = 0;
  {
    operator new();
  }
  uint64_t v40 = mdm::Allocator::instance(void)::alloc;
  v41[0] = MEMORY[0x1E4F143A8];
  v41[1] = 3321888768;
  v41[2] = ___ZN2md18LabelNavEtaLabeler25extractAndSortAnnotationsEP11VKRouteInfoNSt3__18functionIFbRKNS_27RouteRangeAnnotationRequestEEEE_block_invoke;
  v41[3] = &unk_1EF58EAD0;
  uint64_t v44 = a1;
  id v6 = v5;
  id v42 = v6;
  uint64_t v7 = a3[3];
  if (!v7) {
    goto LABEL_5;
  }
  if ((void *)v7 != a3)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
LABEL_5:
    double v46 = (void *)v7;
    goto LABEL_7;
  }
  double v46 = v45;
  (*(void (**)(void *, void *))(*a3 + 24))(a3, v45);
LABEL_7:
  double v43 = &v31;
  [v6 visitAnnotations:v41];
  uint64_t v8 = v32[6];
  double v9 = (long long *)v32[7];
  unint64_t v10 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * (((uint64_t)v9 - v8) >> 4));
  if (v9 == (long long *)v8) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = v10;
  }
  std::__introsort<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*,false>(v8, v9, v11, 1);
  double v12 = v32;
  unint64_t v13 = [v6 route];
  double v14 = (void *)v13;
  double v15 = *(uint64_t **)(a1 + 528);
  if (v15)
  {
    while (1)
    {
      while (1)
      {
        double v17 = (uint64_t **)v15;
        unint64_t v18 = v15[4];
        if (v13 >= v18) {
          break;
        }
        double v15 = *v17;
        double v16 = v17;
        if (!*v17) {
          goto LABEL_17;
        }
      }
      if (v18 >= v13) {
        break;
      }
      double v15 = v17[1];
      if (!v15)
      {
        double v16 = v17 + 1;
        goto LABEL_17;
      }
    }
    double v19 = (uint64_t *)v17;
  }
  else
  {
    double v16 = (uint64_t **)(a1 + 528);
    double v17 = (uint64_t **)(a1 + 528);
LABEL_17:
    double v19 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 536) + 16))(*(void *)(a1 + 536), 72, 8);
    v19[4] = (uint64_t)v14;
    v19[5] = 0;
    v19[6] = 0;
    v19[7] = 0;
    {
      operator new();
    }
    v19[8] = mdm::Allocator::instance(void)::alloc;
    *double v19 = 0;
    v19[1] = 0;
    void v19[2] = (uint64_t)v17;
    uint64_t *v16 = v19;
    uint64_t v20 = **(void **)(a1 + 520);
    double v21 = v19;
    if (v20)
    {
      *(void *)(a1 + 520) = v20;
      double v21 = *v16;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 528), v21);
    double v14 = 0;
    ++*(void *)(a1 + 544);
  }
  double v22 = v19 + 5;
  uint64_t v23 = v19[5];
  if (v23)
  {
    uint64_t v24 = v19[6];
    uint64_t v25 = v19[5];
    if (v24 != v23)
    {
      do
      {
        std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v24 - 32, *(void *)(v24 - 24));

        double v26 = *(void **)(v24 - 48);
        v24 -= 48;
      }
      while (v24 != v23);
      uint64_t v25 = *v22;
    }
    v19[6] = v23;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v19[8] + 40))(v19[8], v25, v19[7] - v25);
    uint64_t *v22 = 0;
    v19[6] = 0;
    v19[7] = 0;
  }
  *(_OWORD *)(v19 + 5) = *((_OWORD *)v12 + 3);
  v19[7] = v12[8];
  v12[6] = 0;
  v12[7] = 0;
  v12[8] = 0;

  if (v46 == v45)
  {
    (*(void (**)(void *))(v45[0] + 32))(v45);
  }
  else if (v46)
  {
    (*(void (**)(void))(*v46 + 40))();
  }

  _Block_object_dispose(&v31, 8);
  uint64_t v27 = v37;
  if (v37)
  {
    uint64_t v28 = v38;
    uint64_t v29 = v37;
    if (v38 != v37)
    {
      do
      {
        std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v28 - 32, *(void *)(v28 - 24));

        double v30 = *(void **)(v28 - 48);
        v28 -= 48;
      }
      while (v28 != v27);
      uint64_t v29 = v37;
    }
    uint64_t v38 = v27;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v40 + 40))(v40, v29, v39 - v29);
  }
}

void sub_1A1F91238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a10, 8);
  std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::~vector[abi:nn180100](&a16);

  _Unwind_Resume(a1);
}

uint64_t std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::__tree_const_iterator<md::RouteRangeAnnotationRequest,std::__tree_node<md::RouteRangeAnnotationRequest,void *> *,long> &,std::insert_iterator<std::set<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>> &>(uint64_t result, uint64_t a2, void *a3, uint64_t a4, void *a5, uint64_t *a6)
{
  uint64_t v7 = (void *)result;
  uint64_t v8 = *(void **)a2;
  double v9 = (void *)*a3;
  if (*(void *)a2 == *a3)
  {
LABEL_56:
    uint64_t v33 = *a6;
    float64x2_t v32 = (void *)a6[1];
    double v9 = v8;
  }
  else
  {
    double v12 = *(void **)a4;
    while (*(void *)a4 != *a5)
    {
      unint64_t v15 = v8[4];
      unint64_t v16 = v12[4];
      if (v15 == v16)
      {
        uint64_t result = [(id)v8[5] compare:v12[5]];
        uint64_t v8 = *(void **)a2;
        if (result == -1)
        {
LABEL_25:
          uint64_t result = std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::__emplace_hint_unique_key_args<md::RouteRangeAnnotationRequest,md::RouteRangeAnnotationRequest const&>(*a6, a6[1], (uint64_t)(v8 + 4), (uint64_t)(v8 + 4));
          a6[1] = result;
          uint64_t v27 = *(void **)(result + 8);
          if (v27)
          {
            do
            {
              uint64_t v28 = v27;
              uint64_t v27 = (void *)*v27;
            }
            while (v27);
          }
          else
          {
            do
            {
              uint64_t v28 = *(void **)(result + 16);
              BOOL v24 = *v28 == result;
              uint64_t result = (uint64_t)v28;
            }
            while (!v24);
          }
          a6[1] = (uint64_t)v28;
          uint64_t v29 = *(void **)a2;
          double v30 = *(void **)(*(void *)a2 + 8);
          if (v30)
          {
            do
            {
              uint64_t v31 = v30;
              double v30 = (void *)*v30;
            }
            while (v30);
          }
          else
          {
            do
            {
              uint64_t v31 = (void *)v29[2];
              BOOL v24 = *v31 == (void)v29;
              uint64_t v29 = v31;
            }
            while (!v24);
          }
          *(void *)a2 = v31;
          goto LABEL_40;
        }
        double v12 = *(void **)a4;
        unint64_t v20 = *(void *)(*(void *)a4 + 32);
        unint64_t v21 = v8[4];
        BOOL v17 = v20 >= v21;
        if (v20 != v21)
        {
LABEL_6:
          if (v17) {
            goto LABEL_14;
          }
          unint64_t v18 = (void *)v12[1];
          if (!v18) {
            goto LABEL_37;
          }
          goto LABEL_8;
        }
      }
      else
      {
        if (v15 < v16) {
          goto LABEL_25;
        }
        BOOL v17 = v16 >= v15;
        if (v16 != v15) {
          goto LABEL_6;
        }
      }
      uint64_t result = [(id)v12[5] compare:v8[5]];
      if (result != -1)
      {
        uint64_t v8 = *(void **)a2;
LABEL_14:
        double v22 = (void *)v8[1];
        if (v22)
        {
          do
          {
            uint64_t v23 = v22;
            double v22 = (void *)*v22;
          }
          while (v22);
        }
        else
        {
          do
          {
            uint64_t v23 = (void *)v8[2];
            BOOL v24 = *v23 == (void)v8;
            uint64_t v8 = v23;
          }
          while (!v24);
        }
        *(void *)a2 = v23;
        uint64_t v25 = *(void **)a4;
        double v26 = *(void **)(*(void *)a4 + 8);
        if (v26)
        {
          do
          {
            double v19 = v26;
            double v26 = (void *)*v26;
          }
          while (v26);
        }
        else
        {
          do
          {
            double v19 = (void *)v25[2];
            BOOL v24 = *v19 == (void)v25;
            uint64_t v25 = v19;
          }
          while (!v24);
        }
        goto LABEL_39;
      }
      double v12 = *(void **)a4;
      unint64_t v18 = *(void **)(*(void *)a4 + 8);
      if (!v18)
      {
        do
        {
LABEL_37:
          double v19 = (void *)v12[2];
          BOOL v24 = *v19 == (void)v12;
          double v12 = v19;
        }
        while (!v24);
        goto LABEL_39;
      }
      do
      {
LABEL_8:
        double v19 = v18;
        unint64_t v18 = (void *)*v18;
      }
      while (v18);
LABEL_39:
      *(void *)a4 = v19;
LABEL_40:
      uint64_t v8 = *(void **)a2;
      double v9 = (void *)*a3;
      if (*(void *)a2 == *a3) {
        goto LABEL_56;
      }
      double v12 = *(void **)a4;
    }
    uint64_t v33 = *a6;
    float64x2_t v32 = (void *)a6[1];
    if (v8 != v9)
    {
      do
      {
        uint64_t result = std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::__emplace_hint_unique_key_args<md::RouteRangeAnnotationRequest,md::RouteRangeAnnotationRequest const&>(v33, (uint64_t)v32, (uint64_t)(v8 + 4), (uint64_t)(v8 + 4));
        double v34 = *(void **)(result + 8);
        if (v34)
        {
          do
          {
            float64x2_t v32 = v34;
            double v34 = (void *)*v34;
          }
          while (v34);
        }
        else
        {
          do
          {
            float64x2_t v32 = *(void **)(result + 16);
            BOOL v24 = *v32 == result;
            uint64_t result = (uint64_t)v32;
          }
          while (!v24);
        }
        float64x2_t v35 = (void *)v8[1];
        if (v35)
        {
          do
          {
            double v36 = v35;
            float64x2_t v35 = (void *)*v35;
          }
          while (v35);
        }
        else
        {
          do
          {
            double v36 = (void *)v8[2];
            BOOL v24 = *v36 == (void)v8;
            uint64_t v8 = v36;
          }
          while (!v24);
        }
        uint64_t v8 = v36;
      }
      while (v36 != v9);
    }
  }
  *uint64_t v7 = v9;
  v7[1] = v33;
  v7[2] = v32;
  return result;
}

void *std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void md::LabelNavEtaLabeler::setupRouteLabelingState(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned int a5, unsigned int a6, char a7)
{
  id v8 = a4;
  double v9 = [v8 route];
  uint64_t v10 = (uint64_t)v9;
  uint64_t v11 = *(uint64_t **)(a1 + 464);
  if (v11)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v13 = (uint64_t **)v11;
        unint64_t v14 = v11[4];
        if ((unint64_t)v9 >= v14) {
          break;
        }
        uint64_t v11 = *v13;
        double v12 = v13;
        if (!*v13) {
          goto LABEL_8;
        }
      }
      if (v14 >= (unint64_t)v9) {
        break;
      }
      uint64_t v11 = v13[1];
      if (!v11)
      {
        double v12 = v13 + 1;
        goto LABEL_8;
      }
    }

    unint64_t v15 = (uint64_t *)v13;
  }
  else
  {
    double v12 = (uint64_t **)(a1 + 464);
    unint64_t v13 = (uint64_t **)(a1 + 464);
LABEL_8:
    unint64_t v15 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 472) + 16))(*(void *)(a1 + 472), 64, 8);
    v15[4] = v10;
    v15[5] = 0;
    v15[6] = 0;
    v15[7] = 0;
    uint64_t *v15 = 0;
    v15[1] = 0;
    void v15[2] = (uint64_t)v13;
    void *v12 = v15;
    uint64_t v16 = **(void **)(a1 + 456);
    BOOL v17 = v15;
    if (v16)
    {
      *(void *)(a1 + 456) = v16;
      BOOL v17 = *v12;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 464), v17);
    ++*(void *)(a1 + 480);
  }
  unint64_t v18 = [v8 route];
  uint64_t v19 = (uint64_t)v18;
  unint64_t v20 = *(uint64_t **)(a1 + 496);
  if (v20)
  {
    while (1)
    {
      while (1)
      {
        double v22 = (uint64_t **)v20;
        unint64_t v23 = v20[4];
        if ((unint64_t)v18 >= v23) {
          break;
        }
        unint64_t v20 = *v22;
        unint64_t v21 = v22;
        if (!*v22) {
          goto LABEL_19;
        }
      }
      if (v23 >= (unint64_t)v18) {
        break;
      }
      unint64_t v20 = v22[1];
      if (!v20)
      {
        unint64_t v21 = v22 + 1;
        goto LABEL_19;
      }
    }

    uint64_t v251 = (uint64_t *)v22;
  }
  else
  {
    unint64_t v21 = (uint64_t **)(a1 + 496);
    double v22 = (uint64_t **)(a1 + 496);
LABEL_19:
    BOOL v24 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 504) + 16))(*(void *)(a1 + 504), 72, 8);
    v24[4] = v19;
    v24[5] = 0;
    v24[6] = 0;
    v24[7] = 0;
    {
      operator new();
    }
    v24[8] = mdm::Allocator::instance(void)::alloc;
    uint64_t *v24 = 0;
    v24[1] = 0;
    void v24[2] = (uint64_t)v22;
    *unint64_t v21 = v24;
    uint64_t v25 = **(void **)(a1 + 488);
    uint64_t v251 = v24;
    if (v25)
    {
      *(void *)(a1 + 488) = v25;
      BOOL v24 = *v21;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 496), v24);
    ++*(void *)(a1 + 512);
  }
  uint64_t v288 = [v8 route];
  uint64_t v250 = (uint64_t)(v15 + 5);
  uint64_t v253 = (VKRouteInfo *)v8;
  double v26 = *(void **)(a1 + 424);
  if (!v26)
  {
LABEL_30:
    int v249 = 0;
    goto LABEL_32;
  }
  while (1)
  {
    unint64_t v27 = v26[4];
    if (v27 <= (unint64_t)v253) {
      break;
    }
LABEL_26:
    double v26 = (void *)*v26;
    if (!v26) {
      goto LABEL_30;
    }
  }
  if (v27 < (unint64_t)v253)
  {
    ++v26;
    goto LABEL_26;
  }
  int v249 = 1;
LABEL_32:

  uint64_t v28 = v251[5];
  uint64_t v295 = a1;
  if (v251[6] != v28)
  {
    size_t v248 = (float *)(a1 + 424);
    int v258 = (void *)(a1 + 80);
    uint64_t v29 = 0;
    while (1)
    {
      uint64_t v252 = v29;
      double v30 = geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>::operator[](v250, v28 + 48 * v29);
      *((unsigned char *)v30 + 148) = a5;
      uint64_t v31 = (char *)v30[6];
      for (uint64_t i = (char *)v30[7]; i != v31; i -= 16)
      {
        uint64_t v33 = (std::__shared_weak_count *)*((void *)i - 1);
        if (v33)
        {
          if (!atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
            std::__shared_weak_count::__release_weak(v33);
          }
        }
      }
      v30[7] = v31;
      double v34 = [*(id *)(v28 + 48 * v252 + 8) etaDescription];
      uint64_t v35 = [v34 routeEtaType];

      v30[19] = (id)v35;
      double v36 = v253;
      uint64_t v37 = v248;
      uint64_t v38 = *(void **)v248;
      float v39 = 0.0;
      if (*(void *)v248)
      {
        do
        {
          unint64_t v40 = v38[4];
          _CF = v40 >= (unint64_t)v36;
          if (v40 >= (unint64_t)v36) {
            id v42 = v38;
          }
          else {
            id v42 = v38 + 1;
          }
          if (_CF) {
            uint64_t v37 = (float *)v38;
          }
          uint64_t v38 = (void *)*v42;
        }
        while (*v42);
        if (v37 != v248 && *((void *)v37 + 4) <= (unint64_t)v36) {
          float v39 = v37[11];
        }
      }
      float v43 = v39 == 0.0 ? 8.0 : v39 + v39;
      float v44 = v43 * *(float *)(*(void *)(a2 + 8) + 176);

      *((float *)v30 + 21) = v44;
      if (v249)
      {
        uint64_t v45 = v28 + 48 * v252;
        *((_DWORD *)v30 + 20) = -1;
        double v46 = *(void **)(v45 + 16);
        uint64_t v255 = (void *)(v45 + 24);
        if (v46 != (void *)(v45 + 24)) {
          break;
        }
      }
LABEL_34:
      uint64_t v28 = v251[5];
      uint64_t v29 = v252 + 1;
      if (v252 + 1 >= 0xAAAAAAAAAAAAAAABLL * ((v251[6] - v28) >> 4)) {
        goto LABEL_211;
      }
    }
    std::string __p = v30;
    while (1)
    {
      uint64_t v47 = v46[5];
      uint64_t v256 = v46[6];
      uint64_t v257 = v46;
      if (v47 != v256) {
        break;
      }
LABEL_60:
      double v48 = (void *)v46[1];
      if (v48)
      {
        do
        {
          double v49 = v48;
          double v48 = (void *)*v48;
        }
        while (v48);
      }
      else
      {
        do
        {
          double v49 = (void *)v46[2];
          _ZF = *v49 == (void)v46;
          double v46 = v49;
        }
        while (!_ZF);
      }
      double v46 = v49;
      if (v49 == v255) {
        goto LABEL_34;
      }
    }
LABEL_64:
    (*(void (**)(float64x2_t *__return_ptr))(**(void **)(a1 + 40) + 24))(&v297);
    uint64_t v259 = v47;
    long long v285 = *(float **)&v297.f64[1];
    float32x2_t v50 = *(float **)&v297.f64[0];
    if (*(void *)&v297.f64[0] == *(void *)&v297.f64[1]) {
      goto LABEL_206;
    }
    unsigned int v51 = *((_DWORD *)v30 + 20);
    if (v51 >= *((_DWORD *)v257 + 8)) {
      unsigned int v51 = *((_DWORD *)v257 + 8);
    }
    *((_DWORD *)v30 + 20) = v51;
    while (2)
    {
      id v52 = v288;
      float v53 = v50[2];
      float v54 = v50[1];
      if (*(_DWORD *)v50 == LODWORD(v53) && vabds_f32(v54, v50[3]) < 0.00000011921)
      {
        unint64_t v55 = 0;
        float v56 = 0;
        float v57 = 0;
        goto LABEL_154;
      }
      if (v54 == 0.0)
      {
        float64x2_t v65 = 0;
        float v56 = 0;
      }
      else
      {
        v299[0] = *(PolylineCoordinate *)v50;
        double v279 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v52, v299);
        double v282 = v58;
        double v291 = v59;
        float64x2_t v60 = *(float64x2_t **)(a2 + 24);
        double v61 = v60[55].f64[1];
        double v62 = v60[57].f64[1];
        double v63 = v60[59].f64[1];
        double v64 = v60[61].f64[1];
        float64x2_t v266 = v60[54];
        float64x2_t v267 = v60[56];
        float64x2_t v271 = v60[58];
        float64x2_t v274 = v60[60];
        float64x2_t v65 = (float32x2_t *)operator new(8uLL);
        float32x2_t *v65 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v274, v266, v279), v267, v282), v271, v291), 1.0 / (v64 + v61 * v279 + v62 * v282 + v63 * v291)));
        float v56 = v65 + 1;
        float v54 = v50[1];
        float v53 = v50[2];
      }
      if (v54 <= 0.0) {
        unsigned int v66 = *(_DWORD *)v50;
      }
      else {
        unsigned int v66 = *(_DWORD *)v50 + 1;
      }
      v292 = v52;
      if (v66 == LODWORD(v53))
      {
        v299[0] = (PolylineCoordinate)LODWORD(v53);
        double v67 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v52, v299);
        uint64_t v70 = (char *)v56 - (char *)v65;
        uint64_t v71 = v56 - v65;
        unint64_t v72 = v71 + 1;
        if ((unint64_t)(v71 + 1) >> 61) {
          goto LABEL_275;
        }
        uint64_t v73 = *(float64x2_t **)(a2 + 24);
        double v74 = v73[55].f64[1];
        double v75 = v73[57].f64[1];
        double v76 = v73[61].f64[1];
        double v77 = v73[59].f64[1];
        float64x2_t v78 = v73[54];
        float64x2_t v79 = v73[56];
        float64x2_t v80 = v73[60];
        float64x2_t v81 = v73[58];
        if (v70 >> 2 > v72) {
          unint64_t v72 = v70 >> 2;
        }
        if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v82 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v82 = v72;
        }
        if (v82)
        {
          if (v82 >> 61) {
            goto LABEL_272;
          }
          float64x2_t v265 = v73[54];
          float64x2_t v266 = v73[56];
          float64x2_t v268 = v73[58];
          float64x2_t v272 = v73[60];
          double v275 = v67;
          double v280 = v68;
          double v283 = v69;
          uint64_t v83 = operator new(8 * v82);
          double v67 = v275;
          double v68 = v280;
          double v69 = v283;
          uint64_t v84 = v83;
          float64x2_t v81 = v268;
          float64x2_t v80 = v272;
          float64x2_t v79 = v266;
          float64x2_t v78 = v265;
        }
        else
        {
          uint64_t v84 = 0;
        }
        unint64_t v55 = (float32x2_t *)&v84[8 * v71];
        *unint64_t v55 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v80, v78, v67), v79, v68), v81, v69), 1.0 / (v76 + v74 * v67 + v75 * v68 + v77 * v69)));
        uint64_t v108 = v55 + 1;
        if (v56 == v65)
        {
          a1 = v295;
          if (v65) {
            goto LABEL_125;
          }
        }
        else
        {
          unint64_t v109 = (char *)&v56[-1] - (char *)v65;
          if (v109 < 0x58 || (unint64_t)((char *)v65 - v84) < 0x20)
          {
            uint64_t v110 = v56;
            a1 = v295;
            goto LABEL_123;
          }
          uint64_t v156 = (v109 >> 3) + 1;
          uint64_t v110 = &v56[-(v156 & 0x3FFFFFFFFFFFFFFCLL)];
          uint64_t v157 = &v84[8 * v71 - 16];
          uint64_t v158 = v56 - 2;
          uint64_t v159 = v156 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v160 = *(_OWORD *)v158->f32;
            *(v157 - 1) = *(_OWORD *)v158[-2].f32;
            *uint64_t v157 = v160;
            v157 -= 2;
            v158 -= 4;
            v159 -= 4;
          }
          while (v159);
          v55 -= v156 & 0x3FFFFFFFFFFFFFFCLL;
          a1 = v295;
          if (v156 != (v156 & 0x3FFFFFFFFFFFFFFCLL))
          {
            do
            {
LABEL_123:
              float32x2_t v111 = v110[-1];
              --v110;
              v55[-1] = v111;
              --v55;
            }
            while (v110 != v65);
          }
          if (v65) {
LABEL_125:
          }
            operator delete(v65);
        }
        float v57 = (float32x2_t *)&v84[8 * v82];
        float v56 = v108;
        id v52 = v292;
LABEL_131:
        if (v50[3] != 0.0)
        {
          v299[0] = *(PolylineCoordinate *)(v50 + 2);
          double v112 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v52, v299);
          uint64_t v113 = *(float64x2_t **)(a2 + 24);
          float32x2_t v116 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v113[60], v113[54], v112), v113[56], v114), v113[58], v115), 1.0 / (v113[61].f64[1] + v113[55].f64[1] * v112 + v113[57].f64[1] * v114 + v113[59].f64[1] * v115)));
          if (v56 < v57)
          {
            *float v56 = v116;
            int v117 = v56 + 1;
            a1 = v295;
            goto LABEL_153;
          }
          uint64_t v118 = v56 - v55;
          unint64_t v119 = v118 + 1;
          if ((unint64_t)(v118 + 1) >> 61) {
LABEL_275:
          }
            abort();
          if (((char *)v57 - (char *)v55) >> 2 > v119) {
            unint64_t v119 = ((char *)v57 - (char *)v55) >> 2;
          }
          if ((unint64_t)((char *)v57 - (char *)v55) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v120 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v120 = v119;
          }
          if (v120)
          {
            if (v120 >> 61) {
LABEL_272:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            uint64_t v121 = operator new(8 * v120);
          }
          else
          {
            uint64_t v121 = 0;
          }
          size_t v122 = (float32x2_t *)&v121[8 * v118];
          *size_t v122 = v116;
          int v117 = v122 + 1;
          if (v56 == v55)
          {
            a1 = v295;
            float v57 = (float32x2_t *)&v121[8 * v120];
            if (v55) {
              goto LABEL_151;
            }
          }
          else
          {
            unint64_t v123 = (char *)&v56[-1] - (char *)v55;
            if (v123 < 0x58 || (unint64_t)((char *)v55 - v121) < 0x20)
            {
              uint64_t v124 = v56;
              a1 = v295;
              goto LABEL_149;
            }
            uint64_t v161 = (v123 >> 3) + 1;
            uint64_t v124 = &v56[-(v161 & 0x3FFFFFFFFFFFFFFCLL)];
            uint64_t v162 = &v121[8 * v118 - 16];
            uint64_t v163 = v56 - 2;
            uint64_t v164 = v161 & 0x3FFFFFFFFFFFFFFCLL;
            a1 = v295;
            do
            {
              long long v165 = *(_OWORD *)v163->f32;
              *(v162 - 1) = *(_OWORD *)v163[-2].f32;
              *uint64_t v162 = v165;
              v162 -= 2;
              v163 -= 4;
              v164 -= 4;
            }
            while (v164);
            v122 -= v161 & 0x3FFFFFFFFFFFFFFCLL;
            if (v161 != (v161 & 0x3FFFFFFFFFFFFFFCLL))
            {
              do
              {
LABEL_149:
                float32x2_t v125 = v124[-1];
                --v124;
                v122[-1] = v125;
                --v122;
              }
              while (v124 != v55);
            }
            float v57 = (float32x2_t *)&v121[8 * v120];
            if (v55) {
LABEL_151:
            }
              operator delete(v55);
          }
          unint64_t v55 = v122;
          id v52 = v292;
LABEL_153:
          float v56 = v117;
        }
LABEL_154:

        if ((unint64_t)((char *)v56 - (char *)v55) < 9)
        {
          if (v55) {
            operator delete(v55);
          }
        }
        else
        {
          uint64_t v126 = (std::__shared_weak_count *)operator new(0x60uLL);
          v126->__shared_owners_ = 0;
          v126->__shared_weak_owners_ = 0;
          v126->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5802F8;
          v126[1].std::__shared_count = 0u;
          uint64_t v127 = (uint64_t)&v126[1];
          *(_OWORD *)&v126[1].__shared_weak_owners_ = 0u;
          *(_OWORD *)&v126[2].__shared_owners_ = 0u;
          v126[3].std::__shared_count = 0u;
          v126[3].__shared_weak_owners_ = 0;
          unsigned __int16 v128 = ((unint64_t)((char *)v56 - (char *)v55) >> 3) - 1;
          v126[2].__vftable = (std::__shared_weak_count_vtbl *)v55;
          v126[2].__shared_owners_ = (uint64_t)v56;
          v126[2].__shared_weak_owners_ = (uint64_t)v57;
          size_t v129 = 32 * ((2 << -(char)__clz(v128 - 1)) - 1);
          unint64_t v130 = (std::__shared_weak_count_vtbl *)operator new(v129);
          bzero(v130, v129);
          v126[1].__vftable = v130;
          v126[1].__shared_owners_ = (uint64_t)v130 + v129;
          v126[1].__shared_weak_owners_ = (uint64_t)v130 + v129;
          if (v128)
          {
            std::vector<md::TileSelectionTileSetType>::__append((uint64_t)&v126[3], v128);
            uint64_t v131 = (unsigned __int16 *)v126[3].__vftable;
            a1 = v295;
            if (v128 < 0x10u)
            {
              uint64_t v132 = 0;
              uint64_t j = __p;
              goto LABEL_164;
            }
            uint64_t v132 = v128 & 0xFFF0;
            uint64_t v134 = (int16x8_t *)(v131 + 8);
            uint64_t v135 = v132;
            int16x8_t v136 = (int16x8_t)xmmword_1A28FD560;
            v137.i64[0] = 0x8000800080008;
            v137.i64[1] = 0x8000800080008;
            v138.i64[0] = 0x10001000100010;
            v138.i64[1] = 0x10001000100010;
            do
            {
              v134[-1] = v136;
              *uint64_t v134 = vaddq_s16(v136, v137);
              int16x8_t v136 = vaddq_s16(v136, v138);
              v134 += 2;
              v135 -= 16;
            }
            while (v135);
            for (uint64_t j = __p; v128 != v132; ++v132)
LABEL_164:
              v131[v132] = v132;
          }
          else
          {
            uint64_t v131 = 0;
            a1 = v295;
            uint64_t j = __p;
          }
          md::PolylineCollider::buildTopDownAABBTree(v127, 0, v131, (unsigned __int16 *)v126[3].__shared_owners_);
          unint64_t v139 = (uint64_t *)j[7];
          unint64_t v140 = (unint64_t)j[8];
          if ((unint64_t)v139 < v140)
          {
            if (v139)
            {
              *unint64_t v139 = v127;
              v139[1] = (uint64_t)v126;
              uint64_t v126 = 0;
            }
            size_t v141 = v139 + 2;
            goto LABEL_190;
          }
          unint64_t v142 = j[6];
          uint64_t v143 = ((char *)v139 - v142) >> 4;
          unint64_t v144 = v143 + 1;
          if ((unint64_t)(v143 + 1) >> 60) {
            abort();
          }
          uint64_t v145 = v140 - (void)v142;
          if (v145 >> 3 > v144) {
            unint64_t v144 = v145 >> 3;
          }
          if ((unint64_t)v145 >= 0x7FFFFFFFFFFFFFF0) {
            uint64_t v146 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v146 = v144;
          }
          if (v146)
          {
            uint64_t v147 = (*(uint64_t (**)(id, uint64_t, uint64_t))(*(void *)j[9] + 16))(j[9], 16 * v146, 8);
            uint64_t v148 = (uint64_t *)(v147 + 16 * v143);
            uint64_t v149 = v147 + 16 * v146;
            if (v147)
            {
              *uint64_t v148 = v127;
              v148[1] = (uint64_t)v126;
              uint64_t v126 = 0;
            }
          }
          else
          {
            uint64_t v149 = 0;
            uint64_t v148 = (uint64_t *)(16 * v143);
          }
          size_t v141 = v148 + 2;
          uint64_t v150 = j[6];
          unsigned int v151 = j[7];
          if (v151 == v150)
          {
            j[6] = v148;
            j[7] = v141;
            uint64_t v154 = j[8];
            j[8] = (id)v149;
            if (!v151) {
              goto LABEL_190;
            }
LABEL_189:
            (*(void (**)(id, void *, int64_t))(*(void *)j[9] + 40))(j[9], v151, v154 - (unsigned char *)v151);
            goto LABEL_190;
          }
          do
          {
            long long v152 = *((_OWORD *)v151 - 1);
            v151 -= 2;
            *((_OWORD *)v148 - 1) = v152;
            v148 -= 2;
            *unsigned int v151 = 0;
            v151[1] = 0;
          }
          while (v151 != v150);
          unsigned int v151 = j[6];
          uint64_t v153 = j[7];
          j[6] = v148;
          j[7] = v141;
          uint64_t v154 = j[8];
          j[8] = (id)v149;
          if (v153 != v151)
          {
            do
            {
              uint64_t v155 = (std::__shared_weak_count *)*(v153 - 1);
              if (v155 && !atomic_fetch_add(&v155->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v155->__on_zero_shared)(v155);
                std::__shared_weak_count::__release_weak(v155);
              }
              v153 -= 2;
            }
            while (v153 != v151);
            uint64_t j = __p;
          }
          if (v151) {
            goto LABEL_189;
          }
LABEL_190:
          j[7] = v141;
          if (v126 && !atomic_fetch_add(&v126->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
            std::__shared_weak_count::__release_weak(v126);
          }
        }
        v50 += 4;
        double v30 = __p;
        if (v50 != v285) {
          continue;
        }
        float32x2_t v50 = *(float **)&v297.f64[0];
LABEL_206:
        if (v50)
        {
          *(void *)&v297.f64[1] = v50;
          operator delete(v50);
        }
        uint64_t v47 = v259 + 16;
        double v46 = v257;
        if (v259 + 16 == v256) {
          goto LABEL_60;
        }
        goto LABEL_64;
      }
      break;
    }
    if (v66 >= LODWORD(v53))
    {
      unint64_t v55 = v65;
      float v57 = v56;
      goto LABEL_131;
    }
    uint64_t v85 = *(void *)(a2 + 24);
    *(_OWORD *)&v299[0].unsigned int index = *(_OWORD *)(v85 + 136);
    double v300 = *(double *)(v85 + 152);
    long long v301 = *(_OWORD *)(v85 + 160);
    uint64_t v302 = *(std::__shared_weak_count **)(v85 + 176);
    uint64_t v86 = *(void *)(a1 + 40);
    v303.unsigned int index = v66;
    v303.float offset = v53;
    if (!(*(unsigned int (**)(uint64_t, uint64_t, const GEOComposedRoute *, PolylineCoordinate *, PolylineCoordinate *, double *))(*(void *)v86 + 32))(v86, a3, v52, v299, &v303, v298))
    {
      uint64_t v89 = v56;
      float v57 = v56;
LABEL_130:
      unint64_t v55 = v65;
      float v56 = v89;
      a1 = v295;
      goto LABEL_131;
    }
    md::RouteSimplifier::simplifiedRibbonIndices(*(void *)(a1 + 48), v52, v66, SLODWORD(v53), v258, v298[0] * 4.0 * *(double *)(v85 + 312) / *(float *)(v85 + 1064));
    unint64_t v87 = *(unsigned int **)(a1 + 80);
    int v88 = *(unsigned int **)(a1 + 88);
    float v57 = v56;
    uint64_t v89 = v56;
    while (2)
    {
      if (v87 == v88) {
        goto LABEL_130;
      }
      PolylineCoordinate v303 = (PolylineCoordinate)*v87;
      double v90 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(v295 + 48), v52, &v303);
      uint64_t v91 = *(float64x2_t **)(a2 + 24);
      float32x2_t v94 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v91[60], v91[54], v90), v91[56], v92), v91[58], v93), 1.0 / (v91[61].f64[1] + v91[55].f64[1] * v90 + v91[57].f64[1] * v92 + v91[59].f64[1] * v93)));
      if (v56 < v57)
      {
        *float v56 = v94;
        uint64_t v89 = v56 + 1;
      }
      else
      {
        uint64_t v95 = v56 - v65;
        unint64_t v96 = v95 + 1;
        if ((unint64_t)(v95 + 1) >> 61) {
          abort();
        }
        if (((char *)v57 - (char *)v65) >> 2 > v96) {
          unint64_t v96 = ((char *)v57 - (char *)v65) >> 2;
        }
        if ((unint64_t)((char *)v57 - (char *)v65) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v97 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v97 = v96;
        }
        if (v97)
        {
          if (v97 >> 61) {
            goto LABEL_272;
          }
          uint64_t v98 = operator new(8 * v97);
        }
        else
        {
          uint64_t v98 = 0;
        }
        uint64_t v99 = (float32x2_t *)&v98[8 * v95];
        *uint64_t v99 = v94;
        uint64_t v89 = v99 + 1;
        if (v56 != v65)
        {
          unint64_t v100 = (char *)&v56[-1] - (char *)v65;
          if (v100 < 0x58)
          {
            char v101 = v56;
            goto LABEL_113;
          }
          if ((unint64_t)((char *)v65 - v98) < 0x20)
          {
            char v101 = v56;
            goto LABEL_113;
          }
          uint64_t v102 = (v100 >> 3) + 1;
          char v101 = &v56[-(v102 & 0x3FFFFFFFFFFFFFFCLL)];
          uint64_t v103 = &v98[8 * v95 - 16];
          int v104 = v56 - 2;
          uint64_t v105 = v102 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v106 = *(_OWORD *)v104->f32;
            *(v103 - 1) = *(_OWORD *)v104[-2].f32;
            *uint64_t v103 = v106;
            v103 -= 2;
            v104 -= 4;
            v105 -= 4;
          }
          while (v105);
          v99 -= v102 & 0x3FFFFFFFFFFFFFFCLL;
          if (v102 != (v102 & 0x3FFFFFFFFFFFFFFCLL))
          {
            do
            {
LABEL_113:
              float32x2_t v107 = v101[-1];
              --v101;
              v99[-1] = v107;
              --v99;
            }
            while (v101 != v65);
          }
        }
        float v57 = (float32x2_t *)&v98[8 * v97];
        if (v65) {
          operator delete(v65);
        }
        float64x2_t v65 = v99;
        id v52 = v292;
      }
      ++v87;
      float v56 = v89;
      continue;
    }
  }
LABEL_211:
  long long v167 = md::LabelNavEtaLabeler::featuresForRoute((md::LabelNavEtaLabeler *)a1, v253);
  uint64_t v168 = v251[5];
  if (v251[6] != v168)
  {
    uint64_t v169 = v167;
    uint64_t v170 = 0;
    uint64_t v281 = (unint64_t *)(a1 + 552);
    __asm { FMOV            V0.2D, #0.5 }
    float64x2_t v264 = _Q0;
LABEL_216:
    uint64_t v178 = (id *)(v168 + 48 * v170);
    uint64_t v179 = geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>::operator[](v250, (uint64_t)v178);
    if (!v169) {
      goto LABEL_229;
    }
    uint64_t v180 = *(void *)v169;
    if (*(void *)v169 == *((void *)v169 + 1)) {
      goto LABEL_228;
    }
    while (1)
    {
      id v181 = *v178;
      id v182 = *(id *)v180;
      if (v181 == v182)
      {
        char v183 = [*(id *)(v168 + 48 * v170 + 8) isEqual:*(void *)(v180 + 8)];

        if (v183)
        {
          if (v180 != *((void *)v169 + 1))
          {
            id v184 = *(id *)(v180 + 56);
            if (v184)
            {
              uint64_t v185 = v184;
              int v186 = v251;
              uint64_t v293 = v184;
              if ([v184 didStyleChange])
              {
                *((unsigned char *)v179 + 40) = 0;
                [v185 setDidStyleChange:0];
              }
              char v286 = 0;
LABEL_230:
              uint64_t v284 = v170;
              uint64_t v189 = v168 + 48 * v170;
              size_t v191 = *(void **)(v189 + 8);
              unint64_t v190 = (id *)(v189 + 8);
              unint64_t v192 = [v191 etaDescription];
              switch([v192 routeEtaType])
              {
                case 0:
                case 3:
                case 6:
                  __pa = operator new(4uLL);
                  _DWORD *__pa = 185337865;
                  uint64_t v193 = __pa + 1;
                  if (!*((unsigned char *)v179 + 40)) {
                    goto LABEL_245;
                  }
                  goto LABEL_232;
                case 1:
                  __pa = operator new(2uLL);
                  uint64_t v209 = (__int16 *)__pa;
                  __int16 v210 = 1798;
                  goto LABEL_244;
                case 2:
                  __pa = operator new(2uLL);
                  uint64_t v209 = (__int16 *)__pa;
                  __int16 v210 = 2057;
                  goto LABEL_244;
                case 4:
                  __pa = operator new(2uLL);
                  uint64_t v209 = (__int16 *)__pa;
                  __int16 v210 = 1284;
LABEL_244:
                  *uint64_t v209 = v210;
                  uint64_t v193 = v209 + 1;
                  if (!*((unsigned char *)v179 + 40)) {
                    goto LABEL_245;
                  }
                  goto LABEL_232;
                default:
                  __pa = operator new(1uLL);
                  *(unsigned char *)__pa = 6;
                  uint64_t v193 = (char *)__pa + 1;
                  if (*((unsigned char *)v179 + 40)) {
                    goto LABEL_232;
                  }
LABEL_245:
                  BOOL v270 = [(VKRouteInfo *)v253 hasFocus];
                  uint64_t v211 = +[VKLabelNavRouteEta toStyleEtaComparison:a6];
                  PolylineCoordinate v277 = [(VKRouteInfo *)v253 route];
                  unsigned int v212 = [v277 transportType];
                  if (v212 >= 7) {
                    unsigned __int8 v213 = 4;
                  }
                  else {
                    unsigned __int8 v213 = 0x50403020100uLL >> (8 * v212);
                  }
                  uint64_t v214 = +[VKLabelNavRouteEta toStyleNavLabelType:](VKLabelNavRouteEta, "toStyleNavLabelType:", [v192 routeEtaType]);
                  uint64_t v215 = *(unsigned __int16 *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v281, (uint64_t)v178);
                  unint64_t v216 = geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v281, (uint64_t)v178);
                  v296[0] = 0;
                  if (*(unsigned char *)(v216 + 2))
                  {
                    v296[1] = *(unsigned char *)(v216 + 3);
                    v296[0] = 1;
                  }
                  uint64_t v217 = [v192 styleAttributes];
                  *(void *)&v266.f64[0] = *(void *)&v266.f64[0] & 0xFFFFFFFFFFFF0000 | v215;
                  +[VKLabelNavRouteEta styleForNavContext:a2 selected:a5 focused:v270 etaComparison:v211 transportType:v213 navLabelType:v214 when:*(void *)&v266.f64[0] routeLegWhen:v296 additionalAttributes:v217];

                  int v186 = v251;
                  if (v296[0]) {
                    v296[0] = 0;
                  }

                  v218 = [(VKRouteInfo *)v253 route];
                  objc_msgSend(v218, "pointAt:", objc_msgSend(*v190, "start"));
                  float64_t v278 = v219;
                  double v221 = v220;

                  long double v222 = tan(v221 * 0.00872664626 + 0.785398163);
                  long double v223 = log(v222);
                  v224.f64[0] = v278;
                  v224.f64[1] = v223;
                  float64x2_t v297 = vmlaq_f64(v264, (float64x2_t)xmmword_1A28FCBE0, v224);
                  uint64_t v225 = __pa;
                  if (__pa != (_DWORD *)v193)
                  {
                    do
                    {
                      LOBYTE(v298[0]) = *v225;
                      unsigned __int8 v226 = LOBYTE(v298[0]);
                      uint64_t v227 = +[VKLabelNavRouteEta artworkForEtaDescription:v192 navContext:a2 roadSignStyleGroup:v299 mercatorPoint:&v297 orientation:LOBYTE(v298[0]) isSelected:a5 artworkCache:*(void *)(v295 + 144)];
                      uint64_t v228 = v227;
                      if (!v227) {
                        break;
                      }
                      objc_msgSend(v227, "offsetPixelForPixel:", 0.0, 0.0);
                      float v230 = v229;
                      float v232 = v231;
                      [v228 localSignBounds];
                      if (v235 < v233 || v236 < v234)
                      {
                        float v239 = 3.4028e38;
                        float v241 = -3.4028e38;
                        float v240 = -3.4028e38;
                        float v238 = 3.4028e38;
                      }
                      else
                      {
                        float v238 = v233 + v230;
                        float v239 = v234 + v232;
                        float v240 = v235 + v230;
                        float v241 = v236 + v232;
                      }
                      int v242 = (float *)std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v179, v226, v298);
                      v242[5] = v238;
                      v242[6] = v239;
                      v242[7] = v240;
                      v242[8] = v241;
                      *((unsigned char *)v179 + 40) = 1;

                      ++v225;
                    }
                    while (v225 != v193);
                  }
                  int v243 = v302;
                  if (v302 && !atomic_fetch_add(&v302->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v243->__on_zero_shared)(v243);
                    std::__shared_weak_count::__release_weak(v243);
                    unsigned int v244 = (std::__shared_weak_count *)v301;
                    if (!(void)v301) {
                      goto LABEL_267;
                    }
                  }
                  else
                  {
                    unsigned int v244 = (std::__shared_weak_count *)v301;
                    if (!(void)v301) {
                      goto LABEL_267;
                    }
                  }
                  if (!atomic_fetch_add(&v244->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v244->__on_zero_shared)(v244);
                    std::__shared_weak_count::__release_weak(v244);
                  }
LABEL_267:
                  uint64_t v245 = (std::__shared_weak_count *)v299[1];
                  if (*(void *)&v299[1]
                    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v299[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v245->__on_zero_shared)(v245);
                    std::__shared_weak_count::__release_weak(v245);
                  }
LABEL_232:
                  *((unsigned char *)v179 + 88) = 0;
                  if ((v286 & 1) == 0
                    && (v249 & [v293 hasLabelWithAnchor]) == 1
                    && (a7 & 1) == 0)
                  {
                    [v293 worldPointForStaging];
                    double v273 = *(double *)&v194;
                    double v276 = *(double *)&v195;
                    double v287 = v196;
                    v299[0] = v194;
                    v299[1] = v195;
                    double v300 = v196;
                    unsigned __int8 v197 = [v293 orientation];
                    LOBYTE(v297.f64[0]) = v197;
                    *((unsigned char *)v179 + 88) = 0;
                    uint64_t v198 = *(void *)(a2 + 24);
                    if (!md::LabelLayoutContext::isDistanceClipped(v198, (uint64_t)v299))
                    {
                      double v199 = *(double *)(v198 + 888);
                      double v200 = *(double *)(v198 + 920);
                      double v201 = *(double *)(v198 + 984);
                      double v202 = *(double *)(v198 + 952);
                      float64x2_t v260 = *(float64x2_t *)(v198 + 864);
                      float64x2_t v261 = *(float64x2_t *)(v198 + 896);
                      float64x2_t v269 = *(float64x2_t *)(v198 + 960);
                      float64x2_t v262 = *(float64x2_t *)(v198 + 928);
                      uint64_t v203 = (float *)std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v179, v197, &v297);
                      float v204 = v203[7];
                      float v205 = v203[5];
                      if (v204 < v205 || (v206 = v203[8], float v207 = v203[6], v206 < v207))
                      {
                        float v174 = 3.4028e38;
                        float v175 = -3.4028e38;
                        float v176 = -3.4028e38;
                        float v177 = 3.4028e38;
                      }
                      else
                      {
                        float32x2_t v208 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v269, v260, v273), v261, v276), v262, v287), 1.0 / (v201 + v199 * v273 + v200 * v276 + v202 * v287)));
                        float v177 = v208.f32[0] + v205;
                        float v174 = v208.f32[1] + v207;
                        float v176 = v208.f32[0] + v204;
                        float v175 = v208.f32[1] + v206;
                      }
                      *((float *)v179 + 23) = v177;
                      *((float *)v179 + 24) = v174;
                      *((float *)v179 + 25) = v176;
                      *((float *)v179 + 26) = v175;
                      *((unsigned char *)v179 + 88) = 1;
                    }
                  }
                  operator delete(__pa);

                  uint64_t v170 = v284 + 1;
                  uint64_t v168 = v186[5];
                  if (v284 + 1 < 0xAAAAAAAAAAAAAAABLL * ((v186[6] - v168) >> 4)) {
                    goto LABEL_216;
                  }
                  goto LABEL_271;
              }
            }
LABEL_229:
            uint64_t v293 = 0;
            char v286 = 1;
            int v186 = v251;
            goto LABEL_230;
          }
LABEL_228:
          v299[0] = (PolylineCoordinate)&unk_1EF559818;
          v299[1] = 0;
          uint64_t v187 = (id *)geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>::operator[]((uint64_t)v169, v168 + 48 * v170);
          objc_storeStrong(v187 + 1, *(id *)&v299[1]);
          unint64_t v188 = (void *)v299[1];
          v299[1] = 0;

          v299[0] = (PolylineCoordinate)&unk_1EF559818;
          goto LABEL_229;
        }
      }
      else
      {
      }
      v180 += 72;
      if (v180 == *((void *)v169 + 1)) {
        goto LABEL_228;
      }
    }
  }
LABEL_271:
}

void sub_1A1F92D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  _Unwind_Resume(a1);
}

void md::LabelNavEtaLabeler::updateEtaFeature(uint64_t a1, void *a2, uint64_t a3, void *a4, unsigned int a5, int a6, double a7)
{
  double v9 = a4;
  uint64_t v10 = [(VKRouteInfo *)v9 route];
  uint64_t v11 = *(void **)(a1 + 464);
  if (!v11) {
    goto LABEL_12;
  }
  uint64_t v12 = a1 + 464;
  do
  {
    unint64_t v13 = v11[4];
    BOOL v14 = v13 >= (unint64_t)v10;
    if (v13 >= (unint64_t)v10) {
      unint64_t v15 = v11;
    }
    else {
      unint64_t v15 = v11 + 1;
    }
    if (v14) {
      uint64_t v12 = (uint64_t)v11;
    }
    uint64_t v11 = (void *)*v15;
  }
  while (*v15);
  if (v12 != a1 + 464 && (unint64_t)v10 >= *(void *)(v12 + 32))
  {

    uint64_t v16 = (uint64_t *)(v12 + 40);
  }
  else
  {
LABEL_12:

    uint64_t v16 = 0;
  }
  uint64_t v288 = (void *)(a1 + 464);

  BOOL v17 = md::LabelNavEtaLabeler::featuresForRoute((md::LabelNavEtaLabeler *)a1, v9);
  uint64_t v293 = v9;
  if (!v17)
  {
    __p[0] = 0;
    __p[1] = 0;
    double v308 = 0.0;
    unint64_t v18 = [(VKRouteInfo *)v9 route];
    uint64_t v19 = (uint64_t)v18;
    unint64_t v20 = *(uint64_t **)(a1 + 496);
    if (v20)
    {
      while (1)
      {
        while (1)
        {
          double v22 = (uint64_t **)v20;
          unint64_t v23 = v20[4];
          if ((unint64_t)v18 >= v23) {
            break;
          }
          unint64_t v20 = *v22;
          unint64_t v21 = v22;
          if (!*v22) {
            goto LABEL_21;
          }
        }
        if (v23 >= (unint64_t)v18) {
          break;
        }
        unint64_t v20 = v22[1];
        if (!v20)
        {
          unint64_t v21 = v22 + 1;
          goto LABEL_21;
        }
      }

      BOOL v24 = (uint64_t *)v22;
    }
    else
    {
      unint64_t v21 = (uint64_t **)(a1 + 496);
      double v22 = (uint64_t **)(a1 + 496);
LABEL_21:
      BOOL v24 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 504) + 16))(*(void *)(a1 + 504), 72, 8);
      v24[4] = v19;
      v24[5] = 0;
      v24[6] = 0;
      v24[7] = 0;
      {
        operator new();
      }
      v24[8] = mdm::Allocator::instance(void)::alloc;
      uint64_t *v24 = 0;
      v24[1] = 0;
      void v24[2] = (uint64_t)v22;
      *unint64_t v21 = v24;
      uint64_t v25 = **(void **)(a1 + 488);
      double v26 = v24;
      if (v25)
      {
        *(void *)(a1 + 488) = v25;
        double v26 = *v21;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 496), v26);
      ++*(void *)(a1 + 512);
    }
    uint64_t v28 = v24[5];
    for (uint64_t i = v24[6]; v28 != i; v28 += 48)
    {
      *(void *)int v316 = &unk_1EF559818;
      *(void *)&v316[8] = 0;
      uint64_t v29 = (id *)geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>::operator[]((uint64_t)__p, v28);
      objc_storeStrong(v29 + 1, *(id *)&v316[8]);
      double v30 = *(void **)&v316[8];
      *(void *)&v316[8] = 0;

      *(void *)int v316 = &unk_1EF559818;
    }
    unint64_t v31 = [(VKRouteInfo *)v9 route];
    float64x2_t v32 = (uint64_t *)v31;
    uint64_t v33 = *(uint64_t **)(a1 + 264);
    if (v33)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v35 = (uint64_t **)v33;
          unint64_t v36 = v33[4];
          if (v31 >= v36) {
            break;
          }
          uint64_t v33 = *v35;
          double v34 = v35;
          if (!*v35) {
            goto LABEL_36;
          }
        }
        if (v36 >= v31) {
          break;
        }
        uint64_t v33 = v35[1];
        if (!v33)
        {
          double v34 = v35 + 1;
          goto LABEL_36;
        }
      }
      uint64_t v37 = v35;
    }
    else
    {
      double v34 = (uint64_t **)(a1 + 264);
      uint64_t v35 = (uint64_t **)(a1 + 264);
LABEL_36:
      uint64_t v37 = (uint64_t **)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 272) + 16))(*(void *)(a1 + 272), 64, 8);
      v37[4] = v32;
      v37[5] = 0;
      v37[6] = 0;
      v37[7] = 0;
      float *v37 = 0;
      v37[1] = 0;
      v37[2] = (uint64_t *)v35;
      void *v34 = (uint64_t *)v37;
      uint64_t v38 = **(void **)(a1 + 256);
      float v39 = (uint64_t *)v37;
      if (v38)
      {
        *(void *)(a1 + 256) = v38;
        float v39 = *v34;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 264), v39);
      float64x2_t v32 = 0;
      ++*(void *)(a1 + 280);
    }
    unint64_t v40 = (void **)(v37 + 5);
    double v41 = v37[5];
    if (v41)
    {
      id v42 = v37[6];
      float v43 = v37[5];
      if (v42 != v41)
      {
        float v44 = v42 - 3;
        do
        {
          *(v42 - 3) = (uint64_t)&unk_1EF559818;

          std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(v42 - 7), *(v42 - 6));
          uint64_t v45 = (void *)*(v42 - 9);
          v42 -= 9;

          v44 -= 9;
        }
        while (v42 != v41);
        float v43 = (uint64_t *)*v40;
      }
      v37[6] = v41;
      operator delete(v43);
      *unint64_t v40 = 0;
      v37[6] = 0;
      v37[7] = 0;
      double v9 = v293;
    }
    *(_OWORD *)(v37 + 5) = *(_OWORD *)__p;
    *((double *)v37 + 7) = v308;
    __p[1] = 0;
    double v308 = 0.0;
    __p[0] = 0;

    BOOL v17 = md::LabelNavEtaLabeler::featuresForRoute((md::LabelNavEtaLabeler *)a1, v9);
    double v46 = (char *)__p[0];
    if (__p[0])
    {
      uint64_t v47 = (char *)__p[1];
      double v48 = __p[0];
      if (__p[1] != __p[0])
      {
        double v49 = (char *)__p[1] - 24;
        do
        {
          *((void *)v47 - 3) = &unk_1EF559818;

          std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(v47 - 56), *((void *)v47 - 6));
          float32x2_t v50 = (void *)*((void *)v47 - 9);
          v47 -= 72;

          v49 -= 72;
        }
        while (v47 != v46);
        double v48 = __p[0];
      }
      __p[1] = v46;
      operator delete(v48);
    }
  }
  unsigned int v51 = [(VKRouteInfo *)v9 route];
  uint64_t v52 = (uint64_t)v51;
  float v53 = *(uint64_t **)(a1 + 496);
  if (v53)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v55 = (uint64_t **)v53;
        unint64_t v56 = v53[4];
        if ((unint64_t)v51 >= v56) {
          break;
        }
        float v53 = *v55;
        float v54 = v55;
        if (!*v55) {
          goto LABEL_59;
        }
      }
      if (v56 >= (unint64_t)v51) {
        break;
      }
      float v53 = v55[1];
      if (!v53)
      {
        float v54 = v55 + 1;
        goto LABEL_59;
      }
    }

    float v57 = (uint64_t *)v55;
  }
  else
  {
    float v54 = (uint64_t **)(a1 + 496);
    unint64_t v55 = (uint64_t **)(a1 + 496);
LABEL_59:
    float v57 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 504) + 16))(*(void *)(a1 + 504), 72, 8);
    v57[4] = v52;
    v57[5] = 0;
    v57[6] = 0;
    v57[7] = 0;
    {
      operator new();
    }
    v57[8] = mdm::Allocator::instance(void)::alloc;
    uint64_t *v57 = 0;
    v57[1] = 0;
    v57[2] = (uint64_t)v55;
    *float v54 = v57;
    uint64_t v58 = **(void **)(a1 + 488);
    double v59 = v57;
    if (v58)
    {
      *(void *)(a1 + 488) = v58;
      double v59 = *v54;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 496), v59);
    ++*(void *)(a1 + 512);
  }
  uint64_t v62 = v57[5];
  uint64_t v61 = v57[6];
  double v63 = v293;
  if (v62 != v61)
  {
    uint64_t v283 = a1 + 352;
    float v64 = 5.0;
    float v65 = 0.5;
    float32x2_t v285 = v60;
    uint64_t v294 = v57[6];
    uint64_t v289 = (unint64_t *)(a1 + 552);
    while (1)
    {
      id location = geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>::operator[]((uint64_t)v17, v62);
      for (uint64_t j = *v16; ; j += 384)
      {
        while (1)
        {
          if (j == v16[1]) {
            goto LABEL_68;
          }
          id v68 = *(id *)v62;
          id v69 = *(id *)j;
          if (v68 == v69) {
            break;
          }

          j += 384;
        }
        char v70 = [*(id *)(v62 + 8) isEqual:*(void *)(j + 8)];

        if (v70) {
          break;
        }
      }
      if (j != v16[1]) {
        break;
      }
LABEL_68:
      v62 += 48;
      if (v62 == v61) {
        goto LABEL_306;
      }
    }
    uint64_t v71 = (void *)location[1];
    locationa = (id *)(location + 1);
    unsigned int v66 = v71;
    unint64_t v72 = [*(id *)(v62 + 8) etaDescription];
    if (!v72) {
      goto LABEL_67;
    }
    uint64_t v295 = v66;
    uint64_t v73 = [*(id *)(v62 + 8) etaDescription];
    double v74 = [v73 etaText];

    if (!v74)
    {
      unsigned int v66 = v295;
      goto LABEL_67;
    }
    unsigned int v66 = v295;
    if (!*(unsigned char *)(j + 88)) {
      goto LABEL_67;
    }
    uint64_t v284 = (const md::RouteLabelState *)(j + 48);
    if (!v295)
    {
      __p[0] = (void *)0xBF80000000000000;
      HIDWORD(__p[1]) = 2139095039;
      double v309 = 0.0;
      uint64_t v310 = 0;
      double v308 = 0.0;
      char v311 = 1;
      int v99 = md::LabelNavEtaLabeler::searchForPlacementAcrossShareSections(a1, a2, a3, (void *)(j + 48), v62, 0, (uint64_t)__p);
      *(double *)(j + 208) = a7;
      *(unsigned char *)(j + 216) = v99;
      if (!v99)
      {
        unsigned int v66 = 0;
        goto LABEL_67;
      }
      unint64_t v100 = [VKLabelNavRouteEta alloc];
      unsigned int v66 = [(VKLabelNavRouteEta *)v100 initWithRouteInfo:v63 routeCoord:__p[0]];
      objc_storeStrong(locationa, v66);
      unsigned int locationb = LOBYTE(__p[1]);
      char v101 = [*(id *)(v62 + 8) etaDescription];
      uint64_t v102 = *(unsigned __int16 *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v289, v62);
      unint64_t v103 = geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v289, v62);
      char v305 = 0;
      if (*(unsigned char *)(v103 + 2))
      {
        char v306 = *(unsigned char *)(v103 + 3);
        char v305 = 1;
      }
      unint64_t v278 = v278 & 0xFFFFFFFFFFFF0000 | v102;
      -[VKLabelNavRouteEta createLabelWithNavContext:orientation:etaDescription:selected:when:routeLegWhen:artworkCache:](v66, "createLabelWithNavContext:orientation:etaDescription:selected:when:routeLegWhen:artworkCache:", a2, locationb, v101, a5, *(void *)(a1 + 144));
      if (v305) {
        char v305 = 0;
      }

      if ([(VKLabelNavRouteEta *)v66 hasLabel] && ![(VKLabelNavRouteEta *)v66 hasAnchor])
      {
        int v104 = *(md::RouteSimplifier **)(a1 + 48);
        uint64_t v105 = [(VKRouteInfo *)v63 route];
        *(void *)int v316 = md::RouteSimplifier::worldPointForPolylineCoordinate(v104, v105, (const PolylineCoordinate *)__p);
        *(void *)&v316[8] = v106;
        *(void *)&v316[16] = v107;

        LOBYTE(v313) = locationb;
        *(unsigned char *)(j + 136) = 0;
        uint64_t v108 = (float64x2_t *)a2[3];
        if (!md::LabelLayoutContext::isDistanceClipped((uint64_t)v108, (uint64_t)v316))
        {
          md::LabelLayoutContext::projectPointToPixel(v108, (double *)v316, (float32x2_t *)&v314);
          unint64_t v109 = (float *)std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v284, locationb, &v313);
          float v110 = v109[7];
          float v111 = v109[5];
          if (v110 >= v111 && (float v112 = v109[8], v113 = v109[6], v112 >= v113))
          {
            float v117 = *(float *)&v314 + v111;
            float v114 = *((float *)&v314 + 1) + v113;
            float v116 = *(float *)&v314 + v110;
            float v115 = *((float *)&v314 + 1) + v112;
          }
          else
          {
            float v114 = 3.4028e38;
            float v115 = -3.4028e38;
            float v116 = -3.4028e38;
            float v117 = 3.4028e38;
          }
          *(float *)(j + 140) = v117;
          *(float *)(j + 144) = v114;
          *(float *)(j + 148) = v116;
          *(float *)(j + 152) = v115;
          *(unsigned char *)(j + 136) = 1;
        }
        *(unsigned char *)(a1 + 252) = 1;
      }
      goto LABEL_237;
    }
    [(VKLabelNavRouteEta *)v295 setRouteInfo:v63];
    [(VKLabelNavRouteEta *)v295 setSelected:a5];
    geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v289, v62);
    -[VKLabelNavRouteEta setWhen:](v295, "setWhen:");
    unint64_t v75 = geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v289, v62);
    v304[0] = 0;
    if (*(unsigned char *)(v75 + 2))
    {
      v304[1] = *(unsigned char *)(v75 + 3);
      v304[0] = 1;
    }
    [(VKLabelNavRouteEta *)v295 setRouteLegWhen:v304];
    if (v304[0]) {
      v304[0] = 0;
    }
    if (![(VKLabelNavRouteEta *)v295 hasLabel])
    {
      uint64_t v76 = [(VKLabelNavRouteEta *)v295 orientation];
      double v77 = [*(id *)(v62 + 8) etaDescription];
      uint64_t v78 = *(unsigned __int16 *)geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v289, v62);
      geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](v289, v62);
      unint64_t v79 = v282 & 0xFFFFFFFFFFFF0000 | v78;
      unsigned int v66 = v295;
      unint64_t v282 = v79;
      -[VKLabelNavRouteEta createLabelWithNavContext:orientation:etaDescription:selected:when:routeLegWhen:artworkCache:](v295, "createLabelWithNavContext:orientation:etaDescription:selected:when:routeLegWhen:artworkCache:", a2, v76, v77, a5, *(void *)(a1 + 144));

      if (![(VKLabelNavRouteEta *)v295 hasLabel]) {
        goto LABEL_67;
      }
      float64x2_t v80 = *(md::RouteSimplifier **)(a1 + 48);
      float64x2_t v81 = [(VKRouteInfo *)v63 route];
      *(void *)int v316 = [(VKLabelNavRouteEta *)v295 routeOffset];
      double v270 = md::RouteSimplifier::worldPointForPolylineCoordinate(v80, v81, (const PolylineCoordinate *)v316);
      double v274 = *(double *)&v82;
      __p[0] = *(void **)&v270;
      __p[1] = v82;
      double v279 = v83;
      double v308 = v83;

      unsigned __int8 v84 = [(VKLabelNavRouteEta *)v295 orientation];
      v316[0] = v84;
      *(unsigned char *)(j + 136) = 0;
      uint64_t v85 = a2[3];
      if (!md::LabelLayoutContext::isDistanceClipped(v85, (uint64_t)__p))
      {
        double v86 = *(double *)(v85 + 888);
        double v87 = *(double *)(v85 + 920);
        double v88 = *(double *)(v85 + 984);
        double v89 = *(double *)(v85 + 952);
        float64x2_t v261 = *(float64x2_t *)(v85 + 864);
        float64x2_t v262 = *(float64x2_t *)(v85 + 896);
        float64x2_t v264 = *(float64x2_t *)(v85 + 928);
        float64x2_t v267 = *(float64x2_t *)(v85 + 960);
        double v90 = (float *)std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v284, v84, v316);
        float v91 = v90[7];
        float v92 = v90[5];
        if (v91 >= v92 && (float v93 = v90[8], v94 = v90[6], v93 >= v94))
        {
          float32x2_t v118 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v267, v261, v270), v262, v274), v264, v279), 1.0 / (v88 + v86 * v270 + v87 * v274 + v89 * v279)));
          float v98 = v118.f32[0] + v92;
          float v95 = v118.f32[1] + v94;
          float v97 = v118.f32[0] + v91;
          float v96 = v118.f32[1] + v93;
        }
        else
        {
          float v95 = 3.4028e38;
          float v96 = -3.4028e38;
          float v97 = -3.4028e38;
          float v98 = 3.4028e38;
        }
        *(float *)(j + 140) = v98;
        *(float *)(j + 144) = v95;
        *(float *)(j + 148) = v97;
        *(float *)(j + 152) = v96;
        *(unsigned char *)(j + 136) = 1;
      }
      float v64 = 5.0;
      float v65 = 0.5;
    }
    if (![(VKLabelNavRouteEta *)v66 hasAnchor])
    {
      *(unsigned char *)(a1 + 252) = 1;
      goto LABEL_67;
    }
    unsigned int v66 = v66;
    [(VKLabelNavRouteEta *)v66 worldPointForStaging];
    double v271 = *(double *)&v119;
    double v275 = *(double *)&v120;
    __p[0] = v119;
    __p[1] = v120;
    double v296 = v121;
    double v308 = v121;
    size_t v122 = (float64x2_t *)a2[3];
    BOOL isDistanceClipped = md::LabelLayoutContext::isDistanceClipped((uint64_t)v122, (uint64_t)__p);
    if (!isDistanceClipped) {
      float32x2_t v285 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v122[60], v122[54], v271), v122[56], v275), v122[58], v296), 1.0 / (v122[61].f64[1] + v122[55].f64[1] * v271 + v122[57].f64[1] * v275 + v122[59].f64[1] * v296)));
    }

    *(unsigned char *)(j + 156) = 0;
    float v123 = *(float *)(a2[1] + 176) * 12.0;
    float v124 = v123 * v123;
    if ((isDistanceClipped | a6))
    {
      uint64_t k = 0;
    }
    else
    {
      uint64_t v127 = [*(id *)(v62 + 8) etaDescription];
      uint64_t v128 = [v127 routeEtaType];

      if (v128)
      {
        if (!*(void *)(v62 + 40)) {
          goto LABEL_67;
        }
        unint64_t v130 = *(void **)(v62 + 16);
        uint64_t k = v130[5];
        if (k == v130[6]) {
          goto LABEL_67;
        }
LABEL_117:
        int v265 = *((_DWORD *)v130 + 8);
      }
      else
      {
        uint64_t v140 = [(VKLabelNavRouteEta *)v66 routeOffset];
        unint64_t v130 = *(void **)(v62 + 16);
        if (v130 != (void *)(v62 + 24))
        {
          LODWORD(v129) = HIDWORD(v140);
          do
          {
            for (uint64_t k = v130[5]; k != v130[6]; k += 16)
            {
              if (*(_DWORD *)k < v140
                || *(_DWORD *)k == v140 && *(float *)(k + 4) <= *((float *)&v140 + 1))
              {
                unsigned int v141 = *(_DWORD *)(k + 8);
                if (v141 > v140 || v141 == v140 && *(float *)(k + 12) >= *((float *)&v140 + 1)) {
                  goto LABEL_117;
                }
              }
            }
            unint64_t v142 = (void *)v130[1];
            if (v142)
            {
              do
              {
                uint64_t v143 = v142;
                unint64_t v142 = (void *)*v142;
              }
              while (v142);
            }
            else
            {
              do
              {
                uint64_t v143 = (void *)v130[2];
                BOOL v189 = *v143 == (void)v130;
                unint64_t v130 = v143;
              }
              while (!v189);
            }
            unint64_t v130 = v143;
          }
          while (v143 != (void *)(v62 + 24));
        }
        uint64_t k = 0;
        int v265 = 0;
      }
      uint64_t v144 = [(VKLabelNavRouteEta *)v66 routeOffset];
      unsigned int v277 = [(VKLabelNavRouteEta *)v66 orientation];
      uint64_t v145 = v63;
      if (k)
      {
        int v298 = v66;
        uint64_t v146 = *(void *)(a1 + 40);
        float64x2_t v272 = v145;
        uint64_t v147 = [(VKRouteInfo *)v145 route];
        (*(void (**)(void **__return_ptr, uint64_t, uint64_t, void *, uint64_t))(*(void *)v146 + 24))(__p, v146, a3, v147, k);

        uint64_t v149 = (PolylineCoordinate *)__p[0];
        if (__p[0] == __p[1]) {
          goto LABEL_177;
        }
        LODWORD(v148) = HIDWORD(v144);
        while (1)
        {
          if (v149->index < v144 || v149->index == v144 && v149->offset <= *((float *)&v144 + 1))
          {
            unsigned int index = v149[1].index;
            if (index > v144 || index == v144 && v149[1].offset >= *((float *)&v144 + 1)) {
              break;
            }
          }
          v149 += 2;
          if (v149 == __p[1]) {
            goto LABEL_177;
          }
        }
        if (v149 == __p[1])
        {
LABEL_177:
          int v175 = 0;
          float32x2_t v263 = *(float32x2_t *)&v148;
        }
        else
        {
          unint64_t v172 = [(VKRouteInfo *)v272 route];
          PolylineCoordinate v173 = *v149;
          PolylineCoordinate v174 = v149[1];
          md::LabelNavEtaLabeler::calculatePositioningFrame((float32x2_t *)&v314, a1, (uint64_t)a2, v172, v173, v174);
          float32x2_t v263 = (float32x2_t)v314;
          *(_OWORD *)int v316 = v314;
          *(void *)&v316[16] = v315;

          int v175 = 1;
        }
        float v176 = *(float *)(a2[1] + 176) * 12.0;
        int v269 = v175;
        if (v176 >= 0.0)
        {
          float v180 = v285.f32[0] - v176;
          float v177 = v285.f32[1] - v176;
          float v179 = v285.f32[0] + v176;
          float v178 = v285.f32[1] + v176;
        }
        else
        {
          float v177 = 3.4028e38;
          float v178 = -3.4028e38;
          float v179 = -3.4028e38;
          float v180 = 3.4028e38;
        }
        *(void *)&long long v314 = __PAIR64__(LODWORD(v177), LODWORD(v180));
        *((void *)&v314 + 1) = __PAIR64__(LODWORD(v178), LODWORD(v179));
        unint64_t v181 = *(void *)(j + 200);
        float v182 = 3.4028e38;
        if (v181 <= 4 && ((1 << v181) & 0x19) != 0)
        {
          char v183 = *(void **)(a1 + 456);
          if (v183 == v288)
          {
            float v182 = 3.4028e38;
          }
          else
          {
            unint64_t v184 = COERCE_UNSIGNED_INT(v180 + (float)((float)(v179 - v180) * v65)) | ((unint64_t)COERCE_UNSIGNED_INT(v177 + (float)((float)(v178 - v177) * v65)) << 32);
            float v182 = 3.4028e38;
            double v291 = v17;
            do
            {
              uint64_t v185 = (void *)v183[5];
              int v186 = (void *)v183[6];
              while (v185 != v186)
              {
                if (v185 != (void *)j)
                {
                  unint64_t v188 = v185[25];
                  BOOL v189 = v188 > 4 || ((1 << v188) & 0x19) == 0;
                  if (!v189 && v188 == *(void *)(j + 200))
                  {
                    uint64_t v190 = a1;
                    LODWORD(v313) = 2139095039;
                    size_t v191 = (uint64_t **)v185[12];
                    unint64_t v192 = (uint64_t **)v185[13];
                    if (v191 == v192)
                    {
                      float v187 = 3.4028e38;
                    }
                    else
                    {
                      do
                      {
                        uint64_t v193 = *v191;
                        v191 += 2;
                        md::PolylineCollider::enumerateSegmentsIntersectingBounds<md::LabelNavEtaLabeler::routeNearestDistSquaredToRectCenter(md::RouteLabelState const&,gm::Box<float,2> const&)::$_0>(v193, 0, (float *)&v314, (float *)&v313, v184);
                      }
                      while (v191 != v192);
                      float v187 = *(float *)&v313;
                    }
                    a1 = v190;
                    BOOL v17 = v291;
                    float v182 = fminf(v187, v182);
                  }
                }
                v185 += 48;
              }
              PolylineCoordinate v194 = (void *)v183[1];
              if (v194)
              {
                do
                {
                  PolylineCoordinate v195 = v194;
                  PolylineCoordinate v194 = (void *)*v194;
                }
                while (v194);
              }
              else
              {
                do
                {
                  PolylineCoordinate v195 = (void *)v183[2];
                  BOOL v189 = *v195 == (void)v183;
                  char v183 = v195;
                }
                while (!v189);
              }
              char v183 = v195;
            }
            while (v195 != v288);
          }
        }
        if (v269)
        {
          float32x2_t v196 = vsub_f32(v285, v263);
          float32x2_t v197 = vabs_f32(vmla_f32(vmul_f32(*(float32x2_t *)&v316[12], (float32x2_t)vrev64_s32((int32x2_t)v196)), v196, (float32x2_t)__PAIR64__(*(unsigned int *)&v316[20], *(unsigned int *)&v316[8])));
          unsigned __int32 v198 = vsub_f32(v197, (float32x2_t)vdup_lane_s32((int32x2_t)v197, 1)).u32[0];
        }
        else
        {
          unsigned __int32 v198 = 2139095039;
        }
        double v63 = v293;
        unsigned int v66 = v298;
        *(float *)(j + 160) = v182;
        *(_DWORD *)(j + 164) = v198;
        long long v313 = *(_OWORD *)(a2[4] + 32);
        unint64_t v199 = *(void *)(j + 56);
        if (v199)
        {
          uint8x8_t v200 = (uint8x8_t)vcnt_s8((int8x8_t)v199);
          v200.i16[0] = vaddlv_u8(v200);
          if (v200.u32[0] > 1uLL)
          {
            unint64_t v201 = v277;
            if (v199 <= v277) {
              unint64_t v201 = v277 % v199;
            }
          }
          else
          {
            unint64_t v201 = (v199 - 1) & v277;
          }
          double v202 = *(float ***)(*(void *)v284 + 8 * v201);
          if (v202)
          {
            uint64_t v203 = *v202;
            if (v203)
            {
              if (v200.u32[0] < 2uLL)
              {
                unint64_t v204 = v199 - 1;
                while (1)
                {
                  uint64_t v206 = *((void *)v203 + 1);
                  if (v206 == v277)
                  {
                    if (*((unsigned __int8 *)v203 + 16) == v277) {
                      goto LABEL_276;
                    }
                  }
                  else if ((v206 & v204) != v201)
                  {
                    goto LABEL_288;
                  }
                  uint64_t v203 = *(float **)v203;
                  if (!v203) {
                    goto LABEL_288;
                  }
                }
              }
              do
              {
                unint64_t v205 = *((void *)v203 + 1);
                if (v205 == v277)
                {
                  if (*((unsigned __int8 *)v203 + 16) == v277)
                  {
LABEL_276:
                    float v245 = v203[7];
                    float v246 = v203[5];
                    if (v245 >= v246)
                    {
                      float v251 = v203[8];
                      float v252 = v203[6];
                      BOOL v253 = v251 < v252;
                      BOOL v254 = v251 < v252;
                      float v255 = v285.f32[0] + v246;
                      float v256 = v285.f32[1] + v252;
                      float v257 = v285.f32[0] + v245;
                      float v248 = v285.f32[1] + v251;
                      if (v253)
                      {
                        float v248 = -3.4028e38;
                        float v249 = -3.4028e38;
                      }
                      else
                      {
                        float v249 = v257;
                      }
                      if (v254) {
                        float v247 = 3.4028e38;
                      }
                      else {
                        float v247 = v256;
                      }
                      if (v254) {
                        float v250 = 3.4028e38;
                      }
                      else {
                        float v250 = v255;
                      }
                    }
                    else
                    {
                      float v247 = 3.4028e38;
                      float v248 = -3.4028e38;
                      float v249 = -3.4028e38;
                      float v250 = 3.4028e38;
                    }
                    v312[0] = v250;
                    v312[1] = v247;
                    v312[2] = v249;
                    v312[3] = v248;
                    md::LabelNavEtaLabeler::scoreEtaLabelRect((uint64_t)&v314, (void *)a1, v284, v312, (float *)&v313);
                    *(_OWORD *)(j + 168) = v314;
                    *(void *)(j + 184) = v315;
                    *(_DWORD *)(j + 192) = v265;
                    break;
                  }
                }
                else
                {
                  if (v205 >= v199) {
                    v205 %= v199;
                  }
                  if (v205 != v201) {
                    break;
                  }
                }
                uint64_t v203 = *(float **)v203;
              }
              while (v203);
            }
          }
        }
LABEL_288:
        if (__p[0])
        {
          __p[1] = __p[0];
          operator delete(__p[0]);
        }
        uint64_t k = j + 160;

        *(unsigned char *)(j + 156) = 1;
        uint64_t v258 = *(void *)(j + 200);
        if (v258 == 1)
        {
          if (*(unsigned char *)(j + 188) && *(float *)(j + 184) <= 0.3) {
            goto LABEL_237;
          }
        }
        else
        {
          BOOL v259 = *(float *)k < v124
              || (float)((float)(*(float *)(j + 172) + *(float *)(j + 168))
                       + (float)(*(float *)(j + 176) + *(float *)(j + 180))) >= 1.0
              || *(_DWORD *)(j + 128) < *(_DWORD *)(j + 192);
          if (v258 == 3)
          {
            char v260 = *(float *)(j + 176) >= 1.0 || v259;
            if ((v260 & 1) == 0) {
              goto LABEL_237;
            }
          }
          else if (!v259)
          {
            goto LABEL_237;
          }
        }
      }
      else
      {
      }
    }
    __p[0] = (void *)0xBF80000000000000;
    HIDWORD(__p[1]) = 2139095039;
    double v309 = 0.0;
    uint64_t v310 = 0;
    double v308 = 0.0;
    char v311 = 1;
    if (!k) {
      goto LABEL_123;
    }
    BOOL v126 = *(float *)k < v124 || *(float *)(k + 12) >= 1.0;
    if (*(void *)(j + 200) == 3)
    {
      if (*(float *)(k + 16) >= 1.0) {
        LOBYTE(v126) = 1;
      }
      if (!v126) {
        goto LABEL_123;
      }
    }
    else if (!v126)
    {
LABEL_123:
      int v131 = 0;
      goto LABEL_126;
    }
    uint64_t k = 0;
    int v131 = 1;
LABEL_126:
    int v132 = md::LabelNavEtaLabeler::searchForPlacementAcrossShareSections(a1, a2, a3, v284, v62, k, (uint64_t)__p);
    *(double *)(j + 208) = a7;
    *(unsigned char *)(j + 216) = v132;
    if (v132)
    {
      uint64_t v133 = v63;
      unsigned int v66 = v66;
      uint64_t v134 = *(md::RouteSimplifier **)(a1 + 48);
      uint64_t v135 = [(VKRouteInfo *)v133 route];
      double v276 = md::RouteSimplifier::worldPointForPolylineCoordinate(v134, v135, (const PolylineCoordinate *)__p);
      double v297 = v136;
      double locationc = v137;

      if (isDistanceClipped)
      {
        BOOL v138 = 1;
      }
      else
      {
        unsigned int v151 = (float64x2_t *)a2[3];
        float32x2_t v152 = vsub_f32(vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v151[60], v151[54], v276), v151[56], v297), v151[58], locationc), 1.0/ (v151[61].f64[1] + v151[55].f64[1] * v276 + v151[57].f64[1] * v297 + v151[59].f64[1] * locationc))), v285);
        BOOL v138 = sqrtf(vaddv_f32(vmul_f32(v152, v152))) > (float)(*(float *)(a2[1] + 176) * v64);
      }
      [(VKLabelNavRouteEta *)v66 worldPointForStaging];
      *(double *)int v316 = v153;
      *(double *)&v316[8] = v154;
      *(double *)&v316[16] = v155;
      if (v138)
      {
        *(double *)&long long v156 = v276;
        *((double *)&v156 + 1) = v297;
        *(_OWORD *)int v316 = v156;
        *(double *)&v316[16] = locationc;
        [(VKLabelNavRouteEta *)v66 repositionAtRouteCoord:__p[0]];
      }
      else
      {
        double v297 = v154;
        double locationc = v155;
        double v276 = v153;
      }
      unsigned __int8 v157 = __p[1];
      [(VKLabelNavRouteEta *)v66 setOrientation:LOBYTE(__p[1])];
      LOBYTE(v314) = v157;
      *(unsigned char *)(j + 136) = 0;
      uint64_t v158 = a2[3];
      if (!md::LabelLayoutContext::isDistanceClipped(v158, (uint64_t)v316))
      {
        double v159 = *(double *)(v158 + 888);
        double v160 = *(double *)(v158 + 920);
        double v161 = *(double *)(v158 + 984);
        double v162 = *(double *)(v158 + 952);
        float64x2_t v266 = *(float64x2_t *)(v158 + 864);
        float64x2_t v268 = *(float64x2_t *)(v158 + 896);
        float64x2_t v281 = *(float64x2_t *)(v158 + 960);
        float64x2_t v273 = *(float64x2_t *)(v158 + 928);
        uint64_t v163 = (float *)std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,gm::Box<float,2>>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v284, v157, &v314);
        float v164 = v163[7];
        float v165 = v163[5];
        if (v164 >= v165 && (float v166 = v163[8], v167 = v163[6], v166 >= v167))
        {
          float32x2_t v207 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v281, v266, v276), v268, v297), v273, locationc), 1.0 / (v161 + v159 * v276 + v160 * v297 + v162 * locationc)));
          float v171 = v207.f32[0] + v165;
          float v168 = v207.f32[1] + v167;
          float v170 = v207.f32[0] + v164;
          float v169 = v207.f32[1] + v166;
        }
        else
        {
          float v168 = 3.4028e38;
          float v169 = -3.4028e38;
          float v170 = -3.4028e38;
          float v171 = 3.4028e38;
        }
        *(float *)(j + 140) = v171;
        *(float *)(j + 144) = v168;
        *(float *)(j + 148) = v170;
        *(float *)(j + 152) = v169;
        *(unsigned char *)(j + 136) = 1;
      }

      float v64 = 5.0;
      float v65 = 0.5;
    }
    else
    {
      if (v131)
      {
        std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::__erase_unique<VKLabelNavRouteEta * {__strong}>(v283, (unint64_t)v66);
        id v139 = *locationa;
        if (*locationa)
        {
          id *locationa = 0;
        }
        goto LABEL_67;
      }
      if (isDistanceClipped) {
        goto LABEL_67;
      }
    }
LABEL_237:
    if ([(VKLabelNavRouteEta *)v66 hasLabelWithAnchor])
    {
      unsigned int v66 = v66;
      *(_OWORD *)std::string __p = xmmword_1A28FCDD0;
      double v308 = 0.0;
      [(VKLabelNavRouteEta *)v66 worldPointForStaging];
      *(void *)int v316 = v208;
      *(void *)&v316[8] = v209;
      *(void *)&v316[16] = v210;
      [(VKLabelNavRouteEta *)v66 worldUnitsPerMeterAtPoint];
      uint64_t v211 = a2[3];
      LOBYTE(v314) = 0;
      BYTE12(v314) = 0;
      BOOL v212 = 1;
      md::LabelLayoutContext::evaluateWorldPoint(v211, (uint64_t)v316, (uint64_t)&v314, 1u, 0, (uint64_t)__p, v213);
      LODWORD(v214) = HIDWORD(__p[0]);
      if (*((float *)__p + 1) >= 0.905)
      {
        uint64_t v215 = [(VKLabelNavRouteEta *)v66 displayEtaDescription];
        unint64_t v216 = [v215 routeEtaType];
        if (v216 <= 4 && ((1 << v216) & 0x19) != 0)
        {

          BOOL v212 = 0;
        }
        else
        {

          BOOL v212 = v309 < 1500.0;
        }
      }

      uint64_t v217 = [(VKLabelNavRouteEta *)v66 label];
      v218 = *(unsigned char **)[v217 label];
      v218[297] = v212;
      if (v218[296]) {
        v218[298] = v212;
      }

      double v220 = *(void **)(a1 + 296);
      unint64_t v219 = *(void *)(a1 + 304);
      if ((unint64_t)v220 < v219)
      {
        if (v220) {
          *double v220 = v66;
        }
        *(void *)(a1 + 296) = v220 + 1;
        goto LABEL_67;
      }
      uint64_t v221 = *(void *)(a1 + 288);
      uint64_t v222 = ((uint64_t)v220 - v221) >> 3;
      v299 = v66;
      if ((unint64_t)(v222 + 1) >> 61) {
        abort();
      }
      uint64_t v223 = v219 - v221;
      uint64_t v224 = v223 >> 2;
      if (v223 >> 2 <= (unint64_t)(v222 + 1)) {
        uint64_t v224 = v222 + 1;
      }
      if ((unint64_t)v223 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v225 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v225 = v224;
      }
      if (v225)
      {
        uint64_t v226 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 312) + 16))(*(void *)(a1 + 312), 8 * v225, 8);
        uint64_t v227 = (void *)(v226 + 8 * v222);
        uint64_t v228 = v226 + 8 * v225;
        if (v226) {
          *uint64_t v227 = v299;
        }
      }
      else
      {
        uint64_t v228 = 0;
        uint64_t v227 = (void *)(8 * v222);
      }
      float v229 = v227 + 1;
      float v230 = *(char **)(a1 + 288);
      float v231 = *(char **)(a1 + 296);
      if (v231 == v230)
      {
        *(void *)(a1 + 288) = v227;
        *(void *)(a1 + 296) = v229;
        uint64_t v237 = *(void *)(a1 + 304);
        *(void *)(a1 + 304) = v228;
LABEL_269:
        if (v231) {
          (*(void (**)(void, char *, uint64_t))(**(void **)(a1 + 312) + 40))(*(void *)(a1 + 312), v231, v237 - (void)v231);
        }
        unsigned int v66 = v299;
        *(void *)(a1 + 296) = v229;
        goto LABEL_67;
      }
      unint64_t v232 = v231 - v230 - 8;
      if (v232 > 0x57
        && ((unint64_t v233 = (v230 - v231 + 7) & 0xFFFFFFFFFFFFFFF8, &v231[v233] >= (char *)v227) || (char *)v227 + v233 >= v231))
      {
        uint64_t v239 = (v232 >> 3) + 1;
        float v234 = &v231[-8 * (v239 & 0x3FFFFFFFFFFFFFFCLL)];
        float v240 = v227 - 2;
        float v241 = (long long *)(v231 - 32);
        uint64_t v242 = v239 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v244 = *v241;
          long long v243 = v241[1];
          *float v241 = 0uLL;
          v241[1] = 0uLL;
          v241 -= 2;
          *(v240 - 1) = v244;
          _OWORD *v240 = v243;
          v240 -= 2;
          v242 -= 4;
        }
        while (v242);
        v227 -= v239 & 0x3FFFFFFFFFFFFFFCLL;
        if (v239 == (v239 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_265:
          float v231 = *(char **)(a1 + 288);
          float v236 = *(char **)(a1 + 296);
          *(void *)(a1 + 288) = v227;
          *(void *)(a1 + 296) = v229;
          uint64_t v237 = *(void *)(a1 + 304);
          *(void *)(a1 + 304) = v228;
          while (v236 != v231)
          {
            float v238 = (void *)*((void *)v236 - 1);
            v236 -= 8;
          }
          goto LABEL_269;
        }
      }
      else
      {
        float v234 = *(char **)(a1 + 296);
      }
      do
      {
        uint64_t v235 = *((void *)v234 - 1);
        v234 -= 8;
        *(void *)float v234 = 0;
        *--uint64_t v227 = v235;
      }
      while (v234 != v230);
      goto LABEL_265;
    }
LABEL_67:

    uint64_t v61 = v294;
    goto LABEL_68;
  }
LABEL_306:
}

void sub_1A1F9486C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,__int16 a50,char a51,char a52,char a53,char a54,char a55,void *__p,uint64_t a57)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

uint64_t std::vector<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::__push_back_slow_path<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0xAAAAAAAAAAAAAAALL;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) < 0x555555555555555) {
    uint64_t v2 = v4;
  }
  if (v2)
  {
    uint64_t v7 = 24 * v2;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 24 * v2, 8);
    uint64_t v9 = v8 + 24 * v3;
    uint64_t v10 = v8 + v7;
    if (v8)
    {
      *(void *)uint64_t v9 = off_1EF559858;
      unint64_t v11 = v8 + 24 * v3;
      *(void *)(v11 + 8) = 0;
      objc_storeStrong((id *)(v11 + 8), *(id *)(a2 + 8));
      uint64_t v12 = *(void **)(a2 + 8);
      *(void *)(a2 + 8) = 0;
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 8 * ((a1[1] - *a1) >> 3);
  }
  uint64_t v13 = v9 + 24;
  unint64_t v15 = (char *)*a1;
  BOOL v14 = (char *)a1[1];
  if (v14 == (char *)*a1)
  {
    *a1 = v9;
    a1[1] = v13;
    uint64_t v19 = (char *)a1[2];
    a1[2] = v10;
    if (!v14) {
      return v13;
    }
    goto LABEL_18;
  }
  uint64_t v16 = v9 - 24;
  do
  {
    *(void *)(v9 - 24) = off_1EF559858;
    v9 -= 24;
    *(void *)(v9 + 8) = 0;
    objc_storeStrong((id *)(v9 + 8), *((id *)v14 - 2));
    BOOL v17 = (void *)*((void *)v14 - 2);
    *((void *)v14 - 2) = 0;

    v16 -= 24;
    v14 -= 24;
  }
  while (v14 != v15);
  BOOL v14 = (char *)*a1;
  unint64_t v18 = (char *)a1[1];
  *a1 = v9;
  a1[1] = v13;
  uint64_t v19 = (char *)a1[2];
  a1[2] = v10;
  if (v18 != v14)
  {
    unint64_t v20 = v18 - 24;
    unint64_t v21 = v18 - 24;
    double v22 = v18 - 24;
    do
    {
      unint64_t v23 = *(void (***)(char *))v22;
      v22 -= 24;
      (*v23)(v21);
      v20 -= 24;
      BOOL v24 = v21 == v14;
      unint64_t v21 = v22;
    }
    while (!v24);
  }
  if (v14) {
LABEL_18:
  }
    (*(void (**)(uint64_t, char *, int64_t))(*(void *)a1[3] + 40))(a1[3], v14, v19 - v14);
  return v13;
}

uint64_t std::vector<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,geo::StdAllocator<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,mdm::Allocator>>::__push_back_slow_path<geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0xAAAAAAAAAAAAAAALL;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) < 0x555555555555555) {
    uint64_t v2 = v4;
  }
  if (v2)
  {
    uint64_t v7 = 24 * v2;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 24 * v2, 8);
    uint64_t v9 = v8 + 24 * v3;
    uint64_t v10 = v8 + v7;
    if (v8)
    {
      *(void *)uint64_t v9 = off_1EF559858;
      unint64_t v11 = v8 + 24 * v3;
      *(void *)(v11 + 8) = 0;
      id v12 = *(id *)(a2 + 8);
      uint64_t v13 = *(void **)(v11 + 8);
      *(void *)(v11 + 8) = v12;
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v9 = 8 * ((a1[1] - *a1) >> 3);
  }
  uint64_t v14 = v9 + 24;
  uint64_t v16 = (char *)*a1;
  unint64_t v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v9;
    a1[1] = v14;
    unint64_t v20 = (char *)a1[2];
    a1[2] = v10;
    if (!v15) {
      return v14;
    }
    goto LABEL_18;
  }
  uint64_t v17 = v9 - 24;
  do
  {
    *(void *)(v9 - 24) = off_1EF559858;
    v9 -= 24;
    *(void *)(v9 + 8) = 0;
    objc_storeStrong((id *)(v9 + 8), *((id *)v15 - 2));
    unint64_t v18 = (void *)*((void *)v15 - 2);
    *((void *)v15 - 2) = 0;

    v17 -= 24;
    v15 -= 24;
  }
  while (v15 != v16);
  unint64_t v15 = (char *)*a1;
  uint64_t v19 = (char *)a1[1];
  *a1 = v9;
  a1[1] = v14;
  unint64_t v20 = (char *)a1[2];
  a1[2] = v10;
  if (v19 != v15)
  {
    unint64_t v21 = v19 - 24;
    double v22 = v19 - 24;
    unint64_t v23 = v19 - 24;
    do
    {
      BOOL v24 = *(void (***)(char *))v23;
      v23 -= 24;
      (*v24)(v22);
      v21 -= 24;
      BOOL v25 = v22 == v15;
      double v22 = v23;
    }
    while (!v25);
  }
  if (v15) {
LABEL_18:
  }
    (*(void (**)(uint64_t, char *, int64_t))(*(void *)a1[3] + 40))(a1[3], v15, v20 - v15);
  return v14;
}

void *geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>::operator[](uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8)) {
    goto LABEL_4;
  }
  while (1)
  {
    char v5 = md::RouteRangeAnnotationRequest::operator==((id *)a2, (uint64_t)v4);
    id v6 = *(void **)(a1 + 8);
    if (v5) {
      break;
    }
    v4 += 9;
    if (v4 == v6) {
      goto LABEL_4;
    }
  }
  if (v4 == v6)
  {
LABEL_4:
    id v34 = *(id *)a2;
    id v7 = *(id *)(a2 + 8);
    uint64_t v8 = *(void *)(a2 + 32);
    v37[0] = 0;
    v37[1] = v8;
    v37[2] = 0;
    id v35 = v7;
    unint64_t v36 = v37;
    std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>((uint64_t *)&v36, *(void **)(a2 + 16), (void *)(a2 + 24));
    uint64_t v38 = &unk_1EF559818;
    v39[0] = 0;
    objc_storeStrong(v39, 0);

    unint64_t v4 = *(void **)a1;
    if (*(void *)a1 != *(void *)(a1 + 8))
    {
      while (1)
      {
        char v9 = md::RouteRangeAnnotationRequest::operator==(&v34, (uint64_t)v4);
        uint64_t v10 = *(void **)(a1 + 8);
        if (v9) {
          break;
        }
        v4 += 9;
        if (v4 == v10)
        {
          unint64_t v4 = *(void **)(a1 + 8);
          goto LABEL_11;
        }
      }
      if (v4 != v10) {
        goto LABEL_37;
      }
    }
LABEL_11:
    unint64_t v11 = *(void *)(a1 + 16);
    if ((unint64_t)v4 < v11)
    {
      std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::pair[abi:nn180100](v4, (uint64_t)&v34);
      id v12 = v4 + 9;
      *(void *)(a1 + 8) = v4 + 9;
LABEL_36:
      *(void *)(a1 + 8) = v12;
      unint64_t v4 = v12 - 9;
LABEL_37:
      uint64_t v38 = &unk_1EF559818;

      std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)&v36, v37[0]);
      return v4 + 6;
    }
    unint64_t v13 = 0x8E38E38E38E38E39 * (((uint64_t)v4 - *(void *)a1) >> 3);
    if (v13 + 1 > 0x38E38E38E38E38ELL) {
      abort();
    }
    unint64_t v14 = 0x8E38E38E38E38E39 * ((uint64_t)(v11 - *(void *)a1) >> 3);
    uint64_t v15 = 2 * v14;
    if (2 * v14 <= v13 + 1) {
      uint64_t v15 = v13 + 1;
    }
    if (v14 >= 0x1C71C71C71C71C7) {
      unint64_t v16 = 0x38E38E38E38E38ELL;
    }
    else {
      unint64_t v16 = v15;
    }
    uint64_t v43 = a1 + 16;
    if (v16)
    {
      if (v16 > 0x38E38E38E38E38ELL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v17 = (char *)operator new(72 * v16);
    }
    else
    {
      uint64_t v17 = 0;
    }
    v39[2] = v17;
    unint64_t v40 = &v17[72 * v13];
    double v41 = v40;
    id v42 = &v17[72 * v16];
    std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::pair[abi:nn180100](v40, (uint64_t)&v34);
    unint64_t v18 = v40;
    id v12 = v41 + 72;
    v41 += 72;
    unint64_t v20 = *(void **)a1;
    uint64_t v19 = *(void **)(a1 + 8);
    if (v19 == *(void **)a1)
    {
      *(void *)a1 = v40;
      *(void *)(a1 + 8) = v12;
      *(void *)(a1 + 16) = v42;
    }
    else
    {
      uint64_t v21 = 0;
      do
      {
        BOOL v24 = &v18[v21 * 8];
        BOOL v25 = (char *)&v19[v21];
        long long v26 = *(_OWORD *)&v19[v21 - 9];
        *((void *)v25 - 9) = 0;
        *((void *)v25 - 8) = 0;
        *(_OWORD *)(v24 - 72) = v26;
        *((void *)v24 - 7) = v19[v21 - 7];
        uint64_t v27 = (uint64_t)&v18[v21 * 8 - 48];
        *((_OWORD *)v24 - 3) = *(_OWORD *)&v19[v21 - 6];
        uint64_t v28 = v19[v21 - 4];
        *((void *)v24 - 4) = v28;
        if (v28)
        {
          *(void *)(*(void *)v27 + 16) = v27;
          *((void *)v25 - 7) = v25 - 48;
          *((void *)v25 - 6) = 0;
          *((void *)v25 - 4) = 0;
        }
        else
        {
          *((void *)v24 - 7) = v27;
        }
        *(void *)&v18[v21 * 8 - 16] = 0;
        double v22 = (id *)&v18[v21 * 8 - 16];
        *(v22 - 1) = &unk_1EF559818;
        objc_storeStrong(v22, (id)v19[v21 - 2]);
        unint64_t v23 = (void *)v19[v21 - 2];
        v19[v21 - 2] = 0;

        v21 -= 9;
      }
      while (&v19[v21] != v20);
      uint64_t v29 = &v18[v21 * 8];
      uint64_t v19 = *(void **)a1;
      double v30 = *(void **)(a1 + 8);
      *(void *)a1 = v29;
      *(void *)(a1 + 8) = v12;
      *(void *)(a1 + 16) = v42;
      if (v30 == v19)
      {
        if (!v19) {
          goto LABEL_36;
        }
        goto LABEL_35;
      }
      unint64_t v31 = (char *)(v30 - 3);
      do
      {
        *(v30 - 3) = &unk_1EF559818;

        std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(v30 - 7), *(v30 - 6));
        float64x2_t v32 = (void *)*(v30 - 9);
        v30 -= 9;

        v31 -= 72;
      }
      while (v30 != v19);
    }
    if (!v19) {
      goto LABEL_36;
    }
LABEL_35:
    operator delete(v19);
    goto LABEL_36;
  }
  return v4 + 6;
}

void sub_1A1F952BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, ...)
{
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  std::__split_buffer<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>::~__split_buffer((uint64_t)va1);
  std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~pair((uint64_t)va);

  _Unwind_Resume(a1);
}

void **geo::linear_map<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>>::~linear_map(void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    unint64_t v3 = (char *)a1[1];
    unint64_t v4 = *a1;
    if (v3 != v2)
    {
      char v5 = v3 - 24;
      do
      {
        *((void *)v3 - 3) = &unk_1EF559818;

        std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(v3 - 56), *((void *)v3 - 6));
        uint64_t v6 = (void *)*((void *)v3 - 9);
        v3 -= 72;

        v5 -= 72;
      }
      while (v3 != v2);
      unint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

uint64_t md::LabelNavEtaLabeler::searchForPlacementAcrossShareSections(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  id v7 = a4;
  uint64_t v10 = a4[38];
  for (uint64_t i = a4[39]; i != v10; i -= 72)
  {
    uint64_t v12 = *(void **)(i - 24);
    if (v12)
    {
      do
      {
        uint64_t v13 = (void *)*v12;
        operator delete(v12);
        uint64_t v12 = v13;
      }
      while (v13);
    }
    uint64_t v14 = *(void **)(i - 40);
    *(void *)(i - 40) = 0;
    if (v14) {
      operator delete(v14);
    }
  }
  v7[39] = v10;
  uint64_t v15 = (void *)a2[3];
  v7[22] = v15[108];
  v7[23] = v15[109];
  v7[24] = v15[110];
  v7[25] = v15[111];
  v7[26] = v15[112];
  v7[27] = v15[113];
  v7[28] = v15[114];
  v7[29] = v15[115];
  v7[30] = v15[116];
  v7[31] = v15[117];
  v7[32] = v15[118];
  v7[33] = v15[119];
  v7[34] = v15[120];
  v7[35] = v15[121];
  v7[36] = v15[122];
  v7[37] = v15[123];
  unint64_t v16 = *(void **)(a5 + 16);
  if (v16 == (void *)(a5 + 24)) {
    return 0;
  }
  double v74 = v7 + 38;
  float v17 = 12.0;
  unint64_t v72 = v7;
  while (1)
  {
    id v18 = *(id *)a5;
    unsigned int v66 = *((unsigned __int8 *)v16 + 32);
    id v19 = v18;
    unint64_t v20 = v19;
    char v70 = v16;
    uint64_t v21 = v16[6] - v16[5];
    if (v21) {
      break;
    }

LABEL_67:
    unint64_t v56 = v70;
    float v57 = (void *)v70[1];
    if (v57)
    {
      do
      {
        uint64_t v58 = v57;
        float v57 = (void *)*v57;
      }
      while (v57);
    }
    else
    {
      do
      {
        uint64_t v58 = (void *)v56[2];
        BOOL v59 = *v58 == (void)v56;
        unint64_t v56 = v58;
      }
      while (!v59);
    }
    unint64_t v16 = v58;
    if (v58 == (void *)(a5 + 24)) {
      return 0;
    }
  }
  unsigned int v68 = 0;
  float v22 = *(float *)(a2[1] + 176);
  long long v75 = *(_OWORD *)(a2[4] + 32);
  unint64_t v23 = v21 >> 4;
  uint64_t v102 = 0x7F7FFFFF00000000;
  float32x2_t v96 = 0;
  uint64_t v97 = 0;
  float v98 = 0.0;
  char v99 = 1;
  unsigned __int8 v95 = -1;
  char v94 = 0;
  PolylineCoordinate v92 = (PolylineCoordinate)0xBF80000000000000;
  PolylineCoordinate v93 = (PolylineCoordinate)0xBF80000000000000;
  float v91 = 0.0;
  float v24 = v22 * v17;
  float v25 = v22 * 40.0;
  if (v23 <= 1) {
    unint64_t v23 = 1;
  }
  unint64_t v69 = v23;
  id v73 = v19;
  while (2)
  {
    uint64_t v26 = 0;
    do
    {
      uint64_t v71 = v26;
      (*(void (**)(PolylineCoordinate **__return_ptr))(**(void **)(a1 + 40) + 24))(&v89);
      uint64_t v27 = v89;
      uint64_t v76 = v90;
      if (v89 == v90)
      {
        if (v89) {
          goto LABEL_44;
        }
      }
      else
      {
        do
        {
          PolylineCoordinate v28 = *v27;
          PolylineCoordinate v29 = v27[1];
          md::LabelNavEtaLabeler::calculatePositioningFrame((float32x2_t *)&v87, a1, (uint64_t)a2, v20, v28, v29);
          *(void *)&long long v81 = a1;
          *((void *)&v81 + 1) = v7;
          *(void *)&long long v82 = &v102;
          *((void *)&v82 + 1) = &v96;
          *(void *)&long long v83 = &v95;
          *((void *)&v83 + 1) = &v94;
          *(void *)&long long v84 = &v93;
          *((void *)&v84 + 1) = &v92;
          *(void *)&long long v85 = &v91;
          *((void *)&v85 + 1) = v74;
          *(float *)double v86 = v24;
          *(_OWORD *)&v86[4] = v87;
          *(void *)&v86[20] = v88;
          *(_OWORD *)&v86[28] = v75;
          *(float *)&v86[44] = v24 * v24;
          double v30 = v20;
          (*(void (**)(char **__return_ptr))(**(void **)(a1 + 40) + 24))(&v119);
          unint64_t v31 = v119;
          float64x2_t v32 = v120;
          double v77 = v27;
          if (v120 - v119 == 16
            && *(_DWORD *)v119 == *((_DWORD *)v119 + 2)
            && vabds_f32(*((float *)v119 + 1), *((float *)v119 + 3)) < 0.00000011921)
          {
            double v33 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(a1 + 48), v30, (const PolylineCoordinate *)v119);
            id v34 = (float64x2_t *)a2[3];
            *(float32x2_t *)&long long v123 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v34[60], v34[54], v33), v34[56], v35), v34[58], v36), 1.0/ (v34[61].f64[1]+ v34[55].f64[1] * v33+ v34[57].f64[1] * v35+ v34[59].f64[1] * v36)));
            md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)const::$_0::operator()((uint64_t)&v81, (float *)&v123, *(void *)v119, *((void *)v119 + 1), 0.0);
          }
          else
          {
            while (v31 != v32)
            {
              float v118 = v25;
              char v117 = 1;
              unint64_t v115 = 0xBF80000000000000;
              float v37 = *(float *)(a2[1] + 176);
              v103[0] = a1;
              v103[1] = &v118;
              v103[2] = &v117;
              v103[3] = &v116;
              v103[4] = &v115;
              int v104 = v30;
              uint64_t v105 = a2;
              float v106 = v25;
              long long v111 = v85;
              long long v112 = *(_OWORD *)v86;
              long long v113 = *(_OWORD *)&v86[16];
              long long v114 = *(_OWORD *)&v86[32];
              long long v107 = v81;
              long long v108 = v82;
              long long v109 = v83;
              long long v110 = v84;
              uint64_t v38 = v104;
              unsigned int v39 = *((_DWORD *)v31 + 2);
              float v40 = *((float *)v31 + 1);
              if (*(_DWORD *)v31 != v39 || vabds_f32(v40, *((float *)v31 + 3)) >= 0.00000011921)
              {
                if (v40 != 0.0)
                {
                  md::LabelNavEtaLabeler::sampleSimplifiedRouteSection<md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0>(md::NavContext const*,geo::Frustum<double> const&,GEOComposedRoute *,gm::Range<geo::PolylineCoordinate> const&,float,md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0)const::{lambda(geo::PolylineCoordinate)#1}::operator()((uint64_t)v103, *(void *)v31);
                  float v40 = *((float *)v31 + 1);
                  unsigned int v39 = *((_DWORD *)v31 + 2);
                }
                if (v40 <= 0.0) {
                  unsigned int v41 = *(_DWORD *)v31;
                }
                else {
                  unsigned int v41 = *(_DWORD *)v31 + 1;
                }
                if (v41 == v39)
                {
                  md::LabelNavEtaLabeler::sampleSimplifiedRouteSection<md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0>(md::NavContext const*,geo::Frustum<double> const&,GEOComposedRoute *,gm::Range<geo::PolylineCoordinate> const&,float,md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0)const::{lambda(geo::PolylineCoordinate)#1}::operator()((uint64_t)v103, v39);
                }
                else if (v41 < v39)
                {
                  uint64_t v42 = a2[3];
                  long long v123 = *(_OWORD *)(v42 + 136);
                  uint64_t v124 = *(void *)(v42 + 152);
                  long long v125 = *(_OWORD *)(v42 + 160);
                  uint64_t v126 = *(void *)(v42 + 176);
                  uint64_t v43 = *(void *)(a1 + 40);
                  v121[0] = v41;
                  v121[1] = v39;
                  if ((*(unsigned int (**)(uint64_t, uint64_t, const GEOComposedRoute *, long long *, _DWORD *, double *))(*(void *)v43 + 32))(v43, a3, v38, &v123, v121, v122))
                  {
                    md::RouteSimplifier::simplifiedRibbonIndices(*(void *)(a1 + 48), v38, v41, v39, (void *)(a1 + 80), v37 * ((v122[0] + v122[0]) * *(double *)(v42 + 312)) / *(float *)(v42 + 1064));
                    uint64_t v45 = *(unsigned int **)(a1 + 80);
                    for (uint64_t j = *(unsigned int **)(a1 + 88); v45 != j; ++v45)
                      md::LabelNavEtaLabeler::sampleSimplifiedRouteSection<md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0>(md::NavContext const*,geo::Frustum<double> const&,GEOComposedRoute *,gm::Range<geo::PolylineCoordinate> const&,float,md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0)const::{lambda(geo::PolylineCoordinate)#1}::operator()((uint64_t)v103, *v45);
                  }
                }
                if (*((float *)v31 + 3) != 0.0) {
                  md::LabelNavEtaLabeler::sampleSimplifiedRouteSection<md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0>(md::NavContext const*,geo::Frustum<double> const&,GEOComposedRoute *,gm::Range<geo::PolylineCoordinate> const&,float,md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0)const::{lambda(geo::PolylineCoordinate)#1}::operator()((uint64_t)v103, *((void *)v31 + 1));
                }
              }

              v31 += 16;
            }
          }
          if (v119)
          {
            unint64_t v120 = v119;
            operator delete(v119);
          }

          uint64_t v27 = v77 + 2;
          id v7 = v72;
          unint64_t v20 = v73;
        }
        while (&v77[2] != v76);
        uint64_t v27 = v89;
        if (v89)
        {
LABEL_44:
          double v90 = v27;
          operator delete(v27);
        }
      }
      uint64_t v26 = v71 + 1;
    }
    while (v71 + 1 != v69);
    if (v95 == 255)
    {
      float v25 = v25 * 0.5;
      if (v68++ < 2) {
        continue;
      }
    }
    break;
  }
  if (v95 == 255) {
    goto LABEL_66;
  }
  uint64_t v47 = v97;
  float v48 = v98;
  char v49 = v99;
  LOWORD(v103[0]) = v100;
  BYTE2(v103[0]) = v101;
  if (!a6) {
    goto LABEL_74;
  }
  if (v7[19] != 1)
  {
    float v52 = *(float *)(a2[1] + 176);
    float v53 = vaddv_f32(v96) + (float)(*(float *)&v97 + *((float *)&v97 + 1));
    float v54 = (float)(*(float *)(a6 + 12) + *(float *)(a6 + 8)) + (float)(*(float *)(a6 + 16) + *(float *)(a6 + 20));
    if (vabds_f32(v53, v54) <= (float)(v52 * 100.0))
    {
      unsigned int v55 = *(_DWORD *)(a6 + 32);
      if (v55 == v66)
      {
        if (*((float *)&v102 + 1) < (float)(*(float *)(a6 + 4) + (float)(v52 * -20.0))) {
          goto LABEL_74;
        }
      }
      else if (v55 > v66)
      {
        goto LABEL_74;
      }
    }
    else if (v53 < v54)
    {
      goto LABEL_74;
    }
LABEL_66:

    float v17 = 12.0;
    goto LABEL_67;
  }
  float v50 = 0.0;
  if (v99) {
    float v51 = v98;
  }
  else {
    float v51 = 0.0;
  }
  if (*(unsigned char *)(a6 + 28)) {
    float v50 = *(float *)(a6 + 24);
  }
  if (vabds_f32(v51, v50) <= 0.3) {
    goto LABEL_66;
  }
LABEL_74:
  float32x2_t v78 = v96;
  uint64_t v80 = v102;
  PolylineCoordinate v62 = v92;
  PolylineCoordinate v61 = v93;
  *(void *)a7 = md::LabelNavEtaLabeler::findClosestCoordinateBetweenVertices(a1, (float64x2_t *)(a2[3] + 864), v20, v61, v62, v91);
  *(unsigned char *)(a7 + 8) = v94;
  *(void *)&long long v63 = v80;
  *((float32x2_t *)&v63 + 1) = v78;
  *(_OWORD *)(a7 + 12) = v63;
  *(void *)(a7 + 28) = v47;
  *(float *)(a7 + 36) = v48;
  *(unsigned char *)(a7 + 40) = v49;
  *(_WORD *)(a7 + 41) = v103[0];
  *(unsigned char *)(a7 + 43) = BYTE2(v103[0]);
  *(_DWORD *)(a7 + 44) = v66;

  return 1;
}

void sub_1A1F95C10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *__p,uint64_t a54)
{
  _Unwind_Resume(a1);
}

unint64_t geo::linear_map<md::RouteRangeAnnotationRequest,md::WhenState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>>::operator[](unint64_t *a1, uint64_t a2)
{
  unint64_t v4 = *a1;
  if (*a1 == a1[1]) {
    goto LABEL_4;
  }
  while (1)
  {
    char v5 = md::RouteRangeAnnotationRequest::operator==((id *)a2, v4);
    unint64_t v6 = a1[1];
    if (v5) {
      break;
    }
    v4 += 56;
    if (v4 == v6) {
      goto LABEL_4;
    }
  }
  if (v4 == v6)
  {
LABEL_4:
    id v30 = *(id *)a2;
    id v7 = *(id *)(a2 + 8);
    uint64_t v8 = *(void *)(a2 + 32);
    v33[0] = 0;
    v33[1] = v8;
    v33[2] = 0;
    id v31 = v7;
    float64x2_t v32 = v33;
    std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>((uint64_t *)&v32, *(void **)(a2 + 16), (void *)(a2 + 24));
    __int16 v34 = 0;
    char v35 = 0;
    unint64_t v4 = *a1;
    if (*a1 == a1[1]) {
      goto LABEL_11;
    }
    while (1)
    {
      char v9 = md::RouteRangeAnnotationRequest::operator==(&v30, v4);
      unint64_t v10 = a1[1];
      if (v9) {
        break;
      }
      v4 += 56;
      if (v4 == v10)
      {
        unint64_t v4 = a1[1];
        goto LABEL_11;
      }
    }
    if (v4 == v10)
    {
LABEL_11:
      unint64_t v11 = a1[2];
      if (v4 >= v11)
      {
        uint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v4 - *a1) >> 3);
        if ((unint64_t)(v13 + 1) > 0x492492492492492) {
          abort();
        }
        unint64_t v14 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v11 - *a1) >> 3);
        uint64_t v15 = 2 * v14;
        if (2 * v14 <= v13 + 1) {
          uint64_t v15 = v13 + 1;
        }
        if (v14 >= 0x249249249249249) {
          unint64_t v16 = 0x492492492492492;
        }
        else {
          unint64_t v16 = v15;
        }
        float v40 = a1 + 2;
        if (v16)
        {
          if (v16 > 0x492492492492492) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          float v17 = (char *)operator new(56 * v16);
        }
        else
        {
          float v17 = 0;
        }
        double v36 = v17;
        unint64_t v37 = (unint64_t)&v17[56 * v13];
        uint64_t v38 = v37;
        unsigned int v39 = &v17[56 * v16];
        std::pair<md::RouteRangeAnnotationRequest,md::WhenState>::pair[abi:nn180100](v37, (uint64_t)&v30);
        uint64_t v18 = v37;
        uint64_t v12 = v38 + 56;
        id v19 = (char *)*a1;
        unint64_t v20 = (char *)a1[1];
        if (v20 == (char *)*a1)
        {
          *a1 = v37;
          a1[1] = v12;
          a1[2] = (unint64_t)v39;
        }
        else
        {
          uint64_t v21 = 0;
          do
          {
            uint64_t v22 = v18 + v21;
            unint64_t v23 = &v20[v21];
            long long v24 = *(_OWORD *)&v20[v21 - 56];
            *((void *)v23 - 7) = 0;
            *((void *)v23 - 6) = 0;
            *(_OWORD *)(v22 - 56) = v24;
            *(void *)(v22 - 40) = *(void *)&v20[v21 - 40];
            uint64_t v25 = v18 + v21 - 32;
            *(_OWORD *)(v22 - 32) = *(_OWORD *)&v20[v21 - 32];
            uint64_t v26 = *(void *)&v20[v21 - 16];
            *(void *)(v22 - 16) = v26;
            if (v26)
            {
              *(void *)(*(void *)v25 + 16) = v25;
              *((void *)v23 - 5) = v23 - 32;
              *((void *)v23 - 4) = 0;
              *((void *)v23 - 2) = 0;
            }
            else
            {
              *(void *)(v22 - 40) = v25;
            }
            uint64_t v27 = v18 + v21;
            *(_WORD *)(v27 - 8) = *(_WORD *)&v20[v21 - 8];
            *(unsigned char *)(v27 - 6) = 0;
            if (v20[v21 - 6])
            {
              *(unsigned char *)(v27 - 5) = v20[v21 - 5];
              *(unsigned char *)(v27 - 6) = 1;
            }
            v21 -= 56;
          }
          while (&v20[v21] != v19);
          unint64_t v20 = (char *)*a1;
          PolylineCoordinate v28 = (char *)a1[1];
          *a1 = v18 + v21;
          a1[1] = v12;
          for (a1[2] = (unint64_t)v39; v28 != v20; v28 -= 56)
          {
            if (*(v28 - 6)) {
              *(v28 - 6) = 0;
            }
            std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(v28 - 40), *((void *)v28 - 4));
          }
        }
        if (v20) {
          operator delete(v20);
        }
      }
      else
      {
        std::pair<md::RouteRangeAnnotationRequest,md::WhenState>::pair[abi:nn180100](v4, (uint64_t)&v30);
        uint64_t v12 = v4 + 56;
        a1[1] = v4 + 56;
      }
      a1[1] = v12;
      unint64_t v4 = v12 - 56;
    }
    if (v35) {
      char v35 = 0;
    }
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)&v32, v33[0]);
  }
  return v4 + 48;
}

void sub_1A1F95FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
}

uint64_t *std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::__erase_unique<VKLabelNavRouteEta * {__strong}>(uint64_t a1, unint64_t a2)
{
  unint64_t v4 = (uint64_t *)(a1 + 8);
  uint64_t result = *(uint64_t **)(a1 + 8);
  if (result)
  {
    char v5 = v4;
    unint64_t v6 = result;
    do
    {
      unint64_t v7 = v6[4];
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        char v9 = (uint64_t **)v6;
      }
      else {
        char v9 = (uint64_t **)(v6 + 1);
      }
      if (v8) {
        char v5 = v6;
      }
      unint64_t v6 = *v9;
    }
    while (*v9);
    if (v5 != v4 && v5[4] <= a2)
    {
      unint64_t v10 = (uint64_t *)v5[1];
      if (v10)
      {
        do
        {
          unint64_t v11 = v10;
          unint64_t v10 = (uint64_t *)*v10;
        }
        while (v10);
      }
      else
      {
        uint64_t v12 = v5;
        do
        {
          unint64_t v11 = (uint64_t *)v12[2];
          BOOL v13 = *v11 == (void)v12;
          uint64_t v12 = v11;
        }
        while (!v13);
      }
      if (*(uint64_t **)a1 == v5) {
        *(void *)a1 = v11;
      }
      --*(void *)(a1 + 24);
      std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(result, v5);
      void v5[5] = (uint64_t)off_1EF559858;

      unint64_t v14 = *(uint64_t (**)(void))(**(void **)(a1 + 16) + 40);
      return (uint64_t *)v14();
    }
  }
  return result;
}

uint64_t std::pair<md::RouteRangeAnnotationRequest,md::WhenState>::pair[abi:nn180100](uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(id *)a2;
  id v4 = *(id *)(a2 + 8);
  *(void *)(a1 + 16) = 0;
  uint64_t v5 = *(void *)(a2 + 32);
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 32) = v5;
  *(void *)(a1 + 40) = 0;
  *(void *)(a1 + 16) = a1 + 24;
  std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>((uint64_t *)(a1 + 16), *(void **)(a2 + 16), (void *)(a2 + 24));
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 48);
  *(unsigned char *)(a1 + 50) = 0;
  if (*(unsigned char *)(a2 + 50))
  {
    *(unsigned char *)(a1 + 51) = *(unsigned char *)(a2 + 51);
    *(unsigned char *)(a1 + 50) = 1;
  }
  return a1;
}

void sub_1A1F961E8(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v2, *(void *)(v1 + 24));

  _Unwind_Resume(a1);
}

uint64_t std::pair<md::RouteRangeAnnotationRequest,md::WhenState>::~pair(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 50)) {
    *(unsigned char *)(a1 + 50) = 0;
  }
  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(a1 + 16, *(void *)(a1 + 24));

  return a1;
}

uint64_t std::__split_buffer<std::pair<md::RouteRangeAnnotationRequest,md::WhenState>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 56;
    if (*(unsigned char *)(i - 6)) {
      *(unsigned char *)(i - 6) = 0;
    }
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(i - 40, *(void *)(i - 32));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

uint64_t *std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>(uint64_t *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    id v4 = a2;
    uint64_t v5 = result;
    unint64_t v6 = result + 1;
    while (1)
    {
      uint64_t v7 = v5[1];
      BOOL v8 = v6;
      if ((uint64_t *)*v5 != v6)
      {
        uint64_t v9 = v5[1];
        unint64_t v10 = v6;
        if (v7)
        {
          do
          {
            BOOL v8 = (uint64_t *)v9;
            uint64_t v9 = *(void *)(v9 + 8);
          }
          while (v9);
        }
        else
        {
          do
          {
            BOOL v8 = (uint64_t *)v10[2];
            BOOL v11 = *v8 == (void)v10;
            unint64_t v10 = v8;
          }
          while (v11);
        }
        unsigned int v12 = *((_DWORD *)v4 + 8);
        if (*((_DWORD *)v8 + 8) >= v12) {
          break;
        }
      }
      BOOL v13 = v6;
      unint64_t v14 = v6;
      if (!v7) {
        goto LABEL_19;
      }
      BOOL v13 = v8 + 1;
      if (!v8[1])
      {
        unint64_t v14 = v8;
LABEL_19:
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[2] + 16))(v5[2], 72, 8);
        *(_DWORD *)(v16 + 32) = *((_DWORD *)v4 + 8);
        *(void *)(v16 + 40) = 0;
        *(void *)(v16 + 48) = 0;
        uint64_t v17 = v4[8];
        *(void *)(v16 + 56) = 0;
        *(void *)(v16 + 64) = v17;
        uint64_t v18 = (char *)v4[5];
        id v19 = (char *)v4[6];
        uint64_t v20 = v19 - v18;
        if (v19 != v18)
        {
          if (v20 < 0) {
            abort();
          }
          uint64_t v21 = (_OWORD *)(*(uint64_t (**)(uint64_t, int64_t, uint64_t))(*(void *)v17 + 16))(v17, v19 - v18, 4);
          *(void *)(v16 + 40) = v21;
          *(void *)(v16 + 48) = v21;
          *(void *)(v16 + 56) = &v21[v20 >> 4];
          do
          {
            if (v21) {
              *uint64_t v21 = *(_OWORD *)v18;
            }
            v18 += 16;
            ++v21;
          }
          while (v18 != v19);
          *(void *)(v16 + 48) = v21;
        }
        *(void *)uint64_t v16 = 0;
        *(void *)(v16 + 8) = 0;
        *(void *)(v16 + 16) = v14;
        *BOOL v13 = v16;
        uint64_t v22 = *(void *)*v5;
        if (v22)
        {
          uint64_t *v5 = v22;
          uint64_t v16 = *v13;
        }
        uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v5[1], (uint64_t *)v16);
        ++v5[3];
      }
LABEL_29:
      unint64_t v23 = (void *)v4[1];
      if (v23)
      {
        do
        {
          long long v24 = v23;
          unint64_t v23 = (void *)*v23;
        }
        while (v23);
      }
      else
      {
        do
        {
          long long v24 = (void *)v4[2];
          BOOL v11 = *v24 == (void)v4;
          id v4 = v24;
        }
        while (!v11);
      }
      id v4 = v24;
      if (v24 == a3) {
        return result;
      }
    }
    BOOL v13 = v6;
    unint64_t v14 = v6;
    if (v7)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v14 = (uint64_t *)v7;
          unsigned int v15 = *(_DWORD *)(v7 + 32);
          if (v12 >= v15) {
            break;
          }
          uint64_t v7 = *v14;
          BOOL v13 = v14;
          if (!*v14) {
            goto LABEL_19;
          }
        }
        if (v15 >= v12) {
          goto LABEL_29;
        }
        BOOL v13 = v14 + 1;
        uint64_t v7 = v14[1];
        if (!v7) {
          goto LABEL_19;
        }
      }
    }
    goto LABEL_19;
  }
  return result;
}

void sub_1A1F9651C(_Unwind_Exception *a1)
{
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 16) + 40))(*(void *)(v1 + 16), v2, 72);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *>,std::__tree_node_destructor<geo::StdAllocator<std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    if (*((unsigned char *)a1 + 16))
    {
      uint64_t v3 = *(void *)(v2 + 40);
      if (v3)
      {
        *(void *)(v2 + 48) = v3;
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 64) + 40))(*(void *)(v2 + 64), v3, *(void *)(v2 + 56) - v3);
      }
    }
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)a1[1] + 40))(*(void *)a1[1], v2, 72);
  }
  return a1;
}

void md::LabelNavEtaLabeler::sampleSimplifiedRouteSection<md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0>(md::NavContext const*,geo::Frustum<double> const&,GEOComposedRoute *,gm::Range<geo::PolylineCoordinate> const&,float,md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)::$_0)const::{lambda(geo::PolylineCoordinate)#1}::operator()(uint64_t a1, uint64_t a2)
{
  PolylineCoordinate v24 = (PolylineCoordinate)a2;
  double v4 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(*(void *)a1 + 48), *(const GEOComposedRoute **)(a1 + 40), &v24);
  uint64_t v5 = *(float64x2_t **)(*(void *)(a1 + 48) + 24);
  float64x2_t v8 = vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v5[60], v5[54], v4), v5[56], v6), v5[58], v7), 1.0 / (v5[61].f64[1] + v5[55].f64[1] * v4 + v5[57].f64[1] * v6 + v5[59].f64[1] * v7));
  float32x2_t v9 = vcvt_f32_f64(v8);
  unint64_t v10 = *(unsigned char **)(a1 + 16);
  if (!*v10)
  {
    BOOL v11 = *(float32x2_t **)(a1 + 24);
    float32x2_t v12 = vsub_f32(v9, *v11);
    *(float32x2_t *)&v8.f64[0] = vmul_f32(v12, v12);
    float v13 = sqrtf(vaddv_f32(*(float32x2_t *)&v8.f64[0]));
    unint64_t v14 = *(_DWORD **)(a1 + 8);
    LODWORD(v8.f64[0]) = *v14;
    float v15 = *(float *)(a1 + 56) - *(float *)v14;
    if (v13 >= v15)
    {
      float v16 = v13 - v15;
      *unint64_t v14 = 0;
      *(float *)v8.f64 = v15 / v13;
      float32x2_t v23 = vmla_n_f32(*v11, vsub_f32(v9, *v11), v15 / v13);
      float64x2_t v21 = v8;
      md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)const::$_0::operator()(a1 + 64, (float *)&v23, **(void **)(a1 + 32), a2, v15 / v13);
      float v17 = *(float *)(a1 + 56);
      if (v16 >= v17)
      {
        float v18 = v17 / v13;
        float64x2_t v19 = v21;
        do
        {
          float v16 = v16 - v17;
          *(float *)v19.f64 = *(float *)v19.f64 + v18;
          float64x2_t v22 = v19;
          uint64_t v20 = *(uint64_t **)(a1 + 32);
          float32x2_t v23 = vmla_n_f32(**(float32x2_t **)(a1 + 24), vsub_f32(v9, **(float32x2_t **)(a1 + 24)), *(float *)v19.f64);
          md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)const::$_0::operator()(a1 + 64, (float *)&v23, *v20, a2, *(float *)v19.f64);
          float64x2_t v19 = v22;
          float v17 = *(float *)(a1 + 56);
        }
        while (v16 >= v17);
      }
      unint64_t v14 = *(_DWORD **)(a1 + 8);
      unint64_t v10 = *(unsigned char **)(a1 + 16);
      LODWORD(v8.f64[0]) = *v14;
      float v13 = v16;
    }
    *(float *)unint64_t v14 = *(float *)v8.f64 + v13;
  }
  *unint64_t v10 = 0;
  **(float32x2_t **)(a1 + 24) = v9;
  **(PolylineCoordinate **)(a1 + 32) = v24;
}

void md::LabelNavEtaLabeler::searchForPlacementWithinSection(md::NavContext const*,geo::Frustum<double> const&,md::RouteLabelState const&,GEOComposedRoute *,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>> const&,md::EtaPlacementScore const*,md::EtaLabelPlacement &,unsigned char)const::$_0::operator()(uint64_t a1, float *a2, uint64_t a3, uint64_t a4, float a5)
{
  unint64_t v10 = *(float **)a1;
  float v11 = md::LabelNavEtaLabeler::scoreEtaLabelPosition(*(void *)a1, *(void **)(a1 + 8), a2, *(float *)(a1 + 80));
  float v13 = v12;
  size_t prime = *(void *)(*(void *)(a1 + 8) + 24);
  *(_OWORD *)float v48 = 0u;
  *(_OWORD *)std::string __p = 0u;
  float v50 = 1.0;
  if (prime == 1)
  {
    size_t prime = 2;
LABEL_17:
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v48, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    float v15 = v48[1];
    BOOL v16 = (void *)prime >= v48[1];
    if ((void *)prime > v48[1]) {
      goto LABEL_17;
    }
  }
  else
  {
    float v15 = 0;
    BOOL v16 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v16)
  {
    unint64_t v17 = vcvtps_u32_f32((float)(unint64_t)__p[1] / v50);
    if ((unint64_t)v15 < 3
      || (uint8x8_t v18 = (uint8x8_t)vcnt_s8((int8x8_t)v15), v18.i16[0] = vaddlv_u8(v18), v18.u32[0] > 1uLL))
    {
      unint64_t v17 = std::__next_prime(v17);
    }
    else
    {
      uint64_t v19 = 1 << -(char)__clz(v17 - 1);
      if (v17 >= 2) {
        unint64_t v17 = v19;
      }
    }
    if (prime <= v17) {
      size_t prime = v17;
    }
    if (prime < (unint64_t)v15) {
      goto LABEL_17;
    }
  }
LABEL_18:
  for (uint64_t i = *(uint64_t **)(*(void *)(a1 + 8) + 16); i; uint64_t i = (uint64_t *)*i)
  {
    float v24 = *((float *)i + 7);
    float v25 = *((float *)i + 5);
    if (v24 >= v25 && (float v26 = *((float *)i + 8), v27 = *((float *)i + 6), v26 >= v27))
    {
      float v32 = a2[1];
      float v31 = *a2 + v25;
      float v28 = v32 + v27;
      float v30 = *a2 + v24;
      float v29 = v32 + v26;
    }
    else
    {
      float v28 = 3.4028e38;
      float v29 = -3.4028e38;
      float v30 = -3.4028e38;
      float v31 = 3.4028e38;
    }
    double v33 = *(const md::RouteLabelState **)(a1 + 8);
    v45[0] = v31;
    v45[1] = v28;
    v45[2] = v30;
    void v45[3] = v29;
    md::LabelNavEtaLabeler::scoreEtaLabelRect((uint64_t)&v46, v10, v33, v45, (float *)(a1 + 108));
    __int16 v34 = (unsigned __int8 *)(i + 2);
    char v35 = std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v48, *((unsigned char *)i + 16), (unsigned char *)i + 16);
    *(_OWORD *)((char *)v35 + 20) = v46;
    *(void *)((char *)v35 + 36) = v47;
    if (*(void *)(*(void *)(a1 + 8) + 152) == 3
      && *((float *)std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v48, *v34, (unsigned char *)i + 16)+ 7) >= 1.0|| v11 < *(float *)(a1 + 124)|| *((float *)std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v48, *v34, (unsigned char *)i + 16)+ 6) >= 1.0)
    {
      continue;
    }
    double v36 = (float *)std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v48, *v34, (unsigned char *)i + 16);
    float v37 = (float)(v36[6] + v36[5]) + (float)(v36[7] + v36[8]);
    if (v37 >= 1.0) {
      int v38 = (int)fminf(-(float)(v10[62] - (float)(v37 * v10[62])), 254.0) + 1;
    }
    else {
      LOBYTE(v38) = 0;
    }
    unsigned int v39 = *(unsigned char **)(a1 + 32);
    unsigned int v40 = *v39;
    if (v40 == v38)
    {
      unsigned int v41 = *(float **)(a1 + 16);
      if (v13 >= v41[1]) {
        continue;
      }
    }
    else
    {
      if (v40 <= v38) {
        continue;
      }
      unsigned int v41 = *(float **)(a1 + 16);
    }
    *unsigned int v41 = v11;
    v41[1] = v13;
    unsigned char *v39 = v38;
    float64x2_t v21 = std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>((uint64_t)v48, *v34, (unsigned char *)i + 16);
    uint64_t v22 = *(void *)(a1 + 24);
    long long v23 = *(_OWORD *)((char *)v21 + 20);
    *(void *)(v22 + 16) = *(void *)((char *)v21 + 36);
    *(_OWORD *)uint64_t v22 = v23;
    **(unsigned char **)(a1 + 40) = *v34;
    **(void **)(a1 + 48) = a3;
    **(void **)(a1 + 56) = a4;
    **(float **)(a1 + 64) = a5;
  }
  uint64_t v42 = __p[0];
  if (__p[0])
  {
    do
    {
      uint64_t v43 = (void *)*v42;
      operator delete(v42);
      uint64_t v42 = v43;
    }
    while (v43);
  }
  float v44 = v48[0];
  v48[0] = 0;
  if (v44) {
    operator delete(v44);
  }
}

void sub_1A1F96B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A1F96B18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::__unordered_map_hasher<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::hash<md::RoadSignOrientation>,std::equal_to<md::RoadSignOrientation>,true>,std::__unordered_map_equal<md::RoadSignOrientation,std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>,std::equal_to<md::RoadSignOrientation>,std::hash<md::RoadSignOrientation>,true>,std::allocator<std::__hash_value_type<md::RoadSignOrientation,md::LabelRectScore>>>::__emplace_unique_key_args<md::RoadSignOrientation,std::piecewise_construct_t const&,std::tuple<md::RoadSignOrientation const&>,std::tuple<>>(uint64_t a1, unsigned __int8 a2, unsigned char *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    float32x2_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      unint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((unsigned __int8 *)v10 + 16) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            unint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int8 *)v10 + 16) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          unint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v10 = operator new(0x30uLL);
  *unint64_t v10 = 0;
  v10[1] = v6;
  *((unsigned char *)v10 + 16) = *a3;
  *(void *)((char *)v10 + 36) = 0;
  *(void *)((char *)v10 + 20) = 0;
  *(void *)((char *)v10 + 28) = 0;
  *((unsigned char *)v10 + 40) = 1;
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_34;
    }
    if (prime < v7)
    {
      unint64_t v19 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v20.i16[0] = vaddlv_u8(v20), v20.u32[0] > 1uLL))
      {
        unint64_t v19 = std::__next_prime(v19);
      }
      else
      {
        uint64_t v21 = 1 << -(char)__clz(v19 - 1);
        if (v19 >= 2) {
          unint64_t v19 = v21;
        }
      }
      if (prime <= v19) {
        size_t prime = v19;
      }
      if (prime < v7) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v22 = *(void *)a1;
  long long v23 = *(void **)(*(void *)a1 + 8 * v3);
  if (v23)
  {
    *unint64_t v10 = *v23;
LABEL_58:
    void *v23 = v10;
    goto LABEL_59;
  }
  *unint64_t v10 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v10;
  *(void *)(v22 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    unint64_t v24 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v24 >= v7) {
        v24 %= v7;
      }
    }
    else
    {
      v24 &= v7 - 1;
    }
    long long v23 = (void *)(*(void *)a1 + 8 * v24);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A1F96E14(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::pair[abi:nn180100](void *a1, uint64_t a2)
{
  *a1 = *(id *)a2;
  id v4 = *(id *)(a2 + 8);
  a1[2] = 0;
  uint64_t v5 = *(void *)(a2 + 32);
  a1[3] = 0;
  a1[1] = v4;
  a1[4] = v5;
  a1[5] = 0;
  a1[2] = a1 + 3;
  std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>(a1 + 2, *(void **)(a2 + 16), (void *)(a2 + 24));
  a1[6] = &unk_1EF559818;
  a1[7] = 0;
  id v6 = *(id *)(a2 + 56);
  unint64_t v7 = (void *)a1[7];
  a1[7] = v6;

  return a1;
}

void sub_1A1F96ED0(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v2, *(void *)(v1 + 24));

  _Unwind_Resume(a1);
}

uint64_t std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~pair(uint64_t a1)
{
  *(void *)(a1 + 48) = &unk_1EF559818;

  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(a1 + 16, *(void *)(a1 + 24));
  return a1;
}

uint64_t std::__split_buffer<std::pair<md::RouteRangeAnnotationRequest,geo::_retain_ptr<VKLabelNavRouteEta * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 72;
    *(void *)(i - 24) = &unk_1EF559818;

    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(i - 56, *(void *)(i - 48));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

id *geo::linear_map<md::RouteRangeAnnotationRequest,md::RouteLabelState,std::equal_to<md::RouteRangeAnnotationRequest>,std::allocator<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>,std::vector<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>>::operator[](uint64_t a1, uint64_t a2)
{
  id v4 = *(id **)a1;
  if (*(void *)a1 == *(void *)(a1 + 8)) {
    goto LABEL_4;
  }
  while (1)
  {
    char v5 = md::RouteRangeAnnotationRequest::operator==((id *)a2, (uint64_t)v4);
    id v6 = *(id **)(a1 + 8);
    if (v5) {
      break;
    }
    v4 += 48;
    if (v4 == v6) {
      goto LABEL_4;
    }
  }
  if (v4 == v6)
  {
LABEL_4:
    long long v76 = 0u;
    long long v77 = 0u;
    long long v74 = 0u;
    long long v75 = 0u;
    long long v72 = 0u;
    long long v73 = 0u;
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    memset(v67, 0, sizeof(v67));
    long long v65 = 0u;
    long long v66 = 0u;
    long long v61 = 0u;
    long long v62 = 0u;
    long long v60 = 0u;
    LODWORD(v62) = 1065353216;
    long long v64 = 0uLL;
    long long v63 = 0uLL;
    {
      operator new();
    }
    *((void *)&v64 + 1) = mdm::Allocator::instance(void)::alloc;
    LODWORD(v67[0]) = 2139095039;
    memset((char *)v67 + 4, 0, 24);
    BYTE12(v67[1]) = 1;
    *(void *)&long long v69 = 0;
    long long v78 = 0uLL;
    uint64_t v79 = 0;
    {
      operator new();
    }
    uint64_t v80 = mdm::Allocator::instance(void)::alloc;
    id v81 = *(id *)a2;
    id v7 = *(id *)(a2 + 8);
    uint64_t v8 = *(void *)(a2 + 32);
    v84[0] = 0;
    v84[1] = v8;
    v84[2] = 0;
    id v82 = v7;
    long long v83 = v84;
    std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>((uint64_t *)&v83, *(void **)(a2 + 16), (void *)(a2 + 24));
    long long v9 = v60;
    long long v60 = 0uLL;
    long long v85 = v9;
    long long v86 = v61;
    int v87 = v62;
    if (*((void *)&v61 + 1))
    {
      unint64_t v10 = *(void *)(v61 + 8);
      if ((*((void *)&v9 + 1) & (*((void *)&v9 + 1) - 1)) != 0)
      {
        if (v10 >= *((void *)&v9 + 1)) {
          v10 %= *((void *)&v9 + 1);
        }
      }
      else
      {
        v10 &= *((void *)&v9 + 1) - 1;
      }
      *(void *)(v9 + 8 * v10) = &v86;
      long long v61 = 0uLL;
    }
    long long v89 = v63;
    long long v93 = v67[0];
    long long v94 = v67[1];
    long long v91 = v65;
    long long v92 = v66;
    long long v101 = v74;
    long long v102 = v75;
    long long v103 = v76;
    long long v104 = v77;
    long long v97 = v70;
    long long v98 = v71;
    long long v99 = v72;
    long long v100 = v73;
    long long v95 = v68;
    long long v96 = v69;
    char v88 = BYTE8(v62);
    long long v90 = v64;
    *(void *)&long long v64 = 0;
    long long v63 = 0uLL;
    long long v105 = v78;
    uint64_t v107 = v80;
    uint64_t v106 = v79;
    uint64_t v79 = 0;
    long long v78 = 0uLL;
    id v4 = *(id **)a1;
    if (*(void *)a1 != *(void *)(a1 + 8))
    {
      while (1)
      {
        char v11 = md::RouteRangeAnnotationRequest::operator==(&v81, (uint64_t)v4);
        uint64_t v12 = *(id **)(a1 + 8);
        if (v11) {
          break;
        }
        v4 += 48;
        if (v4 == v12)
        {
          id v4 = *(id **)(a1 + 8);
          goto LABEL_19;
        }
      }
      if (v4 != v12) {
        goto LABEL_50;
      }
    }
LABEL_19:
    unint64_t v13 = *(void *)(a1 + 16);
    if ((unint64_t)v4 >= v13)
    {
      unint64_t v15 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v4 - *(void *)a1) >> 7);
      if (v15 + 1 > 0xAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v16 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - *(void *)a1) >> 7);
      uint64_t v17 = 2 * v16;
      if (2 * v16 <= v15 + 1) {
        uint64_t v17 = v15 + 1;
      }
      if (v16 >= 0x55555555555555) {
        unint64_t v18 = 0xAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v18 = v17;
      }
      uint64_t v112 = a1 + 16;
      if (v18)
      {
        if (v18 > 0xAAAAAAAAAAAAAALL) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v19 = (char *)operator new(384 * v18);
      }
      else
      {
        unint64_t v19 = 0;
      }
      long long v108 = v19;
      long long v109 = &v19[384 * v15];
      long long v110 = v109;
      long long v111 = &v19[384 * v18];
      std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>::pair[abi:nn180100](v109, (uint64_t)&v81);
      uint8x8_t v20 = v109;
      float v14 = v110 + 384;
      uint64_t v21 = *(id **)a1;
      uint64_t v22 = *(id **)(a1 + 8);
      if (v22 == *(id **)a1)
      {
        *(void *)a1 = v109;
        *(void *)(a1 + 8) = v14;
        *(void *)(a1 + 16) = v111;
        if (!v22) {
          goto LABEL_49;
        }
      }
      else
      {
        uint64_t v23 = 0;
        do
        {
          double v36 = (long long *)&v22[v23 - 48];
          long long v37 = *v36;
          v22[v23 - 47] = 0;
          *(void *)double v36 = 0;
          *(_OWORD *)&v20[v23 * 8 - 384] = v37;
          int v38 = (uint64_t *)&v20[v23 * 8 - 368];
          unsigned int v39 = (uint64_t *)&v22[v23 - 46];
          uint64_t *v38 = *v39;
          uint64_t v40 = (uint64_t)&v20[v23 * 8 - 360];
          unsigned int v41 = &v22[v23 - 45];
          *(_OWORD *)uint64_t v40 = *(_OWORD *)v41;
          uint64_t v42 = (uint64_t *)&v22[v23 - 43];
          uint64_t v43 = *v42;
          *(void *)&v20[v23 * 8 - 344] = *v42;
          if (v43)
          {
            *(void *)(*(void *)v40 + 16) = v40;
            uint64_t *v39 = (uint64_t)v41;
            *unsigned int v41 = 0;
            *uint64_t v42 = 0;
          }
          else
          {
            uint64_t *v38 = v40;
          }
          float v44 = &v20[v23 * 8];
          uint64_t v45 = &v22[v23];
          long long v46 = (uint64_t *)&v22[v23 - 42];
          uint64_t v47 = *v46;
          uint64_t *v46 = 0;
          float v48 = &v22[v23 - 41];
          *(void *)&v20[v23 * 8 - 336] = v47;
          char v49 = (unint64_t *)&v20[v23 * 8 - 328];
          *char v49 = (unint64_t)*v48;
          *float v48 = 0;
          float v50 = &v20[v23 * 8 - 320];
          float v51 = (uint64_t *)&v22[v23 - 40];
          uint64_t v52 = *v51;
          *(void *)float v50 = *v51;
          id v53 = v22[v23 - 39];
          *(void *)&v20[v23 * 8 - 312] = v53;
          *(_DWORD *)&v20[v23 * 8 - 304] = v22[v23 - 38];
          if (v53)
          {
            unint64_t v24 = *(void *)(v52 + 8);
            unint64_t v54 = *v49;
            if ((v54 & (v54 - 1)) != 0)
            {
              if (v24 >= v54) {
                v24 %= v54;
              }
            }
            else
            {
              v24 &= v54 - 1;
            }
            *(void *)(v47 + 8 * v24) = v50;
            uint64_t *v51 = 0;
            v22[v23 - 39] = 0;
          }
          *(v44 - 296) = *((unsigned char *)v45 - 296);
          float v25 = v44 - 288;
          float v26 = (char *)(v45 - 36);
          *((void *)v25 + 1) = 0;
          *((void *)v25 + 2) = 0;
          *(void *)float v25 = 0;
          *((void *)v44 - 33) = *(v45 - 33);
          *(_OWORD *)float v25 = *((_OWORD *)v45 - 18);
          *((void *)v44 - 34) = *(v45 - 34);
          *((void *)v26 + 2) = 0;
          *(v45 - 35) = 0;
          *(void *)float v26 = 0;
          long long v27 = *((_OWORD *)v45 - 12);
          long long v29 = *((_OWORD *)v45 - 15);
          long long v28 = *((_OWORD *)v45 - 14);
          *((_OWORD *)v44 - 13) = *((_OWORD *)v45 - 13);
          *((_OWORD *)v44 - 12) = v27;
          *((_OWORD *)v44 - 15) = v29;
          *((_OWORD *)v44 - 14) = v28;
          *((_OWORD *)v44 - 16) = *((_OWORD *)v45 - 16);
          long long v30 = *((_OWORD *)v45 - 10);
          long long v31 = *((_OWORD *)v45 - 9);
          long long v32 = *((_OWORD *)v45 - 7);
          *((_OWORD *)v44 - 8) = *((_OWORD *)v45 - 8);
          *((_OWORD *)v44 - 7) = v32;
          *((_OWORD *)v44 - 10) = v30;
          *((_OWORD *)v44 - 9) = v31;
          long long v33 = *((_OWORD *)v45 - 6);
          long long v34 = *((_OWORD *)v45 - 5);
          long long v35 = *((_OWORD *)v45 - 3);
          *((_OWORD *)v44 - 4) = *((_OWORD *)v45 - 4);
          *((_OWORD *)v44 - 3) = v35;
          *((_OWORD *)v44 - 6) = v33;
          *((_OWORD *)v44 - 5) = v34;
          *((_OWORD *)v44 - 11) = *((_OWORD *)v45 - 11);
          *((void *)v44 - 3) = 0;
          *((void *)v44 - 2) = 0;
          *((void *)v44 - 4) = 0;
          *((void *)v44 - 1) = *(v45 - 1);
          *((_OWORD *)v44 - 2) = *((_OWORD *)v45 - 2);
          *((void *)v44 - 2) = *(v45 - 2);
          *(v45 - 4) = 0;
          *(v45 - 3) = 0;
          *(v45 - 2) = 0;
          v23 -= 48;
        }
        while (&v22[v23] != v21);
        unsigned int v55 = &v20[v23 * 8];
        uint64_t v22 = *(id **)a1;
        unint64_t v56 = *(id **)(a1 + 8);
        *(void *)a1 = v55;
        *(void *)(a1 + 8) = v14;
        *(void *)(a1 + 16) = v111;
        if (v56 != v22)
        {
          float v57 = v56 - 48;
          do
          {
            md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)(v57 + 6));
            std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(v57 + 2), (uint64_t)v57[3]);

            BOOL v58 = v57 == v22;
            v57 -= 48;
          }
          while (!v58);
        }
        if (!v22) {
          goto LABEL_49;
        }
      }
      operator delete(v22);
    }
    else
    {
      std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>::pair[abi:nn180100](v4, (uint64_t)&v81);
      float v14 = v4 + 48;
      *(void *)(a1 + 8) = v14;
    }
LABEL_49:
    *(void *)(a1 + 8) = v14;
    id v4 = (id *)(v14 - 48);
LABEL_50:
    md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)&v85);
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)&v83, v84[0]);

    md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)&v60);
  }
  return v4 + 6;
}

void sub_1A1F97684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52)
{
  std::__split_buffer<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>::~__split_buffer(v52 - 104);
  std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>::~pair((uint64_t)&a52);
  md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)&a9);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<md::PolylineCollider>::__on_zero_shared(void *a1)
{
  uint64_t v2 = (void *)a1[9];
  if (v2)
  {
    a1[10] = v2;
    operator delete(v2);
  }
  unint64_t v3 = (void *)a1[6];
  if (v3)
  {
    a1[7] = v3;
    operator delete(v3);
  }
  id v4 = (void *)a1[3];
  if (v4)
  {
    a1[4] = v4;
    operator delete(v4);
  }
}

void std::__shared_ptr_emplace<md::PolylineCollider>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5802F8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::PolylineCollider>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5802F8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>::pair[abi:nn180100](void *a1, uint64_t a2)
{
  *a1 = *(id *)a2;
  id v4 = *(id *)(a2 + 8);
  a1[2] = 0;
  uint64_t v5 = *(void *)(a2 + 32);
  a1[3] = 0;
  a1[1] = v4;
  a1[4] = v5;
  a1[5] = 0;
  a1[2] = a1 + 3;
  std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>(a1 + 2, *(void **)(a2 + 16), (void *)(a2 + 24));
  md::RouteLabelState::RouteLabelState((md::RouteLabelState *)(a1 + 6), (const md::RouteLabelState *)(a2 + 48));
  return a1;
}

void sub_1A1F97844(_Unwind_Exception *a1)
{
  md::RouteRangeAnnotationRequest::~RouteRangeAnnotationRequest(v1);
  _Unwind_Resume(a1);
}

void sub_1A1F97858(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v2, *(void *)(v1 + 24));

  _Unwind_Resume(a1);
}

uint64_t std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>::~pair(uint64_t a1)
{
  return a1;
}

uint64_t std::__split_buffer<std::pair<md::RouteRangeAnnotationRequest,md::RouteLabelState>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 384;
    md::RouteLabelState::~RouteLabelState((md::RouteLabelState *)(i - 336));
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(i - 368, *(void *)(i - 360));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void md::RouteRangeAnnotationRequest::~RouteRangeAnnotationRequest(md::RouteRangeAnnotationRequest *this)
{
}

uint64_t std::__split_buffer<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 48;
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(i - 32, *(void *)(i - 24));
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

uint64_t std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::__emplace_hint_unique_key_args<md::RouteRangeAnnotationRequest,md::RouteRangeAnnotationRequest const&>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = (uint64_t *)(a1 + 8);
  if (a1 + 8 == a2) {
    goto LABEL_15;
  }
  unint64_t v9 = *(void *)a3;
  unint64_t v10 = *(void *)(a2 + 32);
  if (*(void *)a3 != v10)
  {
    if (*(void *)a3 >= v10)
    {
      BOOL v11 = v10 >= v9;
      if (v10 != v9) {
        goto LABEL_5;
      }
      goto LABEL_10;
    }
LABEL_15:
    uint64_t v17 = *(void *)v6;
    if (*(void *)a1 == v6)
    {
      uint64_t v19 = v6;
      if (v17) {
        goto LABEL_27;
      }
    }
    else
    {
      if (v17)
      {
        uint64_t v18 = *(void *)v6;
        do
        {
          uint64_t v19 = v18;
          uint64_t v18 = *(void *)(v18 + 8);
        }
        while (v18);
      }
      else
      {
        uint64_t v20 = v6;
        do
        {
          uint64_t v19 = *(void *)(v20 + 16);
          BOOL v21 = *(void *)v19 == v20;
          uint64_t v20 = v19;
        }
        while (v21);
      }
      unint64_t v22 = *(void *)(v19 + 32);
      if (v22 == *(void *)a3)
      {
        if ([*(id *)(v19 + 40) compare:*(void *)(a3 + 8)] != -1) {
          goto LABEL_43;
        }
        if (*(void *)v6)
        {
LABEL_27:
          long long v29 = (uint64_t *)v19;
          float v14 = (uint64_t *)(v19 + 8);
          uint64_t v6 = *v14;
          if (*v14) {
            return v6;
          }
          goto LABEL_44;
        }
      }
      else
      {
        if (v22 >= *(void *)a3) {
          goto LABEL_43;
        }
        if (v17) {
          goto LABEL_27;
        }
      }
    }
    long long v29 = (uint64_t *)v6;
    float v14 = (uint64_t *)v6;
    uint64_t v6 = *(void *)v6;
    if (v6) {
      return v6;
    }
    goto LABEL_44;
  }
  if ([*(id *)(a3 + 8) compare:*(void *)(a2 + 40)] == -1) {
    goto LABEL_15;
  }
  unint64_t v12 = *(void *)(v6 + 32);
  BOOL v11 = v12 >= *(void *)a3;
  if (v12 != *(void *)a3)
  {
LABEL_5:
    if (v11) {
      return v6;
    }
    goto LABEL_11;
  }
LABEL_10:
  if ([*(id *)(v6 + 40) compare:*(void *)(a3 + 8)] != -1) {
    return v6;
  }
LABEL_11:
  float v14 = (uint64_t *)(v6 + 8);
  uint64_t v13 = *(void *)(v6 + 8);
  if (v13)
  {
    unint64_t v15 = *(uint64_t **)(v6 + 8);
    do
    {
      unint64_t v16 = v15;
      unint64_t v15 = (uint64_t *)*v15;
    }
    while (v15);
  }
  else
  {
    uint64_t v23 = (uint64_t *)v6;
    do
    {
      unint64_t v16 = (uint64_t *)v23[2];
      BOOL v21 = *v16 == (void)v23;
      uint64_t v23 = v16;
    }
    while (!v21);
  }
  if (v16 != v8)
  {
    unint64_t v24 = v16[4];
    if (*(void *)a3 == v24)
    {
      if ([*(id *)(a3 + 8) compare:v16[5]] == -1)
      {
        if (*v14)
        {
LABEL_40:
          long long v29 = v16;
          float v14 = v16;
          uint64_t v6 = *v16;
          if (*v16) {
            return v6;
          }
          goto LABEL_44;
        }
        goto LABEL_49;
      }
    }
    else if (*(void *)a3 < v24)
    {
      goto LABEL_39;
    }
LABEL_43:
    float v14 = std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::__find_equal<md::RouteRangeAnnotationRequest>(a1, &v29, (unint64_t *)a3);
    uint64_t v6 = *v14;
    if (*v14) {
      return v6;
    }
    goto LABEL_44;
  }
LABEL_39:
  if (v13) {
    goto LABEL_40;
  }
LABEL_49:
  long long v29 = (uint64_t *)v6;
  uint64_t v6 = *v14;
  if (*v14) {
    return v6;
  }
LABEL_44:
  uint64_t v6 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 16) + 16))(*(void *)(a1 + 16), 80, 8);
  geo::StdAllocator<std::__tree_node<md::RouteRangeAnnotationRequest,void *>,mdm::Allocator>::construct<md::RouteRangeAnnotationRequest,md::RouteRangeAnnotationRequest const&>((uint64_t *)(v6 + 32), a4);
  float v25 = v29;
  *(void *)uint64_t v6 = 0;
  *(void *)(v6 + 8) = 0;
  *(void *)(v6 + 16) = v25;
  *float v14 = v6;
  uint64_t v26 = **(void **)a1;
  long long v27 = (uint64_t *)v6;
  if (v26)
  {
    *(void *)a1 = v26;
    long long v27 = (uint64_t *)*v14;
  }
  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 8), v27);
  ++*(void *)(a1 + 24);
  return v6;
}

void sub_1A1F97CB4(_Unwind_Exception *exception_object)
{
  if (v2) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1 + 16) + 40))(*(void *)(v1 + 16), v2, 80);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *geo::StdAllocator<std::__tree_node<md::RouteRangeAnnotationRequest,void *>,mdm::Allocator>::construct<md::RouteRangeAnnotationRequest,md::RouteRangeAnnotationRequest const&>(uint64_t *result, uint64_t a2)
{
  if (result)
  {
    unint64_t v3 = result;
    *uint64_t result = (uint64_t)*(id *)a2;
    id v4 = *(id *)(a2 + 8);
    v3[2] = 0;
    uint64_t v5 = *(void *)(a2 + 32);
    v3[3] = 0;
    v3[1] = (uint64_t)v4;
    v3[4] = v5;
    v3[5] = 0;
    v3[2] = (uint64_t)(v3 + 3);
    return std::map<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>,std::less<unsigned int>,geo::StdAllocator<std::pair<unsigned int const,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::insert[abi:nn180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__tree_node<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,void *> *,long>>>(v3 + 2, *(void **)(a2 + 16), (void *)(a2 + 24));
  }
  return result;
}

void sub_1A1F97D68(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v2, *(void *)(v1 + 24));

  _Unwind_Resume(a1);
}

uint64_t *std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::__find_equal<md::RouteRangeAnnotationRequest>(uint64_t a1, void *a2, unint64_t *a3)
{
  uint64_t v5 = (uint64_t *)(a1 + 8);
  id v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    while (1)
    {
      id v7 = v4;
      unint64_t v8 = *a3;
      unint64_t v9 = v4[4];
      if (*a3 == v9)
      {
        if ([(id)a3[1] compare:v7[5]] == -1) {
          goto LABEL_3;
        }
        unint64_t v11 = v7[4];
        BOOL v10 = v11 >= *a3;
        if (v11 == *a3)
        {
LABEL_12:
          if ([(id)v7[5] compare:a3[1]] != -1) {
            goto LABEL_16;
          }
          goto LABEL_13;
        }
LABEL_7:
        if (v10) {
          goto LABEL_16;
        }
LABEL_13:
        uint64_t v5 = v7 + 1;
        id v4 = (uint64_t *)v7[1];
        if (!v4) {
          goto LABEL_16;
        }
      }
      else
      {
        if (*a3 >= v9)
        {
          BOOL v10 = v9 >= v8;
          if (v9 == v8) {
            goto LABEL_12;
          }
          goto LABEL_7;
        }
LABEL_3:
        id v4 = (uint64_t *)*v7;
        uint64_t v5 = v7;
        if (!*v7) {
          goto LABEL_16;
        }
      }
    }
  }
  id v7 = (uint64_t *)(a1 + 8);
LABEL_16:
  *a2 = v7;
  return v5;
}

BOOL std::__function::__func<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_1,std::allocator<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_1>,BOOL ()(md::RouteRangeAnnotationRequest const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  unint64_t v3 = [*(id *)(a2 + 8) etaDescription];
  unint64_t v4 = [v3 routeEtaType];

  int8x8_t v5 = (int8x8_t)v2[1];
  if (v5)
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v7 = v4;
      if (v4 >= *(void *)&v5) {
        unint64_t v7 = v4 % *(void *)&v5;
      }
    }
    else
    {
      unint64_t v7 = (*(void *)&v5 - 1) & v4;
    }
    unint64_t v8 = *(void **)(*v2 + 8 * v7);
    if (v8)
    {
      unint64_t v8 = (void *)*v8;
      if (v8)
      {
        if (v6.u32[0] < 2uLL)
        {
          uint64_t v9 = *(void *)&v5 - 1;
          while (1)
          {
            uint64_t v11 = v8[1];
            if (v4 == v11)
            {
              if (v8[2] == v4) {
                return v8 != 0;
              }
            }
            else if ((v11 & v9) != v7)
            {
              goto LABEL_21;
            }
            unint64_t v8 = (void *)*v8;
            if (!v8) {
              return v8 != 0;
            }
          }
        }
        do
        {
          unint64_t v10 = v8[1];
          if (v4 == v10)
          {
            if (v8[2] == v4) {
              return v8 != 0;
            }
          }
          else
          {
            if (v10 >= *(void *)&v5) {
              v10 %= *(void *)&v5;
            }
            if (v10 != v7) {
              goto LABEL_21;
            }
          }
          unint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
    }
  }
  else
  {
LABEL_21:
    unint64_t v8 = 0;
  }
  return v8 != 0;
}

void sub_1A1F97F70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_1,std::allocator<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_1>,BOOL ()(md::RouteRangeAnnotationRequest const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573AA0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_1,std::allocator<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_1>,BOOL ()(md::RouteRangeAnnotationRequest const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF573AA0;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_1,std::allocator<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_1>,BOOL ()(md::RouteRangeAnnotationRequest const&)>::~__func()
{
}

__n128 __Block_byref_object_copy__59(__n128 *a1, __n128 *a2)
{
  a1[3].n128_u64[0] = 0;
  a1[3].n128_u64[1] = 0;
  a1[4].n128_u64[0] = 0;
  a1[4].n128_u64[1] = a2[4].n128_u64[1];
  __n128 result = a2[3];
  a1[3] = result;
  a1[4].n128_u64[0] = a2[4].n128_u64[0];
  a2[3].n128_u64[0] = 0;
  a2[3].n128_u64[1] = 0;
  a2[4].n128_u64[0] = 0;
  return result;
}

uint64_t __Block_byref_object_dispose__60(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  if (v1)
  {
    uint64_t v2 = result;
    for (uint64_t i = *(void *)(result + 56); i != v1; i -= 48)
    {
      std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(i - 32, *(void *)(i - 24));

      unint64_t v4 = *(void **)(i - 48);
    }
    *(void *)(v2 + 56) = v1;
    int8x8_t v5 = *(uint64_t (**)(void))(**(void **)(v2 + 72) + 40);
    return v5();
  }
  return result;
}

void ___ZN2md18LabelNavEtaLabeler25extractAndSortAnnotationsEP11VKRouteInfoNSt3__18functionIFbRKNS_27RouteRangeAnnotationRequestEEEE_block_invoke(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = a1[6];
  int8x8_t v5 = (void *)a1[4];
  id v6 = v3;
  *(void *)&long long v44 = [v5 route];
  *((void *)&v44 + 1) = v6;
  *(void *)&long long v46 = 0;
  {
    operator new();
  }
  *((void *)&v46 + 1) = mdm::Allocator::instance(void)::alloc;
  uint64_t v47 = 0;
  uint64_t v45 = &v46;
  uint64_t v7 = a1[10];
  if (!v7 || ((*(uint64_t (**)(uint64_t, long long *))(*(void *)v7 + 48))(v7, &v44) & 1) == 0)
  {
    unint64_t v8 = (void **)(v4 + 576);
    uint64_t v9 = std::__tree<md::RouteRangeAnnotationRequest,std::less<md::RouteRangeAnnotationRequest>,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::__find_equal<md::RouteRangeAnnotationRequest>(v4 + 576, &v48, (unint64_t *)&v44);
    if (!*v9)
    {
      unint64_t v10 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 592) + 16))(*(void *)(v4 + 592), 80, 8);
      geo::StdAllocator<std::__tree_node<md::RouteRangeAnnotationRequest,void *>,mdm::Allocator>::construct<md::RouteRangeAnnotationRequest,md::RouteRangeAnnotationRequest const&>(v10 + 4, (uint64_t)&v44);
      uint64_t v11 = v48;
      *unint64_t v10 = 0;
      v10[1] = 0;
      v10[2] = v11;
      *uint64_t v9 = (uint64_t)v10;
      unint64_t v12 = (void *)**v8;
      if (v12)
      {
        *unint64_t v8 = v12;
        unint64_t v10 = (uint64_t *)*v9;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 584), v10);
      ++*(void *)(v4 + 600);
    }
    uint64_t v13 = *(void *)(a1[5] + 8);
    unint64_t v14 = *(void *)(v13 + 56);
    unint64_t v15 = *(void *)(v13 + 64);
    if (v14 >= v15)
    {
      uint64_t v20 = *(void *)(v13 + 48);
      unint64_t v21 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v14 - v20) >> 4);
      unint64_t v22 = v21 + 1;
      if (v21 + 1 > 0x555555555555555) {
        abort();
      }
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v15 - v20) >> 4);
      if (2 * v23 > v22) {
        unint64_t v22 = 2 * v23;
      }
      if (v23 >= 0x2AAAAAAAAAAAAAALL) {
        uint64_t v24 = 0x555555555555555;
      }
      else {
        uint64_t v24 = v22;
      }
      if (v24)
      {
        uint64_t v25 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v13 + 72) + 16))(*(void *)(v13 + 72), 48 * v24, 8);
        uint64_t v26 = v25 + 48 * v21;
        uint64_t v27 = v25 + 48 * v24;
        if (v25)
        {
          long long v28 = v44;
          long long v44 = 0uLL;
          *(_OWORD *)uint64_t v26 = v28;
          unint64_t v29 = v25 + 48 * v21;
          *(void *)(v29 + 16) = v45;
          unint64_t v30 = v29 + 16;
          unint64_t v31 = v30 + 8;
          *(_OWORD *)(v30 + 8) = v46;
          uint64_t v32 = v47;
          *(void *)(v30 + 24) = v47;
          if (v32)
          {
            *(void *)(*(void *)v31 + 16) = v31;
            uint64_t v45 = &v46;
            *(void *)&long long v46 = 0;
            uint64_t v47 = 0;
          }
          else
          {
            *(void *)unint64_t v30 = v31;
          }
        }
      }
      else
      {
        uint64_t v27 = 0;
        uint64_t v26 = 48 * v21;
      }
      uint64_t v19 = v26 + 48;
      uint64_t v33 = *(void *)(v13 + 48);
      uint64_t v34 = *(void *)(v13 + 56);
      if (v34 == v33)
      {
        *(void *)(v13 + 48) = v26;
        *(void *)(v13 + 56) = v19;
        uint64_t v42 = *(void *)(v13 + 64);
        *(void *)(v13 + 64) = v27;
        if (!v34) {
          goto LABEL_36;
        }
      }
      else
      {
        uint64_t v35 = 0;
        do
        {
          uint64_t v36 = v26 + v35;
          uint64_t v37 = v34 + v35;
          long long v38 = *(_OWORD *)(v34 + v35 - 48);
          *(void *)(v37 - 48) = 0;
          *(void *)(v37 - 40) = 0;
          *(_OWORD *)(v36 - 48) = v38;
          *(void *)(v36 - 32) = *(void *)(v34 + v35 - 32);
          uint64_t v39 = v26 + v35 - 24;
          *(_OWORD *)(v36 - 24) = *(_OWORD *)(v34 + v35 - 24);
          uint64_t v40 = *(void *)(v34 + v35 - 8);
          *(void *)(v36 - 8) = v40;
          if (v40)
          {
            *(void *)(*(void *)v39 + 16) = v39;
            *(void *)(v37 - 32) = v37 - 24;
            *(void *)(v37 - 24) = 0;
            *(void *)(v37 - 8) = 0;
          }
          else
          {
            *(void *)(v36 - 32) = v39;
          }
          v35 -= 48;
        }
        while (v34 + v35 != v33);
        uint64_t v34 = *(void *)(v13 + 48);
        uint64_t v41 = *(void *)(v13 + 56);
        *(void *)(v13 + 48) = v26 + v35;
        *(void *)(v13 + 56) = v19;
        uint64_t v42 = *(void *)(v13 + 64);
        *(void *)(v13 + 64) = v27;
        while (v41 != v34)
        {
          std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v41 - 32, *(void *)(v41 - 24));

          uint64_t v43 = *(void **)(v41 - 48);
          v41 -= 48;
        }
        if (!v34) {
          goto LABEL_36;
        }
      }
      (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v13 + 72) + 40))(*(void *)(v13 + 72), v34, v42 - v34);
    }
    else
    {
      if (v14)
      {
        long long v16 = v44;
        long long v44 = 0uLL;
        *(_OWORD *)unint64_t v14 = v16;
        *(void *)(v14 + 16) = v45;
        unint64_t v17 = v14 + 24;
        *(_OWORD *)(v14 + 24) = v46;
        uint64_t v18 = v47;
        *(void *)(v14 + 40) = v47;
        if (!v18)
        {
          *(void *)(v14 + 16) = v17;
          uint64_t v19 = v14 + 48;
          goto LABEL_36;
        }
        *(void *)(*(void *)v17 + 16) = v17;
        uint64_t v45 = &v46;
        *(void *)&long long v46 = 0;
        uint64_t v47 = 0;
      }
      uint64_t v19 = v14 + 48;
    }
LABEL_36:
    *(void *)(v13 + 56) = v19;
  }
  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)&v45, v46);
}

void sub_1A1F98530(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (v10) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v11 + 592) + 40))(*(void *)(v11 + 592), v10, 80);
  }
  md::RouteRangeAnnotationRequest::~RouteRangeAnnotationRequest((md::RouteRangeAnnotationRequest *)&a9);

  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*,false>(uint64_t a1, long long *a2, uint64_t a3, char a4)
{
void sub_1A1F99C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,uint64_t a25,uint64_t a26)
{
  _Unwind_Resume(a1);
}

uint64_t *std::vector<md::RouteRangeAnnotationRequest,geo::StdAllocator<md::RouteRangeAnnotationRequest,mdm::Allocator>>::~vector[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  if (*a1)
  {
    uint64_t v3 = a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      do
      {
        std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy(v3 - 32, *(void *)(v3 - 24));

        char v5 = *(void **)(v3 - 48);
        v3 -= 48;
      }
      while (v3 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v4, a1[2] - v4);
  }
  return a1;
}

BOOL md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = [*(id *)(a1 + 8) etaDescription];
  uint64_t v5 = [v4 routeEtaType];

  id v6 = [*(id *)(a2 + 8) etaDescription];
  uint64_t v7 = [v6 routeEtaType];

  unint64_t v8 = *(void **)(a1 + 8);
  if (v5 == v7)
  {
    uint64_t v9 = [v8 start];
    uint64_t v10 = [*(id *)(a2 + 8) start];
    return v9 < v10
        || *((float *)&v9 + 1) < *((float *)&v10 + 1) && v9 == v10;
  }
  else
  {
    unint64_t v12 = [v8 etaDescription];
    uint64_t v13 = [v12 routeEtaType];

    uint64_t v14 = [*(id *)(a2 + 8) etaDescription];
    uint64_t v15 = [v14 routeEtaType];

    return v13 < v15;
  }
}

void sub_1A1F99F24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(long long *a1, void *a2)
{
  long long v4 = *a1;
  *(void *)a1 = 0;
  *((void *)a1 + 1) = 0;
  long long v18 = v4;
  uint64_t v5 = a1 + 1;
  uint64_t v19 = (long long *)*((void *)a1 + 2);
  uint64_t v6 = (uint64_t)a1 + 24;
  long long v20 = *(long long *)((char *)a1 + 24);
  uint64_t v21 = *((void *)a1 + 5);
  if (v21)
  {
    *(void *)(v20 + 16) = &v20;
    *((void *)a1 + 2) = v6;
    *((void *)a1 + 3) = 0;
    *((void *)a1 + 5) = 0;
  }
  else
  {
    uint64_t v19 = &v20;
  }
  uint64_t v7 = (void *)*a2;
  *a2 = 0;
  unint64_t v8 = *(void **)a1;
  *(void *)a1 = v7;

  uint64_t v9 = a2[1];
  a2[1] = 0;
  uint64_t v10 = (void *)*((void *)a1 + 1);
  *((void *)a1 + 1) = v9;

  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)v5, *((void *)a1 + 3));
  *((void *)a1 + 2) = a2[2];
  unint64_t v12 = a2 + 3;
  uint64_t v11 = a2[3];
  *((void *)a1 + 3) = v11;
  uint64_t v13 = a2[5];
  *((void *)a1 + 5) = v13;
  if (v13)
  {
    *(void *)(v11 + 16) = v6;
    a2[2] = v12;
    a2[3] = 0;
    a2[5] = 0;
  }
  else
  {
    void *v5 = v6;
  }
  uint64_t v14 = (void *)*a2;
  *a2 = v18;

  uint64_t v15 = (void *)a2[1];
  a2[1] = *((void *)&v18 + 1);

  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(a2 + 2), a2[3]);
  uint64_t v16 = v20;
  a2[2] = v19;
  a2[3] = v16;
  uint64_t v17 = v21;
  a2[5] = v21;
  if (v17)
  {
    *(void *)(v16 + 16) = v12;
    uint64_t v16 = 0;
    uint64_t v19 = &v20;
    *(void *)&long long v20 = 0;
    uint64_t v21 = 0;
  }
  else
  {
    a2[2] = v12;
  }
  std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)&v19, v16);
}

void std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*>(long long *a1, long long *a2, long long *a3)
{
  BOOL v6 = md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a2, (uint64_t)a1);
  BOOL v7 = md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a3, (uint64_t)a2);
  if (v6)
  {
    if (v7)
    {
      unint64_t v8 = a1;
    }
    else
    {
      std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a1, a2);
      if (!md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a3, (uint64_t)a2))return; {
      unint64_t v8 = a2;
      }
    }
    uint64_t v9 = a3;
  }
  else
  {
    if (!v7) {
      return;
    }
    std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a2, a3);
    if (!md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a2, (uint64_t)a1))return; {
    unint64_t v8 = a1;
    }
    uint64_t v9 = a2;
  }
  std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(v8, v9);
}

void std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*>(long long *a1, long long *a2, long long *a3, void *a4)
{
  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*>(a1, a2, a3);
  if (md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a4, (uint64_t)a3))
  {
    std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a3, a4);
    if (md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a3, (uint64_t)a2))
    {
      std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a2, a3);
      if (md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a2, (uint64_t)a1))
      {
        std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a1, a2);
      }
    }
  }
}

void std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*,0>(long long *a1, long long *a2, long long *a3, long long *a4, void *a5)
{
  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*>(a1, a2, a3, a4);
  if (md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a5, (uint64_t)a4))
  {
    std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a4, a5);
    if (md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a4, (uint64_t)a3))
    {
      std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a3, a4);
      if (md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a3, (uint64_t)a2))
      {
        std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a2, a3);
        if (md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)a2, (uint64_t)a1))
        {
          std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a1, a2);
        }
      }
    }
  }
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*>(long long *a1, long long *a2)
{
  uint64_t v4 = a2 - a1;
  BOOL result = 1;
  switch(0xAAAAAAAAAAAAAAABLL * v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      BOOL v6 = a2 - 3;
      if (!md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)(a2 - 3), (uint64_t)a1))return 1; {
      std::swap[abi:nn180100]<md::RouteRangeAnnotationRequest>(a1, v6);
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*>(a1, a1 + 3, a2 - 3);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*>(a1, a1 + 3, a1 + 6, (void *)a2 - 6);
      return 1;
    case 5uLL:
      std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*,0>(a1, a1 + 3, a1 + 6, a1 + 9, (void *)a2 - 6);
      return 1;
    default:
      uint64_t v7 = (uint64_t)(a1 + 6);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0 &,md::RouteRangeAnnotationRequest*>(a1, a1 + 3, a1 + 6);
      uint64_t v8 = (uint64_t)(a1 + 9);
      if (a1 + 9 == a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (2)
  {
    if (!md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()(v8, v7))goto LABEL_8; {
    long long v12 = *(_OWORD *)v8;
    }
    *(void *)uint64_t v8 = 0;
    *(void *)(v8 + 8) = 0;
    long long v37 = v12;
    uint64_t v13 = *(uint64_t **)(v8 + 16);
    long long v39 = *(_OWORD *)(v8 + 24);
    uint64_t v14 = *(void *)(v8 + 40);
    long long v38 = v13;
    uint64_t v40 = v14;
    if (v14)
    {
      *(void *)(v39 + 16) = &v39;
      *(void *)(v8 + 16) = v8 + 24;
      *(void *)(v8 + 24) = 0;
      *(void *)(v8 + 40) = 0;
    }
    else
    {
      long long v38 = (uint64_t *)&v39;
    }
    uint64_t v15 = v9;
    while (1)
    {
      uint64_t v16 = v15;
      uint64_t v17 = (void *)((char *)a1 + v15);
      uint64_t v18 = *(void *)((char *)a1 + v15 + 96);
      v17[12] = 0;
      uint64_t v19 = (void *)v17[18];
      v17[18] = v18;

      uint64_t v20 = v17[13];
      v17[13] = 0;
      uint64_t v21 = (void *)v17[19];
      v17[19] = v20;

      uint64_t v22 = v17 + 21;
      std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)(v17 + 20), v17[21]);
      v17[20] = v17[14];
      unint64_t v23 = v17 + 15;
      uint64_t v24 = v17[15];
      v17[21] = v24;
      uint64_t v25 = v17[17];
      v17[23] = v25;
      if (!v25) {
        break;
      }
      *(void *)(v24 + 16) = v22;
      v17[14] = v23;
      void *v23 = 0;
      v17[17] = 0;
      if (v16 == -96) {
        goto LABEL_20;
      }
LABEL_18:
      BOOL v26 = md::LabelNavEtaLabeler::extractAndSortAnnotations(VKRouteInfo *,std::function<BOOL ()(md::RouteRangeAnnotationRequest const&)>)::$_0::operator()((uint64_t)&v37, (uint64_t)a1 + v16 + 48);
      uint64_t v15 = v16 - 48;
      if (!v26)
      {
        uint64_t v27 = (uint64_t **)((char *)a1 + v16 + 112);
        uint64_t v28 = (uint64_t)a1 + v15 + 144;
        uint64_t v29 = (void *)((char *)a1 + v16 + 136);
        unint64_t v30 = (uint64_t *)((char *)a1 + v16 + 120);
        goto LABEL_21;
      }
    }
    v17[20] = v22;
    if (v16 != -96) {
      goto LABEL_18;
    }
LABEL_20:
    uint64_t v27 = (uint64_t **)((char *)a1 + v16 + 112);
    uint64_t v29 = (void *)((char *)a1 + v16 + 136);
    unint64_t v30 = (uint64_t *)((char *)a1 + v16 + 120);
    uint64_t v28 = (uint64_t)a1;
LABEL_21:
    uint64_t v31 = v37;
    *(void *)&long long v37 = 0;
    unint64_t v32 = *(void **)v28;
    *(void *)uint64_t v28 = v31;

    uint64_t v33 = *((void *)&v37 + 1);
    *((void *)&v37 + 1) = 0;
    uint64_t v34 = *(void **)(v28 + 8);
    *(void *)(v28 + 8) = v33;

    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)v27, *v30);
    uint64_t v35 = v39;
    uint64_t *v27 = v38;
    *unint64_t v30 = v35;
    uint64_t v36 = v40;
    *uint64_t v29 = v40;
    if (v36)
    {
      uint64_t v11 = 0;
      *(void *)(v35 + 16) = v30;
      long long v38 = (uint64_t *)&v39;
      *(void *)&long long v39 = 0;
      uint64_t v40 = 0;
    }
    else
    {
      uint64_t *v27 = v30;
      uint64_t v11 = v39;
    }
    ++v10;
    std::__tree<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,std::vector<md::ShareSection,geo::StdAllocator<md::ShareSection,mdm::Allocator>>>,mdm::Allocator>>::destroy((uint64_t)&v38, v11);

    if (v10 == 8) {
      return v8 + 48 == (void)a2;
    }
LABEL_8:
    uint64_t v7 = v8;
    v9 += 48;
    v8 += 48;
    if ((long long *)v8 != a2) {
      continue;
    }
    return 1;
  }
}

void sub_1A1F9A624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  md::RouteRangeAnnotationRequest::~RouteRangeAnnotationRequest((md::RouteRangeAnnotationRequest *)va);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_56c62_ZTSNSt3__18functionIFbRKN2md27RouteRangeAnnotationRequestEEEE(uint64_t a1)
{
  uint64_t v1 = a1 + 56;
  uint64_t result = *(void *)(a1 + 80);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

uint64_t __copy_helper_block_ea8_56c62_ZTSNSt3__18functionIFbRKN2md27RouteRangeAnnotationRequestEEEE(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 80);
  if (result)
  {
    if (result == a2 + 56)
    {
      *(void *)(a1 + 80) = a1 + 56;
      uint64_t v4 = *(uint64_t (**)(void))(**(void **)(a2 + 80) + 24);
      return v4();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)(a1 + 80) = result;
    }
  }
  else
  {
    *(void *)(a1 + 80) = 0;
  }
  return result;
}

BOOL std::__function::__func<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_0,std::allocator<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_0>,BOOL ()(md::RouteRangeAnnotationRequest const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = [*(id *)(a2 + 8) etaDescription];
  unint64_t v4 = [v3 routeEtaType];

  int8x8_t v5 = (int8x8_t)v2[1];
  if (v5)
  {
    uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
    v6.i16[0] = vaddlv_u8(v6);
    if (v6.u32[0] > 1uLL)
    {
      unint64_t v7 = v4;
      if (v4 >= *(void *)&v5) {
        unint64_t v7 = v4 % *(void *)&v5;
      }
    }
    else
    {
      unint64_t v7 = (*(void *)&v5 - 1) & v4;
    }
    uint64_t v8 = *(void **)(*v2 + 8 * v7);
    if (v8)
    {
      uint64_t v8 = (void *)*v8;
      if (v8)
      {
        if (v6.u32[0] < 2uLL)
        {
          uint64_t v9 = *(void *)&v5 - 1;
          while (1)
          {
            uint64_t v11 = v8[1];
            if (v4 == v11)
            {
              if (v8[2] == v4) {
                return v8 != 0;
              }
            }
            else if ((v11 & v9) != v7)
            {
              goto LABEL_21;
            }
            uint64_t v8 = (void *)*v8;
            if (!v8) {
              return v8 != 0;
            }
          }
        }
        do
        {
          unint64_t v10 = v8[1];
          if (v4 == v10)
          {
            if (v8[2] == v4) {
              return v8 != 0;
            }
          }
          else
          {
            if (v10 >= *(void *)&v5) {
              v10 %= *(void *)&v5;
            }
            if (v10 != v7) {
              goto LABEL_21;
            }
          }
          uint64_t v8 = (void *)*v8;
        }
        while (v8);
      }
    }
  }
  else
  {
LABEL_21:
    uint64_t v8 = 0;
  }
  return v8 != 0;
}

void sub_1A1F9A880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_0,std::allocator<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_0>,BOOL ()(md::RouteRangeAnnotationRequest const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573A58;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_0,std::allocator<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_0>,BOOL ()(md::RouteRangeAnnotationRequest const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF573A58;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_0,std::allocator<md::LabelNavEtaLabeler::updateLabelPositions(md::NavContext *,std::vector<md::AvoidanceRectWithPriority,geo::StdAllocator<md::AvoidanceRectWithPriority,mdm::Allocator>> const&)::$_0>,BOOL ()(md::RouteRangeAnnotationRequest const&)>::~__func()
{
}

uint64_t md::LabelNavEtaLabeler::indexForRoute(id *this, GEOComposedRoute *a2)
{
  uint64_t v3 = a2;
  unint64_t v4 = [this[3] routeInfo];
  int8x8_t v5 = [v4 route];

  if (v5 != v3)
  {
    for (unint64_t i = 0; ; ++i)
    {
      id v7 = this[3];
      uint64_t v8 = [v7 alternateRoutes];
      unint64_t v9 = [v8 count];

      if (i >= v9) {
        break;
      }
      id v10 = this[3];
      uint64_t v11 = [v10 alternateRoutes];
      long long v12 = [v11 objectAtIndex:i];
      uint64_t v13 = [v12 route];

      if (v13 == v3)
      {
        uint64_t v14 = (i + 1);
        goto LABEL_8;
      }
    }
  }
  uint64_t v14 = 0;
LABEL_8:

  return v14;
}

void sub_1A1F9AA24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

md::RouteElevationSourceContext *md::RouteElevationSourceContext::RouteElevationSourceContext(md::RouteElevationSourceContext *this, const md::RouteElevationSourceContext *a2)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_DWORD *)this + 8) = *((_DWORD *)a2 + 8);
  size_t prime = *((void *)a2 + 1);
  if (prime == 1)
  {
    size_t prime = 2;
LABEL_3:
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)this, prime);
    goto LABEL_4;
  }
  if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(*((void *)a2 + 1));
    int8x8_t v52 = *(int8x8_t *)((char *)this + 8);
    BOOL v53 = prime >= *(void *)&v52;
    if (prime > *(void *)&v52) {
      goto LABEL_3;
    }
  }
  else
  {
    int8x8_t v52 = 0;
    BOOL v53 = 1;
    if (prime) {
      goto LABEL_3;
    }
  }
  if (!v53)
  {
    unint64_t v54 = vcvtps_u32_f32((float)*((unint64_t *)this + 3) / *((float *)this + 8));
    if (*(void *)&v52 < 3uLL || (uint8x8_t v55 = (uint8x8_t)vcnt_s8(v52), v55.i16[0] = vaddlv_u8(v55), v55.u32[0] > 1uLL))
    {
      unint64_t v54 = std::__next_prime(v54);
    }
    else
    {
      uint64_t v56 = 1 << -(char)__clz(v54 - 1);
      if (v54 >= 2) {
        unint64_t v54 = v56;
      }
    }
    if (prime <= v54) {
      size_t prime = v54;
    }
    if (prime < *(void *)&v52) {
      goto LABEL_3;
    }
  }
LABEL_4:
  uint8x8_t v6 = (uint64_t *)*((void *)a2 + 2);
  if (!v6) {
    goto LABEL_70;
  }
  id v7 = (void *)((char *)this + 16);
  while (2)
  {
    while (2)
    {
      uint64_t v8 = *((unsigned __int8 *)v6 + 16);
      uint64_t v9 = *((unsigned __int8 *)v6 + 17);
      unint64_t v10 = (v9
           - 0x61C8864680B583EBLL
           + ((v8 - 0x61C8864680B583EBLL) << 6)
           + ((unint64_t)(v8 - 0x61C8864680B583EBLL) >> 2)) ^ (v8 - 0x61C8864680B583EBLL);
      uint64_t v11 = *((int *)v6 + 5);
      uint64_t v12 = *((int *)v6 + 6);
      unint64_t v13 = (v11 - 0x61C8864680B583EBLL + (v10 << 6) + (v10 >> 2)) ^ v10;
      unint64_t v14 = (v12 - 0x61C8864680B583EBLL + (v13 << 6) + (v13 >> 2)) ^ v13;
      unint64_t v15 = *((void *)this + 1);
      if (!v15) {
        goto LABEL_30;
      }
      uint8x8_t v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
      v16.i16[0] = vaddlv_u8(v16);
      if (v16.u32[0] > 1uLL)
      {
        uint64_t v2 = (v12 - 0x61C8864680B583EBLL + (v13 << 6) + (v13 >> 2)) ^ v13;
        if (v14 >= v15) {
          uint64_t v2 = v14 % v15;
        }
      }
      else
      {
        uint64_t v2 = v14 & (v15 - 1);
      }
      uint64_t v17 = *(uint64_t ***)(*(void *)this + 8 * v2);
      if (!v17 || (uint64_t v18 = *v17) == 0)
      {
LABEL_30:
        uint64_t v21 = operator new(0x38uLL);
        *uint64_t v21 = 0;
        v21[1] = v14;
        *((_WORD *)v21 + 8) = *((_WORD *)v6 + 8);
        *(void *)((char *)v21 + 20) = *(uint64_t *)((char *)v6 + 20);
        v21[5] = v6[5];
        uint64_t v22 = v6[6];
        v21[6] = v22;
        if (v22) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
        }
        float v23 = (float)(unint64_t)(*((void *)this + 3) + 1);
        float v24 = *((float *)this + 8);
        if (!v15 || (float)(v24 * (float)v15) < v23)
        {
          BOOL v25 = (v15 & (v15 - 1)) != 0;
          if (v15 < 3) {
            BOOL v25 = 1;
          }
          unint64_t v26 = v25 | (2 * v15);
          unint64_t v27 = vcvtps_u32_f32(v23 / v24);
          if (v26 <= v27) {
            size_t v28 = v27;
          }
          else {
            size_t v28 = v26;
          }
          if (v28 == 1)
          {
            size_t v28 = 2;
          }
          else if ((v28 & (v28 - 1)) != 0)
          {
            size_t v28 = std::__next_prime(v28);
          }
          int8x8_t v29 = *(int8x8_t *)((char *)this + 8);
          if (v28 > *(void *)&v29) {
            goto LABEL_44;
          }
          if (v28 < *(void *)&v29)
          {
            unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)this + 3) / *((float *)this + 8));
            if (*(void *)&v29 < 3uLL
              || (uint8x8_t v31 = (uint8x8_t)vcnt_s8(v29), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
            {
              unint64_t v30 = std::__next_prime(v30);
            }
            else
            {
              uint64_t v32 = 1 << -(char)__clz(v30 - 1);
              if (v30 >= 2) {
                unint64_t v30 = v32;
              }
            }
            if (v28 <= v30) {
              size_t v28 = v30;
            }
            if (v28 < *(void *)&v29) {
LABEL_44:
            }
              std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)this, v28);
          }
          unint64_t v15 = *((void *)this + 1);
          if ((v15 & (v15 - 1)) != 0)
          {
            if (v14 >= v15) {
              uint64_t v2 = v14 % v15;
            }
            else {
              uint64_t v2 = v14;
            }
          }
          else
          {
            uint64_t v2 = (v15 - 1) & v14;
          }
        }
        uint64_t v33 = *(void *)this;
        uint64_t v34 = *(void **)(*(void *)this + 8 * v2);
        if (v34)
        {
          *uint64_t v21 = *v34;
        }
        else
        {
          *uint64_t v21 = *v7;
          *id v7 = v21;
          *(void *)(v33 + 8 * v2) = v7;
          if (!*v21) {
            goto LABEL_69;
          }
          unint64_t v35 = *(void *)(*v21 + 8);
          if ((v15 & (v15 - 1)) != 0)
          {
            if (v35 >= v15) {
              v35 %= v15;
            }
          }
          else
          {
            v35 &= v15 - 1;
          }
          uint64_t v34 = (void *)(*(void *)this + 8 * v35);
        }
        void *v34 = v21;
LABEL_69:
        ++*((void *)this + 3);
        uint8x8_t v6 = (uint64_t *)*v6;
        if (v6) {
          continue;
        }
        goto LABEL_70;
      }
      break;
    }
    if (v16.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v20 = v18[1];
        if (v20 == v14)
        {
          if (__PAIR64__(*((unsigned __int8 *)v18 + 17), *((unsigned __int8 *)v18 + 16)) == __PAIR64__(v9, v8)
            && *(uint64_t *)((char *)v18 + 20) == __PAIR64__(v12, v11))
          {
            goto LABEL_6;
          }
        }
        else if ((v20 & (v15 - 1)) != v2)
        {
          goto LABEL_30;
        }
        uint64_t v18 = (uint64_t *)*v18;
        if (!v18) {
          goto LABEL_30;
        }
      }
    }
    while (1)
    {
      unint64_t v19 = v18[1];
      if (v19 == v14) {
        break;
      }
      if (v19 >= v15) {
        v19 %= v15;
      }
      if (v19 != v2) {
        goto LABEL_30;
      }
LABEL_17:
      uint64_t v18 = (uint64_t *)*v18;
      if (!v18) {
        goto LABEL_30;
      }
    }
    if (__PAIR64__(*((unsigned __int8 *)v18 + 17), *((unsigned __int8 *)v18 + 16)) != __PAIR64__(v9, v8)
      || *(uint64_t *)((char *)v18 + 20) != __PAIR64__(v12, v11))
    {
      goto LABEL_17;
    }
LABEL_6:
    uint8x8_t v6 = (uint64_t *)*v6;
    if (v6) {
      continue;
    }
    break;
  }
LABEL_70:
  *((void *)this + 6) = 0;
  *((void *)this + 7) = 0;
  *((void *)this + 5) = (char *)this + 48;
  uint64_t v36 = (char *)*((void *)a2 + 5);
  long long v37 = (char *)a2 + 48;
  if (v36 != v37)
  {
    do
    {
      uint64_t v39 = *((void *)this + 6);
      uint64_t v40 = (char *)this + 48;
      if (*((md::RouteElevationSourceContext **)this + 5) == (md::RouteElevationSourceContext *)((char *)this + 48)) {
        goto LABEL_79;
      }
      double v41 = (char *)*((void *)this + 6);
      double v42 = (char *)this + 48;
      if (v39)
      {
        do
        {
          uint64_t v40 = v41;
          double v41 = (char *)*((void *)v41 + 1);
        }
        while (v41);
      }
      else
      {
        do
        {
          uint64_t v40 = (char *)*((void *)v42 + 2);
          BOOL v43 = *(void *)v40 == (void)v42;
          double v42 = v40;
        }
        while (v43);
      }
      unsigned int v44 = v36[25];
      if (v40[25] > v44)
      {
LABEL_79:
        if (v39) {
          uint64_t v45 = v40;
        }
        else {
          uint64_t v45 = (void *)((char *)this + 48);
        }
        if (v39) {
          uint64_t v46 = v40 + 8;
        }
        else {
          uint64_t v46 = (void *)((char *)this + 48);
        }
      }
      else
      {
        uint64_t v45 = (void *)((char *)this + 48);
        uint64_t v46 = (void *)((char *)this + 48);
        if (v39)
        {
          uint64_t v46 = (void *)((char *)this + 48);
          while (1)
          {
            while (1)
            {
              uint64_t v45 = (void *)v39;
              unsigned int v48 = *(unsigned __int8 *)(v39 + 25);
              if (v44 <= v48) {
                break;
              }
              uint64_t v39 = *v45;
              uint64_t v46 = v45;
              if (!*v45) {
                goto LABEL_94;
              }
            }
            if (v48 <= v44) {
              break;
            }
            uint64_t v46 = v45 + 1;
            uint64_t v39 = v45[1];
            if (!v39) {
              goto LABEL_94;
            }
          }
        }
      }
      if (*v46)
      {
        uint64_t v47 = (char *)*((void *)v36 + 1);
        if (v47) {
          goto LABEL_97;
        }
      }
      else
      {
LABEL_94:
        char v49 = operator new(0x20uLL);
        v49[25] = v36[25];
        *(void *)char v49 = 0;
        *((void *)v49 + 1) = 0;
        *((void *)v49 + 2) = v45;
        void *v46 = v49;
        uint64_t v50 = **((void **)this + 5);
        if (v50)
        {
          *((void *)this + 5) = v50;
          char v49 = (unsigned char *)*v46;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 6), (uint64_t *)v49);
        ++*((void *)this + 7);
        uint64_t v47 = (char *)*((void *)v36 + 1);
        if (v47)
        {
          do
          {
LABEL_97:
            float v51 = v47;
            uint64_t v47 = *(char **)v47;
          }
          while (v47);
          goto LABEL_72;
        }
      }
      do
      {
        float v51 = (char *)*((void *)v36 + 2);
        BOOL v43 = *(void *)v51 == (void)v36;
        uint64_t v36 = v51;
      }
      while (!v43);
LABEL_72:
      uint64_t v36 = v51;
    }
    while (v51 != v37);
  }
  return this;
}

void sub_1A1F9B04C(_Unwind_Exception *a1)
{
  std::__hash_table<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

void md::LabelNavEtaLabeler::clearETALabels(md::LabelNavEtaLabeler *this)
{
  std::__tree<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::__map_value_compare<VKLabelNavRouteEta * {__strong},std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,std::less<VKLabelNavRouteEta * {__strong}>,true>,geo::StdAllocator<std::__value_type<VKLabelNavRouteEta * {__strong},geo::_retain_ptr<VKLabelNavRoadLabel * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>,mdm::Allocator>>::destroy((uint64_t)this + 352, *((void *)this + 45));
  *((void *)this + 47) = 0;
  *((void *)this + 44) = (char *)this + 360;
  *((void *)this + 45) = 0;
  uint64_t v2 = (char *)*((void *)this + 32);
  uint64_t v3 = (char *)this + 264;
  if (v2 != (char *)this + 264)
  {
    do
    {
      uint64_t v4 = *((void *)v2 + 5);
      uint64_t v5 = *((void *)v2 + 6);
      while (v4 != v5)
      {
        id v6 = *(id *)(v4 + 56);
        int v7 = [v6 hasLabel];

        if (v7)
        {
          id v8 = *(id *)(v4 + 56);
          [v8 clearLabel];
        }
        v4 += 72;
      }
      uint64_t v9 = (char *)*((void *)v2 + 1);
      if (v9)
      {
        do
        {
          unint64_t v10 = v9;
          uint64_t v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          unint64_t v10 = (char *)*((void *)v2 + 2);
          BOOL v11 = *(void *)v10 == (void)v2;
          uint64_t v2 = v10;
        }
        while (!v11);
      }
      uint64_t v2 = v10;
    }
    while (v10 != v3);
  }
}

void sub_1A1F9B1E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::RouteElevationSourceContext::~RouteElevationSourceContext(md::RouteElevationSourceContext *this)
{
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 6));
  uint64_t v2 = (void *)*((void *)this + 2);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v4 = (std::__shared_weak_count *)v3[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
  }
  uint64_t v5 = *(void **)this;
  *(void *)this = 0;
  if (v5) {
    operator delete(v5);
  }
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::basic_stringstream[abi:nn180100](uint64_t a1)
{
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = off_1EF57F4C8;
  *(void *)a1 = &unk_1EF52F5D8;
  *(void *)(a1 + 136) = &unk_1EF52F600;
  std::ios_base::init((std::ios_base *)(a1 + 136), (void *)(a1 + 24));
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = -1;
  *(void *)a1 = off_1EF57F4A0;
  *(void *)(a1 + 136) = off_1EF57F4F0;
  *(void *)(a1 + 16) = off_1EF57F4C8;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 24) = &unk_1EF57F2D0;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = 0;
  {
    operator new();
  }
  *(void *)(a1 + 112) = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  *(_DWORD *)(a1 + 128) = 24;
  return a1;
}

void sub_1A1F9B438(_Unwind_Exception *a1)
{
  std::iostream::~basic_iostream();
  MEMORY[0x1A62391A0](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::~basic_stringstream(uint64_t a1)
{
  *(void *)a1 = off_1EF57F4A0;
  uint64_t v2 = a1 + 136;
  *(void *)(a1 + 136) = off_1EF57F4F0;
  *(void *)(a1 + 16) = off_1EF57F4C8;
  *(void *)(a1 + 24) = &unk_1EF57F2D0;
  if (*(char *)(a1 + 111) < 0) {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 112) + 40))(*(void *)(a1 + 112), *(void *)(a1 + 88), *(void *)(a1 + 104) & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1A62391A0](v2);
  return a1;
}

void virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::~basic_stringstream(void *a1)
{
  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24);
  *(void *)uint64_t v1 = off_1EF57F4A0;
  *((void *)v1 + 17) = off_1EF57F4F0;
  *((void *)v1 + 2) = off_1EF57F4C8;
  *((void *)v1 + 3) = &unk_1EF57F2D0;
  if (v1[111] < 0) {
    (*(void (**)(void, void, uint64_t))(**((void **)v1 + 14) + 40))(*((void *)v1 + 14), *((void *)v1 + 11), *((void *)v1 + 13) & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1A62391A0](v1 + 136);
  JUMPOUT(0x1A6239270);
}

{
  char *v1;
  uint64_t vars8;

  uint64_t v1 = (char *)a1 + *(void *)(*a1 - 24);
  *(void *)uint64_t v1 = off_1EF57F4A0;
  *((void *)v1 + 17) = off_1EF57F4F0;
  *((void *)v1 + 2) = off_1EF57F4C8;
  *((void *)v1 + 3) = &unk_1EF57F2D0;
  if (v1[111] < 0) {
    (*(void (**)(void, void, uint64_t))(**((void **)v1 + 14) + 40))(*((void *)v1 + 14), *((void *)v1 + 11), *((void *)v1 + 13) & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  JUMPOUT(0x1A62391A0);
}

void non-virtual thunk to'std::basic_stringstream<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::~basic_stringstream(uint64_t a1)
{
  *(void *)(a1 - 16) = off_1EF57F4A0;
  uint64_t v1 = a1 + 120;
  *(void *)(a1 + 120) = off_1EF57F4F0;
  *(void *)a1 = off_1EF57F4C8;
  *(void *)(a1 + 8) = &unk_1EF57F2D0;
  if (*(char *)(a1 + 95) < 0) {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), *(void *)(a1 + 72), *(void *)(a1 + 88) & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1A62391A0](v1);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)(a1 - 16) = off_1EF57F4A0;
  *(void *)(a1 + 120) = off_1EF57F4F0;
  *(void *)a1 = off_1EF57F4C8;
  *(void *)(a1 + 8) = &unk_1EF57F2D0;
  if (*(char *)(a1 + 95) < 0) {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), *(void *)(a1 + 72), *(void *)(a1 + 88) & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  JUMPOUT(0x1A62391A0);
}

void std::basic_stringstream<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::~basic_stringstream(uint64_t a1)
{
  *(void *)a1 = off_1EF57F4A0;
  uint64_t v1 = a1 + 136;
  *(void *)(a1 + 136) = off_1EF57F4F0;
  *(void *)(a1 + 16) = off_1EF57F4C8;
  *(void *)(a1 + 24) = &unk_1EF57F2D0;
  if (*(char *)(a1 + 111) < 0) {
    (*(void (**)(void, void, uint64_t))(**(void **)(a1 + 112) + 40))(*(void *)(a1 + 112), *(void *)(a1 + 88), *(void *)(a1 + 104) & 0x7FFFFFFFFFFFFFFFLL);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x1A62391A0](v1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__hash_table<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>>>::~__hash_table(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    uint64_t v4 = (std::__shared_weak_count *)v3[6];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    operator delete(v3);
  }
  uint64_t v5 = *(void **)a1;
  *(void *)a1 = 0;
  if (v5) {
    operator delete(v5);
  }
  return a1;
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16))
    {
      uint64_t v3 = (std::__shared_weak_count *)v2[6];
      if (v3)
      {
        if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
          std::__shared_weak_count::__release_weak(v3);
        }
      }
    }
    operator delete(v2);
  }
  return a1;
}

void ___ZN2md18LabelNavEtaLabeler9debugDrawERKNS_13LayoutContextEPNS_10NavContextE_block_invoke(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a1 + 440))
  {
    uint64_t v3 = a2;
    uint64_t v4 = a1;
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v73 = a1 + 48;
    uint64_t v71 = a1 + 444;
    __asm { FMOV            V0.2S, #20.0 }
    float32x2_t v75 = _D0;
    uint64_t v69 = a1;
    uint64_t v70 = a2;
    do
    {
      uint64_t v12 = (id *)(v3 + 24 * v5);
      objc_msgSend(*v12, "route", v69, v70);
      unint64_t v13 = (GEOComposedRoute *)objc_claimAutoreleasedReturnValue();
      unsigned int v14 = md::LabelNavEtaLabeler::indexForRoute((id *)v6, v13);

      int v15 = *(_DWORD *)(v71 + 4 * (v14 % 3));
      uint64_t v72 = v5;
      uint64_t v16 = *(void *)(v4 + 40);
      uint64_t v17 = *(float32x2_t **)(v4 + 432);
      uint64_t v18 = [*v12 route];
      unint64_t v19 = (unsigned char *)(v4 + 4 * ((*(_DWORD *)(v4 + 440) - 1) % 3u));
      id v20 = v18;
      v17[12].i8[0] = v19[456];
      v17[12].i8[1] = v19[457];
      v17[12].i8[2] = v19[458];
      v17[12].i8[3] = v19[459];
      id v74 = v20;
      (*(void (**)(PolylineCoordinate **__return_ptr))(**(void **)(v6 + 40) + 24))(&v77);
      uint64_t v21 = v77;
      long long v76 = v78;
      if (v77 != v78)
      {
        uint64_t v22 = v74;
        do
        {
          float v23 = *(float *)(*(void *)(v16 + 8) + 176);
          float v24 = v22;
          float v25 = *(float *)&v21[1].index;
          float offset = v21->offset;
          if (v21->index != LODWORD(v25) || vabds_f32(offset, v21[1].offset) >= 0.00000011921)
          {
            if (offset == 0.0)
            {
              int v28 = 1;
              float v32 = v21->offset;
            }
            else
            {
              v80[0] = *v21;
              double v27 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(v6 + 48), v24, v80);
              int v28 = 0;
              int8x8_t v29 = *(float64x2_t **)(v16 + 24);
              float32x2_t v2 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v29[60], v29[54], v27), v29[56], v30), v29[58], v31), 1.0 / (v29[61].f64[1] + v29[55].f64[1] * v27 + v29[57].f64[1] * v30 + v29[59].f64[1] * v31)));
              float v32 = v21->offset;
              float v25 = *(float *)&v21[1].index;
            }
            if (v32 <= 0.0) {
              unsigned int index = v21->index;
            }
            else {
              unsigned int index = v21->index + 1;
            }
            if (index == LODWORD(v25))
            {
              v80[0] = (PolylineCoordinate)LODWORD(v25);
              double v34 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(v6 + 48), v24, v80);
              unint64_t v35 = *(float64x2_t **)(v16 + 24);
              float32x2_t v38 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v35[60], v35[54], v34), v35[56], v36), v35[58], v37), 1.0 / (v35[61].f64[1] + v35[55].f64[1] * v34 + v35[57].f64[1] * v36 + v35[59].f64[1] * v37)));
              if (offset == 0.0)
              {
                float v40 = 20.0;
                int v28 = 0;
              }
              else
              {
                float32x2_t v39 = vsub_f32(v38, v2);
                float v40 = sqrtf(vaddv_f32(vmul_f32(v39, v39)));
                v17[1] = v2;
                ggl::DebugConsole::drawSymbol(v17, v15);
                if (v40 >= 20.0)
                {
                  float32x2_t v41 = vmul_f32(vmul_n_f32(v39, 1.0 / v40), v75);
                  do
                  {
                    float v40 = v40 + -20.0;
                    float32x2_t v2 = vadd_f32(v2, v41);
                    v17[1] = v2;
                    ggl::DebugConsole::drawSymbol(v17, v15);
                  }
                  while (v40 >= 20.0);
                }
                int v28 = 0;
              }
            }
            else
            {
              float v40 = 20.0;
              if (index >= LODWORD(v25))
              {
                float32x2_t v38 = v2;
              }
              else
              {
                uint64_t v42 = *(void *)(v16 + 24);
                *(_OWORD *)&v80[0].unsigned int index = *(_OWORD *)(v42 + 136);
                uint64_t v81 = *(void *)(v42 + 152);
                long long v82 = *(_OWORD *)(v42 + 160);
                uint64_t v83 = *(void *)(v42 + 176);
                uint64_t v43 = *(void *)(v6 + 40);
                v84.unsigned int index = index;
                v84.float offset = v25;
                if ((*(unsigned int (**)(uint64_t, uint64_t, const GEOComposedRoute *, PolylineCoordinate *, PolylineCoordinate *, double *))(*(void *)v43 + 32))(v43, v73, v24, v80, &v84, v79))
                {
                  md::RouteSimplifier::simplifiedRibbonIndices(*(void *)(v6 + 48), v24, index, SLODWORD(v25), (void *)(v6 + 80), v23 * ((v79[0] + v79[0]) * *(double *)(v42 + 312)) / *(float *)(v42 + 1064));
                  uint64_t v45 = *(unsigned int **)(v6 + 80);
                  unsigned int v44 = *(unsigned int **)(v6 + 88);
                  uint64_t v22 = v74;
                  if (v45 == v44)
                  {
                    int v46 = v28;
                    float32x2_t v38 = v2;
                  }
                  else
                  {
                    do
                    {
                      PolylineCoordinate v84 = (PolylineCoordinate)*v45;
                      double v48 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(v6 + 48), v24, &v84);
                      char v49 = *(float64x2_t **)(v16 + 24);
                      float32x2_t v38 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v49[60], v49[54], v48), v49[56], v50), v49[58], v51), 1.0/ (v49[61].f64[1] + v49[55].f64[1] * v48 + v49[57].f64[1] * v50 + v49[59].f64[1] * v51)));
                      if (!v28)
                      {
                        float32x2_t v52 = vsub_f32(v38, v2);
                        float v53 = sqrtf(vaddv_f32(vmul_f32(v52, v52)));
                        float v54 = 20.0 - v40;
                        if (v53 < (float)(20.0 - v40))
                        {
                          float v47 = v53;
                        }
                        else
                        {
                          float v47 = v53 - v54;
                          float32x2_t v55 = vmul_n_f32(v52, 1.0 / v53);
                          float32x2_t v56 = vmla_n_f32(v2, v55, v54);
                          v17[1] = v56;
                          ggl::DebugConsole::drawSymbol(v17, v15);
                          float v40 = 0.0;
                          if (v47 >= 20.0)
                          {
                            float32x2_t v57 = vmul_f32(v55, v75);
                            do
                            {
                              float v47 = v47 + -20.0;
                              float32x2_t v56 = vadd_f32(v56, v57);
                              v17[1] = v56;
                              ggl::DebugConsole::drawSymbol(v17, v15);
                            }
                            while (v47 >= 20.0);
                          }
                        }
                        float v40 = v40 + v47;
                      }
                      int v28 = 0;
                      int v46 = 0;
                      ++v45;
                      float32x2_t v2 = v38;
                    }
                    while (v45 != v44);
                  }
                }
                else
                {
                  int v46 = v28;
                  float32x2_t v38 = v2;
                  uint64_t v22 = v74;
                }
                int v28 = v46;
              }
            }
            if (v21[1].offset == 0.0)
            {
              float32x2_t v2 = v38;
            }
            else
            {
              v80[0] = v21[1];
              double v58 = md::RouteSimplifier::worldPointForPolylineCoordinate(*(md::RouteSimplifier **)(v6 + 48), v24, v80);
              BOOL v59 = *(float64x2_t **)(v16 + 24);
              float32x2_t v2 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v59[60], v59[54], v58), v59[56], v60), v59[58], v61), 1.0 / (v59[61].f64[1] + v59[55].f64[1] * v58 + v59[57].f64[1] * v60 + v59[59].f64[1] * v61)));
              if (!v28)
              {
                float32x2_t v62 = vsub_f32(v2, v38);
                float v63 = sqrtf(vaddv_f32(vmul_f32(v62, v62)));
                float v64 = 20.0 - v40;
                if (v63 >= (float)(20.0 - v40))
                {
                  float v65 = v63 - v64;
                  float32x2_t v66 = vmul_n_f32(v62, 1.0 / v63);
                  float32x2_t v67 = vmla_n_f32(v38, v66, v64);
                  v17[1] = v67;
                  ggl::DebugConsole::drawSymbol(v17, v15);
                  if (v65 >= 20.0)
                  {
                    float32x2_t v68 = vmul_f32(v66, v75);
                    do
                    {
                      float v65 = v65 + -20.0;
                      float32x2_t v67 = vadd_f32(v67, v68);
                      v17[1] = v67;
                      ggl::DebugConsole::drawSymbol(v17, v15);
                    }
                    while (v65 >= 20.0);
                  }
                }
              }
            }
          }

          v21 += 2;
        }
        while (v21 != v76);
        uint64_t v21 = v77;
        uint64_t v4 = v69;
        uint64_t v3 = v70;
      }
      if (v21)
      {
        BOOL v78 = v21;
        operator delete(v21);
      }

      uint64_t v5 = v72 + 1;
    }
    while (v72 + 1 < (unint64_t)*(unsigned int *)(v4 + 440));
  }
}

void sub_1A1F9C2B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  _Unwind_Resume(a1);
}

void md::LabelNavEtaLabeler::intersectSimplifiedRouteSectionWithFrustum<md::LabelNavEtaLabeler::debugDraw(md::LayoutContext const&,md::NavContext *)::$_1>(md::NavContext const*,geo::Frustum<double> const&,GEOComposedRoute *,float,gm::Range<geo::PolylineCoordinate> const&,md::LabelNavEtaLabeler::debugDraw(md::LayoutContext const&,md::NavContext *)::$_1)const::{lambda(gm::Matrix<double,3,1> const&,gm::Matrix<double,3,1> const&,md::LabelNavEtaLabeler::debugDraw(md::LayoutContext const&,md::NavContext *)::$_1)#1}::operator()(uint64_t a1, float64x2_t *a2, float64x2_t *a3, float32x2_t *a4)
{
  double v29 = a3[1].f64[0];
  double v27 = a2[1].f64[0];
  double v6 = v29 - v27;
  float64x2_t v28 = *a3;
  float64x2_t v26 = *a2;
  float64x2_t v7 = vsubq_f64(*a3, *a2);
  float64x2_t v33 = *a2;
  double v34 = a2[1].f64[0];
  float64x2_t v25 = v7;
  float64x2_t v35 = v7;
  double v36 = v29 - v27;
  double v32 = 0.0;
  double v31 = 0.0;
  if (geo::Intersect::internal::intersection<double,std::array<gm::Plane3<double>,6ul>>((double *)a1, v33.f64, 2u, &v32, &v31))
  {
    _Q18 = v26;
    double v9 = v27;
    if (v32 > 0.0)
    {
      double v9 = v34 + v6 * v32;
      _Q18 = vmlaq_n_f64(v33, v25, v32);
    }
    _Q20 = v28;
    double v10 = v29;
    if (v31 < 1.0)
    {
      double v10 = v34 + v6 * v31;
      _Q20 = vmlaq_n_f64(v33, v25, v31);
    }
    uint64_t v12 = *(void *)(*(void *)(a1 + 384) + 24);
    _D2 = *(void *)(v12 + 920);
    __asm { FMLA            D4, D2, V18.D[1] }
    double v19 = *(double *)(v12 + 952);
    float64x2_t v20 = *(float64x2_t *)(v12 + 864);
    float64x2_t v21 = *(float64x2_t *)(v12 + 896);
    float64x2_t v22 = vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(v12 + 960), v20, _Q18.f64[0]), v21, _Q18, 1);
    float64x2_t v23 = *(float64x2_t *)(v12 + 928);
    __asm { FMLA            D3, D2, V20.D[1] }
    float32x2_t v30 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(v12 + 960), v20, _Q20.f64[0]), v21, _Q20, 1), v23, v10), 1.0 / (_D3 + v19 * v10)));
    a4[1] = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(v22, v23, v9), 1.0 / (_D4 + v19 * v9)));
    ggl::DebugConsole::drawLine((uint64_t)a4, (float *)&v30);
  }
}

uint64_t __copy_helper_block_ea8_444c83_ZTSZN2md18LabelNavEtaLabeler9debugDrawERKNS_13LayoutContextEPNS_10NavContextEE3__0(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 444);
  *(_DWORD *)(result + 452) = *(_DWORD *)(a2 + 452);
  *(void *)(result + 444) = v2;
  *(_DWORD *)(result + 456) = *(_DWORD *)(a2 + 456);
  *(_DWORD *)(result + 460) = *(_DWORD *)(a2 + 460);
  *(_DWORD *)(result + 464) = *(_DWORD *)(a2 + 464);
  return result;
}

void md::LabelNavEtaLabeler::extractPolylineOverlayInfo(md::LabelNavEtaLabeler *this, VKRouteInfo *a2, float a3)
{
  uint64_t v5 = a2;
  if (v5)
  {
    uint64_t v6 = *((void *)this + 13);
    uint64_t v18 = v5;
    float64x2_t v7 = [(VKRouteInfo *)v5 route];
    id v8 = (*(void (**)(uint64_t, void *))(*(void *)v6 + 56))(v6, v7);

    if (v8)
    {
      float v9 = (*(float (**)(void, void *))(**((void **)this + 13) + 128))(*((void *)this + 13), v8);
      float v10 = (*(float (**)(void, void *, float))(**((void **)this + 13) + 72))(*((void *)this + 13), v8, a3);
      BOOL v11 = (uint64_t *)*((void *)this + 53);
      if (v11)
      {
        while (1)
        {
          while (1)
          {
            unint64_t v13 = v11;
            unint64_t v14 = v11[4];
            if (v14 <= (unint64_t)v18) {
              break;
            }
            BOOL v11 = (uint64_t *)*v13;
            uint64_t v12 = v13;
            if (!*v13) {
              goto LABEL_11;
            }
          }
          if (v14 >= (unint64_t)v18) {
            break;
          }
          BOOL v11 = (uint64_t *)v13[1];
          if (!v11)
          {
            uint64_t v12 = v13 + 1;
            goto LABEL_11;
          }
        }
        uint64_t v15 = (uint64_t)v13;
      }
      else
      {
        uint64_t v12 = (uint64_t *)((char *)this + 424);
        unint64_t v13 = (uint64_t *)((char *)this + 424);
LABEL_11:
        uint64_t v15 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 54) + 16))(*((void *)this + 54), 48, 8);
        *(void *)(v15 + 32) = v18;
        *(void *)(v15 + 40) = 0;
        *(void *)uint64_t v15 = 0;
        *(void *)(v15 + 8) = 0;
        *(void *)(v15 + 16) = v13;
        uint64_t *v12 = v15;
        uint64_t v16 = **((void **)this + 52);
        uint64_t v17 = (uint64_t *)v15;
        if (v16)
        {
          *((void *)this + 52) = v16;
          uint64_t v17 = (uint64_t *)*v12;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 53), v17);
        ++*((void *)this + 55);
      }
      *(float *)(v15 + 40) = v9;
      *(float *)(v15 + 44) = v10;
    }

    uint64_t v5 = v18;
  }
}

void sub_1A1F9C694(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::Logic<md::ElevationLogic,md::ElevationContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

BOOL md::ElevationLogic::_startFlatteningScaleAnimation(md::ElevationLogic *this, float a2)
{
  uint64_t v3 = [[VKTimedAnimation alloc] initWithDuration:a2];
  uint64_t v4 = (void *)*((void *)this + 18);
  *((void *)this + 18) = v3;

  [*((id *)this + 18) setTimingFunction:VKAnimationCurveEaseOut];
  v7[0] = MEMORY[0x1E4F143A8];
  v7[1] = 3221225472;
  v7[2] = ___ZN2md14ElevationLogic30_startFlatteningScaleAnimationEf_block_invoke;
  v7[3] = &__block_descriptor_40_e8_v12__0f8l;
  void v7[4] = this;
  [*((id *)this + 18) setStepHandler:v7];
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  v6[2] = ___ZN2md14ElevationLogic30_startFlatteningScaleAnimationEf_block_invoke_2;
  v6[3] = &__block_descriptor_40_e8_v12__0B8l;
  void v6[4] = this;
  [*((id *)this + 18) setCompletionHandler:v6];
  return md::AnimationRunner::runAnimation(*((md::MapEngine ***)this + 16), *((VKAnimation **)this + 18));
}

uint64_t ___ZN2md14ElevationLogic30_startFlatteningScaleAnimationEf_block_invoke(uint64_t result, float a2)
{
  uint64_t v2 = *(void *)(result + 32);
  if (*(float *)(v2 + 168) < 0.0) {
    a2 = 1.0 - a2;
  }
  *(float *)(v2 + 172) = a2;
  return result;
}

void ___ZN2md14ElevationLogic30_startFlatteningScaleAnimationEf_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  float v2 = 1.0;
  if (*(float *)(v1 + 168) < 0.0) {
    float v2 = 0.0;
  }
  *(float *)(v1 + 172) = v2;
  *(_DWORD *)(v1 + 168) = 0;
  uint64_t v3 = *(void **)(v1 + 144);
  if (v3)
  {
    *(void *)(v1 + 144) = 0;
  }
}

uint64_t std::__function::__func<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_1,std::allocator<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570800;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_1,std::allocator<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF570800;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_1,std::allocator<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_1>,void ()(void)>::~__func()
{
}

uint64_t std::__function::__func<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_0,std::allocator<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5707B8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_0,std::allocator<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF5707B8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_0,std::allocator<md::ElevationLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::ResolvedDependencies const&,md::ElevationContext &)::$_0>,void ()(void)>::~__func()
{
}

uint64_t md::Logic<md::ElevationLogic,md::ElevationContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::ElevationLogic,md::ElevationContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0x8BD499FBD96FBB9ELL && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::StyleLogicContext,md::SettingsContext>,gdc::TypeList<md::LayerDataLogicContext>>::resolveDependencies(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::ElevationContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::ElevationContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5555F0;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0x1000C40C50DD75CLL);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::ElevationContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF5555F0;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40C50DD75CLL);
  }
  return a1;
}

void md::ElevationLogic::createDebugNode(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  strcpy((char *)a2, "ElevationLogic");
  *(_WORD *)(a2 + 23) = 14;
  *(_OWORD *)(a2 + 47) = 0u;
  *(_OWORD *)(a2 + 63) = 0u;
  *(_OWORD *)(a2 + 79) = 0u;
  *(unsigned char *)(a2 + 95) = 0;
  uint64_t v4 = *(uint64_t **)(*(void *)(a1 + 280) + 1128);
  uint64_t v5 = *v4;
  uint64_t v6 = v4[1];
  if (v5 == v6) {
    goto LABEL_7;
  }
  while (*(unsigned char *)v5 != 29)
  {
    v5 += 16;
    if (v5 == v6) {
      goto LABEL_7;
    }
  }
  if (v5 == v6) {
LABEL_7:
  }
    uint64_t v7 = 0;
  else {
    uint64_t v7 = *(int *)(v5 + 8);
  }
  BYTE7(v72[1]) = 10;
  strcpy((char *)v72, "groundMode");
  int v71 = 0;
  memset(&v70[4], 0, 24);
  v70[0] = v7;
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v72, (uint64_t)v70);
  BYTE7(v72[1]) = 14;
  strcpy((char *)v72, "forceElevation");
  id v8 = +[VKDebugSettings sharedSettings];
  int v69 = 0;
  memset(&v68[4], 0, 24);
  v68[0] = [v8 daVinciForceElevatedGround];
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v72, (uint64_t)v68);

  uint64_t v9 = *(unsigned __int8 *)(*(void *)(a1 + 160) + 80);
  BYTE7(v72[1]) = 16;
  strcpy((char *)v72, "isGroundElevated");
  int v67 = 0;
  memset(&v66[4], 0, 24);
  v66[0] = v9;
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v72, (uint64_t)v66);
  float v10 = (char *)operator new(0x28uLL);
  *(void *)&v72[0] = v10;
  *(long long *)((char *)v72 + 8) = xmmword_1A28FD150;
  strcpy(v10, "groundElevationTransitionProgress");
  BOOL v11 = *(_DWORD *)(*(void *)(a1 + 160) + 76) != 0;
  int v65 = 0;
  memset(&v64[4], 0, 24);
  v64[0] = v11;
  gdc::DebugTreeNode::addProperty(a2, (uint64_t)v72, (uint64_t)v64);
  operator delete(v10);
  uint64_t v12 = *(void *)(a1 + 280);
  if (v12)
  {
    uint64_t v13 = *(void *)(v12 + 1064);
    unint64_t v14 = *(std::__shared_weak_count **)(v12 + 1072);
    if (v14)
    {
      atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
      double v15 = *(double *)(v13 + 8);
      long long v40 = *(_OWORD *)(v13 + 16);
      if (!atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
    }
    else
    {
      double v15 = *(double *)(v13 + 8);
      long long v40 = *(_OWORD *)(v13 + 16);
    }
    uint64_t v16 = *(unsigned __int8 **)(a1 + 160);
    BYTE7(v72[1]) = 17;
    strcpy((char *)v72, "ShouldElevateInfo");
    ChildNode = gdc::DebugTreeNode::createChildNode(a2, v72);
    BYTE7(v72[1]) = 10;
    strcpy((char *)v72, "FocusPoint");
    gdc::DebugTreeNode::createChildNode((uint64_t)ChildNode, v72);
    uint64_t v18 = *(const QuadTile **)(*(void *)(*(void *)(a1 + 280) + 896) + 320);
    if (v18)
    {
      long double v19 = tan(v15 * 0.5 + 0.785398163);
      long double v20 = log(v19);
      *(void *)&v21.f64[0] = v40;
      v21.f64[1] = v20;
      __asm { FMOV            V1.2D, #0.5 }
      float64x2_t v27 = vmlaq_f64(_Q1, (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL), v21);
      LOWORD(v72[0]) = 6655;
      DWORD1(v72[0]) = 0x1FFFFFF - vcvtmd_s64_f64(vmuld_lane_f64(33554432.0, v27, 1));
      DWORD2(v72[0]) = vcvtmd_s64_f64(33554432.0 * v27.f64[0]);
      md::DaVinciGroundMetaData::queryMetaTileFromTile((md::DaVinciGroundMetaData *)&v62, v18);
      if (v62)
      {
        uint64_t v28 = *(unsigned __int8 *)(v62 + 169);
        uint64_t v29 = *(int *)(v62 + 172);
        uint64_t v30 = *(int *)(v62 + 176);
        BYTE7(v72[1]) = 8;
        strcpy((char *)v72, "Metadata");
        double v31 = gdc::DebugTreeNode::createChildNode((uint64_t)ChildNode, v72);
        BYTE7(v72[1]) = 1;
        strcpy((char *)v72, "x");
        int v61 = 0;
        memset(&v60[4], 0, 24);
        v60[0] = v30;
        gdc::DebugTreeNode::addProperty((uint64_t)v31, (uint64_t)v72, (uint64_t)v60);
        BYTE7(v72[1]) = 1;
        strcpy((char *)v72, "y");
        int v59 = 0;
        memset(&v58[4], 0, 24);
        v58[0] = v29;
        gdc::DebugTreeNode::addProperty((uint64_t)v31, (uint64_t)v72, (uint64_t)v58);
        BYTE7(v72[1]) = 1;
        strcpy((char *)v72, "z");
        int v57 = 0;
        memset(&v56[4], 0, 24);
        v56[0] = v28;
        gdc::DebugTreeNode::addProperty((uint64_t)v31, (uint64_t)v72, (uint64_t)v56);
      }
      double v32 = v63;
      if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    BYTE7(v72[1]) = 19;
    strcpy((char *)v72, "shouldElevateGround");
    uint64_t v33 = v16[40];
    int v55 = 0;
    memset(&v54[4], 0, 24);
    v54[0] = v33;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v72, (uint64_t)v54);
    uint64_t v34 = v16[41];
    BYTE7(v72[1]) = 11;
    strcpy((char *)v72, "hasMetaData");
    int v53 = 0;
    memset(&v52[4], 0, 24);
    v52[0] = v34;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v72, (uint64_t)v52);
    uint64_t v35 = v16[42];
    BYTE7(v72[1]) = 13;
    strcpy((char *)v72, "needsMetaData");
    int v51 = 0;
    memset(&v50[4], 0, 24);
    v50[0] = v35;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v72, (uint64_t)v50);
    uint64_t v36 = v16[43];
    BYTE7(v72[1]) = 19;
    strcpy((char *)v72, "targetInCuratedArea");
    int v49 = 0;
    memset(&v48[4], 0, 24);
    v48[0] = v36;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v72, (uint64_t)v48);
    uint64_t v37 = v16[44];
    BYTE7(v72[1]) = 17;
    strcpy((char *)v72, "targetIsInLowZoom");
    int v47 = 0;
    memset(&v46[4], 0, 24);
    v46[0] = v37;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v72, (uint64_t)v46);
    int v38 = v16[46];
    BYTE7(v72[1]) = 5;
    strcpy((char *)v72, "flags");
    unint64_t v39 = 0x3030303030303030;
    if (v38)
    {
      if (v16[45]) {
        unint64_t v39 = 0x3130303030303030;
      }
      if ((v16[45] & 2) != 0) {
        v39 |= 0x31000000000000uLL;
      }
      if ((v16[45] & 4) != 0) {
        v39 |= 0x310000000000uLL;
      }
      if ((v16[45] & 8) != 0) {
        v39 |= 0x3100000000uLL;
      }
      if ((v16[45] & 0x10) != 0) {
        unint64_t v39 = v39 & 0xFFFFFFFF00FFFFFFLL | 0x31000000;
      }
      if ((v16[45] & 0x20) != 0) {
        unint64_t v39 = v39 & 0xFFFFFFFFFF00FFFFLL | 0x310000;
      }
      if ((v16[45] & 0x40) != 0) {
        unint64_t v39 = v39 & 0xFFFFFFFFFFFF00FFLL | 0x3100;
      }
      if ((char)v16[45] < 0) {
        unint64_t v39 = v39 & 0xFFFFFFFFFFFFFF00 | 0x31;
      }
    }
    uint64_t v43 = 0;
    uint64_t v44 = 0x800000000000000;
    int v45 = 4;
    unint64_t v42 = v39;
    gdc::DebugTreeNode::addProperty((uint64_t)ChildNode, (uint64_t)v72, (uint64_t)v41);
  }
}

void sub_1A1F9D298(_Unwind_Exception *a1)
{
  gdc::DebugTreeNode::~DebugTreeNode(v1);
  _Unwind_Resume(a1);
}

double md::ElevationLogic::didBecomeInactive(md::ElevationLogic *this)
{
  double result = 0.0;
  *((_OWORD *)this + 14) = 0u;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 12) = 0u;
  *((_OWORD *)this + 13) = 0u;
  *((_OWORD *)this + 11) = 0u;
  return result;
}

void md::ElevationLogic::~ElevationLogic(md::ElevationLogic *this)
{
  md::ElevationLogic::~ElevationLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  md::ElevationLogic *v4;
  std::__shared_weak_count *v5;

  *(void *)this = &unk_1EF533990;
  uint64_t v2 = (void *)*((void *)this + 18);
  if (v2)
  {
    [v2 stop];
    uint64_t v3 = (void *)*((void *)this + 18);
    if (v3)
    {
      *((void *)this + 18) = 0;
    }
  }
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable((uint64_t)this + 336);
  if (!*((unsigned char *)this + 328))
  {
LABEL_8:
    uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 33);
    if (!v5) {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
  uint64_t v4 = (md::ElevationLogic *)*((void *)this + 40);
  if (v4 != (md::ElevationLogic *)((char *)this + 296))
  {
    if (v4) {
      (*(void (**)(md::ElevationLogic *))(*(void *)v4 + 40))(v4);
    }
    goto LABEL_8;
  }
  (*(void (**)(char *))(*((void *)this + 37) + 32))((char *)this + 296);
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 33);
  if (!v5) {
    goto LABEL_12;
  }
LABEL_9:
  if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
LABEL_12:
  *((void *)this + 17) = &unk_1EF5596D8;

  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void sub_1A1F9D488(_Unwind_Exception *a1)
{
  md::Monitorable<md::ConfigValue<GEOConfigKeyBOOL,BOOL>>::~Monitorable(v1 + 336);
  std::optional<std::function<void ()(std::optional<double> const&)>>::~optional(v1 + 296);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 256);
  *(void *)(v1 + 136) = &unk_1EF5596D8;

  md::Logic<md::DrapingLogic,md::DrapingContext,md::LogicDependencies<gdc::TypeList<md::OverlaysContext,md::CameraContext,md::PendingSceneContext,md::ElevationContext>,gdc::TypeList<>>>::~Logic(v1);
  _Unwind_Resume(a1);
}

uint64_t std::optional<std::function<void ()(std::optional<double> const&)>>::~optional(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 32))
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2 == a1)
    {
      (*(void (**)(uint64_t))(*(void *)a1 + 32))(a1);
    }
    else if (v2)
    {
      (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
    }
  }
  return a1;
}

void geo::_retain_ptr<VKTimedAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5596D8;

  JUMPOUT(0x1A6239270);
}

uint64_t geo::_retain_ptr<VKTimedAnimation * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF5596D8;

  return a1;
}

void std::__function::__func<md::ElevationLogic::ElevationLogic(md::World *,md::MapEngine *,md::RunLoopController *,md::AnimationRunner const*,BOOL,md::DaVinciTransitionManager const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ElevationLogic::ElevationLogic(md::World *,md::MapEngine *,md::RunLoopController *,md::AnimationRunner const*,BOOL,md::DaVinciTransitionManager const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::operator()()
{
  id v0 = [MEMORY[0x1E4F64AC8] modernLoader];
  [v0 shrinkDiskCacheToSize:0 callbackQ:MEMORY[0x1E4F14428] finished:&__block_literal_global_6698];
}

void sub_1A1F9D67C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZZN2md14ElevationLogicC1EPNS_5WorldEPNS_9MapEngineEPNS_17RunLoopControllerEPKNS_15AnimationRunnerEbPKNS_24DaVinciTransitionManagerEPU28objcproto17OS_dispatch_queue8NSObjectENK3__0clEb_block_invoke()
{
  id v0 = [MEMORY[0x1E4F64AC8] modernLoader];
  [v0 clearAllCaches];

  id v1 = [MEMORY[0x1E4F28EB8] defaultCenter];
  [v1 postNotificationName:@"VKShouldFlushTileCachesNotification" object:0];
}

void sub_1A1F9D70C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<md::ElevationLogic::ElevationLogic(md::World *,md::MapEngine *,md::RunLoopController *,md::AnimationRunner const*,BOOL,md::DaVinciTransitionManager const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ElevationLogic::ElevationLogic(md::World *,md::MapEngine *,md::RunLoopController *,md::AnimationRunner const*,BOOL,md::DaVinciTransitionManager const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1EF51DC78;
  return result;
}

void std::__function::__func<md::ElevationLogic::ElevationLogic(md::World *,md::MapEngine *,md::RunLoopController *,md::AnimationRunner const*,BOOL,md::DaVinciTransitionManager const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0,std::allocator<md::ElevationLogic::ElevationLogic(md::World *,md::MapEngine *,md::RunLoopController *,md::AnimationRunner const*,BOOL,md::DaVinciTransitionManager const*,NSObject  {objcproto17OS_dispatch_queue}*)::$_0>,void ()(BOOL)>::~__func()
{
}

unsigned char *md::ElevationLogic::setElevationAdjustmentFeedback(unsigned char *result, unsigned char *a2)
{
  uint64_t v2 = result;
  v9[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = result + 296;
  if (result[328] == a2[32])
  {
    if (result[328])
    {
      uint64_t v4 = (unsigned char *)*((void *)a2 + 3);
      if (v4)
      {
        if (v4 == a2)
        {
          id v8 = v7;
          (*(void (**)(unsigned char *, void *))(*(void *)a2 + 24))(a2, v7);
        }
        else
        {
          id v8 = (void *)(*(uint64_t (**)(unsigned char *))(*(void *)v4 + 16))(v4);
        }
      }
      else
      {
        id v8 = 0;
      }
      if (v3 != v7)
      {
        uint64_t v5 = v8;
        uint64_t v6 = (void *)*((void *)v2 + 40);
        if (v8 == v7)
        {
          if (v6 == v3)
          {
            (*(void (**)(void *, void *))(v7[0] + 24))(v7, v9);
            (*(void (**)(void *))(*v8 + 32))(v8);
            id v8 = 0;
            (*(void (**)(void, void *))(**((void **)v2 + 40) + 24))(*((void *)v2 + 40), v7);
            (*(void (**)(void))(**((void **)v2 + 40) + 32))(*((void *)v2 + 40));
            *((void *)v2 + 40) = 0;
            id v8 = v7;
            (*(void (**)(void *, void *))(v9[0] + 24))(v9, v3);
            (*(void (**)(void *))(v9[0] + 32))(v9);
          }
          else
          {
            (*(void (**)(void *, void *))(v7[0] + 24))(v7, v3);
            (*(void (**)(void *))(*v8 + 32))(v8);
            id v8 = (void *)*((void *)v2 + 40);
          }
          *((void *)v2 + 40) = v3;
        }
        else if (v6 == v3)
        {
          (*(void (**)(void *, void *))(*((void *)v2 + 37) + 24))(v3, v7);
          (*(void (**)(void))(**((void **)v2 + 40) + 32))(*((void *)v2 + 40));
          *((void *)v2 + 40) = v8;
          id v8 = v7;
        }
        else
        {
          id v8 = (void *)*((void *)v2 + 40);
          *((void *)v2 + 40) = v5;
        }
      }
      double result = v8;
      if (v8 == v7)
      {
        return (unsigned char *)(*(uint64_t (**)(void *))(v7[0] + 32))(v7);
      }
      else if (v8)
      {
        return (unsigned char *)(*(uint64_t (**)(void))(*v8 + 40))();
      }
    }
  }
  else if (result[328])
  {
    double result = (unsigned char *)*((void *)result + 40);
    if (result == (unsigned char *)v3)
    {
      double result = (unsigned char *)(*(uint64_t (**)(void *))(*v3 + 32))(v3);
      v2[328] = 0;
    }
    else
    {
      if (result) {
        double result = (unsigned char *)(*(uint64_t (**)(unsigned char *))(*(void *)result + 40))(result);
      }
      v2[328] = 0;
    }
  }
  else
  {
    double result = (unsigned char *)*((void *)a2 + 3);
    if (result)
    {
      if (result == a2)
      {
        *((void *)v2 + 40) = v3;
        double result = (unsigned char *)(*(uint64_t (**)(void, void *))(**((void **)a2 + 3) + 24))(*((void *)a2 + 3), v3);
      }
      else
      {
        double result = (unsigned char *)(*(uint64_t (**)(unsigned char *))(*(void *)result + 16))(result);
        *((void *)v2 + 40) = result;
      }
    }
    else
    {
      *((void *)v2 + 40) = 0;
    }
    v2[328] = 1;
  }
  return result;
}

void md::ElevationLogic::setFlyoverTour(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 264);
  *(void *)(a1 + 256) = a2;
  *(void *)(a1 + 264) = a3;
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

uint64_t std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_4,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_4>,void ()(unsigned long,float)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51DF48;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_4,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_4>,void ()(unsigned long,float)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF51DF48;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_4,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_4>,void ()(unsigned long,float)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_3,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_3>,void ()(unsigned long,float)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51DF00;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_3,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_3>,void ()(unsigned long,float)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF51DF00;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_3,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_3>,void ()(unsigned long,float)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_2,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_2>,void ()(unsigned long,float)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51DEB8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_2,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_2>,void ()(unsigned long,float)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF51DEB8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_2,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_2>,void ()(unsigned long,float)>::~__func()
{
}

uint64_t std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_1,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_1>,void ()(unsigned long,float)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51DE70;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_1,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_1>,void ()(unsigned long,float)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF51DE70;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_1,std::allocator<md::LabelStyleContext::applyScales(md::StyleSettingsObjectNode const*)::$_1>,void ()(unsigned long,float)>::~__func()
{
}

void DaVinci::GetDataIDs(DaVinci *this)
{
  {
    uint64_t v1 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>();
    uint64_t v2 = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>();
    uint64_t v3 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::View>>();
    uint64_t v4 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>();
    uint64_t v5 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>();
    uint64_t v6 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Transform>>();
    uint64_t v7 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>();
    uint64_t v8 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>();
    uint64_t v9 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>();
    uint64_t v10 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Style>>();
    uint64_t v11 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>();
    uint64_t v12 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>();
    uint64_t v13 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>();
    uint64_t v14 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>();
    uint64_t v15 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>();
    uint64_t v16 = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>();
    uint64_t v17 = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>();
    uint64_t v18 = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>();
    uint64_t v19 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Clipping>>();
    uint64_t v20 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RibbonStyle>>();
    uint64_t v21 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>>();
    uint64_t v22 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ClippedStroke>>();
    uint64_t v23 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>();
    uint64_t v24 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>();
    uint64_t v25 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>>();
    uint64_t v26 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>();
    uint64_t v27 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>();
    uint64_t v28 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>();
    uint64_t v29 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>();
    uint64_t v30 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>();
    uint64_t v31 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>();
    uint64_t v32 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>();
    uint64_t v33 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>();
    uint64_t v34 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>();
    uint64_t v35 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>();
    uint64_t v36 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>();
    uint64_t v37 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>();
    uint64_t v38 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>();
    uint64_t v39 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedFillStyle>>();
    uint64_t v40 = gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>();
    uint64_t v41 = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>();
    uint64_t v42 = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>();
    uint64_t v43 = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>();
    uint64_t v44 = gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>();
    uint64_t v45 = gdc::typeIndex<DaVinci::AmbientTexture>();
    uint64_t v46 = gdc::typeIndex<DaVinci::ShadowTexture>();
    uint64_t v47 = gdc::typeIndex<DaVinci::TexTexture>();
    uint64_t v48 = gdc::typeIndex<DaVinci::OcclusionTexture>();
    uint64_t v49 = gdc::typeIndex<DaVinci::RouteMaskTexture>();
    __guard v50 = gdc::typeIndex<DaVinci::EmissiveTexture>();
    __guard v51 = gdc::typeIndex<DaVinci::OverlayTexture>();
    __guard v52 = gdc::typeIndex<DaVinci::StyleIndexTexture>();
    __guard v53 = gdc::typeIndex<DaVinci::StyleTexture>();
    __guard v54 = gdc::typeIndex<DaVinci::AridityTexture>();
    __guard v55 = gdc::typeIndex<DaVinci::TemperatureTexture>();
    __guard v56 = gdc::typeIndex<DaVinci::Gradient1Texture>();
    __guard v57 = gdc::typeIndex<DaVinci::Gradient2Texture>();
    __guard v58 = gdc::typeIndex<DaVinci::DiffuseTexture>();
    uint64_t v59 = gdc::typeIndex<DaVinci::AlphaTexture>();
    DaVinci::GetDataIDs(void)::kDataIDs = 0u;
    unk_1E958C6C8 = 0u;
    dword_1E958C6D8 = 1065353216;
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v1, v1);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v2, v2);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v3, v3);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v4, v4);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v5, v5);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v6, v6);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v7, v7);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v8, v8);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v9, v9);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v10, v10);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v11, v11);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v12, v12);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v13, v13);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v14, v14);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v15, v15);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v16, v16);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v17, v17);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v18, v18);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v19, v19);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v20, v20);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v21, v21);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v22, v22);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v23, v23);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v24, v24);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v25, v25);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v26, v26);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v27, v27);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v28, v28);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v29, v29);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v30, v30);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v31, v31);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v32, v32);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v33, v33);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v34, v34);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v35, v35);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v36, v36);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v37, v37);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v38, v38);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v39, v39);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v40, v40);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v41, v41);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v42, v42);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v43, v43);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v44, v44);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v45, v45);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v46, v46);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v47, v47);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v48, v48);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v49, v49);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v50, v50);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v51, v51);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v52, v52);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v53, v53);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v54, v54);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v55, v55);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v56, v56);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v57, v57);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v58, v58);
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__emplace_unique_key_args<unsigned long,unsigned long const&>((uint64_t)&DaVinci::GetDataIDs(void)::kDataIDs, v59, v59);
    __cxa_atexit((void (*)(void *))std::unordered_set<unsigned long>::~unordered_set[abi:nn180100], &DaVinci::GetDataIDs(void)::kDataIDs, &dword_1A1780000);
  }
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>()
{
  id v0 = &qword_1E958C000;
  {
    id v0 = &qword_1E958C000;
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      id v0 = &qword_1E958C000;
    }
  }
  return v0[293];
}

uint64_t gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::InstanceTransform>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[23];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::View>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::View>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[41];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RasterOverlay>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[55];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::Blending::SRGBBlendStyle>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[89];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Transform>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Transform>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[45];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Shadow>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[85];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightConfigurationVertex>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[91];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[63];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Style>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::Style>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[83];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSunMatrix>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[59];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleTransitionToFlat>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[81];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GroundAtmosphere>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[61];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleCameraLighting>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[75];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::LinearDepth>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[39];
}

uint64_t gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Normals>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[27];
}

uint64_t gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::UVs>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[25];
}

uint64_t gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::DeviceDataTyped<ggl::DaVinci::Elevations>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[21];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Clipping>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::Tile::Clipping>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[43];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RibbonStyle>>()
{
  id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
  {
    id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RibbonStyle>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    }
  }
  return v0[73];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>>()
{
  id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
  {
    id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinciTraffic::Style>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    }
  }
  return v0[71];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ClippedStroke>>()
{
  id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
  {
    id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ClippedStroke>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    }
  }
  return v0[75];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::Lighting::LightSpecularConfiguration>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[93];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::RenderTargetSize>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[65];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>>()
{
  id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
  {
    id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LightingDebugOptions>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    }
  }
  return v0[79];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ColorCorrectionFactor>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[79];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedStroke>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[57];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[67];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleShadow>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[51];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[71];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[77];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[53];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleBlend>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[47];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[87];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[49];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[73];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedFillStyle>>()
{
  id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
  {
    id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::ElevatedFillStyle>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    }
  }
  return v0[77];
}

uint64_t gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>()
{
  {
    if (v2)
    {
      gdc::typeIndex<ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters>>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[69];
}

uint64_t gdc::typeIndex<DaVinci::AmbientTexture>()
{
  id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
  {
    id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    if (v2)
    {
      gdc::typeIndex<DaVinci::AmbientTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    }
  }
  return v0[87];
}

uint64_t gdc::typeIndex<DaVinci::ShadowTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::ShadowTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[99];
}

uint64_t gdc::typeIndex<DaVinci::TexTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::TexTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[95];
}

uint64_t gdc::typeIndex<DaVinci::OcclusionTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::OcclusionTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[113];
}

uint64_t gdc::typeIndex<DaVinci::RouteMaskTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::RouteMaskTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[115];
}

__guard gdc::typeIndex<DaVinci::EmissiveTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::EmissiveTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[107];
}

__guard gdc::typeIndex<DaVinci::OverlayTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::OverlayTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[105];
}

__guard gdc::typeIndex<DaVinci::StyleIndexTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::StyleIndexTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[117];
}

__guard gdc::typeIndex<DaVinci::StyleTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::StyleTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[97];
}

__guard gdc::typeIndex<DaVinci::AridityTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::AridityTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[101];
}

__guard gdc::typeIndex<DaVinci::TemperatureTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::TemperatureTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[119];
}

__guard gdc::typeIndex<DaVinci::Gradient1Texture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::Gradient1Texture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[109];
}

__guard gdc::typeIndex<DaVinci::Gradient2Texture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::Gradient2Texture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[111];
}

__guard gdc::typeIndex<DaVinci::DiffuseTexture>()
{
  {
    if (v2)
    {
      gdc::typeIndex<DaVinci::DiffuseTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
  }
  return v0[103];
}

uint64_t gdc::typeIndex<DaVinci::AlphaTexture>()
{
  id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
  {
    id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    if (v2)
    {
      gdc::typeIndex<DaVinci::AlphaTexture>(void)::unsigned int index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      id v0 = &ggl::MeshTyped<ggl::VSCommon::Vertex>::attributesReflection(void)::r;
    }
  }
  return v0[81];
}

void md::Logic<md::MaterialLogic,md::MaterialContext,md::LogicDependencies<gdc::TypeList<md::AssetContext,md::IdentifiedResourceContext,md::RegistryContext,md::SceneQueryContext,md::StyleLogicContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

uint64_t gdc::Registry::storage<md::components::SupportsFlexing>(int8x8_t *a1)
{
  uint64_t v10 = 0x3E7F125C68B9E585;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x3E7F125C68B9E585;
    if (*(void *)&v1 <= 0x3E7F125C68B9E585uLL) {
      uint64_t v3 = 0x3E7F125C68B9E585uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x3E7F125C68B9E585;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x3E7F125C68B9E585)
      {
        if (v5[2] == 0x3E7F125C68B9E585) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x3E7F125C68B9E585) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x3E7F125C68B9E585) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1F9FD94(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<md::components::DidResolvePendingMaterial>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::components::DidResolvePendingMaterial>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::components::DidResolvePendingMaterial>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::components::DidResolvePendingMaterial>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

BOOL gdc::ComponentStorageWrapper<md::components::SupportsFlexing>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::components::SupportsFlexing>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::components::SupportsFlexing>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::components::SupportsFlexing>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void md::MaterialLogic::_updateMaterialForComponent(uint64_t a1, int8x8_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v26 = a3;
  if (a5 && (unsigned int v8 = *(unsigned __int16 *)(a5 + 10), *(_WORD *)(a5 + 10)))
  {
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    unsigned int v11 = 0;
    uint64_t v12 = *(int8x8_t **)(a1 + 120);
    uint64_t v28 = (uint64_t *)*a4;
    do
    {
      if (v11 < v8)
      {
        unint64_t v10 = (unsigned int *)(*(void *)a5 + 4 * v11);
        uint64_t v5 = (unsigned __int16 *)(*(void *)a5 + *(unsigned __int16 *)(a5 + 8) + 2 * v11);
      }
      v9 ^= (*v5
           - 0x61C8864680B583EBLL
           + ((((v9 << 6) - 0x61C8864680B583EBLL + (v9 >> 2) + *v10) ^ v9) << 6)
           + ((((v9 << 6) - 0x61C8864680B583EBLL + (v9 >> 2) + *v10) ^ v9) >> 2)) ^ ((v9 << 6)
                                                                                   - 0x61C8864680B583EBLL
                                                                                   + (v9 >> 2)
                                                                                   + *v10);
      unsigned int v13 = v11 + 1;
      if (v11 + 1 < v8) {
        ++v11;
      }
      else {
        unsigned int v11 = v8;
      }
    }
    while (v13 < v8);
    uint64_t v29 = v9;
    uint64_t v14 = a5;
  }
  else
  {
    uint64_t v12 = *(int8x8_t **)(a1 + 120);
    uint64_t v28 = (uint64_t *)*a4;
    uint64_t v29 = 0;
    uint64_t v14 = 0;
  }
  gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v24, v12, (uint64_t *)&v28, v14);
  uint64_t v15 = (std::__shared_weak_count *)a4[2];
  uint64_t v22 = a4[1];
  uint64_t v23 = v15;
  if (v15) {
    atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v17 = v24;
  uint64_t v16 = (uint64_t)v25;
  if (v25) {
    atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v18 = (std::__shared_weak_count *)a4[2];
  a4[1] = v17;
  a4[2] = v16;
  if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
    std::__shared_weak_count::__release_weak(v18);
  }
  if (v22 && v24)
  {
    if (*(unsigned __int8 *)(v22 + 8) == *(unsigned __int8 *)(v24 + 8)
      && *(void *)(v22 + 48) == *(void *)(v24 + 48)
      && *(void *)(v22 + 16) == *(void *)(v24 + 16)
      && *(void *)(v22 + 32) == *(void *)(v24 + 32))
    {
      goto LABEL_30;
    }
  }
  else if (!(v22 | v24))
  {
    goto LABEL_30;
  }
  uint64_t v19 = *(void **)(gdc::Registry::storage<md::components::Material>(a2) + 128);
  if (!v19)
  {
LABEL_30:
    if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
    uint64_t v21 = v25;
    if (v25)
    {
      if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
        std::__shared_weak_count::__release_weak(v21);
      }
    }
    return;
  }
  while (1)
  {
    uint64_t v28 = &v26;
    uint64_t v29 = 1;
    uint64_t v27 = a2;
    uint64_t v20 = v19[6];
    if (!v20) {
      break;
    }
    (*(void (**)(uint64_t, int8x8_t **, uint64_t **))(*(void *)v20 + 48))(v20, &v27, &v28);
    uint64_t v19 = (void *)*v19;
    if (!v19) {
      goto LABEL_30;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  __break(1u);
}

void sub_1A1FA03A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11)
{
}

BOOL gdc::ComponentStorageWrapper<md::components::FlexClientStateChanged>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::components::FlexClientStateChanged>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::components::FlexClientStateChanged>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::components::FlexClientStateChanged>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

void *std::function<BOOL ()(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<gms::MaterialManager<ggl::Texture2D>::addMaterialSheet(unsigned long long,std::shared_ptr<gms::MaterialSheet<ggl::Texture2D>>)::{lambda(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)#1},std::allocator<gms::MaterialManager<ggl::Texture2D>::addMaterialSheet(unsigned long long,std::shared_ptr<gms::MaterialSheet<ggl::Texture2D>>)::{lambda(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)#1}>,BOOL ()(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57CB88;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<gms::MaterialManager<ggl::Texture2D>::addMaterialSheet(unsigned long long,std::shared_ptr<gms::MaterialSheet<ggl::Texture2D>>)::{lambda(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)#1},std::allocator<gms::MaterialManager<ggl::Texture2D>::addMaterialSheet(unsigned long long,std::shared_ptr<gms::MaterialSheet<ggl::Texture2D>>)::{lambda(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)#1}>,BOOL ()(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)>::__clone(uint64_t a1)
{
  double result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *double result = &unk_1EF57CB88;
  result[1] = v3;
  return result;
}

void std::__function::__func<gms::MaterialManager<ggl::Texture2D>::addMaterialSheet(unsigned long long,std::shared_ptr<gms::MaterialSheet<ggl::Texture2D>>)::{lambda(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)#1},std::allocator<gms::MaterialManager<ggl::Texture2D>::addMaterialSheet(unsigned long long,std::shared_ptr<gms::MaterialSheet<ggl::Texture2D>>)::{lambda(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)#1}>,BOOL ()(gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey const&)>::~__func()
{
}

BOOL gdc::ComponentStorageWrapper<md::components::QueuedForMaterialDeletion>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<md::components::QueuedForMaterialDeletion>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<md::components::QueuedForMaterialDeletion>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<md::components::QueuedForMaterialDeletion>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

__n128 std::__function::__func<md::MaterialLogic::_destroyOutgoingMaterials(md::IdentifiedResourceContext const&)::$_0,std::allocator<md::MaterialLogic::_destroyOutgoingMaterials(md::IdentifiedResourceContext const&)::$_0>,void ()(gdc::Registry *)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56FD50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::MaterialLogic::_destroyOutgoingMaterials(md::IdentifiedResourceContext const&)::$_0,std::allocator<md::MaterialLogic::_destroyOutgoingMaterials(md::IdentifiedResourceContext const&)::$_0>,void ()(gdc::Registry *)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x18uLL);
  *(void *)uint64_t v2 = &unk_1EF56FD50;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  return result;
}

void std::__function::__func<md::MaterialLogic::_destroyOutgoingMaterials(md::IdentifiedResourceContext const&)::$_0,std::allocator<md::MaterialLogic::_destroyOutgoingMaterials(md::IdentifiedResourceContext const&)::$_0>,void ()(gdc::Registry *)>::~__func()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13MaterialLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12AssetContextENS2_25IdentifiedResourceContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15MaterialContextEE3__1NS_9allocatorISN_EEFvvEE7__cloneEPNS0_6__baseISQ_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56FDE0;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13MaterialLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12AssetContextENS2_25IdentifiedResourceContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15MaterialContextEE3__1NS_9allocatorISN_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF56FDE0;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13MaterialLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12AssetContextENS2_25IdentifiedResourceContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15MaterialContextEE3__1NS_9allocatorISN_EEFvvEED0Ev()
{
}

uint64_t _ZNKSt3__110__function6__funcIZN2md13MaterialLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12AssetContextENS2_25IdentifiedResourceContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15MaterialContextEE3__0NS_9allocatorISN_EEFvvEE7__cloneEPNS0_6__baseISQ_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56FD98;
  a2[1] = v2;
  return result;
}

void *_ZNKSt3__110__function6__funcIZN2md13MaterialLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12AssetContextENS2_25IdentifiedResourceContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15MaterialContextEE3__0NS_9allocatorISN_EEFvvEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF56FD98;
  result[1] = v3;
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13MaterialLogic29runBeforeLayoutAtVariableRateERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_12AssetContextENS2_25IdentifiedResourceContextENS2_15RegistryContextENS2_17SceneQueryContextENS2_17StyleLogicContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15MaterialContextEE3__0NS_9allocatorISN_EEFvvEED0Ev()
{
}

uint64_t md::Logic<md::MaterialLogic,md::MaterialContext,md::LogicDependencies<gdc::TypeList<md::AssetContext,md::IdentifiedResourceContext,md::RegistryContext,md::SceneQueryContext,md::StyleLogicContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::MaterialLogic,md::MaterialContext,md::LogicDependencies<gdc::TypeList<md::AssetContext,md::IdentifiedResourceContext,md::RegistryContext,md::SceneQueryContext,md::StyleLogicContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) == 0xD2404CDD1F9A6950 && (uint64_t v4 = *(void *)(a3 + 32)) != 0)
  {
    uint64_t v6 = result;
    md::LogicDependencies<gdc::TypeList<md::AssetContext,md::IdentifiedResourceContext,md::RegistryContext,md::SceneQueryContext,md::StyleLogicContext>,gdc::TypeList<>>::buildRequiredTuple<md::AssetContext,md::IdentifiedResourceContext,md::RegistryContext,md::SceneQueryContext,md::StyleLogicContext>(v7, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
    return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v6 + 160))(v6, a2, v7, v4);
  }
  else
  {
    a4[23] = 0;
    *a4 = 0;
  }
  return result;
}

uint64_t gdc::ObjectHolder<md::MaterialContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::MaterialContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555500;
  uint64_t v1 = (md::MaterialContext *)a1[4];
  if (v1)
  {
    md::MaterialContext::~MaterialContext(v1);
    MEMORY[0x1A6239270]();
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::MaterialContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555500;
  uint64_t v2 = (md::MaterialContext *)a1[4];
  if (v2)
  {
    md::MaterialContext::~MaterialContext(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::MaterialLogic::~MaterialLogic(md::MaterialLogic *this)
{
  md::MaterialLogic::~MaterialLogic(this);
  JUMPOUT(0x1A6239270);
}

{
  void *v2;
  void *v3;
  void *v4;
  std::__shared_weak_count *v5;
  std::__shared_weak_count *v6;
  std::__shared_weak_count *v7;
  std::__shared_weak_count *v8;

  *(void *)this = &unk_1EF532808;
  uint64_t v2 = (void *)*((void *)this + 26);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = (void *)*((void *)this + 24);
  *((void *)this + 24) = 0;
  if (v4) {
    operator delete(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)*((void *)this + 23);
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 20);
    if (!v6) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 20);
    if (!v6) {
      goto LABEL_11;
    }
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
LABEL_11:
  unint64_t v7 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v8) {
      goto LABEL_17;
    }
  }
  else
  {
    uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 16);
    if (!v8) {
      goto LABEL_17;
    }
  }
  if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
LABEL_17:
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void *gms::MaterialManager<ggl::Texture2D>::~MaterialManager(void *a1)
{
  geo::FrameCache<gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey,std::shared_ptr<gms::Material<ggl::Texture2D>>,gms::MaterialManager<ggl::Texture2D>::MaterialCacheKeyHash,gms::MaterialManager<ggl::Texture2D>::MaterialCacheKeyEqual>::~FrameCache((uint64_t)(a1 + 37));
  geo::FrameCache<gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey,std::shared_ptr<gms::Material<ggl::Texture2D>>,gms::MaterialManager<ggl::Texture2D>::MaterialCacheKeyHash,gms::MaterialManager<ggl::Texture2D>::MaterialCacheKeyEqual>::~FrameCache((uint64_t)(a1 + 25));
  geo::FrameCache<gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey,std::shared_ptr<gms::Material<ggl::Texture2D>>,gms::MaterialManager<ggl::Texture2D>::MaterialCacheKeyHash,gms::MaterialManager<ggl::Texture2D>::MaterialCacheKeyEqual>::~FrameCache((uint64_t)(a1 + 13));
  uint64_t v2 = (std::__shared_weak_count *)a1[12];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[10];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[10];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (std::__shared_weak_count *)a1[8];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
    uint64_t v5 = (void *)a1[4];
    if (!v5) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t v5 = (void *)a1[4];
    if (!v5) {
      goto LABEL_16;
    }
  }
  do
  {
    uint64_t v6 = v5;
    uint64_t v5 = (void *)*v5;
    unint64_t v7 = (std::__shared_weak_count *)v6[4];
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
    operator delete(v6);
  }
  while (v5);
LABEL_16:
  uint64_t v8 = (void *)a1[2];
  a1[2] = 0;
  if (v8) {
    operator delete(v8);
  }
  uint64_t v9 = (std::__shared_weak_count *)a1[1];
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  return a1;
}

uint64_t geo::FrameCache<gms::MaterialManager<ggl::Texture2D>::MaterialCacheKey,std::shared_ptr<gms::Material<ggl::Texture2D>>,gms::MaterialManager<ggl::Texture2D>::MaterialCacheKeyHash,gms::MaterialManager<ggl::Texture2D>::MaterialCacheKeyEqual>::~FrameCache(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  while (v2)
  {
    uint64_t v3 = v2;
    uint64_t v2 = (void *)*v2;
    if (*((unsigned char *)v3 + 48))
    {
      uint64_t v4 = (std::__shared_weak_count *)v3[5];
      if (v4)
      {
        if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
    operator delete(v3);
  }
  uint64_t v5 = *(void **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = *(void **)(a1 + 16);
  while (v6)
  {
    unint64_t v7 = v6;
    uint64_t v6 = (void *)*v6;
    if (*((unsigned char *)v7 + 48))
    {
      uint64_t v8 = (std::__shared_weak_count *)v7[5];
      if (v8)
      {
        if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
    operator delete(v7);
  }
  uint64_t v9 = *(void **)a1;
  *(void *)a1 = 0;
  if (v9) {
    operator delete(v9);
  }
  return a1;
}

void *std::__shared_ptr_pointer<gms::MaterialManager<ggl::Texture2D> *,std::shared_ptr<gms::MaterialManager<ggl::Texture2D>>::__shared_ptr_default_delete<gms::MaterialManager<ggl::Texture2D>,gms::MaterialManager<ggl::Texture2D>>,std::allocator<gms::MaterialManager<ggl::Texture2D>>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(void **)(a1 + 24);
  if (result)
  {
    gms::MaterialManager<ggl::Texture2D>::~MaterialManager(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<gms::MaterialManager<ggl::Texture2D> *,std::shared_ptr<gms::MaterialManager<ggl::Texture2D>>::__shared_ptr_default_delete<gms::MaterialManager<ggl::Texture2D>,gms::MaterialManager<ggl::Texture2D>>,std::allocator<gms::MaterialManager<ggl::Texture2D>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

pthread_rwlock_t *gms::TextureStore<ggl::Texture2D>::~TextureStore(pthread_rwlock_t *a1)
{
  uint64_t v2 = *(void **)&a1[1].__opaque[16];
  if (v2) {
    operator delete(v2);
  }
  uint64_t sig = a1[1].__sig;
  if (sig)
  {
    uint64_t v4 = *(void *)a1[1].__opaque;
    uint64_t v5 = (void *)a1[1].__sig;
    if (v4 != sig)
    {
      do
      {
        uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
        if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
          std::__shared_weak_count::__release_weak(v6);
        }
        v4 -= 16;
      }
      while (v4 != sig);
      uint64_t v5 = (void *)a1[1].__sig;
    }
    *(void *)a1[1].__opaque = sig;
    operator delete(v5);
  }
  unint64_t v7 = (geo::read_write_lock *)pthread_rwlock_destroy(a1);
  if (v7) {
    geo::read_write_lock::logFailure(v7, (uint64_t)"destruction", v8);
  }
  return a1;
}

void gms::LinearResolver::~LinearResolver(gms::LinearResolver *this)
{
  *(void *)this = &unk_1EF563DF8;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 2);
    uint64_t v4 = (gss::Allocator *)*((void *)this + 1);
    if (v3 != v2)
    {
      do
      {
        if (!*(unsigned char *)(v3 - 10) && *(void *)(v3 - 24))
        {
          uint64_t v5 = gss::Allocator::instance(v4);
          uint64_t v4 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v5 + 40))(v5, *(void *)(v3 - 24), *(unsigned __int16 *)(v3 - 12));
          *(void *)(v3 - 24) = 0;
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = (gss::Allocator *)*((void *)this + 1);
    }
    *((void *)this + 2) = v2;
    operator delete(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  gss::Allocator *v4;
  uint64_t v5;

  *(void *)this = &unk_1EF563DF8;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 2);
    uint64_t v4 = (gss::Allocator *)*((void *)this + 1);
    if (v3 != v2)
    {
      do
      {
        if (!*(unsigned char *)(v3 - 10))
        {
          if (*(void *)(v3 - 24))
          {
            uint64_t v5 = gss::Allocator::instance(v4);
            uint64_t v4 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v5 + 40))(v5, *(void *)(v3 - 24), *(unsigned __int16 *)(v3 - 12));
            *(void *)(v3 - 24) = 0;
          }
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = (gss::Allocator *)*((void *)this + 1);
    }
    *((void *)this + 2) = v2;
    operator delete(v4);
  }
}

pthread_rwlock_t *std::__shared_ptr_pointer<gms::TextureStore<ggl::Texture2D> *,std::shared_ptr<gms::TextureStore<ggl::Texture2D>>::__shared_ptr_default_delete<gms::TextureStore<ggl::Texture2D>,gms::TextureStore<ggl::Texture2D>>,std::allocator<gms::TextureStore<ggl::Texture2D>>>::__on_zero_shared(uint64_t a1)
{
  __n128 result = *(pthread_rwlock_t **)(a1 + 24);
  if (result)
  {
    gms::TextureStore<ggl::Texture2D>::~TextureStore(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<gms::TextureStore<ggl::Texture2D> *,std::shared_ptr<gms::TextureStore<ggl::Texture2D>>::__shared_ptr_default_delete<gms::TextureStore<ggl::Texture2D>,gms::TextureStore<ggl::Texture2D>>,std::allocator<gms::TextureStore<ggl::Texture2D>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t gms::MaterialSheet<ggl::Texture2D>::~MaterialSheet(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 80);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(void *)(a1 + 40);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 40);
    if (!v3) {
      goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 16;
    }
    while (v4 != v3);
    uint64_t v5 = *(void *)(a1 + 40);
  }
  *(void *)(a1 + 48) = v3;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64), v5, *(void *)(a1 + 56) - v5);
LABEL_12:
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 32);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  uint64_t v8 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9) {
    std::__shared_weak_count::__release_weak(v9);
  }
  return a1;
}

uint64_t *std::unique_ptr<gms::MaterialSheet<ggl::Texture2D>>::~unique_ptr[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = gms::MaterialSheet<ggl::Texture2D>::~MaterialSheet(v2);
    MEMORY[0x1A6239270](v3, 0x20C40D3FB9507);
  }
  return a1;
}

uint64_t std::__shared_ptr_pointer<gms::MaterialSheet<ggl::Texture2D> *,std::shared_ptr<gms::MaterialSheet<ggl::Texture2D>>::__shared_ptr_default_delete<gms::MaterialSheet<ggl::Texture2D>,gms::MaterialSheet<ggl::Texture2D>>,std::allocator<gms::MaterialSheet<ggl::Texture2D>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    gms::MaterialSheet<ggl::Texture2D>::~MaterialSheet(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

void std::__shared_ptr_pointer<gms::MaterialSheet<ggl::Texture2D> *,std::shared_ptr<gms::MaterialSheet<ggl::Texture2D>>::__shared_ptr_default_delete<gms::MaterialSheet<ggl::Texture2D>,gms::MaterialSheet<ggl::Texture2D>>,std::allocator<gms::MaterialSheet<ggl::Texture2D>>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnySsaoIntensity()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::ssaoIntensity(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyDryAdjustment()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::dryAdjustment(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyWetAdjustment()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::wetAdjustment(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyColdAdjustment()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::coldAdjustment(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyHotAdjustment()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::hotAdjustment(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyColorRampRGB()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::colorRampRGB(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyGradientMaskFactorRGB()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::gradientMaskFactorRGB(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyEmissiveFactorRGB()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::emissiveFactorRGB(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

BOOL gms::_BuildingMaterial<ggl::Texture2D>::hasAnyAlbedoFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 136) != 0;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::albedoFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 136);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 648))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::addAlbedoFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 136);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Bu, 283);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::NonZoomablePropertyStore<geo::Color<float,3,(geo::ColorSpace)0>>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565D40;
  if (*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 8) = 0;
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::NonZoomablePropertyStore<geo::Color<float,3,(geo::ColorSpace)0>>::~NonZoomablePropertyStore(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EF565D40;
  if (*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

uint64_t gms::NonZoomablePropertyStore<geo::Color<float,3,(geo::ColorSpace)0>>::zoomable()
{
  return 0;
}

uint64_t gms::NonZoomablePropertyStore<geo::Color<float,3,(geo::ColorSpace)0>>::getProperty@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(result + 8))
  {
    *(void *)(a2 + 4) = *(void *)(result + 12);
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(result + 20);
    *(unsigned char *)a2 = 1;
  }
  return result;
}

uint64_t std::__function::__func<geo::Color<float,3,(geo::ColorSpace)0> (*)(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&),std::allocator<geo::Color<float,3,(geo::ColorSpace)0> (*)(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&)>,geo::Color<float,3,(geo::ColorSpace)0> ()(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56BA88;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<geo::Color<float,3,(geo::ColorSpace)0> (*)(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&),std::allocator<geo::Color<float,3,(geo::ColorSpace)0> (*)(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&)>,geo::Color<float,3,(geo::ColorSpace)0> ()(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EF56BA88;
  result[1] = v3;
  return result;
}

void std::__function::__func<geo::Color<float,3,(geo::ColorSpace)0> (*)(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&),std::allocator<geo::Color<float,3,(geo::ColorSpace)0> (*)(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&)>,geo::Color<float,3,(geo::ColorSpace)0> ()(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&)>::~__func()
{
}

void gms::ZoomablePropertyStore<geo::Color<float,3,(geo::ColorSpace)0>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565B10;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<geo::Color<float,3,(geo::ColorSpace)0>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565B10;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

uint64_t gms::ZoomablePropertyStore<geo::Color<float,3,(geo::ColorSpace)0>>::zoomable()
{
  return 1;
}

BOOL gms::_BuildingMaterial<ggl::Texture2D>::hasAnyAlpha(uint64_t a1)
{
  return *(void *)(a1 + 128) != 0;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::alpha@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 128);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 624))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::addAlpha(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 128);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Au, 282);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

uint64_t gms::NonZoomablePropertyStore<float>::~NonZoomablePropertyStore(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EF565E58;
  if (*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

float gms::NonZoomablePropertyStore<float>::getProperty@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(a1 + 8))
  {
    float result = *(float *)(a1 + 12);
    *(float *)(a2 + 4) = result;
    *(unsigned char *)a2 = 1;
  }
  return result;
}

uint64_t std::__function::__func<float (*)(float,float const&,float const&),std::allocator<float (*)(float,float const&,float const&)>,float ()(float,float const&,float const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56BBC8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<float (*)(float,float const&,float const&),std::allocator<float (*)(float,float const&,float const&)>,float ()(float,float const&,float const&)>::__clone(uint64_t a1)
{
  float result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *float result = &unk_1EF56BBC8;
  result[1] = v3;
  return result;
}

void std::__function::__func<float (*)(float,float const&,float const&),std::allocator<float (*)(float,float const&,float const&)>,float ()(float,float const&,float const&)>::~__func()
{
}

void gms::ZoomablePropertyStore<float>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565C28;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<float>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565C28;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

BOOL gms::_BuildingMaterial<ggl::Texture2D>::hasAnyNoColorCorrection(uint64_t a1)
{
  return *(void *)(a1 + 120) != 0;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::noColorCorrection@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 120);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 600))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::addNoColorCorrection(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 120);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x19u, 281);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::NonZoomablePropertyStore<BOOL>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565E20;
  if (*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 8) = 0;
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::NonZoomablePropertyStore<BOOL>::~NonZoomablePropertyStore(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EF565E20;
  if (*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

uint64_t gms::NonZoomablePropertyStore<BOOL>::zoomable()
{
  return 0;
}

void gms::ZoomablePropertyStore<BOOL>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565BF0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<BOOL>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565BF0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

uint64_t gms::ZoomablePropertyStore<BOOL>::zoomable()
{
  return 1;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyHideOnCollapse()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::hideOnCollapse(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyGradientMaskFactor()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::gradientMaskFactor(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

BOOL gms::_BuildingMaterial<ggl::Texture2D>::hasAnyBrightnessRemapRange(uint64_t a1)
{
  return *(void *)(a1 + 112) != 0;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::brightnessRemapRange@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 112);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 528))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::addBrightnessRemapRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 112);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x16u, 278);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::NonZoomablePropertyStore<gm::Matrix<float,2,1>>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565CD0;
  if (*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 8) = 0;
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::NonZoomablePropertyStore<gm::Matrix<float,2,1>>::~NonZoomablePropertyStore(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EF565CD0;
  if (*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

uint64_t gms::NonZoomablePropertyStore<gm::Matrix<float,2,1>>::zoomable()
{
  return 0;
}

uint64_t gms::NonZoomablePropertyStore<gm::Matrix<float,2,1>>::getProperty@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(result + 8))
  {
    *(void *)(a2 + 4) = *(void *)(result + 12);
    *(unsigned char *)a2 = 1;
  }
  return result;
}

void gms::ZoomablePropertyStore<gm::Matrix<float,2,1>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565AA0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<gm::Matrix<float,2,1>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565AA0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

uint64_t gms::ZoomablePropertyStore<gm::Matrix<float,2,1>>::zoomable()
{
  return 1;
}

uint64_t *gms::ZoomablePropertyStore<gm::Matrix<float,2,1>>::addProperty(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t *a4)
{
  uint64_t v4 = result;
  unsigned int v5 = *a2;
  unsigned int v6 = *a3;
  __int16 v7 = (_WORD)v6 << 8;
  uint64_t v8 = *a4;
  if (result[7])
  {
    uint64_t v9 = (uint64_t *)result[5];
    unint64_t v10 = (uint64_t **)(result + 6);
    if (v9 == result + 6)
    {
      uint64_t v16 = (void *)result[5];
    }
    else
    {
      unint64_t v11 = 0;
      uint64_t v12 = (uint64_t *)result[5];
      do
      {
        unsigned int v13 = (uint64_t *)v12[1];
        if (v13)
        {
          do
          {
            uint64_t v14 = (uint64_t **)v13;
            unsigned int v13 = (uint64_t *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            uint64_t v14 = (uint64_t **)v12[2];
            BOOL v15 = *v14 == v12;
            uint64_t v12 = (uint64_t *)v14;
          }
          while (!v15);
        }
        ++v11;
        uint64_t v12 = (uint64_t *)v14;
      }
      while (v14 != v10);
      uint64_t v16 = (void *)result[5];
      do
      {
        unint64_t v17 = v11 >> 1;
        uint64_t v18 = v16;
        if (v11 != 1)
        {
          uint64_t v20 = v11 >> 1;
          uint64_t v21 = v16;
          do
          {
            uint64_t v23 = (void *)v21[1];
            if (v23)
            {
              do
              {
                uint64_t v18 = v23;
                uint64_t v23 = (void *)*v23;
              }
              while (v23);
            }
            else
            {
              do
              {
                uint64_t v18 = (void *)v21[2];
                BOOL v15 = *v18 == (void)v21;
                uint64_t v21 = v18;
              }
              while (!v15);
            }
            uint64_t v21 = v18;
          }
          while (v20-- > 1);
        }
        if (*((unsigned __int8 *)v18 + 29) < v6)
        {
          uint64_t v19 = (void *)v18[1];
          if (v19)
          {
            do
            {
              uint64_t v16 = v19;
              uint64_t v19 = (void *)*v19;
            }
            while (v19);
          }
          else
          {
            do
            {
              uint64_t v16 = (void *)v18[2];
              BOOL v15 = *v16 == (void)v18;
              uint64_t v18 = v16;
            }
            while (!v15);
          }
          unint64_t v17 = v11 + ~v17;
        }
        unint64_t v11 = v17;
      }
      while (v17);
    }
    if (v16 == v10 || *((unsigned __int8 *)v16 + 28) >= v6)
    {
      if (v16 == v9) {
        goto LABEL_46;
      }
      uint64_t v27 = *v16;
      if (*v16)
      {
        do
        {
          uint64_t v28 = v27;
          uint64_t v27 = *(void *)(v27 + 8);
        }
        while (v27);
      }
      else
      {
        do
        {
          uint64_t v28 = v16[2];
          BOOL v15 = *(void *)v28 == (void)v16;
          uint64_t v16 = (void *)v28;
        }
        while (v15);
      }
      if (v5 >= *(unsigned __int8 *)(v28 + 29))
      {
LABEL_46:
        uint64_t v29 = *v10;
        uint64_t v25 = (uint64_t **)(result + 6);
        if (!*v10) {
          goto LABEL_53;
        }
        while (1)
        {
          while (1)
          {
            uint64_t v25 = (uint64_t **)v29;
            unsigned int v30 = *((unsigned __int8 *)v29 + 29);
            if (v6 >= v30) {
              break;
            }
            uint64_t v29 = *v25;
            unint64_t v10 = v25;
            if (!*v25) {
              goto LABEL_53;
            }
          }
          if (v30 >= v6) {
            break;
          }
          uint64_t v29 = v25[1];
          if (!v29) {
            goto LABEL_52;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v10 = (uint64_t **)(result + 6);
    uint64_t v24 = result[6];
    if (!v24)
    {
      uint64_t v25 = (uint64_t **)(result + 6);
LABEL_53:
      uint64_t v31 = operator new(0x28uLL);
      v31[14] = v7 | v5;
      *((void *)v31 + 4) = v8;
      *(void *)uint64_t v31 = 0;
      *((void *)v31 + 1) = 0;
      *((void *)v31 + 2) = v25;
      *unint64_t v10 = (uint64_t *)v31;
      uint64_t v32 = *(void *)v4[5];
      if (v32)
      {
        v4[5] = v32;
        uint64_t v33 = *v10;
      }
      else
      {
        uint64_t v33 = (uint64_t *)v31;
      }
      uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[6], v33);
      ++v4[7];
      return result;
    }
    while (1)
    {
      while (1)
      {
        uint64_t v25 = (uint64_t **)v24;
        unsigned int v26 = *(unsigned __int8 *)(v24 + 29);
        if (v6 >= v26) {
          break;
        }
        uint64_t v24 = (uint64_t)*v25;
        unint64_t v10 = v25;
        if (!*v25) {
          goto LABEL_53;
        }
      }
      if (v26 >= v6) {
        break;
      }
      uint64_t v24 = (uint64_t)v25[1];
      if (!v24)
      {
LABEL_52:
        unint64_t v10 = v25 + 1;
        goto LABEL_53;
      }
    }
  }
  return result;
}

void gms::ZoomablePropertyStore<gm::Matrix<float,2,1>>::getProperty(void *a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(unsigned char *)a2 = 0;
  unsigned int v4 = vcvtms_s32_f32(a3);
  if (v4 >= 0x17) {
    unsigned int v5 = 23;
  }
  else {
    unsigned int v5 = v4;
  }
  unsigned int v6 = (void *)a1[5];
  __int16 v7 = a1 + 6;
  uint64_t v8 = v6;
  if (v6 != a1 + 6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = (void *)a1[5];
    do
    {
      unint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v10[2];
          BOOL v13 = *v12 == (void)v10;
          unint64_t v10 = v12;
        }
        while (!v13);
      }
      ++v9;
      unint64_t v10 = v12;
    }
    while (v12 != v7);
    uint64_t v8 = (void *)a1[5];
    do
    {
      unint64_t v14 = v9 >> 1;
      BOOL v15 = v8;
      if (v9 != 1)
      {
        uint64_t v17 = v9 >> 1;
        uint64_t v18 = v8;
        do
        {
          uint64_t v20 = (void *)v18[1];
          if (v20)
          {
            do
            {
              BOOL v15 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              BOOL v15 = (void *)v18[2];
              BOOL v13 = *v15 == (void)v18;
              uint64_t v18 = v15;
            }
            while (!v13);
          }
          uint64_t v18 = v15;
          BOOL v19 = v17-- <= 1;
        }
        while (!v19);
      }
      if (v5 >= *((unsigned __int8 *)v15 + 29))
      {
        uint64_t v16 = (void *)v15[1];
        if (v16)
        {
          do
          {
            uint64_t v8 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v15[2];
            BOOL v13 = *v8 == (void)v15;
            BOOL v15 = v8;
          }
          while (!v13);
        }
        unint64_t v14 = v9 + ~v14;
      }
      unint64_t v9 = v14;
    }
    while (v14);
  }
  if (v8 == v7 || (v5 >= *((unsigned __int8 *)v8 + 28) ? (BOOL v21 = v5 >= *((unsigned __int8 *)v8 + 29)) : (BOOL v21 = 1), v21)) {
    uint64_t v8 = a1 + 6;
  }
  unsigned __int8 v22 = v5 + 1;
  uint64_t v23 = (void *)a1[5];
  if (v6 != v7)
  {
    unint64_t v24 = 0;
    uint64_t v25 = (void *)a1[5];
    do
    {
      unsigned int v26 = (void *)v25[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          unsigned int v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v25[2];
          BOOL v13 = *v27 == (void)v25;
          uint64_t v25 = v27;
        }
        while (!v13);
      }
      ++v24;
      uint64_t v25 = v27;
    }
    while (v27 != v7);
    uint64_t v23 = (void *)a1[5];
    do
    {
      unint64_t v28 = v24 >> 1;
      uint64_t v29 = v23;
      if (v24 != 1)
      {
        uint64_t v31 = v24 >> 1;
        uint64_t v32 = v23;
        do
        {
          uint64_t v33 = (void *)v32[1];
          if (v33)
          {
            do
            {
              uint64_t v29 = v33;
              uint64_t v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              uint64_t v29 = (void *)v32[2];
              BOOL v13 = *v29 == (void)v32;
              uint64_t v32 = v29;
            }
            while (!v13);
          }
          uint64_t v32 = v29;
          BOOL v19 = v31-- <= 1;
        }
        while (!v19);
      }
      if (*((unsigned __int8 *)v29 + 29) <= v22)
      {
        unsigned int v30 = (void *)v29[1];
        if (v30)
        {
          do
          {
            uint64_t v23 = v30;
            unsigned int v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v23 = (void *)v29[2];
            BOOL v13 = *v23 == (void)v29;
            uint64_t v29 = v23;
          }
          while (!v13);
        }
        unint64_t v28 = v24 + ~v28;
      }
      unint64_t v24 = v28;
    }
    while (v28);
  }
  if (v23 == v7
    || *((unsigned __int8 *)v23 + 28) > v22
    || *((unsigned __int8 *)v23 + 29) <= v22)
  {
    uint64_t v23 = a1 + 6;
  }
  if (v8 != v7 && a1[7])
  {
    if (v23 == v7 || (v34 = a1[4]) == 0 || (float v35 = a3 - (float)v5, v35 > 1.0) || v35 < 0.0)
    {
      if (v6 != v7)
      {
        unint64_t v41 = 0;
        uint64_t v42 = v6;
        do
        {
          uint64_t v43 = (void *)v42[1];
          if (v43)
          {
            do
            {
              uint64_t v44 = v43;
              uint64_t v43 = (void *)*v43;
            }
            while (v43);
          }
          else
          {
            do
            {
              uint64_t v44 = (void *)v42[2];
              BOOL v13 = *v44 == (void)v42;
              uint64_t v42 = v44;
            }
            while (!v13);
          }
          ++v41;
          uint64_t v42 = v44;
        }
        while (v44 != v7);
        do
        {
          unint64_t v45 = v41 >> 1;
          uint64_t v46 = v6;
          if (v41 != 1)
          {
            uint64_t v48 = v41 >> 1;
            uint64_t v49 = v6;
            do
            {
              __guard v50 = (void *)v49[1];
              if (v50)
              {
                do
                {
                  uint64_t v46 = v50;
                  __guard v50 = (void *)*v50;
                }
                while (v50);
              }
              else
              {
                do
                {
                  uint64_t v46 = (void *)v49[2];
                  BOOL v13 = *v46 == (void)v49;
                  uint64_t v49 = v46;
                }
                while (!v13);
              }
              uint64_t v49 = v46;
              BOOL v19 = v48-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v46 + 29))
          {
            uint64_t v47 = (void *)v46[1];
            if (v47)
            {
              do
              {
                unsigned int v6 = v47;
                uint64_t v47 = (void *)*v47;
              }
              while (v47);
            }
            else
            {
              do
              {
                unsigned int v6 = (void *)v46[2];
                BOOL v13 = *v6 == (void)v46;
                uint64_t v46 = v6;
              }
              while (!v13);
            }
            unint64_t v45 = v41 + ~v45;
          }
          unint64_t v41 = v45;
        }
        while (v45);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 28) ? (BOOL v51 = v5 >= *((unsigned __int8 *)v6 + 29)) : (BOOL v51 = 1), v51))
      {
        unsigned int v6 = v7;
      }
      *(unsigned char *)a2 = 1;
      *(void *)(a2 + 4) = v6[4];
    }
    else
    {
      uint64_t v36 = v6;
      if (v6 != v7)
      {
        unint64_t v37 = 0;
        uint64_t v38 = v6;
        do
        {
          uint64_t v39 = (void *)v38[1];
          if (v39)
          {
            do
            {
              uint64_t v40 = v39;
              uint64_t v39 = (void *)*v39;
            }
            while (v39);
          }
          else
          {
            do
            {
              uint64_t v40 = (void *)v38[2];
              BOOL v13 = *v40 == (void)v38;
              uint64_t v38 = v40;
            }
            while (!v13);
          }
          ++v37;
          uint64_t v38 = v40;
        }
        while (v40 != v7);
        uint64_t v36 = v6;
        do
        {
          unint64_t v52 = v37 >> 1;
          __guard v53 = v36;
          if (v37 != 1)
          {
            uint64_t v55 = v37 >> 1;
            __guard v56 = v36;
            do
            {
              __guard v57 = (void *)v56[1];
              if (v57)
              {
                do
                {
                  __guard v53 = v57;
                  __guard v57 = (void *)*v57;
                }
                while (v57);
              }
              else
              {
                do
                {
                  __guard v53 = (void *)v56[2];
                  BOOL v13 = *v53 == (void)v56;
                  __guard v56 = v53;
                }
                while (!v13);
              }
              __guard v56 = v53;
              BOOL v19 = v55-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v53 + 29))
          {
            __guard v54 = (void *)v53[1];
            if (v54)
            {
              do
              {
                uint64_t v36 = v54;
                __guard v54 = (void *)*v54;
              }
              while (v54);
            }
            else
            {
              do
              {
                uint64_t v36 = (void *)v53[2];
                BOOL v13 = *v36 == (void)v53;
                __guard v53 = v36;
              }
              while (!v13);
            }
            unint64_t v52 = v37 + ~v52;
          }
          unint64_t v37 = v52;
        }
        while (v52);
      }
      if (v36 == v7
        || (v5 >= *((unsigned __int8 *)v36 + 28) ? (BOOL v58 = v5 >= *((unsigned __int8 *)v36 + 29)) : (BOOL v58 = 1), v58))
      {
        uint64_t v36 = v7;
      }
      uint64_t v72 = v36[4];
      if (v6 != v7)
      {
        unint64_t v59 = 0;
        double v60 = v6;
        do
        {
          int v61 = (void *)v60[1];
          if (v61)
          {
            do
            {
              uint64_t v62 = v61;
              int v61 = (void *)*v61;
            }
            while (v61);
          }
          else
          {
            do
            {
              uint64_t v62 = (void *)v60[2];
              BOOL v13 = *v62 == (void)v60;
              double v60 = v62;
            }
            while (!v13);
          }
          ++v59;
          double v60 = v62;
        }
        while (v62 != v7);
        do
        {
          unint64_t v63 = v59 >> 1;
          float v64 = v6;
          if (v59 != 1)
          {
            uint64_t v66 = v59 >> 1;
            int v67 = v6;
            do
            {
              float32x2_t v68 = (void *)v67[1];
              if (v68)
              {
                do
                {
                  float v64 = v68;
                  float32x2_t v68 = (void *)*v68;
                }
                while (v68);
              }
              else
              {
                do
                {
                  float v64 = (void *)v67[2];
                  BOOL v13 = *v64 == (void)v67;
                  int v67 = v64;
                }
                while (!v13);
              }
              int v67 = v64;
              BOOL v19 = v66-- <= 1;
            }
            while (!v19);
          }
          if (*((unsigned __int8 *)v64 + 29) <= v22)
          {
            int v65 = (void *)v64[1];
            if (v65)
            {
              do
              {
                unsigned int v6 = v65;
                int v65 = (void *)*v65;
              }
              while (v65);
            }
            else
            {
              do
              {
                unsigned int v6 = (void *)v64[2];
                BOOL v13 = *v6 == (void)v64;
                float v64 = v6;
              }
              while (!v13);
            }
            unint64_t v63 = v59 + ~v63;
          }
          unint64_t v59 = v63;
        }
        while (v63);
      }
      if (v6 == v7
        || *((unsigned __int8 *)v6 + 28) > v22
        || *((unsigned __int8 *)v6 + 29) <= v22)
      {
        unsigned int v6 = v7;
      }
      uint64_t v71 = v6[4];
      float v73 = v35;
      float v69 = (*(float (**)(uint64_t, float *, uint64_t *, uint64_t *))(*(void *)v34 + 48))(v34, &v73, &v72, &v71);
      *(unsigned char *)a2 = 1;
      *(float *)(a2 + 4) = v69;
      *(_DWORD *)(a2 + 8) = v70;
    }
  }
}

BOOL gms::_BuildingMaterial<ggl::Texture2D>::hasAnySaturationRemapRange(uint64_t a1)
{
  return *(void *)(a1 + 104) != 0;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::saturationRemapRange@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 104);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 504))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::addSaturationRemapRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 104);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x15u, 277);
      operator new();
    }
    operator new();
  }
  __int16 v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyAcceptsOverlays()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::acceptsOverlays(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyBrightnessFactor()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::brightnessFactor(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnySaturationFactor()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::saturationFactor(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyColorRamp()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::colorRamp(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyCastShadow()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::castShadow(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyShininess()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::shininess(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnySpecularity()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::specularity(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyOffset()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::offset(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyTiling()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::tiling(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyVisibility()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::visibility(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyLineWidth()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::lineWidth(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyZIndex()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::zIndex(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

BOOL gms::_BuildingMaterial<ggl::Texture2D>::hasAnyAlbedoFactor(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::albedoFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 96);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::addAlbedoFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 8u, 264);
      operator new();
    }
    operator new();
  }
  __int16 v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::NonZoomablePropertyStore<geo::Color<float,4,(geo::ColorSpace)0>>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565D78;
  if (*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 8) = 0;
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::NonZoomablePropertyStore<geo::Color<float,4,(geo::ColorSpace)0>>::~NonZoomablePropertyStore(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EF565D78;
  if (*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

uint64_t gms::NonZoomablePropertyStore<geo::Color<float,4,(geo::ColorSpace)0>>::zoomable()
{
  return 0;
}

__n128 gms::NonZoomablePropertyStore<geo::Color<float,4,(geo::ColorSpace)0>>::getProperty@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(a1 + 8))
  {
    __n128 result = *(__n128 *)(a1 + 12);
    *(__n128 *)(a2 + 4) = result;
    *(unsigned char *)a2 = 1;
  }
  return result;
}

float32x4_t *gms::lerp<geo::Color<float,4,(geo::ColorSpace)0>>@<X0>(float32x4_t *result@<X0>, float32x4_t *a2@<X1>, float32x4_t *a3@<X8>, float a4@<S0>)
{
  *a3 = vmlaq_n_f32(*result, vsubq_f32(*a2, *result), a4);
  return result;
}

uint64_t std::__function::__func<geo::Color<float,4,(geo::ColorSpace)0> (*)(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&),std::allocator<geo::Color<float,4,(geo::ColorSpace)0> (*)(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&)>,geo::Color<float,4,(geo::ColorSpace)0> ()(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&)>::operator()(uint64_t a1, float *a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, float))(a1 + 8))(a3, a4, *a2);
}

uint64_t std::__function::__func<geo::Color<float,4,(geo::ColorSpace)0> (*)(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&),std::allocator<geo::Color<float,4,(geo::ColorSpace)0> (*)(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&)>,geo::Color<float,4,(geo::ColorSpace)0> ()(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56BAD0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<geo::Color<float,4,(geo::ColorSpace)0> (*)(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&),std::allocator<geo::Color<float,4,(geo::ColorSpace)0> (*)(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&)>,geo::Color<float,4,(geo::ColorSpace)0> ()(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&)>::__clone(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EF56BAD0;
  result[1] = v3;
  return result;
}

void std::__function::__func<geo::Color<float,4,(geo::ColorSpace)0> (*)(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&),std::allocator<geo::Color<float,4,(geo::ColorSpace)0> (*)(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&)>,geo::Color<float,4,(geo::ColorSpace)0> ()(float,geo::Color<float,4,(geo::ColorSpace)0> const&,geo::Color<float,4,(geo::ColorSpace)0> const&)>::~__func()
{
}

void gms::ZoomablePropertyStore<geo::Color<float,4,(geo::ColorSpace)0>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565B48;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<geo::Color<float,4,(geo::ColorSpace)0>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565B48;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

uint64_t gms::ZoomablePropertyStore<geo::Color<float,4,(geo::ColorSpace)0>>::zoomable()
{
  return 1;
}

void *gms::ZoomablePropertyStore<geo::Color<float,4,(geo::ColorSpace)0>>::getProperty@<X0>(void *result@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(unsigned char *)a2 = 0;
  unsigned int v4 = vcvtms_s32_f32(a3);
  if (v4 >= 0x17) {
    unsigned int v5 = 23;
  }
  else {
    unsigned int v5 = v4;
  }
  uint64_t v6 = (void *)result[5];
  __int16 v7 = result + 6;
  uint64_t v8 = v6;
  if (v6 != result + 6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = (void *)result[5];
    do
    {
      unint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v10[2];
          BOOL v13 = *v12 == (void)v10;
          unint64_t v10 = v12;
        }
        while (!v13);
      }
      ++v9;
      unint64_t v10 = v12;
    }
    while (v12 != v7);
    uint64_t v8 = (void *)result[5];
    do
    {
      unint64_t v14 = v9 >> 1;
      BOOL v15 = v8;
      if (v9 != 1)
      {
        uint64_t v17 = v9 >> 1;
        uint64_t v18 = v8;
        do
        {
          uint64_t v20 = (void *)v18[1];
          if (v20)
          {
            do
            {
              BOOL v15 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              BOOL v15 = (void *)v18[2];
              BOOL v13 = *v15 == (void)v18;
              uint64_t v18 = v15;
            }
            while (!v13);
          }
          uint64_t v18 = v15;
          BOOL v19 = v17-- <= 1;
        }
        while (!v19);
      }
      if (v5 >= *((unsigned __int8 *)v15 + 29))
      {
        uint64_t v16 = (void *)v15[1];
        if (v16)
        {
          do
          {
            uint64_t v8 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v15[2];
            BOOL v13 = *v8 == (void)v15;
            BOOL v15 = v8;
          }
          while (!v13);
        }
        unint64_t v14 = v9 + ~v14;
      }
      unint64_t v9 = v14;
    }
    while (v14);
  }
  if (v8 == v7 || (v5 >= *((unsigned __int8 *)v8 + 28) ? (BOOL v21 = v5 >= *((unsigned __int8 *)v8 + 29)) : (BOOL v21 = 1), v21)) {
    uint64_t v8 = result + 6;
  }
  unsigned __int8 v22 = v5 + 1;
  uint64_t v23 = (void *)result[5];
  if (v6 != v7)
  {
    unint64_t v24 = 0;
    uint64_t v25 = (void *)result[5];
    do
    {
      unsigned int v26 = (void *)v25[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          unsigned int v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v25[2];
          BOOL v13 = *v27 == (void)v25;
          uint64_t v25 = v27;
        }
        while (!v13);
      }
      ++v24;
      uint64_t v25 = v27;
    }
    while (v27 != v7);
    uint64_t v23 = (void *)result[5];
    do
    {
      unint64_t v28 = v24 >> 1;
      uint64_t v29 = v23;
      if (v24 != 1)
      {
        uint64_t v31 = v24 >> 1;
        uint64_t v32 = v23;
        do
        {
          uint64_t v33 = (void *)v32[1];
          if (v33)
          {
            do
            {
              uint64_t v29 = v33;
              uint64_t v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              uint64_t v29 = (void *)v32[2];
              BOOL v13 = *v29 == (void)v32;
              uint64_t v32 = v29;
            }
            while (!v13);
          }
          uint64_t v32 = v29;
          BOOL v19 = v31-- <= 1;
        }
        while (!v19);
      }
      if (*((unsigned __int8 *)v29 + 29) <= v22)
      {
        unsigned int v30 = (void *)v29[1];
        if (v30)
        {
          do
          {
            uint64_t v23 = v30;
            unsigned int v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v23 = (void *)v29[2];
            BOOL v13 = *v23 == (void)v29;
            uint64_t v29 = v23;
          }
          while (!v13);
        }
        unint64_t v28 = v24 + ~v28;
      }
      unint64_t v24 = v28;
    }
    while (v28);
  }
  if (v23 == v7
    || *((unsigned __int8 *)v23 + 28) > v22
    || *((unsigned __int8 *)v23 + 29) <= v22)
  {
    uint64_t v23 = result + 6;
  }
  if (v8 != v7 && result[7])
  {
    if (v23 == v7 || (__n128 result = (void *)result[4]) == 0 || (v34 = a3 - (float)v5, v34 > 1.0) || v34 < 0.0)
    {
      if (v6 != v7)
      {
        unint64_t v40 = 0;
        unint64_t v41 = v6;
        do
        {
          uint64_t v42 = (void *)v41[1];
          if (v42)
          {
            do
            {
              uint64_t v43 = v42;
              uint64_t v42 = (void *)*v42;
            }
            while (v42);
          }
          else
          {
            do
            {
              uint64_t v43 = (void *)v41[2];
              BOOL v13 = *v43 == (void)v41;
              unint64_t v41 = v43;
            }
            while (!v13);
          }
          ++v40;
          unint64_t v41 = v43;
        }
        while (v43 != v7);
        do
        {
          unint64_t v44 = v40 >> 1;
          unint64_t v45 = v6;
          if (v40 != 1)
          {
            uint64_t v47 = v40 >> 1;
            uint64_t v48 = v6;
            do
            {
              uint64_t v49 = (void *)v48[1];
              if (v49)
              {
                do
                {
                  unint64_t v45 = v49;
                  uint64_t v49 = (void *)*v49;
                }
                while (v49);
              }
              else
              {
                do
                {
                  unint64_t v45 = (void *)v48[2];
                  BOOL v13 = *v45 == (void)v48;
                  uint64_t v48 = v45;
                }
                while (!v13);
              }
              uint64_t v48 = v45;
              BOOL v19 = v47-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v45 + 29))
          {
            uint64_t v46 = (void *)v45[1];
            if (v46)
            {
              do
              {
                uint64_t v6 = v46;
                uint64_t v46 = (void *)*v46;
              }
              while (v46);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v45[2];
                BOOL v13 = *v6 == (void)v45;
                unint64_t v45 = v6;
              }
              while (!v13);
            }
            unint64_t v44 = v40 + ~v44;
          }
          unint64_t v40 = v44;
        }
        while (v44);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 28) ? (BOOL v50 = v5 >= *((unsigned __int8 *)v6 + 29)) : (BOOL v50 = 1), v50))
      {
        uint64_t v6 = v7;
      }
      *(unsigned char *)a2 = 1;
      long long v51 = *((_OWORD *)v6 + 2);
    }
    else
    {
      float v35 = v6;
      if (v6 != v7)
      {
        unint64_t v36 = 0;
        unint64_t v37 = v6;
        do
        {
          uint64_t v38 = (void *)v37[1];
          if (v38)
          {
            do
            {
              uint64_t v39 = v38;
              uint64_t v38 = (void *)*v38;
            }
            while (v38);
          }
          else
          {
            do
            {
              uint64_t v39 = (void *)v37[2];
              BOOL v13 = *v39 == (void)v37;
              unint64_t v37 = v39;
            }
            while (!v13);
          }
          ++v36;
          unint64_t v37 = v39;
        }
        while (v39 != v7);
        float v35 = v6;
        do
        {
          unint64_t v52 = v36 >> 1;
          __guard v53 = v35;
          if (v36 != 1)
          {
            uint64_t v55 = v36 >> 1;
            __guard v56 = v35;
            do
            {
              __guard v57 = (void *)v56[1];
              if (v57)
              {
                do
                {
                  __guard v53 = v57;
                  __guard v57 = (void *)*v57;
                }
                while (v57);
              }
              else
              {
                do
                {
                  __guard v53 = (void *)v56[2];
                  BOOL v13 = *v53 == (void)v56;
                  __guard v56 = v53;
                }
                while (!v13);
              }
              __guard v56 = v53;
              BOOL v19 = v55-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v53 + 29))
          {
            __guard v54 = (void *)v53[1];
            if (v54)
            {
              do
              {
                float v35 = v54;
                __guard v54 = (void *)*v54;
              }
              while (v54);
            }
            else
            {
              do
              {
                float v35 = (void *)v53[2];
                BOOL v13 = *v35 == (void)v53;
                __guard v53 = v35;
              }
              while (!v13);
            }
            unint64_t v52 = v36 + ~v52;
          }
          unint64_t v36 = v52;
        }
        while (v52);
      }
      if (v35 == v7
        || (v5 >= *((unsigned __int8 *)v35 + 28) ? (BOOL v58 = v5 >= *((unsigned __int8 *)v35 + 29)) : (BOOL v58 = 1), v58))
      {
        float v35 = v7;
      }
      v69[2] = *((_OWORD *)v35 + 2);
      if (v6 != v7)
      {
        unint64_t v59 = 0;
        double v60 = v6;
        do
        {
          int v61 = (void *)v60[1];
          if (v61)
          {
            do
            {
              uint64_t v62 = v61;
              int v61 = (void *)*v61;
            }
            while (v61);
          }
          else
          {
            do
            {
              uint64_t v62 = (void *)v60[2];
              BOOL v13 = *v62 == (void)v60;
              double v60 = v62;
            }
            while (!v13);
          }
          ++v59;
          double v60 = v62;
        }
        while (v62 != v7);
        do
        {
          unint64_t v63 = v59 >> 1;
          float v64 = v6;
          if (v59 != 1)
          {
            uint64_t v66 = v59 >> 1;
            int v67 = v6;
            do
            {
              float32x2_t v68 = (void *)v67[1];
              if (v68)
              {
                do
                {
                  float v64 = v68;
                  float32x2_t v68 = (void *)*v68;
                }
                while (v68);
              }
              else
              {
                do
                {
                  float v64 = (void *)v67[2];
                  BOOL v13 = *v64 == (void)v67;
                  int v67 = v64;
                }
                while (!v13);
              }
              int v67 = v64;
              BOOL v19 = v66-- <= 1;
            }
            while (!v19);
          }
          if (*((unsigned __int8 *)v64 + 29) <= v22)
          {
            int v65 = (void *)v64[1];
            if (v65)
            {
              do
              {
                uint64_t v6 = v65;
                int v65 = (void *)*v65;
              }
              while (v65);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v64[2];
                BOOL v13 = *v6 == (void)v64;
                float v64 = v6;
              }
              while (!v13);
            }
            unint64_t v63 = v59 + ~v63;
          }
          unint64_t v59 = v63;
        }
        while (v63);
      }
      if (v6 == v7
        || *((unsigned __int8 *)v6 + 28) > v22
        || *((unsigned __int8 *)v6 + 29) <= v22)
      {
        uint64_t v6 = v7;
      }
      v69[1] = *((_OWORD *)v6 + 2);
      float v70 = v34;
      __n128 result = (*(void *(**)(_OWORD *__return_ptr))(*result + 48))(v69);
      *(unsigned char *)a2 = 1;
      long long v51 = v69[0];
    }
    *(_OWORD *)(a2 + 4) = v51;
  }
  return result;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyEmissiveFactor()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::emissiveFactor(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyMetallicFactor()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::metallicFactor(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyRoughnessFactor()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::roughnessFactor(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyEmissive()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::emissive(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyRoughnessMetallic()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::roughnessMetallic(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyNormal()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::normal(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

BOOL gms::_BuildingMaterial<ggl::Texture2D>::hasAnyAlbedo(uint64_t a1)
{
  return *(void *)(a1 + 88) != 0;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::albedo@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 88);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BuildingMaterial<ggl::Texture2D>::addAlbedo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 88);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 1u, 257);
      operator new();
    }
    operator new();
  }
  __int16 v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::NonZoomablePropertyStore<unsigned char>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565E90;
  if (*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 8) = 0;
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::NonZoomablePropertyStore<unsigned char>::~NonZoomablePropertyStore(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EF565E90;
  if (*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

uint64_t gms::NonZoomablePropertyStore<unsigned char>::zoomable()
{
  return 0;
}

uint64_t gms::NonZoomablePropertyStore<unsigned char>::addProperty(uint64_t result, uint64_t a2, uint64_t a3, char *a4)
{
  char v4 = *a4;
  if (!*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 1;
  }
  *(unsigned char *)(result + 9) = v4;
  return result;
}

uint64_t gms::NonZoomablePropertyStore<unsigned char>::getProperty@<X0>(uint64_t result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = 0;
  if (*(unsigned char *)(result + 8))
  {
    a2[1] = *(unsigned char *)(result + 9);
    *a2 = 1;
  }
  return result;
}

void gms::ZoomablePropertyStore<unsigned char>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565C60;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<unsigned char>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565C60;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

uint64_t gms::ZoomablePropertyStore<unsigned char>::zoomable()
{
  return 1;
}

void *gms::ZoomablePropertyStore<unsigned char>::getProperty@<X0>(void *result@<X0>, unsigned char *a2@<X8>, float a3@<S0>)
{
  *a2 = 0;
  unsigned int v4 = vcvtms_s32_f32(a3);
  if (v4 >= 0x17) {
    unsigned int v5 = 23;
  }
  else {
    unsigned int v5 = v4;
  }
  uint64_t v6 = (void *)result[5];
  __int16 v7 = result + 6;
  uint64_t v8 = v6;
  if (v6 != result + 6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = (void *)result[5];
    do
    {
      unint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v10[2];
          BOOL v13 = *v12 == (void)v10;
          unint64_t v10 = v12;
        }
        while (!v13);
      }
      ++v9;
      unint64_t v10 = v12;
    }
    while (v12 != v7);
    uint64_t v8 = (void *)result[5];
    do
    {
      unint64_t v14 = v9 >> 1;
      BOOL v15 = v8;
      if (v9 != 1)
      {
        uint64_t v17 = v9 >> 1;
        uint64_t v18 = v8;
        do
        {
          uint64_t v20 = (void *)v18[1];
          if (v20)
          {
            do
            {
              BOOL v15 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              BOOL v15 = (void *)v18[2];
              BOOL v13 = *v15 == (void)v18;
              uint64_t v18 = v15;
            }
            while (!v13);
          }
          uint64_t v18 = v15;
          BOOL v19 = v17-- <= 1;
        }
        while (!v19);
      }
      if (v5 >= *((unsigned __int8 *)v15 + 26))
      {
        uint64_t v16 = (void *)v15[1];
        if (v16)
        {
          do
          {
            uint64_t v8 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v15[2];
            BOOL v13 = *v8 == (void)v15;
            BOOL v15 = v8;
          }
          while (!v13);
        }
        unint64_t v14 = v9 + ~v14;
      }
      unint64_t v9 = v14;
    }
    while (v14);
  }
  if (v8 == v7 || (v5 >= *((unsigned __int8 *)v8 + 25) ? (BOOL v21 = v5 >= *((unsigned __int8 *)v8 + 26)) : (BOOL v21 = 1), v21)) {
    uint64_t v8 = result + 6;
  }
  unsigned __int8 v22 = v5 + 1;
  uint64_t v23 = (void *)result[5];
  if (v6 != v7)
  {
    unint64_t v24 = 0;
    uint64_t v25 = (void *)result[5];
    do
    {
      unsigned int v26 = (void *)v25[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          unsigned int v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v25[2];
          BOOL v13 = *v27 == (void)v25;
          uint64_t v25 = v27;
        }
        while (!v13);
      }
      ++v24;
      uint64_t v25 = v27;
    }
    while (v27 != v7);
    uint64_t v23 = (void *)result[5];
    do
    {
      unint64_t v28 = v24 >> 1;
      uint64_t v29 = v23;
      if (v24 != 1)
      {
        uint64_t v31 = v24 >> 1;
        uint64_t v32 = v23;
        do
        {
          uint64_t v33 = (void *)v32[1];
          if (v33)
          {
            do
            {
              uint64_t v29 = v33;
              uint64_t v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              uint64_t v29 = (void *)v32[2];
              BOOL v13 = *v29 == (void)v32;
              uint64_t v32 = v29;
            }
            while (!v13);
          }
          uint64_t v32 = v29;
          BOOL v19 = v31-- <= 1;
        }
        while (!v19);
      }
      if (*((unsigned __int8 *)v29 + 26) <= v22)
      {
        unsigned int v30 = (void *)v29[1];
        if (v30)
        {
          do
          {
            uint64_t v23 = v30;
            unsigned int v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v23 = (void *)v29[2];
            BOOL v13 = *v23 == (void)v29;
            uint64_t v29 = v23;
          }
          while (!v13);
        }
        unint64_t v28 = v24 + ~v28;
      }
      unint64_t v24 = v28;
    }
    while (v28);
  }
  if (v23 == v7
    || *((unsigned __int8 *)v23 + 25) > v22
    || *((unsigned __int8 *)v23 + 26) <= v22)
  {
    uint64_t v23 = result + 6;
  }
  if (v8 != v7 && result[7])
  {
    if (v23 == v7 || (uint64_t result = (void *)result[4]) == 0 || (v34 = a3 - (float)v5, v34 > 1.0) || v34 < 0.0)
    {
      if (v6 != v7)
      {
        unint64_t v40 = 0;
        unint64_t v41 = v6;
        do
        {
          uint64_t v42 = (void *)v41[1];
          if (v42)
          {
            do
            {
              uint64_t v43 = v42;
              uint64_t v42 = (void *)*v42;
            }
            while (v42);
          }
          else
          {
            do
            {
              uint64_t v43 = (void *)v41[2];
              BOOL v13 = *v43 == (void)v41;
              unint64_t v41 = v43;
            }
            while (!v13);
          }
          ++v40;
          unint64_t v41 = v43;
        }
        while (v43 != v7);
        do
        {
          unint64_t v44 = v40 >> 1;
          unint64_t v45 = v6;
          if (v40 != 1)
          {
            uint64_t v47 = v40 >> 1;
            uint64_t v48 = v6;
            do
            {
              uint64_t v49 = (void *)v48[1];
              if (v49)
              {
                do
                {
                  unint64_t v45 = v49;
                  uint64_t v49 = (void *)*v49;
                }
                while (v49);
              }
              else
              {
                do
                {
                  unint64_t v45 = (void *)v48[2];
                  BOOL v13 = *v45 == (void)v48;
                  uint64_t v48 = v45;
                }
                while (!v13);
              }
              uint64_t v48 = v45;
              BOOL v19 = v47-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v45 + 26))
          {
            uint64_t v46 = (void *)v45[1];
            if (v46)
            {
              do
              {
                uint64_t v6 = v46;
                uint64_t v46 = (void *)*v46;
              }
              while (v46);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v45[2];
                BOOL v13 = *v6 == (void)v45;
                unint64_t v45 = v6;
              }
              while (!v13);
            }
            unint64_t v44 = v40 + ~v44;
          }
          unint64_t v40 = v44;
        }
        while (v44);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 25) ? (BOOL v50 = v5 >= *((unsigned __int8 *)v6 + 26)) : (BOOL v50 = 1), v50))
      {
        uint64_t v6 = v7;
      }
      *a2 = 1;
      a2[1] = *((unsigned char *)v6 + 27);
    }
    else
    {
      float v35 = v6;
      if (v6 != v7)
      {
        unint64_t v36 = 0;
        unint64_t v37 = v6;
        do
        {
          uint64_t v38 = (void *)v37[1];
          if (v38)
          {
            do
            {
              uint64_t v39 = v38;
              uint64_t v38 = (void *)*v38;
            }
            while (v38);
          }
          else
          {
            do
            {
              uint64_t v39 = (void *)v37[2];
              BOOL v13 = *v39 == (void)v37;
              unint64_t v37 = v39;
            }
            while (!v13);
          }
          ++v36;
          unint64_t v37 = v39;
        }
        while (v39 != v7);
        float v35 = v6;
        do
        {
          unint64_t v51 = v36 >> 1;
          unint64_t v52 = v35;
          if (v36 != 1)
          {
            uint64_t v54 = v36 >> 1;
            uint64_t v55 = v35;
            do
            {
              __guard v56 = (void *)v55[1];
              if (v56)
              {
                do
                {
                  unint64_t v52 = v56;
                  __guard v56 = (void *)*v56;
                }
                while (v56);
              }
              else
              {
                do
                {
                  unint64_t v52 = (void *)v55[2];
                  BOOL v13 = *v52 == (void)v55;
                  uint64_t v55 = v52;
                }
                while (!v13);
              }
              uint64_t v55 = v52;
              BOOL v19 = v54-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v52 + 26))
          {
            __guard v53 = (void *)v52[1];
            if (v53)
            {
              do
              {
                float v35 = v53;
                __guard v53 = (void *)*v53;
              }
              while (v53);
            }
            else
            {
              do
              {
                float v35 = (void *)v52[2];
                BOOL v13 = *v35 == (void)v52;
                unint64_t v52 = v35;
              }
              while (!v13);
            }
            unint64_t v51 = v36 + ~v51;
          }
          unint64_t v36 = v51;
        }
        while (v51);
      }
      if (v35 == v7
        || (v5 >= *((unsigned __int8 *)v35 + 25) ? (BOOL v57 = v5 >= *((unsigned __int8 *)v35 + 26)) : (BOOL v57 = 1), v57))
      {
        float v35 = v7;
      }
      char v69 = *((unsigned char *)v35 + 27);
      if (v6 != v7)
      {
        unint64_t v58 = 0;
        unint64_t v59 = v6;
        do
        {
          double v60 = (void *)v59[1];
          if (v60)
          {
            do
            {
              int v61 = v60;
              double v60 = (void *)*v60;
            }
            while (v60);
          }
          else
          {
            do
            {
              int v61 = (void *)v59[2];
              BOOL v13 = *v61 == (void)v59;
              unint64_t v59 = v61;
            }
            while (!v13);
          }
          ++v58;
          unint64_t v59 = v61;
        }
        while (v61 != v7);
        do
        {
          unint64_t v62 = v58 >> 1;
          unint64_t v63 = v6;
          if (v58 != 1)
          {
            uint64_t v65 = v58 >> 1;
            uint64_t v66 = v6;
            do
            {
              int v67 = (void *)v66[1];
              if (v67)
              {
                do
                {
                  unint64_t v63 = v67;
                  int v67 = (void *)*v67;
                }
                while (v67);
              }
              else
              {
                do
                {
                  unint64_t v63 = (void *)v66[2];
                  BOOL v13 = *v63 == (void)v66;
                  uint64_t v66 = v63;
                }
                while (!v13);
              }
              uint64_t v66 = v63;
              BOOL v19 = v65-- <= 1;
            }
            while (!v19);
          }
          if (*((unsigned __int8 *)v63 + 26) <= v22)
          {
            float v64 = (void *)v63[1];
            if (v64)
            {
              do
              {
                uint64_t v6 = v64;
                float v64 = (void *)*v64;
              }
              while (v64);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v63[2];
                BOOL v13 = *v6 == (void)v63;
                unint64_t v63 = v6;
              }
              while (!v13);
            }
            unint64_t v62 = v58 + ~v62;
          }
          unint64_t v58 = v62;
        }
        while (v62);
      }
      if (v6 == v7
        || *((unsigned __int8 *)v6 + 25) > v22
        || *((unsigned __int8 *)v6 + 26) <= v22)
      {
        uint64_t v6 = v7;
      }
      char v68 = *((unsigned char *)v6 + 27);
      float v70 = v34;
      uint64_t result = (void *)(*(uint64_t (**)(void *, float *, char *, char *))(*result + 48))(result, &v70, &v69, &v68);
      *a2 = 1;
      a2[1] = (_BYTE)result;
    }
  }
  return result;
}

void gms::_BuildingMaterial<ggl::Texture2D>::~_BuildingMaterial(void *a1)
{
  gms::_BuildingMaterial<ggl::Texture2D>::~_BuildingMaterial(a1);
  JUMPOUT(0x1A6239270);
}

void *gms::_BuildingMaterial<ggl::Texture2D>::~_BuildingMaterial(void *a1)
{
  *a1 = &unk_1EF5653D0;
  uint64_t v2 = a1[17];
  a1[17] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = a1[16];
  a1[16] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  uint64_t v4 = a1[15];
  a1[15] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = a1[14];
  a1[14] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  uint64_t v6 = a1[13];
  a1[13] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
  }
  uint64_t v7 = a1[12];
  a1[12] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  uint64_t v8 = a1[11];
  a1[11] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  return gms::_Material<ggl::Texture2D>::~_Material(a1);
}

void *gms::_Material<ggl::Texture2D>::~_Material(void *a1)
{
  *a1 = &unk_1EF566C48;
  uint64_t v2 = (std::__shared_weak_count *)a1[10];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[7];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[7];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  uint64_t v4 = (void *)a1[3];
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      operator delete(v4);
      uint64_t v4 = v5;
    }
    while (v5);
  }
  uint64_t v6 = (void *)a1[1];
  a1[1] = 0;
  if (v6) {
    operator delete(v6);
  }
  return a1;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyAlbedoFactorRGB()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::albedoFactorRGB(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyAlpha()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::alpha(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyNoColorCorrection()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::noColorCorrection(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyBrightnessRemapRange()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::brightnessRemapRange(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnySaturationRemapRange()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::saturationRemapRange(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyAlbedoFactor()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::albedoFactor(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_Material<ggl::Texture2D>::hasAnyAlbedo()
{
  return 0;
}

void gms::_Material<ggl::Texture2D>::albedo(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

void gms::_Material<ggl::Texture2D>::~_Material(void *a1)
{
  gms::_Material<ggl::Texture2D>::~_Material(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<gms::_BuildingMaterial<ggl::Texture2D>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gms::_BuildingMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A200;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gms::_BuildingMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A200;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyColorRampRGB(uint64_t a1)
{
  return *(void *)(a1 + 224) != 0;
}

void gms::NonZoomablePropertyStore<std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565DB0;
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v4 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v4) {
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 8) = 0;
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::NonZoomablePropertyStore<std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565DB0;
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v4 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v4) {
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 8) = 0;
  }
  return a1;
}

uint64_t gms::NonZoomablePropertyStore<std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::zoomable()
{
  return 0;
}

void gms::ZoomablePropertyStore<std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565B80;
  std::__tree<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,std::__map_value_compare<gm::Range<unsigned char>,std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,geo::range_map<unsigned char,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::RangeCompare,true>,std::allocator<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

void std::__tree<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,std::__map_value_compare<gm::Range<unsigned char>,std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,geo::range_map<unsigned char,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::RangeCompare,true>,std::allocator<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,std::__map_value_compare<gm::Range<unsigned char>,std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,geo::range_map<unsigned char,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::RangeCompare,true>,std::allocator<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::destroy(*a1);
    std::__tree<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,std::__map_value_compare<gm::Range<unsigned char>,std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,geo::range_map<unsigned char,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::RangeCompare,true>,std::allocator<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::destroy(a1[1]);
    uint64_t v2 = (void *)a1[7];
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v4 = (void *)a1[5];
    a1[5] = 0;
    if (v4) {
      operator delete(v4);
    }
    operator delete(a1);
  }
}

uint64_t gms::ZoomablePropertyStore<std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565B80;
  std::__tree<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,std::__map_value_compare<gm::Range<unsigned char>,std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,geo::range_map<unsigned char,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::RangeCompare,true>,std::allocator<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

uint64_t gms::ZoomablePropertyStore<std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::zoomable()
{
  return 1;
}

uint64_t std::pair<gm::Range<unsigned char> const,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 8);
  *(void *)(a1 + 8) = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void gms::ZoomablePropertyStore<std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::getProperty(void *a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(unsigned char *)a2 = 0;
  unsigned int v5 = vcvtms_s32_f32(a3);
  if (v5 >= 0x17) {
    unsigned int v5 = 23;
  }
  uint64_t v6 = (void *)a1[5];
  uint64_t v7 = a1 + 6;
  uint64_t v8 = v6;
  if (v6 != a1 + 6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = (void *)a1[5];
    do
    {
      unint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v10[2];
          BOOL v13 = *v12 == (void)v10;
          unint64_t v10 = v12;
        }
        while (!v13);
      }
      ++v9;
      unint64_t v10 = v12;
    }
    while (v12 != v7);
    uint64_t v8 = (void *)a1[5];
    do
    {
      unint64_t v14 = v9 >> 1;
      BOOL v15 = v8;
      if (v9 != 1)
      {
        uint64_t v17 = v9 >> 1;
        uint64_t v18 = v8;
        do
        {
          uint64_t v20 = (void *)v18[1];
          if (v20)
          {
            do
            {
              BOOL v15 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              BOOL v15 = (void *)v18[2];
              BOOL v13 = *v15 == (void)v18;
              uint64_t v18 = v15;
            }
            while (!v13);
          }
          uint64_t v18 = v15;
          BOOL v19 = v17-- <= 1;
        }
        while (!v19);
      }
      if (v5 >= *((unsigned __int8 *)v15 + 33))
      {
        uint64_t v16 = (void *)v15[1];
        if (v16)
        {
          do
          {
            uint64_t v8 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v15[2];
            BOOL v13 = *v8 == (void)v15;
            BOOL v15 = v8;
          }
          while (!v13);
        }
        unint64_t v14 = v9 + ~v14;
      }
      unint64_t v9 = v14;
    }
    while (v14);
  }
  if (v8 == v7 || (v5 >= *((unsigned __int8 *)v8 + 32) ? (BOOL v21 = v5 >= *((unsigned __int8 *)v8 + 33)) : (BOOL v21 = 1), v21)) {
    uint64_t v8 = a1 + 6;
  }
  unsigned __int8 v22 = v5 + 1;
  uint64_t v23 = (void *)a1[5];
  if (v6 != v7)
  {
    unint64_t v24 = 0;
    uint64_t v25 = (void *)a1[5];
    do
    {
      unsigned int v26 = (void *)v25[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          unsigned int v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v25[2];
          BOOL v13 = *v27 == (void)v25;
          uint64_t v25 = v27;
        }
        while (!v13);
      }
      ++v24;
      uint64_t v25 = v27;
    }
    while (v27 != v7);
    uint64_t v23 = (void *)a1[5];
    do
    {
      unint64_t v28 = v24 >> 1;
      uint64_t v29 = v23;
      if (v24 != 1)
      {
        uint64_t v31 = v24 >> 1;
        uint64_t v32 = v23;
        do
        {
          uint64_t v33 = (void *)v32[1];
          if (v33)
          {
            do
            {
              uint64_t v29 = v33;
              uint64_t v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              uint64_t v29 = (void *)v32[2];
              BOOL v13 = *v29 == (void)v32;
              uint64_t v32 = v29;
            }
            while (!v13);
          }
          uint64_t v32 = v29;
          BOOL v19 = v31-- <= 1;
        }
        while (!v19);
      }
      if (*((unsigned __int8 *)v29 + 33) <= v22)
      {
        unsigned int v30 = (void *)v29[1];
        if (v30)
        {
          do
          {
            uint64_t v23 = v30;
            unsigned int v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v23 = (void *)v29[2];
            BOOL v13 = *v23 == (void)v29;
            uint64_t v29 = v23;
          }
          while (!v13);
        }
        unint64_t v28 = v24 + ~v28;
      }
      unint64_t v24 = v28;
    }
    while (v28);
  }
  if (v23 == v7
    || *((unsigned __int8 *)v23 + 32) > v22
    || *((unsigned __int8 *)v23 + 33) <= v22)
  {
    uint64_t v23 = a1 + 6;
  }
  if (v8 != v7 && a1[7])
  {
    if (v23 == v7 || !a1[4] || (float v34 = a3 - (float)v5, v34 > 1.0) || v34 < 0.0)
    {
      if (v6 != v7)
      {
        unint64_t v57 = 0;
        unint64_t v58 = (void *)a1[5];
        do
        {
          unint64_t v59 = (void *)v58[1];
          if (v59)
          {
            do
            {
              double v60 = v59;
              unint64_t v59 = (void *)*v59;
            }
            while (v59);
          }
          else
          {
            do
            {
              double v60 = (void *)v58[2];
              BOOL v13 = *v60 == (void)v58;
              unint64_t v58 = v60;
            }
            while (!v13);
          }
          ++v57;
          unint64_t v58 = v60;
        }
        while (v60 != v7);
        do
        {
          unint64_t v61 = v57 >> 1;
          unint64_t v62 = v6;
          if (v57 != 1)
          {
            uint64_t v64 = v57 >> 1;
            uint64_t v65 = v6;
            do
            {
              uint64_t v66 = (void *)v65[1];
              if (v66)
              {
                do
                {
                  unint64_t v62 = v66;
                  uint64_t v66 = (void *)*v66;
                }
                while (v66);
              }
              else
              {
                do
                {
                  unint64_t v62 = (void *)v65[2];
                  BOOL v13 = *v62 == (void)v65;
                  uint64_t v65 = v62;
                }
                while (!v13);
              }
              uint64_t v65 = v62;
              BOOL v19 = v64-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v62 + 33))
          {
            unint64_t v63 = (void *)v62[1];
            if (v63)
            {
              do
              {
                uint64_t v6 = v63;
                unint64_t v63 = (void *)*v63;
              }
              while (v63);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v62[2];
                BOOL v13 = *v6 == (void)v62;
                unint64_t v62 = v6;
              }
              while (!v13);
            }
            unint64_t v61 = v57 + ~v61;
          }
          unint64_t v57 = v61;
        }
        while (v61);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 32) ? (BOOL v67 = v5 >= *((unsigned __int8 *)v6 + 33)) : (BOOL v67 = 1), v67))
      {
        uint64_t v6 = a1 + 6;
      }
      *(unsigned char *)a2 = 1;
      std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>::unordered_map(a2 + 8, (uint64_t)(v6 + 5));
    }
    else
    {
      if (v6 != v7)
      {
        unint64_t v35 = 0;
        unint64_t v36 = (void *)a1[5];
        do
        {
          unint64_t v37 = (void *)v36[1];
          if (v37)
          {
            do
            {
              uint64_t v38 = v37;
              unint64_t v37 = (void *)*v37;
            }
            while (v37);
          }
          else
          {
            do
            {
              uint64_t v38 = (void *)v36[2];
              BOOL v13 = *v38 == (void)v36;
              unint64_t v36 = v38;
            }
            while (!v13);
          }
          ++v35;
          unint64_t v36 = v38;
        }
        while (v38 != v7);
        do
        {
          unint64_t v39 = v35 >> 1;
          unint64_t v40 = v6;
          if (v35 != 1)
          {
            uint64_t v42 = v35 >> 1;
            uint64_t v43 = v6;
            do
            {
              unint64_t v44 = (void *)v43[1];
              if (v44)
              {
                do
                {
                  unint64_t v40 = v44;
                  unint64_t v44 = (void *)*v44;
                }
                while (v44);
              }
              else
              {
                do
                {
                  unint64_t v40 = (void *)v43[2];
                  BOOL v13 = *v40 == (void)v43;
                  uint64_t v43 = v40;
                }
                while (!v13);
              }
              uint64_t v43 = v40;
              BOOL v19 = v42-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v40 + 33))
          {
            unint64_t v41 = (void *)v40[1];
            if (v41)
            {
              do
              {
                uint64_t v6 = v41;
                unint64_t v41 = (void *)*v41;
              }
              while (v41);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v40[2];
                BOOL v13 = *v6 == (void)v40;
                unint64_t v40 = v6;
              }
              while (!v13);
            }
            unint64_t v39 = v35 + ~v39;
          }
          unint64_t v35 = v39;
        }
        while (v39);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 32) ? (BOOL v45 = v5 >= *((unsigned __int8 *)v6 + 33)) : (BOOL v45 = 1), v45))
      {
        uint64_t v6 = a1 + 6;
      }
      std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>::unordered_map((uint64_t)&v93, (uint64_t)(v6 + 5));
      uint64_t v46 = (void *)a1[5];
      if (v46 == v7) {
        goto LABEL_175;
      }
      unint64_t v47 = 0;
      uint64_t v48 = (void *)a1[5];
      do
      {
        uint64_t v49 = (void *)v48[1];
        if (v49)
        {
          do
          {
            BOOL v50 = v49;
            uint64_t v49 = (void *)*v49;
          }
          while (v49);
        }
        else
        {
          do
          {
            BOOL v50 = (void *)v48[2];
            BOOL v13 = *v50 == (void)v48;
            uint64_t v48 = v50;
          }
          while (!v13);
        }
        ++v47;
        uint64_t v48 = v50;
      }
      while (v50 != v7);
      do
      {
        unint64_t v51 = v47 >> 1;
        unint64_t v52 = v46;
        if (v47 != 1)
        {
          uint64_t v54 = v47 >> 1;
          uint64_t v55 = v46;
          do
          {
            __guard v56 = (void *)v55[1];
            if (v56)
            {
              do
              {
                unint64_t v52 = v56;
                __guard v56 = (void *)*v56;
              }
              while (v56);
            }
            else
            {
              do
              {
                unint64_t v52 = (void *)v55[2];
                BOOL v13 = *v52 == (void)v55;
                uint64_t v55 = v52;
              }
              while (!v13);
            }
            uint64_t v55 = v52;
            BOOL v19 = v54-- <= 1;
          }
          while (!v19);
        }
        if (*((unsigned __int8 *)v52 + 33) <= v22)
        {
          __guard v53 = (void *)v52[1];
          if (v53)
          {
            do
            {
              uint64_t v46 = v53;
              __guard v53 = (void *)*v53;
            }
            while (v53);
          }
          else
          {
            do
            {
              uint64_t v46 = (void *)v52[2];
              BOOL v13 = *v46 == (void)v52;
              unint64_t v52 = v46;
            }
            while (!v13);
          }
          unint64_t v51 = v47 + ~v51;
        }
        unint64_t v47 = v51;
      }
      while (v51);
      if (v46 == v7
        || *((unsigned __int8 *)v46 + 32) > v22
        || *((unsigned __int8 *)v46 + 33) <= v22)
      {
LABEL_175:
        uint64_t v46 = v7;
      }
      std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>::unordered_map((uint64_t)&v91, (uint64_t)(v46 + 5));
      float v95 = v34;
      uint64_t v68 = a1[4];
      if (v68)
      {
        (*(void (**)(void **__return_ptr))(*(void *)v68 + 48))(&__p);
        if (*(unsigned char *)a2)
        {
          char v69 = *(void **)(a2 + 24);
          if (v69)
          {
            do
            {
              float v70 = (void *)*v69;
              operator delete(v69);
              char v69 = v70;
            }
            while (v70);
          }
          uint64_t v71 = *(void **)(a2 + 8);
          *(void *)(a2 + 8) = 0;
          if (v71) {
            operator delete(v71);
          }
        }
        else
        {
          *(unsigned char *)a2 = 1;
        }
        uint64_t v72 = __p;
        unint64_t v73 = v87;
        id v74 = v88;
        uint64_t v75 = v89;
        *(void *)(a2 + 24) = v88;
        uint64_t v76 = a2 + 24;
        std::string __p = 0;
        unint64_t v87 = 0;
        *(void *)(v76 - 16) = v72;
        *(void *)(v76 - 8) = v73;
        *(void *)(v76 + 8) = v75;
        *(_DWORD *)(v76 + 16) = v90;
        if (v75)
        {
          unint64_t v77 = v74[1];
          if ((v73 & (v73 - 1)) != 0)
          {
            if (v77 >= v73) {
              v77 %= v73;
            }
          }
          else
          {
            v77 &= v73 - 1;
          }
          v72[v77] = v76;
          char v88 = 0;
          uint64_t v89 = 0;
        }
        else if (v74)
        {
          do
          {
            BOOL v78 = (void *)*v74;
            operator delete(v74);
            id v74 = v78;
          }
          while (v78);
        }
        unint64_t v79 = __p;
        std::string __p = 0;
        if (v79) {
          operator delete(v79);
        }
        uint64_t v80 = v92;
        if (v92)
        {
          do
          {
            uint64_t v81 = (void *)*v80;
            operator delete(v80);
            uint64_t v80 = v81;
          }
          while (v81);
        }
        long long v82 = v91;
        uint64_t v91 = 0;
        if (v82) {
          operator delete(v82);
        }
        uint64_t v83 = v94;
        if (v94)
        {
          do
          {
            PolylineCoordinate v84 = (void *)*v83;
            operator delete(v83);
            uint64_t v83 = v84;
          }
          while (v84);
        }
        uint64_t v85 = v93;
        uint64_t v93 = 0;
        if (v85) {
          operator delete(v85);
        }
      }
      else
      {
        std::__throw_bad_function_call[abi:nn180100]();
        __break(1u);
      }
    }
  }
}

void sub_1A1FA58D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100]((uint64_t)va);
  geo::optional<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::~optional(v11);
  _Unwind_Resume(a1);
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyGradientMaskFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 216) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::gradientMaskFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 216);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 696))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addGradientMaskFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 216);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Du, 285);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyEmissiveFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 208) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::emissiveFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 208);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 672))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addEmissiveFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 208);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Cu, 284);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyAlpha(uint64_t a1)
{
  return *(void *)(a1 + 200) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addAlpha(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 200);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Au, 282);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyHideOnCollapse(uint64_t a1)
{
  return *(void *)(a1 + 192) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hideOnCollapse@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 192);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 576))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addHideOnCollapse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 192);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x18u, 280);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyGradientMaskFactor(uint64_t a1)
{
  return *(void *)(a1 + 184) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::gradientMaskFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 184);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 552))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addGradientMaskFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 184);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x17u, 279);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyColorRamp(uint64_t a1)
{
  return *(void *)(a1 + 176) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::colorRamp@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 176);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 408))();
  }
  *a2 = 0;
  return result;
}

void gms::NonZoomablePropertyStore<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565DE8;
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v4 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v4) {
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 8) = 0;
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::NonZoomablePropertyStore<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565DE8;
  if (*(unsigned char *)(a1 + 8))
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      do
      {
        uint64_t v3 = (void *)*v2;
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    uint64_t v4 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v4) {
      operator delete(v4);
    }
    *(unsigned char *)(a1 + 8) = 0;
  }
  return a1;
}

uint64_t gms::NonZoomablePropertyStore<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::zoomable()
{
  return 0;
}

uint64_t gms::NonZoomablePropertyStore<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::getProperty@<X0>(uint64_t result@<X0>, unsigned char *a2@<X8>)
{
  *a2 = 0;
  if (*(unsigned char *)(result + 8))
  {
    uint64_t result = std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>::unordered_map((uint64_t)(a2 + 8), result + 16);
    *a2 = 1;
  }
  return result;
}

void gms::ZoomablePropertyStore<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565BB8;
  std::__tree<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,std::__map_value_compare<gm::Range<unsigned char>,std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,geo::range_map<unsigned char,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::RangeCompare,true>,std::allocator<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565BB8;
  std::__tree<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,std::__map_value_compare<gm::Range<unsigned char>,std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>,geo::range_map<unsigned char,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::less<unsigned char>,std::allocator<std::pair<gm::Range<unsigned char> const,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::RangeCompare,true>,std::allocator<std::__value_type<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

uint64_t gms::ZoomablePropertyStore<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::zoomable()
{
  return 1;
}

void gms::ZoomablePropertyStore<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::getProperty(void *a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(unsigned char *)a2 = 0;
  unsigned int v5 = vcvtms_s32_f32(a3);
  if (v5 >= 0x17) {
    unsigned int v5 = 23;
  }
  uint64_t v6 = (void *)a1[5];
  uint64_t v7 = a1 + 6;
  uint64_t v8 = v6;
  if (v6 != a1 + 6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = (void *)a1[5];
    do
    {
      uint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v10[2];
          BOOL v13 = *v12 == (void)v10;
          unint64_t v10 = v12;
        }
        while (!v13);
      }
      ++v9;
      unint64_t v10 = v12;
    }
    while (v12 != v7);
    uint64_t v8 = (void *)a1[5];
    do
    {
      unint64_t v14 = v9 >> 1;
      BOOL v15 = v8;
      if (v9 != 1)
      {
        uint64_t v17 = v9 >> 1;
        uint64_t v18 = v8;
        do
        {
          uint64_t v20 = (void *)v18[1];
          if (v20)
          {
            do
            {
              BOOL v15 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              BOOL v15 = (void *)v18[2];
              BOOL v13 = *v15 == (void)v18;
              uint64_t v18 = v15;
            }
            while (!v13);
          }
          uint64_t v18 = v15;
          BOOL v19 = v17-- <= 1;
        }
        while (!v19);
      }
      if (v5 >= *((unsigned __int8 *)v15 + 33))
      {
        uint64_t v16 = (void *)v15[1];
        if (v16)
        {
          do
          {
            uint64_t v8 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v15[2];
            BOOL v13 = *v8 == (void)v15;
            BOOL v15 = v8;
          }
          while (!v13);
        }
        unint64_t v14 = v9 + ~v14;
      }
      unint64_t v9 = v14;
    }
    while (v14);
  }
  if (v8 == v7 || (v5 >= *((unsigned __int8 *)v8 + 32) ? (BOOL v21 = v5 >= *((unsigned __int8 *)v8 + 33)) : (BOOL v21 = 1), v21)) {
    uint64_t v8 = a1 + 6;
  }
  unsigned __int8 v22 = v5 + 1;
  uint64_t v23 = (void *)a1[5];
  if (v6 != v7)
  {
    unint64_t v24 = 0;
    uint64_t v25 = (void *)a1[5];
    do
    {
      unsigned int v26 = (void *)v25[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          unsigned int v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v25[2];
          BOOL v13 = *v27 == (void)v25;
          uint64_t v25 = v27;
        }
        while (!v13);
      }
      ++v24;
      uint64_t v25 = v27;
    }
    while (v27 != v7);
    uint64_t v23 = (void *)a1[5];
    do
    {
      unint64_t v28 = v24 >> 1;
      uint64_t v29 = v23;
      if (v24 != 1)
      {
        uint64_t v31 = v24 >> 1;
        uint64_t v32 = v23;
        do
        {
          uint64_t v33 = (void *)v32[1];
          if (v33)
          {
            do
            {
              uint64_t v29 = v33;
              uint64_t v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              uint64_t v29 = (void *)v32[2];
              BOOL v13 = *v29 == (void)v32;
              uint64_t v32 = v29;
            }
            while (!v13);
          }
          uint64_t v32 = v29;
          BOOL v19 = v31-- <= 1;
        }
        while (!v19);
      }
      if (*((unsigned __int8 *)v29 + 33) <= v22)
      {
        unsigned int v30 = (void *)v29[1];
        if (v30)
        {
          do
          {
            uint64_t v23 = v30;
            unsigned int v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v23 = (void *)v29[2];
            BOOL v13 = *v23 == (void)v29;
            uint64_t v29 = v23;
          }
          while (!v13);
        }
        unint64_t v28 = v24 + ~v28;
      }
      unint64_t v24 = v28;
    }
    while (v28);
  }
  if (v23 == v7
    || *((unsigned __int8 *)v23 + 32) > v22
    || *((unsigned __int8 *)v23 + 33) <= v22)
  {
    uint64_t v23 = a1 + 6;
  }
  if (v8 != v7 && a1[7])
  {
    if (v23 == v7 || !a1[4] || (float v34 = a3 - (float)v5, v34 > 1.0) || v34 < 0.0)
    {
      if (v6 != v7)
      {
        unint64_t v57 = 0;
        unint64_t v58 = (void *)a1[5];
        do
        {
          unint64_t v59 = (void *)v58[1];
          if (v59)
          {
            do
            {
              double v60 = v59;
              unint64_t v59 = (void *)*v59;
            }
            while (v59);
          }
          else
          {
            do
            {
              double v60 = (void *)v58[2];
              BOOL v13 = *v60 == (void)v58;
              unint64_t v58 = v60;
            }
            while (!v13);
          }
          ++v57;
          unint64_t v58 = v60;
        }
        while (v60 != v7);
        do
        {
          unint64_t v61 = v57 >> 1;
          unint64_t v62 = v6;
          if (v57 != 1)
          {
            uint64_t v64 = v57 >> 1;
            uint64_t v65 = v6;
            do
            {
              uint64_t v66 = (void *)v65[1];
              if (v66)
              {
                do
                {
                  unint64_t v62 = v66;
                  uint64_t v66 = (void *)*v66;
                }
                while (v66);
              }
              else
              {
                do
                {
                  unint64_t v62 = (void *)v65[2];
                  BOOL v13 = *v62 == (void)v65;
                  uint64_t v65 = v62;
                }
                while (!v13);
              }
              uint64_t v65 = v62;
              BOOL v19 = v64-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v62 + 33))
          {
            unint64_t v63 = (void *)v62[1];
            if (v63)
            {
              do
              {
                uint64_t v6 = v63;
                unint64_t v63 = (void *)*v63;
              }
              while (v63);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v62[2];
                BOOL v13 = *v6 == (void)v62;
                unint64_t v62 = v6;
              }
              while (!v13);
            }
            unint64_t v61 = v57 + ~v61;
          }
          unint64_t v57 = v61;
        }
        while (v61);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 32) ? (BOOL v67 = v5 >= *((unsigned __int8 *)v6 + 33)) : (BOOL v67 = 1), v67))
      {
        uint64_t v6 = a1 + 6;
      }
      *(unsigned char *)a2 = 1;
      std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>::unordered_map(a2 + 8, (uint64_t)(v6 + 5));
    }
    else
    {
      if (v6 != v7)
      {
        unint64_t v35 = 0;
        unint64_t v36 = (void *)a1[5];
        do
        {
          unint64_t v37 = (void *)v36[1];
          if (v37)
          {
            do
            {
              uint64_t v38 = v37;
              unint64_t v37 = (void *)*v37;
            }
            while (v37);
          }
          else
          {
            do
            {
              uint64_t v38 = (void *)v36[2];
              BOOL v13 = *v38 == (void)v36;
              unint64_t v36 = v38;
            }
            while (!v13);
          }
          ++v35;
          unint64_t v36 = v38;
        }
        while (v38 != v7);
        do
        {
          unint64_t v39 = v35 >> 1;
          unint64_t v40 = v6;
          if (v35 != 1)
          {
            uint64_t v42 = v35 >> 1;
            uint64_t v43 = v6;
            do
            {
              unint64_t v44 = (void *)v43[1];
              if (v44)
              {
                do
                {
                  unint64_t v40 = v44;
                  unint64_t v44 = (void *)*v44;
                }
                while (v44);
              }
              else
              {
                do
                {
                  unint64_t v40 = (void *)v43[2];
                  BOOL v13 = *v40 == (void)v43;
                  uint64_t v43 = v40;
                }
                while (!v13);
              }
              uint64_t v43 = v40;
              BOOL v19 = v42-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v40 + 33))
          {
            unint64_t v41 = (void *)v40[1];
            if (v41)
            {
              do
              {
                uint64_t v6 = v41;
                unint64_t v41 = (void *)*v41;
              }
              while (v41);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v40[2];
                BOOL v13 = *v6 == (void)v40;
                unint64_t v40 = v6;
              }
              while (!v13);
            }
            unint64_t v39 = v35 + ~v39;
          }
          unint64_t v35 = v39;
        }
        while (v39);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 32) ? (BOOL v45 = v5 >= *((unsigned __int8 *)v6 + 33)) : (BOOL v45 = 1), v45))
      {
        uint64_t v6 = a1 + 6;
      }
      std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>::unordered_map((uint64_t)&v93, (uint64_t)(v6 + 5));
      uint64_t v46 = (void *)a1[5];
      if (v46 == v7) {
        goto LABEL_175;
      }
      unint64_t v47 = 0;
      uint64_t v48 = (void *)a1[5];
      do
      {
        uint64_t v49 = (void *)v48[1];
        if (v49)
        {
          do
          {
            BOOL v50 = v49;
            uint64_t v49 = (void *)*v49;
          }
          while (v49);
        }
        else
        {
          do
          {
            BOOL v50 = (void *)v48[2];
            BOOL v13 = *v50 == (void)v48;
            uint64_t v48 = v50;
          }
          while (!v13);
        }
        ++v47;
        uint64_t v48 = v50;
      }
      while (v50 != v7);
      do
      {
        unint64_t v51 = v47 >> 1;
        unint64_t v52 = v46;
        if (v47 != 1)
        {
          uint64_t v54 = v47 >> 1;
          uint64_t v55 = v46;
          do
          {
            __guard v56 = (void *)v55[1];
            if (v56)
            {
              do
              {
                unint64_t v52 = v56;
                __guard v56 = (void *)*v56;
              }
              while (v56);
            }
            else
            {
              do
              {
                unint64_t v52 = (void *)v55[2];
                BOOL v13 = *v52 == (void)v55;
                uint64_t v55 = v52;
              }
              while (!v13);
            }
            uint64_t v55 = v52;
            BOOL v19 = v54-- <= 1;
          }
          while (!v19);
        }
        if (*((unsigned __int8 *)v52 + 33) <= v22)
        {
          __guard v53 = (void *)v52[1];
          if (v53)
          {
            do
            {
              uint64_t v46 = v53;
              __guard v53 = (void *)*v53;
            }
            while (v53);
          }
          else
          {
            do
            {
              uint64_t v46 = (void *)v52[2];
              BOOL v13 = *v46 == (void)v52;
              unint64_t v52 = v46;
            }
            while (!v13);
          }
          unint64_t v51 = v47 + ~v51;
        }
        unint64_t v47 = v51;
      }
      while (v51);
      if (v46 == v7
        || *((unsigned __int8 *)v46 + 32) > v22
        || *((unsigned __int8 *)v46 + 33) <= v22)
      {
LABEL_175:
        uint64_t v46 = v7;
      }
      std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>::unordered_map((uint64_t)&v91, (uint64_t)(v46 + 5));
      float v95 = v34;
      uint64_t v68 = a1[4];
      if (v68)
      {
        (*(void (**)(void **__return_ptr))(*(void *)v68 + 48))(&__p);
        if (*(unsigned char *)a2)
        {
          char v69 = *(void **)(a2 + 24);
          if (v69)
          {
            do
            {
              float v70 = (void *)*v69;
              operator delete(v69);
              char v69 = v70;
            }
            while (v70);
          }
          uint64_t v71 = *(void **)(a2 + 8);
          *(void *)(a2 + 8) = 0;
          if (v71) {
            operator delete(v71);
          }
        }
        else
        {
          *(unsigned char *)a2 = 1;
        }
        uint64_t v72 = __p;
        unint64_t v73 = v87;
        id v74 = v88;
        uint64_t v75 = v89;
        *(void *)(a2 + 24) = v88;
        uint64_t v76 = a2 + 24;
        std::string __p = 0;
        unint64_t v87 = 0;
        *(void *)(v76 - 16) = v72;
        *(void *)(v76 - 8) = v73;
        *(void *)(v76 + 8) = v75;
        *(_DWORD *)(v76 + 16) = v90;
        if (v75)
        {
          unint64_t v77 = v74[1];
          if ((v73 & (v73 - 1)) != 0)
          {
            if (v77 >= v73) {
              v77 %= v73;
            }
          }
          else
          {
            v77 &= v73 - 1;
          }
          v72[v77] = v76;
          char v88 = 0;
          uint64_t v89 = 0;
        }
        else if (v74)
        {
          do
          {
            BOOL v78 = (void *)*v74;
            operator delete(v74);
            id v74 = v78;
          }
          while (v78);
        }
        unint64_t v79 = __p;
        std::string __p = 0;
        if (v79) {
          operator delete(v79);
        }
        uint64_t v80 = v92;
        if (v92)
        {
          do
          {
            uint64_t v81 = (void *)*v80;
            operator delete(v80);
            uint64_t v80 = v81;
          }
          while (v81);
        }
        long long v82 = v91;
        uint64_t v91 = 0;
        if (v82) {
          operator delete(v82);
        }
        uint64_t v83 = v94;
        if (v94)
        {
          do
          {
            PolylineCoordinate v84 = (void *)*v83;
            operator delete(v83);
            uint64_t v83 = v84;
          }
          while (v84);
        }
        uint64_t v85 = v93;
        uint64_t v93 = 0;
        if (v85) {
          operator delete(v85);
        }
      }
      else
      {
        std::__throw_bad_function_call[abi:nn180100]();
        __break(1u);
      }
    }
  }
}

void sub_1A1FA6D3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100]((uint64_t)va);
  geo::optional<std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>::~optional(v11);
  _Unwind_Resume(a1);
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyCastShadow(uint64_t a1)
{
  return *(void *)(a1 + 168) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::castShadow@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 168);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 384))();
  }
  *a2 = 0;
  return result;
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyVisibility(uint64_t a1)
{
  return *(void *)(a1 + 160) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addVisibility(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 160);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xBu, 267);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyZIndex(uint64_t a1)
{
  return *(void *)(a1 + 152) != 0;
}

void gms::NonZoomablePropertyStore<unsigned int>::~NonZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565EC8;
  if (*(unsigned char *)(a1 + 8)) {
    *(unsigned char *)(a1 + 8) = 0;
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::NonZoomablePropertyStore<unsigned int>::~NonZoomablePropertyStore(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EF565EC8;
  if (*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

uint64_t gms::NonZoomablePropertyStore<unsigned int>::zoomable()
{
  return 0;
}

void gms::ZoomablePropertyStore<unsigned int>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565C98;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<unsigned int>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565C98;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

uint64_t gms::ZoomablePropertyStore<unsigned int>::zoomable()
{
  return 1;
}

uint64_t *gms::ZoomablePropertyStore<unsigned int>::addProperty(uint64_t *result, unsigned __int8 *a2, unsigned __int8 *a3, unsigned int *a4)
{
  uint64_t v4 = result;
  uint64_t v5 = *a2;
  unsigned int v6 = *a3;
  unint64_t v7 = (unint64_t)*a3 << 8;
  uint64_t v8 = *a4;
  if (result[7])
  {
    unint64_t v9 = (uint64_t *)result[5];
    unint64_t v10 = (uint64_t **)(result + 6);
    if (v9 == result + 6)
    {
      uint64_t v16 = (void *)result[5];
    }
    else
    {
      unint64_t v11 = 0;
      uint64_t v12 = (uint64_t *)result[5];
      do
      {
        BOOL v13 = (uint64_t *)v12[1];
        if (v13)
        {
          do
          {
            unint64_t v14 = (uint64_t **)v13;
            BOOL v13 = (uint64_t *)*v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            unint64_t v14 = (uint64_t **)v12[2];
            BOOL v15 = *v14 == v12;
            uint64_t v12 = (uint64_t *)v14;
          }
          while (!v15);
        }
        ++v11;
        uint64_t v12 = (uint64_t *)v14;
      }
      while (v14 != v10);
      uint64_t v16 = (void *)result[5];
      do
      {
        unint64_t v17 = v11 >> 1;
        uint64_t v18 = v16;
        if (v11 != 1)
        {
          uint64_t v20 = v11 >> 1;
          BOOL v21 = v16;
          do
          {
            uint64_t v23 = (void *)v21[1];
            if (v23)
            {
              do
              {
                uint64_t v18 = v23;
                uint64_t v23 = (void *)*v23;
              }
              while (v23);
            }
            else
            {
              do
              {
                uint64_t v18 = (void *)v21[2];
                BOOL v15 = *v18 == (void)v21;
                BOOL v21 = v18;
              }
              while (!v15);
            }
            BOOL v21 = v18;
          }
          while (v20-- > 1);
        }
        if (*((unsigned __int8 *)v18 + 29) < v6)
        {
          BOOL v19 = (void *)v18[1];
          if (v19)
          {
            do
            {
              uint64_t v16 = v19;
              BOOL v19 = (void *)*v19;
            }
            while (v19);
          }
          else
          {
            do
            {
              uint64_t v16 = (void *)v18[2];
              BOOL v15 = *v16 == (void)v18;
              uint64_t v18 = v16;
            }
            while (!v15);
          }
          unint64_t v17 = v11 + ~v17;
        }
        unint64_t v11 = v17;
      }
      while (v17);
    }
    if (v16 == v10 || *((unsigned __int8 *)v16 + 28) >= v6)
    {
      if (v16 == v9) {
        goto LABEL_47;
      }
      uint64_t v29 = *v16;
      if (*v16)
      {
        do
        {
          uint64_t v30 = v29;
          uint64_t v29 = *(void *)(v29 + 8);
        }
        while (v29);
      }
      else
      {
        do
        {
          uint64_t v30 = v16[2];
          BOOL v15 = *(void *)v30 == (void)v16;
          uint64_t v16 = (void *)v30;
        }
        while (v15);
      }
      if (v5 >= *(unsigned __int8 *)(v30 + 29))
      {
LABEL_47:
        uint64_t v31 = *v10;
        uint64_t v25 = (uint64_t **)(result + 6);
        if (!*v10)
        {
LABEL_54:
          uint64_t v27 = (uint64_t *)operator new(0x28uLL);
          unint64_t v28 = v7 | v5;
LABEL_55:
          *(uint64_t *)((char *)v27 + 28) = v28 | (v8 << 32);
          uint64_t *v27 = 0;
          v27[1] = 0;
          void v27[2] = (uint64_t)v25;
          *unint64_t v10 = v27;
          uint64_t v33 = *(void *)v4[5];
          if (v33)
          {
            v4[5] = v33;
            float v34 = *v10;
          }
          else
          {
            float v34 = v27;
          }
          uint64_t result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v4[6], v34);
          ++v4[7];
          return result;
        }
        while (1)
        {
          while (1)
          {
            uint64_t v25 = (uint64_t **)v31;
            unsigned int v32 = *((unsigned __int8 *)v31 + 29);
            if (v6 >= v32) {
              break;
            }
            uint64_t v31 = *v25;
            unint64_t v10 = v25;
            if (!*v25) {
              goto LABEL_54;
            }
          }
          if (v32 >= v6) {
            break;
          }
          uint64_t v31 = v25[1];
          if (!v31)
          {
            unint64_t v10 = v25 + 1;
            goto LABEL_54;
          }
        }
      }
    }
  }
  else
  {
    unint64_t v10 = (uint64_t **)(result + 6);
    uint64_t v24 = result[6];
    if (!v24)
    {
      uint64_t v25 = (uint64_t **)(result + 6);
LABEL_37:
      uint64_t v27 = (uint64_t *)operator new(0x28uLL);
      unint64_t v28 = v7 | v5;
      goto LABEL_55;
    }
    while (1)
    {
      while (1)
      {
        uint64_t v25 = (uint64_t **)v24;
        unsigned int v26 = *(unsigned __int8 *)(v24 + 29);
        if (v6 >= v26) {
          break;
        }
        uint64_t v24 = (uint64_t)*v25;
        unint64_t v10 = v25;
        if (!*v25) {
          goto LABEL_37;
        }
      }
      if (v26 >= v6) {
        break;
      }
      uint64_t v24 = (uint64_t)v25[1];
      if (!v24)
      {
        unint64_t v10 = v25 + 1;
        goto LABEL_37;
      }
    }
  }
  return result;
}

void *gms::ZoomablePropertyStore<unsigned int>::getProperty@<X0>(void *result@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(unsigned char *)a2 = 0;
  unsigned int v4 = vcvtms_s32_f32(a3);
  if (v4 >= 0x17) {
    unsigned int v5 = 23;
  }
  else {
    unsigned int v5 = v4;
  }
  unsigned int v6 = (void *)result[5];
  unint64_t v7 = result + 6;
  uint64_t v8 = v6;
  if (v6 != result + 6)
  {
    unint64_t v9 = 0;
    unint64_t v10 = (void *)result[5];
    do
    {
      unint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          uint64_t v12 = v11;
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          uint64_t v12 = (void *)v10[2];
          BOOL v13 = *v12 == (void)v10;
          unint64_t v10 = v12;
        }
        while (!v13);
      }
      ++v9;
      unint64_t v10 = v12;
    }
    while (v12 != v7);
    uint64_t v8 = (void *)result[5];
    do
    {
      unint64_t v14 = v9 >> 1;
      BOOL v15 = v8;
      if (v9 != 1)
      {
        uint64_t v17 = v9 >> 1;
        uint64_t v18 = v8;
        do
        {
          uint64_t v20 = (void *)v18[1];
          if (v20)
          {
            do
            {
              BOOL v15 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              BOOL v15 = (void *)v18[2];
              BOOL v13 = *v15 == (void)v18;
              uint64_t v18 = v15;
            }
            while (!v13);
          }
          uint64_t v18 = v15;
          BOOL v19 = v17-- <= 1;
        }
        while (!v19);
      }
      if (v5 >= *((unsigned __int8 *)v15 + 29))
      {
        uint64_t v16 = (void *)v15[1];
        if (v16)
        {
          do
          {
            uint64_t v8 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            uint64_t v8 = (void *)v15[2];
            BOOL v13 = *v8 == (void)v15;
            BOOL v15 = v8;
          }
          while (!v13);
        }
        unint64_t v14 = v9 + ~v14;
      }
      unint64_t v9 = v14;
    }
    while (v14);
  }
  if (v8 == v7 || (v5 >= *((unsigned __int8 *)v8 + 28) ? (BOOL v21 = v5 >= *((unsigned __int8 *)v8 + 29)) : (BOOL v21 = 1), v21)) {
    uint64_t v8 = result + 6;
  }
  unsigned __int8 v22 = v5 + 1;
  uint64_t v23 = (void *)result[5];
  if (v6 != v7)
  {
    unint64_t v24 = 0;
    uint64_t v25 = (void *)result[5];
    do
    {
      unsigned int v26 = (void *)v25[1];
      if (v26)
      {
        do
        {
          uint64_t v27 = v26;
          unsigned int v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          uint64_t v27 = (void *)v25[2];
          BOOL v13 = *v27 == (void)v25;
          uint64_t v25 = v27;
        }
        while (!v13);
      }
      ++v24;
      uint64_t v25 = v27;
    }
    while (v27 != v7);
    uint64_t v23 = (void *)result[5];
    do
    {
      unint64_t v28 = v24 >> 1;
      uint64_t v29 = v23;
      if (v24 != 1)
      {
        uint64_t v31 = v24 >> 1;
        unsigned int v32 = v23;
        do
        {
          uint64_t v33 = (void *)v32[1];
          if (v33)
          {
            do
            {
              uint64_t v29 = v33;
              uint64_t v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              uint64_t v29 = (void *)v32[2];
              BOOL v13 = *v29 == (void)v32;
              unsigned int v32 = v29;
            }
            while (!v13);
          }
          unsigned int v32 = v29;
          BOOL v19 = v31-- <= 1;
        }
        while (!v19);
      }
      if (*((unsigned __int8 *)v29 + 29) <= v22)
      {
        uint64_t v30 = (void *)v29[1];
        if (v30)
        {
          do
          {
            uint64_t v23 = v30;
            uint64_t v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v23 = (void *)v29[2];
            BOOL v13 = *v23 == (void)v29;
            uint64_t v29 = v23;
          }
          while (!v13);
        }
        unint64_t v28 = v24 + ~v28;
      }
      unint64_t v24 = v28;
    }
    while (v28);
  }
  if (v23 == v7
    || *((unsigned __int8 *)v23 + 28) > v22
    || *((unsigned __int8 *)v23 + 29) <= v22)
  {
    uint64_t v23 = result + 6;
  }
  if (v8 != v7 && result[7])
  {
    if (v23 == v7 || (uint64_t result = (void *)result[4]) == 0 || (v34 = a3 - (float)v5, v34 > 1.0) || v34 < 0.0)
    {
      if (v6 != v7)
      {
        unint64_t v40 = 0;
        unint64_t v41 = v6;
        do
        {
          uint64_t v42 = (void *)v41[1];
          if (v42)
          {
            do
            {
              uint64_t v43 = v42;
              uint64_t v42 = (void *)*v42;
            }
            while (v42);
          }
          else
          {
            do
            {
              uint64_t v43 = (void *)v41[2];
              BOOL v13 = *v43 == (void)v41;
              unint64_t v41 = v43;
            }
            while (!v13);
          }
          ++v40;
          unint64_t v41 = v43;
        }
        while (v43 != v7);
        do
        {
          unint64_t v44 = v40 >> 1;
          BOOL v45 = v6;
          if (v40 != 1)
          {
            uint64_t v47 = v40 >> 1;
            uint64_t v48 = v6;
            do
            {
              uint64_t v49 = (void *)v48[1];
              if (v49)
              {
                do
                {
                  BOOL v45 = v49;
                  uint64_t v49 = (void *)*v49;
                }
                while (v49);
              }
              else
              {
                do
                {
                  BOOL v45 = (void *)v48[2];
                  BOOL v13 = *v45 == (void)v48;
                  uint64_t v48 = v45;
                }
                while (!v13);
              }
              uint64_t v48 = v45;
              BOOL v19 = v47-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v45 + 29))
          {
            uint64_t v46 = (void *)v45[1];
            if (v46)
            {
              do
              {
                unsigned int v6 = v46;
                uint64_t v46 = (void *)*v46;
              }
              while (v46);
            }
            else
            {
              do
              {
                unsigned int v6 = (void *)v45[2];
                BOOL v13 = *v6 == (void)v45;
                BOOL v45 = v6;
              }
              while (!v13);
            }
            unint64_t v44 = v40 + ~v44;
          }
          unint64_t v40 = v44;
        }
        while (v44);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 28) ? (BOOL v50 = v5 >= *((unsigned __int8 *)v6 + 29)) : (BOOL v50 = 1), v50))
      {
        unsigned int v6 = v7;
      }
      *(unsigned char *)a2 = 1;
      *(_DWORD *)(a2 + 4) = *((_DWORD *)v6 + 8);
    }
    else
    {
      unint64_t v35 = v6;
      if (v6 != v7)
      {
        unint64_t v36 = 0;
        unint64_t v37 = v6;
        do
        {
          uint64_t v38 = (void *)v37[1];
          if (v38)
          {
            do
            {
              unint64_t v39 = v38;
              uint64_t v38 = (void *)*v38;
            }
            while (v38);
          }
          else
          {
            do
            {
              unint64_t v39 = (void *)v37[2];
              BOOL v13 = *v39 == (void)v37;
              unint64_t v37 = v39;
            }
            while (!v13);
          }
          ++v36;
          unint64_t v37 = v39;
        }
        while (v39 != v7);
        unint64_t v35 = v6;
        do
        {
          unint64_t v51 = v36 >> 1;
          unint64_t v52 = v35;
          if (v36 != 1)
          {
            uint64_t v54 = v36 >> 1;
            uint64_t v55 = v35;
            do
            {
              __guard v56 = (void *)v55[1];
              if (v56)
              {
                do
                {
                  unint64_t v52 = v56;
                  __guard v56 = (void *)*v56;
                }
                while (v56);
              }
              else
              {
                do
                {
                  unint64_t v52 = (void *)v55[2];
                  BOOL v13 = *v52 == (void)v55;
                  uint64_t v55 = v52;
                }
                while (!v13);
              }
              uint64_t v55 = v52;
              BOOL v19 = v54-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v52 + 29))
          {
            __guard v53 = (void *)v52[1];
            if (v53)
            {
              do
              {
                unint64_t v35 = v53;
                __guard v53 = (void *)*v53;
              }
              while (v53);
            }
            else
            {
              do
              {
                unint64_t v35 = (void *)v52[2];
                BOOL v13 = *v35 == (void)v52;
                unint64_t v52 = v35;
              }
              while (!v13);
            }
            unint64_t v51 = v36 + ~v51;
          }
          unint64_t v36 = v51;
        }
        while (v51);
      }
      if (v35 == v7
        || (v5 >= *((unsigned __int8 *)v35 + 28) ? (BOOL v57 = v5 >= *((unsigned __int8 *)v35 + 29)) : (BOOL v57 = 1), v57))
      {
        unint64_t v35 = v7;
      }
      int v69 = *((_DWORD *)v35 + 8);
      if (v6 != v7)
      {
        unint64_t v58 = 0;
        unint64_t v59 = v6;
        do
        {
          double v60 = (void *)v59[1];
          if (v60)
          {
            do
            {
              unint64_t v61 = v60;
              double v60 = (void *)*v60;
            }
            while (v60);
          }
          else
          {
            do
            {
              unint64_t v61 = (void *)v59[2];
              BOOL v13 = *v61 == (void)v59;
              unint64_t v59 = v61;
            }
            while (!v13);
          }
          ++v58;
          unint64_t v59 = v61;
        }
        while (v61 != v7);
        do
        {
          unint64_t v62 = v58 >> 1;
          unint64_t v63 = v6;
          if (v58 != 1)
          {
            uint64_t v65 = v58 >> 1;
            uint64_t v66 = v6;
            do
            {
              BOOL v67 = (void *)v66[1];
              if (v67)
              {
                do
                {
                  unint64_t v63 = v67;
                  BOOL v67 = (void *)*v67;
                }
                while (v67);
              }
              else
              {
                do
                {
                  unint64_t v63 = (void *)v66[2];
                  BOOL v13 = *v63 == (void)v66;
                  uint64_t v66 = v63;
                }
                while (!v13);
              }
              uint64_t v66 = v63;
              BOOL v19 = v65-- <= 1;
            }
            while (!v19);
          }
          if (*((unsigned __int8 *)v63 + 29) <= v22)
          {
            uint64_t v64 = (void *)v63[1];
            if (v64)
            {
              do
              {
                unsigned int v6 = v64;
                uint64_t v64 = (void *)*v64;
              }
              while (v64);
            }
            else
            {
              do
              {
                unsigned int v6 = (void *)v63[2];
                BOOL v13 = *v6 == (void)v63;
                unint64_t v63 = v6;
              }
              while (!v13);
            }
            unint64_t v62 = v58 + ~v62;
          }
          unint64_t v58 = v62;
        }
        while (v62);
      }
      if (v6 == v7
        || *((unsigned __int8 *)v6 + 28) > v22
        || *((unsigned __int8 *)v6 + 29) <= v22)
      {
        unsigned int v6 = v7;
      }
      int v68 = *((_DWORD *)v6 + 8);
      float v70 = v34;
      uint64_t result = (void *)(*(uint64_t (**)(void *, float *, int *, int *))(*result + 48))(result, &v70, &v69, &v68);
      *(unsigned char *)a2 = 1;
      *(_DWORD *)(a2 + 4) = result;
    }
  }
  return result;
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyAlbedoFactor(uint64_t a1)
{
  return *(void *)(a1 + 144) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::albedoFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 144);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  *a2 = 0;
  return result;
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyEmissiveFactor(uint64_t a1)
{
  return *(void *)(a1 + 136) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::emissiveFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 136);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addEmissiveFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 136);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 7u, 263);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyMetallicFactor(uint64_t a1)
{
  return *(void *)(a1 + 128) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::metallicFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 128);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 144))();
  }
  *a2 = 0;
  return result;
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyRoughnessFactor(uint64_t a1)
{
  return *(void *)(a1 + 120) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::roughnessFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 120);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 120))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addRoughnessFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 120);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 5u, 261);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyEmissive(uint64_t a1)
{
  return *(void *)(a1 + 112) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::emissive@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 112);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addEmissive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 112);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 4u, 260);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyRoughnessMetallic(uint64_t a1)
{
  return *(void *)(a1 + 104) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::roughnessMetallic@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 104);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addRoughnessMetallic(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 104);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 3u, 259);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyNormal(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::normal@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 96);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addNormal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 2u, 258);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRWithColorRampMaterial<ggl::Texture2D>::hasAnyAlbedo(uint64_t a1)
{
  return *(void *)(a1 + 88) != 0;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::albedo@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 88);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRWithColorRampMaterial<ggl::Texture2D>::addAlbedo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 88);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 1u, 257);
      operator new();
    }
    operator new();
  }
  unint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::_PBRWithColorRampMaterial<ggl::Texture2D>::~_PBRWithColorRampMaterial(void *a1)
{
  gms::_PBRWithColorRampMaterial<ggl::Texture2D>::~_PBRWithColorRampMaterial(a1);
  JUMPOUT(0x1A6239270);
}

void *gms::_PBRWithColorRampMaterial<ggl::Texture2D>::~_PBRWithColorRampMaterial(void *a1)
{
  *a1 = &unk_1EF5663F0;
  uint64_t v2 = a1[28];
  a1[28] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = a1[27];
  a1[27] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  uint64_t v4 = a1[26];
  a1[26] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = a1[25];
  a1[25] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  uint64_t v6 = a1[24];
  a1[24] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
  }
  uint64_t v7 = a1[23];
  a1[23] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  uint64_t v8 = a1[22];
  a1[22] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  uint64_t v9 = a1[21];
  a1[21] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
  }
  uint64_t v10 = a1[20];
  a1[20] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
  }
  uint64_t v11 = a1[19];
  a1[19] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
  }
  uint64_t v12 = a1[18];
  a1[18] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 32))(v12);
  }
  uint64_t v13 = a1[17];
  a1[17] = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 32))(v13);
  }
  uint64_t v14 = a1[16];
  a1[16] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 32))(v14);
  }
  uint64_t v15 = a1[15];
  a1[15] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 32))(v15);
  }
  uint64_t v16 = a1[14];
  a1[14] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 32))(v16);
  }
  uint64_t v17 = a1[13];
  a1[13] = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 32))(v17);
  }
  uint64_t v18 = a1[12];
  a1[12] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 32))(v18);
  }
  uint64_t v19 = a1[11];
  a1[11] = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 32))(v19);
  }
  return gms::_Material<ggl::Texture2D>::~_Material(a1);
}

uint64_t std::__shared_ptr_emplace<gms::_PBRWithColorRampMaterial<ggl::Texture2D>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gms::_PBRWithColorRampMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A2A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gms::_PBRWithColorRampMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A2A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyGradientMaskFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 168) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::gradientMaskFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 168);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 696))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addGradientMaskFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 168);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Du, 285);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyAlbedoFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 160) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::albedoFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 160);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 648))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addAlbedoFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 160);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Bu, 283);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyHideOnCollapse(uint64_t a1)
{
  return *(void *)(a1 + 152) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::hideOnCollapse@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 152);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 576))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addHideOnCollapse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 152);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x18u, 280);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyGradientMaskFactor(uint64_t a1)
{
  return *(void *)(a1 + 144) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::gradientMaskFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 144);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 552))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addGradientMaskFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 144);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x17u, 279);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyCastShadow(uint64_t a1)
{
  return *(void *)(a1 + 136) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::castShadow@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 136);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 384))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addCastShadow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 136);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x10u, 272);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyOffset(uint64_t a1)
{
  return *(void *)(a1 + 128) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::offset@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 128);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 128);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xDu, 269);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyTiling(uint64_t a1)
{
  return *(void *)(a1 + 120) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::tiling@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 120);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addTiling(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 120);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xCu, 268);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyVisibility(uint64_t a1)
{
  return *(void *)(a1 + 112) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::visibility@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 112);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 264))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addVisibility(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 112);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xBu, 267);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyZIndex(uint64_t a1)
{
  return *(void *)(a1 + 104) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::zIndex@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 104);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 216))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addZIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 104);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 9u, 265);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyAlbedoFactor(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::albedoFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 96);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addAlbedoFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 8u, 264);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_TriPlanarMaterial<ggl::Texture2D>::hasAnyAlbedo(uint64_t a1)
{
  return *(void *)(a1 + 88) != 0;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::albedo@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 88);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_TriPlanarMaterial<ggl::Texture2D>::addAlbedo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 88);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 1u, 257);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::_TriPlanarMaterial<ggl::Texture2D>::~_TriPlanarMaterial(void *a1)
{
  gms::_TriPlanarMaterial<ggl::Texture2D>::~_TriPlanarMaterial(a1);
  JUMPOUT(0x1A6239270);
}

void *gms::_TriPlanarMaterial<ggl::Texture2D>::~_TriPlanarMaterial(void *a1)
{
  *a1 = &unk_1EF565738;
  uint64_t v2 = a1[21];
  a1[21] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = a1[20];
  a1[20] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  uint64_t v4 = a1[19];
  a1[19] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = a1[18];
  a1[18] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  uint64_t v6 = a1[17];
  a1[17] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
  }
  uint64_t v7 = a1[16];
  a1[16] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  uint64_t v8 = a1[15];
  a1[15] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  uint64_t v9 = a1[14];
  a1[14] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
  }
  uint64_t v10 = a1[13];
  a1[13] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
  }
  uint64_t v11 = a1[12];
  a1[12] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
  }
  uint64_t v12 = a1[11];
  a1[11] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 32))(v12);
  }
  return gms::_Material<ggl::Texture2D>::~_Material(a1);
}

uint64_t std::__shared_ptr_emplace<gms::_TriPlanarMaterial<ggl::Texture2D>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gms::_TriPlanarMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A238;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gms::_TriPlanarMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A238;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyGradientMaskFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 176) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::gradientMaskFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 176);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 696))();
  }
  *a2 = 0;
  return result;
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyAlbedoFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 168) != 0;
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyAlpha(uint64_t a1)
{
  return *(void *)(a1 + 160) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::addAlpha(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 160);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Au, 282);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyHideOnCollapse(uint64_t a1)
{
  return *(void *)(a1 + 152) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::hideOnCollapse@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 152);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 576))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::addHideOnCollapse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 152);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x18u, 280);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyGradientMaskFactor(uint64_t a1)
{
  return *(void *)(a1 + 144) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::gradientMaskFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 144);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 552))();
  }
  *a2 = 0;
  return result;
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyCastShadow(uint64_t a1)
{
  return *(void *)(a1 + 136) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::castShadow@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 136);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 384))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::addCastShadow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 136);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x10u, 272);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyOffset(uint64_t a1)
{
  return *(void *)(a1 + 128) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::offset@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 128);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 312))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::addOffset(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 128);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xDu, 269);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyTiling(uint64_t a1)
{
  return *(void *)(a1 + 120) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::tiling@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 120);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 288))();
  }
  *a2 = 0;
  return result;
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyVisibility(uint64_t a1)
{
  return *(void *)(a1 + 112) != 0;
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyZIndex(uint64_t a1)
{
  return *(void *)(a1 + 104) != 0;
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyAlbedoFactor(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::albedoFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 96);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  *a2 = 0;
  return result;
}

BOOL gms::_PlanarMaterial<ggl::Texture2D>::hasAnyAlbedo(uint64_t a1)
{
  return *(void *)(a1 + 88) != 0;
}

uint64_t gms::_PlanarMaterial<ggl::Texture2D>::albedo@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 88);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  *a2 = 0;
  return result;
}

void gms::_PlanarMaterial<ggl::Texture2D>::~_PlanarMaterial(void *a1)
{
  gms::_PlanarMaterial<ggl::Texture2D>::~_PlanarMaterial(a1);
  JUMPOUT(0x1A6239270);
}

void *gms::_PlanarMaterial<ggl::Texture2D>::~_PlanarMaterial(void *a1)
{
  *a1 = &unk_1EF564688;
  uint64_t v2 = a1[22];
  a1[22] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = a1[21];
  a1[21] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  uint64_t v4 = a1[20];
  a1[20] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = a1[19];
  a1[19] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  uint64_t v6 = a1[18];
  a1[18] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
  }
  uint64_t v7 = a1[17];
  a1[17] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  uint64_t v8 = a1[16];
  a1[16] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  uint64_t v9 = a1[15];
  a1[15] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
  }
  uint64_t v10 = a1[14];
  a1[14] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
  }
  uint64_t v11 = a1[13];
  a1[13] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
  }
  uint64_t v12 = a1[12];
  a1[12] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 32))(v12);
  }
  uint64_t v13 = a1[11];
  a1[11] = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 32))(v13);
  }
  return gms::_Material<ggl::Texture2D>::~_Material(a1);
}

uint64_t std::__shared_ptr_emplace<gms::_PlanarMaterial<ggl::Texture2D>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gms::_PlanarMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A158;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gms::_PlanarMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A158;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyColorRampRGB(uint64_t a1)
{
  return *(void *)(a1 + 256) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::colorRampRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 256);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 720))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addColorRampRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 256);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Eu, 286);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyGradientMaskFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 248) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::gradientMaskFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 248);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 696))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addGradientMaskFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 248);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Du, 285);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyEmissiveFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 240) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::emissiveFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 240);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 672))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addEmissiveFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 240);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Cu, 284);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyAlbedoFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 232) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::albedoFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 232);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 648))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addAlbedoFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 232);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Bu, 283);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyAlpha(uint64_t a1)
{
  return *(void *)(a1 + 224) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::alpha@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 224);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 624))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addAlpha(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 224);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Au, 282);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyHideOnCollapse(uint64_t a1)
{
  return *(void *)(a1 + 216) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::hideOnCollapse@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 216);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 576))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addHideOnCollapse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 216);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x18u, 280);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyGradientMaskFactor(uint64_t a1)
{
  return *(void *)(a1 + 208) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::gradientMaskFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 208);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 552))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addGradientMaskFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 208);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x17u, 279);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyAcceptsOverlays(uint64_t a1)
{
  return *(void *)(a1 + 200) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::acceptsOverlays@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 200);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 480))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addAcceptsOverlays(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 200);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x14u, 276);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyBrightnessFactor(uint64_t a1)
{
  return *(void *)(a1 + 192) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::brightnessFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 192);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 456))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addBrightnessFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 192);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x13u, 275);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnySaturationFactor(uint64_t a1)
{
  return *(void *)(a1 + 184) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::saturationFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 184);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 432))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addSaturationFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 184);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x12u, 274);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyColorRamp(uint64_t a1)
{
  return *(void *)(a1 + 176) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::colorRamp@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 176);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 408))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addColorRamp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 176);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x11u, 273);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyCastShadow(uint64_t a1)
{
  return *(void *)(a1 + 168) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::castShadow@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 168);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 384))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addCastShadow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 168);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x10u, 272);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyVisibility(uint64_t a1)
{
  return *(void *)(a1 + 160) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::visibility@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 160);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 264))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addVisibility(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 160);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xBu, 267);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyZIndex(uint64_t a1)
{
  return *(void *)(a1 + 152) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::zIndex@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 152);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 216))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addZIndex(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 152);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 9u, 265);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyAlbedoFactor(uint64_t a1)
{
  return *(void *)(a1 + 144) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::albedoFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 144);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addAlbedoFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 144);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 8u, 264);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyEmissiveFactor(uint64_t a1)
{
  return *(void *)(a1 + 136) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::emissiveFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 136);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addEmissiveFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 136);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 7u, 263);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyMetallicFactor(uint64_t a1)
{
  return *(void *)(a1 + 128) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::metallicFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 128);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 144))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addMetallicFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 128);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 6u, 262);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyRoughnessFactor(uint64_t a1)
{
  return *(void *)(a1 + 120) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::roughnessFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 120);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 120))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addRoughnessFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 120);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 5u, 261);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyEmissive(uint64_t a1)
{
  return *(void *)(a1 + 112) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::emissive@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 112);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 96))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addEmissive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 112);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 4u, 260);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyRoughnessMetallic(uint64_t a1)
{
  return *(void *)(a1 + 104) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::roughnessMetallic@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 104);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 72))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addRoughnessMetallic(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 104);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 3u, 259);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyNormal(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::normal@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 96);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 48))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addNormal(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 2u, 258);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_PBRMaterial<ggl::Texture2D>::hasAnyAlbedo(uint64_t a1)
{
  return *(void *)(a1 + 88) != 0;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::albedo@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 88);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 24))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_PBRMaterial<ggl::Texture2D>::addAlbedo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 88);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 1u, 257);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::_PBRMaterial<ggl::Texture2D>::~_PBRMaterial(void *a1)
{
  gms::_PBRMaterial<ggl::Texture2D>::~_PBRMaterial(a1);
  JUMPOUT(0x1A6239270);
}

void *gms::_PBRMaterial<ggl::Texture2D>::~_PBRMaterial(void *a1)
{
  *a1 = &unk_1EF5635A0;
  uint64_t v2 = a1[32];
  a1[32] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = a1[31];
  a1[31] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  uint64_t v4 = a1[30];
  a1[30] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = a1[29];
  a1[29] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  uint64_t v6 = a1[28];
  a1[28] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
  }
  uint64_t v7 = a1[27];
  a1[27] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  uint64_t v8 = a1[26];
  a1[26] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  uint64_t v9 = a1[25];
  a1[25] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
  }
  uint64_t v10 = a1[24];
  a1[24] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
  }
  uint64_t v11 = a1[23];
  a1[23] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
  }
  uint64_t v12 = a1[22];
  a1[22] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 32))(v12);
  }
  uint64_t v13 = a1[21];
  a1[21] = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 32))(v13);
  }
  uint64_t v14 = a1[20];
  a1[20] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 32))(v14);
  }
  uint64_t v15 = a1[19];
  a1[19] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 32))(v15);
  }
  uint64_t v16 = a1[18];
  a1[18] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 32))(v16);
  }
  uint64_t v17 = a1[17];
  a1[17] = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 32))(v17);
  }
  uint64_t v18 = a1[16];
  a1[16] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 32))(v18);
  }
  uint64_t v19 = a1[15];
  a1[15] = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 32))(v19);
  }
  uint64_t v20 = a1[14];
  a1[14] = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 32))(v20);
  }
  uint64_t v21 = a1[13];
  a1[13] = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 32))(v21);
  }
  uint64_t v22 = a1[12];
  a1[12] = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 32))(v22);
  }
  uint64_t v23 = a1[11];
  a1[11] = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 32))(v23);
  }
  return gms::_Material<ggl::Texture2D>::~_Material(a1);
}

uint64_t std::__shared_ptr_emplace<gms::_PBRMaterial<ggl::Texture2D>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gms::_PBRMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A078;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gms::_PBRMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A078;
  std::__shared_weak_count::~__shared_weak_count(this);
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnySsaoIntensity(uint64_t a1)
{
  return *(void *)(a1 + 288) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addSsaoIntensity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 288);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x23u, 291);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyDryAdjustment(uint64_t a1)
{
  return *(void *)(a1 + 280) != 0;
}

uint64_t gms::NonZoomablePropertyStore<gm::Matrix<float,3,1>>::~NonZoomablePropertyStore(uint64_t result)
{
  *(void *)uint64_t result = &unk_1EF565D08;
  if (*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 0;
  }
  return result;
}

uint64_t gms::NonZoomablePropertyStore<gm::Matrix<float,3,1>>::addProperty(uint64_t result, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v4 = *a4;
  int v5 = *((_DWORD *)a4 + 2);
  if (!*(unsigned char *)(result + 8)) {
    *(unsigned char *)(result + 8) = 1;
  }
  *(_DWORD *)(result + 20) = v5;
  *(void *)(result + 12) = v4;
  return result;
}

uint64_t gms::NonZoomablePropertyStore<gm::Matrix<float,3,1>>::getProperty@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(result + 8))
  {
    *(void *)(a2 + 4) = *(void *)(result + 12);
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(result + 20);
    *(unsigned char *)a2 = 1;
  }
  return result;
}

void gms::ZoomablePropertyStore<gm::Matrix<float,3,1>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565AD8;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t gms::ZoomablePropertyStore<gm::Matrix<float,3,1>>::~ZoomablePropertyStore(uint64_t a1)
{
  *(void *)a1 = &unk_1EF565AD8;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2 == a1 + 8)
  {
    (*(void (**)(uint64_t))(*(void *)(a1 + 8) + 32))(a1 + 8);
  }
  else if (v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 40))(v2);
  }
  return a1;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyWetAdjustment(uint64_t a1)
{
  return *(void *)(a1 + 272) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyColdAdjustment(uint64_t a1)
{
  return *(void *)(a1 + 264) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyHotAdjustment(uint64_t a1)
{
  return *(void *)(a1 + 256) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyGradientMaskFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 248) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyEmissiveFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 240) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addEmissiveFactorRGB(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 240);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x1Cu, 284);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyAlbedoFactorRGB(uint64_t a1)
{
  return *(void *)(a1 + 232) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyAlpha(uint64_t a1)
{
  return *(void *)(a1 + 224) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyHideOnCollapse(uint64_t a1)
{
  return *(void *)(a1 + 216) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addHideOnCollapse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 216);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x18u, 280);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyGradientMaskFactor(uint64_t a1)
{
  return *(void *)(a1 + 208) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyBrightnessRemapRange(uint64_t a1)
{
  return *(void *)(a1 + 200) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addBrightnessRemapRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 200);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x16u, 278);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnySaturationRemapRange(uint64_t a1)
{
  return *(void *)(a1 + 192) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addSaturationRemapRange(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 192);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x15u, 277);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyAcceptsOverlays(uint64_t a1)
{
  return *(void *)(a1 + 184) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::acceptsOverlays@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 184);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 480))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addAcceptsOverlays(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 184);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x14u, 276);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyBrightnessFactor(uint64_t a1)
{
  return *(void *)(a1 + 176) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::brightnessFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 176);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 456))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addBrightnessFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 176);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x13u, 275);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnySaturationFactor(uint64_t a1)
{
  return *(void *)(a1 + 168) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::saturationFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 168);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 432))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addSaturationFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 168);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x12u, 274);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyCastShadow(uint64_t a1)
{
  return *(void *)(a1 + 160) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addCastShadow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 160);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0x10u, 272);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyShininess(uint64_t a1)
{
  return *(void *)(a1 + 152) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addShininess(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 152);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xFu, 271);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnySpecularity(uint64_t a1)
{
  return *(void *)(a1 + 144) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addSpecularity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 144);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xEu, 270);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyVisibility(uint64_t a1)
{
  return *(void *)(a1 + 136) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyLineWidth(uint64_t a1)
{
  return *(void *)(a1 + 128) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::lineWidth@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 128);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 240))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addLineWidth(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 128);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 0xAu, 266);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyZIndex(uint64_t a1)
{
  return *(void *)(a1 + 120) != 0;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyAlbedoFactor(uint64_t a1)
{
  return *(void *)(a1 + 112) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::albedoFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v3 = *(uint64_t (****)(void))(a1 + 112);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 192))();
  }
  *a2 = 0;
  return result;
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyEmissiveFactor(uint64_t a1)
{
  return *(void *)(a1 + 104) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addEmissiveFactor(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 104);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 7u, 263);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyEmissive(uint64_t a1)
{
  return *(void *)(a1 + 96) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addEmissive(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 96);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 4u, 260);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

BOOL gms::_BasicMaterial<ggl::Texture2D>::hasAnyAlbedo(uint64_t a1)
{
  return *(void *)(a1 + 88) != 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::addAlbedo(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v6 = *(void *)(a1 + 88);
  if (!v6)
  {
    if (a5)
    {
      std::__hash_table<std::__hash_value_type<gms::PropertyKey,BOOL>,std::__unordered_map_hasher<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::hash<gms::PropertyKey>,std::equal_to<gms::PropertyKey>,true>,std::__unordered_map_equal<gms::PropertyKey,std::__hash_value_type<gms::PropertyKey,BOOL>,std::equal_to<gms::PropertyKey>,std::hash<gms::PropertyKey>,true>,std::allocator<std::__hash_value_type<gms::PropertyKey,BOOL>>>::__emplace_unique_key_args<gms::PropertyKey,std::pair<gms::PropertyKey const,BOOL>>((float *)(a1 + 8), 1u, 257);
      operator new();
    }
    operator new();
  }
  uint64_t v7 = *(uint64_t (**)(void))(*(void *)v6 + 8);
  return v7();
}

void gms::_BasicMaterial<ggl::Texture2D>::~_BasicMaterial(void *a1)
{
  gms::_BasicMaterial<ggl::Texture2D>::~_BasicMaterial(a1);
  JUMPOUT(0x1A6239270);
}

void *gms::_BasicMaterial<ggl::Texture2D>::~_BasicMaterial(void *a1)
{
  *a1 = &unk_1EF564320;
  uint64_t v2 = a1[36];
  a1[36] = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  uint64_t v3 = a1[35];
  a1[35] = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  uint64_t v4 = a1[34];
  a1[34] = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  uint64_t v5 = a1[33];
  a1[33] = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 32))(v5);
  }
  uint64_t v6 = a1[32];
  a1[32] = 0;
  if (v6) {
    (*(void (**)(uint64_t))(*(void *)v6 + 32))(v6);
  }
  uint64_t v7 = a1[31];
  a1[31] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 32))(v7);
  }
  uint64_t v8 = a1[30];
  a1[30] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 32))(v8);
  }
  uint64_t v9 = a1[29];
  a1[29] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 32))(v9);
  }
  uint64_t v10 = a1[28];
  a1[28] = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 32))(v10);
  }
  uint64_t v11 = a1[27];
  a1[27] = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 32))(v11);
  }
  uint64_t v12 = a1[26];
  a1[26] = 0;
  if (v12) {
    (*(void (**)(uint64_t))(*(void *)v12 + 32))(v12);
  }
  uint64_t v13 = a1[25];
  a1[25] = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 32))(v13);
  }
  uint64_t v14 = a1[24];
  a1[24] = 0;
  if (v14) {
    (*(void (**)(uint64_t))(*(void *)v14 + 32))(v14);
  }
  uint64_t v15 = a1[23];
  a1[23] = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 32))(v15);
  }
  uint64_t v16 = a1[22];
  a1[22] = 0;
  if (v16) {
    (*(void (**)(uint64_t))(*(void *)v16 + 32))(v16);
  }
  uint64_t v17 = a1[21];
  a1[21] = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 32))(v17);
  }
  uint64_t v18 = a1[20];
  a1[20] = 0;
  if (v18) {
    (*(void (**)(uint64_t))(*(void *)v18 + 32))(v18);
  }
  uint64_t v19 = a1[19];
  a1[19] = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 32))(v19);
  }
  uint64_t v20 = a1[18];
  a1[18] = 0;
  if (v20) {
    (*(void (**)(uint64_t))(*(void *)v20 + 32))(v20);
  }
  uint64_t v21 = a1[17];
  a1[17] = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 32))(v21);
  }
  uint64_t v22 = a1[16];
  a1[16] = 0;
  if (v22) {
    (*(void (**)(uint64_t))(*(void *)v22 + 32))(v22);
  }
  uint64_t v23 = a1[15];
  a1[15] = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 32))(v23);
  }
  uint64_t v24 = a1[14];
  a1[14] = 0;
  if (v24) {
    (*(void (**)(uint64_t))(*(void *)v24 + 32))(v24);
  }
  uint64_t v25 = a1[13];
  a1[13] = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 32))(v25);
  }
  uint64_t v26 = a1[12];
  a1[12] = 0;
  if (v26) {
    (*(void (**)(uint64_t))(*(void *)v26 + 32))(v26);
  }
  uint64_t v27 = a1[11];
  a1[11] = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 32))(v27);
  }
  return gms::_Material<ggl::Texture2D>::~_Material(a1);
}

uint64_t std::__shared_ptr_emplace<gms::_BasicMaterial<ggl::Texture2D>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<gms::_BasicMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A120;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<gms::_BasicMaterial<ggl::Texture2D>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A120;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::Logic<md::LabelsExtractExternallyResolvedWorldTransformLogic,md::LabelsExtractExternallyResolvedWorldTransformContext,md::LogicDependencies<gdc::TypeList<md::ARApplyWorldTransformUpdatesContext>,gdc::TypeList<>>>::debugConsoleString(uint64_t a1@<X0>, gdc::DebugTreeNode *a2@<X8>)
{
  uint64_t v13 = 0;
  (*(void (**)(void **__return_ptr))(*(void *)a1 + 56))(&v6);
  gdc::DebugTreeNode::toString(a2);
  uint64_t v3 = __p;
  if (__p)
  {
    uint64_t v4 = (uint64_t)v12;
    uint64_t v5 = __p;
    if (v12 != __p)
    {
      do
      {
        v4 -= 80;
        std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v4);
      }
      while ((void *)v4 != v3);
      uint64_t v5 = __p;
    }
    uint64_t v12 = v3;
    operator delete(v5);
  }
  std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v10);
  if ((v9 & 0x80000000) == 0)
  {
    if ((v7 & 0x80000000) == 0) {
      return;
    }
LABEL_10:
    operator delete(v6);
    return;
  }
  operator delete(v8);
  if (v7 < 0) {
    goto LABEL_10;
  }
}

void *md::LabelsExtractExternallyResolvedWorldTransformLogic::runBeforeLayout(uint64_t a1)
{
  uint64_t v1 = *(int8x8_t **)(a1 + 120);
  uint64_t v2 = (void *)gdc::Registry::storage<arComponents::IsVisible>(v1);
  uint64_t v3 = (void *)gdc::Registry::storage<arComponents::NeedsResolvedWorldTransform>(v1);
  uint64_t v4 = (void *)gdc::Registry::storage<arComponents::WorldTransform>(v1);
  uint64_t result = (void *)gdc::Registry::storage<arComponents::Wrap<std::shared_ptr<md::LabelExternalMesh>>>(v1);
  char v7 = (unint64_t *)v3[7];
  uint64_t v6 = (uint64_t *)v3[8];
  char v9 = (unint64_t *)v2[7];
  uint64_t v8 = (uint64_t *)v2[8];
  if ((char *)v6 - (char *)v7 >= (unint64_t)((char *)v8 - (char *)v9)) {
    uint64_t v10 = v2 + 4;
  }
  else {
    uint64_t v10 = v3 + 4;
  }
  uint64_t v12 = (unint64_t *)v4[7];
  uint64_t v11 = (uint64_t *)v4[8];
  if ((unint64_t)((char *)v11 - (char *)v12) >= v10[4] - v10[3]) {
    uint64_t v13 = v10;
  }
  else {
    uint64_t v13 = v4 + 4;
  }
  uint64_t v15 = (unint64_t *)result[7];
  uint64_t v14 = (uint64_t *)result[8];
  if ((unint64_t)((char *)v14 - (char *)v15) < v13[4] - v13[3]) {
    uint64_t v13 = result + 4;
  }
  if (v2 + 4 == v13 && v9 != (unint64_t *)v8)
  {
    uint64_t v30 = v3[4];
    unint64_t v31 = (v3[5] - v30) >> 3;
    uint64_t v32 = v4[4];
    unint64_t v33 = (v4[5] - v32) >> 3;
    unint64_t v34 = ((char *)v11 - (char *)v12) >> 3;
    uint64_t v35 = result[4];
    unint64_t v36 = (result[5] - v35) >> 3;
    unint64_t v183 = ((char *)v14 - (char *)v15) >> 3;
    uint64_t v175 = v4[10];
    float v180 = (void *)v4[11];
    uint64_t v173 = result[10];
    uint64_t v177 = (void *)result[11];
    do
    {
      unint64_t v89 = *((unsigned int *)v9 + 1);
      unint64_t v90 = v89 >> 7;
      if (v89 >> 7 < v31)
      {
        uint64_t v91 = *(void *)(v30 + 8 * v90);
        if (v91)
        {
          uint64_t v92 = v89 & 0x7F;
          unint64_t v93 = *(unsigned __int16 *)(v91 + 2 * v92);
          if (((char *)v6 - (char *)v7) >> 3 > v93)
          {
            long long v94 = (uint64_t *)&v7[v93];
            BOOL v95 = v94 != v6 && *((_DWORD *)v94 + 1) == v89;
            if (v95 && v90 < v33)
            {
              uint64_t v97 = *(void *)(v32 + 8 * v90);
              if (v97)
              {
                unint64_t v98 = *(unsigned __int16 *)(v97 + 2 * v92);
                if (v34 > v98)
                {
                  uint64_t v99 = (uint64_t *)&v12[v98];
                  BOOL v100 = v99 != v11 && *((_DWORD *)v99 + 1) == v89;
                  if (v100 && v90 < v36)
                  {
                    uint64_t v102 = *(void *)(v35 + 8 * v90);
                    if (v102)
                    {
                      unint64_t v103 = *(unsigned __int16 *)(v102 + 2 * v92);
                      if (v183 > v103)
                      {
                        uint64_t v104 = (uint64_t *)&v15[v103];
                        if (v104 != v14 && *((_DWORD *)v104 + 1) == v89)
                        {
                          unint64_t v171 = HIDWORD(*v9);
                          unint64_t v172 = *v9;
                          unint64_t v106 = *v9 >> 39;
                          uint64_t v107 = v180;
                          if (v106 < v33)
                          {
                            uint64_t v108 = *(void *)(v32 + 8 * v106);
                            uint64_t v107 = v180;
                            if (v108)
                            {
                              unint64_t v109 = *(unsigned __int16 *)(v108 + 2 * (HIDWORD(v172) & 0x7F));
                              uint64_t v107 = v180;
                              if (v34 > v109)
                              {
                                if (HIDWORD(v12[v109]) != v171 || &v12[v109] == (unint64_t *)v11) {
                                  uint64_t v107 = v180;
                                }
                                else {
                                  uint64_t v107 = (void *)(v175 + 80 * v109);
                                }
                              }
                            }
                          }
                          long long v111 = v177;
                          if (v106 < v36)
                          {
                            uint64_t v112 = *(void *)(v35 + 8 * v106);
                            long long v111 = v177;
                            if (v112)
                            {
                              unint64_t v113 = *(unsigned __int16 *)(v112 + 2 * (HIDWORD(v172) & 0x7F));
                              long long v111 = v177;
                              if (v183 > v113)
                              {
                                if (HIDWORD(v15[v113]) != v171 || &v15[v113] == (unint64_t *)v14) {
                                  long long v111 = v177;
                                }
                                else {
                                  long long v111 = (void *)(v173 + 16 * v113);
                                }
                              }
                            }
                          }
                          char v88 = (void *)*v111;
                          v88[7] = v107[3];
                          unsigned char v88[8] = v107[4];
                          v88[9] = v107[5];
                          v88[10] = v107[6];
                          v88[4] = *v107;
                          v88[5] = v107[1];
                          v88[6] = v107[2];
                          v88[11] = v107[7];
                          v88[12] = v107[8];
                          v88[13] = v107[9];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      ++v9;
    }
    while (v9 != (unint64_t *)v8);
  }
  if (v3 + 4 == v13 && v7 != (unint64_t *)v6)
  {
    uint64_t v37 = v2[4];
    unint64_t v38 = (v2[5] - v37) >> 3;
    uint64_t v40 = v2[7];
    uint64_t v39 = v2[8];
    uint64_t v41 = v4[4];
    unint64_t v42 = (v4[5] - v41) >> 3;
    uint64_t v12 = (unint64_t *)v4[7];
    uint64_t v11 = (uint64_t *)v4[8];
    unint64_t v43 = ((char *)v11 - (char *)v12) >> 3;
    uint64_t v44 = result[4];
    unint64_t v45 = (result[5] - v44) >> 3;
    uint64_t v15 = (unint64_t *)result[7];
    uint64_t v14 = (uint64_t *)result[8];
    uint64_t v178 = v4[10];
    unint64_t v181 = (void *)v4[11];
    unint64_t v184 = ((char *)v14 - (char *)v15) >> 3;
    uint64_t v46 = (void *)result[11];
    uint64_t v176 = result[10];
    do
    {
      unint64_t v116 = *((unsigned int *)v7 + 1);
      unint64_t v117 = v116 >> 7;
      if (v116 >> 7 < v38)
      {
        uint64_t v118 = *(void *)(v37 + 8 * v117);
        if (v118)
        {
          uint64_t v119 = v116 & 0x7F;
          unint64_t v120 = *(unsigned __int16 *)(v118 + 2 * v119);
          if ((v39 - v40) >> 3 > v120)
          {
            uint64_t v121 = v40 + 8 * v120;
            BOOL v122 = v121 != v39 && *(_DWORD *)(v121 + 4) == v116;
            if (v122 && v117 < v42)
            {
              uint64_t v124 = *(void *)(v41 + 8 * v117);
              if (v124)
              {
                unint64_t v125 = *(unsigned __int16 *)(v124 + 2 * v119);
                if (v43 > v125)
                {
                  uint64_t v126 = (uint64_t *)&v12[v125];
                  BOOL v127 = v126 != v11 && *((_DWORD *)v126 + 1) == v116;
                  if (v127 && v117 < v45)
                  {
                    uint64_t v129 = *(void *)(v44 + 8 * v117);
                    if (v129)
                    {
                      unint64_t v130 = *(unsigned __int16 *)(v129 + 2 * v119);
                      if (v184 > v130)
                      {
                        int v131 = (uint64_t *)&v15[v130];
                        if (v131 != v14 && *((_DWORD *)v131 + 1) == v116)
                        {
                          unint64_t v174 = HIDWORD(*v7);
                          unint64_t v133 = *v7;
                          unint64_t v134 = *v7 >> 39;
                          uint64_t v135 = v181;
                          if (v134 < v42)
                          {
                            uint64_t v136 = *(void *)(v41 + 8 * v134);
                            uint64_t v135 = v181;
                            if (v136)
                            {
                              unint64_t v137 = *(unsigned __int16 *)(v136 + 2 * (HIDWORD(v133) & 0x7F));
                              uint64_t v135 = v181;
                              if (v43 > v137)
                              {
                                BOOL v138 = HIDWORD(v12[v137]) != v174 || &v12[v137] == (unint64_t *)v11;
                                uint64_t v139 = (void *)(v178 + 80 * v137);
                                if (v138) {
                                  uint64_t v135 = v181;
                                }
                                else {
                                  uint64_t v135 = v139;
                                }
                              }
                            }
                          }
                          uint64_t v140 = v46;
                          if (v134 < v45)
                          {
                            uint64_t v141 = *(void *)(v44 + 8 * v134);
                            uint64_t v140 = v46;
                            if (v141)
                            {
                              unint64_t v142 = *(unsigned __int16 *)(v141 + 2 * (HIDWORD(v133) & 0x7F));
                              uint64_t v140 = v46;
                              if (v184 > v142)
                              {
                                uint64_t v143 = (uint64_t *)&v15[v142];
                                BOOL v144 = *((_DWORD *)v143 + 1) != v174 || v143 == v14;
                                uint64_t v140 = (void *)(v176 + 16 * v142);
                                if (v144) {
                                  uint64_t v140 = v46;
                                }
                              }
                            }
                          }
                          uint64_t v115 = (void *)*v140;
                          v115[7] = v135[3];
                          v115[8] = v135[4];
                          v115[9] = v135[5];
                          v115[10] = v135[6];
                          v115[4] = *v135;
                          v115[5] = v135[1];
                          v115[6] = v135[2];
                          v115[11] = v135[7];
                          v115[12] = v135[8];
                          v115[13] = v135[9];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      ++v7;
    }
    while (v7 != (unint64_t *)v6);
  }
  if (v4 + 4 == v13 && v12 != (unint64_t *)v11)
  {
    uint64_t v18 = v2[4];
    unint64_t v19 = (v2[5] - v18) >> 3;
    uint64_t v21 = v2[7];
    uint64_t v20 = v2[8];
    uint64_t v22 = v3[4];
    unint64_t v23 = (v3[5] - v22) >> 3;
    uint64_t v25 = v3[7];
    uint64_t v24 = v3[8];
    uint64_t v26 = result[4];
    unint64_t v27 = (result[5] - v26) >> 3;
    uint64_t v15 = (unint64_t *)result[7];
    uint64_t v14 = (uint64_t *)result[8];
    unint64_t v28 = (void *)(v4[10] + 40);
    uint64_t v29 = (void *)result[11];
    uint64_t v179 = result[10];
    unint64_t v182 = ((char *)v14 - (char *)v15) >> 3;
    do
    {
      unint64_t v48 = *((unsigned int *)v12 + 1);
      unint64_t v49 = v48 >> 7;
      if (v48 >> 7 < v19)
      {
        uint64_t v50 = *(void *)(v18 + 8 * v49);
        if (v50)
        {
          uint64_t v51 = v48 & 0x7F;
          unint64_t v52 = *(unsigned __int16 *)(v50 + 2 * v51);
          if ((v20 - v21) >> 3 > v52)
          {
            uint64_t v53 = v21 + 8 * v52;
            uint64_t v54 = v29;
            BOOL v55 = v53 != v20 && *(_DWORD *)(v53 + 4) == v48;
            if (v55 && v49 < v23)
            {
              uint64_t v57 = *(void *)(v22 + 8 * v49);
              if (v57)
              {
                unint64_t v58 = *(unsigned __int16 *)(v57 + 2 * v51);
                if ((v24 - v25) >> 3 > v58)
                {
                  uint64_t v59 = v25 + 8 * v58;
                  BOOL v60 = v59 != v24 && *(_DWORD *)(v59 + 4) == v48;
                  if (v60 && v49 < v27)
                  {
                    uint64_t v62 = *(void *)(v26 + 8 * v49);
                    if (v62)
                    {
                      unint64_t v63 = *(unsigned __int16 *)(v62 + 2 * v51);
                      if (v182 > v63)
                      {
                        uint64_t v64 = (uint64_t *)&v15[v63];
                        if (v64 != v14 && *((_DWORD *)v64 + 1) == v48)
                        {
                          unint64_t v66 = *v12;
                          unint64_t v67 = *v12 >> 39;
                          int v68 = v29;
                          if (v67 < v27)
                          {
                            uint64_t v69 = *(void *)(v26 + 8 * v67);
                            int v68 = v29;
                            if (v69)
                            {
                              unint64_t v70 = *(unsigned __int16 *)(v69 + 2 * (HIDWORD(v66) & 0x7F));
                              int v68 = v29;
                              if (v182 > v70)
                              {
                                uint64_t v71 = (uint64_t *)&v15[v70];
                                BOOL v72 = *((_DWORD *)v71 + 1) != HIDWORD(v66) || v71 == v14;
                                uint64_t v29 = v54;
                                if (v72) {
                                  int v68 = v54;
                                }
                                else {
                                  int v68 = (void *)(v179 + 16 * v70);
                                }
                              }
                            }
                          }
                          uint64_t v47 = (void *)*v68;
                          v47[7] = *(v28 - 2);
                          v47[8] = *(v28 - 1);
                          v47[9] = *v28;
                          v47[10] = v28[1];
                          v47[4] = *(v28 - 5);
                          v47[5] = *(v28 - 4);
                          v47[6] = *(v28 - 3);
                          v47[11] = v28[2];
                          v47[12] = v28[3];
                          v47[13] = v28[4];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      ++v12;
      v28 += 10;
    }
    while (v12 != (unint64_t *)v11);
  }
  if (result + 4 == v13 && v15 != (unint64_t *)v14)
  {
    unint64_t v73 = (void *)result[10];
    uint64_t v74 = v2[4];
    unint64_t v75 = (v2[5] - v74) >> 3;
    uint64_t v77 = v2[7];
    uint64_t v76 = v2[8];
    uint64_t v78 = v3[4];
    unint64_t v79 = (v3[5] - v78) >> 3;
    uint64_t v80 = v3[7];
    uint64_t result = (void *)v3[8];
    uint64_t v81 = v4[4];
    unint64_t v82 = (v4[5] - v81) >> 3;
    uint64_t v84 = v4[7];
    uint64_t v83 = v4[8];
    unint64_t v85 = (v83 - v84) >> 3;
    uint64_t v87 = v4[10];
    double v86 = (void *)v4[11];
    do
    {
      unint64_t v146 = *((unsigned int *)v15 + 1);
      unint64_t v147 = v146 >> 7;
      if (v146 >> 7 < v75)
      {
        uint64_t v148 = *(void *)(v74 + 8 * v147);
        if (v148)
        {
          uint64_t v149 = v146 & 0x7F;
          unint64_t v150 = *(unsigned __int16 *)(v148 + 2 * v149);
          if ((v76 - v77) >> 3 > v150)
          {
            uint64_t v151 = v77 + 8 * v150;
            BOOL v152 = v151 != v76 && *(_DWORD *)(v151 + 4) == v146;
            if (v152 && v147 < v79)
            {
              uint64_t v154 = *(void *)(v78 + 8 * v147);
              if (v154)
              {
                unint64_t v155 = *(unsigned __int16 *)(v154 + 2 * v149);
                if (((uint64_t)result - v80) >> 3 > v155)
                {
                  uint64_t v156 = v80 + 8 * v155;
                  BOOL v157 = (void *)v156 != result && *(_DWORD *)(v156 + 4) == v146;
                  if (v157 && v147 < v82)
                  {
                    uint64_t v159 = *(void *)(v81 + 8 * v147);
                    if (v159)
                    {
                      unint64_t v160 = *(unsigned __int16 *)(v159 + 2 * v149);
                      if (v85 > v160)
                      {
                        uint64_t v161 = v84 + 8 * v160;
                        if (v161 != v83 && *(_DWORD *)(v161 + 4) == v146)
                        {
                          unint64_t v163 = *v15;
                          unint64_t v164 = *v15 >> 39;
                          float v165 = v86;
                          if (v164 < v82)
                          {
                            uint64_t v166 = *(void *)(v81 + 8 * v164);
                            float v165 = v86;
                            if (v166)
                            {
                              unint64_t v167 = *(unsigned __int16 *)(v166 + 2 * (HIDWORD(v163) & 0x7F));
                              float v165 = v86;
                              if (v85 > v167)
                              {
                                unint64_t v168 = HIDWORD(v163);
                                uint64_t v169 = v84 + 8 * v167;
                                BOOL v170 = *(_DWORD *)(v169 + 4) != v168 || v169 == v83;
                                float v165 = (void *)(v87 + 80 * v167);
                                if (v170) {
                                  float v165 = v86;
                                }
                              }
                            }
                          }
                          uint64_t v145 = (void *)*v73;
                          v145[7] = v165[3];
                          v145[8] = v165[4];
                          v145[9] = v165[5];
                          v145[10] = v165[6];
                          v145[4] = *v165;
                          v145[5] = v165[1];
                          v145[6] = v165[2];
                          v145[11] = v165[7];
                          v145[12] = v165[8];
                          v145[13] = v165[9];
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      v73 += 2;
      ++v15;
    }
    while (v15 != (unint64_t *)v14);
  }
  return result;
}

uint64_t gdc::Registry::storage<arComponents::NeedsResolvedWorldTransform>(int8x8_t *a1)
{
  unint64_t v10 = 0xF6A197B0F4F03657;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xF6A197B0F4F03657;
    if (*(void *)&v1 <= 0xF6A197B0F4F03657) {
      unint64_t v3 = 0xF6A197B0F4F03657 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xF6A197B0F4F03657;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xF6A197B0F4F03657)
      {
        if (v5[2] == 0xF6A197B0F4F03657) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xF6A197B0F4F03657) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xF6A197B0F4F03657) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1FB0864(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<arComponents::Wrap<std::shared_ptr<md::LabelExternalMesh>>>(int8x8_t *a1)
{
  uint64_t v10 = 0x6348F11188A7D30CLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x6348F11188A7D30CLL;
    if (*(void *)&v1 <= 0x6348F11188A7D30CuLL) {
      uint64_t v3 = 0x6348F11188A7D30CuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x6348F11188A7D30CLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x6348F11188A7D30CLL)
      {
        if (v5[2] == 0x6348F11188A7D30CLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x6348F11188A7D30CLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x6348F11188A7D30CLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1FB0AD4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

BOOL gdc::ComponentStorageWrapper<arComponents::Wrap<std::shared_ptr<md::LabelExternalMesh>>>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

void gdc::ComponentStorageWrapper<arComponents::Wrap<std::shared_ptr<md::LabelExternalMesh>>>::remove(void *a1, unint64_t a2)
{
  unint64_t v24 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 < (v5 - v4) >> 3)
  {
    uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
    if (v6)
    {
      unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
      uint64_t v9 = a1[7];
      uint64_t v8 = a1[8];
      if (v7 < (v8 - v9) >> 3)
      {
        unint64_t v10 = HIDWORD(a2);
        uint64_t v11 = v9 + 8 * v7;
        if (v11 != v8 && *(_DWORD *)(v11 + 4) == v10)
        {
          uint64_t v13 = (void *)(a1[10] + 16 * v7);
          geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
          uint64_t v14 = a1[11];
          uint64_t v16 = *(void *)(v14 - 16);
          uint64_t v15 = *(void *)(v14 - 8);
          if (v15) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v17 = (std::__shared_weak_count *)v13[1];
          *uint64_t v13 = v16;
          v13[1] = v15;
          if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
            std::__shared_weak_count::__release_weak(v17);
          }
          uint64_t v18 = a1[11];
          unint64_t v19 = *(std::__shared_weak_count **)(v18 - 8);
          if (v19)
          {
            if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
              std::__shared_weak_count::__release_weak(v19);
            }
          }
          a1[11] = v18 - 16;
          uint64_t v20 = (void *)a1[28];
          if (v20)
          {
            uint64_t v21 = a1[31];
            while (1)
            {
              v26[0] = &v24;
              v26[1] = 1;
              uint64_t v25 = v21;
              uint64_t v22 = v20[6];
              if (!v22) {
                break;
              }
              (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v22 + 48))(v22, &v25, v26);
              uint64_t v20 = (void *)*v20;
              if (!v20) {
                return;
              }
            }
            std::__throw_bad_function_call[abi:nn180100]();
            gdc::ComponentStorageWrapper<arComponents::Wrap<std::shared_ptr<md::LabelExternalMesh>>>::~ComponentStorageWrapper(v23);
          }
        }
      }
    }
  }
}

void gdc::ComponentStorageWrapper<arComponents::Wrap<std::shared_ptr<md::LabelExternalMesh>>>::~ComponentStorageWrapper(uint64_t a1)
{
  gdc::ComponentStorageSignals::~ComponentStorageSignals((gdc::ComponentStorageSignals *)(a1 + 104));
  geo::sparse_map<gdc::Entity,arComponents::MeshComponent>::~sparse_map((void *)(a1 + 32));
  JUMPOUT(0x1A6239270);
}

uint64_t gdc::ComponentStorageWrapper<arComponents::Wrap<std::shared_ptr<md::LabelExternalMesh>>>::~ComponentStorageWrapper(uint64_t a1)
{
  return a1;
}

BOOL gdc::ComponentStorageWrapper<arComponents::NeedsResolvedWorldTransform>::contains(void *a1, unint64_t a2)
{
  uint64_t v2 = a1[4];
  if (a2 >> 39 >= (a1[5] - v2) >> 3 || (uint64_t v3 = *(void *)(v2 + 8 * (a2 >> 39))) == 0)
  {
    uint64_t v5 = a1[8];
    goto LABEL_8;
  }
  unint64_t v4 = *(unsigned __int16 *)(v3 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v6 = a1[7];
  uint64_t v5 = a1[8];
  if (v4 >= (v5 - v6) >> 3)
  {
LABEL_8:
    uint64_t v7 = v5;
    return v7 != v5;
  }
  uint64_t v7 = v6 + 8 * v4;
  if (*(_DWORD *)(v7 + 4) != HIDWORD(a2)) {
    uint64_t v7 = a1[8];
  }
  return v7 != v5;
}

uint64_t gdc::ComponentStorageWrapper<arComponents::NeedsResolvedWorldTransform>::remove(void *a1, unint64_t a2)
{
  unint64_t v17 = a2;
  uint64_t v4 = a1[4];
  uint64_t v5 = a1[5];
  uint64_t v3 = a1 + 4;
  if (a2 >> 39 >= (v5 - v4) >> 3) {
    return 0;
  }
  uint64_t v6 = *(void *)(v4 + 8 * (a2 >> 39));
  if (!v6) {
    return 0;
  }
  unint64_t v7 = *(unsigned __int16 *)(v6 + 2 * (HIDWORD(a2) & 0x7F));
  uint64_t v9 = a1[7];
  uint64_t v8 = a1[8];
  if (v7 >= (v8 - v9) >> 3) {
    return 0;
  }
  unint64_t v10 = HIDWORD(a2);
  uint64_t v11 = v9 + 8 * v7;
  if (v11 == v8 || *(_DWORD *)(v11 + 4) != v10) {
    return 0;
  }
  geo::sparse_set<gdc::Entity,unsigned short,256ul>::erase(v3, (void *)v11);
  --a1[11];
  uint64_t v14 = (void *)a1[28];
  if (!v14) {
    return 1;
  }
  uint64_t v15 = a1[31];
  while (1)
  {
    v19[0] = &v17;
    v19[1] = 1;
    uint64_t v18 = v15;
    uint64_t v16 = v14[6];
    if (!v16) {
      break;
    }
    (*(void (**)(uint64_t, uint64_t *, void *))(*(void *)v16 + 48))(v16, &v18, v19);
    uint64_t v14 = (void *)*v14;
    if (!v14) {
      return 1;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return gdc::ComponentStorageWrapper<arComponents::NeedsResolvedWorldTransform>::~ComponentStorageWrapper();
}

void gdc::ComponentStorageWrapper<arComponents::NeedsResolvedWorldTransform>::~ComponentStorageWrapper(void *a1)
{
  gdc::ComponentStorageWrapper<md::overlayComponents::TileIsInView>::~ComponentStorageWrapper(a1);
  JUMPOUT(0x1A6239270);
}

uint64_t md::Logic<md::LabelsExtractExternallyResolvedWorldTransformLogic,md::LabelsExtractExternallyResolvedWorldTransformContext,md::LogicDependencies<gdc::TypeList<md::ARApplyWorldTransformUpdatesContext>,gdc::TypeList<>>>::frequency(uint64_t a1)
{
  return *(void *)(a1 + 64);
}

uint64_t md::Logic<md::LabelsExtractExternallyResolvedWorldTransformLogic,md::LabelsExtractExternallyResolvedWorldTransformContext,md::LogicDependencies<gdc::TypeList<md::ARApplyWorldTransformUpdatesContext>,gdc::TypeList<>>>::_debugConsoleString@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unsigned char *a4@<X8>)
{
  if (*(void *)(a3 + 8) != 0xDB33FC702E07AAFLL || !*(void *)(a3 + 32))
  {
    a4[23] = 0;
    *a4 = 0;
    return result;
  }
  uint64_t v4 = *(void **)(a2 + 8);
  int8x8_t v5 = (int8x8_t)v4[1];
  if (!*(void *)&v5) {
    goto LABEL_27;
  }
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v5);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    uint64_t v7 = 0x61AAF6FADEFBCCACLL;
    if (*(void *)&v5 <= 0x61AAF6FADEFBCCACuLL) {
      uint64_t v7 = 0x61AAF6FADEFBCCACuLL % *(void *)&v5;
    }
  }
  else
  {
    uint64_t v7 = (*(void *)&v5 - 1) & 0x61AAF6FADEFBCCACLL;
  }
  uint64_t v8 = *(void **)(*v4 + 8 * v7);
  if (!v8) {
    goto LABEL_27;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_27;
  }
  if (v6.u32[0] < 2uLL)
  {
    uint64_t v10 = *(void *)&v5 - 1;
    while (1)
    {
      uint64_t v12 = v9[1];
      if (v12 == 0x61AAF6FADEFBCCACLL)
      {
        if (v9[2] == 0x61AAF6FADEFBCCACLL) {
          goto LABEL_25;
        }
      }
      else if ((v12 & v10) != v7)
      {
        goto LABEL_27;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_27;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v9[1];
    if (v11 == 0x61AAF6FADEFBCCACLL) {
      break;
    }
    if (v11 >= *(void *)&v5) {
      v11 %= *(void *)&v5;
    }
    if (v11 != v7) {
      goto LABEL_27;
    }
LABEL_14:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_27;
    }
  }
  if (v9[2] != 0x61AAF6FADEFBCCACLL) {
    goto LABEL_14;
  }
LABEL_25:
  uint64_t v13 = v9[5];
  if (*(void *)(v13 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v14 = *(void *)(v13 + 32);
    goto LABEL_28;
  }
LABEL_27:
  uint64_t v14 = 0;
LABEL_28:
  uint64_t v15 = v14;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
}

uint64_t md::Logic<md::LabelsExtractExternallyResolvedWorldTransformLogic,md::LabelsExtractExternallyResolvedWorldTransformContext,md::LogicDependencies<gdc::TypeList<md::ARApplyWorldTransformUpdatesContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0xDB33FC702E07AAFLL || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x61AAF6FADEFBCCACLL;
    if (*(void *)&v4 <= 0x61AAF6FADEFBCCACuLL) {
      uint64_t v6 = 0x61AAF6FADEFBCCACuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x61AAF6FADEFBCCACLL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x61AAF6FADEFBCCACLL)
      {
        if (v8[2] == 0x61AAF6FADEFBCCACLL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x61AAF6FADEFBCCACLL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x61AAF6FADEFBCCACLL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
}

uint64_t md::Logic<md::LabelsExtractExternallyResolvedWorldTransformLogic,md::LabelsExtractExternallyResolvedWorldTransformContext,md::LogicDependencies<gdc::TypeList<md::ARApplyWorldTransformUpdatesContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0xDB33FC702E07AAFLL || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x61AAF6FADEFBCCACLL;
    if (*(void *)&v4 <= 0x61AAF6FADEFBCCACuLL) {
      uint64_t v6 = 0x61AAF6FADEFBCCACuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x61AAF6FADEFBCCACLL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x61AAF6FADEFBCCACLL)
      {
        if (v8[2] == 0x61AAF6FADEFBCCACLL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x61AAF6FADEFBCCACLL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x61AAF6FADEFBCCACLL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 144))(result);
}

uint64_t md::Logic<md::LabelsExtractExternallyResolvedWorldTransformLogic,md::LabelsExtractExternallyResolvedWorldTransformContext,md::LogicDependencies<gdc::TypeList<md::ARApplyWorldTransformUpdatesContext>,gdc::TypeList<>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0xDB33FC702E07AAFLL || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x61AAF6FADEFBCCACLL;
    if (*(void *)&v4 <= 0x61AAF6FADEFBCCACuLL) {
      uint64_t v6 = 0x61AAF6FADEFBCCACuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x61AAF6FADEFBCCACLL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x61AAF6FADEFBCCACLL)
      {
        if (v8[2] == 0x61AAF6FADEFBCCACLL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x61AAF6FADEFBCCACLL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x61AAF6FADEFBCCACLL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 136))(result);
}

uint64_t md::Logic<md::LabelsExtractExternallyResolvedWorldTransformLogic,md::LabelsExtractExternallyResolvedWorldTransformContext,md::LogicDependencies<gdc::TypeList<md::ARApplyWorldTransformUpdatesContext>,gdc::TypeList<>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) != 0xDB33FC702E07AAFLL || !*(void *)(a3 + 32)) {
    return result;
  }
  uint64_t v3 = *(void **)(a2 + 8);
  int8x8_t v4 = (int8x8_t)v3[1];
  if (!*(void *)&v4) {
    goto LABEL_26;
  }
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v4);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    uint64_t v6 = 0x61AAF6FADEFBCCACLL;
    if (*(void *)&v4 <= 0x61AAF6FADEFBCCACuLL) {
      uint64_t v6 = 0x61AAF6FADEFBCCACuLL % *(void *)&v4;
    }
  }
  else
  {
    uint64_t v6 = (*(void *)&v4 - 1) & 0x61AAF6FADEFBCCACLL;
  }
  uint64_t v7 = *(void **)(*v3 + 8 * v6);
  if (!v7) {
    goto LABEL_26;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_26;
  }
  if (v5.u32[0] < 2uLL)
  {
    uint64_t v9 = *(void *)&v4 - 1;
    while (1)
    {
      uint64_t v11 = v8[1];
      if (v11 == 0x61AAF6FADEFBCCACLL)
      {
        if (v8[2] == 0x61AAF6FADEFBCCACLL) {
          goto LABEL_24;
        }
      }
      else if ((v11 & v9) != v6)
      {
        goto LABEL_26;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v8[1];
    if (v10 == 0x61AAF6FADEFBCCACLL) {
      break;
    }
    if (v10 >= *(void *)&v4) {
      v10 %= *(void *)&v4;
    }
    if (v10 != v6) {
      goto LABEL_26;
    }
LABEL_13:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_26;
    }
  }
  if (v8[2] != 0x61AAF6FADEFBCCACLL) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v12 = v8[5];
  if (*(void *)(v12 + 8) == 0x61AAF6FADEFBCCACLL)
  {
    uint64_t v13 = *(void *)(v12 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v13 = 0;
LABEL_27:
  uint64_t v14 = v13;
  return (*(uint64_t (**)(uint64_t))(*(void *)result + 128))(result);
}

void md::Logic<md::LabelsExtractExternallyResolvedWorldTransformLogic,md::LabelsExtractExternallyResolvedWorldTransformContext,md::LogicDependencies<gdc::TypeList<md::ARApplyWorldTransformUpdatesContext>,gdc::TypeList<>>>::_allocateContext()
{
}

void sub_1A1FB1770(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10F1C40B0038B9CLL);
  _Unwind_Resume(a1);
}

uint64_t gdc::ObjectHolder<md::LabelsExtractExternallyResolvedWorldTransformContext>::extract@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  uint64_t v2 = *(void *)(result + 32);
  *(void *)(result + 32) = 0;
  *a2 = v2;
  return result;
}

void gdc::ManagedObjectHolder<md::LabelsExtractExternallyResolvedWorldTransformContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555ED8;
  uint64_t v1 = a1[4];
  if (v1) {
    MEMORY[0x1A6239270](v1, 0xC400A2AC0F1);
  }
  JUMPOUT(0x1A6239270);
}

void *gdc::ManagedObjectHolder<md::LabelsExtractExternallyResolvedWorldTransformContext>::~ManagedObjectHolder(void *a1)
{
  *a1 = &unk_1EF555ED8;
  uint64_t v2 = a1[4];
  if (v2) {
    MEMORY[0x1A6239270](v2, 0xC400A2AC0F1);
  }
  return a1;
}

void md::LabelsExtractExternallyResolvedWorldTransformLogic::~LabelsExtractExternallyResolvedWorldTransformLogic(md::LabelsExtractExternallyResolvedWorldTransformLogic *this)
{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = off_1EF554478;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 13));
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)this + 10));
}

void md::Renderer::createDebugNode(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  uint64_t v2 = *(void *)(a1 + 40);
  for (uint64_t i = *(void *)(a1 + 48); v2 != i; v2 += 8)
  {
    if (*(void *)v2)
    {
      (*(void (**)(void **__return_ptr))(**(void **)v2 + 64))(v15);
      gdc::DebugTreeNode::addChildNode((void *)a2, (long long *)v15);
      uint8x8_t v5 = (void **)__p;
      if (__p)
      {
        uint64_t v6 = v21;
        uint64_t v7 = __p;
        if (v21 != __p)
        {
          do
          {
            uint64_t v8 = (void **)*(v6 - 3);
            if (v8)
            {
              uint64_t v9 = (void **)*(v6 - 2);
              unint64_t v10 = *(v6 - 3);
              if (v9 != v8)
              {
                do
                {
                  if (*((char *)v9 - 1) < 0) {
                    operator delete(*(v9 - 3));
                  }
                  v9 -= 3;
                }
                while (v9 != v8);
                unint64_t v10 = *(v6 - 3);
              }
              *(v6 - 2) = v8;
              operator delete(v10);
            }
            uint64_t v11 = (void **)*(v6 - 6);
            if (v11)
            {
              uint64_t v12 = (void **)*(v6 - 5);
              uint64_t v13 = *(v6 - 6);
              if (v12 != v11)
              {
                do
                {
                  if (*((char *)v12 - 9) < 0) {
                    operator delete(*(v12 - 4));
                  }
                  v12 -= 8;
                }
                while (v12 != v11);
                uint64_t v13 = *(v6 - 6);
              }
              *(v6 - 5) = v11;
              operator delete(v13);
            }
            uint64_t v14 = v6 - 10;
            if (*((char *)v6 - 57) < 0) {
              operator delete(*v14);
            }
            v6 -= 10;
          }
          while (v14 != v5);
          uint64_t v7 = __p;
        }
        uint64_t v21 = v5;
        operator delete(v7);
      }
      std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v19);
      if (v18 < 0)
      {
        operator delete(v17);
        if (v16 < 0) {
LABEL_33:
        }
          operator delete(v15[0]);
      }
      else if (v16 < 0)
      {
        goto LABEL_33;
      }
    }
  }
}

void sub_1A1FB1B08(_Unwind_Exception *a1)
{
  gdc::DebugTreeNode::~DebugTreeNode(v1);
  _Unwind_Resume(a1);
}

uint64_t md::Renderer::didPrepareForLayout(md::Renderer *this, md::LayoutContext *a2)
{
  return (*(uint64_t (**)(void, md::LayoutContext *, md::Renderer *))(**((void **)this + 3) + 16))(*((void *)this + 3), a2, this);
}

md::FrameGraphResourceRegistry **std::unique_ptr<md::FrameGraphResourceRegistry>::~unique_ptr[abi:nn180100](md::FrameGraphResourceRegistry **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    md::FrameGraphResourceRegistry::~FrameGraphResourceRegistry(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void md::Renderer::~Renderer(md::Renderer *this)
{
  *(void *)this = &unk_1EF553E08;
  uint64_t v2 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  uint64_t v3 = (md::FrameGraphResourceRegistry *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v3)
  {
    md::FrameGraphResourceRegistry::~FrameGraphResourceRegistry(v3);
    MEMORY[0x1A6239270]();
  }

  int8x8_t v4 = (void *)*((void *)this + 8);
  if (v4)
  {
    *((void *)this + 9) = v4;
    operator delete(v4);
  }
  uint8x8_t v5 = (void *)*((void *)this + 5);
  if (v5)
  {
    uint64_t v6 = (void *)*((void *)this + 6);
    uint64_t v7 = (void *)*((void *)this + 5);
    if (v6 != v5)
    {
      do
      {
        uint64_t v9 = *--v6;
        uint64_t v8 = v9;
        *uint64_t v6 = 0;
        if (v9) {
          (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
        }
      }
      while (v6 != v5);
      uint64_t v7 = (void *)*((void *)this + 5);
    }
    *((void *)this + 6) = v5;
    operator delete(v7);
  }
  unint64_t v10 = (md::FrameGraphResourceRegistry *)*((void *)this + 4);
  *((void *)this + 4) = 0;
  if (v10)
  {
    md::FrameGraphResourceRegistry::~FrameGraphResourceRegistry(v10);
    MEMORY[0x1A6239270]();
  }
  uint64_t v11 = *((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  uint64_t v12 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v12)
  {
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
}

unsigned __int8 *std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<md::CommandBufferLocation,md::RenderLayer *> *>(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4, unsigned __int8 *a5)
{
  uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<md::CommandBufferLocation,md::RenderLayer *> *>(a1, a2, a3, a4);
  unsigned int v11 = *a5;
  unsigned int v12 = *a4;
  if (v11 < v12
    || v11 == v12 && (unsigned int v11 = a5[1], v12 = a4[1], v11 < v12)
    || v12 >= v11 && *((void *)a5 + 1) < *((void *)a4 + 1))
  {
    __int16 v13 = *(_WORD *)a4;
    *(_WORD *)a4 = *(_WORD *)a5;
    *(_WORD *)a5 = v13;
    uint64_t v14 = *((void *)a4 + 1);
    *((void *)a4 + 1) = *((void *)a5 + 1);
    *((void *)a5 + 1) = v14;
    unsigned int v15 = *a4;
    unsigned int v16 = *a3;
    if (v15 < v16) {
      goto LABEL_11;
    }
    if (v15 == v16)
    {
      unsigned int v15 = a4[1];
      unsigned int v16 = a3[1];
      if (v15 < v16) {
        goto LABEL_11;
      }
    }
    if (v16 >= v15 && *((void *)a4 + 1) < *((void *)a3 + 1))
    {
LABEL_11:
      __int16 v17 = *(_WORD *)a3;
      *(_WORD *)a3 = *(_WORD *)a4;
      *(_WORD *)a4 = v17;
      uint64_t v18 = *((void *)a3 + 1);
      *((void *)a3 + 1) = *((void *)a4 + 1);
      *((void *)a4 + 1) = v18;
      unsigned int v19 = *a3;
      unsigned int v20 = *a2;
      if (v19 < v20) {
        goto LABEL_12;
      }
      if (v19 == v20)
      {
        unsigned int v19 = a3[1];
        unsigned int v20 = a2[1];
        if (v19 < v20) {
          goto LABEL_12;
        }
      }
      if (v20 >= v19 && *((void *)a3 + 1) < *((void *)a2 + 1))
      {
LABEL_12:
        __int16 v21 = *(_WORD *)a2;
        *(_WORD *)a2 = *(_WORD *)a3;
        *(_WORD *)a3 = v21;
        uint64_t v22 = *((void *)a2 + 1);
        *((void *)a2 + 1) = *((void *)a3 + 1);
        *((void *)a3 + 1) = v22;
        unsigned int v23 = *a2;
        unsigned int v24 = *a1;
        if (v23 < v24
          || v23 == v24 && (unsigned int v23 = a2[1], v24 = a1[1], v23 < v24)
          || v24 >= v23 && *((void *)a2 + 1) < *((void *)a1 + 1))
        {
          __int16 v25 = *(_WORD *)a1;
          *(_WORD *)a1 = *(_WORD *)a2;
          *(_WORD *)a2 = v25;
          uint64_t v26 = *((void *)a1 + 1);
          *((void *)a1 + 1) = *((void *)a2 + 1);
          *((void *)a2 + 1) = v26;
        }
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<md::CommandBufferLocation,md::RenderLayer *> *>(unsigned __int8 *a1, unsigned __int8 *a2)
{
  uint64_t v4 = (a2 - a1) >> 4;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unsigned int v6 = *(a2 - 16);
      unsigned int v7 = *a1;
      if (v6 < v7
        || v6 == v7 && (unsigned int v6 = *(a2 - 15), v7 = a1[1], v6 < v7)
        || v7 >= v6 && *((void *)a2 - 1) < *((void *)a1 + 1))
      {
        __int16 v8 = *(_WORD *)a1;
        *(_WORD *)a1 = *((_WORD *)a2 - 8);
        *((_WORD *)a2 - 8) = v8;
        uint64_t v9 = *((void *)a1 + 1);
        *((void *)a1 + 1) = *((void *)a2 - 1);
        *((void *)a2 - 1) = v9;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<md::CommandBufferLocation,md::RenderLayer *> *>(a1, a1 + 16, a2 - 16);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<md::CommandBufferLocation,md::RenderLayer *> *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<md::CommandBufferLocation,md::RenderLayer *> *>(a1, a1 + 16, a1 + 32, a1 + 48, a2 - 16);
      return 1;
    default:
      unint64_t v10 = a1 + 32;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<md::CommandBufferLocation,md::RenderLayer *> *>(a1, a1 + 16, a1 + 32);
      unsigned int v11 = a1 + 48;
      if (a1 + 48 == a2) {
        return 1;
      }
      uint64_t v12 = 0;
      int v13 = 0;
      break;
  }
  while (2)
  {
    unsigned int v15 = *v11;
    unsigned int v16 = *v10;
    if (v15 >= v16)
    {
      if (v15 != v16 || (unsigned int v15 = v11[1], v16 = v10[1], v15 >= v16))
      {
        if (v16 < v15 || *((void *)v11 + 1) >= *((void *)v10 + 1)) {
          goto LABEL_8;
        }
      }
    }
    unsigned int v17 = *(unsigned __int16 *)v11;
    unint64_t v18 = *((void *)v11 + 1);
    *(_WORD *)unsigned int v11 = *(_WORD *)v10;
    *((void *)v11 + 1) = *((void *)v10 + 1);
    uint64_t v14 = (uint64_t)a1;
    if (v10 == a1) {
      goto LABEL_7;
    }
    unsigned int v19 = v17 >> 8;
    uint64_t v20 = v12;
    while (1)
    {
      __int16 v21 = &a1[v20];
      unsigned int v22 = a1[v20 + 16];
      if (v22 <= v17)
      {
        if (v22 == v17)
        {
          unsigned int v23 = a1[v20 + 17];
          if (v23 > v19) {
            goto LABEL_14;
          }
          if (v23 < v19)
          {
LABEL_19:
            uint64_t v14 = (uint64_t)v10;
            goto LABEL_7;
          }
        }
        else if (v22 < v17)
        {
          goto LABEL_19;
        }
        if (v18 >= *(void *)&a1[v20 + 24]) {
          break;
        }
      }
LABEL_14:
      v10 -= 16;
      *((_WORD *)v21 + 16) = *((_WORD *)v21 + 8);
      *((void *)v21 + 5) = *((void *)v21 + 3);
      v20 -= 16;
      if (v20 == -32)
      {
        uint64_t v14 = (uint64_t)a1;
        goto LABEL_7;
      }
    }
    uint64_t v14 = (uint64_t)&a1[v20 + 32];
LABEL_7:
    *(_WORD *)uint64_t v14 = v17;
    *(void *)(v14 + 8) = v18;
    if (++v13 == 8) {
      return v11 + 16 == a2;
    }
LABEL_8:
    unint64_t v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 != a2) {
      continue;
    }
    return 1;
  }
}

uint64_t CoreAnalyticsLibraryCore()
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = 0;
  uint64_t v3 = &v2;
  uint64_t v4 = 0x2020000000;
  uint64_t v0 = CoreAnalyticsLibraryCore_frameworkLibrary;
  uint64_t v5 = CoreAnalyticsLibraryCore_frameworkLibrary;
  if (!CoreAnalyticsLibraryCore_frameworkLibrary)
  {
    long long v6 = xmmword_1E5A8EA58;
    long long v7 = *(_OWORD *)&off_1E5A8EA68;
    v3[3] = _sl_dlopen();
    CoreAnalyticsLibraryCore_frameworkLibrary = v3[3];
    uint64_t v0 = v3[3];
  }
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_1A1FB22B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __CoreAnalyticsLibraryCore_block_invoke(uint64_t a1)
{
  uint64_t result = _sl_dlopen();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  CoreAnalyticsLibraryCore_frameworkLibrary = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *__getAnalyticsSendEventLazySymbolLoc_block_invoke(uint64_t a1)
{
  uint64_t v2 = (void *)CoreAnalyticsLibraryCore();
  if (!v2)
  {
    uint64_t v4 = (void *)abort_report_np();
    free(v4);
  }
  uint64_t result = dlsym(v2, "AnalyticsSendEventLazy");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  getAnalyticsSendEventLazySymbolLoc_ptr = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void vkAnalyticsSendEventLazy(void *a1)
{
  uint64_t v2 = @"com.apple.VectorKit.GeoGL.AccessRevoked";
  id v3 = a1;
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  uint64_t v4 = getAnalyticsSendEventLazySymbolLoc_ptr;
  unint64_t v10 = getAnalyticsSendEventLazySymbolLoc_ptr;
  if (getAnalyticsSendEventLazySymbolLoc_ptr) {
    goto LABEL_5;
  }
  long long v6 = &v7;
  unsigned int v11 = 0;
  uint64_t v4 = (void *)CoreAnalyticsLibraryCore();
  uint64_t v5 = v11;
  if (!v4) {
    goto LABEL_10;
  }
  if (v11) {
    goto LABEL_11;
  }
  while (1)
  {
    *(void *)(v6[1] + 24) = dlsym(v4, "AnalyticsSendEventLazy");
    getAnalyticsSendEventLazySymbolLoc_ptr = *(_UNKNOWN **)(v6[1] + 24);
    uint64_t v4 = (void *)v8[3];
LABEL_5:
    _Block_object_dispose(&v7, 8);
    if (v4) {
      break;
    }
    dlerror();
    abort_report_np();
LABEL_10:
    uint64_t v5 = (void *)abort_report_np();
    __break(1u);
LABEL_11:
    free(v5);
  }
  ((void (*)(__CFString *, id))v4)(@"com.apple.VectorKit.GeoGL.AccessRevoked", v3);
}

void sub_1A1FB2554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void md::ObjectGroup::addFeatureIds(uint64_t a1, uint64_t a2, uint64_t *a3, unsigned int a4)
{
  if (a1 != a2)
  {
    unsigned __int8 v4 = a4;
    uint64_t v6 = a1;
    uint64_t v7 = a4 - 0x61C8864680B583EBLL;
    uint64_t v8 = a3 + 2;
    do
    {
      uint64_t v9 = *(void *)(v6 + 16);
      uint64_t v10 = *(void *)(v6 + 24);
      while (v9 != v10)
      {
        uint64_t v12 = *(void *)(v9 + 8);
        uint64_t v11 = *(void *)(v9 + 16);
        if (v12 != v11)
        {
          while (1)
          {
            while (1)
            {
              int v13 = operator new(0x20uLL);
              *int v13 = 0;
              uint64_t v14 = *(uint64_t **)(v12 + 16);
              *((unsigned char *)v13 + 24) = v4;
              unint64_t v15 = (v7 + ((void)v14 << 6) + ((unint64_t)v14 >> 2)) ^ (unint64_t)v14;
              v13[1] = v15;
              v13[2] = v14;
              if (!std::__hash_table<md::FeatureIdZoom,md::FeatureIdZoomHash,std::equal_to<md::FeatureIdZoom>,std::allocator<md::FeatureIdZoom>>::__node_insert_unique_prepare[abi:nn180100]((uint64_t)a3, v15, v14, v4))break; {
              operator delete(v13);
              }
              v12 += 24;
              if (v12 == v11) {
                goto LABEL_5;
              }
            }
            int8x8_t v16 = (int8x8_t)a3[1];
            unint64_t v17 = v13[1];
            uint8x8_t v18 = (uint8x8_t)vcnt_s8(v16);
            v18.i16[0] = vaddlv_u8(v18);
            if (v18.u32[0] > 1uLL)
            {
              if (v17 >= *(void *)&v16) {
                v17 %= *(void *)&v16;
              }
            }
            else
            {
              v17 &= *(void *)&v16 - 1;
            }
            uint64_t v19 = *a3;
            uint64_t v20 = *(void **)(*a3 + 8 * v17);
            if (v20) {
              break;
            }
            *int v13 = *v8;
            *uint64_t v8 = v13;
            *(void *)(v19 + 8 * v17) = v8;
            if (*v13)
            {
              unint64_t v21 = *(void *)(*v13 + 8);
              if (v18.u32[0] > 1uLL)
              {
                if (v21 >= *(void *)&v16) {
                  v21 %= *(void *)&v16;
                }
              }
              else
              {
                v21 &= *(void *)&v16 - 1;
              }
              uint64_t v20 = (void *)(*a3 + 8 * v21);
              goto LABEL_23;
            }
LABEL_24:
            ++a3[3];
            v12 += 24;
            if (v12 == v11) {
              goto LABEL_5;
            }
          }
          *int v13 = *v20;
LABEL_23:
          *uint64_t v20 = v13;
          goto LABEL_24;
        }
LABEL_5:
        v9 += 32;
      }
      v6 += 40;
    }
    while (v6 != a2);
  }
}

void sub_1A1FB2720(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,karo::AsyncRequestManagerNoArgs>::waitOnRequest(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  uint64_t v6 = std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::TileKey>(a1 + 64, a2);
  if ((_DWORD *)(a1 + 72) == v6)
  {
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    return 0;
  }
  else
  {
    uint64_t v8 = *((void *)v6 + 8);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)v6 + 9);
    if (v7) {
      atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
    if (v8)
    {
      karo::Job::waitToFinish((karo::Job *)v8, a3);
      pthread_mutex_lock(*(pthread_mutex_t **)(v8 + 152));
      uint64_t v9 = *(_DWORD *)(v8 + 160) & 1;
      pthread_mutex_unlock(*(pthread_mutex_t **)(v8 + 152));
      if (!v7) {
        return v9;
      }
    }
    else
    {
      uint64_t v9 = 0;
      if (!v7) {
        return v9;
      }
    }
    if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return v9;
}

uint64_t altitude::DtmRequestManager::request(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void))(*(void *)a1 + 80))(a1, a2, a3, a4, a5, a6, 0);
}

void karo::AsyncRequestManagerTemplate<altitude::TileKey,karo::AsyncRequestManagerNoArgs>::getRequest(void *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t **a4@<X8>)
{
  *a4 = 0;
  a4[1] = 0;
  uint64_t v8 = (void **)(a1 + 8);
  uint64_t v9 = (uint64_t **)std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::TileKey>((uint64_t)(a1 + 8), (unsigned int *)a2);
  uint64_t v10 = v9;
  if (a1 + 9 == v9)
  {
    (*(void (**)(uint64_t **__return_ptr, void *, uint64_t, uint64_t))(*a1 + 64))(&v26, a1, a2, a3);
    uint64_t v14 = v26;
    int v13 = v27;
    *a4 = v26;
    a4[1] = (uint64_t *)v13;
    unint64_t v15 = std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::__find_equal<altitude::TileKey>((uint64_t)v8, &v26, (unsigned int *)a2);
    uint64_t v16 = *v15;
    if (!*v15)
    {
      unint64_t v17 = v15;
      uint64_t v16 = (uint64_t)operator new(0x50uLL);
      long long v18 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v16 + 32) = *(_OWORD *)a2;
      *(_OWORD *)(v16 + 48) = v18;
      *(void *)(v16 + 64) = 0;
      *(void *)(v16 + 72) = 0;
      uint64_t v19 = v26;
      *(void *)uint64_t v16 = 0;
      *(void *)(v16 + 8) = 0;
      *(void *)(v16 + 16) = v19;
      uint64_t *v17 = v16;
      uint64_t v20 = (void *)**v8;
      unint64_t v21 = (uint64_t *)v16;
      if (v20)
      {
        *uint64_t v8 = v20;
        unint64_t v21 = (uint64_t *)*v17;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*v10, v21);
      ++a1[10];
    }
    if (v13) {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unsigned int v22 = *(std::__shared_weak_count **)(v16 + 72);
    *(void *)(v16 + 64) = v14;
    *(void *)(v16 + 72) = v13;
    if (v22 && !atomic_fetch_add(&v22->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
      std::__shared_weak_count::__release_weak(v22);
    }
    unint64_t v23 = a1[6];
    if (v23)
    {
      unsigned int v24 = *a4;
      __int16 v25 = (std::__shared_weak_count *)a4[1];
      uint64_t v26 = v24;
      unint64_t v27 = v25;
      if (v25)
      {
        atomic_fetch_add_explicit(&v25->__shared_owners_, 1uLL, memory_order_relaxed);
        karo::JobManager::queueJob(v23, &v26);
        if (!atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      else
      {
        karo::JobManager::queueJob(v23, &v26);
      }
    }
  }
  else
  {
    uint64_t v12 = v9[8];
    uint64_t v11 = v9[9];
    if (v11) {
      atomic_fetch_add_explicit(v11 + 1, 1uLL, memory_order_relaxed);
    }
    *a4 = v12;
    a4[1] = v11;
  }
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,karo::AsyncRequestManagerNoArgs>::requestT@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, uint64_t a4@<X3>, unsigned int a5@<W4>, char a6@<W5>, uint64_t a7@<X6>, void *a8@<X8>)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a3) {
    a3 = *(_DWORD *)(a1 + 88) + 1;
  }
  (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, a2, a7);
  uint64_t v16 = v22;
  unsigned int v17 = atomic_load(v22 + 4);
  if (v17 != a4) {
    (*(void (**)(unsigned int *, uint64_t))(*(void *)v22 + 24))(v22, a4);
  }
  v16[45] = a3;
  v16[46] = a5;
  *((unsigned char *)v16 + 176) = a6;
  long long v18 = v22;
  uint64_t v19 = v23;
  *a8 = off_1EF5677B0;
  a8[1] = v18;
  a8[2] = v19;
  if (v19)
  {
    atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
    long long v18 = (unsigned int *)a8[1];
  }
  if (v18) {
    atomic_fetch_add((atomic_uint *volatile)v18 + 32, 1u);
  }
  uint64_t v20 = v23;
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
    std::__shared_weak_count::__release_weak(v20);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,karo::AsyncRequestManagerNoArgs>::requestT(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  if (!a4) {
    a4 = *(_DWORD *)(a1 + 88) + 1;
  }
  uint64_t v8 = *a2;
  uint64_t v9 = a2[1];
  if (*a2 != v9)
  {
    do
    {
      uint64_t v10 = v8 + 32;
      (*(void (**)(unsigned int **__return_ptr, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 96))(&v22, a1, v8, v8 + 32);
      uint64_t v11 = v22;
      int v12 = *(_DWORD *)(v8 + 36);
      unsigned int v13 = *(_DWORD *)(v8 + 40);
      char v14 = *(unsigned char *)(v8 + 44);
      unsigned int v15 = atomic_load(v22 + 4);
      if (v15 != v12) {
        (*(void (**)(unsigned int *))(*(void *)v22 + 24))(v22);
      }
      v11[45] = a4;
      v11[46] = v13;
      *((unsigned char *)v11 + 176) = v14;
      uint64_t v16 = *(void **)(a3 + 8);
      if ((unint64_t)v16 >= *(void *)(a3 + 16))
      {
        uint64_t v19 = std::vector<karo::AsyncRequestManager::RequestHandle>::__emplace_back_slow_path<std::shared_ptr<karo::AsyncRequestManager::Request> &>((void **)a3, (uint64_t)v22, (uint64_t)v23);
      }
      else
      {
        void *v16 = off_1EF5677B0;
        unsigned int v17 = v22;
        v16[1] = v22;
        uint64_t v18 = (uint64_t)v23;
        v16[2] = v23;
        if (v18)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v18 + 8), 1uLL, memory_order_relaxed);
          unsigned int v17 = (unsigned int *)v16[1];
        }
        if (v17) {
          atomic_fetch_add((atomic_uint *volatile)v17 + 32, 1u);
        }
        uint64_t v19 = v16 + 3;
      }
      *(void *)(a3 + 8) = v19;
      uint64_t v20 = v23;
      if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
        std::__shared_weak_count::__release_weak(v20);
      }
      uint64_t v8 = v10 + 16;
    }
    while (v10 + 16 != v9);
  }
  return pthread_mutex_unlock(*(pthread_mutex_t **)(a1 + 40));
}

void altitude::DtmRequestManager::createRequest()
{
}

uint64_t std::__shared_ptr_pointer<altitude::DtmRequest *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::DtmRequest>,std::allocator<altitude::DtmRequest>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__shared_ptr_pointer<altitude::DtmRequest *,std::shared_ptr<karo::AsyncRequestManager::Request>::__shared_ptr_default_delete<karo::AsyncRequestManager::Request,altitude::DtmRequest>,std::allocator<altitude::DtmRequest>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void karo::AsyncRequestManagerTemplate<altitude::TileKey,karo::AsyncRequestManagerNoArgs>::createAndQueueRequest(void *a1@<X0>, uint64_t *a2@<X8>)
{
  (*(void (**)(void *))(*a1 + 64))(a1);
  unint64_t v4 = a1[6];
  if (v4)
  {
    uint64_t v5 = *a2;
    uint64_t v6 = (std::__shared_weak_count *)a2[1];
    v7[0] = v5;
    v7[1] = v6;
    if (v6)
    {
      atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
      karo::JobManager::queueJob(v4, v7);
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
    else
    {
      karo::JobManager::queueJob(v4, v7);
    }
  }
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,karo::AsyncRequestManagerNoArgs>::clearRequest(uint64_t a1, unsigned int *a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = (uint64_t **)(a1 + 64);
  uint64_t v5 = (uint64_t *)std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::find<altitude::TileKey>(a1 + 64, a2);
  if ((uint64_t *)(a1 + 72) != v5)
  {
    uint64_t v6 = v5;
    (*(void (**)(uint64_t))(*(void *)v5[8] + 16))(v5[8]);
    uint64_t v7 = (uint64_t *)v6[1];
    if (v7)
    {
      do
      {
        uint64_t v8 = v7;
        uint64_t v7 = (uint64_t *)*v7;
      }
      while (v7);
    }
    else
    {
      uint64_t v9 = v6;
      do
      {
        uint64_t v8 = (uint64_t *)v9[2];
        BOOL v10 = *v8 == (void)v9;
        uint64_t v9 = v8;
      }
      while (!v10);
    }
    if (*v4 == v6) {
      void *v4 = v8;
    }
    uint64_t v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v6);
    int v12 = (std::__shared_weak_count *)v6[9];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v6);
  }
  unsigned int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,karo::AsyncRequestManagerNoArgs>::removeFromRequests(uint64_t a1, uint64_t a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    uint64_t v5 = *(uint64_t **)(a1 + 64);
    while (1)
    {
      uint64_t v6 = (uint64_t *)v5[1];
      if (v5[8] == a2) {
        break;
      }
      if (v6)
      {
        do
        {
          uint64_t v7 = v6;
          uint64_t v6 = (uint64_t *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          uint64_t v7 = (uint64_t *)v5[2];
          BOOL v8 = *v7 == (void)v5;
          uint64_t v5 = v7;
        }
        while (!v8);
      }
      uint64_t v5 = v7;
      if (v7 == (uint64_t *)(a1 + 72)) {
        goto LABEL_23;
      }
    }
    if (v6)
    {
      do
      {
        uint64_t v9 = v6;
        uint64_t v6 = (uint64_t *)*v6;
      }
      while (v6);
    }
    else
    {
      BOOL v10 = v5;
      do
      {
        uint64_t v9 = (uint64_t *)v10[2];
        BOOL v8 = *v9 == (void)v10;
        BOOL v10 = v9;
      }
      while (!v8);
    }
    if (v4 == v5) {
      *(void *)(a1 + 64) = v9;
    }
    uint64_t v11 = *(uint64_t **)(a1 + 72);
    --*(void *)(a1 + 80);
    std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v11, v5);
    int v12 = (std::__shared_weak_count *)v5[9];
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    operator delete(v5);
  }
LABEL_23:
  unsigned int v13 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v13);
}

uint64_t karo::AsyncRequestManagerTemplate<altitude::TileKey,karo::AsyncRequestManagerNoArgs>::pruneRequests(uint64_t a1, int a2)
{
  pthread_mutex_lock(*(pthread_mutex_t **)(a1 + 40));
  unint64_t v4 = *(uint64_t **)(a1 + 64);
  if (v4 != (uint64_t *)(a1 + 72))
  {
    do
    {
      uint64_t v5 = (uint64_t *)v4[1];
      uint64_t v6 = v4;
      if (v5)
      {
        do
        {
          uint64_t v7 = v5;
          uint64_t v5 = (uint64_t *)*v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          uint64_t v7 = (uint64_t *)v6[2];
          BOOL v8 = *v7 == (void)v6;
          uint64_t v6 = v7;
        }
        while (!v8);
      }
      uint64_t v9 = v4[8];
      if (atomic_load((unsigned int *)(v9 + 128))) {
        *(_DWORD *)(v9 + 180) = a2;
      }
      pthread_mutex_lock(*(pthread_mutex_t **)(v9 + 152));
      int v11 = *(_DWORD *)(v9 + 160);
      pthread_mutex_unlock(*(pthread_mutex_t **)(v9 + 152));
      if ((v11 & 1) != 0 && *(unsigned char *)(v9 + 176) && *(_DWORD *)(v9 + 180) != a2
        || (a2 - *(_DWORD *)(v9 + 180)) > *(_DWORD *)(v9 + 184))
      {
        (*(void (**)(uint64_t))(*(void *)v9 + 16))(v9);
        int v12 = (uint64_t *)v4[1];
        unsigned int v13 = v4;
        if (v12)
        {
          do
          {
            char v14 = v12;
            int v12 = (uint64_t *)*v12;
          }
          while (v12);
        }
        else
        {
          do
          {
            char v14 = (uint64_t *)v13[2];
            BOOL v8 = *v14 == (void)v13;
            unsigned int v13 = v14;
          }
          while (!v8);
        }
        if (*(uint64_t **)(a1 + 64) == v4) {
          *(void *)(a1 + 64) = v14;
        }
        unsigned int v15 = *(uint64_t **)(a1 + 72);
        --*(void *)(a1 + 80);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v15, v4);
        uint64_t v16 = (std::__shared_weak_count *)v4[9];
        if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
          std::__shared_weak_count::__release_weak(v16);
        }
        operator delete(v4);
      }
      unint64_t v4 = v7;
    }
    while (v7 != (uint64_t *)(a1 + 72));
  }
  *(_DWORD *)(a1 + 88) = a2;
  unsigned int v17 = *(pthread_mutex_t **)(a1 + 40);
  return pthread_mutex_unlock(v17);
}

void altitude::DtmRequestManager::~DtmRequestManager(altitude::DtmRequestManager *this)
{
  *(void *)this = &unk_1EF567CE8;
  while (*((void *)this + 10))
    (*(void (**)(altitude::DtmRequestManager *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF567CE8;
  while (*((void *)this + 10))
    (*(void (**)(altitude::DtmRequestManager *, uint64_t))(*(void *)this + 48))(this, *((void *)this + 8) + 32);
  std::__tree<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::__map_value_compare<altitude::TileKey,std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>,std::less<altitude::TileKey>,true>,std::allocator<std::__value_type<altitude::TileKey,std::shared_ptr<karo::AsyncRequestManager::Request>>>>::destroy(*((void **)this + 9));
  karo::AsyncRequestManager::~AsyncRequestManager(this);
}

void karo::graphics::Viewport::~Viewport(void **this)
{
  *this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
  JUMPOUT(0x1A6239270);
}

{
  *this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

double karo::graphics::Viewport::computeWindowMatrix(karo::graphics::Viewport *this, uint64_t a2)
{
  long long v21 = 0u;
  uint64_t v23 = 0;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v22 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  uint64_t v18 = 0x3FF0000000000000;
  *(void *)&long long v21 = 0x3FF0000000000000;
  uint64_t v24 = 0x3FF0000000000000;
  uint64_t v27 = 0x3FF0000000000000;
  long long v31 = 0u;
  uint64_t v33 = 0;
  long long v32 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  double v28 = 1.0;
  *(void *)&long long v31 = 0x3FF0000000000000;
  uint64_t v34 = 0x3FF0000000000000;
  *(void *)uint64_t v35 = 0;
  uint64_t v13 = *(void *)(a2 + 40);
  v4.i64[0] = (int)v13;
  v4.i64[1] = SHIDWORD(v13);
  *(float64x2_t *)&v35[8] = vcvtq_f64_s64(v4);
  *(_OWORD *)&v35[24] = xmmword_1A28FCCC0;
  gm::operator*<double,4,4,4>(v16, (double *)&v18, &v28);
  double v5 = (double)(*(_DWORD *)(a2 + 48) - (int)v13) * 0.5;
  double v6 = (double)(*(_DWORD *)(a2 + 52) - HIDWORD(v13)) * -0.5;
  long long v31 = 0u;
  uint64_t v33 = 0;
  memset(v35, 0, 32);
  long long v32 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  double v28 = v5;
  *(double *)&long long v31 = v6;
  *(void *)&v35[32] = 0x3FF0000000000000;
  uint64_t v34 = 0x3FE0000000000000;
  gm::operator*<double,4,4,4>(v15, (double *)&v18, &v28);
  gm::operator*<double,4,4,4>(v17, v16, v15);
  long long v31 = 0u;
  uint64_t v33 = 0;
  long long v32 = 0u;
  long long v30 = 0u;
  long long v29 = 0u;
  double v28 = 1.0;
  *(void *)&long long v31 = 0x3FF0000000000000;
  uint64_t v34 = 0x3FF0000000000000;
  *(void *)uint64_t v35 = 0;
  __asm { FMOV            V1.2D, #1.0 }
  *(_OWORD *)&v35[8] = xmmword_1A28FCBC0;
  *(_OWORD *)&v35[24] = _Q1;
  gm::operator*<double,4,4,4>(v14, (double *)&v18, &v28);
  return gm::operator*<double,4,4,4>((double *)this, v17, v14);
}

gdc::LayerDataCollector **std::unique_ptr<gdc::LayerDataCollector>::~unique_ptr[abi:nn180100](gdc::LayerDataCollector **a1)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    gdc::LayerDataCollector::~LayerDataCollector(v2);
    MEMORY[0x1A6239270]();
  }
  return a1;
}

void ggl::GlyphWithNormalHalo::DefaultPipelineState::~DefaultPipelineState(ggl::GlyphWithNormalHalo::DefaultPipelineState *this)
{
  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int64x2_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  uint64_t v3;
  std::__shared_weak_count *v4;

  *(void *)this = &unk_1EF55B208;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 7);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v3 = *((void *)this + 1);
  if (v3)
  {
    (*(void (**)(uint64_t, void))(*(void *)v3 + 16))(v3, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  int64x2_t v4 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v4)
  {
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
}

void ggl::GlyphWithNormalHalo::DefaultPipelineSetup::~DefaultPipelineSetup(ggl::GlyphWithNormalHalo::DefaultPipelineSetup *this)
{
  ggl::PipelineSetup::~PipelineSetup(this);
  JUMPOUT(0x1A6239270);
}

void non-virtual thunk to'altitude::View::~View(altitude::View *this)
{
  *((void *)this - 8) = &unk_1EF5681C8;
  *((void *)this - 13) = &unk_1EF567F78;
  if (*((char *)this - 73) < 0) {
    operator delete(*((void **)this - 12));
  }
  JUMPOUT(0x1A6239270);
}

{
  *((void *)this - 8) = &unk_1EF5681C8;
  *((void *)this - 13) = &unk_1EF567F78;
  if (*((char *)this - 73) < 0) {
    operator delete(*((void **)this - 12));
  }
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF5681C8;
  *((void *)this - 5) = &unk_1EF567F78;
  if (*((char *)this - 9) < 0) {
    operator delete(*((void **)this - 4));
  }
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF5681C8;
  *((void *)this - 5) = &unk_1EF567F78;
  if (*((char *)this - 9) < 0) {
    operator delete(*((void **)this - 4));
  }
}

void altitude::View::~View(altitude::View *this)
{
  *((void *)this + 5) = &unk_1EF5681C8;
  *(void *)this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
  JUMPOUT(0x1A6239270);
}

{
  *((void *)this + 5) = &unk_1EF5681C8;
  *(void *)this = &unk_1EF567F78;
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

uint64_t altitude::View::View(uint64_t a1, long long *a2, uint64_t a3)
{
  *(void *)a1 = &unk_1EF567F78;
  double v5 = (std::string *)(a1 + 8);
  if (*((char *)a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v5, *(const std::string::value_type **)a2, *((void *)a2 + 1));
  }
  else
  {
    long long v6 = *a2;
    v5->__r_.__value_.__r.__words[2] = *((void *)a2 + 2);
    *(_OWORD *)&v5->__r_.__value_.__l.__data_ = v6;
  }
  *(void *)(a1 + 32) = a3;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(void *)(a1 + 96) = 0x3FF0000000000000;
  *(_DWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(void *)(a1 + 120) = 0x3FF0000000000000;
  *(void *)(a1 + 160) = 0x3FF0000000000000;
  *(void *)(a1 + 200) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 256) = 0u;
  *(_OWORD *)(a1 + 272) = 0u;
  *(_OWORD *)(a1 + 288) = 0u;
  *(_OWORD *)(a1 + 304) = 0u;
  *(_OWORD *)(a1 + 320) = 0u;
  *(_OWORD *)(a1 + 336) = 0u;
  __asm { FMOV            V1.2D, #1.0 }
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = _Q1;
  *(void *)(a1 + 288) = 0x3FF0000000000000;
  *(void *)(a1 + 328) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 384) = 0u;
  *(_OWORD *)(a1 + 400) = 0u;
  *(_OWORD *)(a1 + 416) = 0u;
  *(_OWORD *)(a1 + 432) = 0u;
  *(_OWORD *)(a1 + 448) = 0u;
  *(_OWORD *)(a1 + 464) = 0u;
  *(_OWORD *)(a1 + 480) = 0u;
  *(_OWORD *)(a1 + 352) = 0u;
  *(_OWORD *)(a1 + 368) = _Q1;
  *(void *)(a1 + 416) = 0x3FF0000000000000;
  *(void *)(a1 + 456) = 0x3FF0000000000000;
  *(void *)(a1 + 496) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 944) = xmmword_1A28FD590;
  *(_OWORD *)(a1 + 960) = xmmword_1A28FCBC0;
  *(_OWORD *)(a1 + 976) = xmmword_1A28FCC30;
  *(_OWORD *)(a1 + 992) = xmmword_1A28FD5A0;
  *(void *)(a1 + 1008) = 0xBFF0000000000000;
  *(unsigned char *)(a1 + 1016) = 0;
  *(_OWORD *)(a1 + 1072) = 0u;
  *(_OWORD *)(a1 + 1104) = 0u;
  *(_OWORD *)(a1 + 1136) = 0u;
  *(_OWORD *)(a1 + 1120) = 0u;
  *(_OWORD *)(a1 + 1088) = 0u;
  *(_OWORD *)(a1 + 1056) = 0u;
  *(_OWORD *)(a1 + 1040) = 0u;
  *(void *)(a1 + 1032) = 0x3FF0000000000000;
  *(void *)(a1 + 1072) = 0x3FF0000000000000;
  *(void *)(a1 + 1112) = 0x3FF0000000000000;
  *(_OWORD *)(a1 + 1232) = 0u;
  *(_OWORD *)(a1 + 1200) = 0u;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(_OWORD *)(a1 + 1216) = 0u;
  *(_OWORD *)(a1 + 1248) = 0u;
  *(_OWORD *)(a1 + 1264) = 0u;
  *(_OWORD *)(a1 + 1152) = _Q1;
  *(void *)(a1 + 1200) = 0x3FF0000000000000;
  *(void *)(a1 + 1240) = 0x3FF0000000000000;
  *(void *)(a1 + 1280) = 0x3FF0000000000000;
  *(void *)a1 = &unk_1EF56B320;
  *(void *)(a1 + 40) = &unk_1EF56B358;
  *(void *)(a1 + 104) = &unk_1EF56B388;
  *(unsigned char *)(a1 + 1292) = 0;
  *(_DWORD *)(a1 + 1288) = 0;
  *(void *)(a1 + 1296) = 2;
  *(_OWORD *)(a1 + 1304) = xmmword_1A28FD5B0;
  *(void *)(a1 + 1388) = 0xFF00000000;
  *(_OWORD *)(a1 + 1432) = 0u;
  *(_OWORD *)(a1 + 1448) = 0u;
  *(_OWORD *)(a1 + 1400) = 0u;
  *(_OWORD *)(a1 + 1416) = 0u;
  return a1;
}

double altitude::View::updatePoints(uint64_t a1, double *a2)
{
  double v4 = a2[1];
  double v5 = a2[2];
  __double2 v6 = __sincos_stret(*a2);
  double v7 = 6378137.0 / sqrt(v6.__sinval * v6.__sinval * -0.00669437999 + 1.0);
  double v8 = (v7 + v5) * v6.__cosval;
  __double2 v9 = __sincos_stret(v4);
  double v10 = v8 * v9.__cosval;
  double v11 = v8 * v9.__sinval;
  double v12 = (v5 + v7 * 0.99330562) * v6.__sinval;
  uint64_t v13 = *(void *)(a1 + 40);
  a1 += 40;
  char v14 = (double *)(*(uint64_t (**)(uint64_t))(v13 + 24))(a1);
  double v15 = v14[4];
  double v16 = v14[5];
  double v17 = v14[6];
  double v19 = v14[2];
  double v18 = v14[3];
  double v20 = v14[1];
  double v21 = -(*v14 * v16 - v19 * v18);
  double v22 = -(v20 * v18 - *v14 * v15);
  double v23 = -(v19 * v15 - v20 * v16) - (v19 * v15 - v20 * v16);
  double v24 = v21 + v21;
  double v25 = v22 + v22;
  double v26 = -(v15 * v12 - v16 * v11) - (v15 * v12 - v16 * v11);
  double v27 = -(v16 * v10 - v18 * v12) - (v16 * v10 - v18 * v12);
  double v28 = -(v18 * v11 - v15 * v10) - (v18 * v11 - v15 * v10);
  double v29 = v10 - *v14 + v26 * v17 + v27 * v16 + v25 * v15 - (v28 * v15 + v23 * v17 + v24 * v16);
  double v30 = v11 - v20 + v28 * v18 + v27 * v17 + v23 * v16 - (v26 * v16 + v24 * v17 + v25 * v18);
  double v31 = v12 - v19 + v28 * v17 + v26 * v15 + v24 * v18 - (v27 * v18 + v23 * v15 + v25 * v17);
  *(double *)(a1 + 1360) = v29;
  *(double *)(a1 + 1368) = v30;
  *(double *)(a1 + 1376) = v31;
  *(double *)(a1 + 1384) = v29;
  *(double *)(a1 + 1392) = v30;
  *(double *)(a1 + 1400) = v31;
  *(_OWORD *)(a1 + 1288) = *(_OWORD *)a2;
  GEOMetersPerDegreeAtLatitude();
  *(float *)&double v32 = v32 * 57.2957795;
  *(_DWORD *)(a1 + 1304) = LODWORD(v32);
  uint64_t v33 = (double *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 24))(a1);
  double result = sqrt(*v33 * *v33 + v33[1] * v33[1] + v33[2] * v33[2]) - sqrt(v10 * v10 + v11 * v11 + v12 * v12);
  *(double *)(a1 + 1408) = result;
  return result;
}

void md::LabelFeatureCreationParams::~LabelFeatureCreationParams(md::LabelFeatureCreationParams *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 13);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

uint64_t std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(result, *a2);
    std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(v3, a2[1]);
    double v4 = (std::__shared_weak_count *)a2[5];
    if (v4) {
      std::__shared_weak_count::__release_weak(v4);
    }
    double v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_1,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF579458;
}

void *std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_1,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_1>,void ()(void)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1EF579458;
  return result;
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_1,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_0,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_0>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsTileDecode", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_0,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF579410;
}

void *std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_0,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_0>,void ()(void)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1EF579410;
  return result;
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_0,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<geo::codec::VectorTile> const&,md::LabelTileType,std::shared_ptr<md::LabelManager> const&,BOOL,std::shared_ptr<md::LabelSelectedFeatureInfo>,md::mun::MuninMetadata *)::$_0>,void ()(void)>::~__func()
{
}

void std::__shared_ptr_emplace<md::LabelSourceTile>::__on_zero_shared(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 48);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void std::__shared_ptr_emplace<md::LabelSourceTile>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FF40;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<md::LabelSourceTile>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF57FF40;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void md::LabelTile::LabelTile(uint64_t a1, uint64_t a2, unint64_t *a3, void *a4)
{
  uint64_t v307 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = *a4;
  uint64_t v8 = a4[1];
  *(void *)(a1 + 16) = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 16), 1uLL, memory_order_relaxed);
  }
  __double2 v9 = operator new(0x38uLL);
  v9[1] = 0;
  v9[2] = 0;
  v9[3] = 0;
  *__double2 v9 = &unk_1EF57FF40;
  unint64_t v11 = *a3;
  unint64_t v10 = a3[1];
  void v9[4] = 0;
  v9[5] = v11;
  v9[6] = v10;
  if (v10) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
  }
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 24) = v9 + 3;
  *(void *)(a1 + 32) = v9;
  {
    operator new();
  }
  uint64_t v12 = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 80) = 0;
  uint64_t v13 = a1 + 80;
  *(void *)(a1 + 56) = v12;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 40) = a1 + 48;
  {
    uint64_t v13 = a1 + 80;
    if (v251) {
      operator new();
    }
  }
  uint64_t v14 = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 112) = 0;
  uint64_t v15 = a1 + 112;
  *(void *)(a1 + 88) = v14;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 72) = v13;
  {
    uint64_t v15 = a1 + 112;
    if (v252) {
      operator new();
    }
  }
  uint64_t v16 = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 144) = 0;
  uint64_t v17 = a1 + 144;
  *(void *)(a1 + 120) = v16;
  *(void *)(a1 + 128) = 0;
  *(void *)(a1 + 104) = v15;
  {
    uint64_t v17 = a1 + 144;
    if (v253) {
      operator new();
    }
  }
  uint64_t v18 = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 176) = 0;
  uint64_t v19 = a1 + 176;
  *(void *)(a1 + 152) = v18;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 136) = v17;
  {
    uint64_t v19 = a1 + 176;
    if (v254) {
      operator new();
    }
  }
  uint64_t v20 = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 208) = 0;
  uint64_t v21 = a1 + 208;
  *(void *)(a1 + 184) = v20;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 168) = v19;
  {
    uint64_t v21 = a1 + 208;
    if (v255) {
      operator new();
    }
  }
  uint64_t v22 = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 216) = v22;
  *(void *)(a1 + 224) = 0;
  *(void *)(a1 + 200) = v21;
  {
    operator new();
  }
  *(void *)(a1 + 248) = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 256) = 0;
  float64x2_t v262 = (uint64_t **)(a1 + 240);
  *(void *)(a1 + 232) = a1 + 240;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = 0;
  *(_WORD *)(a1 + 288) = *(_WORD *)a2;
  *(void *)(a1 + 292) = *(void *)(a2 + 4);
  int v23 = 1 << *(unsigned char *)(a2 + 1);
  double v24 = 1.0 / (double)v23;
  double v25 = v24 * (double)*(int *)(a2 + 8);
  double v26 = v24 * (double)(v23 + ~*(_DWORD *)(a2 + 4));
  *(double *)(a1 + 312) = v25;
  *(double *)(a1 + 320) = v26;
  *(double *)(a1 + 328) = v25 + v24;
  *(double *)(a1 + 336) = v26 + v24;
  v303[0] = &unk_1EF579380;
  uint64_t v304 = v303;
  v301[0] = &unk_1EF5793C8;
  uint64_t v302 = v301;
  char v306 = v305;
  v305[0] = &unk_1EF5793C8;
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  double v27 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v27))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v27, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsTileDecode", "", buf, 2u);
  }

  if (v302 == v301)
  {
    (*(void (**)(void *))(v301[0] + 32))(v301);
  }
  else if (v302)
  {
    (*(void (**)(void))(*v302 + 40))();
  }
  char v260 = (void **)(a1 + 232);
  if (v304 == v303)
  {
    (*(void (**)(void *))(v303[0] + 32))(v303);
  }
  else if (v304)
  {
    (*(void (**)(void))(*v304 + 40))();
  }
  uint64_t v28 = *(void *)(*a4 + 288);
  md::LabelFeaturePool::prepareAddFeaturesForTile(v28, (unint64_t **)(a1 + 24));
  long long v276 = 0uLL;
  v278[16] = 0;
  *(_DWORD *)&v278[20] = 0;
  *(_WORD *)&v278[24] = 256;
  v278[26] = 0;
  uint64_t v279 = 0;
  uint64_t v280 = 0;
  long long v29 = *(_OWORD *)(a1 + 328);
  long long v277 = *(_OWORD *)(a1 + 312);
  *(_OWORD *)uint64_t v278 = v29;
  *(void *)long long buf = *a4;
  uint64_t v275 = *(void *)(a1 + 304);
  long long v274 = *(_OWORD *)(a1 + 288);
  unsigned __int8 v30 = atomic_load((unsigned __int8 *)(*(void *)buf + 3392));
  v278[24] = v30 & 1;
  v278[16] = *(unsigned char *)(a1 + 289);
  unsigned __int8 v31 = atomic_load((unsigned __int8 *)(*a4 + 3622));
  if (v31)
  {
    uint64_t v33 = *(void *)(*a3 + 24);
    uint64_t v32 = *(void *)(*a3 + 32);
    if (v33 != v32)
    {
      uint64_t v256 = *(void *)buf;
      uint64_t v265 = *(void *)buf;
      __int16 v266 = v274;
      uint64_t v267 = *(void *)((char *)&v274 + 4);
      long long v268 = v276;
      long long v269 = v277;
      *(_OWORD *)uint64_t v270 = *(_OWORD *)v278;
      *(_OWORD *)&v270[11] = *(_OWORD *)&v278[11];
      uint64_t v271 = v279;
      uint64_t v272 = v280;
      std::mutex::lock((std::mutex *)v28);
      uint64_t v34 = std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)(v28 + 456), *a3);
      if (v34)
      {
        uint64_t v35 = v34;
        std::mutex::unlock((std::mutex *)v28);
        uint64_t v283 = 0;
        uint64_t v284 = 0;
        unint64_t v285 = 0;
        {
          operator new();
        }
        uint64_t v286 = mdm::Allocator::instance(void)::alloc;
        unint64_t v36 = v283;
        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v285 - (void)v283) >> 3) <= 0x1F)
        {
          uint64_t v37 = v284;
          uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                     + 16))(mdm::Allocator::instance(void)::alloc, 768, 8);
          uint64_t v40 = v283;
          uint64_t v39 = v284;
          uint64_t v41 = (char *)(v38 + 24 * ((v37 - v36) / 24));
          if (v284 != v283)
          {
            do
            {
              long long v42 = *(_OWORD *)(v39 - 24);
              *((void *)v41 - 1) = *((void *)v39 - 1);
              *(_OWORD *)(v41 - 24) = v42;
              v41 -= 24;
              v39 -= 24;
            }
            while (v39 != v40);
            uint64_t v39 = v283;
          }
          uint64_t v283 = v41;
          uint64_t v284 = (char *)(v38 + 24 * ((v37 - v36) / 24));
          unint64_t v43 = v285;
          unint64_t v285 = v38 + 768;
          if (v39) {
            (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v286 + 40))(v286, v39, v43 - (void)v39);
          }
        }
        uint64_t v44 = *(void **)(*a3 + 24);
        std::mutex::lock((std::mutex *)v28);
        if (v32 == v33)
        {
LABEL_471:
          if (v283 != v284)
          {
            md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v256 + 296), &v283, 1u, 1, *(void *)(*(void *)(v256 + 152) + 32));
            uint64_t v284 = v283;
            std::mutex::unlock((std::mutex *)v28);
            if (!v28) {
              goto LABEL_492;
            }
            std::mutex::lock((std::mutex *)v28);
          }
          std::mutex::unlock((std::mutex *)v28);
          if (v283)
          {
            uint64_t v284 = v283;
            (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v286 + 40))(v286, v283, v285 - (void)v283);
          }
          uint64_t v249 = v272;
          if (v272 && !atomic_fetch_add(&v272->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v249->__on_zero_shared)(v249);
            std::__shared_weak_count::__release_weak(v249);
          }
          goto LABEL_481;
        }
        uint64_t v45 = 0;
        if ((unint64_t)((v32 - v33) / 56) <= 1) {
          uint64_t v46 = 1;
        }
        else {
          uint64_t v46 = (v32 - v33) / 56;
        }
        long long v258 = (void *)(v28 + 312);
        uint64_t v259 = v46;
        float v257 = v35 + 34;
        while (1)
        {
          {
            operator new();
          }
          uint64_t v47 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                     + 16))(mdm::Allocator::instance(void)::alloc, 104, 8);
          *(_OWORD *)(v47 + 16) = 0u;
          uint64_t v48 = v47 + 16;
          *(void *)uint64_t v47 = 1;
          *(void *)(v47 + 8) = &unk_1EF5372F0;
          *(_OWORD *)(v47 + 32) = 0u;
          unint64_t v49 = (void *)(v47 + 32);
          *(void *)(v47 + 48) = 0;
          {
            operator new();
          }
          *(void *)(v47 + 56) = mdm::Allocator::instance(void)::alloc;
          uint64_t v50 = (std::__shared_weak_count *)v44[1];
          if (v50 && (uint64_t v50 = std::__shared_weak_count::lock(v50)) != 0) {
            uint64_t v51 = *v44;
          }
          else {
            uint64_t v51 = 0;
          }
          *(void *)(v47 + 64) = v44;
          *(void *)(v47 + 72) = v51;
          *(void *)(v47 + 80) = v50;
          *(void *)(v47 + 88) = 0;
          *(unsigned char *)(v47 + 96) = 0;
          unint64_t v52 = *(void **)(v47 + 40);
          unint64_t v53 = *(void *)(v47 + 48);
          uint64_t v264 = v44;
          if ((unint64_t)v52 >= v53)
          {
            unint64_t v55 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v52 - *v49) >> 3);
            unint64_t v56 = v55 + 1;
            if (v55 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            if (0x5555555555555556 * ((uint64_t)(v53 - *v49) >> 3) > v56) {
              unint64_t v56 = 0x5555555555555556 * ((uint64_t)(v53 - *v49) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v53 - *v49) >> 3) >= 0x555555555555555) {
              uint64_t v57 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              uint64_t v57 = v56;
            }
            if (v57)
            {
              uint64_t v58 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v47 + 56) + 16))(*(void *)(v47 + 56), 24 * v57, 8);
              uint64_t v59 = v58 + 24 * v55;
              uint64_t v60 = v58 + 24 * v57;
              if (v58)
              {
                *(_OWORD *)uint64_t v59 = *(_OWORD *)(v47 + 64);
                uint64_t v61 = *(void *)(v47 + 80);
                *(void *)(v58 + 24 * v55 + 16) = v61;
                if (v61) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v61 + 8), 1uLL, memory_order_relaxed);
                }
              }
            }
            else
            {
              uint64_t v60 = 0;
              uint64_t v59 = 8 * (((uint64_t)v52 - *v49) >> 3);
            }
            uint64_t v54 = (void *)(v59 + 24);
            uint64_t v62 = *(void *)(v47 + 32);
            uint64_t v48 = *(void *)(v47 + 40);
            if (v48 == v62)
            {
              *(void *)(v47 + 32) = v59;
              *(void *)(v47 + 40) = v54;
              uint64_t v65 = *(void *)(v47 + 48);
              *(void *)(v47 + 48) = v60;
              if (!v48) {
                goto LABEL_72;
              }
LABEL_71:
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v47 + 56) + 40))(*(void *)(v47 + 56), v48, v65 - v48);
              goto LABEL_72;
            }
            do
            {
              long long v63 = *(_OWORD *)(v48 - 24);
              v48 -= 24;
              *(_OWORD *)(v59 - 24) = v63;
              v59 -= 24;
              *(void *)(v59 + 16) = *(void *)(v48 + 16);
              *(void *)(v48 + 8) = 0;
              *(void *)(v48 + 16) = 0;
            }
            while (v48 != v62);
            uint64_t v48 = *(void *)(v47 + 32);
            uint64_t v64 = *(void *)(v47 + 40);
            *(void *)(v47 + 32) = v59;
            *(void *)(v47 + 40) = v54;
            uint64_t v65 = *(void *)(v47 + 48);
            *(void *)(v47 + 48) = v60;
            while (v64 != v48)
            {
              unint64_t v66 = *(std::__shared_weak_count **)(v64 - 8);
              if (v66 && !atomic_fetch_add(&v66->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v66->__on_zero_shared)(v66);
                std::__shared_weak_count::__release_weak(v66);
              }
              v64 -= 24;
            }
            uint64_t v44 = v264;
            if (v48) {
              goto LABEL_71;
            }
          }
          else
          {
            if (v52)
            {
              *unint64_t v52 = v44;
              v52[1] = v51;
              v52[2] = v50;
              if (v50) {
                atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
              }
            }
            uint64_t v54 = v52 + 3;
          }
LABEL_72:
          *(void *)(v47 + 40) = v54;
          double v287 = (void *)v47;
          unint64_t v67 = *(unsigned __int8 *)(v47 + 96);
          uint64_t v68 = *(void *)(*(void *)(v47 + 64) + 16);
          unint64_t v69 = (v68 + (v67 << 6) + (v67 >> 2) - 0x61C8864680B583EBLL) ^ v67;
          unint64_t v70 = *(void *)(v28 + 296);
          uint64_t v263 = v45;
          if (v70)
          {
            uint8x8_t v71 = (uint8x8_t)vcnt_s8((int8x8_t)v70);
            v71.i16[0] = vaddlv_u8(v71);
            if (v71.u32[0] > 1uLL)
            {
              uint64_t v48 = (v68 + (v67 << 6) + (v67 >> 2) - 0x61C8864680B583EBLL) ^ v67;
              if (v69 >= v70) {
                uint64_t v48 = v69 % v70;
              }
            }
            else
            {
              uint64_t v48 = v69 & (v70 - 1);
            }
            BOOL v72 = *(void **)(*(void *)(v28 + 288) + 8 * v48);
            if (v72)
            {
              unint64_t v73 = (void *)*v72;
              if (*v72)
              {
                if (v71.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v77 = v73[1];
                    if (v77 == v69)
                    {
                      unint64_t v75 = (void *)v73[2];
                      uint64_t v78 = v75 + 1;
                      if (!v75) {
                        uint64_t v78 = 0;
                      }
                      if (*((unsigned __int8 *)v78 + 88) == v67 && *(void *)(v78[7] + 16) == v68) {
                        goto LABEL_98;
                      }
                    }
                    else if ((v77 & (v70 - 1)) != v48)
                    {
                      goto LABEL_110;
                    }
                    unint64_t v73 = (void *)*v73;
                    if (!v73) {
                      goto LABEL_110;
                    }
                  }
                }
                do
                {
                  unint64_t v74 = v73[1];
                  if (v74 == v69)
                  {
                    unint64_t v75 = (void *)v73[2];
                    uint64_t v76 = v75 + 1;
                    if (!v75) {
                      uint64_t v76 = 0;
                    }
                    if (*((unsigned __int8 *)v76 + 88) == v67 && *(void *)(v76[7] + 16) == v68)
                    {
LABEL_98:
                      v270[25] = 0;
                      if (v75) {
                        ++*v75;
                      }
                      BOOL v79 = (*(void *)v47)-- == 1;
                      if (v79)
                      {
                        md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>::~LabelFeatureThunk(v47 + 8);
                        {
                          operator new();
                        }
                        (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                           + 40))(mdm::Allocator::instance(void)::alloc, v287, 104);
                        unint64_t v75 = (void *)v73[2];
                      }
                      double v287 = v75;
                      if (v75) {
                        uint64_t v80 = v75 + 1;
                      }
                      else {
                        uint64_t v80 = 0;
                      }
                      uint64_t v81 = (std::mutex *)(v80[1] + 8);
                      std::mutex::lock(v81);
                      unint64_t v82 = (std::__shared_weak_count *)v44[1];
                      if (v82)
                      {
                        uint64_t v83 = std::__shared_weak_count::lock(v82);
                        if (v83)
                        {
                          uint64_t v84 = *v44;
                          goto LABEL_420;
                        }
                      }
                      else
                      {
                        uint64_t v83 = 0;
                      }
                      uint64_t v84 = 0;
LABEL_420:
                      *(void *)&long long v295 = v44;
                      *((void *)&v295 + 1) = v84;
                      double v296 = v83;
                      long long v288 = 0uLL;
                      float v231 = (void *)v80[4];
                      unint64_t v232 = v80[5];
                      if ((unint64_t)v231 >= v232)
                      {
                        uint64_t v233 = v80[3];
                        unint64_t v234 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v231 - v233) >> 3);
                        unint64_t v235 = v234 + 1;
                        if (v234 + 1 > 0xAAAAAAAAAAAAAAALL) {
                          abort();
                        }
                        if (0x5555555555555556 * ((uint64_t)(v232 - v233) >> 3) > v235) {
                          unint64_t v235 = 0x5555555555555556 * ((uint64_t)(v232 - v233) >> 3);
                        }
                        if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v232 - v233) >> 3) >= 0x555555555555555) {
                          uint64_t v236 = 0xAAAAAAAAAAAAAAALL;
                        }
                        else {
                          uint64_t v236 = v235;
                        }
                        if (v236)
                        {
                          uint64_t v237 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v80[6] + 16))(v80[6], 24 * v236, 8);
                          uint64_t v238 = v237 + 24 * v234;
                          uint64_t v239 = v237 + 24 * v236;
                          if (v237)
                          {
                            *(_OWORD *)uint64_t v238 = v295;
                            *(void *)(v237 + 24 * v234 + 16) = v83;
                            *((void *)&v295 + 1) = 0;
                            double v296 = 0;
                          }
                        }
                        else
                        {
                          uint64_t v239 = 0;
                          uint64_t v238 = 8 * (((uint64_t)v231 - v233) >> 3);
                        }
                        uint64_t v240 = v238 + 24;
                        uint64_t v241 = v80[3];
                        uint64_t v242 = v80[4];
                        if (v242 == v241)
                        {
                          v80[3] = v238;
                          v80[4] = v240;
                          uint64_t v245 = v80[5];
                          void v80[5] = v239;
                        }
                        else
                        {
                          do
                          {
                            long long v243 = *(_OWORD *)(v242 - 24);
                            v242 -= 24;
                            *(_OWORD *)(v238 - 24) = v243;
                            v238 -= 24;
                            *(void *)(v238 + 16) = *(void *)(v242 + 16);
                            *(void *)(v242 + 8) = 0;
                            *(void *)(v242 + 16) = 0;
                          }
                          while (v242 != v241);
                          uint64_t v242 = v80[3];
                          uint64_t v244 = v80[4];
                          v80[3] = v238;
                          v80[4] = v240;
                          uint64_t v245 = v80[5];
                          void v80[5] = v239;
                          while (v244 != v242)
                          {
                            uint64_t v246 = *(std::__shared_weak_count **)(v244 - 8);
                            if (v246 && !atomic_fetch_add(&v246->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v246->__on_zero_shared)(v246);
                              std::__shared_weak_count::__release_weak(v246);
                            }
                            v244 -= 24;
                          }
                        }
                        if (v242) {
                          (*(void (**)(void, uint64_t, uint64_t))(*(void *)v80[6] + 40))(v80[6], v242, v245 - v242);
                        }
                        uint64_t v83 = v296;
                        v80[4] = v240;
                        if (!v83) {
                          goto LABEL_449;
                        }
                      }
                      else
                      {
                        if (v231)
                        {
                          *float v231 = v44;
                          v231[1] = v84;
                          v231[2] = v83;
                          *((void *)&v295 + 1) = 0;
                          double v296 = 0;
                          uint64_t v83 = 0;
                        }
                        v80[4] = v231 + 3;
                        if (!v83) {
                          goto LABEL_449;
                        }
                      }
                      if (!atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
                        std::__shared_weak_count::__release_weak(v83);
                      }
LABEL_449:
                      float v247 = (std::__shared_weak_count *)*((void *)&v288 + 1);
                      float v165 = v264;
                      if (*((void *)&v288 + 1)
                        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v288 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v247->__on_zero_shared)(v247);
                        std::__shared_weak_count::__release_weak(v247);
                      }
                      std::mutex::unlock(v81);
                      uint64_t v161 = v287;
                      uint64_t v248 = v287 + 1;
                      if (!v287) {
                        uint64_t v248 = 0;
                      }
                      md::LabelLineStore::addOverlayLine(*(void *)(v248[1] + 192), v264, (uint64_t)&v265);
                      goto LABEL_267;
                    }
                  }
                  else
                  {
                    if (v74 >= v70) {
                      v74 %= v70;
                    }
                    if (v74 != v48) {
                      break;
                    }
                  }
                  unint64_t v73 = (void *)*v73;
                }
                while (v73);
              }
            }
          }
LABEL_110:
          unint64_t v85 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v28 + 320) + 16))(*(void *)(v28 + 320), 24, 8);
          *(void *)&long long v295 = v85;
          *((void *)&v295 + 1) = v28 + 320;
          *unint64_t v85 = 0;
          v85[1] = v69;
          v85[2] = v47;
          if (v47) {
            ++*(void *)v47;
          }
          LOBYTE(v296) = 1;
          float v86 = (float)(unint64_t)(*(void *)(v28 + 328) + 1);
          float v87 = *(float *)(v28 + 336);
          if (!v70 || (float)(v87 * (float)v70) < v86)
          {
            BOOL v88 = (v70 & (v70 - 1)) != 0;
            if (v70 < 3) {
              BOOL v88 = 1;
            }
            unint64_t v89 = v88 | (2 * v70);
            unint64_t v90 = vcvtps_u32_f32(v86 / v87);
            if (v89 <= v90) {
              size_t prime = v90;
            }
            else {
              size_t prime = v89;
            }
            if (prime == 1)
            {
              size_t prime = 2;
            }
            else if ((prime & (prime - 1)) != 0)
            {
              size_t prime = std::__next_prime(prime);
            }
            unint64_t v70 = *(void *)(v28 + 296);
            if (prime <= v70)
            {
              if (prime < v70)
              {
                unint64_t v103 = vcvtps_u32_f32((float)*(unint64_t *)(v28 + 328) / *(float *)(v28 + 336));
                if (v70 < 3
                  || (uint8x8_t v104 = (uint8x8_t)vcnt_s8((int8x8_t)v70), v104.i16[0] = vaddlv_u8(v104), v104.u32[0] > 1uLL))
                {
                  unint64_t v103 = std::__next_prime(v103);
                }
                else
                {
                  uint64_t v105 = 1 << -(char)__clz(v103 - 1);
                  if (v103 >= 2) {
                    unint64_t v103 = v105;
                  }
                }
                if (prime <= v103) {
                  size_t prime = v103;
                }
                if (prime >= v70)
                {
                  unint64_t v70 = *(void *)(v28 + 296);
                }
                else
                {
                  if (prime) {
                    goto LABEL_124;
                  }
                  uint64_t v156 = *(void *)(v28 + 288);
                  *(void *)(v28 + 288) = 0;
                  if (v156) {
                    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v28 + 304) + 40))(*(void *)(v28 + 304), v156, 8 * *(void *)(v28 + 296));
                  }
                  unint64_t v70 = 0;
                  *(void *)(v28 + 296) = 0;
                }
              }
LABEL_150:
              if ((v70 & (v70 - 1)) != 0)
              {
                if (v69 >= v70) {
                  uint64_t v48 = v69 % v70;
                }
                else {
                  uint64_t v48 = v69;
                }
              }
              else
              {
                uint64_t v48 = (v70 - 1) & v69;
              }
              goto LABEL_163;
            }
LABEL_124:
            uint64_t v92 = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(v28 + 304) + 16))(*(void *)(v28 + 304), 8 * prime, 8);
            uint64_t v93 = *(void *)(v28 + 288);
            *(void *)(v28 + 288) = v92;
            if (v93) {
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v28 + 304) + 40))(*(void *)(v28 + 304), v93, 8 * *(void *)(v28 + 296));
            }
            uint64_t v94 = 0;
            *(void *)(v28 + 296) = prime;
            do
              *(void *)(*(void *)(v28 + 288) + 8 * v94++) = 0;
            while (prime != v94);
            BOOL v95 = (void *)*v258;
            if (!*v258) {
              goto LABEL_149;
            }
            size_t v96 = v95[1];
            size_t v97 = prime - 1;
            if ((prime & (prime - 1)) == 0)
            {
              size_t v98 = v96 & v97;
              *(void *)(*(void *)(v28 + 288) + 8 * v98) = v258;
              for (uint64_t i = (void *)*v95; *v95; uint64_t i = (void *)*v95)
              {
                size_t v100 = i[1] & v97;
                if (v100 == v98)
                {
                  BOOL v95 = i;
                }
                else
                {
                  uint64_t v101 = *(void *)(v28 + 288);
                  if (*(void *)(v101 + 8 * v100))
                  {
                    *BOOL v95 = *i;
                    uint64_t v102 = 8 * v100;
                    void *i = **(void **)(*(void *)(v28 + 288) + v102);
                    **(void **)(*(void *)(v28 + 288) + v102) = i;
                  }
                  else
                  {
                    *(void *)(v101 + 8 * v100) = v95;
                    BOOL v95 = i;
                    size_t v98 = v100;
                  }
                }
              }
              goto LABEL_149;
            }
            if (v96 >= prime) {
              v96 %= prime;
            }
            *(void *)(*(void *)(v28 + 288) + 8 * v96) = v258;
            unint64_t v106 = (void *)*v95;
            if (!*v95)
            {
LABEL_149:
              unint64_t v70 = prime;
              goto LABEL_150;
            }
            while (2)
            {
              size_t v108 = v106[1];
              if (v108 >= prime) {
                v108 %= prime;
              }
              if (v108 != v96)
              {
                uint64_t v109 = *(void *)(v28 + 288);
                if (!*(void *)(v109 + 8 * v108))
                {
                  *(void *)(v109 + 8 * v108) = v95;
LABEL_154:
                  BOOL v95 = v106;
                  unint64_t v106 = (void *)*v106;
                  size_t v96 = v108;
                  if (!v106) {
                    goto LABEL_149;
                  }
                  continue;
                }
                *BOOL v95 = *v106;
                uint64_t v107 = 8 * v108;
                *unint64_t v106 = **(void **)(*(void *)(v28 + 288) + v107);
                **(void **)(*(void *)(v28 + 288) + v107) = v106;
                unint64_t v106 = v95;
              }
              break;
            }
            size_t v108 = v96;
            goto LABEL_154;
          }
LABEL_163:
          uint64_t v110 = *(void **)(*(void *)(v28 + 288) + 8 * v48);
          if (v110)
          {
            *unint64_t v85 = *v110;
            long long v111 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
          }
          else
          {
            *unint64_t v85 = *(void *)(v28 + 312);
            *(void *)(v28 + 312) = v85;
            *(void *)(*(void *)(v28 + 288) + 8 * v48) = v258;
            long long v111 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
            if (!*v85) {
              goto LABEL_172;
            }
            unint64_t v112 = *(void *)(*v85 + 8);
            if ((v70 & (v70 - 1)) != 0)
            {
              if (v112 >= v70) {
                v112 %= v70;
              }
            }
            else
            {
              v112 &= v70 - 1;
            }
            uint64_t v110 = (void *)(*(void *)(v28 + 288) + 8 * v112);
          }
          void *v110 = v85;
LABEL_172:
          ++*(void *)(v28 + 328);
          v270[25] = 1;
          {
            operator new();
          }
          uint64_t v113 = *((void *)v111 + 91);
          uint64_t v114 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v113 + 16))(v113, 472, 8);
          *(void *)uint64_t v114 = &unk_1EF581830;
          *(void *)(v114 + 8) = 0;
          *(void *)(v114 + 16) = 0;
          *(void *)(v114 + 24) = v113;
          md::LineLabelFeature::LineLabelFeature(v114 + 32, 5, 3);
          *(void *)(v114 + 32) = &unk_1EF5439C8;
          *(unsigned char *)(v114 + 466) = -1;
          {
            operator new();
          }
          uint64_t v115 = *((void *)v111 + 91);
          unint64_t v116 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v115 + 16))(v115, 8, 4);
          unint64_t v117 = v116;
          if (v116) {
            *unint64_t v116 = 0x200000005;
          }
          uint64_t v118 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v115 + 16))(v115, 16, 4);
          uint64_t v119 = v118;
          if (v118) {
            v118[1] = 0x7600000003;
          }
          *uint64_t v118 = *v117;
          (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v115 + 40))(v115, v117, 8);
          _ZNSt3__115allocate_sharedB8nn180100I22FeatureStyleAttributesNS_9allocatorIS1_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_(&v295);
          uint64_t v120 = 0;
          char v121 = 0;
          uint64_t v122 = v295;
          unsigned __int8 v123 = *(unsigned char *)(v295 + 33);
          while (1)
          {
            size_t v124 = v123;
            unint64_t v125 = *(void **)v122;
            if (v123) {
              break;
            }
LABEL_179:
            v125[v124] = v119[v120];
            unsigned __int8 v123 = *(unsigned char *)(v122 + 33) + 1;
            *(unsigned char *)(v122 + 33) = v123;
            char v121 = 1;
            BOOL v79 = v120 == 1;
            uint64_t v120 = 1;
            if (v79)
            {
              unint64_t v125 = *(void **)v122;
              size_t v124 = v123;
LABEL_197:
              qsort(v125, v124, 8uLL, (int (__cdecl *)(const void *, const void *))FeatureStyleAttributes::compareStylePairs);
              goto LABEL_198;
            }
          }
          if (v123 > 0x1Fu)
          {
            do
            {
              uint64_t v129 = 0;
              unint64_t v130 = (int *)v125;
              while (1)
              {
                int v131 = *v130;
                v130 += 2;
                if (v131 == LODWORD(v119[v120])) {
                  break;
                }
                if (v124 == ++v129) {
                  goto LABEL_191;
                }
              }
              HIDWORD(v125[v129]) = HIDWORD(v119[v120]);
LABEL_191:
              BOOL v79 = v120 == 1;
              uint64_t v120 = 1;
            }
            while (!v79);
          }
          else
          {
            do
            {
              uint64_t v126 = 0;
              BOOL v127 = (int *)v125;
              while (1)
              {
                int v128 = *v127;
                v127 += 2;
                if (v128 == LODWORD(v119[v120])) {
                  break;
                }
                if (v124 == ++v126) {
                  goto LABEL_179;
                }
              }
              HIDWORD(v125[v126]) = HIDWORD(v119[v120]);
              BOOL v79 = v120 == 1;
              uint64_t v120 = 1;
            }
            while (!v79);
          }
          if (v121) {
            goto LABEL_197;
          }
LABEL_198:
          uint64_t v132 = *((void *)&v295 + 1);
          if (*((void *)&v295 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v295 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v133 = *(std::__shared_weak_count **)(v114 + 456);
          *(void *)(v114 + 448) = v122;
          *(void *)(v114 + 456) = v132;
          if (v133 && !atomic_fetch_add(&v133->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
            std::__shared_weak_count::__release_weak(v133);
            unint64_t v134 = (std::__shared_weak_count *)*((void *)&v295 + 1);
            if (!*((void *)&v295 + 1)) {
              goto LABEL_206;
            }
          }
          else
          {
            unint64_t v134 = (std::__shared_weak_count *)*((void *)&v295 + 1);
            if (!*((void *)&v295 + 1)) {
              goto LABEL_206;
            }
          }
          if (!atomic_fetch_add(&v134->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v134->__on_zero_shared)(v134);
            std::__shared_weak_count::__release_weak(v134);
          }
LABEL_206:
          (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v115 + 40))(v115, v119, 16);
          uint64_t v135 = *(void *)(v114 + 224);
          *(unsigned char *)(v135 + 290) = v266 != 255;
          md::LabelLineStore::addOverlayLine(v135, v44, (uint64_t)&v265);
          uint64_t v136 = *(unsigned __int8 **)(v114 + 224);
          unsigned __int8 v137 = atomic_load(v136 + 80);
          if (v137) {
            md::LabelLineStore::consumeWorkUnits((md::LabelLineStore *)v136);
          }
          uint64_t v138 = v265;
          uint64_t v139 = *(void *)(v114 + 416);
          for (uint64_t j = *(void *)(v114 + 424); j != v139; j -= 64)
          {
            if (*(char *)(j - 9) < 0)
            {
              (*(void (**)(void, void, uint64_t))(**(void **)(j - 8) + 40))(*(void *)(j - 8), *(void *)(j - 32), *(void *)(j - 16) & 0x7FFFFFFFFFFFFFFFLL);
              if ((*(char *)(j - 41) & 0x80000000) == 0) {
                continue;
              }
            }
            else if ((*(char *)(j - 41) & 0x80000000) == 0)
            {
              continue;
            }
            (*(void (**)(void, void, uint64_t))(**(void **)(j - 40) + 40))(*(void *)(j - 40), *(void *)(j - 64), *(void *)(j - 48) & 0x7FFFFFFFFFFFFFFFLL);
          }
          *(void *)(v114 + 424) = v139;
          long long v295 = 0uLL;
          double v296 = 0;
          {
            operator new();
          }
          uint64_t v297 = mdm::Allocator::instance(void)::alloc;
          uint64_t v299 = 0;
          long long v298 = 0uLL;
          {
            operator new();
          }
          uint64_t v141 = mdm::Allocator::instance(void)::alloc;
          uint64_t v300 = mdm::Allocator::instance(void)::alloc;
          if (*((unsigned char *)v44 + 24) == 1)
          {
            unint64_t v142 = *(void **)(v138 + 3472);
            if (v142)
            {
              id v143 = v142;
              id v294 = 0;
              id v293 = 0;
              [v143 getTextForKey:&unk_1EF5BB358 text:&v294 locale:&v293];
              id v144 = v294;
              id v145 = v293;

              id v146 = v144;
              unint64_t v147 = (const char *)[v146 UTF8String];
              id v148 = v145;
              md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::StringWithLocaleImp((uint64_t)&v288, v147, (const char *)[v148 UTF8String]);
              if (SHIBYTE(v296) < 0) {
                (*(void (**)(uint64_t, void, unint64_t))(*(void *)v297 + 40))(v297, v295, (unint64_t)v296 & 0x7FFFFFFFFFFFFFFFLL);
              }
              long long v295 = v288;
              double v296 = v289;
              HIBYTE(v289) = 0;
              LOBYTE(v288) = 0;
              if (SHIBYTE(v299) < 0)
              {
                (*(void (**)(uint64_t, void, uint64_t))(*(void *)v141 + 40))(v141, v298, v299 & 0x7FFFFFFFFFFFFFFFLL);
                long long v298 = v291;
                uint64_t v299 = v292;
                HIBYTE(v292) = 0;
                LOBYTE(v291) = 0;
                if (SHIBYTE(v289) < 0) {
                  (*(void (**)(uint64_t, void, unint64_t))(*(void *)v290 + 40))(v290, v288, (unint64_t)v289 & 0x7FFFFFFFFFFFFFFFLL);
                }
              }
              else
              {
                long long v298 = v291;
                uint64_t v299 = v292;
              }
            }
          }
          uint64_t v149 = HIBYTE(v296);
          int v150 = SHIBYTE(v296);
          unint64_t v151 = *((void *)&v295 + 1);
          if (SHIBYTE(v296) < 0) {
            uint64_t v149 = *((void *)&v295 + 1);
          }
          if (v149)
          {
            BOOL v152 = *(unsigned __int8 **)(v114 + 416);
            unint64_t v153 = *(void *)(v114 + 424);
            if (v152 == (unsigned __int8 *)v153)
            {
              unsigned __int8 v154 = 0;
LABEL_236:
              if (v153 >= *(void *)(v114 + 432))
              {
                uint64_t v155 = std::vector<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,geo::StdAllocator<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,mdm::Allocator>>::__emplace_back_slow_path<md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>> const&>((uint64_t *)(v114 + 416), &v295);
              }
              else
              {
                if (v153)
                {
                  *(void *)(v153 + 24) = v297;
                  if (v150 < 0)
                  {
                    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external((void **)v153, (void *)v295, v151);
                  }
                  else
                  {
                    *(_OWORD *)unint64_t v153 = v295;
                    *(void *)(v153 + 16) = v296;
                  }
                  BOOL v157 = (void **)(v153 + 32);
                  *(void *)(v153 + 56) = v141;
                  if (SHIBYTE(v299) < 0)
                  {
                    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external(v157, (void *)v298, *((unint64_t *)&v298 + 1));
                  }
                  else
                  {
                    *(_OWORD *)BOOL v157 = v298;
                    *(void *)(v153 + 48) = v299;
                  }
                }
                uint64_t v155 = v153 + 64;
                *(void *)(v114 + 424) = v153 + 64;
              }
              *(void *)(v114 + 424) = v155;
            }
            else
            {
              unsigned __int8 v154 = 0;
              while ((md::StringWithLocaleImp<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>::operator==(v152, (unsigned __int8 *)&v295) & 1) == 0)
              {
                ++v154;
                v152 += 64;
                if (v152 == (unsigned __int8 *)v153)
                {
                  if (v154 <= 0x64u) {
                    goto LABEL_236;
                  }
                  goto LABEL_234;
                }
              }
            }
          }
          else
          {
LABEL_234:
            unsigned __int8 v154 = -1;
          }
          *(unsigned char *)(v114 + 466) = v154;
          if (SHIBYTE(v299) < 0)
          {
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)v141 + 40))(v141, v298, v299 & 0x7FFFFFFFFFFFFFFFLL);
            uint64_t v81 = (std::mutex *)(v114 + 32);
            if (v150 < 0) {
              goto LABEL_274;
            }
          }
          else
          {
            uint64_t v81 = (std::mutex *)(v114 + 32);
            if ((v150 & 0x80000000) == 0) {
              goto LABEL_258;
            }
LABEL_274:
            (*(void (**)(uint64_t, void, unint64_t))(*(void *)v297 + 40))(v297, v295, (unint64_t)v296 & 0x7FFFFFFFFFFFFFFFLL);
          }
LABEL_258:
          if (v287) {
            uint64_t v158 = v287 + 1;
          }
          else {
            uint64_t v158 = 0;
          }
          uint64_t v159 = (std::__shared_weak_count *)v158[2];
          v158[1] = v81;
          v158[2] = v114;
          if (v159 && !atomic_fetch_add(&v159->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v159->__on_zero_shared)(v159);
            std::__shared_weak_count::__release_weak(v159);
          }
          uint64_t v160 = *(void *)(v28 + 672);
          uint64_t v161 = v287;
          long long v162 = v287 + 1;
          if (!v287) {
            long long v162 = 0;
          }
          uint64_t v163 = v162[1];
          *(void *)(v163 + 152) = v162;
          uint64_t v164 = v160 + 1;
          *(void *)(v28 + 672) = v164;
          *(void *)(v163 + 72) = v164;
          *(unsigned char *)(v163 + 147) = 0;
          float v165 = v264;
LABEL_267:
          uint64_t v166 = (uint64_t)(v161 + 1);
          if (v161) {
            unint64_t v167 = v161 + 1;
          }
          else {
            unint64_t v167 = 0;
          }
          uint64_t v168 = v167[1];
          unint64_t v169 = *(void *)(v168 + 72);
          unint64_t v170 = v35[32];
          if (v170)
          {
            uint8x8_t v171 = (uint8x8_t)vcnt_s8((int8x8_t)v170);
            v171.i16[0] = vaddlv_u8(v171);
            if (v171.u32[0] > 1uLL)
            {
              uint64_t v81 = *(std::mutex **)(v168 + 72);
              if (v169 >= v170) {
                uint64_t v81 = (std::mutex *)(v169 % v170);
              }
            }
            else
            {
              uint64_t v81 = (std::mutex *)((v170 - 1) & v169);
            }
            unint64_t v172 = *(void **)(v35[31] + 8 * (void)v81);
            if (v172)
            {
              uint64_t v173 = (void *)*v172;
              if (v173)
              {
                if (v171.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v177 = v173[1];
                    if (v177 == v169)
                    {
                      uint64_t v178 = v173[2];
                      if (v178) {
                        uint64_t v179 = v178 + 8;
                      }
                      else {
                        uint64_t v179 = 0;
                      }
                      if (*(void *)(*(void *)(v179 + 8) + 72) == v169) {
                        goto LABEL_360;
                      }
                    }
                    else if ((std::mutex *)(v177 & (v170 - 1)) != v81)
                    {
                      goto LABEL_299;
                    }
                    uint64_t v173 = (void *)*v173;
                    if (!v173) {
                      goto LABEL_299;
                    }
                  }
                }
                do
                {
                  unint64_t v174 = v173[1];
                  if (v174 == v169)
                  {
                    uint64_t v175 = v173[2];
                    if (v175) {
                      uint64_t v176 = v175 + 8;
                    }
                    else {
                      uint64_t v176 = 0;
                    }
                    if (*(void *)(*(void *)(v176 + 8) + 72) == v169) {
                      goto LABEL_360;
                    }
                  }
                  else
                  {
                    if (v174 >= v170) {
                      v174 %= v170;
                    }
                    if ((std::mutex *)v174 != v81) {
                      break;
                    }
                  }
                  uint64_t v173 = (void *)*v173;
                }
                while (v173);
              }
            }
          }
LABEL_299:
          float v180 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v35[35] + 16))(v35[35], 24, 8);
          *(void *)&long long v295 = v180;
          *((void *)&v295 + 1) = v35 + 35;
          *float v180 = 0;
          v180[1] = v169;
          v180[2] = v161;
          if (v161) {
            ++*v161;
          }
          LOBYTE(v296) = 1;
          float v181 = (float)(unint64_t)(v35[36] + 1);
          float v182 = *((float *)v35 + 74);
          if (!v170 || (float)(v182 * (float)v170) < v181)
          {
            BOOL v183 = (v170 & (v170 - 1)) != 0;
            if (v170 < 3) {
              BOOL v183 = 1;
            }
            unint64_t v184 = v183 | (2 * v170);
            unint64_t v185 = vcvtps_u32_f32(v181 / v182);
            if (v184 <= v185) {
              size_t v186 = v185;
            }
            else {
              size_t v186 = v184;
            }
            if (v186 == 1)
            {
              size_t v186 = 2;
            }
            else if ((v186 & (v186 - 1)) != 0)
            {
              size_t v186 = std::__next_prime(v186);
            }
            unint64_t v170 = v35[32];
            if (v186 > v170)
            {
LABEL_313:
              uint64_t v187 = (*(uint64_t (**)(void, size_t, uint64_t))(*(void *)v35[33] + 16))(v35[33], 8 * v186, 8);
              uint64_t v188 = v35[31];
              v35[31] = v187;
              if (v188) {
                (*(void (**)(void, uint64_t, uint64_t))(*(void *)v35[33] + 40))(v35[33], v188, 8 * v35[32]);
              }
              uint64_t v189 = 0;
              v35[32] = v186;
              do
                *(void *)(v35[31] + 8 * v189++) = 0;
              while (v186 != v189);
              BOOL v190 = (void *)*v257;
              if (!*v257) {
                goto LABEL_336;
              }
              size_t v191 = v190[1];
              size_t v192 = v186 - 1;
              if ((v186 & (v186 - 1)) == 0)
              {
                size_t v193 = v191 & v192;
                *(void *)(v35[31] + 8 * v193) = v257;
                for (uint64_t k = (void *)*v190; *v190; uint64_t k = (void *)*v190)
                {
                  size_t v195 = k[1] & v192;
                  if (v195 == v193)
                  {
                    BOOL v190 = k;
                  }
                  else
                  {
                    uint64_t v196 = v35[31];
                    if (*(void *)(v196 + 8 * v195))
                    {
                      *BOOL v190 = *k;
                      uint64_t v197 = 8 * v195;
                      *uint64_t k = **(void **)(v35[31] + v197);
                      **(void **)(v35[31] + v197) = k;
                    }
                    else
                    {
                      *(void *)(v196 + 8 * v195) = v190;
                      BOOL v190 = k;
                      size_t v193 = v195;
                    }
                  }
                }
                goto LABEL_336;
              }
              if (v191 >= v186) {
                v191 %= v186;
              }
              *(void *)(v35[31] + 8 * v191) = v257;
              unint64_t v201 = (void *)*v190;
              if (!*v190)
              {
LABEL_336:
                unint64_t v170 = v186;
                goto LABEL_337;
              }
              while (2)
              {
                size_t v203 = v201[1];
                if (v203 >= v186) {
                  v203 %= v186;
                }
                if (v203 != v191)
                {
                  uint64_t v204 = v35[31];
                  if (!*(void *)(v204 + 8 * v203))
                  {
                    *(void *)(v204 + 8 * v203) = v190;
LABEL_341:
                    BOOL v190 = v201;
                    unint64_t v201 = (void *)*v201;
                    size_t v191 = v203;
                    if (!v201) {
                      goto LABEL_336;
                    }
                    continue;
                  }
                  *BOOL v190 = *v201;
                  uint64_t v202 = 8 * v203;
                  *unint64_t v201 = **(void **)(v35[31] + v202);
                  **(void **)(v35[31] + v202) = v201;
                  unint64_t v201 = v190;
                }
                break;
              }
              size_t v203 = v191;
              goto LABEL_341;
            }
            if (v186 < v170)
            {
              unint64_t v198 = vcvtps_u32_f32((float)(unint64_t)v35[36] / *((float *)v35 + 74));
              if (v170 < 3
                || (uint8x8_t v199 = (uint8x8_t)vcnt_s8((int8x8_t)v170), v199.i16[0] = vaddlv_u8(v199), v199.u32[0] > 1uLL))
              {
                unint64_t v198 = std::__next_prime(v198);
              }
              else
              {
                uint64_t v200 = 1 << -(char)__clz(v198 - 1);
                if (v198 >= 2) {
                  unint64_t v198 = v200;
                }
              }
              if (v186 <= v198) {
                size_t v186 = v198;
              }
              if (v186 >= v170)
              {
                unint64_t v170 = v35[32];
              }
              else
              {
                if (v186) {
                  goto LABEL_313;
                }
                uint64_t v230 = v35[31];
                v35[31] = 0;
                if (v230) {
                  (*(void (**)(void, uint64_t, uint64_t))(*(void *)v35[33] + 40))(v35[33], v230, 8 * v35[32]);
                }
                unint64_t v170 = 0;
                v35[32] = 0;
              }
            }
LABEL_337:
            if ((v170 & (v170 - 1)) != 0)
            {
              if (v169 >= v170) {
                uint64_t v81 = (std::mutex *)(v169 % v170);
              }
              else {
                uint64_t v81 = (std::mutex *)v169;
              }
            }
            else
            {
              uint64_t v81 = (std::mutex *)((v170 - 1) & v169);
            }
          }
          uint64_t v205 = *(void **)(v35[31] + 8 * (void)v81);
          if (v205)
          {
            *float v180 = *v205;
            goto LABEL_358;
          }
          *float v180 = v35[34];
          v35[34] = v180;
          *(void *)(v35[31] + 8 * (void)v81) = v257;
          if (*v180)
          {
            unint64_t v206 = *(void *)(*v180 + 8);
            if ((v170 & (v170 - 1)) != 0)
            {
              if (v206 >= v170) {
                v206 %= v170;
              }
            }
            else
            {
              v206 &= v170 - 1;
            }
            uint64_t v205 = (void *)(v35[31] + 8 * v206);
LABEL_358:
            *uint64_t v205 = v180;
          }
          ++v35[36];
          uint64_t v168 = v167[1];
LABEL_360:
          uint64_t v207 = (std::__shared_weak_count *)v167[2];
          uint64_t v281 = v168;
          uint64_t v282 = v207;
          if (v207) {
            atomic_fetch_add_explicit(&v207->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v161)
          {
            BOOL v79 = (*v161)-- == 1;
            uint64_t v208 = v262;
            if (v79)
            {
              md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>::~LabelFeatureThunk(v166);
              {
                operator new();
              }
              (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 40))(mdm::Allocator::instance(void)::alloc, v287, 104);
              uint64_t v168 = v281;
              uint64_t v207 = v282;
            }
          }
          else
          {
            uint64_t v208 = v262;
          }
          if (v207) {
            atomic_fetch_add_explicit(&v207->__shared_weak_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v209 = *v208;
          uint64_t v210 = v208;
          if (*v208)
          {
            while (1)
            {
              while (1)
              {
                uint64_t v208 = (uint64_t **)v209;
                unint64_t v211 = v209[5];
                if ((unint64_t)v207 >= v211) {
                  break;
                }
                uint64_t v209 = *v208;
                uint64_t v210 = v208;
                if (!*v208) {
                  goto LABEL_377;
                }
              }
              if (v211 >= (unint64_t)v207) {
                break;
              }
              uint64_t v209 = v208[1];
              if (!v209)
              {
                uint64_t v210 = v208 + 1;
                goto LABEL_377;
              }
            }
            if (v207) {
              std::__shared_weak_count::__release_weak(v207);
            }
          }
          else
          {
LABEL_377:
            uint64_t v212 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 248) + 16))(*(void *)(a1 + 248), 48, 8);
            v212[4] = v168;
            v212[5] = (uint64_t)v207;
            *uint64_t v212 = 0;
            v212[1] = 0;
            v212[2] = (uint64_t)v208;
            void *v210 = v212;
            double v213 = (void *)**v260;
            if (v213)
            {
              void *v260 = v213;
              uint64_t v212 = *v210;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 240), v212);
            ++*(void *)(a1 + 256);
          }
          if (v270[25])
          {
            uint64_t v214 = v281;
            uint64_t v215 = v284;
            if ((unint64_t)v284 >= v285)
            {
              unint64_t v217 = 0xAAAAAAAAAAAAAAABLL * ((v284 - v283) >> 3);
              unint64_t v218 = v217 + 1;
              if (v217 + 1 > 0xAAAAAAAAAAAAAAALL) {
                abort();
              }
              if (0x5555555555555556 * ((uint64_t)(v285 - (void)v283) >> 3) > v218) {
                unint64_t v218 = 0x5555555555555556 * ((uint64_t)(v285 - (void)v283) >> 3);
              }
              uint64_t v219 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v285 - (void)v283) >> 3) >= 0x555555555555555
                   ? 0xAAAAAAAAAAAAAAALL
                   : v218;
              if (v219)
              {
                uint64_t v220 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v286 + 16))(v286, 24 * v219, 8);
                uint64_t v221 = (char *)(v220 + 24 * v217);
                uint64_t v222 = v220 + 24 * v219;
                if (v220)
                {
                  *(void *)uint64_t v221 = v214;
                  unint64_t v223 = v220 + 24 * v217;
                  *(void *)(v223 + 8) = 0;
                  *(void *)(v223 + 16) = 0;
                }
              }
              else
              {
                uint64_t v222 = 0;
                uint64_t v221 = (char *)(8 * ((v284 - v283) >> 3));
              }
              uint64_t v225 = v283;
              unint64_t v224 = v284;
              long long v226 = v221;
              if (v284 != v283)
              {
                do
                {
                  long long v227 = *(_OWORD *)(v224 - 24);
                  *((void *)v226 - 1) = *((void *)v224 - 1);
                  *(_OWORD *)(v226 - 24) = v227;
                  v226 -= 24;
                  v224 -= 24;
                }
                while (v224 != v225);
                unint64_t v224 = v283;
              }
              uint64_t v216 = v221 + 24;
              uint64_t v283 = v226;
              uint64_t v284 = v221 + 24;
              unint64_t v228 = v285;
              unint64_t v285 = v222;
              if (v224) {
                (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v286 + 40))(v286, v224, v228 - (void)v224);
              }
            }
            else
            {
              if (v284)
              {
                *((void *)v284 + 1) = 0;
                *((void *)v215 + 2) = 0;
                *(void *)uint64_t v215 = v214;
              }
              uint64_t v216 = v215 + 24;
            }
            uint64_t v284 = v216;
            if (v216 != v283 && 0xAAAAAAAAAAAAAAABLL * ((v216 - v283) >> 3) >= 0x20)
            {
              md::LabelFeatureStyler::styleLabelFeatures(*(unsigned int **)(v256 + 296), &v283, 1u, 1, *(void *)(*(void *)(v256 + 152) + 32));
              uint64_t v284 = v283;
              std::mutex::unlock((std::mutex *)v28);
              if (v28)
              {
                std::mutex::lock((std::mutex *)v28);
                goto LABEL_406;
              }
LABEL_492:
              std::__throw_system_error(1, "unique_lock::lock: references null mutex");
LABEL_512:
              __break(1u);
              return;
            }
          }
LABEL_406:
          float v229 = v282;
          if (v282 && !atomic_fetch_add(&v282->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v229->__on_zero_shared)(v229);
            std::__shared_weak_count::__release_weak(v229);
          }
          uint64_t v45 = v263 + 1;
          uint64_t v44 = v165 + 7;
          if (v263 + 1 == v259) {
            goto LABEL_471;
          }
        }
      }
      std::mutex::unlock((std::mutex *)v28);
    }
  }
LABEL_481:
  float v250 = v280;
  if (v280 && !atomic_fetch_add(&v280->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v250->__on_zero_shared)(v250);
    std::__shared_weak_count::__release_weak(v250);
  }
  if (!v306)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_512;
  }
  (*(void (**)(void *))(*v306 + 48))(v306);
  if (v306 == v305)
  {
    (*(void (**)(void *))(v305[0] + 32))(v305);
  }
  else if (v306)
  {
    (*(void (**)(void))(*v306 + 40))();
  }
}

void sub_1A1FB6FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void **a11, void **a12, void **a13, void **a14, void **a15, void **a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void **a25,uint64_t a26,md::LineLabelFeature *a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  md::components::Material::~Material((md::components::Material *)(v69 - 256));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a67);
  std::mutex::unlock(v67);
  geo::fast_shared_ptr<md::LabelFeatureThunk<md::OverlayLineLabelFeature,md::LabelClientTileOverlay,md::LabelClientTile>,mdm::MDAllocator>::~fast_shared_ptr(&a66);
  std::mutex::unlock(v68);
  if (a62)
  {
    a63 = a62;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a65 + 40))(a65, a62, a64 - a62);
  }
  md::LabelFeatureCreationParams::~LabelFeatureCreationParams((md::LabelFeatureCreationParams *)&a31);
  md::LabelFeatureCreationParams::~LabelFeatureCreationParams((md::LabelFeatureCreationParams *)&a45);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v69 - 128));
  uint8x8_t v71 = *(std::__shared_weak_count **)(a23 + 272);
  if (v71) {
    std::__shared_weak_count::__release_weak(v71);
  }
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy(a22, *a25);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy((uint64_t)(a11 - 1), *a11);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy((uint64_t)(a13 - 1), *a13);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy((uint64_t)(a14 - 1), *a14);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy((uint64_t)(a15 - 1), *a15);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy((uint64_t)(a16 - 1), *a16);
  std::__tree<std::weak_ptr<md::OverlayLineLabelFeature>,std::owner_less<std::weak_ptr<md::OverlayLineLabelFeature>>,geo::StdAllocator<std::weak_ptr<md::OverlayLineLabelFeature>,mdm::Allocator>>::destroy((uint64_t)(a12 - 1), *a12);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a10);
  BOOL v72 = *(std::__shared_weak_count **)(a23 + 16);
  if (v72)
  {
    std::__shared_weak_count::__release_weak(v72);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_1,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_1>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LabelsTileDecode", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_1,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_1>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5793C8;
}

void *std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_1,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_1>,void ()(void)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1EF5793C8;
  return result;
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_1,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_1>,void ()(void)>::~__func()
{
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsTileDecode", "", v1, 2u);
  }
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF579380;
}

void *std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::__clone()
{
  double result = operator new(0x10uLL);
  *double result = &unk_1EF579380;
  return result;
}

void std::__function::__func<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0,std::allocator<md::LabelTile::LabelTile(geo::QuadTile const&,std::shared_ptr<md::LabelClientTile> const&,std::shared_ptr<md::LabelManager> const&)::$_0>,void ()(void)>::~__func()
{
}

void md::RouteRenderLayer::createDebugNode(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = (void *)a2;
  strcpy((char *)a2, "RouteRenderLayer");
  *(_WORD *)(a2 + 23) = 16;
  *(_OWORD *)(a2 + 47) = 0u;
  *(_OWORD *)(a2 + 63) = 0u;
  *(_OWORD *)(a2 + 79) = 0u;
  *(unsigned char *)(a2 + 95) = 0;
  uint64_t v3 = *(uint64_t ***)(a1 + 64);
  double v4 = *v3;
  double v5 = v3[1];
  if (*v3 != v5)
  {
    __double2 v6 = (void ***)&v32;
    uint64_t v28 = v2;
    while (1)
    {
      uint64_t v8 = *v4;
      double v7 = (std::__shared_weak_count *)v4[1];
      uint64_t v35 = *v4;
      unint64_t v36 = v7;
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(_OWORD *)long long v29 = 0u;
      *(_OWORD *)unsigned __int8 v30 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      *(_OWORD *)uint64_t v33 = 0u;
      long long v34 = 0u;
      char v38 = 8;
      strcpy((char *)&v37, "selected");
      uint64_t v9 = *(unsigned __int8 *)(v8 + 620);
      memset(&v46[4], 0, 24);
      int v47 = 0;
      v46[0] = v9;
      gdc::DebugTreeNode::addProperty((uint64_t)v29, (uint64_t)&v37, (uint64_t)v46);
      uint64_t v10 = *(int *)(v8 + 616);
      char v38 = 5;
      strcpy((char *)&v37, "layer");
      memset(&v44[4], 0, 24);
      int v45 = 0;
      v44[0] = v10;
      gdc::DebugTreeNode::addProperty((uint64_t)v29, (uint64_t)&v37, (uint64_t)v44);
      unint64_t v11 = *(void **)(v8 + 144);
      if (v11) {
        break;
      }
LABEL_15:
      gdc::DebugTreeNode::addChildNode(v2, (long long *)v29);
      uint64_t v16 = (void **)v33[1];
      if (v33[1])
      {
        uint64_t v17 = v34;
        uint64_t v18 = v33[1];
        if ((void *)v34 != v33[1])
        {
          uint64_t v19 = v5;
          uint64_t v20 = v6;
          do
          {
            uint64_t v21 = *(void *)(v17 - 24);
            if (v21)
            {
              uint64_t v22 = *(void *)(v17 - 16);
              int v23 = *(void **)(v17 - 24);
              if (v22 != v21)
              {
                do
                {
                  if (*(char *)(v22 - 1) < 0) {
                    operator delete(*(void **)(v22 - 24));
                  }
                  v22 -= 24;
                }
                while (v22 != v21);
                int v23 = *(void **)(v17 - 24);
              }
              *(void *)(v17 - 16) = v21;
              operator delete(v23);
            }
            uint64_t v24 = *(void *)(v17 - 48);
            if (v24)
            {
              uint64_t v25 = *(void *)(v17 - 40);
              double v26 = *(void **)(v17 - 48);
              if (v25 != v24)
              {
                do
                {
                  if (*(char *)(v25 - 9) < 0) {
                    operator delete(*(void **)(v25 - 32));
                  }
                  v25 -= 64;
                }
                while (v25 != v24);
                double v26 = *(void **)(v17 - 48);
              }
              *(void *)(v17 - 40) = v24;
              operator delete(v26);
            }
            double v27 = (void **)(v17 - 80);
            if (*(char *)(v17 - 57) < 0) {
              operator delete(*v27);
            }
            v17 -= 80;
          }
          while (v27 != v16);
          uint64_t v18 = v33[1];
          __double2 v6 = v20;
          double v5 = v19;
          uint64_t v2 = v28;
        }
        *(void *)&long long v34 = v16;
        operator delete(v18);
      }
      std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](v6);
      if (SHIBYTE(v31) < 0)
      {
        operator delete(v30[1]);
        if ((SHIBYTE(v30[0]) & 0x80000000) == 0)
        {
LABEL_41:
          if (v7) {
            goto LABEL_45;
          }
          goto LABEL_3;
        }
      }
      else if ((SHIBYTE(v30[0]) & 0x80000000) == 0)
      {
        goto LABEL_41;
      }
      operator delete(v29[0]);
      if (v7)
      {
LABEL_45:
        if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
          std::__shared_weak_count::__release_weak(v7);
        }
      }
LABEL_3:
      v4 += 2;
      if (v4 == v5) {
        return;
      }
    }
    id v12 = v11;
    [v12 createDebugNode];
    gdc::DebugTreeNode::addChildNode(v29, &v37);
    uint64_t v13 = __p;
    if (__p)
    {
      uint64_t v14 = (uint64_t)v43;
      uint64_t v15 = __p;
      if (v43 != __p)
      {
        do
        {
          v14 -= 80;
          std::__destroy_at[abi:nn180100]<gdc::DebugTreeProperty,0>(v14);
        }
        while ((void *)v14 != v13);
        uint64_t v15 = __p;
      }
      unint64_t v43 = v13;
      operator delete(v15);
    }
    std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100](&v41);
    if (v40 < 0)
    {
      operator delete(v39);
      if ((v38 & 0x80000000) == 0) {
        goto LABEL_14;
      }
    }
    else if ((v38 & 0x80000000) == 0)
    {
LABEL_14:

      goto LABEL_15;
    }
    operator delete((void *)v37);
    goto LABEL_14;
  }
}

void sub_1A1FB7A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);

  gdc::DebugTreeNode::~DebugTreeNode((gdc::DebugTreeNode *)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  gdc::DebugTreeNode::~DebugTreeNode(v3);
  _Unwind_Resume(a1);
}

void md::RouteRenderLayer::layoutOverlay(uint64_t a1, md::LayoutContext *a2, void *a3, char a4, uint64_t a5)
{
  uint64_t v2003 = *MEMORY[0x1E4F143B8];
  if (*(float *)(*a3 + 200) >= 1.0 || *(void *)(*a3 + 176))
  {
    int v7 = 0;
  }
  else
  {
    uint64_t v35 = [[VKTimedAnimation alloc] initWithDuration:0.25];
    unint64_t v36 = *(void **)(*a3 + 176);
    *(void *)(*a3 + 176) = v35;

    v1960[0] = MEMORY[0x1E4F143A8];
    v1960[1] = 3321888768;
    v1960[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke;
    v1960[3] = &__block_descriptor_48_ea8_32c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0f8l;
    uint64_t v37 = *a3;
    char v38 = (std::__shared_weak_count *)a3[1];
    v1960[4] = *a3;
    v1961 = v38;
    if (v38)
    {
      atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v37 = *a3;
    }
    [*(id *)(v37 + 176) setStepHandler:v1960];
    v1958[0] = MEMORY[0x1E4F143A8];
    v1958[1] = 3321888768;
    v1958[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_18;
    v1958[3] = &__block_descriptor_48_ea8_32c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0B8l;
    uint64_t v39 = *a3;
    char v40 = (std::__shared_weak_count *)a3[1];
    v1958[4] = *a3;
    v1959 = v40;
    if (v40)
    {
      atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v39 = *a3;
    }
    [*(id *)(v39 + 176) setCompletionHandler:v1958];
    md::AnimationRunner::runAnimation(*(md::MapEngine ***)(a1 + 88), *(VKAnimation **)(*a3 + 176));
    uint64_t v41 = v1959;
    if (v1959 && !atomic_fetch_add(&v1959->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
      std::__shared_weak_count::__release_weak(v41);
    }
    long long v42 = v1961;
    if (v1961 && !atomic_fetch_add(&v1961->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
    int v7 = 1;
  }
  uint64_t v8 = *a3;
  float v9 = *(float *)(*a3 + 204);
  v1821 = a2;
  if (*(unsigned char *)(*a3 + 208))
  {
    if (v9 >= 1.0 || *(void *)(v8 + 184)) {
      goto LABEL_28;
    }
    uint64_t v10 = [[VKTimedAnimation alloc] initWithDuration:0.25];
    uint64_t v11 = *(void **)(*a3 + 184);
    *(void *)(*a3 + 184) = v10;

    v1956[0] = MEMORY[0x1E4F143A8];
    v1956[1] = 3321888768;
    v1956[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_22;
    v1956[3] = &__block_descriptor_48_ea8_32c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0f8l;
    uint64_t v12 = *a3;
    uint64_t v13 = (std::__shared_weak_count *)a3[1];
    v1956[4] = *a3;
    v1957 = v13;
    if (v13)
    {
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v12 = *a3;
    }
    [*(id *)(v12 + 184) setStepHandler:v1956];
    v1954[0] = MEMORY[0x1E4F143A8];
    v1954[1] = 3321888768;
    v1954[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_2;
    v1954[3] = &__block_descriptor_48_ea8_32c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0B8l;
    uint64_t v14 = *a3;
    uint64_t v15 = (std::__shared_weak_count *)a3[1];
    v1954[4] = *a3;
    v1955 = v15;
    if (v15)
    {
      atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v14 = *a3;
    }
    [*(id *)(v14 + 184) setCompletionHandler:v1954];
    md::AnimationRunner::runAnimation(*(md::MapEngine ***)(a1 + 88), *(VKAnimation **)(*a3 + 184));
    uint64_t v16 = v1955;
    if (v1955 && !atomic_fetch_add(&v1955->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    uint64_t v17 = v1957;
    if (!v1957) {
      goto LABEL_28;
    }
LABEL_26:
    if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
      std::__shared_weak_count::__release_weak(v17);
    }
    goto LABEL_28;
  }
  if (v9 > 0.0 && !*(void *)(v8 + 184))
  {
    uint64_t v18 = [[VKTimedAnimation alloc] initWithDuration:0.25];
    uint64_t v19 = *(void **)(*a3 + 184);
    *(void *)(*a3 + 184) = v18;

    v1952[0] = MEMORY[0x1E4F143A8];
    v1952[1] = 3321888768;
    v1952[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_3;
    v1952[3] = &__block_descriptor_48_ea8_32c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0f8l;
    uint64_t v20 = *a3;
    uint64_t v21 = (std::__shared_weak_count *)a3[1];
    v1952[4] = *a3;
    v1953 = v21;
    if (v21)
    {
      atomic_fetch_add_explicit(&v21->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v20 = *a3;
    }
    [*(id *)(v20 + 184) setStepHandler:v1952];
    v1950[0] = MEMORY[0x1E4F143A8];
    v1950[1] = 3321888768;
    v1950[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_4;
    v1950[3] = &__block_descriptor_48_ea8_32c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0B8l;
    uint64_t v22 = *a3;
    int v23 = (std::__shared_weak_count *)a3[1];
    v1950[4] = *a3;
    v1951 = v23;
    if (v23)
    {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v22 = *a3;
    }
    [*(id *)(v22 + 184) setCompletionHandler:v1950];
    md::AnimationRunner::runAnimation(*(md::MapEngine ***)(a1 + 88), *(VKAnimation **)(*a3 + 184));
    uint64_t v24 = v1951;
    if (v1951 && !atomic_fetch_add(&v1951->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
    uint64_t v17 = v1953;
    if (v1953) {
      goto LABEL_26;
    }
  }
LABEL_28:
  uint64_t v25 = a3;
  if (!*(void *)(*a3 + 216))
  {
    double v26 = operator new(0xE8uLL);
    v26[1] = 0;
    void v26[2] = 0;
    *double v26 = &unk_1EF586DB8;
    uint64_t v27 = ggl::BufferData::BufferData((uint64_t)(v26 + 3), qword_1E9552208, 2, 1, 6, 1);
    v26[28] = ggl::Tile::View::reflection(void)::reflection;
    void v26[3] = &unk_1EF55E258;
    uint64_t v25 = a3;
    uint64_t v28 = *a3;
    long long v29 = *(std::__shared_weak_count **)(*a3 + 224);
    *(void *)(v28 + 216) = v27;
    *(void *)(v28 + 224) = v26;
    if (v29)
    {
      if (!atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
  }
  if (!*(void *)(*v25 + 232))
  {
    unsigned __int8 v30 = (void *)*((void *)a2 + 1);
    int8x8_t v31 = (int8x8_t)v30[1];
    if (v31)
    {
      uint8x8_t v32 = (uint8x8_t)vcnt_s8(v31);
      v32.i16[0] = vaddlv_u8(v32);
      if (v32.u32[0] > 1uLL)
      {
        uint64_t v33 = 0x3070CB6B3C7F21D3;
        if (*(void *)&v31 <= 0x3070CB6B3C7F21D3uLL) {
          uint64_t v33 = 0x3070CB6B3C7F21D3uLL % *(void *)&v31;
        }
      }
      else
      {
        uint64_t v33 = (*(void *)&v31 - 1) & 0x3070CB6B3C7F21D3;
      }
      unint64_t v43 = *(void **)(*v30 + 8 * v33);
      if (v43)
      {
        uint64_t v44 = (void *)*v43;
        if (v44)
        {
          if (v32.u32[0] < 2uLL)
          {
            uint64_t v45 = *(void *)&v31 - 1;
            while (1)
            {
              uint64_t v47 = v44[1];
              if (v47 == 0x3070CB6B3C7F21D3)
              {
                if (v44[2] == 0x3070CB6B3C7F21D3) {
                  goto LABEL_66;
                }
              }
              else if ((v47 & v45) != v33)
              {
                goto LABEL_66;
              }
              uint64_t v44 = (void *)*v44;
              if (!v44) {
                goto LABEL_66;
              }
            }
          }
          do
          {
            unint64_t v46 = v44[1];
            if (v46 == 0x3070CB6B3C7F21D3)
            {
              if (v44[2] == 0x3070CB6B3C7F21D3) {
                break;
              }
            }
            else
            {
              if (v46 >= *(void *)&v31) {
                v46 %= *(void *)&v31;
              }
              if (v46 != v33) {
                break;
              }
            }
            uint64_t v44 = (void *)*v44;
          }
          while (v44);
        }
      }
    }
LABEL_66:
    md::GeometryLogic::createUnitTransformConstantData((md::GeometryLogic *)v1969);
    uint64_t v48 = *a3;
    long long v49 = *(_OWORD *)v1969;
    *(void *)&v1969[8] = 0;
    *(void *)v1969 = 0;
    uint64_t v50 = *(std::__shared_weak_count **)(v48 + 240);
    *(_OWORD *)(v48 + 232) = v49;
    if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
    uint64_t v51 = *(std::__shared_weak_count **)&v1969[8];
    if (*(void *)&v1969[8]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v1969[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
    if (*(void *)(*a3 + 248)) {
      goto LABEL_76;
    }
    goto LABEL_73;
  }
  if (!*(void *)(*v25 + 248))
  {
LABEL_73:
    unint64_t v52 = operator new(0xE8uLL);
    v52[1] = 0;
    v52[2] = 0;
    *unint64_t v52 = &unk_1EF586990;
    uint64_t v53 = ggl::BufferData::BufferData((uint64_t)(v52 + 3), qword_1E9567660, 2, 1, 6, 1);
    v52[28] = ggl::SinglePassRouteLine::ClipParams::reflection(void)::reflection;
    v52[3] = &unk_1EF55DFD8;
    uint64_t v54 = *a3;
    unint64_t v55 = *(std::__shared_weak_count **)(*a3 + 256);
    *(void *)(v54 + 248) = v53;
    *(void *)(v54 + 256) = v52;
    if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
      std::__shared_weak_count::__release_weak(v55);
    }
  }
LABEL_76:
  unint64_t v56 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v57 = (int8x8_t)v56[1];
  uint8x8_t v58 = (uint8x8_t)vcnt_s8(v57);
  v58.i16[0] = vaddlv_u8(v58);
  if (v58.u32[0] > 1uLL)
  {
    uint64_t v59 = 0x1AF456233693CD46;
    if (*(void *)&v57 <= 0x1AF456233693CD46uLL) {
      uint64_t v59 = 0x1AF456233693CD46uLL % *(void *)&v57;
    }
  }
  else
  {
    uint64_t v59 = (*(void *)&v57 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v60 = *v56;
  uint64_t v61 = *(void **)(v60 + 8 * v59);
  if (!v61) {
    goto LABEL_98;
  }
  uint64_t v62 = (void *)*v61;
  if (!v62) {
    goto LABEL_98;
  }
  if (v58.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v64 = v62[1];
      if (v64 == 0x1AF456233693CD46)
      {
        if (v62[2] == 0x1AF456233693CD46) {
          goto LABEL_96;
        }
      }
      else if ((v64 & (*(void *)&v57 - 1)) != v59)
      {
        goto LABEL_98;
      }
      uint64_t v62 = (void *)*v62;
      if (!v62) {
        goto LABEL_98;
      }
    }
  }
  while (1)
  {
    unint64_t v63 = v62[1];
    if (v63 == 0x1AF456233693CD46) {
      break;
    }
    if (v63 >= *(void *)&v57) {
      v63 %= *(void *)&v57;
    }
    if (v63 != v59) {
      goto LABEL_98;
    }
LABEL_85:
    uint64_t v62 = (void *)*v62;
    if (!v62) {
      goto LABEL_98;
    }
  }
  if (v62[2] != 0x1AF456233693CD46) {
    goto LABEL_85;
  }
LABEL_96:
  uint64_t v65 = v62[5];
  if (*(void *)(v65 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v1837 = *(void *)(v65 + 32);
    goto LABEL_99;
  }
LABEL_98:
  uint64_t v1837 = 0;
LABEL_99:
  if (v58.u32[0] > 1uLL)
  {
    uint64_t v66 = 0x13043386C0978CC2;
    if (*(void *)&v57 <= 0x13043386C0978CC2uLL) {
      uint64_t v66 = 0x13043386C0978CC2uLL % *(void *)&v57;
    }
  }
  else
  {
    uint64_t v66 = (*(void *)&v57 - 1) & 0x13043386C0978CC2;
  }
  unint64_t v67 = *(void **)(v60 + 8 * v66);
  if (!v67) {
    goto LABEL_121;
  }
  uint64_t v68 = (void *)*v67;
  if (!v68) {
    goto LABEL_121;
  }
  if (v58.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v70 = v68[1];
      if (v70 == 0x13043386C0978CC2)
      {
        if (v68[2] == 0x13043386C0978CC2) {
          goto LABEL_119;
        }
      }
      else if ((v70 & (*(void *)&v57 - 1)) != v66)
      {
        goto LABEL_121;
      }
      uint64_t v68 = (void *)*v68;
      if (!v68) {
        goto LABEL_121;
      }
    }
  }
  while (2)
  {
    unint64_t v69 = v68[1];
    if (v69 != 0x13043386C0978CC2)
    {
      if (v69 >= *(void *)&v57) {
        v69 %= *(void *)&v57;
      }
      if (v69 != v66) {
        goto LABEL_121;
      }
      goto LABEL_108;
    }
    if (v68[2] != 0x13043386C0978CC2)
    {
LABEL_108:
      uint64_t v68 = (void *)*v68;
      if (!v68) {
        goto LABEL_121;
      }
      continue;
    }
    break;
  }
LABEL_119:
  uint64_t v71 = v68[5];
  if (*(void *)(v71 + 8) == 0x13043386C0978CC2)
  {
    uint64_t v1826 = *(void *)(v71 + 32);
    goto LABEL_122;
  }
LABEL_121:
  uint64_t v1826 = 0;
LABEL_122:
  if (v58.u32[0] > 1uLL)
  {
    unint64_t v72 = 0xA60DDA5A69582425;
    if (*(void *)&v57 <= 0xA60DDA5A69582425) {
      unint64_t v72 = 0xA60DDA5A69582425 % *(void *)&v57;
    }
  }
  else
  {
    unint64_t v72 = (*(void *)&v57 - 1) & 0xA60DDA5A69582425;
  }
  unint64_t v73 = *(void **)(v60 + 8 * v72);
  if (!v73) {
    goto LABEL_143;
  }
  unint64_t v74 = (void *)*v73;
  if (!v74) {
    goto LABEL_143;
  }
  if (v58.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v76 = v74[1];
      if (v76 == 0xA60DDA5A69582425)
      {
        if (v74[2] == 0xA60DDA5A69582425) {
          goto LABEL_141;
        }
      }
      else if ((v76 & (*(void *)&v57 - 1)) != v72)
      {
        goto LABEL_143;
      }
      unint64_t v74 = (void *)*v74;
      if (!v74) {
        goto LABEL_143;
      }
    }
  }
  while (2)
  {
    unint64_t v75 = v74[1];
    if (v75 != 0xA60DDA5A69582425)
    {
      if (v75 >= *(void *)&v57) {
        v75 %= *(void *)&v57;
      }
      if (v75 != v72) {
        goto LABEL_143;
      }
      goto LABEL_131;
    }
    if (v74[2] != 0xA60DDA5A69582425)
    {
LABEL_131:
      unint64_t v74 = (void *)*v74;
      if (!v74) {
        goto LABEL_143;
      }
      continue;
    }
    break;
  }
LABEL_141:
  uint64_t v77 = v74[5];
  if (*(void *)(v77 + 8) == 0xA60DDA5A69582425)
  {
    uint64_t v78 = *(id **)(v77 + 32);
    goto LABEL_144;
  }
LABEL_143:
  uint64_t v78 = 0;
LABEL_144:
  if (v58.u32[0] > 1uLL)
  {
    uint64_t v79 = 0x1B8B241A8D896A1DLL;
    if (*(void *)&v57 <= 0x1B8B241A8D896A1DuLL) {
      uint64_t v79 = 0x1B8B241A8D896A1DuLL % *(void *)&v57;
    }
  }
  else
  {
    uint64_t v79 = (*(void *)&v57 - 1) & 0x1B8B241A8D896A1DLL;
  }
  uint64_t v80 = *(void **)(v60 + 8 * v79);
  if (!v80) {
    goto LABEL_166;
  }
  uint64_t v81 = (void *)*v80;
  if (!v81) {
    goto LABEL_166;
  }
  if (v58.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v83 = v81[1];
      if (v83 == 0x1B8B241A8D896A1DLL)
      {
        if (v81[2] == 0x1B8B241A8D896A1DLL) {
          goto LABEL_164;
        }
      }
      else if ((v83 & (*(void *)&v57 - 1)) != v79)
      {
        goto LABEL_166;
      }
      uint64_t v81 = (void *)*v81;
      if (!v81) {
        goto LABEL_166;
      }
    }
  }
  while (2)
  {
    unint64_t v82 = v81[1];
    if (v82 != 0x1B8B241A8D896A1DLL)
    {
      if (v82 >= *(void *)&v57) {
        v82 %= *(void *)&v57;
      }
      if (v82 != v79) {
        goto LABEL_166;
      }
      goto LABEL_153;
    }
    if (v81[2] != 0x1B8B241A8D896A1DLL)
    {
LABEL_153:
      uint64_t v81 = (void *)*v81;
      if (!v81) {
        goto LABEL_166;
      }
      continue;
    }
    break;
  }
LABEL_164:
  uint64_t v84 = v81[5];
  if (*(void *)(v84 + 8) == 0x1B8B241A8D896A1DLL)
  {
    uint64_t v85 = *(void *)(v84 + 32);
    goto LABEL_167;
  }
LABEL_166:
  uint64_t v85 = 0;
LABEL_167:
  uint64_t v1845 = v85;
  v1818 = v78;
  if (v58.u32[0] >= 2uLL)
  {
    unint64_t v87 = 0x8E4587A431F9C696;
    if (*(void *)&v57 <= 0x8E4587A431F9C696) {
      unint64_t v87 = 0x8E4587A431F9C696 % *(void *)&v57;
    }
    float v86 = *(void **)(v60 + 8 * v87);
    do
    {
      do
        float v86 = (void *)*v86;
      while (v86[1] != 0x8E4587A431F9C696);
    }
    while (v86[2] != 0x8E4587A431F9C696);
  }
  else
  {
    float v86 = *(void **)(v60 + 8 * ((*(void *)&v57 - 1) & 0x8E4587A431F9C696));
    do
    {
      do
        float v86 = (void *)*v86;
      while (v86[1] != 0x8E4587A431F9C696);
    }
    while (v86[2] != 0x8E4587A431F9C696);
  }
  float32_t v88 = *(float *)(*(void *)(v86[5] + 32) + 76);
  unint64_t v89 = *(void **)(*a3 + 216);
  unint64_t v90 = v89[1];
  uint64_t v91 = (float32x4_t *)v89[9];
  gm::operator*<double,4,4,4>((double *)v1969, (double *)(v1837 + 808), (double *)(*a3 + 8));
  *uint64_t v91 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v1969), *(float64x2_t *)&v1969[16]);
  v91[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v1969[32]), *(float64x2_t *)&v1969[48]);
  v91[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v1969[64]), *(float64x2_t *)&v1969[80]);
  v91[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v1969[96]), *(float64x2_t *)&v1969[112]);
  v91[4].f32[0] = v88;
  unint64_t v92 = v89[8];
  if (v92 <= v90) {
    unint64_t v92 = v90;
  }
  v89[7] = 0;
  v89[8] = v92;
  if (*(unsigned __int8 *)(md::LayoutContext::frameState(a2) + 128) - 4 >= 0xFFFFFFFD)
  {
    double v96 = *(double *)(v1837 + 4288);
    double v97 = *(double *)(v1837 + 4296);
    double v1888 = *(double *)(v1837 + 4304);
    double v98 = sqrt(v96 * v96 + v97 * v97 + v1888 * v1888);
    long double v99 = asin(194259.118 / v98);
    long double v100 = cos(1.3962634 - v99);
    v101.f64[0] = 1.0 / v98;
    float v94 = 1.0 / v98 * v96;
    float v95 = 1.0 / v98 * v97;
    v101.f64[1] = v100;
    uint64_t v102 = (const double *)&qword_1A28FB420;
    float64x2_t v103 = vld1q_dup_f64(v102);
    v103.f64[0] = v1888;
    float32x2_t v93 = vcvt_f32_f64(vmulq_f64(v101, v103));
  }
  else
  {
    float32x2_t v93 = 0;
    float v94 = 0.0;
    float v95 = 0.0;
  }
  uint64_t v104 = *a3;
  uint64_t v105 = *(void **)(*a3 + 248);
  unint64_t v106 = v105[1];
  uint64_t v107 = (float32x4_t *)v105[9];
  *uint64_t v107 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(*a3 + 8)), *(float64x2_t *)(*a3 + 24));
  v107[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v104 + 40)), *(float64x2_t *)(v104 + 56));
  v107[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v104 + 72)), *(float64x2_t *)(v104 + 88));
  v107[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v104 + 104)), *(float64x2_t *)(v104 + 120));
  v107[4].f32[0] = v94;
  v107[4].f32[1] = v95;
  *(float32x2_t *)&v107[4].u32[2] = v93;
  unint64_t v108 = v105[8];
  if (v108 <= v106) {
    unint64_t v108 = v106;
  }
  v105[7] = 0;
  v105[8] = v108;
  id v109 = *(id *)a2;
  [v109 contentScale];
  double v111 = v110;
  double v1816 = *(double *)(v1837 + 2984);
  double v112 = *(double *)(*a3 + 168);
  id v113 = *(id *)a2;
  [v113 sizeInPixels];
  double v115 = v114;

  if (!*(void *)(*a3 + 312)) {
    operator new();
  }
  unint64_t v116 = +[VKDebugSettings sharedSettings];
  int v1824 = [v116 showRoutelineAnimation];

  unint64_t v117 = a2;
  uint64_t v118 = (void *)*((void *)a2 + 1);
  int8x8_t v119 = (int8x8_t)v118[1];
  if (!*(void *)&v119)
  {
    uint64_t v1830 = 0;
    uint64_t v121 = v1845;
    if (!v1845) {
      goto LABEL_190;
    }
    goto LABEL_213;
  }
  uint8x8_t v120 = (uint8x8_t)vcnt_s8(v119);
  v120.i16[0] = vaddlv_u8(v120);
  uint64_t v121 = v1845;
  if (v120.u32[0] > 1uLL)
  {
    unint64_t v122 = 0xDFC317497CF9A4BFLL;
    if (*(void *)&v119 <= 0xDFC317497CF9A4BFLL) {
      unint64_t v122 = 0xDFC317497CF9A4BFLL % *(void *)&v119;
    }
  }
  else
  {
    unint64_t v122 = (*(void *)&v119 - 1) & 0xDFC317497CF9A4BFLL;
  }
  size_t v124 = *(void **)(*v118 + 8 * v122);
  if (!v124) {
    goto LABEL_212;
  }
  unint64_t v125 = (void *)*v124;
  if (!v125) {
    goto LABEL_212;
  }
  if (v120.u32[0] < 2uLL)
  {
    uint64_t v126 = *(void *)&v119 - 1;
    while (1)
    {
      uint64_t v128 = v125[1];
      if (v128 == 0xDFC317497CF9A4BFLL)
      {
        if (v125[2] == 0xDFC317497CF9A4BFLL) {
          goto LABEL_209;
        }
      }
      else if ((v128 & v126) != v122)
      {
        goto LABEL_212;
      }
      unint64_t v125 = (void *)*v125;
      if (!v125) {
        goto LABEL_212;
      }
    }
  }
  while (1)
  {
    unint64_t v127 = v125[1];
    if (v127 == 0xDFC317497CF9A4BFLL) {
      break;
    }
    if (v127 >= *(void *)&v119) {
      v127 %= *(void *)&v119;
    }
    if (v127 != v122) {
      goto LABEL_212;
    }
LABEL_198:
    unint64_t v125 = (void *)*v125;
    if (!v125) {
      goto LABEL_212;
    }
  }
  if (v125[2] != 0xDFC317497CF9A4BFLL) {
    goto LABEL_198;
  }
LABEL_209:
  uint64_t v129 = v125[5];
  if (*(void *)(v129 + 8) != 0xDFC317497CF9A4BFLL)
  {
LABEL_212:
    uint64_t v1830 = 0;
    if (!v1845) {
      goto LABEL_190;
    }
    goto LABEL_213;
  }
  uint64_t v1830 = *(void *)(v129 + 32);
  if (v1845)
  {
LABEL_213:
    id v1819 = *(id *)(v121 + 40);

    int v123 = (int)v1819;
    if (v1819) {
      int v123 = [v1819 snappingToTransitLines];
    }
    else {
      id v1819 = 0;
    }
    unint64_t v117 = a2;
    uint64_t v121 = v1845;
    goto LABEL_217;
  }
LABEL_190:
  id v1819 = 0;
  int v123 = 0;
LABEL_217:
  unint64_t v130 = (void *)*((void *)v117 + 1);
  int8x8_t v131 = (int8x8_t)v130[1];
  if (!*(void *)&v131) {
    goto LABEL_243;
  }
  uint8x8_t v132 = (uint8x8_t)vcnt_s8(v131);
  v132.i16[0] = vaddlv_u8(v132);
  if (v132.u32[0] > 1uLL)
  {
    unint64_t v133 = 0xE42D19AFCA302E68;
    if (*(void *)&v131 <= 0xE42D19AFCA302E68) {
      unint64_t v133 = 0xE42D19AFCA302E68 % *(void *)&v131;
    }
  }
  else
  {
    unint64_t v133 = (*(void *)&v131 - 1) & 0xE42D19AFCA302E68;
  }
  unint64_t v134 = *(void **)(*v130 + 8 * v133);
  if (!v134) {
    goto LABEL_243;
  }
  uint64_t v135 = (void *)*v134;
  if (!v135) {
    goto LABEL_243;
  }
  if (v132.u32[0] < 2uLL)
  {
    uint64_t v136 = *(void *)&v131 - 1;
    while (1)
    {
      uint64_t v137 = v135[1];
      if (v137 == 0xE42D19AFCA302E68)
      {
        if (v135[2] == 0xE42D19AFCA302E68) {
          goto LABEL_239;
        }
      }
      else if ((v137 & v136) != v133)
      {
        goto LABEL_243;
      }
      uint64_t v135 = (void *)*v135;
      if (!v135) {
        goto LABEL_243;
      }
    }
  }
  while (2)
  {
    unint64_t v138 = v135[1];
    if (v138 != 0xE42D19AFCA302E68)
    {
      if (v138 >= *(void *)&v131) {
        v138 %= *(void *)&v131;
      }
      if (v138 != v133) {
        goto LABEL_243;
      }
      goto LABEL_233;
    }
    if (v135[2] != 0xE42D19AFCA302E68)
    {
LABEL_233:
      uint64_t v135 = (void *)*v135;
      if (!v135) {
        goto LABEL_243;
      }
      continue;
    }
    break;
  }
LABEL_239:
  uint64_t v139 = v135[5];
  if (*(void *)(v139 + 8) == 0xE42D19AFCA302E68)
  {
    v1835 = *(uint64_t **)(v139 + 32);
    if (!v123) {
      goto LABEL_241;
    }
LABEL_244:
    int v140 = [v1819 currentSegmentIndex];
    if (v121) {
      goto LABEL_245;
    }
LABEL_248:
    int v141 = -1;
    goto LABEL_249;
  }
LABEL_243:
  v1835 = 0;
  if (v123) {
    goto LABEL_244;
  }
LABEL_241:
  int v140 = -1;
  if (!v121) {
    goto LABEL_248;
  }
LABEL_245:
  if (!*(unsigned char *)v121 || !*(unsigned char *)(v121 + 32)) {
    goto LABEL_248;
  }
  int v141 = *(_DWORD *)(v121 + 36);
LABEL_249:
  uint64_t v142 = *(void *)(*v1835 + 520);
  id v143 = *(std::__shared_weak_count **)(*v1835 + 528);
  *(void *)v1969 = v142;
  *(void *)&v1969[8] = v143;
  if (v143) {
    atomic_fetch_add_explicit(&v143->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v1949 = gss::ClientStyleState<gss::PropertyID>::targetMapDisplayStyle(v142);
  if (v143 && !atomic_fetch_add(&v143->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
    std::__shared_weak_count::__release_weak(v143);
  }
  int v1828 = *(unsigned __int8 *)(v1826 + 176);
  float v144 = fmaxf(*(float *)(v1837 + 3080) + *(float *)(v1837 + 3076), 1.0);
  uint64_t v145 = *a3;
  id v146 = *(void **)(*a3 + 160);
  v1943[0] = MEMORY[0x1E4F143A8];
  v1943[1] = 3321888768;
  v1943[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_5;
  v1943[3] = &__block_descriptor_77_ea8_48c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e92_v16__0_fast_shared_ptr_md::RouteLineSection__mdm::MDAllocator_____fast_shared_ptr_control__8l;
  v1943[4] = v1835;
  v1943[5] = &v1949;
  unint64_t v147 = (std::__shared_weak_count *)a3[1];
  v1943[6] = v145;
  v1944 = v147;
  if (v147) {
    atomic_fetch_add_explicit(&v147->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  BOOL v1948 = v1828 == 2;
  float v1945 = v144;
  int v1946 = v140;
  int v1947 = v141;
  [v146 forEachSection:v1943];
  uint64_t v148 = *a3;
  if (!*(void *)(*a3 + 320))
  {
    std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,std::less<GEOComposedRouteSection * {__strong}>,true>,geo::StdAllocator<std::__value_type<GEOComposedRouteSection * {__strong},std::unique_ptr<md::DebugPointsSource>>,mdm::Allocator>>::destroy(v148 + 432, *(void *)(v148 + 440));
    *(void *)(v148 + 456) = 0;
    *(void *)(v148 + 432) = v148 + 440;
    *(void *)(v148 + 440) = 0;
    v1849 = +[VKDebugSettings sharedSettings];
    *(void *)v1969 = 0;
    *(void *)&v1969[8] = v1969;
    *(void *)&v1969[16] = 0x5812000000;
    *(void *)&v1969[24] = __Block_byref_object_copy__7016;
    memset(&v1969[40], 0, 40);
    *(void *)&v1969[32] = __Block_byref_object_dispose__7017;
    *(_DWORD *)&v1969[80] = 1065353216;
    *(void *)v1916 = 0;
    *(void *)&v1916[8] = v1916;
    *(void *)&v1916[16] = 0x5812000000;
    *(void *)&long long v1917 = __Block_byref_object_copy__7_7018;
    long long v1918 = 0u;
    long long v1919 = 0u;
    *((void *)&v1917 + 1) = __Block_byref_object_dispose__8_7019;
    uint64_t v1920 = 0;
    int v1921 = 1065353216;
    uint64_t v149 = *(void **)(*a3 + 160);
    if (v149)
    {
      [v149 sections];
    }
    else
    {
      v1962[1] = 0;
      v1962[0] = 0;
      uint64_t v1963 = 0;
    }
    if ([v1849 disableContinuousMultiSectionRoutes]) {
      goto LABEL_263;
    }
    id v260 = *(id *)(*a3 + 144);
    float64x2_t v261 = [v260 composedRoute];
    if ([v261 transportType] == 3)
    {
    }
    else
    {
      id v262 = *(id *)(*a3 + 144);
      uint64_t v263 = [v262 composedRoute];
      BOOL v264 = [v263 transportType] == 2;

      if (!v264)
      {
LABEL_263:
        unint64_t v5 = (unint64_t)v1962[0];
        int v150 = v1962[1];
        if (v1962[0] == v1962[1]) {
          goto LABEL_596;
        }
        while (1)
        {
          unint64_t v151 = *(id **)v5;
          v1992[0] = v151;
          if (v151) {
            *unint64_t v151 = (char *)*v151 + 1;
          }
          if ([v1849 routeDebugPoints])
          {
            uint64_t v152 = *a3;
            unint64_t v153 = v151 + 1;
            if (!v151) {
              unint64_t v153 = 0;
            }
            id WeakRetained = objc_loadWeakRetained(v153 + 25);
            uint64_t v155 = (uint64_t)WeakRetained;
            uint64_t v156 = *(uint64_t **)(v152 + 440);
            if (v156)
            {
              do
              {
                while (1)
                {
                  uint64_t v158 = (uint64_t **)v156;
                  unint64_t v159 = v156[4];
                  if ((unint64_t)WeakRetained >= v159) {
                    break;
                  }
                  uint64_t v156 = *v158;
                  BOOL v157 = v158;
                  if (!*v158) {
                    goto LABEL_279;
                  }
                }
                if (v159 >= (unint64_t)WeakRetained) {
                  goto LABEL_282;
                }
                uint64_t v156 = v158[1];
              }
              while (v156);
              BOOL v157 = v158 + 1;
            }
            else
            {
              BOOL v157 = (uint64_t **)(v152 + 440);
              uint64_t v158 = (uint64_t **)(v152 + 440);
            }
LABEL_279:
            uint64_t v160 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v152 + 448) + 16))(*(void *)(v152 + 448), 48, 8);
            v160[4] = v155;
            v160[5] = 0;
            *uint64_t v160 = 0;
            v160[1] = 0;
            v160[2] = (uint64_t)v158;
            *BOOL v157 = v160;
            uint64_t v161 = **(void **)(v152 + 432);
            long long v162 = v160;
            if (v161)
            {
              *(void *)(v152 + 432) = v161;
              long long v162 = *v157;
            }
            std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v152 + 440), v162);
            ++*(void *)(v152 + 456);
LABEL_282:
            operator new();
          }
          if (v151) {
            unint64_t v163 = (unint64_t)(v151 + 1);
          }
          else {
            unint64_t v163 = 0;
          }
          if (!*(unsigned char *)(v163 + 236))
          {
            uint64_t v180 = *(void *)&v1969[8];
            *(void *)long long buf = v163;
            unint64_t v181 = (*(uint64_t (**)(void))(**(void **)(v163 + 72) + 24))(*(void *)(v163 + 72));
            {
              operator new();
            }
            float v182 = (md::RouteLineRibbon *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                               + 16))(mdm::Allocator::instance(void)::alloc, 128, 8);
            md::RouteLineRibbon::RouteLineRibbon(v182, v181);
            v1986.i64[0] = (uint64_t)v182;
            if (v181)
            {
              uint64_t v183 = 0;
              for (uint64_t i = 0; i != v181; ++i)
              {
                unint64_t v185 = (_DWORD *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v163 + 72) + 32))(*(void *)(v163 + 72), i);
                size_t v186 = (_DWORD *)(*((void *)v182 + 9) + v183);
                *size_t v186 = *v185;
                v186[1] = v185[1];
                v186[2] = v185[2];
                *(unsigned char *)(*((void *)v182 + 13) + v183 + 8) = *(unsigned char *)((*(uint64_t (**)(void, uint64_t))(**(void **)(v163 + 72) + 32))(*(void *)(v163 + 72), i)+ 44);
                *(unsigned char *)(*((void *)v182 + 13) + v183 + 9) = *(unsigned char *)((*(uint64_t (**)(void, uint64_t))(**(void **)(v163 + 72) + 32))(*(void *)(v163 + 72), i)+ 45);
                *(_DWORD *)(*((void *)v182 + 13) + v183 + 4) = *(_DWORD *)((*(uint64_t (**)(void, uint64_t))(**(void **)(v163 + 72) + 32))(*(void *)(v163 + 72), i)+ 40);
                *(_DWORD *)(*((void *)v182 + 13) + v183) = *(_DWORD *)((*(uint64_t (**)(void, uint64_t))(**(void **)(v163 + 72) + 32))(*(void *)(v163 + 72), i)+ 36);
                v183 += 12;
              }
            }
            uint64_t v187 = (*(uint64_t (**)(void, void))(**(void **)(v163 + 72) + 32))(*(void *)(v163 + 72), 0);
            uint64_t v188 = v1986.i64[0];
            *(_DWORD *)(v1986.i64[0] + 100) = *(_DWORD *)(v187 + 32);
            *(_WORD *)(v188 + 96) = 257;
            uint64_t v189 = std::__hash_table<std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::RouteLineBatchKey,std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::hash<md::RouteLineBatchKey>,std::equal_to<md::RouteLineBatchKey>,true>,std::__unordered_map_equal<md::RouteLineBatchKey,std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::equal_to<md::RouteLineBatchKey>,std::hash<md::RouteLineBatchKey>,true>,std::allocator<std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>>>::__emplace_unique_key_args<md::RouteLineBatchKey,std::piecewise_construct_t const&,std::tuple<md::RouteLineBatchKey const&>,std::tuple<>>((uint64_t *)(v180 + 48), *(unint64_t *)buf, buf);
            BOOL v190 = v189;
            size_t v191 = (uint64_t *)v189[4];
            if ((unint64_t)v191 >= v189[5])
            {
              size_t v193 = std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>>((uint64_t)(v189 + 3), (uint64_t *)&v1986);
            }
            else
            {
              if (v191)
              {
                uint64_t v192 = v1986.i64[0];
                v1986.i64[0] = 0;
                *size_t v191 = v192;
              }
              size_t v193 = v191 + 1;
            }
            v190[4] = v193;
            uint64_t v205 = (void (***)(void))v1986.i64[0];
            v1986.i64[0] = 0;
            if (!v205) {
              goto LABEL_421;
            }
            (**v205)(v205);
            {
              operator new();
            }
            unint64_t v206 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
            goto LABEL_420;
          }
          uint64_t v164 = *(void *)&v1916[8];
          uint64_t v165 = (*(uint64_t (**)(void))(**(void **)(v163 + 72) + 24))(*(void *)(v163 + 72));
          {
            operator new();
          }
          uint64_t v166 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 112, 8);
          unint64_t j = v166;
          double v168 = *(double *)(v163 + 208);
          *(_OWORD *)(v166 + 49) = 0u;
          *(_OWORD *)(v166 + 40) = 0u;
          *(_OWORD *)(v166 + 24) = 0u;
          *(_OWORD *)(v166 + 8) = 0u;
          *(void *)(v166 + 56) = v165;
          *(void *)uint64_t v166 = &unk_1EF553D90;
          *(void *)(v166 + 72) = 0;
          unint64_t v169 = (void *)(v166 + 72);
          *(void *)(v166 + 80) = 0;
          *(void *)(v166 + 88) = 0;
          if (v165)
          {
            *(void *)(v166 + 88) = v165;
            {
              operator new();
            }
            *(void *)(j + 72) = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                       + 16))(mdm::Allocator::instance(void)::alloc, 12 * v165, 8);
            *(unsigned char *)(j + 64) = 1;
          }
          float v170 = v168;
          *(_WORD *)(j + 96) = 0;
          *(void *)unint64_t j = &unk_1EF53F148;
          *(_DWORD *)(j + 100) = 0;
          *(float *)(j + 104) = v170;
          *(void *)long long buf = j;
          if (v165)
          {
            uint64_t v171 = 0;
            for (unint64_t j = 0; j != v165; ++j)
            {
              unint64_t v172 = (_DWORD *)(*(uint64_t (**)(void, unint64_t))(**(void **)(v163 + 72) + 32))(*(void *)(v163 + 72), j);
              uint64_t v173 = (_DWORD *)(*v169 + v171);
              *uint64_t v173 = *v172;
              v173[1] = v172[1];
              v173[2] = v172[2];
              v171 += 12;
            }
          }
          uint64_t v174 = (*(uint64_t (**)(void, void))(**(void **)(v163 + 72) + 32))(*(void *)(v163 + 72), 0);
          *(_DWORD *)(*(void *)buf + 100) = *(_DWORD *)(v174 + 32);
          unint64_t v175 = 0x9DDFEA08EB382D69 * (((8 * v163) + 8) ^ HIDWORD(v163));
          unint64_t v176 = 0x9DDFEA08EB382D69 * (HIDWORD(v163) ^ (v175 >> 47) ^ v175);
          unint64_t v177 = 0x9DDFEA08EB382D69 * (v176 ^ (v176 >> 47));
          unint64_t v178 = *(void *)(v164 + 56);
          if (v178)
          {
            uint8x8_t v179 = (uint8x8_t)vcnt_s8((int8x8_t)v178);
            v179.i16[0] = vaddlv_u8(v179);
            if (v179.u32[0] > 1uLL)
            {
              unint64_t j = 0x9DDFEA08EB382D69 * (v176 ^ (v176 >> 47));
              if (v177 >= v178) {
                unint64_t j = v177 % v178;
              }
            }
            else
            {
              unint64_t j = (v178 - 1) & v177;
            }
            PolylineCoordinate v194 = *(void ***)(*(void *)(v164 + 48) + 8 * j);
            if (v194)
            {
              size_t v195 = *v194;
              if (*v194)
              {
                if (v179.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v197 = v195[1];
                    if (v197 == v177)
                    {
                      if (v195[2] == v163) {
                        goto LABEL_387;
                      }
                    }
                    else if ((v197 & (v178 - 1)) != j)
                    {
                      goto LABEL_322;
                    }
                    size_t v195 = (void *)*v195;
                    if (!v195) {
                      goto LABEL_322;
                    }
                  }
                }
                do
                {
                  unint64_t v196 = v195[1];
                  if (v196 == v177)
                  {
                    if (v195[2] == v163) {
                      goto LABEL_387;
                    }
                  }
                  else
                  {
                    if (v196 >= v178) {
                      v196 %= v178;
                    }
                    if (v196 != j) {
                      break;
                    }
                  }
                  size_t v195 = (void *)*v195;
                }
                while (v195);
              }
            }
          }
LABEL_322:
          size_t v195 = operator new(0x38uLL);
          *size_t v195 = 0;
          v195[1] = v177;
          v195[2] = v163;
          v195[3] = 0;
          v195[4] = 0;
          v195[5] = 0;
          {
            operator new();
          }
          unint64_t v198 = (void *)(v164 + 64);
          v195[6] = mdm::Allocator::instance(void)::alloc;
          float v199 = (float)(unint64_t)(*(void *)(v164 + 72) + 1);
          float v200 = *(float *)(v164 + 80);
          if (!v178 || (float)(v200 * (float)v178) < v199) {
            break;
          }
LABEL_377:
          uint64_t v225 = *(void *)(v164 + 48);
          long long v226 = *(void **)(v225 + 8 * j);
          if (v226)
          {
            *size_t v195 = *v226;
LABEL_385:
            void *v226 = v195;
            goto LABEL_386;
          }
          *size_t v195 = *v198;
          *unint64_t v198 = v195;
          *(void *)(v225 + 8 * j) = v198;
          if (*v195)
          {
            unint64_t v227 = *(void *)(*v195 + 8);
            if ((v178 & (v178 - 1)) != 0)
            {
              if (v227 >= v178) {
                v227 %= v178;
              }
            }
            else
            {
              v227 &= v178 - 1;
            }
            long long v226 = (void *)(*(void *)(v164 + 48) + 8 * v227);
            goto LABEL_385;
          }
LABEL_386:
          ++*(void *)(v164 + 72);
LABEL_387:
          unint64_t v228 = (void *)v195[4];
          unint64_t v229 = v195[5];
          if ((unint64_t)v228 >= v229)
          {
            uint64_t v232 = v195[3];
            uint64_t v233 = ((uint64_t)v228 - v232) >> 3;
            unint64_t v234 = v233 + 1;
            if ((unint64_t)(v233 + 1) >> 61) {
              abort();
            }
            uint64_t v235 = v229 - v232;
            if (v235 >> 2 > v234) {
              unint64_t v234 = v235 >> 2;
            }
            if ((unint64_t)v235 >= 0x7FFFFFFFFFFFFFF8) {
              uint64_t v236 = 0x1FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v236 = v234;
            }
            if (v236)
            {
              uint64_t v237 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v195[6] + 16))(v195[6], 8 * v236, 8);
              uint64_t v238 = (void *)(v237 + 8 * v233);
              uint64_t v239 = v237 + 8 * v236;
              if (v237)
              {
                uint64_t v240 = *(void *)buf;
                *(void *)long long buf = 0;
                *uint64_t v238 = v240;
              }
            }
            else
            {
              uint64_t v239 = 0;
              uint64_t v238 = (void *)(8 * v233);
            }
            float v231 = v238 + 1;
            uint64_t v241 = (char *)v195[3];
            uint64_t v242 = (char *)v195[4];
            if (v242 == v241)
            {
              v195[3] = v238;
              v195[4] = v231;
              uint64_t v248 = v195[5];
              v195[5] = v239;
              goto LABEL_415;
            }
            unint64_t v243 = v242 - v241 - 8;
            if (v243 > 0x57
              && ((unint64_t v244 = (v241 - v242 + 7) & 0xFFFFFFFFFFFFFFF8, &v242[v244] >= (char *)v238)
               || (char *)v238 + v244 >= v242))
            {
              uint64_t v253 = (v243 >> 3) + 1;
              uint64_t v245 = &v242[-8 * (v253 & 0x3FFFFFFFFFFFFFFCLL)];
              int v254 = v238 - 2;
              int v255 = v242 - 32;
              uint64_t v256 = v253 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v258 = *(_OWORD *)v255;
                long long v257 = *((_OWORD *)v255 + 1);
                *(_OWORD *)int v255 = 0uLL;
                *((_OWORD *)v255 + 1) = 0uLL;
                v255 -= 32;
                *(v254 - 1) = v258;
                *int v254 = v257;
                v254 -= 2;
                v256 -= 4;
              }
              while (v256);
              v238 -= v253 & 0x3FFFFFFFFFFFFFFCLL;
              if (v253 == (v253 & 0x3FFFFFFFFFFFFFFCLL))
              {
LABEL_407:
                uint64_t v242 = (char *)v195[3];
                float v247 = (char *)v195[4];
                v195[3] = v238;
                v195[4] = v231;
                uint64_t v248 = v195[5];
                v195[5] = v239;
                while (v247 != v242)
                {
                  float v250 = (void (***)(void))*((void *)v247 - 1);
                  v247 -= 8;
                  uint64_t v249 = v250;
                  *(void *)float v247 = 0;
                  if (v250)
                  {
                    (**v249)(v249);
                    {
                      operator new();
                    }
                    (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                            + 40))(mdm::Allocator::instance(void)::alloc, v249, 112);
                  }
                }
LABEL_415:
                if (v242) {
                  (*(void (**)(void, char *, uint64_t))(*(void *)v195[6] + 40))(v195[6], v242, v248 - (void)v242);
                }
                goto LABEL_417;
              }
            }
            else
            {
              uint64_t v245 = (char *)v195[4];
            }
            do
            {
              uint64_t v246 = *((void *)v245 - 1);
              v245 -= 8;
              *(void *)uint64_t v245 = 0;
              *--uint64_t v238 = v246;
            }
            while (v245 != v241);
            goto LABEL_407;
          }
          if (v228)
          {
            uint64_t v230 = *(void *)buf;
            *(void *)long long buf = 0;
            *unint64_t v228 = v230;
          }
          float v231 = v228 + 1;
LABEL_417:
          v195[4] = v231;
          int v251 = *(void (****)(void))buf;
          *(void *)long long buf = 0;
          if (!v251) {
            goto LABEL_421;
          }
          (**v251)(v251);
          {
            operator new();
          }
          unint64_t v206 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
LABEL_420:
          v206();
LABEL_421:
          int v252 = (char *)v1992[0];
          if (v1992[0])
          {
            _ZF = (*(void *)v1992[0])-- == 1;
            if (_ZF)
            {
              md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v252 + 8));
              {
                operator new();
              }
              (*(void (**)(uint64_t, char *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v252, 400);
            }
          }
          v5 += 8;
          if ((void *)v5 == v150) {
            goto LABEL_596;
          }
        }
        BOOL v201 = (v178 & (v178 - 1)) != 0;
        if (v178 < 3) {
          BOOL v201 = 1;
        }
        unint64_t v202 = v201 | (2 * v178);
        unint64_t v203 = vcvtps_u32_f32(v199 / v200);
        if (v202 <= v203) {
          size_t prime = v203;
        }
        else {
          size_t prime = v202;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
        }
        unint64_t v178 = *(void *)(v164 + 56);
        if (prime <= v178)
        {
          if (prime >= v178) {
            goto LABEL_364;
          }
          unint64_t v218 = vcvtps_u32_f32((float)*(unint64_t *)(v164 + 72) / *(float *)(v164 + 80));
          if (v178 < 3
            || (uint8x8_t v219 = (uint8x8_t)vcnt_s8((int8x8_t)v178), v219.i16[0] = vaddlv_u8(v219), v219.u32[0] > 1uLL))
          {
            unint64_t v218 = std::__next_prime(v218);
          }
          else
          {
            uint64_t v220 = 1 << -(char)__clz(v218 - 1);
            if (v218 >= 2) {
              unint64_t v218 = v220;
            }
          }
          if (prime <= v218) {
            size_t prime = v218;
          }
          if (prime >= v178)
          {
            unint64_t v178 = *(void *)(v164 + 56);
LABEL_364:
            if ((v178 & (v178 - 1)) != 0)
            {
              if (v177 >= v178) {
                unint64_t j = v177 % v178;
              }
              else {
                unint64_t j = v177;
              }
            }
            else
            {
              unint64_t j = (v178 - 1) & v177;
            }
            goto LABEL_377;
          }
          if (!prime)
          {
            uint64_t v259 = *(void **)(v164 + 48);
            *(void *)(v164 + 48) = 0;
            if (v259) {
              operator delete(v259);
            }
            unint64_t v178 = 0;
            *(void *)(v164 + 56) = 0;
            goto LABEL_364;
          }
        }
        if (prime >> 61) {
          goto LABEL_2741;
        }
        uint64_t v207 = operator new(8 * prime);
        uint64_t v208 = *(void **)(v164 + 48);
        *(void *)(v164 + 48) = v207;
        if (v208) {
          operator delete(v208);
        }
        uint64_t v209 = 0;
        *(void *)(v164 + 56) = prime;
        do
          *(void *)(*(void *)(v164 + 48) + 8 * v209++) = 0;
        while (prime != v209);
        uint64_t v210 = (void *)*v198;
        if (!*v198)
        {
LABEL_363:
          unint64_t v178 = prime;
          goto LABEL_364;
        }
        size_t v211 = v210[1];
        size_t v212 = prime - 1;
        if ((prime & (prime - 1)) == 0)
        {
          size_t v213 = v211 & v212;
          *(void *)(*(void *)(v164 + 48) + 8 * v213) = v198;
          for (uint64_t k = (void *)*v210; *v210; uint64_t k = (void *)*v210)
          {
            size_t v215 = k[1] & v212;
            if (v215 == v213)
            {
              uint64_t v210 = k;
            }
            else
            {
              uint64_t v216 = *(void *)(v164 + 48);
              if (*(void *)(v216 + 8 * v215))
              {
                void *v210 = *k;
                uint64_t v217 = 8 * v215;
                *uint64_t k = **(void **)(*(void *)(v164 + 48) + v217);
                **(void **)(*(void *)(v164 + 48) + v217) = k;
              }
              else
              {
                *(void *)(v216 + 8 * v215) = v210;
                uint64_t v210 = k;
                size_t v213 = v215;
              }
            }
          }
          goto LABEL_363;
        }
        if (v211 >= prime) {
          v211 %= prime;
        }
        *(void *)(*(void *)(v164 + 48) + 8 * v211) = v198;
        uint64_t v221 = (void *)*v210;
        if (!*v210) {
          goto LABEL_363;
        }
        while (1)
        {
          size_t v223 = v221[1];
          if (v223 >= prime) {
            v223 %= prime;
          }
          if (v223 != v211)
          {
            uint64_t v224 = *(void *)(v164 + 48);
            if (!*(void *)(v224 + 8 * v223))
            {
              *(void *)(v224 + 8 * v223) = v210;
              goto LABEL_368;
            }
            void *v210 = *v221;
            uint64_t v222 = 8 * v223;
            *uint64_t v221 = **(void **)(*(void *)(v164 + 48) + v222);
            **(void **)(*(void *)(v164 + 48) + v222) = v221;
            uint64_t v221 = v210;
          }
          size_t v223 = v211;
LABEL_368:
          uint64_t v210 = v221;
          uint64_t v221 = (void *)*v221;
          size_t v211 = v223;
          if (!v221) {
            goto LABEL_363;
          }
        }
      }
    }
    uint64_t v265 = v1962[0];
    if (v1962[1] == v1962[0]) {
      goto LABEL_596;
    }
    unint64_t v266 = 0;
    int v267 = 0;
    std::string __p = 0;
    v1833 = 0;
    unint64_t v268 = ((char *)v1962[1] - (char *)v1962[0]) >> 3;
    long long v269 = a3;
    do
    {
      uint64_t v270 = 0;
      uint64_t v271 = v265[v266];
      if (v271) {
        uint64_t v272 = (id *)(v271 + 8);
      }
      else {
        uint64_t v272 = 0;
      }
      if (++v266 < v268)
      {
        uint64_t v273 = v265[v266];
        if (v273) {
          uint64_t v270 = v273 + 8;
        }
        else {
          uint64_t v270 = 0;
        }
      }
      int v274 = [v1849 continuousMultiSectionRouteAdditionalOverlap];
      LODWORD(v1888) = v267;
      if (v270)
      {
        int v275 = v274;
        long long v276 = (float *)(*(uint64_t (**)(uint64_t, void))(*(void *)v270 + 48))(v270, 0);
        uint64_t v277 = (*((uint64_t (**)(id *))*v272 + 7))(v272);
        uint64_t v278 = (*((uint64_t (**)(id *, uint64_t))*v272 + 6))(v272, v277 - 1);
        float v279 = *(float *)v278;
        if (vabds_f32(*(float *)v278, *v276) >= 0.000001
          || (float v280 = *(float *)(v278 + 4), vabds_f32(v280, v276[1]) >= 0.000001))
        {
          int v302 = 0;
          unint64_t v285 = __p;
        }
        else
        {
          float v281 = v88;
          float v282 = *(float *)(v278 + 8);
          if (vabds_f32(v282, v276[2]) >= 0.000001)
          {
            int v302 = 0;
            unint64_t v285 = __p;
            float32_t v88 = v281;
          }
          else
          {
            uint64_t v283 = (v275 + 1);
            if (v275 == -1)
            {
              int v302 = 1;
              unint64_t v285 = __p;
              float32_t v88 = v281;
            }
            else
            {
              unint64_t v284 = 1;
              unint64_t v285 = __p;
              while (v284 < (*(uint64_t (**)(uint64_t))(*(void *)v270 + 56))(v270))
              {
                uint64_t v286 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v270 + 48))(v270, v284);
                uint64_t v287 = v286;
                if (vabds_f32(v279, *(float *)v286) >= 0.000001
                  || vabds_f32(v280, *(float *)(v286 + 4)) >= 0.000001
                  || vabds_f32(v282, *(float *)(v286 + 8)) >= 0.000001)
                {
                  if (v285 >= v1833)
                  {
                    unint64_t v290 = v266;
                    unint64_t v291 = 0xAAAAAAAAAAAAAAABLL * ((v285 - __p) >> 4) + 1;
                    if (v291 > 0x555555555555555) {
                      abort();
                    }
                    if (0x5555555555555556 * ((v1833 - __p) >> 4) > v291) {
                      unint64_t v291 = 0x5555555555555556 * ((v1833 - __p) >> 4);
                    }
                    if (0xAAAAAAAAAAAAAAABLL * ((v1833 - __p) >> 4) >= 0x2AAAAAAAAAAAAAALL) {
                      unint64_t v292 = 0x555555555555555;
                    }
                    else {
                      unint64_t v292 = v291;
                    }
                    if (v292)
                    {
                      if (v292 > 0x555555555555555) {
                        goto LABEL_2741;
                      }
                      id v293 = (char *)operator new(48 * v292);
                    }
                    else
                    {
                      id v293 = 0;
                    }
                    id v294 = &v293[16 * ((v285 - __p) >> 4)];
                    long long v295 = *(_OWORD *)v287;
                    long long v296 = *(_OWORD *)(v287 + 32);
                    *((_OWORD *)v294 + 1) = *(_OWORD *)(v287 + 16);
                    *((_OWORD *)v294 + 2) = v296;
                    *(_OWORD *)id v294 = v295;
                    if (v285 == __p)
                    {
                      uint64_t v299 = &v293[16 * ((v285 - __p) >> 4)];
                      long long v298 = __p;
                    }
                    else
                    {
                      uint64_t v297 = &v293[16 * ((v285 - __p) >> 4)];
                      long long v298 = __p;
                      do
                      {
                        uint64_t v299 = v297 - 48;
                        long long v300 = *((_OWORD *)v285 - 3);
                        long long v301 = *((_OWORD *)v285 - 1);
                        *((_OWORD *)v297 - 2) = *((_OWORD *)v285 - 2);
                        *((_OWORD *)v297 - 1) = v301;
                        *((_OWORD *)v297 - 3) = v300;
                        v285 -= 48;
                        v297 -= 48;
                      }
                      while (v285 != __p);
                    }
                    v1833 = &v293[48 * v292];
                    unint64_t v285 = v294 + 48;
                    if (v298) {
                      operator delete(v298);
                    }
                    std::string __p = v299;
                    long long v269 = a3;
                    unint64_t v266 = v290;
                  }
                  else
                  {
                    long long v288 = *(_OWORD *)v286;
                    long long v289 = *(_OWORD *)(v286 + 32);
                    *((_OWORD *)v285 + 1) = *(_OWORD *)(v286 + 16);
                    *((_OWORD *)v285 + 2) = v289;
                    *(_OWORD *)unint64_t v285 = v288;
                    v285 += 48;
                  }
                  --v283;
                  float v279 = *(float *)v287;
                  float v280 = *(float *)(v287 + 4);
                  float v282 = *(float *)(v287 + 8);
                }
                ++v284;
                int v302 = 1;
                if (!v283)
                {
                  float32_t v88 = v281;
                  goto LABEL_501;
                }
              }
              int v302 = 1;
              float32_t v88 = v281;
            }
          }
        }
      }
      else
      {
        int v302 = 0;
        unint64_t v285 = __p;
      }
LABEL_501:
      uint64_t v303 = (*((uint64_t (**)(id *))*v272 + 7))(v272);
      {
        operator new();
      }
      uint64_t v304 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                  + 16))(mdm::Allocator::instance(void)::alloc, 128, 8);
      unint64_t v5 = (v285 - __p) / 48;
      unint64_t v1870 = v303 + v5;
      md::RouteLineRibbon::RouteLineRibbon((md::RouteLineRibbon *)v304, v303 + v5);
      *(void *)long long buf = v304;
      uint64_t v305 = 0;
      unint64_t v306 = 0;
      *(_DWORD *)(v304 + 100) = *(_DWORD *)((*((uint64_t (**)(id *, void))*v272 + 6))(v272, 0) + 32);
      *(unsigned char *)(v304 + 96) = (LOBYTE(v1888) & 1) == 0;
      *(unsigned char *)(v304 + 97) = v302 ^ 1;
      while (v306 < (*((uint64_t (**)(id *))*v272 + 7))(v272))
      {
        uint64_t v307 = (_DWORD *)(*((uint64_t (**)(id *, unint64_t))*v272 + 6))(v272, v306);
        double v308 = (_DWORD *)(*(void *)(v304 + 72) + v305);
        _DWORD *v308 = *v307;
        v308[1] = v307[1];
        v308[2] = v307[2];
        *(unsigned char *)(*(void *)(v304 + 104) + v305 + 8) = *(unsigned char *)((*((uint64_t (**)(id *, unint64_t))*v272
                                                                     + 6))(v272, v306++)+ 44);
        v305 += 12;
      }
      int v1840 = v302;
      if (v285 != __p)
      {
        uint64_t v309 = 0;
        if (v5 <= 1) {
          uint64_t v310 = 1;
        }
        else {
          uint64_t v310 = (v285 - __p) / 48;
        }
        char v311 = __p;
        do
        {
          uint64_t v312 = *(void *)(v304 + 72);
          unint64_t v5 = 12;
          long long v313 = (_DWORD *)(v312 + 12 * (v309 + (*((uint64_t (**)(id *))*v272 + 7))(v272)));
          _DWORD *v313 = *(_DWORD *)v311;
          v313[1] = *((_DWORD *)v311 + 1);
          v313[2] = *((_DWORD *)v311 + 2);
          LOBYTE(v312) = v311[44];
          *(unsigned char *)(*(void *)(v304 + 104) + 12 * (v309 + (*((uint64_t (**)(id *))*v272 + 7))(v272)) + 8) = v312;
          ++v309;
          v311 += 48;
        }
        while (v310 != v309);
      }
      if ([v1849 routeDebugPoints])
      {
        {
          operator new();
        }
        uint64_t v1865 = mdm::Allocator::instance(void)::alloc;
        {
          operator new();
        }
        uint64_t v1859 = mdm::Allocator::instance(void)::alloc;
        if (!v1870)
        {
LABEL_565:
          uint64_t v352 = *v269;
          id v353 = objc_loadWeakRetained(v272 + 25);
          uint64_t v354 = (uint64_t)v353;
          __int16 v355 = *(uint64_t **)(v352 + 440);
          if (v355)
          {
            do
            {
              while (1)
              {
                uint64_t v357 = (uint64_t **)v355;
                unint64_t v358 = v355[4];
                if ((unint64_t)v353 >= v358) {
                  break;
                }
                __int16 v355 = *v357;
                v356 = v357;
                if (!*v357) {
                  goto LABEL_572;
                }
              }
              if (v358 >= (unint64_t)v353) {
                goto LABEL_575;
              }
              __int16 v355 = v357[1];
            }
            while (v355);
            v356 = v357 + 1;
          }
          else
          {
            v356 = (uint64_t **)(v352 + 440);
            uint64_t v357 = (uint64_t **)(v352 + 440);
          }
LABEL_572:
          BOOL v359 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v352 + 448) + 16))(*(void *)(v352 + 448), 48, 8);
          v359[4] = v354;
          v359[5] = 0;
          uint64_t *v359 = 0;
          v359[1] = 0;
          v359[2] = (uint64_t)v357;
          uint64_t *v356 = v359;
          uint64_t v360 = **(void **)(v352 + 432);
          BOOL v361 = v359;
          if (v360)
          {
            *(void *)(v352 + 432) = v360;
            BOOL v361 = *v356;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v352 + 440), v361);
          ++*(void *)(v352 + 456);
LABEL_575:
          operator new();
        }
        uint64_t v314 = 0;
        unint64_t v315 = 0;
        unint64_t v1889 = 0;
        int v316 = 0;
        int v317 = 0;
        unint64_t v1879 = 0;
        uint64_t v318 = 0;
        while (1)
        {
          uint64_t v319 = *(void *)buf;
          uint64_t v320 = *(void *)(*(void *)buf + 72) + 12 * v318;
          if (v315 >= v1889)
          {
            unint64_t v322 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v315 - v314) >> 2);
            unint64_t v323 = v322 + 1;
            if (v322 + 1 > 0x1555555555555555) {
              goto LABEL_2743;
            }
            unint64_t v324 = v1889 - v314;
            if (0x5555555555555556 * ((uint64_t)(v1889 - v314) >> 2) > v323) {
              unint64_t v323 = 0x5555555555555556 * ((uint64_t)(v1889 - v314) >> 2);
            }
            uint64_t v325 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v1889 - v314) >> 2) >= 0xAAAAAAAAAAAAAAALL
                 ? 0x1555555555555555
                 : v323;
            if (v325)
            {
              uint64_t v1876 = v314;
              uint64_t v326 = v316;
              unint64_t v327 = v324;
              uint64_t v328 = v317;
              uint64_t v329 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1865 + 16))(v1865, 12 * v325, 4);
              uint64_t v330 = v329 + 12 * v322;
              unint64_t v1889 = v329 + 12 * v325;
              if (v329)
              {
                uint64_t v331 = *(void *)v320;
                *(_DWORD *)(v330 + 8) = *(_DWORD *)(v320 + 8);
                *(void *)uint64_t v330 = v331;
              }
              int v317 = v328;
              unint64_t v324 = v327;
              int v316 = v326;
              uint64_t v314 = v1876;
            }
            else
            {
              unint64_t v1889 = 0;
              uint64_t v330 = 4 * ((uint64_t)(v315 - v314) >> 2);
            }
            uint64_t v332 = v330;
            if (v315 != v314)
            {
              uint64_t v332 = v330;
              do
              {
                uint64_t v333 = *(void *)(v315 - 12);
                v315 -= 12;
                int v334 = *(_DWORD *)(v315 + 8);
                *(void *)(v332 - 12) = v333;
                v332 -= 12;
                *(_DWORD *)(v332 + 8) = v334;
              }
              while (v315 != v314);
            }
            unint64_t v315 = v330 + 12;
            if (v314)
            {
              v335 = v317;
              (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)v1865 + 40))(v1865, v314, v324);
              int v317 = v335;
              uint64_t v319 = *(void *)buf;
            }
            uint64_t v314 = v332;
          }
          else
          {
            if (v315)
            {
              uint64_t v321 = *(void *)v320;
              *(_DWORD *)(v315 + 8) = *(_DWORD *)(v320 + 8);
              *(void *)unint64_t v315 = v321;
            }
            v315 += 12;
          }
          v336 = (unsigned char *)(*(void *)(v319 + 104) + 12 * v318 + 8);
          if ((unint64_t)v317 >= v1879) {
            break;
          }
          long long v269 = a3;
          if (v317) {
            *int v317 = *v336;
          }
          ++v317;
LABEL_517:
          if (++v318 == v1870) {
            goto LABEL_565;
          }
        }
        unint64_t v337 = v317 - v316;
        uint64_t v338 = v317 - v316 + 1;
        if (v338 < 0) {
LABEL_2743:
        }
          abort();
        unint64_t v339 = v1879 - (void)v316;
        if (2 * (v1879 - (unint64_t)v316) > v338) {
          uint64_t v338 = 2 * (v1879 - (void)v316);
        }
        if (v339 >= 0x3FFFFFFFFFFFFFFFLL) {
          uint64_t v340 = 0x7FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v340 = v338;
        }
        if (v340)
        {
          float v341 = v317;
          uint64_t v342 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1859 + 16))(v1859, v340, 1);
          v343 = (unsigned char *)(v342 + v337);
          unint64_t v1879 = v342 + v340;
          int v317 = v341;
          if (v342) {
            unsigned char *v343 = *v336;
          }
        }
        else
        {
          unint64_t v1879 = 0;
          v343 = (unsigned char *)(v317 - v316);
        }
        unint64_t v344 = v343;
        if (v317 != v316)
        {
          if (v337 < 0x20 || (unint64_t)(v317 - v343) < 0x20)
          {
            uint64_t v345 = v317;
            unint64_t v344 = v343;
          }
          else
          {
            uint64_t v345 = &v317[-(v337 & 0xFFFFFFFFFFFFFFE0)];
            uint64_t v346 = v343 - 16;
            uint64_t v347 = (long long *)(v317 - 16);
            unint64_t v348 = v337 & 0xFFFFFFFFFFFFFFE0;
            do
            {
              long long v349 = *v347;
              *(v346 - 1) = *(v347 - 1);
              *uint64_t v346 = v349;
              v346 -= 2;
              v347 -= 2;
              v348 -= 32;
            }
            while (v348);
            unint64_t v344 = &v343[-(v337 & 0xFFFFFFFFFFFFFFE0)];
            if (v337 == (v337 & 0xFFFFFFFFFFFFFFE0)) {
              goto LABEL_562;
            }
          }
          do
          {
            char v350 = *--v345;
            *--unint64_t v344 = v350;
          }
          while (v345 != v316);
        }
LABEL_562:
        int v317 = v343 + 1;
        if (v316)
        {
          uint64_t v351 = v343 + 1;
          (*(void (**)(uint64_t, unsigned char *, unint64_t))(*(void *)v1859 + 40))(v1859, v316, v339);
          int v317 = v351;
        }
        int v316 = v344;
        long long v269 = a3;
        goto LABEL_517;
      }
      v1986.i64[0] = (uint64_t)v272;
      uint64_t v362 = std::__hash_table<std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::RouteLineBatchKey,std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::hash<md::RouteLineBatchKey>,std::equal_to<md::RouteLineBatchKey>,true>,std::__unordered_map_equal<md::RouteLineBatchKey,std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::equal_to<md::RouteLineBatchKey>,std::hash<md::RouteLineBatchKey>,true>,std::allocator<std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>>>::__emplace_unique_key_args<md::RouteLineBatchKey,std::piecewise_construct_t const&,std::tuple<md::RouteLineBatchKey const&>,std::tuple<>>((uint64_t *)(*(void *)&v1969[8] + 48), (unint64_t)v272, &v1986);
      v363 = v362;
      v364 = (void *)v362[4];
      if ((unint64_t)v364 >= v362[5])
      {
        uint64_t v366 = std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>>((uint64_t)(v362 + 3), (uint64_t *)buf);
      }
      else
      {
        if (v364)
        {
          uint64_t v365 = *(void *)buf;
          *(void *)long long buf = 0;
          void *v364 = v365;
        }
        uint64_t v366 = v364 + 1;
      }
      v363[4] = v366;
      id v367 = *(void (****)(void))buf;
      *(void *)long long buf = 0;
      if (v367)
      {
        (**v367)(v367);
        {
          operator new();
        }
        (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                + 40))(mdm::Allocator::instance(void)::alloc, v367, 128);
      }
      uint64_t v265 = v1962[0];
      unint64_t v268 = ((char *)v1962[1] - (char *)v1962[0]) >> 3;
      int v267 = v1840;
    }
    while (v266 < v268);
    if (__p) {
      operator delete(__p);
    }
LABEL_596:
    id v368 = *(void **)(*(void *)&v1969[8] + 64);
    if (v368)
    {
      int v369 = 0;
      while (1)
      {
        double v370 = (char *)v368[3];
        v371 = (char *)v368[4];
        if (v370 != v371)
        {
          unint64_t v372 = v371 - v370 - 8;
          if (v372 >= 8)
          {
            int v373 = 0;
            uint64_t v374 = (v372 >> 3) + 1;
            uint64_t v375 = v370 + 8;
            uint64_t v376 = v374 & 0x3FFFFFFFFFFFFFFELL;
            do
            {
              v369 += *(_DWORD *)(*(v375 - 1) + 88);
              v373 += *(_DWORD *)(*v375 + 88);
              v375 += 2;
              v376 -= 2;
            }
            while (v376);
            v369 += v373;
            if (v374 == (v374 & 0x3FFFFFFFFFFFFFFELL)) {
              goto LABEL_598;
            }
            v370 += 8 * (v374 & 0x3FFFFFFFFFFFFFFELL);
          }
          do
          {
            uint64_t v377 = *(void *)v370;
            v370 += 8;
            v369 += *(_DWORD *)(v377 + 88);
          }
          while (v370 != v371);
        }
LABEL_598:
        id v368 = (void *)*v368;
        if (!v368) {
          goto LABEL_608;
        }
      }
    }
    int v369 = 0;
LABEL_608:
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    v378 = (id)GEOGetVectorKitRouteLog_log;
    if (os_log_type_enabled(v378, OS_LOG_TYPE_INFO))
    {
      uint64_t v379 = *(void *)(*(void *)&v1969[8] + 72);
      *(_DWORD *)long long buf = 134218240;
      *(void *)&buf[4] = v379;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v369;
      _os_log_impl(&dword_1A1780000, v378, OS_LOG_TYPE_INFO, "RouteRenderLayer::buildRouteLineLayer routeRibbons size: %zu  pointCount: %d", buf, 0x12u);
    }

    uint64_t v380 = *((void *)v1821 + 92);
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&buf[16] = ___ZN2md16RouteRenderLayer19buildRouteLineLayerERKNS_13LayoutContextERKNSt3__110shared_ptrINS_16RouteLineOverlayEEE_block_invoke;
    *(void *)&buf[24] = &unk_1E5A8EB40;
    *(void *)&v1982[8] = a3;
    *(void *)v1982 = v1969;
    *(void *)&v1987[8] = 0;
    v1986.i64[0] = (uint64_t)&unk_1EF56BC58;
    v1986.i64[1] = MEMORY[0x1A6239EB0](buf);
    *(void *)&v1987[8] = &v1986;
    v1992[1] = 0;
    v1992[0] = 0;
    (*(void (**)(void, float32x4_t *, void **))(**(void **)(v380 + 32) + 16))(*(void *)(v380 + 32), &v1986, v1992);
    id v381 = (std::__shared_weak_count *)v1992[1];
    if (v1992[1] && !atomic_fetch_add((atomic_ullong *volatile)v1992[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v381->__on_zero_shared)(v381);
      std::__shared_weak_count::__release_weak(v381);
    }
    if (*(float32x4_t **)&v1987[8] == &v1986)
    {
      (*(void (**)(float32x4_t *))(v1986.i64[0] + 32))(&v1986);
    }
    else if (*(void *)&v1987[8])
    {
      (*(void (**)(void))(**(void **)&v1987[8] + 40))();
    }
    uint64_t v382 = *((void *)v1821 + 92);
    v1986.i64[0] = MEMORY[0x1E4F143A8];
    v1986.i64[1] = 3221225472;
    *(void *)v1987 = ___ZN2md16RouteRenderLayer19buildRouteLineLayerERKNS_13LayoutContextERKNSt3__110shared_ptrINS_16RouteLineOverlayEEE_block_invoke_2;
    *(void *)&v1987[8] = &unk_1E5A8EB40;
    *(void *)&v1987[24] = a3;
    *(void *)&v1987[16] = v1916;
    *((void *)&v1993 + 1) = 0;
    v1992[0] = &unk_1EF56BC58;
    v1992[1] = (void *)MEMORY[0x1A6239EB0](&v1986);
    *((void *)&v1993 + 1) = v1992;
    long long v2001 = 0uLL;
    (*(void (**)(void, void **, long long *))(**(void **)(v382 + 32) + 16))(*(void *)(v382 + 32), v1992, &v2001);
    v383 = (std::__shared_weak_count *)*((void *)&v2001 + 1);
    if (*((void *)&v2001 + 1)
      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v2001 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v383->__on_zero_shared)(v383);
      std::__shared_weak_count::__release_weak(v383);
    }
    if (*((void ***)&v1993 + 1) == v1992)
    {
      (*((void (**)(void **))v1992[0] + 4))(v1992);
      uint64_t v384 = (char *)v1962[0];
      if (!v1962[0])
      {
LABEL_640:
        _Block_object_dispose(v1916, 8);
        std::__hash_table<std::__hash_value_type<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::DottedRouteLineBatchKey,std::__hash_value_type<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>,std::hash<md::DottedRouteLineBatchKey>,std::equal_to<md::DottedRouteLineBatchKey>,true>,std::__unordered_map_equal<md::DottedRouteLineBatchKey,std::__hash_value_type<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>,std::equal_to<md::DottedRouteLineBatchKey>,std::hash<md::DottedRouteLineBatchKey>,true>,std::allocator<std::__hash_value_type<md::DottedRouteLineBatchKey,std::vector<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::DottedRouteLineRibbon,mdm::TypeDeleter<md::DottedRouteLineRibbon>>,mdm::Allocator>>>>>::__deallocate_node(*((void ***)&v1919 + 1));
        v390 = (void *)*((void *)&v1918 + 1);
        *((void *)&v1918 + 1) = 0;
        if (v390) {
          operator delete(v390);
        }
        _Block_object_dispose(v1969, 8);
        std::__hash_table<std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::RouteLineBatchKey,std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::hash<md::RouteLineBatchKey>,std::equal_to<md::RouteLineBatchKey>,true>,std::__unordered_map_equal<md::RouteLineBatchKey,std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::equal_to<md::RouteLineBatchKey>,std::hash<md::RouteLineBatchKey>,true>,std::allocator<std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>>>::__deallocate_node(*(void ***)&v1969[64]);
        v391 = *(void **)&v1969[48];
        *(void *)&v1969[48] = 0;
        if (v391) {
          operator delete(v391);
        }

        uint64_t v148 = *a3;
        int v7 = 1;
        unint64_t v117 = v1821;
        if (*(void *)(*a3 + 328)) {
          goto LABEL_957;
        }
LABEL_645:
        unint64_t v392 = (void *)*((void *)v117 + 1);
        int8x8_t v393 = (int8x8_t)v392[1];
        if (!*(void *)&v393)
        {
          v1877 = 0;
          v395 = a3;
          goto LABEL_670;
        }
        uint8x8_t v394 = (uint8x8_t)vcnt_s8(v393);
        v394.i16[0] = vaddlv_u8(v394);
        v395 = a3;
        if (v394.u32[0] > 1uLL)
        {
          unint64_t v396 = 0xE42D19AFCA302E68;
          if (*(void *)&v393 <= 0xE42D19AFCA302E68) {
            unint64_t v396 = 0xE42D19AFCA302E68 % *(void *)&v393;
          }
        }
        else
        {
          unint64_t v396 = (*(void *)&v393 - 1) & 0xE42D19AFCA302E68;
        }
        v397 = *(void **)(*v392 + 8 * v396);
        if (!v397) {
          goto LABEL_669;
        }
        uint64_t v398 = (void *)*v397;
        if (!v398) {
          goto LABEL_669;
        }
        if (v394.u32[0] < 2uLL)
        {
          uint64_t v399 = *(void *)&v393 - 1;
          while (1)
          {
            uint64_t v401 = v398[1];
            if (v401 == 0xE42D19AFCA302E68)
            {
              if (v398[2] == 0xE42D19AFCA302E68) {
                goto LABEL_667;
              }
            }
            else if ((v401 & v399) != v396)
            {
              goto LABEL_669;
            }
            uint64_t v398 = (void *)*v398;
            if (!v398) {
              goto LABEL_669;
            }
          }
        }
        while (1)
        {
          unint64_t v400 = v398[1];
          if (v400 == 0xE42D19AFCA302E68) {
            break;
          }
          if (v400 >= *(void *)&v393) {
            v400 %= *(void *)&v393;
          }
          if (v400 != v396) {
            goto LABEL_669;
          }
LABEL_656:
          uint64_t v398 = (void *)*v398;
          if (!v398) {
            goto LABEL_669;
          }
        }
        if (v398[2] != 0xE42D19AFCA302E68) {
          goto LABEL_656;
        }
LABEL_667:
        uint64_t v402 = v398[5];
        if (*(void *)(v402 + 8) == 0xE42D19AFCA302E68)
        {
          v1877 = *(uint64_t **)(v402 + 32);
          goto LABEL_670;
        }
LABEL_669:
        v1877 = 0;
LABEL_670:
        *(void *)v1969 = 0;
        *(void *)&v1969[8] = v1969;
        *(void *)&v1969[16] = 0x5812000000;
        *(void *)&v1969[24] = __Block_byref_object_copy__14_7011;
        memset(&v1969[40], 0, 40);
        *(void *)&v1969[32] = __Block_byref_object_dispose__15_7012;
        *(_DWORD *)&v1969[80] = 1065353216;
        v403 = *(void **)(v148 + 160);
        if (v403)
        {
          unint64_t v404 = (gss::Allocator *)[v403 sections];
          v405 = v1998;
          v1850 = (void **)v1999;
          if (v1998 != (void **)v1999)
          {
            long long v406 = 0uLL;
            do
            {
              v1866 = v405;
              v407 = *v405;
              v1996[0] = (uint64_t)v407;
              if (v407) {
                ++*v407;
              }
              uint64_t v408 = *(void *)&v1969[8];
              v1860 = v407;
              __pa = (md::RouteLineSection *)(v407 + 1);
              if (v407) {
                unint64_t v409 = (float *)(v407 + 1);
              }
              else {
                unint64_t v409 = 0;
              }
              *(_OWORD *)&v1916[8] = v406;
              long long v1917 = v406;
              *(void *)v1916 = v409;
              v1992[1] = 0;
              v1992[0] = 0;
              *(void *)&long long v1993 = 0;
              BOOL v410 = 0;
              v411 = 0;
              *((void *)&v1993 + 1) = gss::Allocator::instance(v404);
              v1871 = (float **)(v408 + 64);
              uint64_t v1880 = v408;
              while (1)
              {
                unint64_t v404 = (gss::Allocator *)(*(uint64_t (**)(void))(**((void **)v409 + 9) + 24))(*((void *)v409 + 9));
                if (v404 == v410) {
                  break;
                }
                float v412 = (unsigned __int8 *)(*(uint64_t (**)(void, gss::Allocator *))(**((void **)v409 + 9)
                                                                                              + 32))(*((void *)v409 + 9), v410);
                uint64_t v413 = v412[47];
                uint64_t v414 = gss::Allocator::instance((gss::Allocator *)v412);
                *(void *)&buf[24] = v414;
                uint64_t v415 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v414 + 16))(v414, 24, 4);
                uint64_t v416 = v415;
                *(void *)long long buf = v415;
                *(void *)&buf[16] = v415 + 24;
                if (v415) {
                  *(void *)uint64_t v415 = 0xB00000005;
                }
                *(void *)&double v1888 = (*(void *)&v1888 & 0xFFFF000000000000 | (v413 << 32) | 0x10001) + 84;
                *(double *)(v415 + 8) = v1888;
                *(void *)(v415 + 16) = 65613;
                *(void *)&uint8_t buf[8] = v415 + 24;
                gss::FeatureAttributeSet::FeatureAttributeSet((gss::FeatureAttributeSet *)v1962, (uint64_t)buf);
                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v414 + 40))(v414, v416, 24);
                uint64_t v417 = (*(uint64_t (**)(void))(**((void **)v409 + 9) + 24))(*((void *)v409 + 9));
                if (v410)
                {
                  uint64_t v418 = v417 - 1;
                  uint64_t v419 = v1992[0];
                  id v420 = v1962[0];
                  if ((char *)v1992[1] - (char *)v1992[0] != (char *)v1962[1] - (char *)v1962[0]) {
                    goto LABEL_695;
                  }
                  if (v1992[0] != v1992[1])
                  {
                    while (1)
                    {
                      _ZF = *v419 == *v420 && *((unsigned __int16 *)v419 + 2) == *((unsigned __int16 *)v420 + 2);
                      if (!_ZF) {
                        break;
                      }
                      v419 += 2;
                      v420 += 2;
                      if (v419 == v1992[1]) {
                        goto LABEL_694;
                      }
                    }
LABEL_695:
                    uint64_t v422 = *v1877;
                    *(void *)&buf[7] = 0;
                    *(void *)long long buf = 0;
                    buf[15] = 1;
                    gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v1986, v422, (gss::FeatureAttributeSet *)v1992, (gss::QueryOverrides *)buf);
                    float32x4_t v424 = v1986;
                    float32x4_t v1986 = 0uLL;
                    unint64_t v425 = *(std::__shared_weak_count **)&v1916[16];
                    *(float32x4_t *)&v1916[8] = v424;
                    if (v425 && !atomic_fetch_add(&v425->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v425->__on_zero_shared)(v425);
                      std::__shared_weak_count::__release_weak(v425);
                      BOOL v426 = (std::__shared_weak_count *)v1986.i64[1];
                      if (v1986.i64[1]) {
                        goto LABEL_698;
                      }
                    }
                    else
                    {
                      BOOL v426 = (std::__shared_weak_count *)v1986.i64[1];
                      if (v1986.i64[1])
                      {
LABEL_698:
                        if (!atomic_fetch_add(&v426->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v426->__on_zero_shared)(v426);
                          std::__shared_weak_count::__release_weak(v426);
                        }
                      }
                    }
                    uint64_t v428 = *v1877;
                    float32x4_t v1986 = 0uLL;
                    *(void *)v1987 = 0;
                    *(void *)&v1987[8] = gss::Allocator::instance(v423);
                    v429 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)&v1987[8] + 16))(*(void *)&v1987[8], 8, 4);
                    v1986.i64[0] = (uint64_t)v429;
                    *(void *)v1987 = v429 + 1;
                    if (v429) {
                      void *v429 = 0x10001004DLL;
                    }
                    v1986.i64[1] = (uint64_t)(v429 + 1);
                    gss::FeatureAttributeSet::setByReplacingAttributes((gss::Allocator *)v1992, (unsigned int **)&v1986, (unsigned int **)buf);
                    *(void *)((char *)&v2001 + 7) = 0;
                    *(void *)&long long v2001 = 0;
                    HIBYTE(v2001) = 1;
                    gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)v1997, v428, (gss::FeatureAttributeSet *)buf, (gss::QueryOverrides *)&v2001);
                    long long v430 = *(_OWORD *)v1997;
                    v1997[1] = 0;
                    v1997[0] = 0;
                    unint64_t v431 = (std::__shared_weak_count *)*((void *)&v1917 + 1);
                    long long v1917 = v430;
                    if (v431 && !atomic_fetch_add(&v431->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v431->__on_zero_shared)(v431);
                      std::__shared_weak_count::__release_weak(v431);
                      v432 = (std::__shared_weak_count *)v1997[1];
                      if (v1997[1]) {
                        goto LABEL_709;
                      }
                    }
                    else
                    {
                      v432 = (std::__shared_weak_count *)v1997[1];
                      if (v1997[1])
                      {
LABEL_709:
                        if (!atomic_fetch_add(&v432->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v432->__on_zero_shared)(v432);
                          std::__shared_weak_count::__release_weak(v432);
                        }
                      }
                    }
                    if (*(void *)buf)
                    {
                      *(void *)&uint8_t buf[8] = *(void *)buf;
                      (*(void (**)(void, void, void))(**(void **)&buf[24] + 40))(*(void *)&buf[24], *(void *)buf, *(void *)&buf[16] - *(void *)buf);
                    }
                    if (v1986.i64[0])
                    {
                      v1986.i64[1] = v1986.i64[0];
                      (*(void (**)(void, uint64_t, uint64_t))(**(void **)&v1987[8] + 40))(*(void *)&v1987[8], v1986.i64[0], *(void *)v1987 - v1986.i64[0]);
                    }
                    uint64_t v433 = *(void *)&v1916[8];
                    unsigned int v434 = *(std::__shared_weak_count **)&v1916[16];
                    float32x4_t v1986 = *(float32x4_t *)&v1916[8];
                    if (*(void *)&v1916[16]) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v1916[16] + 8), 1uLL, memory_order_relaxed);
                    }
                    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)buf, v433, (uint64_t)v434);
                    if (v434 && !atomic_fetch_add(&v434->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v434->__on_zero_shared)(v434);
                      std::__shared_weak_count::__release_weak(v434);
                    }
                    long long v435 = v1917;
                    long long v2001 = v1917;
                    if (*((void *)&v1917 + 1)) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v1917 + 1) + 8), 1uLL, memory_order_relaxed);
                    }
                    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v1986, v435, *((uint64_t *)&v435 + 1));
                    if (*((void *)&v435 + 1)
                      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v435 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                    {
                      (*(void (**)(void))(**((void **)&v435 + 1) + 16))(*((void *)&v435 + 1));
                      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v435 + 1));
                    }
                    if (!(v1982[0] | v1987[16])) {
                      goto LABEL_894;
                    }
                    uint64_t v436 = (*(uint64_t (**)(void, void))(**((void **)v409 + 9) + 32))(*((void *)v409 + 9), (int)v410 - (v418 != (void)v410));
                    {
                      operator new();
                    }
                    uint64_t v437 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                + 16))(mdm::Allocator::instance(void)::alloc, 128, 8);
                    uint64_t v438 = v437;
                    unint64_t v439 = v410 - v411;
                    *(_OWORD *)(v437 + 49) = 0u;
                    *(_OWORD *)(v437 + 40) = 0u;
                    *(_OWORD *)(v437 + 24) = 0u;
                    *(_OWORD *)(v437 + 8) = 0u;
                    *(void *)(v437 + 56) = v410 - v411;
                    *(void *)uint64_t v437 = &unk_1EF553D90;
                    *(void *)(v437 + 72) = 0;
                    v440 = (void *)(v437 + 72);
                    *(void *)(v437 + 80) = 0;
                    *(void *)(v437 + 88) = 0;
                    if (v410 == v411)
                    {
                      *(void *)uint64_t v437 = &unk_1EF545860;
                      *(_OWORD *)(v437 + 96) = 0uLL;
                      *(_OWORD *)(v437 + 112) = 0uLL;
                    }
                    else
                    {
                      *(void *)(v437 + 88) = v439;
                      {
                        operator new();
                      }
                      *(void *)(v438 + 72) = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 12 * v439, 8);
                      *(unsigned char *)(v438 + 64) = 1;
                      *(void *)uint64_t v438 = &unk_1EF545860;
                      *(_OWORD *)(v438 + 96) = 0u;
                      *(_OWORD *)(v438 + 112) = 0u;
                      if (v439 >> 62) {
                        abort();
                      }
                      unint64_t v5 = 4 * v439;
                      unint64_t v441 = (char *)operator new(4 * v439);
                      *(void *)(v438 + 104) = v441;
                      *(void *)(v438 + 120) = &v441[4 * v439];
                      bzero(v441, 4 * v439);
                      *(void *)(v438 + 112) = &v441[4 * v439];
                      v395 = a3;
                    }
                    v1997[0] = (md::SharedResource *)v438;
                    BOOL v442 = (float *)(*(uint64_t (**)(void, gss::Allocator *))(**((void **)v409 + 9) + 32))(*((void *)v409 + 9), v411);
                    float v444 = v442[8];
                    *(float *)(v438 + 96) = v444;
                    float v445 = *(float *)(v436 + 32);
                    *(float *)(v438 + 100) = v445;
                    if (v410 != v411)
                    {
                      uint64_t v446 = 0;
                      uint64_t v447 = 0;
                      do
                      {
                        float v448 = (_DWORD *)(*(uint64_t (**)(void, gss::Allocator *))(**((void **)v409 + 9)
                                                                                             + 32))(*((void *)v409 + 9), v411);
                        unint64_t v449 = (_DWORD *)(*v440 + v446);
                        *unint64_t v449 = *v448;
                        v449[1] = v448[1];
                        v449[2] = v448[2];
                        BOOL v442 = (float *)(*(uint64_t (**)(void, gss::Allocator *))(**((void **)v409 + 9)
                                                                                            + 32))(*((void *)v409 + 9), v411);
                        float v444 = *(float *)(v438 + 96);
                        float v445 = *(float *)(v438 + 100);
                        *(float *)(*(void *)(v438 + 104) + v447) = fminf(fminf(fmaxf((float)(v445 - v442[8])/ (float)(v409[14] * 10.0), 0.0), 1.0), fminf(fmaxf((float)(v442[8] - v444)/ (float)(v409[14] * 10.0), 0.0), 1.0));
                        v411 = (gss::Allocator *)((char *)v411 + 1);
                        v447 += 4;
                        v446 += 12;
                      }
                      while (v410 != v411);
                    }
                    *(void *)&long long v1918 = __PAIR64__(LODWORD(v445), LODWORD(v444));
                    unint64_t v450 = 0x9DDFEA08EB382D69
                         * (((8 * *(_DWORD *)v1916) + 8) ^ *(unsigned int *)&v1916[4]);
                    unint64_t v451 = 0x9DDFEA08EB382D69 * (*(unsigned int *)&v1916[4] ^ (v450 >> 47) ^ v450);
                    unint64_t v452 = v451 ^ (v451 >> 47);
                    unint64_t v453 = 0x9DDFEA08EB382D69 * v452;
                    if (*(void *)&v1916[8])
                    {
                      id v455 = *(unsigned int **)(*(void *)&v1916[8] + 240);
                      uint64_t v454 = *(unsigned int **)(*(void *)&v1916[8] + 248);
                      for (unint64_t m = ((char *)v454 - (char *)v455) >> 3; v455 != v454; v455 += 2)
                      {
                        unint64_t v457 = ((m << 6) - 0x61C8864680B583EBLL + (m >> 2) + *v455) ^ m;
                        unint64_t m = (*((unsigned __int16 *)v455 + 2) - 0x61C8864680B583EBLL + (v457 << 6) + (v457 >> 2)) ^ v457;
                      }
                      unsigned int v458 = *(unsigned __int16 *)(*(void *)&v1916[8] + 282);
                      unint64_t v459 = 0;
                      if (*(_WORD *)(*(void *)&v1916[8] + 282))
                      {
                        uint64_t v460 = 0;
                        unsigned int v461 = 0;
                        uint64_t v462 = *(void *)(*(void *)&v1916[8] + 272);
                        BOOL v442 = (float *)(v462 + *(unsigned __int16 *)(*(void *)&v1916[8] + 280));
                        do
                        {
                          if (v461 < v458)
                          {
                            uint64_t v460 = (unsigned int *)(v462 + 4 * v461);
                            v443 = (unsigned __int16 *)v442 + v461;
                          }
                          v459 ^= (*v443
                                 - 0x61C8864680B583EBLL
                                 + ((((v459 << 6) - 0x61C8864680B583EBLL + (v459 >> 2) + *v460) ^ v459) << 6)
                                 + ((((v459 << 6) - 0x61C8864680B583EBLL + (v459 >> 2) + *v460) ^ v459) >> 2)) ^ ((v459 << 6) - 0x61C8864680B583EBLL + (v459 >> 2) + *v460);
                          unsigned int v463 = v461 + 1;
                          if (v461 + 1 < v458) {
                            ++v461;
                          }
                          else {
                            unsigned int v461 = *(unsigned __int16 *)(*(void *)&v1916[8] + 282);
                          }
                        }
                        while (v463 < v458);
                      }
                      v453 ^= 0x77FA823ACE0B5A40 * v452 - 0x61C8864680B583EBLL + (v453 >> 2) + (v459 ^ m);
                      uint64_t v464 = v1917;
                      if (!(void)v1917)
                      {
LABEL_763:
                        uint64_t v475 = LODWORD(v444) - 0x61C8864680B583EBLL;
                        if (v444 == 0.0) {
                          uint64_t v475 = 0x9E3779B97F4A7C15;
                        }
                        unint64_t v476 = ((v453 >> 2) + (v453 << 6) + v475) ^ v453;
                        uint64_t v477 = LODWORD(v445) - 0x61C8864680B583EBLL;
                        if (v445 == 0.0) {
                          uint64_t v477 = 0x9E3779B97F4A7C15;
                        }
                        unint64_t v478 = (v477 + (v476 << 6) + (v476 >> 2)) ^ v476;
                        unint64_t v479 = *(void *)(v1880 + 56);
                        if (v479)
                        {
                          uint8x8_t v480 = (uint8x8_t)vcnt_s8((int8x8_t)v479);
                          v480.i16[0] = vaddlv_u8(v480);
                          if (v480.u32[0] > 1uLL)
                          {
                            unint64_t v5 = (v477 + (v476 << 6) + (v476 >> 2)) ^ v476;
                            if (v478 >= v479) {
                              unint64_t v5 = v478 % v479;
                            }
                          }
                          else
                          {
                            unint64_t v5 = (v479 - 1) & v478;
                          }
                          v481 = *(float ***)(*(void *)(v1880 + 48) + 8 * v5);
                          if (v481)
                          {
                            BOOL v482 = *v481;
                            if (*v481)
                            {
                              if (v480.u32[0] < 2uLL)
                              {
                                while (1)
                                {
                                  uint64_t v484 = *((void *)v482 + 1);
                                  if (v484 == v478)
                                  {
                                    if (*((void *)v482 + 2) == *(void *)v1916
                                      && *((void *)v482 + 3) == *(void *)&v1916[8]
                                      && *((void *)v482 + 5) == v464
                                      && v482[14] == v444
                                      && v482[15] == v445)
                                    {
                                      goto LABEL_861;
                                    }
                                  }
                                  else if ((v484 & (v479 - 1)) != v5)
                                  {
                                    goto LABEL_796;
                                  }
                                  BOOL v482 = *(float **)v482;
                                  if (!v482) {
                                    goto LABEL_796;
                                  }
                                }
                              }
                              do
                              {
                                unint64_t v483 = *((void *)v482 + 1);
                                if (v483 == v478)
                                {
                                  if (*((void *)v482 + 2) == *(void *)v1916
                                    && *((void *)v482 + 3) == *(void *)&v1916[8]
                                    && *((void *)v482 + 5) == v464
                                    && v482[14] == v444
                                    && v482[15] == v445)
                                  {
                                    goto LABEL_861;
                                  }
                                }
                                else
                                {
                                  if (v483 >= v479) {
                                    v483 %= v479;
                                  }
                                  if (v483 != v5) {
                                    break;
                                  }
                                }
                                BOOL v482 = *(float **)v482;
                              }
                              while (v482);
                            }
                          }
                        }
LABEL_796:
                        v485 = (float *)operator new(0x60uLL);
                        BOOL v482 = v485;
                        *(void *)&long long v2001 = v485;
                        *((void *)&v2001 + 1) = v1871;
                        *(void *)v485 = 0;
                        *((void *)v485 + 1) = v478;
                        *((_OWORD *)v485 + 1) = *(_OWORD *)v1916;
                        uint64_t v486 = *(void *)&v1916[16];
                        *((void *)v485 + 4) = *(void *)&v1916[16];
                        if (v486) {
                          atomic_fetch_add_explicit((atomic_ullong *volatile)(v486 + 8), 1uLL, memory_order_relaxed);
                        }
                        uint64_t v487 = *((void *)&v1917 + 1);
                        *((void *)v485 + 5) = v464;
                        *((void *)v485 + 6) = v487;
                        if (v487) {
                          atomic_fetch_add_explicit((atomic_ullong *volatile)(v487 + 8), 1uLL, memory_order_relaxed);
                        }
                        *((void *)v485 + 7) = v1918;
                        *((void *)v485 + 8) = 0;
                        *((void *)v485 + 9) = 0;
                        *((void *)v485 + 10) = 0;
                        uint64_t v488 = v1880;
                        {
                          operator new();
                        }
                        *((void *)v482 + 11) = mdm::Allocator::instance(void)::alloc;
                        LOBYTE(v2002) = 1;
                        float v489 = (float)(unint64_t)(*(void *)(v1880 + 72) + 1);
                        float v490 = *(float *)(v1880 + 80);
                        if (!v479 || (float)(v490 * (float)v479) < v489)
                        {
                          BOOL v491 = (v479 & (v479 - 1)) != 0;
                          if (v479 < 3) {
                            BOOL v491 = 1;
                          }
                          unint64_t v492 = v491 | (2 * v479);
                          unint64_t v493 = vcvtps_u32_f32(v489 / v490);
                          if (v492 <= v493) {
                            size_t v494 = v493;
                          }
                          else {
                            size_t v494 = v492;
                          }
                          if (v494 == 1)
                          {
                            size_t v494 = 2;
                          }
                          else if ((v494 & (v494 - 1)) != 0)
                          {
                            size_t v494 = std::__next_prime(v494);
                          }
                          unint64_t v479 = *(void *)(v1880 + 56);
                          if (v494 > v479)
                          {
LABEL_813:
                            if (v494 >> 61) {
                              goto LABEL_2741;
                            }
                            v495 = operator new(8 * v494);
                            v496 = *(void **)(v1880 + 48);
                            *(void *)(v1880 + 48) = v495;
                            if (v496) {
                              operator delete(v496);
                            }
                            uint64_t v497 = 0;
                            *(void *)(v1880 + 56) = v494;
                            do
                              *(void *)(*(void *)(v1880 + 48) + 8 * v497++) = 0;
                            while (v494 != v497);
                            id v498 = *v1871;
                            if (!*v1871) {
                              goto LABEL_836;
                            }
                            size_t v499 = *((void *)v498 + 1);
                            size_t v500 = v494 - 1;
                            if ((v494 & (v494 - 1)) == 0)
                            {
                              size_t v501 = v499 & v500;
                              *(void *)(*(void *)(v1880 + 48) + 8 * v501) = v1871;
                              while (1)
                              {
                                v502 = *(float **)v498;
                                if (!*(void *)v498) {
                                  break;
                                }
                                size_t v503 = *((void *)v502 + 1) & v500;
                                if (v503 == v501)
                                {
                                  id v498 = *(float **)v498;
                                }
                                else
                                {
                                  uint64_t v504 = *(void *)(v1880 + 48);
                                  if (*(void *)(v504 + 8 * v503))
                                  {
                                    *(void *)id v498 = *(void *)v502;
                                    uint64_t v505 = 8 * v503;
                                    *(void *)v502 = **(void **)(*(void *)(v1880 + 48) + v505);
                                    **(void **)(*(void *)(v1880 + 48) + v505) = v502;
                                  }
                                  else
                                  {
                                    *(void *)(v504 + 8 * v503) = v498;
                                    id v498 = v502;
                                    size_t v501 = v503;
                                  }
                                }
                              }
                              goto LABEL_836;
                            }
                            if (v499 >= v494) {
                              v499 %= v494;
                            }
                            *(void *)(*(void *)(v1880 + 48) + 8 * v499) = v1871;
                            unint64_t v509 = *(float **)v498;
                            if (!*(void *)v498)
                            {
LABEL_836:
                              unint64_t v479 = v494;
LABEL_837:
                              uint64_t v488 = v1880;
                              goto LABEL_838;
                            }
                            while (2)
                            {
                              size_t v511 = *((void *)v509 + 1);
                              if (v511 >= v494) {
                                v511 %= v494;
                              }
                              if (v511 != v499)
                              {
                                uint64_t v512 = *(void *)(v1880 + 48);
                                if (!*(void *)(v512 + 8 * v511))
                                {
                                  *(void *)(v512 + 8 * v511) = v498;
LABEL_842:
                                  id v498 = v509;
                                  unint64_t v509 = *(float **)v509;
                                  size_t v499 = v511;
                                  if (!v509) {
                                    goto LABEL_836;
                                  }
                                  continue;
                                }
                                *(void *)id v498 = *(void *)v509;
                                uint64_t v510 = 8 * v511;
                                *(void *)unint64_t v509 = **(void **)(*(void *)(v1880 + 48) + v510);
                                **(void **)(*(void *)(v1880 + 48) + v510) = v509;
                                unint64_t v509 = v498;
                              }
                              break;
                            }
                            size_t v511 = v499;
                            goto LABEL_842;
                          }
                          if (v494 >= v479) {
                            goto LABEL_837;
                          }
                          unint64_t v506 = vcvtps_u32_f32((float)*(unint64_t *)(v1880 + 72) / *(float *)(v1880 + 80));
                          if (v479 < 3
                            || (uint8x8_t v507 = (uint8x8_t)vcnt_s8((int8x8_t)v479),
                                v507.i16[0] = vaddlv_u8(v507),
                                v507.u32[0] > 1uLL))
                          {
                            unint64_t v506 = std::__next_prime(v506);
                          }
                          else
                          {
                            uint64_t v508 = 1 << -(char)__clz(v506 - 1);
                            if (v506 >= 2) {
                              unint64_t v506 = v508;
                            }
                          }
                          if (v494 <= v506) {
                            size_t v494 = v506;
                          }
                          if (v494 >= v479)
                          {
                            uint64_t v488 = v1880;
                            unint64_t v479 = *(void *)(v1880 + 56);
                          }
                          else
                          {
                            if (v494) {
                              goto LABEL_813;
                            }
                            uint64_t v488 = v1880;
                            uint64_t v545 = *(void **)(v1880 + 48);
                            *(void *)(v1880 + 48) = 0;
                            if (v545) {
                              operator delete(v545);
                            }
                            unint64_t v479 = 0;
                            *(void *)(v1880 + 56) = 0;
                          }
LABEL_838:
                          if ((v479 & (v479 - 1)) != 0)
                          {
                            if (v478 >= v479) {
                              unint64_t v5 = v478 % v479;
                            }
                            else {
                              unint64_t v5 = v478;
                            }
                          }
                          else
                          {
                            unint64_t v5 = (v479 - 1) & v478;
                          }
                        }
                        uint64_t v513 = *(void *)(v488 + 48);
                        v514 = *(float ***)(v513 + 8 * v5);
                        if (v514)
                        {
                          *(void *)BOOL v482 = *v514;
                          goto LABEL_859;
                        }
                        *(void *)BOOL v482 = *v1871;
                        *v1871 = v482;
                        *(void *)(v513 + 8 * v5) = v1871;
                        if (*(void *)v482)
                        {
                          unint64_t v515 = *(void *)(*(void *)v482 + 8);
                          if ((v479 & (v479 - 1)) != 0)
                          {
                            if (v515 >= v479) {
                              v515 %= v479;
                            }
                          }
                          else
                          {
                            v515 &= v479 - 1;
                          }
                          v514 = (float **)(*(void *)(v488 + 48) + 8 * v515);
LABEL_859:
                          void *v514 = v482;
                        }
                        ++*(void *)(v488 + 72);
LABEL_861:
                        BOOL v516 = (md::SharedResource **)*((void *)v482 + 9);
                        unint64_t v517 = *((void *)v482 + 10);
                        if ((unint64_t)v516 < v517)
                        {
                          if (v516)
                          {
                            BOOL v518 = v1997[0];
                            v1997[0] = 0;
                            *BOOL v516 = v518;
                          }
                          v519 = v516 + 1;
                          goto LABEL_891;
                        }
                        uint64_t v520 = *((void *)v482 + 8);
                        uint64_t v521 = ((uint64_t)v516 - v520) >> 3;
                        unint64_t v522 = v521 + 1;
                        if ((unint64_t)(v521 + 1) >> 61) {
                          abort();
                        }
                        uint64_t v523 = v517 - v520;
                        if (v523 >> 2 > v522) {
                          unint64_t v522 = v523 >> 2;
                        }
                        if ((unint64_t)v523 >= 0x7FFFFFFFFFFFFFF8) {
                          uint64_t v524 = 0x1FFFFFFFFFFFFFFFLL;
                        }
                        else {
                          uint64_t v524 = v522;
                        }
                        if (v524)
                        {
                          uint64_t v525 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v482 + 11) + 16))(*((void *)v482 + 11), 8 * v524, 8);
                          uint64_t v526 = (md::SharedResource **)(v525 + 8 * v521);
                          uint64_t v527 = v525 + 8 * v524;
                          if (v525)
                          {
                            id v528 = v1997[0];
                            v1997[0] = 0;
                            *uint64_t v526 = v528;
                          }
                        }
                        else
                        {
                          uint64_t v527 = 0;
                          uint64_t v526 = (md::SharedResource **)(8 * v521);
                        }
                        v519 = v526 + 1;
                        v529 = (char *)*((void *)v482 + 8);
                        uint64_t v530 = (char *)*((void *)v482 + 9);
                        if (v530 == v529)
                        {
                          *((void *)v482 + 8) = v526;
                          *((void *)v482 + 9) = v519;
                          uint64_t v535 = *((void *)v482 + 10);
                          *((void *)v482 + 10) = v527;
                        }
                        else
                        {
                          unint64_t v531 = v530 - v529 - 8;
                          if (v531 <= 0x57
                            || (unint64_t v532 = (v529 - v530 + 7) & 0xFFFFFFFFFFFFFFF8, &v530[v532] < (char *)v526)
                            && (char *)v526 + v532 < v530)
                          {
                            uint64_t v533 = (char *)*((void *)v482 + 9);
                            goto LABEL_880;
                          }
                          uint64_t v539 = (v531 >> 3) + 1;
                          uint64_t v533 = &v530[-8 * (v539 & 0x3FFFFFFFFFFFFFFCLL)];
                          v540 = v526 - 2;
                          unint64_t v541 = (long long *)(v530 - 32);
                          uint64_t v542 = v539 & 0x3FFFFFFFFFFFFFFCLL;
                          do
                          {
                            long long v544 = *v541;
                            long long v543 = v541[1];
                            *unint64_t v541 = 0uLL;
                            v541[1] = 0uLL;
                            v541 -= 2;
                            *((_OWORD *)v540 - 1) = v544;
                            *(_OWORD *)v540 = v543;
                            v540 -= 4;
                            v542 -= 4;
                          }
                          while (v542);
                          v526 -= v539 & 0x3FFFFFFFFFFFFFFCLL;
                          if (v539 != (v539 & 0x3FFFFFFFFFFFFFFCLL))
                          {
                            do
                            {
LABEL_880:
                              id v534 = (md::SharedResource *)*((void *)v533 - 1);
                              v533 -= 8;
                              *(void *)uint64_t v533 = 0;
                              *--uint64_t v526 = v534;
                            }
                            while (v533 != v529);
                          }
                          uint64_t v530 = (char *)*((void *)v482 + 8);
                          unint64_t v5 = *((void *)v482 + 9);
                          *((void *)v482 + 8) = v526;
                          *((void *)v482 + 9) = v519;
                          uint64_t v535 = *((void *)v482 + 10);
                          *((void *)v482 + 10) = v527;
                          while ((char *)v5 != v530)
                          {
                            uint64_t v537 = *(void (****)(void))(v5 - 8);
                            v5 -= 8;
                            v536 = v537;
                            *(void *)unint64_t v5 = 0;
                            if (v537)
                            {
                              (**v536)(v536);
                              {
                                operator new();
                              }
                              (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v536, 128);
                            }
                          }
                        }
                        if (v530) {
                          (*(void (**)(void, char *, uint64_t))(**((void **)v482 + 11) + 40))(*((void *)v482 + 11), v530, v535 - (void)v530);
                        }
LABEL_891:
                        *((void *)v482 + 9) = v519;
                        v538 = v1997[0];
                        v1997[0] = 0;
                        if (v538)
                        {
                          (**(void (***)(md::SharedResource *))v538)(v538);
                          {
                              operator new();
                          }
                          (*(void (**)(uint64_t, md::SharedResource *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                         + 40))(mdm::Allocator::instance(void)::alloc, v538, 128);
                        }
LABEL_894:
                        std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>((uint64_t *)v1992, (uint64_t)v1962[0], (void *)v1962[1], ((char *)v1962[1] - (char *)v1962[0]) >> 3);
                        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v1986);
                        gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)buf);
                        v411 = v410;
                        v427 = v1962[0];
                        if (!v1962[0]) {
                          goto LABEL_681;
                        }
LABEL_895:
                        v1962[1] = v427;
                        (*(void (**)(unint64_t, void *, uint64_t))(*(void *)v1964 + 40))(v1964, v427, v1963 - (void)v427);
                        goto LABEL_681;
                      }
                    }
                    else
                    {
                      uint64_t v464 = v1917;
                      if (!(void)v1917) {
                        goto LABEL_763;
                      }
                    }
                    v466 = *(unsigned int **)(v464 + 240);
                    uint64_t v465 = *(unsigned int **)(v464 + 248);
                    for (unint64_t n = ((char *)v465 - (char *)v466) >> 3; v466 != v465; v466 += 2)
                    {
                      unint64_t v468 = ((n << 6) - 0x61C8864680B583EBLL + (n >> 2) + *v466) ^ n;
                      unint64_t n = (*((unsigned __int16 *)v466 + 2) - 0x61C8864680B583EBLL + (v468 << 6) + (v468 >> 2)) ^ v468;
                    }
                    unsigned int v469 = *(unsigned __int16 *)(v464 + 282);
                    if (*(_WORD *)(v464 + 282))
                    {
                      unint64_t v470 = 0;
                      v471 = 0;
                      unsigned int v472 = 0;
                      uint64_t v473 = *(void *)(v464 + 272);
                      do
                      {
                        if (v472 < v469)
                        {
                          v471 = (unsigned int *)(v473 + 4 * v472);
                          BOOL v442 = (float *)(v473 + *(unsigned __int16 *)(v464 + 280) + 2 * v472);
                        }
                        v470 ^= (*(unsigned __int16 *)v442
                               - 0x61C8864680B583EBLL
                               + ((((v470 << 6) - 0x61C8864680B583EBLL + (v470 >> 2) + *v471) ^ v470) << 6)
                               + ((((v470 << 6) - 0x61C8864680B583EBLL + (v470 >> 2) + *v471) ^ v470) >> 2)) ^ ((v470 << 6) - 0x61C8864680B583EBLL + (v470 >> 2) + *v471);
                        unsigned int v474 = v472 + 1;
                        if (v472 + 1 < v469) {
                          ++v472;
                        }
                        else {
                          unsigned int v472 = *(unsigned __int16 *)(v464 + 282);
                        }
                      }
                      while (v474 < v469);
                    }
                    else
                    {
                      unint64_t v470 = 0;
                    }
                    v453 ^= (v453 << 6) - 0x61C8864680B583EBLL + (v453 >> 2) + (v470 ^ n);
                    goto LABEL_763;
                  }
LABEL_694:
                  if ((gss::Allocator *)v418 == v410) {
                    goto LABEL_695;
                  }
                }
                else
                {
                  std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>((uint64_t *)v1992, (uint64_t)v1962[0], (void *)v1962[1], ((char *)v1962[1] - (char *)v1962[0]) >> 3);
                }
                v427 = v1962[0];
                if (v1962[0]) {
                  goto LABEL_895;
                }
LABEL_681:
                BOOL v410 = (gss::Allocator *)((char *)v410 + 1);
              }
              if (v1992[0])
              {
                v1992[1] = v1992[0];
                unint64_t v404 = (gss::Allocator *)(*(uint64_t (**)(void, void *, unint64_t))(**((void **)&v1993 + 1) + 40))(*((void *)&v1993 + 1), v1992[0], v1993 - (unint64_t)v1992[0]);
              }
              uint64_t v546 = (std::__shared_weak_count *)*((void *)&v1917 + 1);
              if (*((void *)&v1917 + 1)
                && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v1917 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v546->__on_zero_shared)(v546);
                std::__shared_weak_count::__release_weak(v546);
                unsigned __int8 v547 = *(std::__shared_weak_count **)&v1916[16];
                if (*(void *)&v1916[16])
                {
LABEL_922:
                  if (!atomic_fetch_add(&v547->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v547->__on_zero_shared)(v547);
                    std::__shared_weak_count::__release_weak(v547);
                  }
                }
              }
              else
              {
                unsigned __int8 v547 = *(std::__shared_weak_count **)&v1916[16];
                if (*(void *)&v1916[16]) {
                  goto LABEL_922;
                }
              }
              if (v1860)
              {
                _ZF = (*v1860)-- == 1;
                if (_ZF)
                {
                  md::RouteLineSection::~RouteLineSection(__pa);
                  {
                    operator new();
                  }
                  unint64_t v404 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                                 + 40))(mdm::Allocator::instance(void)::alloc, v1860, 400);
                }
              }
              v405 = v1866 + 1;
              long long v406 = 0uLL;
            }
            while (v1866 + 1 != v1850);
          }
        }
        else
        {
          v1998 = 0;
          uint64_t v1999 = 0;
          uint64_t v2000 = 0;
        }
        uint64_t v548 = *((void *)v1821 + 92);
        *(void *)v1916 = MEMORY[0x1E4F143A8];
        *(void *)&v1916[8] = 3221225472;
        *(void *)&v1916[16] = ___ZN2md16RouteRenderLayer28buildRouteStyledOverlayLayerERKNS_13LayoutContextERKNSt3__110shared_ptrINS_16RouteLineOverlayEEE_block_invoke;
        *(void *)&long long v1917 = &unk_1E5A8EB40;
        *(void *)&long long v1918 = v395;
        *((void *)&v1917 + 1) = v1969;
        *(void *)&buf[24] = 0;
        *(void *)long long buf = &unk_1EF56BC58;
        *(void *)&uint8_t buf[8] = MEMORY[0x1A6239EB0](v1916);
        *(void *)&buf[24] = buf;
        float32x4_t v1986 = 0uLL;
        (*(void (**)(void, unsigned char *, float32x4_t *))(**(void **)(v548 + 32) + 16))(*(void *)(v548 + 32), buf, &v1986);
        v549 = (std::__shared_weak_count *)v1986.i64[1];
        if (v1986.i64[1] && !atomic_fetch_add((atomic_ullong *volatile)(v1986.i64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v549->__on_zero_shared)(v549);
          std::__shared_weak_count::__release_weak(v549);
        }
        unint64_t v117 = v1821;
        if (*(unsigned char **)&buf[24] == buf)
        {
          (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
        }
        else if (*(void *)&buf[24])
        {
          (*(void (**)(void))(**(void **)&buf[24] + 40))();
        }
        uint64_t v550 = (uint64_t)v1998;
        if (v1998)
        {
          uint64_t v551 = v1999;
          v552 = v1998;
          if ((void **)v1999 != v1998)
          {
            uint64_t v553 = v1999;
            do
            {
              v555 = *(void **)(v553 - 8);
              v553 -= 8;
              v554 = v555;
              if (v555)
              {
                _ZF = (*v554)-- == 1;
                if (_ZF)
                {
                  md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v554 + 1));
                  {
                    operator new();
                  }
                  (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                   + 40))(mdm::Allocator::instance(void)::alloc, *(void *)(v551 - 8), 400);
                  *(void *)(v551 - 8) = 0;
                }
              }
              uint64_t v551 = v553;
            }
            while (v553 != v550);
            v552 = v1998;
          }
          uint64_t v1999 = v550;
          operator delete(v552);
        }
        _Block_object_dispose(v1969, 8);
        v556 = *(void **)&v1969[64];
        if (*(void *)&v1969[64])
        {
          do
          {
            v557 = (void *)*v556;
            std::pair<md::RouteStyledOverlayBatchKey const,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>>::~pair((uint64_t)(v556 + 2));
            operator delete(v556);
            v556 = v557;
          }
          while (v557);
        }
        uint64_t v558 = *(void **)&v1969[48];
        *(void *)&v1969[48] = 0;
        if (v558) {
          operator delete(v558);
        }
        uint64_t v148 = *a3;
        int v7 = 1;
        goto LABEL_957;
      }
    }
    else
    {
      if (*((void *)&v1993 + 1)) {
        (*(void (**)(void))(**((void **)&v1993 + 1) + 40))();
      }
      uint64_t v384 = (char *)v1962[0];
      if (!v1962[0]) {
        goto LABEL_640;
      }
    }
    uint64_t v385 = v1962[1];
    v386 = v384;
    if (v1962[1] != v384)
    {
      double v387 = (char *)v1962[1];
      do
      {
        v389 = (void *)*((void *)v387 - 1);
        v387 -= 8;
        id v388 = v389;
        if (v389)
        {
          _ZF = (*v388)-- == 1;
          if (_ZF)
          {
            md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v388 + 1));
            {
              operator new();
            }
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *(v385 - 1), 400);
            *(v385 - 1) = 0;
          }
        }
        uint64_t v385 = v387;
      }
      while (v387 != v384);
      v386 = (char *)v1962[0];
    }
    v1962[1] = v384;
    operator delete(v386);
    goto LABEL_640;
  }
  if (!*(void *)(v148 + 328)) {
    goto LABEL_645;
  }
LABEL_957:
  uint64_t v559 = *(void *)(v148 + 320);
  uint64_t v560 = *(void *)(v559 + 8);
  uint64_t v561 = *(void *)(v559 + 16);
  if (v560 != v561)
  {
    do
    {
      uint64_t v563 = *(void **)v560;
      uint64_t v564 = *(void *)(*(void *)v560 + 2352);
      uint64_t v565 = *(void *)(*(void *)v560 + 2344);
      if (v564 != v565)
      {
        uint64_t v566 = *(void *)(*(void *)v560 + 2352);
        do
        {
          id v568 = *(void **)(v566 - 24);
          v566 -= 24;
          int v567 = v568;
          if (v568)
          {
            *(void *)(v564 - 16) = v567;
            operator delete(v567);
          }
          uint64_t v564 = v566;
        }
        while (v566 != v565);
      }
      v563[294] = v565;
      v563[291] = v563[290];
      v569 = (void *)v563[300];
      if (v569)
      {
        do
        {
          if (v569[1])
          {
            unint64_t v570 = 0;
            v571 = v569 + 2;
            v572 = v569 + 2;
            v573 = (void (***)(void))(v569 + 2);
            do
            {
              v574 = (void (**)(void *))*v573;
              v573 += 15;
              (*v574)(v572);
              ++v570;
              v571 += 15;
              v572 = v573;
            }
            while (v570 < v569[1]);
          }
          v569[1] = 0;
          v569 = (void *)*v569;
        }
        while (v569);
        uint64_t v562 = v563[300];
      }
      else
      {
        uint64_t v562 = 0;
      }
      v563[301] = v562;
      v560 += 8;
    }
    while (v560 != v561);
    uint64_t v148 = *a3;
  }
  uint64_t v575 = *(void *)(v148 + 328);
  uint64_t v576 = *(void *)(v575 + 8);
  uint64_t v577 = *(void *)(v575 + 16);
  if (v576 == v577)
  {
    if (*(unsigned char *)(v148 + 620)) {
      goto LABEL_976;
    }
LABEL_992:
    if (*(unsigned char *)(v148 + 622))
    {
      char v593 = *(void **)(v148 + 160);
      id v579 = *(id *)(v1826 + 192);
      [v593 splitRouteLineAtAnnotation:v579 puckOffset:*MEMORY[0x1E4F64198]];
      goto LABEL_994;
    }
    __int16 v594 = 0;
  }
  else
  {
    do
    {
      v581 = *(void **)v576;
      uint64_t v583 = *(void *)(*(void *)v576 + 168);
      uint64_t v582 = *(void *)(*(void *)v576 + 176);
      if (v582 != v583)
      {
        uint64_t v584 = *(void *)(*(void *)v576 + 176);
        do
        {
          v586 = *(void **)(v584 - 24);
          v584 -= 24;
          v585 = v586;
          if (v586)
          {
            *(void *)(v582 - 16) = v585;
            operator delete(v585);
          }
          uint64_t v582 = v584;
        }
        while (v584 != v583);
      }
      v581[22] = v583;
      v581[19] = v581[18];
      v587 = (void *)v581[28];
      if (v587)
      {
        do
        {
          if (v587[1])
          {
            unint64_t v588 = 0;
            v589 = v587 + 2;
            v590 = v587 + 2;
            uint64_t v591 = (void (***)(void))(v587 + 2);
            do
            {
              v592 = (void (**)(void *))*v591;
              v591 += 15;
              (*v592)(v590);
              ++v588;
              v589 += 15;
              v590 = v591;
            }
            while (v588 < v587[1]);
          }
          v587[1] = 0;
          v587 = (void *)*v587;
        }
        while (v587);
        uint64_t v580 = v581[28];
      }
      else
      {
        uint64_t v580 = 0;
      }
      v581[29] = v580;
      v576 += 8;
    }
    while (v576 != v577);
    uint64_t v148 = *a3;
    if (!*(unsigned char *)(*a3 + 620)) {
      goto LABEL_992;
    }
LABEL_976:
    v578 = *(void **)(v148 + 160);
    id v579 = *(id *)(v1826 + 184);
    [v578 splitRouteLineAtAnnotation:v579 puckOffset:*(void *)(v1845 + 12)];
LABEL_994:

    __int16 v594 = *(unsigned __int8 *)(*a3 + 620);
    unint64_t v117 = v1821;
  }
  memset(v1941, 0, sizeof(v1941));
  char v1942 = 1;
  *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)v1941, 0x10002u) = v594;
  __int16 v595 = *(unsigned __int8 *)(*a3 + 621);
  *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)v1941, 0x1004Du) = v595;
  v596 = (void *)*((void *)v117 + 1);
  int8x8_t v597 = (int8x8_t)v596[1];
  if (!*(void *)&v597) {
    goto LABEL_1021;
  }
  uint8x8_t v598 = (uint8x8_t)vcnt_s8(v597);
  v598.i16[0] = vaddlv_u8(v598);
  if (v598.u32[0] > 1uLL)
  {
    unint64_t v599 = 0xE42D19AFCA302E68;
    if (*(void *)&v597 <= 0xE42D19AFCA302E68) {
      unint64_t v599 = 0xE42D19AFCA302E68 % *(void *)&v597;
    }
  }
  else
  {
    unint64_t v599 = (*(void *)&v597 - 1) & 0xE42D19AFCA302E68;
  }
  long long v600 = *(void **)(*v596 + 8 * v599);
  if (!v600) {
    goto LABEL_1021;
  }
  long long v601 = (void *)*v600;
  if (!v601) {
    goto LABEL_1021;
  }
  if (v598.u32[0] < 2uLL)
  {
    uint64_t v602 = *(void *)&v597 - 1;
    while (1)
    {
      uint64_t v604 = v601[1];
      if (v604 == 0xE42D19AFCA302E68)
      {
        if (v601[2] == 0xE42D19AFCA302E68) {
          goto LABEL_1017;
        }
      }
      else if ((v604 & v602) != v599)
      {
        goto LABEL_1021;
      }
      long long v601 = (void *)*v601;
      if (!v601) {
        goto LABEL_1021;
      }
    }
  }
  while (1)
  {
    unint64_t v603 = v601[1];
    if (v603 == 0xE42D19AFCA302E68) {
      break;
    }
    if (v603 >= *(void *)&v597) {
      v603 %= *(void *)&v597;
    }
    if (v603 != v599) {
      goto LABEL_1021;
    }
LABEL_1005:
    long long v601 = (void *)*v601;
    if (!v601) {
      goto LABEL_1021;
    }
  }
  if (v601[2] != 0xE42D19AFCA302E68) {
    goto LABEL_1005;
  }
LABEL_1017:
  uint64_t v605 = v601[5];
  if (*(void *)(v605 + 8) != 0xE42D19AFCA302E68 || (uint64_t v606 = *(void *)(v605 + 32)) == 0)
  {
LABEL_1021:
    BOOL __pb = 0;
    if (v1845) {
      goto LABEL_1022;
    }
    goto LABEL_1037;
  }
  BOOL __pb = *(unsigned __int8 *)(v606 + 84) == 3;
  if (!v1845) {
    goto LABEL_1037;
  }
LABEL_1022:
  id v607 = *(id *)(v1845 + 40);
  long long v608 = [v607 routeInfo];
  long long v609 = [v608 route];
  uint64_t v610 = [v609 source];

  id v611 = *(id *)(v1845 + 40);
  int v612 = [v611 routeInfo];
  v613 = [v612 route];
  if ([v613 transportType]) {
    BOOL v614 = v1828 == 9;
  }
  else {
    BOOL v614 = 1;
  }
  char v615 = !v614;

  id v616 = *(id *)(v1845 + 40);
  if (v616)
  {
    id v617 = *(id *)(v1845 + 40);
    BOOL v618 = [v617 useType] == 1;
  }
  else
  {
    BOOL v618 = 0;
  }

  v619 = +[VKPlatform sharedPlatform];
  int v620 = [v619 reduceMotionEnabled];

  unint64_t v117 = v1821;
  if ((v610 == 4) | v615 & 1 | (!v618 || __pb) || (*(unsigned char *)v1845 ? (int v621 = 1) : (int v621 = v620), v621 == 1))
  {
    int v1824 = 0;
    int v7 = 0;
  }
LABEL_1037:
  v622 = (void *)*((void *)v117 + 1);
  int8x8_t v623 = (int8x8_t)v622[1];
  if (!*(void *)&v623) {
    goto LABEL_1061;
  }
  uint8x8_t v624 = (uint8x8_t)vcnt_s8(v623);
  v624.i16[0] = vaddlv_u8(v624);
  if (v624.u32[0] > 1uLL)
  {
    unint64_t v625 = 0xC97B9E962ADF4AD4;
    if (*(void *)&v623 <= 0xC97B9E962ADF4AD4) {
      unint64_t v625 = 0xC97B9E962ADF4AD4 % *(void *)&v623;
    }
  }
  else
  {
    unint64_t v625 = (*(void *)&v623 - 1) & 0xC97B9E962ADF4AD4;
  }
  v626 = *(void **)(*v622 + 8 * v625);
  if (!v626) {
    goto LABEL_1061;
  }
  v627 = (void *)*v626;
  if (!v627) {
    goto LABEL_1061;
  }
  if (v624.u32[0] < 2uLL)
  {
    uint64_t v628 = *(void *)&v623 - 1;
    while (1)
    {
      uint64_t v630 = v627[1];
      if (v630 == 0xC97B9E962ADF4AD4)
      {
        if (v627[2] == 0xC97B9E962ADF4AD4) {
          goto LABEL_1058;
        }
      }
      else if ((v630 & v628) != v625)
      {
        goto LABEL_1061;
      }
      v627 = (void *)*v627;
      if (!v627) {
        goto LABEL_1061;
      }
    }
  }
  while (1)
  {
    unint64_t v629 = v627[1];
    if (v629 == 0xC97B9E962ADF4AD4) {
      break;
    }
    if (v629 >= *(void *)&v623) {
      v629 %= *(void *)&v623;
    }
    if (v629 != v625) {
      goto LABEL_1061;
    }
LABEL_1047:
    v627 = (void *)*v627;
    if (!v627) {
      goto LABEL_1061;
    }
  }
  if (v627[2] != 0xC97B9E962ADF4AD4) {
    goto LABEL_1047;
  }
LABEL_1058:
  uint64_t v631 = v627[5];
  if (*(void *)(v631 + 8) != 0xC97B9E962ADF4AD4)
  {
LABEL_1061:
    v632 = 0;
    if (v7) {
      goto LABEL_1062;
    }
LABEL_1086:
    v633 = a3;
    uint64_t v634 = *a3;
    goto LABEL_1087;
  }
  v632 = *(void **)(v631 + 32);
  if (!v7) {
    goto LABEL_1086;
  }
LABEL_1062:
  v633 = a3;
  uint64_t v634 = *a3;
  if (*(void *)(*a3 + 320))
  {
    if (v1828 != 9)
    {
      v635 = (std::__shared_weak_count *)a3[1];
      v1938[0] = *a3;
      v1938[1] = v635;
      if (v635) {
        atomic_fetch_add_explicit(&v635->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      PolylineCoordinate v636 = 0;
      md::RouteRenderLayer::updateRoutelineDrawinAnimation(a1, v117, v1938, v636);
      if (v635 && !atomic_fetch_add(&v635->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v635->__on_zero_shared)(v635);
        std::__shared_weak_count::__release_weak(v635);
      }
      goto LABEL_1086;
    }
    v637 = [*(id *)(v634 + 160) composedRoute];
    v638 = [v637 anchorPoints];
    unsigned int v639 = [v638 count];

    uint64_t v640 = *a3;
    if (v639 >= 2 && *(_DWORD *)(a1 + 48) < v639)
    {
      v646 = [*(id *)(v640 + 160) composedRoute];
      v647 = [v646 anchorPoints];
      v648 = [v647 objectAtIndexedSubscript:v639 - 2];

      v644 = (std::__shared_weak_count *)a3[1];
      v1940[0] = *a3;
      v1940[1] = v644;
      if (v644) {
        atomic_fetch_add_explicit(&v644->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      PolylineCoordinate v649 = (PolylineCoordinate)[v648 routeCoordinate];
      md::RouteRenderLayer::updateRoutelineDrawinAnimation(a1, v1821, v1940, v649);
      goto LABEL_1081;
    }
    if (*(unsigned char *)(v640 + 849))
    {
      v642 = [*(id *)(v640 + 160) composedRoute];
      v643 = [v642 anchorPoints];
      v648 = [v643 lastObject];

      v644 = (std::__shared_weak_count *)a3[1];
      v1939[0] = *a3;
      v1939[1] = v644;
      if (v644) {
        atomic_fetch_add_explicit(&v644->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      PolylineCoordinate v645 = (PolylineCoordinate)[v648 routeCoordinate];
      md::RouteRenderLayer::updateRoutelineDrawinAnimation(a1, v1821, v1939, v645);
LABEL_1081:
      if (v644 && !atomic_fetch_add(&v644->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v644->__on_zero_shared)(v644);
        std::__shared_weak_count::__release_weak(v644);
      }
    }
    *(_DWORD *)(a1 + 48) = v639;
    goto LABEL_1086;
  }
LABEL_1087:
  if (v634) {
    int v650 = v1824;
  }
  else {
    int v650 = 0;
  }
  if (v650 == 1)
  {
    *(_DWORD *)v1969 = 0;
    float v651 = md::RouteLineDrawAnimation::update((md::RouteLineDrawAnimation *)(v634 + 632), *(float *)(v634 + 832), (int *)v1969);
    uint64_t v652 = *(void *)(*v633 + 320);
    v653 = *(uint64_t **)(v652 + 8);
    v654 = *(uint64_t **)(v652 + 16);
    if (v653 != v654)
    {
      unint64_t v655 = *(int *)v1969;
      if (v651 < 1.0)
      {
        do
        {
          uint64_t v656 = *v653;
          if (*(unsigned char *)(*v653 + 2448))
          {
            unint64_t v657 = *(void *)(*(void *)(v656 + 2456) + 216);
            if (v657 >= v655) {
              float v658 = 0.0;
            }
            else {
              float v658 = 1.0;
            }
            if (v657 == v655) {
              float v658 = v651;
            }
            *(float *)(v656 + 2584) = v658;
          }
          ++v653;
        }
        while (v653 != v654);
      }
      else
      {
        do
        {
          uint64_t v659 = *v653;
          if (*(unsigned char *)(*v653 + 2448))
          {
            unint64_t v660 = *(void *)(*(void *)(v659 + 2456) + 216);
            float v661 = v651;
            if (v660 != v655)
            {
              float v661 = 1.0;
              if (v660 >= v655)
              {
                if (v660 <= v655) {
                  float v661 = 0.0;
                }
                else {
                  float v661 = 1.0;
                }
              }
            }
            *(float *)(v659 + 2584) = v661;
          }
          ++v653;
        }
        while (v653 != v654);
      }
    }
    goto LABEL_1118;
  }
  v662 = *(void **)(v634 + 696);
  if (v662)
  {
    [v662 stop];
    uint64_t v634 = *v633;
  }
  uint64_t v663 = *(void *)(v634 + 320);
  uint64_t v664 = *(void *)(v663 + 8);
  for (iuint64_t i = *(void *)(v663 + 16); v664 != ii; v664 += 8)
  {
    if (*(unsigned char *)(*(void *)v664 + 2448)) {
      *(_DWORD *)(*(void *)v664 + 2584) = 1065353216;
    }
  }
  if (v1824)
  {
LABEL_1118:
    uint64_t v666 = *v633;
    v667 = *(void **)(*v633 + 696);
    if (!v667
      || *(float *)(v666 + 832) >= 1.0
      || [v667 state] == 3
      || [*(id *)(v666 + 696) state] == 4)
    {
      goto LABEL_1122;
    }
    int v668 = 1;
  }
  else
  {
LABEL_1122:
    int v668 = 0;
  }
  int v1851 = v668;
  uint64_t v669 = *v633;
  *(unsigned char *)(v669 + 857) = v668;
  uint64_t v671 = *(void *)(v669 + 312);
  v670 = *(void **)(v669 + 320);
  uint64_t v672 = v670[38];
  if (v672) {
    BOOL v673 = v672 == v671;
  }
  else {
    BOOL v673 = 0;
  }
  if (v673) {
    goto LABEL_1169;
  }
  v670[38] = v671;
  v674 = (uint64_t *)v670[1];
  v675 = (uint64_t *)v670[2];
  if (v674 == v675) {
    goto LABEL_1168;
  }
  v1890 = v632;
  while (2)
  {
    uint64_t v676 = *v674;
    uint64_t v677 = *(void *)(*(void *)(*v674 + 8) + 304);
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(*v674 + 2464), *(void *)(v677 + 96), *(std::__shared_weak_count **)(v677 + 104));
    **(void **)(*(void *)(v676 + 2464) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2472), *(void *)(v677 + 96), *(std::__shared_weak_count **)(v677 + 104));
    **(void **)(*(void *)(v676 + 2472) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2480), *(void *)(v677 + 96), *(std::__shared_weak_count **)(v677 + 104));
    **(void **)(*(void *)(v676 + 2480) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2488), *(void *)(v677 + 96), *(std::__shared_weak_count **)(v677 + 104));
    **(void **)(*(void *)(v676 + 2488) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    if (!*(unsigned char *)(v676 + 2609))
    {
      ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2520), *(void *)(v677 + 96), *(std::__shared_weak_count **)(v677 + 104));
      **(void **)(*(void *)(v676 + 2520) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
      goto LABEL_1149;
    }
    v678 = *(void **)(v676 + 2512);
    uint64_t v680 = *(void *)(v677 + 128);
    v679 = *(std::__shared_weak_count **)(v677 + 136);
    if (v679) {
      atomic_fetch_add_explicit(&v679->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v680 || **(void **)(v680 + 40) != v678[1])
    {
      v681 = (std::__shared_weak_count *)v678[3];
      v678[2] = 0;
      v678[3] = 0;
      if (!v681) {
        goto LABEL_1145;
      }
LABEL_1144:
      if (atomic_fetch_add(&v681->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_1145;
      }
      ((void (*)(std::__shared_weak_count *))v681->__on_zero_shared)(v681);
      std::__shared_weak_count::__release_weak(v681);
      if (!v679) {
        goto LABEL_1149;
      }
LABEL_1146:
      if (!atomic_fetch_add(&v679->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v679->__on_zero_shared)(v679);
        std::__shared_weak_count::__release_weak(v679);
      }
      goto LABEL_1149;
    }
    uint64_t v682 = v678[2];
    if (v682 && v682 != v680) {
      ggl::PipelineSetup::resetData((uint64_t)v678);
    }
    if (v679) {
      atomic_fetch_add_explicit(&v679->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v681 = (std::__shared_weak_count *)v678[3];
    v678[2] = v680;
    v678[3] = v679;
    if (v681) {
      goto LABEL_1144;
    }
LABEL_1145:
    if (v679) {
      goto LABEL_1146;
    }
LABEL_1149:
    v683 = *(void **)(v676 + 2552);
    uint64_t v685 = *(void *)(v677 + 160);
    v684 = *(std::__shared_weak_count **)(v677 + 168);
    if (v684) {
      atomic_fetch_add_explicit(&v684->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v685 || **(void **)(v685 + 40) != v683[1])
    {
      v686 = (std::__shared_weak_count *)v683[3];
      v683[2] = 0;
      v683[3] = 0;
      if (!v686) {
        goto LABEL_1162;
      }
LABEL_1161:
      if (atomic_fetch_add(&v686->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_1162;
      }
      ((void (*)(std::__shared_weak_count *))v686->__on_zero_shared)(v686);
      std::__shared_weak_count::__release_weak(v686);
      if (!v684) {
        goto LABEL_1129;
      }
LABEL_1163:
      if (!atomic_fetch_add(&v684->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v684->__on_zero_shared)(v684);
        std::__shared_weak_count::__release_weak(v684);
      }
      goto LABEL_1129;
    }
    uint64_t v687 = v683[2];
    if (v687 && v687 != v685) {
      ggl::PipelineSetup::resetData((uint64_t)v683);
    }
    if (v684) {
      atomic_fetch_add_explicit(&v684->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v686 = (std::__shared_weak_count *)v683[3];
    v683[2] = v685;
    v683[3] = v684;
    if (v686) {
      goto LABEL_1161;
    }
LABEL_1162:
    if (v684) {
      goto LABEL_1163;
    }
LABEL_1129:
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2496), *(void *)(v677 + 112), *(std::__shared_weak_count **)(v677 + 120));
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2504), *(void *)(v677 + 112), *(std::__shared_weak_count **)(v677 + 120));
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2528), *(void *)(v677 + 96), *(std::__shared_weak_count **)(v677 + 104));
    **(void **)(*(void *)(v676 + 2528) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2536), *(void *)(v677 + 144), *(std::__shared_weak_count **)(v677 + 152));
    **(void **)(*(void *)(v676 + 2536) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v676 + 2544), *(void *)(v677 + 144), *(std::__shared_weak_count **)(v677 + 152));
    **(void **)(*(void *)(v676 + 2544) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    **(void **)(*(void *)(v676 + 2560) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    **(void **)(*(void *)(v676 + 2568) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    **(void **)(*(void *)(v676 + 2576) + 96) = *(void *)(*(void *)(v677 + 248) + 24);
    if (++v674 != v675) {
      continue;
    }
    break;
  }
  uint64_t v669 = *a3;
  v632 = v1890;
LABEL_1168:
  uint64_t v672 = *(void *)(v669 + 312);
LABEL_1169:
  v688 = *(void **)(v669 + 336);
  uint64_t v689 = v688[19];
  if (v689) {
    BOOL v690 = v689 == v672;
  }
  else {
    BOOL v690 = 0;
  }
  if (v690) {
    goto LABEL_1198;
  }
  v688[19] = v672;
  uint64_t v691 = v688[1];
  uint64_t v692 = v688[2];
  if (v691 == v692) {
    goto LABEL_1197;
  }
  while (2)
  {
    uint64_t v693 = *(void *)(*(void *)(*(void *)v691 + 8) + 152);
    v694 = *(void **)(*(void *)v691 + 288);
    uint64_t v696 = *(void *)(v693 + 176);
    v695 = *(std::__shared_weak_count **)(v693 + 184);
    if (v695) {
      atomic_fetch_add_explicit(&v695->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (!v696 || **(void **)(v696 + 40) != v694[1])
    {
      v697 = (std::__shared_weak_count *)v694[3];
      v694[2] = 0;
      v694[3] = 0;
      if (!v697) {
        goto LABEL_1191;
      }
LABEL_1190:
      if (atomic_fetch_add(&v697->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
        goto LABEL_1191;
      }
      ((void (*)(std::__shared_weak_count *))v697->__on_zero_shared)(v697);
      std::__shared_weak_count::__release_weak(v697);
      if (!v695) {
        goto LABEL_1175;
      }
LABEL_1192:
      if (!atomic_fetch_add(&v695->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v695->__on_zero_shared)(v695);
        std::__shared_weak_count::__release_weak(v695);
      }
      goto LABEL_1175;
    }
    uint64_t v698 = v694[2];
    if (v698) {
      BOOL v699 = v698 == v696;
    }
    else {
      BOOL v699 = 1;
    }
    if (!v699) {
      ggl::PipelineSetup::resetData((uint64_t)v694);
    }
    if (v695) {
      atomic_fetch_add_explicit(&v695->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v697 = (std::__shared_weak_count *)v694[3];
    v694[2] = v696;
    v694[3] = v695;
    if (v697) {
      goto LABEL_1190;
    }
LABEL_1191:
    if (v695) {
      goto LABEL_1192;
    }
LABEL_1175:
    v691 += 8;
    if (v691 != v692) {
      continue;
    }
    break;
  }
  uint64_t v669 = *a3;
LABEL_1197:
  uint64_t v672 = *(void *)(v669 + 312);
LABEL_1198:
  v700 = *(void **)(v669 + 328);
  uint64_t v701 = v700[19];
  if (v701) {
    BOOL v702 = v701 == v672;
  }
  else {
    BOOL v702 = 0;
  }
  if (!v702)
  {
    v700[19] = v672;
    uint64_t v703 = v700[1];
    uint64_t v704 = v700[2];
    if (v703 != v704)
    {
      while (2)
      {
        uint64_t v705 = *(void *)(*(void *)(*(void *)v703 + 8) + 152);
        v706 = *(void **)(*(void *)v703 + 328);
        uint64_t v708 = *(void *)(v705 + 192);
        v707 = *(std::__shared_weak_count **)(v705 + 200);
        if (v707) {
          atomic_fetch_add_explicit(&v707->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v708 && **(void **)(v708 + 40) == v706[1])
        {
          uint64_t v710 = v706[2];
          if (v710) {
            BOOL v711 = v710 == v708;
          }
          else {
            BOOL v711 = 1;
          }
          if (!v711) {
            ggl::PipelineSetup::resetData((uint64_t)v706);
          }
          if (v707) {
            atomic_fetch_add_explicit(&v707->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v709 = (std::__shared_weak_count *)v706[3];
          v706[2] = v708;
          v706[3] = v707;
          if (v709) {
            goto LABEL_1219;
          }
LABEL_1220:
          if (!v707)
          {
LABEL_1204:
            v703 += 8;
            if (v703 == v704)
            {
              uint64_t v669 = *a3;
              goto LABEL_1226;
            }
            continue;
          }
        }
        else
        {
          v709 = (std::__shared_weak_count *)v706[3];
          v706[2] = 0;
          v706[3] = 0;
          if (!v709) {
            goto LABEL_1220;
          }
LABEL_1219:
          if (atomic_fetch_add(&v709->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_1220;
          }
          ((void (*)(std::__shared_weak_count *))v709->__on_zero_shared)(v709);
          std::__shared_weak_count::__release_weak(v709);
          if (!v707) {
            goto LABEL_1204;
          }
        }
        break;
      }
      if (!atomic_fetch_add(&v707->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v707->__on_zero_shared)(v707);
        std::__shared_weak_count::__release_weak(v707);
      }
      goto LABEL_1204;
    }
  }
LABEL_1226:
  float v712 = *(float *)(v1837 + 5232);
  id v713 = *(id *)(v669 + 144);
  v714 = [v713 composedRoute];
  int v715 = [v714 transportType];
  BOOL v717 = v712 >= 1.0 || v715 != 1;

  if (!v632)
  {
    v722 = a3;
    BOOL v1861 = *(unsigned char *)(*a3 + 623) != 0;
    v721 = v1821;
    uint64_t v723 = v1830;
    goto LABEL_1255;
  }
  uint64_t v718 = *v632;
  uint64_t v719 = v632[1];
  uint64_t v720 = *v632;
  v721 = v1821;
  v722 = a3;
  if (*v632 != v719)
  {
    uint64_t v720 = *v632;
    uint64_t v723 = v1830;
    while (*(unsigned char *)v720 != 2)
    {
      v720 += 16;
      if (v720 == v719)
      {
        uint64_t v724 = 0;
        if (v718 != v719) {
          goto LABEL_1244;
        }
        goto LABEL_1247;
      }
    }
  }
  if (v720 == v719) {
    uint64_t v724 = 0;
  }
  else {
    uint64_t v724 = *(void *)(v720 + 8);
  }
  uint64_t v723 = v1830;
  if (v718 != v719)
  {
LABEL_1244:
    while (*(unsigned char *)v718 != 23)
    {
      v718 += 16;
      if (v718 == v719) {
        goto LABEL_1251;
      }
    }
  }
LABEL_1247:
  if (v718 == v719)
  {
LABEL_1251:
    if (v724) {
      BOOL v726 = 1;
    }
    else {
      BOOL v726 = *(unsigned char *)(*a3 + 623) != 0;
    }
    BOOL v1861 = v726;
LABEL_1255:
    uint64_t v727 = *v1835;
    v728 = (gss::FeatureAttributeSet *)(*v722 + 536);
    *(void *)&v1969[7] = 0;
    *(void *)v1969 = 0;
    v1969[15] = 1;
    gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes(&v1936, v727, v728, (gss::QueryOverrides *)v1969);
    v729 = v1936;
    v730 = v1937;
    if (v1937) {
      atomic_fetch_add_explicit(&v1937->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    md::TrafficMeshStyle::setup((int *)v1916, (uint64_t)v729, v730, 0);
    if (v730 && !atomic_fetch_add(&v730->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v730->__on_zero_shared)(v730);
      std::__shared_weak_count::__release_weak(v730);
    }
    BOOL v1867 = *(_DWORD *)&v1916[4] == 0;
    v731 = v1937;
    if (v1937 && !atomic_fetch_add(&v1937->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v731->__on_zero_shared)(v731);
      std::__shared_weak_count::__release_weak(v731);
    }
    char v732 = 1;
  }
  else
  {
    uint64_t v725 = *(void *)(v718 + 8);
    if (v724)
    {
      BOOL v1861 = 1;
      if (!v725) {
        goto LABEL_1255;
      }
    }
    else
    {
      BOOL v1861 = *(unsigned char *)(*a3 + 623) != 0;
      if (!v725) {
        goto LABEL_1255;
      }
    }
    BOOL v1867 = 0;
    char v732 = 0;
  }
  if (*(unsigned char *)(a1 + 109))
  {
    uint64_t v733 = *v632;
    uint64_t v734 = v632[1];
    uint64_t v735 = *v632;
    if (*v632 != v734)
    {
      uint64_t v735 = *v632;
      while (*(unsigned char *)v735 != 21)
      {
        v735 += 16;
        if (v735 == v734) {
          goto LABEL_1273;
        }
      }
    }
    if (v735 == v734 || !*(void *)(v735 + 8))
    {
LABEL_1273:
      if (v733 != v734)
      {
        while (*(unsigned char *)v733 != 25)
        {
          v733 += 16;
          if (v733 == v734) {
            goto LABEL_1280;
          }
        }
      }
      if (v733 == v734) {
LABEL_1280:
      }
        uint64_t v737 = 0;
      else {
        uint64_t v737 = *(void *)(v733 + 8);
      }
      BOOL v736 = v737 != 0;
    }
    else
    {
      BOOL v736 = 1;
    }
  }
  else
  {
    BOOL v736 = 0;
  }
  v738 = (void *)*((void *)v721 + 1);
  int8x8_t v739 = (int8x8_t)v738[1];
  if (v739)
  {
    uint8x8_t v740 = (uint8x8_t)vcnt_s8(v739);
    v740.i16[0] = vaddlv_u8(v740);
    if (v740.u32[0] > 1uLL)
    {
      unint64_t v741 = 0xE42D19AFCA302E68;
      if (*(void *)&v739 <= 0xE42D19AFCA302E68) {
        unint64_t v741 = 0xE42D19AFCA302E68 % *(void *)&v739;
      }
    }
    else
    {
      unint64_t v741 = (*(void *)&v739 - 1) & 0xE42D19AFCA302E68;
    }
    v742 = *(void **)(*v738 + 8 * v741);
    if (v742)
    {
      v743 = (void *)*v742;
      if (v743)
      {
        if (v740.u32[0] < 2uLL)
        {
          uint64_t v744 = *(void *)&v739 - 1;
          while (1)
          {
            uint64_t v746 = v743[1];
            if (v746 == 0xE42D19AFCA302E68)
            {
              if (v743[2] == 0xE42D19AFCA302E68) {
                goto LABEL_1305;
              }
            }
            else if ((v746 & v744) != v741)
            {
              goto LABEL_1309;
            }
            v743 = (void *)*v743;
            if (!v743) {
              goto LABEL_1309;
            }
          }
        }
        do
        {
          unint64_t v745 = v743[1];
          if (v745 == 0xE42D19AFCA302E68)
          {
            if (v743[2] == 0xE42D19AFCA302E68)
            {
LABEL_1305:
              uint64_t v747 = v743[5];
              if (*(void *)(v747 + 8) == 0xE42D19AFCA302E68)
              {
                uint64_t v748 = *(void *)(v747 + 32);
                if (v748)
                {
                  if ((*(_DWORD *)(v748 + 88) - 3) >= 0xFFFFFFFE) {
                    BOOL v736 = 0;
                  }
                }
              }
              break;
            }
          }
          else
          {
            if (v745 >= *(void *)&v739) {
              v745 %= *(void *)&v739;
            }
            if (v745 != v741) {
              break;
            }
          }
          v743 = (void *)*v743;
        }
        while (v743);
      }
    }
  }
LABEL_1309:
  uint64_t v749 = *v722;
  md::RibbonLayoutContext::RibbonLayoutContext((md::RibbonLayoutContext *)v1916, v721);
  uint64_t v1922 = v749 + 464;
  char v1923 = v1828;
  char v1924 = 0;
  __asm { FMOV            V14.2S, #1.0 }
  uint64_t v1925 = _D14;
  uint64_t v1926 = 0;
  __int16 v1927 = 0;
  float v1931 = 0.0;
  long double __x = 0.0;
  memset(v1930, 0, 21);
  char v1933 = 1;
  memset(v1934, 0, sizeof(v1934));
  unint64_t v1935 = *(void *)(md::LayoutContext::frameState(v721) + 624);
  if (v723 && *(unsigned char *)(v723 + 64))
  {
    uint64_t v754 = *(void *)(v723 + 72);
    uint64_t v753 = *(void *)(v723 + 80);
    if (v753) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v753 + 8), 1uLL, memory_order_relaxed);
    }
    v755 = *(std::__shared_weak_count **)&v1930[3];
    *(void *)&v1930[1] = v754;
    *(void *)&v1930[3] = v753;
    if (v755 && !atomic_fetch_add(&v755->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v755->__on_zero_shared)(v755);
      std::__shared_weak_count::__release_weak(v755);
    }
  }
  uint64_t v756 = *v722;
  char v1924 = *(unsigned char *)(*v722 + 620);
  double v757 = *(double *)(v756 + 168);
  if (fabs(v757) <= 2.22044605e-16)
  {
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    v758 = (id)GEOGetVectorKitRouteLog_log;
    if (os_log_type_enabled(v758, OS_LOG_TYPE_INFO))
    {
      uint64_t v759 = *(void *)(*v722 + 168);
      *(_DWORD *)v1969 = 134217984;
      *(void *)&v1969[4] = v759;
      _os_log_impl(&dword_1A1780000, v758, OS_LOG_TYPE_INFO, "*** RouteLine width scale = %f ", v1969, 0xCu);
    }

    v722 = a3;
    uint64_t v756 = *a3;
    double v757 = *(double *)(*a3 + 168);
  }
  float v760 = v757;
  *((float *)&v1925 + 1) = v760;
  float v761 = *(float *)(v756 + 200);
  if (fabsf(v761) <= 0.00000011921)
  {
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    v762 = (id)GEOGetVectorKitRouteLog_log;
    if (os_log_type_enabled(v762, OS_LOG_TYPE_INFO))
    {
      double v763 = *(float *)(*v722 + 200);
      *(_DWORD *)v1969 = 134217984;
      *(double *)&v1969[4] = v763;
      _os_log_impl(&dword_1A1780000, v762, OS_LOG_TYPE_INFO, "*** RouteLine alpha scale = %f ", v1969, 0xCu);
    }

    uint64_t v756 = *a3;
    float v761 = *(float *)(*a3 + 200);
  }
  *(float *)&uint64_t v1925 = v761;
  if (*(unsigned char *)(v756 + 621))
  {
    int v764 = 0;
    if (!v736) {
      goto LABEL_1340;
    }
LABEL_1335:
    if (*(unsigned char *)(a1 + 109)) {
      int v764 = 2;
    }
    if (!*(unsigned char *)(v756 + 621) && *(unsigned char *)(a1 + 109)) {
      int v764 = *(unsigned __int8 *)(v756 + 620);
    }
  }
  else
  {
    if (*(unsigned char *)(v756 + 620)) {
      int v764 = 1;
    }
    else {
      int v764 = 2;
    }
    if (v736) {
      goto LABEL_1335;
    }
  }
LABEL_1340:
  uint64_t v1926 = (v764 << 24) | (*(_DWORD *)(v756 + 616) << 16);
  BYTE1(v1919) = *(_DWORD *)(v756 + 512);
  id v765 = *(id *)(v756 + 144);
  v766 = [v765 composedRoute];
  int v1928 = [v766 transportType];

  float v767 = v1816 * v111 * v112 / v115;
  if (**((unsigned char **)v1821 + 92)) {
    int v768 = 1;
  }
  else {
    int v768 = v736;
  }
  v769 = (int8x8_t *)*((void *)v1821 + 1);
  if (v768 == 1)
  {
    md::LayoutContext::zoomAtCentrePoint(*((int8x8_t **)v1821 + 1));
    BOOL v771 = v770 > 13.5 && v717;
  }
  else
  {
    BOOL v771 = 0;
  }
  LOBYTE(v1927) = v771;
  float v1929 = v767;
  HIBYTE(v1927) = v1867;
  md::LayoutContext::zoomAtCentrePoint(v769);
  v1930[0] = v772;
  LOBYTE(v1930[5]) = a4;
  float v1931 = v88;
  long double __x = *(long double *)(md::LayoutContext::frameState(v1821) + 88);
  char v1933 = v736;
  BOOL v773 = v1845;
  if (v1845) {
    BOOL v773 = *(unsigned char *)v1845 != 0;
  }
  v1934[0] = v773;
  v1934[1] = *(unsigned __int8 *)(md::LayoutContext::frameState(v1821) + 128) - 1 < 3;
  float v774 = *(float *)(v1837 + 3076);
  float v775 = *(float *)(v1837 + 3080);
  v776 = +[VKDebugSettings sharedSettings];
  [v776 daVinciGlobeSplinedMaxZoom];
  BOOL v778 = fmaxf(v775 + v774, 1.0) <= v777 && *(unsigned __int8 *)(v1837 + 3776) - 1 < 3;

  v1934[2] = v778;
  if (*(unsigned char *)(v1845 + 32)) {
    int v779 = *(_DWORD *)(v1845 + 36);
  }
  else {
    int v779 = -1;
  }
  *(_DWORD *)&v1934[3] = v779;
  id v780 = *(id *)(v1845 + 40);
  v781 = [v780 routeInfo];
  uint64_t v782 = [v781 route];
  v783 = *(void **)&v1934[7];
  *(void *)&v1934[7] = v782;

  BOOL v1881 = v736;
  v784 = (uint64_t **)a3;
  uint64_t v785 = *(void *)(*a3 + 320);
  uint64_t v786 = *(void *)(v785 + 304);
  *(void *)(v785 + 168) = *(void *)(v786 + 16);
  *(void *)(v785 + 184) = *(void *)(v786 + 72);
  *(void *)(v785 + 160) = *(void *)(v786 + 16);
  if ((_BYTE)v1927)
  {
    v787 = (void *)(v786 + 8);
    *(void *)(v785 + 56) = *(void *)(v786 + 8);
    *(void *)(v785 + 72) = *(void *)v786;
    *(void *)(v785 + 88) = *(void *)(v786 + 8);
    *(void *)(v785 + 112) = *(void *)(v786 + 8);
    *(void *)(v785 + 64) = *(void *)(v786 + 40);
    *(void *)(v785 + 80) = *(void *)(v786 + 40);
    *(void *)(v785 + 96) = *(void *)(v786 + 40);
    *(void *)(v785 + 112) = *(void *)(v786 + 40);
    v788 = (void *)(v786 + 64);
  }
  else
  {
    *(void *)(v785 + 56) = *(void *)v786;
    *(void *)(v785 + 72) = *(void *)v786;
    *(void *)(v785 + 88) = *(void *)v786;
    *(void *)(v785 + 112) = *(void *)v786;
    *(void *)(v785 + 64) = *(void *)(v786 + 32);
    *(void *)(v785 + 80) = *(void *)(v786 + 32);
    *(void *)(v785 + 96) = *(void *)(v786 + 32);
    *(void *)(v785 + 112) = *(void *)(v786 + 32);
    v788 = (void *)(v786 + 56);
    v787 = (void *)v786;
  }
  *(void *)(v785 + 176) = *v788;
  *(void *)(v785 + 120) = *v787;
  *(void *)(v785 + 192) = *(void *)(v786 + 80);
  if (*(unsigned char *)(v786 + 296))
  {
    *(void *)(v785 + 136) = *(void *)(v786 + 80);
  }
  else
  {
    *(void *)(v785 + 152) = *(void *)(v786 + 48);
    *(void *)(v785 + 144) = *(void *)(v786 + 24);
  }
  *(void *)(v785 + 128) = *(void *)(v786 + 88);
  v789 = *(uint64_t **)(v785 + 8);
  v790 = *(uint64_t **)(v785 + 16);
  if (v789 == v790) {
    goto LABEL_1370;
  }
  do
  {
    if (*(unsigned char *)(*v789 + 2448)) {
      md::RouteLineBatch::layout(*v789, (uint64_t)v1916);
    }
    ++v789;
  }
  while (v789 != v790);
  v791 = *(char **)(v785 + 8);
  v792 = *(char **)(v785 + 16);
  if (v791 == v792)
  {
LABEL_1370:
    int v794 = 0;
  }
  else
  {
    unint64_t v793 = v792 - v791 - 8;
    if (v793 > 7)
    {
      int v795 = 0;
      int v796 = 0;
      uint64_t v797 = (v793 >> 3) + 1;
      v798 = v791 + 8;
      uint64_t v799 = v797 & 0x3FFFFFFFFFFFFFFELL;
      do
      {
        v795 += *(unsigned __int8 *)(*(v798 - 1) + 2448);
        v796 += *(unsigned __int8 *)(*v798 + 2448);
        v798 += 2;
        v799 -= 2;
      }
      while (v799);
      int v794 = v796 + v795;
      if (v797 != (v797 & 0x3FFFFFFFFFFFFFFELL))
      {
        v791 += 8 * (v797 & 0x3FFFFFFFFFFFFFFELL);
        goto LABEL_1375;
      }
    }
    else
    {
      int v794 = 0;
      do
      {
LABEL_1375:
        uint64_t v800 = *(void *)v791;
        v791 += 8;
        v794 += *(unsigned __int8 *)(v800 + 2448);
      }
      while (v791 != v792);
    }
  }
  if (*(_DWORD *)(v785 + 312) != v794)
  {
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    v801 = (id)GEOGetVectorKitRouteLog_log;
    if (os_log_type_enabled(v801, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)v1969 = 67109120;
      *(_DWORD *)&v1969[4] = v794;
      _os_log_impl(&dword_1A1780000, v801, OS_LOG_TYPE_INFO, "RouteLine batchRendered = %d", v1969, 8u);
    }

    v784 = (uint64_t **)a3;
  }
  *(_DWORD *)(v785 + 312) = v794;
  uint64_t v802 = (*v784)[42];
  *(void *)(v802 + 56) = **(void **)(v802 + 152);
  v803 = *(void **)(*(void *)v1916 + 8);
  int8x8_t v804 = (int8x8_t)v803[1];
  if (!*(void *)&v804) {
    goto LABEL_1405;
  }
  uint8x8_t v805 = (uint8x8_t)vcnt_s8(v804);
  v805.i16[0] = vaddlv_u8(v805);
  if (v805.u32[0] > 1uLL)
  {
    uint64_t v806 = 0x1AF456233693CD46;
    if (*(void *)&v804 <= 0x1AF456233693CD46uLL) {
      uint64_t v806 = 0x1AF456233693CD46uLL % *(void *)&v804;
    }
  }
  else
  {
    uint64_t v806 = (*(void *)&v804 - 1) & 0x1AF456233693CD46;
  }
  v807 = *(void **)(*v803 + 8 * v806);
  if (!v807) {
    goto LABEL_1405;
  }
  v808 = (void *)*v807;
  if (!v808) {
    goto LABEL_1405;
  }
  if (v805.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v810 = v808[1];
      if (v810 == 0x1AF456233693CD46)
      {
        if (v808[2] == 0x1AF456233693CD46) {
          goto LABEL_1403;
        }
      }
      else if ((v810 & (*(void *)&v804 - 1)) != v806)
      {
        goto LABEL_1405;
      }
      v808 = (void *)*v808;
      if (!v808) {
        goto LABEL_1405;
      }
    }
  }
  while (2)
  {
    unint64_t v809 = v808[1];
    if (v809 != 0x1AF456233693CD46)
    {
      if (v809 >= *(void *)&v804) {
        v809 %= *(void *)&v804;
      }
      if (v809 != v806) {
        goto LABEL_1405;
      }
      goto LABEL_1392;
    }
    if (v808[2] != 0x1AF456233693CD46)
    {
LABEL_1392:
      v808 = (void *)*v808;
      if (!v808) {
        goto LABEL_1405;
      }
      continue;
    }
    break;
  }
LABEL_1403:
  uint64_t v811 = v808[5];
  if (*(void *)(v811 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v812 = *(void *)(v811 + 32);
    goto LABEL_1406;
  }
LABEL_1405:
  uint64_t v812 = 0;
LABEL_1406:
  char v1872 = v732;
  if (!*(unsigned char *)(v812 + 3776))
  {
    if ((*(void *)&v804 & (*(void *)&v804 - 1)) != 0)
    {
      unint64_t v820 = 0x8BD499FBD96FBB9ELL;
      if (*(void *)&v804 <= 0x8BD499FBD96FBB9ELL) {
        unint64_t v820 = 0x8BD499FBD96FBB9ELL % *(void *)&v804;
      }
      v816 = *(void **)(*v803 + 8 * v820);
      do
      {
        do
          v816 = (void *)*v816;
        while (v816[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v816[2] != 0x8BD499FBD96FBB9ELL);
    }
    else
    {
      v816 = *(void **)(*v803 + 8 * ((*(void *)&v804 - 1) & 0x8BD499FBD96FBB9ELL));
      do
      {
        do
          v816 = (void *)*v816;
        while (v816[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v816[2] != 0x8BD499FBD96FBB9ELL);
    }
    double v821 = 0.0;
    if (**(unsigned char **)(v816[5] + 32) && *(unsigned char *)(v802 + 104)) {
      double v821 = *(double *)(v812 + 24) * 0.0000000249532021 * (double)(1 << *(unsigned char *)(v802 + 81));
    }
    uint64_t v822 = *(void *)(v802 + 112);
    if ((*(unsigned char *)(v822 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      *(void *)v1969 = &v1986;
      *(void *)long long buf = v1969;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, buf, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    v818 = *(float **)(v822 + 72);
    double v819 = v821;
    goto LABEL_1430;
  }
  uint64_t v813 = *(void *)(v802 + 72);
  if (!v813)
  {
    uint64_t v817 = *(void *)(v802 + 112);
    if ((*(unsigned char *)(v817 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      *(void *)v1969 = &v1986;
      *(void *)long long buf = v1969;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, buf, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    v818 = *(float **)(v817 + 72);
    double v819 = 0.0;
LABEL_1430:
    int v814 = ggl::CullingGrid::intersectedCellsForView(v818, v819);
    goto LABEL_1431;
  }
  int v814 = gdc::GlobeTileGrid::intersectWithFrustum(v813, (const double *)(v812 + 984), *(double *)(v812 + 24));
LABEL_1431:
  v823 = *(uint64_t **)(v802 + 8);
  v824 = *(uint64_t **)(v802 + 16);
  if (v823 != v824)
  {
    do
    {
      uint64_t v826 = *v823;
      v827 = *(uint64_t **)(*v823 + 248);
      v828 = *(uint64_t **)(*v823 + 256);
      if (v827 == v828)
      {
        char v825 = 0;
      }
      else
      {
        char v825 = 0;
        do
        {
          uint64_t v829 = *v827++;
          BOOL v830 = (*(_DWORD *)(v829 + 96) & v814) != 0;
          v825 |= v830;
          *(unsigned char *)(v829 + 48) = v830;
        }
        while (v827 != v828);
      }
      *(unsigned char *)(v826 + 136) = v825 & 1;
      *(unsigned char *)(v826 + 272) = v825 & 1;
      ++v823;
    }
    while (v823 != v824);
    v832 = *(uint64_t **)(v802 + 8);
    v831 = *(uint64_t **)(v802 + 16);
    if (v832 != v831)
    {
      __asm { FMOV            V0.4S, #1.0 }
      *(__n128 *)v1891 = _Q0;
      while (1)
      {
        uint64_t v834 = *v832;
        if (!*(unsigned char *)(*v832 + 272)) {
          goto LABEL_1443;
        }
        uint64_t v835 = *(void *)(*(void *)(*(void *)(v834 + 8) + 152) + 248);
        float v836 = v835 ? *(float *)(v835 + 16) : 1.0;
        md::RouteStyleContext::RouteStyleContext((uint64_t)v1969, (uint64_t)v1916, *(void *)(v834 + 280), *(unsigned __int8 *)(v834 + 296), v836);
        if (v1969[2]) {
          break;
        }
        *(unsigned char *)(v834 + 136) = 0;
        *(unsigned char *)(v834 + 272) = 0;
        uint64_t v833 = v1974;
        if ((void)v1974) {
          goto LABEL_1442;
        }
LABEL_1443:
        if (++v832 == v831) {
          goto LABEL_1465;
        }
      }
      *(unsigned char *)(v834 + 272) = 1;
      uint64_t v838 = *(void *)(v834 + 280);
      uint64_t v837 = *(void *)(v834 + 288);
      __int32 v839 = *(_DWORD *)(v838 + 64);
      *(unsigned char *)(v834 + 136) = 1;
      __int32 v840 = v1979;
      double v841 = *(double *)(v838 + 208);
      float v842 = v841 / (*((float *)&v1925 + 1) * v1931);
      float32_t v843 = (float)(*((float *)&v1925 + 1) * v842)
           / (float)(int)(v841
                        / (float)((float)(*(float *)(v838 + 56) * v1980)
                                + (float)((float)(*((float *)&v1925 + 1) * v1931) * v1978)));
      int v844 = *(unsigned __int8 *)(v834 + 296);
      v845 = *(void **)(*(void *)(v837 + 64) + 32);
      unint64_t v846 = v845[1];
      v847 = (float32x4_t *)v845[9];
      v847[5].i32[0] = v1925;
      v847->i32[0] = v840;
      _Q0 = *(__n128 *)&v1969[8];
      v847[4] = vsubq_f32(*(float32x4_t *)v1891, *(float32x4_t *)&v1969[8]);
      v847[3].i64[0] = *(void *)&v1969[40];
      v847[3].i64[1] = *(void *)&v1969[48];
      v847[2].i32[0] = v839;
      v847[6].f32[2] = v843;
      unint64_t v848 = v845[8];
      if (v848 <= v846) {
        unint64_t v848 = v846;
      }
      v845[7] = 0;
      v845[8] = v848;
      if (!v844)
      {
        _Q0.n128_f32[0] = _Q0.n128_f32[3] * 0.9;
        uint64_t v849 = v845[9];
        *(float *)(v849 + 84) = _Q0.n128_f32[3] * 0.9;
        *(_DWORD *)(v849 + 88) = 1065353216;
        if (v845[8] > v846) {
          unint64_t v846 = v845[8];
        }
        v845[7] = 0;
        v845[8] = v846;
      }
      *(void *)(v834 + 48) = v837;
      v850 = *(void **)(v834 + 224);
      if (v850)
      {
        do
        {
          if (v850[1])
          {
            unint64_t v852 = 0;
            v853 = v850 + 2;
            v854 = v850 + 2;
            v855 = (void (***)(void))(v850 + 2);
            do
            {
              v856 = (void (**)(void *))*v855;
              v855 += 15;
              (*v856)(v854);
              ++v852;
              v853 += 15;
              v854 = v855;
            }
            while (v852 < v850[1]);
          }
          v850[1] = 0;
          v850 = (void *)*v850;
        }
        while (v850);
        uint64_t v851 = *(void *)(v834 + 224);
      }
      else
      {
        uint64_t v851 = 0;
      }
      *(void *)(v834 + 232) = v851;
      v784 = (uint64_t **)a3;
      uint64_t v833 = v1974;
      if (!(void)v1974) {
        goto LABEL_1443;
      }
LABEL_1442:
      *((void *)&v1974 + 1) = v833;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1976 + 40))(v1976, v833, v1975 - v833);
      goto LABEL_1443;
    }
  }
LABEL_1465:
  uint64_t v857 = *(void *)(*(void *)(a1 + 40) + 24);
  v858 = *(void **)(v857 + 8);
  uint64_t v859 = v858[3];
  uint64_t v860 = v858[4];
  if (v860 == v859)
  {
    uint64_t v868 = 0;
    uint64_t v866 = 0;
    goto LABEL_1482;
  }
  uint64_t v861 = 0;
  while (1)
  {
    v862 = *(unsigned __int8 **)(v859 + 8 * v861);
    if (*v862 == *(unsigned __int8 *)(a1 + 96))
    {
      unint64_t v863 = *((void *)v862 + 1);
      uint64_t v864 = v858[15];
      if (v863 < (v858[16] - v864) >> 3) {
        break;
      }
    }
    if (++v861 >= (unint64_t)((v860 - v859) >> 3)) {
      goto LABEL_1473;
    }
  }
  uint64_t v865 = *(void *)(v864 + 8 * v863);
  if (v865)
  {
    uint64_t v866 = *(void *)(*(void *)(v865 + 24) + 8 * *(unsigned __int8 *)(a1 + 97));
    uint64_t v867 = v860 - v859;
    if (v860 == v859)
    {
LABEL_1472:
      uint64_t v868 = 0;
LABEL_1482:
      uint64_t v875 = 0;
LABEL_1483:
      uint64_t v1878 = 0;
      goto LABEL_1484;
    }
  }
  else
  {
LABEL_1473:
    uint64_t v866 = 0;
    uint64_t v867 = v860 - v859;
    if (v860 == v859) {
      goto LABEL_1472;
    }
  }
  uint64_t v869 = 0;
  unint64_t v870 = v867 >> 3;
  while (1)
  {
    v871 = *(unsigned __int8 **)(v859 + 8 * v869);
    if (*v871 == *(unsigned __int8 *)(a1 + 98))
    {
      unint64_t v872 = *((void *)v871 + 1);
      uint64_t v873 = v858[15];
      if (v872 < (v858[16] - v873) >> 3) {
        break;
      }
    }
    if (++v869 >= v870) {
      goto LABEL_1609;
    }
  }
  uint64_t v874 = *(void *)(v873 + 8 * v872);
  if (v874)
  {
    uint64_t v875 = *(void *)(*(void *)(v874 + 24) + 8 * *(unsigned __int8 *)(a1 + 99));
    uint64_t v876 = v860 - v859;
    if (v860 == v859)
    {
LABEL_1480:
      uint64_t v868 = 0;
      goto LABEL_1483;
    }
  }
  else
  {
LABEL_1609:
    uint64_t v875 = 0;
    uint64_t v876 = v860 - v859;
    if (v860 == v859) {
      goto LABEL_1480;
    }
  }
  uint64_t v979 = 0;
  unint64_t v980 = v876 >> 3;
  while (1)
  {
    v981 = *(unsigned __int8 **)(v859 + 8 * v979);
    if (*v981 == *(unsigned __int8 *)(a1 + 100))
    {
      unint64_t v982 = *((void *)v981 + 1);
      uint64_t v983 = v858[15];
      if (v982 < (v858[16] - v983) >> 3) {
        break;
      }
    }
    if (++v979 >= v980) {
      goto LABEL_1627;
    }
  }
  uint64_t v984 = *(void *)(v983 + 8 * v982);
  if (v984)
  {
    uint64_t v868 = *(void *)(*(void *)(v984 + 24) + 8 * *(unsigned __int8 *)(a1 + 101));
    uint64_t v985 = v860 - v859;
    if (v860 == v859) {
      goto LABEL_1483;
    }
    goto LABEL_1628;
  }
LABEL_1627:
  uint64_t v868 = 0;
  uint64_t v985 = v860 - v859;
  if (v860 == v859) {
    goto LABEL_1483;
  }
LABEL_1628:
  uint64_t v998 = 0;
  unint64_t v999 = v985 >> 3;
  while (1)
  {
    v1000 = *(unsigned __int8 **)(v859 + 8 * v998);
    if (*v1000 == *(unsigned __int8 *)(a1 + 102))
    {
      unint64_t v1001 = *((void *)v1000 + 1);
      uint64_t v1002 = v858[15];
      if (v1001 < (v858[16] - v1002) >> 3) {
        break;
      }
    }
    if (++v998 >= v999) {
      goto LABEL_1483;
    }
  }
  uint64_t v1003 = *(void *)(v1002 + 8 * v1001);
  if (!v1003) {
    goto LABEL_1483;
  }
  uint64_t v1878 = *(void *)(*(void *)(v1003 + 24) + 8 * *(unsigned __int8 *)(a1 + 103));
LABEL_1484:
  uint64_t v877 = (*v784)[40];
  v878 = *(char ****)(v877 + 8);
  v879 = *(char ****)(v877 + 16);
  if (v878 != v879)
  {
    do
    {
      v880 = *v878;
      *(void *)v1969 = &unk_1EF578F90;
      *(void *)&v1969[8] = v875;
      *(void *)&v1969[24] = v1969;
      md::Ribbons::RibbonBatch<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(v880, 0xC0u, (uint64_t)v1969, _Q0);
      if (*(unsigned char **)&v1969[24] == v1969)
      {
        (*(void (**)(unsigned char *))(*(void *)v1969 + 32))(v1969);
      }
      else if (*(void *)&v1969[24])
      {
        (*(void (**)(void))(**(void **)&v1969[24] + 40))();
      }
      ++v878;
    }
    while (v878 != v879);
    v784 = (uint64_t **)a3;
    uint64_t v877 = *(void *)(*a3 + 320);
  }
  v881 = *(char ****)(v877 + 8);
  v882 = *(char ****)(v877 + 16);
  if (v881 != v882)
  {
    do
    {
      v883 = *v881;
      *(void *)v1969 = &unk_1EF578F90;
      *(void *)&v1969[8] = v866;
      *(void *)&v1969[24] = v1969;
      md::Ribbons::RibbonBatch<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(v883, 0xCu, (uint64_t)v1969, _Q0);
      if (*(unsigned char **)&v1969[24] == v1969)
      {
        (*(void (**)(unsigned char *))(*(void *)v1969 + 32))(v1969);
      }
      else if (*(void *)&v1969[24])
      {
        (*(void (**)(void))(**(void **)&v1969[24] + 40))();
      }
      ++v881;
    }
    while (v881 != v882);
    uint64_t v877 = (*v784)[40];
  }
  v884 = *(char ****)(v877 + 8);
  for (junint64_t j = *(char ****)(v877 + 16); v884 != jj; ++v884)
  {
    v886 = *v884;
    *(void *)v1969 = &unk_1EF578F90;
    *(void *)&v1969[8] = v868;
    *(void *)&v1969[24] = v1969;
    md::Ribbons::RibbonBatch<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(v886, 0x30u, (uint64_t)v1969, _Q0);
    if (*(unsigned char **)&v1969[24] == v1969)
    {
      (*(void (**)(unsigned char *))(*(void *)v1969 + 32))(v1969);
    }
    else if (*(void *)&v1969[24])
    {
      (*(void (**)(void))(**(void **)&v1969[24] + 40))();
    }
  }
  if (v1881) {
    int v887 = 155907;
  }
  else {
    int v887 = 16387;
  }
  int v888 = v887 | 0x18000;
  if (v1867) {
    int v888 = v887;
  }
  if (v1861) {
    int v889 = v888;
  }
  else {
    int v889 = v887;
  }
  if (*(unsigned char *)(a1 + 109)) {
    char v890 = v1872;
  }
  else {
    char v890 = 1;
  }
  if (*(unsigned char *)(a1 + 109)) {
    int v891 = 1024;
  }
  else {
    int v891 = 6144;
  }
  if ((v890 & 1) == 0)
  {
    v892 = *(void **)(v857 + 8);
    uint64_t v893 = v892[3];
    uint64_t v894 = v892[4];
    uint64_t v895 = v894 - v893;
    if (v894 == v893) {
      goto LABEL_1529;
    }
    uint64_t v896 = 0;
    unint64_t v897 = v895 >> 3;
    while (1)
    {
      v898 = *(unsigned __int8 **)(v893 + 8 * v896);
      if (*v898 == *(unsigned __int8 *)(a1 + 104))
      {
        unint64_t v899 = *((void *)v898 + 1);
        uint64_t v900 = v892[15];
        if (v899 < (v892[16] - v900) >> 3) {
          break;
        }
      }
      if (++v896 >= v897) {
        goto LABEL_1529;
      }
    }
    uint64_t v901 = *(void *)(v900 + 8 * v899);
    if (!v901) {
LABEL_1529:
    }
      uint64_t v902 = 0;
    else {
      uint64_t v902 = *(void *)(*(void *)(v901 + 24) + 8 * *(unsigned __int8 *)(a1 + 105));
    }
    uint64_t v903 = (*v784)[40];
    v904 = *(char ****)(v903 + 8);
    for (kuint64_t k = *(char ****)(v903 + 16); v904 != kk; ++v904)
    {
      v906 = *v904;
      *(void *)v1969 = &unk_1EF578F90;
      *(void *)&v1969[8] = v902;
      *(void *)&v1969[24] = v1969;
      md::Ribbons::RibbonBatch<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(v906, 0x400u, (uint64_t)v1969, _Q0);
      if (*(unsigned char **)&v1969[24] == v1969)
      {
        (*(void (**)(unsigned char *))(*(void *)v1969 + 32))(v1969);
      }
      else if (*(void *)&v1969[24])
      {
        (*(void (**)(void))(**(void **)&v1969[24] + 40))();
      }
    }
    int v891 = 1024;
  }
  v907 = *v784;
  uint64_t v908 = (*v784)[40];
  v909 = *(char ****)(v908 + 8);
  v910 = *(char ****)(v908 + 16);
  uint64_t v1846 = v857;
  if (v909 != v910)
  {
    unsigned int v911 = v889 | v891;
    do
    {
      v912 = *v909;
      *(void *)v1969 = &unk_1EF578F90;
      *(void *)&v1969[8] = v1878;
      *(void *)&v1969[24] = v1969;
      md::Ribbons::RibbonBatch<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(v912, v911, (uint64_t)v1969, _Q0);
      if (*(unsigned char **)&v1969[24] == v1969)
      {
        (*(void (**)(unsigned char *))(*(void *)v1969 + 32))(v1969);
      }
      else if (*(void *)&v1969[24])
      {
        (*(void (**)(void))(**(void **)&v1969[24] + 40))();
      }
      ++v909;
    }
    while (v909 != v910);
    v907 = *v784;
  }
  uint64_t v913 = v907[42];
  v914 = *(uint64_t **)(v913 + 8);
  v1892 = *(uint64_t **)(v913 + 16);
  if (v914 != v1892)
  {
    v915 = (md::LayoutContext *)&v1969[8];
    do
    {
      uint64_t v917 = *v914;
      *(void *)long long buf = &unk_1EF579140;
      *(void *)&uint8_t buf[8] = v1878;
      *(void *)&buf[24] = buf;
      if (*(unsigned char *)(v917 + 272))
      {
        if (*(unsigned char *)(v917 + 136))
        {
          uint64_t v918 = *(void *)(*(void *)(v917 + 8) + 56);
          *(void *)(v917 + 40) = v918;
          BOOL v919 = *(unsigned __int8 *)(v918 + 58) == 1;
        }
        else
        {
          BOOL v919 = 0;
        }
        v920 = *(uint64_t ***)(v917 + 248);
        v784 = *(uint64_t ***)(v917 + 256);
        if (v920 != v784)
        {
          uint64_t v921 = 0;
          v922 = (char **)(v917 + 144);
          while (1)
          {
            v923 = *v920;
            if (*((unsigned char *)*v920 + 48))
            {
              if (v923[11] != v921)
              {
                if (v921)
                {
                  v924 = ggl::Batcher::commit((long long **)(v917 + 144), 0xC8u, _Q0);
                  if (v924[1] != *v924)
                  {
                    if (*(unsigned char *)(v917 + 136))
                    {
                      v910 = (char ***)v924;
                      long long v926 = *(_OWORD *)(v917 + 24);
                      long long v925 = *(_OWORD *)(v917 + 40);
                      long long v927 = *(_OWORD *)(v917 + 56);
                      long long v928 = *(_OWORD *)(v917 + 72);
                      long long v929 = *(_OWORD *)(v917 + 88);
                      long long v930 = *(_OWORD *)(v917 + 120);
                      *(_OWORD *)&v1969[88] = *(_OWORD *)(v917 + 104);
                      *(_OWORD *)&v1969[104] = v930;
                      *(void *)v1969 = &off_1EF55A458;
                      *(_OWORD *)&v1969[8] = v926;
                      *(_OWORD *)&v1969[24] = v925;
                      *(_OWORD *)&v1969[56] = v928;
                      *(_OWORD *)&v1969[72] = v929;
                      *(_OWORD *)&v1969[40] = v927;
                      v931 = *(void **)(v917 + 232);
                      uint64_t v932 = v931[1];
                      if (v932 == *(void *)(v917 + 240))
                      {
                        v931 = (void *)*v931;
                        if (!v931)
                        {
                          v931 = malloc_type_malloc(120 * v932 + 16, 0xB644C221uLL);
                          void *v931 = 0;
                          v931[1] = 0;
                          **(void **)(v917 + 232) = v931;
                        }
                        *(void *)(v917 + 232) = v931;
                        uint64_t v932 = v931[1];
                      }
                      v933 = &v931[15 * v932];
                      v931[1] = v932 + 1;
                      v933[2] = &off_1EF55A458;
                      long long v934 = *(_OWORD *)&v1969[88];
                      long long v935 = *(_OWORD *)&v1969[104];
                      long long v936 = *(_OWORD *)&v1969[72];
                      *(_OWORD *)(v933 + 9) = *(_OWORD *)&v1969[56];
                      long long v937 = *(_OWORD *)&v1969[8];
                      long long v938 = *(_OWORD *)&v1969[24];
                      *(_OWORD *)(v933 + 7) = *(_OWORD *)&v1969[40];
                      *(_OWORD *)(v933 + 5) = v938;
                      *(_OWORD *)(v933 + 3) = v937;
                      *(_OWORD *)(v933 + 15) = v935;
                      *(_OWORD *)(v933 + 13) = v934;
                      *(_OWORD *)(v933 + 11) = v936;
                      v933[10] = v921;
                      v939 = *v910;
                      v933[13] = *v910;
                      v933[14] = ((char *)v910[1] - (char *)v939) >> 4;
                      v1986.i32[0] = 0;
                      *(void *)v1969 = v933 + 2;
                      if (!*(void *)&buf[24]) {
                        goto LABEL_2744;
                      }
                      (*(void (**)(void, float32x4_t *, unsigned char *))(**(void **)&buf[24] + 48))(*(void *)&buf[24], &v1986, v1969);
                    }
                  }
                }
                v923 = *v920;
                uint64_t v921 = (*v920)[11];
              }
              uint64_t v940 = 2;
              if (v919)
              {
                uint64_t v940 = 4;
                v941 = v923 + 4;
              }
              else
              {
                v941 = v923 + 2;
              }
              if (v941[1] != v923[v940]) {
                gm::MultiRange<unsigned long>::push_back((char **)(v917 + 144), v941);
              }
            }
            if (++v920 == v784) {
              goto LABEL_1576;
            }
          }
        }
        uint64_t v921 = 0;
LABEL_1576:
        v942 = ggl::Batcher::commit((long long **)(v917 + 144), 0xC8u, _Q0);
        v784 = (uint64_t **)a3;
        if (v942[1] != *v942 && *(unsigned char *)(v917 + 136))
        {
          v922 = v942;
          long long v943 = *(_OWORD *)(v917 + 40);
          long long v944 = *(_OWORD *)(v917 + 24);
          long long v945 = *(_OWORD *)(v917 + 56);
          long long v946 = *(_OWORD *)(v917 + 72);
          long long v947 = *(_OWORD *)(v917 + 88);
          long long v948 = *(_OWORD *)(v917 + 120);
          *(_OWORD *)&v1969[88] = *(_OWORD *)(v917 + 104);
          *(_OWORD *)&v1969[104] = v948;
          *(void *)v1969 = &off_1EF55A458;
          *(_OWORD *)&v1969[8] = v944;
          *(_OWORD *)&v1969[24] = v943;
          *(_OWORD *)&v1969[56] = v946;
          *(_OWORD *)&v1969[72] = v947;
          *(_OWORD *)&v1969[40] = v945;
          v949 = *(void **)(v917 + 232);
          uint64_t v950 = v949[1];
          if (v950 == *(void *)(v917 + 240))
          {
            v949 = (void *)*v949;
            if (!v949)
            {
              v949 = malloc_type_malloc(120 * v950 + 16, 0xB644C221uLL);
              void *v949 = 0;
              v949[1] = 0;
              **(void **)(v917 + 232) = v949;
            }
            *(void *)(v917 + 232) = v949;
            uint64_t v950 = v949[1];
          }
          v951 = &v949[15 * v950];
          v949[1] = v950 + 1;
          v951[2] = &off_1EF55A458;
          long long v952 = *(_OWORD *)&v1969[88];
          long long v953 = *(_OWORD *)&v1969[104];
          long long v954 = *(_OWORD *)&v1969[72];
          *(_OWORD *)(v951 + 9) = *(_OWORD *)&v1969[56];
          long long v955 = *(_OWORD *)&v1969[8];
          long long v956 = *(_OWORD *)&v1969[24];
          *(_OWORD *)(v951 + 7) = *(_OWORD *)&v1969[40];
          *(_OWORD *)(v951 + 5) = v956;
          *(_OWORD *)(v951 + 3) = v955;
          *(_OWORD *)(v951 + 15) = v953;
          *(_OWORD *)(v951 + 13) = v952;
          *(_OWORD *)(v951 + 11) = v954;
          v951[10] = v921;
          v957 = *v922;
          v951[13] = *v922;
          v951[14] = (v922[1] - v957) >> 4;
          v1986.i32[0] = 0;
          *(void *)v1969 = v951 + 2;
          if (!*(void *)&buf[24])
          {
LABEL_2744:
            std::__throw_bad_function_call[abi:nn180100]();
            goto LABEL_2760;
          }
          (*(void (**)(void, float32x4_t *, unsigned char *))(**(void **)&buf[24] + 48))(*(void *)&buf[24], &v1986, v1969);
          v784 = (uint64_t **)a3;
        }
        if (*(unsigned char **)&buf[24] != buf)
        {
          if (*(void *)&buf[24]) {
            (*(void (**)(void))(**(void **)&buf[24] + 40))();
          }
          goto LABEL_1550;
        }
        v916 = *(void (***)(unsigned char *))buf;
      }
      else
      {
        v916 = (void (**)(unsigned char *))&unk_1EF579140;
      }
      v916[4](buf);
LABEL_1550:
      ++v914;
    }
    while (v914 != v1892);
  }
  v915 = v1821;
  if (v1830 && *(unsigned char *)(v1830 + 64))
  {
    uint64_t v958 = 0;
    int v959 = *(unsigned __int8 *)(a1 + 106);
    v960 = *(void **)(v1846 + 8);
    while (1)
    {
      v961 = *(unsigned __int8 **)(v960[3] + 8 * v958);
      if (*v961 == v959)
      {
        unint64_t v962 = *((void *)v961 + 1);
        uint64_t v963 = v960[15];
        if (v962 < (v960[16] - v963) >> 3) {
          break;
        }
      }
      ++v958;
    }
    *(void *)(*(void *)(*(void *)(*(void *)(v963 + 8 * v962) + 24) + 8 * *(unsigned __int8 *)(a1 + 107))
              + 32) = *(void *)(*(void *)(a1 + 56) + 8);
    v964 = *(void **)(v1846 + 8);
    uint64_t v965 = v964[3];
    uint64_t v966 = v964[4];
    uint64_t v967 = v966 - v965;
    if (v966 == v965) {
      goto LABEL_1601;
    }
    uint64_t v968 = 0;
    unint64_t v969 = v967 >> 3;
    while (1)
    {
      v970 = *(unsigned __int8 **)(v965 + 8 * v968);
      if (*v970 == v959)
      {
        unint64_t v971 = *((void *)v970 + 1);
        uint64_t v972 = v964[15];
        if (v971 < (v964[16] - v972) >> 3) {
          break;
        }
      }
      if (++v968 >= v969) {
        goto LABEL_1601;
      }
    }
    uint64_t v973 = *(void *)(v972 + 8 * v971);
    if (!v973) {
LABEL_1601:
    }
      uint64_t v974 = 0;
    else {
      uint64_t v974 = *(void *)(*(void *)(v973 + 24) + 8 * *(unsigned __int8 *)(a1 + 107));
    }
    uint64_t v975 = (*v784)[40];
    v976 = *(char ****)(v975 + 8);
    v977 = *(char ****)(v975 + 16);
    if (v976 != v977)
    {
      do
      {
        v978 = *v976;
        *(void *)v1969 = &unk_1EF578F90;
        *(void *)&v1969[8] = v974;
        *(void *)&v1969[24] = v1969;
        md::Ribbons::RibbonBatch<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(v978, 0x200u, (uint64_t)v1969, _Q0);
        if (*(unsigned char **)&v1969[24] == v1969)
        {
          (*(void (**)(unsigned char *))(*(void *)v1969 + 32))(v1969);
        }
        else if (*(void *)&v1969[24])
        {
          (*(void (**)(void))(**(void **)&v1969[24] + 40))();
        }
        ++v976;
      }
      while (v976 != v977);
      int v959 = *(unsigned __int8 *)(a1 + 106);
    }
    v986 = *(void **)(v1846 + 8);
    uint64_t v987 = v986[3];
    uint64_t v988 = v986[4];
    uint64_t v989 = v988 - v987;
    if (v988 == v987) {
      goto LABEL_1625;
    }
    uint64_t v990 = 0;
    unint64_t v991 = v989 >> 3;
    while (1)
    {
      v992 = *(unsigned __int8 **)(v987 + 8 * v990);
      if (*v992 == v959)
      {
        unint64_t v993 = *((void *)v992 + 1);
        uint64_t v994 = v986[15];
        if (v993 < (v986[16] - v994) >> 3) {
          break;
        }
      }
      if (++v990 >= v991) {
        goto LABEL_1625;
      }
    }
    uint64_t v995 = *(void *)(v994 + 8 * v993);
    if (!v995) {
LABEL_1625:
    }
      uint64_t v996 = 0;
    else {
      uint64_t v996 = *(void *)(*(void *)(v995 + 24) + 8 * *(unsigned __int8 *)(a1 + 107));
    }
    *(void *)(v996 + 48) = *(void *)(v996 + 40);
    v997 = +[VKDebugSettings sharedSettings];
    [v997 daVinciRouteLineMaskBlurSigma];

    operator new();
  }
  if (v1861 && v1867)
  {
    uint64_t v1004 = *v1835;
    v1005 = (gss::FeatureAttributeSet *)(*v784 + 67);
    *(void *)&v1969[7] = 0;
    *(void *)v1969 = 0;
    v1969[15] = 1;
    gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)v1992, v1004, v1005, (gss::QueryOverrides *)v1969);
    v1006 = v1992[0];
    v1007 = (std::__shared_weak_count *)v1992[1];
    v1914 = v1992[0];
    v1915 = (std::__shared_weak_count *)v1992[1];
    if (v1992[1])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v1992[1] + 1, 1uLL, memory_order_relaxed);
      atomic_fetch_add_explicit(&v1007->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    md::TrafficMeshStyle::setup((int *)v1962, (uint64_t)v1006, v1007, 0);
    if (v1007 && !atomic_fetch_add(&v1007->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1007->__on_zero_shared)(v1007);
      std::__shared_weak_count::__release_weak(v1007);
    }
    if (v1915 && !atomic_fetch_add(&v1915->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1915->__on_zero_shared)(v1915);
      std::__shared_weak_count::__release_weak(v1915);
    }
    v1008 = *v784;
    if (!(*v784)[34]
      || !v1008[33]
      || ((void *)v1008[75] == v1962[0] ? (BOOL v1009 = (void *)v1008[76] == v1962[1]) : (BOOL v1009 = 0), !v1009))
    {
      *(void *)v1969 = 0;
      *(void *)&v1969[8] = v1969;
      *(void *)&v1969[16] = 0x5812000000;
      *(void *)&v1969[24] = __Block_byref_object_copy__27;
      memset(&v1969[40], 0, 40);
      *(void *)&v1969[32] = __Block_byref_object_dispose__28;
      *(_DWORD *)&v1969[80] = 1065353216;
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&buf[16] = 0x5812000000;
      *(void *)&buf[24] = __Block_byref_object_copy__29;
      memset(&v1982[8], 0, 40);
      *(void *)v1982 = __Block_byref_object_dispose__30;
      LODWORD(v1983[0]) = 1065353216;
      v1010 = (void *)v1008[20];
      v1911[0] = MEMORY[0x1E4F143A8];
      v1911[1] = 3321888768;
      v1911[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_31;
      v1911[3] = &unk_1EF58E9C0;
      v1911[4] = v1969;
      v1911[5] = buf;
      v1911[6] = v1992[0];
      v1912 = (std::__shared_weak_count *)v1992[1];
      if (v1992[1]) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)v1992[1] + 1, 1uLL, memory_order_relaxed);
      }
      long long v1913 = *(_OWORD *)v1962;
      [v1010 forEachSection:v1911];
      uint64_t v1011 = *((void *)v1821 + 92);
      v1909[0] = MEMORY[0x1E4F143A8];
      v1909[1] = 3321888768;
      v1909[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_32;
      v1909[3] = &unk_1EF58E6C8;
      v1012 = (std::__shared_weak_count *)v784[1];
      v1909[6] = *v784;
      v1910 = v1012;
      if (v1012) {
        atomic_fetch_add_explicit(&v1012->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v1909[4] = v1969;
      v1909[5] = buf;
      *(void *)&v1987[8] = 0;
      v1986.i64[0] = (uint64_t)&unk_1EF56BC58;
      v1986.i64[1] = MEMORY[0x1A6239EB0](v1909);
      *(void *)&v1987[8] = &v1986;
      long long v2001 = 0uLL;
      (*(void (**)(void, float32x4_t *, long long *))(**(void **)(v1011 + 32) + 16))(*(void *)(v1011 + 32), &v1986, &v2001);
      v1013 = (std::__shared_weak_count *)*((void *)&v2001 + 1);
      if (*((void *)&v2001 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v2001 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v1013->__on_zero_shared)(v1013);
        std::__shared_weak_count::__release_weak(v1013);
      }
      v915 = v1821;
      v784 = (uint64_t **)a3;
      if (*(float32x4_t **)&v1987[8] == &v1986)
      {
        (*(void (**)(float32x4_t *))(v1986.i64[0] + 32))(&v1986);
      }
      else if (*(void *)&v1987[8])
      {
        (*(void (**)(void))(**(void **)&v1987[8] + 40))();
      }
      *(_OWORD *)(*a3 + 600) = *(_OWORD *)v1962;
      v1014 = v1910;
      if (v1910 && !atomic_fetch_add(&v1910->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v1014->__on_zero_shared)(v1014);
        std::__shared_weak_count::__release_weak(v1014);
      }
      v1015 = v1912;
      if (v1912 && !atomic_fetch_add(&v1912->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v1015->__on_zero_shared)(v1015);
        std::__shared_weak_count::__release_weak(v1015);
      }
      _Block_object_dispose(buf, 8);
      v1016 = *(void **)&v1982[32];
      if (*(void *)&v1982[32])
      {
        do
        {
          v1017 = (void *)*v1016;
          std::__destroy_at[abi:nn180100]<std::pair<md::TrafficBatchKey const,std::vector<std::unique_ptr<md::CasedTrafficRibbon,mdm::TypeDeleter<md::CasedTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::CasedTrafficRibbon,mdm::TypeDeleter<md::CasedTrafficRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v1016 + 2));
          operator delete(v1016);
          v1016 = v1017;
        }
        while (v1017);
      }
      v1018 = *(void **)&v1982[16];
      *(void *)&v1982[16] = 0;
      if (v1018) {
        operator delete(v1018);
      }
      _Block_object_dispose(v1969, 8);
      v1019 = *(void **)&v1969[64];
      if (*(void *)&v1969[64])
      {
        do
        {
          v1020 = (void *)*v1019;
          std::__destroy_at[abi:nn180100]<std::pair<md::TrafficBatchKey const,std::vector<std::unique_ptr<md::CasedTrafficRibbon,mdm::TypeDeleter<md::CasedTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::CasedTrafficRibbon,mdm::TypeDeleter<md::CasedTrafficRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v1019 + 2));
          operator delete(v1019);
          v1019 = v1020;
        }
        while (v1020);
      }
      v1021 = *(void **)&v1969[48];
      *(void *)&v1969[48] = 0;
      if (v1021) {
        operator delete(v1021);
      }
    }
    md::RibbonLayoutContext::RibbonLayoutContext((md::RibbonLayoutContext *)v1969, v915);
    *(_OWORD *)&v1969[112] = 0uLL;
    memset_pattern16(&v1969[128], &unk_1A28FFCB0, 0x10uLL);
    BYTE1(v1972[0]) = 0;
    *(_DWORD *)&v1971[7] = 0;
    v1969[56] = 1;
    *(void *)v1971 = 0;
    uint64_t v1970 = v1926 | 0x40000000;
    v1969[57] = *((_DWORD *)*v784 + 128);
    v1971[8] = v1927;
    v1022 = v1992[0];
    v1023 = v1992[1];
    if (v1992[1])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)v1992[1] + 1, 1uLL, memory_order_relaxed);
      v1024 = *(std::__shared_weak_count **)&v1969[120];
      *(void *)&v1969[112] = v1022;
      *(void *)&v1969[120] = v1023;
      if (v1024 && !atomic_fetch_add(&v1024->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v1024->__on_zero_shared)(v1024);
        std::__shared_weak_count::__release_weak(v1024);
      }
    }
    else
    {
      *(_OWORD *)&v1969[112] = (unint64_t)v1992[0];
    }
    *(_OWORD *)&v1969[128] = *(_OWORD *)v1962;
    v1971[9] = 0;
    *(_DWORD *)v1971 = 0;
    v1025 = *v784;
    uint64_t v1026 = (*v784)[63];
    if (v1026)
    {
      uint64_t v1027 = *(void *)(v1026 + 256);
      v1028 = *(std::__shared_weak_count **)(v1026 + 264);
      if (v1028) {
        atomic_fetch_add_explicit(&v1028->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v1986.i64[0] = v1027;
      v1986.i64[1] = (uint64_t)v1028;
      long long v2001 = 0uLL;
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)buf, v1027, (uint64_t)v1028);
      if (v1028 && !atomic_fetch_add(&v1028->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v1028->__on_zero_shared)(v1028);
        std::__shared_weak_count::__release_weak(v1028);
      }
      v1029 = (std::__shared_weak_count *)*((void *)&v2001 + 1);
      if (*((void *)&v2001 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v2001 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v1029->__on_zero_shared)(v1029);
        std::__shared_weak_count::__release_weak(v1029);
      }
      md::RouteLineSection::halfWidthAtZoom(buf, *(float *)&v1969[8]);
      float v1031 = *((double *)*v784 + 21) * v1030;
      *(float *)v1971 = v1031;
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)buf);
      v1025 = *v784;
    }
    v1032 = (void *)v1025[34];
    v1033 = (const md::TrafficSharedResources *)v1032[19];
    if (!v1033 || v1033 != *(const md::TrafficSharedResources **)(a1 + 80))
    {
      md::PilledTrafficLayer::setSharedResources(v1032, *(void *)(a1 + 80));
      v1025 = *v784;
      v1033 = *(const md::TrafficSharedResources **)(a1 + 80);
    }
    v1034 = (md::SolidTrafficLayer *)v1025[33];
    v1035 = (const md::TrafficSharedResources *)*((void *)v1034 + 20);
    if (!v1035 || v1035 != v1033)
    {
      md::SolidTrafficLayer::setSharedResources(v1034, v1033);
      v1025 = *v784;
    }
    md::PilledTrafficLayer::layout((md::PilledTrafficLayer *)v1025[34], (const md::TrafficContext *)v1969);
    md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(*(uint64_t **)((*v784)[34] + 8), *(uint64_t **)((*v784)[34] + 16), v1878, v1036);
    md::SolidTrafficLayer::layout((md::SolidTrafficLayer *)(*v784)[33], (const md::TrafficContext *)v1969);
    md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(*(void **)((*v784)[33] + 8), *(void **)((*v784)[33] + 16), v1878, v1037);
    v1038 = *(std::__shared_weak_count **)&v1969[120];
    if (*(void *)&v1969[120]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v1969[120] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1038->__on_zero_shared)(v1038);
      std::__shared_weak_count::__release_weak(v1038);
      v1039 = (std::__shared_weak_count *)v1992[1];
      if (!v1992[1]) {
        goto LABEL_1700;
      }
    }
    else
    {
      v1039 = (std::__shared_weak_count *)v1992[1];
      if (!v1992[1]) {
        goto LABEL_1700;
      }
    }
    if (!atomic_fetch_add(&v1039->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1039->__on_zero_shared)(v1039);
      std::__shared_weak_count::__release_weak(v1039);
      if (v1851) {
        goto LABEL_1701;
      }
      goto LABEL_1729;
    }
  }
LABEL_1700:
  if (v1851)
  {
LABEL_1701:
    v1041 = *v784;
    v1040 = (std::__shared_weak_count *)v784[1];
    v1907 = *v784;
    v1908 = v1040;
    if (v1040) {
      atomic_fetch_add_explicit(&v1040->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if (*((float *)v1041 + 208) < 1.0)
    {
      uint64_t v1042 = v1926;
      v1043 = (void *)v1041[87];
      if (!v1043 || [v1043 state] != 3 && objc_msgSend((id)v1041[87], "state") != 4)
      {
        uint64_t v1044 = v1041[80];
        if (v1044)
        {
          if (v1041[81])
          {
            if (*(void *)(v1041[40] + 16) == *(void *)(v1041[40] + 8))
            {
              v1052 = *(void **)(v1044 + 64);
            }
            else
            {
              gm::operator*<double,4,4,4>((double *)v1969, (double *)v1041 + 1, (double *)v1041 + 88);
              gm::operator*<double,4,4,4>((double *)buf, v1814, (double *)v1969);
              float32x2_t v1045 = vcvt_f32_f64(*(float64x2_t *)&buf[16]);
              float32x2_t v1046 = vcvt_f32_f64(*(float64x2_t *)v1982);
              float32x2_t v1047 = vcvt_f32_f64(*(float64x2_t *)&v1982[16]);
              float32x2_t v1048 = vcvt_f32_f64(*(float64x2_t *)&v1982[32]);
              float32x2_t v1049 = vcvt_f32_f64(*(float64x2_t *)v1983);
              float32x2_t v1050 = vcvt_f32_f64(v1984);
              float32x2_t v1051 = vcvt_f32_f64(v1985);
              v1052 = *(void **)(v1044 + 64);
              uint64_t v1053 = *v1052;
              unint64_t v1054 = *(void *)(*v1052 + 8);
              v1055 = *(float32x2_t **)(*v1052 + 72);
              float32x2_t *v1055 = vcvt_f32_f64(*(float64x2_t *)buf);
              v1055[1] = v1045;
              v1055[2] = v1046;
              v1055[3] = v1047;
              v1055[4] = v1048;
              v1055[5] = v1049;
              v1055[6] = v1050;
              v1055[7] = v1051;
              unint64_t v1056 = *(void *)(v1053 + 64);
              if (v1056 <= v1054) {
                unint64_t v1056 = v1054;
              }
              *(void *)(v1053 + 56) = 0;
              v1055[8].f32[0] = v88;
              if (v1056 > v1054) {
                unint64_t v1054 = v1056;
              }
              *(void *)(v1053 + 64) = v1054;
            }
            v1052[3] = 0;
            uint64_t v1057 = v1041[29];
            v1052[2] = v1057;
            uint64_t v1058 = *(void *)(v1044 + 160);
            uint64_t v1059 = v1041[30];
            if (v1059) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v1059 + 8), 1uLL, memory_order_relaxed);
            }
            v1060 = *(std::__shared_weak_count **)(v1058 + 24);
            *(void *)(v1058 + 16) = v1057;
            *(void *)(v1058 + 24) = v1059;
            if (v1060 && !atomic_fetch_add(&v1060->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v1060->__on_zero_shared)(v1060);
              std::__shared_weak_count::__release_weak(v1060);
            }
            md::RouteLineDrawAnimation::updateStyle((uint64_t)(v1907 + 79), *(unsigned char **)(v1907[40] + 8), *(unsigned char **)(v1907[40] + 16));
            uint64_t v1061 = v1907[81];
            *(void *)(v1061 + 48) = v1042 + 1;
            ggl::CommandBuffer::pushRenderItem(a5, v1061);
          }
        }
      }
    }
    if (v1040 && !atomic_fetch_add(&v1040->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1040->__on_zero_shared)(v1040);
      std::__shared_weak_count::__release_weak(v1040);
    }
  }
LABEL_1729:
  v1062 = *v784;
  if (!__pb)
  {
    if (*((unsigned char *)v1062 + 620))
    {
      v1063 = (void *)[(id)v1062[20] arrows];
      v1062 = *v784;
      if (*v1063 != v1063[1])
      {
        uint64_t v1064 = v1062[65];
        v1065 = [(id)v1062[20] overlay];
        v1066 = [v1065 composedRoute];
        LOBYTE(v1064) = v1064 == [v1066 currentDisplayStep];

        v1067 = a3;
        if ((v1064 & 1) == 0)
        {
          int v1068 = *(_DWORD *)(*a3 + 528);
          v1069 = [[VKTimedAnimation alloc] initWithDuration:0.25];
          v1070 = *(void **)(*a3 + 192);
          *(void *)(*a3 + 192) = v1069;

          v1904[0] = MEMORY[0x1E4F143A8];
          v1904[1] = 3321888768;
          v1904[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_35;
          v1904[3] = &__block_descriptor_60_ea8_40c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0f8l;
          uint64_t v1071 = *a3;
          v1072 = (std::__shared_weak_count *)a3[1];
          v1904[4] = a1;
          v1904[5] = v1071;
          v1905 = v1072;
          if (v1072)
          {
            atomic_fetch_add_explicit(&v1072->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v1071 = *a3;
          }
          int v1906 = v1068;
          [*(id *)(v1071 + 192) setStepHandler:v1904];
          v1902[0] = MEMORY[0x1E4F143A8];
          v1902[1] = 3321888768;
          v1902[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_37;
          v1902[3] = &__block_descriptor_56_ea8_40c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0B8l;
          uint64_t v1073 = *a3;
          v1074 = (std::__shared_weak_count *)a3[1];
          v1902[4] = a1;
          v1902[5] = v1073;
          v1903 = v1074;
          if (v1074)
          {
            atomic_fetch_add_explicit(&v1074->__shared_owners_, 1uLL, memory_order_relaxed);
            uint64_t v1073 = *a3;
          }
          [*(id *)(v1073 + 192) setCompletionHandler:v1902];
          md::AnimationRunner::runAnimation(*(md::MapEngine ***)(a1 + 88), *(VKAnimation **)(*a3 + 192));
          v1075 = [*(id *)(*a3 + 160) overlay];
          v1076 = [v1075 composedRoute];
          *(void *)(*a3 + 520) = [v1076 currentDisplayStep];

          v1077 = v1903;
          if (v1903 && !atomic_fetch_add(&v1903->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1077->__on_zero_shared)(v1077);
            std::__shared_weak_count::__release_weak(v1077);
          }
          v1078 = v1905;
          v1067 = a3;
          if (v1905 && !atomic_fetch_add(&v1905->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1078->__on_zero_shared)(v1078);
            std::__shared_weak_count::__release_weak(v1078);
          }
        }
        v1079 = v1821;
        if (*(void *)(*v1067 + 288) == *(void *)(*v1067 + 296))
        {
          v1080 = (uint64_t *)[*(id *)(*v1067 + 160) arrows];
          v1852 = (void *)*v1067;
          v1081 = *(void **)(*v1067 + 160);
          if (v1081)
          {
            [v1081 sections];
          }
          else
          {
            v1992[1] = 0;
            v1992[0] = 0;
            *(void *)&long long v1993 = 0;
          }
          uint64_t v1107 = *v1080;
          uint64_t v1882 = v1080[1];
          if (*v1080 != v1882)
          {
            v1847 = (char **)(v1852 + 36);
            long long v1108 = 0uLL;
            while (1)
            {
              *(void *)v1969 = 0;
              *(void *)&v1969[8] = v1969;
              *(void *)&v1969[16] = 0x5812000000;
              *(void *)&v1969[24] = __Block_byref_object_copy__45;
              *(void *)&v1969[32] = __Block_byref_object_dispose__46;
              *(_OWORD *)&v1969[40] = v1108;
              *(_OWORD *)&v1969[56] = v1108;
              *(void *)&v1969[72] = 0;
              *(_DWORD *)&v1969[80] = 1065353216;
              v1962[1] = 0;
              v1962[0] = 0;
              uint64_t v1893 = v1107;
              if (*(_DWORD *)(v1107 + 4) != -1 && *(_DWORD *)(v1107 + 8) != -1)
              {
                v1109 = v1992[0];
                if (v1992[1] != v1992[0]) {
                  break;
                }
              }
LABEL_2081:
              v1292 = (std::__shared_weak_count *)v1962[1];
              LOBYTE(v915) = -1;
              if (v1962[1] && !atomic_fetch_add((atomic_ullong *volatile)v1962[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v1292->__on_zero_shared)(v1292);
                std::__shared_weak_count::__release_weak(v1292);
              }
              _Block_object_dispose(v1969, 8);
              v1293 = *(void **)&v1969[64];
              v1079 = v1821;
              if (*(void *)&v1969[64])
              {
                do
                {
                  v1295 = v1293;
                  v1293 = (void *)*v1293;
                  v1296 = (void *)v1295[4];
                  if (v1296)
                  {
                    v1297 = (void *)v1295[5];
                    uint64_t v1298 = v1295[4];
                    if (v1297 != v1296)
                    {
                      do
                      {
                        v1300 = (void (***)(void, uint64_t))*--v1297;
                        v1299 = v1300;
                        void *v1297 = 0;
                        if (v1300)
                        {
                          (**v1299)(v1299, v1298);
                          {
                            operator new();
                          }
                          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v1299, 104);
                        }
                      }
                      while (v1297 != v1296);
                      uint64_t v1298 = v1295[4];
                    }
                    v1295[5] = v1296;
                    (*(void (**)(void, uint64_t, uint64_t))(*(void *)v1295[7] + 40))(v1295[7], v1298, v1295[6] - v1298);
                  }
                  v1301 = (std::__shared_weak_count *)v1295[3];
                  if (v1301 && !atomic_fetch_add(&v1301->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v1301->__on_zero_shared)(v1301);
                    std::__shared_weak_count::__release_weak(v1301);
                  }
                  operator delete(v1295);
                }
                while (v1293);
              }
              v1294 = *(void **)&v1969[48];
              *(void *)&v1969[48] = 0;
              if (v1294) {
                operator delete(v1294);
              }
              uint64_t v1107 = v1893 + 44;
              long long v1108 = 0uLL;
              if (v1893 + 44 == v1882) {
                goto LABEL_2123;
              }
            }
            unint64_t v1110 = ((char *)v1992[1] - (char *)v1992[0]) >> 3;
            unsigned int v1111 = *(_DWORD *)(v1107 + 12);
            if (v1110 <= 1) {
              unint64_t v1110 = 1;
            }
            while (1)
            {
              uint64_t v1112 = *v1109 ? *v1109 + 8 : 0;
              unsigned int v1113 = *(_DWORD *)(v1112 + 88);
              if (v1113 < v1111 || v1113 == v1111 && *(float *)(v1112 + 92) <= *(float *)(v1107 + 16))
              {
                unsigned int v1114 = *(_DWORD *)(v1112 + 96);
                if (v1111 < v1114 || v1111 == v1114 && *(float *)(v1107 + 16) <= *(float *)(v1112 + 100)) {
                  break;
                }
              }
              ++v1109;
              if (!--v1110) {
                goto LABEL_2081;
              }
            }
            v1115 = *(void **)(v1112 + 248);
            v1116 = *(atomic_ullong **)(v1112 + 256);
            if (v1116)
            {
              atomic_fetch_add_explicit(v1116 + 1, 1uLL, memory_order_relaxed);
              v1962[0] = v1115;
              v1962[1] = v1116;
            }
            else
            {
              v1962[0] = *(void **)(v1112 + 248);
            }
            uint64_t v1117 = *(unsigned int *)(v1107 + 28);
            if (*(float *)(v1107 + 32) <= 0.0)
            {
              v1126 = 0;
              v1125 = 0;
            }
            else
            {
              if ((*(uint64_t (**)(uint64_t))(*(void *)v1112 + 56))(v1112) <= (unint64_t)(v1117 + 1))
              {
                v1126 = 0;
                v1125 = 0;
              }
              else
              {
                uint64_t v1118 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v1112 + 72) + 32))(*(void *)(v1112 + 72), v1117);
                float32x2_t v1119 = *(float32x2_t *)v1118;
                float v1120 = *(float *)(v1118 + 8);
                float v1121 = *(float *)(v1893 + 32);
                uint64_t v1122 = (*(uint64_t (**)(void, void))(**(void **)(v1112 + 72) + 32))(*(void *)(v1112 + 72), (v1117 + 1));
                float32x2_t v1123 = *(float32x2_t *)v1122;
                float v1124 = *(float *)(v1122 + 8);
                float v1841 = *(float *)(v1893 + 32);
                v1125 = (float32x2_t *)operator new(0xCuLL);
                v1126 = (float32x2_t *)((char *)v1125 + 12);
                float32x2_t *v1125 = vmla_n_f32(vmul_n_f32(v1119, 1.0 - v1121), v1123, v1841);
                v1125[1].f32[0] = (float)((float)(1.0 - v1121) * v1120) + (float)(v1841 * v1124);
                LODWORD(v1117) = v1117 + 1;
              }
              uint64_t v1107 = v1893;
            }
            int v1127 = *(_DWORD *)(v1107 + 8);
            if (*(_DWORD *)(v1107 + 4) == v1127)
            {
              unsigned int v1128 = *(_DWORD *)(v1107 + 36);
              v1129 = (float *)v1126;
              while (v1117 <= v1128)
              {
                v1130 = (__int32 *)(*(uint64_t (**)(void, void))(**(void **)(v1112 + 72) + 32))(*(void *)(v1112 + 72), v1117);
                __int32 v1132 = *v1130;
                __int32 v1131 = v1130[1];
                __int32 v1133 = v1130[2];
                if (v1129 < (float *)v1126)
                {
                  *(_DWORD *)v1129 = v1132;
                  *((_DWORD *)v1129 + 1) = v1131;
                  *((_DWORD *)v1129 + 2) = v1133;
                  v1129 += 3;
                }
                else
                {
                  unint64_t v1134 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1129 - (char *)v1125) >> 2) + 1;
                  if (v1134 > 0x1555555555555555) {
                    abort();
                  }
                  if (0x5555555555555556 * (((char *)v1126 - (char *)v1125) >> 2) > v1134) {
                    unint64_t v1134 = 0x5555555555555556 * (((char *)v1126 - (char *)v1125) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * (((char *)v1126 - (char *)v1125) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v1135 = 0x1555555555555555;
                  }
                  else {
                    unint64_t v1135 = v1134;
                  }
                  if (v1135)
                  {
                    if (v1135 > 0x1555555555555555) {
                      goto LABEL_2741;
                    }
                    v1136 = (char *)operator new(12 * v1135);
                  }
                  else
                  {
                    v1136 = 0;
                  }
                  v1137 = (float32x2_t *)&v1136[4 * (((char *)v1129 - (char *)v1125) >> 2)];
                  v1137->i32[0] = v1132;
                  v1137->i32[1] = v1131;
                  v1137[1].i32[0] = v1133;
                  for (munint64_t m = v1137; v1129 != (float *)v1125; mm[1].i32[0] = v1140)
                  {
                    float32x2_t v1139 = *(float32x2_t *)(v1129 - 3);
                    v1129 -= 3;
                    __int32 v1140 = *((_DWORD *)v1129 + 2);
                    *(float32x2_t *)((char *)mm - 12) = v1139;
                    munint64_t m = (float32x2_t *)((char *)mm - 12);
                  }
                  v1126 = (float32x2_t *)&v1136[12 * v1135];
                  v1129 = (float *)&v1137[1] + 1;
                  if (v1125) {
                    operator delete(v1125);
                  }
                  v1125 = mm;
                }
                LODWORD(v1117) = v1117 + 1;
                unsigned int v1128 = *(_DWORD *)(v1893 + 36);
              }
              if (*(float *)(v1893 + 40) <= 0.0
                || (*(uint64_t (**)(uint64_t))(*(void *)v1112 + 56))(v1112) <= (unint64_t)(v1128 + 1))
              {
                v1126 = (float32x2_t *)v1129;
              }
              else
              {
                uint64_t v1142 = (*(uint64_t (**)(void, void))(**(void **)(v1112 + 72) + 32))(*(void *)(v1112 + 72), *(unsigned int *)(v1893 + 36));
                float32x2_t v1143 = *(float32x2_t *)v1142;
                float v1144 = *(float *)(v1142 + 8);
                float v1145 = *(float *)(v1893 + 40);
                v1146 = (float32x2_t *)(*(uint64_t (**)(void, void))(**(void **)(v1112 + 72) + 32))(*(void *)(v1112 + 72), (*(_DWORD *)(v1893 + 36) + 1));
                float v1147 = *(float *)(v1893 + 40);
                float32x2_t v1148 = vmla_n_f32(vmul_n_f32(v1143, 1.0 - v1145), *v1146, v1147);
                float v1149 = (float)((float)(1.0 - v1145) * v1144) + (float)(v1147 * v1146[1].f32[0]);
                if (v1129 >= (float *)v1126)
                {
                  unint64_t v1185 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1129 - (char *)v1125) >> 2) + 1;
                  if (v1185 > 0x1555555555555555) {
                    abort();
                  }
                  if (0x5555555555555556 * (((char *)v1126 - (char *)v1125) >> 2) > v1185) {
                    unint64_t v1185 = 0x5555555555555556 * (((char *)v1126 - (char *)v1125) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * (((char *)v1126 - (char *)v1125) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v1185 = 0x1555555555555555;
                  }
                  if (v1185)
                  {
                    if (v1185 > 0x1555555555555555) {
                      goto LABEL_2741;
                    }
                    v1186 = (char *)operator new(12 * v1185);
                  }
                  else
                  {
                    v1186 = 0;
                  }
                  v1189 = (float32x2_t *)&v1186[4 * (((char *)v1129 - (char *)v1125) >> 2)];
                  float32x2_t *v1189 = v1148;
                  v1189[1].f32[0] = v1149;
                  if (v1129 == (float *)v1125)
                  {
                    v1125 = (float32x2_t *)&v1186[4 * (((char *)v1129 - (char *)v1125) >> 2)];
                  }
                  else
                  {
                    v1190 = (float32x2_t *)&v1186[4 * (((char *)v1129 - (char *)v1125) >> 2)];
                    do
                    {
                      float32x2_t v1191 = *(float32x2_t *)(v1129 - 3);
                      v1129 -= 3;
                      __int32 v1192 = *((_DWORD *)v1129 + 2);
                      *(float32x2_t *)((char *)v1190 - 12) = v1191;
                      v1190 = (float32x2_t *)((char *)v1190 - 12);
                      v1190[1].i32[0] = v1192;
                    }
                    while (v1129 != (float *)v1125);
                    v1129 = (float *)v1125;
                    v1125 = v1190;
                  }
                  v1126 = (float32x2_t *)((char *)v1189 + 12);
                  if (v1129) {
                    operator delete(v1129);
                  }
                }
                else
                {
                  *(float32x2_t *)v1129 = v1148;
                  v1129[2] = v1149;
                  v1126 = (float32x2_t *)(v1129 + 3);
                }
              }
            }
            else
            {
              if (v1117 <= *(_DWORD *)(v1112 + 96))
              {
                uint64_t v1150 = v1117;
                v1141 = v1126;
                do
                {
                  v1151 = (__int32 *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v1112 + 72) + 32))(*(void *)(v1112 + 72), v1150);
                  __int32 v1153 = *v1151;
                  __int32 v1152 = v1151[1];
                  __int32 v1154 = v1151[2];
                  if (v1126 < v1141)
                  {
                    v1126->i32[0] = v1153;
                    v1126->i32[1] = v1152;
                    v1126[1].i32[0] = v1154;
                    v1126 = (float32x2_t *)((char *)v1126 + 12);
                  }
                  else
                  {
                    unint64_t v1155 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1126 - (char *)v1125) >> 2) + 1;
                    if (v1155 > 0x1555555555555555) {
                      abort();
                    }
                    if (0x5555555555555556 * (((char *)v1141 - (char *)v1125) >> 2) > v1155) {
                      unint64_t v1155 = 0x5555555555555556 * (((char *)v1141 - (char *)v1125) >> 2);
                    }
                    if (0xAAAAAAAAAAAAAAABLL * (((char *)v1141 - (char *)v1125) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                      unint64_t v1156 = 0x1555555555555555;
                    }
                    else {
                      unint64_t v1156 = v1155;
                    }
                    if (v1156)
                    {
                      if (v1156 > 0x1555555555555555) {
                        goto LABEL_2741;
                      }
                      v1157 = (char *)operator new(12 * v1156);
                    }
                    else
                    {
                      v1157 = 0;
                    }
                    v1158 = &v1157[4 * (((char *)v1126 - (char *)v1125) >> 2)];
                    *(_DWORD *)v1158 = v1153;
                    *((_DWORD *)v1158 + 1) = v1152;
                    *((_DWORD *)v1158 + 2) = v1154;
                    for (nunint64_t n = (float32x2_t *)v1158; v1126 != v1125; nn[1].i32[0] = v1161)
                    {
                      float32x2_t v1160 = *(float32x2_t *)((char *)v1126 - 12);
                      v1126 = (float32x2_t *)((char *)v1126 - 12);
                      __int32 v1161 = v1126[1].i32[0];
                      *(float32x2_t *)((char *)nn - 12) = v1160;
                      nunint64_t n = (float32x2_t *)((char *)nn - 12);
                    }
                    v1141 = (float32x2_t *)&v1157[12 * v1156];
                    v1126 = (float32x2_t *)(v1158 + 12);
                    if (v1125) {
                      operator delete(v1125);
                    }
                    v1125 = nn;
                  }
                  LODWORD(v1117) = v1117 + 1;
                }
                while (v1117 <= *(_DWORD *)(v1112 + 96));
                int v1127 = *(_DWORD *)(v1893 + 8);
              }
              else
              {
                v1141 = v1126;
              }
              unsigned int v1162 = 0;
              uint64_t v1163 = *((void *)v1992[0] + v1127);
              if (v1163) {
                v1164 = (void **)(v1163 + 8);
              }
              else {
                v1164 = 0;
              }
              do
              {
                v1166 = (__int32 *)(*(uint64_t (**)(void *, void))(*v1164[9] + 32))(v1164[9], v1162);
                __int32 v1168 = *v1166;
                __int32 v1167 = v1166[1];
                __int32 v1169 = v1166[2];
                if (v1126 < v1141)
                {
                  v1126->i32[0] = v1168;
                  v1126->i32[1] = v1167;
                  v1126[1].i32[0] = v1169;
                  v1126 = (float32x2_t *)((char *)v1126 + 12);
                }
                else
                {
                  unint64_t v1170 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1126 - (char *)v1125) >> 2) + 1;
                  if (v1170 > 0x1555555555555555) {
                    abort();
                  }
                  if (0x5555555555555556 * (((char *)v1141 - (char *)v1125) >> 2) > v1170) {
                    unint64_t v1170 = 0x5555555555555556 * (((char *)v1141 - (char *)v1125) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * (((char *)v1141 - (char *)v1125) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v1171 = 0x1555555555555555;
                  }
                  else {
                    unint64_t v1171 = v1170;
                  }
                  if (v1171)
                  {
                    if (v1171 > 0x1555555555555555) {
                      goto LABEL_2741;
                    }
                    v1172 = (char *)operator new(12 * v1171);
                  }
                  else
                  {
                    v1172 = 0;
                  }
                  v1173 = &v1172[4 * (((char *)v1126 - (char *)v1125) >> 2)];
                  *(_DWORD *)v1173 = v1168;
                  *((_DWORD *)v1173 + 1) = v1167;
                  *((_DWORD *)v1173 + 2) = v1169;
                  for (i1 = (float32x2_t *)v1173; v1126 != v1125; i1[1].i32[0] = v1176)
                  {
                    float32x2_t v1175 = *(float32x2_t *)((char *)v1126 - 12);
                    v1126 = (float32x2_t *)((char *)v1126 - 12);
                    __int32 v1176 = v1126[1].i32[0];
                    *(float32x2_t *)((char *)i1 - 12) = v1175;
                    i1 = (float32x2_t *)((char *)i1 - 12);
                  }
                  v1141 = (float32x2_t *)&v1172[12 * v1171];
                  v1126 = (float32x2_t *)(v1173 + 12);
                  if (v1125) {
                    operator delete(v1125);
                  }
                  v1125 = i1;
                }
                ++v1162;
                uint64_t v1165 = *(unsigned int *)(v1893 + 36);
              }
              while (v1162 <= v1165);
              if (*(float *)(v1893 + 40) > 0.0
                && ((uint64_t (*)(void **))(*v1164)[7])(v1164) > (unint64_t)(v1165 + 1))
              {
                uint64_t v1177 = (*(uint64_t (**)(void *, void))(*v1164[9] + 32))(v1164[9], *(unsigned int *)(v1893 + 36));
                float32x2_t v1178 = *(float32x2_t *)v1177;
                float v1179 = *(float *)(v1177 + 8);
                float v1180 = *(float *)(v1893 + 40);
                v1181 = (float32x2_t *)(*(uint64_t (**)(void *, void))(*v1164[9] + 32))(v1164[9], (*(_DWORD *)(v1893 + 36) + 1));
                float v1182 = *(float *)(v1893 + 40);
                float32x2_t v1183 = vmla_n_f32(vmul_n_f32(v1178, 1.0 - v1180), *v1181, v1182);
                float v1184 = (float)((float)(1.0 - v1180) * v1179) + (float)(v1182 * v1181[1].f32[0]);
                if (v1126 >= v1141)
                {
                  unint64_t v1187 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1126 - (char *)v1125) >> 2) + 1;
                  if (v1187 > 0x1555555555555555) {
                    abort();
                  }
                  if (0x5555555555555556 * (((char *)v1141 - (char *)v1125) >> 2) > v1187) {
                    unint64_t v1187 = 0x5555555555555556 * (((char *)v1141 - (char *)v1125) >> 2);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * (((char *)v1141 - (char *)v1125) >> 2) >= 0xAAAAAAAAAAAAAAALL) {
                    unint64_t v1187 = 0x1555555555555555;
                  }
                  if (v1187)
                  {
                    if (v1187 > 0x1555555555555555) {
                      goto LABEL_2741;
                    }
                    v1188 = (char *)operator new(12 * v1187);
                  }
                  else
                  {
                    v1188 = 0;
                  }
                  v1193 = (float32x2_t *)&v1188[4 * (((char *)v1126 - (char *)v1125) >> 2)];
                  float32x2_t *v1193 = v1183;
                  v1193[1].f32[0] = v1184;
                  for (i2 = v1193; v1126 != v1125; i2[1].i32[0] = v1196)
                  {
                    float32x2_t v1195 = *(float32x2_t *)((char *)v1126 - 12);
                    v1126 = (float32x2_t *)((char *)v1126 - 12);
                    __int32 v1196 = v1126[1].i32[0];
                    *(float32x2_t *)((char *)i2 - 12) = v1195;
                    i2 = (float32x2_t *)((char *)i2 - 12);
                  }
                  v1126 = (float32x2_t *)((char *)v1193 + 12);
                  if (v1125) {
                    operator delete(v1125);
                  }
                  v1125 = i2;
                }
                else
                {
                  float32x2_t *v1126 = v1183;
                  v1126[1].f32[0] = v1184;
                  v1126 = (float32x2_t *)((char *)v1126 + 12);
                }
              }
            }
            {
              operator new();
            }
            uint64_t v1197 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                         + 16))(mdm::Allocator::instance(void)::alloc, 104, 8);
            uint64_t v1198 = v1197;
            unint64_t v1199 = (char *)v1126 - (char *)v1125;
            *(_OWORD *)(v1197 + 49) = 0u;
            *(_OWORD *)(v1197 + 40) = 0u;
            unint64_t v1200 = 0xAAAAAAAAAAAAAAABLL * (((char *)v1126 - (char *)v1125) >> 2);
            *(_OWORD *)(v1197 + 24) = 0u;
            *(_OWORD *)(v1197 + 8) = 0u;
            *(void *)(v1197 + 56) = v1200;
            *(void *)uint64_t v1197 = &unk_1EF553D90;
            *(void *)(v1197 + 80) = 0;
            *(void *)(v1197 + 88) = 0;
            *(void *)(v1197 + 72) = 0;
            if (v1126 == v1125)
            {
              uint64_t v1202 = 0;
              v1201 = 0;
            }
            else
            {
              *(void *)(v1197 + 88) = v1200;
              {
                operator new();
              }
              v1201 = (void *)(*(uint64_t (**)(uint64_t, int64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                          + 16))(mdm::Allocator::instance(void)::alloc, (char *)v1126 - (char *)v1125, 8);
              *(void *)(v1198 + 72) = v1201;
              *(unsigned char *)(v1198 + 64) = 1;
              uint64_t v1202 = *(void *)(v1198 + 88);
            }
            *(void *)uint64_t v1198 = &unk_1EF53EC90;
            v1998 = (void **)v1198;
            *(unsigned char *)(v1198 + 96) = *(_DWORD *)v1893;
            memcpy(v1201, v1125, 12 * v1202);
            uint64_t v1203 = *(void *)&v1969[8];
            v1204 = v1962[0];
            unint64_t v1205 = 0x9DDFEA08EB382D69
                  * (((8 * LODWORD(v1962[0])) + 8) ^ ((unint64_t)v1962[0] >> 32));
            unint64_t v1206 = 0x9DDFEA08EB382D69 * (((unint64_t)v1962[0] >> 32) ^ (v1205 >> 47) ^ v1205);
            unint64_t v1207 = 0x9DDFEA08EB382D69 * (v1206 ^ (v1206 >> 47));
            unint64_t v1208 = *(void *)(*(void *)&v1969[8] + 56);
            if (v1208)
            {
              uint8x8_t v1209 = (uint8x8_t)vcnt_s8((int8x8_t)v1208);
              v1209.i16[0] = vaddlv_u8(v1209);
              if (v1209.u32[0] > 1uLL)
              {
                unint64_t v1199 = 0x9DDFEA08EB382D69 * (v1206 ^ (v1206 >> 47));
                if (v1207 >= v1208) {
                  unint64_t v1199 = v1207 % v1208;
                }
              }
              else
              {
                unint64_t v1199 = (v1208 - 1) & v1207;
              }
              v1210 = *(void **)(*(void *)(*(void *)&v1969[8] + 48) + 8 * v1199);
              if (v1210)
              {
                v1211 = (void *)*v1210;
                if (*v1210)
                {
                  if (v1209.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v1213 = v1211[1];
                      if (v1213 == v1207)
                      {
                        if ((void *)v1211[2] == v1962[0]) {
                          goto LABEL_2009;
                        }
                      }
                      else if ((v1213 & (v1208 - 1)) != v1199)
                      {
                        goto LABEL_1946;
                      }
                      v1211 = (void *)*v1211;
                      if (!v1211) {
                        goto LABEL_1946;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v1212 = v1211[1];
                    if (v1212 == v1207)
                    {
                      if ((void *)v1211[2] == v1962[0]) {
                        goto LABEL_2009;
                      }
                    }
                    else
                    {
                      if (v1212 >= v1208) {
                        v1212 %= v1208;
                      }
                      if (v1212 != v1199) {
                        break;
                      }
                    }
                    v1211 = (void *)*v1211;
                  }
                  while (v1211);
                }
              }
            }
LABEL_1946:
            v1214 = operator new(0x40uLL);
            v1211 = v1214;
            v1986.i64[0] = (uint64_t)v1214;
            v1842 = (void *)(v1203 + 64);
            v1986.i64[1] = v1203 + 64;
            void *v1214 = 0;
            v1214[1] = v1207;
            v1215 = (atomic_ullong *)v1962[1];
            v1214[2] = v1204;
            v1214[3] = v1215;
            if (v1215) {
              atomic_fetch_add_explicit(v1215 + 1, 1uLL, memory_order_relaxed);
            }
            v1214[4] = 0;
            v1214[5] = 0;
            v1214[6] = 0;
            {
              operator new();
            }
            v1211[7] = mdm::Allocator::instance(void)::alloc;
            v1987[0] = 1;
            float v1216 = (float)(unint64_t)(*(void *)(v1203 + 72) + 1);
            float v1217 = *(float *)(v1203 + 80);
            if (v1208 && (float)(v1217 * (float)v1208) >= v1216)
            {
LABEL_1999:
              uint64_t v1240 = *(void *)(v1203 + 48);
              v1241 = *(void **)(v1240 + 8 * v1199);
              if (v1241)
              {
                void *v1211 = *v1241;
              }
              else
              {
                void *v1211 = *v1842;
                void *v1842 = v1211;
                *(void *)(v1240 + 8 * v1199) = v1842;
                if (!*v1211)
                {
LABEL_2008:
                  ++*(void *)(v1203 + 72);
LABEL_2009:
                  v1243 = (uint64_t *)v1211[5];
                  unint64_t v1244 = v1211[6];
                  if ((unint64_t)v1243 < v1244)
                  {
                    if (v1243)
                    {
                      uint64_t v1245 = (uint64_t)v1998;
                      v1998 = 0;
                      uint64_t *v1243 = v1245;
                    }
                    v1246 = v1243 + 1;
LABEL_2040:
                    v1211[5] = v1246;
                    v1267 = (char *)v1852[37];
                    unint64_t v1266 = v1852[38];
                    if ((unint64_t)v1267 >= v1266)
                    {
                      v1270 = *v1847;
                      uint64_t v1271 = v1267 - *v1847;
                      unint64_t v1272 = (v1271 >> 3) + 1;
                      if (v1272 >> 61) {
LABEL_2754:
                      }
                        abort();
                      uint64_t v1273 = v1266 - (void)v1270;
                      if (v1273 >> 2 > v1272) {
                        unint64_t v1272 = v1273 >> 2;
                      }
                      if ((unint64_t)v1273 >= 0x7FFFFFFFFFFFFFF8) {
                        unint64_t v1274 = 0x1FFFFFFFFFFFFFFFLL;
                      }
                      else {
                        unint64_t v1274 = v1272;
                      }
                      if (v1274)
                      {
                        if (v1274 >> 61) {
                          goto LABEL_2741;
                        }
                        v1275 = (char *)operator new(8 * v1274);
                      }
                      else
                      {
                        v1275 = 0;
                      }
                      v1276 = &v1275[8 * (v1271 >> 3)];
                      v1277 = &v1275[8 * v1274];
                      *(void *)v1276 = 0;
                      v1268 = v1276 + 8;
                      if (v1267 == v1270)
                      {
                        v1852[36] = v1276;
                        v1852[37] = v1268;
                        v1852[38] = v1277;
                        uint64_t v1269 = v1893;
                      }
                      else
                      {
                        unint64_t v1278 = v1267 - v1270 - 8;
                        if (v1278 <= 0x77
                          || &v1267[-(v1278 & 0xFFFFFFFFFFFFFFF8) - 8] < v1276
                          && &v1275[v1271 - (v1278 & 0xFFFFFFFFFFFFFFF8) - 8] < v1267)
                        {
                          goto LABEL_2777;
                        }
                        uint64_t v1279 = (v1278 >> 3) + 1;
                        v1280 = &v1275[v1271 - 16];
                        v1281 = v1267 - 32;
                        uint64_t v1282 = v1279 & 0x3FFFFFFFFFFFFFFCLL;
                        do
                        {
                          long long v1284 = *(_OWORD *)v1281;
                          long long v1283 = *((_OWORD *)v1281 + 1);
                          *(_OWORD *)v1281 = 0uLL;
                          *((_OWORD *)v1281 + 1) = 0uLL;
                          v1281 -= 32;
                          *((_OWORD *)v1280 - 1) = v1284;
                          *(_OWORD *)v1280 = v1283;
                          v1280 -= 32;
                          v1282 -= 4;
                        }
                        while (v1282);
                        v1276 -= 8 * (v1279 & 0x3FFFFFFFFFFFFFFCLL);
                        v1267 -= 8 * (v1279 & 0x3FFFFFFFFFFFFFFCLL);
                        if (v1279 != (v1279 & 0x3FFFFFFFFFFFFFFCLL))
                        {
LABEL_2777:
                          do
                          {
                            uint64_t v1285 = *((void *)v1267 - 1);
                            v1267 -= 8;
                            *(void *)v1267 = 0;
                            *((void *)v1276 - 1) = v1285;
                            v1276 -= 8;
                          }
                          while (v1267 != v1270);
                        }
                        v1267 = (char *)v1852[36];
                        v1286 = (char *)v1852[37];
                        v1852[36] = v1276;
                        v1852[37] = v1268;
                        v1852[38] = v1277;
                        if (v1286 == v1267)
                        {
                          uint64_t v1269 = v1893;
                        }
                        else
                        {
                          uint64_t v1269 = v1893;
                          do
                          {
                            uint64_t v1288 = *((void *)v1286 - 1);
                            v1286 -= 8;
                            uint64_t v1287 = v1288;
                            *(void *)v1286 = 0;
                            if (v1288) {
                              (*(void (**)(uint64_t))(*(void *)v1287 + 8))(v1287);
                            }
                          }
                          while (v1286 != v1267);
                        }
                      }
                      if (v1267) {
                        operator delete(v1267);
                      }
                    }
                    else
                    {
                      *(void *)v1267 = 0;
                      v1268 = v1267 + 8;
                      uint64_t v1269 = v1893;
                    }
                    v1852[37] = v1268;
                    uint64_t v1289 = *((void *)v1821 + 92);
                    *(void *)long long buf = MEMORY[0x1E4F143A8];
                    *(void *)&uint8_t buf[8] = 3221225472;
                    *(void *)&buf[16] = ___ZN2md16RouteRenderLayer15addArrowRibbonsERKNS_13LayoutContextERKNSt3__110shared_ptrINS_16RouteLineOverlayEEE_block_invoke;
                    *(void *)&buf[24] = &unk_1E5A8EB68;
                    *(void *)&v1982[8] = v1852 + 36;
                    *(void *)v1982 = v1969;
                    *(void *)&v1982[16] = a3;
                    *(void *)&v1982[24] = v1269;
                    *(void *)&v1987[8] = 0;
                    v1986.i64[0] = (uint64_t)&unk_1EF56BC58;
                    v1986.i64[1] = MEMORY[0x1A6239EB0](buf);
                    *(void *)&v1987[8] = &v1986;
                    long long v2001 = 0uLL;
                    (*(void (**)(void, float32x4_t *, long long *))(**(void **)(v1289 + 32) + 16))(*(void *)(v1289 + 32), &v1986, &v2001);
                    v1290 = (std::__shared_weak_count *)*((void *)&v2001 + 1);
                    if (*((void *)&v2001 + 1)
                      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v2001 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v1290->__on_zero_shared)(v1290);
                      std::__shared_weak_count::__release_weak(v1290);
                    }
                    if (*(float32x4_t **)&v1987[8] == &v1986)
                    {
                      (*(void (**)(float32x4_t *))(v1986.i64[0] + 32))(&v1986);
                    }
                    else if (*(void *)&v1987[8])
                    {
                      (*(void (**)(void))(**(void **)&v1987[8] + 40))();
                    }
                    v1291 = (void (***)(void))v1998;
                    v1998 = 0;
                    if (v1291)
                    {
                      (**v1291)(v1291);
                      {
                        operator new();
                      }
                      (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                              + 40))(mdm::Allocator::instance(void)::alloc, v1291, 104);
                    }
                    if (v1125) {
                      operator delete(v1125);
                    }
                    goto LABEL_2081;
                  }
                  uint64_t v1247 = v1211[4];
                  uint64_t v1248 = ((uint64_t)v1243 - v1247) >> 3;
                  unint64_t v1249 = v1248 + 1;
                  if ((unint64_t)(v1248 + 1) >> 61) {
                    goto LABEL_2754;
                  }
                  uint64_t v1250 = v1244 - v1247;
                  if (v1250 >> 2 > v1249) {
                    unint64_t v1249 = v1250 >> 2;
                  }
                  if ((unint64_t)v1250 >= 0x7FFFFFFFFFFFFFF8) {
                    uint64_t v1251 = 0x1FFFFFFFFFFFFFFFLL;
                  }
                  else {
                    uint64_t v1251 = v1249;
                  }
                  if (v1251)
                  {
                    uint64_t v1252 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v1211[7] + 16))(v1211[7], 8 * v1251, 8);
                    v1253 = (uint64_t *)(v1252 + 8 * v1248);
                    uint64_t v1254 = v1252 + 8 * v1251;
                    if (v1252)
                    {
                      uint64_t v1255 = (uint64_t)v1998;
                      v1998 = 0;
                      uint64_t *v1253 = v1255;
                    }
                  }
                  else
                  {
                    uint64_t v1254 = 0;
                    v1253 = (uint64_t *)(8 * v1248);
                  }
                  v1246 = v1253 + 1;
                  v1256 = (char *)v1211[4];
                  v1257 = (char *)v1211[5];
                  if (v1257 == v1256)
                  {
                    v1211[4] = v1253;
                    v1211[5] = v1246;
                    uint64_t v1263 = v1211[6];
                    v1211[6] = v1254;
                    goto LABEL_2038;
                  }
                  unint64_t v1258 = v1257 - v1256 - 8;
                  if (v1258 > 0x57
                    && ((unint64_t v1259 = (v1256 - v1257 + 7) & 0xFFFFFFFFFFFFFFF8, &v1257[v1259] >= (char *)v1253)
                     || (char *)v1253 + v1259 >= v1257))
                  {
                    uint64_t v1302 = (v1258 >> 3) + 1;
                    v1260 = &v1257[-8 * (v1302 & 0x3FFFFFFFFFFFFFFCLL)];
                    v1303 = v1253 - 2;
                    v1304 = v1257 - 32;
                    uint64_t v1305 = v1302 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v1307 = *(_OWORD *)v1304;
                      long long v1306 = *((_OWORD *)v1304 + 1);
                      *(_OWORD *)v1304 = 0uLL;
                      *((_OWORD *)v1304 + 1) = 0uLL;
                      v1304 -= 32;
                      *((_OWORD *)v1303 - 1) = v1307;
                      *(_OWORD *)v1303 = v1306;
                      v1303 -= 4;
                      v1305 -= 4;
                    }
                    while (v1305);
                    v1253 -= v1302 & 0x3FFFFFFFFFFFFFFCLL;
                    if (v1302 == (v1302 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_2030:
                      v1257 = (char *)v1211[4];
                      v1262 = (char *)v1211[5];
                      v1211[4] = v1253;
                      v1211[5] = v1246;
                      uint64_t v1263 = v1211[6];
                      v1211[6] = v1254;
                      while (v1262 != v1257)
                      {
                        v1265 = (void (***)(void))*((void *)v1262 - 1);
                        v1262 -= 8;
                        v1264 = v1265;
                        *(void *)v1262 = 0;
                        if (v1265)
                        {
                          (**v1264)(v1264);
                          {
                            operator new();
                          }
                          (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                                  + 40))(mdm::Allocator::instance(void)::alloc, v1264, 104);
                        }
                      }
LABEL_2038:
                      if (v1257) {
                        (*(void (**)(void, char *, uint64_t))(*(void *)v1211[7] + 40))(v1211[7], v1257, v1263 - (void)v1257);
                      }
                      goto LABEL_2040;
                    }
                  }
                  else
                  {
                    v1260 = (char *)v1211[5];
                  }
                  do
                  {
                    uint64_t v1261 = *((void *)v1260 - 1);
                    v1260 -= 8;
                    *(void *)v1260 = 0;
                    *--v1253 = v1261;
                  }
                  while (v1260 != v1256);
                  goto LABEL_2030;
                }
                unint64_t v1242 = *(void *)(*v1211 + 8);
                if ((v1208 & (v1208 - 1)) != 0)
                {
                  if (v1242 >= v1208) {
                    v1242 %= v1208;
                  }
                }
                else
                {
                  v1242 &= v1208 - 1;
                }
                v1241 = (void *)(*(void *)(v1203 + 48) + 8 * v1242);
              }
              void *v1241 = v1211;
              goto LABEL_2008;
            }
            BOOL v1218 = (v1208 & (v1208 - 1)) != 0;
            if (v1208 < 3) {
              BOOL v1218 = 1;
            }
            unint64_t v1219 = v1218 | (2 * v1208);
            unint64_t v1220 = vcvtps_u32_f32(v1216 / v1217);
            if (v1219 <= v1220) {
              size_t v1221 = v1220;
            }
            else {
              size_t v1221 = v1219;
            }
            if (v1221 == 1)
            {
              size_t v1221 = 2;
            }
            else if ((v1221 & (v1221 - 1)) != 0)
            {
              size_t v1221 = std::__next_prime(v1221);
            }
            unint64_t v1208 = *(void *)(v1203 + 56);
            if (v1221 <= v1208)
            {
              if (v1221 >= v1208) {
                goto LABEL_1986;
              }
              unint64_t v1233 = vcvtps_u32_f32((float)*(unint64_t *)(v1203 + 72) / *(float *)(v1203 + 80));
              if (v1208 < 3
                || (uint8x8_t v1234 = (uint8x8_t)vcnt_s8((int8x8_t)v1208), v1234.i16[0] = vaddlv_u8(v1234), v1234.u32[0] > 1uLL))
              {
                unint64_t v1233 = std::__next_prime(v1233);
              }
              else
              {
                uint64_t v1235 = 1 << -(char)__clz(v1233 - 1);
                if (v1233 >= 2) {
                  unint64_t v1233 = v1235;
                }
              }
              if (v1221 <= v1233) {
                size_t v1221 = v1233;
              }
              if (v1221 >= v1208)
              {
                unint64_t v1208 = *(void *)(v1203 + 56);
LABEL_1986:
                if ((v1208 & (v1208 - 1)) != 0)
                {
                  if (v1207 >= v1208) {
                    unint64_t v1199 = v1207 % v1208;
                  }
                  else {
                    unint64_t v1199 = v1207;
                  }
                }
                else
                {
                  unint64_t v1199 = (v1208 - 1) & v1207;
                }
                goto LABEL_1999;
              }
              if (!v1221)
              {
                v1308 = *(void **)(v1203 + 48);
                *(void *)(v1203 + 48) = 0;
                if (v1308) {
                  operator delete(v1308);
                }
                unint64_t v1208 = 0;
                *(void *)(v1203 + 56) = 0;
                goto LABEL_1986;
              }
            }
            if (v1221 >> 61) {
              goto LABEL_2741;
            }
            v1222 = operator new(8 * v1221);
            v1223 = *(void **)(v1203 + 48);
            *(void *)(v1203 + 48) = v1222;
            if (v1223) {
              operator delete(v1223);
            }
            uint64_t v1224 = 0;
            *(void *)(v1203 + 56) = v1221;
            do
              *(void *)(*(void *)(v1203 + 48) + 8 * v1224++) = 0;
            while (v1221 != v1224);
            v1225 = (void *)*v1842;
            if (!*v1842)
            {
LABEL_1985:
              unint64_t v1208 = v1221;
              goto LABEL_1986;
            }
            size_t v1226 = v1225[1];
            size_t v1227 = v1221 - 1;
            if ((v1221 & (v1221 - 1)) == 0)
            {
              size_t v1228 = v1226 & v1227;
              *(void *)(*(void *)(v1203 + 48) + 8 * v1228) = v1842;
              for (i3 = (void *)*v1225; *v1225; i3 = (void *)*v1225)
              {
                size_t v1230 = i3[1] & v1227;
                if (v1230 == v1228)
                {
                  v1225 = i3;
                }
                else
                {
                  uint64_t v1231 = *(void *)(v1203 + 48);
                  if (*(void *)(v1231 + 8 * v1230))
                  {
                    void *v1225 = *i3;
                    uint64_t v1232 = 8 * v1230;
                    void *i3 = **(void **)(*(void *)(v1203 + 48) + v1232);
                    **(void **)(*(void *)(v1203 + 48) + v1232) = i3;
                  }
                  else
                  {
                    *(void *)(v1231 + 8 * v1230) = v1225;
                    v1225 = i3;
                    size_t v1228 = v1230;
                  }
                }
              }
              goto LABEL_1985;
            }
            if (v1226 >= v1221) {
              v1226 %= v1221;
            }
            *(void *)(*(void *)(v1203 + 48) + 8 * v1226) = v1842;
            v1236 = (void *)*v1225;
            if (!*v1225) {
              goto LABEL_1985;
            }
            while (1)
            {
              size_t v1238 = v1236[1];
              if (v1238 >= v1221) {
                v1238 %= v1221;
              }
              if (v1238 != v1226)
              {
                uint64_t v1239 = *(void *)(v1203 + 48);
                if (!*(void *)(v1239 + 8 * v1238))
                {
                  *(void *)(v1239 + 8 * v1238) = v1225;
                  goto LABEL_1990;
                }
                void *v1225 = *v1236;
                uint64_t v1237 = 8 * v1238;
                void *v1236 = **(void **)(*(void *)(v1203 + 48) + v1237);
                **(void **)(*(void *)(v1203 + 48) + v1237) = v1236;
                v1236 = v1225;
              }
              size_t v1238 = v1226;
LABEL_1990:
              v1225 = v1236;
              v1236 = (void *)*v1236;
              size_t v1226 = v1238;
              if (!v1236) {
                goto LABEL_1985;
              }
            }
          }
LABEL_2123:
          v1309 = (char *)v1992[0];
          if (v1992[0])
          {
            v1310 = v1992[1];
            v1311 = v1992[0];
            if (v1992[1] != v1992[0])
            {
              v1312 = (char *)v1992[1];
              do
              {
                v1314 = (void *)*((void *)v1312 - 1);
                v1312 -= 8;
                v1313 = v1314;
                if (v1314)
                {
                  _ZF = (*v1313)-- == 1;
                  if (_ZF)
                  {
                    md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v1313 + 1));
                    {
                      operator new();
                    }
                    (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                     + 40))(mdm::Allocator::instance(void)::alloc, *(v1310 - 1), 400);
                    *(v1310 - 1) = 0;
                  }
                }
                v1310 = v1312;
              }
              while (v1312 != v1309);
              v1311 = v1992[0];
            }
            v1992[1] = v1309;
            operator delete(v1311);
          }
          v1067 = a3;
        }
        if (!*(void *)(*(void *)(a1 + 56) + 32))
        {
          id v1883 = *v1818;
          [*(id *)(*(void *)(a1 + 40) + 104) format];
          id v1315 = v1883;
          if (v1315)
          {
            [v1315 textureManager];
            v1316 = *(void **)buf;
          }
          else
          {
            v1316 = 0;
            *(void *)&uint8_t buf[8] = 0;
            *(void *)long long buf = 0;
          }
          v1969[23] = 14;
          strcpy(v1969, "routeLineArrow");
          v1317 = (std::__shared_weak_count *)operator new(0x58uLL);
          v1317->__shared_owners_ = 0;
          v1317->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF583858;
          v1317[1].__shared_weak_owners_ = 0;
          v1317[2].__vftable = 0;
          v1317[1].__shared_owners_ = 0;
          LODWORD(v1317[2].__shared_owners_) = 0;
          v1317->__shared_weak_owners_ = 0;
          v1317[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55AE58;
          *(_OWORD *)((char *)&v1317[2].__shared_owners_ + 4) = xmmword_1A28FD5C0;
          *(std::__shared_weak_count_vtbl **)((char *)&v1317[3].__vftable + 4) = (std::__shared_weak_count_vtbl *)0x100000001;
          HIDWORD(v1317[3].__shared_owners_) = 0;
          v1992[0] = &v1317[1];
          v1992[1] = v1317;
          md::TextureManager::texture(&v1986, v1316, (uint64_t)v1969, (uint64_t *)v1992, 0, 1.0);
          if (atomic_fetch_add(&v1317->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            if ((v1969[23] & 0x80000000) == 0) {
              goto LABEL_2143;
            }
          }
          else
          {
            ((void (*)(std::__shared_weak_count *))v1317->__on_zero_shared)(v1317);
            std::__shared_weak_count::__release_weak(v1317);
            if ((v1969[23] & 0x80000000) == 0)
            {
LABEL_2143:
              v1318 = *(std::__shared_weak_count **)&buf[8];
              if (!*(void *)&buf[8]) {
                goto LABEL_2149;
              }
              goto LABEL_2147;
            }
          }
          operator delete(*(void **)v1969);
          v1318 = *(std::__shared_weak_count **)&buf[8];
          if (!*(void *)&buf[8]) {
            goto LABEL_2149;
          }
LABEL_2147:
          if (!atomic_fetch_add(&v1318->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1318->__on_zero_shared)(v1318);
            std::__shared_weak_count::__release_weak(v1318);
          }
LABEL_2149:
          operator new();
        }
        uint64_t v1395 = *v1067;
        md::RibbonLayoutContext::RibbonLayoutContext((md::RibbonLayoutContext *)v1969, v1079);
        *(void *)&v1969[112] = v1395 + 464;
        *(_WORD *)&v1969[120] = v1828;
        *(void *)&v1969[124] = _D14;
        *(void *)&v1969[136] = 0;
        LOWORD(v1970) = 0;
        v1972[4] = 0;
        uint64_t v1973 = 0;
        memset(v1972, 0, 13);
        *(void *)&v1971[4] = 0;
        LOBYTE(v1974) = 1;
        *(void *)((char *)&v1974 + 1) = 0;
        *((void *)&v1974 + 1) = 0;
        uint64_t v1975 = *(void *)(md::LayoutContext::frameState(v1079) + 624);
        uint64_t v1976 = 1065353216;
        uint64_t v1396 = *v1067;
        int v1397 = *(_DWORD *)(*v1067 + 528);
        LODWORD(v1976) = *(_DWORD *)(*v1067 + 204);
        HIDWORD(v1976) = v1397;
        float v1398 = *(double *)(v1396 + 168);
        *(float *)&v1969[128] = v1398;
        *(void *)&v1969[136] = -1;
        LOBYTE(v1970) = **((unsigned char **)v1079 + 92);
        uint64_t v1399 = *(void *)(v1396 + 504);
        if (v1399) {
          uint64_t v1400 = v1399 + 8;
        }
        else {
          uint64_t v1400 = 0;
        }
        uint64_t v1977 = v1400;
        v1402 = *(uint64_t **)(v1396 + 288);
        v1401 = *(uint64_t **)(v1396 + 296);
        if (v1402 == v1401) {
          goto LABEL_2199;
        }
        uint64_t v1403 = 0;
        uint64_t v1404 = 0xFFFFFFFFLL;
        v1884 = *(uint64_t **)(v1396 + 296);
LABEL_2170:
        uint64_t v1405 = *v1402;
        uint64_t v1406 = *(void *)(*(void *)(a1 + 56) + 32);
        if (!(*(void *)(*v1402 + 160) | v1406)) {
          goto LABEL_2195;
        }
        unsigned int v1894 = v1404;
        *(void *)(v1405 + 160) = v1406;
        v915 = *(md::LayoutContext **)(v1405 + 8);
        v1407 = *(md::LayoutContext **)(v1405 + 16);
        while (1)
        {
          if (v915 == v1407)
          {
            uint64_t v1405 = *v1402;
            v1067 = a3;
            v1401 = v1884;
            uint64_t v1404 = v1894;
LABEL_2195:
            uint64_t v1416 = v1403;
            if (*(unsigned __int8 *)(v1405 + 152) != llroundf(*(float *)(*v1067 + 528)))
            {
              md::RouteLineArrowLayer::layout((md::RouteLineArrowLayer *)v1405, (const md::RouteLineArrowContext *)v1969);
              md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(*(uint64_t **)(*v1402 + 8), *(uint64_t **)(*v1402 + 16), v1878, v1417);
              uint64_t v1416 = v1404;
            }
            uint64_t v1403 = (v1403 + 1);
            ++v1402;
            uint64_t v1404 = v1416;
            if (v1402 != v1401) {
              goto LABEL_2170;
            }
            if ((v1416 & 0x80000000) == 0)
            {
              md::RouteLineArrowLayer::layout(*(md::RouteLineArrowLayer **)(*(void *)(*v1067 + 288) + 8 * v1416), (const md::RouteLineArrowContext *)v1969);
              uint64_t v1418 = *(void *)(*(void *)(*v1067 + 288) + 8 * v1416);
              md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(*(uint64_t **)(v1418 + 8), *(uint64_t **)(v1418 + 16), v1878, v1419);
            }
LABEL_2199:

            v1420 = *(std::__shared_weak_count **)&v1972[1];
            if (*(void *)&v1972[1]
              && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v1972[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v1420->__on_zero_shared)(v1420);
              std::__shared_weak_count::__release_weak(v1420);
            }
LABEL_1755:
            v1089 = a3;
            goto LABEL_2256;
          }
          uint64_t v1408 = *(void *)v915;
          v1409 = *(uint64_t **)(*(void *)(*(void *)v915 + 8) + 160);
          v1410 = *(void **)(*(void *)v915 + 296);
          uint64_t v1412 = *v1409;
          v1411 = (std::__shared_weak_count *)v1409[1];
          if (v1411) {
            atomic_fetch_add_explicit(&v1411->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v1412 && **(void **)(v1412 + 40) == v1410[1])
          {
            uint64_t v1414 = v1410[2];
            if (v1414) {
              BOOL v1415 = v1414 == v1412;
            }
            else {
              BOOL v1415 = 1;
            }
            if (!v1415) {
              ggl::PipelineSetup::resetData((uint64_t)v1410);
            }
            if (v1411) {
              atomic_fetch_add_explicit(&v1411->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            v1413 = (std::__shared_weak_count *)v1410[3];
            v1410[2] = v1412;
            v1410[3] = v1411;
            if (!v1413) {
              goto LABEL_2189;
            }
          }
          else
          {
            v1413 = (std::__shared_weak_count *)v1410[3];
            v1410[2] = 0;
            v1410[3] = 0;
            if (!v1413) {
              goto LABEL_2189;
            }
          }
          if (!atomic_fetch_add(&v1413->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1413->__on_zero_shared)(v1413);
            std::__shared_weak_count::__release_weak(v1413);
            if (!v1411) {
              goto LABEL_2172;
            }
            goto LABEL_2190;
          }
LABEL_2189:
          if (!v1411) {
            goto LABEL_2172;
          }
LABEL_2190:
          if (!atomic_fetch_add(&v1411->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1411->__on_zero_shared)(v1411);
            std::__shared_weak_count::__release_weak(v1411);
          }
LABEL_2172:
          **(void **)(*(void *)(v1408 + 296) + 96) = v1409[4];
          v915 = (md::LayoutContext *)((char *)v915 + 8);
        }
      }
    }
  }
  int v1082 = *((unsigned __int8 *)v1062 + 624);
  v1083 = +[VKDebugSettings sharedSettings];
  int v1084 = [v1083 showManeuverPoints] ^ 1;
  if (v1082) {
    LOBYTE(v1084) = 1;
  }
  if (v1084)
  {

    goto LABEL_1755;
  }
  v1085 = [(id)(*v784)[20] overlay];
  v1086 = [v1085 composedRoute];
  BOOL v1087 = [v1086 stepsCount] == 0;

  v1088 = v1821;
  v1089 = a3;
  if (!v1087)
  {
    uint64_t v1090 = *a3;
    if (!*(void *)(*a3 + 344))
    {
      uint64_t v1098 = *((void *)v1821 + 92);
      v1900[0] = MEMORY[0x1E4F143A8];
      v1900[1] = 3321888768;
      v1900[2] = ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_41;
      v1900[3] = &__block_descriptor_56_ea8_40c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e30_v16__0__ResourceAccessor_____8l;
      v1900[4] = a1;
      v1900[5] = v1090;
      v1099 = (std::__shared_weak_count *)a3[1];
      v1901 = v1099;
      if (v1099) {
        atomic_fetch_add_explicit(&v1099->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      *(void *)&v1969[24] = 0;
      *(void *)v1969 = &unk_1EF56BC58;
      *(void *)&v1969[8] = MEMORY[0x1A6239EB0](v1900);
      *(void *)&v1969[24] = v1969;
      *(void *)&uint8_t buf[8] = 0;
      *(void *)long long buf = 0;
      (*(void (**)(void, unsigned char *, unsigned char *))(**(void **)(v1098 + 32) + 16))(*(void *)(v1098 + 32), v1969, buf);
      v1100 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8]
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v1100->__on_zero_shared)(v1100);
        std::__shared_weak_count::__release_weak(v1100);
      }
      v1088 = v1821;
      v1089 = a3;
      if (*(unsigned char **)&v1969[24] == v1969)
      {
        (*(void (**)(unsigned char *))(*(void *)v1969 + 32))(v1969);
      }
      else if (*(void *)&v1969[24])
      {
        (*(void (**)(void))(**(void **)&v1969[24] + 40))();
      }
      v1105 = v1901;
      if (v1901 && !atomic_fetch_add(&v1901->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v1105->__on_zero_shared)(v1105);
        std::__shared_weak_count::__release_weak(v1105);
      }
    }
    uint64_t v1091 = *v1835;
    __int16 v1092 = *(unsigned __int8 *)(*v1089 + 620);
    uint64_t v1093 = *(void *)(*v1089 + 344);
    v1094 = (void *)*((void *)v1088 + 1);
    int8x8_t v1095 = (int8x8_t)v1094[1];
    if (!*(void *)&v1095) {
      goto LABEL_2204;
    }
    uint8x8_t v1096 = (uint8x8_t)vcnt_s8(v1095);
    v1096.i16[0] = vaddlv_u8(v1096);
    if (v1096.u32[0] > 1uLL)
    {
      uint64_t v1097 = 0x1AF456233693CD46;
      if (*(void *)&v1095 <= 0x1AF456233693CD46uLL) {
        uint64_t v1097 = 0x1AF456233693CD46uLL % *(void *)&v1095;
      }
    }
    else
    {
      uint64_t v1097 = (*(void *)&v1095 - 1) & 0x1AF456233693CD46;
    }
    v1101 = *(void **)(*v1094 + 8 * v1097);
    if (!v1101) {
      goto LABEL_2204;
    }
    v1102 = (void *)*v1101;
    if (!v1102) {
      goto LABEL_2204;
    }
    if (v1096.u32[0] < 2uLL)
    {
      uint64_t v1103 = *(void *)&v1095 - 1;
      while (1)
      {
        uint64_t v1104 = v1102[1];
        if (v1104 == 0x1AF456233693CD46)
        {
          if (v1102[2] == 0x1AF456233693CD46) {
            goto LABEL_2202;
          }
        }
        else if ((v1104 & v1103) != v1097)
        {
          goto LABEL_2204;
        }
        v1102 = (void *)*v1102;
        if (!v1102) {
          goto LABEL_2204;
        }
      }
    }
    while (1)
    {
      unint64_t v1106 = v1102[1];
      if (v1106 == 0x1AF456233693CD46)
      {
        if (v1102[2] == 0x1AF456233693CD46)
        {
LABEL_2202:
          uint64_t v1421 = v1102[5];
          if (*(void *)(v1421 + 8) == 0x1AF456233693CD46)
          {
            uint64_t v1422 = *(void *)(v1421 + 32);
LABEL_2205:
            v1423 = *(uint64_t **)(*(void *)(v1093 + 40) + 64);
            uint64_t v1424 = *v1423;
            unint64_t v1425 = *(void *)(*v1423 + 8);
            v1426 = *(float32x4_t **)(*v1423 + 72);
            gm::operator*<double,4,4,4>((double *)v1969, (double *)(v1422 + 808), (double *)(v1093 + 56));
            float32x4_t *v1426 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v1969), *(float64x2_t *)&v1969[16]);
            v1426[1] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v1969[32]), *(float64x2_t *)&v1969[48]);
            v1426[2] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v1969[64]), *(float64x2_t *)&v1969[80]);
            v1426[3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v1969[96]), *(float64x2_t *)&v1969[112]);
            unint64_t v1428 = *(void *)(v1424 + 64);
            if (v1428 <= v1425) {
              unint64_t v1428 = v1425;
            }
            *(void *)(v1424 + 56) = 0;
            *(void *)(v1424 + 64) = v1428;
            memset(buf, 0, 24);
            *(void *)&buf[24] = gss::Allocator::instance(v1427);
            v1429 = (void *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)&buf[24] + 16))(*(void *)&buf[24], 8, 4);
            *(void *)long long buf = v1429;
            *(void *)&buf[16] = v1429 + 1;
            if (v1429) {
              void *v1429 = 0xB00000005;
            }
            *(void *)&uint8_t buf[8] = v1429 + 1;
            gss::FeatureAttributeSet::FeatureAttributeSet((gss::FeatureAttributeSet *)&v1986, (uint64_t)buf);
            *(void **)((char *)v1992 + 7) = 0;
            v1992[0] = 0;
            HIBYTE(v1992[1]) = 1;
            *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)v1992, 0x10002u) = v1092;
            gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)v1962, v1091, (gss::FeatureAttributeSet *)&v1986, (gss::QueryOverrides *)v1992);
            v1430 = v1962[0];
            v1431 = (std::__shared_weak_count *)v1962[1];
            long long v2001 = *(_OWORD *)v1962;
            if (v1962[1]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)v1962[1] + 1, 1uLL, memory_order_relaxed);
            }
            gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v1969, (uint64_t)v1430, (uint64_t)v1431);
            if (v1431 && !atomic_fetch_add(&v1431->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v1431->__on_zero_shared)(v1431);
              std::__shared_weak_count::__release_weak(v1431);
            }
            float v1432 = *(float *)(v1422 + 3072);
            float v1433 = *(float *)(v1422 + 3080);
            uint64_t v1434 = *(void *)(*(void *)v1969 + 24);
            v1435 = *(float **)v1434;
            if (*(void *)v1434
              && (float v1436 = *v1435, LODWORD(v1435) = *v1435 == 1.0, *(unsigned char *)(v1434 + 10))
              && v1436 != 0.0
              && v1436 != 1.0
              || (v1437 = *(unsigned __int8 *)(v1434 + v1435 + 11), float v1436 = 0.0, v1437 == 2))
            {
              LOBYTE(v2001) = 1;
              LOBYTE(v1998) = 1;
              v1438 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v1434, 0xF3u, 0, &v2001);
              float v1439 = *v1438
                    + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v1434, 0xF3u, 1u, &v1998)- *v1438)* v1436);
            }
            else
            {
              float v1439 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(*(void *)v1969 + 24), 0xF3u, v1437, 0);
            }
            uint64_t v1440 = *(void *)(*(void *)v1969 + 24);
            v1441 = *(float **)v1440;
            if (*(void *)v1440
              && (float v1442 = *v1441, LODWORD(v1441) = *v1441 == 1.0, *(unsigned char *)(v1440 + 10))
              && v1442 != 0.0
              && v1442 != 1.0
              || (v1443 = *(unsigned __int8 *)(v1440 + v1441 + 11), float v1442 = 0.0, v1443 == 2))
            {
              LOBYTE(v2001) = 1;
              LOBYTE(v1998) = 1;
              v1444 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v1440, 0xF4u, 0, &v2001);
              float v1445 = *v1444
                    + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v1440, 0xF4u, 1u, &v1998)- *v1444)* v1442);
            }
            else
            {
              float v1445 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(*(void *)v1969 + 24), 0xF4u, v1443, 0);
            }
            float v1895 = v1445;
            uint64_t v1446 = *(void *)(*(void *)v1969 + 24);
            v1447 = *(float **)v1446;
            if (*(void *)v1446
              && (float v1448 = *v1447, LODWORD(v1447) = *v1447 == 1.0, *(unsigned char *)(v1446 + 10))
              && v1448 != 0.0
              && v1448 != 1.0
              || (v1449 = *(unsigned __int8 *)(v1446 + v1447 + 11), float v1448 = 0.0, v1449 == 2))
            {
              LOBYTE(v2001) = 1;
              LOBYTE(v1998) = 1;
              v1450 = (float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v1446, 0xF5u, 0, &v2001);
              float v1451 = v1439;
              float v1452 = v88;
              float v1453 = *v1450
                    + (float)((float)(*(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(v1446, 0xF5u, 1u, &v1998)- *v1450)* v1448);
            }
            else
            {
              float v1451 = v1439;
              float v1452 = v88;
              float v1453 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(*(void *)(*(void *)v1969 + 24), 0xF5u, v1449, 0);
            }
            float v1454 = fmaxf(v1433 + v1432, 1.0);
            unint64_t v1455 = *(void *)(*(void *)v1969 + 24);
            float v1456 = fminf(fmaxf(v1454, 0.0), 23.0);
            v1457 = *(float **)v1455;
            if (*(void *)v1455
              && (float v1458 = *v1457, LODWORD(v1457) = *v1457 == 1.0, *(unsigned char *)(v1455 + 10))
              && v1458 != 0.0
              && v1458 != 1.0
              || (v1459 = *(unsigned __int8 *)(v1455 + v1457 + 11), float v1458 = 0.0, v1459 == 2))
            {
              LOBYTE(v2001) = 1;
              LOBYTE(v1998) = 1;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v1455, 0x5Eu, 0, (BOOL *)&v2001, v1456);
              float v1461 = v1460;
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v1455, 0x5Eu, 1u, (BOOL *)&v1998, v1456);
              float v1463 = v1461 + (float)((float)(v1462 - v1461) * v1458);
            }
            else
            {
              gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)v1969 + 24), 0x5Eu, v1459, 0, v1456);
            }
            float v1464 = (float)((float)(fminf(fmaxf(v1895 * (float)(v1454 - v1451), 0.0), v1453) * 0.5) + 0.5) * v1463;
            float v1465 = v1452 / *(double *)(v1093 + 56);
            v1466 = *(void **)(*(void *)(*(void *)(v1093 + 48) + 64) + 16);
            unint64_t v1467 = v1466[1];
            uint64_t v1468 = v1466[9];
            *(float *)(v1468 + 16) = (float)(v1464 + 2.0) * (float)(v1465 * *(float *)(v1093 + 184));
            *(_OWORD *)uint64_t v1468 = xmmword_1A28FCDD0;
            if (v1466[8] > v1467) {
              unint64_t v1467 = v1466[8];
            }
            v1466[7] = 0;
            v1466[8] = v1467;
            uint64_t v1469 = *(void *)(v1093 + 24);
            *(void *)(v1469 + 48) = 1610612736;
            ggl::CommandBuffer::pushRenderItem(v1878, v1469);
            v1470 = *(void **)(*(void *)(*(void *)(v1093 + 40) + 64) + 16);
            unint64_t v1471 = v1470[1];
            uint64_t v1472 = v1470[9];
            *(float *)(v1472 + 16) = (float)(v1464 * v1465) * *(float *)(v1093 + 184);
            __asm { FMOV            V0.4S, #1.0 }
            *(_OWORD *)uint64_t v1472 = _Q0;
            if (v1470[8] > v1471) {
              unint64_t v1471 = v1470[8];
            }
            v1470[7] = 0;
            v1470[8] = v1471;
            uint64_t v1474 = *(void *)(v1093 + 16);
            *(void *)(v1474 + 48) = 1610612737;
            ggl::CommandBuffer::pushRenderItem(v1878, v1474);
            v1475 = (gss::Allocator *)gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v1969);
            v1476 = (std::__shared_weak_count *)v1962[1];
            if (v1962[1] && !atomic_fetch_add((atomic_ullong *volatile)v1962[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v1476->__on_zero_shared)(v1476);
              std::__shared_weak_count::__release_weak(v1476);
            }
            if (!BYTE6(v1992[1]))
            {
              v1477 = v1992[0];
              if (v1992[0])
              {
                uint64_t v1478 = gss::Allocator::instance(v1475);
                (*(void (**)(uint64_t, void *, void))(*(void *)v1478 + 40))(v1478, v1477, WORD2(v1992[1]));
              }
            }
            if (v1986.i64[0])
            {
              v1986.i64[1] = v1986.i64[0];
              (*(void (**)(void, uint64_t, uint64_t))(**(void **)&v1987[8] + 40))(*(void *)&v1987[8], v1986.i64[0], *(void *)v1987 - v1986.i64[0]);
            }
            if (*(void *)buf)
            {
              *(void *)&uint8_t buf[8] = *(void *)buf;
              (*(void (**)(void, void, void))(**(void **)&buf[24] + 40))(*(void *)&buf[24], *(void *)buf, *(void *)&buf[16] - *(void *)buf);
            }
            break;
          }
LABEL_2204:
          uint64_t v1422 = 0;
          goto LABEL_2205;
        }
      }
      else
      {
        if (v1106 >= *(void *)&v1095) {
          v1106 %= *(void *)&v1095;
        }
        if (v1106 != v1097) {
          goto LABEL_2204;
        }
      }
      v1102 = (void *)*v1102;
      if (!v1102) {
        goto LABEL_2204;
      }
    }
  }
LABEL_2256:
  uint64_t v1479 = *(void *)(*v1089 + 328);
  *(void *)(v1479 + 56) = **(void **)(v1479 + 152);
  v1480 = *(void **)(*(void *)v1916 + 8);
  int8x8_t v1481 = (int8x8_t)v1480[1];
  if (!*(void *)&v1481) {
    goto LABEL_2284;
  }
  uint8x8_t v1482 = (uint8x8_t)vcnt_s8(v1481);
  v1482.i16[0] = vaddlv_u8(v1482);
  if (v1482.u32[0] > 1uLL)
  {
    uint64_t v1483 = 0x1AF456233693CD46;
    if (*(void *)&v1481 <= 0x1AF456233693CD46uLL) {
      uint64_t v1483 = 0x1AF456233693CD46uLL % *(void *)&v1481;
    }
  }
  else
  {
    uint64_t v1483 = (*(void *)&v1481 - 1) & 0x1AF456233693CD46;
  }
  v1484 = *(void **)(*v1480 + 8 * v1483);
  if (!v1484) {
    goto LABEL_2284;
  }
  v1485 = (void *)*v1484;
  if (!v1485) {
    goto LABEL_2284;
  }
  if (v1482.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v1487 = v1485[1];
      if (v1487 == 0x1AF456233693CD46)
      {
        if (v1485[2] == 0x1AF456233693CD46) {
          goto LABEL_2277;
        }
      }
      else if ((v1487 & (*(void *)&v1481 - 1)) != v1483)
      {
        goto LABEL_2284;
      }
      v1485 = (void *)*v1485;
      if (!v1485) {
        goto LABEL_2284;
      }
    }
  }
  while (1)
  {
    unint64_t v1486 = v1485[1];
    if (v1486 == 0x1AF456233693CD46) {
      break;
    }
    if (v1486 >= *(void *)&v1481) {
      v1486 %= *(void *)&v1481;
    }
    if (v1486 != v1483) {
      goto LABEL_2284;
    }
LABEL_2266:
    v1485 = (void *)*v1485;
    if (!v1485) {
      goto LABEL_2284;
    }
  }
  if (v1485[2] != 0x1AF456233693CD46) {
    goto LABEL_2266;
  }
LABEL_2277:
  uint64_t v1488 = v1485[5];
  if (*(void *)(v1488 + 8) != 0x1AF456233693CD46)
  {
LABEL_2284:
    uint64_t v1489 = 0;
    if (MEMORY[0xEC0]) {
      goto LABEL_2285;
    }
LABEL_2279:
    if ((*(void *)&v1481 & (*(void *)&v1481 - 1)) != 0)
    {
      unint64_t v1497 = 0x8BD499FBD96FBB9ELL;
      if (*(void *)&v1481 <= 0x8BD499FBD96FBB9ELL) {
        unint64_t v1497 = 0x8BD499FBD96FBB9ELL % *(void *)&v1481;
      }
      v1490 = *(void **)(*v1480 + 8 * v1497);
      do
      {
        do
          v1490 = (void *)*v1490;
        while (v1490[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v1490[2] != 0x8BD499FBD96FBB9ELL);
    }
    else
    {
      v1490 = *(void **)(*v1480 + 8 * ((*(void *)&v1481 - 1) & 0x8BD499FBD96FBB9ELL));
      do
      {
        do
          v1490 = (void *)*v1490;
        while (v1490[1] != 0x8BD499FBD96FBB9ELL);
      }
      while (v1490[2] != 0x8BD499FBD96FBB9ELL);
    }
    double v1498 = 0.0;
    if (**(unsigned char **)(v1490[5] + 32) && *(unsigned char *)(v1479 + 104)) {
      double v1498 = *(double *)(v1489 + 24) * 0.0000000249532021 * (double)(1 << *(unsigned char *)(v1479 + 81));
    }
    uint64_t v1499 = *(void *)(v1479 + 112);
    if ((*(unsigned char *)(v1499 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      *(void *)v1969 = &v1986;
      *(void *)long long buf = v1969;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, buf, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    v1495 = *(float **)(v1499 + 72);
    double v1496 = v1498;
    goto LABEL_2303;
  }
  uint64_t v1489 = *(void *)(v1488 + 32);
  if (!*(unsigned char *)(v1489 + 3776)) {
    goto LABEL_2279;
  }
LABEL_2285:
  uint64_t v1491 = *(void *)(v1479 + 72);
  if (!v1491)
  {
    uint64_t v1494 = *(void *)(v1479 + 112);
    if ((*(unsigned char *)(v1494 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      *(void *)v1969 = &v1986;
      *(void *)long long buf = v1969;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, buf, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    v1495 = *(float **)(v1494 + 72);
    double v1496 = 0.0;
LABEL_2303:
    int v1492 = ggl::CullingGrid::intersectedCellsForView(v1495, v1496);
    goto LABEL_2304;
  }
  int v1492 = gdc::GlobeTileGrid::intersectWithFrustum(v1491, (const double *)(v1489 + 984), *(double *)(v1489 + 24));
LABEL_2304:
  v1500 = *(uint64_t **)(v1479 + 8);
  v1501 = *(uint64_t **)(v1479 + 16);
  if (v1500 != v1501)
  {
    do
    {
      uint64_t v1503 = *v1500;
      v1504 = *(uint64_t **)(*v1500 + 248);
      v1505 = *(uint64_t **)(*v1500 + 256);
      if (v1504 == v1505)
      {
        char v1502 = 0;
      }
      else
      {
        char v1502 = 0;
        do
        {
          uint64_t v1506 = *v1504++;
          BOOL v1507 = (*(_DWORD *)(v1506 + 96) & v1492) != 0;
          v1502 |= v1507;
          *(unsigned char *)(v1506 + 48) = v1507;
        }
        while (v1504 != v1505);
      }
      *(unsigned char *)(v1503 + 136) = v1502 & 1;
      *(unsigned char *)(v1503 + 272) = v1502 & 1;
      ++v1500;
    }
    while (v1500 != v1501);
    uint64_t v1508 = *(void *)(v1479 + 8);
    uint64_t v1509 = *(void *)(v1479 + 16);
    if (v1508 != v1509)
    {
      while (2)
      {
        v915 = *(md::LayoutContext **)v1508;
        if (!*(unsigned char *)(*(void *)v1508 + 272)) {
          goto LABEL_2316;
        }
        uint64_t v1510 = *((void *)v915 + 35);
        uint64_t v1511 = *(void *)(v1510 + 248);
        v1512 = *(std::__shared_weak_count **)(v1510 + 256);
        if (v1512) {
          atomic_fetch_add_explicit(&v1512->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)v1992, v1511, (uint64_t)v1512);
        if (!v1512 || atomic_fetch_add(&v1512->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          if ((_BYTE)v1994) {
            goto LABEL_2323;
          }
LABEL_2333:
          if (GEOGetVectorKitRouteLog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
          }
          v1524 = (id)GEOGetVectorKitRouteLog_log;
          if (os_log_type_enabled(v1524, OS_LOG_TYPE_INFO))
          {
            *(_WORD *)v1969 = 0;
            _os_log_impl(&dword_1A1780000, v1524, OS_LOG_TYPE_INFO, "***RouteStyledOverlayBatch failed to layout", v1969, 2u);
          }

          *((unsigned char *)v915 + 136) = 0;
          *((unsigned char *)v915 + 272) = 0;
LABEL_2315:
          gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v1992);
LABEL_2316:
          v1508 += 8;
          if (v1508 == v1509) {
            goto LABEL_2450;
          }
          continue;
        }
        break;
      }
      ((void (*)(std::__shared_weak_count *))v1512->__on_zero_shared)(v1512);
      std::__shared_weak_count::__release_weak(v1512);
      if (!(_BYTE)v1994) {
        goto LABEL_2333;
      }
LABEL_2323:
      uint64_t v1513 = *((void *)v915 + 35);
      float v1514 = *(float *)(v1513 + 56);
      float v1515 = *(float *)&v1916[8];
      float v1516 = *(float *)(v1513 + 64);
      float v1517 = *((float *)v915 + 80);
      float v1518 = *((float *)v915 + 81);
      md::RouteStyledOverlayBatch::StyleProperties::StyleProperties((uint64_t)v1969, (uint64_t *)v915 + 36, *(float *)&v1916[8]);
      md::RouteStyledOverlayBatch::StyleProperties::StyleProperties((uint64_t)buf, (uint64_t *)v915 + 38, v1515);
      float v1519 = fminf(fminf(fmaxf((float)(v1518 - (float)(v1516 + (float)(v1514 * 20.0))) / (float)(v1514 * 20.0), 0.0), 1.0), fminf(fmaxf((float)((float)(v1516 + (float)(v1514 * 20.0)) - v1517) / (float)(v1514 * 20.0), 0.0), 1.0));
      *(float32x4_t *)&v1987[16] = vmlaq_n_f32(*(float32x4_t *)&v1969[32], vsubq_f32(*(float32x4_t *)v1982, *(float32x4_t *)&v1969[32]), v1519);
      *(float *)&v1987[32] = *(float *)&v1969[48]
                           + (float)((float)(*(float *)&v1982[16] - *(float *)&v1969[48]) * v1519);
      *(_WORD *)&v1989[7] = 0;
      LOBYTE(v1988) = 0;
      HIBYTE(v1990) = 0;
      float32x4_t v1986 = vmlaq_n_f32(*(float32x4_t *)v1969, vsubq_f32(*(float32x4_t *)buf, *(float32x4_t *)v1969), v1519);
      *(float32x4_t *)v1987 = vmlaq_n_f32(*(float32x4_t *)&v1969[16], vsubq_f32(*(float32x4_t *)&buf[16], *(float32x4_t *)&v1969[16]), v1519);
      float v1991 = *(float *)&v1969[104] + (float)((float)(*(float *)&v1984.f64[1] - *(float *)&v1969[104]) * v1519);
      if (v1969[79] >= 0) {
        uint64_t v1520 = v1969[79];
      }
      else {
        uint64_t v1520 = *(void *)&v1969[64];
      }
      uint64_t v1521 = v1982[47];
      size_t v1522 = *(void *)&v1982[32];
      if (v1982[47] < 0) {
        uint64_t v1521 = *(void *)&v1982[32];
      }
      if (v1520)
      {
        if (!v1521)
        {
          v1523 = &v1969[56];
          if ((v1969[79] & 0x80000000) != 0)
          {
            float v1862 = v1519;
            v1523 = &v1969[56];
            size_t v1522 = *(void *)&v1969[64];
            goto LABEL_2349;
          }
LABEL_2345:
          long long v1988 = *(_OWORD *)v1523;
          *(void *)v1989 = *((void *)v1523 + 2);
LABEL_2350:
          if (v1969[103] >= 0) {
            size_t v1527 = v1969[103];
          }
          else {
            size_t v1527 = *(void *)&v1969[88];
          }
          size_t v1528 = HIBYTE(v1984.f64[0]);
          v1529 = v1983[1];
          if (v1984.f64[0] < 0.0) {
            size_t v1528 = (size_t)v1983[1];
          }
          if (v1527)
          {
            if (!v1528)
            {
              if ((SHIBYTE(v1990) & 0x80000000) == 0)
              {
                v1530 = (void **)&v1969[80];
                if ((v1969[103] & 0x80000000) != 0)
                {
                  v1530 = (void **)&v1969[80];
                  v1529 = *(void **)&v1969[88];
                  goto LABEL_2383;
                }
LABEL_2371:
                *(_OWORD *)&v1989[8] = *(_OWORD *)v1530;
                v1990 = v1530[2];
LABEL_2392:
                if (v1986.f32[3] == 0.0)
                {
                  *((unsigned char *)v915 + 136) = 0;
                  *((unsigned char *)v915 + 272) = 0;
                  goto LABEL_2394;
                }
                md::RouteLineSection::halfWidthAtZoom(v1992, v1515);
                float v1539 = v1538;
                float v1540 = *((float *)&v1925 + 1);
                float v1541 = v1986.f32[0];
                double v1542 = 0.0;
                double v1543 = 0.0;
                if (v1986.f32[1] > 0.0)
                {
                  double v1544 = v1986.f32[1];
                  double v1543 = fmod(__x, v1986.f32[1]) / v1544;
                }
                if (v1986.f32[2] > 0.0)
                {
                  double v1545 = v1986.f32[2];
                  double v1542 = fmod(__x, v1986.f32[2]) / v1545;
                }
                v1546 = *(void **)(*(void *)v1916 + 8);
                unint64_t v1547 = v1546[1];
                if ((v1547 & (v1547 - 1)) != 0)
                {
                  unint64_t v1549 = 0xA60DDA5A69582425;
                  if (v1547 <= 0xA60DDA5A69582425) {
                    unint64_t v1549 = 0xA60DDA5A69582425 % v1547;
                  }
                  v1548 = *(void **)(*v1546 + 8 * v1549);
                  do
                  {
                    do
                      v1548 = (void *)*v1548;
                    while (v1548[1] != 0xA60DDA5A69582425);
                  }
                  while (v1548[2] != 0xA60DDA5A69582425);
                }
                else
                {
                  v1548 = *(void **)(*v1546 + 8 * ((v1547 - 1) & 0xA60DDA5A69582425));
                  do
                  {
                    do
                      v1548 = (void *)*v1548;
                    while (v1548[1] != 0xA60DDA5A69582425);
                  }
                  while (v1548[2] != 0xA60DDA5A69582425);
                }
                id v1550 = **(id **)(v1548[5] + 32);
                v1551 = v1550;
                if (v1550)
                {
                  [v1550 textureManager];
                }
                else
                {
                  v1962[1] = 0;
                  v1962[0] = 0;
                }

                v1552 = v1962[0];
                float v1553 = *(float *)&v1916[20];
                v1554 = (std::__shared_weak_count *)*((void *)v915 + 43);
                v1998 = (void **)*((void *)v915 + 42);
                uint64_t v1999 = (uint64_t)v1554;
                if (v1554) {
                  atomic_fetch_add_explicit(&v1554->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                md::TextureManager::texture(&v2001, v1552, (uint64_t)&v1988, (uint64_t *)&v1998, 1, v1553);
                if (v1554 && !atomic_fetch_add(&v1554->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v1554->__on_zero_shared)(v1554);
                  std::__shared_weak_count::__release_weak(v1554);
                  v1555 = (md::SharedResource *)v2001;
                  if (!(void)v2001) {
                    goto LABEL_2430;
                  }
LABEL_2428:
                  md::SharedResource::addFrameRef(v1555, v1935);
                  v1556 = (uint64_t *)((char *)v1555 + 32);
                  v1557 = v1962[0];
                }
                else
                {
                  v1555 = (md::SharedResource *)v2001;
                  if ((void)v2001) {
                    goto LABEL_2428;
                  }
LABEL_2430:
                  v1557 = v1962[0];
                  v1556 = (uint64_t *)v1962[0];
                }
                uint64_t v1558 = *v1556;
                float v1559 = *(float *)&v1916[20];
                v1560 = (std::__shared_weak_count *)*((void *)v915 + 43);
                v1996[0] = *((void *)v915 + 42);
                v1996[1] = (uint64_t)v1560;
                if (v1560) {
                  atomic_fetch_add_explicit(&v1560->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                md::TextureManager::texture(v1997, v1557, (uint64_t)&v1989[8], v1996, 1, v1559);
                if (v1560 && !atomic_fetch_add(&v1560->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v1560->__on_zero_shared)(v1560);
                  std::__shared_weak_count::__release_weak(v1560);
                  v1561 = v1997[0];
                  if (!v1997[0]) {
                    goto LABEL_2438;
                  }
LABEL_2436:
                  md::SharedResource::addFrameRef(v1561, v1935);
                  v1562 = (uint64_t *)((char *)v1561 + 32);
                }
                else
                {
                  v1561 = v1997[0];
                  if (v1997[0]) {
                    goto LABEL_2436;
                  }
LABEL_2438:
                  v1562 = (uint64_t *)v1962[0];
                }
                float v1563 = v1543;
                float v1564 = v1542;
                uint64_t v1565 = *v1562;
                **(void **)(*((void *)v915 + 41) + 96) = v1558;
                *(void *)(*(void *)(*((void *)v915 + 41) + 96) + 8) = v1565;
                uint64_t v1566 = *((void *)v915 + 41);
                v1567 = *(void **)(*(void *)(v1566 + 64) + 32);
                unint64_t v1568 = v1567[1];
                v1569 = (float32x2_t *)v1567[9];
                v1569->i32[0] = v1986.i32[3];
                v1569->f32[1] = (float)(v1541 + v1539) * v1540;
                uint64_t v1570 = *((void *)v915 + 35);
                v1569[1].f32[0] = *(float *)(v1570 + 56) * *(float *)v1987;
                v1569[2] = vmla_n_f32(*(float32x2_t *)&v1987[4], *(float32x2_t *)&v1987[12], v1563);
                v1569[3] = vmla_n_f32(*(float32x2_t *)&v1987[20], *(float32x2_t *)&v1987[28], v1564);
                v1569[4].f32[0] = v1991;
                v1569[4].i32[1] = 1065353216;
                *((void *)v915 + 6) = v1566;
                *((unsigned char *)v915 + 136) = 1;
                *((void *)v915 + 8) = (*(void *)(v1570 + 216) + v1926) | 0x20000;
                unint64_t v1571 = v1567[8];
                if (v1571 <= v1568) {
                  unint64_t v1571 = v1568;
                }
                v1567[7] = 0;
                v1567[8] = v1571;
                v1572 = (std::__shared_weak_count *)v1997[1];
                if (v1997[1] && !atomic_fetch_add((atomic_ullong *volatile)v1997[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v1572->__on_zero_shared)(v1572);
                  std::__shared_weak_count::__release_weak(v1572);
                }
                v1573 = (std::__shared_weak_count *)*((void *)&v2001 + 1);
                if (*((void *)&v2001 + 1)
                  && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v2001 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v1573->__on_zero_shared)(v1573);
                  std::__shared_weak_count::__release_weak(v1573);
                }
                v1574 = (std::__shared_weak_count *)v1962[1];
                if (v1962[1] && !atomic_fetch_add((atomic_ullong *volatile)v1962[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v1574->__on_zero_shared)(v1574);
                  std::__shared_weak_count::__release_weak(v1574);
                }
LABEL_2394:
                if (SHIBYTE(v1990) < 0)
                {
                  operator delete(*(void **)&v1989[8]);
                  if ((v1989[7] & 0x80000000) != 0) {
                    goto LABEL_2410;
                  }
LABEL_2396:
                  if ((SHIBYTE(v1984.f64[0]) & 0x80000000) == 0) {
                    goto LABEL_2397;
                  }
LABEL_2411:
                  operator delete(v1983[0]);
                  if ((v1982[47] & 0x80000000) != 0) {
                    goto LABEL_2412;
                  }
LABEL_2398:
                  if ((v1969[103] & 0x80000000) != 0) {
                    goto LABEL_2314;
                  }
LABEL_2413:
                  if ((v1969[79] & 0x80000000) == 0) {
                    goto LABEL_2315;
                  }
                }
                else
                {
                  if ((v1989[7] & 0x80000000) == 0) {
                    goto LABEL_2396;
                  }
LABEL_2410:
                  operator delete((void *)v1988);
                  if (SHIBYTE(v1984.f64[0]) < 0) {
                    goto LABEL_2411;
                  }
LABEL_2397:
                  if ((v1982[47] & 0x80000000) == 0) {
                    goto LABEL_2398;
                  }
LABEL_2412:
                  operator delete(*(void **)&v1982[24]);
                  if ((v1969[103] & 0x80000000) == 0) {
                    goto LABEL_2413;
                  }
LABEL_2314:
                  operator delete(*(void **)&v1969[80]);
                  if ((v1969[79] & 0x80000000) == 0) {
                    goto LABEL_2315;
                  }
                }
                operator delete(*(void **)&v1969[56]);
                goto LABEL_2315;
              }
              if (v1969[103] >= 0) {
                v1536 = (void **)&v1969[80];
              }
              else {
                v1536 = *(void ***)&v1969[80];
              }
              size_t v1528 = v1527;
LABEL_2391:
              std::string::__assign_no_alias<false>((void **)&v1989[8], v1536, v1528);
              goto LABEL_2392;
            }
LABEL_2364:
            if (v1519 > 0.5) {
              v1531 = buf;
            }
            else {
              v1531 = v1969;
            }
            v1530 = (void **)&v1969[80];
            if (v1519 > 0.5) {
              v1530 = v1983;
            }
            size_t v1532 = v1531[103];
            if (SHIBYTE(v1990) < 0)
            {
              v1533 = (void **)*((void *)v1531 + 10);
              v1534 = (void **)&v1969[88];
              if (v1519 > 0.5) {
                v1534 = &v1983[1];
              }
              v1535 = *v1534;
              if ((v1532 & 0x80u) == 0) {
                v1536 = v1530;
              }
              else {
                v1536 = v1533;
              }
              if ((v1532 & 0x80u) == 0) {
                size_t v1528 = v1532;
              }
              else {
                size_t v1528 = (size_t)v1535;
              }
              goto LABEL_2391;
            }
            if ((v1532 & 0x80) == 0) {
              goto LABEL_2371;
            }
            v1537 = (void **)&v1969[88];
            if (v1519 > 0.5) {
              v1537 = &v1983[1];
            }
            v1529 = *v1537;
          }
          else
          {
            if (!v1528) {
              goto LABEL_2364;
            }
            if (SHIBYTE(v1990) < 0)
            {
              if (v1984.f64[0] >= 0.0) {
                v1536 = v1983;
              }
              else {
                v1536 = (void **)v1983[0];
              }
              goto LABEL_2391;
            }
            v1530 = v1983;
            if ((SHIBYTE(v1984.f64[0]) & 0x80000000) == 0) {
              goto LABEL_2371;
            }
            v1530 = v1983;
          }
LABEL_2383:
          std::string::__assign_no_alias<true>(&v1989[8], *v1530, (size_t)v1529);
          goto LABEL_2392;
        }
LABEL_2341:
        v1523 = &v1969[56];
        if (v1519 <= 0.5)
        {
          v1525 = v1969;
        }
        else
        {
          v1523 = &v1982[24];
          v1525 = buf;
        }
        if (((char)v1525[79] & 0x80000000) == 0) {
          goto LABEL_2345;
        }
        v1526 = (size_t *)&v1969[64];
        float v1862 = v1519;
        if (v1519 > 0.5) {
          v1526 = (size_t *)&v1982[32];
        }
        size_t v1522 = *v1526;
      }
      else
      {
        if (!v1521) {
          goto LABEL_2341;
        }
        v1523 = &v1982[24];
        if ((v1982[47] & 0x80000000) == 0) {
          goto LABEL_2345;
        }
        float v1862 = v1519;
        v1523 = &v1982[24];
      }
LABEL_2349:
      std::string::__assign_no_alias<true>(&v1988, *(void **)v1523, v1522);
      float v1519 = v1862;
      goto LABEL_2350;
    }
  }
LABEL_2450:
  v1575 = a3;
  uint64_t v1576 = *(void *)(*a3 + 328);
  v1577 = *(uint64_t **)(v1576 + 8);
  v1896 = *(uint64_t **)(v1576 + 16);
  v910 = (char ***)v1821;
  if (v1577 != v1896)
  {
    v914 = (uint64_t *)&v1969[8];
    do
    {
      uint64_t v921 = *v1577;
      *(void *)long long buf = &unk_1EF579188;
      *(void *)&uint8_t buf[8] = v1878;
      *(void *)&buf[24] = buf;
      if (*(unsigned char *)(v921 + 272))
      {
        if (*(unsigned char *)(v921 + 136))
        {
          uint64_t v1579 = *(void *)(*(void *)(v921 + 8) + 56);
          *(void *)(v921 + 40) = v1579;
          BOOL v919 = *(unsigned __int8 *)(v1579 + 58) == 1;
        }
        else
        {
          BOOL v919 = 0;
        }
        v1580 = *(uint64_t ***)(v921 + 248);
        v784 = *(uint64_t ***)(v921 + 256);
        if (v1580 != v784)
        {
          uint64_t v1581 = 0;
          v922 = (char **)(v921 + 144);
          v915 = (md::LayoutContext *)(v921 + 24);
          while (1)
          {
            v1582 = *v1580;
            if (*((unsigned char *)*v1580 + 48))
            {
              if (v1582[11] != v1581)
              {
                if (v1581)
                {
                  v1583 = ggl::Batcher::commit((long long **)(v921 + 144), 0xC8u, v1493);
                  if (v1583[1] != *v1583)
                  {
                    if (*(unsigned char *)(v921 + 136))
                    {
                      v910 = (char ***)v1583;
                      long long v1585 = *(_OWORD *)v915;
                      long long v1584 = *(_OWORD *)(v921 + 40);
                      long long v1586 = *(_OWORD *)(v921 + 56);
                      long long v1587 = *(_OWORD *)(v921 + 72);
                      long long v1588 = *(_OWORD *)(v921 + 88);
                      long long v1589 = *(_OWORD *)(v921 + 120);
                      *(_OWORD *)&v1969[88] = *(_OWORD *)(v921 + 104);
                      *(_OWORD *)&v1969[104] = v1589;
                      *(void *)v1969 = &off_1EF55A458;
                      *(_OWORD *)&v1969[8] = v1585;
                      *(_OWORD *)&v1969[24] = v1584;
                      *(_OWORD *)&v1969[56] = v1587;
                      *(_OWORD *)&v1969[72] = v1588;
                      *(_OWORD *)&v1969[40] = v1586;
                      v1590 = *(void **)(v921 + 232);
                      uint64_t v1591 = v1590[1];
                      if (v1591 == *(void *)(v921 + 240))
                      {
                        v1590 = (void *)*v1590;
                        if (!v1590)
                        {
                          v1590 = malloc_type_malloc(120 * v1591 + 16, 0xB644C221uLL);
                          void *v1590 = 0;
                          v1590[1] = 0;
                          **(void **)(v921 + 232) = v1590;
                        }
                        *(void *)(v921 + 232) = v1590;
                        uint64_t v1591 = v1590[1];
                      }
                      v1592 = &v1590[15 * v1591];
                      v1590[1] = v1591 + 1;
                      v1592[2] = &off_1EF55A458;
                      long long v1593 = *(_OWORD *)&v1969[88];
                      long long v1594 = *(_OWORD *)&v1969[104];
                      long long v1595 = *(_OWORD *)&v1969[72];
                      *(_OWORD *)(v1592 + 9) = *(_OWORD *)&v1969[56];
                      long long v1596 = *(_OWORD *)&v1969[8];
                      long long v1597 = *(_OWORD *)&v1969[24];
                      *(_OWORD *)(v1592 + 7) = *(_OWORD *)&v1969[40];
                      *(_OWORD *)(v1592 + 5) = v1597;
                      *(_OWORD *)(v1592 + 3) = v1596;
                      *(_OWORD *)(v1592 + 15) = v1594;
                      *(_OWORD *)(v1592 + 13) = v1593;
                      *(_OWORD *)(v1592 + 11) = v1595;
                      v1592[10] = v1581;
                      v1598 = *v910;
                      v1592[13] = *v910;
                      v1592[14] = ((char *)v910[1] - (char *)v1598) >> 4;
                      v1986.i32[0] = 0;
                      *(void *)v1969 = v1592 + 2;
                      if (!*(void *)&buf[24]) {
                        goto LABEL_2745;
                      }
                      (*(void (**)(void, float32x4_t *, unsigned char *))(**(void **)&buf[24] + 48))(*(void *)&buf[24], &v1986, v1969);
                    }
                  }
                }
                v1582 = *v1580;
                uint64_t v1581 = (*v1580)[11];
              }
              uint64_t v1599 = 2;
              if (v919)
              {
                uint64_t v1599 = 4;
                v1600 = v1582 + 4;
              }
              else
              {
                v1600 = v1582 + 2;
              }
              if (v1600[1] != v1582[v1599]) {
                gm::MultiRange<unsigned long>::push_back((char **)(v921 + 144), v1600);
              }
            }
            if (++v1580 == v784) {
              goto LABEL_2480;
            }
          }
        }
        uint64_t v1581 = 0;
LABEL_2480:
        v1601 = ggl::Batcher::commit((long long **)(v921 + 144), 0xC8u, v1493);
        v910 = (char ***)v1821;
        v1575 = a3;
        if (v1601[1] != *v1601 && *(unsigned char *)(v921 + 136))
        {
          v922 = v1601;
          long long v1602 = *(_OWORD *)(v921 + 40);
          long long v1603 = *(_OWORD *)(v921 + 24);
          long long v1604 = *(_OWORD *)(v921 + 56);
          long long v1605 = *(_OWORD *)(v921 + 72);
          long long v1606 = *(_OWORD *)(v921 + 88);
          long long v1607 = *(_OWORD *)(v921 + 120);
          *(_OWORD *)&v1969[88] = *(_OWORD *)(v921 + 104);
          *(_OWORD *)&v1969[104] = v1607;
          *(void *)v1969 = &off_1EF55A458;
          *(_OWORD *)&v1969[8] = v1603;
          *(_OWORD *)&v1969[24] = v1602;
          *(_OWORD *)&v1969[56] = v1605;
          *(_OWORD *)&v1969[72] = v1606;
          *(_OWORD *)&v1969[40] = v1604;
          v1608 = *(void **)(v921 + 232);
          uint64_t v1609 = v1608[1];
          if (v1609 == *(void *)(v921 + 240))
          {
            v1608 = (void *)*v1608;
            if (!v1608)
            {
              v1608 = malloc_type_malloc(120 * v1609 + 16, 0xB644C221uLL);
              void *v1608 = 0;
              v1608[1] = 0;
              **(void **)(v921 + 232) = v1608;
            }
            *(void *)(v921 + 232) = v1608;
            uint64_t v1609 = v1608[1];
          }
          v1610 = &v1608[15 * v1609];
          v1608[1] = v1609 + 1;
          v1610[2] = &off_1EF55A458;
          long long v1611 = *(_OWORD *)&v1969[88];
          long long v1612 = *(_OWORD *)&v1969[104];
          long long v1613 = *(_OWORD *)&v1969[72];
          *(_OWORD *)(v1610 + 9) = *(_OWORD *)&v1969[56];
          long long v1614 = *(_OWORD *)&v1969[8];
          long long v1615 = *(_OWORD *)&v1969[24];
          *(_OWORD *)(v1610 + 7) = *(_OWORD *)&v1969[40];
          *(_OWORD *)(v1610 + 5) = v1615;
          *(_OWORD *)(v1610 + 3) = v1614;
          *(_OWORD *)(v1610 + 15) = v1612;
          *(_OWORD *)(v1610 + 13) = v1611;
          *(_OWORD *)(v1610 + 11) = v1613;
          v1610[10] = v1581;
          v1616 = *v922;
          v1610[13] = *v922;
          v1610[14] = (v922[1] - v1616) >> 4;
          v1986.i32[0] = 0;
          *(void *)v1969 = v1610 + 2;
          if (!*(void *)&buf[24])
          {
LABEL_2745:
            std::__throw_bad_function_call[abi:nn180100]();
LABEL_2760:
            __break(1u);
            if (v1813)
            {
              {
                {
                  ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::RouteLineArrow::defaultVboReflection;
                }
                ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::attributesReflection(void)::r;
                *(void *)algn_1E957D770 = 1;
              }
              *v910 = (char **)&ggl::MeshTyped<ggl::RouteLineArrow::DefaultVbo>::typedReflection(void)::r;
              v910[1] = (char **)&ggl::RouteLineArrow::pipelineDataBasePipelineDeviceStructs(void)::ref;
              v910[2] = 0;
              {
                ggl::RouteLineArrow::pipelineDataBasePipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
                unk_1E957D730 = ggl::Tile::Transform::reflection(void)::reflection;
                qword_1E957D738 = (uint64_t)ggl::RouteLineArrow::Style::reflection(void)::reflection;
              }
              qword_1E957D708 = (uint64_t)&ggl::RouteLineArrow::pipelineDataBasePipelineConstantStructs(void)::ref;
              unk_1E957D710 = xmmword_1A28FCEF0;
            }
            ggl::RouteLineArrow::BasePipelineState::typedReflection(void)::ref = (uint64_t)v910;
            ggl::RouteLineArrowShader::typedReflection(v1813);
            qword_1E9594990 = (uint64_t)&ggl::RouteLineArrowShader::typedReflection(void)::ref;
            {
              ggl::RouteLineArrow::pipelineStateBasePipelineAttributeStructBinding(void)::attr = 0;
              unk_1E95949F0 = 0;
              qword_1E95949F8 = (uint64_t)"";
              dword_1E9594A00 = 0;
              qword_1E9594A08 = (uint64_t)&ggl::RouteLineArrow::pipelineStateBasePipelineAttributeBinding_0(void)::attr;
              unk_1E9594A10 = 4;
            }
            qword_1E9594998 = (uint64_t)&ggl::RouteLineArrow::pipelineStateBasePipelineAttributeStructBinding(void)::attr;
            unk_1E95949A0 = 1;
            qword_1E95949A8 = 0;
            unk_1E95949B0 = 1;
            qword_1E95949B8 = (uint64_t)&ggl::RouteLineArrow::pipelineStateBasePipelineDeviceStructBinding(void)::ref;
            unk_1E95949C0 = 0;
            {
              ggl::RouteLineArrow::pipelineStateBasePipelineConstantStructBinding(void)::ref = 0;
              unk_1E9594A30 = 0;
              qword_1E9594A38 = (uint64_t)"view";
              dword_1E9594A40 = 3;
              qword_1E9594A48 = (uint64_t)&ggl::RouteLineArrow::pipelineStateBasePipelineConstantViewBinding(void)::reflection;
              *(_OWORD *)algn_1E9594A50 = xmmword_1A28FCEB0;
              qword_1E9594A60 = 1;
              unk_1E9594A68 = "transform";
              dword_1E9594A70 = 3;
              qword_1E9594A78 = (uint64_t)&ggl::RouteLineArrow::pipelineStateBasePipelineConstantTransformBinding(void)::reflection;
              unk_1E9594A80 = xmmword_1A28FCF70;
              qword_1E9594A90 = 2;
              unk_1E9594A98 = "style";
              dword_1E9594AA0 = 3;
              qword_1E9594AA8 = (uint64_t)&ggl::RouteLineArrow::pipelineStateBasePipelineConstantStyleBinding(void)::reflection;
              unk_1E9594AB0 = 10;
            }
            qword_1E95949C8 = (uint64_t)&ggl::RouteLineArrow::pipelineStateBasePipelineConstantStructBinding(void)::ref;
            unk_1E95949D0 = 3;
            v1319 = *(char **)buf;
            v1320 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)&buf[8]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
            }
            v922[4] = 0;
            v922[5] = 0;
            *((_DWORD *)v922 + 14) = 0;
            v922[6] = 0;
            v922[3] = (char *)&unk_1EF55B208;
            v922[8] = (char *)&ggl::RouteLineArrow::BasePipelineState::typedReflection(void)::ref;
            v922[9] = v1319;
            v922[10] = (char *)v1320;
            if (v1320) {
              atomic_fetch_add_explicit(&v1320->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            *((unsigned char *)v922 + 136) = 0;
            *(_OWORD *)((char *)v922 + 140) = xmmword_1A28FC970;
            *(char **)((char *)v922 + 156) = 0;
            *(char **)((char *)v922 + 172) = 0;
            *(char **)((char *)v922 + 164) = 0;
            *((unsigned char *)v922 + 184) = 0;
            *(_OWORD *)((char *)v922 + 188) = xmmword_1A28FC970;
            *(char **)((char *)v922 + 204) = 0;
            *(char **)((char *)v922 + 220) = 0;
            *(char **)((char *)v922 + 212) = 0;
            *((unsigned char *)v922 + 232) = 0;
            *(_OWORD *)((char *)v922 + 236) = xmmword_1A28FC970;
            *(char **)((char *)v922 + 252) = 0;
            *(char **)((char *)v922 + 268) = 0;
            *(char **)((char *)v922 + 260) = 0;
            long long v1321 = *(_OWORD *)&v1969[16];
            *(_OWORD *)(v922 + 35) = *(_OWORD *)v1969;
            *(_OWORD *)(v922 + 37) = v1321;
            *((unsigned char *)v922 + 312) = 0;
            v922[48] = 0;
            *((_OWORD *)v922 + 22) = 0u;
            *((_OWORD *)v922 + 23) = 0u;
            *((_OWORD *)v922 + 20) = 0u;
            *((_OWORD *)v922 + 21) = 0u;
            v922[49] = (char *)0x100000001;
            *((unsigned char *)v922 + 400) = 0;
            *((unsigned char *)v922 + 88) = v915 ^ 1;
            *((unsigned char *)v922 + 91) = BYTE2(v2001);
            *(_WORD *)((char *)v922 + 89) = v2001;
            *((_DWORD *)v922 + 23) = v921;
            *((_DWORD *)v922 + 24) = v919;
            *(char **)((char *)v922 + 100) = (char *)0x100000000;
            *((_DWORD *)v922 + 27) = v919;
            v922[14] = 0;
            v922[15] = 0;
            *((_DWORD *)v922 + 32) = 0;
            *((unsigned char *)v922 + 132) = 15;
            if (v1320 && !atomic_fetch_add(&v1320->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v1320->__on_zero_shared)(v1320);
              std::__shared_weak_count::__release_weak(v1320);
            }
            *((unsigned char *)v922 + 328) = (_BYTE)v915;
            *((unsigned char *)v922 + 329) = 1;
            *((_WORD *)v922 + 169) = 0;
            *(char **)((char *)v922 + 330) = 0;
            int8x16_t v1322 = vceqzq_s8(*(int8x16_t *)(v922 + 41));
            int16x8_t v1323 = vmovl_high_s8(v1322);
            int32x4_t v1324 = vmovl_s16(*(int16x4_t *)v1323.i8);
            v1325.i64[0] = v1324.u32[0];
            v1325.i64[1] = v1324.u32[1];
            int8x16_t v1326 = v1325;
            int16x8_t v1327 = vmovl_s8(*(int8x8_t *)v1322.i8);
            int32x4_t v1328 = vmovl_s16(*(int16x4_t *)v1327.i8);
            v1325.i64[0] = v1328.u32[0];
            v1325.i64[1] = v1328.u32[1];
            int8x16_t v1329 = v1325;
            int32x4_t v1330 = vmovl_high_s16(v1323);
            v1325.i64[0] = v1330.u32[0];
            v1325.i64[1] = v1330.u32[1];
            int8x16_t v1331 = v1325;
            int32x4_t v1332 = vmovl_high_s16(v1327);
            v1325.i64[0] = v1332.u32[0];
            v1325.i64[1] = v1332.u32[1];
            int8x16_t v1333 = v1325;
            v1325.i64[0] = v1324.u32[2];
            v1325.i64[1] = v1324.u32[3];
            int8x16_t v1334 = v1325;
            v1325.i64[0] = v1328.u32[2];
            v1325.i64[1] = v1328.u32[3];
            int8x16_t v1335 = v1325;
            v1325.i64[0] = v1330.u32[2];
            v1325.i64[1] = v1330.u32[3];
            int8x16_t v1336 = v1325;
            v1325.i64[0] = v1332.u32[2];
            v1325.i64[1] = v1332.u32[3];
            int8x16_t v1337 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v1325);
            int8x16_t v1338 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v1336);
            int8x16_t v1339 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v1335);
            int8x16_t v1340 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v1331);
            int8x16_t v1341 = vceqzq_s8(*(int8x16_t *)(v922 + 43));
            int16x8_t v1342 = vmovl_high_s8(v1341);
            int32x4_t v1343 = vmovl_s16(*(int16x4_t *)v1342.i8);
            v1325.i64[0] = v1343.u32[0];
            v1325.i64[1] = v1343.u32[1];
            int8x16_t v1344 = v1325;
            v922[3] = (char *)&unk_1EF55B860;
            int16x8_t v1345 = vmovl_s8(*(int8x8_t *)v1341.i8);
            int32x4_t v1346 = vmovl_s16(*(int16x4_t *)v1345.i8);
            v1325.i64[0] = v1346.u32[0];
            v1325.i64[1] = v1346.u32[1];
            int8x16_t v1347 = v1325;
            int32x4_t v1348 = vmovl_high_s16(v1342);
            v1325.i64[0] = v1348.u32[0];
            v1325.i64[1] = v1348.u32[1];
            int8x16_t v1349 = v1325;
            int32x4_t v1350 = vmovl_high_s16(v1345);
            v1325.i64[0] = v1350.u32[0];
            v1325.i64[1] = v1350.u32[1];
            int8x16_t v1351 = v1325;
            v1325.i64[0] = v1343.u32[2];
            v1325.i64[1] = v1343.u32[3];
            int8x16_t v1352 = v1325;
            v1325.i64[0] = v1346.u32[2];
            v1325.i64[1] = v1346.u32[3];
            int8x16_t v1353 = v1325;
            v1325.i64[0] = v1348.u32[2];
            v1325.i64[1] = v1348.u32[3];
            int8x16_t v1354 = v1325;
            v1325.i64[0] = v1350.u32[2];
            v1325.i64[1] = v1350.u32[3];
            int8x16_t v1355 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v1354);
            int8x16_t v1356 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v1344), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v1326));
            int8x16_t v1357 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v1347), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v1329));
            int8x16_t v1358 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v1349), v1340);
            int8x16_t v1359 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v1351), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v1333));
            int8x16_t v1360 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v1352), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v1334));
            int8x16_t v1361 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v1353), v1339);
            int8x16_t v1362 = vorrq_s8(v1355, v1338);
            int8x16_t v1363 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v1325), v1337);
            int8x16_t v1364 = vceqzq_s8(*(int8x16_t *)(v922 + 45));
            int16x8_t v1365 = vmovl_s8(*(int8x8_t *)v1364.i8);
            int32x4_t v1366 = vmovl_high_s16(v1365);
            v1325.i64[0] = v1366.i32[2];
            v1325.i64[1] = v1366.i32[3];
            int8x16_t v1367 = v1325;
            int16x8_t v1368 = vmovl_high_s8(v1364);
            int32x4_t v1369 = vmovl_high_s16(v1368);
            v1325.i64[0] = v1369.i32[2];
            v1325.i64[1] = v1369.i32[3];
            int8x16_t v1370 = v1325;
            int32x4_t v1371 = vmovl_s16(*(int16x4_t *)v1365.i8);
            v1325.i64[0] = v1371.i32[2];
            v1325.i64[1] = v1371.i32[3];
            int8x16_t v1372 = v1325;
            int32x4_t v1373 = vmovl_s16(*(int16x4_t *)v1368.i8);
            v1325.i64[0] = v1373.i32[2];
            v1325.i64[1] = v1373.i32[3];
            int8x16_t v1374 = v1325;
            v1325.i64[0] = v1366.i32[0];
            v1325.i64[1] = v1366.i32[1];
            int8x16_t v1375 = v1325;
            v1325.i64[0] = v1369.i32[0];
            v1325.i64[1] = v1369.i32[1];
            int8x16_t v1376 = v1325;
            v1325.i64[0] = v1371.i32[0];
            v1325.i64[1] = v1371.i32[1];
            int8x16_t v1377 = v1325;
            v1325.i64[0] = v1373.i32[0];
            v1325.i64[1] = v1373.i32[1];
            int8x16_t v1378 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v1325);
            int8x16_t v1379 = vceqzq_s8(*(int8x16_t *)(v922 + 47));
            int16x8_t v1380 = vmovl_high_s8(v1379);
            int32x4_t v1381 = vmovl_s16(*(int16x4_t *)v1380.i8);
            v1325.i64[0] = v1381.i32[0];
            v1325.i64[1] = v1381.i32[1];
            int8x16_t v1382 = v1325;
            int16x8_t v1383 = vmovl_s8(*(int8x8_t *)v1379.i8);
            int32x4_t v1384 = vmovl_s16(*(int16x4_t *)v1383.i8);
            v1325.i64[0] = v1384.i32[0];
            v1325.i64[1] = v1384.i32[1];
            int8x16_t v1385 = v1325;
            int32x4_t v1386 = vmovl_high_s16(v1380);
            v1325.i64[0] = v1386.i32[0];
            v1325.i64[1] = v1386.i32[1];
            int8x16_t v1387 = v1325;
            int32x4_t v1388 = vmovl_high_s16(v1383);
            v1325.i64[0] = v1388.i32[0];
            v1325.i64[1] = v1388.i32[1];
            int8x16_t v1389 = v1325;
            v1325.i64[0] = v1381.i32[2];
            v1325.i64[1] = v1381.i32[3];
            int8x16_t v1390 = v1325;
            v1325.i64[0] = v1384.i32[2];
            v1325.i64[1] = v1384.i32[3];
            int8x16_t v1391 = v1325;
            v1325.i64[0] = v1386.i32[2];
            v1325.i64[1] = v1386.i32[3];
            int8x16_t v1392 = v1325;
            v1325.i64[0] = v1388.i32[2];
            v1325.i64[1] = v1388.i32[3];
            v922[40] = (char *)vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v1385), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v1377)), v1357), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v1382), v1378), v1356)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v1389), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v1375)), v1359), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB40, v1387),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCA90, v1376)),
                                                    v1358))),
                                   (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v1391), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v1372)), v1361), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v1390), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v1374)), v1360)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v1325), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v1367)), v1363), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB00, v1392),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v1370)),
                                                    v1362)))));
            *((unsigned char *)v922 + 312) = 1;
            v1393 = (std::__shared_weak_count *)v784[1];
            *v784 = v914;
            v784[1] = (uint64_t *)v922;
            if (v1393 && !atomic_fetch_add(&v1393->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v1393->__on_zero_shared)(v1393);
              std::__shared_weak_count::__release_weak(v1393);
            }
            v1394 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)&buf[8]
              && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v1394->__on_zero_shared)(v1394);
              std::__shared_weak_count::__release_weak(v1394);
            }
            v784[2] = 0;
            v784[3] = 0;
            operator new();
          }
          (*(void (**)(void, float32x4_t *, unsigned char *))(**(void **)&buf[24] + 48))(*(void *)&buf[24], &v1986, v1969);
          v910 = (char ***)v1821;
          v1575 = a3;
        }
        if (*(unsigned char **)&buf[24] != buf)
        {
          if (*(void *)&buf[24]) {
            (*(void (**)(void))(**(void **)&buf[24] + 40))();
          }
          goto LABEL_2454;
        }
        v1578 = *(void (***)(unsigned char *))buf;
      }
      else
      {
        v1578 = (void (**)(unsigned char *))&unk_1EF579188;
      }
      v1578[4](buf);
LABEL_2454:
      ++v1577;
    }
    while (v1577 != v1896);
  }
  v1617 = +[VKDebugSettings sharedSettings];
  v1618 = v1818;
  if (![v1617 highlightRouteLineSnappingStatus]) {
    goto LABEL_2728;
  }
  id v1817 = *v1818;
  uint64_t v1619 = [v1817 shaderLibrary];
  v1620 = *(uint64_t **)(*v1575 + 368);
  v1832 = v1617;
  if (!v1620)
  {
    uint64_t v1625 = *(void *)(v1619 + 80);
    v1626 = *(std::__shared_weak_count **)(v1625 + 400);
    v1992[0] = *(void **)(v1625 + 392);
    v1992[1] = v1626;
    if (v1626) {
      atomic_fetch_add_explicit(&v1626->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    memset(&v1969[24], 0, 20);
    v1969[0] = 1;
    *(_OWORD *)&v1969[4] = xmmword_1A28FCEE0;
    *(_DWORD *)&v1969[20] = 7;
    v1969[44] = 15;
    id v1627 = *(id *)(*(void *)(a1 + 40) + 104);
    v1628 = (_OWORD *)[v1627 format];
    v1629 = operator new(0x198uLL);
    v1629[1] = 0;
    v1629[2] = 0;
    void *v1629 = &unk_1EF589048;
    *(_OWORD *)long long buf = *v1628;
    *(_OWORD *)&buf[16] = v1628[1];
    v1986.i64[0] = ggl::Debug::BasePipelineState::BasePipelineState((uint64_t)(v1629 + 3), v1992, (uint64_t)v1969, buf);
    v1986.i64[1] = (uint64_t)v1629;

    if (v1626 && !atomic_fetch_add(&v1626->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1626->__on_zero_shared)(v1626);
      std::__shared_weak_count::__release_weak(v1626);
    }
    operator new();
  }
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(v1620);
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(*v1575 + 376));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(*v1575 + 384));
  v1621 = v910[1];
  int8x8_t v1622 = (int8x8_t)v1621[1];
  if (!*(void *)&v1622) {
    goto LABEL_2523;
  }
  uint8x8_t v1623 = (uint8x8_t)vcnt_s8(v1622);
  v1623.i16[0] = vaddlv_u8(v1623);
  if (v1623.u32[0] > 1uLL)
  {
    uint64_t v1624 = 0x1AF456233693CD46;
    if (*(void *)&v1622 <= 0x1AF456233693CD46uLL) {
      uint64_t v1624 = 0x1AF456233693CD46uLL % *(void *)&v1622;
    }
  }
  else
  {
    uint64_t v1624 = (*(void *)&v1622 - 1) & 0x1AF456233693CD46;
  }
  v1630 = *(void **)&(*v1621)[8 * v1624];
  if (!v1630) {
    goto LABEL_2523;
  }
  v1631 = (void *)*v1630;
  if (!v1631) {
    goto LABEL_2523;
  }
  if (v1623.u32[0] < 2uLL)
  {
    uint64_t v1632 = *(void *)&v1622 - 1;
    while (1)
    {
      uint64_t v1634 = v1631[1];
      if (v1634 == 0x1AF456233693CD46)
      {
        if (v1631[2] == 0x1AF456233693CD46) {
          goto LABEL_2521;
        }
      }
      else if ((v1634 & v1632) != v1624)
      {
        goto LABEL_2523;
      }
      v1631 = (void *)*v1631;
      if (!v1631) {
        goto LABEL_2523;
      }
    }
  }
  while (1)
  {
    unint64_t v1633 = v1631[1];
    if (v1633 == 0x1AF456233693CD46) {
      break;
    }
    if (v1633 >= *(void *)&v1622) {
      v1633 %= *(void *)&v1622;
    }
    if (v1633 != v1624) {
      goto LABEL_2523;
    }
LABEL_2510:
    v1631 = (void *)*v1631;
    if (!v1631) {
      goto LABEL_2523;
    }
  }
  if (v1631[2] != 0x1AF456233693CD46) {
    goto LABEL_2510;
  }
LABEL_2521:
  uint64_t v1635 = v1631[5];
  if (*(void *)(v1635 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v1636 = *(void *)(v1635 + 32);
    goto LABEL_2524;
  }
LABEL_2523:
  uint64_t v1636 = 0;
LABEL_2524:
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x4812000000;
  *(void *)&buf[24] = __Block_byref_object_copy__49;
  *(void *)v1982 = __Block_byref_object_dispose__50;
  *(void *)&v1982[8] = "";
  *(void *)&v1982[32] = 0;
  *(void *)&v1982[24] = 0;
  *(void *)&v1982[16] = &v1982[24];
  v1968[1] = 0;
  v1968[0] = 0;
  v1967 = v1968;
  v1637 = [*(id *)(*v1575 + 160) overlay];
  v1638 = [v1637 composedRoute];
  v1986.i64[0] = MEMORY[0x1E4F143A8];
  v1986.i64[1] = 3221225472;
  *(void *)v1987 = ___ZN2md16RouteRenderLayer34layoutDebugRouteLineSnappingStatusERKNSt3__110shared_ptrINS_16RouteLineOverlayEEERKN3ggl15StandardLibraryERKNS_13LayoutContextEPNS7_13CommandBufferE_block_invoke;
  *(void *)&v1987[8] = &unk_1E5A8EB90;
  *(void *)&v1987[16] = buf;
  *(void *)&v1987[24] = v1575;
  *(void *)&v1987[32] = v1636;
  *(void *)&long long v1988 = v1878;
  [v1638 forEachSnappedPath:&v1986];

  long long v1995 = 0u;
  long long v1994 = 0u;
  long long v1993 = 0u;
  *(_OWORD *)v1992 = 0u;
  v1639 = [*(id *)(*a3 + 160) overlay];
  v1640 = [v1639 composedRoute];
  id obja = [v1640 sections];

  uint64_t v1641 = [obja countByEnumeratingWithState:v1992 objects:v1969 count:16];
  if (!v1641)
  {

    goto LABEL_2727;
  }
  v1642 = 0;
  v1897 = 0;
  v1643 = (float64x2_t *)(v1636 + 808);
  uint64_t v1827 = *(void *)v1993;
  __asm { FMOV            V3.4S, #1.0 }
  float32x4_t v1836 = _Q3;
  do
  {
    uint64_t v1831 = 0;
    uint64_t v1825 = v1641;
    do
    {
      v1645 = v1642;
      if (*(void *)v1993 != v1827) {
        objc_enumerationMutation(obja);
      }
      v1646 = (void *)*((void *)v1992[1] + v1831);
      if (![v1646 pointCount])
      {
        v1657 = v1617;
        v1829 = v1642;
        goto LABEL_2528;
      }
      uint64_t v1647 = *(void *)&buf[8];
      v1648 = *(uint64_t **)(*(void *)&buf[8] + 56);
      if (!v1648) {
        goto LABEL_2543;
      }
      uint64_t v1649 = *(void *)&buf[8] + 56;
      v1650 = *(void **)(*(void *)&buf[8] + 56);
      do
      {
        unint64_t v1651 = v1650[4];
        BOOL v1652 = v1651 >= (unint64_t)v1646;
        if (v1651 >= (unint64_t)v1646) {
          v1653 = v1650;
        }
        else {
          v1653 = v1650 + 1;
        }
        if (v1652) {
          uint64_t v1649 = (uint64_t)v1650;
        }
        v1650 = (void *)*v1653;
      }
      while (*v1653);
      if (v1649 == *(void *)&buf[8] + 56 || (unint64_t)v1646 < *(void *)(v1649 + 32))
      {
LABEL_2543:
        int v1654 = [v1646 pointCount] - 1;
        v1655 = v1897;
        if (v1897 >= (int *)v1645)
        {
          unint64_t v1660 = (v1645 - (char *)v1897) >> 2;
          if (v1660 <= 1) {
            unint64_t v1660 = 1;
          }
          if ((unint64_t)(v1645 - (char *)v1897) >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v1661 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v1661 = v1660;
          }
          if (v1661 >> 61) {
LABEL_2741:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          v1655 = (int *)operator new(8 * v1661);
          v1657 = v1617;
          v1658 = v1646;
          v1829 = (char *)&v1655[2 * v1661];
          int *v1655 = 0;
          v1655[1] = v1654;
          v1659 = v1655 + 2;
          if (v1897) {
            operator delete(v1897);
          }
        }
        else
        {
          v1656 = v1645;
          v1657 = v1617;
          v1658 = v1646;
          v1829 = v1656;
          int *v1897 = 0;
          v1897[1] = v1654;
          v1659 = v1897 + 2;
        }
LABEL_2646:
        v1727 = v1655;
        v1834 = v1655;
        while (1)
        {
          uint64_t v1730 = *v1727;
          uint64_t v1729 = v1727[1];
          uint64_t v1731 = v1729 - v1730;
          if ((v1729 - v1730) >= 2) {
            break;
          }
LABEL_2650:
          v1727 += 2;
          if (v1727 == v1659)
          {
            v1897 = v1655;
            uint64_t v1641 = v1825;
            goto LABEL_2528;
          }
        }
        uint64_t v1732 = ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::pop(*(void *)(*a3 + 384));
        uint64_t v1733 = **(void **)(v1732 + 64);
        uint64_t v1734 = *(void *)(v1733 + 72);
        if (*(void *)(v1733 + 80) != v1734)
        {
          *(void *)(v1733 + 80) = v1734;
          v1735 = *(std::__shared_weak_count **)(v1733 + 32);
          *(void *)(v1733 + 24) = 0;
          *(void *)(v1733 + 32) = 0;
          if (v1735 && !atomic_fetch_add(&v1735->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1735->__on_zero_shared)(v1735);
            std::__shared_weak_count::__release_weak(v1735);
          }
          *(void *)(v1733 + 120) = 0;
          *(_DWORD *)(v1733 + 112) = 0;
          uint64_t v1736 = *(void *)(v1733 + 80) - *(void *)(v1733 + 72);
          *(void *)(v1733 + 40) = 0;
          *(void *)(v1733 + 48) = v1736;
          *(void *)(v1733 + 56) = 0;
          *(void *)(v1733 + 64) = v1736;
        }
        [v1658 vkBounds];
        double v1873 = v1737;
        double v1739 = v1738;
        double v1741 = v1740;
        double v1868 = v1742;
        float64x2_t v1838 = v1643[5];
        float64x2_t v1843 = v1643[4];
        float64x2_t v1848 = v1643[2];
        float64x2_t v1853 = *v1643;
        *(float64x2_t *)__pc = v1643[3];
        float64x2_t v1863 = v1643[1];
        float64x2_t v1886 = v1643[6];
        *(float64x2_t *)v1898 = v1643[7];
        uint64_t v1743 = [v1658 points];
        uint64_t v1744 = **(void **)(v1732 + 64);
        unint64_t v1745 = *(void *)(v1744 + 8) * v1731;
        uint64_t v1746 = *(void *)(v1744 + 72);
        unint64_t v1747 = *(void *)(v1744 + 80) - v1746;
        if (v1745 != v1747)
        {
          if (v1745 <= v1747)
          {
            if (v1745 < v1747) {
              *(void *)(v1744 + 80) = v1746 + v1745;
            }
          }
          else
          {
            std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v1744 + 72, v1745 - v1747);
          }
          v1748 = *(std::__shared_weak_count **)(v1744 + 32);
          *(void *)(v1744 + 24) = 0;
          *(void *)(v1744 + 32) = 0;
          if (v1748 && !atomic_fetch_add(&v1748->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v1748->__on_zero_shared)(v1748);
            std::__shared_weak_count::__release_weak(v1748);
          }
          *(void *)(v1744 + 120) = 0;
          *(_DWORD *)(v1744 + 112) = 0;
          uint64_t v1749 = *(void *)(v1744 + 80) - *(void *)(v1744 + 72);
          *(void *)(v1744 + 40) = 0;
          *(void *)(v1744 + 48) = v1749;
          *(void *)(v1744 + 56) = 0;
          *(void *)(v1744 + 64) = v1749;
          uint64_t v1744 = **(void **)(v1732 + 64);
          unint64_t v1745 = *(void *)(v1744 + 8) * v1731;
        }
        v1962[1] = 0;
        v1962[0] = 0;
        if (v1745) {
          unint64_t v1750 = *(void *)(v1744 + 72);
        }
        else {
          unint64_t v1750 = 0;
        }
        *(void *)&long long v1751 = 0;
        *((void *)&v1751 + 1) = v1744;
        *(_OWORD *)v1962 = v1751;
        v1752 = (uint64_t *)(v1743 + 12 * (int)v1730);
        uint64_t v1963 = 0;
        unint64_t v1964 = v1745;
        unint64_t v1966 = v1750;
        __int16 v1965 = 1;
        if (v1731 > 8
          && (v1750 < v1743 + 12 * (v1730 + (unint64_t)v1731) - 4
            ? (BOOL v1753 = (unint64_t)v1752 >= v1750 + 16 * v1731)
            : (BOOL v1753 = 1),
              v1753))
        {
          uint64_t v1754 = v1731 & 7;
          if ((v1731 & 7) == 0) {
            uint64_t v1754 = 8;
          }
          uint64_t v1755 = v1731 - v1754;
          v1756 = (float *)(v1750 + 64);
          v1757 = (const float *)(v1743 + 12 * (int)v1730);
          uint64_t v1758 = v1755;
          float32x4_t v1759 = v1836;
          do
          {
            v1760 = v1757;
            float32x4x3_t v2004 = vld3q_f32(v1760);
            v1760 += 12;
            v2004.val[2] = 0uLL;
            *(float32x4x3_t *)v2005.val[0].f32 = vld3q_f32(v1760);
            v2005.val[2] = 0uLL;
            v2005.val[3] = v1836;
            v1761 = v1756 - 16;
            vst4q_f32(v1761, *(float32x4x4_t *)(&v1759 - 3));
            vst4q_f32(v1756, v2005);
            v1756 += 32;
            v1757 += 24;
            v1758 -= 8;
          }
          while (v1758);
          v1752 = (uint64_t *)((char *)v1752 + 12 * v1755);
        }
        else
        {
          uint64_t v1755 = 0;
        }
        double v1762 = v1741 - v1873;
        double v1763 = v1739 - v1868;
        float64x2_t v1839 = vmulq_n_f64(v1838, v1739 - v1868);
        float64x2_t v1844 = vmulq_n_f64(v1843, v1739 - v1868);
        float64x2_t v1899 = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)v1898, v1863, v1868), *(float64x2_t *)__pc, v1873);
        float64x2_t v1887 = vmlaq_n_f64(vmlaq_n_f64(v1886, v1853, v1868), v1848, v1873);
        float64x2_t v1764 = vmulq_n_f64(v1853, v1739 - v1868);
        float64x2_t v1869 = vmulq_n_f64(v1848, v1741 - v1873);
        float64x2_t v1874 = v1764;
        float64x2_t v1854 = vmulq_n_f64(v1863, v1763);
        float64x2_t v1864 = vmulq_n_f64(*(float64x2_t *)__pc, v1762);
        uint64_t v1765 = v1731 - v1755;
        v1766 = (void *)(v1750 + 16 * v1755 + 8);
        do
        {
          uint64_t v1767 = *v1752;
          v1752 = (uint64_t *)((char *)v1752 + 12);
          *(v1766 - 1) = v1767;
          void *v1766 = 0x3F80000000000000;
          v1766 += 2;
          --v1765;
        }
        while (v1765);
        uint64_t v1768 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*(void *)(*a3 + 368));
        v1769 = *(void **)(v1768 + 64);
        v1770 = (void *)v1769[2];
        unint64_t v1771 = v1770[1];
        uint64_t v1772 = v1770[9];
        *(float32x2_t *)uint64_t v1772 = vcvt_f32_f64(v1874);
        *(float32x2_t *)(v1772 + 8) = vcvt_f32_f64(v1854);
        *(float32x2_t *)(v1772 + 16) = vcvt_f32_f64(v1869);
        *(float32x2_t *)(v1772 + 24) = vcvt_f32_f64(v1864);
        *(float32x4_t *)(v1772 + 32) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v1844), v1839);
        *(float32x4_t *)(v1772 + 48) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v1887), v1899);
        if (v1770[8] > v1771) {
          unint64_t v1771 = v1770[8];
        }
        v1770[7] = 0;
        v1770[8] = v1771;
        v1773 = (void *)*v1769;
        unint64_t v1774 = v1773[1];
        *(float32x4_t *)v1773[9] = v1836;
        if (v1773[8] > v1774) {
          unint64_t v1774 = v1773[8];
        }
        v1773[7] = 0;
        v1773[8] = v1774;
        v1775 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*a3 + 376));
        v1776 = v1775;
        v1775[8] = v1732;
        v1775[4] = v1768;
        v1775[3] = *(void *)(*a3 + 360);
        v1777 = *(void **)(v1878 + 80);
        unint64_t v1778 = *(void *)(v1878 + 88);
        if ((unint64_t)v1777 < v1778)
        {
          if (v1777) {
            void *v1777 = v1775;
          }
          v1779 = v1777 + 1;
          uint64_t v1780 = v1878;
          v1657 = v1832;
LABEL_2714:
          *(void *)(v1780 + 80) = v1779;
          v1655 = v1834;
          if (v1966 && v1745)
          {
            v1801 = v1962[1];
            if (v1962[0] && *((unsigned char *)v1962[1] + 17) != 2) {
              (*(void (**)(void))(*(void *)v1962[0] + 64))();
            }
            unint64_t v1728 = v1801[8];
            if (v1728 <= v1745) {
              unint64_t v1728 = v1745;
            }
            v1801[7] = 0;
            v1801[8] = v1728;
          }
          goto LABEL_2650;
        }
        uint64_t v1781 = *(void *)(v1878 + 72);
        uint64_t v1782 = ((uint64_t)v1777 - v1781) >> 3;
        unint64_t v1783 = v1782 + 1;
        if ((unint64_t)(v1782 + 1) >> 61) {
          abort();
        }
        uint64_t v1784 = v1778 - v1781;
        if (v1784 >> 2 > v1783) {
          unint64_t v1783 = v1784 >> 2;
        }
        if ((unint64_t)v1784 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v1785 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v1785 = v1783;
        }
        if (v1785)
        {
          uint64_t v1786 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v1878 + 96) + 16))(*(void *)(v1878 + 96), 8 * v1785, 8);
          v1787 = (void *)(v1786 + 8 * v1782);
          uint64_t v1788 = v1786 + 8 * v1785;
          if (v1786) {
            void *v1787 = v1776;
          }
        }
        else
        {
          uint64_t v1788 = 0;
          v1787 = (void *)(8 * v1782);
        }
        uint64_t v1790 = *(void *)(v1878 + 72);
        uint64_t v1789 = *(void *)(v1878 + 80);
        uint64_t v1791 = v1789 - v1790;
        v1657 = v1832;
        if (v1789 == v1790)
        {
          v1793 = v1787;
          uint64_t v1780 = v1878;
          goto LABEL_2712;
        }
        unint64_t v1792 = v1791 - 8;
        if ((unint64_t)(v1791 - 8) < 0x38)
        {
          v1793 = v1787;
        }
        else
        {
          v1793 = v1787;
          if ((unint64_t)(v1789 - (void)v1787) >= 0x20)
          {
            uint64_t v1794 = (v1792 >> 3) + 1;
            v1795 = v1787 - 2;
            v1796 = (long long *)(v1789 - 16);
            uint64_t v1797 = v1794 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v1798 = *v1796;
              *(v1795 - 1) = *(v1796 - 1);
              _OWORD *v1795 = v1798;
              v1795 -= 2;
              v1796 -= 2;
              v1797 -= 4;
            }
            while (v1797);
            v1793 = &v1787[-(v1794 & 0x3FFFFFFFFFFFFFFCLL)];
            v1789 -= 8 * (v1794 & 0x3FFFFFFFFFFFFFFCLL);
            if (v1794 == (v1794 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_2711;
            }
          }
        }
        do
        {
          uint64_t v1799 = *(void *)(v1789 - 8);
          v1789 -= 8;
          *--v1793 = v1799;
        }
        while (v1789 != v1790);
LABEL_2711:
        uint64_t v1780 = v1878;
        uint64_t v1789 = *(void *)(v1878 + 72);
LABEL_2712:
        v1779 = v1787 + 1;
        *(void *)(v1780 + 72) = v1793;
        *(void *)(v1780 + 80) = v1787 + 1;
        uint64_t v1800 = *(void *)(v1780 + 88);
        *(void *)(v1780 + 88) = v1788;
        if (v1789)
        {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v1780 + 96) + 40))(*(void *)(v1780 + 96), v1789, v1800 - v1789);
          uint64_t v1780 = v1878;
        }
        goto LABEL_2714;
      }
      v1662 = *(uint64_t **)(*(void *)&buf[8] + 56);
      do
      {
        while (1)
        {
          v1663 = (uint64_t **)v1662;
          unint64_t v1664 = v1662[4];
          if ((unint64_t)v1646 < v1664) {
            break;
          }
          if (v1664 >= (unint64_t)v1646)
          {
            uint64_t v1669 = (uint64_t)v1663[5];
            goto LABEL_2567;
          }
          v1662 = v1663[1];
          if (!v1662)
          {
            v1665 = v1663 + 1;
            goto LABEL_2561;
          }
        }
        v1662 = *v1663;
      }
      while (*v1663);
      v1665 = v1663;
LABEL_2561:
      v1666 = (uint64_t *)operator new(0x40uLL);
      v1666[4] = (uint64_t)v1646;
      v1666[5] = 0;
      v1666[6] = 0;
      v1666[7] = 0;
      uint64_t *v1666 = 0;
      v1666[1] = 0;
      v1666[2] = (uint64_t)v1663;
      *v1665 = v1666;
      uint64_t v1667 = **(void **)(v1647 + 48);
      v1668 = v1666;
      if (v1667)
      {
        *(void *)(v1647 + 48) = v1667;
        v1668 = *v1665;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v1647 + 56), v1668);
      ++*(void *)(v1647 + 64);
      uint64_t v1647 = *(void *)&buf[8];
      v1648 = *(uint64_t **)(*(void *)&buf[8] + 56);
      uint64_t v1669 = v1666[5];
      if (v1648)
      {
        while (1)
        {
LABEL_2567:
          while (1)
          {
            v1671 = (uint64_t **)v1648;
            unint64_t v1672 = v1648[4];
            if ((unint64_t)v1646 >= v1672) {
              break;
            }
            v1648 = *v1671;
            v1670 = v1671;
            if (!*v1671) {
              goto LABEL_2571;
            }
          }
          if (v1672 >= (unint64_t)v1646) {
            break;
          }
          v1648 = v1671[1];
          if (!v1648)
          {
            v1670 = v1671 + 1;
            goto LABEL_2571;
          }
        }
        v1673 = (uint64_t *)v1671;
      }
      else
      {
        v1670 = (uint64_t **)(*(void *)&buf[8] + 56);
        v1671 = (uint64_t **)(*(void *)&buf[8] + 56);
LABEL_2571:
        v1673 = (uint64_t *)operator new(0x40uLL);
        v1673[4] = (uint64_t)v1646;
        v1673[5] = 0;
        v1673[6] = 0;
        v1673[7] = 0;
        uint64_t *v1673 = 0;
        v1673[1] = 0;
        v1673[2] = (uint64_t)v1671;
        *v1670 = v1673;
        uint64_t v1674 = **(void **)(v1647 + 48);
        v1675 = v1673;
        if (v1674)
        {
          *(void *)(v1647 + 48) = v1674;
          v1675 = *v1670;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v1647 + 56), v1675);
        ++*(void *)(v1647 + 64);
      }
      v1676 = (int *)v1673[6];
      unint64_t v1677 = 126 - 2 * __clz(((uint64_t)v1676 - v1669) >> 3);
      if (v1676 == (int *)v1669) {
        uint64_t v1678 = 0;
      }
      else {
        uint64_t v1678 = v1677;
      }
      std::__introsort<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *,false>(v1669, v1676, v1678, 1);
      uint64_t v1679 = *(void *)&buf[8];
      v1681 = (uint64_t **)(*(void *)&buf[8] + 56);
      v1680 = *(uint64_t **)(*(void *)&buf[8] + 56);
      if (v1680)
      {
        while (1)
        {
          while (1)
          {
            v1682 = (uint64_t **)v1680;
            unint64_t v1683 = v1680[4];
            if ((unint64_t)v1646 >= v1683) {
              break;
            }
            v1680 = *v1682;
            v1681 = v1682;
            if (!*v1682) {
              goto LABEL_2585;
            }
          }
          if (v1683 >= (unint64_t)v1646) {
            break;
          }
          v1680 = v1682[1];
          if (!v1680)
          {
            v1681 = v1682 + 1;
            goto LABEL_2585;
          }
        }
        v1684 = (uint64_t *)v1682;
      }
      else
      {
        v1682 = (uint64_t **)(*(void *)&buf[8] + 56);
LABEL_2585:
        v1684 = (uint64_t *)operator new(0x40uLL);
        v1684[4] = (uint64_t)v1646;
        v1684[5] = 0;
        v1684[6] = 0;
        v1684[7] = 0;
        uint64_t *v1684 = 0;
        v1684[1] = 0;
        v1684[2] = (uint64_t)v1682;
        *v1681 = v1684;
        uint64_t v1685 = **(void **)(v1679 + 48);
        v1686 = v1684;
        if (v1685)
        {
          *(void *)(v1679 + 48) = v1685;
          v1686 = *v1681;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v1679 + 56), v1686);
        ++*(void *)(v1679 + 64);
      }
      v1688 = (int *)v1684[5];
      v1687 = (int *)v1684[6];
      if (v1688 != v1687)
      {
        uint64_t v1689 = 0;
        v1655 = v1897;
        v1885 = (int *)v1684[6];
        while (1)
        {
          int v1691 = *v1688;
          if (*v1688 < (int)v1689)
          {
            uint64_t v1690 = v1689;
          }
          else
          {
            uint64_t v1690 = v1688[1];
            if (v1691 > (int)v1689)
            {
              v1692 = v1617;
              int v1693 = v1691 - 1;
              v1694 = v1645;
              if (v1897 >= (int *)v1645)
              {
                v1695 = v1655;
                uint64_t v1696 = (char *)v1897 - (char *)v1655;
                uint64_t v1697 = v1696 >> 3;
                unint64_t v1698 = (v1696 >> 3) + 1;
                if (v1698 >> 61) {
                  abort();
                }
                unint64_t v1699 = v1694 - (char *)v1695;
                unint64_t v1700 = (v1694 - (char *)v1695) >> 2;
                if (v1700 > v1698) {
                  unint64_t v1698 = v1700;
                }
                if (v1699 >= 0x7FFFFFFFFFFFFFF8) {
                  unint64_t v1701 = 0x1FFFFFFFFFFFFFFFLL;
                }
                else {
                  unint64_t v1701 = v1698;
                }
                if (v1701 >> 61) {
                  goto LABEL_2741;
                }
                v1702 = v1695;
                v1703 = operator new(8 * v1701);
                v1704 = &v1703[8 * v1697];
                _DWORD *v1704 = v1689;
                v1704[1] = v1693;
                v1705 = v1702;
                if (v1897 == v1702)
                {
                  v1655 = (int *)&v1703[8 * v1697];
                  v1617 = v1832;
                }
                else
                {
                  unint64_t v1706 = (char *)(v1897 - 2) - (char *)v1702;
                  v1617 = v1832;
                  if (v1706 < 0x168)
                  {
                    v1707 = v1897;
                    goto LABEL_2612;
                  }
                  if (&v1703[v1696 - 8 - (v1706 & 0xFFFFFFFFFFFFFFF8)] <= &v1703[v1696 - 8]
                    && (int *)((char *)v1897 - (v1706 & 0xFFFFFFFFFFFFFFF8) - 8) <= v1897 - 2
                    && (unint64_t)((char *)v1897 - v1696 - v1703) >= 0x20)
                  {
                    uint64_t v1709 = (v1706 >> 3) + 1;
                    v1707 = &v1897[-2 * (v1709 & 0x3FFFFFFFFFFFFFFCLL)];
                    v1710 = &v1703[v1696 - 16];
                    v1711 = (long long *)(v1897 - 4);
                    uint64_t v1712 = v1709 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v1713 = *v1711;
                      *(v1710 - 1) = *(v1711 - 1);
                      _OWORD *v1710 = v1713;
                      v1710 -= 2;
                      v1711 -= 2;
                      v1712 -= 4;
                    }
                    while (v1712);
                    v1655 = &v1704[-2 * (v1709 & 0x3FFFFFFFFFFFFFFCLL)];
                    v1705 = v1702;
                    if (v1709 != (v1709 & 0x3FFFFFFFFFFFFFFCLL)) {
                      goto LABEL_2613;
                    }
                  }
                  else
                  {
                    v1707 = v1897;
LABEL_2612:
                    v1655 = (int *)&v1703[8 * v1697];
                    v1705 = v1702;
                    do
                    {
LABEL_2613:
                      uint64_t v1708 = *((void *)v1707 - 1);
                      v1707 -= 2;
                      *((void *)v1655 - 1) = v1708;
                      v1655 -= 2;
                    }
                    while (v1707 != v1705);
                  }
                }
                v1645 = &v1703[8 * v1701];
                v1897 = v1704 + 2;
                if (v1705) {
                  operator delete(v1705);
                }
                v1687 = v1885;
                goto LABEL_2592;
              }
              int *v1897 = v1689;
              v1897[1] = v1693;
              v1897 += 2;
              v1617 = v1692;
            }
          }
LABEL_2592:
          v1688 += 2;
          uint64_t v1689 = v1690;
          if (v1688 == v1687) {
            goto LABEL_2622;
          }
        }
      }
      LODWORD(v1690) = 0;
      v1655 = v1897;
LABEL_2622:
      unint64_t v1714 = (unint64_t)v1645;
      v1657 = v1617;
      uint64_t v1641 = v1825;
      if (v1690 >= [v1646 pointCount])
      {
        v1658 = v1646;
        v1829 = (char *)v1714;
        goto LABEL_2645;
      }
      int v1715 = [v1646 pointCount];
      int v1716 = v1715;
      if ((unint64_t)v1897 < v1714)
      {
        v1658 = v1646;
        v1829 = (char *)v1714;
        int *v1897 = v1690;
        v1897[1] = v1715;
        v1897 += 2;
        goto LABEL_2645;
      }
      int64_t v1717 = (char *)v1897 - (char *)v1655;
      uint64_t v1718 = ((char *)v1897 - (char *)v1655) >> 3;
      unint64_t v1719 = v1718 + 1;
      if ((unint64_t)(v1718 + 1) >> 61) {
        abort();
      }
      if ((uint64_t)(v1714 - (void)v1655) >> 2 > v1719) {
        unint64_t v1719 = (uint64_t)(v1714 - (void)v1655) >> 2;
      }
      if (v1714 - (unint64_t)v1655 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v1720 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v1720 = v1719;
      }
      if (v1720 >> 61) {
        goto LABEL_2741;
      }
      v1721 = operator new(8 * v1720);
      v1722 = &v1721[8 * v1718];
      _DWORD *v1722 = v1690;
      v1722[1] = v1716;
      if (v1897 == v1655)
      {
        v1725 = &v1721[8 * v1718];
      }
      else
      {
        unint64_t v1723 = (char *)(v1897 - 2) - (char *)v1655;
        if (v1723 >= 0x168)
        {
          if (&v1721[v1717 - 8 - (v1723 & 0xFFFFFFFFFFFFFFF8)] <= &v1721[v1717 - 8]
            && (int *)((char *)v1897 - (v1723 & 0xFFFFFFFFFFFFFFF8) - 8) <= v1897 - 2
            && (unint64_t)((char *)v1655 - v1721) >= 0x20)
          {
            uint64_t v1802 = (v1723 >> 3) + 1;
            v1724 = &v1897[-2 * (v1802 & 0x3FFFFFFFFFFFFFFCLL)];
            v1803 = &v1721[v1717 - 16];
            v1804 = (long long *)(v1897 - 4);
            uint64_t v1805 = v1802 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v1806 = *v1804;
              *(v1803 - 1) = *(v1804 - 1);
              _OWORD *v1803 = v1806;
              v1803 -= 2;
              v1804 -= 2;
              v1805 -= 4;
            }
            while (v1805);
            v1725 = &v1722[-2 * (v1802 & 0x3FFFFFFFFFFFFFFCLL)];
            if (v1802 == (v1802 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_2642;
            }
          }
          else
          {
            v1724 = v1897;
            v1725 = &v1721[8 * v1718];
          }
        }
        else
        {
          v1724 = v1897;
          v1725 = &v1721[8 * v1718];
        }
        do
        {
          uint64_t v1726 = *((void *)v1724 - 1);
          v1724 -= 2;
          *((void *)v1725 - 1) = v1726;
          v1725 -= 2;
        }
        while (v1724 != v1655);
      }
LABEL_2642:
      v1897 = v1722 + 2;
      v1829 = &v1721[8 * v1720];
      v1658 = v1646;
      if (v1655) {
        operator delete(v1655);
      }
      v1655 = v1725;
LABEL_2645:
      v1659 = v1897;
      if (v1655 != v1897) {
        goto LABEL_2646;
      }
LABEL_2528:
      v1642 = v1829;
      ++v1831;
      v1617 = v1657;
    }
    while (v1831 != v1641);
    uint64_t v1641 = [obja countByEnumeratingWithState:v1992 objects:v1969 count:16];
  }
  while (v1641);

  if (v1897) {
    operator delete(v1897);
  }
LABEL_2727:
  std::__tree<VKPolylineGroupOverlay * {__strong}>::destroy(v1968[0]);
  _Block_object_dispose(buf, 8);
  std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::less<GEOComposedRouteSection * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>>>::destroy(*(void **)&v1982[24]);

  v910 = (char ***)v1821;
  v1575 = a3;
  v1618 = v1818;
LABEL_2728:
  if ([v1617 routeDebugPoints])
  {
    id v1807 = *v1618;
    md::RouteRenderLayer::layoutDebugRouteLinePoints(a1, v1575, *(void *)([v1807 shaderLibrary] + 80), (uint64_t)v910, v1878);
  }
  v1809 = *(std::__shared_weak_count **)&v1930[3];
  if (*(void *)&v1930[3]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v1930[3] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1809->__on_zero_shared)(v1809);
    std::__shared_weak_count::__release_weak(v1809);
  }
  if (!v1941[14])
  {
    uint64_t v1810 = *(void *)v1941;
    if (*(void *)v1941)
    {
      uint64_t v1811 = gss::Allocator::instance(v1808);
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v1811 + 40))(v1811, v1810, *(unsigned __int16 *)&v1941[12]);
    }
  }
  v1812 = v1944;
  if (v1944 && !atomic_fetch_add(&v1944->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1812->__on_zero_shared)(v1812);
    std::__shared_weak_count::__release_weak(v1812);
  }
}

void sub_1A1FC6AD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  if (v23) {
    operator delete(v23);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&STACK[0x560]);
  _Block_object_dispose(&STACK[0x5C0], 8);
  std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>::~unordered_map[abi:nn180100](a23);
  std::vector<geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>>::~vector[abi:nn180100]((void **)&STACK[0x7C0]);
  md::RouteLineArrowContext::~RouteLineArrowContext((id *)&STACK[0x2C0]);
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)&STACK[0x3D8]);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&STACK[0x418]);

  _Unwind_Resume(a1);
}

uint64_t ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke(uint64_t result, float a2)
{
  *(float *)(*(void *)(result + 32) + 200) = a2;
  return result;
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_18(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2) {
    *(_DWORD *)(v2 + 200) = 1065353216;
  }
  uint64_t v3 = *(void **)(v2 + 176);
  *(void *)(v2 + 176) = 0;
}

uint64_t ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_22(uint64_t result, float a2)
{
  *(float *)(*(void *)(result + 32) + 204) = a2;
  return result;
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_2(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2) {
    *(_DWORD *)(v2 + 204) = 1065353216;
  }
  uint64_t v3 = *(void **)(v2 + 184);
  *(void *)(v2 + 184) = 0;
}

float ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_3(uint64_t a1, float a2)
{
  float result = 1.0 - a2;
  *(float *)(*(void *)(a1 + 32) + 204) = result;
  return result;
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_4(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (a2) {
    *(_DWORD *)(v2 + 204) = 0;
  }
  uint64_t v3 = *(void **)(v2 + 184);
  *(void *)(v2 + 184) = 0;
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_5(uint64_t a1, void *a2)
{
  if (*a2) {
    uint64_t v3 = *a2 + 8;
  }
  else {
    uint64_t v3 = 0;
  }
  double v4 = *(uint64_t **)(a1 + 32);
  unint64_t v5 = (std::__shared_weak_count *)v4[1];
  v7[0] = *v4;
  v7[1] = (uint64_t)v5;
  if (v5) {
    atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v6 = *(unsigned __int8 **)(a1 + 48);
  md::RouteLineSection::updateStyleQueryIfNecessary(v3, v7, *(unsigned __int8 **)(a1 + 40), v6[620], v6[621], v6[622], (gss::FeatureAttributeSet *)(v6 + 536), (gss::FeatureAttributeSet *)(v6 + 568), *(float *)(a1 + 64), *(unsigned char *)(a1 + 76), *(_DWORD *)(a1 + 68), *(_DWORD *)(a1 + 72));
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_1A1FC7DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void md::RouteRenderLayer::updateRoutelineDrawinAnimation(uint64_t a1, md::LayoutContext *a2, void *a3, PolylineCoordinate a4)
{
  uint64_t v8 = *a3;
  if (*(unsigned char *)(*a3 + 848) && !*(unsigned char *)(v8 + 849) || *(float *)(v8 + 832) >= 1.0) {
    goto LABEL_8;
  }
  float v9 = *(void **)(v8 + 696);
  if (v9)
  {
    if ([v9 state] == 3)
    {
      uint64_t v8 = *a3;
LABEL_8:
      unint64_t v74 = [*(id *)(v8 + 144) routeRibbon];
      PolylineCoordinate v11 = a4;
      md::RouteLineDrawAnimation::rebuildAnimationSegments((md::RouteLineDrawAnimation *)(*a3 + 632), v74, v11);

      return;
    }
    uint64_t v10 = [*(id *)(v8 + 696) state];
    uint64_t v8 = *a3;
    if (v10 == 4) {
      goto LABEL_8;
    }
  }
  uint64_t v12 = *(void **)(v8 + 160);
  if (!v12) {
    return;
  }
  [v12 sections];
  uint64_t v14 = (char *)__p;
  uint64_t v13 = v85;
  if (__p)
  {
    if (v85 == __p)
    {
      uint64_t v20 = v85;
    }
    else
    {
      uint64_t v15 = v85;
      uint64_t v16 = v85;
      do
      {
        uint64_t v18 = (void *)*((void *)v16 - 1);
        v16 -= 8;
        uint64_t v17 = v18;
        if (v18)
        {
          BOOL v19 = (*v17)-- == 1;
          if (v19)
          {
            md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v17 + 1));
            {
              operator new();
            }
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *((void *)v15 - 1), 400);
            *((void *)v15 - 1) = 0;
          }
        }
        uint64_t v15 = v16;
      }
      while (v16 != v14);
      uint64_t v20 = __p;
    }
    uint64_t v85 = v14;
    operator delete(v20);
  }
  if (v13 == v14) {
    return;
  }
  uint64_t v21 = (void *)*((void *)a2 + 1);
  int8x8_t v22 = (int8x8_t)v21[1];
  if (!*(void *)&v22) {
    goto LABEL_50;
  }
  uint8x8_t v23 = (uint8x8_t)vcnt_s8(v22);
  v23.i16[0] = vaddlv_u8(v23);
  if (v23.u32[0] > 1uLL)
  {
    uint64_t v24 = 0x1AF456233693CD46;
    if (*(void *)&v22 <= 0x1AF456233693CD46uLL) {
      uint64_t v24 = 0x1AF456233693CD46uLL % *(void *)&v22;
    }
  }
  else
  {
    uint64_t v24 = (*(void *)&v22 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v25 = *(void **)(*v21 + 8 * v24);
  if (!v25) {
    goto LABEL_50;
  }
  double v26 = (void *)*v25;
  if (!v26) {
    goto LABEL_50;
  }
  if (v23.u32[0] < 2uLL)
  {
    uint64_t v27 = *(void *)&v22 - 1;
    while (1)
    {
      uint64_t v29 = v26[1];
      if (v29 == 0x1AF456233693CD46)
      {
        if (v26[2] == 0x1AF456233693CD46) {
          goto LABEL_48;
        }
      }
      else if ((v29 & v27) != v24)
      {
        goto LABEL_50;
      }
      double v26 = (void *)*v26;
      if (!v26) {
        goto LABEL_50;
      }
    }
  }
  while (1)
  {
    unint64_t v28 = v26[1];
    if (v28 == 0x1AF456233693CD46) {
      break;
    }
    if (v28 >= *(void *)&v22) {
      v28 %= *(void *)&v22;
    }
    if (v28 != v24) {
      goto LABEL_50;
    }
LABEL_37:
    double v26 = (void *)*v26;
    if (!v26) {
      goto LABEL_50;
    }
  }
  if (v26[2] != 0x1AF456233693CD46) {
    goto LABEL_37;
  }
LABEL_48:
  uint64_t v30 = v26[5];
  if (*(void *)(v30 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v31 = *(void *)(v30 + 32);
    goto LABEL_51;
  }
LABEL_50:
  uint64_t v31 = 0;
LABEL_51:
  float v32 = *(float *)(v31 + 3076);
  float v33 = *(float *)(v31 + 3080);
  long long v34 = +[VKDebugSettings sharedSettings];
  [v34 daVinciGlobeSplinedMaxZoom];
  BOOL v36 = fmaxf(v33 + v32, 1.0) <= v35 && *(unsigned __int8 *)(v31 + 3776) - 1 < 3;

  BOOL v37 = *(unsigned __int8 *)(md::LayoutContext::frameState(a2) + 128) - 1 < 3;
  uint64_t v38 = *a3;
  uint64_t v39 = *(void *)(*a3 + 312);
  v92[0] = *(unsigned char *)(v39 + 296);
  v92[1] = v36;
  v92[2] = v37;
  v92[3] = 0;
  md::SinglePassRoutePipelineStateManager::pipelineStateForFunctionConstants(&v90, *(void *)(v39 + 208), v92);
  ggl::Flyover::FlyoverPipelineSetup::setState(*(ggl::PipelineSetup **)(v38 + 640), (uint64_t)v90, v91);
  if (!*(void *)(v38 + 648)) {
    operator new();
  }
  char v40 = v91;
  if (v91 && !atomic_fetch_add(&v91->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
    std::__shared_weak_count::__release_weak(v40);
  }
  **(void **)(*(void *)(*a3 + 640) + 96) = *(void *)(*(void *)(*(void *)(*a3 + 312) + 248) + 24);
  if (*(unsigned char *)(*a3 + 620)) {
    float v41 = 2.0;
  }
  else {
    float v41 = 2.2;
  }
  long long v42 = *(void **)(*a3 + 160);
  if (v42)
  {
    [v42 sections];
    unint64_t v43 = (char *)__p;
  }
  else
  {
    unint64_t v43 = 0;
    std::string __p = 0;
    uint64_t v85 = 0;
    uint64_t v86 = 0;
  }
  if (*(void *)v43) {
    uint64_t v44 = *(void *)v43 + 8;
  }
  else {
    uint64_t v44 = 0;
  }
  uint64_t v46 = *(void *)(v44 + 248);
  uint64_t v45 = *(std::__shared_weak_count **)(v44 + 256);
  uint64_t v88 = v46;
  unint64_t v89 = v45;
  if (v45) {
    atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v47 = v85;
  uint64_t v48 = v43;
  if (v85 != v43)
  {
    long long v49 = v85;
    do
    {
      uint64_t v51 = (void *)*((void *)v49 - 1);
      v49 -= 8;
      uint64_t v50 = v51;
      if (v51)
      {
        BOOL v19 = (*v50)-- == 1;
        if (v19)
        {
          md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v50 + 1));
          {
            operator new();
          }
          (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *((void *)v47 - 1), 400);
          *((void *)v47 - 1) = 0;
        }
      }
      uint64_t v47 = v49;
    }
    while (v49 != v43);
    uint64_t v48 = __p;
  }
  uint64_t v85 = v43;
  operator delete(v48);
  if (v46)
  {
    uint64_t v82 = v46;
    uint64_t v83 = v45;
    if (v45) {
      atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&__p, v46, (uint64_t)v45);
    if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
    if (v87)
    {
      if (!*(unsigned char *)(*a3 + 620)) {
        goto LABEL_126;
      }
      if (gss::QueryableLocker<gss::PropertyID>::hasValueForKey(*((void *)__p + 3), 0x19Fu))
      {
        gss::QueryableLocker<gss::PropertyID>::value<(gss::PropertyID)415>(*((void *)__p + 3));
        goto LABEL_94;
      }
      if (!*(unsigned char *)(*a3 + 620))
      {
LABEL_126:
        if (gss::QueryableLocker<gss::PropertyID>::hasValueForKey(*((void *)__p + 3), 0x1A0u))
        {
          gss::QueryableLocker<gss::PropertyID>::value<(gss::PropertyID)416>(*((void *)__p + 3));
LABEL_94:
          float v41 = v52;
        }
      }
    }
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&__p);
  }
  uint64_t v53 = [*(id *)(*a3 + 144) routeRibbon];
  PolylineCoordinate v54 = a4;
  md::RouteLineDrawAnimation::rebuildAnimationSegments((md::RouteLineDrawAnimation *)(*a3 + 632), v53, v54);
  uint64_t v55 = *a3;
  *(unsigned char *)(v55 + 848) = 1;
  uint64_t v56 = *(void *)(v55 + 672);
  if (*(void *)(v55 + 680) == v56)
  {
    uint64_t v58 = 0;
    long long v57 = 0uLL;
  }
  else
  {
    long long v57 = *(_OWORD *)(v56 + 32);
    uint64_t v58 = *(void *)(v56 + 48);
  }
  *(void *)(v55 + 704) = 0x3FF0000000000000;
  *(_OWORD *)(v55 + 712) = 0uLL;
  *(_OWORD *)(v55 + 728) = 0uLL;
  *(void *)(v55 + 744) = 0x3FF0000000000000;
  *(_OWORD *)(v55 + 752) = 0uLL;
  *(_OWORD *)(v55 + 768) = 0uLL;
  *(_OWORD *)(v55 + 784) = xmmword_1A28FCBD0;
  *(_OWORD *)(v55 + 800) = v57;
  *(void *)(v55 + 816) = v58;
  *(void *)(v55 + 824) = 0x3FF0000000000000;
  uint64_t v59 = [[VKTimedAnimation alloc] initWithDuration:v41];
  uint64_t v60 = *(void **)(v55 + 696);
  *(void *)(v55 + 696) = v59;

  [*(id *)(v55 + 696) setTimingFunction:VKAnimationCurveLinear];
  md::RouteLineDrawAnimation::updateStyle(*a3 + 632, *(unsigned char **)(*(void *)(*a3 + 320) + 8), *(unsigned char **)(*(void *)(*a3 + 320) + 16));
  uint64_t v61 = *a3;
  uint64_t v62 = *(void *)(*a3 + 640);
  uint64_t v63 = *(void *)(v62 + 64);
  *(void *)(v63 + 24) = 0;
  uint64_t v64 = *(void *)(v61 + 232);
  *(void *)(v63 + 16) = v64;
  uint64_t v65 = *(void *)(v62 + 160);
  uint64_t v66 = *(void *)(v61 + 240);
  if (v66) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v66 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v67 = *(std::__shared_weak_count **)(v65 + 24);
  *(void *)(v65 + 16) = v64;
  *(void *)(v65 + 24) = v66;
  if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
    std::__shared_weak_count::__release_weak(v67);
  }
  uint64_t v69 = *a3;
  uint64_t v68 = (std::__shared_weak_count *)a3[1];
  if (v68) {
    atomic_fetch_add_explicit(&v68->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  v77[0] = MEMORY[0x1E4F143A8];
  v77[1] = 3321888768;
  v77[2] = ___ZN2md16RouteRenderLayer30updateRoutelineDrawinAnimationERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEN3geo18PolylineCoordinateE_block_invoke;
  v77[3] = &__block_descriptor_72_ea8_32c46_ZTSNSt3__18weak_ptrIN2md16RouteLineOverlayEEE48c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE_e8_v12__0f8l;
  v77[4] = v69;
  uint64_t v78 = v68;
  if (v68) {
    atomic_fetch_add_explicit(&v68->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v70 = *a3;
  uint64_t v71 = (std::__shared_weak_count *)a3[1];
  uint64_t v79 = *a3;
  uint64_t v80 = v71;
  if (v71)
  {
    atomic_fetch_add_explicit(&v71->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v70 = *a3;
  }
  PolylineCoordinate v81 = a4;
  [*(id *)(v70 + 696) setStepHandler:v77];
  v75[0] = MEMORY[0x1E4F143A8];
  v75[1] = 3321888768;
  v75[2] = ___ZN2md16RouteRenderLayer30updateRoutelineDrawinAnimationERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEN3geo18PolylineCoordinateE_block_invoke_11;
  v75[3] = &__block_descriptor_48_ea8_32c46_ZTSNSt3__18weak_ptrIN2md16RouteLineOverlayEEE_e8_v12__0B8l;
  v75[4] = v69;
  uint64_t v76 = v68;
  if (v68) {
    atomic_fetch_add_explicit(&v68->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  [*(id *)(*a3 + 696) setCompletionHandler:v75];
  md::AnimationRunner::runAnimation(*(md::MapEngine ***)(a1 + 88), *(VKAnimation **)(*a3 + 696));
  if (v76) {
    std::__shared_weak_count::__release_weak(v76);
  }
  unint64_t v72 = v80;
  if (v80 && !atomic_fetch_add(&v80->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v72->__on_zero_shared)(v72);
    std::__shared_weak_count::__release_weak(v72);
  }
  if (v78) {
    std::__shared_weak_count::__release_weak(v78);
  }
  if (v68) {
    std::__shared_weak_count::__release_weak(v68);
  }

  unint64_t v73 = v89;
  if (v89 && !atomic_fetch_add(&v89->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
    std::__shared_weak_count::__release_weak(v73);
  }
}

void sub_1A1FC87EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::__shared_weak_count *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,std::__shared_weak_count *a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,char a28)
{
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&a28);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v28 - 144);
  _Unwind_Resume(a1);
}

void sub_1A1FC8890(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

char **md::Ribbons::RibbonBatch<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(char **result, unsigned int a2, uint64_t a3, __n128 a4)
{
  if (*((unsigned char *)result + 2448))
  {
    uint64_t v6 = result;
    char v7 = 0;
    uint64_t v8 = result + 17;
    for (uint64_t i = 7; i != 25; ++i)
    {
      if (((a2 >> (i - 7)) & 1) != 0 && *v8)
      {
        uint64_t v10 = *(void *)&result[1][8 * i];
        *((void *)v8 - 12) = v10;
        v7 |= *(unsigned char *)(v10 + 58) == 1;
      }
      v8 += 128;
    }
    PolylineCoordinate v11 = result[303];
    uint64_t v12 = result[304];
    if (v11 == v12)
    {
      uint64_t v13 = 0;
    }
    else
    {
      uint64_t v13 = 0;
      uint64_t v55 = (long long **)(result + 290);
      uint64_t v53 = result + 17;
      PolylineCoordinate v54 = result[304];
      do
      {
        uint64_t v14 = *(void *)v11;
        if (*(unsigned char *)(*(void *)v11 + 48))
        {
          if (*(void *)(v14 + 88) != v13)
          {
            if (v13)
            {
              uint64_t v15 = ggl::Batcher::commit(v55, 0xC8u, a4);
              if (v15[1] != *v15)
              {
                uint64_t v16 = v15;
                uint64_t v17 = 0;
                uint64_t v18 = v53;
                do
                {
                  if (((a2 >> v17) & 1) != 0 && *(unsigned char *)v18)
                  {
                    long long v57 = &off_1EF55A458;
                    long long v28 = *((_OWORD *)v18 - 6);
                    long long v58 = *((_OWORD *)v18 - 7);
                    long long v59 = v28;
                    long long v29 = *((_OWORD *)v18 - 1);
                    long long v30 = *((_OWORD *)v18 - 3);
                    long long v63 = *((_OWORD *)v18 - 2);
                    long long v64 = v29;
                    long long v31 = *((_OWORD *)v18 - 4);
                    long long v60 = *((_OWORD *)v18 - 5);
                    long long v61 = v31;
                    long long v62 = v30;
                    float v32 = v6[301];
                    BOOL v19 = (char *)*((void *)v32 + 1);
                    if (v19 == v6[302])
                    {
                      float v32 = *(char **)v32;
                      if (!v32)
                      {
                        float v32 = (char *)malloc_type_malloc(120 * (void)v19 + 16, 0xB644C221uLL);
                        *(void *)float v32 = 0;
                        *((void *)v32 + 1) = 0;
                        *(void *)v6[301] = v32;
                      }
                      v6[301] = v32;
                      BOOL v19 = (char *)*((void *)v32 + 1);
                    }
                    uint64_t v20 = &v32[120 * (void)v19];
                    *((void *)v32 + 1) = v19 + 1;
                    *((void *)v20 + 2) = &off_1EF55A458;
                    long long v21 = v63;
                    long long v22 = v64;
                    long long v23 = v62;
                    *(_OWORD *)(v20 + 72) = v61;
                    long long v24 = v58;
                    long long v25 = v59;
                    *(_OWORD *)(v20 + 56) = v60;
                    *(_OWORD *)(v20 + 40) = v25;
                    *(_OWORD *)(v20 + 24) = v24;
                    *(_OWORD *)(v20 + 120) = v22;
                    *(_OWORD *)(v20 + 104) = v21;
                    *(_OWORD *)(v20 + 88) = v23;
                    *((void *)v20 + 10) = v13;
                    double v26 = *v16;
                    *((void *)v20 + 13) = *v16;
                    *((void *)v20 + 14) = (v16[1] - v26) >> 4;
                    int v56 = v17;
                    long long v57 = (void (**)(ggl::RenderItem *__hidden))(v20 + 16);
                    uint64_t v27 = *(void *)(a3 + 24);
                    if (!v27)
                    {
LABEL_43:
                      std::__throw_bad_function_call[abi:nn180100]();
                      return (char **)std::function<void ()(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(v52);
                    }
                    (*(void (**)(uint64_t, int *, void (***)(ggl::RenderItem *__hidden)))(*(void *)v27 + 48))(v27, &v56, &v57);
                  }
                  ++v17;
                  v18 += 16;
                }
                while (v17 != 18);
              }
            }
            uint64_t v14 = *(void *)v11;
            uint64_t v13 = *(void *)(*(void *)v11 + 88);
            uint64_t v12 = v54;
          }
          uint64_t v33 = 16;
          if (v7)
          {
            uint64_t v33 = 32;
            uint64_t v34 = v14 + 32;
          }
          else
          {
            uint64_t v34 = v14 + 16;
          }
          if (*(void *)(v34 + 8) != *(void *)(v14 + v33)) {
            gm::MultiRange<unsigned long>::push_back((char **)v55, (_OWORD *)v34);
          }
        }
        v11 += 8;
      }
      while (v11 != v12);
    }
    float result = ggl::Batcher::commit((long long **)v6 + 290, 0xC8u, a4);
    if (result[1] != *result)
    {
      float v35 = result;
      uint64_t v36 = 0;
      BOOL v37 = v6 + 17;
      do
      {
        if (((a2 >> v36) & 1) != 0 && *v37)
        {
          long long v57 = &off_1EF55A458;
          long long v47 = *((_OWORD *)v37 - 6);
          long long v58 = *((_OWORD *)v37 - 7);
          long long v59 = v47;
          long long v48 = *((_OWORD *)v37 - 1);
          long long v49 = *((_OWORD *)v37 - 3);
          long long v63 = *((_OWORD *)v37 - 2);
          long long v64 = v48;
          long long v50 = *((_OWORD *)v37 - 4);
          long long v60 = *((_OWORD *)v37 - 5);
          long long v61 = v50;
          long long v62 = v49;
          uint64_t v51 = v6[301];
          uint64_t v38 = (char *)*((void *)v51 + 1);
          if (v38 == v6[302])
          {
            uint64_t v51 = *(char **)v51;
            if (!v51)
            {
              uint64_t v51 = (char *)malloc_type_malloc(120 * (void)v38 + 16, 0xB644C221uLL);
              *(void *)uint64_t v51 = 0;
              *((void *)v51 + 1) = 0;
              *(void *)v6[301] = v51;
            }
            v6[301] = v51;
            uint64_t v38 = (char *)*((void *)v51 + 1);
          }
          uint64_t v39 = &v51[120 * (void)v38];
          *((void *)v51 + 1) = v38 + 1;
          *((void *)v39 + 2) = &off_1EF55A458;
          long long v40 = v63;
          long long v41 = v64;
          long long v42 = v62;
          *(_OWORD *)(v39 + 72) = v61;
          long long v43 = v58;
          long long v44 = v59;
          *(_OWORD *)(v39 + 56) = v60;
          *(_OWORD *)(v39 + 40) = v44;
          *(_OWORD *)(v39 + 24) = v43;
          *(_OWORD *)(v39 + 120) = v41;
          *(_OWORD *)(v39 + 104) = v40;
          *(_OWORD *)(v39 + 88) = v42;
          *((void *)v39 + 10) = v13;
          uint64_t v45 = *v35;
          *((void *)v39 + 13) = *v35;
          *((void *)v39 + 14) = (v35[1] - v45) >> 4;
          int v56 = v36;
          long long v57 = (void (**)(ggl::RenderItem *__hidden))(v39 + 16);
          uint64_t v46 = *(void *)(a3 + 24);
          if (!v46) {
            goto LABEL_43;
          }
          float result = (char **)(*(uint64_t (**)(uint64_t, int *, void (***)(ggl::RenderItem *__hidden)))(*(void *)v46 + 48))(v46, &v56, &v57);
        }
        ++v36;
        v37 += 128;
      }
      while (v36 != 18);
    }
  }
  return result;
}

void *std::function<void ()(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t __Block_byref_object_copy__27(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void __Block_byref_object_dispose__28(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<md::TrafficBatchKey const,std::vector<std::unique_ptr<md::CasedTrafficRibbon,mdm::TypeDeleter<md::CasedTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::CasedTrafficRibbon,mdm::TypeDeleter<md::CasedTrafficRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4)
  {
    operator delete(v4);
  }
}

uint64_t __Block_byref_object_copy__29(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void __Block_byref_object_dispose__30(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<md::TrafficBatchKey const,std::vector<std::unique_ptr<md::CasedTrafficRibbon,mdm::TypeDeleter<md::CasedTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::CasedTrafficRibbon,mdm::TypeDeleter<md::CasedTrafficRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4)
  {
    operator delete(v4);
  }
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_31(void *a1, void *a2)
{
  if (*a2) {
    uint64_t v3 = *a2 + 8;
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = *(void *)(a1[4] + 8) + 48;
  uint64_t v5 = *(void *)(a1[5] + 8) + 48;
  uint64_t v6 = a1 + 8;
  uint64_t v32 = 0;
  uint64_t v33 = &v32;
  uint64_t v34 = 0x5012000000;
  float v35 = __Block_byref_object_copy__32280;
  uint64_t v36 = __Block_byref_object_dispose__32281;
  BOOL v37 = "";
  uint64_t v38 = 0;
  uint64_t v39 = 0;
  uint64_t v7 = a1[6];
  unint64_t v8 = (std::__shared_weak_count *)a1[7];
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    float v9 = v39;
    uint64_t v38 = v7;
    uint64_t v39 = v8;
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
    }
  }
  else
  {
    uint64_t v38 = a1[6];
    uint64_t v39 = 0;
  }
  uint64_t v10 = v33;
  *((_DWORD *)v33 + 16) = 0;
  *((unsigned char *)v10 + 68) = 3;
  *((_DWORD *)v10 + 18) = 0;
  v31[0] = MEMORY[0x1E4F143A8];
  v31[1] = 3221225472;
  v31[2] = ___ZNK2md16RouteLineSection17addTrafficRibbonsERNSt3__113unordered_mapINS_15TrafficBatchKeyENS1_6vectorINS1_10unique_ptrINS_13TrafficRibbonEN3mdm11TypeDeleterIS6_EEEEN3geo12StdAllocatorISA_NS7_9AllocatorEEEEENS1_4hashIS3_EENS1_8equal_toIS3_EENS1_9allocatorINS1_4pairIKS3_SF_EEEEEERNS2_IS3_NS4_INS5_INS_18SolidTrafficRibbonENS8_ISR_EEEENSC_IST_SD_EEEESH_SJ_NSK_INSL_ISM_SV_EEEEEERKNS1_10shared_ptrIN3gss15StylesheetQueryINS11_10PropertyIDEEEEERKNS_16TrafficMeshStyleE_block_invoke;
  v31[3] = &unk_1E5A93EF8;
  v31[4] = &v32;
  v31[5] = v3;
  v31[6] = v6;
  v31[7] = v4;
  v31[8] = v5;
  PolylineCoordinate v11 = (void (**)(void, void, void, void, void))MEMORY[0x1A6239EB0](v31);
  uint64_t v12 = 0;
  uint64_t v13 = 0;
  char v14 = -1;
  while (1)
  {
    uint64_t v15 = (*(uint64_t (**)(void))(**(void **)(v3 + 72) + 24))(*(void *)(v3 + 72));
    uint64_t v16 = **(void **)(v3 + 72);
    if (v12 == v15) {
      break;
    }
    uint64_t v17 = (unsigned __int8 *)(*(uint64_t (**)(void))(v16 + 32))();
    uint64_t v18 = v17;
    if (v17[44] != v14)
    {
      uint64_t v19 = a1[6];
      uint64_t v28 = 0;
      uint64_t v29 = 0;
      uint64_t v27 = 0;
      uint64_t v30 = gss::Allocator::instance((gss::Allocator *)v17);
      if (&v27 != (uint64_t *)(v19 + 240)) {
        std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(&v27, *(void *)(v19 + 240), *(void **)(v19 + 248), (uint64_t)(*(void *)(v19 + 248) - *(void *)(v19 + 240)) >> 3);
      }
      ((void (**)(void, void, uint64_t, uint64_t, uint64_t *))v11)[2](v11, v14, v13, v12 - v13 + 1, &v27);
      if (v27)
      {
        uint64_t v28 = v27;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v30 + 40))(v30, v27, v29 - v27);
      }
      char v14 = v18[44];
      uint64_t v13 = v12;
    }
    ++v12;
  }
  uint64_t v20 = (gss::Allocator *)(*(uint64_t (**)(void))(v16 + 24))();
  uint64_t v21 = a1[6];
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  uint64_t v26 = gss::Allocator::instance(v20);
  if (&v23 != (uint64_t *)(v21 + 240)) {
    std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(&v23, *(void *)(v21 + 240), *(void **)(v21 + 248), (uint64_t)(*(void *)(v21 + 248) - *(void *)(v21 + 240)) >> 3);
  }
  ((void (**)(void, void, uint64_t, char *, uint64_t *))v11)[2](v11, v14, v13, (char *)v20 - v13, &v23);
  if (v23)
  {
    uint64_t v24 = v23;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v26 + 40))(v26, v23, v25 - v23);
  }

  _Block_object_dispose(&v32, 8);
  long long v22 = v39;
  if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v22->__on_zero_shared)(v22);
    std::__shared_weak_count::__release_weak(v22);
  }
}

void sub_1A1FC93A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,std::__shared_weak_count *a33)
{
  if (a9) {
    (*(void (**)(void))(*(void *)a12 + 40))();
  }

  _Block_object_dispose(&a26, 8);
  float v35 = a33;
  if (a33)
  {
    if (!atomic_fetch_add(&a33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }
  _Unwind_Resume(a1);
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_32()
{
}

void sub_1A1FC95FC(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10E1C4095CD5A37);
  _Unwind_Resume(a1);
}

uint64_t md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(uint64_t *a1, uint64_t *a2, uint64_t a3, __n128 a4)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (uint64_t (**)(void *))&unk_1EF579068;
  v74[0] = &unk_1EF579068;
  v74[1] = a3;
  unint64_t v75 = v74;
  if (a1 == a2) {
    return v4[4](v74);
  }
  uint64_t v5 = a1;
  do
  {
    uint64_t v6 = *v5;
    uint64_t v7 = (uint64_t)v75;
    if (!v75) {
      goto LABEL_8;
    }
    if (v75 != v74)
    {
      uint64_t v7 = (*(uint64_t (**)(void *))(*v75 + 16))(v75);
LABEL_8:
      uint64_t v77 = (void *)v7;
      goto LABEL_10;
    }
    uint64_t v77 = v76;
    (*(void (**)(void *, void *))(v74[0] + 24))(v74, v76);
LABEL_10:
    if (!*(unsigned char *)(v6 + 272)) {
      goto LABEL_66;
    }
    uint64_t v9 = *(void *)(v6 + 168);
    uint64_t v8 = *(void *)(v6 + 176);
    if (v8 != v9)
    {
      uint64_t v10 = *(void *)(v6 + 176);
      do
      {
        uint64_t v12 = *(void **)(v10 - 24);
        v10 -= 24;
        PolylineCoordinate v11 = v12;
        if (v12)
        {
          *(void *)(v8 - 16) = v11;
          operator delete(v11);
        }
        uint64_t v8 = v10;
      }
      while (v10 != v9);
    }
    *(void *)(v6 + 176) = v9;
    *(void *)(v6 + 152) = *(void *)(v6 + 144);
    uint64_t v13 = *(void **)(v6 + 224);
    if (v13)
    {
      do
      {
        if (v13[1])
        {
          unint64_t v15 = 0;
          uint64_t v16 = v13 + 2;
          uint64_t v17 = v13 + 2;
          uint64_t v18 = (void (***)(void))(v13 + 2);
          do
          {
            uint64_t v19 = (void (**)(void *))*v18;
            v18 += 15;
            (*v19)(v17);
            ++v15;
            v16 += 15;
            uint64_t v17 = v18;
          }
          while (v15 < v13[1]);
        }
        v13[1] = 0;
        uint64_t v13 = (void *)*v13;
      }
      while (v13);
      uint64_t v14 = *(void *)(v6 + 224);
    }
    else
    {
      uint64_t v14 = 0;
    }
    *(void *)(v6 + 232) = v14;
    uint64_t v20 = (uint64_t)v77;
    if (v77)
    {
      if (v77 == v76)
      {
        uint64_t v79 = v78;
        (*(void (**)(void *, void *))(v76[0] + 24))(v76, v78);
        goto LABEL_29;
      }
      uint64_t v20 = (*(uint64_t (**)(void *))(*v77 + 16))(v77);
    }
    uint64_t v79 = (void *)v20;
LABEL_29:
    if (*(unsigned char *)(v6 + 272))
    {
      if (*(unsigned char *)(v6 + 136))
      {
        uint64_t v21 = *(void *)(*(void *)(v6 + 8) + 56);
        *(void *)(v6 + 40) = v21;
        BOOL v22 = *(unsigned __int8 *)(v21 + 58) == 1;
      }
      else
      {
        BOOL v22 = 0;
      }
      uint64_t v23 = *(uint64_t **)(v6 + 248);
      uint64_t v24 = *(uint64_t **)(v6 + 256);
      if (v23 != v24)
      {
        uint64_t v25 = 0;
        while (1)
        {
          uint64_t v26 = *v23;
          if (*(unsigned char *)(*v23 + 48))
          {
            if (*(void *)(v26 + 88) != v25)
            {
              if (v25)
              {
                uint64_t v27 = ggl::Batcher::commit((long long **)(v6 + 144), 0xC8u, a4);
                if (v27[1] != *v27)
                {
                  if (*(unsigned char *)(v6 + 136))
                  {
                    uint64_t v28 = v27;
                    long long v30 = *(_OWORD *)(v6 + 24);
                    long long v29 = *(_OWORD *)(v6 + 40);
                    long long v31 = *(_OWORD *)(v6 + 56);
                    long long v32 = *(_OWORD *)(v6 + 72);
                    long long v33 = *(_OWORD *)(v6 + 88);
                    long long v34 = *(_OWORD *)(v6 + 120);
                    long long v72 = *(_OWORD *)(v6 + 104);
                    long long v73 = v34;
                    uint64_t v66 = &off_1EF55A458;
                    long long v67 = v30;
                    long long v68 = v29;
                    long long v70 = v32;
                    long long v71 = v33;
                    long long v69 = v31;
                    float v35 = *(void **)(v6 + 232);
                    uint64_t v36 = v35[1];
                    if (v36 == *(void *)(v6 + 240))
                    {
                      float v35 = (void *)*v35;
                      if (!v35)
                      {
                        float v35 = malloc_type_malloc(120 * v36 + 16, 0xB644C221uLL);
                        *float v35 = 0;
                        v35[1] = 0;
                        **(void **)(v6 + 232) = v35;
                      }
                      *(void *)(v6 + 232) = v35;
                      uint64_t v36 = v35[1];
                    }
                    BOOL v37 = &v35[15 * v36];
                    v35[1] = v36 + 1;
                    v37[2] = &off_1EF55A458;
                    long long v38 = v72;
                    long long v39 = v73;
                    long long v40 = v71;
                    *(_OWORD *)(v37 + 9) = v70;
                    long long v41 = v67;
                    long long v42 = v68;
                    *(_OWORD *)(v37 + 7) = v69;
                    *(_OWORD *)(v37 + 5) = v42;
                    *(_OWORD *)(v37 + 3) = v41;
                    *(_OWORD *)(v37 + 15) = v39;
                    *(_OWORD *)(v37 + 13) = v38;
                    *(_OWORD *)(v37 + 11) = v40;
                    v37[10] = v25;
                    long long v43 = *v28;
                    v37[13] = *v28;
                    v37[14] = (v28[1] - v43) >> 4;
                    int v65 = 0;
                    uint64_t v66 = (void (**)(ggl::RenderItem *__hidden))(v37 + 2);
                    if (!v79) {
                      goto LABEL_75;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v79 + 48))(v79, &v65, &v66);
                  }
                }
              }
              uint64_t v26 = *v23;
              uint64_t v25 = *(void *)(*v23 + 88);
            }
            uint64_t v44 = 16;
            if (v22)
            {
              uint64_t v44 = 32;
              uint64_t v45 = v26 + 32;
            }
            else
            {
              uint64_t v45 = v26 + 16;
            }
            if (*(void *)(v45 + 8) != *(void *)(v26 + v44)) {
              gm::MultiRange<unsigned long>::push_back((char **)(v6 + 144), (_OWORD *)v45);
            }
          }
          if (++v23 == v24) {
            goto LABEL_54;
          }
        }
      }
      uint64_t v25 = 0;
LABEL_54:
      uint64_t v46 = ggl::Batcher::commit((long long **)(v6 + 144), 0xC8u, a4);
      if (v46[1] != *v46 && *(unsigned char *)(v6 + 136))
      {
        long long v47 = v46;
        long long v48 = *(_OWORD *)(v6 + 40);
        long long v49 = *(_OWORD *)(v6 + 24);
        long long v50 = *(_OWORD *)(v6 + 56);
        long long v51 = *(_OWORD *)(v6 + 72);
        long long v52 = *(_OWORD *)(v6 + 88);
        long long v53 = *(_OWORD *)(v6 + 120);
        long long v72 = *(_OWORD *)(v6 + 104);
        long long v73 = v53;
        uint64_t v66 = &off_1EF55A458;
        long long v67 = v49;
        long long v68 = v48;
        long long v70 = v51;
        long long v71 = v52;
        long long v69 = v50;
        PolylineCoordinate v54 = *(void **)(v6 + 232);
        uint64_t v55 = v54[1];
        if (v55 == *(void *)(v6 + 240))
        {
          PolylineCoordinate v54 = (void *)*v54;
          if (!v54)
          {
            PolylineCoordinate v54 = malloc_type_malloc(120 * v55 + 16, 0xB644C221uLL);
            *PolylineCoordinate v54 = 0;
            v54[1] = 0;
            **(void **)(v6 + 232) = v54;
          }
          *(void *)(v6 + 232) = v54;
          uint64_t v55 = v54[1];
        }
        int v56 = &v54[15 * v55];
        v54[1] = v55 + 1;
        v56[2] = &off_1EF55A458;
        long long v57 = v72;
        long long v58 = v73;
        long long v59 = v71;
        *(_OWORD *)(v56 + 9) = v70;
        long long v60 = v67;
        long long v61 = v68;
        *(_OWORD *)(v56 + 7) = v69;
        *(_OWORD *)(v56 + 5) = v61;
        *(_OWORD *)(v56 + 3) = v60;
        *(_OWORD *)(v56 + 15) = v58;
        *(_OWORD *)(v56 + 13) = v57;
        *(_OWORD *)(v56 + 11) = v59;
        v56[10] = v25;
        long long v62 = *v47;
        v56[13] = *v47;
        v56[14] = (v47[1] - v62) >> 4;
        int v65 = 0;
        uint64_t v66 = (void (**)(ggl::RenderItem *__hidden))(v56 + 2);
        if (!v79)
        {
LABEL_75:
          std::__throw_bad_function_call[abi:nn180100]();
          __break(1u);
        }
        (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v79 + 48))(v79, &v65, &v66);
      }
    }
    if (v79 == v78)
    {
      (*(void (**)(void *))(v78[0] + 32))(v78);
    }
    else if (v79)
    {
      (*(void (**)(void))(*v79 + 40))();
    }
LABEL_66:
    if (v77 == v76)
    {
      (*(void (**)(void *))(v76[0] + 32))(v76);
    }
    else if (v77)
    {
      (*(void (**)(void))(*v77 + 40))();
    }
    ++v5;
  }
  while (v5 != a2);
  uint64_t result = (uint64_t)v75;
  if (v75 == v74)
  {
    uint64_t v4 = (uint64_t (**)(void *))v74[0];
    return v4[4](v74);
  }
  if (v75) {
    return (*(uint64_t (**)(void))(*v75 + 40))();
  }
  return result;
}

void sub_1A1FC9D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  std::function<void ()(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function((void *)(v27 - 128));
  std::function<void ()(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function((void *)(v27 - 160));
  std::function<void ()(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(&a27);
  _Unwind_Resume(a1);
}

uint64_t md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(void *a1, void *a2, uint64_t a3, __n128 a4)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (uint64_t (**)(void *))&unk_1EF579020;
  v103[0] = &unk_1EF579020;
  v103[1] = a3;
  uint64_t v104 = v103;
  if (a1 == a2) {
    return v4[4](v103);
  }
  uint64_t v5 = a1;
  do
  {
    uint64_t v6 = *v5;
    uint64_t v7 = (uint64_t)v104;
    if (!v104) {
      goto LABEL_8;
    }
    if (v104 != v103)
    {
      uint64_t v7 = (*(uint64_t (**)(void *))(*v104 + 16))(v104);
LABEL_8:
      unint64_t v106 = (void *)v7;
      goto LABEL_10;
    }
    unint64_t v106 = v105;
    (*(void (**)(void *, void *))(v103[0] + 24))(v103, v105);
LABEL_10:
    if (!*(unsigned char *)(v6 + 400)) {
      goto LABEL_83;
    }
    float32x2_t v93 = v5;
    uint64_t v9 = *(void *)(v6 + 296);
    uint64_t v8 = *(void *)(v6 + 304);
    if (v8 != v9)
    {
      uint64_t v10 = *(void *)(v6 + 304);
      do
      {
        uint64_t v12 = *(void **)(v10 - 24);
        v10 -= 24;
        PolylineCoordinate v11 = v12;
        if (v12)
        {
          *(void *)(v8 - 16) = v11;
          operator delete(v11);
        }
        uint64_t v8 = v10;
      }
      while (v10 != v9);
    }
    *(void *)(v6 + 304) = v9;
    *(void *)(v6 + 280) = *(void *)(v6 + 272);
    uint64_t v13 = *(void **)(v6 + 352);
    if (v13)
    {
      do
      {
        if (v13[1])
        {
          unint64_t v15 = 0;
          uint64_t v16 = v13 + 2;
          uint64_t v17 = v13 + 2;
          uint64_t v18 = (void (***)(void))(v13 + 2);
          do
          {
            uint64_t v19 = (void (**)(void *))*v18;
            v18 += 15;
            (*v19)(v17);
            ++v15;
            v16 += 15;
            uint64_t v17 = v18;
          }
          while (v15 < v13[1]);
        }
        v13[1] = 0;
        uint64_t v13 = (void *)*v13;
      }
      while (v13);
      uint64_t v14 = *(void *)(v6 + 352);
    }
    else
    {
      uint64_t v14 = 0;
    }
    *(void *)(v6 + 360) = v14;
    uint64_t v20 = (uint64_t)v106;
    if (!v106) {
      goto LABEL_27;
    }
    if (v106 != v105)
    {
      uint64_t v20 = (*(uint64_t (**)(void *))(*v106 + 16))(v106);
LABEL_27:
      unint64_t v108 = (void *)v20;
      goto LABEL_29;
    }
    unint64_t v108 = v107;
    (*(void (**)(void *, void *))(v105[0] + 24))(v105, v107);
LABEL_29:
    if (*(unsigned char *)(v6 + 400))
    {
      if (*(unsigned char *)(v6 + 136))
      {
        uint64_t v21 = *(void *)(*(void *)(v6 + 8) + 56);
        *(void *)(v6 + 40) = v21;
        BOOL v22 = *(unsigned __int8 *)(v21 + 58) == 1;
        if (!*(unsigned char *)(v6 + 264)) {
          goto LABEL_34;
        }
      }
      else
      {
        BOOL v22 = 0;
        if (!*(unsigned char *)(v6 + 264)) {
          goto LABEL_34;
        }
      }
      uint64_t v23 = *(void *)(*(void *)(v6 + 8) + 64);
      *(void *)(v6 + 168) = v23;
      if (*(unsigned char *)(v23 + 58) == 1) {
        BOOL v22 = 1;
      }
LABEL_34:
      uint64_t v25 = *(uint64_t **)(v6 + 376);
      uint64_t v24 = *(uint64_t **)(v6 + 384);
      if (v25 != v24)
      {
        uint64_t v26 = 0;
        while (1)
        {
          uint64_t v27 = *v25;
          if (*(unsigned char *)(*v25 + 48))
          {
            if (*(void *)(v27 + 88) != v26)
            {
              if (v26)
              {
                uint64_t v28 = ggl::Batcher::commit((long long **)(v6 + 272), 0xC8u, a4);
                if (v28[1] != *v28)
                {
                  long long v29 = v28;
                  if (*(unsigned char *)(v6 + 136))
                  {
                    long long v31 = *(_OWORD *)(v6 + 24);
                    long long v30 = *(_OWORD *)(v6 + 40);
                    long long v32 = *(_OWORD *)(v6 + 56);
                    long long v33 = *(_OWORD *)(v6 + 72);
                    long long v34 = *(_OWORD *)(v6 + 88);
                    long long v35 = *(_OWORD *)(v6 + 120);
                    long long v101 = *(_OWORD *)(v6 + 104);
                    long long v102 = v35;
                    float v95 = &off_1EF55A458;
                    long long v96 = v31;
                    long long v97 = v30;
                    long long v99 = v33;
                    long long v100 = v34;
                    long long v98 = v32;
                    uint64_t v36 = *(void **)(v6 + 360);
                    uint64_t v37 = v36[1];
                    if (v37 == *(void *)(v6 + 368))
                    {
                      uint64_t v36 = (void *)*v36;
                      if (!v36)
                      {
                        uint64_t v36 = malloc_type_malloc(120 * v37 + 16, 0xB644C221uLL);
                        *uint64_t v36 = 0;
                        v36[1] = 0;
                        **(void **)(v6 + 360) = v36;
                      }
                      *(void *)(v6 + 360) = v36;
                      uint64_t v37 = v36[1];
                    }
                    long long v38 = &v36[15 * v37];
                    v36[1] = v37 + 1;
                    v38[2] = &off_1EF55A458;
                    long long v39 = v101;
                    long long v40 = v102;
                    long long v41 = v100;
                    *(_OWORD *)(v38 + 9) = v99;
                    long long v42 = v96;
                    long long v43 = v97;
                    *(_OWORD *)(v38 + 7) = v98;
                    *(_OWORD *)(v38 + 5) = v43;
                    *(_OWORD *)(v38 + 3) = v42;
                    *(_OWORD *)(v38 + 15) = v40;
                    *(_OWORD *)(v38 + 13) = v39;
                    *(_OWORD *)(v38 + 11) = v41;
                    v38[10] = v26;
                    uint64_t v44 = *v29;
                    v38[13] = *v29;
                    v38[14] = (v29[1] - v44) >> 4;
                    int v94 = 0;
                    float v95 = (void (**)(ggl::RenderItem *__hidden))(v38 + 2);
                    if (!v108) {
                      goto LABEL_92;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v108 + 48))(v108, &v94, &v95);
                  }
                  if (*(unsigned char *)(v6 + 264))
                  {
                    float v95 = &off_1EF55A458;
                    long long v45 = *(_OWORD *)(v6 + 168);
                    long long v96 = *(_OWORD *)(v6 + 152);
                    long long v97 = v45;
                    long long v46 = *(_OWORD *)(v6 + 248);
                    long long v47 = *(_OWORD *)(v6 + 216);
                    long long v101 = *(_OWORD *)(v6 + 232);
                    long long v102 = v46;
                    long long v48 = *(_OWORD *)(v6 + 200);
                    long long v98 = *(_OWORD *)(v6 + 184);
                    long long v99 = v48;
                    long long v100 = v47;
                    long long v49 = *(void **)(v6 + 360);
                    uint64_t v50 = v49[1];
                    if (v50 == *(void *)(v6 + 368))
                    {
                      long long v49 = (void *)*v49;
                      if (!v49)
                      {
                        long long v49 = malloc_type_malloc(120 * v50 + 16, 0xB644C221uLL);
                        *long long v49 = 0;
                        v49[1] = 0;
                        **(void **)(v6 + 360) = v49;
                      }
                      *(void *)(v6 + 360) = v49;
                      uint64_t v50 = v49[1];
                    }
                    long long v51 = &v49[15 * v50];
                    v49[1] = v50 + 1;
                    v51[2] = &off_1EF55A458;
                    long long v52 = v101;
                    long long v53 = v102;
                    long long v54 = v100;
                    *(_OWORD *)(v51 + 9) = v99;
                    long long v55 = v96;
                    long long v56 = v97;
                    *(_OWORD *)(v51 + 7) = v98;
                    *(_OWORD *)(v51 + 5) = v56;
                    *(_OWORD *)(v51 + 3) = v55;
                    *(_OWORD *)(v51 + 15) = v53;
                    *(_OWORD *)(v51 + 13) = v52;
                    *(_OWORD *)(v51 + 11) = v54;
                    v51[10] = v26;
                    long long v57 = *v29;
                    v51[13] = *v29;
                    v51[14] = (v29[1] - v57) >> 4;
                    int v94 = 1;
                    float v95 = (void (**)(ggl::RenderItem *__hidden))(v51 + 2);
                    if (!v108) {
                      goto LABEL_92;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v108 + 48))(v108, &v94, &v95);
                  }
                }
              }
              uint64_t v27 = *v25;
              uint64_t v26 = *(void *)(*v25 + 88);
            }
            uint64_t v58 = 16;
            if (v22)
            {
              uint64_t v58 = 32;
              uint64_t v59 = v27 + 32;
            }
            else
            {
              uint64_t v59 = v27 + 16;
            }
            if (*(void *)(v59 + 8) != *(void *)(v27 + v58)) {
              gm::MultiRange<unsigned long>::push_back((char **)(v6 + 272), (_OWORD *)v59);
            }
          }
          if (++v25 == v24) {
            goto LABEL_64;
          }
        }
      }
      uint64_t v26 = 0;
LABEL_64:
      long long v60 = ggl::Batcher::commit((long long **)(v6 + 272), 0xC8u, a4);
      if (v60[1] != *v60)
      {
        long long v61 = v60;
        if (*(unsigned char *)(v6 + 136))
        {
          long long v62 = *(_OWORD *)(v6 + 40);
          long long v63 = *(_OWORD *)(v6 + 24);
          long long v64 = *(_OWORD *)(v6 + 56);
          long long v65 = *(_OWORD *)(v6 + 72);
          long long v66 = *(_OWORD *)(v6 + 88);
          long long v67 = *(_OWORD *)(v6 + 120);
          long long v101 = *(_OWORD *)(v6 + 104);
          long long v102 = v67;
          float v95 = &off_1EF55A458;
          long long v96 = v63;
          long long v97 = v62;
          long long v99 = v65;
          long long v100 = v66;
          long long v98 = v64;
          long long v68 = *(void **)(v6 + 360);
          uint64_t v69 = v68[1];
          if (v69 == *(void *)(v6 + 368))
          {
            long long v68 = (void *)*v68;
            if (!v68)
            {
              long long v68 = malloc_type_malloc(120 * v69 + 16, 0xB644C221uLL);
              *long long v68 = 0;
              v68[1] = 0;
              **(void **)(v6 + 360) = v68;
            }
            *(void *)(v6 + 360) = v68;
            uint64_t v69 = v68[1];
          }
          long long v70 = &v68[15 * v69];
          v68[1] = v69 + 1;
          v70[2] = &off_1EF55A458;
          long long v71 = v101;
          long long v72 = v102;
          long long v73 = v100;
          *(_OWORD *)(v70 + 9) = v99;
          long long v74 = v96;
          long long v75 = v97;
          *(_OWORD *)(v70 + 7) = v98;
          *(_OWORD *)(v70 + 5) = v75;
          *(_OWORD *)(v70 + 3) = v74;
          *(_OWORD *)(v70 + 15) = v72;
          *(_OWORD *)(v70 + 13) = v71;
          *(_OWORD *)(v70 + 11) = v73;
          v70[10] = v26;
          uint64_t v76 = *v61;
          v70[13] = *v61;
          v70[14] = (v61[1] - v76) >> 4;
          int v94 = 0;
          float v95 = (void (**)(ggl::RenderItem *__hidden))(v70 + 2);
          if (!v108)
          {
LABEL_92:
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v108 + 48))(v108, &v94, &v95);
        }
        if (*(unsigned char *)(v6 + 264))
        {
          float v95 = &off_1EF55A458;
          long long v77 = *(_OWORD *)(v6 + 168);
          long long v96 = *(_OWORD *)(v6 + 152);
          long long v97 = v77;
          long long v78 = *(_OWORD *)(v6 + 184);
          long long v79 = *(_OWORD *)(v6 + 248);
          long long v80 = *(_OWORD *)(v6 + 216);
          long long v101 = *(_OWORD *)(v6 + 232);
          long long v102 = v79;
          long long v81 = *(_OWORD *)(v6 + 200);
          long long v98 = v78;
          long long v99 = v81;
          long long v100 = v80;
          uint64_t v82 = *(void **)(v6 + 360);
          uint64_t v83 = v82[1];
          if (v83 == *(void *)(v6 + 368))
          {
            uint64_t v82 = (void *)*v82;
            if (!v82)
            {
              uint64_t v82 = malloc_type_malloc(120 * v83 + 16, 0xB644C221uLL);
              *uint64_t v82 = 0;
              v82[1] = 0;
              **(void **)(v6 + 360) = v82;
            }
            *(void *)(v6 + 360) = v82;
            uint64_t v83 = v82[1];
          }
          uint64_t v84 = &v82[15 * v83];
          v82[1] = v83 + 1;
          v84[2] = &off_1EF55A458;
          long long v85 = v101;
          long long v86 = v102;
          long long v87 = v100;
          *(_OWORD *)(v84 + 9) = v99;
          long long v88 = v96;
          long long v89 = v97;
          *(_OWORD *)(v84 + 7) = v98;
          *(_OWORD *)(v84 + 5) = v89;
          *(_OWORD *)(v84 + 3) = v88;
          *(_OWORD *)(v84 + 15) = v86;
          *(_OWORD *)(v84 + 13) = v85;
          *(_OWORD *)(v84 + 11) = v87;
          v84[10] = v26;
          unint64_t v90 = *v61;
          v84[13] = *v61;
          v84[14] = (v61[1] - v90) >> 4;
          int v94 = 1;
          float v95 = (void (**)(ggl::RenderItem *__hidden))(v84 + 2);
          if (!v108) {
            goto LABEL_92;
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v108 + 48))(v108, &v94, &v95);
        }
      }
    }
    if (v108 == v107)
    {
      (*(void (**)(void *))(v107[0] + 32))(v107);
      uint64_t v5 = v93;
    }
    else
    {
      uint64_t v5 = v93;
      if (v108) {
        (*(void (**)(void))(*v108 + 40))();
      }
    }
LABEL_83:
    if (v106 == v105)
    {
      (*(void (**)(void *))(v105[0] + 32))(v105);
    }
    else if (v106)
    {
      (*(void (**)(void))(*v106 + 40))();
    }
    ++v5;
  }
  while (v5 != a2);
  uint64_t result = (uint64_t)v104;
  if (v104 == v103)
  {
    uint64_t v4 = (uint64_t (**)(void *))v103[0];
    return v4[4](v103);
  }
  if (v104) {
    return (*(uint64_t (**)(void))(*v104 + 40))();
  }
  return result;
}

void sub_1A1FCA79C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  std::function<void ()(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function((void *)(v27 - 128));
  std::function<void ()(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function((void *)(v27 - 160));
  std::function<void ()(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(&a27);
  _Unwind_Resume(a1);
}

void md::TrafficContext::~TrafficContext(md::TrafficContext *this)
{
  uint64_t v1 = (std::__shared_weak_count *)*((void *)this + 15);
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_35(uint64_t a1, float a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  *(float *)(*(void *)(a1 + 40) + 528) = *(float *)(a1 + 56)
                                           + (float)((float)((float)*(unint64_t *)(*(void *)(a1 + 40) + 520)
                                                           - *(float *)(a1 + 56))
                                                   * a2);
  uint64_t v3 = **(void **)(*(void *)(v2 + 40) + 88);
  if (v3)
  {
    char v4 = 7;
    md::MapEngine::setNeedsTick(v3, &v4);
  }
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_37(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  *(float *)(v1 + 528) = (float)*(unint64_t *)(v1 + 520);
  uint64_t v3 = *(void **)(v1 + 192);
  *(void *)(v1 + 192) = 0;

  uint64_t v4 = **(void **)(*(void *)(v2 + 40) + 88);
  if (v4)
  {
    char v5 = 7;
    md::MapEngine::setNeedsTick(v4, &v5);
  }
}

uint64_t md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(uint64_t *a1, uint64_t *a2, uint64_t a3, __n128 a4)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (uint64_t (**)(void *))&unk_1EF5790F8;
  v74[0] = &unk_1EF5790F8;
  v74[1] = a3;
  long long v75 = v74;
  if (a1 == a2) {
    return v4[4](v74);
  }
  char v5 = a1;
  do
  {
    uint64_t v6 = *v5;
    uint64_t v7 = (uint64_t)v75;
    if (!v75) {
      goto LABEL_8;
    }
    if (v75 != v74)
    {
      uint64_t v7 = (*(uint64_t (**)(void *))(*v75 + 16))(v75);
LABEL_8:
      long long v77 = (void *)v7;
      goto LABEL_10;
    }
    long long v77 = v76;
    (*(void (**)(void *, void *))(v74[0] + 24))(v74, v76);
LABEL_10:
    if (!*(unsigned char *)(v6 + 272)) {
      goto LABEL_66;
    }
    uint64_t v9 = *(void *)(v6 + 168);
    uint64_t v8 = *(void *)(v6 + 176);
    if (v8 != v9)
    {
      uint64_t v10 = *(void *)(v6 + 176);
      do
      {
        uint64_t v12 = *(void **)(v10 - 24);
        v10 -= 24;
        PolylineCoordinate v11 = v12;
        if (v12)
        {
          *(void *)(v8 - 16) = v11;
          operator delete(v11);
        }
        uint64_t v8 = v10;
      }
      while (v10 != v9);
    }
    *(void *)(v6 + 176) = v9;
    *(void *)(v6 + 152) = *(void *)(v6 + 144);
    uint64_t v13 = *(void **)(v6 + 224);
    if (v13)
    {
      do
      {
        if (v13[1])
        {
          unint64_t v15 = 0;
          uint64_t v16 = v13 + 2;
          uint64_t v17 = v13 + 2;
          uint64_t v18 = (void (***)(void))(v13 + 2);
          do
          {
            uint64_t v19 = (void (**)(void *))*v18;
            v18 += 15;
            (*v19)(v17);
            ++v15;
            v16 += 15;
            uint64_t v17 = v18;
          }
          while (v15 < v13[1]);
        }
        v13[1] = 0;
        uint64_t v13 = (void *)*v13;
      }
      while (v13);
      uint64_t v14 = *(void *)(v6 + 224);
    }
    else
    {
      uint64_t v14 = 0;
    }
    *(void *)(v6 + 232) = v14;
    uint64_t v20 = (uint64_t)v77;
    if (v77)
    {
      if (v77 == v76)
      {
        long long v79 = v78;
        (*(void (**)(void *, void *))(v76[0] + 24))(v76, v78);
        goto LABEL_29;
      }
      uint64_t v20 = (*(uint64_t (**)(void *))(*v77 + 16))(v77);
    }
    long long v79 = (void *)v20;
LABEL_29:
    if (*(unsigned char *)(v6 + 272))
    {
      if (*(unsigned char *)(v6 + 136))
      {
        uint64_t v21 = *(void *)(*(void *)(v6 + 8) + 56);
        *(void *)(v6 + 40) = v21;
        BOOL v22 = *(unsigned __int8 *)(v21 + 58) == 1;
      }
      else
      {
        BOOL v22 = 0;
      }
      uint64_t v23 = *(uint64_t **)(v6 + 248);
      uint64_t v24 = *(uint64_t **)(v6 + 256);
      if (v23 != v24)
      {
        uint64_t v25 = 0;
        while (1)
        {
          uint64_t v26 = *v23;
          if (*(unsigned char *)(*v23 + 48))
          {
            if (*(void *)(v26 + 88) != v25)
            {
              if (v25)
              {
                uint64_t v27 = ggl::Batcher::commit((long long **)(v6 + 144), 0xC8u, a4);
                if (v27[1] != *v27)
                {
                  if (*(unsigned char *)(v6 + 136))
                  {
                    uint64_t v28 = v27;
                    long long v30 = *(_OWORD *)(v6 + 24);
                    long long v29 = *(_OWORD *)(v6 + 40);
                    long long v31 = *(_OWORD *)(v6 + 56);
                    long long v32 = *(_OWORD *)(v6 + 72);
                    long long v33 = *(_OWORD *)(v6 + 88);
                    long long v34 = *(_OWORD *)(v6 + 120);
                    long long v72 = *(_OWORD *)(v6 + 104);
                    long long v73 = v34;
                    long long v66 = &off_1EF55A458;
                    long long v67 = v30;
                    long long v68 = v29;
                    long long v70 = v32;
                    long long v71 = v33;
                    long long v69 = v31;
                    long long v35 = *(void **)(v6 + 232);
                    uint64_t v36 = v35[1];
                    if (v36 == *(void *)(v6 + 240))
                    {
                      long long v35 = (void *)*v35;
                      if (!v35)
                      {
                        long long v35 = malloc_type_malloc(120 * v36 + 16, 0xB644C221uLL);
                        *long long v35 = 0;
                        v35[1] = 0;
                        **(void **)(v6 + 232) = v35;
                      }
                      *(void *)(v6 + 232) = v35;
                      uint64_t v36 = v35[1];
                    }
                    uint64_t v37 = &v35[15 * v36];
                    v35[1] = v36 + 1;
                    v37[2] = &off_1EF55A458;
                    long long v38 = v72;
                    long long v39 = v73;
                    long long v40 = v71;
                    *(_OWORD *)(v37 + 9) = v70;
                    long long v41 = v67;
                    long long v42 = v68;
                    *(_OWORD *)(v37 + 7) = v69;
                    *(_OWORD *)(v37 + 5) = v42;
                    *(_OWORD *)(v37 + 3) = v41;
                    *(_OWORD *)(v37 + 15) = v39;
                    *(_OWORD *)(v37 + 13) = v38;
                    *(_OWORD *)(v37 + 11) = v40;
                    v37[10] = v25;
                    long long v43 = *v28;
                    v37[13] = *v28;
                    v37[14] = (v28[1] - v43) >> 4;
                    int v65 = 0;
                    long long v66 = (void (**)(ggl::RenderItem *__hidden))(v37 + 2);
                    if (!v79) {
                      goto LABEL_75;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v79 + 48))(v79, &v65, &v66);
                  }
                }
              }
              uint64_t v26 = *v23;
              uint64_t v25 = *(void *)(*v23 + 88);
            }
            uint64_t v44 = 16;
            if (v22)
            {
              uint64_t v44 = 32;
              uint64_t v45 = v26 + 32;
            }
            else
            {
              uint64_t v45 = v26 + 16;
            }
            if (*(void *)(v45 + 8) != *(void *)(v26 + v44)) {
              gm::MultiRange<unsigned long>::push_back((char **)(v6 + 144), (_OWORD *)v45);
            }
          }
          if (++v23 == v24) {
            goto LABEL_54;
          }
        }
      }
      uint64_t v25 = 0;
LABEL_54:
      long long v46 = ggl::Batcher::commit((long long **)(v6 + 144), 0xC8u, a4);
      if (v46[1] != *v46 && *(unsigned char *)(v6 + 136))
      {
        long long v47 = v46;
        long long v48 = *(_OWORD *)(v6 + 40);
        long long v49 = *(_OWORD *)(v6 + 24);
        long long v50 = *(_OWORD *)(v6 + 56);
        long long v51 = *(_OWORD *)(v6 + 72);
        long long v52 = *(_OWORD *)(v6 + 88);
        long long v53 = *(_OWORD *)(v6 + 120);
        long long v72 = *(_OWORD *)(v6 + 104);
        long long v73 = v53;
        long long v66 = &off_1EF55A458;
        long long v67 = v49;
        long long v68 = v48;
        long long v70 = v51;
        long long v71 = v52;
        long long v69 = v50;
        long long v54 = *(void **)(v6 + 232);
        uint64_t v55 = v54[1];
        if (v55 == *(void *)(v6 + 240))
        {
          long long v54 = (void *)*v54;
          if (!v54)
          {
            long long v54 = malloc_type_malloc(120 * v55 + 16, 0xB644C221uLL);
            *long long v54 = 0;
            v54[1] = 0;
            **(void **)(v6 + 232) = v54;
          }
          *(void *)(v6 + 232) = v54;
          uint64_t v55 = v54[1];
        }
        long long v56 = &v54[15 * v55];
        v54[1] = v55 + 1;
        v56[2] = &off_1EF55A458;
        long long v57 = v72;
        long long v58 = v73;
        long long v59 = v71;
        *(_OWORD *)(v56 + 9) = v70;
        long long v60 = v67;
        long long v61 = v68;
        *(_OWORD *)(v56 + 7) = v69;
        *(_OWORD *)(v56 + 5) = v61;
        *(_OWORD *)(v56 + 3) = v60;
        *(_OWORD *)(v56 + 15) = v58;
        *(_OWORD *)(v56 + 13) = v57;
        *(_OWORD *)(v56 + 11) = v59;
        v56[10] = v25;
        long long v62 = *v47;
        v56[13] = *v47;
        v56[14] = (v47[1] - v62) >> 4;
        int v65 = 0;
        long long v66 = (void (**)(ggl::RenderItem *__hidden))(v56 + 2);
        if (!v79)
        {
LABEL_75:
          std::__throw_bad_function_call[abi:nn180100]();
          __break(1u);
        }
        (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v79 + 48))(v79, &v65, &v66);
      }
    }
    if (v79 == v78)
    {
      (*(void (**)(void *))(v78[0] + 32))(v78);
    }
    else if (v79)
    {
      (*(void (**)(void))(*v79 + 40))();
    }
LABEL_66:
    if (v77 == v76)
    {
      (*(void (**)(void *))(v76[0] + 32))(v76);
    }
    else if (v77)
    {
      (*(void (**)(void))(*v77 + 40))();
    }
    ++v5;
  }
  while (v5 != a2);
  uint64_t result = (uint64_t)v75;
  if (v75 == v74)
  {
    uint64_t v4 = (uint64_t (**)(void *))v74[0];
    return v4[4](v74);
  }
  if (v75) {
    return (*(uint64_t (**)(void))(*v75 + 40))();
  }
  return result;
}

void sub_1A1FCB028(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  std::function<void ()(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)>::~function((void *)(v27 - 128));
  std::function<void ()(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)>::~function((void *)(v27 - 160));
  std::function<void ()(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(&a27);
  _Unwind_Resume(a1);
}

void md::RouteLineArrowContext::~RouteLineArrowContext(id *this)
{
  uint64_t v2 = (std::__shared_weak_count *)this[21];
  if (v2)
  {
    if (!atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
}

void ___ZN2md16RouteRenderLayer13layoutOverlayERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEbPN3ggl13CommandBufferE_block_invoke_41()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A1FCBFAC(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void **)(v2 - 152);
  if (v4)
  {
    *(void *)(v2 - 144) = v4;
    operator delete(v4);
  }
  MEMORY[0x1A6239270](v1, 0x1020C40A59E487DLL);
  _Unwind_Resume(a1);
}

void *std::function<void ()(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void md::RouteRenderLayer::layoutDebugRouteLinePoints(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a2;
  v251[26] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = *(uint64_t **)(*a2 + 400);
  if (!v7)
  {
    long long v59 = *(std::__shared_weak_count **)(a3 + 424);
    v251[0] = *(void *)(a3 + 416);
    v251[1] = v59;
    if (v59) {
      atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)&v237[24] = 0;
    v238.f64[0] = 0.0;
    LODWORD(v238.f64[1]) = 0;
    v237[0] = 1;
    *(_OWORD *)&v237[4] = xmmword_1A28FCEE0;
    *(_DWORD *)&v237[20] = 7;
    BYTE4(v238.f64[1]) = 15;
    id v60 = *(id *)(*(void *)(a1 + 40) + 104);
    long long v61 = (long long *)[v60 format];
    long long v62 = (char *)operator new(0x198uLL);
    *((void *)v62 + 1) = 0;
    *((void *)v62 + 2) = 0;
    *(void *)long long v62 = &unk_1EF5890B8;
    long long v244 = *v61;
    long long v245 = v61[1];
    std::string __p = (void *)ggl::Debug::ExtendedPipelineState::ExtendedPipelineState((uint64_t)(v62 + 24), v251, (uint64_t)v237, &v244);
    uint64_t v249 = v62;

    if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
      std::__shared_weak_count::__release_weak(v59);
    }
    operator new();
  }
  uint64_t v8 = (uint64_t *)v7[4];
  uint64_t v9 = (uint64_t *)v7[5];
  if (v8 != v9)
  {
    uint64_t v10 = (void *)v7[1];
    while (1)
    {
      uint64_t v11 = *v8;
      unint64_t v12 = v7[2];
      if ((unint64_t)v10 >= v12) {
        break;
      }
      if (v10) {
        *uint64_t v10 = v11;
      }
      ++v10;
LABEL_5:
      v7[1] = (uint64_t)v10;
      if (++v8 == v9)
      {
        uint64_t v32 = v7[4];
        uint64_t v6 = a2;
        if (v32 != v7[5]) {
          void v7[5] = v32;
        }
        goto LABEL_34;
      }
    }
    uint64_t v13 = ((uint64_t)v10 - *v7) >> 3;
    if ((unint64_t)(v13 + 1) >> 61) {
LABEL_298:
    }
      abort();
    uint64_t v14 = v12 - *v7;
    uint64_t v15 = v14 >> 2;
    if (v14 >> 2 <= (unint64_t)(v13 + 1)) {
      uint64_t v15 = v13 + 1;
    }
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v16 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v16 = v15;
    }
    if (v16)
    {
      uint64_t v17 = 8 * v16;
      uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[3] + 16))(v7[3], 8 * v16, 8);
      uint64_t v19 = (void *)(v18 + 8 * v13);
      uint64_t v16 = v18 + v17;
      if (v18) {
        *uint64_t v19 = v11;
      }
    }
    else
    {
      uint64_t v19 = (void *)(8 * v13);
    }
    uint64_t v21 = *v7;
    uint64_t v20 = v7[1];
    uint64_t v22 = v20 - *v7;
    if (v20 == *v7)
    {
      uint64_t v24 = v19;
      goto LABEL_30;
    }
    unint64_t v23 = v22 - 8;
    if ((unint64_t)(v22 - 8) < 0x38)
    {
      uint64_t v24 = v19;
    }
    else
    {
      uint64_t v24 = v19;
      if ((unint64_t)(v20 - (void)v19) >= 0x20)
      {
        uint64_t v25 = (v23 >> 3) + 1;
        uint64_t v26 = v19 - 2;
        uint64_t v27 = (long long *)(v20 - 16);
        uint64_t v28 = v25 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *(v26 - 1) = *(v27 - 1);
          *uint64_t v26 = v29;
          v26 -= 2;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        uint64_t v24 = &v19[-(v25 & 0x3FFFFFFFFFFFFFFCLL)];
        v20 -= 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL);
        if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_29;
        }
      }
    }
    do
    {
      uint64_t v30 = *(void *)(v20 - 8);
      v20 -= 8;
      *--uint64_t v24 = v30;
    }
    while (v20 != v21);
LABEL_29:
    uint64_t v20 = *v7;
LABEL_30:
    uint64_t v10 = v19 + 1;
    *uint64_t v7 = (uint64_t)v24;
    v7[1] = (uint64_t)(v19 + 1);
    uint64_t v31 = v7[2];
    uint64_t v7[2] = v16;
    if (v20) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7[3] + 40))(v7[3], v20, v31 - v20);
    }
    goto LABEL_5;
  }
LABEL_34:
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(*v6 + 408));
  long long v33 = *(uint64_t **)(*v6 + 416);
  long long v34 = (uint64_t *)v33[4];
  long long v35 = (uint64_t *)v33[5];
  if (v34 == v35) {
    goto LABEL_72;
  }
  uint64_t v36 = (void *)v33[1];
  do
  {
    uint64_t v37 = *v34;
    unint64_t v38 = v33[2];
    if ((unint64_t)v36 < v38)
    {
      if (v36) {
        *uint64_t v36 = v37;
      }
      ++v36;
      goto LABEL_37;
    }
    uint64_t v39 = ((uint64_t)v36 - *v33) >> 3;
    if ((unint64_t)(v39 + 1) >> 61) {
      goto LABEL_298;
    }
    uint64_t v40 = v38 - *v33;
    uint64_t v41 = v40 >> 2;
    if (v40 >> 2 <= (unint64_t)(v39 + 1)) {
      uint64_t v41 = v39 + 1;
    }
    if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v42 = v41;
    }
    if (v42)
    {
      uint64_t v43 = 8 * v42;
      uint64_t v44 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v33[3] + 16))(v33[3], 8 * v42, 8);
      uint64_t v45 = (void *)(v44 + 8 * v39);
      uint64_t v42 = v44 + v43;
      if (v44) {
        void *v45 = v37;
      }
    }
    else
    {
      uint64_t v45 = (void *)(8 * v39);
    }
    uint64_t v47 = *v33;
    uint64_t v46 = v33[1];
    uint64_t v48 = v46 - *v33;
    if (v46 == *v33)
    {
      long long v50 = v45;
      goto LABEL_62;
    }
    unint64_t v49 = v48 - 8;
    if ((unint64_t)(v48 - 8) < 0x38)
    {
      long long v50 = v45;
    }
    else
    {
      long long v50 = v45;
      if ((unint64_t)(v46 - (void)v45) >= 0x20)
      {
        uint64_t v51 = (v49 >> 3) + 1;
        long long v52 = v45 - 2;
        long long v53 = (long long *)(v46 - 16);
        uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v55 = *v53;
          *(v52 - 1) = *(v53 - 1);
          *long long v52 = v55;
          v52 -= 2;
          v53 -= 2;
          v54 -= 4;
        }
        while (v54);
        long long v50 = &v45[-(v51 & 0x3FFFFFFFFFFFFFFCLL)];
        v46 -= 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
        if (v51 == (v51 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_61;
        }
      }
    }
    do
    {
      uint64_t v56 = *(void *)(v46 - 8);
      v46 -= 8;
      *--long long v50 = v56;
    }
    while (v46 != v47);
LABEL_61:
    uint64_t v46 = *v33;
LABEL_62:
    uint64_t v36 = v45 + 1;
    *long long v33 = (uint64_t)v50;
    v33[1] = (uint64_t)(v45 + 1);
    uint64_t v57 = v33[2];
    v33[2] = v42;
    if (v46) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v33[3] + 40))(v33[3], v46, v57 - v46);
    }
LABEL_37:
    v33[1] = (uint64_t)v36;
    ++v34;
  }
  while (v34 != v35);
  uint64_t v58 = v33[4];
  uint64_t v6 = a2;
  if (v58 != v33[5]) {
    v33[5] = v58;
  }
LABEL_72:
  long long v63 = *(void **)(a4 + 8);
  int8x8_t v64 = (int8x8_t)v63[1];
  if (!*(void *)&v64) {
    goto LABEL_95;
  }
  uint8x8_t v65 = (uint8x8_t)vcnt_s8(v64);
  v65.i16[0] = vaddlv_u8(v65);
  if (v65.u32[0] > 1uLL)
  {
    uint64_t v66 = 0x1AF456233693CD46;
    if (*(void *)&v64 <= 0x1AF456233693CD46uLL) {
      uint64_t v66 = 0x1AF456233693CD46uLL % *(void *)&v64;
    }
  }
  else
  {
    uint64_t v66 = (*(void *)&v64 - 1) & 0x1AF456233693CD46;
  }
  long long v67 = *(void **)(*v63 + 8 * v66);
  if (!v67) {
    goto LABEL_95;
  }
  long long v68 = (void *)*v67;
  if (!v68) {
    goto LABEL_95;
  }
  if (v65.u32[0] < 2uLL)
  {
    uint64_t v69 = *(void *)&v64 - 1;
    while (1)
    {
      uint64_t v71 = v68[1];
      if (v71 == 0x1AF456233693CD46)
      {
        if (v68[2] == 0x1AF456233693CD46) {
          goto LABEL_93;
        }
      }
      else if ((v71 & v69) != v66)
      {
        goto LABEL_95;
      }
      long long v68 = (void *)*v68;
      if (!v68) {
        goto LABEL_95;
      }
    }
  }
  while (2)
  {
    unint64_t v70 = v68[1];
    if (v70 != 0x1AF456233693CD46)
    {
      if (v70 >= *(void *)&v64) {
        v70 %= *(void *)&v64;
      }
      if (v70 != v66) {
        goto LABEL_95;
      }
      goto LABEL_82;
    }
    if (v68[2] != 0x1AF456233693CD46)
    {
LABEL_82:
      long long v68 = (void *)*v68;
      if (!v68) {
        goto LABEL_95;
      }
      continue;
    }
    break;
  }
LABEL_93:
  uint64_t v72 = v68[5];
  if (*(void *)(v72 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v221 = *(void *)(v72 + 32);
    goto LABEL_96;
  }
LABEL_95:
  uint64_t v221 = 0;
LABEL_96:
  long long v73 = *(void **)(*v6 + 160);
  if (v73)
  {
    [v73 sections];
  }
  else
  {
    std::string __p = 0;
    uint64_t v249 = 0;
    uint64_t v250 = 0;
  }
  {
    operator new();
  }
  uint64_t v230 = mdm::Allocator::instance(void)::alloc;
  {
    operator new();
  }
  uint64_t v229 = mdm::Allocator::instance(void)::alloc;
  long long v74 = +[VKDebugSettings sharedSettings];
  uint64_t v233 = [v74 routeDebugPoints];

  long long v75 = __p;
  uint64_t v76 = v249;
  if (v249 == __p) {
    goto LABEL_282;
  }
  uint64_t v77 = 0;
  long long v78 = 0;
  long long v79 = 0;
  uint64_t v80 = 0;
  unint64_t v235 = 0;
  unint64_t v236 = 0;
  long long v81 = 0;
  __asm { FMOV            V0.4S, #1.0 }
  int32x4_t v224 = _Q0;
  while (2)
  {
    uint64_t v227 = v77;
    uint64_t v85 = v75[v77];
    if (v85) {
      uint64_t v86 = v85 + 8;
    }
    else {
      uint64_t v86 = 0;
    }
    uint64_t v87 = *a2;
    id WeakRetained = objc_loadWeakRetained((id *)(v86 + 200));
    long long v89 = (void *)(v87 + 440);
    unint64_t v90 = *(void **)(v87 + 440);
    if (!v90) {
      goto LABEL_118;
    }
    uint64_t v91 = (void *)(v87 + 440);
    do
    {
      unint64_t v92 = v90[4];
      _CF = v92 >= (unint64_t)WeakRetained;
      if (v92 >= (unint64_t)WeakRetained) {
        int v94 = v90;
      }
      else {
        int v94 = v90 + 1;
      }
      if (_CF) {
        uint64_t v91 = v90;
      }
      unint64_t v90 = (void *)*v94;
    }
    while (*v94);
    if (v91 == v89 || (unint64_t)WeakRetained < v91[4]) {
LABEL_118:
    }
      uint64_t v91 = v89;

    if (v91 != (void *)(*a2 + 440))
    {
      unint64_t v95 = 0;
      _ZF = (v227 & 1) != 0 && v233 == 1;
      if (_ZF) {
        float v97 = 0.0;
      }
      else {
        float v97 = 1.0;
      }
      uint64_t v98 = v91[5];
      int32x4_t v99 = v224;
      *(float *)v99.i32 = v97;
      int32x4_t v100 = vzip1q_s32(v99, v99);
      *(float *)&v100.i32[2] = v97;
      int32x4_t v231 = v100;
      while (1)
      {
        while (1)
        {
LABEL_128:
          if ((*(uint64_t (**)(uint64_t))(*(void *)v98 + 32))(v98) <= v95) {
            goto LABEL_103;
          }
          long long v101 = (float *)(*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v98 + 16))(v98, v95);
          int v102 = (*(uint64_t (**)(uint64_t, unint64_t))(*(void *)v98 + 24))(v98, v95);
          unint64_t v103 = v80;
          float v104 = *v101;
          float v105 = v101[1];
          float v106 = v101[2];
          if (v233 != 1) {
            break;
          }
          uint64_t v107 = (char *)v79 - (char *)v78;
          if (v79 == v78) {
            break;
          }
          unint64_t v108 = +[VKDebugSettings sharedSettings];
          int v109 = [v108 continuousMultiSectionRouteAdditionalOverlap];

          uint64_t v110 = v107 >> 5;
          LODWORD(v111) = v109 + 2;
          unsigned int v112 = (v107 >> 5) - 1;
          uint64_t v111 = v112 >= v109 + 2 ? v111 : v112;
          if (!v111) {
            break;
          }
          uint64_t v113 = v110 - 1;
          uint64_t v114 = 32 * v110 - 32;
          while (vabds_f32(v104, *(float *)((char *)v78 + v114)) >= 0.000001
               || vabds_f32(v105, *(float *)((char *)v78 + v114 + 4)) >= 0.000001
               || vabds_f32(v106, *(float *)((char *)v78 + v114 + 8)) >= 0.000001)
          {
            --v113;
            v114 -= 32;
            if (!--v111) {
              goto LABEL_143;
            }
          }
          double v115 = &v78[8 * v113];
          *((_OWORD *)v115 + 1) = xmmword_1A28FC6C0;
          unint64_t v116 = v115 + 4;
          if (*(unsigned __int8 *)(v235 + v113) != v102) {
            v116[1] = 1.0;
          }
          uint64_t v80 = v103;
          ++v95;
        }
LABEL_143:
        uint64_t v80 = v103;
        if ((unint64_t)v79 >= v103) {
          break;
        }
        if (v79)
        {
          *(_OWORD *)long long v79 = 0u;
          *((_OWORD *)v79 + 1) = 0u;
        }
        v79 += 8;
LABEL_162:
        *(v79 - 8) = v104;
        *(v79 - 7) = v105;
        *(v79 - 6) = v106;
        *((int32x4_t *)v79 - 1) = v231;
        if ((unint64_t)v81 >= v236)
        {
          unint64_t v125 = (unint64_t)&v81[-v235];
          uint64_t v126 = (uint64_t)&v81[-v235 + 1];
          if (v126 < 0) {
            abort();
          }
          unint64_t v127 = v236 - v235;
          if (2 * (v236 - v235) > v126) {
            uint64_t v126 = 2 * v127;
          }
          if (v127 >= 0x3FFFFFFFFFFFFFFFLL) {
            uint64_t v128 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v128 = v126;
          }
          if (v128)
          {
            uint64_t v129 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v229 + 16))(v229, v128, 1);
            unint64_t v130 = (unsigned char *)(v129 + v125);
            v128 += v129;
            if (v129) {
              *unint64_t v130 = v102;
            }
          }
          else
          {
            unint64_t v130 = &v81[-v235];
          }
          if (v81 != (unsigned char *)v235)
          {
            if (v125 < 0x30
              || &v130[v235 - (void)v81] > v130 - 1
              || v235 > (unint64_t)(v81 - 1)
              || (unint64_t)(v81 - v130) < 0x20)
            {
              int8x8_t v131 = v81;
              uint8x8_t v132 = v130;
            }
            else
            {
              int8x8_t v131 = &v81[-(v125 & 0xFFFFFFFFFFFFFFE0)];
              uint64_t v135 = v130 - 16;
              uint64_t v136 = (long long *)(v81 - 16);
              unint64_t v137 = v125 & 0xFFFFFFFFFFFFFFE0;
              do
              {
                long long v138 = *v136;
                *(v135 - 1) = *(v136 - 1);
                *uint64_t v135 = v138;
                v135 -= 2;
                v136 -= 2;
                v137 -= 32;
              }
              while (v137);
              uint8x8_t v132 = &v130[-(v125 & 0xFFFFFFFFFFFFFFE0)];
              if (v125 == (v125 & 0xFFFFFFFFFFFFFFE0))
              {
                unint64_t v133 = (unsigned char *)v235;
                long long v81 = v130 + 1;
                if (!v235) {
                  goto LABEL_184;
                }
LABEL_183:
                (*(void (**)(uint64_t, unsigned char *, unint64_t))(*(void *)v229 + 40))(v229, v133, v236 - (void)v133);
LABEL_184:
                unint64_t v235 = (unint64_t)v132;
                unint64_t v236 = v128;
                ++v95;
                goto LABEL_128;
              }
            }
            unint64_t v133 = (unsigned char *)v235;
            do
            {
              char v134 = *--v131;
              *--uint8x8_t v132 = v134;
            }
            while (v131 != (unsigned char *)v235);
            long long v81 = v130 + 1;
            if (!v235) {
              goto LABEL_184;
            }
            goto LABEL_183;
          }
          uint8x8_t v132 = v130;
          unint64_t v133 = v81;
          long long v81 = v130 + 1;
          if (v133) {
            goto LABEL_183;
          }
          goto LABEL_184;
        }
        if (v81) {
          unsigned char *v81 = v102;
        }
        ++v81;
        ++v95;
      }
      uint64_t v117 = ((char *)v79 - (char *)v78) >> 5;
      unint64_t v118 = v117 + 1;
      if ((unint64_t)(v117 + 1) >> 59) {
        abort();
      }
      if ((uint64_t)(v103 - (void)v78) >> 4 > v118) {
        unint64_t v118 = (uint64_t)(v103 - (void)v78) >> 4;
      }
      if (v103 - (unint64_t)v78 >= 0x7FFFFFFFFFFFFFE0) {
        uint64_t v119 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v119 = v118;
      }
      if (v119)
      {
        uint64_t v120 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v230 + 16))(v230, 32 * v119, 16);
        uint64_t v121 = (_OWORD *)(v120 + 32 * v117);
        uint64_t v119 = v120 + 32 * v119;
        if (v120)
        {
          *uint64_t v121 = 0u;
          v121[1] = 0u;
        }
      }
      else
      {
        uint64_t v121 = (_OWORD *)(32 * v117);
      }
      unint64_t v122 = v121;
      if (v79 == v78)
      {
        long long v78 = v79;
        long long v79 = (float *)(v121 + 2);
        if (v78) {
          goto LABEL_160;
        }
      }
      else
      {
        do
        {
          uint64_t v123 = *((void *)v79 - 4);
          v79 -= 8;
          int v124 = *((_DWORD *)v79 + 2);
          *((void *)v122 - 4) = v123;
          v122 -= 2;
          *((_DWORD *)v122 + 2) = v124;
          v122[1] = *((_OWORD *)v79 + 1);
        }
        while (v79 != v78);
        long long v79 = (float *)(v121 + 2);
        if (v78) {
LABEL_160:
        }
          (*(void (**)(uint64_t, float *, unint64_t))(*(void *)v230 + 40))(v230, v78, v103 - (void)v78);
      }
      uint64_t v80 = v119;
      long long v78 = (float *)v122;
      goto LABEL_162;
    }
LABEL_103:
    uint64_t v77 = v227 + 1;
    long long v75 = __p;
    if (v227 + 1 < (unint64_t)((v249 - (unsigned char *)__p) >> 3)) {
      continue;
    }
    break;
  }
  uint64_t v139 = (char *)v79 - (char *)v78;
  if (v79 == v78) {
    goto LABEL_277;
  }
  uint64_t v140 = *(void *)(*a2 + 416);
  uint64_t v141 = *(void *)(v140 + 8);
  uint64_t v142 = v80;
  if (v141 == *(void *)v140)
  {
    uint64_t v154 = *(void *)(v140 + 88);
    if (!v154)
    {
LABEL_303:
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
      return;
    }
    uint64_t v143 = (*(uint64_t (**)(uint64_t))(*(void *)v154 + 48))(v154);
    float v144 = *(uint64_t **)(v140 + 40);
    unint64_t v155 = *(void *)(v140 + 48);
    if ((unint64_t)v144 < v155)
    {
LABEL_209:
      if (v144) {
        *float v144 = v143;
      }
      uint64_t v156 = v144 + 1;
      goto LABEL_247;
    }
    uint64_t v157 = *(void *)(v140 + 32);
    uint64_t v158 = ((uint64_t)v144 - v157) >> 3;
    unint64_t v159 = v158 + 1;
    if ((unint64_t)(v158 + 1) >> 61) {
LABEL_304:
    }
      abort();
    uint64_t v160 = v155 - v157;
    if (v160 >> 2 > v159) {
      unint64_t v159 = v160 >> 2;
    }
    if ((unint64_t)v160 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v161 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v161 = v159;
    }
    if (v161)
    {
      uint64_t v162 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v140 + 56) + 16))(*(void *)(v140 + 56), 8 * v161, 8);
      uint64_t v152 = (uint64_t *)(v162 + 8 * v158);
      uint64_t v153 = v162 + 8 * v161;
      if (v162) {
        *uint64_t v152 = v143;
      }
    }
    else
    {
      uint64_t v153 = 0;
      uint64_t v152 = (uint64_t *)(8 * v158);
    }
    uint64_t v156 = v152 + 1;
    uint64_t v172 = *(void *)(v140 + 32);
    uint64_t v163 = *(void *)(v140 + 40);
    if (v163 == v172) {
      goto LABEL_245;
    }
    unint64_t v173 = v163 - v172 - 8;
    if (v173 < 0x38)
    {
      uint64_t v175 = *(void *)(v140 + 40);
    }
    else if ((unint64_t)(v163 - (void)v152) < 0x20)
    {
      uint64_t v175 = *(void *)(v140 + 40);
    }
    else
    {
      uint64_t v174 = (v173 >> 3) + 1;
      uint64_t v175 = v163 - 8 * (v174 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v176 = v152 - 2;
      unint64_t v177 = (long long *)(v163 - 16);
      uint64_t v178 = v174 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v179 = *v177;
        *((_OWORD *)v176 - 1) = *(v177 - 1);
        *(_OWORD *)unint64_t v176 = v179;
        v176 -= 4;
        v177 -= 2;
        v178 -= 4;
      }
      while (v178);
      v152 -= v174 & 0x3FFFFFFFFFFFFFFCLL;
      if (v174 == (v174 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_244;
      }
    }
    do
    {
      uint64_t v181 = *(void *)(v175 - 8);
      v175 -= 8;
      *--uint64_t v152 = v181;
    }
    while (v175 != v172);
LABEL_244:
    uint64_t v163 = *(void *)(v140 + 32);
    goto LABEL_245;
  }
  uint64_t v143 = *(void *)(v141 - 8);
  *(void *)(v140 + 8) = v141 - 8;
  float v144 = *(uint64_t **)(v140 + 40);
  unint64_t v145 = *(void *)(v140 + 48);
  if ((unint64_t)v144 < v145) {
    goto LABEL_209;
  }
  uint64_t v146 = *(void *)(v140 + 32);
  uint64_t v147 = ((uint64_t)v144 - v146) >> 3;
  unint64_t v148 = v147 + 1;
  if ((unint64_t)(v147 + 1) >> 61) {
    goto LABEL_304;
  }
  uint64_t v149 = v145 - v146;
  if (v149 >> 2 > v148) {
    unint64_t v148 = v149 >> 2;
  }
  if ((unint64_t)v149 >= 0x7FFFFFFFFFFFFFF8) {
    uint64_t v150 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v150 = v148;
  }
  if (v150)
  {
    uint64_t v151 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v140 + 56) + 16))(*(void *)(v140 + 56), 8 * v150, 8);
    uint64_t v152 = (uint64_t *)(v151 + 8 * v147);
    uint64_t v153 = v151 + 8 * v150;
    if (v151) {
      *uint64_t v152 = v143;
    }
  }
  else
  {
    uint64_t v153 = 0;
    uint64_t v152 = (uint64_t *)(8 * v147);
  }
  uint64_t v156 = v152 + 1;
  uint64_t v164 = *(void *)(v140 + 32);
  uint64_t v163 = *(void *)(v140 + 40);
  if (v163 != v164)
  {
    unint64_t v165 = v163 - v164 - 8;
    if (v165 < 0x38)
    {
      uint64_t v167 = *(void *)(v140 + 40);
    }
    else if ((unint64_t)(v163 - (void)v152) < 0x20)
    {
      uint64_t v167 = *(void *)(v140 + 40);
    }
    else
    {
      uint64_t v166 = (v165 >> 3) + 1;
      uint64_t v167 = v163 - 8 * (v166 & 0x3FFFFFFFFFFFFFFCLL);
      double v168 = v152 - 2;
      unint64_t v169 = (long long *)(v163 - 16);
      uint64_t v170 = v166 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v171 = *v169;
        *((_OWORD *)v168 - 1) = *(v169 - 1);
        *(_OWORD *)double v168 = v171;
        v168 -= 4;
        v169 -= 2;
        v170 -= 4;
      }
      while (v170);
      v152 -= v166 & 0x3FFFFFFFFFFFFFFCLL;
      if (v166 == (v166 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_244;
      }
    }
    do
    {
      uint64_t v180 = *(void *)(v167 - 8);
      v167 -= 8;
      *--uint64_t v152 = v180;
    }
    while (v167 != v164);
    goto LABEL_244;
  }
LABEL_245:
  *(void *)(v140 + 32) = v152;
  *(void *)(v140 + 40) = v156;
  uint64_t v182 = *(void *)(v140 + 48);
  *(void *)(v140 + 48) = v153;
  if (v163) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v140 + 56) + 40))(*(void *)(v140 + 56), v163, v182 - v163);
  }
LABEL_247:
  *(void *)(v140 + 40) = v156;
  *(void *)uint64_t v237 = v143;
  uint64_t v183 = *(void *)(v140 + 120);
  if (!v183) {
    goto LABEL_303;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v183 + 48))(v183, v237);
  unint64_t v184 = v139 >> 5;
  uint64_t v185 = **(void **)(v143 + 64);
  unint64_t v186 = *(void *)(v185 + 8) * (v139 >> 5);
  uint64_t v187 = *(void *)(v185 + 72);
  unint64_t v188 = *(void *)(v185 + 80) - v187;
  if (v186 != v188)
  {
    if (v186 <= v188)
    {
      if (v186 < v188) {
        *(void *)(v185 + 80) = v187 + v186;
      }
    }
    else
    {
      std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v185 + 72, v186 - v188);
    }
    uint64_t v189 = *(std::__shared_weak_count **)(v185 + 32);
    *(void *)(v185 + 24) = 0;
    *(void *)(v185 + 32) = 0;
    if (v189 && !atomic_fetch_add(&v189->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v189->__on_zero_shared)(v189);
      std::__shared_weak_count::__release_weak(v189);
    }
    *(void *)(v185 + 120) = 0;
    *(_DWORD *)(v185 + 112) = 0;
    uint64_t v190 = *(void *)(v185 + 80) - *(void *)(v185 + 72);
    *(void *)(v185 + 40) = 0;
    *(void *)(v185 + 48) = v190;
    *(void *)(v185 + 56) = 0;
    *(void *)(v185 + 64) = v190;
    uint64_t v185 = **(void **)(v143 + 64);
    unint64_t v186 = *(void *)(v185 + 8) * v184;
  }
  long long v244 = 0uLL;
  *(void *)&long long v191 = 0;
  *((void *)&v191 + 1) = v185;
  if (v186) {
    uint64_t v192 = *(void *)(v185 + 72);
  }
  else {
    uint64_t v192 = 0;
  }
  uint64_t v80 = v142;
  long long v244 = v191;
  *(void *)&long long v245 = 0;
  *((void *)&v245 + 1) = v186;
  uint64_t v247 = v192;
  __int16 v246 = 1;
  if (v184 <= 1) {
    uint64_t v193 = 1;
  }
  else {
    uint64_t v193 = v184;
  }
  uint64_t v194 = 4;
  do
  {
    size_t v195 = (_DWORD *)(v192 + v194 * 4);
    *(v195 - 4) = LODWORD(v78[v194 - 4]);
    *(v195 - 3) = LODWORD(v78[v194 - 3]);
    *(v195 - 2) = LODWORD(v78[v194 - 2]);
    *size_t v195 = LODWORD(v78[v194]);
    v195[1] = LODWORD(v78[v194 + 1]);
    v195[2] = LODWORD(v78[v194 + 2]);
    v195[3] = LODWORD(v78[v194 + 3]);
    v194 += 8;
    --v193;
  }
  while (v193);
  uint64_t v196 = *a2;
  gm::operator*<double,4,4,4>((double *)v237, (double *)(v222 + 808), (double *)(*a2 + 8));
  uint64_t v197 = ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>::pop(*(void *)(v196 + 400));
  float32x4_t v198 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v240), v241);
  float32x4_t v199 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v242), v243);
  float v200 = *(void **)(v197 + 64);
  BOOL v201 = (void *)v200[2];
  unint64_t v202 = v201[1];
  unint64_t v203 = (float32x4_t *)v201[9];
  float32x4_t v232 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v238), v239);
  float32x4_t v234 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)v237), *(float64x2_t *)&v237[16]);
  float32x4_t *v203 = v234;
  v203[1] = v232;
  float32x4_t v228 = v198;
  v203[2] = v198;
  v203[3] = v199;
  float32x4_t v225 = v199;
  if (v201[8] > v202) {
    unint64_t v202 = v201[8];
  }
  v201[7] = 0;
  v201[8] = v202;
  uint64_t v204 = (void *)*v200;
  unint64_t v205 = v204[1];
  *(int32x4_t *)v204[9] = v224;
  if (v204[8] > v205) {
    unint64_t v205 = v204[8];
  }
  v204[7] = 0;
  v204[8] = v205;
  unint64_t v206 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*a2 + 408));
  v206[8] = v143;
  v206[4] = v197;
  v206[3] = *(void *)(*a2 + 392);
  v206[6] = -1;
  ggl::CommandBuffer::pushRenderItem(a5, (uint64_t)v206);
  uint64_t v207 = ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>::pop(*(void *)(*a2 + 400));
  uint64_t v208 = *(void **)(v207 + 64);
  uint64_t v209 = (void *)v208[2];
  unint64_t v210 = v209[1];
  size_t v211 = (float32x4_t *)v209[9];
  *size_t v211 = v234;
  v211[1] = v232;
  v211[2] = v228;
  v211[3] = v225;
  if (v209[8] > v210) {
    unint64_t v210 = v209[8];
  }
  v209[7] = 0;
  v209[8] = v210;
  size_t v212 = (void *)*v208;
  unint64_t v213 = v212[1];
  *(_OWORD *)v212[9] = xmmword_1A28FD5D0;
  if (v212[8] > v213) {
    unint64_t v213 = v212[8];
  }
  void v212[7] = 0;
  v212[8] = v213;
  uint64_t v214 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(*a2 + 408));
  v214[8] = v143;
  v214[4] = v207;
  v214[3] = *(void *)(*a2 + 424);
  v214[6] = -1;
  ggl::CommandBuffer::pushRenderItem(a5, (uint64_t)v214);
  if (v186)
  {
    unint64_t v215 = *(void *)(v185 + 64);
    if (v215 <= v186) {
      unint64_t v215 = v186;
    }
    *(void *)(v185 + 56) = 0;
    *(void *)(v185 + 64) = v215;
  }
LABEL_277:
  if (v235) {
    (*(void (**)(uint64_t, unint64_t, unint64_t))(*(void *)v229 + 40))(v229, v235, v236 - v235);
  }
  if (v78) {
    (*(void (**)(uint64_t, float *, uint64_t))(*(void *)v230 + 40))(v230, v78, v80 - (void)v78);
  }
  uint64_t v76 = (char *)__p;
LABEL_282:
  if (v76)
  {
    uint64_t v216 = v249;
    uint64_t v217 = v76;
    if (v249 != v76)
    {
      unint64_t v218 = v249;
      do
      {
        uint64_t v220 = (void *)*((void *)v218 - 1);
        v218 -= 8;
        uint8x8_t v219 = v220;
        if (v220)
        {
          _ZF = (*v219)-- == 1;
          if (_ZF)
          {
            md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v219 + 1));
            {
              operator new();
            }
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *(v216 - 1), 400);
            *(v216 - 1) = 0;
          }
        }
        uint64_t v216 = v218;
      }
      while (v218 != v76);
      uint64_t v217 = __p;
    }
    uint64_t v249 = v76;
    operator delete(v217);
  }
}

void sub_1A1FCE790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  std::function<ggl::Debug::ExtendedMesh * ()(void)>::~function(v65);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v64);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v63);
  std::function<void ()(ggl::Debug::ExtendedMesh *)>::~function(&a59);
  std::function<ggl::Debug::ExtendedMesh * ()(void)>::~function(&a63);
  MEMORY[0x1A6239270](v63, 0x10A0C40D234DDC7);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a50);
  _Unwind_Resume(a1);
}

void sub_1A1FCE888(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50)
{
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a43);
  if (a25) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a19 + 40))(a19, a25, a26 - a25);
  }
  if (v50) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a20 + 40))(a20, v50, v51 - v50);
  }
  std::vector<geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>>::~vector[abi:nn180100](&a50);
  _Unwind_Resume(a1);
}

void *std::function<void ()(ggl::Debug::ExtendedPipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Debug::ExtendedPipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::Debug::ExtendedMesh *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Debug::ExtendedMesh * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t ggl::FragmentedPool<ggl::Debug::ExtendedPipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        long long v34 = v12 - 2;
        long long v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)long long v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--unint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        unint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        unint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        uint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--unint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void **std::vector<geo::fast_shared_ptr<md::RouteLineSection,mdm::MDAllocator>>::~vector[abi:nn180100](void **a1)
{
  uint64_t v2 = (char *)*a1;
  if (*a1)
  {
    uint64_t v3 = (char *)a1[1];
    uint64_t v4 = *a1;
    if (v3 != v2)
    {
      unint64_t v5 = (char *)a1[1];
      do
      {
        uint64_t v7 = (void *)*((void *)v5 - 1);
        v5 -= 8;
        uint64_t v6 = v7;
        if (v7)
        {
          if ((*v6)-- == 1)
          {
            md::RouteLineSection::~RouteLineSection((md::RouteLineSection *)(v6 + 1));
            {
              operator new();
            }
            (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *((void *)v3 - 1), 400);
            *((void *)v3 - 1) = 0;
          }
        }
        uint64_t v3 = v5;
      }
      while (v5 != v2);
      uint64_t v4 = *a1;
    }
    a1[1] = v2;
    operator delete(v4);
  }
  return a1;
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug12ExtendedMeshEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C048;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug12ExtendedMeshEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57C048;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug12ExtendedMeshEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2>,ggl::Debug::ExtendedMesh * ()(void)>::operator()()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2>,ggl::Debug::ExtendedMesh * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF572540;
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2>,ggl::Debug::ExtendedMesh * ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF572540;
  return result;
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2>,ggl::Debug::ExtendedMesh * ()(void)>::~__func()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::RenderItem * ()(void)>::operator()()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5724F8;
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::RenderItem * ()(void)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF5724F8;
  return result;
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::RenderItem * ()(void)>::~__func()
{
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug21ExtendedPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C120;
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug21ExtendedPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EF57C120;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug21ExtendedPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0>,ggl::Debug::ExtendedPipelineSetup * ()(void)>::operator()()
{
}

void sub_1A1FCFA04(_Unwind_Exception *a1)
{
  if (!atomic_fetch_add(v3, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  MEMORY[0x1A6239270](v1, 0xE1C40C3CBA79CLL);
  _Unwind_Resume(a1);
}

void ggl::ConstantDataTyped<ggl::Debug::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Debug::View>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::View>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::View>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586E98;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::View>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586E98;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void ggl::ConstantDataTyped<ggl::Debug::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::ConstantDataTyped<ggl::Debug::Style>::~ConstantDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::Style>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586ED0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::ConstantDataTyped<ggl::Debug::Style>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF586ED0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0>,ggl::Debug::ExtendedPipelineSetup * ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)__p[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)__p[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  operator delete(__p);
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0>,ggl::Debug::ExtendedPipelineSetup * ()(void)>::destroy(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 32);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3) {
      return;
    }
  }
  else
  {
    uint64_t v3 = *(std::__shared_weak_count **)(a1 + 16);
    if (!v3) {
      return;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0>,ggl::Debug::ExtendedPipelineSetup * ()(void)>::__clone(void *result, void *a2)
{
  uint64_t v3 = result[1];
  uint64_t v2 = result[2];
  *a2 = &unk_1EF5724B0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v4 = result[4];
  a2[3] = result[3];
  a2[4] = v4;
  if (v4) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v4 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0>,ggl::Debug::ExtendedPipelineSetup * ()(void)>::__clone(void *a1)
{
  uint64_t result = operator new(0x28uLL);
  uint64_t v4 = a1[1];
  uint64_t v3 = a1[2];
  *uint64_t result = &unk_1EF5724B0;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v5 = a1[4];
  result[3] = a1[3];
  result[4] = v5;
  if (v5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0>,ggl::Debug::ExtendedPipelineSetup * ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF5724B0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0,std::allocator<md::RouteRenderLayer::layoutDebugRouteLinePoints(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0>,ggl::Debug::ExtendedPipelineSetup * ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF5724B0;
  uint64_t v2 = (std::__shared_weak_count *)a1[4];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      return a1;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[2];
    if (!v3) {
      return a1;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::Debug::ExtendedPipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Debug::ExtendedPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5890B8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Debug::ExtendedPipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5890B8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void *std::function<void ()(ggl::Debug::BasePipelineSetup *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::Debug::BasePipelineSetup * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<void ()(ggl::CommonMesh::Pos4Mesh *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *std::function<ggl::CommonMesh::Pos4Mesh * ()(void)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void *__Block_byref_object_copy__49(void *result, void *a2)
{
  result[6] = a2[6];
  uint64_t v2 = a2 + 7;
  uint64_t v3 = a2[7];
  result[7] = v3;
  uint64_t v4 = result + 7;
  uint64_t v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(void *)(v3 + 16) = v4;
    a2[6] = v2;
    *uint64_t v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__50(uint64_t a1)
{
}

void ___ZN2md16RouteRenderLayer34layoutDebugRouteLineSnappingStatusERKNSt3__110shared_ptrINS_16RouteLineOverlayEEERKN3ggl15StandardLibraryERKNS_13LayoutContextEPNS7_13CommandBufferE_block_invoke(uint64_t a1, void *a2)
{
  id v96 = a2;
  uint64_t v3 = [v96 section];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v95 = v3;
  unint64_t v5 = [v96 section];
  uint64_t v6 = (void *)v5;
  unint64_t v8 = (uint64_t **)(v4 + 56);
  uint64_t v7 = *(uint64_t **)(v4 + 56);
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v9 = (uint64_t **)v7;
        unint64_t v10 = v7[4];
        if (v5 >= v10) {
          break;
        }
        uint64_t v7 = *v9;
        unint64_t v8 = v9;
        if (!*v9) {
          goto LABEL_8;
        }
      }
      if (v10 >= v5) {
        break;
      }
      uint64_t v7 = v9[1];
      if (!v7)
      {
        unint64_t v8 = v9 + 1;
        goto LABEL_8;
      }
    }
    uint64_t v11 = (uint64_t *)v9;
  }
  else
  {
    uint64_t v9 = (uint64_t **)(v4 + 56);
LABEL_8:
    uint64_t v11 = (uint64_t *)operator new(0x40uLL);
    v11[4] = (uint64_t)v6;
    v11[5] = 0;
    v11[6] = 0;
    v11[7] = 0;
    *uint64_t v11 = 0;
    v11[1] = 0;
    void v11[2] = (uint64_t)v9;
    *unint64_t v8 = v11;
    uint64_t v12 = **(void **)(v4 + 48);
    uint64_t v13 = v11;
    if (v12)
    {
      *(void *)(v4 + 48) = v12;
      uint64_t v13 = *v8;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 56), v13);
    uint64_t v6 = 0;
    ++*(void *)(v4 + 64);
  }
  int v14 = [v96 routeStartIndex];
  int v15 = [v3 startPointIndex];
  int v16 = [v96 routeEndIndex];
  int v17 = v14 - v15;
  int v18 = v16 - [v3 startPointIndex];
  uint64_t v20 = (char *)v11[6];
  unint64_t v19 = v11[7];
  if ((unint64_t)v20 < v19)
  {
    *(_DWORD *)uint64_t v20 = v17;
    *((_DWORD *)v20 + 1) = v18;
    uint64_t v21 = v20 + 8;
    uint64_t v22 = a1;
    unint64_t v23 = v3;
    goto LABEL_32;
  }
  uint64_t v24 = (char *)v11[5];
  uint64_t v25 = (v20 - v24) >> 3;
  unint64_t v26 = v25 + 1;
  if ((unint64_t)(v25 + 1) >> 61) {
    abort();
  }
  uint64_t v27 = v19 - (void)v24;
  if (v27 >> 2 > v26) {
    unint64_t v26 = v27 >> 2;
  }
  if ((unint64_t)v27 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v28 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v28 = v26;
  }
  if (v28 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  long long v29 = operator new(8 * v28);
  uint64_t v30 = &v29[8 * v25];
  unint64_t v31 = &v29[8 * v28];
  *uint64_t v30 = v17;
  v30[1] = v18;
  uint64_t v21 = v30 + 2;
  if (v20 == v24)
  {
    uint64_t v22 = a1;
    unint64_t v23 = v95;
    goto LABEL_30;
  }
  unint64_t v32 = v20 - v24 - 8;
  if (v32 < 0x58)
  {
    uint64_t v22 = a1;
    unint64_t v23 = v95;
    do
    {
LABEL_29:
      uint64_t v38 = *((void *)v20 - 1);
      v20 -= 8;
      *((void *)v30 - 1) = v38;
      v30 -= 2;
    }
    while (v20 != v24);
    goto LABEL_30;
  }
  uint64_t v22 = a1;
  unint64_t v23 = v95;
  if ((unint64_t)(v24 - v29) < 0x20) {
    goto LABEL_29;
  }
  uint64_t v33 = (v32 >> 3) + 1;
  long long v34 = &v29[8 * v25 - 16];
  long long v35 = v20 - 16;
  uint64_t v36 = v33 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v37 = *(_OWORD *)v35;
    *(v34 - 1) = *((_OWORD *)v35 - 1);
    _OWORD *v34 = v37;
    v34 -= 2;
    v35 -= 32;
    v36 -= 4;
  }
  while (v36);
  v30 -= 2 * (v33 & 0x3FFFFFFFFFFFFFFCLL);
  v20 -= 8 * (v33 & 0x3FFFFFFFFFFFFFFCLL);
  if (v33 != (v33 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_29;
  }
LABEL_30:
  v11[5] = (uint64_t)v30;
  v11[6] = (uint64_t)v21;
  v11[7] = (uint64_t)v31;
  if (v24) {
    operator delete(v24);
  }
LABEL_32:
  v11[6] = (uint64_t)v21;

  int v39 = [v96 routeEndIndex];
  int v40 = [v96 routeStartIndex];
  if ([v23 pointCount])
  {
    uint64_t v41 = (v39 - v40 + 1);
    if (v41 >= 2)
    {
      uint64_t v42 = ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::pop(*(void *)(**(void **)(v22 + 40) + 384));
      uint64_t v43 = **(void **)(v42 + 64);
      uint64_t v44 = *(void *)(v43 + 72);
      if (*(void *)(v43 + 80) != v44)
      {
        *(void *)(v43 + 80) = v44;
        uint64_t v45 = *(std::__shared_weak_count **)(v43 + 32);
        *(void *)(v43 + 24) = 0;
        *(void *)(v43 + 32) = 0;
        if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
          std::__shared_weak_count::__release_weak(v45);
        }
        *(void *)(v43 + 120) = 0;
        *(_DWORD *)(v43 + 112) = 0;
        uint64_t v46 = *(void *)(v43 + 80) - *(void *)(v43 + 72);
        *(void *)(v43 + 40) = 0;
        *(void *)(v43 + 48) = v46;
        *(void *)(v43 + 56) = 0;
        *(void *)(v43 + 64) = v46;
      }
      [v23 vkBounds];
      long long v101 = 0u;
      uint64_t v103 = 0;
      uint64_t v105 = 0;
      long long v102 = 0u;
      long long v100 = 0u;
      long long v99 = 0u;
      double v98 = v48 - v47;
      *(double *)&long long v101 = v50 - v49;
      double v104 = v48 - v47;
      double v106 = v47;
      double v107 = v49;
      uint64_t v51 = (double *)(*(void *)(v22 + 48) + 808);
      long long v108 = xmmword_1A28FCCC0;
      uint64_t v52 = objc_msgSend(v23, "points", gm::operator*<double,4,4,4>(v97[0].f64, v51, &v98));
      unsigned int v53 = [v96 routeStartIndex];
      uint64_t v54 = [v23 startPointIndex];
      uint64_t v94 = v42;
      uint64_t v55 = **(void **)(v42 + 64);
      unint64_t v56 = *(void *)(v55 + 8) * v41;
      uint64_t v57 = *(void *)(v55 + 72);
      unint64_t v58 = *(void *)(v55 + 80) - v57;
      if (v56 != v58)
      {
        if (v56 <= v58)
        {
          if (v56 < v58) {
            *(void *)(v55 + 80) = v57 + v56;
          }
        }
        else
        {
          std::vector<unsigned char,geo::StdAllocator<unsigned char,mdm::Allocator>>::__append(v55 + 72, v56 - v58);
        }
        long long v59 = *(std::__shared_weak_count **)(v55 + 32);
        *(void *)(v55 + 24) = 0;
        *(void *)(v55 + 32) = 0;
        if (v59 && !atomic_fetch_add(&v59->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v59->__on_zero_shared)(v59);
          std::__shared_weak_count::__release_weak(v59);
        }
        *(void *)(v55 + 120) = 0;
        *(_DWORD *)(v55 + 112) = 0;
        uint64_t v60 = *(void *)(v55 + 80) - *(void *)(v55 + 72);
        *(void *)(v55 + 40) = 0;
        *(void *)(v55 + 48) = v60;
        *(void *)(v55 + 56) = 0;
        *(void *)(v55 + 64) = v60;
        uint64_t v55 = **(void **)(v94 + 64);
        unint64_t v56 = *(void *)(v55 + 8) * v41;
      }
      long long v61 = (uint64_t *)(v52 + 12 * v53 - 12 * v54);
      uint64_t v62 = v55;
      if (v56) {
        unint64_t v63 = *(void *)(v55 + 72);
      }
      else {
        unint64_t v63 = 0;
      }
      uint64_t v64 = v62;
      if (v41 > 8
        && (v63 >= -12 * v54 + 12 * ((unint64_t)v53 + v41) + v52 - 4 || (unint64_t)v61 >= v63 + 16 * v41))
      {
        uint64_t v66 = v41 & 7;
        if ((v41 & 7) == 0) {
          uint64_t v66 = 8;
        }
        uint64_t v65 = v41 - v66;
        long long v67 = (float *)(v63 + 64);
        __asm { FMOV            V5.4S, #1.0 }
        uint64_t v72 = v52 + 12 * v53 - 12 * v54;
        uint64_t v73 = v65;
        unint64_t v23 = v95;
        do
        {
          long long v74 = (const float *)v72;
          float32x4x3_t v110 = vld3q_f32(v74);
          v74 += 12;
          v110.val[2] = 0uLL;
          *(float32x4x3_t *)v111.val[0].f32 = vld3q_f32(v74);
          v111.val[2] = 0uLL;
          v111.val[3] = _Q5;
          long long v75 = v67 - 16;
          vst4q_f32(v75, *(float32x4x4_t *)(&_Q5 - 3));
          vst4q_f32(v67, v111);
          v67 += 32;
          v72 += 96;
          v73 -= 8;
        }
        while (v73);
        long long v61 = (uint64_t *)((char *)v61 + 12 * v65);
      }
      else
      {
        uint64_t v65 = 0;
        unint64_t v23 = v95;
      }
      uint64_t v76 = v41 - v65;
      uint64_t v77 = (void *)(v63 + 16 * v65 + 8);
      do
      {
        uint64_t v78 = *v61;
        long long v61 = (uint64_t *)((char *)v61 + 12);
        *(v77 - 1) = v78;
        *uint64_t v77 = 0x3F80000000000000;
        v77 += 2;
        --v76;
      }
      while (v76);
      uint64_t v79 = ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(*(void *)(**(void **)(v22 + 40) + 368));
      float32x4_t v80 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v97[2]), v97[3]);
      float32x4_t v81 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v97[4]), v97[5]);
      float32x4_t v82 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v97[6]), v97[7]);
      uint64_t v83 = *(void **)(v79 + 64);
      uint64_t v84 = (void *)v83[2];
      unint64_t v85 = v84[1];
      uint64_t v86 = (float32x4_t *)v84[9];
      *uint64_t v86 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v97[0]), v97[1]);
      v86[1] = v80;
      v86[2] = v81;
      v86[3] = v82;
      if (v84[8] > v85) {
        unint64_t v85 = v84[8];
      }
      v84[7] = 0;
      v84[8] = v85;
      uint64_t v87 = (void *)*v83;
      unint64_t v88 = v87[1];
      if (v88)
      {
        uint64_t v89 = v87[9];
        if (v89) {
          _ZF = v88 == 0;
        }
        else {
          _ZF = 1;
        }
        if (!_ZF)
        {
          if (v87[8] > v88) {
            unint64_t v88 = v87[8];
          }
          v87[7] = 0;
          v87[8] = v88;
        }
      }
      else
      {
        uint64_t v89 = 0;
      }
      if ([v96 isMapMatched] && (objc_msgSend(v96, "isMapMatching") & 1) == 0)
      {
        *(void *)uint64_t v89 = 0;
      }
      else
      {
        int v91 = [v96 isMapMatching];
        *(_DWORD *)uint64_t v89 = 1065353216;
        if (v91) {
          *(_DWORD *)(v89 + 4) = 1065353216;
        }
        else {
          *(_DWORD *)(v89 + 4) = 0;
        }
      }
      *(void *)(v89 + 8) = 0x3F80000000000000;
      unint64_t v92 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(**(void **)(v22 + 40) + 376));
      v92[8] = v94;
      v92[4] = v79;
      v92[3] = *(void *)(**(void **)(v22 + 40) + 360);
      ggl::CommandBuffer::pushRenderItem(*(void *)(v22 + 56), (uint64_t)v92);
      if (v56)
      {
        unint64_t v93 = *(void *)(v64 + 64);
        if (v93 <= v56) {
          unint64_t v93 = v56;
        }
        *(void *)(v64 + 56) = 0;
        *(void *)(v64 + 64) = v93;
      }
    }
  }
}

void sub_1A1FD0D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, id a12, char a13)
{
  _Unwind_Resume(a1);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *,false>(uint64_t result, int *a2, uint64_t a3, char a4)
{
  uint64_t v9 = (int *)result;
LABEL_2:
  unint64_t v10 = a2 - 2;
  uint64_t v11 = a2 - 1;
  uint64_t v12 = v9;
  while (1)
  {
    uint64_t v9 = v12;
    uint64_t v13 = (char *)a2 - (char *)v12;
    uint64_t v14 = ((char *)a2 - (char *)v12) >> 3;
    if (v5 || !v4)
    {
      switch(v14)
      {
        case 0:
        case 1:
          return result;
        case 2:
          int v102 = *v12;
          if (*v10 < *v12)
          {
            int *v12 = *v10;
            *unint64_t v10 = v102;
            int v103 = v12[1];
            v12[1] = *v11;
            *uint64_t v11 = v103;
          }
          return result;
        case 3:
          int v104 = v12[2];
          int v105 = *v12;
          int v106 = *v10;
          if (v104 >= *v12)
          {
            if (v106 >= v104) {
              return result;
            }
            v12[2] = v106;
            *unint64_t v10 = v104;
            int v157 = v12[3];
            v12[3] = *v11;
            *uint64_t v11 = v157;
            int v158 = v12[2];
            int v159 = *v12;
            if (v158 >= *v12) {
              return result;
            }
            int *v12 = v158;
            v12[2] = v159;
            double v107 = v12 + 1;
            uint64_t v11 = v12 + 3;
          }
          else
          {
            if (v106 >= v104)
            {
              double v107 = v12 + 3;
              int v167 = v12[3];
              int v168 = v12[1];
              int *v12 = v104;
              v12[1] = v167;
              v12[2] = v105;
              v12[3] = v168;
              if (*v10 >= v105) {
                return result;
              }
              v12[2] = *v10;
            }
            else
            {
              double v107 = v12 + 1;
              int *v12 = v106;
            }
            *unint64_t v10 = v105;
          }
          int v169 = *v107;
          *double v107 = *v11;
          *uint64_t v11 = v169;
          return result;
        case 4:
          return (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *>(v12, v12 + 2, v12 + 4, a2 - 2);
        case 5:
          uint64_t result = (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *>(v12, v12 + 2, v12 + 4, v12 + 6);
          int v108 = v12[6];
          if (*v10 < v108)
          {
            v12[6] = *v10;
            *unint64_t v10 = v108;
            int v109 = v12[7];
            v12[7] = *v11;
            *uint64_t v11 = v109;
            int v110 = v12[6];
            int v111 = v12[4];
            if (v110 < v111)
            {
              int v112 = v12[5];
              int v113 = v12[7];
              uint64_t v12[4] = v110;
              v12[5] = v113;
              v12[6] = v111;
              v12[7] = v112;
              int v114 = v12[2];
              if (v110 < v114)
              {
                int v115 = v12[3];
                v12[2] = v110;
                v12[3] = v113;
                uint64_t v12[4] = v114;
                v12[5] = v115;
                int v116 = *v12;
                if (v110 < *v12)
                {
                  int v117 = v12[1];
                  int *v12 = v110;
                  v12[1] = v113;
                  v12[2] = v116;
                  v12[3] = v117;
                }
              }
            }
          }
          return result;
        default:
          JUMPOUT(0);
      }
    }
    if (v13 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v12 != a2)
      {
        int64_t v131 = (unint64_t)(v14 - 2) >> 1;
        int64_t v132 = v131;
        do
        {
          if (v131 >= v132)
          {
            uint64_t v134 = (2 * v132) | 1;
            uint64_t v135 = &v12[2 * v134];
            if (2 * v132 + 2 < v14)
            {
              int v137 = *v135;
              int v136 = v135[2];
              if (*v135 <= v136) {
                int v137 = v135[2];
              }
              if (*v135 < v136)
              {
                v135 += 2;
                uint64_t v134 = 2 * v132 + 2;
              }
            }
            else
            {
              int v137 = *v135;
            }
            long long v138 = &v12[2 * v132];
            if (v137 >= *v138)
            {
              int v139 = *v138;
              int v140 = v138[1];
              while (1)
              {
                uint64_t result = (uint64_t)v138;
                long long v138 = v135;
                *(_DWORD *)uint64_t result = v137;
                *(_DWORD *)(result + 4) = v135[1];
                if (v131 < v134) {
                  break;
                }
                uint64_t result = (2 * v134) | 1;
                uint64_t v135 = &v12[2 * result];
                uint64_t v134 = 2 * v134 + 2;
                if (v134 < v14)
                {
                  int v137 = *v135;
                  int v141 = v135[2];
                  if (*v135 <= v141) {
                    int v137 = v135[2];
                  }
                  if (*v135 >= v141) {
                    uint64_t v134 = result;
                  }
                  else {
                    v135 += 2;
                  }
                  if (v137 < v139) {
                    break;
                  }
                }
                else
                {
                  int v137 = *v135;
                  uint64_t v134 = result;
                  if (*v135 < v139) {
                    break;
                  }
                }
              }
              *long long v138 = v139;
              v138[1] = v140;
            }
          }
          BOOL v133 = v132-- <= 0;
        }
        while (!v133);
        uint64_t v142 = (unint64_t)v13 >> 3;
        do
        {
          uint64_t v143 = 0;
          uint64_t v144 = *(void *)v12;
          unint64_t v145 = v12;
          do
          {
            unint64_t v148 = &v145[2 * v143 + 2];
            uint64_t v149 = (2 * v143) | 1;
            uint64_t v143 = 2 * v143 + 2;
            if (v143 < v142)
            {
              int v146 = *v148;
              int v147 = v148[2];
              if (*v148 <= v147) {
                int v146 = v148[2];
              }
              if (*v148 >= v147) {
                uint64_t v143 = v149;
              }
              else {
                v148 += 2;
              }
            }
            else
            {
              int v146 = *v148;
              uint64_t v143 = v149;
            }
            *unint64_t v145 = v146;
            v145[1] = v148[1];
            unint64_t v145 = v148;
          }
          while (v143 <= (uint64_t)((unint64_t)(v142 - 2) >> 1));
          if (v148 == a2 - 2)
          {
            *(void *)unint64_t v148 = v144;
          }
          else
          {
            *unint64_t v148 = *(a2 - 2);
            v148[1] = *(a2 - 1);
            *((void *)a2 - 1) = v144;
            uint64_t v150 = (char *)v148 - (char *)v12 + 8;
            if (v150 >= 9)
            {
              unint64_t v151 = (((unint64_t)v150 >> 3) - 2) >> 1;
              uint64_t v152 = &v12[2 * v151];
              int v153 = *v152;
              if (*v152 < *v148)
              {
                int v154 = *v148;
                int v155 = v148[1];
                do
                {
                  uint64_t v156 = v148;
                  unint64_t v148 = v152;
                  *uint64_t v156 = v153;
                  v156[1] = v152[1];
                  if (!v151) {
                    break;
                  }
                  unint64_t v151 = (v151 - 1) >> 1;
                  uint64_t v152 = &v12[2 * v151];
                  int v153 = *v152;
                }
                while (*v152 < v154);
                *unint64_t v148 = v154;
                v148[1] = v155;
              }
            }
          }
          a2 -= 2;
          BOOL v133 = v142-- <= 2;
        }
        while (!v133);
      }
      return result;
    }
    unint64_t v15 = (unint64_t)v14 >> 1;
    int v16 = &v12[2 * ((unint64_t)v14 >> 1)];
    int v17 = *v10;
    if ((unint64_t)v13 >= 0x401)
    {
      int v18 = *v16;
      int v19 = *v12;
      if (*v16 >= *v12)
      {
        if (v17 < v18)
        {
          int *v16 = v17;
          *unint64_t v10 = v18;
          uint64_t v24 = &v12[2 * v15];
          int v26 = v24[1];
          uint64_t v25 = v24 + 1;
          *uint64_t v25 = *v11;
          *uint64_t v11 = v26;
          int v27 = *v12;
          if (*v16 < *v12)
          {
            int *v12 = *v16;
            uint64_t v20 = v12 + 1;
            int *v16 = v27;
            goto LABEL_23;
          }
        }
      }
      else
      {
        if (v17 < v18)
        {
          uint64_t v20 = v12 + 1;
          int *v12 = v17;
          goto LABEL_22;
        }
        int *v12 = v18;
        int *v16 = v19;
        int v31 = v12[1];
        uint64_t v20 = &v12[2 * v15 + 1];
        v12[1] = *v20;
        *uint64_t v20 = v31;
        if (*v10 < v19)
        {
          int *v16 = *v10;
LABEL_22:
          *unint64_t v10 = v19;
          uint64_t v25 = a2 - 1;
LABEL_23:
          int v32 = *v20;
          *uint64_t v20 = *v25;
          *uint64_t v25 = v32;
        }
      }
      unint64_t v33 = v15 - 1;
      long long v34 = &v12[2 * v15 - 2];
      int v35 = *v34;
      int v36 = v12[2];
      int v37 = *(a2 - 4);
      if (*v34 >= v36)
      {
        if (v37 < v35)
        {
          int *v34 = v37;
          *(a2 - 4) = v35;
          int v39 = &v12[2 * v33];
          int v41 = v39[1];
          int v40 = v39 + 1;
          *int v40 = *(a2 - 3);
          *(a2 - 3) = v41;
          int v42 = v12[2];
          if (*v34 < v42)
          {
            v12[2] = *v34;
            int *v34 = v42;
            uint64_t v38 = v12 + 3;
            goto LABEL_36;
          }
        }
      }
      else
      {
        if (v37 < v35)
        {
          uint64_t v38 = v12 + 3;
          v12[2] = v37;
          goto LABEL_35;
        }
        uint64_t v45 = &v12[2 * v33];
        int v46 = v45[1];
        uint64_t v38 = v45 + 1;
        int v47 = v12[3];
        v12[2] = v35;
        v12[3] = v46;
        int *v34 = v36;
        int *v38 = v47;
        int v48 = *(a2 - 4);
        if (v48 < v36)
        {
          int *v34 = v48;
LABEL_35:
          *(a2 - 4) = v36;
          int v40 = a2 - 3;
LABEL_36:
          int v49 = *v38;
          int *v38 = *v40;
          *int v40 = v49;
        }
      }
      unint64_t v50 = v15 + 1;
      uint64_t v51 = &v12[2 * v15 + 2];
      int v52 = *v51;
      int v53 = v12[4];
      int v54 = *(a2 - 6);
      if (*v51 >= v53)
      {
        if (v54 < v52)
        {
          int *v51 = v54;
          *(a2 - 6) = v52;
          unint64_t v56 = &v12[2 * v50];
          int v58 = v56[1];
          uint64_t v57 = v56 + 1;
          int *v57 = *(a2 - 5);
          *(a2 - 5) = v58;
          int v52 = *v51;
          int v59 = v12[4];
          if (*v51 < v59)
          {
            uint64_t v12[4] = v52;
            int *v51 = v59;
            uint64_t v55 = v12 + 5;
            goto LABEL_46;
          }
        }
      }
      else
      {
        if (v54 < v52)
        {
          uint64_t v55 = v12 + 5;
          uint64_t v12[4] = v54;
          goto LABEL_45;
        }
        uint64_t v60 = &v12[2 * v50];
        int v61 = v60[1];
        uint64_t v55 = v60 + 1;
        uint64_t result = v12[5];
        uint64_t v12[4] = v52;
        v12[5] = v61;
        int *v51 = v53;
        *uint64_t v55 = result;
        int v62 = *(a2 - 6);
        if (v62 >= v53)
        {
          int v52 = v53;
        }
        else
        {
          int *v51 = v62;
LABEL_45:
          *(a2 - 6) = v53;
          uint64_t v57 = a2 - 5;
LABEL_46:
          int v63 = *v55;
          *uint64_t v55 = *v57;
          int *v57 = v63;
          int v52 = *v51;
        }
      }
      int v64 = *v16;
      int v65 = *v34;
      if (*v16 >= *v34)
      {
        if (v52 < v64)
        {
          int *v16 = v52;
          long long v68 = &v12[2 * v15];
          unsigned int v69 = v68[1];
          long long v67 = v68 + 1;
          uint64_t result = v69;
          int *v51 = v64;
          unint64_t v70 = &v12[2 * v50];
          *long long v67 = v70[1];
          v70[1] = v69;
          if (v52 < v65)
          {
            int *v34 = v52;
            int *v16 = v65;
            uint64_t v66 = &v12[2 * v33 + 1];
            goto LABEL_55;
          }
          int v64 = v52;
        }
      }
      else
      {
        uint64_t v66 = &v12[2 * v33 + 1];
        if (v52 < v64)
        {
          int *v34 = v52;
          int *v51 = v65;
          long long v67 = &v12[2 * v50 + 1];
          goto LABEL_55;
        }
        int *v34 = v64;
        int *v16 = v65;
        uint64_t v71 = &v12[2 * v15];
        int v73 = v71[1];
        uint64_t v72 = v71 + 1;
        int v74 = *v66;
        int *v66 = v73;
        *uint64_t v72 = v74;
        if (v52 >= v65)
        {
          int v64 = v65;
        }
        else
        {
          int *v16 = v52;
          int *v51 = v65;
          long long v67 = &v12[2 * v50 + 1];
          uint64_t v66 = v72;
LABEL_55:
          int v75 = *v66;
          int *v66 = *v67;
          *long long v67 = v75;
          int v64 = *v16;
        }
      }
      int v76 = *v12;
      int *v12 = v64;
      unint64_t v23 = v12 + 1;
      int *v16 = v76;
      long long v29 = &v12[2 * v15 + 1];
      goto LABEL_57;
    }
    int v21 = *v12;
    int v22 = *v16;
    if (*v12 >= *v16)
    {
      if (v17 >= v21) {
        goto LABEL_58;
      }
      int *v12 = v17;
      *unint64_t v10 = v21;
      long long v29 = v12 + 1;
      int v28 = v12[1];
      v12[1] = *v11;
      *uint64_t v11 = v28;
      int v30 = *v16;
      if (*v12 >= *v16) {
        goto LABEL_58;
      }
      int *v16 = *v12;
      int *v12 = v30;
      unint64_t v23 = &v12[2 * v15 + 1];
    }
    else
    {
      unint64_t v23 = &v12[2 * v15 + 1];
      if (v17 >= v21)
      {
        int *v16 = v21;
        int v43 = v12[1];
        int *v12 = v22;
        int v44 = *v23;
        int *v23 = v43;
        v12[1] = v44;
        if (*v10 >= v22) {
          goto LABEL_58;
        }
        int *v12 = *v10;
        *unint64_t v10 = v22;
        unint64_t v23 = v12 + 1;
      }
      else
      {
        int *v16 = v17;
        *unint64_t v10 = v22;
      }
      long long v29 = a2 - 1;
    }
LABEL_57:
    int v77 = *v23;
    int *v23 = *v29;
    *long long v29 = v77;
LABEL_58:
    --a3;
    if ((a4 & 1) != 0 || *(v12 - 2) < *v12)
    {
      uint64_t v78 = *(void *)v12;
      uint64_t v79 = v12;
      do
      {
        float32x4_t v80 = v79;
        int v82 = v79[2];
        v79 += 2;
        int v81 = v82;
      }
      while (v82 < (int)v78);
      uint64_t v83 = a2;
      if (v80 == v12)
      {
        uint64_t v83 = a2;
        do
        {
          if (v79 >= v83) {
            break;
          }
          int v85 = *(v83 - 2);
          v83 -= 2;
        }
        while (v85 >= (int)v78);
      }
      else
      {
        do
        {
          int v84 = *(v83 - 2);
          v83 -= 2;
        }
        while (v84 >= (int)v78);
      }
      if (v79 < v83)
      {
        int v86 = *v83;
        uint64_t v12 = v79;
        uint64_t v87 = v83;
        do
        {
          int *v12 = v86;
          *uint64_t v87 = v81;
          int v88 = v12[1];
          v12[1] = v87[1];
          v87[1] = v88;
          do
          {
            int v89 = v12[2];
            v12 += 2;
            int v81 = v89;
          }
          while (v89 < (int)v78);
          do
          {
            int v90 = *(v87 - 2);
            v87 -= 2;
            int v86 = v90;
          }
          while (v90 >= (int)v78);
        }
        while (v12 < v87);
      }
      else
      {
        uint64_t v12 = v79;
      }
      if (v12 - 2 != v9)
      {
        *uint64_t v9 = *(v12 - 2);
        v9[1] = *(v12 - 1);
      }
      *((void *)v12 - 1) = v78;
      if (v79 < v83) {
        goto LABEL_80;
      }
      BOOL v91 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *>(v9, v12 - 2);
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *>(v12, a2);
      if (result)
      {
        a2 = v12 - 2;
        if (v91) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v91)
      {
LABEL_80:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *,false>(v9, v12 - 2, a3, a4 & 1);
        a4 = 0;
      }
    }
    else
    {
      uint64_t v92 = *(void *)v12;
      if (*v10 > (int)*(void *)v12)
      {
        do
        {
          int v93 = v12[2];
          v12 += 2;
        }
        while (v93 <= (int)v92);
      }
      else
      {
        uint64_t v94 = v12 + 2;
        do
        {
          uint64_t v12 = v94;
          if (v94 >= a2) {
            break;
          }
          v94 += 2;
        }
        while (*v12 <= (int)v92);
      }
      unint64_t v95 = a2;
      if (v12 < a2)
      {
        unint64_t v95 = a2;
        do
        {
          int v96 = *(v95 - 2);
          v95 -= 2;
        }
        while (v96 > (int)v92);
      }
      if (v12 < v95)
      {
        int v97 = *v12;
        int v98 = *v95;
        do
        {
          int *v12 = v98;
          *unint64_t v95 = v97;
          int v99 = v12[1];
          v12[1] = v95[1];
          v95[1] = v99;
          do
          {
            int v100 = v12[2];
            v12 += 2;
            int v97 = v100;
          }
          while (v100 <= (int)v92);
          do
          {
            int v101 = *(v95 - 2);
            v95 -= 2;
            int v98 = v101;
          }
          while (v101 > (int)v92);
        }
        while (v12 < v95);
      }
      BOOL v4 = v12 - 2 >= v9;
      BOOL v5 = v12 - 2 == v9;
      if (v12 - 2 != v9)
      {
        *uint64_t v9 = *(v12 - 2);
        v9[1] = *(v12 - 1);
      }
      a4 = 0;
      *((void *)v12 - 1) = v92;
    }
  }
  unint64_t v118 = v12 + 2;
  BOOL v120 = v12 == a2 || v118 == a2;
  if (a4)
  {
    if (!v120)
    {
      uint64_t v121 = 0;
      unint64_t v122 = v12;
      do
      {
        int v124 = v122[2];
        int v125 = *v122;
        unint64_t v122 = v118;
        if (v124 < v125)
        {
          int v127 = *v118;
          int v126 = v118[1];
          uint64_t v128 = v121;
          do
          {
            uint64_t v129 = (char *)v12 + v128;
            int v130 = *(int *)((char *)v12 + v128 + 4);
            *((_DWORD *)v129 + 2) = v125;
            *((_DWORD *)v129 + 3) = v130;
            if (!v128)
            {
              uint64_t v123 = v12;
              goto LABEL_128;
            }
            int v125 = *((_DWORD *)v129 - 2);
            v128 -= 8;
          }
          while (v125 > v127);
          uint64_t v123 = (int *)((char *)v12 + v128 + 8);
LABEL_128:
          *uint64_t v123 = v127;
          v123[1] = v126;
        }
        unint64_t v118 = v122 + 2;
        v121 += 8;
      }
      while (v122 + 2 != a2);
    }
  }
  else if (!v120)
  {
    uint64_t v160 = v12 + 3;
    do
    {
      int v161 = v9[2];
      int v162 = *v9;
      uint64_t v9 = v118;
      if (v161 < v162)
      {
        uint64_t v163 = *(void *)v118;
        uint64_t v164 = v160;
        do
        {
          unint64_t v165 = v164;
          *(v164 - 1) = v162;
          int v166 = *(v164 - 2);
          v164 -= 2;
          *unint64_t v165 = v166;
          int v162 = *(v165 - 5);
        }
        while (v162 > (int)v163);
        *(void *)(v164 - 1) = v163;
      }
      unint64_t v118 = v9 + 2;
      v160 += 2;
    }
    while (v9 + 2 != a2);
  }
  return result;
}

uint64_t ggl::FragmentedPool<ggl::CommonMesh::Pos4Mesh>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    BOOL v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        long long v34 = v12 - 2;
        int v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)long long v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    BOOL v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        int v26 = v12 - 2;
        int v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)int v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t ggl::FragmentedPool<ggl::Debug::BasePipelineSetup>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    BOOL v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        long long v34 = v12 - 2;
        int v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)long long v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    BOOL v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          uint64_t *v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        int v26 = v12 - 2;
        int v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)int v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

void std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::less<GEOComposedRouteSection * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::less<GEOComposedRouteSection * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>>>::destroy(*a1);
    std::__tree<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::__map_value_compare<GEOComposedRouteSection * {__strong},std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>,std::less<GEOComposedRouteSection * {__strong}>,true>,std::allocator<std::__value_type<GEOComposedRouteSection * {__strong},std::vector<std::pair<int,int>>>>>::destroy(a1[1]);
    uint64_t v2 = (void *)a1[5];
    if (v2)
    {
      a1[6] = v2;
      operator delete(v2);
    }

    operator delete(a1);
  }
}

int *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *>(int *result, int *a2, int *a3, int *a4)
{
  int v4 = *a2;
  int v5 = *result;
  int v6 = *a3;
  if (*a2 >= *result)
  {
    if (v6 < v4)
    {
      *a2 = v6;
      *a3 = v4;
      uint64_t v9 = a2 + 1;
      int v8 = a2[1];
      a2[1] = a3[1];
      a3[1] = v8;
      int v10 = *result;
      if (*a2 < *result)
      {
        *uint64_t result = *a2;
        uint64_t v7 = result + 1;
        *a2 = v10;
LABEL_10:
        int v12 = *v7;
        *uint64_t v7 = *v9;
        *uint64_t v9 = v12;
      }
    }
  }
  else
  {
    if (v6 < v4)
    {
      uint64_t v7 = result + 1;
      *uint64_t result = v6;
LABEL_9:
      *a3 = v5;
      uint64_t v9 = a3 + 1;
      goto LABEL_10;
    }
    *uint64_t result = v4;
    *a2 = v5;
    uint64_t v7 = a2 + 1;
    int v11 = result[1];
    result[1] = a2[1];
    a2[1] = v11;
    int v5 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      goto LABEL_9;
    }
  }
  int v13 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v13;
    int v14 = a3[1];
    a3[1] = a4[1];
    a4[1] = v14;
    int v15 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v15;
      int v16 = a2[1];
      a2[1] = a3[1];
      a3[1] = v16;
      int v17 = *result;
      if (*a2 < *result)
      {
        *uint64_t result = *a2;
        *a2 = v17;
        int v18 = result[1];
        result[1] = a2[1];
        a2[1] = v18;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *>(int *a1, int *a2)
{
  uint64_t v4 = ((char *)a2 - (char *)a1) >> 3;
  BOOL result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      int v6 = *(a2 - 2);
      int v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 2) = v7;
        int v8 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return result;
    case 3:
      int v9 = a1[2];
      int v10 = *a1;
      int v11 = *(a2 - 2);
      if (v9 < *a1)
      {
        if (v11 >= v9)
        {
          int v12 = a1 + 3;
          int v36 = a1[3];
          int v37 = a1[1];
          *a1 = v9;
          a1[1] = v36;
          a1[2] = v10;
          a1[3] = v37;
          int v38 = *(a2 - 2);
          if (v38 >= v10) {
            return result;
          }
          a1[2] = v38;
        }
        else
        {
          int v12 = a1 + 1;
          *a1 = v11;
        }
        *(a2 - 2) = v10;
        uint64_t v30 = a2 - 1;
        goto LABEL_25;
      }
      if (v11 < v9)
      {
        a1[2] = v11;
        *(a2 - 2) = v9;
        uint64_t v30 = a1 + 3;
        int v29 = a1[3];
        a1[3] = *(a2 - 1);
        *(a2 - 1) = v29;
        int v31 = a1[2];
        int v32 = *a1;
        if (v31 < *a1)
        {
          *a1 = v31;
          a1[2] = v32;
          int v12 = a1 + 1;
LABEL_25:
          int v39 = *v12;
          int *v12 = *v30;
          *uint64_t v30 = v39;
          return result;
        }
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *>(a1, a1 + 2, a1 + 4, a2 - 2);
      return 1;
    case 5:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_0 &,std::pair<int,int> *>(a1, a1 + 2, a1 + 4, a1 + 6);
      int v18 = *(a2 - 2);
      int v19 = a1[6];
      if (v18 < v19)
      {
        a1[6] = v18;
        *(a2 - 2) = v19;
        int v20 = a1[7];
        a1[7] = *(a2 - 1);
        *(a2 - 1) = v20;
        int v21 = a1[6];
        int v22 = a1[4];
        if (v21 < v22)
        {
          int v23 = a1[5];
          int v24 = a1[7];
          a1[4] = v21;
          a1[5] = v24;
          a1[6] = v22;
          a1[7] = v23;
          int v25 = a1[2];
          if (v21 < v25)
          {
            int v26 = a1[3];
            a1[2] = v21;
            a1[3] = v24;
            a1[4] = v25;
            a1[5] = v26;
            int v27 = *a1;
            if (v21 < *a1)
            {
              int v28 = a1[1];
              *a1 = v21;
              a1[1] = v24;
              a1[2] = v27;
              a1[3] = v28;
            }
          }
        }
      }
      return 1;
    default:
      int v13 = a1 + 4;
      int v14 = a1[4];
      int v15 = a1[2];
      int v16 = *a1;
      if (v15 < *a1)
      {
        if (v14 >= v15)
        {
          int v17 = a1 + 3;
          int v40 = a1[3];
          int v41 = a1[1];
          *a1 = v15;
          a1[1] = v40;
          a1[2] = v16;
          a1[3] = v41;
          if (v14 >= v16) {
            goto LABEL_30;
          }
          a1[2] = v14;
        }
        else
        {
          int v17 = a1 + 1;
          *a1 = v14;
        }
        a1[4] = v16;
        long long v34 = a1 + 5;
        goto LABEL_29;
      }
      if (v14 < v15)
      {
        long long v34 = a1 + 3;
        int v33 = a1[3];
        int v35 = a1[5];
        a1[4] = v15;
        a1[5] = v33;
        a1[2] = v14;
        a1[3] = v35;
        if (v14 < v16)
        {
          *a1 = v14;
          a1[2] = v16;
          int v17 = a1 + 1;
LABEL_29:
          int v42 = *v17;
          int *v17 = *v34;
          int *v34 = v42;
        }
      }
LABEL_30:
      uint64_t v43 = a1 + 6;
      if (a1 + 6 == a2) {
        return 1;
      }
      uint64_t v44 = 0;
      int v45 = 0;
      while (1)
      {
        int v47 = *v13;
        if (*v43 < *v13)
        {
          int v49 = *v43;
          int v48 = v43[1];
          uint64_t v50 = v44;
          do
          {
            uint64_t v51 = (int *)((char *)a1 + v50);
            int v52 = *(int *)((char *)a1 + v50 + 20);
            v51[6] = v47;
            v51[7] = v52;
            if (v50 == -16)
            {
              int v46 = a1;
              goto LABEL_33;
            }
            int v47 = v51[2];
            v50 -= 8;
          }
          while (v47 > v49);
          int v46 = (int *)((char *)a1 + v50 + 24);
LABEL_33:
          int *v46 = v49;
          v46[1] = v48;
          if (++v45 == 8) {
            return v43 + 2 == a2;
          }
        }
        int v13 = v43;
        v44 += 8;
        v43 += 2;
        if (v43 == a2) {
          return 1;
        }
      }
  }
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_10CommonMesh8Pos4MeshEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1EF57ABC0;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_10CommonMesh8Pos4MeshEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_3,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_3>,ggl::CommonMesh::Pos4Mesh * ()(void)>::operator()()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_3,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_3>,ggl::CommonMesh::Pos4Mesh * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF572618;
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_3,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_3>,ggl::CommonMesh::Pos4Mesh * ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1EF572618;
  return result;
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_3,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_3>,ggl::CommonMesh::Pos4Mesh * ()(void)>::~__func()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2>,ggl::RenderItem * ()(void)>::operator()()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2>,ggl::RenderItem * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5725D0;
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2>,ggl::RenderItem * ()(void)>::__clone()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1EF5725D0;
  return result;
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_2>,ggl::RenderItem * ()(void)>::~__func()
{
}

void *_ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug17BasePipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEv()
{
  BOOL result = operator new(0x10uLL);
  *BOOL result = &unk_1EF57C090;
  return result;
}

void _ZNSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_5Debug17BasePipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_ED0Ev()
{
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::Debug::BasePipelineSetup * ()(void)>::operator()()
{
}

void sub_1A1FD29A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, std::__shared_weak_count *a14)
{
  if (!atomic_fetch_add(v16, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
    std::__shared_weak_count::__release_weak(v15);
  }
  if (a14)
  {
    if (!atomic_fetch_add(&a14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a14->__on_zero_shared)(a14);
      std::__shared_weak_count::__release_weak(a14);
    }
  }
  MEMORY[0x1A6239270](v14, 0xE1C40C3CBA79CLL);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::Debug::BasePipelineSetup * ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::Debug::BasePipelineSetup * ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::Debug::BasePipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1EF572588;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::Debug::BasePipelineSetup * ()(void)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x18uLL);
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 16);
  *BOOL result = &unk_1EF572588;
  result[1] = v4;
  result[2] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::Debug::BasePipelineSetup * ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF572588;
  uint64_t v1 = (std::__shared_weak_count *)a1[2];
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
  JUMPOUT(0x1A6239270);
}

void *std::__function::__func<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1,std::allocator<md::RouteRenderLayer::layoutDebugRouteLineSnappingStatus(std::shared_ptr<md::RouteLineOverlay> const&,ggl::StandardLibrary const&,md::LayoutContext const&,ggl::CommandBuffer *)::$_1>,ggl::Debug::BasePipelineSetup * ()(void)>::~__func(void *a1)
{
  *a1 = &unk_1EF572588;
  uint64_t v2 = (std::__shared_weak_count *)a1[2];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::Debug::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::Debug::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589048;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::Debug::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF589048;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return ggl::CommandBuffer::pushRenderItem(*(void *)(a1 + 8), *a3);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579188;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF579188;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteStyledOverlayRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

void __destroy_helper_block_ea8_40c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_40c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void *std::function<void ()(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return ggl::CommandBuffer::pushRenderItem(*(void *)(a1 + 8), *a3);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5790F8;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF5790F8;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineArrowRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteLineArrowRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

uint64_t __Block_byref_object_copy__45(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void __Block_byref_object_dispose__46(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<md::RouteLineArrowBatchKey const,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4)
  {
    operator delete(v4);
  }
}

void ___ZN2md16RouteRenderLayer15addArrowRibbonsERKNS_13LayoutContextERKNSt3__110shared_ptrINS_16RouteLineOverlayEEE_block_invoke()
{
}

void sub_1A1FD31E4(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10E1C408A7D4C0DLL);
  _Unwind_Resume(a1);
}

void (****std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>::~unique_ptr[abi:nn180100](void (****a1)(void)))(void)
{
  uint64_t v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    (**v2)(v2);
    uint64_t v3 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v3 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v5) {
        operator new();
      }
    }
    (*(void (**)(void, void (***)(void), uint64_t))(**((void **)v3 + 91) + 40))(*((void *)v3 + 91), v2, 104);
  }
  return a1;
}

uint64_t std::unordered_map<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::__destroy_at[abi:nn180100]<std::pair<md::RouteLineArrowBatchKey const,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void std::__destroy_at[abi:nn180100]<std::pair<md::RouteLineArrowBatchKey const,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 24);
    uint64_t v4 = *(void *)(a1 + 16);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = (void (***)(void, uint64_t))*--v3;
        int v5 = v6;
        *uint64_t v3 = 0;
        if (v6)
        {
          (**v5)(v5, v4);
          {
            operator new();
          }
          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                           + 40))(mdm::Allocator::instance(void)::alloc, v5, 104);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void *)(a1 + 16);
    }
    *(void *)(a1 + 24) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), v4, *(void *)(a1 + 32) - v4);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 8);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t std::unique_ptr<std::__hash_node<std::__hash_value_type<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::RouteLineArrowBatchKey,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,void *>>>>::~unique_ptr[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)a1;
  *(void *)a1 = 0;
  if (v2)
  {
    if (*(unsigned char *)(a1 + 16)) {
      std::__destroy_at[abi:nn180100]<std::pair<md::RouteLineArrowBatchKey const,std::vector<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineArrowRibbon,mdm::TypeDeleter<md::RouteLineArrowRibbon>>,mdm::Allocator>>>,0>((uint64_t)v2 + 16);
    }
    operator delete(v2);
  }
  return a1;
}

void md::RouteLineArrowRibbon::~RouteLineArrowRibbon(md::RouteLineArrowRibbon *this)
{
  *(void *)this = &unk_1EF553D90;
  if (*((unsigned char *)this + 64))
  {
    uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v3) {
        operator new();
      }
    }
    (*(void (**)(void, void, void))(**((void **)v2 + 91) + 40))(*((void *)v2 + 91), *((void *)this + 9), 0);
  }
  JUMPOUT(0x1A6239270);
}

{
  float *v2;
  int v3;

  *(void *)this = &unk_1EF553D90;
  if (*((unsigned char *)this + 64))
  {
    uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v3) {
        operator new();
      }
    }
    (*(void (**)(void, void, void))(**((void **)v2 + 91) + 40))(*((void *)v2 + 91), *((void *)this + 9), 0);
  }
}

void md::RouteLineDrawAnimation::updateStyle(uint64_t a1, unsigned char *a2, unsigned char *a3)
{
  size_t v3 = a3 - a2;
  if (a3 != a2)
  {
    if ((v3 & 0x8000000000000000) != 0) {
      abort();
    }
    uint64_t v6 = operator new(a3 - a2);
    memcpy(v6, a2, v3);
    uint64_t v7 = *(void *)(*(void *)(*(void *)(*(void *)v6 + 2560) + 64) + 32);
    uint64_t v8 = *(void *)(v7 + 8);
    if ((*(unsigned char *)(v7 + 16) & 2) == 0
      && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
    {
      int v16 = &v14;
      int v15 = &v16;
      std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v15, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
    }
    if (v8) {
      int v9 = *(long long **)(v7 + 72);
    }
    else {
      int v9 = 0;
    }
    int v10 = *(void **)(*(void *)(*(void *)(a1 + 8) + 64) + 32);
    unint64_t v11 = v10[1];
    if (v11) {
      uint64_t v12 = v10[9];
    }
    else {
      uint64_t v12 = 0;
    }
    long long v13 = *v9;
    *(_DWORD *)(v12 + 8) = *((void *)v9 + 1);
    *(void *)uint64_t v12 = v13;
    *(_DWORD *)(v12 + 16) = *((_DWORD *)v9 + 4);
    *(_DWORD *)(v12 + 20) = *((_DWORD *)v9 + 5);
    *(_DWORD *)(v12 + 24) = *((_DWORD *)v9 + 6);
    *(_DWORD *)(v12 + 28) = *((_DWORD *)v9 + 7);
    *(_DWORD *)(v12 + 32) = *((_DWORD *)v9 + 8);
    *(_DWORD *)(v12 + 36) = *((_DWORD *)v9 + 9);
    *(_DWORD *)(v12 + 40) = *((_DWORD *)v9 + 10);
    *(_DWORD *)(v12 + 44) = *((_DWORD *)v9 + 11);
    *(_OWORD *)(v12 + 48) = v9[3];
    *(_DWORD *)(v12 + 64) = *((_DWORD *)v9 + 16);
    *(_DWORD *)(v12 + 80) = *((_DWORD *)v9 + 20);
    *(_DWORD *)(v12 + 84) = *((_DWORD *)v9 + 21);
    *(_DWORD *)(v12 + 88) = *((_DWORD *)v9 + 22);
    *(_DWORD *)(v12 + 92) = *((_DWORD *)v9 + 23);
    *(_DWORD *)(v12 + 96) = *((_DWORD *)v9 + 24);
    *(_DWORD *)(v12 + 100) = *((_DWORD *)v9 + 25);
    *(_DWORD *)(v12 + 104) = *((_DWORD *)v9 + 26);
    *(_DWORD *)(v12 + 108) = *((_DWORD *)v9 + 27);
    *(_DWORD *)(v12 + 112) = *((_DWORD *)v9 + 28);
    *(_DWORD *)(v12 + 116) = *((_DWORD *)v9 + 29);
    *(_DWORD *)(v12 + 120) = *((_DWORD *)v9 + 30);
    *(_DWORD *)(v12 + 124) = *((_DWORD *)v9 + 31);
    *(_DWORD *)(v12 + 128) = *((_DWORD *)v9 + 32);
    *(_DWORD *)(v12 + 132) = *((_DWORD *)v9 + 33);
    *(_DWORD *)(v12 + 136) = *((_DWORD *)v9 + 34);
    *(_DWORD *)(v12 + 140) = *((_DWORD *)v9 + 35);
    *(_DWORD *)(v12 + 144) = *((_DWORD *)v9 + 36);
    *(_DWORD *)(v12 + 148) = *((_DWORD *)v9 + 37);
    *(_DWORD *)(v12 + 152) = *((_DWORD *)v9 + 38);
    *(_DWORD *)(v12 + 156) = *((_DWORD *)v9 + 39);
    *(_DWORD *)(v12 + 160) = *((_DWORD *)v9 + 40);
    *(_DWORD *)(v12 + 164) = *((_DWORD *)v9 + 41);
    *(_DWORD *)(v12 + 168) = *((_DWORD *)v9 + 42);
    *(_DWORD *)(v12 + 172) = *((_DWORD *)v9 + 43);
    *(_DWORD *)(v12 + 176) = *((_DWORD *)v9 + 44);
    *(_DWORD *)(v12 + 180) = *((_DWORD *)v9 + 45);
    *(_DWORD *)(v12 + 184) = *((_DWORD *)v9 + 46);
    *(_DWORD *)(v12 + 188) = *((_DWORD *)v9 + 47);
    *(_DWORD *)(v12 + 192) = *((_DWORD *)v9 + 48);
    *(_DWORD *)(v12 + 196) = *((_DWORD *)v9 + 49);
    *(_DWORD *)(v12 + 200) = *((_DWORD *)v9 + 50);
    *(_DWORD *)(v12 + 204) = *((_DWORD *)v9 + 51);
    *(_DWORD *)(v12 + 208) = *((_DWORD *)v9 + 52);
    *(_DWORD *)(v12 + 212) = *((_DWORD *)v9 + 53);
    *(_DWORD *)(v12 + 216) = *((_DWORD *)v9 + 54);
    *(_DWORD *)(v12 + 220) = *((_DWORD *)v9 + 55);
    *(_DWORD *)(v12 + 224) = *((_DWORD *)v9 + 56);
    *(_DWORD *)(v12 + 228) = *((_DWORD *)v9 + 57);
    *(_DWORD *)(v12 + 232) = *((_DWORD *)v9 + 58);
    *(_DWORD *)(v12 + 236) = *((_DWORD *)v9 + 59);
    if (v12 && v11)
    {
      if (v10[8] > v11) {
        unint64_t v11 = v10[8];
      }
      v10[7] = 0;
      v10[8] = v11;
    }
    operator delete(v6);
  }
}

void *std::function<void ()(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return ggl::CommandBuffer::pushRenderItem(*(void *)(a1 + 8), *a3);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579020;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF579020;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::SolidTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::SolidTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

void *std::function<void ()(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return ggl::CommandBuffer::pushRenderItem(*(void *)(a1 + 8), *a3);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579068;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF579068;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::PilledTrafficRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::PilledTrafficRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

void __destroy_helper_block_ea8_48c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_48c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_48c68_ZTSNSt3__110shared_ptrIN3gss15StylesheetQueryINS1_10PropertyIDEEEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 56);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_48c68_ZTSNSt3__110shared_ptrIN3gss15StylesheetQueryINS1_10PropertyIDEEEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 56);
  *(void *)(result + 48) = *(void *)(a2 + 48);
  *(void *)(result + 56) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return ggl::CommandBuffer::pushRenderItem(*(void *)(a1 + 8), *a3);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579140;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF579140;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::DottedRouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::DottedRouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return ggl::CommandBuffer::pushRenderItem(*(void *)(a1 + 8), *a3);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578F90;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t a1)
{
  BOOL result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *BOOL result = &unk_1EF578F90;
  result[1] = v3;
  return result;
}

void std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RouteLineRibbonDescriptor>::collectRenderItemsForPassesNoReset(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RouteLineRibbonDescriptor::Passes,ggl::RenderItem *)>::~__func()
{
}

void md::SinglePassRoutePipelineStateManager::pipelineStateForFunctionConstants(std::__shared_weak_count **a1, uint64_t a2, char *a3)
{
  char v4 = *a3;
  unsigned __int8 v5 = a3[1];
  v6.i64[0] = *a3;
  *(__int32 *)((char *)v6.i32 + 1) = v5;
  v6.i8[7] = a3[2];
  unsigned __int8 v7 = a3[3];
  v6.i64[1] = v7;
  int8x16_t v8 = vceqzq_s8(v6);
  int16x8_t v9 = vmovl_s8(*(int8x8_t *)v8.i8);
  int32x4_t v10 = vmovl_high_s16(v9);
  v11.i64[0] = v10.u32[2];
  v11.i64[1] = v10.u32[3];
  int8x16_t v12 = v11;
  int16x8_t v13 = vmovl_high_s8(v8);
  int32x4_t v14 = vmovl_high_s16(v13);
  v11.i64[0] = v14.u32[2];
  v11.i64[1] = v14.u32[3];
  int8x16_t v15 = v11;
  int32x4_t v16 = vmovl_s16(*(int16x4_t *)v9.i8);
  v11.i64[0] = v16.u32[2];
  v11.i64[1] = v16.u32[3];
  int8x16_t v17 = v11;
  int32x4_t v18 = vmovl_s16(*(int16x4_t *)v13.i8);
  v11.i64[0] = v18.u32[2];
  v11.i64[1] = v18.u32[3];
  int8x16_t v19 = v11;
  v11.i64[0] = v10.u32[0];
  v11.i64[1] = v10.u32[1];
  int8x16_t v20 = v11;
  v11.i64[0] = v14.u32[0];
  v11.i64[1] = v14.u32[1];
  int8x16_t v21 = v11;
  v11.i64[0] = v16.u32[0];
  v11.i64[1] = v16.u32[1];
  int8x16_t v22 = v11;
  v11.i64[0] = v18.u32[0];
  v11.i64[1] = v18.u32[1];
  unint64_t v23 = vaddvq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v22), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v11)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v20), vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v21))), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v17), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v19)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC980, v12), vbicq_s8((int8x16_t)xmmword_1A28FC990, v15)))));
  unint64_t v24 = v23;
  int v26 = (uint64_t **)(a2 + 104);
  int v25 = *(void **)(a2 + 104);
  if (!v25) {
    goto LABEL_12;
  }
  int v27 = (uint64_t **)(a2 + 104);
  do
  {
    unint64_t v28 = v25[4];
    BOOL v29 = v28 >= v23;
    if (v28 >= v23) {
      uint64_t v30 = v25;
    }
    else {
      uint64_t v30 = v25 + 1;
    }
    if (v29) {
      int v27 = (uint64_t **)v25;
    }
    int v25 = (void *)*v30;
  }
  while (*v30);
  if (v27 != v26 && v23 >= (unint64_t)v27[4])
  {
    *a1 = (std::__shared_weak_count *)v27[5];
    int v114 = v27[6];
    a1[1] = (std::__shared_weak_count *)v114;
    if (v114) {
      atomic_fetch_add_explicit(v114 + 1, 1uLL, memory_order_relaxed);
    }
  }
  else
  {
LABEL_12:
    unsigned __int8 v116 = a3[2];
    int v31 = (std::__shared_weak_count *)operator new(0x198uLL);
    v31->__shared_owners_ = 0;
    v31->__shared_weak_owners_ = 0;
    v31->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588328;
    int v32 = v31 + 1;
    long long v118 = *(_OWORD *)(a2 + 16);
    long long v119 = *(_OWORD *)(a2 + 32);
    {
      if (v115)
      {
        {
          if (v115)
          {
            {
              {
                ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::RouteLine::defaultVboReflection;
              }
              ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::attributesReflection(void)::r;
              unk_1EB32B798 = 1;
            }
            ggl::SinglePassRouteLine::BasePipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::RouteLine::DefaultVbo>::typedReflection(void)::r;
            unk_1E958D4B0 = &ggl::SinglePassRouteLine::pipelineDataBasePipelineDeviceStructs(void)::ref;
            qword_1E958D4B8 = 0;
            {
              ggl::SinglePassRouteLine::pipelineDataBasePipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
              *(void *)algn_1E958D4E8 = ggl::Tile::Transform::reflection(void)::reflection;
              qword_1E958D4F0 = (uint64_t)ggl::SinglePassRouteLine::Style::reflection(void)::reflection;
              unk_1E958D4F8 = ggl::SinglePassRouteLine::ClipParams::reflection(void)::reflection;
              qword_1E958D500 = (uint64_t)ggl::SinglePassRouteLine::DrawAnimationDescription::reflection(void)::reflection;
            }
            qword_1E958D4C0 = (uint64_t)&ggl::SinglePassRouteLine::pipelineDataBasePipelineConstantStructs(void)::ref;
            *(_OWORD *)algn_1E958D4C8 = xmmword_1A28FC940;
          }
        }
        ggl::SinglePassRouteLine::BasePipelineState::typedReflection(void)::ref = (uint64_t)&ggl::SinglePassRouteLine::BasePipelineSetup::typedReflection(void)::ref;
        ggl::SinglePassRouteLineShader::typedReflection(v115);
        qword_1E957EB78 = (uint64_t)&ggl::SinglePassRouteLineShader::typedReflection(void)::ref;
        {
          ggl::SinglePassRouteLine::pipelineStateBasePipelineAttributeStructBinding(void)::attr = 0;
          *(void *)algn_1E957ECB8 = 0;
          qword_1E957ECC0 = (uint64_t)"";
          dword_1E957ECC8 = 0;
          qword_1E957ECD0 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineAttributeBinding_0(void)::attr;
          unk_1E957ECD8 = 7;
        }
        qword_1E957EB80 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineAttributeStructBinding(void)::attr;
        *(void *)algn_1E957EB88 = 1;
        qword_1E957EB90 = 0;
        unk_1E957EB98 = 1;
        qword_1E957EBA0 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineDeviceStructBinding(void)::ref;
        unk_1E957EBA8 = 0;
        {
          ggl::SinglePassRouteLine::pipelineStateBasePipelineConstantStructBinding(void)::ref = 0;
          *(void *)algn_1E957EBC8 = 0;
          qword_1E957EBD0 = (uint64_t)"view";
          dword_1E957EBD8 = 3;
          qword_1E957EBE0 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineConstantViewBinding(void)::reflection;
          unk_1E957EBE8 = xmmword_1A28FCEB0;
          qword_1E957EBF8 = 1;
          unk_1E957EC00 = "transform";
          dword_1E957EC08 = 3;
          qword_1E957EC10 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineConstantTransformBinding(void)::reflection;
          unk_1E957EC18 = xmmword_1A28FCF70;
          qword_1E957EC28 = 2;
          unk_1E957EC30 = "style";
          dword_1E957EC38 = 3;
          qword_1E957EC40 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineConstantStyleBinding(void)::reflection;
          unk_1E957EC48 = xmmword_1A28FD5E0;
          qword_1E957EC58 = 3;
          unk_1E957EC60 = "clipParams";
          dword_1E957EC68 = 3;
          qword_1E957EC70 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineConstantClipParamsBinding(void)::reflection;
          unk_1E957EC78 = xmmword_1A28FD5F0;
          qword_1E957EC88 = 4;
          unk_1E957EC90 = "animationDescription";
          dword_1E957EC98 = 3;
          qword_1E957ECA0 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineConstantAnimationDescriptionBinding(void)::reflection;
          unk_1E957ECA8 = 2;
        }
        qword_1E957EBB0 = (uint64_t)&ggl::SinglePassRouteLine::pipelineStateBasePipelineConstantStructBinding(void)::ref;
        *(void *)algn_1E957EBB8 = 5;
      }
    }
    int v33 = *(std::__shared_weak_count_vtbl **)a2;
    long long v34 = *(std::__shared_weak_count **)(a2 + 8);
    if (v34) {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(_OWORD *)BOOL v120 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)&v120[12] = *(_OWORD *)(a2 + 60);
    long long v35 = *(_OWORD *)(a2 + 76);
    char v36 = *(unsigned char *)(a2 + 92);
    v31[1].__shared_weak_owners_ = 0;
    v31[2].__vftable = 0;
    LODWORD(v31[2].__shared_owners_) = 0;
    v31[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55B208;
    v31[1].__shared_owners_ = 0;
    v31[2].__shared_weak_owners_ = (uint64_t)&ggl::SinglePassRouteLine::BasePipelineState::typedReflection(void)::ref;
    v31[3].__vftable = v33;
    v31[3].__shared_owners_ = (uint64_t)v34;
    if (v34) {
      atomic_fetch_add_explicit(&v34->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    LOBYTE(v31[5].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v31[5].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v31[6].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v31[7].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v31[6].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v31[7].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v31[7].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v31[8].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v31[9].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v31[8].__shared_weak_owners_ + 4) = 0;
    LOBYTE(v31[9].__shared_weak_owners_) = 0;
    *(_OWORD *)((char *)&v31[9].__shared_weak_owners_ + 4) = xmmword_1A28FC970;
    *(uint64_t *)((char *)&v31[10].__shared_owners_ + 4) = 0;
    *(std::__shared_weak_count_vtbl **)((char *)&v31[11].__vftable + 4) = 0;
    *(uint64_t *)((char *)&v31[10].__shared_weak_owners_ + 4) = 0;
    *(_OWORD *)&v31[11].__shared_weak_owners_ = v118;
    *(_OWORD *)&v31[12].__shared_owners_ = v119;
    LOBYTE(v31[13].__vftable) = 0;
    v31[16].__vftable = 0;
    *(_OWORD *)&v31[14].__shared_weak_owners_ = 0u;
    *(_OWORD *)&v31[15].__shared_owners_ = 0u;
    *(_OWORD *)&v31[13].__shared_owners_ = 0u;
    v31[14].std::__shared_count = 0u;
    v31[16].__shared_owners_ = 0x100000001;
    LOBYTE(v31[16].__shared_weak_owners_) = 0;
    *(std::__shared_count *)((char *)&v31[4].std::__shared_count + 4) = *(std::__shared_count *)&v120[12];
    *(_OWORD *)&v31[3].__shared_weak_owners_ = *(_OWORD *)v120;
    *(_OWORD *)((char *)&v31[4].__shared_weak_owners_ + 4) = v35;
    BYTE4(v31[5].__shared_owners_) = v36;
    if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
    LOBYTE(v31[13].__shared_weak_owners_) = v4;
    BYTE1(v31[13].__shared_weak_owners_) = v5;
    BYTE6(v31[13].__shared_weak_owners_) = 0;
    *(_DWORD *)((char *)&v31[13].__shared_weak_owners_ + 2) = 0;
    HIBYTE(v31[13].__shared_weak_owners_) = v116;
    LOBYTE(v31[14].__vftable) = v7;
    *(_WORD *)((char *)&v31[14].__vftable + 1) = 0;
    BYTE3(v31[14].__vftable) = 0;
    int8x16_t v37 = *(int8x16_t *)&v31[14].__shared_owners_;
    int8x16_t v38 = vceqzq_s8(*(int8x16_t *)&v31[13].__shared_weak_owners_);
    int16x8_t v39 = vmovl_high_s8(v38);
    int32x4_t v40 = vmovl_s16(*(int16x4_t *)v39.i8);
    v41.i64[0] = v40.u32[0];
    v41.i64[1] = v40.u32[1];
    int8x16_t v42 = v41;
    int16x8_t v43 = vmovl_s8(*(int8x8_t *)v38.i8);
    int32x4_t v44 = vmovl_s16(*(int16x4_t *)v43.i8);
    v41.i64[0] = v44.u32[0];
    v41.i64[1] = v44.u32[1];
    int8x16_t v45 = v41;
    int32x4_t v46 = vmovl_high_s16(v39);
    v41.i64[0] = v46.u32[0];
    v41.i64[1] = v46.u32[1];
    int8x16_t v47 = v41;
    int32x4_t v48 = vmovl_high_s16(v43);
    v41.i64[0] = v48.u32[0];
    v41.i64[1] = v48.u32[1];
    int8x16_t v49 = v41;
    v41.i64[0] = v40.u32[2];
    v41.i64[1] = v40.u32[3];
    int8x16_t v50 = v41;
    v41.i64[0] = v44.u32[2];
    v41.i64[1] = v44.u32[3];
    int8x16_t v51 = v41;
    v41.i64[0] = v46.u32[2];
    v41.i64[1] = v46.u32[3];
    int8x16_t v52 = v41;
    v41.i64[0] = v48.u32[2];
    v41.i64[1] = v48.u32[3];
    int8x16_t v53 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v41);
    v31[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55F4C0;
    int8x16_t v54 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v52);
    int8x16_t v55 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v51);
    int8x16_t v56 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v47);
    int8x16_t v57 = vceqzq_s8(v37);
    int16x8_t v58 = vmovl_high_s8(v57);
    int32x4_t v59 = vmovl_s16(*(int16x4_t *)v58.i8);
    v41.i64[0] = v59.u32[0];
    v41.i64[1] = v59.u32[1];
    int8x16_t v60 = v41;
    int16x8_t v61 = vmovl_s8(*(int8x8_t *)v57.i8);
    int32x4_t v62 = vmovl_s16(*(int16x4_t *)v61.i8);
    v41.i64[0] = v62.u32[0];
    v41.i64[1] = v62.u32[1];
    int8x16_t v63 = v41;
    int32x4_t v64 = vmovl_high_s16(v58);
    v41.i64[0] = v64.u32[0];
    v41.i64[1] = v64.u32[1];
    int8x16_t v65 = v41;
    int32x4_t v66 = vmovl_high_s16(v61);
    v41.i64[0] = v66.u32[0];
    v41.i64[1] = v66.u32[1];
    int8x16_t v67 = v41;
    v41.i64[0] = v59.u32[2];
    v41.i64[1] = v59.u32[3];
    int8x16_t v68 = v41;
    v41.i64[0] = v62.u32[2];
    v41.i64[1] = v62.u32[3];
    int8x16_t v69 = v41;
    v41.i64[0] = v64.u32[2];
    v41.i64[1] = v64.u32[3];
    int8x16_t v70 = v41;
    v41.i64[0] = v66.u32[2];
    v41.i64[1] = v66.u32[3];
    int8x16_t v71 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v70);
    int8x16_t v72 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v60), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v42));
    int8x16_t v73 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v63), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v45));
    int8x16_t v74 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v65), v56);
    int8x16_t v75 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v67), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v49));
    int8x16_t v76 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v68), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v50));
    int8x16_t v77 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v69), v55);
    int8x16_t v78 = vorrq_s8(v71, v54);
    int8x16_t v79 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v41), v53);
    int8x16_t v80 = vceqzq_s8((int8x16_t)v31[15].std::__shared_count);
    int16x8_t v81 = vmovl_s8(*(int8x8_t *)v80.i8);
    int32x4_t v82 = vmovl_high_s16(v81);
    v41.i64[0] = v82.i32[2];
    v41.i64[1] = v82.i32[3];
    int8x16_t v83 = v41;
    int16x8_t v84 = vmovl_high_s8(v80);
    int32x4_t v85 = vmovl_high_s16(v84);
    v41.i64[0] = v85.i32[2];
    v41.i64[1] = v85.i32[3];
    int8x16_t v86 = v41;
    int32x4_t v87 = vmovl_s16(*(int16x4_t *)v81.i8);
    v41.i64[0] = v87.i32[2];
    v41.i64[1] = v87.i32[3];
    int8x16_t v88 = v41;
    int32x4_t v89 = vmovl_s16(*(int16x4_t *)v84.i8);
    v41.i64[0] = v89.i32[2];
    v41.i64[1] = v89.i32[3];
    int8x16_t v90 = v41;
    v41.i64[0] = v82.i32[0];
    v41.i64[1] = v82.i32[1];
    int8x16_t v91 = v41;
    v41.i64[0] = v85.i32[0];
    v41.i64[1] = v85.i32[1];
    int8x16_t v92 = v41;
    v41.i64[0] = v87.i32[0];
    v41.i64[1] = v87.i32[1];
    int8x16_t v93 = v41;
    v41.i64[0] = v89.i32[0];
    v41.i64[1] = v89.i32[1];
    int8x16_t v94 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v41);
    int8x16_t v95 = vceqzq_s8(*(int8x16_t *)&v31[15].__shared_weak_owners_);
    int16x8_t v96 = vmovl_high_s8(v95);
    int32x4_t v97 = vmovl_s16(*(int16x4_t *)v96.i8);
    v41.i64[0] = v97.i32[0];
    v41.i64[1] = v97.i32[1];
    int8x16_t v98 = v41;
    int16x8_t v99 = vmovl_s8(*(int8x8_t *)v95.i8);
    int32x4_t v100 = vmovl_s16(*(int16x4_t *)v99.i8);
    v41.i64[0] = v100.i32[0];
    v41.i64[1] = v100.i32[1];
    int8x16_t v101 = v41;
    int32x4_t v102 = vmovl_high_s16(v96);
    v41.i64[0] = v102.i32[0];
    v41.i64[1] = v102.i32[1];
    int8x16_t v103 = v41;
    int32x4_t v104 = vmovl_high_s16(v99);
    v41.i64[0] = v104.i32[0];
    v41.i64[1] = v104.i32[1];
    int8x16_t v105 = v41;
    v41.i64[0] = v97.i32[2];
    v41.i64[1] = v97.i32[3];
    int8x16_t v106 = v41;
    v41.i64[0] = v100.i32[2];
    v41.i64[1] = v100.i32[3];
    int8x16_t v107 = v41;
    v41.i64[0] = v102.i32[2];
    v41.i64[1] = v102.i32[3];
    int8x16_t v108 = v41;
    v41.i64[0] = v104.i32[2];
    v41.i64[1] = v104.i32[3];
    v31[13].__shared_owners_ = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v101), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v93)), v73), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v98), v94), v72)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v105), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v91)), v75), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB40, v103),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCA90, v92)),
                                                    v74))),
                                   (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v107), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v88)), v77), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v106), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v90)), v76)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v41), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v83)), v79), vorrq_s8(vorrq_s8(
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCB00, v108),
                                                      vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v86)),
                                                    v78)))));
    LOBYTE(v31[13].__vftable) = 1;
    *a1 = v32;
    a1[1] = v31;
    atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
    int v109 = *v26;
    int v110 = v26;
    if (*v26)
    {
      while (1)
      {
        while (1)
        {
          int v110 = (uint64_t **)v109;
          unint64_t v111 = v109[4];
          if (v24 >= v111) {
            break;
          }
          int v109 = *v110;
          int v26 = v110;
          if (!*v110) {
            goto LABEL_27;
          }
        }
        if (v111 >= v24) {
          break;
        }
        int v109 = v110[1];
        if (!v109)
        {
          int v26 = v110 + 1;
          goto LABEL_27;
        }
      }
      if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
        std::__shared_weak_count::__release_weak(v31);
      }
    }
    else
    {
LABEL_27:
      int v112 = (uint64_t *)operator new(0x38uLL);
      v112[4] = v24;
      v112[5] = (uint64_t)v32;
      v112[6] = (uint64_t)v31;
      *int v112 = 0;
      v112[1] = 0;
      v112[2] = (uint64_t)v110;
      *int v26 = v112;
      uint64_t v113 = **(void **)(a2 + 96);
      if (v113)
      {
        *(void *)(a2 + 96) = v113;
        int v112 = *v26;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a2 + 104), v112);
      ++*(void *)(a2 + 112);
    }
  }
}

void sub_1A1FD4930(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  md::components::Material::~Material((md::components::Material *)&a29);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v29);
  _Unwind_Resume(a1);
}

uint64_t gss::QueryableLocker<gss::PropertyID>::hasValueForKey(uint64_t a1, unsigned int a2)
{
  char v4 = *(float **)a1;
  if (*(void *)a1
    && (float v5 = *v4, LODWORD(v4) = *v4 == 1.0, *(unsigned char *)(a1 + 10))
    && (v5 != 0.0 ? (BOOL v6 = v5 == 1.0) : (BOOL v6 = 1), !v6)
    || (unsigned int v7 = *(unsigned __int8 *)(a1 + v4 + 11), v7 == 2))
  {
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(a1, a2, 0)) {
      return 1;
    }
    unsigned int v7 = 1;
  }
  return gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(a1, a2, v7);
}

uint64_t gss::QueryableLocker<gss::PropertyID>::value<(gss::PropertyID)415>(uint64_t a1)
{
  uint64_t v2 = *(float **)a1;
  if (!*(void *)a1
    || (float v3 = *v2, LODWORD(v2) = *v2 == 1.0, !*(unsigned char *)(a1 + 10))
    || (v3 != 0.0 ? (BOOL v4 = v3 == 1.0) : (BOOL v4 = 1), v4))
  {
    unsigned int v5 = *(unsigned __int8 *)(a1 + v2 + 11);
    if (v5 != 2) {
      return gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x19Fu, v5, 0);
    }
  }
  char v8 = 1;
  char v7 = 1;
  gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x19Fu, 0, &v8);
  return gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x19Fu, 1u, &v7);
}

uint64_t gss::QueryableLocker<gss::PropertyID>::value<(gss::PropertyID)416>(uint64_t a1)
{
  uint64_t v2 = *(float **)a1;
  if (!*(void *)a1
    || (float v3 = *v2, LODWORD(v2) = *v2 == 1.0, !*(unsigned char *)(a1 + 10))
    || (v3 != 0.0 ? (BOOL v4 = v3 == 1.0) : (BOOL v4 = 1), v4))
  {
    unsigned int v5 = *(unsigned __int8 *)(a1 + v2 + 11);
    if (v5 != 2) {
      return gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x1A0u, v5, 0);
    }
  }
  char v8 = 1;
  char v7 = 1;
  gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x1A0u, 0, &v8);
  return gss::RenderStyle<gss::PropertyID>::styleValueForKey<float>(a1, 0x1A0u, 1u, &v7);
}

void ___ZN2md16RouteRenderLayer30updateRoutelineDrawinAnimationERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEN3geo18PolylineCoordinateE_block_invoke(uint64_t a1, float a2)
{
  float v3 = *(std::__shared_weak_count **)(a1 + 40);
  if (v3)
  {
    unsigned int v5 = std::__shared_weak_count::lock(v3);
    unint64_t v23 = v5;
    if (v5)
    {
      BOOL v6 = v5;
      uint64_t v7 = *(void *)(a1 + 32);
      uint64_t v22 = v7;
      if (v7 && *(void *)(v7 + 320) && *(unsigned char *)(v7 + 848) && !*(unsigned char *)(v7 + 849))
      {
        int v21 = 0;
        char v8 = [*(id *)(*(void *)(a1 + 48) + 144) routeRibbon];
        PolylineCoordinate v9 = *(PolylineCoordinate *)(a1 + 64);
        md::RouteLineDrawAnimation::rebuildAnimationSegments((md::RouteLineDrawAnimation *)(v7 + 632), v8, v9);
        float v10 = md::RouteLineDrawAnimation::update((md::RouteLineDrawAnimation *)(v7 + 632), a2, &v21);
        uint64_t v11 = *(void *)(v7 + 320);
        int8x16_t v12 = *(uint64_t **)(v11 + 8);
        int16x8_t v13 = *(uint64_t **)(v11 + 16);
        if (v12 != v13)
        {
          unint64_t v14 = v21;
          if (v10 < 1.0)
          {
            do
            {
              uint64_t v15 = *v12;
              if (*(unsigned char *)(*v12 + 2448))
              {
                unint64_t v16 = *(void *)(*(void *)(v15 + 2456) + 216);
                if (v16 >= v14) {
                  float v17 = 0.0;
                }
                else {
                  float v17 = 1.0;
                }
                if (v16 == v14) {
                  float v17 = v10;
                }
                *(float *)(v15 + 2584) = v17;
              }
              ++v12;
            }
            while (v12 != v13);
          }
          else
          {
            do
            {
              uint64_t v18 = *v12;
              if (*(unsigned char *)(*v12 + 2448))
              {
                unint64_t v19 = *(void *)(*(void *)(v18 + 2456) + 216);
                float v20 = v10;
                if (v19 != v14)
                {
                  float v20 = 1.0;
                  if (v19 >= v14)
                  {
                    if (v19 <= v14) {
                      float v20 = 0.0;
                    }
                    else {
                      float v20 = 1.0;
                    }
                  }
                }
                *(float *)(v18 + 2584) = v20;
              }
              ++v12;
            }
            while (v12 != v13);
          }
        }
      }
      if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
    }
  }
}

void sub_1A1FD4D54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ___ZN2md16RouteRenderLayer30updateRoutelineDrawinAnimationERKNS_13LayoutContextENSt3__110shared_ptrINS_16RouteLineOverlayEEEN3geo18PolylineCoordinateE_block_invoke_11(uint64_t a1, int a2)
{
  uint64_t v12 = 0;
  int16x8_t v13 = 0;
  BOOL v4 = *(std::__shared_weak_count **)(a1 + 40);
  if (v4)
  {
    unsigned int v5 = std::__shared_weak_count::lock(v4);
    int16x8_t v13 = v5;
    if (v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v12 = v6;
      if (!a2)
      {
LABEL_15:
        if (!v6) {
          goto LABEL_18;
        }
        goto LABEL_16;
      }
    }
    else
    {
      uint64_t v6 = 0;
      if (!a2) {
        goto LABEL_15;
      }
    }
  }
  else
  {
    unsigned int v5 = 0;
    uint64_t v6 = 0;
    if (!a2) {
      goto LABEL_15;
    }
  }
  if (!v6) {
    goto LABEL_18;
  }
  if (*(unsigned char *)(v6 + 848))
  {
    if (!*(unsigned char *)(v6 + 849))
    {
      uint64_t v7 = *(void *)(v6 + 320);
      uint64_t v8 = *(void *)(v7 + 8);
      for (uint64_t i = *(void *)(v7 + 16); v8 != i; v8 += 8)
      {
        if (*(unsigned char *)(*(void *)v8 + 2448)) {
          *(_DWORD *)(*(void *)v8 + 2584) = 1065353216;
        }
      }
    }
  }
LABEL_16:
  *(_WORD *)(v6 + 848) = 256;
  float v10 = *(void **)(v6 + 696);
  if (v10)
  {
    objc_msgSend(v10, "stop", v12, v13);
    uint64_t v11 = *(void **)(v6 + 696);
    *(void *)(v6 + 696) = 0;
  }
LABEL_18:
  if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
    std::__shared_weak_count::__release_weak(v5);
  }
}

void sub_1A1FD4EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void __destroy_helper_block_ea8_32c46_ZTSNSt3__18weak_ptrIN2md16RouteLineOverlayEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t __copy_helper_block_ea8_32c46_ZTSNSt3__18weak_ptrIN2md16RouteLineOverlayEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

void __destroy_helper_block_ea8_32c46_ZTSNSt3__18weak_ptrIN2md16RouteLineOverlayEEE48c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 56);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    float v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v3) {
      return;
    }
  }
  else
  {
    float v3 = *(std::__shared_weak_count **)(a1 + 40);
    if (!v3) {
      return;
    }
  }
  std::__shared_weak_count::__release_weak(v3);
}

void *__copy_helper_block_ea8_32c46_ZTSNSt3__18weak_ptrIN2md16RouteLineOverlayEEE48c49_ZTSNSt3__110shared_ptrIN2md16RouteLineOverlayEEE(void *result, void *a2)
{
  uint64_t v2 = a2[5];
  result[4] = a2[4];
  result[5] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  uint64_t v3 = a2[7];
  result[6] = a2[6];
  result[7] = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<ggl::SinglePassRouteLine::BasePipelineState>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::SinglePassRouteLine::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588328;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::SinglePassRouteLine::BasePipelineState>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588328;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t __Block_byref_object_copy__14_7011(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void __Block_byref_object_dispose__15_7012(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::pair<md::RouteStyledOverlayBatchKey const,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>>::~pair((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v4)
  {
    operator delete(v4);
  }
}

void ___ZN2md16RouteRenderLayer28buildRouteStyledOverlayLayerERKNS_13LayoutContextERKNSt3__110shared_ptrINS_16RouteLineOverlayEEE_block_invoke()
{
}

void sub_1A1FD5240(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10A1C400A608395);
  _Unwind_Resume(a1);
}

uint64_t std::pair<md::RouteStyledOverlayBatchKey const,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>>::~pair(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 48);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 56);
    uint64_t v4 = *(void *)(a1 + 48);
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = (void (***)(void, uint64_t))*--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6)
        {
          (**v5)(v5, v4);
          {
            operator new();
          }
          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                           + 40))(mdm::Allocator::instance(void)::alloc, v5, 128);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void *)(a1 + 48);
    }
    *(void *)(a1 + 56) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 72) + 40))(*(void *)(a1 + 72), v4, *(void *)(a1 + 64) - v4);
  }
  unint64_t v7 = *(std::__shared_weak_count **)(a1 + 32);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  unint64_t v8 = *(std::__shared_weak_count **)(a1 + 16);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  return a1;
}

uint64_t std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>>::~unordered_map[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 16);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      std::pair<md::RouteStyledOverlayBatchKey const,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>>::~pair((uint64_t)(v2 + 2));
      operator delete(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  uint64_t v4 = *(void **)a1;
  *(void *)a1 = 0;
  if (v4) {
    operator delete(v4);
  }
  return a1;
}

void md::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::RibbonLayer(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char *a6)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    int v74 = a6[24];
    if (a6[24])
    {
      char v6 = a6[1];
      char v75 = *a6;
      uint64_t v8 = *(void *)(a6 + 4);
    }
    else
    {
      char v75 = 0;
    }
    *(void *)a1 = &unk_1EF553C70;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    *(_OWORD *)(a1 + 32) = 0u;
    *(void *)(a1 + 72) = 0;
    *(unsigned char *)(a1 + 80) = 0;
    *(unsigned char *)(a1 + 104) = 0;
    *(_OWORD *)(a1 + 48) = 0u;
    *(unsigned char *)(a1 + 64) = 0;
    if (v74)
    {
      *(unsigned char *)(a1 + 80) = v75;
      *(unsigned char *)(a1 + 81) = v6;
      *(void *)(a1 + 84) = v8;
      *(unsigned char *)(a1 + 104) = 1;
    }
    int8x16_t v76 = operator new(0xF8uLL);
    v76[1] = 0;
    v76[2] = 0;
    *int8x16_t v76 = &unk_1EF584D20;
    ggl::BufferData::BufferData((uint64_t)(v76 + 3), 32, 0, 0, 1, 0);
    v76[29] = "BatchType/VData";
    v76[30] = &ggl::TexturedAnimatedRibbon::defaultVboReflection;
    void v76[3] = &unk_1EF55C9C8;
    v76[28] = &unk_1EF55C9E8;
    int8x16_t v77 = operator new(0xF8uLL);
    v77[1] = 0;
    v77[2] = 0;
    *int8x16_t v77 = &unk_1EF583D28;
    ggl::BufferData::BufferData((uint64_t)(v77 + 3), 2, 1, 0, 1, 0);
    *((_DWORD *)v77 + 60) = 0;
    v77[3] = &unk_1EF55B630;
    v77[4] = 2;
    v77[28] = &unk_1EF55B650;
    v77[29] = "BatchType/IData";
    operator new();
  }
  long long v78 = 0uLL;
  {
    operator new();
  }
  uint64_t v79 = mdm::Allocator::instance(void)::alloc;
  uint64_t v80 = 0;
  {
    operator new();
  }
  uint64_t v81 = mdm::Allocator::instance(void)::alloc;
  unint64_t v82 = 0;
  float v83 = 1.0;
  float v10 = *(uint64_t **)(a3 + 64);
  uint64_t v11 = *(uint64_t **)(a3 + 72);
  while (1)
  {
    if (v10 == v11) {
      operator new();
    }
    unsigned int v13 = ggl::CullingGrid::intersectedCellsForRibbon(*(void *)(*v10 + 88), *(void **)(*v10 + 72));
    unsigned int v14 = v13;
    unint64_t v15 = v13;
    size_t v16 = *((void *)&v78 + 1);
    if (*((void *)&v78 + 1))
    {
      uint8x8_t v17 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v78 + 8));
      v17.i16[0] = vaddlv_u8(v17);
      if (v17.u32[0] > 1uLL)
      {
        unint64_t v7 = v13;
        if (*((void *)&v78 + 1) <= (unint64_t)v13) {
          unint64_t v7 = (unint64_t)v13 % *((void *)&v78 + 1);
        }
      }
      else
      {
        unint64_t v7 = (DWORD2(v78) - 1) & v13;
      }
      uint64_t v18 = *(uint64_t **)(v78 + 8 * v7);
      if (v18)
      {
        uint64_t v19 = *v18;
        if (*v18)
        {
          if (v17.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v21 = *(void *)(v19 + 8);
              if (v21 == v13)
              {
                if (*(_DWORD *)(v19 + 16) == v13) {
                  goto LABEL_88;
                }
              }
              else if ((v21 & (*((void *)&v78 + 1) - 1)) != v7)
              {
                goto LABEL_28;
              }
              uint64_t v19 = *(void *)v19;
              if (!v19) {
                goto LABEL_28;
              }
            }
          }
          do
          {
            unint64_t v20 = *(void *)(v19 + 8);
            if (v20 == v13)
            {
              if (*(_DWORD *)(v19 + 16) == v13) {
                goto LABEL_88;
              }
            }
            else
            {
              if (v20 >= *((void *)&v78 + 1)) {
                v20 %= *((void *)&v78 + 1);
              }
              if (v20 != v7) {
                break;
              }
            }
            uint64_t v19 = *(void *)v19;
          }
          while (v19);
        }
      }
    }
LABEL_28:
    uint64_t v19 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v81 + 16))(v81, 56, 8);
    *(void *)uint64_t v19 = 0;
    *(void *)(v19 + 8) = v15;
    *(_DWORD *)(v19 + 16) = v14;
    *(void *)(v19 + 32) = 0;
    *(void *)(v19 + 40) = 0;
    *(void *)(v19 + 24) = 0;
    {
      operator new();
    }
    *(void *)(v19 + 48) = mdm::Allocator::instance(void)::alloc;
    float v22 = (float)(v82 + 1);
    if (!*((void *)&v78 + 1) || (float)(v83 * (float)*((unint64_t *)&v78 + 1)) < v22) {
      break;
    }
LABEL_78:
    int16x8_t v43 = *(uint64_t **)(v78 + 8 * v7);
    if (v43)
    {
      *(void *)uint64_t v19 = *v43;
LABEL_86:
      *int16x8_t v43 = v19;
      goto LABEL_87;
    }
    *(void *)uint64_t v19 = v80;
    uint64_t v80 = v19;
    *(void *)(v78 + 8 * v7) = &v80;
    if (*(void *)v19)
    {
      size_t v44 = *(void *)(*(void *)v19 + 8);
      if ((v16 & (v16 - 1)) != 0)
      {
        if (v44 >= v16) {
          v44 %= v16;
        }
      }
      else
      {
        v44 &= v16 - 1;
      }
      int16x8_t v43 = (uint64_t *)(v78 + 8 * v44);
      goto LABEL_86;
    }
LABEL_87:
    ++v82;
LABEL_88:
    int8x16_t v45 = *(void **)(v19 + 32);
    unint64_t v46 = *(void *)(v19 + 40);
    if ((unint64_t)v45 < v46)
    {
      if (v45)
      {
        uint64_t v47 = *v10;
        *float v10 = 0;
        void *v45 = v47;
      }
      uint64_t v12 = v45 + 1;
      goto LABEL_6;
    }
    uint64_t v48 = *(void *)(v19 + 24);
    uint64_t v49 = ((uint64_t)v45 - v48) >> 3;
    unint64_t v50 = v49 + 1;
    if ((unint64_t)(v49 + 1) >> 61) {
      abort();
    }
    uint64_t v51 = v46 - v48;
    if (v51 >> 2 > v50) {
      unint64_t v50 = v51 >> 2;
    }
    if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v52 = v50;
    }
    if (v52)
    {
      uint64_t v53 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v19 + 48) + 16))(*(void *)(v19 + 48), 8 * v52, 8);
      int8x16_t v54 = (void *)(v53 + 8 * v49);
      uint64_t v55 = v53 + 8 * v52;
      if (v53)
      {
        uint64_t v56 = *v10;
        *float v10 = 0;
        *int8x16_t v54 = v56;
      }
    }
    else
    {
      uint64_t v55 = 0;
      int8x16_t v54 = (void *)(8 * v49);
    }
    uint64_t v12 = v54 + 1;
    int8x16_t v57 = *(void **)(v19 + 24);
    unint64_t v58 = *(void *)(v19 + 32);
    if ((void *)v58 == v57)
    {
      *(void *)(v19 + 24) = v54;
      *(void *)(v19 + 32) = v12;
      unint64_t v7 = *(void *)(v19 + 40);
      *(void *)(v19 + 40) = v55;
      goto LABEL_115;
    }
    unint64_t v59 = v58 - (void)v57 - 8;
    if (v59 <= 0x47
      || (unint64_t v60 = v59 >> 3, v58 - 8 * v60 - 8 < (unint64_t)v54) && (unint64_t)&v54[-v60 - 1] < v58)
    {
      int16x8_t v61 = *(void **)(v19 + 32);
      do
      {
LABEL_106:
        uint64_t v62 = *--v61;
        *int16x8_t v61 = 0;
        *--int8x16_t v54 = v62;
      }
      while (v61 != v57);
      goto LABEL_107;
    }
    unint64_t v66 = v60 + 1;
    uint64_t v67 = (v60 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    int16x8_t v61 = (void *)(v58 - 8 * v67);
    int8x16_t v68 = v54 - 2;
    int8x16_t v69 = (long long *)(v58 - 32);
    uint64_t v70 = v67;
    do
    {
      long long v72 = *v69;
      long long v71 = v69[1];
      long long *v69 = 0uLL;
      v69[1] = 0uLL;
      v69 -= 2;
      *(v68 - 1) = v72;
      *int8x16_t v68 = v71;
      v68 -= 2;
      v70 -= 4;
    }
    while (v70);
    v54 -= v67;
    if (v66 != v67) {
      goto LABEL_106;
    }
LABEL_107:
    unint64_t v58 = *(void *)(v19 + 24);
    int8x16_t v63 = *(void **)(v19 + 32);
    *(void *)(v19 + 24) = v54;
    *(void *)(v19 + 32) = v12;
    unint64_t v7 = *(void *)(v19 + 40);
    *(void *)(v19 + 40) = v55;
    while (v63 != (void *)v58)
    {
      int8x16_t v65 = (void (***)(void))*--v63;
      int32x4_t v64 = v65;
      *int8x16_t v63 = 0;
      if (v65)
      {
        (**v64)(v64);
        {
          operator new();
        }
        (*(void (**)(uint64_t, void (***)(void), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                + 40))(mdm::Allocator::instance(void)::alloc, v64, 128);
      }
    }
LABEL_115:
    if (v58) {
      (*(void (**)(void, unint64_t, unint64_t))(**(void **)(v19 + 48) + 40))(*(void *)(v19 + 48), v58, v7 - v58);
    }
LABEL_6:
    *(void *)(v19 + 32) = v12;
    ++v10;
  }
  BOOL v23 = (*((void *)&v78 + 1) & (*((void *)&v78 + 1) - 1)) != 0;
  if (*((void *)&v78 + 1) < 3uLL) {
    BOOL v23 = 1;
  }
  unint64_t v24 = v23 | (2 * *((void *)&v78 + 1));
  unint64_t v25 = vcvtps_u32_f32(v22 / v83);
  if (v24 <= v25) {
    size_t prime = v25;
  }
  else {
    size_t prime = v24;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
  }
  size_t v16 = *((void *)&v78 + 1);
  if (prime <= *((void *)&v78 + 1))
  {
    if (prime >= *((void *)&v78 + 1)) {
      goto LABEL_65;
    }
    unint64_t v37 = vcvtps_u32_f32((float)v82 / v83);
    if (*((void *)&v78 + 1) < 3uLL
      || (uint8x8_t v38 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v78 + 8)), v38.i16[0] = vaddlv_u8(v38), v38.u32[0] > 1uLL))
    {
      unint64_t v37 = std::__next_prime(v37);
    }
    else
    {
      uint64_t v39 = 1 << -(char)__clz(v37 - 1);
      if (v37 >= 2) {
        unint64_t v37 = v39;
      }
    }
    if (prime <= v37) {
      size_t prime = v37;
    }
    if (prime >= *((void *)&v78 + 1))
    {
      size_t v16 = *((void *)&v78 + 1);
LABEL_65:
      if ((v16 & (v16 - 1)) != 0)
      {
        if (v16 <= v15) {
          unint64_t v7 = v15 % v16;
        }
        else {
          unint64_t v7 = v15;
        }
      }
      else
      {
        unint64_t v7 = (v16 - 1) & v15;
      }
      goto LABEL_78;
    }
    if (!prime)
    {
      uint64_t v73 = v78;
      *(void *)&long long v78 = 0;
      if (v73) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v79 + 40))(v79, v73, 8 * *((void *)&v78 + 1));
      }
      size_t v16 = 0;
      *((void *)&v78 + 1) = 0;
      goto LABEL_65;
    }
  }
  uint64_t v27 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(*(void *)v79 + 16))(v79, 8 * prime, 8);
  uint64_t v28 = v78;
  *(void *)&long long v78 = v27;
  if (v28) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v79 + 40))(v79, v28, 8 * *((void *)&v78 + 1));
  }
  uint64_t v29 = 0;
  *((void *)&v78 + 1) = prime;
  do
    *(void *)(v78 + 8 * v29++) = 0;
  while (prime != v29);
  uint64_t v30 = (void **)v80;
  if (!v80)
  {
LABEL_64:
    size_t v16 = prime;
    goto LABEL_65;
  }
  size_t v31 = *(void *)(v80 + 8);
  size_t v32 = prime - 1;
  if ((prime & (prime - 1)) == 0)
  {
    size_t v33 = v31 & v32;
    *(void *)(v78 + 8 * v33) = &v80;
    for (uint64_t i = *v30; *v30; uint64_t i = *v30)
    {
      size_t v35 = i[1] & v32;
      if (v35 == v33)
      {
        uint64_t v30 = (void **)i;
      }
      else if (*(void *)(v78 + 8 * v35))
      {
        *uint64_t v30 = (void *)*i;
        uint64_t v36 = 8 * v35;
        void *i = **(void **)(v78 + v36);
        **(void **)(v78 + v36) = i;
      }
      else
      {
        *(void *)(v78 + 8 * v35) = v30;
        uint64_t v30 = (void **)i;
        size_t v33 = v35;
      }
    }
    goto LABEL_64;
  }
  if (v31 >= prime) {
    v31 %= prime;
  }
  *(void *)(v78 + 8 * v31) = &v80;
  int32x4_t v40 = *v30;
  if (!*v30) {
    goto LABEL_64;
  }
  while (1)
  {
    size_t v42 = v40[1];
    if (v42 >= prime) {
      v42 %= prime;
    }
    if (v42 != v31)
    {
      if (!*(void *)(v78 + 8 * v42))
      {
        *(void *)(v78 + 8 * v42) = v30;
        goto LABEL_69;
      }
      *uint64_t v30 = (void *)*v40;
      uint64_t v41 = 8 * v42;
      *int32x4_t v40 = **(void **)(v78 + v41);
      **(void **)(v78 + v41) = v40;
      int32x4_t v40 = v30;
    }
    size_t v42 = v31;
LABEL_69:
    uint64_t v30 = (void **)v40;
    int32x4_t v40 = (void *)*v40;
    size_t v31 = v42;
    if (!v40) {
      goto LABEL_64;
    }
  }
}

void sub_1A1FD9C70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void **a40,uint64_t a41,uint64_t a42,uint64_t a43,void **a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t *a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *a63)
{
  MEMORY[0x1A6239270](v63, 0x1020C4007FF0C4BLL);
  if (v64) {
    operator delete(v64);
  }
  std::unique_ptr<gdc::GlobeTileGrid>::~unique_ptr[abi:nn180100](a49);
  unint64_t v66 = *a44;
  if (*a44)
  {
    *(void *)(a37 + 40) = v66;
    operator delete(v66);
  }
  uint64_t v67 = *a40;
  if (*a40)
  {
    *(void *)(a37 + 16) = v67;
    operator delete(v67);
    if (!a63) {
LABEL_8:
    }
      _Unwind_Resume(a1);
  }
  else if (!a63)
  {
    goto LABEL_8;
  }
  operator delete(a63);
  goto LABEL_8;
}

void md::RouteStyledOverlayLayer::~RouteStyledOverlayLayer(md::RouteStyledOverlayLayer *this)
{
  *(void *)this = &unk_1EF531138;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF531138;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 17);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(this);
}

void *md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF553C70;
  uint64_t v2 = (void *)a1[1];
  uint64_t v3 = (void *)a1[2];
  while (v2 != v3)
  {
    if (*v2) {
      (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
    }
    ++v2;
  }
  uint64_t v4 = (void *)a1[4];
  uint64_t v5 = (void *)a1[5];
  while (v4 != v5)
  {
    if (*v4) {
      (*(void (**)(void))(*(void *)*v4 + 8))(*v4);
    }
    ++v4;
  }
  uint64_t v6 = a1[9];
  a1[9] = 0;
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 2584);
    if (v7) {
      MEMORY[0x1A6239250](v7, 0x1000C8000313F17);
    }
    MEMORY[0x1A6239270](v6, 0x1020C4007FF0C4BLL);
  }
  uint64_t v8 = (void *)a1[4];
  if (v8)
  {
    a1[5] = v8;
    operator delete(v8);
  }
  PolylineCoordinate v9 = (void *)a1[1];
  if (v9)
  {
    a1[2] = v9;
    operator delete(v9);
  }
  return a1;
}

void md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(void *a1)
{
  md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(a1);
  JUMPOUT(0x1A6239270);
}

void md::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF531138;
  uint64_t v2 = (std::__shared_weak_count *)a1[17];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(a1);
  JUMPOUT(0x1A6239270);
}

void *md::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(void *a1)
{
  *a1 = &unk_1EF531138;
  uint64_t v2 = (std::__shared_weak_count *)a1[17];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    uint64_t v3 = (std::__shared_weak_count *)a1[15];
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  return md::Ribbons::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::~RibbonLayer(a1);
}

float md::Ribbons::RibbonWriter<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::eliminateDuplicates(uint64_t a1, uint64_t a2, std::vector<unsigned int> *a3, uint64_t *a4)
{
  *a4 = 1;
  unint64_t v8 = *(void *)(a1 + 88);
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  if (v8 <= v9)
  {
    if (v8 < v9) {
      *(void *)(a2 + 8) = *(void *)a2 + 12 * v8;
    }
  }
  else
  {
    std::vector<gm::Matrix<float,3,1>>::__append((char **)a2, v8 - v9);
    unint64_t v8 = *(void *)(a1 + 88);
  }
  begiunint64_t n = a3->__begin_;
  unint64_t v11 = a3->__end_ - a3->__begin_;
  if (v8 <= v11)
  {
    if (v8 < v11) {
      a3->__end_ = &begin[v8];
    }
  }
  else
  {
    std::vector<unsigned int>::__append(a3, v8 - v11);
    begiunint64_t n = a3->__begin_;
    unint64_t v8 = *(void *)(a1 + 88);
  }
  uint64_t v12 = *(char **)a2;
  uint64_t v13 = *(void *)(a1 + 72);
  *(_DWORD *)uint64_t v12 = *(_DWORD *)v13;
  *((_DWORD *)v12 + 1) = *(_DWORD *)(v13 + 4);
  float result = *(float *)(v13 + 8);
  *((float *)v12 + 2) = result;
  *begiunint64_t n = 0;
  if (v8 >= 2)
  {
    uint64_t v15 = 0;
    uint64_t v16 = *a4;
    uint8x8_t v17 = (float *)(v13 + 20);
    uint64_t v18 = (float *)&v12[12 * *a4 + 8];
    do
    {
      uint64_t v19 = v16 + v15;
      unint64_t v20 = v15 + 2;
      begin[v19] = ++v15;
      *a4 = v19 + 1;
      *(v18 - 2) = *(v17 - 2);
      *(v18 - 1) = *(v17 - 1);
      float v21 = *v17;
      v17 += 3;
      float result = v21;
      *uint64_t v18 = v21;
      v18 += 3;
    }
    while (*(void *)(a1 + 88) > v20);
  }
  return result;
}

void non-virtual thunk to'ggl::VertexDataTyped<ggl::TexturedAnimatedRibbon::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;

  *(void *)(a1 - 200) = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 - 72));
  uint64_t v2 = *(void *)(a1 - 128);
  if (v2)
  {
    *(void *)(a1 - 120) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 - 104) + 40))(*(void *)(a1 - 104), v2, *(void *)(a1 - 112) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 - 168);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

void ggl::VertexDataTyped<ggl::TexturedAnimatedRibbon::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t ggl::VertexDataTyped<ggl::TexturedAnimatedRibbon::DefaultVbo>::~VertexDataTyped(uint64_t a1)
{
  *(void *)a1 = &unk_1EF55A1F0;
  std::mutex::~mutex((std::mutex *)(a1 + 128));
  uint64_t v2 = *(void *)(a1 + 72);
  if (v2)
  {
    *(void *)(a1 + 80) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v2, *(void *)(a1 + 88) - v2);
  }
  uint64_t v3 = *(std::__shared_weak_count **)(a1 + 32);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  return a1;
}

uint64_t std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TexturedAnimatedRibbon::DefaultVbo>>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TexturedAnimatedRibbon::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584D20;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1A6239270);
}

void std::__shared_ptr_emplace<ggl::VertexDataTyped<ggl::TexturedAnimatedRibbon::DefaultVbo>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF584D20;
  std::__shared_weak_count::~__shared_weak_count(this);
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::batch(std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*,false>(uint64_t result, int8x16_t *a2, uint64_t a3, char a4)
{
  uint64_t v6 = (int8x16_t *)result;
LABEL_2:
  uint64_t v160 = &a2[-1].i64[1];
  uint64_t v7 = v6;
  while (1)
  {
    uint64_t v6 = v7;
    uint64_t v8 = (char *)a2 - (char *)v7;
    uint64_t v9 = ((char *)a2 - (char *)v7) >> 3;
    if (!(!v5 & v4))
    {
      switch(v9)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v65 = *v160;
          uint64_t v66 = v7->i64[0];
          float result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v160 + 96), v7->i64[0]);
          if (result)
          {
            v7->i64[0] = v65;
            *uint64_t v160 = v66;
          }
          break;
        case 3:
          float result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v160);
          break;
        case 4:
          uint64_t v67 = v7 + 1;
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v7[1].i64);
          uint64_t v68 = *v160;
          uint64_t v69 = v7[1].i64[0];
          float result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v160 + 96), v69);
          if (result)
          {
            v67->i64[0] = v68;
            *uint64_t v160 = v69;
            float result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v67->i64[0] + 96), v7->i64[1]);
            if (result)
            {
              int8x16_t v70 = *(int8x16_t *)((char *)v7 + 8);
              *(int8x16_t *)((char *)v7 + 8) = vextq_s8(v70, v70, 8uLL);
              float result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v70.i64[1] + 96), v7->i64[0]);
              if (result) {
                *uint64_t v7 = vextq_s8(*v7, *v7, 8uLL);
              }
            }
          }
          break;
        case 5:
          float result = std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, &v7->i64[1], v7[1].i64, &v7[1].i64[1], v160);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v8 <= 191)
    {
      long long v71 = (int8x16_t *)&v7->u64[1];
      BOOL v73 = v7 == a2 || v71 == a2;
      if (a4)
      {
        if (!v73)
        {
          int v74 = (uint64_t *)v7;
          do
          {
            int8x16_t v76 = v71;
            uint64_t v77 = v74[1];
            float result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v77 + 96), *v74);
            if (result)
            {
              long long v78 = (uint64_t *)v76;
              uint64_t v79 = 0;
              uint64_t *v78 = 0;
              uint64_t v167 = v77;
              uint64_t v80 = *v74;
              uint64_t v163 = v78;
              for (i = v78; ; uint64_t v79 = *i)
              {
                uint64_t *i = v80;
                uint64_t i = v74;
                uint64_t *v74 = 0;
                if (v79)
                {
                  uint64_t v81 = *(void **)(v79 + 56);
                  if (v81)
                  {
                    unint64_t v82 = *(void **)(v79 + 64);
                    uint64_t v83 = *(void *)(v79 + 56);
                    if (v82 != v81)
                    {
                      do
                      {
                        int32x4_t v85 = (void (***)(void, uint64_t))*--v82;
                        uint64_t v84 = v85;
                        *unint64_t v82 = 0;
                        if (v85)
                        {
                          (**v84)(v84, v83);
                          {
                            operator new();
                          }
                          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v84, 128);
                        }
                      }
                      while (v82 != v81);
                      uint64_t v83 = *(void *)(v79 + 56);
                    }
                    *(void *)(v79 + 64) = v81;
                    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v79 + 80) + 40))(*(void *)(v79 + 80), v83, *(void *)(v79 + 72) - v83);
                  }
                  MEMORY[0x1A6239270](v79, 0x1020C4010FC18DELL);
                }
                uint64_t v86 = v167;
                if (i == (uint64_t *)v6) {
                  break;
                }
                unint64_t v87 = *(unsigned int *)(v167 + 96);
                if ((v87 & 0xF000) != 0) {
                  uint64_t v88 = 3;
                }
                else {
                  uint64_t v88 = 0;
                }
                if ((v87 & 0xF00) != 0) {
                  uint64_t v88 = 2;
                }
                if ((v87 & 0xF0) != 0) {
                  uint64_t v88 = 1;
                }
                if ((v87 & 0xF) != 0) {
                  uint64_t v88 = 0;
                }
                int v89 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v88];
                int v90 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v87 >> 12];
                int v91 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v87 >> 8) & 0xF];
                int v92 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v87 >> 4];
                unsigned int v93 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v87 & 0xF];
                int v74 = i - 1;
                uint64_t v80 = *(i - 1);
                unint64_t v94 = *(unsigned int *)(v80 + 96);
                if ((v94 & 0xF000) != 0) {
                  uint64_t v95 = 3;
                }
                else {
                  uint64_t v95 = 0;
                }
                if ((v94 & 0xF00) != 0) {
                  uint64_t v95 = 2;
                }
                if ((v94 & 0xF0) != 0) {
                  uint64_t v95 = 1;
                }
                if ((v94 & 0xF) != 0) {
                  uint64_t v95 = 0;
                }
                if (((v90 << 12) | (v89 << 16) | (v91 << 8) | (16 * v92) | v93) >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v94 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v95] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v94 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v94 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v94 & 0xF])) {
                  goto LABEL_128;
                }
              }
              uint64_t i = (uint64_t *)v6;
LABEL_128:
              uint64_t v167 = 0;
              std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](i, v86);
              float result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
              int8x16_t v76 = (int8x16_t *)v163;
            }
            long long v71 = (int8x16_t *)&v76->u64[1];
            int v74 = (uint64_t *)v76;
          }
          while (&v76->u64[1] != (unint64_t *)a2);
        }
      }
      else if (!v73)
      {
        do
        {
          long long v138 = v71;
          uint64_t v139 = v6->i64[1];
          float result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v139 + 96), v6->i64[0]);
          if (result)
          {
            int v140 = (uint64_t *)v138;
            uint64_t v141 = 0;
            *int v140 = 0;
            uint64_t v167 = v139;
            uint64_t v142 = v6->i64[0];
            uint64_t v164 = v140;
            for (j = v140; ; uint64_t v141 = *j)
            {
              uint64_t *j = v142;
              unint64_t j = (uint64_t *)v6;
              v6->i64[0] = 0;
              if (v141)
              {
                uint64_t v144 = *(void **)(v141 + 56);
                if (v144)
                {
                  unint64_t v145 = *(void **)(v141 + 64);
                  uint64_t v146 = *(void *)(v141 + 56);
                  if (v145 != v144)
                  {
                    do
                    {
                      unint64_t v148 = (void (***)(void, uint64_t))*--v145;
                      int v147 = v148;
                      *unint64_t v145 = 0;
                      if (v148)
                      {
                        (**v147)(v147, v146);
                        {
                          operator new();
                        }
                        (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v147, 128);
                      }
                    }
                    while (v145 != v144);
                    uint64_t v146 = *(void *)(v141 + 56);
                  }
                  *(void *)(v141 + 64) = v144;
                  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v141 + 80) + 40))(*(void *)(v141 + 80), v146, *(void *)(v141 + 72) - v146);
                }
                MEMORY[0x1A6239270](v141, 0x1020C4010FC18DELL);
              }
              uint64_t v149 = v167;
              unint64_t v150 = *(unsigned int *)(v167 + 96);
              if ((v150 & 0xF000) != 0) {
                uint64_t v151 = 3;
              }
              else {
                uint64_t v151 = 0;
              }
              if ((v150 & 0xF00) != 0) {
                uint64_t v151 = 2;
              }
              if ((v150 & 0xF0) != 0) {
                uint64_t v151 = 1;
              }
              if ((v150 & 0xF) != 0) {
                uint64_t v151 = 0;
              }
              int v152 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v151];
              int v153 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v150 >> 12];
              int v154 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v150 >> 8) & 0xF];
              int v155 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v150 >> 4];
              unsigned int v156 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v150 & 0xF];
              uint64_t v6 = (int8x16_t *)(j - 1);
              uint64_t v142 = *(j - 1);
              unint64_t v157 = *(unsigned int *)(v142 + 96);
              if ((v157 & 0xF000) != 0) {
                uint64_t v158 = 3;
              }
              else {
                uint64_t v158 = 0;
              }
              if ((v157 & 0xF00) != 0) {
                uint64_t v158 = 2;
              }
              if ((v157 & 0xF0) != 0) {
                uint64_t v158 = 1;
              }
              if ((v157 & 0xF) != 0) {
                uint64_t v158 = 0;
              }
              if (((v153 << 12) | (v152 << 16) | (v154 << 8) | (16 * v155) | v156) >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v157 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v158] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v157 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v157 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v157 & 0xF])) {
                break;
              }
            }
            uint64_t v167 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](j, v149);
            float result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
            long long v138 = (int8x16_t *)v164;
          }
          long long v71 = (int8x16_t *)&v138->u64[1];
          uint64_t v6 = v138;
        }
        while (&v138->u64[1] != (unint64_t *)a2);
      }
      return result;
    }
    if (!a3) {
      break;
    }
    unint64_t v10 = (unint64_t)v9 >> 1;
    unint64_t v11 = &v7->i64[(unint64_t)v9 >> 1];
    if ((unint64_t)v8 < 0x401)
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v11, v7->i64, v160);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7->i64, v11, v160);
      uint64_t v12 = v10;
      uint64_t v13 = &v7->i64[v10];
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(&v7->i64[1], v13 - 1, a2[-1].i64);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v7[1].i64, &v7->i64[v12 + 1], &a2[-2].i64[1]);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v13 - 1, v11, &v7->i64[v12 + 1]);
      uint64_t v14 = v7->i64[0];
      v7->i64[0] = *v13;
      *uint64_t v13 = v14;
    }
    --a3;
    uint64_t v15 = v7->i64[0];
    if ((a4 & 1) != 0
      || md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v7[-1].i64[1] + 96), v7->i64[0]))
    {
      v7->i64[0] = 0;
      uint64_t v167 = v15;
      uint64_t v16 = v7;
      do
      {
        uint8x8_t v17 = v16;
        uint64_t v19 = v16->i64[1];
        uint64_t v16 = (int8x16_t *)((char *)v16 + 8);
        uint64_t v18 = v19;
      }
      while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v19 + 96), v15));
      unint64_t v20 = (uint64_t *)a2;
      if (v17 == v6)
      {
        unint64_t v20 = (uint64_t *)a2;
        do
        {
          if (v16 >= (int8x16_t *)v20) {
            break;
          }
          uint64_t v22 = *--v20;
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v22 + 96), v15));
      }
      else
      {
        do
          uint64_t v21 = *--v20;
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v21 + 96), v15));
      }
      if (v16 < (int8x16_t *)v20)
      {
        uint64_t v23 = *v20;
        unint64_t v24 = (uint64_t *)v16;
        unint64_t v25 = v20;
        do
        {
          uint64_t *v24 = v23;
          *unint64_t v25 = v18;
          uint64_t v15 = v167;
          unint64_t v26 = *(unsigned int *)(v167 + 96);
          int v27 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v26 >> 8) & 0xF];
          int v28 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v26 >> 12] << 12;
          int v29 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v26 >> 4];
          int v30 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v26 & 0xF];
          if ((v26 & 0xF000) != 0) {
            uint64_t v31 = 3;
          }
          else {
            uint64_t v31 = 0;
          }
          if ((v26 & 0xF00) != 0) {
            uint64_t v31 = 2;
          }
          if (*(_DWORD *)(v167 + 96)) {
            BOOL v32 = (*(_DWORD *)(v167 + 96) & 0xF) == 0;
          }
          else {
            BOOL v32 = v31;
          }
          unsigned int v33 = v28 | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v32] << 16) | (v27 << 8) | (16 * v29) | v30;
          do
          {
            uint64_t v34 = v24[1];
            ++v24;
            uint64_t v18 = v34;
            unint64_t v35 = *(unsigned int *)(v34 + 96);
            if ((v35 & 0xF000) != 0) {
              uint64_t v36 = 3;
            }
            else {
              uint64_t v36 = 0;
            }
            if ((v35 & 0xF00) != 0) {
              uint64_t v36 = 2;
            }
            if ((v35 & 0xF0) != 0) {
              uint64_t v36 = 1;
            }
            if ((v35 & 0xF) != 0) {
              uint64_t v36 = 0;
            }
          }
          while (((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v35 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v36] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v35 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v35 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v35 & 0xF]) < v33);
          uint8x8_t v17 = (int8x16_t *)(v24 - 1);
          do
          {
            uint64_t v37 = *--v25;
            uint64_t v23 = v37;
            unint64_t v38 = *(unsigned int *)(v37 + 96);
            if ((v38 & 0xF000) != 0) {
              uint64_t v39 = 3;
            }
            else {
              uint64_t v39 = 0;
            }
            if ((v38 & 0xF00) != 0) {
              uint64_t v39 = 2;
            }
            if ((v38 & 0xF0) != 0) {
              uint64_t v39 = 1;
            }
            if ((v38 & 0xF) != 0) {
              uint64_t v39 = 0;
            }
          }
          while (((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v38 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v39] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v38 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v38 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v38 & 0xF]) >= v33);
        }
        while (v24 < v25);
      }
      if (v17 != v6)
      {
        uint64_t v40 = v17->i64[0];
        v17->i64[0] = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v6->i64, v40);
        uint64_t v15 = v167;
      }
      uint64_t v167 = 0;
      std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v17->i64, v15);
      std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
      if (v16 < (int8x16_t *)v20) {
        goto LABEL_58;
      }
      char v41 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::batch(std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(v6, v17);
      uint64_t v7 = (int8x16_t *)&v17->u64[1];
      float result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::batch(std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>((int8x16_t *)&v17->u64[1], a2);
      if (result)
      {
        a2 = v17;
        if (v41) {
          return result;
        }
        goto LABEL_2;
      }
      if ((v41 & 1) == 0)
      {
LABEL_58:
        float result = std::__introsort<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::batch(std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*,false>(v6, v17, a3, a4 & 1);
        a4 = 0;
        uint64_t v7 = (int8x16_t *)&v17->u64[1];
      }
    }
    else
    {
      v7->i64[0] = 0;
      uint64_t v167 = v15;
      unint64_t v42 = *(unsigned int *)(v15 + 96);
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, *v160))
      {
        do
        {
          uint64_t v43 = v7->i64[1];
          uint64_t v7 = (int8x16_t *)((char *)v7 + 8);
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v43));
      }
      else
      {
        size_t v44 = (int8x16_t *)&v7->u64[1];
        do
        {
          uint64_t v7 = v44;
          if (v44 >= a2) {
            break;
          }
          size_t v44 = (int8x16_t *)((char *)v44 + 8);
        }
        while (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v7->i64[0]));
      }
      int8x16_t v45 = a2;
      if (v7 < a2)
      {
        int8x16_t v45 = a2;
        do
        {
          uint64_t v46 = v45[-1].i64[1];
          int8x16_t v45 = (int8x16_t *)((char *)v45 - 8);
        }
        while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(v42, v46));
      }
      if (v7 < v45)
      {
        uint64_t v47 = v7->i64[0];
        uint64_t v48 = v45->i64[0];
        do
        {
          v7->i64[0] = v48;
          v45->i64[0] = v47;
          uint64_t v15 = v167;
          unint64_t v49 = *(unsigned int *)(v167 + 96);
          int v50 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v49 >> 8) & 0xF];
          int v51 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v49 >> 4];
          int v52 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v49 & 0xF];
          int v53 = ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v49 >> 12] << 12;
          if ((v49 & 0xF000) != 0) {
            uint64_t v54 = 3;
          }
          else {
            uint64_t v54 = 0;
          }
          if ((v49 & 0xF00) != 0) {
            uint64_t v54 = 2;
          }
          if (*(_DWORD *)(v167 + 96)) {
            BOOL v55 = (*(_DWORD *)(v167 + 96) & 0xF) == 0;
          }
          else {
            BOOL v55 = v54;
          }
          unsigned int v56 = v53 | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v55] << 16) | (v50 << 8) | (16 * v51) | v52;
          do
          {
            uint64_t v57 = v7->i64[1];
            uint64_t v7 = (int8x16_t *)((char *)v7 + 8);
            uint64_t v47 = v57;
            unint64_t v58 = *(unsigned int *)(v57 + 96);
            if ((v58 & 0xF000) != 0) {
              uint64_t v59 = 3;
            }
            else {
              uint64_t v59 = 0;
            }
            if ((v58 & 0xF00) != 0) {
              uint64_t v59 = 2;
            }
            if ((v58 & 0xF0) != 0) {
              uint64_t v59 = 1;
            }
            if ((v58 & 0xF) != 0) {
              uint64_t v59 = 0;
            }
          }
          while (v56 >= ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v58 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v59] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v58 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v58 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v58 & 0xF]));
          do
          {
            uint64_t v60 = v45[-1].i64[1];
            int8x16_t v45 = (int8x16_t *)((char *)v45 - 8);
            uint64_t v48 = v60;
            unint64_t v61 = *(unsigned int *)(v60 + 96);
            if ((v61 & 0xF000) != 0) {
              uint64_t v62 = 3;
            }
            else {
              uint64_t v62 = 0;
            }
            if ((v61 & 0xF00) != 0) {
              uint64_t v62 = 2;
            }
            if ((v61 & 0xF0) != 0) {
              uint64_t v62 = 1;
            }
            if ((v61 & 0xF) != 0) {
              uint64_t v62 = 0;
            }
          }
          while (v56 < ((ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(unsigned __int16)v61 >> 12] << 12) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v62] << 16) | (ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[(v61 >> 8) & 0xF] << 8) | (16 * ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v61 >> 4]) | ggl::CullingGrid::sortOrderForCells::sortOrderForQuad[v61 & 0xF]));
        }
        while (v7 < v45);
      }
      uint64_t v63 = &v7[-1].i64[1];
      if (&v7[-1].u64[1] != (unint64_t *)v6)
      {
        uint64_t v64 = *v63;
        *uint64_t v63 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v6->i64, v64);
        uint64_t v15 = v167;
      }
      uint64_t v167 = 0;
      std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v7[-1].i64[1], v15);
      float result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
      a4 = 0;
    }
  }
  if (v7 != a2)
  {
    unint64_t v161 = (char *)a2 - (char *)v7;
    int64_t v96 = (unint64_t)(v9 - 2) >> 1;
    int64_t v97 = v96;
    do
    {
      int64_t v98 = v97;
      if (v96 >= v97)
      {
        uint64_t v99 = (2 * v97) | 1;
        int32x4_t v100 = &v6->i64[v99];
        if (2 * v97 + 2 < v9)
        {
          uint64_t v101 = *v100;
          uint64_t v102 = v100[1];
          BOOL v103 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v100 + 96), v102);
          if (v103) {
            uint64_t v104 = v102;
          }
          else {
            uint64_t v104 = v101;
          }
          if (v103)
          {
            ++v100;
            uint64_t v99 = 2 * v98 + 2;
          }
        }
        else
        {
          uint64_t v104 = *v100;
        }
        int8x16_t v105 = &v6->i64[v98];
        uint64_t v106 = *v105;
        float result = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v104 + 96), *v105);
        if ((result & 1) == 0)
        {
          uint64_t *v105 = 0;
          uint64_t v167 = v106;
          uint64_t v107 = *v100;
          while (1)
          {
            unint64_t v111 = v100;
            *int32x4_t v100 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v105, v107);
            if (v96 < v99) {
              break;
            }
            uint64_t v112 = (2 * v99) | 1;
            int32x4_t v100 = &v6->i64[v112];
            uint64_t v113 = 2 * v99 + 2;
            if (v113 < v9)
            {
              uint64_t v108 = *v100;
              uint64_t v107 = v100[1];
              BOOL v109 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v100 + 96), v107);
              if (v109) {
                ++v100;
              }
              else {
                uint64_t v107 = v108;
              }
              if (v109) {
                uint64_t v99 = v113;
              }
              else {
                uint64_t v99 = v112;
              }
            }
            else
            {
              uint64_t v107 = *v100;
              uint64_t v99 = (2 * v99) | 1;
            }
            uint64_t v110 = v167;
            int8x16_t v105 = v111;
            if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v107 + 96), v167))
            {
              goto LABEL_168;
            }
          }
          uint64_t v110 = v167;
LABEL_168:
          uint64_t v167 = 0;
          std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v111, v110);
          float result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v167, 0);
        }
      }
      int64_t v97 = v98 - 1;
    }
    while (v98);
    uint64_t v114 = v161 >> 3;
    while (2)
    {
      if (v114 >= 2)
      {
        uint64_t v118 = 0;
        uint64_t v119 = v6->i64[0];
        v6->i64[0] = 0;
        uint64_t v166 = v119;
        BOOL v120 = (uint64_t *)v6;
        do
        {
          int v125 = &v120[v118 + 1];
          uint64_t v126 = (2 * v118) | 1;
          uint64_t v127 = 2 * v118 + 2;
          if (v127 < v114)
          {
            uint64_t v121 = *v125;
            uint64_t v122 = v120[v118 + 2];
            BOOL v123 = md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v125 + 96), v125[1]);
            if (v123) {
              uint64_t v124 = v122;
            }
            else {
              uint64_t v124 = v121;
            }
            if (v123)
            {
              ++v125;
              uint64_t v118 = v127;
            }
            else
            {
              uint64_t v118 = v126;
            }
          }
          else
          {
            uint64_t v124 = *v125;
            uint64_t v118 = (2 * v118) | 1;
          }
          *int v125 = 0;
          std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v120, v124);
          BOOL v120 = v125;
        }
        while (v118 <= (uint64_t)((unint64_t)(v114 - 2) >> 1));
        uint64_t v128 = &a2[-1].i64[1];
        if (v125 == (uint64_t *)&a2[-1].u64[1])
        {
          uint64_t v115 = v166;
          uint64_t v166 = 0;
          unsigned __int8 v116 = v125;
          goto LABEL_193;
        }
        uint64_t v129 = *v128;
        *uint64_t v128 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v125, v129);
        uint64_t v130 = v166;
        uint64_t v166 = 0;
        std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v128, v130);
        uint64_t v131 = (char *)v125 - (char *)v6 + 8;
        if (v131 >= 9)
        {
          unint64_t v132 = (unint64_t)((v131 >> 3) - 2) >> 1;
          BOOL v133 = &v6->i64[v132];
          uint64_t v134 = *v125;
          if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v133 + 96), *v125))
          {
            *int v125 = 0;
            uint64_t v167 = v134;
            uint64_t v135 = *v133;
            do
            {
              int v136 = v133;
              *BOOL v133 = 0;
              std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v125, v135);
              uint64_t v137 = v167;
              if (!v132) {
                break;
              }
              unint64_t v132 = (v132 - 1) >> 1;
              BOOL v133 = &v6->i64[v132];
              uint64_t v135 = *v133;
              int v125 = v136;
            }
            while (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v133 + 96), v167));
            uint64_t v167 = 0;
            std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v136, v137);
            unsigned __int8 v116 = &v167;
            uint64_t v115 = 0;
LABEL_193:
            std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v116, v115);
          }
        }
        float result = (uint64_t)std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v166, 0);
      }
      a2 = (int8x16_t *)((char *)a2 - 8);
      if ((unint64_t)v114-- <= 2) {
        return result;
      }
      continue;
    }
  }
  return result;
}

uint64_t std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::RouteStyledOverlayRibbonDescriptor>::batch(std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::RouteStyledOverlayBatchKey,std::vector<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteStyledOverlayRibbon,mdm::TypeDeleter<md::RouteStyledOverlayRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::RouteStyledOverlayRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(int8x16_t *a1, int8x16_t *a2)
{
  BOOL v4 = 1;
  switch(((char *)a2 - (char *)a1) >> 3)
  {
    case 0:
    case 1:
      return v4;
    case 2:
      uint64_t v5 = a2[-1].i64[1];
      uint64_t v6 = a1->i64[0];
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v5 + 96), a1->i64[0]))
      {
        a1->i64[0] = v5;
        a2[-1].i64[1] = v6;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], &a2[-1].i64[1]);
      return v4;
    case 4:
      uint64_t v16 = a1 + 1;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64);
      uint64_t v17 = a2[-1].i64[1];
      uint64_t v18 = a1[1].i64[0];
      if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v17 + 96), v18))
      {
        v16->i64[0] = v17;
        a2[-1].i64[1] = v18;
        if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v16->i64[0] + 96), a1->i64[1]))
        {
          int8x16_t v19 = *(int8x16_t *)((char *)a1 + 8);
          *(int8x16_t *)((char *)a1 + 8) = vextq_s8(v19, v19, 8uLL);
          if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v19.i64[1] + 96), a1->i64[0]))
          {
            *a1 = vextq_s8(*a1, *a1, 8uLL);
          }
        }
      }
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64, &a1[1].i64[1], &a2[-1].i64[1]);
      return v4;
    default:
      i64 = a1[1].i64;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1} &,std::default_delete<md::RibbonSection>*>(a1->i64, &a1->i64[1], a1[1].i64);
      uint64_t v8 = &a1[1].i64[1];
      if (&a1[1].u64[1] == (unint64_t *)a2) {
        return 1;
      }
      uint64_t v9 = 0;
      int v10 = 0;
      break;
  }
  while (1)
  {
    uint64_t v11 = *v8;
    if (md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(*v8 + 96), *i64))
    {
      break;
    }
LABEL_6:
    i64 = v8;
    v9 += 8;
    if (++v8 == (uint64_t *)a2) {
      return 1;
    }
  }
  *uint64_t v8 = 0;
  uint64_t v21 = v11;
  uint64_t v12 = *i64;
  uint64_t v13 = v9;
  while (1)
  {
    *(uint64_t *)((char *)a1[1].i64 + v13) = 0;
    std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100]((uint64_t *)((char *)&a1[1].i64[1] + v13), v12);
    uint64_t v14 = v21;
    if (v13 == -16) {
      break;
    }
    uint64_t v12 = *(uint64_t *)((char *)&a1->i64[1] + v13);
    v13 -= 8;
    if (!md::RibbonLayer<md::Ribbons::DaVinciTrafficRibbonDescriptor>::batch(std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&,std::shared_ptr<ggl::ConstantDataTyped<std::shared_ptr::Tile::View>> const&,std::unordered_map<md::DaVinciTrafficBatchKey,std::vector<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,geo::StdAllocator<std::unique_ptr<md::DaVinciTrafficRibbon,mdm::TypeDeleter<md::DaVinciTrafficRibbon>>,mdm::Allocator>>> &&<ggl<ggl::ConstantDataTyped::Transform>> const&,BOOL)::{lambda(std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const&,std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>> const)#1}::operator()(*(unsigned int *)(v21 + 96), v12))
    {
      uint64_t v15 = (uint64_t *)((char *)&a1[1].i64[1] + v13);
      goto LABEL_13;
    }
  }
  uint64_t v15 = (uint64_t *)a1;
LABEL_13:
  uint64_t v21 = 0;
  std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](v15, v14);
  if (++v10 != 8)
  {
    std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v21, 0);
    goto LABEL_6;
  }
  BOOL v4 = v8 + 1 == (uint64_t *)a2;
  std::unique_ptr<md::RibbonSection<md::Ribbons::DaVinciTrafficRibbonDescriptor>>::reset[abi:nn180100](&v21, 0);
  return v4;
}

uint64_t __Block_byref_object_copy__7016(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}

void __Block_byref_object_dispose__7017(uint64_t a1)
{
  std::__hash_table<std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::__unordered_map_hasher<md::RouteLineBatchKey,std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::hash<md::RouteLineBatchKey>,std::equal_to<md::RouteLineBatchKey>,true>,std::__unordered_map_equal<md::RouteLineBatchKey,std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>,std::equal_to<md::RouteLineBatchKey>,std::hash<md::RouteLineBatchKey>,true>,std::allocator<std::__hash_value_type<md::RouteLineBatchKey,std::vector<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,geo::StdAllocator<std::unique_ptr<md::RouteLineRibbon,mdm::TypeDeleter<md::RouteLineRibbon>>,mdm::Allocator>>>>>::__deallocate_node(*(void ***)(a1 + 64));
  uint64_t v2 = *(void **)(a1 + 48);
  *(void *)(a1 + 48) = 0;
  if (v2)
  {
    operator delete(v2);
  }
}

uint64_t __Block_byref_object_copy__7_7018(uint64_t result, void *a2)
{
  uint64_t v2 = a2[6];
  a2[6] = 0;
  *(void *)(result + 48) = v2;
  *(void *)(result + 56) = a2[7];
  a2[7] = 0;
  uint64_t v5 = a2[8];
  uint64_t v3 = a2 + 8;
  uint64_t v4 = v5;
  *(void *)(result + 64) = v5;
  uint64_t v6 = v3[1];
  *(void *)(result + 72) = v6;
  *(_DWORD *)(result + 80) = *((_DWORD *)v3 + 4);
  if (v6)
  {
    unint64_t v7 = *(void *)(v4 + 8);
    unint64_t v8 = *(void *)(result + 56);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8) {
        v7 %= v8;
      }
    }
    else
    {
      v7 &= v8 - 1;
    }
    *(void *)(v2 + 8 * v7) = result + 64;
    *uint64_t v3 = 0;
    v3[1] = 0;
  }
  return result;
}