void *geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(void *a1, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  BOOL v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *result;
  void *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  void *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unsigned char *v26;
  void *v27;
  unint64_t v28;
  uint64_t v29;
  _OWORD *v30;
  char *v31;
  uint64_t v32;
  long long v33;
  uint64_t v34;

  v4 = *(unsigned int *)(a2 + 4);
  v5 = v4 >> 7;
  v6 = (uint64_t)(a1[1] - *a1) >> 3;
  v7 = v4 >> 7 >= v6;
  v8 = (v4 >> 7) - v6;
  if (v7)
  {
    v15 = a1 + 4;
    v16 = a1[4] - a1[3];
    std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__append(a1, v8 + 1);
    v17 = v16 >> 3;
    if (*(void *)(*a1 + 8 * v5)) {
      goto LABEL_13;
    }
LABEL_12:
    operator new();
  }
  v9 = *(void *)(*a1 + 8 * v5);
  if (!v9) {
    goto LABEL_12;
  }
  v10 = *(unsigned __int16 *)(v9 + 2 * (v4 & 0x7F));
  v12 = a1[3];
  v11 = (void *)a1[4];
  if (v10 < ((uint64_t)v11 - v12) >> 3)
  {
    v13 = v12 + 8 * v10;
    result = (void *)(*(_DWORD *)(v13 + 4) == v4 ? v13 : a1[4]);
    if (result != v11) {
      return result;
    }
  }
  v15 = a1 + 4;
  v17 = ((unint64_t)v11 - v12) >> 3;
LABEL_13:
  *(_WORD *)(*(void *)(*a1 + 8 * v5) + 2 * (v4 & 0x7F)) = v17;
  v19 = (char *)a1[4];
  v18 = a1[5];
  if ((unint64_t)v19 >= v18)
  {
    v21 = (char *)a1[3];
    v22 = (v19 - v21) >> 3;
    v23 = v22 + 1;
    if ((unint64_t)(v22 + 1) >> 61) {
      abort();
    }
    v24 = v18 - (void)v21;
    if (v24 >> 2 > v23) {
      v23 = v24 >> 2;
    }
    if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
      v25 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      v25 = v23;
    }
    if (v25)
    {
      if (v25 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      v26 = operator new(8 * v25);
    }
    else
    {
      v26 = 0;
    }
    v27 = &v26[8 * v22];
    *v27 = *(void *)a2;
    v20 = v27 + 1;
    if (v19 == v21)
    {
      v21 = v19;
    }
    else
    {
      v28 = v19 - v21 - 8;
      if (v28 < 0x58) {
        goto LABEL_41;
      }
      if ((unint64_t)(v21 - v26) < 0x20) {
        goto LABEL_41;
      }
      v29 = (v28 >> 3) + 1;
      v30 = &v26[8 * v22 - 16];
      v31 = v19 - 16;
      v32 = v29 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v33 = *(_OWORD *)v31;
        *(v30 - 1) = *((_OWORD *)v31 - 1);
        *v30 = v33;
        v30 -= 2;
        v31 -= 32;
        v32 -= 4;
      }
      while (v32);
      v27 -= v29 & 0x3FFFFFFFFFFFFFFCLL;
      v19 -= 8 * (v29 & 0x3FFFFFFFFFFFFFFCLL);
      if (v29 != (v29 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_41:
        do
        {
          v34 = *((void *)v19 - 1);
          v19 -= 8;
          *--v27 = v34;
        }
        while (v19 != v21);
        v21 = (char *)a1[3];
      }
    }
    a1[3] = v27;
    a1[4] = v20;
    a1[5] = &v26[8 * v25];
    if (v21) {
      operator delete(v21);
    }
  }
  else
  {
    *(void *)v19 = *(void *)a2;
    v20 = v19 + 8;
  }
  *v15 = v20;
  return v20 - 1;
}

void std::__function::__func<gdc::Registry::_registerStorageDataSignals(unsigned long,gdc::TypeInfo,gdc::ComponentStorageSignals *)::{lambda(gdc::Registry*,std::span<gdc::Entity,18446744073709551615ul>)#2},std::allocator<gdc::Registry::_registerStorageDataSignals(unsigned long,gdc::TypeInfo,gdc::ComponentStorageSignals *)::{lambda(gdc::Registry*,std::span<gdc::Entity,18446744073709551615ul>)#2}>,void ()(gdc::Registry*,std::span<gdc::Entity,18446744073709551615ul>)>::operator()(uint64_t a1, uint64_t *a2, unint64_t **a3)
{
  uint64_t v3 = a1;
  uint64_t v4 = *a2;
  v6 = *a3;
  v5 = a3[1];
  v7 = *(void **)(a1 + 40);
  if (v5)
  {
    v8 = (void *)(a1 + 16);
    for (i = *a3; i != &v6[(void)v5]; ++i)
    {
      unint64_t v11 = *i;
      int v12 = (unsigned __int16)*i;
      if (*(unsigned __int16 *)(v4 + 40) == v12)
      {
        unint64_t v13 = HIDWORD(v11);
        uint64_t v14 = *(void *)(v4 + 48);
        if (HIDWORD(v11) < (unint64_t)((*(void *)(v4 + 56) - v14) >> 3))
        {
          v15 = (unsigned __int16 *)(v14 + 8 * v13);
          if (*v15 == v12 && v15[1] == WORD1(v11) && *((_DWORD *)v15 + 1) == HIDWORD(v11))
          {
            v16 = *(char ***)(v7[12] + 8 * v13);
            if (v16)
            {
              v18 = *v16;
              unint64_t v17 = (unint64_t)v16[1];
              if (*v16 == (char *)v17)
              {
                v19 = *v16;
LABEL_17:
                v20 = v16[1];
                if (v19 != (char *)v17)
                {
                  v20 = v19;
                  if (*v8 == *(void *)v19) {
                    continue;
                  }
                }
              }
              else
              {
                v19 = *v16;
                do
                {
                  if (*(void *)v19 >= *v8) {
                    goto LABEL_17;
                  }
                  v19 += 24;
                }
                while (v19 != (char *)v17);
                v20 = v16[1];
              }
              uint64_t v21 = (v20 - v18) / 24;
              v22 = &v18[24 * v21];
              unint64_t v23 = (unint64_t)v16[2];
              if (v17 >= v23)
              {
                v63 = v8;
                unint64_t v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v17 - (void)v18) >> 3) + 1;
                if (v29 > 0xAAAAAAAAAAAAAAALL) {
                  goto LABEL_68;
                }
                unint64_t v30 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (void)v18) >> 3);
                if (2 * v30 > v29) {
                  unint64_t v29 = 2 * v30;
                }
                if (v30 >= 0x555555555555555) {
                  unint64_t v31 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  unint64_t v31 = v29;
                }
                uint64_t v62 = v3;
                if (v31)
                {
                  __src = v7;
                  if (v31 > 0xAAAAAAAAAAAAAAALL) {
                    goto LABEL_69;
                  }
                  v32 = v22;
                  v33 = (char *)operator new(24 * v31);
                  v22 = v32;
                  v7 = __src;
                }
                else
                {
                  v33 = 0;
                }
                v35 = &v33[24 * v21];
                v36 = &v33[24 * v31];
                if (v35 == v36)
                {
                  int64_t v38 = 0xAAAAAAAAAAAAAAABLL * ((24 * v21) >> 3);
                  if (v35 <= v33)
                  {
                    __srca = v22;
                    if (v35 == v33) {
                      unint64_t v40 = 1;
                    }
                    else {
                      unint64_t v40 = 0x5555555555555556 * ((24 * v21) >> 3);
                    }
                    if (v40 > 0xAAAAAAAAAAAAAAALL) {
LABEL_69:
                    }
                      std::__throw_bad_array_new_length[abi:nn180100]();
                    v41 = v33;
                    v42 = (char *)operator new(24 * v40);
                    v35 = &v42[24 * (v40 >> 2)];
                    v36 = &v42[24 * v40];
                    if (v41)
                    {
                      v43 = &v42[24 * v40];
                      operator delete(v41);
                      v36 = v43;
                    }
                    v37 = v63;
                    v22 = __srca;
                  }
                  else
                  {
                    if (v38 >= -1) {
                      uint64_t v39 = v38 + 1;
                    }
                    else {
                      uint64_t v39 = v38 + 2;
                    }
                    v36 = &v33[24 * v21];
                    v35 -= 24 * (v39 >> 1);
                    v37 = v63;
                  }
                }
                else
                {
                  v37 = v63;
                }
                long long v44 = *(_OWORD *)v37;
                *((void *)v35 + 2) = v37[2];
                *(_OWORD *)v35 = v44;
                v45 = *v16;
                v46 = v35;
                if (*v16 != v22)
                {
                  v47 = v22;
                  v48 = v35;
                  do
                  {
                    long long v49 = *(_OWORD *)(v47 - 24);
                    v46 = v48 - 24;
                    *((void *)v48 - 1) = *((void *)v47 - 1);
                    *(_OWORD *)(v48 - 24) = v49;
                    v47 -= 24;
                    v48 -= 24;
                  }
                  while (v47 != v45);
                }
                v50 = v35 + 24;
                v51 = v16[1];
                int64_t v52 = v51 - v22;
                if (v51 != v22)
                {
                  __srcb = v36;
                  memmove(v50, v22, v51 - v22);
                  v36 = __srcb;
                }
                v53 = *v16;
                *v16 = v46;
                v16[1] = &v50[v52];
                v16[2] = v36;
                uint64_t v3 = v62;
                v8 = v63;
                if (v53) {
                  operator delete(v53);
                }
              }
              else if (v22 == (char *)v17)
              {
                long long v34 = *(_OWORD *)v8;
                *(void *)(v17 + 16) = v8[2];
                *(_OWORD *)unint64_t v17 = v34;
                v16[1] = (char *)(v17 + 24);
              }
              else
              {
                unint64_t v24 = v17 - 24;
                v25 = v16[1];
                if (v17 >= 0x18)
                {
                  do
                  {
                    long long v26 = *(_OWORD *)v24;
                    *((void *)v25 + 2) = *(void *)(v24 + 16);
                    *(_OWORD *)v25 = v26;
                    v25 += 24;
                    v24 += 24;
                  }
                  while (v24 < v17);
                }
                v16[1] = v25;
                if ((char *)v17 != v22 + 24)
                {
                  v27 = v22;
                  memmove(v22 + 24, v22, v17 - (void)(v22 + 24));
                  v22 = v27;
                }
                v28 = v8;
                if (v22 <= (char *)v8) {
                  v28 = &v8[3 * (v16[1] > (char *)v8)];
                }
                long long v10 = *(_OWORD *)v28;
                *((void *)v22 + 2) = v28[2];
                *(_OWORD *)v22 = v10;
              }
            }
          }
        }
      }
    }
  }
  for (j = (void *)v7[23]; j; j = (void *)*j)
  {
    v66 = v6;
    v67 = v5;
    uint64_t v65 = v4;
    uint64_t v55 = j[6];
    if (!v55) {
      goto LABEL_67;
    }
    (*(void (**)(uint64_t, uint64_t *, unint64_t **))(*(void *)v55 + 48))(v55, &v65, &v66);
  }
  v56 = (void *)v7[41];
  if (v56)
  {
    uint64_t v57 = *(void *)(v3 + 8);
    while (1)
    {
      v66 = v6;
      v67 = v5;
      uint64_t v64 = v57;
      uint64_t v65 = v4;
      uint64_t v58 = v56[6];
      if (!v58) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, unint64_t **, uint64_t *))(*(void *)v58 + 48))(v58, &v65, &v66, &v64);
      v56 = (void *)*v56;
      if (!v56) {
        return;
      }
    }
LABEL_67:
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_68:
    abort();
  }
}

void sub_1A17C098C(_Unwind_Exception *exception_object)
{
  if (v1) {
    operator delete(v1);
  }
  _Unwind_Resume(exception_object);
}

void *md::IconLabelPart::populateMeshDescriptor(md::IconLabelPart *this, md::IconMeshDescriptor *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1EF56F768;
  v3[1] = this;
  uint64_t v4 = v3;
  std::__function::__value_func<void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::swap[abi:nn180100](v3, (void *)a2 + 1);
  result = v4;
  if (v4 == v3) {
    return (void *)(*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (void *)(*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

void *std::__function::__value_func<void ()(md::LabelRenderDescriptor const&,md::IconMeshData &)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        void v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      void v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

uint64_t std::__function::__func<md::TextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::TextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::GlyphMeshData &)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF570728;
  a2[1] = v2;
  return result;
}

uint64_t gdc::Registry::storage<md::GlyphMeshDescriptor>(int8x8_t *a1)
{
  uint64_t v10 = 0x6080C5D91E489CF6;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x6080C5D91E489CF6;
    if (*(void *)&v1 <= 0x6080C5D91E489CF6uLL) {
      uint64_t v3 = 0x6080C5D91E489CF6uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x6080C5D91E489CF6;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x6080C5D91E489CF6)
      {
        if (v5[2] == 0x6080C5D91E489CF6) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x6080C5D91E489CF6) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x6080C5D91E489CF6) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A17C0FCC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t md::LabelPart::isFading(md::LabelPart *this)
{
  return 0;
}

uint64_t md::CompositeLabelPart::isAnimating(md::CompositeLabelPart *this)
{
  uint64_t v1 = *((void *)this + 72);
  uint64_t v2 = *((void *)this + 73);
  if (v1 == v2) {
    return 0;
  }
  uint64_t v3 = v1 + 8;
  do
  {
    uint64_t result = (*(uint64_t (**)(void))(**(void **)(v3 - 8) + 704))(*(void *)(v3 - 8));
    if (result) {
      break;
    }
    BOOL v5 = v3 == v2;
    v3 += 8;
  }
  while (!v5);
  return result;
}

uint64_t md::LabelPart::isAnimating(md::LabelPart *this)
{
  return 0;
}

float md::HorizontalTextLabelPart::pushToRenderModel(md::HorizontalTextLabelPart *this, gdc::Registry **a2, float a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  md::TextLabelPart::pushToRenderModel(this, a2, a3);
  if (*((unsigned char *)this + 873))
  {
    if (*((void *)this + 59))
    {
      int v6 = *((_DWORD *)this + 122);
      if (v6)
      {
        float result = *((float *)this + 197);
        if (result > 0.0)
        {
          *((_WORD *)this + 555) = *((_WORD *)this + 279);
          *((_WORD *)this + 568) = v6;
          *((unsigned char *)this + 1113) = *((unsigned char *)this + 565) ^ 1;
          *((unsigned char *)this + 1106) = *((unsigned char *)this + 556);
          uint64_t v7 = *((void *)this + 4);
          if (*(unsigned char *)(v7 + 78)) {
            int v8 = *(_DWORD *)(v7 + 72);
          }
          else {
            int v8 = 0;
          }
          *((_DWORD *)this + 282) = v8;
          *((unsigned char *)this + 1105) = *((unsigned char *)this + 809);
          gdc::Registry::create(*a2);
        }
      }
    }
  }
  return result;
}

void sub_1A17C122C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

float md::LabelPart::pixelBoundsForDisplay(md::LabelPart *this)
{
  return *(float *)(*((void *)this + 3) + 360);
}

void *std::__hash_table<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>>>::__emplace_unique_key_args<unsigned long,std::piecewise_construct_t const&,std::tuple<unsigned long const&>,std::tuple<>>(uint64_t *a1, unint64_t a2, void *a3)
{
  unint64_t v5 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v13 = a1 + 2;
  uint64_t v10 = operator new(0x20uLL);
  *uint64_t v10 = 0;
  v10[1] = v5;
  v10[2] = *a3;
  v10[3] = 0;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v5 = v3;
    goto LABEL_72;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = a1[1];
  }
  if (prime > v7)
  {
LABEL_35:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    v20 = operator new(8 * prime);
    uint64_t v21 = (void *)*a1;
    *a1 = (uint64_t)v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v22++) = 0;
    while (prime != v22);
    unint64_t v23 = (void *)*v13;
    if (!*v13) {
      goto LABEL_59;
    }
    size_t v24 = v23[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*a1 + 8 * v26) = v13;
      for (i = (void *)*v23; *v23; i = (void *)*v23)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          unint64_t v23 = i;
        }
        else if (*(void *)(*a1 + 8 * v28))
        {
          *unint64_t v23 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*a1 + v29);
          **(void **)(*a1 + v29) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v28) = v23;
          unint64_t v23 = i;
          size_t v26 = v28;
        }
      }
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*a1 + 8 * v24) = v13;
    v33 = (void *)*v23;
    if (!*v23) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*a1 + 8 * v35))
        {
          *(void *)(*a1 + 8 * v35) = v23;
          goto LABEL_64;
        }
        *unint64_t v23 = *v33;
        uint64_t v34 = 8 * v35;
        void *v33 = **(void **)(*a1 + v34);
        **(void **)(*a1 + v34) = v33;
        v33 = v23;
      }
      size_t v35 = v24;
LABEL_64:
      unint64_t v23 = v33;
      v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_60;
  }
  unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      unint64_t v40 = (void *)*a1;
      *a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_60;
    }
    goto LABEL_35;
  }
  unint64_t v7 = a1[1];
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5) {
      v5 %= v7;
    }
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_72:
  uint64_t v36 = *a1;
  v37 = *(void **)(*a1 + 8 * v5);
  if (v37)
  {
    *uint64_t v10 = *v37;
LABEL_80:
    void *v37 = v10;
    goto LABEL_81;
  }
  *uint64_t v10 = *v13;
  *unint64_t v13 = v10;
  *(void *)(v36 + 8 * v5) = v13;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++a1[3];
  return v10;
}

void sub_1A17C16BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long,std::unique_ptr<gdc::ComponentStorageWrapperBase>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<std::unique_ptr<std::array<unsigned short,128ul>>>::__append(void *a1, unint64_t a2)
{
  unint64_t v5 = (char *)a1[1];
  uint64_t v4 = a1[2];
  int v6 = v5;
  if (a2 <= (v4 - (uint64_t)v5) >> 3)
  {
    if (a2)
    {
      bzero(v5, 8 * a2);
      int v6 = &v5[8 * a2];
    }
    a1[1] = v6;
  }
  else
  {
    unint64_t v7 = (char *)*a1;
    uint64_t v8 = (uint64_t)&v5[-*a1];
    uint64_t v9 = v8 >> 3;
    unint64_t v10 = (v8 >> 3) + a2;
    if (v10 >> 61) {
      abort();
    }
    uint64_t v11 = v4 - (void)v7;
    if (v11 >> 2 > v10) {
      unint64_t v10 = v11 >> 2;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v12 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v13 = (char *)operator new(8 * v12);
    }
    else
    {
      unint64_t v13 = 0;
    }
    float v14 = &v13[8 * v9];
    size_t v15 = 8 * a2;
    BOOL v16 = &v13[8 * v12];
    bzero(v14, v15);
    unint64_t v17 = &v14[v15];
    if (v5 == v7)
    {
      *a1 = v14;
      a1[1] = v17;
      a1[2] = v16;
    }
    else
    {
      unint64_t v18 = v5 - v7 - 8;
      if (v18 <= 0x77
        || &v5[-(v18 & 0xFFFFFFFFFFFFFFF8) - 8] < v14 && &v13[v8 - (v18 & 0xFFFFFFFFFFFFFFF8) - 8] < v5)
      {
        goto LABEL_37;
      }
      uint64_t v19 = (v18 >> 3) + 1;
      int v6 = &v5[-8 * (v19 & 0x3FFFFFFFFFFFFFFCLL)];
      v20 = &v13[8 * v9 - 16];
      uint64_t v21 = v5 - 32;
      uint64_t v22 = v19 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v24 = *(_OWORD *)v21;
        long long v23 = *((_OWORD *)v21 + 1);
        *(_OWORD *)uint64_t v21 = 0uLL;
        *((_OWORD *)v21 + 1) = 0uLL;
        v21 -= 32;
        *((_OWORD *)v20 - 1) = v24;
        *(_OWORD *)v20 = v23;
        v20 -= 32;
        v22 -= 4;
      }
      while (v22);
      v14 -= 8 * (v19 & 0x3FFFFFFFFFFFFFFCLL);
      if (v19 != (v19 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_37:
        do
        {
          uint64_t v25 = *((void *)v6 - 1);
          v6 -= 8;
          *(void *)int v6 = 0;
          *((void *)v14 - 1) = v25;
          v14 -= 8;
        }
        while (v6 != v7);
      }
      int v6 = (char *)*a1;
      size_t v26 = (char *)a1[1];
      *a1 = v14;
      a1[1] = v17;
      a1[2] = v16;
      while (v26 != v6)
      {
        uint64_t v28 = *((void *)v26 - 1);
        v26 -= 8;
        uint64_t v27 = v28;
        *(void *)size_t v26 = 0;
        if (v28) {
          MEMORY[0x1A6239270](v27, 0x1000C40104B78CFLL);
        }
      }
    }
    if (v6)
    {
      operator delete(v6);
    }
  }
}

uint64_t md::AnimatedCrossFadeLabelPart::isAnimating(md::AnimatedCrossFadeLabelPart *this)
{
  return (*(uint64_t (**)(void))(*(void *)this + 696))();
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(void *a1, void *a2, void *a3, void *a4, unsigned int (**a5)(void))
{
  char v10 = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
  int v11 = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
  if (v10)
  {
    uint64_t v12 = *a1;
    if (v11)
    {
      *a1 = *a3;
      *a3 = v12;
    }
    else
    {
      *a1 = *a2;
      *a2 = v12;
      if ((*a5)(*a3))
      {
        uint64_t v15 = *a2;
        *a2 = *a3;
        *a3 = v15;
      }
    }
  }
  else if (v11)
  {
    uint64_t v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    if (((unsigned int (*)(void, void))*a5)(*a2, *a1))
    {
      uint64_t v14 = *a1;
      *a1 = *a2;
      *a2 = v14;
    }
  }
  uint64_t result = ((uint64_t (*)(void, void))*a5)(*a4, *a3);
  if (result)
  {
    uint64_t v17 = *a3;
    *a3 = *a4;
    *a4 = v17;
    uint64_t result = ((uint64_t (*)(void, void))*a5)(*a3, *a2);
    if (result)
    {
      uint64_t v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      uint64_t result = ((uint64_t (*)(void, void))*a5)(*a2, *a1);
      if (result)
      {
        uint64_t v19 = *a1;
        *a1 = *a2;
        *a2 = v19;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(md::LabelRenderDescriptor const*,md::LabelRenderDescriptor const*),md::LabelRenderDescriptor**>(void *a1, void *a2, unsigned int (**a3)(uint64_t))
{
  uint64_t v6 = a2 - a1;
  BOOL result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (((unsigned int (*)(void, void))*a3)(*(a2 - 1), *a1))
      {
        uint64_t v8 = *a1;
        *a1 = *(a2 - 1);
        *(a2 - 1) = v8;
      }
      return 1;
    case 3:
      char v9 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      int v10 = ((uint64_t (*)(void, void))*a3)(*(a2 - 1), a1[1]);
      if (v9)
      {
        uint64_t v11 = *a1;
        if (v10)
        {
          *a1 = *(a2 - 1);
          *(a2 - 1) = v11;
        }
        else
        {
          *a1 = a1[1];
          a1[1] = v11;
          if ((*a3)(*(a2 - 1)))
          {
            uint64_t v26 = a1[1];
            a1[1] = *(a2 - 1);
            *(a2 - 1) = v26;
          }
        }
      }
      else if (v10)
      {
        uint64_t v24 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v24;
        int v19 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
LABEL_17:
        if (v19) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(a1, a1 + 1, a1 + 2, a2 - 1, a3);
      return 1;
    case 5:
      uint64_t v12 = a1 + 2;
      uint64_t v13 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(a1, a1 + 1, a1 + 2, a1 + 3, a3);
      if (!((unsigned int (*)(void, void))*a3)(*(a2 - 1), a1[3])) {
        return 1;
      }
      uint64_t v14 = *v13;
      *uint64_t v13 = *(a2 - 1);
      *(a2 - 1) = v14;
      if (!((unsigned int (*)(void, void))*a3)(*v13, *v12)) {
        return 1;
      }
      uint64_t v15 = *v12;
      *uint64_t v12 = *v13;
      *uint64_t v13 = v15;
      if (!((unsigned int (*)(void))*a3)()) {
        return 1;
      }
      uint64_t v17 = a1[1];
      uint64_t v16 = a1[2];
      uint64_t v18 = *a1;
      a1[1] = v16;
      a1[2] = v17;
      int v19 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v16, v18);
      goto LABEL_17;
    default:
      char v20 = ((uint64_t (*)(void, void))*a3)(a1[1], *a1);
      uint64_t v21 = a1 + 2;
      int v22 = ((uint64_t (*)(void, void))*a3)(a1[2], a1[1]);
      if (v20)
      {
        uint64_t v23 = *a1;
        if (v22)
        {
          *a1 = a1[2];
          a1[2] = v23;
        }
        else
        {
          uint64_t v27 = a1[2];
          *a1 = a1[1];
          a1[1] = v23;
          if ((*a3)(v27)) {
            *(int8x16_t *)(a1 + 1) = vextq_s8(*(int8x16_t *)(a1 + 1), *(int8x16_t *)(a1 + 1), 8uLL);
          }
        }
      }
      else if (v22)
      {
        uint64_t v25 = a1[1];
        a1[1] = a1[2];
        a1[2] = v25;
        if (((unsigned int (*)(void))*a3)()) {
          *(int8x16_t *)a1 = vextq_s8(*(int8x16_t *)a1, *(int8x16_t *)a1, 8uLL);
        }
      }
      uint64_t v28 = a1 + 3;
      if (a1 + 3 == a2) {
        return 1;
      }
      uint64_t v29 = 0;
      int v30 = 0;
      break;
  }
  while (1)
  {
    if (((unsigned int (*)(void, void))*a3)(*v28, *v21))
    {
      uint64_t v32 = *v28;
      uint64_t v33 = v29;
      do
      {
        uint64_t v34 = (char *)a1 + v33;
        *(void *)((char *)a1 + v33 + 24) = *(void *)((char *)a1 + v33 + 16);
        if (v33 == -16)
        {
          uint8x8_t v31 = a1;
          goto LABEL_29;
        }
        v33 -= 8;
      }
      while ((((uint64_t (*)(uint64_t, void))*a3)(v32, *((void *)v34 + 1)) & 1) != 0);
      uint8x8_t v31 = (void *)((char *)a1 + v33 + 24);
LABEL_29:
      *uint8x8_t v31 = v32;
      if (++v30 == 8) {
        return v28 + 1 == a2;
      }
    }
    uint64_t v21 = v28;
    v29 += 8;
    if (++v28 == a2) {
      return 1;
    }
  }
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(md::LabelRenderDescriptor const*,md::LabelRenderDescriptor const*),md::LabelRenderDescriptor**,false>(uint64_t result, int8x16_t *a2, unsigned int (**a3)(uint64_t), uint64_t a4, char a5)
{
  char v9 = (int8x16_t *)result;
  while (2)
  {
    int v10 = a2;
    uint64_t v11 = &a2[-1].i64[1];
    uint64_t v12 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          char v9 = v12;
          uint64_t v13 = (char *)v10 - (char *)v12;
          uint64_t v14 = ((char *)v10 - (char *)v12) >> 3;
          if (v6 || !v5)
          {
            switch(v14)
            {
              case 0:
              case 1:
                return result;
              case 2:
                BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v77 = v12->i64[0];
                v12->i64[0] = *v11;
                goto LABEL_169;
              case 3:
                char v78 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
                BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12->i64[1]);
                if (v78)
                {
                  uint64_t v79 = v12->i64[0];
                  if (result)
                  {
                    v12->i64[0] = *v11;
                    *uint64_t v11 = v79;
                  }
                  else
                  {
                    v12->i64[0] = v12->i64[1];
                    v12->i64[1] = v79;
                    BOOL result = ((uint64_t (*)(uint64_t))*a3)(*v11);
                    if (result)
                    {
                      uint64_t v77 = v12->i64[1];
                      v12->i64[1] = *v11;
LABEL_169:
                      *uint64_t v11 = v77;
                    }
                  }
                }
                else if (result)
                {
                  uint64_t v105 = v12->i64[1];
                  v12->i64[1] = *v11;
                  *uint64_t v11 = v105;
                  BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v12->i64[1], v12->i64[0]);
LABEL_143:
                  if (result) {
                    *uint64_t v12 = vextq_s8(*v12, *v12, 8uLL);
                  }
                }
                break;
              case 4:
                return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, v11, a3);
              case 5:
                v80 = v12 + 1;
                v81 = &v12[1].i64[1];
                std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(karo::StaticSphereTreeElement const*,karo::StaticSphereTreeElement const*),karo::StaticSphereTreeElement**>(v12, &v12->i64[1], (int8x16_t *)v12[1].i64, &v12[1].i64[1], a3);
                BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v12[1].i64[1]);
                if (!result) {
                  return result;
                }
                uint64_t v82 = *v81;
                uint64_t *v81 = *v11;
                *uint64_t v11 = v82;
                BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v81, v80->i64[0]);
                if (!result) {
                  return result;
                }
                uint64_t v83 = v80->i64[0];
                v80->i64[0] = *v81;
                uint64_t *v81 = v83;
                BOOL result = ((uint64_t (*)(void))*a3)();
                if (!result) {
                  return result;
                }
                uint64_t v85 = v12->i64[1];
                uint64_t v84 = v12[1].i64[0];
                uint64_t v86 = v12->i64[0];
                v12->i64[1] = v84;
                v12[1].i64[0] = v85;
                BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v84, v86);
                goto LABEL_143;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v13 <= 191)
          {
            v87 = &v12->i64[1];
            BOOL v89 = v12 == v10 || v87 == (uint64_t *)v10;
            if (a5)
            {
              if (!v89)
              {
                uint64_t v90 = 0;
                v91 = (uint64_t *)v12;
                do
                {
                  uint64_t v94 = *v91;
                  uint64_t v93 = v91[1];
                  v91 = v87;
                  BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v93, v94);
                  if (result)
                  {
                    uint64_t v95 = *v91;
                    uint64_t v96 = v90;
                    do
                    {
                      *(uint64_t *)((char *)&v12->i64[1] + v96) = *(uint64_t *)((char *)v12->i64 + v96);
                      if (!v96)
                      {
                        v92 = (uint64_t *)v12;
                        goto LABEL_117;
                      }
                      BOOL result = ((uint64_t (*)(uint64_t, void))*a3)(v95, *(uint64_t *)((char *)&v12->i64[-1] + v96));
                      v96 -= 8;
                    }
                    while ((result & 1) != 0);
                    v92 = (uint64_t *)((char *)&v12->i64[1] + v96);
LABEL_117:
                    uint64_t *v92 = v95;
                  }
                  v87 = v91 + 1;
                  v90 += 8;
                }
                while (v91 + 1 != (uint64_t *)a2);
              }
            }
            else if (!v89)
            {
              do
              {
                uint64_t v107 = v9->i64[0];
                uint64_t v106 = v9->i64[1];
                char v9 = (int8x16_t *)v87;
                BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v106, v107);
                if (result)
                {
                  uint64_t v108 = v9->i64[0];
                  v109 = (uint64_t *)v9;
                  do
                  {
                    v110 = v109;
                    uint64_t v111 = *--v109;
                    uint64_t *v110 = v111;
                    BOOL result = ((uint64_t (*)(uint64_t, void))*a3)(v108, *(v110 - 2));
                  }
                  while ((result & 1) != 0);
                  uint64_t *v109 = v108;
                }
                v87 = &v9->i64[1];
              }
              while (&v9->u64[1] != (unint64_t *)a2);
            }
            return result;
          }
          if (!a4)
          {
            if (v12 != v10)
            {
              int64_t v97 = (unint64_t)(v14 - 2) >> 1;
              int64_t v128 = v97;
              do
              {
                if (v128 >= v97)
                {
                  uint64_t v99 = (2 * v97) | 1;
                  v100 = &v9->i64[v99];
                  if (2 * v97 + 2 < v14 && ((unsigned int (*)(uint64_t, uint64_t))*a3)(*v100, v100[1]))
                  {
                    ++v100;
                    uint64_t v99 = 2 * v97 + 2;
                  }
                  v101 = &v9->i64[v97];
                  BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v100, *v101);
                  if ((result & 1) == 0)
                  {
                    uint64_t v126 = *v101;
                    do
                    {
                      v102 = v100;
                      uint64_t *v101 = *v100;
                      if (v128 < v99) {
                        break;
                      }
                      uint64_t v103 = (2 * v99) | 1;
                      v100 = &v9->i64[v103];
                      uint64_t v104 = 2 * v99 + 2;
                      if (v104 < v14 && ((unsigned int (*)(uint64_t, uint64_t))*a3)(*v100, v100[1]))
                      {
                        ++v100;
                        uint64_t v103 = v104;
                      }
                      BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v100, v126);
                      v101 = v102;
                      uint64_t v99 = v103;
                    }
                    while (!result);
                    uint64_t *v102 = v126;
                  }
                }
                BOOL v98 = v97-- <= 0;
              }
              while (!v98);
              uint64_t v112 = (unint64_t)v13 >> 3;
              do
              {
                uint64_t v113 = 0;
                uint64_t v114 = v9->i64[0];
                v115 = (uint64_t *)v9;
                do
                {
                  v116 = (unint64_t *)&v115[v113 + 1];
                  uint64_t v117 = (2 * v113) | 1;
                  uint64_t v118 = 2 * v113 + 2;
                  if (v118 < v112)
                  {
                    BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v115[v113 + 1], v115[v113 + 2]);
                    if (result)
                    {
                      ++v116;
                      uint64_t v117 = v118;
                    }
                  }
                  uint64_t *v115 = *v116;
                  v115 = (uint64_t *)v116;
                  uint64_t v113 = v117;
                }
                while (v117 <= (uint64_t)((unint64_t)(v112 - 2) >> 1));
                v119 = &a2[-1].i64[1];
                BOOL v6 = v116 == &a2[-1].u64[1];
                a2 = (int8x16_t *)((char *)a2 - 8);
                if (v6)
                {
                  unint64_t *v116 = v114;
                }
                else
                {
                  unint64_t *v116 = *v119;
                  uint64_t *v119 = v114;
                  uint64_t v120 = (char *)v116 - (char *)v9 + 8;
                  if (v120 >= 9)
                  {
                    unint64_t v121 = (((unint64_t)v120 >> 3) - 2) >> 1;
                    v122 = &v9->i64[v121];
                    BOOL result = ((uint64_t (*)(uint64_t, unint64_t))*a3)(*v122, *v116);
                    if (result)
                    {
                      unint64_t v123 = *v116;
                      do
                      {
                        v124 = v122;
                        unint64_t *v116 = *v122;
                        if (!v121) {
                          break;
                        }
                        unint64_t v121 = (v121 - 1) >> 1;
                        v122 = &v9->i64[v121];
                        BOOL result = ((uint64_t (*)(uint64_t, unint64_t))*a3)(*v122, v123);
                        v116 = (unint64_t *)v124;
                      }
                      while ((result & 1) != 0);
                      uint64_t *v124 = v123;
                    }
                  }
                }
                BOOL v98 = v112-- <= 2;
              }
              while (!v98);
            }
            return result;
          }
          unint64_t v15 = (unint64_t)v14 >> 1;
          uint64_t v16 = *a3;
          if ((unint64_t)v13 >= 0x401)
          {
            char v17 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v9->i64[v15], v9->i64[0]);
            int v18 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v9->i64[v15]);
            if (v17)
            {
              uint64_t v19 = v9->i64[0];
              if (v18)
              {
                v9->i64[0] = *v11;
                *uint64_t v11 = v19;
              }
              else
              {
                v9->i64[0] = v9->i64[v15];
                v9->i64[v15] = v19;
                if ((*a3)(*v11))
                {
                  uint64_t v27 = v9->i64[v15];
                  v9->i64[v15] = *v11;
                  *uint64_t v11 = v27;
                }
              }
            }
            else if (v18)
            {
              uint64_t v23 = v9->i64[v15];
              v9->i64[v15] = *v11;
              *uint64_t v11 = v23;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v15], v9->i64[0]))
              {
                uint64_t v24 = v9->i64[0];
                v9->i64[0] = v9->i64[v15];
                v9->i64[v15] = v24;
              }
            }
            unint64_t v28 = v15 - 1;
            uint64_t v29 = v15 - 1;
            char v30 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v29], v9->i64[1]);
            int v31 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v10[-1].i64[0], v9->i64[v29]);
            uint64_t v125 = a4;
            if (v30)
            {
              uint64_t v32 = v9->i64[1];
              if (v31)
              {
                v9->i64[1] = v10[-1].i64[0];
                v10[-1].i64[0] = v32;
              }
              else
              {
                v9->i64[1] = v9->i64[v29];
                v9->i64[v29] = v32;
                if ((*a3)(v10[-1].i64[0]))
                {
                  uint64_t v36 = v9->i64[v29];
                  v9->i64[v29] = v10[-1].i64[0];
                  v10[-1].i64[0] = v36;
                }
              }
            }
            else if (v31)
            {
              uint64_t v33 = v9->i64[v29];
              v9->i64[v29] = v10[-1].i64[0];
              v10[-1].i64[0] = v33;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v29], v9->i64[1]))
              {
                uint64_t v34 = v9->i64[1];
                v9->i64[1] = v9->i64[v29];
                v9->i64[v29] = v34;
              }
            }
            unint64_t v37 = v15 + 1;
            uint64_t v38 = v15 + 1;
            char v39 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v38], v9[1].i64[0]);
            int v40 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v10[-2].i64[1], v9->i64[v38]);
            if (v39)
            {
              uint64_t v41 = v9[1].i64[0];
              if (v40)
              {
                v9[1].i64[0] = v10[-2].i64[1];
                v10[-2].i64[1] = v41;
              }
              else
              {
                v9[1].i64[0] = v9->i64[v38];
                v9->i64[v38] = v41;
                if ((*a3)(v10[-2].i64[1]))
                {
                  uint64_t v44 = v9->i64[v38];
                  v9->i64[v38] = v10[-2].i64[1];
                  v10[-2].i64[1] = v44;
                }
              }
            }
            else if (v40)
            {
              uint64_t v42 = v9->i64[v38];
              v9->i64[v38] = v10[-2].i64[1];
              v10[-2].i64[1] = v42;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[v38], v9[1].i64[0]))
              {
                uint64_t v43 = v9[1].i64[0];
                v9[1].i64[0] = v9->i64[v38];
                v9->i64[v38] = v43;
              }
            }
            char v45 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v15], v9->i64[v28]);
            int v46 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[v37], v9->i64[v15]);
            if (v45)
            {
              uint64_t v47 = v9->i64[v28];
              if (v46)
              {
                v9->i64[v28] = v9->i64[v38];
                v9->i64[v38] = v47;
                uint64_t v48 = v9->i64[v15];
                uint64_t v11 = &a2[-1].i64[1];
              }
              else
              {
                v9->i64[v28] = v9->i64[v15];
                v9->i64[v15] = v47;
                unsigned int v51 = (*a3)(v9->i64[v37]);
                uint64_t v48 = v9->i64[v15];
                uint64_t v11 = &a2[-1].i64[1];
                if (v51)
                {
                  uint64_t v52 = v9->i64[v38];
                  v9->i64[v15] = v52;
                  v9->i64[v38] = v48;
                  uint64_t v48 = v52;
                }
              }
              a4 = v125;
            }
            else
            {
              uint64_t v48 = v9->i64[v15];
              a4 = v125;
              if (v46)
              {
                v9->i64[v15] = v9->i64[v38];
                v9->i64[v38] = v48;
                int v49 = ((uint64_t (*)(void))*a3)();
                uint64_t v48 = v9->i64[v15];
                if (v49)
                {
                  uint64_t v50 = v9->i64[v29];
                  v9->i64[v29] = v48;
                  v9->i64[v15] = v50;
                  uint64_t v48 = v50;
                }
              }
              uint64_t v11 = &a2[-1].i64[1];
            }
            uint64_t v53 = v9->i64[0];
            v9->i64[0] = v48;
            v9->i64[v15] = v53;
          }
          else
          {
            char v20 = ((uint64_t (*)(uint64_t, uint64_t))v16)(v9->i64[0], v9->i64[v15]);
            int v21 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(*v11, v9->i64[0]);
            if (v20)
            {
              uint64_t v22 = v9->i64[v15];
              if (v21)
              {
                v9->i64[v15] = *v11;
                *uint64_t v11 = v22;
              }
              else
              {
                v9->i64[v15] = v9->i64[0];
                v9->i64[0] = v22;
                if ((*a3)(*v11))
                {
                  uint64_t v35 = v9->i64[0];
                  v9->i64[0] = *v11;
                  *uint64_t v11 = v35;
                }
              }
            }
            else if (v21)
            {
              uint64_t v25 = v9->i64[0];
              v9->i64[0] = *v11;
              *uint64_t v11 = v25;
              if (((unsigned int (*)(uint64_t, uint64_t))*a3)(v9->i64[0], v9->i64[v15]))
              {
                uint64_t v26 = v9->i64[v15];
                v9->i64[v15] = v9->i64[0];
                v9->i64[0] = v26;
              }
            }
          }
          --a4;
          uint64_t v54 = v9->i64[0];
          if (a5) {
            break;
          }
          char v55 = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9[-1].i64[1], v9->i64[0]);
          uint64_t v54 = v9->i64[0];
          if (v55) {
            break;
          }
          BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v9->i64[0], *v11);
          if (result)
          {
            uint64_t v12 = v9;
            do
            {
              uint64_t v69 = v12->i64[1];
              uint64_t v12 = (int8x16_t *)((char *)v12 + 8);
              BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v69);
            }
            while ((result & 1) == 0);
          }
          else
          {
            v70 = (int8x16_t *)&v9->u64[1];
            do
            {
              uint64_t v12 = v70;
              if (v70 >= a2) {
                break;
              }
              v70 = (int8x16_t *)((char *)v70 + 8);
              BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v12->i64[0]);
            }
            while (!result);
          }
          int v10 = a2;
          v71 = a2;
          if (v12 < a2)
          {
            v71 = a2;
            do
            {
              uint64_t v72 = v71[-1].i64[1];
              v71 = (int8x16_t *)((char *)v71 - 8);
              BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v72);
            }
            while ((result & 1) != 0);
          }
          while (v12 < v71)
          {
            uint64_t v73 = v12->i64[0];
            v12->i64[0] = v71->i64[0];
            v71->i64[0] = v73;
            do
            {
              uint64_t v74 = v12->i64[1];
              uint64_t v12 = (int8x16_t *)((char *)v12 + 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v54, v74));
            do
            {
              uint64_t v75 = v71[-1].i64[1];
              v71 = (int8x16_t *)((char *)v71 - 8);
              BOOL result = ((uint64_t (*)(uint64_t, uint64_t))*a3)(v54, v75);
            }
            while ((result & 1) != 0);
          }
          v76 = &v12[-1].i64[1];
          BOOL v5 = &v12[-1].u64[1] >= (unint64_t *)v9;
          BOOL v6 = &v12[-1].u64[1] == (unint64_t *)v9;
          if (&v12[-1].u64[1] != (unint64_t *)v9) {
            v9->i64[0] = *v76;
          }
          a5 = 0;
          uint64_t *v76 = v54;
        }
        v56 = (uint64_t *)v9;
        do
        {
          uint64_t v57 = (int8x16_t *)v56;
          uint64_t v58 = v56[1];
          ++v56;
        }
        while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v58, v54) & 1) != 0);
        uint64_t v59 = a4;
        v60 = (uint64_t *)v10;
        if (v57 == v9)
        {
          v60 = (uint64_t *)v10;
          do
          {
            if (v56 >= v60) {
              break;
            }
            uint64_t v62 = *--v60;
          }
          while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v62, v54) & 1) == 0);
        }
        else
        {
          do
            uint64_t v61 = *--v60;
          while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v61, v54));
        }
        if (v56 < v60)
        {
          v63 = (int8x16_t *)v56;
          uint64_t v64 = (int8x16_t *)v60;
          do
          {
            uint64_t v65 = v63->i64[0];
            v63->i64[0] = v64->i64[0];
            v64->i64[0] = v65;
            do
            {
              uint64_t v57 = v63;
              uint64_t v66 = v63->i64[1];
              v63 = (int8x16_t *)((char *)v63 + 8);
            }
            while ((((uint64_t (*)(uint64_t, uint64_t))*a3)(v66, v54) & 1) != 0);
            do
            {
              uint64_t v67 = v64[-1].i64[1];
              uint64_t v64 = (int8x16_t *)((char *)v64 - 8);
            }
            while (!((unsigned int (*)(uint64_t, uint64_t))*a3)(v67, v54));
          }
          while (v63 < v64);
        }
        if (v57 != v9) {
          v9->i64[0] = v57->i64[0];
        }
        v57->i64[0] = v54;
        int v10 = a2;
        a4 = v59;
        if (v56 >= v60) {
          break;
        }
LABEL_73:
        BOOL result = std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(md::LabelRenderDescriptor const*,md::LabelRenderDescriptor const*),md::LabelRenderDescriptor**,false>(v9, v57, a3, a4, a5 & 1);
        a5 = 0;
        uint64_t v12 = (int8x16_t *)&v57->u64[1];
      }
      BOOL v68 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(md::LabelRenderDescriptor const*,md::LabelRenderDescriptor const*),md::LabelRenderDescriptor**>(v9, v57, a3);
      uint64_t v12 = (int8x16_t *)&v57->u64[1];
      BOOL result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,BOOL (*&)(md::LabelRenderDescriptor const*,md::LabelRenderDescriptor const*),md::LabelRenderDescriptor**>(&v57->i64[1], a2, a3);
      if (result) {
        break;
      }
      if (!v68) {
        goto LABEL_73;
      }
    }
    a2 = v57;
    if (!v68) {
      continue;
    }
    return result;
  }
}

BOOL sortRenderDescriptionFunc(unint64_t a1, unint64_t a2)
{
  unsigned int v2 = *(unsigned __int8 *)(a1 + 1);
  unsigned int v3 = *(unsigned __int8 *)(a2 + 1);
  if (v2 != v3) {
    return v2 > v3;
  }
  int v4 = *(unsigned __int8 *)(a1 + 2);
  int v5 = *(unsigned __int8 *)(a2 + 2);
  if (v4 != v5) {
    return (char)v4 < (char)v5;
  }
  float v6 = *(float *)(a1 + 24);
  float v7 = *(float *)(a2 + 24);
  if (v6 != v7) {
    return v6 > v7;
  }
  unsigned int v9 = *(unsigned __int16 *)(a1 + 6);
  unsigned int v10 = *(unsigned __int16 *)(a2 + 6);
  BOOL v11 = v9 >= v10;
  if (v9 != v10) {
    return !v11;
  }
  unsigned int v12 = *(unsigned __int8 *)(a1 + 3);
  unsigned int v13 = *(unsigned __int8 *)(a2 + 3);
  BOOL v11 = v12 >= v13;
  if (v12 != v13) {
    return !v11;
  }
  unsigned int v14 = *(unsigned __int8 *)(a1 + 8);
  unsigned int v15 = *(unsigned __int8 *)(a2 + 8);
  BOOL v11 = v14 >= v15;
  if (v14 != v15) {
    return !v11;
  }
  unsigned int v16 = *(unsigned __int8 *)(a1 + 4);
  unsigned int v17 = *(unsigned __int8 *)(a2 + 4);
  BOOL v11 = v16 >= v17;
  if (v16 != v17) {
    return !v11;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v19 = *(void *)(a2 + 16);
  if (v18 == v19)
  {
    int v20 = *(unsigned __int8 *)(a1 + 9);
    if (v20 == *(unsigned __int8 *)(a2 + 9)) {
      return a1 < a2;
    }
    else {
      return v20 == 0;
    }
  }
  else
  {
    BOOL v21 = v18 == v19;
    BOOL v22 = v18 < v19;
    if (v21) {
      return HIDWORD(v18) < HIDWORD(v19);
    }
    else {
      return v22;
    }
  }
}

void std::__function::__func<md::CurvedTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::CurvedTextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::ShadowMeshData &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, double a4, int8x16_t a5, double a6, int32x4_t a7, int32x4_t a8, double a9, int32x4_t a10, int8x16_t a11)
{
  uint64_t v13 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v13 + 565)) {
    *(void *)(a3 + 40) = (*(uint64_t (**)(void))(*(void *)v13 + 144))(*(void *)(a1 + 8));
  }
  *(_DWORD *)(a3 + 24) = *(_DWORD *)(v13 + 552);
  *(unsigned char *)(a3 + 32) = *(unsigned char *)(v13 + 826);
  *(unsigned char *)(a3 + 33) = *(unsigned char *)(v13 + 827);
  *(unsigned char *)(a3 + 34) = *(unsigned char *)(v13 + 828);
  *(unsigned char *)(a3 + 35) = *(unsigned char *)(v13 + 829);
  unint64_t v14 = *(unsigned __int16 *)(a2 + 32);
  unsigned int v15 = *(char **)a3;
  unsigned int v16 = *(char **)(a3 + 8);
  unint64_t v17 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)&v16[-*(void *)a3] >> 3);
  if (v14 <= v17)
  {
    if (v14 < v17)
    {
      unsigned int v16 = &v15[56 * *(unsigned __int16 *)(a2 + 32)];
      *(void *)(a3 + 8) = v16;
    }
  }
  else
  {
    std::vector<md::ShadowMeshQuad>::__append((char **)a3, v14 - v17);
    unint64_t v14 = *(unsigned __int16 *)(a2 + 32);
    unsigned int v15 = *(char **)a3;
    unsigned int v16 = *(char **)(a3 + 8);
  }
  *(_DWORD *)(a3 + 28) = *(_DWORD *)(v13 + 788);
  unint64_t v18 = 0x6DB6DB6DB6DB6DB7 * ((v16 - v15) >> 3);
  if (v14 <= v18)
  {
    if (v14 < v18) {
      *(void *)(a3 + 8) = &v15[56 * v14];
    }
  }
  else
  {
    std::vector<md::ShadowMeshQuad>::__append((char **)a3, v14 - v18);
  }
  uint64_t v19 = *(void *)(v13 + 880);
  uint64_t v20 = *(void *)(v13 + 888);
  if (v19 != v20)
  {
    uint64_t v21 = 0;
    do
    {
      if (*(unsigned char *)(v19 + 1))
      {
        uint64_t v25 = *(_DWORD **)(v19 + 8);
        LODWORD(a4) = *(_DWORD *)(*(void *)v25 + 40);
        a5.i32[0] = *(_DWORD *)(*(void *)v25 + 44);
        LODWORD(a6) = *(_DWORD *)(*(void *)v25 + 32);
        a7.i32[0] = *(_DWORD *)(*(void *)v25 + 36);
        float v26 = *(float *)a5.i32 - *(float *)a7.i32;
        float v27 = (float)(*(float *)&a4 - *(float *)&a6) * 0.5;
        if (*(float *)&a4 >= *(float *)&a6 && *(float *)a5.i32 >= *(float *)a7.i32)
        {
          float v29 = *(float *)(v13 + 788);
          *(float *)a10.i32 = (float)(v26 * 0.1) - v29;
          float v30 = fminf(v27, v26 * 0.1) - v29;
          *(float *)&a6 = v30 + *(float *)&a6;
          *(float *)&a4 = *(float *)&a4 - v30;
          *(float *)a7.i32 = *(float *)a10.i32 + *(float *)a7.i32;
          *(float *)a5.i32 = *(float *)a5.i32 - *(float *)a10.i32;
          float v26 = *(float *)a5.i32 - *(float *)a7.i32;
          float v27 = (float)(*(float *)&a4 - *(float *)&a6) * 0.5;
        }
        BOOL v22 = *(char **)a3;
        uint64_t v23 = (float *)(*(void *)a3 + 56 * v21);
        a8.i32[0] = v25[20];
        LODWORD(a9) = *(_DWORD *)(*(void *)v25 + 48);
        *uint64_t v23 = *(float *)&a6;
        v23[1] = *(float *)a7.i32;
        v23[2] = 0.0;
        v23[3] = *(float *)&a4;
        v23[4] = *(float *)a7.i32;
        v23[5] = 0.0;
        v23[6] = *(float *)&a4;
        v23[7] = *(float *)a5.i32;
        v23[8] = 0.0;
        *(float *)&a4 = *(float *)a8.i32 / *(float *)&a9;
        v23[9] = *(float *)&a6;
        v23[10] = *(float *)a5.i32;
        v23[11] = 0.0;
        md::TextLabelPart::prepareGlyphVertices(v13, (uint64_t)v25, (uint64_t)v23, a4, a5, a6, a7, a8, a9, a10, a11);
        *(float *)&a6 = v23[1];
        *uint64_t v23 = *v23 + *(float *)(v13 + 1440);
        v23[1] = *(float *)&a6 + *(float *)(v13 + 1444);
        *(float *)&a6 = v23[3];
        v23[2] = v23[2] + *(float *)(v13 + 1448);
        v23[3] = *(float *)&a6 + *(float *)(v13 + 1440);
        *(float *)&a6 = v23[5];
        v23[4] = v23[4] + *(float *)(v13 + 1444);
        v23[5] = *(float *)&a6 + *(float *)(v13 + 1448);
        *(float *)&a6 = v23[7];
        v23[6] = v23[6] + *(float *)(v13 + 1440);
        v23[7] = *(float *)&a6 + *(float *)(v13 + 1444);
        *(float *)&a6 = v23[9];
        v23[8] = v23[8] + *(float *)(v13 + 1448);
        v23[9] = *(float *)&a6 + *(float *)(v13 + 1440);
        *(float *)&a6 = v23[11];
        v23[10] = v23[10] + *(float *)(v13 + 1444);
        v23[11] = *(float *)&a6 + *(float *)(v13 + 1448);
        uint64_t v24 = &v22[56 * v21];
        *((float *)v24 + 12) = v27;
        *((float *)v24 + 13) = v26 * 0.5;
        ++v21;
      }
      v19 += 16;
    }
    while (v19 != v20);
  }
}

void std::__function::__func<md::TextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0,std::allocator<md::TextLabelPart::pushToRenderModel(md::LabelRenderModel &,float)::$_0>,void ()(md::LabelRenderDescriptor const&,md::GlyphMeshData &)>::operator()(uint64_t a1, unsigned __int16 *a2, char **a3, double a4, double a5, uint8x8_t a6, uint8x8_t a7)
{
  uint64_t v9 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v9 + 565))
  {
    a3[8] = (char *)(*(uint64_t (**)(void))(*(void *)v9 + 144))(*(void *)(a1 + 8));
    if (*(unsigned char *)(v9 + 866))
    {
      a3[9] = *(char **)(v9 + 776);
      int v10 = *(_DWORD *)(v9 + 908);
      *((_DWORD *)a3 + 20) = *(_DWORD *)(v9 + 772);
      *((_DWORD *)a3 + 21) = v10;
      *((unsigned char *)a3 + 88) = *(unsigned char *)(v9 + 822);
      *((unsigned char *)a3 + 89) = *(unsigned char *)(v9 + 823);
      *((unsigned char *)a3 + 90) = *(unsigned char *)(v9 + 824);
      *((unsigned char *)a3 + 91) = *(unsigned char *)(v9 + 825);
      *((unsigned char *)a3 + 92) = *(unsigned char *)(v9 + 818);
      *((unsigned char *)a3 + 93) = *(unsigned char *)(v9 + 819);
      *((unsigned char *)a3 + 94) = *(unsigned char *)(v9 + 820);
      *((unsigned char *)a3 + 95) = *(unsigned char *)(v9 + 821);
    }
  }
  int v11 = *(unsigned __int8 *)(v9 + 808);
  if (*(unsigned char *)(v9 + 808)) {
    int v12 = a2[17] - 1;
  }
  else {
    int v12 = a2[18] + 1;
  }
  if (*(unsigned char *)(v9 + 808)) {
    unsigned int v13 = a2[18];
  }
  else {
    unsigned int v13 = a2[17];
  }
  *((_DWORD *)a3 + 6) = *(_DWORD *)(v9 + 552);
  int32x4_t v14 = vdupq_n_s32(0x3B808081u);
  a7.i32[0] = *(_DWORD *)(v9 + 810);
  int32x4_t v15 = v14;
  *(float *)v15.i32 = *(float *)(v9 + 764) * 0.0039216;
  float32x4_t v16 = (float32x4_t)vzip1q_s32(v15, v15);
  v16.f32[2] = *(float *)(v9 + 764) * 0.0039216;
  *(float32x4_t *)((char *)a3 + 28) = vmulq_f32(v16, vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a7))));
  a6.i32[0] = *(_DWORD *)(v9 + 814);
  *(float *)v14.i32 = *(float *)(v9 + 764) * 0.0039216;
  float32x4_t v17 = (float32x4_t)vzip1q_s32(v14, v14);
  v17.f32[2] = *(float *)(v9 + 764) * 0.0039216;
  *(float32x4_t *)((char *)a3 + 44) = vmulq_f32(v17, vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(a6))));
  unint64_t v18 = a2[16];
  uint64_t v19 = *a3;
  uint64_t v20 = a3[1];
  unint64_t v21 = 0xD37A6F4DE9BD37A7 * ((v20 - *a3) >> 2);
  unint64_t v22 = v18 - v21;
  v80 = (void **)a3;
  if (v18 <= v21)
  {
    if (v18 >= v21) {
      goto LABEL_28;
    }
    uint64_t v35 = &v19[92 * v18];
    goto LABEL_24;
  }
  uint64_t v23 = a3[2];
  if (0xD37A6F4DE9BD37A7 * ((v23 - v20) >> 2) >= v22)
  {
    bzero(v20, 92 * ((92 * v22 - 92) / 0x5C) + 92);
    uint64_t v35 = &v20[92 * ((92 * v22 - 92) / 0x5C) + 92];
LABEL_24:
    a3[1] = v35;
    goto LABEL_28;
  }
  unint64_t v24 = 0xD37A6F4DE9BD37A7 * ((v23 - v19) >> 2);
  unint64_t v25 = 0xA6F4DE9BD37A6F4ELL * ((v23 - v19) >> 2);
  if (v25 > v18) {
    unint64_t v18 = v25;
  }
  if (v24 >= 0x1642C8590B21642) {
    unint64_t v18 = 0x2C8590B21642C85;
  }
  if (v18 > 0x2C8590B21642C85) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v26 = 92 * v18;
  float v27 = (char *)operator new(92 * v18);
  unint64_t v28 = &v27[92 * v21];
  uint64_t v79 = &v27[v26];
  bzero(v28, 92 * ((92 * v22 - 92) / 0x5C) + 92);
  float v29 = &v28[92 * ((92 * v22 - 92) / 0x5C) + 92];
  if (v20 == v19)
  {
    float v30 = v80;
  }
  else
  {
    float v30 = v80;
    do
    {
      long long v31 = *(_OWORD *)(v20 - 92);
      *(_OWORD *)(v28 - 76) = *(_OWORD *)(v20 - 76);
      *(_OWORD *)(v28 - 92) = v31;
      long long v32 = *(_OWORD *)(v20 - 60);
      long long v33 = *(_OWORD *)(v20 - 44);
      long long v34 = *(_OWORD *)(v20 - 28);
      *((_OWORD *)v28 - 1) = *((_OWORD *)v20 - 1);
      *(_OWORD *)(v28 - 28) = v34;
      *(_OWORD *)(v28 - 44) = v33;
      *(_OWORD *)(v28 - 60) = v32;
      v28 -= 92;
      v20 -= 92;
    }
    while (v20 != v19);
    uint64_t v20 = (char *)*v80;
  }
  *float v30 = v28;
  v30[1] = v29;
  v30[2] = v79;
  if (v20) {
    operator delete(v20);
  }
LABEL_28:
  if (v12 != v13)
  {
    uint64_t v36 = 0;
    if (v11) {
      uint64_t v37 = -1;
    }
    else {
      uint64_t v37 = 1;
    }
    unsigned int v38 = v13 - v12;
    uint64_t v39 = 16 * v13;
    do
    {
      uint64_t v53 = *(void *)(v9 + 880);
      if (*(unsigned char *)(v53 + v39))
      {
        uint64_t v54 = *(float **)(v53 + v39 + 8);
        char v55 = (float *)*v80;
        uint64_t v56 = (uint64_t)*v80 + 92 * v36;
        uint64_t v57 = *(void *)v54;
        uint64_t v58 = *(void *)(*(void *)v54 + 96);
        float v59 = (float)(*(float *)(*(void *)v54 + 104) * v54[20]) / *(float *)(*(void *)v54 + 48);
        *(float *)(v56 + 88) = *(float *)(v9 + 756) / v59;
        v60 = (_DWORD *)(*(uint64_t (**)(void))(**(void **)(v58 + 32) + 32))(*(void *)(v58 + 32));
        *(_DWORD *)(v56 + 48) = *v60;
        *(_DWORD *)(v56 + 52) = v60[1];
        *(_DWORD *)(v56 + 56) = v60[2];
        *(_DWORD *)(v56 + 60) = v60[3];
        float v61 = *(float *)(v57 + 64);
        v62.i32[0] = *(_DWORD *)(v57 + 68);
        *(float *)&double v63 = v61 + (float)*(unsigned int *)(v57 + 72);
        *(float *)v64.i32 = *(float *)v62.i32 + (float)*(unsigned int *)(v57 + 76);
        *(float *)uint64_t v56 = v61;
        *(_DWORD *)(v56 + 4) = v62.i32[0];
        *(_DWORD *)(v56 + 8) = 0;
        *(_DWORD *)(v56 + 12) = LODWORD(v63);
        *(_DWORD *)(v56 + 16) = v62.i32[0];
        *(_DWORD *)(v56 + 20) = 0;
        *(_DWORD *)(v56 + 24) = LODWORD(v63);
        *(_DWORD *)(v56 + 28) = v64.i32[0];
        *(_DWORD *)(v56 + 32) = 0;
        *(float *)(v56 + 36) = v61;
        *(_DWORD *)(v56 + 40) = v64.i32[0];
        *(_DWORD *)(v56 + 44) = 0;
        *(float *)&double v65 = v59;
        md::TextLabelPart::prepareGlyphVertices(v9, (uint64_t)v54, v56, v65, v62, v63, v64, v66, v67, v68, v69);
        if (*(unsigned char *)(v9 + 565))
        {
          v70 = &v55[23 * v36];
          v71 = v70 + 16;
          if (*(unsigned char *)(v9 + 869))
          {
            float v72 = v54[13];
            float *v71 = v72;
            float v73 = v54[14];
            uint64_t v74 = &v55[23 * v36];
            v74[17] = v73;
            float v75 = v54[15];
            v74[18] = v75;
            float v77 = v54[17];
            float v76 = v54[18];
            float v78 = v54[16];
            float v49 = -(float)((float)(v76 * v73) - (float)(v77 * v75));
            float v50 = -(float)((float)(v78 * v75) - (float)(v76 * v72));
            float v51 = -(float)((float)(v77 * v72) - (float)(v78 * v73));
          }
          else
          {
            float v40 = -v54[16];
            _D2 = vmul_n_f32(*(float32x2_t *)(v54 + 13), v54[17]);
            *(float32x2_t *)v71 = _D2;
            v55[23 * v36 + 18] = v40;
            _S0 = _D2.i32[1];
            __asm { FMLA            S1, S0, V2.S[1] }
            float v48 = 1.0 / sqrtf(_S1);
            float v49 = -(float)(_D2.f32[1] * v48);
            float v50 = v48 * _D2.f32[0];
            float v51 = 0.0;
          }
          v70[19] = v49;
          uint64_t v52 = &v55[23 * v36];
          v52[20] = v50;
          v52[21] = v51;
        }
        ++v36;
      }
      v39 += 16 * v37;
      v38 += v37;
    }
    while (v38);
  }
}

uint64_t ta2::TextureAtlasRegion::uvRect(ta2::TextureAtlasRegion *this)
{
  return (uint64_t)this + 48;
}

float md::TextLabelPart::prepareGlyphVertices(uint64_t a1, uint64_t a2, uint64_t a3, double a4, int8x16_t a5, double a6, int32x4_t a7, int32x4_t a8, double a9, int32x4_t a10, int8x16_t a11)
{
  int v12 = *(unsigned __int8 *)(a1 + 565);
  if (*(unsigned char *)(a1 + 565))
  {
    if (*(unsigned char *)(a1 + 869))
    {
      a5.i32[0] = *(_DWORD *)(a2 + 60);
      a11.i32[0] = *(_DWORD *)(a2 + 72);
      v13.i64[0] = *(void *)a3;
      a10.i32[0] = *(_DWORD *)(a3 + 8);
      a7.i64[0] = *(void *)(a3 + 12);
      a8.i32[0] = *(_DWORD *)(a3 + 20);
      *(int32x2_t *)v14.f32 = vrev64_s32(*(int32x2_t *)a3);
      v14.i64[1] = __PAIR64__(a7.u32[0], a7.u32[1]);
      float v15 = *(float *)(a3 + 44);
      v11.i64[0] = *(void *)(a2 + 64);
      float32x2_t v16 = *(float32x2_t *)(a2 + 52);
      float32x2_t v17 = (float32x2_t)vrev64_s32((int32x2_t)v16);
      int32x4_t v18 = (int32x4_t)a5;
      v18.i32[1] = a11.i32[0];
      float32x2_t v19 = vmul_f32(*(float32x2_t *)v11.i8, v17);
      float32x2_t v20 = vsub_f32(v19, (float32x2_t)vdup_lane_s32((int32x2_t)v19, 1));
      int32x4_t v21 = vuzp2q_s32(v11, vzip1q_s32(v11, v11));
      float32x4_t v22 = (float32x4_t)v21;
      v22.i32[1] = a11.i32[0];
      int8x16_t v23 = vextq_s8(a11, a11, 4uLL);
      float32x2_t v24 = *(float32x2_t *)(a3 + 36);
      float v25 = vmlas_n_f32(vmul_lane_f32(v20, v24, 1).f32[0], *(float *)a5.i32, v24.f32[0])
          + (float)(v15 * *(float *)a11.i32);
      a11.i32[1] = a5.i32[0];
      *(float32x2_t *)a11.i8 = vmla_f32(vneg_f32(vmul_f32((float32x2_t)vzip1_s32((int32x2_t)v17, *(int32x2_t *)v11.i8), *(float32x2_t *)a11.i8)), (float32x2_t)__PAIR64__(v17.u32[1], v11.u32[1]), *(float32x2_t *)v18.i8);
      v13.i64[1] = a7.i64[0];
      a10.i32[1] = a8.i32[0];
      v18.i64[0] = *(void *)(a3 + 24);
      v18.i32[2] = v18.i32[1];
      int8x16_t v26 = (int8x16_t)vzip1q_s32(v18, a7);
      *(int32x2_t *)a7.i8 = vdup_lane_s32(*(int32x2_t *)a7.i8, 1);
      a8.i32[1] = *(_DWORD *)(a3 + 32);
      float32x4_t v27 = (float32x4_t)vtrn1q_s32(a7, v18);
      *(float *)a3 = vmlas_n_f32(vmla_lane_f32(vmul_f32(*(float32x2_t *)a3, v16), *(float32x2_t *)a11.i8, *(float32x2_t *)a3, 1).f32[0], *(float *)a10.i32, *(float *)v11.i32)* *(float *)&a4;
      float32x4_t v28 = (float32x4_t)vuzp2q_s32((int32x4_t)a11, vzip1q_s32((int32x4_t)a11, (int32x4_t)a11));
      v28.i32[1] = a5.i32[0];
      v28.i32[3] = v16.i32[1];
      float32x4_t v29 = vmulq_f32(v14, v28);
      v22.i32[3] = v21.i32[0];
      float32x4_t v30 = (float32x4_t)vextq_s8((int8x16_t)v28, vextq_s8((int8x16_t)v28, (int8x16_t)v28, 8uLL), 0xCuLL);
      float32x4_t v31 = (float32x4_t)vextq_s8(v26, v26, 4uLL);
      v31.i32[2] = v31.i32[1];
      v27.i32[2] = v27.i32[1];
      v30.i32[1] = v20.i32[0];
      v30.i32[2] = v16.i32[0];
      float32x4_t v32 = vmulq_n_f32(vmlaq_f32(vmlaq_f32(v29, v30, v13), v22, (float32x4_t)vzip1q_s32(a10, a10)), *(float *)&a4);
      float32x4_t v33 = (float32x4_t)vextq_s8(vextq_s8(a5, a5, 4uLL), a11, 0xCuLL);
      v33.i32[3] = v33.i32[0];
      *(int32x2_t *)v13.f32 = vzip1_s32((int32x2_t)v20, (int32x2_t)v16);
      v30.i64[0] = v13.i64[0];
      v30.i64[1] = __PAIR64__(v13.u32[0], vdup_lane_s32((int32x2_t)v16, 1).u32[0]);
      *(float32x4_t *)(a3 + 4) = v32;
      float32x4_t v34 = (float32x4_t)vextq_s8(v23, (int8x16_t)v11, 0xCuLL);
      v34.i32[3] = v34.i32[0];
      v16.i32[1] = a11.i32[1];
      *(float32x4_t *)(a3 + 20) = vmulq_n_f32(vmlaq_f32(vmlaq_f32(vmulq_f32(v31, v33), v30, v27), v34, (float32x4_t)vzip1q_s32(a8, vdupq_lane_s32(*(int32x2_t *)a8.i8, 1))), *(float *)&a4);
      a11.i32[1] = v17.i32[0];
      *(float32x2_t *)(a3 + 36) = vmul_f32(vmla_n_f32(vmla_f32(vmul_f32((float32x2_t)vrev64_s32((int32x2_t)v24), *(float32x2_t *)a11.i8), v16, v24), *(float32x2_t *)v11.i8, v15), (float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)&a4, 0));
      *(float *)(a3 + 44) = v25 * *(float *)&a4;
    }
    else
    {
      float v35 = *(float *)(a2 + 64);
      if (v35 == 0.0)
      {
        float v38 = *(float *)(a3 + 8);
        float v40 = *(float *)(a3 + 20);
        float v42 = *(float *)(a3 + 32);
        float v44 = *(float *)(a3 + 44);
      }
      else
      {
        float v36 = *(float *)(a2 + 68);
        float v37 = *(float *)a3 * v36;
        *(float *)a3 = v37;
        float v38 = -(float)(v35 * v37);
        float v39 = *(float *)(a3 + 12) * v36;
        *(float *)(a3 + 8) = v38;
        *(float *)(a3 + 12) = v39;
        float v40 = -(float)(v35 * v39);
        float v41 = *(float *)(a3 + 24) * v36;
        *(float *)(a3 + 20) = v40;
        *(float *)(a3 + 24) = v41;
        float v42 = -(float)(v35 * v41);
        float v43 = *(float *)(a3 + 36) * v36;
        *(float *)(a3 + 32) = v42;
        *(float *)(a3 + 36) = v43;
        float v44 = -(float)(v35 * v43);
        *(float *)(a3 + 44) = v44;
      }
      float v45 = *(float *)(a2 + 76);
      *(float *)(a3 + 8) = v38 + v45;
      *(float *)(a3 + 20) = v40 + v45;
      *(float *)(a3 + 32) = v42 + v45;
      *(float *)(a3 + 44) = v44 + v45;
    }
  }
  float v46 = *(float *)a3;
  if (*(unsigned char *)(a1 + 869))
  {
    float v47 = *(float *)(a3 + 4);
    float v49 = *(float *)(a3 + 12);
    float v48 = *(float *)(a3 + 16);
    float v51 = *(float *)(a3 + 24);
    float v50 = *(float *)(a3 + 28);
    float v53 = *(float *)(a3 + 36);
    float v52 = *(float *)(a3 + 40);
  }
  else
  {
    float v54 = *(float *)(a2 + 52) * *(float *)&a4;
    float v55 = *(float *)(a2 + 56) * *(float *)&a4;
    float v56 = v46 * v55;
    float v57 = *(float *)(a3 + 4);
    float v46 = -(float)((float)(v57 * v55) - (float)(v46 * v54));
    float v47 = v56 + (float)(v57 * v54);
    *(float *)a3 = v46;
    *(float *)(a3 + 4) = v47;
    float v58 = *(float *)(a3 + 12);
    float v59 = *(float *)(a3 + 16);
    float v49 = -(float)((float)(v59 * v55) - (float)(v58 * v54));
    float v48 = (float)(v58 * v55) + (float)(v59 * v54);
    *(float *)(a3 + 12) = v49;
    *(float *)(a3 + 16) = v48;
    float v60 = *(float *)(a3 + 24);
    float v61 = *(float *)(a3 + 28);
    float v51 = -(float)((float)(v61 * v55) - (float)(v60 * v54));
    float v50 = (float)(v60 * v55) + (float)(v61 * v54);
    *(float *)(a3 + 24) = v51;
    *(float *)(a3 + 28) = v50;
    float v62 = *(float *)(a3 + 36);
    float v63 = *(float *)(a3 + 40);
    float v64 = v62 * v55;
    float v53 = -(float)((float)(v63 * v55) - (float)(v62 * v54));
    float v52 = v64 + (float)(v63 * v54);
    *(float *)(a3 + 36) = v53;
    *(float *)(a3 + 40) = v52;
  }
  float v65 = *(float *)(a2 + 40);
  float v66 = *(float *)(a2 + 44);
  float v67 = *(float *)(a2 + 48);
  float v68 = v46 + v65;
  float result = v47 + v66;
  *(float *)a3 = v68;
  *(float *)(a3 + 4) = result;
  float v70 = v49 + v65;
  *(float *)(a3 + 8) = *(float *)(a3 + 8) + v67;
  *(float *)(a3 + 12) = v70;
  float v71 = v48 + v66;
  float v72 = *(float *)(a3 + 20) + v67;
  *(float *)(a3 + 16) = v71;
  *(float *)(a3 + 20) = v72;
  float v73 = v51 + v65;
  float v74 = v50 + v66;
  *(float *)(a3 + 24) = v73;
  *(float *)(a3 + 28) = v74;
  float v75 = v53 + v65;
  *(float *)(a3 + 32) = *(float *)(a3 + 32) + v67;
  *(float *)(a3 + 36) = v75;
  float v76 = v52 + v66;
  float v77 = *(float *)(a3 + 44) + v67;
  *(float *)(a3 + 40) = v76;
  *(float *)(a3 + 44) = v77;
  if (!v12)
  {
    float v78 = *(float *)(*(void *)(a1 + 32) + 68);
    float v79 = 1.1;
    if (!*(unsigned char *)(a1 + 830)) {
      float v79 = 1.0;
    }
    float v80 = (float)(*(float *)(a1 + 912) * v79) * v78;
    if (fabsf(v80 + -1.0) > 0.000001)
    {
      float v68 = v68 * v80;
      float result = result * v80;
      *(float *)a3 = v68;
      *(float *)(a3 + 4) = result;
      float v70 = v70 * v80;
      float v71 = v71 * v80;
      *(float *)(a3 + 12) = v70;
      *(float *)(a3 + 16) = v71;
      float v73 = v73 * v80;
      float v74 = v74 * v80;
      *(float *)(a3 + 24) = v73;
      *(float *)(a3 + 28) = v74;
      float v75 = v75 * v80;
      float v76 = v76 * v80;
      *(float *)(a3 + 36) = v75;
      *(float *)(a3 + 40) = v76;
    }
    if (*(unsigned char *)(a1 + 508))
    {
      float v81 = *(float *)(a1 + 328);
      float v82 = *(float *)(a1 + 332);
      float v83 = v82 * v68;
      float v68 = -(float)((float)(result * v82) - (float)(v81 * v68));
      float result = v83 + (float)(result * v81);
      *(float *)a3 = v68;
      *(float *)(a3 + 4) = result;
      float v84 = *(float *)(a1 + 328);
      float v85 = *(float *)(a1 + 332);
      float v86 = v85 * v70;
      float v70 = -(float)((float)(v71 * v85) - (float)(v84 * v70));
      float v71 = v86 + (float)(v71 * v84);
      *(float *)(a3 + 12) = v70;
      *(float *)(a3 + 16) = v71;
      float v87 = *(float *)(a1 + 328);
      float v88 = *(float *)(a1 + 332);
      float v89 = v88 * v73;
      float v73 = -(float)((float)(v74 * v88) - (float)(v87 * v73));
      float v74 = v89 + (float)(v74 * v87);
      *(float *)(a3 + 24) = v73;
      *(float *)(a3 + 28) = v74;
      float v90 = *(float *)(a1 + 328);
      float v91 = *(float *)(a1 + 332);
      float v92 = v91 * v75;
      float v75 = -(float)((float)(v76 * v91) - (float)(v90 * v75));
      float v76 = v92 + (float)(v76 * v90);
      *(float *)(a3 + 36) = v75;
      *(float *)(a3 + 40) = v76;
    }
    float v93 = *(float *)(a1 + 832) + (float)(*(float *)(a1 + 544) * v78);
    float v94 = *(float *)(a1 + 836) + (float)(*(float *)(a1 + 548) * v78);
    *(float *)a3 = v93 + v68;
    *(float *)(a3 + 4) = v94 + result;
    *(float *)(a3 + 12) = v93 + v70;
    *(float *)(a3 + 16) = v94 + v71;
    *(float *)(a3 + 24) = v93 + v73;
    *(float *)(a3 + 28) = v94 + v74;
    float result = v93 + v75;
    *(float *)(a3 + 36) = v93 + v75;
    *(float *)(a3 + 40) = v94 + v76;
  }
  return result;
}

uint64_t md::TextLabelPart::modelMatrix(md::TextLabelPart *this)
{
  return *((void *)this + 105);
}

void std::vector<md::ShadowMeshQuad>::__append(char **a1, unint64_t a2)
{
  int v5 = a1[1];
  int v4 = a1[2];
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - v5) >> 3) >= a2)
  {
    if (a2)
    {
      size_t v12 = 56 * ((56 * a2 - 56) / 0x38) + 56;
      bzero(a1[1], v12);
      v5 += v12;
    }
    a1[1] = v5;
  }
  else
  {
    float v6 = *a1;
    uint64_t v7 = 0x6DB6DB6DB6DB6DB7 * ((v5 - *a1) >> 3);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x492492492492492) {
      abort();
    }
    unint64_t v9 = 0x6DB6DB6DB6DB6DB7 * ((v4 - v6) >> 3);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x249249249249249) {
      unint64_t v10 = 0x492492492492492;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x492492492492492) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int32x4_t v11 = (char *)operator new(56 * v10);
    }
    else
    {
      int32x4_t v11 = 0;
    }
    float32x4_t v13 = &v11[56 * v7];
    float32x4_t v14 = &v11[56 * v10];
    size_t v15 = 56 * ((56 * a2 - 56) / 0x38) + 56;
    bzero(v13, v15);
    float32x2_t v16 = &v13[v15];
    if (v5 != v6)
    {
      do
      {
        long long v17 = *(_OWORD *)(v5 - 56);
        long long v18 = *(_OWORD *)(v5 - 40);
        long long v19 = *(_OWORD *)(v5 - 24);
        *((void *)v13 - 1) = *((void *)v5 - 1);
        *(_OWORD *)(v13 - 24) = v19;
        *(_OWORD *)(v13 - 40) = v18;
        *(_OWORD *)(v13 - 56) = v17;
        v13 -= 56;
        v5 -= 56;
      }
      while (v5 != v6);
      int v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v16;
    a1[2] = v14;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void grl::codec::IconConfigPack::iconForKey(grl::codec::IconConfigPack *this@<X0>, const grl::IconKey *a2@<X1>, grl::IconKey *a3@<X2>, void *a4@<X8>)
{
  unint64_t v8 = (char *)a2 + 8;
  long long v33 = *(_OWORD *)((char *)a2 + 8);
  LOBYTE(v43) = *((unsigned char *)a2 + 24);
  *(_DWORD *)((char *)&v43 + 2) = HIDWORD(v33);
  grl::codec::IconConfigPack::decodeIconDataIfNeeded(&v34, (uint64_t)this, (unsigned __int8 *)&v43);
  uint64_t v9 = v34;
  if (!v34
    || (unint64_t v10 = std::__tree<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,std::__map_value_compare<grl::IconKey,std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,std::less<grl::IconKey>,true>,geo::StdAllocator<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>::find<grl::IconKey>(v34, (uint64_t)a2), (void *)(v9 + 8) == v10))
  {
    float v43 = &unk_1EF5672F0;
    long long v44 = *(_OWORD *)v8;
    char v45 = v8[16];
    char v13 = v45;
    if (v45)
    {
      while (1)
      {
        char v45 = v13 - 1;
        unint64_t v14 = (WORD6(v44)
             - 0x61C8864680B583EBLL
             + ((DWORD2(v44) - 0x61C8864680B583EBLL) << 6)
             + (((unint64_t)DWORD2(v44) - 0x61C8864680B583EBLL) >> 2)) ^ (DWORD2(v44) - 0x61C8864680B583EBLL);
        unint64_t v15 = (HIWORD(v44) - 0x61C8864680B583EBLL + (v14 << 6) + (v14 >> 2)) ^ v14;
        *(void *)&long long v44 = ((v13 - 1) - 0x61C8864680B583EBLL + (v15 << 6) + (v15 >> 2)) ^ v15;
        float v36 = &unk_1EF5672F0;
        char v38 = v13 - 1;
        long long v37 = v44;
        v39[0] = v13 - 1;
        int v40 = HIDWORD(v44);
        grl::codec::IconConfigPack::decodeIconDataIfNeeded(&v41, (uint64_t)this, v39);
        uint64_t v16 = v41;
        if (v41)
        {
          long long v17 = std::__tree<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,std::__map_value_compare<grl::IconKey,std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,std::less<grl::IconKey>,true>,geo::StdAllocator<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>::find<grl::IconKey>(v41, (uint64_t)&v43);
          if ((void *)(v16 + 8) != v17) {
            break;
          }
        }
        if (v42) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v42);
        }
        char v13 = v45;
        if (!v45) {
          goto LABEL_13;
        }
      }
      if (a3)
      {
        long long v31 = *(_OWORD *)v8;
        *((unsigned char *)a3 + 24) = v8[16];
        *(_OWORD *)((char *)a3 + 8) = v31;
      }
      uint64_t v32 = v17[8];
      long long v18 = (std::__shared_weak_count *)v17[9];
      if (v18) {
        atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v42) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v42);
      }
      if (v32)
      {
        *a4 = v32;
        a4[1] = v18;
        goto LABEL_36;
      }
    }
    else
    {
LABEL_13:
      long long v18 = 0;
    }
    if (*((_WORD *)a2 + 11))
    {
      uint64_t v19 = *((unsigned __int16 *)a2 + 10);
      uint64_t v20 = *((unsigned __int8 *)a2 + 24);
      DWORD2(v44) = *((_DWORD *)a2 + 4);
      HIDWORD(v44) = (unsigned __int16)v19;
      char v45 = v20;
      unint64_t v21 = (v19
           - 0x61C8864680B583EBLL
           + ((DWORD2(v44) - 0x61C8864680B583EBLL) << 6)
           + (((unint64_t)DWORD2(v44) - 0x61C8864680B583EBLL) >> 2)) ^ (DWORD2(v44) - 0x61C8864680B583EBLL);
      unint64_t v22 = ((v21 << 6) - 0x61C8864680B583EBLL + (v21 >> 2)) ^ v21;
      float v43 = &unk_1EF5672F0;
      *(void *)&long long v44 = (v20 - 0x61C8864680B583EBLL + (v22 << 6) + (v22 >> 2)) ^ v22;
      grl::codec::IconConfigPack::iconForKey((uint64_t *)&v36, this, (const grl::IconKey *)&v43, a3);
      float32x2_t v24 = v36;
      int8x16_t v23 = (std::__shared_weak_count *)v37;
      if (v18) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v18);
      }
      if (v24)
      {
        *a4 = v24;
        a4[1] = v23;
        goto LABEL_36;
      }
    }
    else
    {
      int8x16_t v23 = v18;
    }
    if (*((_WORD *)a2 + 10))
    {
      uint64_t v25 = *((unsigned __int16 *)a2 + 11);
      uint64_t v26 = *((unsigned __int8 *)a2 + 24);
      DWORD2(v44) = *((_DWORD *)a2 + 4);
      WORD6(v44) = 0;
      HIWORD(v44) = v25;
      char v45 = v26;
      unint64_t v27 = DWORD2(v44) - 0x61C8864680B583EBLL;
      unint64_t v28 = (v25
           - 0x61C8864680B583EBLL
           + ((((v27 << 6) - 0x61C8864680B583EBLL + (v27 >> 2)) ^ v27) << 6)
           + ((((v27 << 6) - 0x61C8864680B583EBLL + (v27 >> 2)) ^ v27) >> 2)) ^ ((v27 << 6)
                                                                               - 0x61C8864680B583EBLL
                                                                               + (v27 >> 2)) ^ v27;
      float v43 = &unk_1EF5672F0;
      *(void *)&long long v44 = (v26 - 0x61C8864680B583EBLL + (v28 << 6) + (v28 >> 2)) ^ v28;
      grl::codec::IconConfigPack::iconForKey((uint64_t *)&v36, this, (const grl::IconKey *)&v43, a3);
      float32x4_t v30 = v36;
      float32x4_t v29 = (std::__shared_weak_count *)v37;
      if (v23) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v23);
      }
      if (v30)
      {
        *a4 = v30;
        a4[1] = v29;
        goto LABEL_36;
      }
    }
    else
    {
      float32x4_t v29 = v23;
    }
    *a4 = 0;
    a4[1] = 0;
    if (v29) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v29);
    }
  }
  else
  {
    if (a3)
    {
      long long v11 = *(_OWORD *)v8;
      *((unsigned char *)a3 + 24) = v8[16];
      *(_OWORD *)((char *)a3 + 8) = v11;
    }
    uint64_t v12 = v10[9];
    *a4 = v10[8];
    a4[1] = v12;
    if (v12) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v12 + 8), 1uLL, memory_order_relaxed);
    }
  }
LABEL_36:
  if (v35) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v35);
  }
}

void grl::codec::IconConfigPack::decodeIconDataIfNeeded(void *a1, uint64_t a2, unsigned __int8 *a3)
{
  float v6 = (std::mutex *)(a2 + 232);
  std::mutex::lock((std::mutex *)(a2 + 232));
  uint64_t v7 = geo::LRUPolicy<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>,grl::codec::IconConfigPack::IconLocationIndexHash>::get(a2 + 120, (void *)(a2 + 80), a3);
  if (a2 + 120 != v7)
  {
    atomic_fetch_add((atomic_uint *volatile)(a2 + 144), 1u);
    uint64_t v8 = *(void *)(v7 + 32);
    *a1 = *(void *)(v7 + 24);
    a1[1] = v8;
    if (v8) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
    }
    goto LABEL_52;
  }
  uint64_t v9 = a2 + 72;
  atomic_fetch_add((atomic_uint *volatile)(a2 + 148), 1u);
  *a1 = 0;
  a1[1] = 0;
  uint64_t v10 = *(void *)(a2 + 48);
  if (!v10) {
    goto LABEL_49;
  }
  unsigned int v11 = *a3;
  unsigned int v12 = *((unsigned __int16 *)a3 + 2);
  uint64_t v13 = a2 + 48;
  unsigned int v14 = *((unsigned __int16 *)a3 + 1);
  do
  {
    unsigned int v15 = *(unsigned __int8 *)(v10 + 28);
    BOOL v16 = v15 >= v11;
    if (v15 == v11)
    {
      unsigned int v17 = *(unsigned __int16 *)(v10 + 32);
      BOOL v16 = v17 >= v12;
      if (v17 == v12) {
        BOOL v16 = *(unsigned __int16 *)(v10 + 30) >= v14;
      }
    }
    int v18 = !v16;
    BOOL v19 = v18 == 0;
    if (v18) {
      uint64_t v20 = (uint64_t *)(v10 + 8);
    }
    else {
      uint64_t v20 = (uint64_t *)v10;
    }
    if (v19) {
      uint64_t v13 = v10;
    }
    uint64_t v10 = *v20;
  }
  while (*v20);
  if (a2 + 48 == v13) {
    goto LABEL_49;
  }
  unsigned int v21 = *(unsigned __int8 *)(v13 + 28);
  BOOL v22 = v11 >= v21;
  if (v11 == v21)
  {
    unsigned int v23 = *(unsigned __int16 *)(v13 + 32);
    BOOL v22 = v12 >= v23;
    if (v12 == v23) {
      BOOL v22 = v14 >= *(unsigned __int16 *)(v13 + 30);
    }
  }
  if (!v22)
  {
LABEL_49:
    float v36 = (void *)geo::Cache<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>,grl::codec::IconConfigPack::IconLocationIndexHash,geo::LRUPolicy>::operator[](v9, a3);
    float v35 = 0;
    uint64_t v34 = 0;
    goto LABEL_50;
  }
  unint64_t v80 = 0;
  v81[0] = 0;
  float v78 = 0;
  long long v79 = 0uLL;
  float32x2_t v24 = *(std::__shared_weak_count **)(a2 + 176);
  v77[0] = *(void *)(a2 + 168);
  v77[1] = (uint64_t)v24;
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float v73 = (const unsigned __int8 *)(*(void *)(a2 + 184) + *(unsigned int *)(v13 + 36) + 16);
  BOOL v25 = grl::codec::ResourcePack::decodeChapterSize(a2, v77, (uint64_t)&v73, v81, &v80);
  if (v24) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v24);
  }
  if (!v25)
  {
    int v30 = 314;
    long long v31 = "decodeChapterSize(_packStream, _packStreamIconDataStart + locationIter->second + sizeSkip, rawSize, compressedSize)";
    uint64_t v32 = "Failed to read Icon Data Chapter Size";
    goto LABEL_41;
  }
  uint64_t v26 = *(std::__shared_weak_count **)(a2 + 176);
  v76[0] = *(void *)(a2 + 168);
  v76[1] = (uint64_t)v26;
  if (v26) {
    atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  float v73 = (const unsigned __int8 *)(*(void *)(a2 + 184) + *(unsigned int *)(v13 + 36) + 32);
  BOOL v27 = grl::codec::ResourcePack::decodePackChunk(a2, v76, (uint64_t)&v73, v80, (unint64_t *)&v78);
  if (v26) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v26);
  }
  if (!v27)
  {
    int v30 = 315;
    long long v31 = "decodePackChunk(_packStream, _packStreamIconDataStart + locationIter->second + (sizeSkip * 2), compressedSize, chapterData)";
    uint64_t v32 = "Failed to read compressed Icon Data Chapter";
    goto LABEL_41;
  }
  grl::codec::ResourcePack::decompressData((uint64_t)&v78, v81[0], (unint64_t *)&v73);
  if (v78)
  {
    *(void *)&long long v79 = v78;
    operator delete(v78);
  }
  unint64_t v28 = v73;
  float v78 = (unsigned __int8 *)v73;
  long long v79 = v74;
  unint64_t v29 = v74 - (void)v73;
  if ((void)v74 - (void)v73 <= 3uLL)
  {
    int v30 = 321;
    long long v31 = "numberOfIcons.has_value()";
    uint64_t v32 = "Number of Icons could not be read";
LABEL_41:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v32, v31, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconConfigPack.cpp", v30);
    char v33 = 0;
    goto LABEL_42;
  }
  unsigned int v39 = *(_DWORD *)v73;
  int v40 = (grl::Allocator *)operator new(0x38uLL);
  *((void *)v40 + 1) = 0;
  *((void *)v40 + 2) = 0;
  *(void *)int v40 = &unk_1EF58B1C0;
  *((void *)v40 + 4) = 0;
  *((void *)v40 + 5) = grl::Allocator::instance(v40);
  *((void *)v40 + 6) = 0;
  *((void *)v40 + 3) = (char *)v40 + 32;
  *a1 = (char *)v40 + 24;
  a1[1] = v40;
  unsigned int v69 = v39;
  if (!v39)
  {
    char v33 = 1;
    goto LABEL_42;
  }
  BOOL v41 = 0;
  unsigned int v42 = 0;
  unint64_t v43 = 4;
  float v68 = v28;
  unint64_t v66 = v29;
  do
  {
    unint64_t v44 = v43 + 4;
    if (v43 + 4 > v29)
    {
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Icon Key Size could not be read", "iconKeySize.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconConfigPack.cpp", 325);
      char v33 = v41;
      break;
    }
    char v67 = v41;
    unint64_t v45 = *(unsigned int *)&v28[v43];
    float v73 = (const unsigned __int8 *)&unk_1EF5672F0;
    long long v74 = 0uLL;
    unsigned __int8 v75 = 4;
    char v46 = grl::IconKey::decode((grl::IconKey *)&v73, &v28[v44], v45, *(unsigned __int16 *)(a2 + 192));
    unint64_t v47 = v44 + v45;
    if (v44 + v45 >= v29) {
      unint64_t v47 = v29;
    }
    unint64_t v48 = v47 + 4;
    if (v47 + 4 > v29)
    {
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Icon Data Size could not be read", "iconDataSize.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconConfigPack.cpp", 332);
      char v33 = v67;
      break;
    }
    unint64_t v49 = *(unsigned int *)&v28[v47];
    if ((v46 & 1) == 0) {
      goto LABEL_89;
    }
    unsigned int v70 = v42;
    unint64_t v71 = v49;
    unint64_t v72 = v48;
    float v50 = (char *)operator new(0x100uLL);
    *((void *)v50 + 1) = 0;
    *((void *)v50 + 2) = 0;
    *(void *)float v50 = &unk_1EF58A3C0;
    *(_OWORD *)(v50 + 24) = 0u;
    *(_OWORD *)(v50 + 40) = 0u;
    *(_OWORD *)(v50 + 56) = 0u;
    *(_OWORD *)(v50 + 72) = 0u;
    *(_OWORD *)(v50 + 88) = 0u;
    *(_OWORD *)(v50 + 104) = 0u;
    *(_OWORD *)(v50 + 136) = 0u;
    *(_OWORD *)(v50 + 168) = 0u;
    *(_OWORD *)(v50 + 200) = 0u;
    *(_OWORD *)(v50 + 216) = 0u;
    *(_OWORD *)(v50 + 232) = 0u;
    *((void *)v50 + 31) = 0;
    *(_OWORD *)(v50 + 184) = 0u;
    *(_OWORD *)(v50 + 152) = 0u;
    *(_OWORD *)(v50 + 120) = 0u;
    float v51 = (grl::Allocator *)grl::Allocator::instance((grl::Allocator *)v50);
    *((void *)v50 + 5) = v51;
    *((void *)v50 + 6) = 0;
    *((void *)v50 + 3) = v50 + 32;
    v50[56] = 0;
    *((void *)v50 + 15) = 0;
    float v52 = (grl::Allocator *)grl::Allocator::instance(v51);
    *((void *)v50 + 16) = v52;
    *((void *)v50 + 17) = 0;
    *((void *)v50 + 14) = v50 + 120;
    *((void *)v50 + 19) = 0;
    float v53 = (grl::Allocator *)grl::Allocator::instance(v52);
    *((void *)v50 + 20) = v53;
    *((void *)v50 + 21) = 0;
    *((void *)v50 + 18) = v50 + 152;
    *((void *)v50 + 23) = 0;
    *((void *)v50 + 24) = grl::Allocator::instance(v53);
    *((void *)v50 + 25) = 0;
    *((void *)v50 + 22) = v50 + 184;
    v50[208] = 0;
    if (!grl::codec::IconData::decode((uint64_t **)v50 + 3, &v68[v72], v71, a2 + 200))
    {
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Icon Data could not be decoded", "iconData->decode(stream.currentByte(), iconDataSize.value(), context.propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconConfigPack.cpp", 337);
      std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v50);
      char v33 = v67;
      uint64_t v9 = a2 + 72;
      break;
    }
    float v54 = (uint64_t **)*a1;
    float v56 = (uint64_t **)(*a1 + 8);
    float v55 = *v56;
    if (!*v56)
    {
      uint64_t v57 = *a1 + 8;
      goto LABEL_83;
    }
    do
    {
      while (1)
      {
        uint64_t v57 = (uint64_t)v55;
        unsigned int v58 = *((_DWORD *)v55 + 12);
        if (DWORD2(v74) != v58) {
          break;
        }
        unsigned int v59 = *(unsigned __int16 *)(v57 + 52);
        if (WORD6(v74) != v59)
        {
          if (WORD6(v74) < v59) {
            goto LABEL_77;
          }
          if (v59 >= WORD6(v74)) {
            goto LABEL_86;
          }
          goto LABEL_80;
        }
        unsigned int v60 = *(unsigned __int16 *)(v57 + 54);
        if (HIWORD(v74) != v60)
        {
          if (HIWORD(v74) < v60) {
            goto LABEL_77;
          }
          if (v60 >= HIWORD(v74)) {
            goto LABEL_86;
          }
          goto LABEL_80;
        }
        unsigned int v61 = *(unsigned __int8 *)(v57 + 56);
        if (v75 >= v61)
        {
          if (v61 >= v75) {
            goto LABEL_86;
          }
          goto LABEL_80;
        }
LABEL_77:
        float v55 = *(uint64_t **)v57;
        float v56 = (uint64_t **)v57;
        if (!*(void *)v57) {
          goto LABEL_83;
        }
      }
      if (DWORD2(v74) < v58) {
        goto LABEL_77;
      }
      if (v58 >= DWORD2(v74)) {
        goto LABEL_86;
      }
LABEL_80:
      float v55 = *(uint64_t **)(v57 + 8);
    }
    while (v55);
    float v56 = (uint64_t **)(v57 + 8);
LABEL_83:
    uint64_t v62 = v57;
    uint64_t v57 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v54[2] + 16))(v54[2], 80, 8);
    *(void *)(v57 + 32) = &unk_1EF5672F0;
    *(_OWORD *)(v57 + 40) = v74;
    *(unsigned char *)(v57 + 56) = v75;
    *(void *)(v57 + 64) = 0;
    *(void *)(v57 + 72) = 0;
    *(void *)uint64_t v57 = 0;
    *(void *)(v57 + 8) = 0;
    *(void *)(v57 + 16) = v62;
    uint64_t *v56 = (uint64_t *)v57;
    float v63 = (uint64_t *)**v54;
    float v64 = (uint64_t *)v57;
    if (v63)
    {
      *float v54 = v63;
      float v64 = *v56;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v54[1], v64);
    v54[3] = (uint64_t *)((char *)v54[3] + 1);
    unsigned int v42 = v70;
LABEL_86:
    atomic_fetch_add_explicit((atomic_ullong *volatile)v50 + 1, 1uLL, memory_order_relaxed);
    float v65 = *(std::__shared_weak_count **)(v57 + 72);
    *(void *)(v57 + 64) = v50 + 24;
    *(void *)(v57 + 72) = v50;
    unint64_t v28 = v68;
    if (v65) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v65);
    }
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v50);
    uint64_t v9 = a2 + 72;
    unint64_t v29 = v66;
    unint64_t v49 = v71;
    unint64_t v48 = v72;
LABEL_89:
    unint64_t v43 = v49 + v48;
    if (v43 >= v29) {
      unint64_t v43 = v29;
    }
    ++v42;
    char v33 = 1;
    BOOL v41 = v42 >= v69;
  }
  while (v42 != v69);
LABEL_42:
  if (v78)
  {
    *(void *)&long long v79 = v78;
    operator delete(v78);
  }
  if ((v33 & 1) == 0)
  {
    long long v37 = (std::__shared_weak_count *)a1[1];
    *a1 = 0;
    a1[1] = 0;
    if (v37) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v37);
    }
    goto LABEL_49;
  }
  float v35 = (uint64_t **)*a1;
  uint64_t v34 = a1[1];
  float v36 = (void *)geo::Cache<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>,grl::codec::IconConfigPack::IconLocationIndexHash,geo::LRUPolicy>::operator[](v9, a3);
  if (v34) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v34 + 8), 1uLL, memory_order_relaxed);
  }
LABEL_50:
  char v38 = (std::__shared_weak_count *)v36[1];
  void *v36 = v35;
  v36[1] = v34;
  if (v38) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v38);
  }
LABEL_52:
  std::mutex::unlock(v6);
}

uint64_t grl::IconKey::decode(grl::IconKey *this, const unsigned __int8 *a2, unint64_t a3, unsigned int a4)
{
  if (a3 < 4)
  {
    int v4 = 82;
    int v5 = "id.has_value()";
    float v6 = "ID could not be read";
LABEL_12:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v6, v5, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconKey.cpp", v4);
    return 0;
  }
  *((_DWORD *)this + 4) = *(_DWORD *)a2;
  if (a4 < 3)
  {
    __int16 v7 = 0;
    unint64_t v8 = 6;
  }
  else
  {
    if (a3 < 6)
    {
      int v4 = 87;
      int v5 = "dataVariant.has_value()";
      float v6 = "Data Variant could not be read";
      goto LABEL_12;
    }
    __int16 v7 = *((_WORD *)a2 + 2);
    unint64_t v8 = 8;
  }
  *((_WORD *)this + 10) = v7;
  if (v8 > a3)
  {
    int v4 = 94;
    int v5 = "variant.has_value()";
    float v6 = "Variant could not be read";
    goto LABEL_12;
  }
  *((_WORD *)this + 11) = *(_WORD *)&a2[v8 - 2];
  if ((v8 | 1) > a3)
  {
    int v4 = 98;
    int v5 = "sizeGroupRaw.has_value()";
    float v6 = "Size Group could not be read";
    goto LABEL_12;
  }
  unsigned int v10 = a2[v8];
  if (v10 <= 9)
  {
    *((unsigned char *)this + 24) = v10;
    return 1;
  }
  return 0;
}

uint64_t grl::codec::IconData::decode(uint64_t **a1, unsigned char *a2, unint64_t a3, uint64_t a4)
{
  if (!a3)
  {
    int v24 = 88;
    BOOL v25 = "imageCount.has_value()";
    uint64_t v26 = "Icon Image Count could not be read";
    goto LABEL_96;
  }
  unint64_t v4 = a3;
  int v5 = a2;
  float v6 = a1;
  unsigned int v70 = a2 - 4;
  unsigned int v68 = *a2;
  if (*a2)
  {
    unsigned int v7 = 0;
    char v67 = a1 + 1;
    uint64_t v8 = 1;
    while (v8 + 2 <= v4)
    {
      uint64_t v9 = v8 + 6;
      if (v8 + 6 > v4)
      {
        int v24 = 95;
        BOOL v25 = "imageID.has_value()";
        uint64_t v26 = "Image ID could not be read";
        goto LABEL_96;
      }
      if (v8 + 10 > v4)
      {
        int v24 = 97;
        BOOL v25 = "imageSizeX.has_value()";
        uint64_t v26 = "Image Size X could not be read";
        goto LABEL_96;
      }
      uint64_t v10 = v8 + 14;
      if (v8 + 14 > v4)
      {
        int v24 = 99;
        BOOL v25 = "imageSizeY.has_value()";
        uint64_t v26 = "Image Size Y could not be read";
        goto LABEL_96;
      }
      unsigned int v11 = v6;
      unsigned int v12 = *(unsigned __int16 *)&v5[v8];
      int v13 = *(_DWORD *)&v70[v9];
      unsigned int v14 = v67;
      uint64_t v15 = (uint64_t)v67;
      uint64_t v16 = *(void *)&v5[v9];
      uint64_t v17 = (uint64_t)*v67;
      if (*v67)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v15 = v17;
            unsigned int v18 = *(unsigned __int16 *)(v17 + 28);
            if (v18 <= v12) {
              break;
            }
            uint64_t v17 = *(void *)v15;
            unsigned int v14 = (uint64_t **)v15;
            if (!*(void *)v15) {
              goto LABEL_15;
            }
          }
          if (v18 >= v12) {
            break;
          }
          uint64_t v17 = *(void *)(v15 + 8);
          if (!v17)
          {
            unsigned int v14 = (uint64_t **)(v15 + 8);
            goto LABEL_15;
          }
        }
        float v6 = v11;
      }
      else
      {
LABEL_15:
        unint64_t v19 = v4;
        uint64_t v20 = v5;
        uint64_t v21 = v15;
        uint64_t v15 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v11[2] + 16))(v11[2], 48, 8);
        *(_WORD *)(v15 + 28) = v12;
        float v6 = v11;
        *(void *)(v15 + 32) = 0;
        *(_DWORD *)(v15 + 40) = 0;
        *(void *)uint64_t v15 = 0;
        *(void *)(v15 + 8) = 0;
        *(void *)(v15 + 16) = v21;
        *unsigned int v14 = (uint64_t *)v15;
        BOOL v22 = (uint64_t *)**v11;
        unsigned int v23 = (uint64_t *)v15;
        if (v22)
        {
          *unsigned int v11 = v22;
          unsigned int v23 = *v14;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v11[1], v23);
        v11[3] = (uint64_t *)((char *)v11[3] + 1);
        int v5 = v20;
        unint64_t v4 = v19;
      }
      *(_DWORD *)(v15 + 32) = v13;
      *(void *)(v15 + 36) = v16;
      ++v7;
      uint64_t v8 = v10;
      if (v7 >= v68) {
        goto LABEL_23;
      }
    }
    int v24 = 92;
    BOOL v25 = "imageLayerIndex.has_value()";
    uint64_t v26 = "Image Layer Index could not be read";
LABEL_96:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v26, v25, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp", v24);
    return 0;
  }
  uint64_t v10 = 1;
LABEL_23:
  uint64_t v27 = v10 + 1;
  if (v10 + 1 > v4)
  {
    int v24 = 107;
    BOOL v25 = "layerCount.has_value()";
    uint64_t v26 = "Icon Layer Count could not be read";
    goto LABEL_96;
  }
  unsigned int v69 = v5[v10];
  if (!v5[v10]) {
    return 1;
  }
  unsigned int v28 = 0;
  float v65 = v6 + 10;
  uint64_t v29 = a4;
  while (1)
  {
    if (v27 + 2 > v4)
    {
      int v62 = 111;
      float v63 = "layerTypeRaw.has_value()";
      float v64 = "Layer Type could not be read";
      goto LABEL_102;
    }
    grl::toEnum<grl::LayerType>(*(unsigned __int16 *)&v5[v27], (uint64_t)v81);
    uint64_t v30 = v27 + 4;
    if (v27 + 4 > v4)
    {
      int v62 = 115;
      float v63 = "layerIndex.has_value()";
      float v64 = "Layer Index could not be read";
      goto LABEL_102;
    }
    uint64_t v31 = v27 + 8;
    if (v27 + 8 > v4) {
      break;
    }
    size_t v32 = *(unsigned int *)&v70[v31];
    uint64_t v27 = v31 + v32;
    if (v31 + v32 <= v4)
    {
      unsigned int v34 = *(unsigned __int16 *)&v5[v30 - 2];
      long long v71 = 0uLL;
      unint64_t v72 = 0;
      if (v32)
      {
        std::vector<unsigned char>::__append((unint64_t *)&v71, v32);
        float v35 = (void *)v71;
      }
      else
      {
        float v35 = 0;
      }
      memcpy(v35, &v5[v31], v32);
      char v78 = 1;
      long long v79 = v71;
      unint64_t v80 = v72;
      if (!v81[0])
      {
        long long v37 = (void *)v71;
        int v33 = 19;
        if (!(void)v71) {
          goto LABEL_88;
        }
LABEL_86:
        *((void *)&v79 + 1) = v37;
        operator delete(v37);
        goto LABEL_88;
      }
      switch(v82)
      {
        case 0:
          grl::codec::ColorLayerData::ColorLayerData((grl::codec::ColorLayerData *)&v71);
          if (*((unsigned char *)v6 + 32))
          {
            std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__vdeallocate((uint64_t)(v6 + 5));
            uint64_t v36 = (uint64_t)(v6 + 5);
            *(_OWORD *)(v6 + 5) = v71;
            v6[7] = v72;
            unint64_t v72 = 0;
            long long v71 = 0uLL;
            *((unsigned char *)v6 + 72) = v74;
            *(_DWORD *)((char *)v6 + 73) = v75;
            *float v65 = v76;
            *((_WORD *)v6 + 42) = v77;
          }
          else
          {
            *(_OWORD *)(v6 + 5) = v71;
            unsigned int v60 = v73;
            v6[7] = v72;
            v6[8] = v60;
            long long v71 = 0uLL;
            unint64_t v72 = 0;
            *((unsigned char *)v6 + 72) = v74;
            *(_DWORD *)((char *)v6 + 73) = v75;
            *float v65 = v76;
            *((_WORD *)v6 + 42) = v77;
            *((unsigned char *)v6 + 32) = 1;
            uint64_t v36 = (uint64_t)(v6 + 5);
          }
          if (grl::codec::ColorLayerData::decode(v36, (uint64_t)&v79, v29)) {
            goto LABEL_80;
          }
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Color Layer could not be read", "_internalLayers.colorLayer->decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp", 134);
          goto LABEL_82;
        case 1:
          uint64_t v38 = (uint64_t)(v6 + 20);
          while (1)
          {
            uint64_t v39 = *(void *)v38;
            int v40 = (uint64_t **)v38;
            if (!*(void *)v38) {
              break;
            }
            while (1)
            {
              uint64_t v38 = v39;
              unsigned int v41 = *(unsigned __int16 *)(v39 + 32);
              if (v41 > v34) {
                break;
              }
              if (v41 >= v34) {
                goto LABEL_50;
              }
              uint64_t v39 = *(void *)(v38 + 8);
              if (!v39)
              {
                int v40 = (uint64_t **)(v38 + 8);
                goto LABEL_47;
              }
            }
          }
LABEL_47:
          uint64_t v42 = v38;
          uint64_t v38 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6[21] + 16))(v6[21], 176, 8);
          *(_WORD *)(v38 + 32) = v34;
          grl::codec::PathLayerData::PathLayerData((grl::codec::PathLayerData *)(v38 + 40));
          *(void *)uint64_t v38 = 0;
          *(void *)(v38 + 8) = 0;
          *(void *)(v38 + 16) = v42;
          *int v40 = (uint64_t *)v38;
          unint64_t v43 = (uint64_t *)*v6[19];
          unint64_t v44 = (uint64_t *)v38;
          if (v43)
          {
            v6[19] = v43;
            unint64_t v44 = *v40;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v6[20], v44);
          v6[22] = (uint64_t *)((char *)v6[22] + 1);
          uint64_t v29 = a4;
LABEL_50:
          if (grl::codec::PathLayerData::decode(v38 + 40, (uint64_t)&v79, v29)) {
            goto LABEL_80;
          }
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Path Layer could not be read", "_internalLayers.pathLayers[layerIndex.value()].decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp", 130);
          goto LABEL_82;
        case 2:
          uint64_t v45 = (uint64_t)(v6 + 16);
          while (1)
          {
            uint64_t v46 = *(void *)v45;
            unint64_t v47 = (uint64_t **)v45;
            if (!*(void *)v45) {
              break;
            }
            while (1)
            {
              uint64_t v45 = v46;
              unsigned int v48 = *(unsigned __int16 *)(v46 + 32);
              if (v48 > v34) {
                break;
              }
              if (v48 >= v34) {
                goto LABEL_61;
              }
              uint64_t v46 = *(void *)(v45 + 8);
              if (!v46)
              {
                unint64_t v47 = (uint64_t **)(v45 + 8);
                goto LABEL_58;
              }
            }
          }
LABEL_58:
          uint64_t v49 = v45;
          uint64_t v45 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6[17] + 16))(v6[17], 192, 8);
          *(_WORD *)(v45 + 32) = v34;
          grl::codec::ImageLayerData::ImageLayerData((grl::codec::ImageLayerData *)(v45 + 40));
          *(void *)uint64_t v45 = 0;
          *(void *)(v45 + 8) = 0;
          *(void *)(v45 + 16) = v49;
          char *v47 = (uint64_t *)v45;
          float v50 = (uint64_t *)*v6[15];
          float v51 = (uint64_t *)v45;
          if (v50)
          {
            v6[15] = v50;
            float v51 = *v47;
          }
          std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v6[16], v51);
          v6[18] = (uint64_t *)((char *)v6[18] + 1);
          uint64_t v29 = a4;
LABEL_61:
          if (grl::codec::ImageLayerData::decode(v45 + 40, (uint64_t)&v79, v29)) {
            goto LABEL_80;
          }
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Image Layer could not be read", "_internalLayers.imageLayers[layerIndex.value()].decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp", 137);
          goto LABEL_82;
        case 3:
          uint64_t v52 = (uint64_t)(v6 + 12);
          break;
        case 4:
          LODWORD(v71) = 0;
          BYTE4(v71) = -1;
          int v59 = *((unsigned __int8 *)v6 + 184);
          *(uint64_t **)((char *)v6 + 188) = (uint64_t *)0xFFFFFFFF00000000;
          *(uint64_t **)((char *)v6 + 196) = (uint64_t *)0xFF000000FF000000;
          *((unsigned char *)v6 + 204) = 0;
          *(_DWORD *)((char *)v6 + 205) = *(_DWORD *)((char *)&v71 + 1);
          *(uint64_t **)((char *)v6 + 209) = (uint64_t *)0xFF000000FF000000;
          *((_DWORD *)v6 + 55) = 1065353216;
          *((_WORD *)v6 + 112) = 0;
          if (!v59) {
            *((unsigned char *)v6 + 184) = 1;
          }
          if (grl::codec::InfoLayerData::decode((uint64_t)v6 + 188, (uint64_t)&v79, v29)) {
            goto LABEL_80;
          }
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Information Layer could not be read", "_internalLayers.infoLayer->decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp", 144);
          goto LABEL_82;
        default:
          goto LABEL_80;
      }
      while (1)
      {
        uint64_t v53 = *(void *)v52;
        float v54 = (uint64_t **)v52;
        if (!*(void *)v52) {
          break;
        }
        while (1)
        {
          uint64_t v52 = v53;
          unsigned int v55 = *(unsigned __int16 *)(v53 + 32);
          if (v55 > v34) {
            break;
          }
          if (v55 >= v34) {
            goto LABEL_72;
          }
          uint64_t v53 = *(void *)(v52 + 8);
          if (!v53)
          {
            float v54 = (uint64_t **)(v52 + 8);
            goto LABEL_69;
          }
        }
      }
LABEL_69:
      uint64_t v56 = v52;
      uint64_t v52 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v6[13] + 16))(v6[13], 224, 8);
      *(_WORD *)(v52 + 32) = v34;
      grl::codec::TextLayerData::TextLayerData((grl::codec::TextLayerData *)(v52 + 40));
      *(void *)uint64_t v52 = 0;
      *(void *)(v52 + 8) = 0;
      *(void *)(v52 + 16) = v56;
      *float v54 = (uint64_t *)v52;
      uint64_t v57 = (uint64_t *)*v6[11];
      unsigned int v58 = (uint64_t *)v52;
      if (v57)
      {
        v6[11] = v57;
        unsigned int v58 = *v54;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v6[12], v58);
      v6[14] = (uint64_t *)((char *)v6[14] + 1);
      uint64_t v29 = a4;
LABEL_72:
      if (grl::codec::TextLayerData::decode(v52 + 40, (uint64_t)&v79, v29))
      {
LABEL_80:
        int v33 = 0;
      }
      else
      {
        printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Text Layer could not be read", "_internalLayers.textLayers[layerIndex.value()].decode(layerData.value(), propertyContext)", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp", 140);
LABEL_82:
        int v33 = 1;
      }
      uint64_t v31 = v27;
    }
    else
    {
      char v78 = 0;
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Layer Data could not be read", "layerData.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp", 121);
      int v33 = 1;
    }
    if (!v78)
    {
      uint64_t v27 = v31;
      goto LABEL_88;
    }
    long long v37 = (void *)v79;
    uint64_t v27 = v31;
    if ((void)v79) {
      goto LABEL_86;
    }
LABEL_88:
    if (v33 != 19 && v33) {
      return 0;
    }
    ++v28;
    uint64_t result = 1;
    if (v28 >= v69) {
      return result;
    }
  }
  int v62 = 118;
  float v63 = "layerLength.has_value()";
  float v64 = "Layer Length could not be read";
LABEL_102:
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v64, v63, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconData.cpp", v62);
  return 0;
}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  int v5 = (char *)a1[1];
  unint64_t v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    unint64_t v6 = *a1;
    unsigned int v7 = &v5[-*a1];
    unint64_t v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0) {
      abort();
    }
    unint64_t v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v10 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v10 = v8;
    }
    if (v10) {
      unint64_t v11 = (unint64_t)operator new(v10);
    }
    else {
      unint64_t v11 = 0;
    }
    unsigned int v12 = &v7[v11];
    int v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      unint64_t v11 = (unint64_t)v12;
    }
    else
    {
      unsigned int v14 = &v5[~v6];
      do
      {
        char v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      int v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void grl::toEnum<grl::LayerType>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  switch(a1)
  {
    case 0:
      *(unsigned char *)a2 = 1;
      *(_WORD *)(a2 + 2) = 0;
      return;
    case 1:
      __int16 v5 = 1;
      *(unsigned char *)a2 = 1;
      goto LABEL_12;
    case 2:
      *(unsigned char *)a2 = 1;
      __int16 v5 = 2;
      goto LABEL_12;
    case 3:
      *(unsigned char *)a2 = 1;
      __int16 v5 = 3;
      goto LABEL_12;
    case 4:
      *(unsigned char *)a2 = 1;
      __int16 v5 = 4;
LABEL_12:
      *(_WORD *)(a2 + 2) = v5;
      break;
    default:
      if (GEOGetGeoResourceLibCodecLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibCodecLog::onceToken, &__block_literal_global_5_1);
      }
      unint64_t v4 = GEOGetGeoResourceLibCodecLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibCodecLog::log, OS_LOG_TYPE_ERROR))
      {
        v6[0] = 67109890;
        v6[1] = a1;
        __int16 v7 = 2080;
        unint64_t v8 = "false";
        __int16 v9 = 2080;
        size_t v10 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconEnums.cpp";
        __int16 v11 = 1024;
        int v12 = 336;
        _os_log_impl(&dword_1A1780000, v4, OS_LOG_TYPE_ERROR, "LayerType value is out of range with value %d.: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)v6, 0x22u);
      }
      *(unsigned char *)a2 = 0;
      break;
  }
}

grl::codec::ImageLayerData *grl::codec::ImageLayerData::ImageLayerData(grl::codec::ImageLayerData *this)
{
  __int16 v6 = 515;
  char v7 = 1;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  uint64_t v2 = grl::Allocator::instance(this);
  *((void *)this + 3) = v2;
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 16))(v2, 3, 1);
  uint64_t v4 = 0;
  *(void *)this = v3;
  *((void *)this + 2) = v3 + 3;
  do
  {
    if (v3 + v4) {
      *(unsigned char *)(v3 + v4) = *((unsigned char *)&v6 + v4);
    }
    ++v4;
  }
  while (v4 != 3);
  *((void *)this + 1) = v3 + 3;
  *((_DWORD *)this + 8) = 0;
  *((_WORD *)this + 18) = -256;
  *((unsigned char *)this + 38) = 0;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 48) = 0;
  *((_DWORD *)this + 13) = 1119092736;
  *((_DWORD *)this + 14) = -16777216;
  *((_DWORD *)this + 15) = 1065353216;
  *((void *)this + 8) = 4278190080;
  *((_DWORD *)this + 18) = 1;
  *((unsigned char *)this + 76) = -1;
  *((void *)this + 13) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *(void *)((char *)this + 93) = 0;
  *((unsigned char *)this + 112) = 2;
  *((_DWORD *)this + 29) = 1065353216;
  *((_DWORD *)this + 30) = -16777216;
  *(void *)((char *)this + 140) = 0;
  *(void *)((char *)this + 129) = 0;
  *(void *)((char *)this + 124) = 0;
  *((_WORD *)this + 74) = 1;
  return this;
}

uint64_t grl::codec::InfoLayerData::decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(_WORD **)a2;
  unint64_t v4 = *(void *)(a2 + 8) - *(void *)a2;
  unsigned int v60 = *(_WORD **)a2;
  unint64_t v61 = v4;
  if (v4 >= 2)
  {
    uint64_t v62 = 2;
    unsigned int v57 = (unsigned __int16)*v3;
    if (!*v3)
    {
      char v5 = 1;
      return v5 & 1;
    }
    BOOL v6 = 0;
    int v7 = 0;
    unint64_t v8 = (void *)(a3 + 8);
    unsigned int v55 = (void *)(a3 + 8);
    while (v62 + 2 <= v61)
    {
      uint64_t v9 = v62 + 4;
      if (v62 + 4 > v61)
      {
        int v51 = 130;
        uint64_t v52 = "numPropertiesForType.has_value()";
        uint64_t v53 = "Property Count could not be read";
        goto LABEL_119;
      }
      unsigned int v10 = *(unsigned __int16 *)((char *)v60 + v62);
      v62 += 4;
      uint64_t v11 = *v8;
      if (!*v8) {
        goto LABEL_116;
      }
      int v12 = *(unsigned __int16 *)((char *)v60 + v9 - 2);
      uint64_t v13 = v8;
      do
      {
        unsigned int v14 = *(_DWORD *)(v11 + 28);
        BOOL v15 = v14 >= v10;
        if (v14 >= v10) {
          uint64_t v16 = (uint64_t *)v11;
        }
        else {
          uint64_t v16 = (uint64_t *)(v11 + 8);
        }
        if (v15) {
          uint64_t v13 = (void *)v11;
        }
        uint64_t v11 = *v16;
      }
      while (*v16);
      if (v13 == v8 || *((_DWORD *)v13 + 7) > v10)
      {
LABEL_116:
        int v51 = 133;
        uint64_t v52 = "decoderMapIter != propertyContext.decoderMap.end()";
        uint64_t v53 = "Property Type read from set that wasnt in the Property Info Chapter";
LABEL_119:
        printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v53, v52, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/InfoLayerData_Generated.cpp", v51);
        char v5 = v6;
        return v5 & 1;
      }
      int v58 = v7;
      for (char i = v6; v12; --v12)
      {
        unint64_t v17 = v61;
        uint64_t v18 = v62;
        uint64_t v19 = v62 + 2;
        if (v62 + 2 > v61)
        {
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/InfoLayerData_Generated.cpp", 137);
          char v5 = i;
          return v5 & 1;
        }
        v62 += 2;
        uint64_t v20 = *((unsigned __int8 *)v13 + 32);
        if (v10 <= 6 && v20 == (0x41008040401uLL >> (8 * v10)))
        {
          uint64_t v21 = v60;
          signed int v22 = *(unsigned __int16 *)((char *)v60 + v18);
          if (grl::propertyTypeFromPropertyID(v22) == v10)
          {
            if (v22 > 26)
            {
              switch(v22)
              {
                case '""':
                  if (v18 + 3 > v17)
                  {
                    unint64_t v26 = v18 + 3;
                  }
                  else
                  {
                    uint64_t v62 = v18 + 3;
                    char v23 = *((unsigned char *)v21 + v19);
                    unint64_t v26 = v18 + 4;
                    uint64_t v19 = v18 + 3;
                  }
                  if (v26 > v17)
                  {
                    unint64_t v36 = v26;
                  }
                  else
                  {
                    uint64_t v62 = v26;
                    char v24 = *((unsigned char *)v21 + v19);
                    unint64_t v36 = v26 + 1;
                    uint64_t v19 = v26;
                  }
                  if (v36 > v17)
                  {
                    unint64_t v40 = v36;
                  }
                  else
                  {
                    uint64_t v62 = v36;
                    char v25 = *((unsigned char *)v21 + v19);
                    unint64_t v40 = v36 + 1;
                    uint64_t v19 = v36;
                  }
                  if (v40 <= v17)
                  {
                    uint64_t v62 = v40;
                    if (v18 + 3 <= v17 && v26 <= v17 && v36 <= v17)
                    {
                      char v44 = *((unsigned char *)v21 + v19);
                      *(unsigned char *)(a1 + 8) = v23;
                      *(unsigned char *)(a1 + 9) = v24;
                      *(unsigned char *)(a1 + 10) = v25;
                      *(unsigned char *)(a1 + 11) = v44;
                    }
                  }
                  break;
                case '#':
                case '$':
                case '\'':
                case '(':
                case '*':
                case '+':
                  goto LABEL_39;
                case '%':
                  if (v18 + 6 <= v17)
                  {
                    uint64_t v62 = v18 + 6;
                    int v31 = *(_DWORD *)((char *)v21 + v18 + 2);
                    uint64_t v30 = a1;
                  }
                  else
                  {
                    uint64_t v30 = a1;
                    LOBYTE(v31) = *(unsigned char *)(a1 + 16);
                  }
                  *(unsigned char *)(v30 + 16) = v31;
                  break;
                case '&':
                  if (v18 + 3 > v17)
                  {
                    unint64_t v32 = v18 + 3;
                  }
                  else
                  {
                    uint64_t v62 = v18 + 3;
                    char v23 = *((unsigned char *)v21 + v19);
                    unint64_t v32 = v18 + 4;
                    uint64_t v19 = v18 + 3;
                  }
                  if (v32 > v17)
                  {
                    unint64_t v37 = v32;
                  }
                  else
                  {
                    uint64_t v62 = v32;
                    char v24 = *((unsigned char *)v21 + v19);
                    unint64_t v37 = v32 + 1;
                    uint64_t v19 = v32;
                  }
                  if (v37 > v17)
                  {
                    unint64_t v41 = v37;
                  }
                  else
                  {
                    uint64_t v62 = v37;
                    char v25 = *((unsigned char *)v21 + v19);
                    unint64_t v41 = v37 + 1;
                    uint64_t v19 = v37;
                  }
                  if (v41 <= v17)
                  {
                    uint64_t v62 = v41;
                    if (v18 + 3 <= v17 && v32 <= v17 && v37 <= v17)
                    {
                      char v45 = *((unsigned char *)v21 + v19);
                      *(unsigned char *)(a1 + 25) = v23;
                      *(unsigned char *)(a1 + 26) = v24;
                      *(unsigned char *)(a1 + 27) = v25;
                      *(unsigned char *)(a1 + 28) = v45;
                    }
                  }
                  break;
                case ')':
                  char v33 = a1;
                  *(unsigned char *)(a1 + 37) = 1;
                  if (v18 + 3 > v17)
                  {
                    unint64_t v34 = v18 + 3;
                  }
                  else
                  {
                    uint64_t v62 = v18 + 3;
                    char v33 = *((unsigned char *)v21 + v19);
                    unint64_t v34 = v18 + 4;
                    uint64_t v19 = v18 + 3;
                  }
                  if (v34 > v17)
                  {
                    unint64_t v38 = v34;
                  }
                  else
                  {
                    uint64_t v62 = v34;
                    char v24 = *((unsigned char *)v21 + v19);
                    unint64_t v38 = v34 + 1;
                    uint64_t v19 = v34;
                  }
                  if (v38 > v17)
                  {
                    unint64_t v42 = v38;
                  }
                  else
                  {
                    uint64_t v62 = v38;
                    char v25 = *((unsigned char *)v21 + v19);
                    unint64_t v42 = v38 + 1;
                    uint64_t v19 = v38;
                  }
                  if (v42 <= v17)
                  {
                    uint64_t v62 = v42;
                    if (v18 + 3 <= v17 && v34 <= v17 && v38 <= v17)
                    {
                      char v46 = *((unsigned char *)v21 + v19);
                      *(unsigned char *)(a1 + 17) = v33;
                      *(unsigned char *)(a1 + 18) = v24;
                      *(unsigned char *)(a1 + 19) = v25;
                      *(unsigned char *)(a1 + 20) = v46;
                    }
                  }
                  break;
                case ',':
                  if (v18 + 3 > v17)
                  {
                    unint64_t v35 = v18 + 3;
                  }
                  else
                  {
                    uint64_t v62 = v18 + 3;
                    char v23 = *((unsigned char *)v21 + v19);
                    unint64_t v35 = v18 + 4;
                    uint64_t v19 = v18 + 3;
                  }
                  if (v35 > v17)
                  {
                    unint64_t v39 = v35;
                  }
                  else
                  {
                    uint64_t v62 = v35;
                    char v24 = *((unsigned char *)v21 + v19);
                    unint64_t v39 = v35 + 1;
                    uint64_t v19 = v35;
                  }
                  if (v39 > v17)
                  {
                    unint64_t v43 = v39;
                  }
                  else
                  {
                    uint64_t v62 = v39;
                    char v25 = *((unsigned char *)v21 + v19);
                    unint64_t v43 = v39 + 1;
                    uint64_t v19 = v39;
                  }
                  if (v43 <= v17)
                  {
                    uint64_t v62 = v43;
                    if (v18 + 3 <= v17 && v35 <= v17 && v39 <= v17)
                    {
                      char v47 = *((unsigned char *)v21 + v19);
                      *(unsigned char *)(a1 + 21) = v23;
                      *(unsigned char *)(a1 + 22) = v24;
                      *(unsigned char *)(a1 + 23) = v25;
                      *(unsigned char *)(a1 + 24) = v47;
                    }
                  }
                  break;
                default:
                  if (v22 != 27) {
                    goto LABEL_39;
                  }
                  char v28 = a1;
                  *(unsigned char *)(a1 + 36) = 1;
                  if (v18 + 3 > v17)
                  {
                    unint64_t v29 = v18 + 3;
                  }
                  else
                  {
                    uint64_t v62 = v18 + 3;
                    char v28 = *((unsigned char *)v21 + v19);
                    unint64_t v29 = v18 + 4;
                    uint64_t v19 = v18 + 3;
                  }
                  if (v29 > v17)
                  {
                    unint64_t v48 = v29;
                  }
                  else
                  {
                    uint64_t v62 = v29;
                    char v24 = *((unsigned char *)v21 + v19);
                    unint64_t v48 = v29 + 1;
                    uint64_t v19 = v29;
                  }
                  if (v48 > v17)
                  {
                    unint64_t v49 = v48;
                  }
                  else
                  {
                    uint64_t v62 = v48;
                    char v25 = *((unsigned char *)v21 + v19);
                    unint64_t v49 = v48 + 1;
                    uint64_t v19 = v48;
                  }
                  if (v49 <= v17)
                  {
                    uint64_t v62 = v49;
                    if (v18 + 3 <= v17 && v29 <= v17 && v48 <= v17)
                    {
                      char v50 = *((unsigned char *)v21 + v19);
                      *(unsigned char *)(a1 + 12) = v28;
                      *(unsigned char *)(a1 + 13) = v24;
                      *(unsigned char *)(a1 + 14) = v25;
                      *(unsigned char *)(a1 + 15) = v50;
                    }
                  }
                  break;
              }
              continue;
            }
            switch(v22)
            {
              case 0:
                if (v18 + 6 <= v17)
                {
                  int v27 = *(_DWORD *)((char *)v21 + v19);
                  uint64_t v62 = v18 + 6;
                  *(_DWORD *)(a1 + 32) = v27;
                }
                continue;
              case 19:
                if (v18 + 6 <= v17)
                {
                  uint64_t v62 = v18 + 6;
                  *(_DWORD *)(a1 + 4) = *(_DWORD *)((char *)v21 + v18 + 2);
                }
                continue;
              case 20:
                if (v18 + 6 <= v17)
                {
                  uint64_t v62 = v18 + 6;
                  *(_DWORD *)a1 = *(_DWORD *)((char *)v21 + v18 + 2);
                }
                continue;
            }
          }
        }
LABEL_39:
        grl::SkipStreamBytes(&v60, v20);
      }
      int v7 = v58 + 1;
      char v5 = 1;
      BOOL v6 = v58 + 1 >= v57;
      unint64_t v8 = v55;
      if (v58 + 1 == v57) {
        return v5 & 1;
      }
    }
    int v51 = 126;
    uint64_t v52 = "propertyTypeValue.has_value()";
    uint64_t v53 = "Property Type could not be read";
    goto LABEL_119;
  }
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/InfoLayerData_Generated.cpp", 122);
  char v5 = 0;
  return v5 & 1;
}

grl::codec::PathLayerData *grl::codec::PathLayerData::PathLayerData(grl::codec::PathLayerData *this)
{
  __int16 v6 = 515;
  char v7 = 1;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  uint64_t v2 = grl::Allocator::instance(this);
  *((void *)this + 3) = v2;
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 16))(v2, 3, 1);
  uint64_t v4 = 0;
  *(void *)this = v3;
  *((void *)this + 2) = v3 + 3;
  do
  {
    if (v3 + v4) {
      *(unsigned char *)(v3 + v4) = *((unsigned char *)&v6 + v4);
    }
    ++v4;
  }
  while (v4 != 3);
  *((void *)this + 1) = v3 + 3;
  *((_WORD *)this + 16) = 0;
  *(_DWORD *)((char *)this + 34) = -1;
  *((_DWORD *)this + 10) = 0;
  *(_DWORD *)((char *)this + 43) = 0;
  *(_WORD *)((char *)this + 47) = 255;
  *(void *)((char *)this + 52) = 0;
  *((unsigned char *)this + 60) = 0;
  *((_DWORD *)this + 16) = 1119092736;
  *((_DWORD *)this + 17) = -16777216;
  *((_DWORD *)this + 18) = 1065353216;
  *(void *)((char *)this + 76) = 4278190080;
  *((_DWORD *)this + 21) = 1;
  *((unsigned char *)this + 88) = -1;
  *((_DWORD *)this + 23) = 0;
  *((unsigned char *)this + 96) = 0;
  *((_DWORD *)this + 25) = 1065353216;
  *((_DWORD *)this + 26) = -16777216;
  *((_DWORD *)this + 31) = 0;
  *(void *)((char *)this + 113) = 0;
  *(void *)((char *)this + 108) = 0;
  *((unsigned char *)this + 128) = 1;
  return this;
}

uint64_t grl::codec::PathLayerData::decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(_WORD **)a2;
  unint64_t v4 = *(void *)(a2 + 8) - *(void *)a2;
  float v81 = *(_WORD **)a2;
  unint64_t v82 = v4;
  if (v4 >= 2)
  {
    uint64_t v83 = 2;
    unsigned int v78 = (unsigned __int16)*v3;
    if (*v3)
    {
      BOOL v6 = 0;
      int v7 = 0;
      unint64_t v8 = (void *)(a3 + 8);
      int v76 = (void *)(a3 + 8);
      while (1)
      {
        if (v83 + 2 > v82)
        {
          int v72 = 182;
          float v73 = "propertyTypeValue.has_value()";
          char v74 = "Property Type could not be read";
          goto LABEL_166;
        }
        uint64_t v9 = v83 + 4;
        if (v83 + 4 > v82)
        {
          int v72 = 186;
          float v73 = "numPropertiesForType.has_value()";
          char v74 = "Property Count could not be read";
          goto LABEL_166;
        }
        unsigned int v10 = *(unsigned __int16 *)((char *)v81 + v83);
        v83 += 4;
        uint64_t v11 = *v8;
        if (!*v8) {
          goto LABEL_163;
        }
        int v12 = *(unsigned __int16 *)((char *)v81 + v9 - 2);
        uint64_t v13 = v8;
        do
        {
          unsigned int v14 = *(_DWORD *)(v11 + 28);
          BOOL v15 = v14 >= v10;
          if (v14 >= v10) {
            uint64_t v16 = (uint64_t *)v11;
          }
          else {
            uint64_t v16 = (uint64_t *)(v11 + 8);
          }
          if (v15) {
            uint64_t v13 = (void *)v11;
          }
          uint64_t v11 = *v16;
        }
        while (*v16);
        if (v13 == v8 || *((_DWORD *)v13 + 7) > v10)
        {
LABEL_163:
          int v72 = 189;
          float v73 = "decoderMapIter != propertyContext.decoderMap.end()";
          char v74 = "Property Type read from set that wasnt in the Property Info Chapter";
LABEL_166:
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v74, v73, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/PathLayerData_Generated.cpp", v72);
          char v5 = v6;
          return v5 & 1;
        }
        int v79 = v7;
        char v77 = v6;
        if (v12) {
          break;
        }
LABEL_159:
        int v7 = v79 + 1;
        char v5 = 1;
        BOOL v6 = v79 + 1 >= v78;
        unint64_t v8 = v76;
        if (v79 + 1 == v78) {
          return v5 & 1;
        }
      }
      while (1)
      {
        unint64_t v17 = v82;
        uint64_t v18 = v83;
        uint64_t v19 = v83 + 2;
        if (v83 + 2 > v82) {
          break;
        }
        v83 += 2;
        uint64_t v20 = *((unsigned __int8 *)v13 + 32);
        if (v10 <= 6
          && v20 == (0x41008040401uLL >> (8 * v10))
          && (uint64_t v21 = v81,
              unsigned int v22 = *(unsigned __int16 *)((char *)v81 + v18),
              grl::propertyTypeFromPropertyID(v22) == v10))
        {
          switch(v22)
          {
            case 0u:
              if (v18 + 6 <= v17)
              {
                int v26 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                *(_DWORD *)(a1 + 100) = v26;
              }
              break;
            case 1u:
              if (v18 + 6 <= v17)
              {
                int v27 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                if (v18 + 10 <= v17)
                {
                  int v28 = *(_DWORD *)((char *)v21 + v18 + 6);
                  uint64_t v83 = v18 + 10;
                  *(_DWORD *)(a1 + 52) = v27;
                  *(_DWORD *)(a1 + 56) = v28;
                }
              }
              break;
            case 2u:
              if (v18 + 6 <= v17)
              {
                int v29 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                *(_DWORD *)(a1 + 92) = v29;
              }
              break;
            case 3u:
              if (v18 + 6 <= v17)
              {
                int v30 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                *(_DWORD *)(a1 + 116) = v30;
              }
              break;
            case 4u:
              if (v18 + 6 <= v17)
              {
                int v31 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                if (v18 + 10 <= v17)
                {
                  int v32 = *(_DWORD *)((char *)v21 + v18 + 6);
                  uint64_t v83 = v18 + 10;
                  *(_DWORD *)(a1 + 108) = v31;
                  *(_DWORD *)(a1 + 112) = v32;
                }
              }
              break;
            case 5u:
              if (v18 + 3 > v17)
              {
                unint64_t v33 = v18 + 3;
              }
              else
              {
                uint64_t v83 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v33 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v33 > v17)
              {
                unint64_t v54 = v33;
              }
              else
              {
                uint64_t v83 = v33;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v54 = v33 + 1;
                uint64_t v19 = v33;
              }
              if (v54 > v17)
              {
                unint64_t v60 = v54;
              }
              else
              {
                uint64_t v83 = v54;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v60 = v54 + 1;
                uint64_t v19 = v54;
              }
              if (v60 <= v17)
              {
                uint64_t v83 = v60;
                if (v18 + 3 <= v17 && v33 <= v17 && v54 <= v17)
                {
                  char v66 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 44) = v23;
                  *(unsigned char *)(a1 + 45) = v24;
                  *(unsigned char *)(a1 + 46) = v25;
                  *(unsigned char *)(a1 + 47) = v66;
                }
              }
              break;
            case 6u:
              if (v18 + 3 > v17)
              {
                unint64_t v34 = v18 + 3;
              }
              else
              {
                uint64_t v83 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v34 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v34 > v17)
              {
                unint64_t v55 = v34;
              }
              else
              {
                uint64_t v83 = v34;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v55 = v34 + 1;
                uint64_t v19 = v34;
              }
              if (v55 > v17)
              {
                unint64_t v61 = v55;
              }
              else
              {
                uint64_t v83 = v55;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v61 = v55 + 1;
                uint64_t v19 = v55;
              }
              if (v61 <= v17)
              {
                uint64_t v83 = v61;
                if (v18 + 3 <= v17 && v34 <= v17 && v55 <= v17)
                {
                  char v67 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 85) = v23;
                  *(unsigned char *)(a1 + 86) = v24;
                  *(unsigned char *)(a1 + 87) = v25;
                  *(unsigned char *)(a1 + 88) = v67;
                }
              }
              break;
            case 7u:
              if (v18 + 3 > v17)
              {
                unint64_t v35 = v18 + 3;
              }
              else
              {
                uint64_t v83 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v35 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v35 > v17)
              {
                unint64_t v56 = v35;
              }
              else
              {
                uint64_t v83 = v35;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v56 = v35 + 1;
                uint64_t v19 = v35;
              }
              if (v56 > v17)
              {
                unint64_t v62 = v56;
              }
              else
              {
                uint64_t v83 = v56;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v62 = v56 + 1;
                uint64_t v19 = v56;
              }
              if (v62 <= v17)
              {
                uint64_t v83 = v62;
                if (v18 + 3 <= v17 && v35 <= v17 && v56 <= v17)
                {
                  char v68 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 104) = v23;
                  *(unsigned char *)(a1 + 105) = v24;
                  *(unsigned char *)(a1 + 106) = v25;
                  *(unsigned char *)(a1 + 107) = v68;
                }
              }
              break;
            case 8u:
              if (v18 + 6 <= v17)
              {
                uint64_t v83 = v18 + 6;
                int v49 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v48 = a1;
              }
              else
              {
                uint64_t v48 = a1;
                LOBYTE(v49) = *(unsigned char *)(a1 + 32);
              }
              *(unsigned char *)(v48 + 32) = v49;
              break;
            case 0xCu:
              if (v18 + 3 <= v17)
              {
                uint64_t v83 = v18 + 3;
                *(unsigned char *)(a1 + 33) = *((unsigned char *)v21 + v19) != 0;
              }
              break;
            case 0xDu:
              if (v18 + 6 <= v17)
              {
                int v36 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                *(_DWORD *)(a1 + 40) = v36;
              }
              break;
            case 0xEu:
              if (v18 + 6 <= v17)
              {
                int v37 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                *(_DWORD *)(a1 + 124) = v37;
              }
              break;
            case 0xFu:
              if (v18 + 3 <= v17)
              {
                uint64_t v83 = v18 + 3;
                *(unsigned char *)(a1 + 128) = *((unsigned char *)v21 + v19) != 0;
              }
              break;
            case 0x10u:
              if (v18 + 3 > v17)
              {
                unint64_t v38 = v18 + 3;
              }
              else
              {
                uint64_t v83 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v38 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v38 > v17)
              {
                unint64_t v57 = v38;
              }
              else
              {
                uint64_t v83 = v38;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v57 = v38 + 1;
                uint64_t v19 = v38;
              }
              if (v57 > v17)
              {
                unint64_t v63 = v57;
              }
              else
              {
                uint64_t v83 = v57;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v63 = v57 + 1;
                uint64_t v19 = v57;
              }
              if (v63 <= v17)
              {
                uint64_t v83 = v63;
                if (v18 + 3 <= v17 && v38 <= v17 && v57 <= v17)
                {
                  char v69 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 76) = v23;
                  *(unsigned char *)(a1 + 77) = v24;
                  *(unsigned char *)(a1 + 78) = v25;
                  *(unsigned char *)(a1 + 79) = v69;
                }
              }
              break;
            case 0x11u:
              if (v18 + 3 > v17)
              {
                unint64_t v39 = v18 + 3;
              }
              else
              {
                uint64_t v83 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v39 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v39 > v17)
              {
                unint64_t v58 = v39;
              }
              else
              {
                uint64_t v83 = v39;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v58 = v39 + 1;
                uint64_t v19 = v39;
              }
              if (v58 > v17)
              {
                unint64_t v64 = v58;
              }
              else
              {
                uint64_t v83 = v58;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v64 = v58 + 1;
                uint64_t v19 = v58;
              }
              if (v64 <= v17)
              {
                uint64_t v83 = v64;
                if (v18 + 3 <= v17 && v39 <= v17 && v58 <= v17)
                {
                  char v70 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 68) = v23;
                  *(unsigned char *)(a1 + 69) = v24;
                  *(unsigned char *)(a1 + 70) = v25;
                  *(unsigned char *)(a1 + 71) = v70;
                }
              }
              break;
            case 0x12u:
              if (v18 + 6 <= v17)
              {
                uint64_t v83 = v18 + 6;
                int v41 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v40 = a1;
              }
              else
              {
                uint64_t v40 = a1;
                LOBYTE(v41) = *(unsigned char *)(a1 + 60);
              }
              *(unsigned char *)(v40 + 60) = v41;
              break;
            case 0x15u:
              if (v18 + 6 <= v17)
              {
                uint64_t v83 = v18 + 6;
                int v51 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v50 = a1;
              }
              else
              {
                uint64_t v50 = a1;
                LOBYTE(v51) = *(unsigned char *)(a1 + 120);
              }
              *(unsigned char *)(v50 + 120) = v51;
              break;
            case 0x20u:
              if (v18 + 6 <= v17)
              {
                int v52 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                *(_DWORD *)(a1 + 80) = v52;
              }
              break;
            case 0x21u:
              if (v18 + 6 <= v17)
              {
                int v42 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                *(_DWORD *)(a1 + 72) = v42;
              }
              break;
            case 0x23u:
              if (v18 + 6 <= v17)
              {
                uint64_t v83 = v18 + 6;
                int v44 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v43 = a1;
              }
              else
              {
                uint64_t v43 = a1;
                LOBYTE(v44) = *(unsigned char *)(a1 + 48);
              }
              *(unsigned char *)(v43 + 48) = v44;
              break;
            case 0x27u:
              if (v18 + 6 <= v17)
              {
                int v53 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v83 = v18 + 6;
                *(_DWORD *)(a1 + 64) = v53;
              }
              break;
            case 0x28u:
              if (v18 + 6 <= v17)
              {
                uint64_t v83 = v18 + 6;
                int v46 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v45 = a1;
              }
              else
              {
                uint64_t v45 = a1;
                LOBYTE(v46) = *(unsigned char *)(a1 + 84);
              }
              *(unsigned char *)(v45 + 84) = v46;
              break;
            case 0x2Bu:
              if (v18 + 3 <= v17)
              {
                uint64_t v83 = v18 + 3;
                *(unsigned char *)(a1 + 96) = *((unsigned char *)v21 + v19) != 0;
              }
              break;
            case 0x2Fu:
              if (v18 + 3 > v17)
              {
                unint64_t v47 = v18 + 3;
              }
              else
              {
                uint64_t v83 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v47 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v47 > v17)
              {
                unint64_t v59 = v47;
              }
              else
              {
                uint64_t v83 = v47;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v59 = v47 + 1;
                uint64_t v19 = v47;
              }
              if (v59 > v17)
              {
                unint64_t v65 = v59;
              }
              else
              {
                uint64_t v83 = v59;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v65 = v59 + 1;
                uint64_t v19 = v59;
              }
              if (v65 <= v17)
              {
                uint64_t v83 = v65;
                if (v18 + 3 <= v17 && v47 <= v17 && v59 <= v17)
                {
                  char v71 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 34) = v23;
                  *(unsigned char *)(a1 + 35) = v24;
                  *(unsigned char *)(a1 + 36) = v25;
                  *(unsigned char *)(a1 + 37) = v71;
                }
              }
              break;
            default:
              goto LABEL_26;
          }
        }
        else
        {
LABEL_26:
          grl::SkipStreamBytes(&v81, v20);
        }
        if (!--v12) {
          goto LABEL_159;
        }
      }
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/PathLayerData_Generated.cpp", 193);
      char v5 = v77;
    }
    else
    {
      char v5 = 1;
    }
  }
  else
  {
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/PathLayerData_Generated.cpp", 178);
    char v5 = 0;
  }
  return v5 & 1;
}

uint64_t grl::codec::ImageLayerData::decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *(_WORD **)a2;
  unint64_t v4 = *(void *)(a2 + 8) - *(void *)a2;
  float v85 = *(_WORD **)a2;
  unint64_t v86 = v4;
  if (v4 >= 2)
  {
    uint64_t v87 = 2;
    unsigned int v82 = (unsigned __int16)*v3;
    if (*v3)
    {
      BOOL v6 = 0;
      int v7 = 0;
      unint64_t v8 = (void *)(a3 + 8);
      unint64_t v80 = (void *)(a3 + 8);
      while (1)
      {
        if (v87 + 2 > v86)
        {
          int v76 = 202;
          char v77 = "propertyTypeValue.has_value()";
          unsigned int v78 = "Property Type could not be read";
          goto LABEL_164;
        }
        uint64_t v9 = v87 + 4;
        if (v87 + 4 > v86)
        {
          int v76 = 206;
          char v77 = "numPropertiesForType.has_value()";
          unsigned int v78 = "Property Count could not be read";
          goto LABEL_164;
        }
        unsigned int v10 = *(unsigned __int16 *)((char *)v85 + v87);
        v87 += 4;
        uint64_t v11 = *v8;
        if (!*v8) {
          goto LABEL_161;
        }
        int v12 = *(unsigned __int16 *)((char *)v85 + v9 - 2);
        uint64_t v13 = v8;
        do
        {
          unsigned int v14 = *(_DWORD *)(v11 + 28);
          BOOL v15 = v14 >= v10;
          if (v14 >= v10) {
            uint64_t v16 = (uint64_t *)v11;
          }
          else {
            uint64_t v16 = (uint64_t *)(v11 + 8);
          }
          if (v15) {
            uint64_t v13 = (void *)v11;
          }
          uint64_t v11 = *v16;
        }
        while (*v16);
        if (v13 == v8 || *((_DWORD *)v13 + 7) > v10)
        {
LABEL_161:
          int v76 = 209;
          char v77 = "decoderMapIter != propertyContext.decoderMap.end()";
          unsigned int v78 = "Property Type read from set that wasnt in the Property Info Chapter";
LABEL_164:
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v78, v77, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/ImageLayerData_Generated.cpp", v76);
          char v5 = v6;
          return v5 & 1;
        }
        int v83 = v7;
        char v81 = v6;
        if (v12) {
          break;
        }
LABEL_157:
        int v7 = v83 + 1;
        char v5 = 1;
        BOOL v6 = v83 + 1 >= v82;
        unint64_t v8 = v80;
        if (v83 + 1 == v82) {
          return v5 & 1;
        }
      }
      while (1)
      {
        unint64_t v17 = v86;
        uint64_t v18 = v87;
        uint64_t v19 = v87 + 2;
        if (v87 + 2 > v86) {
          break;
        }
        v87 += 2;
        uint64_t v20 = *((unsigned __int8 *)v13 + 32);
        if (v10 <= 6
          && v20 == (0x41008040401uLL >> (8 * v10))
          && (uint64_t v21 = v85,
              unsigned int v22 = *(unsigned __int16 *)((char *)v85 + v18),
              grl::propertyTypeFromPropertyID(v22) == v10))
        {
          switch(v22)
          {
            case 1u:
              if (v18 + 6 <= v17)
              {
                int v26 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                if (v18 + 10 <= v17)
                {
                  int v27 = *(_DWORD *)((char *)v21 + v18 + 6);
                  uint64_t v87 = v18 + 10;
                  *(_DWORD *)(a1 + 40) = v26;
                  *(_DWORD *)(a1 + 44) = v27;
                }
              }
              break;
            case 2u:
              if (v18 + 6 <= v17)
              {
                int v28 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                *(_DWORD *)(a1 + 80) = v28;
              }
              break;
            case 3u:
              if (v18 + 6 <= v17)
              {
                int v29 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                *(_DWORD *)(a1 + 132) = v29;
              }
              break;
            case 4u:
              if (v18 + 6 <= v17)
              {
                int v30 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                if (v18 + 10 <= v17)
                {
                  int v31 = *(_DWORD *)((char *)v21 + v18 + 6);
                  uint64_t v87 = v18 + 10;
                  *(_DWORD *)(a1 + 124) = v30;
                  *(_DWORD *)(a1 + 128) = v31;
                }
              }
              break;
            case 5u:
              if (v18 + 3 > v17)
              {
                unint64_t v32 = v18 + 3;
              }
              else
              {
                uint64_t v87 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v32 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v32 > v17)
              {
                unint64_t v61 = v32;
              }
              else
              {
                uint64_t v87 = v32;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v61 = v32 + 1;
                uint64_t v19 = v32;
              }
              if (v61 > v17)
              {
                unint64_t v66 = v61;
              }
              else
              {
                uint64_t v87 = v61;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v66 = v61 + 1;
                uint64_t v19 = v61;
              }
              if (v66 <= v17)
              {
                uint64_t v87 = v66;
                if (v18 + 3 <= v17 && v32 <= v17 && v61 <= v17)
                {
                  char v71 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 34) = v23;
                  *(unsigned char *)(a1 + 35) = v24;
                  *(unsigned char *)(a1 + 36) = v25;
                  *(unsigned char *)(a1 + 37) = v71;
                }
              }
              break;
            case 6u:
              if (v18 + 3 > v17)
              {
                unint64_t v33 = v18 + 3;
              }
              else
              {
                uint64_t v87 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v33 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v33 > v17)
              {
                unint64_t v62 = v33;
              }
              else
              {
                uint64_t v87 = v33;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v62 = v33 + 1;
                uint64_t v19 = v33;
              }
              if (v62 > v17)
              {
                unint64_t v67 = v62;
              }
              else
              {
                uint64_t v87 = v62;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v67 = v62 + 1;
                uint64_t v19 = v62;
              }
              if (v67 <= v17)
              {
                uint64_t v87 = v67;
                if (v18 + 3 <= v17 && v33 <= v17 && v62 <= v17)
                {
                  char v72 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 73) = v23;
                  *(unsigned char *)(a1 + 74) = v24;
                  *(unsigned char *)(a1 + 75) = v25;
                  *(unsigned char *)(a1 + 76) = v72;
                }
              }
              break;
            case 7u:
              if (v18 + 3 > v17)
              {
                unint64_t v34 = v18 + 3;
              }
              else
              {
                uint64_t v87 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v34 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v34 > v17)
              {
                unint64_t v63 = v34;
              }
              else
              {
                uint64_t v87 = v34;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v63 = v34 + 1;
                uint64_t v19 = v34;
              }
              if (v63 > v17)
              {
                unint64_t v68 = v63;
              }
              else
              {
                uint64_t v87 = v63;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v68 = v63 + 1;
                uint64_t v19 = v63;
              }
              if (v68 <= v17)
              {
                uint64_t v87 = v68;
                if (v18 + 3 <= v17 && v34 <= v17 && v63 <= v17)
                {
                  char v73 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 120) = v23;
                  *(unsigned char *)(a1 + 121) = v24;
                  *(unsigned char *)(a1 + 122) = v25;
                  *(unsigned char *)(a1 + 123) = v73;
                }
              }
              break;
            case 8u:
              if (v18 + 6 <= v17)
              {
                uint64_t v87 = v18 + 6;
                int v36 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v35 = a1;
              }
              else
              {
                uint64_t v35 = a1;
                LOBYTE(v36) = *(unsigned char *)(a1 + 32);
              }
              *(unsigned char *)(v35 + 32) = v36;
              break;
            case 9u:
              if (v18 + 6 <= v17)
              {
                uint64_t v87 = v18 + 6;
                int v55 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v54 = a1;
              }
              else
              {
                uint64_t v54 = a1;
                LOBYTE(v55) = *(unsigned char *)(a1 + 112);
              }
              *(unsigned char *)(v54 + 112) = v55;
              break;
            case 0xAu:
              if (v18 + 6 <= v17)
              {
                int v56 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                if (v18 + 10 <= v17)
                {
                  int v57 = *(_DWORD *)((char *)v21 + v18 + 6);
                  uint64_t v87 = v18 + 10;
                  *(_DWORD *)(a1 + 84) = v56;
                  *(_DWORD *)(a1 + 88) = v57;
                }
              }
              break;
            case 0xBu:
              if (v18 + 6 <= v17)
              {
                int v37 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                if (v18 + 10 <= v17)
                {
                  int v38 = *(_DWORD *)((char *)v21 + v18 + 6);
                  uint64_t v87 = v18 + 10;
                  *(_DWORD *)(a1 + 140) = v37;
                  *(_DWORD *)(a1 + 144) = v38;
                }
              }
              break;
            case 0xCu:
              if (v18 + 3 <= v17)
              {
                uint64_t v87 = v18 + 3;
                *(unsigned char *)(a1 + 33) = *((unsigned char *)v21 + v19) != 0;
              }
              break;
            case 0xFu:
              if (v18 + 3 <= v17)
              {
                uint64_t v87 = v18 + 3;
                *(unsigned char *)(a1 + 148) = *((unsigned char *)v21 + v19) != 0;
              }
              break;
            case 0x10u:
              if (v18 + 3 > v17)
              {
                unint64_t v39 = v18 + 3;
              }
              else
              {
                uint64_t v87 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v39 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v39 > v17)
              {
                unint64_t v64 = v39;
              }
              else
              {
                uint64_t v87 = v39;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v64 = v39 + 1;
                uint64_t v19 = v39;
              }
              if (v64 > v17)
              {
                unint64_t v69 = v64;
              }
              else
              {
                uint64_t v87 = v64;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v69 = v64 + 1;
                uint64_t v19 = v64;
              }
              if (v69 <= v17)
              {
                uint64_t v87 = v69;
                if (v18 + 3 <= v17 && v39 <= v17 && v64 <= v17)
                {
                  char v74 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 64) = v23;
                  *(unsigned char *)(a1 + 65) = v24;
                  *(unsigned char *)(a1 + 66) = v25;
                  *(unsigned char *)(a1 + 67) = v74;
                }
              }
              break;
            case 0x11u:
              if (v18 + 3 > v17)
              {
                unint64_t v40 = v18 + 3;
              }
              else
              {
                uint64_t v87 = v18 + 3;
                char v23 = *((unsigned char *)v21 + v19);
                unint64_t v40 = v18 + 4;
                uint64_t v19 = v18 + 3;
              }
              if (v40 > v17)
              {
                unint64_t v65 = v40;
              }
              else
              {
                uint64_t v87 = v40;
                char v24 = *((unsigned char *)v21 + v19);
                unint64_t v65 = v40 + 1;
                uint64_t v19 = v40;
              }
              if (v65 > v17)
              {
                unint64_t v70 = v65;
              }
              else
              {
                uint64_t v87 = v65;
                char v25 = *((unsigned char *)v21 + v19);
                unint64_t v70 = v65 + 1;
                uint64_t v19 = v65;
              }
              if (v70 <= v17)
              {
                uint64_t v87 = v70;
                if (v18 + 3 <= v17 && v40 <= v17 && v65 <= v17)
                {
                  char v75 = *((unsigned char *)v21 + v19);
                  *(unsigned char *)(a1 + 56) = v23;
                  *(unsigned char *)(a1 + 57) = v24;
                  *(unsigned char *)(a1 + 58) = v25;
                  *(unsigned char *)(a1 + 59) = v75;
                }
              }
              break;
            case 0x12u:
              if (v18 + 6 <= v17)
              {
                uint64_t v87 = v18 + 6;
                int v42 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v41 = a1;
              }
              else
              {
                uint64_t v41 = a1;
                LOBYTE(v42) = *(unsigned char *)(a1 + 48);
              }
              *(unsigned char *)(v41 + 48) = v42;
              break;
            case 0x20u:
              if (v18 + 6 <= v17)
              {
                int v58 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                *(_DWORD *)(a1 + 68) = v58;
              }
              break;
            case 0x21u:
              if (v18 + 6 <= v17)
              {
                int v59 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                *(_DWORD *)(a1 + 60) = v59;
              }
              break;
            case 0x23u:
              if (v18 + 6 <= v17)
              {
                uint64_t v87 = v18 + 6;
                int v44 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v43 = a1;
              }
              else
              {
                uint64_t v43 = a1;
                LOBYTE(v44) = *(unsigned char *)(a1 + 38);
              }
              *(unsigned char *)(v43 + 38) = v44;
              break;
            case 0x24u:
              if (v18 + 6 <= v17)
              {
                int v45 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                if (v18 + 10 <= v17)
                {
                  int v46 = *(_DWORD *)((char *)v21 + v18 + 6);
                  uint64_t v87 = v18 + 10;
                  *(_DWORD *)(a1 + 92) = v45;
                  *(_DWORD *)(a1 + 96) = v46;
                }
              }
              break;
            case 0x27u:
              if (v18 + 6 <= v17)
              {
                int v60 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                *(_DWORD *)(a1 + 52) = v60;
              }
              break;
            case 0x28u:
              if (v18 + 6 <= v17)
              {
                uint64_t v87 = v18 + 6;
                int v48 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v47 = a1;
              }
              else
              {
                uint64_t v47 = a1;
                LOBYTE(v48) = *(unsigned char *)(a1 + 72);
              }
              *(unsigned char *)(v47 + 72) = v48;
              break;
            case 0x2Au:
              *(unsigned char *)(a1 + 149) = 1;
              if (v18 + 6 <= v17)
              {
                int v49 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                if (v18 + 10 <= v17)
                {
                  int v50 = *(_DWORD *)((char *)v21 + v18 + 6);
                  uint64_t v87 = v18 + 10;
                  *(_DWORD *)(a1 + 104) = v49;
                  *(_DWORD *)(a1 + 108) = v50;
                }
              }
              break;
            case 0x2Du:
              if (v18 + 3 <= v17)
              {
                uint64_t v87 = v18 + 3;
                *(unsigned char *)(a1 + 136) = *((unsigned char *)v21 + v19) != 0;
              }
              break;
            case 0x2Eu:
              if (v18 + 6 <= v17)
              {
                int v51 = *(_DWORD *)((char *)v21 + v19);
                uint64_t v87 = v18 + 6;
                *(_DWORD *)(a1 + 116) = v51;
              }
              break;
            case 0x30u:
              if (v18 + 6 <= v17)
              {
                uint64_t v87 = v18 + 6;
                int v53 = *(_DWORD *)((char *)v21 + v18 + 2);
                uint64_t v52 = a1;
              }
              else
              {
                uint64_t v52 = a1;
                LOBYTE(v53) = *(unsigned char *)(a1 + 100);
              }
              *(unsigned char *)(v52 + 100) = v53;
              break;
            default:
              goto LABEL_27;
          }
        }
        else
        {
LABEL_27:
          grl::SkipStreamBytes(&v85, v20);
        }
        if (!--v12) {
          goto LABEL_157;
        }
      }
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/ImageLayerData_Generated.cpp", 213);
      char v5 = v81;
    }
    else
    {
      char v5 = 1;
    }
  }
  else
  {
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/ImageLayerData_Generated.cpp", 198);
    char v5 = 0;
  }
  return v5 & 1;
}

uint64_t grl::propertyTypeFromPropertyID(unsigned int a1)
{
  if (a1 > 0x30) {
    return 0;
  }
  else {
    return word_1A29CE150[(__int16)a1];
  }
}

uint64_t grl::codec::TextLayerData::decode(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v91[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(_WORD **)a2;
  unint64_t v4 = *(void *)(a2 + 8) - *(void *)a2;
  float v85 = *(_WORD **)a2;
  unint64_t v86 = v4;
  if (v4 >= 2)
  {
    uint64_t v87 = 2;
    unsigned int v82 = (unsigned __int16)*v3;
    if (*v3)
    {
      BOOL v6 = 0;
      int v7 = 0;
      unint64_t v8 = (void *)(a3 + 8);
      int v79 = (void *)(a1 + 152);
      char v77 = (void *)(a1 + 48);
      unsigned int v78 = (void *)(a1 + 96);
      unint64_t v80 = (void *)(a3 + 8);
      while (1)
      {
        if (v87 + 2 > v86)
        {
          int v73 = 162;
          char v74 = "propertyTypeValue.has_value()";
          char v75 = "Property Type could not be read";
          goto LABEL_154;
        }
        uint64_t v9 = v87 + 4;
        if (v87 + 4 > v86)
        {
          int v73 = 166;
          char v74 = "numPropertiesForType.has_value()";
          char v75 = "Property Count could not be read";
          goto LABEL_154;
        }
        unsigned int v10 = *(unsigned __int16 *)((char *)v85 + v87);
        v87 += 4;
        uint64_t v11 = *v8;
        if (!*v8) {
          goto LABEL_151;
        }
        int v12 = *(unsigned __int16 *)((char *)v85 + v9 - 2);
        uint64_t v13 = v8;
        do
        {
          unsigned int v14 = *(_DWORD *)(v11 + 28);
          BOOL v15 = v14 >= v10;
          if (v14 >= v10) {
            uint64_t v16 = (uint64_t *)v11;
          }
          else {
            uint64_t v16 = (uint64_t *)(v11 + 8);
          }
          if (v15) {
            uint64_t v13 = (void *)v11;
          }
          uint64_t v11 = *v16;
        }
        while (*v16);
        if (v13 == v8 || *((_DWORD *)v13 + 7) > v10)
        {
LABEL_151:
          int v73 = 169;
          char v74 = "decoderMapIter != propertyContext.decoderMap.end()";
          char v75 = "Property Type read from set that wasnt in the Property Info Chapter";
LABEL_154:
          printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v75, v74, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/TextLayerData_Generated.cpp", v73);
          char v5 = v6;
          return v5 & 1;
        }
        int v84 = v7;
        char v81 = v6;
        if (v12) {
          break;
        }
LABEL_147:
        int v7 = v84 + 1;
        char v5 = 1;
        BOOL v6 = v84 + 1 >= v82;
        unint64_t v8 = v80;
        if (v84 + 1 == v82) {
          return v5 & 1;
        }
      }
      int v17 = 0;
      while (1)
      {
        unint64_t v18 = v86;
        uint64_t v19 = v87;
        uint64_t v20 = v87 + 2;
        if (v86 < v87 + 2) {
          break;
        }
        v87 += 2;
        uint64_t v21 = *((unsigned __int8 *)v13 + 32);
        if (v10 <= 6
          && v21 == (0x41008040401uLL >> (8 * v10))
          && (unsigned int v22 = v85,
              unsigned int v23 = *(unsigned __int16 *)((char *)v85 + v19),
              grl::propertyTypeFromPropertyID(v23) == v10))
        {
          int v27 = (int *)((char *)v22 + v20);
          switch(v23)
          {
            case 2u:
              if (v19 + 6 <= v18)
              {
                int v28 = *v27;
                uint64_t v87 = v19 + 6;
                *(_DWORD *)(a1 + 72) = v28;
              }
              goto LABEL_28;
            case 3u:
              if (v19 + 6 <= v18)
              {
                int v29 = *v27;
                uint64_t v87 = v19 + 6;
                *(_DWORD *)(a1 + 136) = v29;
              }
              goto LABEL_28;
            case 4u:
              if (v19 + 6 <= v18)
              {
                int v30 = *v27;
                uint64_t v87 = v19 + 6;
                if (v19 + 10 <= v18)
                {
                  int v31 = *(_DWORD *)((char *)v22 + v19 + 6);
                  uint64_t v87 = v19 + 10;
                  *(_DWORD *)(a1 + 128) = v30;
                  *(_DWORD *)(a1 + 132) = v31;
                }
              }
              goto LABEL_28;
            case 5u:
              if (v19 + 3 > v18)
              {
                unint64_t v32 = v19 + 3;
              }
              else
              {
                uint64_t v87 = v19 + 3;
                char v24 = *(unsigned char *)v27;
                unint64_t v32 = v19 + 4;
                uint64_t v20 = v19 + 3;
              }
              if (v32 > v18)
              {
                unint64_t v49 = v32;
              }
              else
              {
                uint64_t v87 = v32;
                char v25 = *((unsigned char *)v22 + v20);
                unint64_t v49 = v32 + 1;
                uint64_t v20 = v32;
              }
              if (v49 > v18)
              {
                unint64_t v54 = v49;
              }
              else
              {
                uint64_t v87 = v49;
                char v26 = *((unsigned char *)v22 + v20);
                unint64_t v54 = v49 + 1;
                uint64_t v20 = v49;
              }
              if (v54 <= v18)
              {
                uint64_t v87 = v54;
                if (v19 + 3 <= v18 && v32 <= v18 && v49 <= v18)
                {
                  char v59 = *((unsigned char *)v22 + v20);
                  *(unsigned char *)(a1 + 32) = v24;
                  *(unsigned char *)(a1 + 33) = v25;
                  *(unsigned char *)(a1 + 34) = v26;
                  *(unsigned char *)(a1 + 35) = v59;
                }
              }
              goto LABEL_28;
            case 6u:
              if (v19 + 3 > v18)
              {
                unint64_t v33 = v19 + 3;
              }
              else
              {
                uint64_t v87 = v19 + 3;
                char v24 = *(unsigned char *)v27;
                unint64_t v33 = v19 + 4;
                uint64_t v20 = v19 + 3;
              }
              if (v33 > v18)
              {
                unint64_t v50 = v33;
              }
              else
              {
                uint64_t v87 = v33;
                char v25 = *((unsigned char *)v22 + v20);
                unint64_t v50 = v33 + 1;
                uint64_t v20 = v33;
              }
              if (v50 > v18)
              {
                unint64_t v55 = v50;
              }
              else
              {
                uint64_t v87 = v50;
                char v26 = *((unsigned char *)v22 + v20);
                unint64_t v55 = v50 + 1;
                uint64_t v20 = v50;
              }
              if (v55 <= v18)
              {
                uint64_t v87 = v55;
                if (v19 + 3 <= v18 && v33 <= v18 && v50 <= v18)
                {
                  char v60 = *((unsigned char *)v22 + v20);
                  *(unsigned char *)(a1 + 68) = v24;
                  *(unsigned char *)(a1 + 69) = v25;
                  *(unsigned char *)(a1 + 70) = v26;
                  *(unsigned char *)(a1 + 71) = v60;
                }
              }
              goto LABEL_28;
            case 7u:
              if (v19 + 3 > v18)
              {
                unint64_t v34 = v19 + 3;
              }
              else
              {
                uint64_t v87 = v19 + 3;
                char v24 = *(unsigned char *)v27;
                unint64_t v34 = v19 + 4;
                uint64_t v20 = v19 + 3;
              }
              if (v34 > v18)
              {
                unint64_t v51 = v34;
              }
              else
              {
                uint64_t v87 = v34;
                char v25 = *((unsigned char *)v22 + v20);
                unint64_t v51 = v34 + 1;
                uint64_t v20 = v34;
              }
              if (v51 > v18)
              {
                unint64_t v56 = v51;
              }
              else
              {
                uint64_t v87 = v51;
                char v26 = *((unsigned char *)v22 + v20);
                unint64_t v56 = v51 + 1;
                uint64_t v20 = v51;
              }
              if (v56 <= v18)
              {
                uint64_t v87 = v56;
                if (v19 + 3 <= v18 && v34 <= v18 && v51 <= v18)
                {
                  char v61 = *((unsigned char *)v22 + v20);
                  *(unsigned char *)(a1 + 124) = v24;
                  *(unsigned char *)(a1 + 125) = v25;
                  *(unsigned char *)(a1 + 126) = v26;
                  *(unsigned char *)(a1 + 127) = v61;
                }
              }
              goto LABEL_28;
            case 0xAu:
              if (v19 + 6 <= v18)
              {
                int v35 = *v27;
                uint64_t v87 = v19 + 6;
                if (v19 + 10 <= v18)
                {
                  int v36 = *(_DWORD *)((char *)v22 + v19 + 6);
                  uint64_t v87 = v19 + 10;
                  *(_DWORD *)(a1 + 76) = v35;
                  *(_DWORD *)(a1 + 80) = v36;
                }
              }
              goto LABEL_28;
            case 0xFu:
              if (v19 + 3 <= v18)
              {
                uint64_t v87 = v19 + 3;
                *(unsigned char *)(a1 + 176) = *(unsigned char *)v27 != 0;
              }
              goto LABEL_28;
            case 0x16u:
              if (v19 + 6 <= v18)
              {
                int v37 = *v27;
                uint64_t v87 = v19 + 6;
                *(_DWORD *)(a1 + 64) = v37;
              }
              goto LABEL_28;
            case 0x17u:
              if (v19 + 6 <= v18)
              {
                int v38 = *v27;
                uint64_t v87 = v19 + 6;
                *(_DWORD *)(a1 + 112) = v38;
              }
              goto LABEL_28;
            case 0x18u:
              if (v18 == v20) {
                goto LABEL_28;
              }
              size_t v39 = 0;
              while (*((unsigned char *)v22 + v19 + v39 + 2))
              {
                if (v18 - v20 == ++v39) {
                  goto LABEL_28;
                }
              }
              std::string::basic_string[abi:nn180100](&__dst, v27, v39);
              uint64_t v87 = v19 + v39 + 3;
              uint64_t v64 = __dst;
              v91[0] = *(void *)v89;
              *(void *)((char *)v91 + 7) = *(void *)&v89[7];
              char v65 = v90;
              uint64_t v66 = a1;
              if (*(char *)(a1 + 63) < 0)
              {
                operator delete(*(void **)(a1 + 40));
                uint64_t v66 = a1;
              }
              *(void *)(v66 + 40) = v64;
              *char v77 = v91[0];
              *(void *)((char *)v77 + 7) = *(void *)((char *)v91 + 7);
              *(unsigned char *)(v66 + 63) = v65;
              goto LABEL_28;
            case 0x19u:
              if (v18 == v20) {
                goto LABEL_28;
              }
              size_t v40 = 0;
              while (*((unsigned char *)v22 + v19 + v40 + 2))
              {
                if (v18 - v20 == ++v40) {
                  goto LABEL_28;
                }
              }
              std::string::basic_string[abi:nn180100](&__dst, v27, v40);
              uint64_t v87 = v19 + v40 + 3;
              uint64_t v67 = __dst;
              v91[0] = *(void *)v89;
              *(void *)((char *)v91 + 7) = *(void *)&v89[7];
              char v68 = v90;
              uint64_t v69 = a1;
              if (*(char *)(a1 + 111) < 0)
              {
                operator delete(*(void **)(a1 + 88));
                uint64_t v69 = a1;
              }
              *(void *)(v69 + 88) = v67;
              *unsigned int v78 = v91[0];
              *(void *)((char *)v78 + 7) = *(void *)((char *)v91 + 7);
              *(unsigned char *)(v69 + 111) = v68;
              goto LABEL_28;
            case 0x1Au:
              if (v19 + 3 > v18)
              {
                unint64_t v41 = v19 + 3;
              }
              else
              {
                uint64_t v87 = v19 + 3;
                char v24 = *(unsigned char *)v27;
                unint64_t v41 = v19 + 4;
                uint64_t v20 = v19 + 3;
              }
              if (v41 > v18)
              {
                unint64_t v52 = v41;
              }
              else
              {
                uint64_t v87 = v41;
                char v25 = *((unsigned char *)v22 + v20);
                unint64_t v52 = v41 + 1;
                uint64_t v20 = v41;
              }
              if (v52 > v18)
              {
                unint64_t v57 = v52;
              }
              else
              {
                uint64_t v87 = v52;
                char v26 = *((unsigned char *)v22 + v20);
                unint64_t v57 = v52 + 1;
                uint64_t v20 = v52;
              }
              if (v57 <= v18)
              {
                uint64_t v87 = v57;
                if (v19 + 3 <= v18 && v41 <= v18 && v52 <= v18)
                {
                  char v62 = *((unsigned char *)v22 + v20);
                  *(unsigned char *)(a1 + 84) = v24;
                  *(unsigned char *)(a1 + 85) = v25;
                  *(unsigned char *)(a1 + 86) = v26;
                  *(unsigned char *)(a1 + 87) = v62;
                }
              }
              goto LABEL_28;
            case 0x1Cu:
              if (v18 == v20) {
                goto LABEL_28;
              }
              size_t v42 = 0;
              break;
            case 0x1Du:
              if (v19 + 6 <= v18)
              {
                int v43 = *v27;
                uint64_t v87 = v19 + 6;
                *(_DWORD *)(a1 + 120) = v43;
              }
              goto LABEL_28;
            case 0x1Eu:
              if (v19 + 3 > v18)
              {
                unint64_t v44 = v19 + 3;
              }
              else
              {
                uint64_t v87 = v19 + 3;
                char v24 = *(unsigned char *)v27;
                unint64_t v44 = v19 + 4;
                uint64_t v20 = v19 + 3;
              }
              if (v44 > v18)
              {
                unint64_t v53 = v44;
              }
              else
              {
                uint64_t v87 = v44;
                char v25 = *((unsigned char *)v22 + v20);
                unint64_t v53 = v44 + 1;
                uint64_t v20 = v44;
              }
              if (v53 > v18)
              {
                unint64_t v58 = v53;
              }
              else
              {
                uint64_t v87 = v53;
                char v26 = *((unsigned char *)v22 + v20);
                unint64_t v58 = v53 + 1;
                uint64_t v20 = v53;
              }
              if (v58 <= v18)
              {
                uint64_t v87 = v58;
                if (v19 + 3 <= v18 && v44 <= v18 && v53 <= v18)
                {
                  char v63 = *((unsigned char *)v22 + v20);
                  *(unsigned char *)(a1 + 116) = v24;
                  *(unsigned char *)(a1 + 117) = v25;
                  *(unsigned char *)(a1 + 118) = v26;
                  *(unsigned char *)(a1 + 119) = v63;
                }
              }
              goto LABEL_28;
            case 0x1Fu:
              *(unsigned char *)(a1 + 177) = 1;
              if (v19 + 6 <= v18)
              {
                int v45 = *v27;
                uint64_t v87 = v19 + 6;
                if (v19 + 10 <= v18)
                {
                  int v46 = *(_DWORD *)((char *)v22 + v19 + 6);
                  uint64_t v87 = v19 + 10;
                  *(_DWORD *)(a1 + 168) = v45;
                  *(_DWORD *)(a1 + 172) = v46;
                }
              }
              goto LABEL_28;
            case 0x23u:
              if (v19 + 6 <= v18)
              {
                uint64_t v87 = v19 + 6;
                int v48 = *(_DWORD *)((char *)v22 + v19 + 2);
                uint64_t v47 = a1;
              }
              else
              {
                uint64_t v47 = a1;
                LOBYTE(v48) = *(unsigned char *)(a1 + 36);
              }
              *(unsigned char *)(v47 + 36) = v48;
              goto LABEL_28;
            default:
              goto LABEL_27;
          }
          while (*((unsigned char *)v22 + v19 + v42 + 2))
          {
            if (v18 - v20 == ++v42) {
              goto LABEL_28;
            }
          }
          std::string::basic_string[abi:nn180100](&__dst, v27, v42);
          uint64_t v87 = v19 + v42 + 3;
          uint64_t v70 = __dst;
          v91[0] = *(void *)v89;
          *(void *)((char *)v91 + 7) = *(void *)&v89[7];
          char v71 = v90;
          uint64_t v72 = a1;
          if (*(char *)(a1 + 167) < 0)
          {
            operator delete(*(void **)(a1 + 144));
            uint64_t v72 = a1;
          }
          *(void *)(v72 + 144) = v70;
          *int v79 = v91[0];
          *(void *)((char *)v79 + 7) = *(void *)((char *)v91 + 7);
          *(unsigned char *)(v72 + 167) = v71;
        }
        else
        {
LABEL_27:
          grl::SkipStreamBytes(&v85, v21);
        }
LABEL_28:
        if (++v17 == v12) {
          goto LABEL_147;
        }
      }
      printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property ID could not be read", "propertyIDValue.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/TextLayerData_Generated.cpp", 173);
      char v5 = v81;
    }
    else
    {
      char v5 = 1;
    }
  }
  else
  {
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Property Type Count could not be read", "numPropertyTypes.has_value()", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/TextLayerData_Generated.cpp", 158);
    char v5 = 0;
  }
  return v5 & 1;
}

uint64_t geo::LRUPolicy<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>,grl::codec::IconConfigPack::IconLocationIndexHash>::get(uint64_t a1, void *a2, unsigned __int8 *a3)
{
  unint64_t v4 = std::__hash_table<std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,std::__unordered_map_hasher<grl::codec::IconConfigPack::IconLocationIndex,std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,grl::codec::IconConfigPack::IconLocationIndexHash,std::equal_to<grl::codec::IconConfigPack::IconLocationIndex>,true>,std::__unordered_map_equal<grl::codec::IconConfigPack::IconLocationIndex,std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,std::equal_to<grl::codec::IconConfigPack::IconLocationIndex>,grl::codec::IconConfigPack::IconLocationIndexHash,true>,std::allocator<std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>>>::find<grl::codec::IconConfigPack::IconLocationIndex>(a2, a3);
  if (v4)
  {
    char v5 = *(uint64_t **)(a1 + 8);
    BOOL v6 = v4[3];
    if (v5 == v6) {
      return *(void *)(a1 + 8);
    }
    int v7 = (uint64_t *)v6[1];
    if (v7 == v5)
    {
      return *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v8 = *v6;
      *(void *)(v8 + 8) = v7;
      *(void *)v6[1] = v8;
      uint64_t v9 = *v5;
      *(void *)(v9 + 8) = v6;
      uint64_t *v6 = v9;
      uint64_t *v5 = (uint64_t)v6;
      v6[1] = (uint64_t)v5;
      return *(void *)(a1 + 8);
    }
  }
  return a1;
}

uint64_t **std::__hash_table<std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,std::__unordered_map_hasher<grl::codec::IconConfigPack::IconLocationIndex,std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,grl::codec::IconConfigPack::IconLocationIndexHash,std::equal_to<grl::codec::IconConfigPack::IconLocationIndex>,true>,std::__unordered_map_equal<grl::codec::IconConfigPack::IconLocationIndex,std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,std::equal_to<grl::codec::IconConfigPack::IconLocationIndex>,grl::codec::IconConfigPack::IconLocationIndexHash,true>,std::allocator<std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>>>::find<grl::codec::IconConfigPack::IconLocationIndex>(void *a1, unsigned __int8 *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = *((unsigned __int16 *)a2 + 1);
  unint64_t v5 = (v4
      + ((v3 - 0x61C8864680B583EBLL) << 6)
      + ((unint64_t)(v3 - 0x61C8864680B583EBLL) >> 2)
      - 0x61C8864680B583EBLL) ^ (v3 - 0x61C8864680B583EBLL);
  uint64_t v6 = *((unsigned __int16 *)a2 + 2);
  unint64_t v7 = (v6 + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583EBLL) ^ v5;
  uint8x8_t v8 = (uint8x8_t)vcnt_s8(v2);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    uint64_t v9 = (v6 + (v5 << 6) + (v5 >> 2) - 0x61C8864680B583EBLL) ^ v5;
    if (v7 >= *(void *)&v2) {
      uint64_t v9 = v7 % *(void *)&v2;
    }
  }
  else
  {
    uint64_t v9 = v7 & (*(void *)&v2 - 1);
  }
  unsigned int v10 = *(uint64_t ****)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (uint64_t result = *v10; result; uint64_t result = (uint64_t **)*result)
  {
    unint64_t v12 = (unint64_t)result[1];
    if (v12 == v7)
    {
      if (*((unsigned __int8 *)result + 16) == v3
        && __PAIR64__(*((unsigned __int16 *)result + 10), *((unsigned __int16 *)result + 9)) == __PAIR64__(v6, v4))
      {
        return result;
      }
    }
    else
    {
      if (v8.u32[0] > 1uLL)
      {
        if (v12 >= *(void *)&v2) {
          v12 %= *(void *)&v2;
        }
      }
      else
      {
        v12 &= *(void *)&v2 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return result;
}

void *std::__tree<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,std::__map_value_compare<grl::IconKey,std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,std::less<grl::IconKey>,true>,geo::StdAllocator<std::__value_type<grl::IconKey,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>::find<grl::IconKey>(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = (void *)(a1 + 8);
  uint64_t v3 = *(void **)(a1 + 8);
  if (!v3) {
    return v2;
  }
  unint64_t v5 = (void *)(a1 + 8);
  do
  {
    BOOL v6 = grl::IconKey::operator<((uint64_t)(v3 + 4), a2);
    unint64_t v7 = v3 + 1;
    if (!v6)
    {
      unint64_t v7 = v3;
      unint64_t v5 = v3;
    }
    uint64_t v3 = (void *)*v7;
  }
  while (*v7);
  if (v5 == v2 || grl::IconKey::operator<(a2, (uint64_t)(v5 + 4))) {
    return v2;
  }
  return v5;
}

BOOL grl::IconKey::operator<(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(a2 + 16);
  BOOL v4 = v2 >= v3;
  if (v2 == v3)
  {
    unsigned int v5 = *(unsigned __int16 *)(a1 + 20);
    unsigned int v6 = *(unsigned __int16 *)(a2 + 20);
    BOOL v4 = v5 >= v6;
    if (v5 == v6)
    {
      unsigned int v7 = *(unsigned __int16 *)(a1 + 22);
      unsigned int v8 = *(unsigned __int16 *)(a2 + 22);
      BOOL v4 = v7 >= v8;
      if (v7 == v8) {
        BOOL v4 = *(unsigned __int8 *)(a1 + 24) >= *(unsigned __int8 *)(a2 + 24);
      }
    }
  }
  return !v4;
}

uint64_t geo::Cache<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>,grl::codec::IconConfigPack::IconLocationIndexHash,geo::LRUPolicy>::operator[](uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v5 = a1 + 48;
  unsigned int v6 = (void **)(a1 + 8);
  uint64_t v7 = geo::LRUPolicy<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>,grl::codec::IconConfigPack::IconLocationIndexHash>::get(a1 + 48, (void *)(a1 + 8), a2);
  if (v5 != v7) {
    return v7 + 24;
  }
  unsigned int v8 = std::__hash_table<std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,std::__unordered_map_hasher<grl::codec::IconConfigPack::IconLocationIndex,std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,grl::codec::IconConfigPack::IconLocationIndexHash,std::equal_to<grl::codec::IconConfigPack::IconLocationIndex>,true>,std::__unordered_map_equal<grl::codec::IconConfigPack::IconLocationIndex,std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,std::equal_to<grl::codec::IconConfigPack::IconLocationIndex>,grl::codec::IconConfigPack::IconLocationIndexHash,true>,std::allocator<std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>>>::find<grl::codec::IconConfigPack::IconLocationIndex>(v6, a2);
  if (v8)
  {
    uint64_t v9 = (uint64_t *)v8;
    unsigned int v10 = v8[3];
    uint64_t v11 = *v10;
    *(void *)(v11 + 8) = v10[1];
    *(void *)v10[1] = v11;
    --*(void *)(a1 + 64);
    unint64_t v12 = (std::__shared_weak_count *)v10[4];
    if (v12) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v12);
    }
    operator delete(v10);
    std::__hash_table<std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,std::__unordered_map_hasher<grl::codec::IconConfigPack::IconLocationIndex,std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,grl::codec::IconConfigPack::IconLocationIndexHash,std::equal_to<grl::codec::IconConfigPack::IconLocationIndex>,true>,std::__unordered_map_equal<grl::codec::IconConfigPack::IconLocationIndex,std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>,std::equal_to<grl::codec::IconConfigPack::IconLocationIndex>,grl::codec::IconConfigPack::IconLocationIndexHash,true>,std::allocator<std::__hash_value_type<grl::codec::IconConfigPack::IconLocationIndex,std::__list_iterator<std::pair<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>>,void *>>>>::erase(v6, v9);
  }
  uint64_t v13 = operator new(0x28uLL);
  v13[4] = *(_DWORD *)a2;
  uint64_t v14 = *((unsigned __int16 *)a2 + 2);
  *((_WORD *)v13 + 10) = v14;
  *((void *)v13 + 3) = 0;
  *((void *)v13 + 4) = 0;
  BOOL v15 = *(void **)(a1 + 56);
  uint64_t v16 = *(void *)(a1 + 64);
  *(void *)uint64_t v13 = v5;
  *((void *)v13 + 1) = v15;
  void *v15 = v13;
  unint64_t v17 = v16 + 1;
  *(void *)(a1 + 56) = v13;
  *(void *)(a1 + 64) = v16 + 1;
  uint64_t v18 = *a2;
  uint64_t v19 = *((unsigned __int16 *)a2 + 1);
  unint64_t v20 = (v19
       + ((v18 - 0x61C8864680B583EBLL) << 6)
       + ((unint64_t)(v18 - 0x61C8864680B583EBLL) >> 2)
       - 0x61C8864680B583EBLL) ^ (v18 - 0x61C8864680B583EBLL);
  unint64_t v21 = v14 + (v20 << 6) + (v20 >> 2);
  unint64_t v22 = (v21 - 0x61C8864680B583EBLL) ^ v20;
  unint64_t v23 = *(void *)(a1 + 16);
  if (v23)
  {
    uint8x8_t v24 = (uint8x8_t)vcnt_s8((int8x8_t)v23);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      uint64_t v2 = (v21 - 0x61C8864680B583EBLL) ^ v20;
      if (v22 >= v23) {
        uint64_t v2 = v22 % v23;
      }
    }
    else
    {
      uint64_t v2 = v22 & (v23 - 1);
    }
    char v25 = (uint64_t ***)*((void *)*v6 + v2);
    if (v25)
    {
      for (char i = *v25; i; char i = (uint64_t **)*i)
      {
        unint64_t v27 = (unint64_t)i[1];
        if (v27 == v22)
        {
          if (*((unsigned __int8 *)i + 16) == v18
            && __PAIR64__(*((unsigned __int16 *)i + 10), *((unsigned __int16 *)i + 9)) == __PAIR64__(v14, v19))
          {
            goto LABEL_80;
          }
        }
        else
        {
          if (v24.u32[0] > 1uLL)
          {
            if (v27 >= v23) {
              v27 %= v23;
            }
          }
          else
          {
            v27 &= v23 - 1;
          }
          if (v27 != v2) {
            break;
          }
        }
      }
    }
  }
  int v28 = operator new(0x20uLL);
  void *v28 = 0;
  v28[1] = v22;
  *((_DWORD *)v28 + 4) = *(_DWORD *)a2;
  *((_WORD *)v28 + 10) = *((_WORD *)a2 + 2);
  v28[3] = v13;
  float v29 = (float)(unint64_t)(*(void *)(a1 + 32) + 1);
  float v30 = *(float *)(a1 + 40);
  if (!v23 || (float)(v30 * (float)v23) < v29)
  {
    BOOL v31 = 1;
    if (v23 >= 3) {
      BOOL v31 = (v23 & (v23 - 1)) != 0;
    }
    unint64_t v32 = v31 | (2 * v23);
    unint64_t v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33) {
      int8x8_t prime = (int8x8_t)v33;
    }
    else {
      int8x8_t prime = (int8x8_t)v32;
    }
    if (*(void *)&prime == 1)
    {
      int8x8_t prime = (int8x8_t)2;
    }
    else if ((*(void *)&prime & (*(void *)&prime - 1)) != 0)
    {
      int8x8_t prime = (int8x8_t)std::__next_prime(*(void *)&prime);
      unint64_t v23 = *(void *)(a1 + 16);
    }
    if (*(void *)&prime > v23) {
      goto LABEL_36;
    }
    if (*(void *)&prime < v23)
    {
      unint64_t v41 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 32) / *(float *)(a1 + 40));
      if (v23 < 3 || (uint8x8_t v42 = (uint8x8_t)vcnt_s8((int8x8_t)v23), v42.i16[0] = vaddlv_u8(v42), v42.u32[0] > 1uLL))
      {
        unint64_t v41 = std::__next_prime(v41);
      }
      else
      {
        uint64_t v43 = 1 << -(char)__clz(v41 - 1);
        if (v41 >= 2) {
          unint64_t v41 = v43;
        }
      }
      if (*(void *)&prime <= v41) {
        int8x8_t prime = (int8x8_t)v41;
      }
      if (*(void *)&prime >= v23)
      {
        unint64_t v23 = *(void *)(a1 + 16);
      }
      else
      {
        if (prime)
        {
LABEL_36:
          if (*(void *)&prime >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          int v35 = operator new(8 * *(void *)&prime);
          int v36 = *v6;
          uint64_t *v6 = v35;
          if (v36) {
            operator delete(v36);
          }
          uint64_t v37 = 0;
          *(int8x8_t *)(a1 + 16) = prime;
          do
            *((void *)*v6 + v37++) = 0;
          while (*(void *)&prime != v37);
          int v38 = *(void **)(a1 + 24);
          if (v38)
          {
            unint64_t v39 = v38[1];
            uint8x8_t v40 = (uint8x8_t)vcnt_s8(prime);
            v40.i16[0] = vaddlv_u8(v40);
            if (v40.u32[0] > 1uLL)
            {
              if (v39 >= *(void *)&prime) {
                v39 %= *(void *)&prime;
              }
            }
            else
            {
              v39 &= *(void *)&prime - 1;
            }
            *((void *)*v6 + v39) = a1 + 24;
            unint64_t v44 = (void *)*v38;
            if (*v38)
            {
              do
              {
                unint64_t v45 = v44[1];
                if (v40.u32[0] > 1uLL)
                {
                  if (v45 >= *(void *)&prime) {
                    v45 %= *(void *)&prime;
                  }
                }
                else
                {
                  v45 &= *(void *)&prime - 1;
                }
                if (v45 != v39)
                {
                  if (!*((void *)*v6 + v45))
                  {
                    *((void *)*v6 + v45) = v38;
                    goto LABEL_61;
                  }
                  *int v38 = *v44;
                  *unint64_t v44 = **((void **)*v6 + v45);
                  **((void **)*v6 + v45) = v44;
                  unint64_t v44 = v38;
                }
                unint64_t v45 = v39;
LABEL_61:
                int v38 = v44;
                unint64_t v44 = (void *)*v44;
                unint64_t v39 = v45;
              }
              while (v44);
            }
          }
          unint64_t v23 = (unint64_t)prime;
          goto LABEL_65;
        }
        unint64_t v51 = *v6;
        uint64_t *v6 = 0;
        if (v51) {
          operator delete(v51);
        }
        unint64_t v23 = 0;
        *(void *)(a1 + 16) = 0;
      }
    }
LABEL_65:
    if ((v23 & (v23 - 1)) != 0)
    {
      if (v22 >= v23) {
        uint64_t v2 = v22 % v23;
      }
      else {
        uint64_t v2 = v22;
      }
    }
    else
    {
      uint64_t v2 = (v23 - 1) & v22;
    }
  }
  int v46 = *v6;
  uint64_t v47 = (void *)*((void *)*v6 + v2);
  if (v47)
  {
    void *v28 = *v47;
  }
  else
  {
    uint64_t v48 = *(void *)(a1 + 24);
    void *v28 = v48;
    *(void *)(a1 + 24) = v28;
    v46[v2] = a1 + 24;
    if (!v48) {
      goto LABEL_79;
    }
    unint64_t v49 = *(void *)(v48 + 8);
    if ((v23 & (v23 - 1)) != 0)
    {
      if (v49 >= v23) {
        v49 %= v23;
      }
    }
    else
    {
      v49 &= v23 - 1;
    }
    uint64_t v47 = (char *)*v6 + 8 * v49;
  }
  void *v47 = v28;
LABEL_79:
  ++*(void *)(a1 + 32);
  unint64_t v17 = *(void *)(a1 + 64);
LABEL_80:
  if (v17 > *(void *)a1)
  {
    do
      geo::Cache<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>,grl::codec::IconConfigPack::IconLocationIndexHash,geo::LRUPolicy>::_pop(a1);
    while (*(void *)(a1 + 64) > *(void *)a1);
  }
  uint64_t v7 = *(void *)(a1 + 56);
  return v7 + 24;
}

BOOL grl::codec::ResourcePack::decodePackChunk(uint64_t a1, uint64_t *a2, uint64_t a3, unint64_t a4, unint64_t *a5)
{
  uint64_t v5 = *a2;
  if (*a2)
  {
    std::istream::seekg();
    unint64_t v8 = a5[1] - *a5;
    BOOL v9 = a4 >= v8;
    size_t v10 = a4 - v8;
    if (v10 != 0 && v9)
    {
      std::vector<unsigned char>::__append(a5, v10);
    }
    else if (!v9)
    {
      a5[1] = *a5 + a4;
    }
    std::istream::read();
  }
  else
  {
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", "Pack Stream Is Invalid", "packStream", "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/ResourcePack.cpp", 324);
  }
  return v5 != 0;
}

void __destroy_helper_block_ea8_32c47_ZTSNSt3__18weak_ptrIN2md17RunLoopControllerEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 40);
  if (v1) {
    std::__shared_weak_count::__release_weak(v1);
  }
}

void md::StandardLabeler::layoutForStaging(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = a2;
  if (!(*a2 | a2[1])) {
    goto LABEL_129;
  }
  uint64_t v4 = *(void *)(a1 + 48);
  LODWORD(v5) = *(unsigned __int8 *)(*(void *)(*(void *)(v4 + 8) + 432) + 28);
  if (!*(unsigned char *)(v4 + 760) || *(unsigned __int8 *)(v4 + 756) != v5)
  {
    unsigned int v6 = (id *)&v191;
    uint64_t v7 = (uint64_t *)&v192;
    BOOL v9 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
LABEL_380:
        operator new();
    }
    uint64_t v10 = *((void *)v9 + 91);
    uint64_t v11 = *(float **)(v4 + 672);
    unint64_t v12 = *(void **)(v4 + 680);
    *(void *)(v4 + 680) = 0;
    v191 = v11;
    v192 = v12;
    uint64_t v13 = *(void *)(v4 + 696);
    *(void *)(v4 + 696) = 0;
    uint64_t v193 = v10;
    uint64_t v194 = v13;
    *(void *)(v4 + 672) = v4 + 680;
    uint64_t v14 = (id *)(v12 + 2);
    if (!v13) {
      uint64_t v14 = v6;
    }
    *uint64_t v14 = v7;
    md::LabelPool::addGlobalFeatureLabels(v4, (int)v5, *(void **)(*(void *)(v4 + 624) + 136), *(void **)(*(void *)(v4 + 624) + 144));
    md::LabelPool::addGlobalFeatureLabels(v4, (int)v5, *(void **)(*(void *)(v4 + 632) + 8), *(void **)(*(void *)(v4 + 632) + 16));
    uint64_t v15 = *(void *)(v4 + 704);
    if (!v15) {
      goto LABEL_59;
    }
    unint64_t v16 = *(void *)(*(void *)(v15 + 8) + 72);
    unsigned int v17 = *(_DWORD *)(v15 + 48);
    std::mutex::lock((std::mutex *)(v4 + 480));
    uint64_t v18 = (uint64_t *)(v4 + 552);
    uint64_t v19 = *(void *)(v4 + 552);
    if (v19)
    {
      uint64_t v20 = v4 + 552;
      uint64_t v21 = *(void *)(v4 + 552);
      do
      {
        unint64_t v22 = *(void *)(v21 + 32);
        BOOL v24 = v22 == v16;
        BOOL v23 = v22 < v16;
        if (v24) {
          BOOL v23 = *(_DWORD *)(v21 + 40) < v17;
        }
        BOOL v24 = !v23;
        if (v23) {
          char v25 = (uint64_t *)(v21 + 8);
        }
        else {
          char v25 = (uint64_t *)v21;
        }
        if (v24) {
          uint64_t v20 = v21;
        }
        uint64_t v21 = *v25;
      }
      while (*v25);
      if ((uint64_t *)v20 != v18)
      {
        unint64_t v26 = *(void *)(v20 + 32);
        BOOL v27 = v17 < *(_DWORD *)(v20 + 40);
        BOOL v24 = v16 == v26;
        BOOL v28 = v16 < v26;
        if (!v24) {
          BOOL v27 = v28;
        }
        if (!v27) {
          goto LABEL_44;
        }
      }
      while (1)
      {
        while (1)
        {
          uint64_t v29 = v19;
          unint64_t v30 = *(void *)(v19 + 32);
          unsigned int v31 = *(_DWORD *)(v29 + 40);
          BOOL v32 = v17 < v31;
          if (v16 != v30) {
            BOOL v32 = v16 < v30;
          }
          if (!v32) {
            break;
          }
          uint64_t v19 = *(void *)v29;
          uint64_t v18 = (uint64_t *)v29;
          if (!*(void *)v29) {
            goto LABEL_35;
          }
        }
        BOOL v33 = v31 < v17;
        int v34 = v16 == v30 ? v33 : v30 < v16;
        if (v34 != 1) {
          break;
        }
        uint64_t v19 = *(void *)(v29 + 8);
        if (!v19)
        {
          uint64_t v18 = (uint64_t *)(v29 + 8);
          goto LABEL_35;
        }
      }
      uint64_t v35 = v29;
    }
    else
    {
      uint64_t v29 = v4 + 552;
LABEL_35:
      uint64_t v35 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v4 + 560) + 16))(*(void *)(v4 + 560), 64, 8);
      *(void *)(v35 + 32) = v16;
      *(_DWORD *)(v35 + 40) = v17;
      *(void *)(v35 + 48) = 0;
      *(void *)(v35 + 56) = 0;
      *(void *)uint64_t v35 = 0;
      *(void *)(v35 + 8) = 0;
      *(void *)(v35 + 16) = v29;
      uint64_t *v18 = v35;
      uint64_t v36 = **(void **)(v4 + 544);
      uint64_t v37 = (uint64_t *)v35;
      if (v36)
      {
        *(void *)(v4 + 544) = v36;
        uint64_t v37 = (uint64_t *)*v18;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v4 + 552), v37);
      ++*(void *)(v4 + 568);
    }
    BOOL v9 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    uint64_t v38 = *(void *)(v4 + 704);
    uint64_t v39 = *(void *)(v4 + 712);
    if (v39) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v39 + 8), 1uLL, memory_order_relaxed);
    }
    uint8x8_t v40 = *(std::__shared_weak_count **)(v35 + 56);
    *(void *)(v35 + 48) = v38;
    *(void *)(v35 + 56) = v39;
    if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
    ++*(_DWORD *)(v4 + 744);
LABEL_44:
    std::mutex::unlock((std::mutex *)(v4 + 480));
    uint64_t v41 = *(void *)(v4 + 704);
    uint64_t v43 = *(void *)(v41 + 8);
    uint8x8_t v42 = *(std::__shared_weak_count **)(v41 + 16);
    if (v42) {
      atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    if ((atomic_load_explicit((atomic_uchar *volatile)v8, memory_order_acquire) & 1) == 0
    {
      operator new();
    }
    uint64_t v44 = *((void *)v9 + 91);
    unint64_t v45 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v44 + 16))(v44, 16, 8);
    int v46 = v45;
    if (v45)
    {
      void *v45 = v43;
      v45[1] = v42;
      if (v42) {
        atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    md::LabelPool::addGlobalFeatureLabels(v4, (int)v5, v45, v45 + 2);
    if (v46)
    {
      uint64_t v47 = (std::__shared_weak_count *)v46[1];
      if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v44 + 40))(v44, v46, 16);
    }
    if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
    *(unsigned char *)(v4 + 757) = 0;
LABEL_59:
    uint64_t v48 = v191;
    if (v191 != (float *)v7)
    {
      do
      {
        uint64_t v49 = *((void *)v48 + 4);
        if (atomic_fetch_add((atomic_uchar *volatile)(v49 + 1296), 0xFFu) == 1)
        {
          if (*(unsigned char *)(v49 + 1264))
          {
            *(unsigned char *)(v49 + 1261) = 1;
            *(void *)(v49 + 1224) = 0;
          }
          else
          {
            md::Label::updateStateMachineForStaging(v49, 1, 37);
          }
        }
        unint64_t v50 = (uint64_t *)*((void *)v48 + 1);
        if (v50)
        {
          do
          {
            unint64_t v51 = v50;
            unint64_t v50 = (uint64_t *)*v50;
          }
          while (v50);
        }
        else
        {
          do
          {
            unint64_t v51 = (uint64_t *)*((void *)v48 + 2);
            BOOL v24 = *v51 == (void)v48;
            uint64_t v48 = (float *)v51;
          }
          while (!v24);
        }
        uint64_t v48 = (float *)v51;
      }
      while (v51 != v7);
    }
    *(unsigned char *)(v4 + 756) = (_BYTE)v5;
    *(unsigned char *)(v4 + 760) = 1;
    std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy((uint64_t)&v191, v192);
  }
  uint64_t v52 = *(void *)(v4 + 704);
  if (v52)
  {
    unint64_t v53 = (md::LabelPoint *)(*(uint64_t (**)(void, uint64_t))(**(void **)(v52 + 8) + 112))(*(void *)(v52 + 8), v52 + 48);
    if (*((unsigned char *)v53 + 46))
    {
      uint64_t v54 = md::LabelPoint::mercatorPoint(v53);
      unint64_t v55 = *(uint64_t **)(v4 + 16);
      unint64_t v56 = *(uint64_t **)(v4 + 24);
      if (v55 != v56)
      {
        unint64_t v57 = (double *)v54;
        do
        {
          uint64_t v58 = *v55;
          if (*(unsigned __int8 *)(*v55 + 8) == 255)
          {
            unsigned int v59 = *(unsigned __int8 *)(v58 + 9);
            if (v59 > *(unsigned __int8 *)(v4 + 757) && *v57 >= *(double *)(v58 + 40) && *v57 <= *(double *)(v58 + 56))
            {
              double v60 = v57[1];
              if (v60 >= *(double *)(v58 + 48) && v60 <= *(double *)(v58 + 64))
              {
                *(unsigned char *)(v4 + 757) = v59;
                (*(void (**)(uint64_t, void))(*(void *)v58 + 24))(v58, *(void *)(v4 + 704));
              }
            }
          }
          v55 += 2;
        }
        while (v55 != v56);
      }
    }
  }
  if (*v2 | v2[5])
  {
    uint64_t v67 = *(unsigned char ***)(v4 + 16);
    char v68 = *(unsigned char ***)(v4 + 24);
    while (v67 != v68)
    {
      uint64_t v69 = *v67;
      v67 += 2;
      md::LabelMapTile::updateLabels(v69, *(md::LabelManager **)(v4 + 8), (md::LabelPool *)v4, (int)v5, v2[4]);
    }
LABEL_99:
    uint64_t v70 = *(void **)(v4 + 104);
    if (v70)
    {
      while (1)
      {
        unint64_t v71 = v70[2];
        if (*(unsigned char *)(v71 + 125))
        {
          *(unsigned char *)(v71 + 125) = 0;
          uint64_t v72 = *(void **)(v71 + 408);
          int v73 = (void *)(v71 + 416);
          if (v72 != (void *)(v71 + 416)) {
            break;
          }
        }
LABEL_102:
        std::__hash_table<std::shared_ptr<md::LabelMapTile>,std::hash<std::shared_ptr<md::LabelMapTile>>,std::equal_to<std::shared_ptr<md::LabelMapTile>>,geo::StdAllocator<std::shared_ptr<md::LabelMapTile>,mdm::Allocator>>::__emplace_unique_key_args<std::shared_ptr<md::LabelMapTile>,std::shared_ptr<md::LabelMapTile> const&>(v4 + 136, v71, v70 + 2);
        uint64_t v70 = (void *)*v70;
        if (!v70) {
          goto LABEL_117;
        }
      }
      while (1)
      {
        uint64_t v74 = v72[4];
        if (atomic_fetch_add((atomic_uchar *volatile)(v74 + 1296), 0xFFu) != 1) {
          goto LABEL_110;
        }
        if (*(unsigned char *)(v74 + 1264)) {
          break;
        }
        md::Label::updateStateMachineForStaging(v74, 1, 37);
        char v75 = (void *)v72[1];
        if (!v75)
        {
          do
          {
LABEL_114:
            int v76 = (void *)v72[2];
            BOOL v24 = *v76 == (void)v72;
            uint64_t v72 = v76;
          }
          while (!v24);
          goto LABEL_106;
        }
        do
        {
LABEL_111:
          int v76 = v75;
          char v75 = (void *)*v75;
        }
        while (v75);
LABEL_106:
        uint64_t v72 = v76;
        if (v76 == v73)
        {
          unint64_t v71 = v70[2];
          goto LABEL_102;
        }
      }
      *(unsigned char *)(v74 + 1261) = 1;
      *(void *)(v74 + 1224) = 0;
LABEL_110:
      char v75 = (void *)v72[1];
      if (!v75) {
        goto LABEL_114;
      }
      goto LABEL_111;
    }
LABEL_117:
    uint64_t v64 = *(void *)(v4 + 120);
    if (v64)
    {
      char v77 = *(void **)(v4 + 104);
      while (v77)
      {
        unsigned int v78 = v77;
        char v77 = (void *)*v77;
        int v79 = (std::__shared_weak_count *)v78[3];
        if (v79 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
          std::__shared_weak_count::__release_weak(v79);
        }
        (*(void (**)(void, void *, uint64_t))(**(void **)(v4 + 112) + 40))(*(void *)(v4 + 112), v78, 32);
      }
      *(void *)(v4 + 104) = 0;
      uint64_t v80 = *(void *)(v4 + 88);
      if (v80)
      {
        for (uint64_t i = 0; i != v80; ++i)
          *(void *)(*(void *)(v4 + 80) + 8 * i) = 0;
      }
      LOBYTE(v64) = 0;
      *(void *)(v4 + 120) = 0;
    }
LABEL_128:
    if (v2[5]) {
      goto LABEL_129;
    }
LABEL_368:
    *(unsigned char *)(a1 + 370) |= v64;
    if (!v2[2]) {
      goto LABEL_369;
    }
LABEL_130:
    uint64_t v2 = *(unsigned __int8 **)(a1 + 48);
    uint64_t v82 = *(void *)(*(void *)(*((void *)v2 + 1) + 168) + 32);
    uint64_t v83 = (*(uint64_t (**)(uint64_t))(*(void *)v82 + 80))(v82);
    uint64_t v85 = v83;
    if (v83)
    {
      BOOL v86 = *(_DWORD *)(v83 + 232) != *((_DWORD *)v2 + 185);
      if (v2[758]) {
        goto LABEL_137;
      }
    }
    else
    {
      BOOL v86 = 0;
      if (v2[758]) {
        goto LABEL_137;
      }
    }
    if (*(_DWORD *)(*((void *)v2 + 78) + 224) != *((_DWORD *)v2 + 184)) {
      BOOL v86 = 1;
    }
    if (!v86)
    {
      uint64_t v111 = *(void *)(a1 + 72);
      uint64_t v110 = *(void *)(a1 + 80);
      if (v111 == v110) {
        goto LABEL_377;
      }
      BOOL v112 = 0;
      unint64_t v113 = 0;
      do
      {
        if (v112)
        {
          do
            v111 += 16;
          while (v111 != v110);
          goto LABEL_137;
        }
        while (1)
        {
          uint64_t v114 = *(unsigned char **)v111;
          if (!*(unsigned char *)(*(void *)v111 + 820) && !v114[1251])
          {
            if (!atomic_load(v114 + 1297)) {
              break;
            }
            uint64_t v114 = *(unsigned char **)v111;
          }
          if (v114[824]) {
            break;
          }
          v111 += 16;
          if (v111 == v110) {
            goto LABEL_377;
          }
        }
        BOOL v112 = ++v113 > 4;
        v111 += 16;
      }
      while (v111 != v110);
      if (v113 < 5) {
        goto LABEL_377;
      }
    }
LABEL_137:
    uint64_t v87 = *((void *)v2 + 78);
    unsigned int v6 = *(id **)(v87 + 208);
    *((_DWORD *)v2 + 184) = *(_DWORD *)(v87 + 224);
    v2[758] = 0;
    uint64_t v88 = *((void *)v2 + 88);
    if (v88)
    {
      unsigned __int8 v89 = (*(uint64_t (**)(void))(**(void **)(v88 + 8) + 184))(*(void *)(v88 + 8));
      v190 = v90;
      int v187 = v89;
      uint64_t v91 = *((void *)v2 + 90);
      if (v91) {
        goto LABEL_139;
      }
    }
    else
    {
      int v187 = 0;
      v190 = 0;
      uint64_t v91 = *((void *)v2 + 90);
      if (v91)
      {
LABEL_139:
        unsigned __int8 v92 = (*(uint64_t (**)(void))(**(void **)(v91 + 8) + 184))(*(void *)(v91 + 8));
        uint64_t v189 = v93;
        int v185 = v92;
        if (v85)
        {
LABEL_140:
          *((_DWORD *)v2 + 185) = *(_DWORD *)(v85 + 232);
          v186 = (void *)(v85 + 120);
          uint64_t v8 = *(void *)(v85 + 160) == 0;
LABEL_144:
          v188 = (uint64_t *)(a1 + 72);
          uint64_t v95 = *(void *)(a1 + 72);
          uint64_t v94 = *(void *)(a1 + 80);
          if (v94 != v95)
          {
            do
            {
              uint64_t v96 = *(std::__shared_weak_count **)(v94 - 8);
              if (v96 && !atomic_fetch_add(&v96->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v96->__on_zero_shared)(v96);
                std::__shared_weak_count::__release_weak(v96);
              }
              v94 -= 16;
            }
            while (v94 != v95);
            uint64_t v94 = *v188;
          }
          *(void *)(a1 + 80) = v95;
          unint64_t v97 = *((void *)v2 + 31);
          if (v97 > (*(void *)(a1 + 88) - v94) >> 4)
          {
            if (v97 >> 60) {
              abort();
            }
            uint64_t v99 = 16 * v97;
            uint64_t v100 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 96) + 16))(*(void *)(a1 + 96), 16 * v97, 8);
            uint64_t v98 = v95 - v94;
            uint64_t v101 = v100 + v98;
            uint64_t v102 = v100 + v99;
            uint64_t v103 = *(void **)(a1 + 72);
            uint64_t v104 = *(void **)(a1 + 80);
            if (v104 == v103)
            {
              *(void *)(a1 + 72) = v101;
              *(void *)(a1 + 80) = v101;
              uint64_t v108 = *(void *)(a1 + 88);
              *(void *)(a1 + 88) = v102;
            }
            else
            {
              uint64_t v105 = v100 + v98;
              do
              {
                long long v106 = *((_OWORD *)v104 - 1);
                v104 -= 2;
                *(_OWORD *)(v105 - 16) = v106;
                v105 -= 16;
                *uint64_t v104 = 0;
                v104[1] = 0;
              }
              while (v104 != v103);
              uint64_t v104 = *(void **)(a1 + 72);
              uint64_t v107 = *(void **)(a1 + 80);
              *(void *)(a1 + 72) = v105;
              *(void *)(a1 + 80) = v101;
              uint64_t v108 = *(void *)(a1 + 88);
              for (*(void *)(a1 + 88) = v102; v107 != v104; v107 -= 2)
              {
                v109 = (std::__shared_weak_count *)*(v107 - 1);
                if (v109 && !atomic_fetch_add(&v109->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
                  std::__shared_weak_count::__release_weak(v109);
                }
              }
            }
            if (v104) {
              (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 96) + 40))(*(void *)(a1 + 96), v104, v108 - (void)v104);
            }
          }
          *((void *)v2 + 77) = 0;
          v116 = (uint64_t *)*((void *)v2 + 28);
          uint64_t v5 = v2 + 232;
          if (v116 != (uint64_t *)(v2 + 232))
          {
            v184 = (void *)(v87 + 168);
            do
            {
              uint64_t v7 = v116 + 6;
              uint64_t v117 = v116[6];
              if (!*(unsigned char *)(v117 + 820) && !*(unsigned char *)(v117 + 1251))
              {
                int v118 = atomic_load((unsigned __int8 *)(v117 + 1297));
                uint64_t v117 = *v7;
                if (!v118)
                {
                  atomic_store(0, (unsigned __int8 *)(v117 + 1242));
                  unsigned __int8 v144 = atomic_load((unsigned __int8 *)(v117 + 1242));
                  if ((v144 & 1) == 0) {
                    *(void *)(v117 + 352) = 0;
                  }
                  md::Label::setActive(v116[6], 0, v84);
                  v145 = (uint64_t *)v116[1];
                  v146 = v116;
                  if (v145)
                  {
                    do
                    {
                      v143 = v145;
                      v145 = (uint64_t *)*v145;
                    }
                    while (v145);
                  }
                  else
                  {
                    do
                    {
                      v143 = (uint64_t *)v146[2];
                      BOOL v24 = *v143 == (void)v146;
                      v146 = v143;
                    }
                    while (!v24);
                  }
                  if (*((uint64_t **)v2 + 28) == v116) {
                    *((void *)v2 + 28) = v143;
                  }
                  --*((void *)v2 + 31);
                  std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v2 + 29), v116);
                  v147 = (std::__shared_weak_count *)v116[7];
                  if (v147 && !atomic_fetch_add(&v147->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v147->__on_zero_shared)(v147);
                    std::__shared_weak_count::__release_weak(v147);
                  }
                  (*(void (**)(void, uint64_t *, uint64_t))(**((void **)v2 + 30) + 40))(*((void *)v2 + 30), v116, 64);
                  goto LABEL_181;
                }
              }
              if (*(unsigned __int8 *)(v117 + 1211) - 20 >= 3)
              {
                if (v190
                  && v117 != *((void *)v2 + 88)
                  && v187 == (*(unsigned __int8 (**)(void))(**(void **)(v117 + 8) + 184))(*(void *)(v117 + 8)))
                {
                  uint64_t v4 = v190 == v120;
                  if (!v189) {
                    goto LABEL_187;
                  }
                }
                else
                {
                  uint64_t v4 = 0;
                  if (!v189) {
                    goto LABEL_187;
                  }
                }
                if (v4) {
                  goto LABEL_187;
                }
                uint64_t v121 = *v7;
                uint64_t v122 = *((void *)v2 + 90);
                if (*(unsigned char *)(*v7 + 1264))
                {
                  if (*(unsigned char *)(v122 + 1264)) {
                    BOOL v123 = v121 == v122;
                  }
                  else {
                    BOOL v123 = 1;
                  }
                  if (!v123)
                  {
LABEL_214:
                    if (v185 == (*(unsigned __int8 (**)(void))(**(void **)(v117 + 8) + 184))(*(void *)(v117 + 8)))
                    {
                      uint64_t v4 = v189 == v128;
                      goto LABEL_187;
                    }
                  }
                }
                else if (v121 != v122)
                {
                  goto LABEL_214;
                }
              }
              uint64_t v4 = 0;
LABEL_187:
              uint64_t v119 = *v7;
              if (!v6 || (v4 & 1) != 0) {
                goto LABEL_191;
              }
              if (*(unsigned char *)(v119 + 1264))
              {
                uint64_t v4 = 0;
LABEL_191:
                if ((v8 | v4)) {
                  goto LABEL_218;
                }
LABEL_192:
                if (*(unsigned __int8 *)(v119 + 1211) - 20 >= 3)
                {
                  unsigned __int8 v124 = (*(uint64_t (**)(void))(**(void **)(v117 + 8) + 184))(*(void *)(v117 + 8));
                  if (v125) {
                    uint64_t v4 = std::__hash_table<md::LabelFeatureID,std::hash<md::LabelFeatureID>,std::equal_to<md::LabelFeatureID>,geo::StdAllocator<md::LabelFeatureID,mdm::Allocator>>::find<md::LabelFeatureID>(v186, v124, v125) != 0;
                  }
                  else {
                    uint64_t v4 = 0;
                  }
                  uint64_t v119 = *v7;
                }
                else
                {
                  uint64_t v4 = 0;
                }
                goto LABEL_218;
              }
              unsigned __int8 v126 = (*(uint64_t (**)(void))(**(void **)(v117 + 8) + 184))(*(void *)(v117 + 8));
              if (v127) {
                uint64_t v4 = std::__hash_table<md::LabelFeatureID,std::hash<md::LabelFeatureID>,std::equal_to<md::LabelFeatureID>,geo::StdAllocator<md::LabelFeatureID,mdm::Allocator>>::find<md::LabelFeatureID>(v184, v126, v127) != 0;
              }
              else {
                uint64_t v4 = 0;
              }
              uint64_t v119 = *v7;
              if (((v8 | v4) & 1) == 0) {
                goto LABEL_192;
              }
LABEL_218:
              if (*((void *)v2 + 83))
              {
                v129 = (*(void (**)(uint64_t))(*(void *)v119 + 32))(v119);

                uint64_t v119 = *v7;
                if (v129)
                {
                  (*(void (**)(uint64_t))(*(void *)v119 + 32))(*v7);
                  BOOL v9 = (float *)(id)objc_claimAutoreleasedReturnValue();
                  v191 = v9;
                  uint64_t v130 = *((void *)v2 + 83);
                  if (!v130)
                  {
                    std::__throw_bad_function_call[abi:nn180100]();
                    __break(1u);
                    goto LABEL_380;
                  }
                  int v131 = (*(uint64_t (**)(uint64_t, float **))(*(void *)v130 + 48))(v130, &v191);

                  LODWORD(v4) = v4 | v131;
                  uint64_t v119 = *v7;
                }
              }
              if (v4 == (*(unsigned char *)(v119 + 824) != 0) || *(unsigned __int8 *)(v119 + 824) == v4)
              {
                if (!v4) {
                  goto LABEL_250;
                }
              }
              else
              {
                *(unsigned char *)(v119 + 824) = v4;
                *(unsigned char *)(v119 + 1262) = 0;
                if (!v4)
                {
                  if (!*(unsigned char *)(v119 + 1251))
                  {
                    *(_WORD *)(v119 + 1283) = 0;
                    *(unsigned char *)(v119 + 1250) = 0;
                    *(unsigned char *)(v119 + 1285) = 0;
                    uint64_t v138 = *(void *)(v119 + 264);
                    *(void *)(v119 + 264) = 0;
                    if (v138) {
                      (*(void (**)(uint64_t))(*(void *)v138 + 8))(v138);
                    }
                    uint64_t v139 = *(void *)(v119 + 272);
                    *(void *)(v119 + 272) = 0;
                    if (v139) {
                      (*(void (**)(uint64_t))(*(void *)v139 + 8))(v139);
                    }
                    uint64_t v140 = *(void *)(v119 + 304);
                    *(void *)(v119 + 304) = 0;
                    if (v140) {
                      (*(void (**)(uint64_t))(*(void *)v140 + 8))(v140);
                    }
                    if (*(void *)(v119 + 288))
                    {
                      *(void *)(v119 + 288) = 0;
                      *(unsigned char *)(v119 + 1247) = 1;
                    }
                  }
                  *(unsigned char *)(v119 + 1214) = -1;
                  goto LABEL_250;
                }
                uint64_t v136 = md::LabelPool::replacementForLabel((md::LabelPool *)v2, (const md::Label *)v119);
                if (v136)
                {
                  *(unsigned char *)(v119 + 1262) = 1;
                  *(void *)(v119 + 1224) = 0;
                  unsigned __int8 v137 = atomic_load((unsigned __int8 *)(v136 + 1240));
                  if ((v137 & 1) != 0 && !*(unsigned char *)(v119 + 1245) && *(unsigned char *)(v119 + 822) != 1) {
                    *(unsigned char *)(v119 + 826) = 1;
                  }
                }
                else
                {
                  md::Label::updateStateMachineForStaging(v119, 2, 28);
                }
              }
              if (!*(unsigned char *)(*v7 + 1262))
              {
                unsigned __int8 v133 = atomic_load((unsigned __int8 *)(*v7 + 1240));
                if ((v133 & 1) == 0 && *(unsigned char *)(*v7 + 820) != 2)
                {
                  unsigned __int8 v134 = atomic_load((unsigned __int8 *)(*v7 + 1243));
                  if ((v134 & 1) == 0)
                  {
                    ++*((void *)v2 + 77);
                    v135 = (uint64_t *)v116[1];
                    if (v135) {
                      goto LABEL_257;
                    }
                    goto LABEL_259;
                  }
                }
              }
LABEL_250:
              v141 = *(void **)(a1 + 80);
              if ((unint64_t)v141 >= *(void *)(a1 + 88))
              {
                *(void *)(a1 + 80) = std::vector<std::shared_ptr<md::LabelMarker>,geo::StdAllocator<std::shared_ptr<md::LabelMarker>,mdm::Allocator>>::__push_back_slow_path<std::shared_ptr<md::LabelMarker> const&>((uint64_t)v188, (long long *)v116 + 3);
                v135 = (uint64_t *)v116[1];
                if (v135) {
                  goto LABEL_257;
                }
              }
              else
              {
                if (v141)
                {
                  void *v141 = v116[6];
                  uint64_t v142 = v116[7];
                  v141[1] = v142;
                  if (v142) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v142 + 8), 1uLL, memory_order_relaxed);
                  }
                }
                *(void *)(a1 + 80) = v141 + 2;
                v135 = (uint64_t *)v116[1];
                if (v135)
                {
                  do
                  {
LABEL_257:
                    v143 = v135;
                    v135 = (uint64_t *)*v135;
                  }
                  while (v135);
                  goto LABEL_181;
                }
              }
              do
              {
LABEL_259:
                v143 = (uint64_t *)v116[2];
                BOOL v24 = *v143 == (void)v116;
                v116 = v143;
              }
              while (!v24);
LABEL_181:
              v116 = v143;
            }
            while (v143 != (uint64_t *)v5);
          }
          v148 = (uint64_t *)*((void *)v2 + 35);
          if (v148)
          {
            while (1)
            {
              v149 = (uint64_t *)*v148;
              if (*(void *)(v148[6] + 8) == *(void *)(v148[6] + 16)) {
                break;
              }
LABEL_280:
              v148 = v149;
              if (!v149) {
                goto LABEL_311;
              }
            }
            int8x8_t v150 = *(int8x8_t *)(v2 + 264);
            unint64_t v151 = v148[1];
            uint8x8_t v152 = (uint8x8_t)vcnt_s8(v150);
            v152.i16[0] = vaddlv_u8(v152);
            if (v152.u32[0] > 1uLL)
            {
              if (v151 >= *(void *)&v150) {
                v151 %= *(void *)&v150;
              }
            }
            else
            {
              v151 &= *(void *)&v150 - 1;
            }
            uint64_t v153 = *((void *)v2 + 32);
            v154 = *(unsigned __int8 **)(v153 + 8 * v151);
            do
            {
              v155 = v154;
              v154 = *(unsigned __int8 **)v154;
            }
            while (v154 != (unsigned __int8 *)v148);
            if (v155 == v2 + 280) {
              goto LABEL_387;
            }
            unint64_t v156 = *((void *)v155 + 1);
            if (v152.u32[0] > 1uLL)
            {
              if (v156 >= *(void *)&v150) {
                v156 %= *(void *)&v150;
              }
            }
            else
            {
              v156 &= *(void *)&v150 - 1;
            }
            uint64_t v157 = *v148;
            if (v156 != v151)
            {
LABEL_387:
              if (v149)
              {
                unint64_t v158 = v149[1];
                if (v152.u32[0] > 1uLL)
                {
                  if (v158 >= *(void *)&v150) {
                    v158 %= *(void *)&v150;
                  }
                }
                else
                {
                  v158 &= *(void *)&v150 - 1;
                }
                uint64_t v157 = *v148;
                if (v158 == v151) {
                  goto LABEL_302;
                }
              }
              *(void *)(v153 + 8 * v151) = 0;
              uint64_t v157 = *v148;
            }
            if (!v157)
            {
LABEL_308:
              *(void *)v155 = v157;
              uint64_t *v148 = 0;
              --*((void *)v2 + 37);
              v160 = (std::__shared_weak_count *)v148[7];
              if (v160 && !atomic_fetch_add(&v160->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v160->__on_zero_shared)(v160);
                std::__shared_weak_count::__release_weak(v160);
              }
              if (*((char *)v148 + 39) < 0) {
                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v148[5] + 40))(v148[5], v148[2], v148[4] & 0x7FFFFFFFFFFFFFFFLL);
              }
              (*(void (**)(void, uint64_t *, uint64_t))(**((void **)v2 + 36) + 40))(*((void *)v2 + 36), v148, 64);
              goto LABEL_280;
            }
LABEL_302:
            unint64_t v159 = *(void *)(v157 + 8);
            if (v152.u32[0] > 1uLL)
            {
              if (v159 >= *(void *)&v150) {
                v159 %= *(void *)&v150;
              }
            }
            else
            {
              v159 &= *(void *)&v150 - 1;
            }
            if (v159 != v151)
            {
              *(void *)(*((void *)v2 + 32) + 8 * v159) = v155;
              uint64_t v157 = *v148;
            }
            goto LABEL_308;
          }
LABEL_311:
          v161 = (void *)*((void *)v2 + 49);
          if (v161)
          {
            do
            {
              while (*(void *)(v161[3] + 8) != *(void *)(v161[3] + 16))
              {
                v161 = (void *)*v161;
                if (!v161) {
                  goto LABEL_322;
                }
              }
              v162 = (void *)*v161;
              std::__hash_table<std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,geo::StdAllocator<std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,mdm::Allocator>>::remove((uint64_t)&v191, (void *)v2 + 46, v161);
              v163 = v191;
              v191 = 0;
              if (v163)
              {
                if ((_BYTE)v193)
                {
                  v164 = (std::__shared_weak_count *)*((void *)v163 + 4);
                  if (v164)
                  {
                    if (!atomic_fetch_add(&v164->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v164->__on_zero_shared)(v164);
                      std::__shared_weak_count::__release_weak(v164);
                    }
                  }
                }
                (*(void (**)(void, float *, uint64_t))(*(void *)*v192 + 40))(*v192, v163, 40);
              }
              v161 = v162;
            }
            while (v162);
          }
LABEL_322:
          v165 = (void *)*((void *)v2 + 56);
          if (v165)
          {
            do
            {
              while (*(void *)(v165[3] + 8) != *(void *)(v165[3] + 16))
              {
                v165 = (void *)*v165;
                if (!v165) {
                  goto LABEL_333;
                }
              }
              v166 = (void *)*v165;
              std::__hash_table<std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,geo::StdAllocator<std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,mdm::Allocator>>::remove((uint64_t)&v191, (void *)v2 + 53, v165);
              v167 = v191;
              v191 = 0;
              if (v167)
              {
                if ((_BYTE)v193)
                {
                  v168 = (std::__shared_weak_count *)*((void *)v167 + 4);
                  if (v168)
                  {
                    if (!atomic_fetch_add(&v168->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v168->__on_zero_shared)(v168);
                      std::__shared_weak_count::__release_weak(v168);
                    }
                  }
                }
                (*(void (**)(void, float *, uint64_t))(*(void *)*v192 + 40))(*v192, v167, 40);
              }
              v165 = v166;
            }
            while (v166);
          }
LABEL_333:
          v169 = (unsigned __int8 *)*((void *)v2 + 42);
          if (!v169)
          {
LABEL_377:
            (*(void (**)(uint64_t))(*(void *)a1 + 456))(a1);
            return;
          }
          while (1)
          {
            v170 = *(unsigned __int8 **)v169;
            if (*(void *)(*((void *)v169 + 2) + 8) == *(void *)(*((void *)v169 + 2) + 16)) {
              break;
            }
LABEL_336:
            v169 = v170;
            if (!v170) {
              goto LABEL_377;
            }
          }
          int8x8_t v171 = *(int8x8_t *)(v2 + 320);
          unint64_t v172 = *((void *)v169 + 1);
          uint8x8_t v173 = (uint8x8_t)vcnt_s8(v171);
          v173.i16[0] = vaddlv_u8(v173);
          if (v173.u32[0] > 1uLL)
          {
            if (v172 >= *(void *)&v171) {
              v172 %= *(void *)&v171;
            }
          }
          else
          {
            v172 &= *(void *)&v171 - 1;
          }
          uint64_t v174 = *((void *)v2 + 39);
          v175 = *(unsigned __int8 **)(v174 + 8 * v172);
          do
          {
            v176 = v175;
            v175 = *(unsigned __int8 **)v175;
          }
          while (v175 != v169);
          if (v176 == v2 + 336) {
            goto LABEL_388;
          }
          unint64_t v177 = *((void *)v176 + 1);
          if (v173.u32[0] > 1uLL)
          {
            if (v177 >= *(void *)&v171) {
              v177 %= *(void *)&v171;
            }
          }
          else
          {
            v177 &= *(void *)&v171 - 1;
          }
          v178 = *(unsigned __int8 **)v169;
          if (v177 != v172)
          {
LABEL_388:
            if (v170)
            {
              unint64_t v179 = *((void *)v170 + 1);
              if (v173.u32[0] > 1uLL)
              {
                if (v179 >= *(void *)&v171) {
                  v179 %= *(void *)&v171;
                }
              }
              else
              {
                v179 &= *(void *)&v171 - 1;
              }
              v178 = *(unsigned __int8 **)v169;
              if (v179 == v172) {
                goto LABEL_358;
              }
            }
            *(void *)(v174 + 8 * v172) = 0;
            v178 = *(unsigned __int8 **)v169;
          }
          if (!v178)
          {
LABEL_364:
            *(void *)v176 = v178;
            *(void *)v169 = 0;
            --*((void *)v2 + 44);
            v181 = (std::__shared_weak_count *)*((void *)v169 + 3);
            if (v181)
            {
              if (!atomic_fetch_add(&v181->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v181->__on_zero_shared)(v181);
                std::__shared_weak_count::__release_weak(v181);
              }
            }
            (*(void (**)(void, unsigned __int8 *, uint64_t))(**((void **)v2 + 43) + 40))(*((void *)v2 + 43), v169, 32);
            goto LABEL_336;
          }
LABEL_358:
          unint64_t v180 = *((void *)v178 + 1);
          if (v173.u32[0] > 1uLL)
          {
            if (v180 >= *(void *)&v171) {
              v180 %= *(void *)&v171;
            }
          }
          else
          {
            v180 &= *(void *)&v171 - 1;
          }
          if (v180 != v172)
          {
            *(void *)(*((void *)v2 + 39) + 8 * v180) = v176;
            v178 = *(unsigned __int8 **)v169;
          }
          goto LABEL_364;
        }
LABEL_143:
        v186 = 0;
        uint64_t v8 = 1;
        goto LABEL_144;
      }
    }
    int v185 = 0;
    uint64_t v189 = 0;
    if (v85) {
      goto LABEL_140;
    }
    goto LABEL_143;
  }
  uint64_t v61 = mach_absolute_time();
  char v62 = *(unsigned char ***)(v4 + 16);
  char v63 = *(unsigned char ***)(v4 + 24);
  if (v62 == v63) {
    goto LABEL_99;
  }
  LOBYTE(v64) = 0;
  uint64_t v65 = MaxMachTimeDiffPerLabelTileUpdate + v61;
  while (1)
  {
    uint64_t v66 = *v62;
    if ((v64 & 1) == 0)
    {
      md::LabelMapTile::updateLabels(v66, *(md::LabelManager **)(v4 + 8), (md::LabelPool *)v4, (int)v5, 0);
      LOBYTE(v64) = mach_absolute_time() >= v65;
      goto LABEL_89;
    }
    if ((char)v66[492] != v5 || v66[122] || v66[124] || v66[123]) {
      break;
    }
    LOBYTE(v64) = 1;
    if (v66[128]) {
      goto LABEL_128;
    }
LABEL_89:
    v62 += 2;
    if (v62 == v63) {
      goto LABEL_99;
    }
  }
  LOBYTE(v64) = 1;
  if (!v2[5]) {
    goto LABEL_368;
  }
LABEL_129:
  if (v2[2]) {
    goto LABEL_130;
  }
LABEL_369:
  if (v2[3])
  {
    LOWORD(v191) = 257;
    BYTE2(v191) = 1;
    v182 = *(md::Label ***)(a1 + 72);
    v183 = *(md::Label ***)(a1 + 80);
    while (v182 != v183)
    {
      if (*((unsigned char *)*v182 + 820) == 2) {
        md::Label::layoutForStaging(*v182, *(void *)(a1 + 24), *(md::LabelPool **)(a1 + 48), &v191);
      }
      v182 += 2;
    }
  }
}

void sub_1A17C9668(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, std::mutex *a16, char a17, void *a18)
{
}

void sub_1A17C9764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy(result, *a2);
    std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy(v3, a2[1]);
    uint64_t v4 = (std::__shared_weak_count *)a2[5];
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

uint64_t **std::__hash_table<md::LabelFeatureID,std::hash<md::LabelFeatureID>,std::equal_to<md::LabelFeatureID>,geo::StdAllocator<md::LabelFeatureID,mdm::Allocator>>::find<md::LabelFeatureID>(void *a1, unsigned __int8 a2, uint64_t *a3)
{
  int8x8_t v3 = (int8x8_t)a1[1];
  if (!*(void *)&v3) {
    return 0;
  }
  unint64_t v4 = ((unint64_t)&a3[8 * (unint64_t)a2 - 0xC3910C8D016B07DLL] + ((unint64_t)a2 >> 2) - 3) ^ a2;
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = ((unint64_t)&a3[8 * (unint64_t)a2 - 0xC3910C8D016B07DLL] + ((unint64_t)a2 >> 2) - 3) ^ a2;
    if (v4 >= *(void *)&v3) {
      unint64_t v6 = v4 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v6 = v4 & (*(void *)&v3 - 1);
  }
  uint64_t v7 = *(uint64_t ****)(*a1 + 8 * v6);
  if (!v7) {
    return 0;
  }
  uint64_t result = *v7;
  if (*v7)
  {
    if (v5.u32[0] < 2uLL)
    {
      uint64_t v9 = *(void *)&v3 - 1;
      while (1)
      {
        uint64_t v13 = result[1];
        if ((uint64_t *)v4 == v13)
        {
          if (*((unsigned __int8 *)result + 16) == a2 && result[3] == a3) {
            return result;
          }
        }
        else if (((unint64_t)v13 & v9) != v6)
        {
          return 0;
        }
        uint64_t result = (uint64_t **)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v11 = (unint64_t)result[1];
      if (v4 == v11)
      {
        if (*((unsigned __int8 *)result + 16) == a2 && result[3] == a3) {
          return result;
        }
      }
      else
      {
        if (v11 >= *(void *)&v3) {
          v11 %= *(void *)&v3;
        }
        if (v11 != v6) {
          return 0;
        }
      }
      uint64_t result = (uint64_t **)*result;
    }
    while (result);
  }
  return result;
}

uint64_t md::LabelFeature::dedupingFeatureID(md::LabelFeature *this)
{
  if ((*(uint64_t (**)(md::LabelFeature *))(*(void *)this + 176))(this)
    || (*(uint64_t (**)(md::LabelFeature *))(*(void *)this + 160))(this))
  {
    return 4;
  }
  uint64_t result = (*(uint64_t (**)(md::LabelFeature *))(*(void *)this + 168))(this);
  if (result)
  {
    (*(void (**)(md::LabelFeature *))(*(void *)this + 168))(this);
    return 3;
  }
  return result;
}

uint64_t md::LabelPool::replacementForLabel(md::LabelPool *this, const md::Label *a2)
{
  uint64_t v4 = (*(uint64_t (**)(void))(**((void **)a2 + 1) + 160))(*((void *)a2 + 1));
  uint64_t v5 = (*(uint64_t (**)(void))(**((void **)a2 + 1) + 176))(*((void *)a2 + 1));
  unint64_t v6 = (std::mutex *)((char *)this + 480);
  std::mutex::lock((std::mutex *)((char *)this + 480));
  uint64_t v7 = (char *)*((void *)this + 28);
  uint64_t v8 = (char *)this + 232;
  if (v7 == (char *)this + 232)
  {
LABEL_57:
    uint64_t v9 = 0;
    goto LABEL_58;
  }
  if (v4)
  {
    if (v5)
    {
      while (1)
      {
        uint64_t v9 = *((void *)v7 + 6);
        if ((const md::Label *)v9 != a2
          && *(unsigned char *)(v9 + 820)
          && *(unsigned char *)(v9 + 1264)
          && (*(unsigned int (**)(void))(**(void **)(v9 + 8) + 216))(*(void *)(v9 + 8)))
        {
          uint64_t v10 = (*(uint64_t (**)(void))(**(void **)(v9 + 8) + 160))(*(void *)(v9 + 8));
          uint64_t v11 = (*(uint64_t (**)(void))(**(void **)(v9 + 8) + 176))(*(void *)(v9 + 8));
          BOOL v12 = v10 == v4 || v11 == v5;
          if (v12) {
            break;
          }
        }
        uint64_t v13 = (char *)*((void *)v7 + 1);
        if (v13)
        {
          do
          {
            uint64_t v14 = v13;
            uint64_t v13 = *(char **)v13;
          }
          while (v13);
        }
        else
        {
          do
          {
            uint64_t v14 = (char *)*((void *)v7 + 2);
            BOOL v12 = *(void *)v14 == (void)v7;
            uint64_t v7 = v14;
          }
          while (!v12);
        }
        uint64_t v7 = v14;
        if (v14 == v8) {
          goto LABEL_57;
        }
      }
    }
    else
    {
      while (1)
      {
        uint64_t v9 = *((void *)v7 + 6);
        if ((const md::Label *)v9 != a2
          && *(unsigned char *)(v9 + 820)
          && *(unsigned char *)(v9 + 1264)
          && (*(unsigned int (**)(void))(**(void **)(v9 + 8) + 216))(*(void *)(v9 + 8))
          && (*(uint64_t (**)(void))(**(void **)(v9 + 8) + 160))(*(void *)(v9 + 8)) == v4)
        {
          break;
        }
        uint64_t v15 = (char *)*((void *)v7 + 1);
        if (v15)
        {
          do
          {
            unint64_t v16 = v15;
            uint64_t v15 = *(char **)v15;
          }
          while (v15);
        }
        else
        {
          do
          {
            unint64_t v16 = (char *)*((void *)v7 + 2);
            BOOL v12 = *(void *)v16 == (void)v7;
            uint64_t v7 = v16;
          }
          while (!v12);
        }
        uint64_t v7 = v16;
        if (v16 == v8) {
          goto LABEL_57;
        }
      }
    }
    goto LABEL_58;
  }
  if (!v5)
  {
    do
    {
      uint64_t v19 = *((void *)v7 + 6);
      if ((const md::Label *)v19 != a2 && *(unsigned char *)(v19 + 820) && *(unsigned char *)(v19 + 1264)) {
        (*(void (**)(void))(**(void **)(v19 + 8) + 216))(*(void *)(v19 + 8));
      }
      uint64_t v20 = (char *)*((void *)v7 + 1);
      if (v20)
      {
        do
        {
          uint64_t v21 = v20;
          uint64_t v20 = *(char **)v20;
        }
        while (v20);
      }
      else
      {
        do
        {
          uint64_t v21 = (char *)*((void *)v7 + 2);
          BOOL v12 = *(void *)v21 == (void)v7;
          uint64_t v7 = v21;
        }
        while (!v12);
      }
      uint64_t v7 = v21;
    }
    while (v21 != v8);
    goto LABEL_57;
  }
  while (1)
  {
    uint64_t v9 = *((void *)v7 + 6);
    if ((const md::Label *)v9 != a2
      && *(unsigned char *)(v9 + 820)
      && *(unsigned char *)(v9 + 1264)
      && (*(unsigned int (**)(void))(**(void **)(v9 + 8) + 216))(*(void *)(v9 + 8))
      && (*(uint64_t (**)(void))(**(void **)(v9 + 8) + 176))(*(void *)(v9 + 8)) == v5)
    {
      break;
    }
    unsigned int v17 = (char *)*((void *)v7 + 1);
    if (v17)
    {
      do
      {
        uint64_t v18 = v17;
        unsigned int v17 = *(char **)v17;
      }
      while (v17);
    }
    else
    {
      do
      {
        uint64_t v18 = (char *)*((void *)v7 + 2);
        BOOL v12 = *(void *)v18 == (void)v7;
        uint64_t v7 = v18;
      }
      while (!v12);
    }
    uint64_t v7 = v18;
    if (v18 == v8) {
      goto LABEL_57;
    }
  }
LABEL_58:
  std::mutex::unlock(v6);
  return v9;
}

void sub_1A17C9DE0(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t md::PointLabelFeature::hasValidCustomFeatureAnnotation(md::PointLabelFeature *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 395);
  return v1 & 1;
}

uint64_t md::PointLabelFeature::businessID(md::PointLabelFeature *this)
{
  return *((void *)this + 47);
}

uint64_t md::PointLabelFeature::featureID(md::PointLabelFeature *this)
{
  return *((void *)this + 62);
}

uint64_t md::LineLabelFeature::dedupingFeatureID(md::LineLabelFeature *this)
{
  return 0;
}

uint64_t md::Label::setActive(uint64_t this, int a2, md::LabelPool *a3)
{
  if (*(unsigned __int8 *)(this + 1253) != a2)
  {
    int8x8_t v3 = (int32x2_t *)this;
    *(unsigned char *)(this + 1253) = a2;
    if ((a2 & 1) == 0)
    {
      if (!*(unsigned char *)(this + 1251))
      {
        *(_WORD *)(this + 1283) = 0;
        *(unsigned char *)(this + 1250) = 0;
        *(unsigned char *)(this + 1285) = 0;
        uint64_t v4 = *(void *)(this + 264);
        v3[33] = 0;
        if (v4) {
          (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
        }
        int32x2_t v5 = v3[34];
        v3[34] = 0;
        if (v5) {
          (*(void (**)(int32x2_t))(**(void **)&v5 + 8))(v5);
        }
        this = (uint64_t)v3[38];
        v3[38] = 0;
        if (this) {
          this = (*(uint64_t (**)(uint64_t))(*(void *)this + 8))(this);
        }
        if (v3[36])
        {
          v3[36] = 0;
          v3[155].i8[7] = 1;
        }
      }
      unint64_t v6 = (void *)v3[3];
      if (v6)
      {
        uint64_t v7 = (void *)v6[2];
        uint64_t v8 = (void *)v6[1];
        if (v8 != v7)
        {
          while ((int32x2_t *)*v8 != v3)
          {
            if (++v8 == v7)
            {
              uint64_t v8 = (void *)v6[2];
              break;
            }
          }
        }
        if (v8 != v7)
        {
          uint64_t v9 = v8 + 1;
          if (v8 + 1 != v7)
          {
            do
            {
              if ((int32x2_t *)*v9 != v3) {
                *v8++ = *v9;
              }
              ++v9;
            }
            while (v9 != v7);
            uint64_t v7 = (void *)v6[2];
          }
        }
        if (v8 != v7) {
          _DWORD v6[2] = v8;
        }
        this = (*(uint64_t (**)(void *, int32x2_t *))(*v6 + 48))(v6, v3);
        void v3[3] = 0;
      }
      v3[103].i8[7] = 0;
      v3[59] = vdup_n_s32(0xC2C80000);
      if (v3[60].i8[3])
      {
        *(unsigned char *)(*(void *)&v3[57] + 285) = 1;
        v3[60].i8[3] = 0;
      }
      v3[157].i8[7] = 0;
    }
  }
  return this;
}

void md::CaptionedIconLabelPart::~CaptionedIconLabelPart(md::CaptionedIconLabelPart *this)
{
  md::CaptionedIconLabelPart::~CaptionedIconLabelPart(this);
  unsigned __int8 v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    unsigned __int8 v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t vars8;

  *(void *)this = &unk_1EF540EB8;
  uint64_t v2 = *((void *)this + 114);
  *((void *)this + 114) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40AE2C30F4);
  }
  int v3 = *((void *)this + 113);
  *((void *)this + 113) = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C40AE2C30F4);
  }
  uint64_t v4 = *((void *)this + 112);
  *((void *)this + 112) = 0;
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x1000C40AE2C30F4);
  }
  int32x2_t v5 = *((void *)this + 111);
  *((void *)this + 111) = 0;
  if (v5) {
    MEMORY[0x1A6239270](v5, 0x1000C40AE2C30F4);
  }
  unint64_t v6 = *((void *)this + 100);
  if (v6)
  {
    *((void *)this + 101) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 103) + 40))(*((void *)this + 103), v6, *((void *)this + 102) - v6);
  }
  if (*((char *)this + 759) < 0) {
    (*(void (**)(void, void, uint64_t))(**((void **)this + 95) + 40))(*((void *)this + 95), *((void *)this + 92), *((void *)this + 94) & 0x7FFFFFFFFFFFFFFFLL);
  }
  md::CompositeLabelPart::~CompositeLabelPart(this);
}

void md::StandardLabeler::startFrameLayout(md::StandardLabeler *this, const md::LayoutContext *a2, __n128 a3)
{
  float v3 = a3.n128_f32[0];
  *((_DWORD *)this + 91) = 0;
  *((_DWORD *)this + 94) = a3.n128_u32[0];
  *((_WORD *)this + 185) = 0;
  uint64_t v5 = *((void *)this + 4);
  unint64_t v6 = *(void **)(v5 + 72);
  uint64_t v7 = (void *)(v5 + 80);
  if (v6 != (void *)(v5 + 80))
  {
    char v8 = 0;
    while (1)
    {
      uint64_t v9 = v6[24];
      if (v9)
      {
        int v10 = *(unsigned __int8 *)(v9 + 52);
        if ((v10 - 1) < 2)
        {
          float v15 = *(float *)(v9 + 16);
          if (v15 < 1.0)
          {
            *(float *)(v9 + 16) = fminf((float)(v3 / *(float *)(v9 + 24)) + v15, 1.0);
            *(float *)(v9 + 20) = (*(float (**)(void))(v9 + 32))();
            if (*(float *)(v9 + 16) >= 1.0)
            {
              *(_DWORD *)(v9 + 16) = 1065353216;
              *(float *)(v9 + 20) = (*(float (**)(float))(v9 + 32))(1.0);
              *(unsigned char *)(v9 + 52) = 2;
              a3.n128_u64[0] = *(void *)(*(void *)(*(void *)v9 + 432) + 336);
              *(void *)(v9 + 104) = a3.n128_u64[0];
            }
          }
        }
        else
        {
          if (*(unsigned char *)(v9 + 52)) {
            BOOL v11 = v10 == 3;
          }
          else {
            BOOL v11 = 1;
          }
          if (v11)
          {
            float v12 = *(float *)(v9 + 16);
            if (v12 > 0.0)
            {
              *(float *)(v9 + 16) = fmaxf(v12 - (float)(v3 / *(float *)(v9 + 28)), 0.0);
              *(float *)(v9 + 20) = (*(float (**)(void))(v9 + 40))();
              if (*(float *)(v9 + 16) <= 0.0)
              {
                *(_DWORD *)(v9 + 16) = 0;
                *(float *)(v9 + 20) = (*(float (**)(double))(v9 + 40))(0.0);
                *(unsigned char *)(v9 + 52) = 0;
              }
            }
          }
        }
        BOOL v13 = (*(unsigned char *)(v9 + 52) & 0xFD) == 1;
        uint64_t v14 = (void *)v6[1];
        if (!v14)
        {
          do
          {
LABEL_22:
            unint64_t v16 = (void *)v6[2];
            BOOL v11 = *v16 == (void)v6;
            unint64_t v6 = v16;
          }
          while (!v11);
          goto LABEL_3;
        }
      }
      else
      {
        BOOL v13 = 0;
        uint64_t v14 = (void *)v6[1];
        if (!v14) {
          goto LABEL_22;
        }
      }
      do
      {
        unint64_t v16 = v14;
        uint64_t v14 = (void *)*v14;
      }
      while (v14);
LABEL_3:
      v8 |= v13;
      unint64_t v6 = v16;
      if (v16 == v7)
      {
        char v17 = *((unsigned char *)this + 370);
        goto LABEL_27;
      }
    }
  }
  char v17 = 0;
  char v8 = 0;
LABEL_27:
  *((unsigned char *)this + 370) = v17 | v8 & 1;
  uint64_t v19 = (md::Label **)*((void *)this + 13);
  uint64_t v18 = (md::Label **)*((void *)this + 14);
  while (v19 != v18)
  {
    uint64_t v20 = *v19;
    v19 += 2;
    a3.n128_f32[0] = v3;
    md::Label::animate(v20, a3);
  }
}

uint64_t md::Label::animate(md::Label *this, __n128 a2)
{
  float v2 = a2.n128_f32[0];
  int v4 = *((unsigned __int8 *)this + 1072);
  if (v4 == 2)
  {
    if (vabds_f32(*((float *)this + 278), *((float *)this + 110)) < 0.4)
    {
      *((float *)this + 280) = fmaxf(fminf(*((float *)this + 280), 0.9) - (float)(a2.n128_f32[0] / *((float *)this + 283)), 0.0);
      a2.n128_f32[0] = (*((float (**)(void))this + 143))();
      *((_DWORD *)this + 281) = a2.n128_u32[0];
      if (*((float *)this + 280) > 0.0 && a2.n128_f32[0] > 0.1) {
        goto LABEL_14;
      }
      if (*((void *)this + 148) || *((unsigned char *)this + 1081)) {
        goto LABEL_14;
      }
    }
    *((_DWORD *)this + 280) = 0;
    a2.n128_u64[0] = 0;
    float v5 = (*((float (**)(__n128))this + 143))(a2);
    goto LABEL_13;
  }
  if (v4 != 1) {
    goto LABEL_15;
  }
  *((float *)this + 280) = fminf((float)(a2.n128_f32[0] / *((float *)this + 282)) + fmaxf(*((float *)this + 280), 0.1), 1.0);
  a2.n128_f32[0] = (*((float (**)(void))this + 142))();
  *((_DWORD *)this + 281) = a2.n128_u32[0];
  if ((*((float *)this + 280) >= 1.0 || a2.n128_f32[0] >= 0.9) && !*((void *)this + 148))
  {
    *((_DWORD *)this + 280) = 1065353216;
    a2.n128_u32[0] = 1.0;
    float v5 = (*((float (**)(__n128))this + 142))(a2);
LABEL_13:
    *((float *)this + 281) = v5;
    md::Label::updateStateMachineForDisplay((uint64_t)this, 7, *((unsigned char *)this + 1073), 0);
  }
LABEL_14:
  int v4 = *((unsigned __int8 *)this + 1072);
LABEL_15:
  if (v4 == 3) {
    goto LABEL_18;
  }
  if (v4 != 2)
  {
    if (v4 != 1) {
      goto LABEL_25;
    }
LABEL_18:
    float v6 = *((float *)this + 288);
    float v7 = 1.0;
    if (v6 < 1.0)
    {
      *((float *)this + 288) = fminf((float)(v2 / *((float *)this + 290)) + v6, 1.0);
      *((float *)this + 289) = (*((float (**)(void))this + 146))();
      if (*((float *)this + 288) >= 1.0)
      {
        char v8 = (float (**)(float))((char *)this + 1168);
        uint64_t v9 = (float *)((char *)this + 1156);
        *((_DWORD *)this + 288) = 1065353216;
LABEL_24:
        *uint64_t v9 = (*v8)(v7);
        goto LABEL_25;
      }
    }
    goto LABEL_25;
  }
  float v10 = *((float *)this + 288);
  if (v10 > 0.0)
  {
    float v7 = 0.0;
    *((float *)this + 288) = fmaxf(v10 - (float)(v2 / *((float *)this + 291)), 0.0);
    *((float *)this + 289) = (*((float (**)(void))this + 147))();
    if (*((float *)this + 288) <= 0.0)
    {
      char v8 = (float (**)(float))((char *)this + 1176);
      uint64_t v9 = (float *)((char *)this + 1156);
      *((_DWORD *)this + 288) = 0;
      goto LABEL_24;
    }
  }
LABEL_25:
  uint64_t v11 = *((void *)this + 148);
  if (!v11) {
    goto LABEL_38;
  }
  if (!*(unsigned char *)(v11 + 88))
  {
    if (!*(unsigned char *)(v11 + 90))
    {
LABEL_31:
      *(float *)(v11 + 20) = *(float *)(v11 + 20) + v2;
      float v12 = *(md::LabelAnimationTrack ***)(v11 + 56);
      BOOL v13 = *(md::LabelAnimationTrack ***)(v11 + 64);
      if (v12 == v13) {
        goto LABEL_35;
      }
      char v14 = 0;
      do
      {
        a2.n128_u32[0] = *(_DWORD *)(v11 + 20);
        md::LabelAnimationTrack::runAnimation(*v12, a2);
        float v15 = *v12++;
        v14 |= *((unsigned char *)v15 + 40) == 0;
      }
      while (v12 != v13);
      if ((v14 & 1) == 0) {
LABEL_35:
      }
        *(unsigned char *)(v11 + 88) = 1;
      goto LABEL_36;
    }
    if (v2 >= 100.0 || *(unsigned char *)(*(void *)(*(void *)(v11 + 8) + 1192) + 52) == 2)
    {
      *(unsigned char *)(v11 + 90) = 0;
      goto LABEL_31;
    }
  }
LABEL_36:
  unint64_t v16 = (md::LabelAnimator *)*((void *)this + 148);
  if (*((unsigned char *)v16 + 88))
  {
    *((void *)this + 148) = 0;
    md::LabelAnimator::~LabelAnimator(v16);
    MEMORY[0x1A6239270]();
    *((unsigned char *)this + 1106) = *((unsigned char *)this + 1108);
  }
LABEL_38:
  uint64_t v17 = *((void *)this + 37);
  if (v17)
  {
    (*(void (**)(uint64_t, float))(*(void *)v17 + 616))(v17, v2);
    if ((*(unsigned int (**)(void))(**((void **)this + 37) + 688))()
      && ((*(uint64_t (**)(void))(**((void **)this + 37) + 696))(*((void *)this + 37)) & 1) == 0)
    {
      if (*((unsigned char *)this + 1082))
      {
        *((unsigned char *)this + 1082) = 0;
        atomic_store(0, (unsigned __int8 *)this + 1243);
      }
      if (*((unsigned char *)this + 1081))
      {
        *((unsigned char *)this + 1081) = 0;
        atomic_store(0, (unsigned __int8 *)this + 1244);
        *((_DWORD *)this + 280) = 0;
        *((float *)this + 281) = (*((float (**)(double))this + 143))(0.0);
        md::Label::updateStateMachineForDisplay((uint64_t)this, 8, *((unsigned char *)this + 1073), 0);
      }
      uint64_t v18 = *((void *)this + 37);
      *((void *)this + 37) = 0;
      if (v18) {
        (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
      }
      uint64_t v19 = *((void *)this + 35);
      *((void *)this + 35) = 0;
      if (v19) {
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
      }
    }
  }
  else
  {
    uint64_t v20 = *((void *)this + 34);
    if (v20) {
      (*(void (**)(uint64_t, float))(*(void *)v20 + 616))(v20, v2);
    }
  }
  uint64_t result = *((void *)this + 38);
  if (result)
  {
    (*(void (**)(uint64_t, float))(*(void *)result + 616))(result, v2);
    uint64_t result = (*(uint64_t (**)(void))(**((void **)this + 38) + 696))();
    if ((result & 1) == 0)
    {
      uint64_t result = *((void *)this + 38);
      *((void *)this + 38) = 0;
      if (result)
      {
        unint64_t v22 = *(uint64_t (**)(void))(*(void *)result + 8);
        return v22();
      }
    }
  }
  return result;
}

uint64_t md::CrossFadeLabelPart::isCrossFadeNode(md::CrossFadeLabelPart *this)
{
  return 1;
}

BOOL md::AnimatedCrossFadeLabelPart::isCrossFading(md::AnimatedCrossFadeLabelPart *this)
{
  return *((unsigned char *)this + 737) || *((unsigned char *)this + 728) == 0;
}

void md::AnimatedCrossFadeLabelPart::animate(md::AnimatedCrossFadeLabelPart *this, float a2)
{
  float v4 = *((float *)this + 158) + (float)(a2 * 2.5);
  *((float *)this + 158) = v4;
  if (v4 >= 1.0)
  {
    *((_DWORD *)this + 158) = 1065353216;
    *((unsigned char *)this + 737) = 0;
    if (*((unsigned char *)this + 738))
    {
      *((unsigned char *)this + 738) = 0;
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      float v5 = (id)GEOGetVectorKitPerformanceLog_log;
      float v6 = v5;
      os_signpost_id_t v7 = *((unsigned __int8 *)this + 736);
      if (*((unsigned char *)this + 736) && os_signpost_enabled(v5))
      {
        *(_WORD *)BOOL v13 = 0;
        _os_signpost_emit_with_name_impl(&dword_1A1780000, v6, OS_SIGNPOST_INTERVAL_END, v7, "LabelsPickAnimation", "", v13, 2u);
      }
    }
  }
  (*(void (**)(void, float))(**(void **)(*((void *)this + 72) + 8) + 616))(*(void *)(*((void *)this + 72) + 8), a2);
  if (!*((unsigned char *)this + 728))
  {
    if (*((unsigned char *)this + 730))
    {
      if (a2 < 100.0 && *(unsigned char *)(*(void *)(*((void *)this + 81) + 1192) + 52) != 2) {
        return;
      }
      *((unsigned char *)this + 730) = 0;
    }
    *((float *)this + 165) = *((float *)this + 165) + a2;
    uint64_t v9 = (md::LabelAnimationTrack **)*((void *)this + 87);
    float v10 = (md::LabelAnimationTrack **)*((void *)this + 88);
    if (v9 == v10) {
      goto LABEL_18;
    }
    char v11 = 0;
    do
    {
      v8.n128_u32[0] = *((_DWORD *)this + 165);
      md::LabelAnimationTrack::runAnimation(*v9, v8);
      float v12 = *v9++;
      v11 |= *((unsigned char *)v12 + 40) == 0;
    }
    while (v9 != v10);
    if ((v11 & 1) == 0) {
LABEL_18:
    }
      *((unsigned char *)this + 728) = 1;
  }
}

uint64_t md::CaptionedIconLabelPart::animate(md::CaptionedIconLabelPart *this, float a2)
{
  uint64_t result = (*(uint64_t (**)(md::CaptionedIconLabelPart *))(*(void *)this + 608))(this);
  if (result)
  {
    float v5 = 0.0;
    if (!*((unsigned char *)this + 732)) {
      float v5 = 1.0;
    }
    float v6 = *((float *)this + 237);
    BOOL v7 = v6 < v5;
    float v8 = fmaxf(v5, v6 - (float)(a2 * 5.0));
    float v9 = fminf(v6 + (float)(a2 * 5.0), v5);
    if (!v7) {
      float v9 = v8;
    }
    *((float *)this + 237) = v9;
  }
  return result;
}

BOOL md::CaptionedIconLabelPart::isFading(md::CaptionedIconLabelPart *this)
{
  if (!*((unsigned char *)this + 926)) {
    return 0;
  }
  float v1 = 0.0;
  if (!*((unsigned char *)this + 732)) {
    float v1 = 1.0;
  }
  return *((float *)this + 237) != v1;
}

float EaseConstantOne(float a1)
{
  return 1.0;
}

void md::LabelAnimationTrack::runAnimation(md::LabelAnimationTrack *this, __n128 a2)
{
  if (!*((unsigned char *)this + 40))
  {
    uint64_t v4 = *(void *)this;
    uint64_t v3 = *((void *)this + 1);
    if (*(void *)this != v3)
    {
      float v5 = a2.n128_f32[0];
      unint64_t v6 = *((unsigned int *)this + 8);
      unint64_t v7 = (v3 - v4) >> 5;
      if (v7 <= v6)
      {
LABEL_7:
        if (*((unsigned char *)this + 41))
        {
          a2.n128_f32[0] = fmodf(v5, *(float *)(v3 - 28) + *(float *)(v3 - 32));
          LODWORD(v6) = 0;
          a2.n128_f32[0] = v5 - a2.n128_f32[0];
          *((_DWORD *)this + 9) = a2.n128_u32[0];
          *((_DWORD *)this + 8) = 0;
        }
        else
        {
          LODWORD(v6) = ((unint64_t)(v3 - v4) >> 5) - 1;
          *((_DWORD *)this + 8) = v6;
          *((unsigned char *)this + 40) = 1;
          a2.n128_u32[0] = *((_DWORD *)this + 9);
        }
      }
      else
      {
        a2.n128_u32[0] = *((_DWORD *)this + 9);
        while ((float)(*(float *)(v4 + 32 * v6 + 4) + *(float *)(v4 + 32 * v6)) <= (float)(v5 - a2.n128_f32[0]))
        {
          unint64_t v6 = (v6 + 1);
          if (v7 <= v6) {
            goto LABEL_7;
          }
        }
        *((_DWORD *)this + 8) = v6;
      }
      uint64_t v8 = v4 + 32 * v6;
      a2.n128_f32[0] = fminf(fmaxf(v5 - (float)(a2.n128_f32[0] + *(float *)v8), 0.0), *(float *)(v8 + 4))
                     / *(float *)(v8 + 4);
      *(_DWORD *)(v8 + 12) = a2.n128_u32[0];
      if (!*(unsigned char *)(v8 + 16)) {
        a2.n128_f32[0] = 1.0 - a2.n128_f32[0];
      }
      *(float *)(v8 + 8) = (*(float (**)(__n128))(v8 + 24))(a2);
    }
  }
}

float EaseQuadIn(float a1)
{
  return a1 * a1;
}

uint64_t md::StyleCrossFadeLabelPart::isCrossFading(md::StyleCrossFadeLabelPart *this)
{
  return *((unsigned __int8 *)this + 638);
}

uint64_t md::StyleCrossFadeLabelPart::animate(md::StyleCrossFadeLabelPart *this, float a2)
{
  float v2 = *((float *)this + 158) + (float)(a2 * 2.5);
  *((float *)this + 158) = v2;
  if (v2 >= 1.0)
  {
    *((_DWORD *)this + 158) = 1065353216;
    *((unsigned char *)this + 638) = 0;
  }
  return (*(uint64_t (**)(void))(**(void **)(*((void *)this + 72) + 8) + 616))();
}

void md::NullLabelPart::~NullLabelPart(void **this)
{
  *this = &unk_1EF5540C8;
  free(this[59]);
  free(this[60]);
  free(this[62]);
  free(this[29]);
  free(this[30]);
  free(this[32]);
  float v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    float v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v4) {
      operator new();
    }
  }
  uint64_t v3 = *(void (**)(void))(**((void **)v2 + 91) + 40);
  v3();
}

{
  *this = &unk_1EF5540C8;
  free(this[59]);
  free(this[60]);
  free(this[62]);
  free(this[29]);
  free(this[30]);
  free(this[32]);
}

void md::AnimatedCrossFadeLabelPart::~AnimatedCrossFadeLabelPart(md::AnimatedCrossFadeLabelPart *this)
{
  md::AnimatedCrossFadeLabelPart::~AnimatedCrossFadeLabelPart(this);
  float v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    float v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  float v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

{
  NSObject *v2;
  NSObject *v3;
  os_signpost_id_t v4;
  uint8_t v5[16];

  *(void *)this = &unk_1EF547510;
  if (*((unsigned char *)this + 738))
  {
    *((unsigned char *)this + 738) = 0;
    if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
    }
    float v2 = (id)GEOGetVectorKitPerformanceLog_log;
    int v3 = v2;
    int v4 = *((unsigned __int8 *)this + 736);
    if (*((unsigned char *)this + 736) && os_signpost_enabled(v2))
    {
      *(_WORD *)float v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "LabelsPickAnimation", "", v5, 2u);
    }
  }
  md::LabelAnimator::~LabelAnimator((md::AnimatedCrossFadeLabelPart *)((char *)this + 640));
  md::CompositeLabelPart::~CompositeLabelPart(this);
}

void md::CompositeLabelPart::~CompositeLabelPart(md::CompositeLabelPart *this)
{
  *(void *)this = &unk_1EF538820;
  if (*((unsigned char *)this + 628))
  {
    float v2 = (void *)*((void *)this + 72);
    int v3 = (void *)*((void *)this + 73);
    while (v2 != v3)
    {
      if (*v2) {
        (*(void (**)(void))(*(void *)*v2 + 8))(*v2);
      }
      ++v2;
    }
  }
  if (*((unsigned char *)this + 616)) {
    *((unsigned char *)this + 616) = 0;
  }
  if (*((unsigned char *)this + 608)) {
    *((unsigned char *)this + 608) = 0;
  }
  uint64_t v4 = *((void *)this + 72);
  if (v4)
  {
    *((void *)this + 73) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 75) + 40))(*((void *)this + 75), v4, *((void *)this + 74) - v4);
  }
  *(void *)this = &unk_1EF5540C8;
  free(*((void **)this + 59));
  free(*((void **)this + 60));
  free(*((void **)this + 62));
  free(*((void **)this + 29));
  free(*((void **)this + 30));
  free(*((void **)this + 32));
}

void md::LabelAnimator::~LabelAnimator(md::LabelAnimator *this)
{
  float v2 = (void *)*((void *)this + 7);
  if (v2)
  {
    int v3 = (void *)*((void *)this + 8);
    uint64_t v4 = *((void *)this + 7);
    if (v3 != v2)
    {
      do
      {
        unint64_t v6 = (uint64_t *)*--v3;
        float v5 = v6;
        *int v3 = 0;
        if (v6)
        {
          uint64_t v7 = *v5;
          if (*v5)
          {
            v5[1] = v7;
            (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v5[3] + 40))(v5[3], v7, v5[2] - v7);
          }
          MEMORY[0x1A6239270](v5, 0x1020C4034EA8E73);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *((void *)this + 7);
    }
    *((void *)this + 8) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 10) + 40))(*((void *)this + 10), v4, *((void *)this + 9) - v4);
  }
  uint64_t v8 = *((void *)this + 3);
  if (v8)
  {
    uint64_t v9 = *((void *)this + 4);
    uint64_t v10 = *((void *)this + 3);
    if (v9 != v8)
    {
      do
      {
        float v12 = *(void **)(v9 - 144);
        v9 -= 144;
        char v11 = v12;
        if (v12 != *(void **)(v9 + 16)) {
          free(v11);
        }
      }
      while (v9 != v8);
      uint64_t v10 = *((void *)this + 3);
    }
    *((void *)this + 4) = v8;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 6) + 40))(*((void *)this + 6), v10, *((void *)this + 5) - v10);
  }
}

void md::PointIconLabelPart::~PointIconLabelPart(md::PointIconLabelPart *this)
{
  *(void *)this = &unk_1EF539EE0;
  uint64_t v2 = *((void *)this + 104);
  *((void *)this + 104) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*((char *)this + 791) < 0) {
    (*(void (**)(void, void, uint64_t))(**((void **)this + 99) + 40))(*((void *)this + 99), *((void *)this + 96), *((void *)this + 98) & 0x7FFFFFFFFFFFFFFFLL);
  }
  md::IconLabelPart::~IconLabelPart(this);
  int v3 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    int v3 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v5) {
      operator new();
    }
  }
  uint64_t v4 = *(void (**)(void))(**((void **)v3 + 91) + 40);
  v4();
}

{
  uint64_t v2;
  uint64_t vars8;

  *(void *)this = &unk_1EF539EE0;
  uint64_t v2 = *((void *)this + 104);
  *((void *)this + 104) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  if (*((char *)this + 791) < 0) {
    (*(void (**)(void, void, uint64_t))(**((void **)this + 99) + 40))(*((void *)this + 99), *((void *)this + 96), *((void *)this + 98) & 0x7FFFFFFFFFFFFFFFLL);
  }
  md::IconLabelPart::~IconLabelPart(this);
}

void md::IconLabelPart::~IconLabelPart(md::IconLabelPart *this)
{
  *(void *)this = &unk_1EF531FD8;
  if (*((unsigned char *)this + 756)) {
    *((unsigned char *)this + 756) = 0;
  }
  uint64_t v2 = *((void *)this + 92);
  *((void *)this + 92) = 0;
  if (v2) {
    MEMORY[0x1A6239270](v2, 0x1000C40AE2C30F4);
  }
  uint64_t v3 = *((void *)this + 91);
  *((void *)this + 91) = 0;
  if (v3) {
    MEMORY[0x1A6239270](v3, 0x1000C40AE2C30F4);
  }
  uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 81);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  *(void *)this = &unk_1EF5540C8;
  free(*((void **)this + 59));
  free(*((void **)this + 60));
  free(*((void **)this + 62));
  free(*((void **)this + 29));
  free(*((void **)this + 30));
  free(*((void **)this + 32));
}

{
  float *v1;
  void (*v2)(void);
  int v3;
  uint64_t vars8;

  md::IconLabelPart::~IconLabelPart(this);
  float v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    float v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

void md::HorizontalTextLabelPart::~HorizontalTextLabelPart(md::HorizontalTextLabelPart *this)
{
  md::TextLabelPart::~TextLabelPart(this);
  float v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    float v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

void md::TextLabelPart::~TextLabelPart(md::TextLabelPart *this)
{
  *(void *)this = &unk_1EF533088;
  uint64_t v2 = (void *)*((void *)this + 117);
  if (v2)
  {
    *((void *)this + 118) = v2;
    operator delete(v2);
  }
  if (*((unsigned char *)this + 920)) {
    *((unsigned char *)this + 920) = 0;
  }
  int v3 = (void *)*((void *)this + 110);
  if (v3)
  {
    *((void *)this + 111) = v3;
    operator delete(v3);
  }
  if (*((unsigned char *)this + 856)) {
    *((unsigned char *)this + 856) = 0;
  }
  uint64_t v4 = *((void *)this + 106);
  *((void *)this + 106) = 0;
  if (v4) {
    MEMORY[0x1A6239270](v4, 0x1000C40AE2C30F4);
  }
  uint64_t v5 = *((void *)this + 105);
  *((void *)this + 105) = 0;
  if (v5) {
    MEMORY[0x1A6239270](v5, 0x1000C40AE2C30F4);
  }
  unint64_t v6 = (std::__shared_weak_count *)*((void *)this + 91);
  if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 77);
    if (!v7) {
      goto LABEL_19;
    }
  }
  else
  {
    uint64_t v7 = (std::__shared_weak_count *)*((void *)this + 77);
    if (!v7) {
      goto LABEL_19;
    }
  }
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
LABEL_19:
  uint64_t v8 = (std::__shared_weak_count *)*((void *)this + 75);
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 73);
    if (!v9) {
      goto LABEL_25;
    }
  }
  else
  {
    uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 73);
    if (!v9) {
      goto LABEL_25;
    }
  }
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
LABEL_25:
  *(void *)this = &unk_1EF5540C8;
  free(*((void **)this + 59));
  free(*((void **)this + 60));
  free(*((void **)this + 62));
  free(*((void **)this + 29));
  free(*((void **)this + 30));
  free(*((void **)this + 32));
}

{
  float *v1;
  void (*v2)(void);
  int v3;
  uint64_t vars8;

  md::TextLabelPart::~TextLabelPart(this);
  float v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    float v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

void md::LabelText::~LabelText(md::LabelText *this)
{
  *(void *)this = &unk_1EF554458;
  uint64_t v4 = (uint64_t *)((char *)this + 96);
  std::vector<md::FontGlyphQuad,geo::StdAllocator<md::FontGlyphQuad,mdm::Allocator>>::__destroy_vector::operator()[abi:nn180100](&v4);
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 11);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v4 = (uint64_t *)((char *)this + 32);
  std::vector<md::FontGlyphQuad,geo::StdAllocator<md::FontGlyphQuad,mdm::Allocator>>::__destroy_vector::operator()[abi:nn180100](&v4);
  int v3 = (std::__shared_weak_count *)*((void *)this + 3);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

{
  uint64_t vars8;

  md::LabelText::~LabelText(this);
  JUMPOUT(0x1A6239270);
}

uint64_t **std::vector<md::FontGlyphQuad,geo::StdAllocator<md::FontGlyphQuad,mdm::Allocator>>::__destroy_vector::operator()[abi:nn180100](uint64_t **result)
{
  float v1 = *result;
  uint64_t v2 = **result;
  if (!v2) {
    return result;
  }
  uint64_t v3 = v1[1];
  uint64_t v4 = **result;
  uint64_t v5 = *result;
  if (v3 == v2) {
    goto LABEL_14;
  }
  unint64_t v6 = result;
  do
  {
    uint64_t v7 = *(std::__shared_weak_count **)(v3 - 64);
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *, uint64_t))v7->__on_zero_shared)(v7, v4);
      std::__shared_weak_count::__release_weak(v7);
      uint64_t v8 = *(std::__shared_weak_count **)(v3 - 80);
      if (!v8) {
        goto LABEL_4;
      }
    }
    else
    {
      uint64_t v8 = *(std::__shared_weak_count **)(v3 - 80);
      if (!v8) {
        goto LABEL_4;
      }
    }
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *, uint64_t))v8->__on_zero_shared)(v8, v4);
      std::__shared_weak_count::__release_weak(v8);
    }
LABEL_4:
    v3 -= 88;
  }
  while (v3 != v2);
  uint64_t v5 = *v6;
LABEL_14:
  v1[1] = v2;
  uint64_t v9 = *(uint64_t (**)(void))(*(void *)v5[3] + 40);
  return (uint64_t **)v9();
}

uint64_t std::__shared_ptr_emplace<md::LabelText>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void md::StyleCrossFadeLabelPart::~StyleCrossFadeLabelPart(md::StyleCrossFadeLabelPart *this)
{
  md::CompositeLabelPart::~CompositeLabelPart(this);
  float v1 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    float v1 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v3) {
      operator new();
    }
  }
  uint64_t v2 = *(void (**)(void))(**((void **)v1 + 91) + 40);
  v2();
}

uint64_t non-virtual thunk to'md::MapNavLabeler::routeSupport(md::MapNavLabeler *this)
{
  return *((void *)this + 7);
}

void md::LabelPool::addGlobalFeatureLabels(uint64_t a1, int a2, void *a3, void *a4)
{
  if (a3 != a4)
  {
    uint64_t v5 = a3;
    __p = 0;
    uint64_t v7 = (uint64_t **)(a1 + 680);
    __asm { FMOV            V0.2D, #1.0 }
    long long v56 = _Q0;
    while (1)
    {
      if (*(void *)(*(uint64_t (**)(void, void, void, void, void))(*(void *)*v5 + 552))(*v5, 0, 0, 0, 0))
      {
        int v13 = (*(uint64_t (**)(void))(*(void *)*v5 + 264))(*v5);
        if ((v13 - 6) < 2)
        {
          uint64_t v28 = *(void *)(a1 + 8);
          LODWORD(v62) = 1;
          md::LabelPool::labelForCustomFeature(&v59, a1, v28, v5, (unsigned int *)&v62, 1);
          uint64_t v29 = v59;
          if (v59)
          {
            unint64_t v30 = *v7;
            unsigned int v31 = v7;
            BOOL v32 = v7;
            if (*v7)
            {
              while (1)
              {
                while (1)
                {
                  BOOL v32 = (uint64_t **)v30;
                  unint64_t v33 = v30[4];
                  if ((unint64_t)v59 >= v33) {
                    break;
                  }
                  unint64_t v30 = *v32;
                  unsigned int v31 = v32;
                  if (!*v32) {
                    goto LABEL_41;
                  }
                }
                if (v33 >= (unint64_t)v59) {
                  break;
                }
                unint64_t v30 = v32[1];
                if (!v30)
                {
                  unsigned int v31 = v32 + 1;
                  goto LABEL_41;
                }
              }
            }
            else
            {
LABEL_41:
              int v34 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 688) + 16))(*(void *)(a1 + 688), 48, 8);
              uint64_t v35 = v34;
              uint64_t v36 = v60;
              v34[4] = (uint64_t)v59;
              v34[5] = (uint64_t)v36;
              if (v36) {
                atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              *int v34 = 0;
              v34[1] = 0;
              v34[2] = (uint64_t)v32;
              *unsigned int v31 = v34;
              uint64_t v37 = **(void **)(a1 + 672);
              if (v37)
              {
                *(void *)(a1 + 672) = v37;
                uint64_t v35 = *v31;
              }
              std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 680), v35);
              ++*(void *)(a1 + 696);
              uint64_t v38 = v59;
              if (!atomic_fetch_add((atomic_uchar *volatile)v59 + 1296, 1u) && !*((unsigned char *)v38 + 820))
              {
                *((unsigned char *)v38 + 1214) = -1;
                md::Label::updateStateMachineForStaging((uint64_t)v38, 0, 37);
              }
              *((unsigned char *)v38 + 1261) = 0;
              *((void *)v38 + 153) = 0;
              uint64_t v29 = v59;
            }
            md::Label::assignWorldPointToLabel(v29, *(LabelManager **)(a1 + 8));
          }
          uint64_t v39 = v60;
          if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
          goto LABEL_3;
        }
        if (v13 != 1)
        {
          if (v13 == 3)
          {
            uint64_t v14 = *v5;
            md::LineLabelFeature::updatePositions((md::LineLabelFeature *)*v5, *(md::LabelManager **)(a1 + 8), a2, 0);
            unsigned int v59 = 0;
            double v60 = 0;
            long long v61 = v56;
            md::LineLabelPlacer::placementsForRect(&v62, v14 + 192, (double *)&v59, a2);
            if (__p) {
              operator delete(__p);
            }
            float v15 = (unsigned int *)v63;
            unint64_t v16 = (unsigned int *)v62;
            __p = v62;
            if (v62 != v63)
            {
              do
              {
                md::LabelPool::labelForCustomFeature(&v59, a1, *(void *)(a1 + 8), v5, v16, 1);
                uint64_t v17 = v59;
                if (v59)
                {
                  uint64_t v18 = *v7;
                  uint64_t v19 = v7;
                  uint64_t v20 = v7;
                  if (*v7)
                  {
                    while (1)
                    {
                      while (1)
                      {
                        uint64_t v20 = (uint64_t **)v18;
                        unint64_t v21 = v18[4];
                        if ((unint64_t)v59 >= v21) {
                          break;
                        }
                        uint64_t v18 = *v20;
                        uint64_t v19 = v20;
                        if (!*v20) {
                          goto LABEL_21;
                        }
                      }
                      if (v21 >= (unint64_t)v59) {
                        break;
                      }
                      uint64_t v18 = v20[1];
                      if (!v18)
                      {
                        uint64_t v19 = v20 + 1;
                        goto LABEL_21;
                      }
                    }
                  }
                  else
                  {
LABEL_21:
                    unint64_t v22 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 688) + 16))(*(void *)(a1 + 688), 48, 8);
                    BOOL v23 = v22;
                    BOOL v24 = v60;
                    v22[4] = (uint64_t)v59;
                    v22[5] = (uint64_t)v24;
                    if (v24) {
                      atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    uint64_t *v22 = 0;
                    v22[1] = 0;
                    v22[2] = (uint64_t)v20;
                    char *v19 = v22;
                    uint64_t v25 = **(void **)(a1 + 672);
                    if (v25)
                    {
                      *(void *)(a1 + 672) = v25;
                      BOOL v23 = *v19;
                    }
                    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 680), v23);
                    ++*(void *)(a1 + 696);
                    unint64_t v26 = v59;
                    if (!atomic_fetch_add((atomic_uchar *volatile)v59 + 1296, 1u) && !*((unsigned char *)v26 + 820))
                    {
                      *((unsigned char *)v26 + 1214) = -1;
                      md::Label::updateStateMachineForStaging((uint64_t)v26, 0, 37);
                    }
                    *((unsigned char *)v26 + 1261) = 0;
                    *((void *)v26 + 153) = 0;
                    uint64_t v17 = v59;
                  }
                  md::Label::assignWorldPointToLabel(v17, *(LabelManager **)(a1 + 8));
                }
                BOOL v27 = v60;
                if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
                  std::__shared_weak_count::__release_weak(v27);
                }
                ++v16;
              }
              while (v16 != v15);
            }
          }
          goto LABEL_3;
        }
        uint64_t v40 = *v5;
        md::PointLabelFeature::updatePositions((md::PointLabelFeature *)*v5);
        uint64_t v41 = *(unsigned int **)(v40 + 456);
        uint8x8_t v42 = (unsigned int *)(v40 + 464);
        if (v41 != (unsigned int *)(v40 + 464)) {
          break;
        }
      }
LABEL_3:
      v5 += 2;
      if (v5 == a4)
      {
        if (__p) {
          operator delete(__p);
        }
        return;
      }
    }
    while (1)
    {
      md::LabelPool::labelForCustomFeature(&v59, a1, *(void *)(a1 + 8), v5, v41 + 8, 1);
      uint64_t v43 = v59;
      if (v59)
      {
        uint64_t v44 = *v7;
        unint64_t v45 = v7;
        int v46 = v7;
        if (*v7)
        {
          while (1)
          {
            while (1)
            {
              int v46 = (uint64_t **)v44;
              unint64_t v47 = v44[4];
              if ((unint64_t)v59 >= v47) {
                break;
              }
              uint64_t v44 = *v46;
              unint64_t v45 = v46;
              if (!*v46) {
                goto LABEL_64;
              }
            }
            if (v47 >= (unint64_t)v59) {
              break;
            }
            uint64_t v44 = v46[1];
            if (!v44)
            {
              unint64_t v45 = v46 + 1;
              goto LABEL_64;
            }
          }
        }
        else
        {
LABEL_64:
          uint64_t v48 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 688) + 16))(*(void *)(a1 + 688), 48, 8);
          uint64_t v49 = v48;
          unint64_t v50 = v60;
          v48[4] = (uint64_t)v59;
          v48[5] = (uint64_t)v50;
          if (v50) {
            atomic_fetch_add_explicit(&v50->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t *v48 = 0;
          v48[1] = 0;
          v48[2] = (uint64_t)v46;
          void *v45 = v48;
          uint64_t v51 = **(void **)(a1 + 672);
          if (v51)
          {
            *(void *)(a1 + 672) = v51;
            uint64_t v49 = *v45;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 680), v49);
          ++*(void *)(a1 + 696);
          uint64_t v52 = v59;
          if (!atomic_fetch_add((atomic_uchar *volatile)v59 + 1296, 1u) && !*((unsigned char *)v52 + 820))
          {
            *((unsigned char *)v52 + 1214) = -1;
            md::Label::updateStateMachineForStaging((uint64_t)v52, 0, 37);
          }
          *((unsigned char *)v52 + 1261) = 0;
          *((void *)v52 + 153) = 0;
          uint64_t v43 = v59;
        }
        md::Label::assignWorldPointToLabel(v43, *(LabelManager **)(a1 + 8));
      }
      unint64_t v53 = v60;
      if (v60 && !atomic_fetch_add(&v60->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
        std::__shared_weak_count::__release_weak(v53);
        uint64_t v54 = (unsigned int *)*((void *)v41 + 1);
        if (!v54)
        {
          do
          {
LABEL_79:
            unint64_t v55 = (unsigned int *)*((void *)v41 + 2);
            _ZF = *(void *)v55 == (void)v41;
            uint64_t v41 = v55;
          }
          while (!_ZF);
          goto LABEL_55;
        }
      }
      else
      {
        uint64_t v54 = (unsigned int *)*((void *)v41 + 1);
        if (!v54) {
          goto LABEL_79;
        }
      }
      do
      {
        unint64_t v55 = v54;
        uint64_t v54 = *(unsigned int **)v54;
      }
      while (v54);
LABEL_55:
      uint64_t v41 = v55;
      if (v55 == v42) {
        goto LABEL_3;
      }
    }
  }
}

void sub_1A17CC268(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, char a14)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *geo::ibitstream::readFloat@<X0>(uint64_t *this@<X0>, uint64_t a2@<X8>)
{
  int v13 = 0;
  unint64_t v2 = this[1];
  uint64_t v3 = this[2];
  char v4 = *((unsigned char *)this + 24);
  unint64_t v5 = v3 + 5;
  if (!v4) {
    unint64_t v5 = v3 + 4;
  }
  if (v2 >= v5)
  {
    uint64_t v6 = *this;
    if (*((unsigned char *)this + 24))
    {
      uint64_t v7 = 0;
      uint64_t v8 = v6 + v3;
      uint64_t v9 = v3 + 1;
      do
      {
        if (v9 + v7 >= v2) {
          int v10 = 0;
        }
        else {
          int v10 = *(unsigned __int8 *)(v8 + v7 + 1);
        }
        unsigned int v11 = ((v10 & (0xFFFF << (8 - v4))) >> (8 - v4)) | ((((1 << (8 - v4)) + 255) & *(unsigned __int8 *)(v8 + v7)) << v4);
        this[2] = v9 + v7;
        *((unsigned char *)&v13 + v7++) = v11;
      }
      while (v7 != 4);
      int v12 = v13;
    }
    else
    {
      int v12 = *(_DWORD *)(v6 + v3);
      this[2] = v3 + 4;
    }
    *(unsigned char *)a2 = 1;
    *(_DWORD *)(a2 + 4) = v12;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
  return this;
}

BOOL VKLocationCoordinate2DIsValid(double a1, double a2)
{
  BOOL v2 = a1 <= 90.0;
  if (a1 < -90.0) {
    BOOL v2 = 0;
  }
  if (a2 > 180.0) {
    BOOL v2 = 0;
  }
  return a2 >= -180.0 && v2;
}

uint64_t md::DaVinciCenterLineRoadsTileData::DaVinciCenterLineRoadsTileData(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, char a7, uint64_t *a8, void *a9, uint64_t a10, char a11, uint64_t *a12)
{
  LODWORD(v17) = a6;
  uint64_t v437 = *MEMORY[0x1E4F143B8];
  id v337 = a9;
  if (*(void *)(a5 + 8) == *(void *)a5)
  {
    BOOL v23 = 0;
    long long v430 = 0uLL;
  }
  else
  {
    uint64_t v22 = **(void **)a5;
    BOOL v23 = *(std::__shared_weak_count **)(v22 + 152);
    *(void *)&long long v430 = *(void *)(v22 + 144);
    *((void *)&v430 + 1) = v23;
    if (v23) {
      atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
    }
  }
  md::MapTileData::MapTileData(a1, a3, a4, (uint64_t *)&v430, 1);
  if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
    std::__shared_weak_count::__release_weak(v23);
  }
  uint64_t v24 = a1;
  *(void *)a1 = &unk_1EF54C198;
  *(void *)(a1 + 632) = &unk_1EF54C1D8;
  v339 = (void *)(a1 + 760);
  *(_OWORD *)(a1 + 760) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  unint64_t v26 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
LABEL_582:
      operator new();
  }
  *(void *)(v24 + 776) = *((void *)v26 + 91);
  *(void *)(v24 + 784) = 0;
  if ((atomic_load_explicit(v25, memory_order_acquire) & 1) == 0
  {
    operator new();
  }
  *(void *)(v24 + 792) = *((void *)v26 + 91);
  *(void *)(v24 + 800) = 0;
  *(_DWORD *)(v24 + 808) = 1065353216;
  *(void *)(v24 + 816) = 0;
  BOOL v27 = operator new(0xE8uLL);
  v27[1] = 0;
  v27[2] = 0;
  void *v27 = &unk_1EF586DB8;
  uint64_t v28 = ggl::BufferData::BufferData((uint64_t)(v27 + 3), qword_1E9552208, 2, 1, 6, 1);
  v27[28] = ggl::Tile::View::reflection(void)::reflection;
  v27[3] = &unk_1EF55E258;
  *(void *)(v24 + 824) = v28;
  *(void *)(v24 + 832) = v27;
  uint64_t v29 = operator new(0xE8uLL);
  v29[1] = 0;
  v29[2] = 0;
  *uint64_t v29 = &unk_1EF586E28;
  uint64_t v30 = ggl::BufferData::BufferData((uint64_t)(v29 + 3), qword_1E95523C8, 2, 1, 6, 1);
  v29[28] = ggl::Tile::Transform::reflection(void)::reflection;
  v29[3] = &unk_1EF55E298;
  *(void *)(v24 + 840) = v30;
  *(void *)(v24 + 848) = v29;
  *(unsigned char *)(v24 + 856) = v17;
  *(unsigned char *)(v24 + 857) = a7;
  long long v430 = 0u;
  long long v431 = 0u;
  int v432 = 1065353216;
  *(_OWORD *)v427 = 0u;
  long long v428 = 0u;
  int v429 = 1065353216;
  *(_OWORD *)v424 = 0u;
  long long v425 = 0u;
  int v426 = 1065353216;
  *(_OWORD *)v421 = 0u;
  long long v422 = 0u;
  int v423 = 1065353216;
  *(_OWORD *)v418 = 0u;
  long long v419 = 0u;
  int v420 = 1065353216;
  *(_OWORD *)__p = 0u;
  *(_OWORD *)v416 = 0u;
  float v417 = 1.0;
  unint64_t v26 = *(float **)a5;
  v346 = *(float **)(a5 + 8);
  int v341 = a2;
  if (*(float **)a5 != v346)
  {
    uint64_t v24 = a10;
    BOOL v345 = a2 == 46;
    BOOL v344 = a2 == 48;
    uint64_t v31 = 151;
    if (v17) {
      uint64_t v31 = 0x100000097;
    }
    uint64_t v348 = v31;
    a7 = -32;
    a5 = 168;
    do
    {
      int v32 = a2;
      uint64_t v33 = *(void *)v26;
      if (v32 != 48)
      {
        if (v341 == 47)
        {
          uint64_t v83 = *(void *)(v33 + 144);
          uint64_t v84 = a8[1];
          uint64_t v413 = *a8;
          v414 = (std::__shared_weak_count *)v84;
          if (v84) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v84 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v85 = v414;
          if (v414 && !atomic_fetch_add(&v414->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v85->__on_zero_shared)(v85);
            std::__shared_weak_count::__release_weak(v85);
          }
          uint64_t v86 = *(void *)(v33 + 144);
          uint64_t v87 = a8[1];
          uint64_t v411 = *a8;
          v412 = (std::__shared_weak_count *)v87;
          if (v87) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v87 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v88 = v412;
          if (v412 && !atomic_fetch_add(&v412->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
            std::__shared_weak_count::__release_weak(v88);
          }
          uint64_t v89 = *(void *)(v33 + 144);
          uint64_t v90 = a8[1];
          uint64_t v409 = *a8;
          v410 = (std::__shared_weak_count *)v90;
          if (v90) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v90 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v91 = v410;
          if (v410 && !atomic_fetch_add(&v410->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
            std::__shared_weak_count::__release_weak(v91);
          }
          uint64_t v92 = *(void *)(v33 + 144);
          uint64_t v93 = a8[1];
          uint64_t v407 = *a8;
          v408 = (std::__shared_weak_count *)v93;
          if (v93) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v93 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v94 = v408;
          if (v408 && !atomic_fetch_add(&v408->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
            std::__shared_weak_count::__release_weak(v94);
          }
          BOOL v360 = 0;
          int v349 = 0;
          goto LABEL_119;
        }
        BOOL v360 = v344;
        int v349 = v345;
        if (v341 != 46) {
          goto LABEL_119;
        }
      }
      for (unint64_t i = 0; geo::codec::VectorTile::poisCount(*(geo::codec::VectorTile **)(v33 + 144)) > i; ++i)
      {
        uint64_t v35 = (gss::Allocator *)geo::codec::VectorTile::pois(*(geo::codec::VectorTile **)(v33 + 144));
        uint64_t v36 = (char *)v35 + 224 * i;
        uint64_t v39 = *((void *)v36 + 3);
        uint64_t v38 = (uint64_t *)(v36 + 24);
        uint64_t v37 = v39;
        if (!v39) {
          continue;
        }
        unint64_t v40 = *(unsigned __int8 *)(v37 + 33);
        if (!*(unsigned char *)(v37 + 33)) {
          continue;
        }
        uint64_t v41 = *(_DWORD **)v37;
        if (*v41 == 6)
        {
          unint64_t v42 = 0;
LABEL_29:
          if (v41[2 * v42 + 1] != 446) {
            continue;
          }
          float v45 = *((float *)v35 + 56 * i + 24);
          if (v45 == 3.4028e38) {
            float v12 = 0.0;
          }
          else {
            float v12 = *(float *)(a1 + 624) * v45;
          }
          int v46 = (float *)((char *)v35 + 224 * i);
          float v14 = v46[22];
          float v13 = v46[23];
          *(void *)((char *)&__src + 7) = 0;
          *(void *)&long long __src = 0;
          HIBYTE(__src) = 1;
          if (v341 == 48)
          {
            uint64_t v47 = gss::Allocator::instance(v35);
            uint64_t v48 = (_DWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v47 + 16))(v47, 26, 1);
            uint64_t v49 = v48;
            if ((void)__src)
            {
              if (WORD5(__src))
              {
                uint64_t v48 = memmove(v48, (const void *)__src, 4 * WORD5(__src));
                if (WORD5(__src)) {
                  uint64_t v48 = memmove((char *)v49 + 18, (const void *)(__src + WORD4(__src)), 2 * WORD5(__src));
                }
              }
              uint64_t v50 = gss::Allocator::instance((gss::Allocator *)v48);
              (*(void (**)(uint64_t, void, void))(*(void *)v50 + 40))(v50, __src, WORD6(__src));
            }
            WORD6(__src) = 4;
            *(void *)&long long __src = v49;
            WORD4(__src) = 18;
            uint64_t v51 = WORD5(__src);
            v49[WORD5(__src)] = 65538;
            *((_WORD *)v49 + v51 + 9) = 0;
            ++WORD5(__src);
            HIBYTE(__src) = 0;
            *(_WORD *)((char *)v49 + 2 * WORD5(__src) + WORD4(__src) - 2) = 1;
          }
          uint64_t v52 = *a8;
          md::createFeatureAttributeSet((gss::Allocator *)&v433, v38);
          gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v400, v52, (gss::FeatureAttributeSet *)&v433, (gss::QueryOverrides *)&__src);
          if ((void)v433)
          {
            *((void *)&v433 + 1) = v433;
            unint64_t v53 = (gss::Allocator *)(*(uint64_t (**)(long long *, void, char *))(*(void *)v435 + 40))(v435, v433, &v434[-v433]);
          }
          uint64_t v54 = (uint64_t *)v400;
          int8x8_t v55 = *(int8x8_t *)(a1 + 768);
          if (!*(void *)&v55) {
            goto LABEL_62;
          }
          unint64_t v56 = 0x9DDFEA08EB382D69 * (((8 * v400) + 8) ^ HIDWORD(v400));
          unint64_t v57 = 0x9DDFEA08EB382D69 * (HIDWORD(v400) ^ (v56 >> 47) ^ v56);
          unint64_t v58 = 0x9DDFEA08EB382D69 * (v57 ^ (v57 >> 47));
          uint8x8_t v59 = (uint8x8_t)vcnt_s8(v55);
          v59.i16[0] = vaddlv_u8(v59);
          if (v59.u32[0] > 1uLL)
          {
            unint64_t v60 = v58;
            if (v58 >= *(void *)&v55) {
              unint64_t v60 = v58 % *(void *)&v55;
            }
          }
          else
          {
            unint64_t v60 = v58 & (*(void *)&v55 - 1);
          }
          long long v61 = *(void **)(*v339 + 8 * v60);
          if (!v61 || (char v62 = (void *)*v61) == 0)
          {
LABEL_62:
            uint64_t v66 = (float *)operator new(0xCuLL);
            float *v66 = v14;
            v66[1] = v13;
            v66[2] = v12;
            *(void *)&long long v433 = v54;
            *((void *)&v433 + 1) = v401;
            if (v401) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v401 + 8), 1uLL, memory_order_relaxed);
            }
            v434 = 0;
            v435 = 0;
            v436 = 0;
            uint64_t v67 = (char *)operator new(0xCuLL);
            v435 = (long long *)(v67 + 12);
            v436 = v67 + 12;
            *(void *)uint64_t v67 = *(void *)v66;
            *((float *)v67 + 2) = v66[2];
            v434 = v67;
            std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::Allocator>>::__emplace_unique_key_args<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::pair<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>> const,std::vector<gm::Matrix<float,3,1>>>>((unint64_t)v339, (unint64_t)v54, (uint64_t)&v433);
            if (v434)
            {
              v435 = (long long *)v434;
              operator delete(v434);
            }
            char v68 = (std::__shared_weak_count *)*((void *)&v433 + 1);
            if (*((void *)&v433 + 1)
              && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v433 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
              std::__shared_weak_count::__release_weak(v68);
            }
            operator delete(v66);
            uint64_t v69 = (std::__shared_weak_count *)v401;
            if (!v401) {
              goto LABEL_72;
            }
            goto LABEL_70;
          }
          if (v59.u32[0] < 2uLL)
          {
            uint64_t v63 = *(void *)&v55 - 1;
            while (1)
            {
              uint64_t v65 = v62[1];
              if (v65 == v58)
              {
                if (v62[2] == v400) {
                  goto LABEL_75;
                }
              }
              else if ((v65 & v63) != v60)
              {
                goto LABEL_62;
              }
              char v62 = (void *)*v62;
              if (!v62) {
                goto LABEL_62;
              }
            }
          }
          while (1)
          {
            unint64_t v64 = v62[1];
            if (v64 == v58)
            {
              if (v62[2] == v400)
              {
LABEL_75:
                uint64_t v72 = (float *)v62[5];
                unint64_t v71 = v62[6];
                if ((unint64_t)v72 < v71)
                {
                  *uint64_t v72 = v14;
                  v72[1] = v13;
                  int v73 = (char *)(v72 + 3);
                  v72[2] = v12;
                  goto LABEL_95;
                }
                uint64_t v74 = (float *)v62[4];
                unint64_t v75 = 0xAAAAAAAAAAAAAAABLL * (v72 - v74) + 1;
                if (v75 > 0x1555555555555555) {
                  abort();
                }
                int v76 = v26;
                unint64_t v77 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v71 - (void)v74) >> 2);
                if (2 * v77 > v75) {
                  unint64_t v75 = 2 * v77;
                }
                if (v77 >= 0xAAAAAAAAAAAAAAALL) {
                  unint64_t v78 = 0x1555555555555555;
                }
                else {
                  unint64_t v78 = v75;
                }
                if (!v78)
                {
                  unint64_t v53 = 0;
                  goto LABEL_87;
                }
                if (v78 <= 0x1555555555555555)
                {
                  unint64_t v53 = (gss::Allocator *)operator new(12 * v78);
LABEL_87:
                  int v79 = (float *)((char *)v53 + 4 * (v72 - v74));
                  *int v79 = v14;
                  v79[1] = v13;
                  v79[2] = v12;
                  uint64_t v80 = v79;
                  if (v72 == v74)
                  {
                    uint64_t v24 = a10;
                  }
                  else
                  {
                    uint64_t v24 = a10;
                    do
                    {
                      uint64_t v81 = *(void *)(v72 - 3);
                      v72 -= 3;
                      int v82 = *((_DWORD *)v72 + 2);
                      *(void *)(v80 - 3) = v81;
                      v80 -= 3;
                      *((_DWORD *)v80 + 2) = v82;
                    }
                    while (v72 != v74);
                    uint64_t v72 = (float *)v62[4];
                  }
                  int v73 = (char *)(v79 + 3);
                  v62[4] = v80;
                  v62[5] = v79 + 3;
                  v62[6] = (char *)v53 + 12 * v78;
                  if (v72) {
                    operator delete(v72);
                  }
                  unint64_t v26 = v76;
LABEL_95:
                  v62[5] = v73;
                  a7 = -32;
                  uint64_t v69 = (std::__shared_weak_count *)v401;
                  if (!v401)
                  {
LABEL_72:
                    if (!BYTE14(__src))
                    {
                      if ((void)__src)
                      {
                        uint64_t v70 = gss::Allocator::instance(v53);
                        (*(void (**)(uint64_t, void, void))(*(void *)v70 + 40))(v70, __src, WORD6(__src));
                      }
                    }
                    goto LABEL_19;
                  }
LABEL_70:
                  if (!atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
                    std::__shared_weak_count::__release_weak(v69);
                  }
                  goto LABEL_72;
                }
LABEL_579:
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
            }
            else
            {
              if (v64 >= *(void *)&v55) {
                v64 %= *(void *)&v55;
              }
              if (v64 != v60) {
                goto LABEL_62;
              }
            }
            char v62 = (void *)*v62;
            if (!v62) {
              goto LABEL_62;
            }
          }
        }
        unint64_t v42 = 0;
        uint64_t v43 = v41 + 2;
        do
        {
          if (v40 - 1 == v42) {
            goto LABEL_19;
          }
          int v44 = *v43;
          v43 += 2;
          ++v42;
        }
        while (v44 != 6);
        if (v42 < v40) {
          goto LABEL_29;
        }
LABEL_19:
        ;
      }
      BOOL v360 = v344;
      int v349 = v345;
      a5 = 168;
LABEL_119:
      uint64_t v25 = (atomic_uchar *)geo::codec::VectorTile::lines(*(geo::codec::VectorTile **)(v33 + 144));
      unint64_t v95 = geo::codec::VectorTile::linesCount(*(geo::codec::VectorTile **)(v33 + 144));
      unint64_t v17 = v95;
      a2 = v341;
      if (v95)
      {
        uint64_t v96 = 0;
        v356 = v26;
        v358 = v25;
        unint64_t v353 = v95;
        do
        {
          uint64_t v97 = *(void *)v26;
          LOWORD(v433) = a2;
          uint64_t v98 = *(void *)(v24 + 24);
          if (!v98)
          {
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
            goto LABEL_582;
          }
          unint64_t v99 = (unint64_t)&v25[168 * v96];
          if ((*(uint64_t (**)(uint64_t, uint64_t, unint64_t, long long *))(*(void *)v98 + 48))(v98, v97, v99, &v433))goto LABEL_121; {
          if (v360)
          }
            goto LABEL_139;
          uint64_t v100 = *(void *)(v99 + 24);
          if (v100)
          {
            unint64_t v101 = *(unsigned __int8 *)(v100 + 33);
            if (*(unsigned char *)(v100 + 33))
            {
              uint64_t v102 = *(_DWORD **)v100;
              if (*v102 == 185)
              {
                unint64_t v103 = 0;
                BOOL v104 = 1;
LABEL_133:
                int v107 = (v102[2 * v103 + 1] & 0xFFFFFFFD) == 0 && v104;
                if (v349 != v107) {
                  goto LABEL_121;
                }
                goto LABEL_139;
              }
              unint64_t v103 = 0;
              uint64_t v105 = v102 + 2;
              while (v101 - 1 != v103)
              {
                int v106 = *v105;
                v105 += 2;
                ++v103;
                if (v106 == 185)
                {
                  BOOL v104 = v103 < v101;
                  goto LABEL_133;
                }
              }
            }
          }
          if (v349) {
            goto LABEL_121;
          }
LABEL_139:
          FeatureAttributeSet = md::createFeatureAttributeSet((gss::Allocator *)&v433, (uint64_t *)(v99 + 24));
          unint64_t v400 = 0;
          unint64_t v401 = 0;
          v402 = 0;
          uint64_t v403 = gss::Allocator::instance(FeatureAttributeSet);
          v109 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v403 + 16))(v403, 8, 4);
          unint64_t v400 = (unint64_t)v109;
          v402 = v109 + 1;
          if (v109) {
            uint64_t *v109 = v348;
          }
          unint64_t v401 = (unint64_t)(v109 + 1);
          gss::FeatureAttributeSet::setByReplacingAttributes((gss::Allocator *)&v433, (unsigned int **)&v400, (unsigned int **)&__src);
          uint64_t v110 = (void *)*((void *)&__src + 1);
          uint64_t v111 = __src;
          uint64_t v112 = *((void *)&__src + 1) - __src;
          unint64_t v113 = (uint64_t)(*((void *)&__src + 1) - __src) >> 3;
          uint64_t v114 = (uint64_t)v434;
          uint64_t v115 = v433;
          if (v113 <= (uint64_t)&v434[-v433] >> 3)
          {
            uint64_t v118 = *((void *)&v433 + 1);
            unint64_t v120 = (uint64_t)(*((void *)&v433 + 1) - v433) >> 3;
            if (v120 >= v113)
            {
              uint64_t v124 = v433;
              if ((void)__src != *((void *)&__src + 1))
              {
                do
                {
                  *(_DWORD *)uint64_t v124 = *(_DWORD *)v111;
                  *(_WORD *)(v124 + 4) = *(_WORD *)(v111 + 4);
                  v124 += 8;
                  v111 += 8;
                }
                while ((void *)v111 != v110);
              }
              BOOL v123 = (char *)(v124 - v115);
              uint64_t v118 = v115;
            }
            else
            {
              uint64_t v121 = (void *)(__src + 8 * v120);
              if (*((void *)&v433 + 1) != (void)v433)
              {
                do
                {
                  *(_DWORD *)uint64_t v115 = *(_DWORD *)v111;
                  *(_WORD *)(v115 + 4) = *(_WORD *)(v111 + 4);
                  v111 += 8;
                  v115 += 8;
                }
                while ((void *)v111 != v121);
              }
              uint64_t v122 = (void *)v118;
              while (v121 != v110)
              {
                if (v122) {
                  void *v122 = *v121;
                }
                ++v121;
                ++v122;
              }
              BOOL v123 = (char *)v122 - v118;
            }
          }
          else
          {
            if ((void)v433)
            {
              *((void *)&v433 + 1) = v433;
              (*(void (**)(long long *))(*(void *)v435 + 40))(v435);
              uint64_t v114 = 0;
              long long v433 = 0uLL;
              v434 = 0;
            }
            if (v112 < 0) {
              goto LABEL_578;
            }
            uint64_t v116 = v114 >> 2;
            if (v114 >> 2 <= v113) {
              uint64_t v116 = v113;
            }
            unint64_t v117 = (unint64_t)v114 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v116;
            if (v117 >> 61) {
LABEL_578:
            }
              abort();
            uint64_t v118 = (*(uint64_t (**)(long long *, unint64_t, uint64_t))(*(void *)v435 + 16))(v435, 8 * v117, 4);
            *(void *)&long long v433 = v118;
            *((void *)&v433 + 1) = v118;
            v434 = (char *)(v118 + 8 * v117);
            uint64_t v119 = (void *)v118;
            if ((void *)v111 != v110)
            {
              uint64_t v119 = (void *)v118;
              do
              {
                if (v119) {
                  void *v119 = *(void *)v111;
                }
                v111 += 8;
                ++v119;
              }
              while ((void *)v111 != v110);
            }
            BOOL v123 = (char *)v119 - v118;
          }
          *((void *)&v433 + 1) = &v123[v118];
          if ((void)__src)
          {
            *((void *)&__src + 1) = __src;
            (*(void (**)(uint64_t, void, void))(*(void *)v406 + 40))(v406, __src, v405 - __src);
          }
          if (v400)
          {
            unint64_t v401 = v400;
            (*(void (**)(uint64_t, unint64_t, unint64_t))(*(void *)v403 + 40))(v403, v400, (unint64_t)v402 - v400);
          }
          long long v125 = v433;
          uint64_t v126 = *((void *)&v433 + 1) - v433;
          unint64_t v127 = (uint64_t)(*((void *)&v433 + 1) - v433) >> 3;
          unint64_t v128 = v127;
          if (*((void *)&v433 + 1) != (void)v433)
          {
            unint64_t v128 = (uint64_t)(*((void *)&v433 + 1) - v433) >> 3;
            v129 = (unsigned int *)v433;
            do
            {
              unint64_t v130 = ((v128 << 6) - 0x61C8864680B583EBLL + (v128 >> 2) + *v129) ^ v128;
              unint64_t v128 = (*((unsigned __int16 *)v129 + 2) - 0x61C8864680B583EBLL + (v130 << 6) + (v130 >> 2)) ^ v130;
              v129 += 2;
            }
            while (v129 != *((unsigned int **)&v433 + 1));
          }
          unint64_t v131 = (unint64_t)__p[1];
          if (!__p[1]) {
            goto LABEL_214;
          }
          uint8x8_t v132 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
          v132.i16[0] = vaddlv_u8(v132);
          if (v132.u32[0] > 1uLL)
          {
            unint64_t v133 = v128;
            if ((void *)v128 >= __p[1]) {
              unint64_t v133 = v128 % (unint64_t)__p[1];
            }
          }
          else
          {
            unint64_t v133 = ((unint64_t)__p[1] - 1) & v128;
          }
          unsigned __int8 v134 = (void *)*((void *)__p[0] + v133);
          if (!v134 || (v135 = (void *)*v134) == 0)
          {
LABEL_214:
            v149 = operator new(8uLL);
            void *v149 = v99;
            int8x8_t v150 = v149 + 1;
            if ((void)v125 != *((void *)&v125 + 1))
            {
              unint64_t v151 = (unsigned int *)v125;
              do
              {
                unint64_t v152 = ((v127 << 6) - 0x61C8864680B583EBLL + (v127 >> 2) + *v151) ^ v127;
                unint64_t v127 = (*((unsigned __int16 *)v151 + 2) - 0x61C8864680B583EBLL + (v152 << 6) + (v152 >> 2)) ^ v152;
                v151 += 2;
              }
              while (v151 != *((unsigned int **)&v125 + 1));
            }
            *(void *)&long long v153 = v149;
            *((void *)&v153 + 1) = v149 + 1;
            long long v363 = v153;
            uint64_t v24 = a10;
            if (v131)
            {
              uint8x8_t v154 = (uint8x8_t)vcnt_s8((int8x8_t)v131);
              v154.i16[0] = vaddlv_u8(v154);
              if (v154.u32[0] > 1uLL)
              {
                unint64_t v99 = v127;
                if (v127 >= v131) {
                  unint64_t v99 = v127 % v131;
                }
              }
              else
              {
                unint64_t v99 = (v131 - 1) & v127;
              }
              v155 = (void *)*((void *)__p[0] + v99);
              if (v155)
              {
                unint64_t v156 = (void *)*v155;
                if (v156)
                {
                  if (v154.u32[0] < 2uLL)
                  {
                    while (1)
                    {
                      uint64_t v162 = v156[1];
                      if (v162 == v127)
                      {
                        uint64_t v164 = v156[2];
                        uint64_t v163 = v156[3];
                        if (v163 - v164 == v126)
                        {
                          if (v164 == v163) {
                            goto LABEL_253;
                          }
                          uint64_t v165 = v125;
                          while (*(_DWORD *)v164 == *(_DWORD *)v165
                               && *(unsigned __int16 *)(v164 + 4) == *(unsigned __int16 *)(v165 + 4))
                          {
                            v164 += 8;
                            v165 += 8;
                            if (v164 == v163) {
                              goto LABEL_253;
                            }
                          }
                        }
                      }
                      else if ((v162 & (v131 - 1)) != v99)
                      {
                        goto LABEL_254;
                      }
                      unint64_t v156 = (void *)*v156;
                      if (!v156) {
                        goto LABEL_254;
                      }
                    }
                  }
                  do
                  {
                    unint64_t v157 = v156[1];
                    if (v157 == v127)
                    {
                      uint64_t v159 = v156[2];
                      uint64_t v158 = v156[3];
                      if (v158 - v159 == v126)
                      {
                        if (v159 == v158)
                        {
LABEL_253:
                          a7 = -32;
                          a5 = 168;
                          uint64_t v25 = v358;
                          unint64_t v17 = v353;
                          v167 = (void *)v363;
                          goto LABEL_322;
                        }
                        uint64_t v160 = v125;
                        while (*(_DWORD *)v159 == *(_DWORD *)v160
                             && *(unsigned __int16 *)(v159 + 4) == *(unsigned __int16 *)(v160 + 4))
                        {
                          v159 += 8;
                          v160 += 8;
                          if (v159 == v158) {
                            goto LABEL_253;
                          }
                        }
                      }
                    }
                    else
                    {
                      if (v157 >= v131) {
                        v157 %= v131;
                      }
                      if (v157 != v99) {
                        break;
                      }
                    }
                    unint64_t v156 = (void *)*v156;
                  }
                  while (v156);
                }
              }
            }
LABEL_254:
            v168 = (uint64_t *)operator new(0x48uLL);
            *(void *)&long long __src = v168;
            *((void *)&__src + 1) = v416;
            LOBYTE(v405) = 0;
            uint64_t *v168 = 0;
            v168[1] = v127;
            v168[3] = 0;
            v168[4] = 0;
            v168[2] = 0;
            v168[5] = gss::Allocator::instance((gss::Allocator *)v168);
            std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__assign_with_size[abi:nn180100]<std::pair<gss::StyleAttribute,unsigned short>*,std::pair<gss::StyleAttribute,unsigned short>*>(v168 + 2, v433, *((void **)&v433 + 1), (uint64_t)(*((void *)&v433 + 1) - v433) >> 3);
            *((_OWORD *)v168 + 3) = v363;
            v168[8] = (uint64_t)v150;
            LOBYTE(v405) = 1;
            float v169 = (float)((unint64_t)v416[1] + 1);
            a7 = -32;
            if (!v131 || (float)(v417 * (float)v131) < v169)
            {
              BOOL v170 = (v131 & (v131 - 1)) != 0;
              if (v131 < 3) {
                BOOL v170 = 1;
              }
              unint64_t v171 = v170 | (2 * v131);
              unint64_t v172 = vcvtps_u32_f32(v169 / v417);
              if (v171 <= v172) {
                size_t prime = v172;
              }
              else {
                size_t prime = v171;
              }
              if (prime == 1)
              {
                size_t prime = 2;
              }
              else if ((prime & (prime - 1)) != 0)
              {
                size_t prime = std::__next_prime(prime);
              }
              unint64_t v131 = (unint64_t)__p[1];
              if ((void *)prime > __p[1])
              {
LABEL_266:
                if (prime >> 61) {
                  goto LABEL_579;
                }
                uint64_t v174 = operator new(8 * prime);
                v175 = __p[0];
                __p[0] = v174;
                if (v175) {
                  operator delete(v175);
                }
                uint64_t v176 = 0;
                __p[1] = (void *)prime;
                do
                  *((void *)__p[0] + v176++) = 0;
                while (prime != v176);
                unint64_t v177 = (void **)v416[0];
                if (!v416[0]) {
                  goto LABEL_299;
                }
                size_t v178 = *((void *)v416[0] + 1);
                size_t v179 = prime - 1;
                if ((prime & (prime - 1)) == 0)
                {
                  size_t v180 = v178 & v179;
                  *((void *)__p[0] + v180) = v416;
                  for (j = *v177; *v177; j = *v177)
                  {
                    size_t v182 = j[1] & v179;
                    if (v182 == v180)
                    {
                      unint64_t v177 = (void **)j;
                    }
                    else if (*((void *)__p[0] + v182))
                    {
                      *unint64_t v177 = (void *)*j;
                      uint64_t v183 = 8 * v182;
                      void *j = **(void **)((char *)__p[0] + v183);
                      **(void **)((char *)__p[0] + v183) = j;
                    }
                    else
                    {
                      *((void *)__p[0] + v182) = v177;
                      unint64_t v177 = (void **)j;
                      size_t v180 = v182;
                    }
                  }
                  goto LABEL_299;
                }
                if (v178 >= prime) {
                  v178 %= prime;
                }
                *((void *)__p[0] + v178) = v416;
                uint64_t v193 = *v177;
                if (!*v177)
                {
LABEL_299:
                  unint64_t v131 = prime;
                  goto LABEL_300;
                }
                while (2)
                {
                  size_t v195 = v193[1];
                  if (v195 >= prime) {
                    v195 %= prime;
                  }
                  if (v195 != v178)
                  {
                    if (!*((void *)__p[0] + v195))
                    {
                      *((void *)__p[0] + v195) = v177;
LABEL_304:
                      unint64_t v177 = (void **)v193;
                      uint64_t v193 = (void *)*v193;
                      size_t v178 = v195;
                      if (!v193) {
                        goto LABEL_299;
                      }
                      continue;
                    }
                    *unint64_t v177 = (void *)*v193;
                    uint64_t v194 = 8 * v195;
                    *uint64_t v193 = **(void **)((char *)__p[0] + v194);
                    **(void **)((char *)__p[0] + v194) = v193;
                    uint64_t v193 = v177;
                  }
                  break;
                }
                size_t v195 = v178;
                goto LABEL_304;
              }
              if ((void *)prime < __p[1])
              {
                unint64_t v184 = vcvtps_u32_f32((float)(unint64_t)v416[1] / v417);
                if (__p[1] < (void *)3
                  || (uint8x8_t v185 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]), v185.i16[0] = vaddlv_u8(v185), v185.u32[0] > 1uLL))
                {
                  unint64_t v184 = std::__next_prime(v184);
                }
                else
                {
                  uint64_t v186 = 1 << -(char)__clz(v184 - 1);
                  if (v184 >= 2) {
                    unint64_t v184 = v186;
                  }
                }
                if (prime <= v184) {
                  size_t prime = v184;
                }
                if (prime >= v131)
                {
                  unint64_t v131 = (unint64_t)__p[1];
                }
                else
                {
                  if (prime) {
                    goto LABEL_266;
                  }
                  v199 = __p[0];
                  __p[0] = 0;
                  if (v199) {
                    operator delete(v199);
                  }
                  unint64_t v131 = 0;
                  __p[1] = 0;
                }
              }
LABEL_300:
              if ((v131 & (v131 - 1)) != 0)
              {
                if (v127 >= v131) {
                  unint64_t v99 = v127 % v131;
                }
                else {
                  unint64_t v99 = v127;
                }
              }
              else
              {
                unint64_t v99 = (v131 - 1) & v127;
              }
            }
            v196 = (void *)*((void *)__p[0] + v99);
            if (v196)
            {
              *(void *)long long __src = *v196;
              void *v196 = __src;
              a5 = 168;
              uint64_t v25 = v358;
              unint64_t v17 = v353;
            }
            else
            {
              *(void **)long long __src = v416[0];
              v416[0] = (void *)__src;
              unint64_t v17 = v353;
              *((void *)__p[0] + v99) = v416;
              a5 = 168;
              uint64_t v25 = v358;
              if (*(void *)__src)
              {
                unint64_t v197 = *(void *)(*(void *)__src + 8);
                if ((v131 & (v131 - 1)) != 0)
                {
                  if (v197 >= v131) {
                    v197 %= v131;
                  }
                }
                else
                {
                  v197 &= v131 - 1;
                }
                *((void *)__p[0] + v197) = __src;
              }
            }
            ++v416[1];
            v167 = 0;
LABEL_322:
            unint64_t v26 = v356;
            if (v167) {
              operator delete(v167);
            }
            uint64_t v198 = v433;
            if (!(void)v433) {
              goto LABEL_121;
            }
LABEL_325:
            *((void *)&v433 + 1) = v198;
            (*(void (**)(long long *, uint64_t, char *))(*(void *)v435 + 40))(v435, v198, &v434[-v198]);
            goto LABEL_121;
          }
          if (v132.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v141 = v135[1];
              if (v141 == v128)
              {
                uint64_t v143 = v135[2];
                uint64_t v142 = v135[3];
                if (v142 - v143 == v126)
                {
                  if (v143 == v142) {
                    goto LABEL_212;
                  }
                  uint64_t v144 = v433;
                  while (*(_DWORD *)v143 == *(_DWORD *)v144
                       && *(unsigned __int16 *)(v143 + 4) == *(unsigned __int16 *)(v144 + 4))
                  {
                    v143 += 8;
                    v144 += 8;
                    if (v143 == v142) {
                      goto LABEL_212;
                    }
                  }
                }
              }
              else if ((v141 & ((uint64_t)__p[1] - 1)) != v133)
              {
                goto LABEL_214;
              }
              v135 = (void *)*v135;
              if (!v135) {
                goto LABEL_214;
              }
            }
          }
          while (1)
          {
            unint64_t v136 = v135[1];
            if (v136 == v128) {
              break;
            }
            if ((void *)v136 >= __p[1]) {
              v136 %= (unint64_t)__p[1];
            }
            if (v136 != v133) {
              goto LABEL_214;
            }
LABEL_186:
            v135 = (void *)*v135;
            if (!v135) {
              goto LABEL_214;
            }
          }
          uint64_t v138 = v135[2];
          uint64_t v137 = v135[3];
          if (v137 - v138 != v126) {
            goto LABEL_186;
          }
          if (v138 != v137)
          {
            uint64_t v139 = v433;
            while (*(_DWORD *)v138 == *(_DWORD *)v139
                 && *(unsigned __int16 *)(v138 + 4) == *(unsigned __int16 *)(v139 + 4))
            {
              v138 += 8;
              v139 += 8;
              if (v138 == v137) {
                goto LABEL_212;
              }
            }
            goto LABEL_186;
          }
LABEL_212:
          v147 = (unint64_t *)v135[7];
          unint64_t v146 = v135[8];
          if ((unint64_t)v147 < v146)
          {
            unint64_t *v147 = v99;
            v148 = v147 + 1;
            unint64_t v26 = v356;
            uint64_t v24 = a10;
            goto LABEL_348;
          }
          int v187 = (char *)v135[6];
          uint64_t v188 = ((char *)v147 - v187) >> 3;
          unint64_t v189 = v188 + 1;
          if ((unint64_t)(v188 + 1) >> 61) {
            abort();
          }
          uint64_t v190 = v146 - (void)v187;
          if (v190 >> 2 > v189) {
            unint64_t v189 = v190 >> 2;
          }
          if ((unint64_t)v190 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v191 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v191 = v189;
          }
          if (v191)
          {
            if (v191 >> 61) {
              goto LABEL_579;
            }
            v192 = (char *)operator new(8 * v191);
          }
          else
          {
            v192 = 0;
          }
          v200 = (unint64_t *)&v192[8 * v188];
          unint64_t *v200 = v99;
          v148 = v200 + 1;
          if (v147 == (unint64_t *)v187)
          {
            a2 = v341;
          }
          else
          {
            unint64_t v201 = (char *)(v147 - 1) - v187;
            if (v201 < 0x58)
            {
              a2 = v341;
              goto LABEL_344;
            }
            a2 = v341;
            if ((unint64_t)(v187 - v192) < 0x20) {
              goto LABEL_588;
            }
            uint64_t v202 = (v201 >> 3) + 1;
            v203 = &v192[8 * v188 - 16];
            v204 = v147 - 2;
            uint64_t v205 = v202 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v206 = *(_OWORD *)v204;
              *((_OWORD *)v203 - 1) = *((_OWORD *)v204 - 1);
              *(_OWORD *)v203 = v206;
              v203 -= 32;
              v204 -= 4;
              v205 -= 4;
            }
            while (v205);
            v200 -= v202 & 0x3FFFFFFFFFFFFFFCLL;
            v147 -= v202 & 0x3FFFFFFFFFFFFFFCLL;
            if (v202 != (v202 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_588:
              do
              {
LABEL_344:
                unint64_t v207 = *--v147;
                *--v200 = v207;
              }
              while (v147 != (unint64_t *)v187);
            }
            v147 = (unint64_t *)v135[6];
          }
          v135[6] = v200;
          v135[7] = v148;
          v135[8] = &v192[8 * v191];
          unint64_t v26 = v356;
          uint64_t v24 = a10;
          if (v147) {
            operator delete(v147);
          }
LABEL_348:
          unint64_t v17 = v353;
          v135[7] = v148;
          a7 = -32;
          a5 = 168;
          uint64_t v25 = v358;
          uint64_t v198 = v433;
          if ((void)v433) {
            goto LABEL_325;
          }
LABEL_121:
          ++v96;
        }
        while (v96 != v17);
      }
      v26 += 4;
    }
    while (v26 != v346);
  }
  if ((a11 & 1) != 0 && [v337 undulationModel])
  {
    uint64_t v359 = [v337 undulationModel];
    char v357 = 1;
    int v208 = 1 << *(unsigned char *)(a1 + 169);
    double v364 = (double)*(int *)(a1 + 176);
    double v354 = (double)(v208 + ~*(_DWORD *)(a1 + 172));
    double v209 = 6.28318531 / (double)v208;
    long double v210 = exp(v209 * v354 + -3.14159265);
    double v352 = atan(v210);
    long double v211 = fmod(v209 * v364, 6.28318531);
    long double v361 = fmod(v211 + 6.28318531, 6.28318531) * 57.2957795 + -180.0;
    long double v212 = exp((v354 + 1.0) * v209 + -3.14159265);
    double v213 = atan(v212);
    long double v214 = fmod(v209 + v364 * v209, 6.28318531);
    long double v215 = fmod(v214 + 6.28318531, 6.28318531);
    double v216 = v213 * 114.591559 + -90.0;
    float v12 = v361;
    float v13 = v215 * 57.2957795 + -180.0;
    float v14 = v352 * 114.591559 + -90.0;
    float v15 = v216;
    v217 = v416[0];
    if (!v416[0]) {
      goto LABEL_535;
    }
    goto LABEL_355;
  }
  char v357 = 0;
  uint64_t v359 = 0;
  v217 = v416[0];
  if (v416[0])
  {
LABEL_355:
    uint64_t v355 = a1 + 168;
    do
    {
      if (a2 == 48)
      {
        *(void *)((char *)&v433 + 7) = 0;
        *(void *)&long long v433 = 0;
        HIBYTE(v433) = 1;
        *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)&v433, 0x10002u) = 1;
        gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&__src, *a8, (gss::FeatureAttributeSet *)(v217 + 2), (gss::QueryOverrides *)&v433);
        v220 = (std::__shared_weak_count *)*((void *)&__src + 1);
        uint64_t v219 = __src;
        if (!BYTE14(v433) && (void)v433)
        {
          uint64_t v221 = gss::Allocator::instance(v218);
          (*(void (**)(uint64_t, void, void))(*(void *)v221 + 40))(v221, v433, WORD6(v433));
        }
        *(void *)&long long __src = v219;
        *((void *)&__src + 1) = v220;
        if (!v220) {
          goto LABEL_369;
        }
      }
      else
      {
        uint64_t v223 = *a8;
        *(void *)((char *)&v433 + 7) = 0;
        *(void *)&long long v433 = 0;
        HIBYTE(v433) = 1;
        gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&__src, v223, (gss::FeatureAttributeSet *)(v217 + 2), (gss::QueryOverrides *)&v433);
        if (BYTE14(v433)) {
          BOOL v225 = 1;
        }
        else {
          BOOL v225 = (void)v433 == 0;
        }
        if (!v225)
        {
          uint64_t v226 = gss::Allocator::instance(v224);
          (*(void (**)(uint64_t, void, void))(*(void *)v226 + 40))(v226, v433, WORD6(v433));
        }
        v220 = (std::__shared_weak_count *)*((void *)&__src + 1);
        uint64_t v219 = __src;
        if (!*((void *)&__src + 1))
        {
LABEL_369:
          uint64_t v222 = 0;
          goto LABEL_370;
        }
      }
      atomic_fetch_add_explicit(&v220->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v222 = *((void *)&__src + 1);
LABEL_370:
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)&v433, v219, v222);
      v228 = (std::__shared_weak_count *)*((void *)&__src + 1);
      if (*((void *)&__src + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&__src + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v228->__on_zero_shared)(v228);
        std::__shared_weak_count::__release_weak(v228);
      }
      uint64_t v365 = v219;
      if (!(_BYTE)v436)
      {
        BOOL v362 = 0;
LABEL_446:
        BOOL v350 = 0;
        goto LABEL_447;
      }
      uint64_t v229 = *(void *)(v433 + 24);
      v230 = *(float **)v229;
      if (!*(void *)v229)
      {
        BOOL v232 = 0;
LABEL_384:
        unsigned int v234 = *(unsigned __int8 *)(v229 + v232 + 11);
        if (v234 != 2) {
          goto LABEL_386;
        }
        goto LABEL_385;
      }
      float v231 = *v230;
      BOOL v232 = *v230 == 1.0;
      if (!*(unsigned char *)(v229 + 10)) {
        goto LABEL_384;
      }
      if (v231 == 0.0 || v231 == 1.0) {
        goto LABEL_384;
      }
LABEL_385:
      unsigned int v234 = 1;
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(*(void *)(v433 + 24), 0x12Cu, 0)) {
        goto LABEL_400;
      }
LABEL_386:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v229, 0x12Cu, v234)) {
        goto LABEL_399;
      }
      if (!v230)
      {
        BOOL v236 = 0;
LABEL_396:
        unsigned int v234 = *(unsigned __int8 *)(v229 + v236 + 11);
        if (v234 != 2) {
          goto LABEL_398;
        }
        goto LABEL_397;
      }
      float v235 = *v230;
      BOOL v236 = *v230 == 1.0;
      if (!*(unsigned char *)(v229 + 10)) {
        goto LABEL_396;
      }
      if (v235 == 0.0 || v235 == 1.0) {
        goto LABEL_396;
      }
LABEL_397:
      unsigned int v234 = 1;
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v229, 0x12Du, 0)) {
        goto LABEL_400;
      }
LABEL_398:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v229, 0x12Du, v234))
      {
LABEL_399:
        unsigned int v234 = 1;
        goto LABEL_400;
      }
      if (v230)
      {
        float v252 = *v230;
        BOOL v253 = *v230 == 1.0;
        if (*(unsigned char *)(v229 + 10))
        {
          if (v252 != 0.0 && v252 != 1.0) {
            goto LABEL_439;
          }
        }
      }
      else
      {
        BOOL v253 = 0;
      }
      unsigned int v255 = *(unsigned __int8 *)(v229 + v253 + 11);
      float v252 = 0.0;
      if (v255 != 2)
      {
        LOBYTE(v259) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v229, 0x96u, v255, 0);
        goto LABEL_444;
      }
LABEL_439:
      LOBYTE(__src) = 1;
      LOBYTE(v400) = 1;
      uint64_t v256 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v229, 0x96u, 0, &__src);
      uint64_t v257 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v229, 0x96u, 1u, &v400);
      if (v252 >= 1.0) {
        v258 = (int *)v257;
      }
      else {
        v258 = (int *)v256;
      }
      int v259 = *v258;
LABEL_444:
      unsigned int v234 = v259 == 1;
      if (!(_BYTE)v436)
      {
        BOOL v362 = v259 == 1;
        goto LABEL_446;
      }
LABEL_400:
      uint64_t v238 = *(void *)(v433 + 24);
      v239 = *(float **)v238;
      BOOL v362 = v234;
      if (!*(void *)v238)
      {
        BOOL v241 = 0;
LABEL_409:
        unsigned int v243 = *(unsigned __int8 *)(v238 + v241 + 11);
        if (v243 != 2) {
          goto LABEL_412;
        }
        goto LABEL_410;
      }
      float v240 = *v239;
      BOOL v241 = *v239 == 1.0;
      if (!*(unsigned char *)(v238 + 10)) {
        goto LABEL_409;
      }
      if (v240 == 0.0 || v240 == 1.0) {
        goto LABEL_409;
      }
LABEL_410:
      if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v238, 0x1C3u, 0)) {
        goto LABEL_413;
      }
      unsigned int v243 = 1;
LABEL_412:
      if (!gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(v238, 0x1C3u, v243)) {
        goto LABEL_446;
      }
LABEL_413:
      if (v239)
      {
        float v244 = *v239;
        BOOL v245 = *v239 == 1.0;
        if (*(unsigned char *)(v238 + 10))
        {
          if (v244 != 0.0 && v244 != 1.0)
          {
LABEL_423:
            LOBYTE(__src) = 1;
            LOBYTE(v400) = 1;
            uint64_t v248 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v238, 0x1C3u, 0, &__src);
            uint64_t v249 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v238, 0x1C3u, 1u, &v400);
            if (v244 >= 1.0) {
              v250 = (int *)v249;
            }
            else {
              v250 = (int *)v248;
            }
            int v251 = *v250;
            goto LABEL_428;
          }
        }
      }
      else
      {
        BOOL v245 = 0;
      }
      unsigned int v247 = *(unsigned __int8 *)(v238 + v245 + 11);
      float v244 = 0.0;
      if (v247 == 2) {
        goto LABEL_423;
      }
      LOBYTE(v251) = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v238, 0x1C3u, v247, 0);
LABEL_428:
      BOOL v350 = v251 == 0;
LABEL_447:
      v261 = (uint64_t *)v217[6];
      v260 = (uint64_t *)v217[7];
      v338 = v217;
      v342 = v260;
      while (v261 != v260)
      {
        uint64_t v262 = *v261;
        uint64_t v263 = *(unsigned int *)(*v261 + 100);
        unint64_t v398 = 0;
        v264 = geo::codec::multiSectionFeatureCharacteristicPoints((std::__shared_weak_count **)v262, (GeoCodecsRoadFeature *)&v398, v227);
        v265 = v264;
        v266 = *(int ***)(v262 + 24);
        unint64_t v267 = *((unsigned __int8 *)v266 + 33);
        v343 = v261;
        if (*((unsigned char *)v266 + 33))
        {
          v268 = *v266;
          int v269 = **v266;
          if (v269 == 2)
          {
            BOOL v270 = 1;
          }
          else
          {
            unint64_t v272 = 0;
            v273 = v268 + 2;
            while (v267 - 1 != v272)
            {
              int v274 = *v273;
              v273 += 2;
              ++v272;
              if (v274 == 2) {
                goto LABEL_460;
              }
            }
            unint64_t v272 = v267;
LABEL_460:
            BOOL v270 = v272 < v267;
            if (v269 == 185)
            {
              unint64_t v275 = 0;
              LODWORD(v267) = 1;
LABEL_466:
              BOOL v271 = (v268[2 * v275 + 1] & 0xFFFFFFFD) == 0;
              if (!v263) {
                goto LABEL_448;
              }
              goto LABEL_469;
            }
          }
          unint64_t v275 = 0;
          v276 = v268 + 2;
          while (v267 - 1 != v275)
          {
            int v277 = *v276;
            v276 += 2;
            ++v275;
            if (v277 == 185)
            {
              LODWORD(v267) = v275 < v267;
              goto LABEL_466;
            }
          }
          LODWORD(v267) = 0;
          BOOL v271 = 1;
          if (!v263) {
            goto LABEL_448;
          }
        }
        else
        {
          BOOL v270 = 0;
          BOOL v271 = 1;
          if (!v263) {
            goto LABEL_448;
          }
        }
LABEL_469:
        unint64_t v278 = 0;
        int v279 = v267 & v271;
        BOOL v280 = !v270;
        v281 = (void **)&v430;
        if (!v280) {
          v281 = v427;
        }
        v347 = (uint64_t *)v281;
        v282 = v421;
        if (!v280) {
          v282 = v418;
        }
        v351 = (uint64_t *)v282;
        v283 = (char *)v264 + 108;
        while (2)
        {
          unint64_t v397 = 0;
          v284 = geo::codec::multiSectionFeaturePoints((void *)v262, v278, &v397);
          uint64_t v396 = 0;
          uint64_t v285 = geo::codec::multiSectionFeatureElevations(v262, v278, &v396);
          v227 = (unint64_t *)v397;
          if (v397 < 2) {
            goto LABEL_474;
          }
          if (v398)
          {
            if (v278 == *((_DWORD *)v265 + 2))
            {
              unint64_t v286 = 0;
              BOOL v287 = 1;
            }
            else
            {
              unint64_t v286 = 0;
              v288 = (int *)((char *)v265 + 108);
              while (v398 - 1 != v286)
              {
                int v289 = *v288;
                v288 += 25;
                ++v286;
                if (v278 == v289)
                {
                  BOOL v287 = v286 < v398;
                  goto LABEL_485;
                }
              }
              BOOL v287 = 0;
              unint64_t v286 = v398;
            }
          }
          else
          {
            unint64_t v286 = 0;
            BOOL v287 = 0;
          }
LABEL_485:
          if (v398 <= v286 + 1) {
            unint64_t v290 = v286 + 1;
          }
          else {
            unint64_t v290 = v398;
          }
          unint64_t v291 = v290 - 1;
          unint64_t v292 = v286 - 1;
          v293 = &v283[100 * v286];
          do
          {
            if (v292 + 2 >= v398)
            {
              unint64_t v292 = v291;
              if (v279) {
                goto LABEL_492;
              }
LABEL_499:
              char v295 = 0;
              char v296 = 0;
              if (!v362) {
                goto LABEL_511;
              }
              goto LABEL_500;
            }
            int v294 = *(_DWORD *)v293;
            v293 += 100;
            ++v292;
          }
          while (v278 == v294);
          if (!v279) {
            goto LABEL_499;
          }
LABEL_492:
          if (v287 && !*((_DWORD *)v265 + 25 * v286 + 3))
          {
            char v295 = *((unsigned char *)v265 + 100 * v286 + 28) == 0;
            if (v292 >= v398) {
              goto LABEL_510;
            }
LABEL_495:
            if (v397 - 1 != *((_DWORD *)v265 + 25 * v292 + 3)) {
              goto LABEL_510;
            }
            char v296 = *((unsigned char *)v265 + 100 * v292 + 28) == 0;
            if (v362) {
              goto LABEL_500;
            }
LABEL_511:
            if (v350)
            {
              uint64_t v385 = v365;
              v386 = v220;
              if (v220) {
                atomic_fetch_add_explicit(&v220->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              float v301 = *(float *)(a1 + 624);
              LOBYTE(__src) = 0;
              LOBYTE(v400) = 0;
              *((void *)&v380 + 1) = __PAIR64__(LODWORD(v13), LODWORD(v12));
              float v381 = v14;
              float v382 = v15;
              char v383 = v357;
              *(_DWORD *)v384 = *(_DWORD *)v399;
              *(_DWORD *)&v384[3] = *(_DWORD *)&v399[3];
              uint64_t v302 = a12[1];
              uint64_t v378 = *a12;
              v379 = (std::__shared_weak_count *)v302;
              *(void *)&long long v380 = v359;
              if (v302) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v302 + 8), 1uLL, memory_order_relaxed);
              }
              v303 = v379;
              if (v379 && !atomic_fetch_add(&v379->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v303->__on_zero_shared)(v303);
                std::__shared_weak_count::__release_weak(v303);
              }
              v300 = v386;
              if (!v386) {
                goto LABEL_474;
              }
            }
            else
            {
              uint64_t v376 = v365;
              v377 = v220;
              if (v220) {
                atomic_fetch_add_explicit(&v220->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              float v304 = *(float *)(a1 + 624);
              LOBYTE(__src) = 0;
              LOBYTE(v400) = 0;
              *((void *)&v371 + 1) = __PAIR64__(LODWORD(v13), LODWORD(v12));
              float v372 = v14;
              float v373 = v15;
              char v374 = v357;
              *(_DWORD *)v375 = *(_DWORD *)v399;
              *(_DWORD *)&v375[3] = *(_DWORD *)&v399[3];
              uint64_t v305 = a12[1];
              uint64_t v369 = *a12;
              v370 = (std::__shared_weak_count *)v305;
              *(void *)&long long v371 = v359;
              if (v305) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v305 + 8), 1uLL, memory_order_relaxed);
              }
              v306 = v370;
              if (v370 && !atomic_fetch_add(&v370->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v306->__on_zero_shared)(v306);
                std::__shared_weak_count::__release_weak(v306);
                v300 = v377;
                if (!v377) {
                  goto LABEL_474;
                }
              }
              else
              {
                v300 = v377;
                if (!v377) {
                  goto LABEL_474;
                }
              }
            }
LABEL_528:
            if (!atomic_fetch_add(&v300->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v300->__on_zero_shared)(v300);
              std::__shared_weak_count::__release_weak(v300);
            }
            goto LABEL_474;
          }
          char v295 = 1;
          if (v292 < v398) {
            goto LABEL_495;
          }
LABEL_510:
          char v296 = 1;
          if (!v362) {
            goto LABEL_511;
          }
LABEL_500:
          uint64_t v394 = v365;
          v395 = v220;
          if (v220) {
            atomic_fetch_add_explicit(&v220->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          float v297 = *(float *)(a1 + 624);
          *((void *)&v389 + 1) = __PAIR64__(LODWORD(v13), LODWORD(v12));
          float v390 = v14;
          float v391 = v15;
          char v392 = v357;
          *(_DWORD *)v393 = *(_DWORD *)v399;
          *(_DWORD *)&v393[3] = *(_DWORD *)&v399[3];
          uint64_t v298 = a12[1];
          uint64_t v387 = *a12;
          v388 = (std::__shared_weak_count *)v298;
          *(void *)&long long v389 = v359;
          if (v298) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v298 + 8), 1uLL, memory_order_relaxed);
          }
          v299 = v388;
          if (v388 && !atomic_fetch_add(&v388->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v299->__on_zero_shared)(v299);
            std::__shared_weak_count::__release_weak(v299);
          }
          v300 = v395;
          if (v395) {
            goto LABEL_528;
          }
LABEL_474:
          if (++v278 != v263) {
            continue;
          }
          break;
        }
LABEL_448:
        v260 = v342;
        v261 = v343 + 1;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&v433);
      if (v220 && !atomic_fetch_add(&v220->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v220->__on_zero_shared)(v220);
        std::__shared_weak_count::__release_weak(v220);
      }
      v217 = (void *)*v338;
      a2 = v341;
    }
    while (*v338);
  }
LABEL_535:
  (*(void (**)(unint64_t *__return_ptr))(*(void *)[v337 gglDevice] + 24))(&v400);
  v307 = (long long *)operator new(0x38uLL);
  *(void *)v307 = &unk_1EF590DB0;
  *((void *)v307 + 1) = v421;
  *((void *)v307 + 2) = &v430;
  *((void *)v307 + 3) = v418;
  *((void *)v307 + 4) = v427;
  *((void *)v307 + 5) = v424;
  *((void *)v307 + 6) = a1;
  v435 = v307;
  long long __src = 0uLL;
  (*(void (**)(unint64_t, long long *, long long *))(*(void *)v400 + 16))(v400, &v433, &__src);
  v308 = (std::__shared_weak_count *)*((void *)&__src + 1);
  if (*((void *)&__src + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&__src + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v308->__on_zero_shared)(v308);
    std::__shared_weak_count::__release_weak(v308);
  }
  if (v435 == &v433)
  {
    (*(void (**)(long long *))(v433 + 32))(&v433);
    uint64_t v309 = a1;
    unint64_t v310 = v400;
    if (!v400) {
      goto LABEL_548;
    }
    goto LABEL_544;
  }
  uint64_t v309 = a1;
  if (v435) {
    (*(void (**)(void))(*(void *)v435 + 40))();
  }
  unint64_t v310 = v400;
  if (v400)
  {
LABEL_544:
    uint64_t v311 = (*(uint64_t (**)(unint64_t))(*(void *)v310 + 24))(v310);
    unint64_t v312 = v400;
    unint64_t v400 = 0;
    *(void *)&long long v433 = v312;
    (*(void (**)(uint64_t, long long *))(*(void *)v311 + 48))(v311, &v433);
    uint64_t v313 = v433;
    *(void *)&long long v433 = 0;
    if (v313) {
      (*(void (**)(uint64_t))(*(void *)v313 + 8))(v313);
    }
    v314 = (uint64_t *)v400;
    unint64_t v400 = 0;
    if (v314) {
      (*(void (**)(uint64_t *))(*v314 + 8))(v314);
    }
  }
LABEL_548:
  *(void *)(v309 + 752) = *((void *)&v419 + 1)
                          + *((void *)&v422 + 1)
                          + *((void *)&v425 + 1)
                          + *((void *)&v428 + 1)
                          + *((void *)&v431 + 1);
  float v315 = *(float *)(v309 + 624);
  uint64_t v368 = 0;
  double v367 = 1.0 / v315;
  gdc::Tiled::setZBoundsInMeters((unsigned __int8 *)(v309 + 168), (double *)&v368, &v367);
  v316 = (void **)v416[0];
  if (v416[0])
  {
    do
    {
      v334 = (void **)*v316;
      v335 = v316[6];
      if (v335)
      {
        v316[7] = v335;
        operator delete(v335);
      }
      v336 = v316[2];
      if (v336)
      {
        v316[3] = v336;
        (*(void (**)(void *, void *, int64_t))(*(void *)v316[5] + 40))(v316[5], v336, (unsigned char *)v316[4] - (unsigned char *)v336);
      }
      operator delete(v316);
      v316 = v334;
    }
    while (v334);
  }
  v317 = __p[0];
  __p[0] = 0;
  if (v317) {
    operator delete(v317);
  }
  v318 = (void *)v419;
  if ((void)v419)
  {
    do
    {
      v319 = (void *)*v318;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v318 + 2));
      operator delete(v318);
      v318 = v319;
    }
    while (v319);
  }
  v320 = v418[0];
  v418[0] = 0;
  if (v320) {
    operator delete(v320);
  }
  v321 = (void *)v422;
  if ((void)v422)
  {
    do
    {
      v322 = (void *)*v321;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v321 + 2));
      operator delete(v321);
      v321 = v322;
    }
    while (v322);
  }
  v323 = v421[0];
  v421[0] = 0;
  if (v323) {
    operator delete(v323);
  }
  v324 = (void *)v425;
  if ((void)v425)
  {
    do
    {
      v325 = (void *)*v324;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v324 + 2));
      operator delete(v324);
      v324 = v325;
    }
    while (v325);
  }
  v326 = v424[0];
  v424[0] = 0;
  if (v326) {
    operator delete(v326);
  }
  v327 = (void *)v428;
  if ((void)v428)
  {
    do
    {
      v328 = (void *)*v327;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v327 + 2));
      operator delete(v327);
      v327 = v328;
    }
    while (v328);
  }
  v329 = v427[0];
  v427[0] = 0;
  if (v329) {
    operator delete(v329);
  }
  v330 = (void *)v431;
  if ((void)v431)
  {
    do
    {
      v331 = (void *)*v330;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v330 + 2));
      operator delete(v330);
      v330 = v331;
    }
    while (v331);
  }
  v332 = (void *)v430;
  *(void *)&long long v430 = 0;
  if (v332) {
    operator delete(v332);
  }

  return a1;
}

void sub_1A17CED08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,md::MapTileData *a34)
{
  uint64_t v36 = (void **)STACK[0x250];
  if (STACK[0x250])
  {
    do
    {
      long long v61 = (void **)*v36;
      char v62 = v36[6];
      if (v62)
      {
        v36[7] = v62;
        operator delete(v62);
      }
      uint64_t v63 = v36[2];
      if (v63)
      {
        v36[3] = v63;
        (*(void (**)(void *, void *, int64_t))(*(void *)v36[5] + 40))(v36[5], v63, (unsigned char *)v36[4] - (unsigned char *)v63);
      }
      operator delete(v36);
      uint64_t v36 = v61;
    }
    while (v61);
  }
  uint64_t v37 = (void *)STACK[0x240];
  STACK[0x240] = 0;
  if (v37) {
    operator delete(v37);
  }
  uint64_t v38 = (void *)STACK[0x280];
  if (STACK[0x280])
  {
    do
    {
      uint64_t v39 = (void *)*v38;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v38 + 2));
      operator delete(v38);
      uint64_t v38 = v39;
    }
    while (v39);
  }
  unint64_t v40 = (void *)STACK[0x270];
  STACK[0x270] = 0;
  if (v40) {
    operator delete(v40);
  }
  uint64_t v41 = (void *)STACK[0x2B0];
  if (STACK[0x2B0])
  {
    do
    {
      unint64_t v42 = (void *)*v41;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v41 + 2));
      operator delete(v41);
      uint64_t v41 = v42;
    }
    while (v42);
  }
  uint64_t v43 = (void *)STACK[0x2A0];
  STACK[0x2A0] = 0;
  if (v43) {
    operator delete(v43);
  }
  int v44 = (void *)STACK[0x2E0];
  if (STACK[0x2E0])
  {
    do
    {
      float v45 = (void *)*v44;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v44 + 2));
      operator delete(v44);
      int v44 = v45;
    }
    while (v45);
  }
  int v46 = (void *)STACK[0x2D0];
  STACK[0x2D0] = 0;
  if (v46) {
    operator delete(v46);
  }
  uint64_t v47 = (void *)STACK[0x310];
  if (STACK[0x310])
  {
    do
    {
      uint64_t v48 = (void *)*v47;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v47 + 2));
      operator delete(v47);
      uint64_t v47 = v48;
    }
    while (v48);
  }
  uint64_t v49 = (void *)STACK[0x300];
  STACK[0x300] = 0;
  if (v49) {
    operator delete(v49);
  }
  uint64_t v50 = *(void **)(v34 - 240);
  if (v50)
  {
    do
    {
      uint64_t v51 = (void *)*v50;
      std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>((uint64_t)(v50 + 2));
      operator delete(v50);
      uint64_t v50 = v51;
    }
    while (v51);
  }
  uint64_t v52 = *(void **)(v34 - 256);
  *(void *)(v34 - 256) = 0;
  if (v52) {
    operator delete(v52);
  }
  unint64_t v53 = (std::__shared_weak_count *)*((void *)a34 + 106);
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  uint64_t v54 = (std::__shared_weak_count *)*((void *)a34 + 104);
  if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
    std::__shared_weak_count::__release_weak(v54);
  }
  uint64_t v55 = *((void *)a34 + 102);
  *((void *)a34 + 102) = 0;
  if (v55) {
    (*(void (**)(uint64_t))(*(void *)v55 + 8))(v55);
  }
  std::__hash_table<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::__unordered_map_hasher<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,std::__unordered_map_equal<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,std::equal_to<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>>,true>,geo::StdAllocator<std::__hash_value_type<std::shared_ptr<gss::StylesheetQuery<gss::PropertyID>>,std::vector<gm::Matrix<float,3,1>>>,mdm::Allocator>>::~__hash_table(a15);
  uint64_t v56 = *((void *)a34 + 93);
  *((void *)a34 + 93) = 0;
  if (v56) {
    (*(void (**)(uint64_t))(*(void *)v56 + 8))(v56);
  }
  uint64_t v57 = *((void *)a34 + 92);
  *((void *)a34 + 92) = 0;
  if (v57) {
    (*(void (**)(uint64_t))(*(void *)v57 + 8))(v57);
  }
  unint64_t v58 = (uint64_t *)((char *)a34 + 720);
  uint64_t v59 = *((void *)a34 + 91);
  *((void *)a34 + 91) = 0;
  if (v59) {
    (*(void (**)(uint64_t))(*(void *)v59 + 8))(v59);
  }
  uint64_t v60 = *v58;
  *unint64_t v58 = 0;
  if (v60) {
    (*(void (**)(uint64_t))(*(void *)v60 + 8))(v60);
  }
  md::MapTileData::~MapTileData(a34);

  _Unwind_Resume(a1);
}

void *geo::codec::multiSectionFeaturePoints(void *result, unint64_t a2, void *a3)
{
  if (!result) {
    goto LABEL_8;
  }
  unint64_t v5 = result;
  if (*((unsigned int *)result + 25) <= a2)
  {
LABEL_9:
    uint64_t result = 0;
    *a3 = 0;
    return result;
  }
  uint64_t result = geo::codec::vertexPoolForFeature((uint64_t)result);
  if (!result)
  {
LABEL_8:
    *a3 = 0;
    return result;
  }
  uint64_t v6 = result[4];
  if (v6)
  {
    unint64_t v7 = *((unsigned int *)v5 + 24) + a2;
    if (result[5] > v7)
    {
      unint64_t v8 = *(void *)(v6 + 16 * v7);
      if (v8 < result[2])
      {
        uint64_t result = (void *)(result[1] + 8 * v8);
        *a3 = *(void *)(v6 + 16 * v7 + 8);
        return result;
      }
    }
    goto LABEL_9;
  }
  return 0;
}

uint64_t geo::codec::multiSectionFeatureElevations(uint64_t result, unint64_t a2, void *a3)
{
  if (result)
  {
    uint64_t v5 = result;
    if (*(unsigned int *)(result + 100) <= a2)
    {
      uint64_t result = 0;
      *a3 = 0;
    }
    else
    {
      uint64_t v6 = geo::codec::vertexPoolForFeature(result);
      uint64_t v7 = *(unsigned int *)(v5 + 96);
      *a3 = 0;
      uint64_t v8 = v6[3];
      if (v8)
      {
        uint64_t v9 = (void *)(v6[4] + 16 * (v7 + a2));
        uint64_t result = v8 + 4 * *v9;
        *a3 = v9[1];
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    *a3 = 0;
  }
  return result;
}

void *geo::codec::vertexPoolForFeature(uint64_t a1)
{
  float v1 = (void *)a1;
  if (!a1) {
    return v1;
  }
  BOOL v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = std::__shared_weak_count::lock(v2);
  if (!v3) {
    return 0;
  }
  char v4 = v3;
  uint64_t v5 = (void *)*v1;
  if (!*v1) {
    goto LABEL_45;
  }
  if (v5[4] <= (unint64_t)v1 && v5[5] > (unint64_t)v1)
  {
    float v1 = (void *)v5[99];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
    goto LABEL_46;
  }
  if (v5[12] <= (unint64_t)v1 && v5[13] > (unint64_t)v1)
  {
    float v1 = (void *)v5[100];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
    goto LABEL_46;
  }
  if (v5[23] <= (unint64_t)v1 && v5[24] > (unint64_t)v1
    || v5[27] <= (unint64_t)v1 && v5[28] > (unint64_t)v1)
  {
    float v1 = (void *)v5[105];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
    goto LABEL_46;
  }
  if (v5[35] <= (unint64_t)v1 && v5[36] > (unint64_t)v1)
  {
    float v1 = (void *)v5[102];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
    goto LABEL_46;
  }
  if (v5[47] <= (unint64_t)v1 && v5[48] > (unint64_t)v1)
  {
    float v1 = (void *)v5[103];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
    goto LABEL_46;
  }
  if (v5[51] <= (unint64_t)v1 && v5[52] > (unint64_t)v1)
  {
    float v1 = (void *)v5[104];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
    goto LABEL_46;
  }
  if (v5[8] <= (unint64_t)v1 && v5[9] > (unint64_t)v1)
  {
    float v1 = (void *)v5[101];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
    goto LABEL_46;
  }
  if (v5[19] <= (unint64_t)v1 && v5[20] > (unint64_t)v1)
  {
    float v1 = (void *)v5[106];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
    goto LABEL_46;
  }
  if (v5[436] <= (unint64_t)v1 && v5[437] > (unint64_t)v1)
  {
    float v1 = (void *)v5[440];
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
  }
  else
  {
LABEL_45:
    float v1 = 0;
    if (atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
      return v1;
    }
  }
LABEL_46:
  ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
  std::__shared_weak_count::__release_weak(v4);
  return v1;
}

uint64_t _ZNSt3__110__function6__funcIZN2md37DaVinciCenterLineRoadsLayerDataSourceC1ENS2_11MapDataTypeEtPN3gdc14LayerDataStoreERNS5_23ResourceStatusContainerEP17VKSharedResourcesPN3geo9TaskQueueEbONS_10unique_ptrINS2_23ElevationRequestUpdaterENS_14default_deleteISG_EEEENS_8functionIFbRKNS2_21GEOVectorTileResourceERK20GeoCodecsRoadFeatureS4_EEEEd_UlSO_SR_S4_E_NS_9allocatorISU_EESS_EclESO_SR_OS4_()
{
  return 0;
}

geo::codec *geo::codec::multiSectionFeatureCharacteristicPoints(std::__shared_weak_count **this, GeoCodecsRoadFeature *a2, unint64_t *a3)
{
  uint64_t v3 = (geo::codec *)this;
  if (!this) {
    return v3;
  }
  char v4 = this[1];
  if (!v4) {
    return 0;
  }
  uint64_t v6 = std::__shared_weak_count::lock(v4);
  if (!v6) {
    return 0;
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(void **)v3;
  if (*(void *)v3)
  {
    size_t v9 = v8[151];
    int v10 = (geo::codec *)v8[150];
    unint64_t __key = 0xCF3CF3CF3CF3CF3DLL * (((uint64_t)v3 - v8[4]) >> 3);
    unsigned int v11 = (geo::codec *)bsearch(&__key, v10, v9, 0x64uLL, (int (__cdecl *)(const void *, const void *))geo::codec::_searchForCharacteristicPoints(GeoCodecsCharacteristicPoint const*,unsigned long,unsigned long,unsigned long *)::$_0::__invoke);
    if (a2)
    {
      uint64_t v3 = v11;
      if (v11)
      {
        if (v11 > v10)
        {
          do
          {
            if (__key != *((_DWORD *)v3 - 24)) {
              break;
            }
            uint64_t v3 = (geo::codec *)((char *)v3 - 100);
          }
          while (v3 > v10);
        }
        *(void *)a2 = 0;
        float v12 = (geo::codec *)((char *)v10 + 100 * v9);
        if (v3 < v12)
        {
          unint64_t v13 = __key;
          uint64_t v14 = 1;
          float v15 = v3;
          do
          {
            if (v13 != *((_DWORD *)v15 + 1)) {
              break;
            }
            *(void *)a2 = v14;
            float v15 = (geo::codec *)((char *)v15 + 100);
            ++v14;
          }
          while (v15 < v12);
        }
        goto LABEL_18;
      }
      *(void *)a2 = 0;
    }
  }
  uint64_t v3 = 0;
LABEL_18:
  if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return v3;
}

void sub_1A17CF9A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::shared_ptr<geo::codec::VectorTile>::~shared_ptr[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtEnd(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3 = *(void *)(a1 + 16 * a3 + 16);
  if (!v3) {
    return 0;
  }
  char v4 = *(unsigned __int16 ****)(v3 + 72);
  if (!v4 || (uint64_t v5 = *v4, v6 = *((unsigned __int16 *)*v4 + 5), !v6))
  {
LABEL_27:
    uint64_t v18 = a1 + 16 * a3;
    uint64_t v19 = *(unsigned __int16 *)(v18 + 56);
    if (*(_WORD *)(v18 + 56))
    {
      uint64_t v20 = *(void *)(v18 + 48);
      uint64_t v21 = v20 + 8 * v19;
      while (1)
      {
        BOOL v23 = *(unsigned __int16 ****)(*(void *)v20 + 72);
        if (v23)
        {
          uint64_t v24 = *v23;
          unint64_t v25 = *((unsigned __int16 *)*v23 + 5);
          if (!v25)
          {
            LOWORD(v22) = 0;
            goto LABEL_30;
          }
          unint64_t v26 = *v24;
          if (!*((unsigned char *)v24 + 15))
          {
            uint64_t v29 = 2 * v25;
            uint64_t v30 = *v24;
            while (*v30 != a2)
            {
              ++v30;
              v29 -= 2;
              if (!v29)
              {
                uint64_t v30 = &v26[v25];
                break;
              }
            }
            unint64_t v22 = (unint64_t)((char *)v30 - (char *)v26) >> 1;
LABEL_30:
            if (v25 != (unsigned __int16)v22) {
              return 1;
            }
            goto LABEL_31;
          }
          if (v25 < 0x1E)
          {
            uint64_t v27 = 0;
            while (1)
            {
              unsigned int v28 = v26[v27];
              if (v28 >= a2) {
                break;
              }
              if (v25 == ++v27) {
                goto LABEL_31;
              }
            }
            if (v28 == a2) {
              LOWORD(v22) = v27;
            }
            else {
              LOWORD(v22) = v25;
            }
            goto LABEL_30;
          }
          uint64_t v31 = *v24;
          unint64_t v32 = v25;
          do
          {
            unint64_t v33 = v32 >> 1;
            uint64_t v34 = &v31[v32 >> 1];
            unsigned int v36 = *v34;
            uint64_t v35 = v34 + 1;
            v32 += ~(v32 >> 1);
            if (v36 < a2) {
              uint64_t v31 = v35;
            }
            else {
              unint64_t v32 = v33;
            }
          }
          while (v32);
          if (v31 != &v26[v25] && *v31 == a2)
          {
            unint64_t v22 = (unint64_t)((char *)v31 - (char *)v26) >> 1;
            goto LABEL_30;
          }
        }
LABEL_31:
        v20 += 8;
        if (v20 == v21) {
          return 0;
        }
      }
    }
    return 0;
  }
  uint64_t v7 = *v5;
  if (!*((unsigned char *)v5 + 15))
  {
    uint64_t v10 = 2 * v6;
    unsigned int v11 = *v5;
    while (*v11 != a2)
    {
      ++v11;
      v10 -= 2;
      if (!v10)
      {
        LODWORD(v11) = v7 + 2 * v6;
        break;
      }
    }
LABEL_22:
    if ((unsigned __int16)((v11 - v7) >> 1) == v6) {
      goto LABEL_27;
    }
    return 1;
  }
  if (v6 >= 0x1E)
  {
    unsigned int v11 = *v5;
    unint64_t v12 = v6;
    do
    {
      unint64_t v13 = v12 >> 1;
      uint64_t v14 = &v11[v12 >> 1];
      unsigned int v16 = *v14;
      float v15 = v14 + 1;
      v12 += ~(v12 >> 1);
      if (v16 < a2) {
        unsigned int v11 = v15;
      }
      else {
        unint64_t v12 = v13;
      }
    }
    while (v12);
    if (v11 == &v7[v6] || *v11 != a2) {
      goto LABEL_27;
    }
    goto LABEL_22;
  }
  uint64_t v8 = 0;
  while (1)
  {
    unsigned int v9 = v7[v8];
    if (v9 >= a2) {
      break;
    }
    if (v6 == ++v8) {
      goto LABEL_27;
    }
  }
  int v17 = (unsigned __int16)v8;
  if (v9 != a2) {
    int v17 = v6;
  }
  if (v17 == v6) {
    goto LABEL_27;
  }
  return 1;
}

uint64_t ggl::MetalLoader::performWithAccessor(uint64_t a1, uint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(a2 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v2 + 48))(v2, &v5);
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return ggl::MetalDevice::vendLoader(v4);
}

void ggl::MetalDevice::vendLoader(ggl::MetalDevice *this)
{
}

void sub_1A17CFCC8(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0xA1C409BE6959DLL);
  _Unwind_Resume(a1);
}

uint64_t ggl::MetalLoader::device(ggl::MetalLoader *this)
{
  return *((void *)this + 1);
}

void ggl::MetalLoader::~MetalLoader(ggl::MetalLoader *this)
{
  *(void *)this = &unk_1EF55A740;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;

  *(void *)this = &unk_1EF55A740;
  uint64_t v2 = *((void *)this + 2);
  *((void *)this + 2) = 0;
  if (v2) {
    (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  }
}

void ggl::MetalResourceAccessor::~MetalResourceAccessor(ggl::MetalResourceAccessor *this)
{
}

uint64_t ggl::MetalDevice::unvendLoader(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  *a2 = 0;
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__destroy_at[abi:nn180100]<std::pair<md::PatternedBatchKey const,std::vector<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,geo::StdAllocator<std::unique_ptr<md::PatternedRibbon,mdm::TypeDeleter<md::PatternedRibbon>>,mdm::Allocator>>>,0>(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 24);
    if (v3 != v2)
    {
      do
      {
        unint64_t v6 = (void (***)(void, uint64_t))*--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6)
        {
          (**v5)(v5, v4);
          {
            operator new();
          }
          (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                           + 40))(mdm::Allocator::instance(void)::alloc, v5, 120);
        }
      }
      while (v3 != v2);
      uint64_t v4 = *(void *)(a1 + 24);
    }
    *(void *)(a1 + 32) = v2;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v4, *(void *)(a1 + 40) - v4);
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 8);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
}

uint64_t std::__function::__func<ggl::MetalClearItemProcessor::process(ggl::ProcessClearItemContext &,ggl::ClearItem *)::$_0,std::allocator<ggl::MetalClearItemProcessor::process(ggl::ProcessClearItemContext &,ggl::ClearItem *)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *a2;
  uint64_t v4 = *(uint64_t **)(result + 8);
  uint64_t v5 = *v4;
  unint64_t v6 = *(void *)(*v4 + 8);
  if (v6)
  {
    if (v3 && *(unsigned char *)(v5 + 17) != 2)
    {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, void, unint64_t, uint64_t, void))(*(void *)v3 + 56))(*a2, v5, 0, v6, 1, 0);
      uint64_t v7 = (_DWORD *)result;
    }
    else
    {
      uint64_t v7 = *(_DWORD **)(v5 + 72);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = **(_DWORD ***)(v2 + 16);
  _DWORD *v7 = v8[1];
  v7[1] = v8[2];
  v7[2] = v8[3];
  v7[3] = v8[4];
  v7[4] = v8[6];
  if (v6)
  {
    if (v3 && *(unsigned char *)(v5 + 17) != 2) {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
    }
    unint64_t v9 = *(void *)(v5 + 64);
    if (v9 <= v6) {
      unint64_t v9 = v6;
    }
    *(void *)(v5 + 56) = 0;
    *(void *)(v5 + 64) = v9;
  }
  return result;
}

uint64_t md::DaVinciMaterialResourceFetcher::resourceKey(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = a2;
  uint64_t v5 = **(void **)(a3 + 8);
  [v4 style];
  unint64_t v6 = +[VKSharedResourcesManager sharedResources];
  [v6 gglDevice];
  LOBYTE(v8) = GEOTileKeyMakeEmpty();
  *(void *)((char *)&v8 + 1) = v5;

  return v8;
}

void sub_1A17D01A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<md::MeshRenderableLogic::processChangedBatches(md::LayoutContext const&)::$_1,std::allocator<md::MeshRenderableLogic::processChangedBatches(md::LayoutContext const&)::$_1>,void ()(ggl::ResourceAccessor *)>::operator()(void *a1, uint64_t *a2)
{
  uint64_t v2 = (void *)a1[1];
  if (v2[1] != *v2)
  {
    unint64_t v4 = 0;
    uint64_t v5 = *a2;
    uint64_t v6 = a1[2];
    uint64_t v7 = (void *)a1[3];
    uint64_t v8 = a1[5] + 160;
    do
    {
      unint64_t v9 = *(void *)(*v2 + 8 * v4);
      unint64_t v11 = v9;
      uint64_t v10 = std::__hash_table<std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::__unordered_map_hasher<md::RenderBatch *,std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::hash<md::RenderBatch *>,std::equal_to<md::RenderBatch *>,true>,std::__unordered_map_equal<md::RenderBatch *,std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>,std::equal_to<md::RenderBatch *>,std::hash<md::RenderBatch *>,true>,std::allocator<std::__hash_value_type<md::RenderBatch *,gm::Range<unsigned long>>>>::__emplace_unique_key_args<md::RenderBatch *,std::piecewise_construct_t const&,std::tuple<md::RenderBatch * const&>,std::tuple<>>(v6, v9, &v11);
      md::RenderBatch::prepareResources(v9, v5, v8, *v7 + 8 * v10[3], *v7 + 8 * v10[4]);
      ++v4;
    }
    while (v4 < (uint64_t)(*(void *)(a1[1] + 8) - *(void *)a1[1]) >> 3);
  }
}

void *std::__function::__func<md::DaVinciCenterLineRoadsTileData::DaVinciCenterLineRoadsTileData(md::MapDataType,gdc::LayerDataRequestKey const&,std::vector<gdc::Resource::LoadMetadata> &&,std::vector<std::shared_ptr<md::GEOVectorTileResource>> const&,BOOL,BOOL,std::vector<gdc::Resource::LoadMetadata> &&<gss::StylesheetManager<std::vector<std::shared_ptr<md::GEOVectorTileResource>> const&::PropertyID>>,VKSharedResources *,std::function<BOOL ()(std::shared_ptr const&,GeoCodecsRoadFeature const&,md::MapDataType)>,BOOL,std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>)::$_0,std::allocator<std::vector<gdc::Resource::LoadMetadata> &&<md::FlyoverDsmResource>>,void ()(ggl::ResourceAccessor *)>::operator()(void *result)
{
  if (*(void *)(result[2] + 24)) {
    operator new();
  }
  if (*(void *)(result[4] + 24)) {
    operator new();
  }
  if (*(void *)(result[5] + 24)) {
    operator new();
  }
  if (*(void *)(result[1] + 24)) {
    operator new();
  }
  if (*(void *)(result[3] + 24)) {
    operator new();
  }
  return result;
}

void sub_1A17D0594(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v1, 0x10A1C40520EE663);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<ggl::DistanceAtlas::DistanceAtlas(unsigned int,float,float,ggl::Device *)::$_0,std::allocator<ggl::DistanceAtlas::DistanceAtlas(unsigned int,float,float,ggl::Device *)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)v4, *(void *)(*(void *)(a1 + 8) + 16));
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 24))(v2, v4);
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  if (v6) {
    return (*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

uint64_t std::__function::__func<md::TextureManager::_cubeTexture(std::string const&,std::shared_ptr<ggl::SamplerState>,BOOL,geo::optional<unsigned int>)::$_0,std::allocator<md::TextureManager::_cubeTexture(std::string const&,std::shared_ptr<ggl::SamplerState>,BOOL,geo::optional<unsigned int>)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  {
    operator new();
  }
  uint64_t v16 = ggl::Allocator::instance(void)::alloc;
  uint64_t result = ggl::TextureCube::vendImplicitLoadItems(**(void **)(a1 + 8), &v13);
  uint64_t v5 = v13;
  uint64_t v6 = v14;
  if (v13 == v14)
  {
    if (!v13) {
      return result;
    }
  }
  else
  {
    uint64_t v7 = v13;
    do
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v3 + 24))(v3, v7);
      v7 += 80;
    }
    while (v7 != v6);
    if (!v5) {
      return result;
    }
    if (v5 != v6)
    {
      uint64_t v8 = v6 - 32;
      unint64_t v9 = (void *)(v6 - 32);
      do
      {
        unint64_t v11 = (void *)v9[3];
        if (v9 == v11)
        {
          (*(void (**)(void *))(*v9 + 32))(v9);
          if (!*((unsigned char *)v9 - 28)) {
            goto LABEL_14;
          }
        }
        else
        {
          if (v11) {
            (*(void (**)(void *))(*v11 + 40))(v11);
          }
          if (!*((unsigned char *)v9 - 28)) {
            goto LABEL_14;
          }
        }
        *((unsigned char *)v9 - 28) = 0;
LABEL_14:
        if (*((unsigned char *)v9 - 32)) {
          *((unsigned char *)v9 - 32) = 0;
        }
        uint64_t v10 = v9 - 6;
        v9 -= 10;
        v8 -= 80;
      }
      while (v10 != (void *)v5);
    }
  }
  unint64_t v12 = *(uint64_t (**)(void))(*(void *)v16 + 40);
  return v12();
}

void sub_1A17D08DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  if (!v12) {
LABEL_14:
  }
    _Unwind_Resume(exception_object);
  uint64_t v15 = (void *)(v13 - 32);
  uint64_t v16 = v15;
  while (1)
  {
    uint64_t v18 = (void *)v16[3];
    if (v16 == v18)
    {
      (*(void (**)(void *))(*v16 + 32))(v16);
      if (!*((unsigned char *)v16 - 28)) {
        goto LABEL_9;
      }
    }
    else
    {
      if (v18) {
        (*(void (**)(void *))(*v18 + 40))(v18);
      }
      if (!*((unsigned char *)v16 - 28)) {
        goto LABEL_9;
      }
    }
    *((unsigned char *)v16 - 28) = 0;
LABEL_9:
    if (*((unsigned char *)v16 - 32)) {
      *((unsigned char *)v16 - 32) = 0;
    }
    int v17 = v16 - 6;
    v16 -= 10;
    v15 -= 10;
    if (v17 == v12)
    {
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)a12 + 40))(a12, v12, a11 - (void)v12);
      goto LABEL_14;
    }
  }
}

uint64_t md::Ribbons::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::collectRenderItemsForPasses(void *a1, void *a2, uint64_t a3, __n128 a4)
{
  uint64_t v250 = *MEMORY[0x1E4F143B8];
  unint64_t v4 = (uint64_t (**)(void *))&unk_1EF578F00;
  v244[0] = &unk_1EF578F00;
  v244[1] = a3;
  BOOL v245 = v244;
  if (a1 == a2) {
    return v4[4](v244);
  }
  uint64_t v5 = a1;
  do
  {
    uint64_t v6 = *v5;
    uint64_t v7 = (uint64_t)v245;
    if (!v245) {
      goto LABEL_8;
    }
    if (v245 != v244)
    {
      uint64_t v7 = (*(uint64_t (**)(void *))(*v245 + 16))(v245);
LABEL_8:
      unsigned int v247 = (void *)v7;
      goto LABEL_10;
    }
    unsigned int v247 = v246;
    (*(void (**)(void *, void *))(v244[0] + 24))(v244, v246);
LABEL_10:
    if (!*(unsigned char *)(v6 + 1040)) {
      goto LABEL_168;
    }
    uint64_t v8 = *(void *)(v6 + 944);
    uint64_t v9 = *(void *)(v6 + 936);
    if (v8 != v9)
    {
      uint64_t v10 = *(void *)(v6 + 944);
      do
      {
        unint64_t v12 = *(void **)(v10 - 24);
        v10 -= 24;
        unint64_t v11 = v12;
        if (v12)
        {
          *(void *)(v8 - 16) = v11;
          operator delete(v11);
        }
        uint64_t v8 = v10;
      }
      while (v10 != v9);
    }
    *(void *)(v6 + 944) = v9;
    *(void *)(v6 + 920) = *(void *)(v6 + 912);
    uint64_t v13 = *(void **)(v6 + 992);
    if (v13)
    {
      do
      {
        if (v13[1])
        {
          unint64_t v15 = 0;
          uint64_t v16 = v13 + 2;
          int v17 = v13 + 2;
          uint64_t v18 = (void (***)(void))(v13 + 2);
          do
          {
            uint64_t v19 = (void (**)(void *))*v18;
            v18 += 15;
            (*v19)(v17);
            ++v15;
            v16 += 15;
            int v17 = v18;
          }
          while (v15 < v13[1]);
        }
        v13[1] = 0;
        uint64_t v13 = (void *)*v13;
      }
      while (v13);
      uint64_t v14 = *(void *)(v6 + 992);
    }
    else
    {
      uint64_t v14 = 0;
    }
    *(void *)(v6 + 1000) = v14;
    uint64_t v20 = (uint64_t)v247;
    v233 = v5;
    if (!v247) {
      goto LABEL_27;
    }
    if (v247 != v246)
    {
      uint64_t v20 = (*(uint64_t (**)(void *))(*v247 + 16))(v247);
LABEL_27:
      uint64_t v249 = (void *)v20;
      goto LABEL_29;
    }
    uint64_t v249 = v248;
    (*(void (**)(void *, void *))(v246[0] + 24))(v246, v248);
LABEL_29:
    if (*(unsigned char *)(v6 + 1040))
    {
      if (*(unsigned char *)(v6 + 136))
      {
        uint64_t v21 = *(void *)(*(void *)(v6 + 8) + 56);
        *(void *)(v6 + 40) = v21;
        BOOL v22 = *(unsigned __int8 *)(v21 + 58) == 1;
        if (!*(unsigned char *)(v6 + 264)) {
          goto LABEL_34;
        }
      }
      else
      {
        BOOL v22 = 0;
        if (!*(unsigned char *)(v6 + 264)) {
          goto LABEL_34;
        }
      }
      uint64_t v23 = *(void *)(*(void *)(v6 + 8) + 64);
      *(void *)(v6 + 168) = v23;
      if (*(unsigned char *)(v23 + 58) == 1) {
        BOOL v22 = 1;
      }
LABEL_34:
      if (*(unsigned char *)(v6 + 392))
      {
        uint64_t v24 = *(void *)(*(void *)(v6 + 8) + 72);
        *(void *)(v6 + 296) = v24;
        if (*(unsigned char *)(v24 + 58) == 1) {
          BOOL v22 = 1;
        }
      }
      if (*(unsigned char *)(v6 + 520))
      {
        uint64_t v25 = *(void *)(*(void *)(v6 + 8) + 80);
        *(void *)(v6 + 424) = v25;
        if (*(unsigned char *)(v25 + 58) == 1) {
          BOOL v22 = 1;
        }
      }
      if (*(unsigned char *)(v6 + 648))
      {
        uint64_t v26 = *(void *)(*(void *)(v6 + 8) + 88);
        *(void *)(v6 + 552) = v26;
        if (*(unsigned char *)(v26 + 58) == 1) {
          BOOL v22 = 1;
        }
      }
      if (*(unsigned char *)(v6 + 776))
      {
        uint64_t v27 = *(void *)(*(void *)(v6 + 8) + 96);
        *(void *)(v6 + 680) = v27;
        if (*(unsigned char *)(v27 + 58) == 1) {
          BOOL v22 = 1;
        }
      }
      if (*(unsigned char *)(v6 + 904))
      {
        uint64_t v28 = *(void *)(*(void *)(v6 + 8) + 104);
        *(void *)(v6 + 808) = v28;
        if (*(unsigned char *)(v28 + 58) == 1) {
          BOOL v22 = 1;
        }
      }
      unsigned int v234 = (long long **)(v6 + 912);
      uint64_t v29 = *(uint64_t **)(v6 + 1016);
      uint64_t v30 = *(uint64_t **)(v6 + 1024);
      if (v29 != v30)
      {
        uint64_t v31 = 0;
        while (1)
        {
          uint64_t v32 = *v29;
          if (*(unsigned char *)(*v29 + 48))
          {
            if (*(void *)(v32 + 88) != v31)
            {
              if (v31)
              {
                unint64_t v33 = ggl::Batcher::commit(v234, 0xC8u, a4);
                if (v33[1] != *v33)
                {
                  uint64_t v34 = v33;
                  if (*(unsigned char *)(v6 + 136))
                  {
                    long long v36 = *(_OWORD *)(v6 + 24);
                    long long v35 = *(_OWORD *)(v6 + 40);
                    long long v37 = *(_OWORD *)(v6 + 56);
                    long long v38 = *(_OWORD *)(v6 + 72);
                    long long v39 = *(_OWORD *)(v6 + 88);
                    long long v40 = *(_OWORD *)(v6 + 120);
                    long long v242 = *(_OWORD *)(v6 + 104);
                    long long v243 = v40;
                    BOOL v236 = &off_1EF55A458;
                    long long v237 = v36;
                    long long v238 = v35;
                    long long v240 = v38;
                    long long v241 = v39;
                    long long v239 = v37;
                    uint64_t v41 = *(void **)(v6 + 1000);
                    uint64_t v42 = v41[1];
                    if (v42 == *(void *)(v6 + 1008))
                    {
                      uint64_t v41 = (void *)*v41;
                      if (!v41)
                      {
                        uint64_t v41 = malloc_type_malloc(120 * v42 + 16, 0xB644C221uLL);
                        void *v41 = 0;
                        v41[1] = 0;
                        **(void **)(v6 + 1000) = v41;
                      }
                      *(void *)(v6 + 1000) = v41;
                      uint64_t v42 = v41[1];
                    }
                    uint64_t v43 = &v41[15 * v42];
                    v41[1] = v42 + 1;
                    v43[2] = &off_1EF55A458;
                    long long v44 = v242;
                    long long v45 = v243;
                    long long v46 = v241;
                    *(_OWORD *)(v43 + 9) = v240;
                    long long v47 = v237;
                    long long v48 = v238;
                    *(_OWORD *)(v43 + 7) = v239;
                    *(_OWORD *)(v43 + 5) = v48;
                    *(_OWORD *)(v43 + 3) = v47;
                    *(_OWORD *)(v43 + 15) = v45;
                    *(_OWORD *)(v43 + 13) = v44;
                    *(_OWORD *)(v43 + 11) = v46;
                    v43[10] = v31;
                    uint64_t v49 = *v34;
                    v43[13] = *v34;
                    v43[14] = (v34[1] - v49) >> 4;
                    int v235 = 0;
                    BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v43 + 2);
                    if (!v249) {
                      goto LABEL_177;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
                  }
                  if (*(unsigned char *)(v6 + 264))
                  {
                    BOOL v236 = &off_1EF55A458;
                    long long v50 = *(_OWORD *)(v6 + 168);
                    long long v237 = *(_OWORD *)(v6 + 152);
                    long long v238 = v50;
                    long long v51 = *(_OWORD *)(v6 + 248);
                    long long v52 = *(_OWORD *)(v6 + 216);
                    long long v242 = *(_OWORD *)(v6 + 232);
                    long long v243 = v51;
                    long long v53 = *(_OWORD *)(v6 + 200);
                    long long v239 = *(_OWORD *)(v6 + 184);
                    long long v240 = v53;
                    long long v241 = v52;
                    uint64_t v54 = *(void **)(v6 + 1000);
                    uint64_t v55 = v54[1];
                    if (v55 == *(void *)(v6 + 1008))
                    {
                      uint64_t v54 = (void *)*v54;
                      if (!v54)
                      {
                        uint64_t v54 = malloc_type_malloc(120 * v55 + 16, 0xB644C221uLL);
                        *uint64_t v54 = 0;
                        v54[1] = 0;
                        **(void **)(v6 + 1000) = v54;
                      }
                      *(void *)(v6 + 1000) = v54;
                      uint64_t v55 = v54[1];
                    }
                    uint64_t v56 = &v54[15 * v55];
                    v54[1] = v55 + 1;
                    v56[2] = &off_1EF55A458;
                    long long v57 = v242;
                    long long v58 = v243;
                    long long v59 = v241;
                    *(_OWORD *)(v56 + 9) = v240;
                    long long v60 = v237;
                    long long v61 = v238;
                    *(_OWORD *)(v56 + 7) = v239;
                    *(_OWORD *)(v56 + 5) = v61;
                    *(_OWORD *)(v56 + 3) = v60;
                    *(_OWORD *)(v56 + 15) = v58;
                    *(_OWORD *)(v56 + 13) = v57;
                    *(_OWORD *)(v56 + 11) = v59;
                    v56[10] = v31;
                    char v62 = *v34;
                    v56[13] = *v34;
                    v56[14] = (v34[1] - v62) >> 4;
                    int v235 = 1;
                    BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v56 + 2);
                    if (!v249) {
                      goto LABEL_177;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
                  }
                  if (*(unsigned char *)(v6 + 392))
                  {
                    BOOL v236 = &off_1EF55A458;
                    long long v63 = *(_OWORD *)(v6 + 296);
                    long long v237 = *(_OWORD *)(v6 + 280);
                    long long v238 = v63;
                    long long v64 = *(_OWORD *)(v6 + 376);
                    long long v65 = *(_OWORD *)(v6 + 344);
                    long long v242 = *(_OWORD *)(v6 + 360);
                    long long v243 = v64;
                    long long v66 = *(_OWORD *)(v6 + 328);
                    long long v239 = *(_OWORD *)(v6 + 312);
                    long long v240 = v66;
                    long long v241 = v65;
                    uint64_t v67 = *(void **)(v6 + 1000);
                    uint64_t v68 = v67[1];
                    if (v68 == *(void *)(v6 + 1008))
                    {
                      uint64_t v67 = (void *)*v67;
                      if (!v67)
                      {
                        uint64_t v67 = malloc_type_malloc(120 * v68 + 16, 0xB644C221uLL);
                        void *v67 = 0;
                        v67[1] = 0;
                        **(void **)(v6 + 1000) = v67;
                      }
                      *(void *)(v6 + 1000) = v67;
                      uint64_t v68 = v67[1];
                    }
                    uint64_t v69 = &v67[15 * v68];
                    v67[1] = v68 + 1;
                    v69[2] = &off_1EF55A458;
                    long long v70 = v242;
                    long long v71 = v243;
                    long long v72 = v241;
                    *(_OWORD *)(v69 + 9) = v240;
                    long long v73 = v237;
                    long long v74 = v238;
                    *(_OWORD *)(v69 + 7) = v239;
                    *(_OWORD *)(v69 + 5) = v74;
                    *(_OWORD *)(v69 + 3) = v73;
                    *(_OWORD *)(v69 + 15) = v71;
                    *(_OWORD *)(v69 + 13) = v70;
                    *(_OWORD *)(v69 + 11) = v72;
                    v69[10] = v31;
                    unint64_t v75 = *v34;
                    v69[13] = *v34;
                    v69[14] = (v34[1] - v75) >> 4;
                    int v235 = 2;
                    BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v69 + 2);
                    if (!v249) {
                      goto LABEL_177;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
                  }
                  if (*(unsigned char *)(v6 + 520))
                  {
                    BOOL v236 = &off_1EF55A458;
                    long long v76 = *(_OWORD *)(v6 + 424);
                    long long v237 = *(_OWORD *)(v6 + 408);
                    long long v238 = v76;
                    long long v77 = *(_OWORD *)(v6 + 504);
                    long long v78 = *(_OWORD *)(v6 + 472);
                    long long v242 = *(_OWORD *)(v6 + 488);
                    long long v243 = v77;
                    long long v79 = *(_OWORD *)(v6 + 456);
                    long long v239 = *(_OWORD *)(v6 + 440);
                    long long v240 = v79;
                    long long v241 = v78;
                    uint64_t v80 = *(void **)(v6 + 1000);
                    uint64_t v81 = v80[1];
                    if (v81 == *(void *)(v6 + 1008))
                    {
                      uint64_t v80 = (void *)*v80;
                      if (!v80)
                      {
                        uint64_t v80 = malloc_type_malloc(120 * v81 + 16, 0xB644C221uLL);
                        void *v80 = 0;
                        v80[1] = 0;
                        **(void **)(v6 + 1000) = v80;
                      }
                      *(void *)(v6 + 1000) = v80;
                      uint64_t v81 = v80[1];
                    }
                    int v82 = &v80[15 * v81];
                    v80[1] = v81 + 1;
                    v82[2] = &off_1EF55A458;
                    long long v83 = v242;
                    long long v84 = v243;
                    long long v85 = v241;
                    *(_OWORD *)(v82 + 9) = v240;
                    long long v86 = v237;
                    long long v87 = v238;
                    *(_OWORD *)(v82 + 7) = v239;
                    *(_OWORD *)(v82 + 5) = v87;
                    *(_OWORD *)(v82 + 3) = v86;
                    *(_OWORD *)(v82 + 15) = v84;
                    *(_OWORD *)(v82 + 13) = v83;
                    *(_OWORD *)(v82 + 11) = v85;
                    v82[10] = v31;
                    uint64_t v88 = *v34;
                    v82[13] = *v34;
                    v82[14] = (v34[1] - v88) >> 4;
                    int v235 = 3;
                    BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v82 + 2);
                    if (!v249) {
                      goto LABEL_177;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
                  }
                  if (*(unsigned char *)(v6 + 648))
                  {
                    BOOL v236 = &off_1EF55A458;
                    long long v89 = *(_OWORD *)(v6 + 552);
                    long long v237 = *(_OWORD *)(v6 + 536);
                    long long v238 = v89;
                    long long v90 = *(_OWORD *)(v6 + 632);
                    long long v91 = *(_OWORD *)(v6 + 600);
                    long long v242 = *(_OWORD *)(v6 + 616);
                    long long v243 = v90;
                    long long v92 = *(_OWORD *)(v6 + 584);
                    long long v239 = *(_OWORD *)(v6 + 568);
                    long long v240 = v92;
                    long long v241 = v91;
                    uint64_t v93 = *(void **)(v6 + 1000);
                    uint64_t v94 = v93[1];
                    if (v94 == *(void *)(v6 + 1008))
                    {
                      uint64_t v93 = (void *)*v93;
                      if (!v93)
                      {
                        uint64_t v93 = malloc_type_malloc(120 * v94 + 16, 0xB644C221uLL);
                        *uint64_t v93 = 0;
                        v93[1] = 0;
                        **(void **)(v6 + 1000) = v93;
                      }
                      *(void *)(v6 + 1000) = v93;
                      uint64_t v94 = v93[1];
                    }
                    unint64_t v95 = &v93[15 * v94];
                    v93[1] = v94 + 1;
                    v95[2] = &off_1EF55A458;
                    long long v96 = v242;
                    long long v97 = v243;
                    long long v98 = v241;
                    *(_OWORD *)(v95 + 9) = v240;
                    long long v99 = v237;
                    long long v100 = v238;
                    *(_OWORD *)(v95 + 7) = v239;
                    *(_OWORD *)(v95 + 5) = v100;
                    *(_OWORD *)(v95 + 3) = v99;
                    *(_OWORD *)(v95 + 15) = v97;
                    *(_OWORD *)(v95 + 13) = v96;
                    *(_OWORD *)(v95 + 11) = v98;
                    v95[10] = v31;
                    unint64_t v101 = *v34;
                    v95[13] = *v34;
                    v95[14] = (v34[1] - v101) >> 4;
                    int v235 = 4;
                    BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v95 + 2);
                    if (!v249) {
                      goto LABEL_177;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
                  }
                  if (*(unsigned char *)(v6 + 776))
                  {
                    BOOL v236 = &off_1EF55A458;
                    long long v102 = *(_OWORD *)(v6 + 680);
                    long long v237 = *(_OWORD *)(v6 + 664);
                    long long v238 = v102;
                    long long v103 = *(_OWORD *)(v6 + 760);
                    long long v104 = *(_OWORD *)(v6 + 728);
                    long long v242 = *(_OWORD *)(v6 + 744);
                    long long v243 = v103;
                    long long v105 = *(_OWORD *)(v6 + 712);
                    long long v239 = *(_OWORD *)(v6 + 696);
                    long long v240 = v105;
                    long long v241 = v104;
                    int v106 = *(void **)(v6 + 1000);
                    uint64_t v107 = v106[1];
                    if (v107 == *(void *)(v6 + 1008))
                    {
                      int v106 = (void *)*v106;
                      if (!v106)
                      {
                        int v106 = malloc_type_malloc(120 * v107 + 16, 0xB644C221uLL);
                        *int v106 = 0;
                        v106[1] = 0;
                        **(void **)(v6 + 1000) = v106;
                      }
                      *(void *)(v6 + 1000) = v106;
                      uint64_t v107 = v106[1];
                    }
                    uint64_t v108 = &v106[15 * v107];
                    v106[1] = v107 + 1;
                    v108[2] = &off_1EF55A458;
                    long long v109 = v242;
                    long long v110 = v243;
                    long long v111 = v241;
                    *(_OWORD *)(v108 + 9) = v240;
                    long long v112 = v237;
                    long long v113 = v238;
                    *(_OWORD *)(v108 + 7) = v239;
                    *(_OWORD *)(v108 + 5) = v113;
                    *(_OWORD *)(v108 + 3) = v112;
                    *(_OWORD *)(v108 + 15) = v110;
                    *(_OWORD *)(v108 + 13) = v109;
                    *(_OWORD *)(v108 + 11) = v111;
                    v108[10] = v31;
                    uint64_t v114 = *v34;
                    v108[13] = *v34;
                    v108[14] = (v34[1] - v114) >> 4;
                    int v235 = 5;
                    BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v108 + 2);
                    if (!v249) {
                      goto LABEL_177;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
                  }
                  if (*(unsigned char *)(v6 + 904))
                  {
                    BOOL v236 = &off_1EF55A458;
                    long long v115 = *(_OWORD *)(v6 + 808);
                    long long v237 = *(_OWORD *)(v6 + 792);
                    long long v238 = v115;
                    long long v116 = *(_OWORD *)(v6 + 888);
                    long long v117 = *(_OWORD *)(v6 + 856);
                    long long v242 = *(_OWORD *)(v6 + 872);
                    long long v243 = v116;
                    long long v118 = *(_OWORD *)(v6 + 840);
                    long long v239 = *(_OWORD *)(v6 + 824);
                    long long v240 = v118;
                    long long v241 = v117;
                    uint64_t v119 = *(void **)(v6 + 1000);
                    uint64_t v120 = v119[1];
                    if (v120 == *(void *)(v6 + 1008))
                    {
                      uint64_t v119 = (void *)*v119;
                      if (!v119)
                      {
                        uint64_t v119 = malloc_type_malloc(120 * v120 + 16, 0xB644C221uLL);
                        void *v119 = 0;
                        v119[1] = 0;
                        **(void **)(v6 + 1000) = v119;
                      }
                      *(void *)(v6 + 1000) = v119;
                      uint64_t v120 = v119[1];
                    }
                    uint64_t v121 = &v119[15 * v120];
                    v119[1] = v120 + 1;
                    v121[2] = &off_1EF55A458;
                    long long v122 = v242;
                    long long v123 = v243;
                    long long v124 = v241;
                    *(_OWORD *)(v121 + 9) = v240;
                    long long v125 = v237;
                    long long v126 = v238;
                    *(_OWORD *)(v121 + 7) = v239;
                    *(_OWORD *)(v121 + 5) = v126;
                    *(_OWORD *)(v121 + 3) = v125;
                    *(_OWORD *)(v121 + 15) = v123;
                    *(_OWORD *)(v121 + 13) = v122;
                    *(_OWORD *)(v121 + 11) = v124;
                    v121[10] = v31;
                    unint64_t v127 = *v34;
                    v121[13] = *v34;
                    v121[14] = (v34[1] - v127) >> 4;
                    int v235 = 6;
                    BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v121 + 2);
                    if (!v249) {
                      goto LABEL_177;
                    }
                    (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
                  }
                }
              }
              uint64_t v32 = *v29;
              uint64_t v31 = *(void *)(*v29 + 88);
            }
            uint64_t v128 = 16;
            if (v22)
            {
              uint64_t v128 = 32;
              uint64_t v129 = v32 + 32;
            }
            else
            {
              uint64_t v129 = v32 + 16;
            }
            if (*(void *)(v129 + 8) != *(void *)(v32 + v128)) {
              gm::MultiRange<unsigned long>::push_back((char **)v234, (_OWORD *)v129);
            }
          }
          if (++v29 == v30) {
            goto LABEL_114;
          }
        }
      }
      uint64_t v31 = 0;
LABEL_114:
      unint64_t v130 = ggl::Batcher::commit(v234, 0xC8u, a4);
      if (v130[1] != *v130)
      {
        unint64_t v131 = v130;
        if (*(unsigned char *)(v6 + 136))
        {
          long long v132 = *(_OWORD *)(v6 + 40);
          long long v133 = *(_OWORD *)(v6 + 24);
          long long v134 = *(_OWORD *)(v6 + 56);
          long long v135 = *(_OWORD *)(v6 + 72);
          long long v136 = *(_OWORD *)(v6 + 88);
          long long v137 = *(_OWORD *)(v6 + 120);
          long long v242 = *(_OWORD *)(v6 + 104);
          long long v243 = v137;
          BOOL v236 = &off_1EF55A458;
          long long v237 = v133;
          long long v238 = v132;
          long long v240 = v135;
          long long v241 = v136;
          long long v239 = v134;
          uint64_t v138 = *(void **)(v6 + 1000);
          uint64_t v139 = v138[1];
          if (v139 == *(void *)(v6 + 1008))
          {
            uint64_t v138 = (void *)*v138;
            if (!v138)
            {
              uint64_t v138 = malloc_type_malloc(120 * v139 + 16, 0xB644C221uLL);
              *uint64_t v138 = 0;
              v138[1] = 0;
              **(void **)(v6 + 1000) = v138;
            }
            *(void *)(v6 + 1000) = v138;
            uint64_t v139 = v138[1];
          }
          uint64_t v140 = &v138[15 * v139];
          v138[1] = v139 + 1;
          v140[2] = &off_1EF55A458;
          long long v141 = v242;
          long long v142 = v243;
          long long v143 = v241;
          *(_OWORD *)(v140 + 9) = v240;
          long long v144 = v237;
          long long v145 = v238;
          *(_OWORD *)(v140 + 7) = v239;
          *(_OWORD *)(v140 + 5) = v145;
          *(_OWORD *)(v140 + 3) = v144;
          *(_OWORD *)(v140 + 15) = v142;
          *(_OWORD *)(v140 + 13) = v141;
          *(_OWORD *)(v140 + 11) = v143;
          v140[10] = v31;
          unint64_t v146 = *v131;
          v140[13] = *v131;
          v140[14] = (v131[1] - v146) >> 4;
          int v235 = 0;
          BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v140 + 2);
          if (!v249)
          {
LABEL_177:
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
        }
        if (*(unsigned char *)(v6 + 264))
        {
          BOOL v236 = &off_1EF55A458;
          long long v147 = *(_OWORD *)(v6 + 168);
          long long v237 = *(_OWORD *)(v6 + 152);
          long long v238 = v147;
          long long v148 = *(_OWORD *)(v6 + 184);
          long long v149 = *(_OWORD *)(v6 + 248);
          long long v150 = *(_OWORD *)(v6 + 216);
          long long v242 = *(_OWORD *)(v6 + 232);
          long long v243 = v149;
          long long v151 = *(_OWORD *)(v6 + 200);
          long long v239 = v148;
          long long v240 = v151;
          long long v241 = v150;
          unint64_t v152 = *(void **)(v6 + 1000);
          uint64_t v153 = v152[1];
          if (v153 == *(void *)(v6 + 1008))
          {
            unint64_t v152 = (void *)*v152;
            if (!v152)
            {
              unint64_t v152 = malloc_type_malloc(120 * v153 + 16, 0xB644C221uLL);
              *unint64_t v152 = 0;
              v152[1] = 0;
              **(void **)(v6 + 1000) = v152;
            }
            *(void *)(v6 + 1000) = v152;
            uint64_t v153 = v152[1];
          }
          uint8x8_t v154 = &v152[15 * v153];
          v152[1] = v153 + 1;
          v154[2] = &off_1EF55A458;
          long long v155 = v242;
          long long v156 = v243;
          long long v157 = v241;
          *(_OWORD *)(v154 + 9) = v240;
          long long v158 = v237;
          long long v159 = v238;
          *(_OWORD *)(v154 + 7) = v239;
          *(_OWORD *)(v154 + 5) = v159;
          *(_OWORD *)(v154 + 3) = v158;
          *(_OWORD *)(v154 + 15) = v156;
          *(_OWORD *)(v154 + 13) = v155;
          *(_OWORD *)(v154 + 11) = v157;
          v154[10] = v31;
          uint64_t v160 = *v131;
          v154[13] = *v131;
          v154[14] = (v131[1] - v160) >> 4;
          int v235 = 1;
          BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v154 + 2);
          if (!v249) {
            goto LABEL_177;
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
        }
        if (*(unsigned char *)(v6 + 392))
        {
          BOOL v236 = &off_1EF55A458;
          long long v161 = *(_OWORD *)(v6 + 296);
          long long v237 = *(_OWORD *)(v6 + 280);
          long long v238 = v161;
          long long v162 = *(_OWORD *)(v6 + 312);
          long long v163 = *(_OWORD *)(v6 + 376);
          long long v164 = *(_OWORD *)(v6 + 344);
          long long v242 = *(_OWORD *)(v6 + 360);
          long long v243 = v163;
          long long v165 = *(_OWORD *)(v6 + 328);
          long long v239 = v162;
          long long v240 = v165;
          long long v241 = v164;
          v166 = *(void **)(v6 + 1000);
          uint64_t v167 = v166[1];
          if (v167 == *(void *)(v6 + 1008))
          {
            v166 = (void *)*v166;
            if (!v166)
            {
              v166 = malloc_type_malloc(120 * v167 + 16, 0xB644C221uLL);
              void *v166 = 0;
              v166[1] = 0;
              **(void **)(v6 + 1000) = v166;
            }
            *(void *)(v6 + 1000) = v166;
            uint64_t v167 = v166[1];
          }
          v168 = &v166[15 * v167];
          v166[1] = v167 + 1;
          v168[2] = &off_1EF55A458;
          long long v169 = v242;
          long long v170 = v243;
          long long v171 = v241;
          *(_OWORD *)(v168 + 9) = v240;
          long long v172 = v237;
          long long v173 = v238;
          *(_OWORD *)(v168 + 7) = v239;
          *(_OWORD *)(v168 + 5) = v173;
          *(_OWORD *)(v168 + 3) = v172;
          *(_OWORD *)(v168 + 15) = v170;
          *(_OWORD *)(v168 + 13) = v169;
          *(_OWORD *)(v168 + 11) = v171;
          v168[10] = v31;
          uint64_t v174 = *v131;
          v168[13] = *v131;
          v168[14] = (v131[1] - v174) >> 4;
          int v235 = 2;
          BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v168 + 2);
          if (!v249) {
            goto LABEL_177;
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
        }
        if (*(unsigned char *)(v6 + 520))
        {
          BOOL v236 = &off_1EF55A458;
          long long v175 = *(_OWORD *)(v6 + 424);
          long long v237 = *(_OWORD *)(v6 + 408);
          long long v238 = v175;
          long long v176 = *(_OWORD *)(v6 + 440);
          long long v177 = *(_OWORD *)(v6 + 504);
          long long v178 = *(_OWORD *)(v6 + 472);
          long long v242 = *(_OWORD *)(v6 + 488);
          long long v243 = v177;
          long long v179 = *(_OWORD *)(v6 + 456);
          long long v239 = v176;
          long long v240 = v179;
          long long v241 = v178;
          size_t v180 = *(void **)(v6 + 1000);
          uint64_t v181 = v180[1];
          if (v181 == *(void *)(v6 + 1008))
          {
            size_t v180 = (void *)*v180;
            if (!v180)
            {
              size_t v180 = malloc_type_malloc(120 * v181 + 16, 0xB644C221uLL);
              *size_t v180 = 0;
              v180[1] = 0;
              **(void **)(v6 + 1000) = v180;
            }
            *(void *)(v6 + 1000) = v180;
            uint64_t v181 = v180[1];
          }
          size_t v182 = &v180[15 * v181];
          v180[1] = v181 + 1;
          v182[2] = &off_1EF55A458;
          long long v183 = v242;
          long long v184 = v243;
          long long v185 = v241;
          *(_OWORD *)(v182 + 9) = v240;
          long long v186 = v237;
          long long v187 = v238;
          *(_OWORD *)(v182 + 7) = v239;
          *(_OWORD *)(v182 + 5) = v187;
          *(_OWORD *)(v182 + 3) = v186;
          *(_OWORD *)(v182 + 15) = v184;
          *(_OWORD *)(v182 + 13) = v183;
          *(_OWORD *)(v182 + 11) = v185;
          v182[10] = v31;
          uint64_t v188 = *v131;
          v182[13] = *v131;
          v182[14] = (v131[1] - v188) >> 4;
          int v235 = 3;
          BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v182 + 2);
          if (!v249) {
            goto LABEL_177;
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
        }
        if (*(unsigned char *)(v6 + 648))
        {
          BOOL v236 = &off_1EF55A458;
          long long v189 = *(_OWORD *)(v6 + 552);
          long long v237 = *(_OWORD *)(v6 + 536);
          long long v238 = v189;
          long long v190 = *(_OWORD *)(v6 + 568);
          long long v191 = *(_OWORD *)(v6 + 632);
          long long v192 = *(_OWORD *)(v6 + 600);
          long long v242 = *(_OWORD *)(v6 + 616);
          long long v243 = v191;
          long long v193 = *(_OWORD *)(v6 + 584);
          long long v239 = v190;
          long long v240 = v193;
          long long v241 = v192;
          uint64_t v194 = *(void **)(v6 + 1000);
          uint64_t v195 = v194[1];
          if (v195 == *(void *)(v6 + 1008))
          {
            uint64_t v194 = (void *)*v194;
            if (!v194)
            {
              uint64_t v194 = malloc_type_malloc(120 * v195 + 16, 0xB644C221uLL);
              *uint64_t v194 = 0;
              v194[1] = 0;
              **(void **)(v6 + 1000) = v194;
            }
            *(void *)(v6 + 1000) = v194;
            uint64_t v195 = v194[1];
          }
          v196 = &v194[15 * v195];
          v194[1] = v195 + 1;
          v196[2] = &off_1EF55A458;
          long long v197 = v242;
          long long v198 = v243;
          long long v199 = v241;
          *(_OWORD *)(v196 + 9) = v240;
          long long v200 = v237;
          long long v201 = v238;
          *(_OWORD *)(v196 + 7) = v239;
          *(_OWORD *)(v196 + 5) = v201;
          *(_OWORD *)(v196 + 3) = v200;
          *(_OWORD *)(v196 + 15) = v198;
          *(_OWORD *)(v196 + 13) = v197;
          *(_OWORD *)(v196 + 11) = v199;
          v196[10] = v31;
          uint64_t v202 = *v131;
          v196[13] = *v131;
          v196[14] = (v131[1] - v202) >> 4;
          int v235 = 4;
          BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v196 + 2);
          if (!v249) {
            goto LABEL_177;
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
        }
        if (*(unsigned char *)(v6 + 776))
        {
          BOOL v236 = &off_1EF55A458;
          long long v203 = *(_OWORD *)(v6 + 680);
          long long v237 = *(_OWORD *)(v6 + 664);
          long long v238 = v203;
          long long v204 = *(_OWORD *)(v6 + 696);
          long long v205 = *(_OWORD *)(v6 + 760);
          long long v206 = *(_OWORD *)(v6 + 728);
          long long v242 = *(_OWORD *)(v6 + 744);
          long long v243 = v205;
          long long v207 = *(_OWORD *)(v6 + 712);
          long long v239 = v204;
          long long v240 = v207;
          long long v241 = v206;
          int v208 = *(void **)(v6 + 1000);
          uint64_t v209 = v208[1];
          if (v209 == *(void *)(v6 + 1008))
          {
            int v208 = (void *)*v208;
            if (!v208)
            {
              int v208 = malloc_type_malloc(120 * v209 + 16, 0xB644C221uLL);
              *int v208 = 0;
              v208[1] = 0;
              **(void **)(v6 + 1000) = v208;
            }
            *(void *)(v6 + 1000) = v208;
            uint64_t v209 = v208[1];
          }
          long double v210 = &v208[15 * v209];
          v208[1] = v209 + 1;
          v210[2] = &off_1EF55A458;
          long long v211 = v242;
          long long v212 = v243;
          long long v213 = v241;
          *(_OWORD *)(v210 + 9) = v240;
          long long v214 = v237;
          long long v215 = v238;
          *(_OWORD *)(v210 + 7) = v239;
          *(_OWORD *)(v210 + 5) = v215;
          *(_OWORD *)(v210 + 3) = v214;
          *(_OWORD *)(v210 + 15) = v212;
          *(_OWORD *)(v210 + 13) = v211;
          *(_OWORD *)(v210 + 11) = v213;
          v210[10] = v31;
          double v216 = *v131;
          v210[13] = *v131;
          v210[14] = (v131[1] - v216) >> 4;
          int v235 = 5;
          BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v210 + 2);
          if (!v249) {
            goto LABEL_177;
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
        }
        if (*(unsigned char *)(v6 + 904))
        {
          BOOL v236 = &off_1EF55A458;
          long long v217 = *(_OWORD *)(v6 + 808);
          long long v237 = *(_OWORD *)(v6 + 792);
          long long v238 = v217;
          long long v218 = *(_OWORD *)(v6 + 824);
          long long v219 = *(_OWORD *)(v6 + 888);
          long long v220 = *(_OWORD *)(v6 + 856);
          long long v242 = *(_OWORD *)(v6 + 872);
          long long v243 = v219;
          long long v221 = *(_OWORD *)(v6 + 840);
          long long v239 = v218;
          long long v240 = v221;
          long long v241 = v220;
          uint64_t v222 = *(void **)(v6 + 1000);
          uint64_t v223 = v222[1];
          if (v223 == *(void *)(v6 + 1008))
          {
            uint64_t v222 = (void *)*v222;
            if (!v222)
            {
              uint64_t v222 = malloc_type_malloc(120 * v223 + 16, 0xB644C221uLL);
              *uint64_t v222 = 0;
              v222[1] = 0;
              **(void **)(v6 + 1000) = v222;
            }
            *(void *)(v6 + 1000) = v222;
            uint64_t v223 = v222[1];
          }
          v224 = &v222[15 * v223];
          v222[1] = v223 + 1;
          v224[2] = &off_1EF55A458;
          long long v225 = v242;
          long long v226 = v243;
          long long v227 = v241;
          *(_OWORD *)(v224 + 9) = v240;
          long long v228 = v237;
          long long v229 = v238;
          *(_OWORD *)(v224 + 7) = v239;
          *(_OWORD *)(v224 + 5) = v229;
          *(_OWORD *)(v224 + 3) = v228;
          *(_OWORD *)(v224 + 15) = v226;
          *(_OWORD *)(v224 + 13) = v225;
          *(_OWORD *)(v224 + 11) = v227;
          v224[10] = v31;
          v230 = *v131;
          v224[13] = *v131;
          v224[14] = (v131[1] - v230) >> 4;
          int v235 = 6;
          BOOL v236 = (void (**)(ggl::RenderItem *__hidden))(v224 + 2);
          if (!v249) {
            goto LABEL_177;
          }
          (*(void (**)(void *, int *, void (***)(ggl::RenderItem *__hidden)))(*v249 + 48))(v249, &v235, &v236);
        }
      }
    }
    if (v249 == v248)
    {
      (*(void (**)(void *))(v248[0] + 32))(v248);
      uint64_t v5 = v233;
    }
    else
    {
      uint64_t v5 = v233;
      if (v249) {
        (*(void (**)(void))(*v249 + 40))();
      }
    }
LABEL_168:
    if (v247 == v246)
    {
      (*(void (**)(void *))(v246[0] + 32))(v246);
    }
    else if (v247)
    {
      (*(void (**)(void))(*v247 + 40))();
    }
    ++v5;
  }
  while (v5 != a2);
  uint64_t result = (uint64_t)v245;
  if (v245 == v244)
  {
    unint64_t v4 = (uint64_t (**)(void *))v244[0];
    return v4[4](v244);
  }
  if (v245) {
    return (*(uint64_t (**)(void))(*v245 + 40))();
  }
  return result;
}

void sub_1A17D21FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33)
{
  std::function<void ()(md::Ribbons::RoadRibbonDescriptor::Passes,ggl::RenderItem *)>::~function((void *)(v33 - 160));
  std::function<void ()(md::Ribbons::RoadRibbonDescriptor::Passes,ggl::RenderItem *)>::~function(&a33);
  _Unwind_Resume(a1);
}

void gm::MultiRange<unsigned long>::push_back(char **a1, _OWORD *a2)
{
  uint64_t v5 = a1[1];
  unint64_t v4 = (unint64_t)a1[2];
  if ((unint64_t)v5 >= v4)
  {
    uint64_t v7 = *a1;
    uint64_t v8 = (v5 - *a1) >> 4;
    unint64_t v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 60) {
      abort();
    }
    uint64_t v10 = v4 - (void)v7;
    if (v10 >> 3 > v9) {
      unint64_t v9 = v10 >> 3;
    }
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v11 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v11 = v9;
    }
    if (v11)
    {
      if (v11 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v12 = (char *)operator new(16 * v11);
    }
    else
    {
      unint64_t v12 = 0;
    }
    uint64_t v13 = &v12[16 * v8];
    *(_OWORD *)uint64_t v13 = *a2;
    uint64_t v6 = v13 + 16;
    if (v5 != v7)
    {
      do
      {
        *((_OWORD *)v13 - 1) = *((_OWORD *)v5 - 1);
        v13 -= 16;
        v5 -= 16;
      }
      while (v5 != v7);
      uint64_t v5 = *a1;
    }
    *a1 = v13;
    a1[1] = v6;
    a1[2] = &v12[16 * v11];
    if (v5) {
      operator delete(v5);
    }
  }
  else
  {
    *(_OWORD *)uint64_t v5 = *a2;
    uint64_t v6 = v5 + 16;
  }
  a1[1] = v6;
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RoadRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RoadRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RoadRibbonDescriptor::Passes,ggl::RenderItem *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578F00;
  a2[1] = v2;
  return result;
}

uint64_t ggl::CommandBuffer::pushRenderItem(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  unint64_t v4 = *(void **)(result + 80);
  unint64_t v5 = *(void *)(result + 88);
  if ((unint64_t)v4 < v5)
  {
    if (v4) {
      *unint64_t v4 = a2;
    }
    uint64_t v6 = v4 + 1;
    goto LABEL_27;
  }
  uint64_t v7 = *(void *)(result + 72);
  uint64_t v8 = ((uint64_t)v4 - v7) >> 3;
  unint64_t v9 = v8 + 1;
  if ((unint64_t)(v8 + 1) >> 61) {
    abort();
  }
  uint64_t v10 = v5 - v7;
  if (v10 >> 2 > v9) {
    unint64_t v9 = v10 >> 2;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v9)
  {
    uint64_t v11 = 8 * v9;
    uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(result + 96) + 16))(*(void *)(result + 96), 8 * v9, 8);
    unint64_t v12 = (void *)(result + 8 * v8);
    unint64_t v9 = result + v11;
    if (result) {
      *unint64_t v12 = a2;
    }
  }
  else
  {
    unint64_t v12 = (void *)(8 * v8);
  }
  uint64_t v6 = v12 + 1;
  uint64_t v14 = *(void *)(v3 + 72);
  uint64_t v13 = *(void *)(v3 + 80);
  if (v13 != v14)
  {
    unint64_t v15 = v13 - v14 - 8;
    if (v15 < 0x38)
    {
      uint64_t v17 = *(void *)(v3 + 80);
    }
    else if ((unint64_t)(v13 - (void)v12) < 0x20)
    {
      uint64_t v17 = *(void *)(v3 + 80);
    }
    else
    {
      uint64_t v16 = (v15 >> 3) + 1;
      uint64_t v17 = v13 - 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v18 = v12 - 2;
      uint64_t v19 = (long long *)(v13 - 16);
      uint64_t v20 = v16 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v21 = *v19;
        *(v18 - 1) = *(v19 - 1);
        _OWORD *v18 = v21;
        v18 -= 2;
        v19 -= 2;
        v20 -= 4;
      }
      while (v20);
      v12 -= v16 & 0x3FFFFFFFFFFFFFFCLL;
      if (v16 == (v16 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_24;
      }
    }
    do
    {
      uint64_t v22 = *(void *)(v17 - 8);
      v17 -= 8;
      *--unint64_t v12 = v22;
    }
    while (v17 != v14);
LABEL_24:
    uint64_t v13 = *(void *)(v3 + 72);
  }
  *(void *)(v3 + 72) = v12;
  *(void *)(v3 + 80) = v6;
  uint64_t v23 = *(void *)(v3 + 88);
  *(void *)(v3 + 88) = v9;
  if (v13) {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v3 + 96) + 40))(*(void *)(v3 + 96), v13, v23 - v13);
  }
LABEL_27:
  *(void *)(v3 + 80) = v6;
  return result;
}

void ggl::RenderItem::~RenderItem(ggl::RenderItem *this)
{
  *(void *)this = &off_1EF55A458;
  *((void *)this + 2) = 3131955885;
}

{
  *(void *)this = &off_1EF55A458;
  *((void *)this + 2) = 3131955885;
  JUMPOUT(0x1A6239270);
}

uint64_t std::__function::__func<md::Ribbons::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RoadRibbonDescriptor::Passes,ggl::RenderItem *)#1},std::allocator<md::Ribbons::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::collectRenderItemsForPasses(unsigned int,ggl::CommandBuffer *,unsigned int)::{lambda(md::Ribbons::RoadRibbonDescriptor::Passes,ggl::RenderItem *)#1}>,void ()(md::Ribbons::RoadRibbonDescriptor::Passes,ggl::RenderItem *)>::operator()(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return ggl::CommandBuffer::pushRenderItem(*(void *)(a1 + 8), *a3);
}

char **ggl::Batcher::commit(long long **this, unsigned int a2, __n128 a3)
{
  if (this[1] == *this) {
    return (char **)(this + 7);
  }
  unint64_t v5 = this[4];
  unint64_t v6 = (unint64_t)this[5];
  if ((unint64_t)v5 >= v6)
  {
    uint64_t v9 = 0xAAAAAAAAAAAAAAALL;
    uint64_t v10 = this[3];
    unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * (((char *)v5 - (char *)v10) >> 3);
    unint64_t v12 = v11 + 1;
    if (v11 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - (void)v10) >> 3);
    if (2 * v13 > v12) {
      unint64_t v12 = 2 * v13;
    }
    if (v13 < 0x555555555555555) {
      uint64_t v9 = v12;
    }
    if (v9)
    {
      uint64_t v14 = 24 * v9;
      uint64_t v15 = (*(uint64_t (**)(long long *, uint64_t, uint64_t))(*(void *)this[6] + 16))(this[6], 24 * v9, 8);
      uint64_t v16 = v15 + 24 * v11;
      uint64_t v9 = v15 + v14;
      if (v15)
      {
        *(void *)uint64_t v16 = 0;
        *(void *)(v16 + 8) = 0;
        *(void *)(v16 + 16) = 0;
      }
    }
    else
    {
      uint64_t v16 = 24 * v11;
    }
    uint64_t v7 = (long long *)(v16 + 24);
    uint64_t v17 = this[3];
    uint64_t v18 = this[4];
    if (v18 == v17)
    {
      this[3] = (long long *)v16;
      this[4] = v7;
      long long v21 = this[5];
      this[5] = (long long *)v9;
    }
    else
    {
      do
      {
        *(void *)(v16 - 24) = 0;
        *(void *)(v16 - 16) = 0;
        v16 -= 24;
        *(void *)(v16 + 16) = 0;
        __n128 v19 = *(__n128 *)((char *)v18 - 24);
        uint64_t v18 = (long long *)((char *)v18 - 24);
        a3 = v19;
        *(__n128 *)uint64_t v16 = v19;
        *(void *)(v16 + 16) = *((void *)v18 + 2);
        *(void *)uint64_t v18 = 0;
        *((void *)v18 + 1) = 0;
        *((void *)v18 + 2) = 0;
      }
      while (v18 != v17);
      uint64_t v18 = this[3];
      uint64_t v20 = this[4];
      this[3] = (long long *)v16;
      this[4] = v7;
      long long v21 = this[5];
      this[5] = (long long *)v9;
      if (v20 != v18)
      {
        uint64_t v22 = v20;
        do
        {
          uint64_t v24 = (void *)*((void *)v22 - 3);
          uint64_t v22 = (long long *)((char *)v22 - 24);
          uint64_t v23 = v24;
          if (v24)
          {
            *((void *)v20 - 2) = v23;
            operator delete(v23);
          }
          uint64_t v20 = v22;
        }
        while (v22 != v18);
      }
    }
    if (v18) {
      (*(void (**)(long long *, long long *, int64_t))(*(void *)this[6] + 40))(this[6], v18, (char *)v21 - (char *)v18);
    }
  }
  else
  {
    if (v5)
    {
      *(void *)unint64_t v5 = 0;
      *((void *)v5 + 1) = 0;
      *((void *)v5 + 2) = 0;
    }
    uint64_t v7 = (long long *)((char *)v5 + 24);
  }
  uint64_t v25 = (__n128 *)*this;
  uint64_t v26 = (__n128 *)this[1];
  unint64_t v27 = 126 - 2 * __clz(((char *)v26 - (char *)*this) >> 4);
  BOOL v28 = v26 == (__n128 *)*this;
  this[4] = v7;
  if (v28) {
    uint64_t v29 = 0;
  }
  else {
    uint64_t v29 = v27;
  }
  uint64_t v8 = (char **)v7 - 3;
  std::__introsort<std::_ClassicAlgPolicy,ggl::Batcher::commit::$_0 &,gm::Range<unsigned long> *,false>(v25, v26, v29, 1, a3);
  uint64_t v31 = *this;
  uint64_t v30 = this[1];
  long long v34 = **this;
  for (unint64_t i = v31 + 1; i != v30; ++i)
  {
    if (*((void *)&v34 + 1) + (unint64_t)a2 >= *(void *)i)
    {
      if (*((void *)&v34 + 1) < *((void *)i + 1)) {
        *((void *)&v34 + 1) = *((void *)i + 1);
      }
    }
    else
    {
      if (*((void *)&v34 + 1) != (void)v34)
      {
        gm::MultiRange<unsigned long>::push_back(v8, &v34);
        uint64_t v30 = this[1];
      }
      long long v34 = *i;
    }
  }
  if (*((void *)&v34 + 1) != (void)v34) {
    gm::MultiRange<unsigned long>::push_back(v8, &v34);
  }
  this[1] = *this;
  return v8;
}

__n128 std::__introsort<std::_ClassicAlgPolicy,ggl::Batcher::commit(unsigned int)::$_0 &,gm::Range<unsigned long> *,false>(__n128 *a1, __n128 *a2, uint64_t a3, char a4, __n128 result)
{
__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ggl::Batcher::commit(unsigned int)::$_0 &,gm::Range<unsigned long> *>(__n128 *a1, __n128 *a2, unint64_t *a3, _OWORD *a4, __n128 result)
{
  unint64_t v5 = a2->n128_u64[0];
  unint64_t v6 = *a3;
  if (a2->n128_u64[0] >= a1->n128_u64[0])
  {
    if (v6 < v5)
    {
      uint64_t result = *a2;
      *a2 = *(__n128 *)a3;
      *(__n128 *)a3 = result;
      if (a2->n128_u64[0] < a1->n128_u64[0])
      {
        uint64_t result = *a1;
        *a1 = *a2;
        *a2 = result;
      }
    }
  }
  else
  {
    if (v6 < v5)
    {
      uint64_t result = *a1;
      *a1 = *(__n128 *)a3;
LABEL_9:
      *(__n128 *)a3 = result;
      goto LABEL_10;
    }
    uint64_t result = *a1;
    *a1 = *a2;
    *a2 = result;
    if (*a3 < a2->n128_u64[0])
    {
      uint64_t result = *a2;
      *a2 = *(__n128 *)a3;
      goto LABEL_9;
    }
  }
LABEL_10:
  if (*(void *)a4 < *a3)
  {
    uint64_t result = *(__n128 *)a3;
    *(_OWORD *)a3 = *a4;
    *a4 = result;
    if (*a3 < a2->n128_u64[0])
    {
      uint64_t result = *a2;
      *a2 = *(__n128 *)a3;
      *(__n128 *)a3 = result;
      if (a2->n128_u64[0] < a1->n128_u64[0])
      {
        uint64_t result = *a1;
        *a1 = *a2;
        *a2 = result;
      }
    }
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,ggl::Batcher::commit(unsigned int)::$_0 &,gm::Range<unsigned long> *>(__n128 *a1, __n128 *a2, __n128 a3)
{
  uint64_t v5 = a2 - a1;
  BOOL result = 1;
  switch(v5)
  {
    case 0:
    case 1:
      return result;
    case 2:
      uint64_t v7 = a2 - 1;
      if (a2[-1].n128_u64[0] < a1->n128_u64[0]) {
        goto LABEL_6;
      }
      return result;
    case 3:
      uint64_t v8 = (long long *)&a1[1];
      unint64_t v9 = a1[1].n128_u64[0];
      uint64_t v7 = a2 - 1;
      unint64_t v10 = a2[-1].n128_u64[0];
      if (v9 >= a1->n128_u64[0])
      {
        if (v10 < v9)
        {
          long long v27 = *v8;
          long long *v8 = (__int128)*v7;
          __n128 *v7 = (__n128)v27;
          if (a1[1].n128_u64[0] < a1->n128_u64[0])
          {
            long long v28 = (__int128)*a1;
            *a1 = (__n128)*v8;
            long long *v8 = v28;
          }
        }
      }
      else if (v10 >= v9)
      {
        long long v31 = (__int128)*a1;
        *a1 = (__n128)*v8;
        long long *v8 = v31;
        if (v7->n128_u64[0] < a1[1].n128_u64[0])
        {
          long long v32 = *v8;
          long long *v8 = (__int128)*v7;
          __n128 *v7 = (__n128)v32;
        }
      }
      else
      {
LABEL_6:
        __n128 v11 = *a1;
        *a1 = *v7;
        __n128 *v7 = v11;
      }
      return result;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ggl::Batcher::commit::$_0 &,gm::Range<unsigned long> *>(a1, a1 + 1, a1[2].n128_u64, (__n128 *)a2[-1].n128_u64, a3);
      return 1;
    case 5:
      uint64_t v18 = a1 + 1;
      unint64_t v19 = a1 + 2;
      unint64_t v20 = a1 + 3;
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,ggl::Batcher::commit::$_0 &,gm::Range<unsigned long> *>(a1, a1 + 1, a1[2].n128_u64, (__n128 *)a1[3].n128_u64, a3);
      unint64_t v22 = a2[-1].n128_u64[0];
      unint64_t v21 = a2 - 1;
      if (v22 < a1[3].n128_u64[0])
      {
        __n128 v23 = *v20;
        __n128 *v20 = *v21;
        *unint64_t v21 = v23;
        if (v20->n128_u64[0] < v19->n128_u64[0])
        {
          __n128 v24 = *v19;
          __n128 *v19 = *v20;
          __n128 *v20 = v24;
          if (v19->n128_u64[0] < v18->n128_u64[0])
          {
            __n128 v25 = *v18;
            __n128 *v18 = *v19;
            __n128 *v19 = v25;
            if (a1[1].n128_u64[0] < a1->n128_u64[0])
            {
              __n128 v26 = *a1;
              *a1 = *v18;
              __n128 *v18 = v26;
            }
          }
        }
      }
      return 1;
    default:
      unint64_t v12 = a1 + 2;
      unint64_t v13 = a1[2].n128_u64[0];
      uint64_t v14 = a1 + 1;
      unint64_t v15 = a1[1].n128_u64[0];
      unint64_t v16 = a1->n128_u64[0];
      if (v15 >= a1->n128_u64[0])
      {
        if (v13 < v15)
        {
          __n128 v29 = *v14;
          *uint64_t v14 = *v12;
          *unint64_t v12 = v29;
          if (v14->n128_u64[0] < v16)
          {
            __n128 v30 = *a1;
            *a1 = *v14;
            *uint64_t v14 = v30;
          }
        }
      }
      else
      {
        if (v13 >= v15)
        {
          __n128 v33 = *a1;
          *a1 = *v14;
          *uint64_t v14 = v33;
          if (v13 >= a1[1].n128_u64[0]) {
            goto LABEL_27;
          }
          __n128 v17 = *v14;
          *uint64_t v14 = *v12;
        }
        else
        {
          __n128 v17 = *a1;
          *a1 = *v12;
        }
        *unint64_t v12 = v17;
      }
LABEL_27:
      unint64_t v34 = a1 + 3;
      if (&a1[3] == a2) {
        return 1;
      }
      uint64_t v35 = 0;
      int v36 = 0;
      break;
  }
  while (1)
  {
    unint64_t v38 = v34->n128_u64[0];
    if (v34->n128_u64[0] < v12->n128_u64[0])
    {
      uint64_t v39 = v34->n128_i64[1];
      uint64_t v40 = v35;
      do
      {
        *(__n128 *)((char *)a1 + v40 + 48) = *(__n128 *)((char *)a1 + v40 + 32);
        if (v40 == -32)
        {
          __n128 v37 = (unint64_t *)a1;
          goto LABEL_30;
        }
        unint64_t v41 = *(unint64_t *)((char *)a1[1].n128_u64 + v40);
        v40 -= 16;
      }
      while (v38 < v41);
      __n128 v37 = (unint64_t *)((char *)a1[3].n128_u64 + v40);
LABEL_30:
      unint64_t *v37 = v38;
      v37[1] = v39;
      if (++v36 == 8) {
        return &v34[1] == a2;
      }
    }
    unint64_t v12 = v34;
    v35 += 16;
    if (++v34 == a2) {
      return 1;
    }
  }
}

void gss::CartoStyle<gss::ScenePropertyID>::populateStyles(unint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  unint64_t v4 = 0x9DDFEA08EB382D69 * (((8 * a1) + 8) ^ HIDWORD(a1));
  unint64_t v5 = 0x9DDFEA08EB382D69 * (HIDWORD(a1) ^ (v4 >> 47) ^ v4);
  unint64_t v6 = (std::mutex *)(a2
                    + ((unint64_t)((9 * ((v5 >> 47) ^ v5)) & 0x1F) << 6)
                    + 480);
  std::mutex::lock(v6);
  unsigned __int8 v8 = atomic_load((unsigned __int8 *)(v3 + 123));
  if ((v8 & 1) == 0)
  {
    if (*(void *)(v3 + 72))
    {
LABEL_109:
      atomic_store(1u, (unsigned __int8 *)(v3 + 123));
      goto LABEL_110;
    }
    unint64_t v105 = v6;
    uint64_t v9 = gss::Allocator::instance(v7);
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 16))(v9, 72, 8);
    *(void *)uint64_t v10 = &unk_1EF58A4A0;
    *(void *)(v10 + 8) = 0;
    *(void *)(v10 + 16) = 0;
    *(void *)(v10 + 24) = v9;
    long long v11 = 0uLL;
    *(_OWORD *)(v10 + 48) = 0u;
    *(void *)(v10 + 64) = 0;
    *(_OWORD *)(v10 + 32) = 0u;
    unint64_t v12 = *(std::__shared_weak_count **)(v3 + 80);
    *(void *)(v3 + 72) = v10 + 32;
    *(void *)(v3 + 80) = v10;
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
      long long v11 = 0uLL;
    }
    long long v124 = v11;
    long long v125 = v11;
    int v126 = 1065353216;
    char v123 = 0;
    memset(v113, 0, sizeof(v113));
    char v114 = 1;
    memset(v115, 0, sizeof(v115));
    char v116 = 1;
    memset(v117, 0, sizeof(v117));
    char v118 = 1;
    memset(v119, 0, sizeof(v119));
    char v120 = 1;
    memset(v121, 0, sizeof(v121));
    char v122 = 1;
    gss::CartoStyle<gss::ScenePropertyID>::applyStyle(v3, (uint64_t)v113, v2, -1.0);
    geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v113);
    geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v115);
    geo::intern_linear_map<gss::ScenePropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v117);
    geo::intern_linear_map<gss::ScenePropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v119);
    geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((gss::Allocator *)v121);
    std::__hash_table<std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::__unordered_map_hasher<gss::StylePropertySet<gss::ScenePropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::hash<gss::StylePropertySet<gss::ScenePropertyID>>,std::equal_to<gss::StylePropertySet<gss::ScenePropertyID>>,true>,std::__unordered_map_equal<gss::StylePropertySet<gss::ScenePropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::equal_to<gss::StylePropertySet<gss::ScenePropertyID>>,std::hash<gss::StylePropertySet<gss::ScenePropertyID>>,true>,std::allocator<std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>>>::__emplace_unique_key_args<gss::StylePropertySet<gss::ScenePropertyID>,gss::StylePropertySet<gss::ScenePropertyID>,unsigned char &>((uint64_t)&v124, (uint64_t)v113, (uint64_t)v113, &v123);
    char v123 = 1;
    gss::StylePropertySet<gss::PropertyID>::~StylePropertySet((uint64_t)v113);
    unint64_t v13 = 0;
    uint64_t v14 = 1;
    do
    {
      memset(v113, 0, sizeof(v113));
      char v114 = 1;
      memset(v115, 0, sizeof(v115));
      char v116 = 1;
      memset(v117, 0, sizeof(v117));
      char v118 = 1;
      memset(v119, 0, sizeof(v119));
      char v120 = 1;
      memset(v121, 0, sizeof(v121));
      char v122 = 1;
      gss::CartoStyle<gss::ScenePropertyID>::applyStyle(v3, (uint64_t)v113, v2, (float)v13);
      geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v113);
      geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v115);
      geo::intern_linear_map<gss::ScenePropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v117);
      geo::intern_linear_map<gss::ScenePropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v119);
      geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((gss::Allocator *)v121);
      unint64_t v15 = std::__hash_table<std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::__unordered_map_hasher<gss::StylePropertySet<gss::ScenePropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::hash<gss::StylePropertySet<gss::ScenePropertyID>>,std::equal_to<gss::StylePropertySet<gss::ScenePropertyID>>,true>,std::__unordered_map_equal<gss::StylePropertySet<gss::ScenePropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::equal_to<gss::StylePropertySet<gss::ScenePropertyID>>,std::hash<gss::StylePropertySet<gss::ScenePropertyID>>,true>,std::allocator<std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>>>::__emplace_unique_key_args<gss::StylePropertySet<gss::ScenePropertyID>,gss::StylePropertySet<gss::ScenePropertyID>,unsigned char &>((uint64_t)&v124, (uint64_t)v113, (uint64_t)v113, &v123);
      if (v16)
      {
        uint64_t v14 = (v14 + 1);
        char v123 = v14;
      }
      *((unsigned char *)v13 + *(void *)(v3 + 72) + 16) = v15[96];
      gss::StylePropertySet<gss::PropertyID>::~StylePropertySet((uint64_t)v113);
      unint64_t v13 = (gss::Allocator *)((char *)v13 + 1);
    }
    while (v13 != (gss::Allocator *)24);
    uint64_t v17 = *(void *)(v3 + 72);
    if (!*(unsigned char *)(v17 + 12))
    {
      unint64_t v18 = *(unsigned __int16 *)(v17 + 8);
      if (v18 <= v14)
      {
        if (v18 >= v14) {
          goto LABEL_23;
        }
        uint64_t v14 = v14;
        if (*(unsigned __int16 *)(v17 + 10) < v14)
        {
          geo::intern_vector<gss::StylePropertySet<gss::PropertyID>,geo::StdAllocator<gss::StylePropertySet<gss::PropertyID>,gss::Allocator>>::reallocate(*(gss::Allocator ***)(v3 + 72), v14);
          unint64_t v18 = *(unsigned __int16 *)(v17 + 8);
        }
        if (v18 != v14)
        {
          uint64_t v21 = *(void *)v17 + 80 * v14;
          uint64_t v22 = *(void *)v17 + 80 * v18;
          do
          {
            *(void *)uint64_t v22 = 0;
            *(void *)(v22 + 8) = 0;
            *(unsigned char *)(v22 + 15) = 1;
            *(void *)(v22 + 16) = 0;
            *(void *)(v22 + 23) = 0;
            *(unsigned char *)(v22 + 31) = 1;
            *(void *)(v22 + 32) = 0;
            *(void *)(v22 + 39) = 0;
            *(unsigned char *)(v22 + 47) = 1;
            *(void *)(v22 + 48) = 0;
            *(void *)(v22 + 55) = 0;
            *(unsigned char *)(v22 + 63) = 1;
            *(void *)(v22 + 64) = 0;
            *(void *)(v22 + 71) = 0;
            *(unsigned char *)(v22 + 79) = 1;
            v22 += 80;
          }
          while (v22 != v21);
        }
      }
      else
      {
        uint64_t v19 = *(void *)v17 + 80 * v14;
        uint64_t v20 = 80 * *(unsigned __int16 *)(v17 + 8) - 80 * v14;
        do
        {
          uint64_t v19 = gss::StylePropertySet<gss::PropertyID>::~StylePropertySet(v19) + 80;
          v20 -= 80;
        }
        while (v20);
        uint64_t v14 = v14;
      }
      *(_WORD *)(v17 + 8) = v14;
    }
LABEL_23:
    uint64_t v104 = v2;
    __n128 v23 = (uint64_t *)v125;
    if ((void)v125)
    {
      uint64_t v106 = v3;
      do
      {
        __n128 v24 = *(_OWORD ***)(v3 + 72);
        unsigned int v25 = *((unsigned __int8 *)v23 + 96);
        __n128 v26 = *v24;
        geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=(&(*v24)[5 * *((unsigned __int8 *)v23 + 96)], (uint64_t)(v23 + 2));
        isSpaceAvailable = (gss::Allocator *)geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=(&v26[5 * v25 + 1], (uint64_t)(v23 + 4));
        long long v28 = (uint64_t *)&v26[5 * v25];
        if (v28 == v23 + 2) {
          goto LABEL_35;
        }
        __n128 v29 = (const void **)(v28 + 4);
        uint64_t __dst = (char *)&v26[5 * v25 + 2] + 14;
        if (!*__dst && *v29)
        {
          uint64_t v30 = gss::Allocator::instance(isSpaceAvailable);
          isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v30 + 40))(v30, *v29, WORD6(v26[5 * v25 + 2]));
        }
        long long v31 = &v26[5 * v25];
        *((unsigned char *)v31 + 47) = 1;
        *(const void **)((char *)v29 + 7) = 0;
        *__n128 v29 = 0;
        uint64_t v107 = (char *)v31 + 47;
        if (*((unsigned char *)v23 + 62))
        {
          *__n128 v29 = (const void *)v23[6];
          DWORD2(v26[5 * v25 + 2]) = *((_DWORD *)v23 + 14);
        }
        else
        {
          unsigned int v53 = *((unsigned __int16 *)v23 + 29);
          if (!*__dst)
          {
            BOOL v54 = &v26[5 * v25];
            unsigned int v56 = *((unsigned __int16 *)v54 + 22);
            __n128 v55 = (_WORD *)v54 + 22;
            if (v56 < v53)
            {
              int v57 = (v53 & 0xFFFC) + 4;
              uint64_t v14 = v57 + 4 * v53;
              uint64_t v58 = gss::Allocator::instance(isSpaceAvailable);
              isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v58 + 16))(v58, (unsigned __int16)(v57 + 4 * v53) & 0xFFFC, 1);
              unint64_t v13 = isSpaceAvailable;
              if (*v29)
              {
                unint64_t v59 = &v26[5 * v25];
                unsigned int v61 = *((unsigned __int16 *)v59 + 21);
                uint64_t v14 = (uint64_t)v59 + 42;
                size_t v60 = v61;
                if (v61)
                {
                  isSpaceAvailable = (gss::Allocator *)memmove(isSpaceAvailable, *v29, v60);
                  if (*(_WORD *)v14) {
                    isSpaceAvailable = (gss::Allocator *)memmove((char *)v13 + (unsigned __int16)v57, (char *)*v29 + WORD4(v26[5 * v25 + 2]), 4 * *(unsigned __int16 *)v14);
                  }
                }
                uint64_t v62 = gss::Allocator::instance(isSpaceAvailable);
                isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v62 + 40))(v62, *v29, (unsigned __int16)*v55);
              }
              *__n128 v55 = v53;
              *__n128 v29 = v13;
              WORD4(v26[5 * v25 + 2]) = v57;
              unsigned int v53 = *((unsigned __int16 *)v23 + 29);
              if (!*((_WORD *)v23 + 29)) {
                goto LABEL_34;
              }
LABEL_75:
              unsigned int v73 = 0;
              long long v74 = 0;
              unint64_t v75 = &v26[5 * v25];
              unint64_t v13 = (gss::Allocator *)((char *)v75 + 42);
              long long v76 = (unsigned __int16 *)v75 + 20;
              do
              {
                isSpaceAvailable = (gss::Allocator *)geo::intern_linear_map<gss::ScenePropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v29);
                if (!isSpaceAvailable) {
                  break;
                }
                if (v73 < *((unsigned __int16 *)v23 + 29))
                {
                  uint64_t v79 = v23[6];
                  long long v74 = (unsigned char *)(v79 + v73);
                  uint64_t v14 = v79 + *((unsigned __int16 *)v23 + 28) + 4 * v73;
                }
                uint64_t v77 = *(unsigned __int16 *)v13;
                uint64_t v78 = *v29;
                v78[v77] = *v74;
                *(_DWORD *)&v78[4 * v77 + *v76] = *(_DWORD *)v14;
                *(_WORD *)unint64_t v13 = v77 + 1;
                if (v73 + 1 < *((unsigned __int16 *)v23 + 29)) {
                  ++v73;
                }
                else {
                  unsigned int v73 = *((unsigned __int16 *)v23 + 29);
                }
              }
              while (v73 != v53);
              goto LABEL_34;
            }
          }
          if (*((_WORD *)v23 + 29)) {
            goto LABEL_75;
          }
        }
LABEL_34:
        *uint64_t __dst = *((unsigned char *)v23 + 62);
        *uint64_t v107 = *((unsigned char *)v23 + 63);
LABEL_35:
        long long v32 = (uint64_t *)&v26[5 * v25];
        if (v32 == v23 + 2) {
          goto LABEL_42;
        }
        __n128 v33 = (const void **)(v32 + 6);
        long long v111 = (char *)&v26[5 * v25 + 3] + 14;
        if (!*v111 && *v33)
        {
          uint64_t v34 = gss::Allocator::instance(isSpaceAvailable);
          isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v34 + 40))(v34, *v33, WORD6(v26[5 * v25 + 3]));
        }
        uint64_t v35 = &v26[5 * v25];
        *((unsigned char *)v35 + 63) = 1;
        *(const void **)((char *)v33 + 7) = 0;
        __n128 *v33 = 0;
        __dsta = (char *)v35 + 63;
        if (*((unsigned char *)v23 + 78))
        {
          __n128 *v33 = (const void *)v23[8];
          DWORD2(v26[5 * v25 + 3]) = *((_DWORD *)v23 + 18);
        }
        else
        {
          unsigned int v63 = *((unsigned __int16 *)v23 + 37);
          if (!*v111)
          {
            long long v64 = &v26[5 * v25];
            unsigned int v66 = *((unsigned __int16 *)v64 + 30);
            unint64_t v65 = (_WORD *)v64 + 30;
            if (v66 < v63)
            {
              int v67 = (v63 & 0xFFF8) + 8;
              uint64_t v14 = v67 + 8 * v63;
              uint64_t v68 = gss::Allocator::instance(isSpaceAvailable);
              isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v68 + 16))(v68, (unsigned __int16)(v67 + 8 * v63) & 0xFFF8, 1);
              unint64_t v13 = isSpaceAvailable;
              if (*v33)
              {
                uint64_t v69 = &v26[5 * v25];
                unsigned int v71 = *((unsigned __int16 *)v69 + 29);
                uint64_t v14 = (uint64_t)v69 + 58;
                size_t v70 = v71;
                if (v71)
                {
                  isSpaceAvailable = (gss::Allocator *)memmove(isSpaceAvailable, *v33, v70);
                  if (*(_WORD *)v14) {
                    isSpaceAvailable = (gss::Allocator *)memmove((char *)v13 + (unsigned __int16)v67, (char *)*v33 + WORD4(v26[5 * v25 + 3]), 8 * *(unsigned __int16 *)v14);
                  }
                }
                uint64_t v72 = gss::Allocator::instance(isSpaceAvailable);
                isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v72 + 40))(v72, *v33, (unsigned __int16)*v65);
              }
              *unint64_t v65 = v63;
              __n128 *v33 = v13;
              WORD4(v26[5 * v25 + 3]) = v67;
              unsigned int v63 = *((unsigned __int16 *)v23 + 37);
              if (!*((_WORD *)v23 + 37)) {
                goto LABEL_41;
              }
LABEL_84:
              unsigned int v80 = 0;
              int64_t v81 = 0;
              int64_t v82 = &v26[5 * v25];
              BOOL v83 = (_WORD *)v82 + 29;
              uint64_t v14 = (uint64_t)v82 + 56;
              do
              {
                isSpaceAvailable = (gss::Allocator *)geo::intern_linear_map<gss::ScenePropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v33);
                if (!isSpaceAvailable) {
                  break;
                }
                if (v80 < *((unsigned __int16 *)v23 + 37))
                {
                  uint64_t v86 = v23[8];
                  int64_t v81 = (unsigned char *)(v86 + v80);
                  unint64_t v13 = (gss::Allocator *)(v86 + *((unsigned __int16 *)v23 + 36) + 8 * v80);
                }
                uint64_t v84 = (unsigned __int16)*v83;
                long long v85 = *v33;
                v85[v84] = *v81;
                *(void *)&v85[8 * v84 + *(unsigned __int16 *)v14] = *(void *)v13;
                *BOOL v83 = v84 + 1;
                if (v80 + 1 < *((unsigned __int16 *)v23 + 37)) {
                  ++v80;
                }
                else {
                  unsigned int v80 = *((unsigned __int16 *)v23 + 37);
                }
              }
              while (v80 != v63);
              goto LABEL_41;
            }
          }
          if (*((_WORD *)v23 + 37)) {
            goto LABEL_84;
          }
        }
LABEL_41:
        *long long v111 = *((unsigned char *)v23 + 78);
        unsigned char *__dsta = *((unsigned char *)v23 + 79);
LABEL_42:
        int v36 = (uint64_t *)&v26[5 * v25];
        if (v36 == v23 + 2) {
          goto LABEL_27;
        }
        __n128 v37 = (const void **)(v36 + 8);
        unint64_t v38 = &v26[5 * v25];
        int v39 = *((unsigned __int8 *)v38 + 78);
        uint64_t v14 = (uint64_t)v38 + 78;
        if (!v39 && *v37)
        {
          uint64_t v40 = gss::Allocator::instance(isSpaceAvailable);
          isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v40 + 40))(v40, *v37, WORD6(v26[5 * v25 + 4]));
        }
        unint64_t v41 = &v26[5 * v25];
        *((unsigned char *)v41 + 79) = 1;
        unint64_t v13 = (gss::Allocator *)((char *)v41 + 79);
        *(const void **)((char *)v37 + 7) = 0;
        unint64_t *v37 = 0;
        if (*((unsigned char *)v23 + 94))
        {
          unint64_t *v37 = (const void *)v23[10];
          DWORD2(v26[5 * v25 + 4]) = *((_DWORD *)v23 + 22);
        }
        else
        {
          unsigned int v42 = *((unsigned __int16 *)v23 + 45);
          if (!*(unsigned char *)v14)
          {
            unint64_t v43 = &v26[5 * v25];
            unsigned int v45 = *((unsigned __int16 *)v43 + 38);
            long long v44 = (_WORD *)v43 + 38;
            if (v45 < v42)
            {
              unsigned __int16 v112 = (v42 & 0xFFF8) + 8;
              uint64_t v46 = gss::Allocator::instance(isSpaceAvailable);
              long long v47 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v46 + 16))(v46, (unsigned __int16)(v112 + 16 * v42) & 0xFFF8, 1);
              if (*v37)
              {
                __dstb = v47;
                unint64_t v48 = &v26[5 * v25];
                unsigned int v51 = *((unsigned __int16 *)v48 + 37);
                long long v50 = (_WORD *)v48 + 37;
                size_t v49 = v51;
                if (v51)
                {
                  long long v47 = (char *)memmove(v47, *v37, v49);
                  if (*v50) {
                    long long v47 = (char *)memmove(&__dstb[v112], (char *)*v37 + WORD4(v26[5 * v25 + 4]), 16 * (unsigned __int16)*v50);
                  }
                }
                uint64_t v52 = gss::Allocator::instance((gss::Allocator *)v47);
                (*(void (**)(uint64_t, const void *, void))(*(void *)v52 + 40))(v52, *v37, (unsigned __int16)*v44);
                long long v47 = __dstb;
              }
              *long long v44 = v42;
              unint64_t *v37 = v47;
              WORD4(v26[5 * v25 + 4]) = v112;
              unsigned int v42 = *((unsigned __int16 *)v23 + 45);
              if (!*((_WORD *)v23 + 45)) {
                goto LABEL_26;
              }
LABEL_93:
              unsigned int v87 = 0;
              uint64_t v88 = 0;
              unint64_t v89 = &v26[5 * v25];
              uint64_t v90 = (_WORD *)v89 + 37;
              unint64_t v91 = (unsigned __int16 *)v89 + 36;
              do
              {
                if (!geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v37)) {
                  break;
                }
                if (v87 < *((unsigned __int16 *)v23 + 45))
                {
                  uint64_t v94 = v23[10];
                  uint64_t v88 = (unsigned char *)(v94 + v87);
                  __n128 v26 = (_OWORD *)(v94 + *((unsigned __int16 *)v23 + 44) + 16 * v87);
                }
                uint64_t v92 = (unsigned __int16)*v90;
                BOOL v93 = *v37;
                v93[v92] = *v88;
                *(_OWORD *)&v93[16 * v92 + *v91] = *v26;
                ++*v90;
                if (v87 + 1 < *((unsigned __int16 *)v23 + 45)) {
                  ++v87;
                }
                else {
                  unsigned int v87 = *((unsigned __int16 *)v23 + 45);
                }
              }
              while (v87 != v42);
              goto LABEL_26;
            }
          }
          if (*((_WORD *)v23 + 45)) {
            goto LABEL_93;
          }
        }
LABEL_26:
        *(unsigned char *)uint64_t v14 = *((unsigned char *)v23 + 94);
        *(unsigned char *)unint64_t v13 = *((unsigned char *)v23 + 95);
LABEL_27:
        __n128 v23 = (uint64_t *)*v23;
        uint64_t v3 = v106;
      }
      while (v23);
    }
    uint64_t v2 = v104;
    std::mutex::lock((std::mutex *)(v104 + 168));
    uint64_t v95 = *(void *)(v3 + 72);
    if (*(_WORD *)(v95 + 8))
    {
      uint64_t v96 = *(void *)v95;
      uint64_t v97 = 80 * *(unsigned __int16 *)(v95 + 8);
      do
      {
        gss::StylePropertySet<gss::ScenePropertyID>::intern(v96, v104 + 232);
        v96 += 80;
        v97 -= 80;
      }
      while (v97);
    }
    std::mutex::unlock((std::mutex *)(v104 + 168));
    long long v98 = (void *)v125;
    if ((void)v125)
    {
      do
      {
        long long v99 = (void *)*v98;
        gss::StylePropertySet<gss::PropertyID>::~StylePropertySet((uint64_t)(v98 + 2));
        operator delete(v98);
        long long v98 = v99;
      }
      while (v99);
    }
    uint64_t v100 = (void *)v124;
    *(void *)&long long v124 = 0;
    if (v100) {
      operator delete(v100);
    }
    unint64_t v6 = v105;
    goto LABEL_109;
  }
LABEL_110:
  std::mutex::unlock(v6);
  if (*(_WORD *)(v3 + 64))
  {
    uint64_t v101 = *(uint64_t **)(v3 + 56);
    uint64_t v102 = 16 * *(unsigned __int16 *)(v3 + 64);
    do
    {
      uint64_t v103 = *v101;
      v101 += 2;
      gss::CartoStyle<gss::ScenePropertyID>::populateStyles(v103, v2);
      v102 -= 16;
    }
    while (v102);
  }
  atomic_store(1u, (unsigned __int8 *)(v3 + 122));
}

void sub_1A17D4294(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  std::unordered_map<gss::StylePropertySet<gss::PropertyID>,unsigned char>::~unordered_map[abi:nn180100](v16 - 128);
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

uint64_t gss::CartoStyle<gss::ScenePropertyID>::applyStyle(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  if (a3 && *(_WORD *)(a1 + 32))
  {
    unsigned __int8 v8 = *(unsigned int **)(a1 + 24);
    uint64_t v9 = 4 * *(unsigned __int16 *)(a1 + 32);
    do
    {
      unsigned int v10 = *v8++;
      gss::CartoStyle<gss::ScenePropertyID>::applyStyle(*(void *)(*(void *)(a3 + 64) + 16 * v10), a2, a3, a4);
      v9 -= 4;
    }
    while (v9);
  }
  uint64_t result = gss::StylePropertySet<gss::ScenePropertyID>::unionWith(a2, *(void *)(a1 + 88));
  if (*(_WORD *)(a1 + 48))
  {
    uint64_t v12 = *(void *)(a1 + 40);
    uint64_t v13 = 24 * *(unsigned __int16 *)(a1 + 48);
    uint64_t v14 = (uint64_t *)(v12 + 8);
    do
    {
      if (*((float *)v14 - 2) + -0.001 <= a4 && *((float *)v14 - 1) > a4) {
        uint64_t result = gss::StylePropertySet<gss::ScenePropertyID>::unionWith(a2, *v14);
      }
      v14 += 3;
      v13 -= 24;
    }
    while (v13);
  }
  return result;
}

uint64_t gss::StylePropertySet<gss::ScenePropertyID>::unionWith(uint64_t result, uint64_t a2)
{
  unint64_t v5 = (unsigned __int8 **)result;
  if (!*(unsigned char *)(result + 14))
  {
    uint64_t v140 = 0;
    unsigned int v141 = 0;
    int v142 = *(unsigned __int16 *)(a2 + 10);
    uint64_t v3 = (unsigned __int8 *)*(unsigned __int16 *)(a2 + 10);
    while (1)
    {
      if (v141 == v142) {
        goto LABEL_2;
      }
      if (v141 < v3)
      {
        uint64_t v140 = (unsigned char *)(*(void *)a2 + v141);
        uint64_t v2 = &v140[*(unsigned __int16 *)(a2 + 8)];
      }
      uint64_t v145 = *((unsigned __int16 *)v5 + 5);
      if (!*((_WORD *)v5 + 5))
      {
        unsigned __int16 v150 = 0;
        goto LABEL_286;
      }
      uint64_t v146 = (uint64_t)*v5;
      if (!*((unsigned char *)v5 + 15)) {
        break;
      }
      if (v145 <= 0x1D)
      {
        uint64_t v147 = 0;
        unsigned int v148 = *v140;
        while (1)
        {
          unsigned int v149 = *(unsigned __int8 *)(v146 + v147);
          if (v149 >= v148) {
            break;
          }
          if (v145 == ++v147) {
            goto LABEL_287;
          }
        }
        if (v149 == v148) {
          unsigned __int16 v150 = v147;
        }
        else {
          unsigned __int16 v150 = *((_WORD *)v5 + 5);
        }
        goto LABEL_286;
      }
      unsigned int v153 = *v140;
      unint64_t v152 = *v5;
      unint64_t v154 = *((unsigned __int16 *)v5 + 5);
      do
      {
        unint64_t v155 = v154 >> 1;
        long long v156 = &v152[v154 >> 1];
        unsigned int v158 = *v156;
        long long v157 = v156 + 1;
        v154 += ~(v154 >> 1);
        if (v158 < v153) {
          unint64_t v152 = v157;
        }
        else {
          unint64_t v154 = v155;
        }
      }
      while (v154);
      if (v152 != (unsigned __int8 *)(v146 + v145) && *v152 == v153) {
        goto LABEL_282;
      }
LABEL_287:
      uint64_t result = geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v5);
      if (!result) {
        goto LABEL_2;
      }
      if (v141 >= v3 && v141 < *(unsigned __int16 *)(a2 + 10))
      {
        uint64_t v140 = (unsigned char *)(*(void *)a2 + v141);
        uint64_t v2 = &v140[*(unsigned __int16 *)(a2 + 8)];
      }
      uint64_t v143 = *((unsigned __int16 *)v5 + 5);
      uint64_t v144 = (uint64_t)*v5;
      *(unsigned char *)(v144 + v143) = *v140;
      *(unsigned char *)(v144 + *((unsigned __int16 *)v5 + 4) + v143) = *v2;
      ++*((_WORD *)v5 + 5);
      *((unsigned char *)v5 + 15) = 0;
      uint64_t v3 = (unsigned __int8 *)*(unsigned __int16 *)(a2 + 10);
LABEL_257:
      if (v141 + 1 < v3) {
        ++v141;
      }
      else {
        unsigned int v141 = v3;
      }
    }
    uint64_t v151 = *((unsigned __int16 *)v5 + 5);
    unint64_t v152 = *v5;
    while (*v152 != *v140)
    {
      ++v152;
      if (!--v151)
      {
        LOWORD(v152) = v146 + v145;
        break;
      }
    }
LABEL_282:
    unsigned __int16 v150 = (_WORD)v152 - v146;
LABEL_286:
    if (v145 != v150) {
      goto LABEL_257;
    }
    goto LABEL_287;
  }
LABEL_2:
  int v6 = *(unsigned __int16 *)(a2 + 26);
  if (*(_WORD *)(a2 + 26))
  {
    uint64_t v7 = 0;
    unsigned int v8 = 0;
    unsigned int v9 = *(unsigned __int16 *)(a2 + 26);
    while (1)
    {
      if (v8 < v9)
      {
        uint64_t v7 = (unsigned __int8 *)(*(void *)(a2 + 16) + v8);
        uint64_t v3 = &v7[*(unsigned __int16 *)(a2 + 24)];
      }
      unsigned __int8 v11 = *v3;
      uint64_t v12 = (unsigned __int8 *)*((unsigned __int16 *)v5 + 13);
      if (!*((_WORD *)v5 + 13)) {
        goto LABEL_31;
      }
      uint64_t v13 = v5[2];
      if (!*((unsigned char *)v5 + 31)) {
        break;
      }
      if (v12 <= 0x1D)
      {
        uint64_t v14 = 0;
        unsigned int v15 = *v7;
        while (1)
        {
          unsigned int v16 = v13[v14];
          if (v16 >= v15) {
            break;
          }
          if (v12 == (unsigned __int8 *)++v14) {
            goto LABEL_32;
          }
        }
        if (v16 == v15) {
          unsigned __int16 v24 = v14;
        }
        else {
          unsigned __int16 v24 = *((_WORD *)v5 + 13);
        }
        if (v12 != v24)
        {
LABEL_51:
          uint64_t v10 = v24;
          goto LABEL_5;
        }
        goto LABEL_31;
      }
      unsigned int v15 = *v7;
      unint64_t v18 = v5[2];
      unint64_t v19 = *((unsigned __int16 *)v5 + 13);
      do
      {
        unint64_t v20 = v19 >> 1;
        uint64_t v21 = &v18[v19 >> 1];
        unsigned int v23 = *v21;
        uint64_t v22 = v21 + 1;
        v19 += ~(v19 >> 1);
        if (v23 < v15) {
          unint64_t v18 = v22;
        }
        else {
          unint64_t v19 = v20;
        }
      }
      while (v19);
      if (v18 != &v12[(void)v13] && *v18 == v15) {
        goto LABEL_30;
      }
LABEL_32:
      if (!*((unsigned char *)v5 + 30))
      {
        if (!*((_WORD *)v5 + 13)) {
          goto LABEL_63;
        }
        unsigned int v25 = v5[2];
        if (*((unsigned char *)v5 + 31))
        {
          __n128 v26 = v5[2];
          unint64_t v27 = *((unsigned __int16 *)v5 + 13);
          if (v12 < 0x1E)
          {
            uint64_t v28 = 0;
            while (1)
            {
              unsigned int v29 = v25[v28];
              if (v29 >= v15) {
                break;
              }
              if (v12 == (unsigned __int8 *)++v28) {
                goto LABEL_63;
              }
            }
            if (v29 == v15) {
              unsigned __int16 v35 = v28;
            }
            else {
              unsigned __int16 v35 = *((_WORD *)v5 + 13);
            }
            if (v12 != v35) {
              goto LABEL_4;
            }
LABEL_63:
            uint64_t result = geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v5 + 8);
            LOWORD(v12) = *((_WORD *)v5 + 13);
            if (result)
            {
              uint64_t v12 = &v5[2][*((unsigned __int16 *)v5 + 13)];
              *uint64_t v12 = v15;
              v12[*((unsigned __int16 *)v5 + 12)] = 0;
              LOWORD(v12) = *((_WORD *)v5 + 13) + 1;
              *((_WORD *)v5 + 13) = (_WORD)v12;
              *((unsigned char *)v5 + 31) = 0;
            }
            goto LABEL_4;
          }
          do
          {
            unint64_t v30 = v27 >> 1;
            long long v31 = &v26[v27 >> 1];
            unsigned int v33 = *v31;
            long long v32 = v31 + 1;
            v27 += ~(v27 >> 1);
            if (v33 < v15) {
              __n128 v26 = v32;
            }
            else {
              unint64_t v27 = v30;
            }
          }
          while (v27);
          if (v26 == &v12[(void)v25] || *v26 != v15) {
            goto LABEL_63;
          }
        }
        else
        {
          uint64_t v34 = *((unsigned __int16 *)v5 + 13);
          __n128 v26 = v5[2];
          while (*v26 != v15)
          {
            ++v26;
            if (!--v34)
            {
              LOWORD(v26) = (_WORD)v25 + (_WORD)v12;
              break;
            }
          }
        }
        if (v12 == (unsigned __int16)((_WORD)v26 - (_WORD)v25)) {
          goto LABEL_63;
        }
      }
LABEL_4:
      uint64_t v10 = (unsigned __int16)v12 - 1;
LABEL_5:
      v5[2][*((unsigned __int16 *)v5 + 12) + v10] = v11;
      unsigned int v9 = *(unsigned __int16 *)(a2 + 26);
      if (v8 + 1 < v9) {
        ++v8;
      }
      else {
        unsigned int v8 = *(unsigned __int16 *)(a2 + 26);
      }
      if (v8 == v6) {
        goto LABEL_65;
      }
    }
    uint64_t v17 = *((unsigned __int16 *)v5 + 13);
    unint64_t v18 = v5[2];
    while (*v18 != *v7)
    {
      ++v18;
      if (!--v17)
      {
        LOWORD(v18) = (_WORD)v13 + (_WORD)v12;
        break;
      }
    }
LABEL_30:
    unsigned __int16 v24 = (_WORD)v18 - (_WORD)v13;
    if (v12 != v24) {
      goto LABEL_51;
    }
LABEL_31:
    unsigned int v15 = *v7;
    goto LABEL_32;
  }
LABEL_65:
  int v36 = *(unsigned __int16 *)(a2 + 42);
  if (*(_WORD *)(a2 + 42))
  {
    __n128 v37 = 0;
    unsigned int v38 = 0;
    LOWORD(v39) = *((_WORD *)v5 + 21);
    unsigned int v40 = *(unsigned __int16 *)(a2 + 42);
    unsigned __int16 v41 = v39;
    unsigned __int16 v42 = v39;
    do
    {
      uint64_t v44 = *(void *)(a2 + 32);
      unsigned int v45 = (unsigned __int8 *)(v44 + v38);
      uint64_t v46 = v44 + *(unsigned __int16 *)(a2 + 40) + 4 * v38;
      if (v38 < v40)
      {
        __n128 v37 = v45;
        uint64_t v3 = (unsigned __int8 *)v46;
      }
      int v47 = *(_DWORD *)v3;
      if (v42)
      {
        uint64_t v43 = (uint64_t)v5[4];
        if (*((unsigned char *)v5 + 47))
        {
          if (v42 <= 0x1Du)
          {
            uint64_t v48 = 0;
            unsigned int v49 = *v37;
            while (1)
            {
              unsigned int v50 = *(unsigned __int8 *)(v43 + v48);
              if (v50 >= v49) {
                break;
              }
              if (v42 == ++v48) {
                goto LABEL_100;
              }
            }
            if (v50 == v49) {
              LOWORD(v43) = v48;
            }
            else {
              LOWORD(v43) = v42;
            }
            goto LABEL_98;
          }
          unsigned int v49 = *v37;
          uint64_t v52 = v5[4];
          unint64_t v53 = v42;
          do
          {
            unint64_t v54 = v53 >> 1;
            __n128 v55 = &v52[v53 >> 1];
            unsigned int v57 = *v55;
            unsigned int v56 = v55 + 1;
            uint64_t result = v57;
            v53 += ~(v53 >> 1);
            if (v57 < v49) {
              uint64_t v52 = v56;
            }
            else {
              unint64_t v53 = v54;
            }
          }
          while (v53);
          if (v52 == (unsigned __int8 *)(v43 + v42) || *v52 != v49) {
            goto LABEL_100;
          }
        }
        else
        {
          uint64_t v51 = v42;
          uint64_t v52 = v5[4];
          while (*v52 != *v37)
          {
            ++v52;
            if (!--v51)
            {
              LOWORD(v52) = v43 + v42;
              break;
            }
          }
        }
        LOWORD(v43) = (_WORD)v52 - v43;
      }
      else
      {
        LOWORD(v43) = 0;
      }
LABEL_98:
      if ((unsigned __int16)v43 != v42)
      {
        uint64_t v43 = (unsigned __int16)v43;
        goto LABEL_69;
      }
      unsigned int v49 = *v37;
LABEL_100:
      if (*((unsigned char *)v5 + 46)) {
        goto LABEL_68;
      }
      if (v42)
      {
        uint64_t v58 = v5[4];
        if (*((unsigned char *)v5 + 47))
        {
          unint64_t v59 = v5[4];
          unint64_t v60 = v42;
          if (v42 >= 0x1Eu)
          {
            do
            {
              unint64_t v63 = v60 >> 1;
              long long v64 = &v59[v60 >> 1];
              unsigned int v66 = *v64;
              unint64_t v65 = v64 + 1;
              v60 += ~(v60 >> 1);
              if (v66 < v49) {
                unint64_t v59 = v65;
              }
              else {
                unint64_t v60 = v63;
              }
            }
            while (v60);
            if (v59 == &v58[v42] || *v59 != v49)
            {
LABEL_126:
              uint64_t result = geo::intern_linear_map<gss::ScenePropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v5 + 16);
              uint64_t v39 = *((unsigned __int16 *)v5 + 21);
              if (result)
              {
                size_t v70 = v5[4];
                v70[v39] = v49;
                *(_DWORD *)&v70[4 * v39 + *((unsigned __int16 *)v5 + 20)] = 0;
                LOWORD(v39) = v39 + 1;
                *((_WORD *)v5 + 21) = v39;
                *((unsigned char *)v5 + 47) = 0;
              }
              goto LABEL_67;
            }
            unsigned __int16 v67 = (_WORD)v59 - (_WORD)v58;
          }
          else
          {
            uint64_t v61 = 0;
            while (1)
            {
              unsigned int v62 = v58[v61];
              if (v62 >= v49) {
                break;
              }
              if (v42 == ++v61) {
                goto LABEL_126;
              }
            }
            if (v62 == v49) {
              unsigned __int16 v67 = v61;
            }
            else {
              unsigned __int16 v67 = v42;
            }
          }
        }
        else
        {
          uint64_t v68 = v42;
          uint64_t v69 = v5[4];
          while (*v69 != v49)
          {
            ++v69;
            if (!--v68)
            {
              LOWORD(v69) = (_WORD)v58 + v42;
              break;
            }
          }
          unsigned __int16 v67 = (_WORD)v69 - (_WORD)v58;
        }
      }
      else
      {
        unsigned __int16 v67 = 0;
      }
      if (v67 == v42) {
        goto LABEL_126;
      }
LABEL_67:
      unsigned int v40 = *(unsigned __int16 *)(a2 + 42);
      unsigned __int16 v41 = v39;
LABEL_68:
      uint64_t v43 = v41 - 1;
      unsigned __int16 v42 = v41;
LABEL_69:
      *(_DWORD *)&v5[4][4 * v43 + *((unsigned __int16 *)v5 + 20)] = v47;
      if (v38 + 1 < v40) {
        ++v38;
      }
      else {
        unsigned int v38 = v40;
      }
    }
    while (v38 != v36);
  }
  int v71 = *(unsigned __int16 *)(a2 + 58);
  if (*(_WORD *)(a2 + 58))
  {
    uint64_t v72 = 0;
    unsigned int v73 = 0;
    LOWORD(v74) = *((_WORD *)v5 + 29);
    unsigned int v75 = *(unsigned __int16 *)(a2 + 58);
    unsigned __int16 v76 = v74;
    unsigned __int16 v77 = v74;
    do
    {
      uint64_t v79 = *(void *)(a2 + 48);
      unsigned int v80 = (unsigned __int8 *)(v79 + v73);
      uint64_t v81 = v79 + *(unsigned __int16 *)(a2 + 56) + 8 * v73;
      if (v73 < v75)
      {
        uint64_t v72 = v80;
        uint64_t v3 = (unsigned __int8 *)v81;
      }
      uint64_t v82 = *(void *)v3;
      if (v77)
      {
        uint64_t v78 = (uint64_t)v5[6];
        if (*((unsigned char *)v5 + 63))
        {
          if (v77 <= 0x1Du)
          {
            uint64_t v83 = 0;
            unsigned int v84 = *v72;
            while (1)
            {
              unsigned int v85 = *(unsigned __int8 *)(v78 + v83);
              if (v85 >= v84) {
                break;
              }
              if (v77 == ++v83) {
                goto LABEL_163;
              }
            }
            if (v85 == v84) {
              LOWORD(v78) = v83;
            }
            else {
              LOWORD(v78) = v77;
            }
            goto LABEL_161;
          }
          unsigned int v84 = *v72;
          unsigned int v87 = v5[6];
          unint64_t v88 = v77;
          do
          {
            unint64_t v89 = v88 >> 1;
            uint64_t v90 = &v87[v88 >> 1];
            unsigned int v92 = *v90;
            unint64_t v91 = v90 + 1;
            uint64_t result = v92;
            v88 += ~(v88 >> 1);
            if (v92 < v84) {
              unsigned int v87 = v91;
            }
            else {
              unint64_t v88 = v89;
            }
          }
          while (v88);
          if (v87 == (unsigned __int8 *)(v78 + v77) || *v87 != v84) {
            goto LABEL_163;
          }
        }
        else
        {
          uint64_t v86 = v77;
          unsigned int v87 = v5[6];
          while (*v87 != *v72)
          {
            ++v87;
            if (!--v86)
            {
              LOWORD(v87) = v78 + v77;
              break;
            }
          }
        }
        LOWORD(v78) = (_WORD)v87 - v78;
      }
      else
      {
        LOWORD(v78) = 0;
      }
LABEL_161:
      if ((unsigned __int16)v78 != v77)
      {
        uint64_t v78 = (unsigned __int16)v78;
        goto LABEL_132;
      }
      unsigned int v84 = *v72;
LABEL_163:
      if (*((unsigned char *)v5 + 62)) {
        goto LABEL_131;
      }
      if (v77)
      {
        BOOL v93 = v5[6];
        if (*((unsigned char *)v5 + 63))
        {
          uint64_t v94 = v5[6];
          unint64_t v95 = v77;
          if (v77 >= 0x1Eu)
          {
            do
            {
              unint64_t v98 = v95 >> 1;
              long long v99 = &v94[v95 >> 1];
              unsigned int v101 = *v99;
              uint64_t v100 = v99 + 1;
              v95 += ~(v95 >> 1);
              if (v101 < v84) {
                uint64_t v94 = v100;
              }
              else {
                unint64_t v95 = v98;
              }
            }
            while (v95);
            if (v94 == &v93[v77] || *v94 != v84)
            {
LABEL_189:
              uint64_t result = geo::intern_linear_map<gss::ScenePropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v5 + 24);
              uint64_t v74 = *((unsigned __int16 *)v5 + 29);
              if (result)
              {
                unint64_t v105 = v5[6];
                v105[v74] = v84;
                *(void *)&v105[8 * v74 + *((unsigned __int16 *)v5 + 28)] = 0;
                LOWORD(v74) = v74 + 1;
                *((_WORD *)v5 + 29) = v74;
                *((unsigned char *)v5 + 63) = 0;
              }
              goto LABEL_130;
            }
            unsigned __int16 v102 = (_WORD)v94 - (_WORD)v93;
          }
          else
          {
            uint64_t v96 = 0;
            while (1)
            {
              unsigned int v97 = v93[v96];
              if (v97 >= v84) {
                break;
              }
              if (v77 == ++v96) {
                goto LABEL_189;
              }
            }
            if (v97 == v84) {
              unsigned __int16 v102 = v96;
            }
            else {
              unsigned __int16 v102 = v77;
            }
          }
        }
        else
        {
          uint64_t v103 = v77;
          uint64_t v104 = v5[6];
          while (*v104 != v84)
          {
            ++v104;
            if (!--v103)
            {
              LOWORD(v104) = (_WORD)v93 + v77;
              break;
            }
          }
          unsigned __int16 v102 = (_WORD)v104 - (_WORD)v93;
        }
      }
      else
      {
        unsigned __int16 v102 = 0;
      }
      if (v102 == v77) {
        goto LABEL_189;
      }
LABEL_130:
      unsigned int v75 = *(unsigned __int16 *)(a2 + 58);
      unsigned __int16 v76 = v74;
LABEL_131:
      uint64_t v78 = v76 - 1;
      unsigned __int16 v77 = v76;
LABEL_132:
      *(void *)&v5[6][8 * v78 + *((unsigned __int16 *)v5 + 28)] = v82;
      if (v73 + 1 < v75) {
        ++v73;
      }
      else {
        unsigned int v73 = v75;
      }
    }
    while (v73 != v71);
  }
  int v106 = *(unsigned __int16 *)(a2 + 74);
  if (*(_WORD *)(a2 + 74))
  {
    unsigned int v107 = 0;
    uint64_t v108 = 0;
    unsigned int v109 = *(unsigned __int16 *)(a2 + 74);
    while (1)
    {
      uint64_t v111 = *(void *)(a2 + 64);
      unsigned __int16 v112 = (unsigned __int8 *)(v111 + v107);
      uint64_t v113 = v111 + *(unsigned __int16 *)(a2 + 72) + 16 * v107;
      if (v107 < v109)
      {
        uint64_t v3 = (unsigned __int8 *)v113;
        uint64_t v108 = v112;
      }
      uint64_t v114 = *((unsigned __int16 *)v5 + 37);
      if (!*((_WORD *)v5 + 37)) {
        goto LABEL_220;
      }
      __n128 v115 = v5[8];
      if (!*((unsigned char *)v5 + 79)) {
        break;
      }
      if (v114 <= 0x1D)
      {
        uint64_t v116 = 0;
        unsigned int v117 = *v108;
        while (1)
        {
          unsigned int v118 = v115[v116];
          if (v118 >= v117) {
            break;
          }
          if (v114 == ++v116) {
            goto LABEL_221;
          }
        }
        if (v118 == v117) {
          unsigned __int16 v126 = v116;
        }
        else {
          unsigned __int16 v126 = *((_WORD *)v5 + 37);
        }
        if (v114 != v126)
        {
LABEL_240:
          uint64_t v110 = v126;
          goto LABEL_194;
        }
        goto LABEL_220;
      }
      unsigned int v117 = *v108;
      char v120 = v5[8];
      unint64_t v121 = *((unsigned __int16 *)v5 + 37);
      do
      {
        unint64_t v122 = v121 >> 1;
        char v123 = &v120[v121 >> 1];
        unsigned int v125 = *v123;
        long long v124 = v123 + 1;
        v121 += ~(v121 >> 1);
        if (v125 < v117) {
          char v120 = v124;
        }
        else {
          unint64_t v121 = v122;
        }
      }
      while (v121);
      if (v120 != &v115[v114] && *v120 == v117) {
        goto LABEL_219;
      }
LABEL_221:
      if (!*((unsigned char *)v5 + 78))
      {
        if (!*((_WORD *)v5 + 37)) {
          goto LABEL_252;
        }
        __n128 v127 = v5[8];
        if (*((unsigned char *)v5 + 79))
        {
          __n128 v128 = v5[8];
          unint64_t v129 = *((unsigned __int16 *)v5 + 37);
          if (v114 < 0x1E)
          {
            uint64_t v130 = 0;
            while (1)
            {
              unsigned int v131 = v127[v130];
              if (v131 >= v117) {
                break;
              }
              if (v114 == ++v130) {
                goto LABEL_252;
              }
            }
            if (v131 == v117) {
              unsigned __int16 v137 = v130;
            }
            else {
              unsigned __int16 v137 = *((_WORD *)v5 + 37);
            }
            if (v114 != v137) {
              goto LABEL_193;
            }
LABEL_252:
            uint64_t result = geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v5 + 32);
            uint64_t v138 = *((unsigned __int16 *)v5 + 37);
            LOWORD(v114) = *((_WORD *)v5 + 37);
            if (result)
            {
              uint64_t v139 = v5[8];
              v139[v138] = v117;
              uint64_t v114 = (uint64_t)&v139[16 * v138 + *((unsigned __int16 *)v5 + 36)];
              *(unsigned char *)uint64_t v114 = 0;
              *(_DWORD *)(v114 + 1) = *(_DWORD *)v159;
              *(_DWORD *)(v114 + 4) = *(_DWORD *)&v159[3];
              *(void *)(v114 + 8) = 0;
              LOWORD(v114) = *((_WORD *)v5 + 37) + 1;
              *((_WORD *)v5 + 37) = v114;
              *((unsigned char *)v5 + 79) = 0;
            }
            goto LABEL_193;
          }
          do
          {
            unint64_t v132 = v129 >> 1;
            __n128 v133 = &v128[v129 >> 1];
            unsigned int v135 = *v133;
            __n128 v134 = v133 + 1;
            v129 += ~(v129 >> 1);
            if (v135 < v117) {
              __n128 v128 = v134;
            }
            else {
              unint64_t v129 = v132;
            }
          }
          while (v129);
          if (v128 == &v127[v114] || *v128 != v117) {
            goto LABEL_252;
          }
        }
        else
        {
          uint64_t v136 = *((unsigned __int16 *)v5 + 37);
          __n128 v128 = v5[8];
          while (*v128 != v117)
          {
            ++v128;
            if (!--v136)
            {
              LOWORD(v128) = (_WORD)v127 + v114;
              break;
            }
          }
        }
        if (v114 == (unsigned __int16)((_WORD)v128 - (_WORD)v127)) {
          goto LABEL_252;
        }
      }
LABEL_193:
      uint64_t v110 = (unsigned __int16)v114 - 1;
LABEL_194:
      *(_OWORD *)&v5[8][16 * v110 + *((unsigned __int16 *)v5 + 36)] = *(_OWORD *)v3;
      unsigned int v109 = *(unsigned __int16 *)(a2 + 74);
      if (v107 + 1 < v109) {
        ++v107;
      }
      else {
        unsigned int v107 = *(unsigned __int16 *)(a2 + 74);
      }
      if (v107 == v106) {
        return result;
      }
    }
    uint64_t v119 = *((unsigned __int16 *)v5 + 37);
    char v120 = v5[8];
    while (*v120 != *v108)
    {
      ++v120;
      if (!--v119)
      {
        LOWORD(v120) = (_WORD)v115 + v114;
        break;
      }
    }
LABEL_219:
    unsigned __int16 v126 = (_WORD)v120 - (_WORD)v115;
    if (v114 != v126) {
      goto LABEL_240;
    }
LABEL_220:
    unsigned int v117 = *v108;
    goto LABEL_221;
  }
  return result;
}

uint64_t geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable(unsigned __int16 *a1)
{
  int v1 = a1[5];
  if (v1 != a1[6]) {
    return 1;
  }
  if (v1 == 0xFFFF) {
    return 0;
  }
  unsigned int v3 = 2 * (v1 & 0x7FFF);
  if (v3 <= 4) {
    int v4 = 4;
  }
  else {
    int v4 = v3;
  }
  unsigned int v5 = v4 | 1;
  uint64_t v6 = gss::Allocator::instance((gss::Allocator *)a1);
  uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v6 + 16))(v6, (unsigned __int16)((v4 | 1) + v4), 1);
  unsigned int v8 = v7;
  if (*(void *)a1)
  {
    if (a1[5])
    {
      uint64_t v7 = (char *)memmove(v7, *(const void **)a1, a1[5]);
      if (a1[5]) {
        uint64_t v7 = (char *)memmove(&v8[v5], (const void *)(*(void *)a1 + a1[4]), a1[5]);
      }
    }
    uint64_t v9 = gss::Allocator::instance((gss::Allocator *)v7);
    (*(void (**)(uint64_t, void, void))(*(void *)v9 + 40))(v9, *(void *)a1, a1[6]);
  }
  a1[6] = v4;
  *(void *)a1 = v8;
  uint64_t result = 1;
  a1[4] = v5;
  return result;
}

{
  int v1;
  unsigned int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t result;

  int v1 = a1[5];
  if (v1 != a1[6]) {
    return 1;
  }
  if (v1 == 0xFFFF) {
    return 0;
  }
  unsigned int v3 = 2 * (v1 & 0x7FFF);
  if (v3 <= 4) {
    int v4 = 4;
  }
  else {
    int v4 = v3;
  }
  unsigned int v5 = gss::Allocator::instance((gss::Allocator *)a1);
  uint64_t v6 = v4 | 1;
  uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)((v4 | 1) + v4), 1);
  unsigned int v8 = v7;
  if (*(void *)a1)
  {
    if (a1[5])
    {
      uint64_t v7 = (char *)memmove(v7, *(const void **)a1, a1[5]);
      if (a1[5]) {
        uint64_t v7 = (char *)memmove(&v8[v6], (const void *)(*(void *)a1 + a1[4]), a1[5]);
      }
    }
    uint64_t v9 = gss::Allocator::instance((gss::Allocator *)v7);
    (*(void (**)(uint64_t, void, void))(*(void *)v9 + 40))(v9, *(void *)a1, a1[6]);
  }
  a1[6] = v4;
  *(void *)a1 = v8;
  uint64_t result = 1;
  a1[4] = v6;
  return result;
}

uint64_t geo::intern_linear_map<gss::ScenePropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable(unsigned __int16 *a1)
{
  int v1 = a1[5];
  if (v1 != a1[6]) {
    return 1;
  }
  if (v1 == 0xFFFF) {
    return 0;
  }
  unsigned int v3 = 2 * (v1 & 0x7FFF);
  if (v3 <= 4) {
    __int16 v4 = 4;
  }
  else {
    __int16 v4 = v3;
  }
  unsigned __int16 v5 = (v4 & 0xFFFC) + 4;
  uint64_t v6 = gss::Allocator::instance((gss::Allocator *)a1);
  uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v6 + 16))(v6, (unsigned __int16)(v5 + 4 * v4) & 0xFFFC, 1);
  unsigned int v8 = v7;
  if (*(void *)a1)
  {
    if (a1[5])
    {
      uint64_t v7 = (char *)memmove(v7, *(const void **)a1, a1[5]);
      if (a1[5]) {
        uint64_t v7 = (char *)memmove(&v8[v5], (const void *)(*(void *)a1 + a1[4]), 4 * a1[5]);
      }
    }
    uint64_t v9 = gss::Allocator::instance((gss::Allocator *)v7);
    (*(void (**)(uint64_t, void, void))(*(void *)v9 + 40))(v9, *(void *)a1, a1[6]);
  }
  a1[6] = v4;
  *(void *)a1 = v8;
  uint64_t result = 1;
  a1[4] = v5;
  return result;
}

{
  int v1;
  unsigned int v3;
  __int16 v4;
  uint64_t v5;
  unsigned __int16 v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t result;

  int v1 = a1[5];
  if (v1 != a1[6]) {
    return 1;
  }
  if (v1 == 0xFFFF) {
    return 0;
  }
  unsigned int v3 = 2 * (v1 & 0x7FFF);
  if (v3 <= 4) {
    __int16 v4 = 4;
  }
  else {
    __int16 v4 = v3;
  }
  unsigned __int16 v5 = gss::Allocator::instance((gss::Allocator *)a1);
  uint64_t v6 = (v4 & 0xFFFC) + 4;
  uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)(v6 + 4 * v4), 1);
  unsigned int v8 = v7;
  if (*(void *)a1)
  {
    if (a1[5])
    {
      uint64_t v7 = (char *)memmove(v7, *(const void **)a1, a1[5]);
      if (a1[5]) {
        uint64_t v7 = (char *)memmove(&v8[v6], (const void *)(*(void *)a1 + a1[4]), 4 * a1[5]);
      }
    }
    uint64_t v9 = gss::Allocator::instance((gss::Allocator *)v7);
    (*(void (**)(uint64_t, void, void))(*(void *)v9 + 40))(v9, *(void *)a1, a1[6]);
  }
  a1[6] = v4;
  *(void *)a1 = v8;
  uint64_t result = 1;
  a1[4] = v6;
  return result;
}

void gss::CartoStyle<gss::PropertyID>::populateStyles(unint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = a1;
  unint64_t v4 = 0x9DDFEA08EB382D69 * (((8 * a1) + 8) ^ HIDWORD(a1));
  unint64_t v5 = 0x9DDFEA08EB382D69 * (HIDWORD(a1) ^ (v4 >> 47) ^ v4);
  uint64_t v6 = (std::mutex *)(a2
                    + ((unint64_t)((9 * ((v5 >> 47) ^ v5)) & 0x1F) << 6)
                    + 480);
  std::mutex::lock(v6);
  unsigned __int8 v8 = atomic_load((unsigned __int8 *)(v3 + 123));
  if ((v8 & 1) == 0)
  {
    if (*(void *)(v3 + 72))
    {
LABEL_109:
      atomic_store(1u, (unsigned __int8 *)(v3 + 123));
      goto LABEL_110;
    }
    unint64_t v105 = v6;
    uint64_t v9 = gss::Allocator::instance(v7);
    uint64_t v10 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v9 + 16))(v9, 72, 8);
    *(void *)uint64_t v10 = &unk_1EF58A430;
    *(void *)(v10 + 8) = 0;
    *(void *)(v10 + 16) = 0;
    *(void *)(v10 + 24) = v9;
    long long v11 = 0uLL;
    *(_OWORD *)(v10 + 48) = 0u;
    *(void *)(v10 + 64) = 0;
    *(_OWORD *)(v10 + 32) = 0u;
    uint64_t v12 = *(std::__shared_weak_count **)(v3 + 80);
    *(void *)(v3 + 72) = v10 + 32;
    *(void *)(v3 + 80) = v10;
    if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
      long long v11 = 0uLL;
    }
    long long v124 = v11;
    long long v125 = v11;
    int v126 = 1065353216;
    char v123 = 0;
    memset(v113, 0, sizeof(v113));
    char v114 = 1;
    memset(v115, 0, sizeof(v115));
    char v116 = 1;
    memset(v117, 0, sizeof(v117));
    char v118 = 1;
    memset(v119, 0, sizeof(v119));
    char v120 = 1;
    memset(v121, 0, sizeof(v121));
    char v122 = 1;
    gss::CartoStyle<gss::PropertyID>::applyStyle(v3, (unint64_t)v113, v2, -1.0);
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v113);
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v115);
    geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v117);
    geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v119);
    geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((gss::Allocator *)v121);
    std::__hash_table<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::__unordered_map_hasher<gss::StylePropertySet<gss::PropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::hash<gss::StylePropertySet<gss::PropertyID>>,std::equal_to<gss::StylePropertySet<gss::PropertyID>>,true>,std::__unordered_map_equal<gss::StylePropertySet<gss::PropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::equal_to<gss::StylePropertySet<gss::PropertyID>>,std::hash<gss::StylePropertySet<gss::PropertyID>>,true>,std::allocator<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>>>::__emplace_unique_key_args<gss::StylePropertySet<gss::PropertyID>,gss::StylePropertySet<gss::PropertyID>,unsigned char &>((uint64_t)&v124, (uint64_t)v113, (uint64_t)v113, &v123);
    char v123 = 1;
    gss::StylePropertySet<gss::PropertyID>::~StylePropertySet((uint64_t)v113);
    uint64_t v13 = 0;
    uint64_t v14 = 1;
    do
    {
      memset(v113, 0, sizeof(v113));
      char v114 = 1;
      memset(v115, 0, sizeof(v115));
      char v116 = 1;
      memset(v117, 0, sizeof(v117));
      char v118 = 1;
      memset(v119, 0, sizeof(v119));
      char v120 = 1;
      memset(v121, 0, sizeof(v121));
      char v122 = 1;
      gss::CartoStyle<gss::PropertyID>::applyStyle(v3, (unint64_t)v113, v2, (float)v13);
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v113);
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v115);
      geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v117);
      geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((uint64_t)v119);
      geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit((gss::Allocator *)v121);
      unsigned int v15 = std::__hash_table<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::__unordered_map_hasher<gss::StylePropertySet<gss::PropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::hash<gss::StylePropertySet<gss::PropertyID>>,std::equal_to<gss::StylePropertySet<gss::PropertyID>>,true>,std::__unordered_map_equal<gss::StylePropertySet<gss::PropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::equal_to<gss::StylePropertySet<gss::PropertyID>>,std::hash<gss::StylePropertySet<gss::PropertyID>>,true>,std::allocator<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>>>::__emplace_unique_key_args<gss::StylePropertySet<gss::PropertyID>,gss::StylePropertySet<gss::PropertyID>,unsigned char &>((uint64_t)&v124, (uint64_t)v113, (uint64_t)v113, &v123);
      if (v16)
      {
        uint64_t v14 = (v14 + 1);
        char v123 = v14;
      }
      *((unsigned char *)v13 + *(void *)(v3 + 72) + 16) = *((unsigned char *)v15 + 96);
      gss::StylePropertySet<gss::PropertyID>::~StylePropertySet((uint64_t)v113);
      uint64_t v13 = (gss::Allocator *)((char *)v13 + 1);
    }
    while (v13 != (gss::Allocator *)24);
    uint64_t v17 = *(void *)(v3 + 72);
    if (!*(unsigned char *)(v17 + 12))
    {
      unint64_t v18 = *(unsigned __int16 *)(v17 + 8);
      if (v18 <= v14)
      {
        if (v18 >= v14) {
          goto LABEL_23;
        }
        uint64_t v14 = v14;
        if (*(unsigned __int16 *)(v17 + 10) < v14)
        {
          geo::intern_vector<gss::StylePropertySet<gss::PropertyID>,geo::StdAllocator<gss::StylePropertySet<gss::PropertyID>,gss::Allocator>>::reallocate(*(gss::Allocator ***)(v3 + 72), v14);
          unint64_t v18 = *(unsigned __int16 *)(v17 + 8);
        }
        if (v18 != v14)
        {
          uint64_t v21 = *(void *)v17 + 80 * v14;
          uint64_t v22 = *(void *)v17 + 80 * v18;
          do
          {
            *(void *)uint64_t v22 = 0;
            *(void *)(v22 + 8) = 0;
            *(unsigned char *)(v22 + 15) = 1;
            *(void *)(v22 + 16) = 0;
            *(void *)(v22 + 23) = 0;
            *(unsigned char *)(v22 + 31) = 1;
            *(void *)(v22 + 32) = 0;
            *(void *)(v22 + 39) = 0;
            *(unsigned char *)(v22 + 47) = 1;
            *(void *)(v22 + 48) = 0;
            *(void *)(v22 + 55) = 0;
            *(unsigned char *)(v22 + 63) = 1;
            *(void *)(v22 + 64) = 0;
            *(void *)(v22 + 71) = 0;
            *(unsigned char *)(v22 + 79) = 1;
            v22 += 80;
          }
          while (v22 != v21);
        }
      }
      else
      {
        uint64_t v19 = *(void *)v17 + 80 * v14;
        uint64_t v20 = 80 * *(unsigned __int16 *)(v17 + 8) - 80 * v14;
        do
        {
          uint64_t v19 = gss::StylePropertySet<gss::PropertyID>::~StylePropertySet(v19) + 80;
          v20 -= 80;
        }
        while (v20);
        uint64_t v14 = v14;
      }
      *(_WORD *)(v17 + 8) = v14;
    }
LABEL_23:
    uint64_t v104 = v2;
    unsigned int v23 = (uint64_t *)v125;
    if ((void)v125)
    {
      uint64_t v106 = v3;
      do
      {
        unsigned __int16 v24 = *(_OWORD ***)(v3 + 72);
        unsigned int v25 = *((unsigned __int8 *)v23 + 96);
        __n128 v26 = *v24;
        geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=(&(*v24)[5 * *((unsigned __int8 *)v23 + 96)], (uint64_t)(v23 + 2));
        isSpaceAvailable = (gss::Allocator *)geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=(&v26[5 * v25 + 1], (uint64_t)(v23 + 4));
        uint64_t v28 = (uint64_t *)&v26[5 * v25];
        if (v28 == v23 + 2) {
          goto LABEL_35;
        }
        unsigned int v29 = (const void **)(v28 + 4);
        uint64_t __dst = (char *)&v26[5 * v25 + 2] + 14;
        if (!*__dst && *v29)
        {
          uint64_t v30 = gss::Allocator::instance(isSpaceAvailable);
          isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v30 + 40))(v30, *v29, WORD6(v26[5 * v25 + 2]));
        }
        long long v31 = &v26[5 * v25];
        *((unsigned char *)v31 + 47) = 1;
        *(const void **)((char *)v29 + 7) = 0;
        *unsigned int v29 = 0;
        unsigned int v107 = (char *)v31 + 47;
        if (*((unsigned char *)v23 + 62))
        {
          *unsigned int v29 = (const void *)v23[6];
          DWORD2(v26[5 * v25 + 2]) = *((_DWORD *)v23 + 14);
        }
        else
        {
          unsigned int v53 = *((unsigned __int16 *)v23 + 29);
          if (!*__dst)
          {
            unint64_t v54 = &v26[5 * v25];
            unsigned int v56 = *((unsigned __int16 *)v54 + 22);
            __n128 v55 = (_WORD *)v54 + 22;
            if (v56 < v53)
            {
              int v57 = ((2 * v53) & 0x1FFFC) + 4;
              uint64_t v14 = v57 + 4 * v53;
              uint64_t v58 = gss::Allocator::instance(isSpaceAvailable);
              isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v58 + 16))(v58, (unsigned __int16)(v57 + 4 * v53) & 0xFFFC, 1);
              uint64_t v13 = isSpaceAvailable;
              if (*v29)
              {
                unint64_t v59 = &v26[5 * v25];
                unsigned int v61 = *((unsigned __int16 *)v59 + 21);
                uint64_t v14 = (uint64_t)v59 + 42;
                uint64_t v60 = v61;
                if (v61)
                {
                  isSpaceAvailable = (gss::Allocator *)memmove(isSpaceAvailable, *v29, 2 * v60);
                  if (*(_WORD *)v14) {
                    isSpaceAvailable = (gss::Allocator *)memmove((char *)v13 + (unsigned __int16)v57, (char *)*v29 + WORD4(v26[5 * v25 + 2]), 4 * *(unsigned __int16 *)v14);
                  }
                }
                uint64_t v62 = gss::Allocator::instance(isSpaceAvailable);
                isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v62 + 40))(v62, *v29, (unsigned __int16)*v55);
              }
              *__n128 v55 = v53;
              *unsigned int v29 = v13;
              WORD4(v26[5 * v25 + 2]) = v57;
              unsigned int v53 = *((unsigned __int16 *)v23 + 29);
              if (!*((_WORD *)v23 + 29)) {
                goto LABEL_34;
              }
LABEL_75:
              unsigned int v73 = 0;
              uint64_t v74 = 0;
              unsigned int v75 = &v26[5 * v25];
              uint64_t v13 = (gss::Allocator *)((char *)v75 + 42);
              unsigned __int16 v76 = (unsigned __int16 *)v75 + 20;
              do
              {
                isSpaceAvailable = (gss::Allocator *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v29);
                if (!isSpaceAvailable) {
                  break;
                }
                if (v73 < *((unsigned __int16 *)v23 + 29))
                {
                  uint64_t v79 = v23[6];
                  uint64_t v74 = (_WORD *)(v79 + 2 * v73);
                  uint64_t v14 = v79 + *((unsigned __int16 *)v23 + 28) + 4 * v73;
                }
                uint64_t v77 = *(unsigned __int16 *)v13;
                uint64_t v78 = (char *)*v29;
                *((_WORD *)*v29 + v77) = *v74;
                *(_DWORD *)&v78[4 * v77 + *v76] = *(_DWORD *)v14;
                *(_WORD *)uint64_t v13 = v77 + 1;
                if (v73 + 1 < *((unsigned __int16 *)v23 + 29)) {
                  ++v73;
                }
                else {
                  unsigned int v73 = *((unsigned __int16 *)v23 + 29);
                }
              }
              while (v73 != v53);
              goto LABEL_34;
            }
          }
          if (*((_WORD *)v23 + 29)) {
            goto LABEL_75;
          }
        }
LABEL_34:
        *uint64_t __dst = *((unsigned char *)v23 + 62);
        *unsigned int v107 = *((unsigned char *)v23 + 63);
LABEL_35:
        long long v32 = (uint64_t *)&v26[5 * v25];
        if (v32 == v23 + 2) {
          goto LABEL_42;
        }
        unsigned int v33 = (const void **)(v32 + 6);
        uint64_t v111 = (char *)&v26[5 * v25 + 3] + 14;
        if (!*v111 && *v33)
        {
          uint64_t v34 = gss::Allocator::instance(isSpaceAvailable);
          isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v34 + 40))(v34, *v33, WORD6(v26[5 * v25 + 3]));
        }
        unsigned __int16 v35 = &v26[5 * v25];
        *((unsigned char *)v35 + 63) = 1;
        *(const void **)((char *)v33 + 7) = 0;
        __n128 *v33 = 0;
        __dsta = (char *)v35 + 63;
        if (*((unsigned char *)v23 + 78))
        {
          __n128 *v33 = (const void *)v23[8];
          DWORD2(v26[5 * v25 + 3]) = *((_DWORD *)v23 + 18);
        }
        else
        {
          unsigned int v63 = *((unsigned __int16 *)v23 + 37);
          if (!*v111)
          {
            long long v64 = &v26[5 * v25];
            unsigned int v66 = *((unsigned __int16 *)v64 + 30);
            unint64_t v65 = (_WORD *)v64 + 30;
            if (v66 < v63)
            {
              int v67 = ((2 * v63) & 0x1FFF8) + 8;
              uint64_t v14 = v67 + 8 * v63;
              uint64_t v68 = gss::Allocator::instance(isSpaceAvailable);
              isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v68 + 16))(v68, (unsigned __int16)(v67 + 8 * v63) & 0xFFF8, 1);
              uint64_t v13 = isSpaceAvailable;
              if (*v33)
              {
                uint64_t v69 = &v26[5 * v25];
                unsigned int v71 = *((unsigned __int16 *)v69 + 29);
                uint64_t v14 = (uint64_t)v69 + 58;
                uint64_t v70 = v71;
                if (v71)
                {
                  isSpaceAvailable = (gss::Allocator *)memmove(isSpaceAvailable, *v33, 2 * v70);
                  if (*(_WORD *)v14) {
                    isSpaceAvailable = (gss::Allocator *)memmove((char *)v13 + (unsigned __int16)v67, (char *)*v33 + WORD4(v26[5 * v25 + 3]), 8 * *(unsigned __int16 *)v14);
                  }
                }
                uint64_t v72 = gss::Allocator::instance(isSpaceAvailable);
                isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v72 + 40))(v72, *v33, (unsigned __int16)*v65);
              }
              *unint64_t v65 = v63;
              __n128 *v33 = v13;
              WORD4(v26[5 * v25 + 3]) = v67;
              unsigned int v63 = *((unsigned __int16 *)v23 + 37);
              if (!*((_WORD *)v23 + 37)) {
                goto LABEL_41;
              }
LABEL_84:
              unsigned int v80 = 0;
              uint64_t v81 = 0;
              uint64_t v82 = &v26[5 * v25];
              uint64_t v83 = (_WORD *)v82 + 29;
              uint64_t v14 = (uint64_t)v82 + 56;
              do
              {
                isSpaceAvailable = (gss::Allocator *)geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v33);
                if (!isSpaceAvailable) {
                  break;
                }
                if (v80 < *((unsigned __int16 *)v23 + 37))
                {
                  uint64_t v86 = v23[8];
                  uint64_t v81 = (_WORD *)(v86 + 2 * v80);
                  uint64_t v13 = (gss::Allocator *)(v86 + *((unsigned __int16 *)v23 + 36) + 8 * v80);
                }
                uint64_t v84 = (unsigned __int16)*v83;
                unsigned int v85 = (char *)*v33;
                *((_WORD *)*v33 + v84) = *v81;
                *(void *)&v85[8 * v84 + *(unsigned __int16 *)v14] = *(void *)v13;
                *uint64_t v83 = v84 + 1;
                if (v80 + 1 < *((unsigned __int16 *)v23 + 37)) {
                  ++v80;
                }
                else {
                  unsigned int v80 = *((unsigned __int16 *)v23 + 37);
                }
              }
              while (v80 != v63);
              goto LABEL_41;
            }
          }
          if (*((_WORD *)v23 + 37)) {
            goto LABEL_84;
          }
        }
LABEL_41:
        *uint64_t v111 = *((unsigned char *)v23 + 78);
        unsigned char *__dsta = *((unsigned char *)v23 + 79);
LABEL_42:
        int v36 = (uint64_t *)&v26[5 * v25];
        if (v36 == v23 + 2) {
          goto LABEL_27;
        }
        __n128 v37 = (const void **)(v36 + 8);
        unsigned int v38 = &v26[5 * v25];
        int v39 = *((unsigned __int8 *)v38 + 78);
        uint64_t v14 = (uint64_t)v38 + 78;
        if (!v39 && *v37)
        {
          uint64_t v40 = gss::Allocator::instance(isSpaceAvailable);
          isSpaceAvailable = (gss::Allocator *)(*(uint64_t (**)(uint64_t, const void *, void))(*(void *)v40 + 40))(v40, *v37, WORD6(v26[5 * v25 + 4]));
        }
        unsigned __int16 v41 = &v26[5 * v25];
        *((unsigned char *)v41 + 79) = 1;
        uint64_t v13 = (gss::Allocator *)((char *)v41 + 79);
        *(const void **)((char *)v37 + 7) = 0;
        unsigned __int8 *v37 = 0;
        if (*((unsigned char *)v23 + 94))
        {
          unsigned __int8 *v37 = (const void *)v23[10];
          DWORD2(v26[5 * v25 + 4]) = *((_DWORD *)v23 + 22);
        }
        else
        {
          unsigned int v42 = *((unsigned __int16 *)v23 + 45);
          if (!*(unsigned char *)v14)
          {
            uint64_t v43 = &v26[5 * v25];
            unsigned int v45 = *((unsigned __int16 *)v43 + 38);
            uint64_t v44 = (_WORD *)v43 + 38;
            if (v45 < v42)
            {
              unsigned __int16 v112 = ((2 * v42) & 0xFFF8) + 8;
              uint64_t v46 = gss::Allocator::instance(isSpaceAvailable);
              int v47 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v46 + 16))(v46, (unsigned __int16)(v112 + 16 * v42) & 0xFFF8, 1);
              if (*v37)
              {
                __dstb = v47;
                uint64_t v48 = &v26[5 * v25];
                unsigned int v51 = *((unsigned __int16 *)v48 + 37);
                unsigned int v50 = (_WORD *)v48 + 37;
                uint64_t v49 = v51;
                if (v51)
                {
                  int v47 = (char *)memmove(v47, *v37, 2 * v49);
                  if (*v50) {
                    int v47 = (char *)memmove(&__dstb[v112], (char *)*v37 + WORD4(v26[5 * v25 + 4]), 16 * (unsigned __int16)*v50);
                  }
                }
                uint64_t v52 = gss::Allocator::instance((gss::Allocator *)v47);
                (*(void (**)(uint64_t, const void *, void))(*(void *)v52 + 40))(v52, *v37, (unsigned __int16)*v44);
                int v47 = __dstb;
              }
              *uint64_t v44 = v42;
              unsigned __int8 *v37 = v47;
              WORD4(v26[5 * v25 + 4]) = v112;
              unsigned int v42 = *((unsigned __int16 *)v23 + 45);
              if (!*((_WORD *)v23 + 45)) {
                goto LABEL_26;
              }
LABEL_93:
              unsigned int v87 = 0;
              unint64_t v88 = 0;
              unint64_t v89 = &v26[5 * v25];
              uint64_t v90 = (_WORD *)v89 + 37;
              unint64_t v91 = (unsigned __int16 *)v89 + 36;
              do
              {
                if (!geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v37)) {
                  break;
                }
                if (v87 < *((unsigned __int16 *)v23 + 45))
                {
                  uint64_t v94 = v23[10];
                  unint64_t v88 = (_WORD *)(v94 + 2 * v87);
                  __n128 v26 = (_OWORD *)(v94 + *((unsigned __int16 *)v23 + 44) + 16 * v87);
                }
                uint64_t v92 = (unsigned __int16)*v90;
                BOOL v93 = (char *)*v37;
                *((_WORD *)*v37 + v92) = *v88;
                *(_OWORD *)&v93[16 * v92 + *v91] = *v26;
                ++*v90;
                if (v87 + 1 < *((unsigned __int16 *)v23 + 45)) {
                  ++v87;
                }
                else {
                  unsigned int v87 = *((unsigned __int16 *)v23 + 45);
                }
              }
              while (v87 != v42);
              goto LABEL_26;
            }
          }
          if (*((_WORD *)v23 + 45)) {
            goto LABEL_93;
          }
        }
LABEL_26:
        *(unsigned char *)uint64_t v14 = *((unsigned char *)v23 + 94);
        *(unsigned char *)uint64_t v13 = *((unsigned char *)v23 + 95);
LABEL_27:
        unsigned int v23 = (uint64_t *)*v23;
        uint64_t v3 = v106;
      }
      while (v23);
    }
    uint64_t v2 = v104;
    std::mutex::lock((std::mutex *)(v104 + 168));
    uint64_t v95 = *(void *)(v3 + 72);
    if (*(_WORD *)(v95 + 8))
    {
      uint64_t v96 = *(void *)v95;
      uint64_t v97 = 80 * *(unsigned __int16 *)(v95 + 8);
      do
      {
        gss::StylePropertySet<gss::PropertyID>::intern(v96, v104 + 232);
        v96 += 80;
        v97 -= 80;
      }
      while (v97);
    }
    std::mutex::unlock((std::mutex *)(v104 + 168));
    unint64_t v98 = (void *)v125;
    if ((void)v125)
    {
      do
      {
        long long v99 = (void *)*v98;
        gss::StylePropertySet<gss::PropertyID>::~StylePropertySet((uint64_t)(v98 + 2));
        operator delete(v98);
        unint64_t v98 = v99;
      }
      while (v99);
    }
    uint64_t v100 = (void *)v124;
    *(void *)&long long v124 = 0;
    if (v100) {
      operator delete(v100);
    }
    uint64_t v6 = v105;
    goto LABEL_109;
  }
LABEL_110:
  std::mutex::unlock(v6);
  if (*(_WORD *)(v3 + 64))
  {
    unsigned int v101 = *(uint64_t **)(v3 + 56);
    uint64_t v102 = 16 * *(unsigned __int16 *)(v3 + 64);
    do
    {
      uint64_t v103 = *v101;
      v101 += 2;
      gss::CartoStyle<gss::PropertyID>::populateStyles(v103, v2);
      v102 -= 16;
    }
    while (v102);
  }
  atomic_store(1u, (unsigned __int8 *)(v3 + 122));
}

void sub_1A17D601C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, std::mutex *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  std::unordered_map<gss::StylePropertySet<gss::PropertyID>,unsigned char>::~unordered_map[abi:nn180100](v16 - 128);
  std::mutex::unlock(a11);
  _Unwind_Resume(a1);
}

uint64_t geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit(uint64_t result)
{
  if (!*(unsigned char *)(result + 14))
  {
    uint64_t v1 = result;
    int v2 = *(unsigned __int16 *)(result + 10);
    int v3 = *(unsigned __int8 *)(result + 15);
    if (v2 != *(unsigned __int16 *)(result + 12) || !*(unsigned char *)(result + 15))
    {
      unsigned __int16 v4 = (2 * v2) | 1;
      uint64_t v5 = gss::Allocator::instance((gss::Allocator *)result);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)(v4 + v2), 1);
      uint64_t v6 = result;
      if (*(void *)v1)
      {
        geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(v1, (_WORD *)result, (unsigned char *)(result + v4), v3 == 0);
        uint64_t v8 = gss::Allocator::instance(v7);
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v8 + 40))(v8, *(void *)v1, *(unsigned __int16 *)(v1 + 12));
      }
      *(_WORD *)(v1 + 12) = v2;
      *(void *)uint64_t v1 = v6;
      *(_WORD *)(v1 + 8) = v4;
    }
  }
  return result;
}

uint64_t gss::StylePropertySet<gss::PropertyID>::~StylePropertySet(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!*(unsigned char *)(a1 + 78) && *(void *)(a1 + 64))
  {
    uint64_t v2 = gss::Allocator::instance((gss::Allocator *)a1);
    a1 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v2 + 40))(v2, *(void *)(v1 + 64), *(unsigned __int16 *)(v1 + 76));
    *(void *)(v1 + 64) = 0;
  }
  if (!*(unsigned char *)(v1 + 62) && *(void *)(v1 + 48))
  {
    uint64_t v3 = gss::Allocator::instance((gss::Allocator *)a1);
    a1 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v3 + 40))(v3, *(void *)(v1 + 48), *(unsigned __int16 *)(v1 + 60));
    *(void *)(v1 + 48) = 0;
  }
  if (!*(unsigned char *)(v1 + 46) && *(void *)(v1 + 32))
  {
    uint64_t v4 = gss::Allocator::instance((gss::Allocator *)a1);
    a1 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v4 + 40))(v4, *(void *)(v1 + 32), *(unsigned __int16 *)(v1 + 44));
    *(void *)(v1 + 32) = 0;
  }
  if (!*(unsigned char *)(v1 + 30) && *(void *)(v1 + 16))
  {
    uint64_t v5 = gss::Allocator::instance((gss::Allocator *)a1);
    a1 = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v5 + 40))(v5, *(void *)(v1 + 16), *(unsigned __int16 *)(v1 + 28));
    *(void *)(v1 + 16) = 0;
  }
  if (!*(unsigned char *)(v1 + 14) && *(void *)v1)
  {
    uint64_t v6 = gss::Allocator::instance((gss::Allocator *)a1);
    (*(void (**)(uint64_t, void, void))(*(void *)v6 + 40))(v6, *(void *)v1, *(unsigned __int16 *)(v1 + 12));
    *(void *)uint64_t v1 = 0;
  }
  return v1;
}

unsigned __int16 *std::__hash_table<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::__unordered_map_hasher<gss::StylePropertySet<gss::PropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::hash<gss::StylePropertySet<gss::PropertyID>>,std::equal_to<gss::StylePropertySet<gss::PropertyID>>,true>,std::__unordered_map_equal<gss::StylePropertySet<gss::PropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,std::equal_to<gss::StylePropertySet<gss::PropertyID>>,std::hash<gss::StylePropertySet<gss::PropertyID>>,true>,std::allocator<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>>>::__emplace_unique_key_args<gss::StylePropertySet<gss::PropertyID>,gss::StylePropertySet<gss::PropertyID>,unsigned char &>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v9 = *(unsigned __int16 *)(a2 + 10);
  if (!*(_WORD *)(a2 + 10))
  {
    unint64_t v10 = 0;
    unsigned int v14 = *(unsigned __int16 *)(a2 + 26);
    if (!*(_WORD *)(a2 + 26)) {
      goto LABEL_19;
    }
    goto LABEL_12;
  }
  unint64_t v10 = 0;
  long long v11 = 0;
  unsigned int v12 = 0;
  do
  {
    if (v12 < v9) {
      long long v11 = (unsigned __int16 *)(*(void *)a2 + 2 * v12);
    }
    uint64_t v4 = (void *)((v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2));
    v10 ^= (unint64_t)v4 + *v11;
    unsigned int v13 = v12 + 1;
    if (v12 + 1 < v9) {
      ++v12;
    }
    else {
      unsigned int v12 = *(unsigned __int16 *)(a2 + 10);
    }
  }
  while (v13 < v9);
  unsigned int v14 = *(unsigned __int16 *)(a2 + 26);
  if (*(_WORD *)(a2 + 26))
  {
LABEL_12:
    unsigned int v15 = 0;
    unsigned int v16 = 0;
    uint64_t v17 = *(void *)(a2 + 16);
    do
    {
      if (v16 < v14)
      {
        unsigned int v15 = (unsigned __int16 *)(v17 + 2 * v16);
        uint64_t v4 = (void *)(v17 + *(unsigned __int16 *)(a2 + 24) + v16);
      }
      unint64_t v18 = ((v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + *v15) ^ v10;
      unint64_t v10 = (*(unsigned __int8 *)v4 - 0x61C8864680B583EBLL + (v18 << 6) + (v18 >> 2)) ^ v18;
      unsigned int v19 = v16 + 1;
      if (v16 + 1 < v14) {
        ++v16;
      }
      else {
        unsigned int v16 = v14;
      }
    }
    while (v19 < v14);
  }
LABEL_19:
  unsigned int v20 = *(unsigned __int16 *)(a2 + 42);
  if (*(_WORD *)(a2 + 42))
  {
    uint64_t v21 = 0;
    unsigned int v22 = 0;
    uint64_t v23 = *(void *)(a2 + 32);
    do
    {
      if (v22 < v20)
      {
        uint64_t v21 = (unsigned __int16 *)(v23 + 2 * v22);
        uint64_t v4 = (void *)(v23 + *(unsigned __int16 *)(a2 + 40) + 4 * v22);
      }
      unint64_t v24 = ((v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + *v21) ^ v10;
      unint64_t v10 = (*(unsigned int *)v4 - 0x61C8864680B583EBLL + (v24 << 6) + (v24 >> 2)) ^ v24;
      unsigned int v25 = v22 + 1;
      if (v22 + 1 < v20) {
        ++v22;
      }
      else {
        unsigned int v22 = *(unsigned __int16 *)(a2 + 42);
      }
    }
    while (v25 < v20);
  }
  unsigned int v26 = *(unsigned __int16 *)(a2 + 58);
  if (*(_WORD *)(a2 + 58))
  {
    unint64_t v27 = 0;
    unsigned int v28 = 0;
    uint64_t v29 = *(void *)(a2 + 48);
    do
    {
      if (v28 < v26)
      {
        unint64_t v27 = (unsigned __int16 *)(v29 + 2 * v28);
        uint64_t v4 = (void *)(v29 + *(unsigned __int16 *)(a2 + 56) + 8 * v28);
      }
      unint64_t v30 = ((v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + *v27) ^ v10;
      unint64_t v10 = (*v4 - 0x61C8864680B583EBLL + (v30 << 6) + (v30 >> 2)) ^ v30;
      unsigned int v31 = v28 + 1;
      if (v28 + 1 < v26) {
        ++v28;
      }
      else {
        unsigned int v28 = *(unsigned __int16 *)(a2 + 58);
      }
    }
    while (v31 < v26);
  }
  unsigned int v32 = *(unsigned __int16 *)(a2 + 74);
  if (*(_WORD *)(a2 + 74))
  {
    LODWORD(v6) = 0;
    unsigned int v33 = 0;
    uint64_t v34 = *(void *)(a2 + 64);
    uint64_t v35 = v34 + *(unsigned __int16 *)(a2 + 72);
    do
    {
      if (v6 < v32)
      {
        uint64_t v5 = (unsigned __int8 *)(v35 + 16 * v6);
        unsigned int v33 = (unsigned __int16 *)(v34 + 2 * v6);
      }
      v10 ^= (v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + *v33;
      int v38 = *v5;
      if (v38 == 2)
      {
        uint64_t v43 = *((void *)v5 + 1);
        float v44 = *(float *)(v43 + 32);
        unint64_t v45 = (LODWORD(v44) - 0x61C8864680B57FA7) ^ 0x11;
        if (v44 == 0.0) {
          unint64_t v45 = 0x9E3779B97F4A8048;
        }
        uint64_t v46 = *(float **)v43;
        for (unint64_t i = *(float **)(v43 + 8); v46 != i; v45 ^= (v45 >> 2) + (v45 << 6) + v49)
        {
          float v48 = *v46++;
          uint64_t v49 = LODWORD(v48) - 0x61C8864680B583EBLL;
          if (v48 == 0.0) {
            uint64_t v49 = 0x9E3779B97F4A7C15;
          }
        }
        unint64_t v36 = (v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + v45;
      }
      else
      {
        if (v38 != 1) {
          goto LABEL_39;
        }
        uint64_t v39 = *((void *)v5 + 1);
        int v40 = *(char *)(v39 + 23);
        if (v40 >= 0) {
          unsigned __int16 v41 = (uint64_t *)*((void *)v5 + 1);
        }
        else {
          unsigned __int16 v41 = *(uint64_t **)v39;
        }
        if (v40 >= 0) {
          unint64_t v42 = *(unsigned __int8 *)(v39 + 23);
        }
        else {
          unint64_t v42 = *(void *)(v39 + 8);
        }
        unint64_t v36 = (v10 << 6)
            - 0x61C8864680B583EBLL
            + (v10 >> 2)
            + std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v41, v42);
      }
      v10 ^= v36;
LABEL_39:
      unsigned int v37 = v6 + 1;
      if ((int)v6 + 1 < v32) {
        unint64_t v6 = (v6 + 1);
      }
      else {
        unint64_t v6 = v32;
      }
    }
    while (v37 < v32);
  }
  unint64_t v50 = *(void *)(a1 + 8);
  if (v50)
  {
    uint8x8_t v51 = (uint8x8_t)vcnt_s8((int8x8_t)v50);
    v51.i16[0] = vaddlv_u8(v51);
    if (v51.u32[0] > 1uLL)
    {
      unint64_t v6 = v10;
      if (v10 >= v50) {
        unint64_t v6 = v10 % v50;
      }
    }
    else
    {
      unint64_t v6 = (v50 - 1) & v10;
    }
    uint64_t v52 = *(unsigned __int16 ***)(*(void *)a1 + 8 * v6);
    if (v52)
    {
      unsigned int v53 = *v52;
      if (*v52)
      {
        if (v51.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v55 = *((void *)v53 + 1);
            if (v55 == v10)
            {
              if (gss::StylePropertySet<gss::PropertyID>::operator==((unsigned __int16 **)v53 + 2, (unsigned __int16 **)a2))return v53; {
            }
              }
            else if ((v55 & (v50 - 1)) != v6)
            {
              goto LABEL_83;
            }
            unsigned int v53 = *(unsigned __int16 **)v53;
            if (!v53) {
              goto LABEL_83;
            }
          }
        }
        do
        {
          unint64_t v54 = *((void *)v53 + 1);
          if (v54 == v10)
          {
            if (gss::StylePropertySet<gss::PropertyID>::operator==((unsigned __int16 **)v53 + 2, (unsigned __int16 **)a2))return v53; {
          }
            }
          else
          {
            if (v54 >= v50) {
              v54 %= v50;
            }
            if (v54 != v6) {
              break;
            }
          }
          unsigned int v53 = *(unsigned __int16 **)v53;
        }
        while (v53);
      }
    }
  }
LABEL_83:
  unsigned int v56 = (void *)(a1 + 16);
  uint64_t v90 = operator new(0x68uLL);
  *uint64_t v90 = 0;
  v90[1] = v10;
  uint64_t v57 = *(void *)(a3 + 8);
  v90[2] = *(void *)a3;
  *((_DWORD *)v90 + 6) = v57;
  *((_WORD *)v90 + 14) = WORD2(v57);
  *((_WORD *)v90 + 15) = *(_WORD *)(a3 + 14);
  *(void *)(a3 + 7) = 0;
  *(void *)a3 = 0;
  uint64_t v58 = *(void *)(a3 + 24);
  v90[4] = *(void *)(a3 + 16);
  *((_DWORD *)v90 + 10) = v58;
  *((_WORD *)v90 + 22) = WORD2(v58);
  *((_WORD *)v90 + 23) = *(_WORD *)(a3 + 30);
  uint64_t v59 = *(void *)(a3 + 40);
  v90[6] = *(void *)(a3 + 32);
  *((_DWORD *)v90 + 14) = v59;
  *((_WORD *)v90 + 30) = WORD2(v59);
  *((_WORD *)v90 + 31) = *(_WORD *)(a3 + 46);
  uint64_t v60 = *(void *)(a3 + 56);
  v90[8] = *(void *)(a3 + 48);
  *((_DWORD *)v90 + 18) = v60;
  *((_WORD *)v90 + 38) = WORD2(v60);
  *((unsigned char *)v90 + 78) = *(unsigned char *)(a3 + 62);
  *((unsigned char *)v90 + 79) = *(unsigned char *)(a3 + 63);
  uint64_t v61 = *(void *)(a3 + 72);
  v90[10] = *(void *)(a3 + 64);
  *(unsigned char *)(a3 + 15) = 1;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 23) = 0;
  *(unsigned char *)(a3 + 31) = 1;
  *(void *)(a3 + 39) = 0;
  *(void *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 47) = 1;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 55) = 0;
  *(unsigned char *)(a3 + 63) = 1;
  *((_DWORD *)v90 + 22) = v61;
  *((_WORD *)v90 + 46) = WORD2(v61);
  *((unsigned char *)v90 + 94) = *(unsigned char *)(a3 + 78);
  *((unsigned char *)v90 + 95) = *(unsigned char *)(a3 + 79);
  *(void *)(a3 + 64) = 0;
  *(void *)(a3 + 71) = 0;
  *(unsigned char *)(a3 + 79) = 1;
  *((unsigned char *)v90 + 96) = *a4;
  float v62 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v63 = *(float *)(a1 + 32);
  if (!v50 || (float)(v63 * (float)v50) < v62)
  {
    BOOL v64 = v50 < 3 || (v50 & (v50 - 1)) != 0;
    unint64_t v65 = v64 | (2 * v50);
    unint64_t v66 = vcvtps_u32_f32(v62 / v63);
    if (v65 <= v66) {
      size_t prime = v66;
    }
    else {
      size_t prime = v65;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v50 = *(void *)(a1 + 8);
    if (prime <= v50)
    {
      if (prime >= v50) {
        goto LABEL_121;
      }
      unint64_t v78 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v50 < 3 || (uint8x8_t v79 = (uint8x8_t)vcnt_s8((int8x8_t)v50), v79.i16[0] = vaddlv_u8(v79), v79.u32[0] > 1uLL))
      {
        unint64_t v78 = std::__next_prime(v78);
      }
      else
      {
        uint64_t v80 = 1 << -(char)__clz(v78 - 1);
        if (v78 >= 2) {
          unint64_t v78 = v80;
        }
      }
      if (prime <= v78) {
        size_t prime = v78;
      }
      if (prime >= v50)
      {
        unint64_t v50 = *(void *)(a1 + 8);
LABEL_121:
        if ((v50 & (v50 - 1)) != 0)
        {
          if (v10 >= v50) {
            unint64_t v6 = v10 % v50;
          }
          else {
            unint64_t v6 = v10;
          }
        }
        else
        {
          unint64_t v6 = (v50 - 1) & v10;
        }
        goto LABEL_134;
      }
      if (!prime)
      {
        unsigned int v87 = *(void **)a1;
        *(void *)a1 = 0;
        if (v87) {
          operator delete(v87);
        }
        unint64_t v50 = 0;
        *(void *)(a1 + 8) = 0;
        goto LABEL_121;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v68 = operator new(8 * prime);
    uint64_t v69 = *(void **)a1;
    *(void *)a1 = v68;
    if (v69) {
      operator delete(v69);
    }
    uint64_t v70 = 0;
    *(void *)(a1 + 8) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v70++) = 0;
    while (prime != v70);
    unsigned int v71 = (void *)*v56;
    if (!*v56)
    {
LABEL_120:
      unint64_t v50 = prime;
      goto LABEL_121;
    }
    size_t v72 = v71[1];
    size_t v73 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v74 = v72 & v73;
      *(void *)(*(void *)a1 + 8 * v74) = v56;
      for (j = (void *)*v71; *v71; j = (void *)*v71)
      {
        size_t v76 = j[1] & v73;
        if (v76 == v74)
        {
          unsigned int v71 = j;
        }
        else if (*(void *)(*(void *)a1 + 8 * v76))
        {
          void *v71 = *j;
          uint64_t v77 = 8 * v76;
          void *j = **(void **)(*(void *)a1 + v77);
          **(void **)(*(void *)a1 + v77) = j;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v76) = v71;
          unsigned int v71 = j;
          size_t v74 = v76;
        }
      }
      goto LABEL_120;
    }
    if (v72 >= prime) {
      v72 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v72) = v56;
    uint64_t v81 = (void *)*v71;
    if (!*v71) {
      goto LABEL_120;
    }
    while (1)
    {
      size_t v83 = v81[1];
      if (v83 >= prime) {
        v83 %= prime;
      }
      if (v83 != v72)
      {
        if (!*(void *)(*(void *)a1 + 8 * v83))
        {
          *(void *)(*(void *)a1 + 8 * v83) = v71;
          goto LABEL_125;
        }
        void *v71 = *v81;
        uint64_t v82 = 8 * v83;
        void *v81 = **(void **)(*(void *)a1 + v82);
        **(void **)(*(void *)a1 + v82) = v81;
        uint64_t v81 = v71;
      }
      size_t v83 = v72;
LABEL_125:
      unsigned int v71 = v81;
      uint64_t v81 = (void *)*v81;
      size_t v72 = v83;
      if (!v81) {
        goto LABEL_120;
      }
    }
  }
LABEL_134:
  uint64_t v84 = *(void **)(*(void *)a1 + 8 * v6);
  unsigned int v53 = (unsigned __int16 *)v90;
  if (v84)
  {
    *uint64_t v90 = *v84;
LABEL_142:
    *uint64_t v84 = v90;
    goto LABEL_143;
  }
  *uint64_t v90 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v90;
  *(void *)(*(void *)a1 + 8 * v6) = v56;
  if (*v90)
  {
    unint64_t v85 = *(void *)(*v90 + 8);
    if ((v50 & (v50 - 1)) != 0)
    {
      if (v85 >= v50) {
        v85 %= v50;
      }
    }
    else
    {
      v85 &= v50 - 1;
    }
    uint64_t v84 = (void *)(*(void *)a1 + 8 * v85);
    goto LABEL_142;
  }
LABEL_143:
  ++*(void *)(a1 + 24);
  return v53;
}

void sub_1A17D6B28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit(uint64_t result)
{
  if (!*(unsigned char *)(result + 14))
  {
    uint64_t v1 = result;
    int v2 = *(unsigned __int16 *)(result + 10);
    int v3 = *(unsigned __int8 *)(result + 15);
    if (v2 != *(unsigned __int16 *)(result + 12) || !*(unsigned char *)(result + 15))
    {
      unsigned __int16 v4 = ((2 * v2) & 0xFFF8) + 8;
      uint64_t v5 = gss::Allocator::instance((gss::Allocator *)result);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)(v4 + 8 * v2) & 0xFFF8, 1);
      uint64_t v6 = result;
      if (*(void *)v1)
      {
        geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(v1, (_WORD *)result, (void *)(result + v4), v3 == 0);
        uint64_t v8 = gss::Allocator::instance(v7);
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v8 + 40))(v8, *(void *)v1, *(unsigned __int16 *)(v1 + 12));
      }
      *(_WORD *)(v1 + 12) = v2;
      *(void *)uint64_t v1 = v6;
      *(_WORD *)(v1 + 8) = v4;
    }
  }
  return result;
}

uint64_t geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit(uint64_t result)
{
  if (!*(unsigned char *)(result + 14))
  {
    uint64_t v1 = result;
    int v2 = *(unsigned __int16 *)(result + 10);
    int v3 = *(unsigned __int8 *)(result + 15);
    if (v2 != *(unsigned __int16 *)(result + 12) || !*(unsigned char *)(result + 15))
    {
      unsigned __int16 v4 = ((2 * v2) & 0xFFFC) + 4;
      uint64_t v5 = gss::Allocator::instance((gss::Allocator *)result);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)(v4 + 4 * v2) & 0xFFFC, 1);
      uint64_t v6 = result;
      if (*(void *)v1)
      {
        geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(v1, (_WORD *)result, (_DWORD *)(result + v4), v3 == 0);
        uint64_t v8 = gss::Allocator::instance(v7);
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v8 + 40))(v8, *(void *)v1, *(unsigned __int16 *)(v1 + 12));
      }
      *(_WORD *)(v1 + 12) = v2;
      *(void *)uint64_t v1 = v6;
      *(_WORD *)(v1 + 8) = v4;
    }
  }
  return result;
}

gss::Allocator *geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit(gss::Allocator *result)
{
  if (!*((unsigned char *)result + 14))
  {
    uint64_t v1 = result;
    int v2 = *((unsigned __int16 *)result + 5);
    int v3 = *((unsigned __int8 *)result + 15);
    if (v2 != *((unsigned __int16 *)result + 6) || !*((unsigned char *)result + 15))
    {
      unsigned __int16 v4 = ((2 * v2) & 0xFFF8) + 8;
      uint64_t v5 = gss::Allocator::instance(result);
      uint64_t result = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)(v4 + 16 * v2) & 0xFFF8, 1);
      uint64_t v6 = result;
      if (!*(void *)v1)
      {
LABEL_21:
        *((_WORD *)v1 + 6) = v2;
        *(void *)uint64_t v1 = v6;
        *((_WORD *)v1 + 4) = v4;
        return result;
      }
      unint64_t v7 = *((unsigned __int16 *)v1 + 5);
      if (!*((_WORD *)v1 + 5))
      {
LABEL_20:
        uint64_t v22 = gss::Allocator::instance(result);
        uint64_t result = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v22 + 40))(v22, *(void *)v1, *((unsigned __int16 *)v1 + 6));
        goto LABEL_21;
      }
      uint64_t v8 = (_OWORD *)((char *)result + v4);
      if (v3)
      {
        uint64_t result = (gss::Allocator *)memmove(result, *(const void **)v1, 2 * v7);
        if (*((_WORD *)v1 + 5)) {
          uint64_t result = (gss::Allocator *)memmove((char *)v6 + v4, (const void *)(*(void *)v1 + *((unsigned __int16 *)v1 + 4)), 16 * *((unsigned __int16 *)v1 + 5));
        }
        goto LABEL_20;
      }
      unsigned int v9 = (int32x4_t *)operator new(4 * v7);
      bzero(v9, 4 * v7);
      unint64_t v10 = (unsigned int *)v9 + v7;
      if (4 * v7 - 4 >= 0x1C)
      {
        unint64_t v13 = ((4 * v7 - 4) >> 2) + 1;
        uint64_t v11 = v13 & 0x7FFFFFFFFFFFFFF8;
        int32x4_t v14 = (int32x4_t)xmmword_1A28FC7A0;
        unsigned int v15 = v9 + 1;
        v16.i64[0] = 0x400000004;
        v16.i64[1] = 0x400000004;
        v17.i64[0] = 0x800000008;
        v17.i64[1] = 0x800000008;
        uint64_t v18 = v13 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v15[-1] = v14;
          int32x4_t *v15 = vaddq_s32(v14, v16);
          int32x4_t v14 = vaddq_s32(v14, v17);
          v15 += 2;
          v18 -= 8;
        }
        while (v18);
        if (v13 == v11) {
          goto LABEL_16;
        }
        unsigned int v12 = (unsigned int *)v9 + (v13 & 0x7FFFFFFFFFFFFFF8);
      }
      else
      {
        LODWORD(v11) = 0;
        unsigned int v12 = (unsigned int *)v9;
      }
      do
      {
        *v12++ = v11;
        LODWORD(v11) = v11 + 1;
      }
      while (v12 != v10);
LABEL_16:
      uint64_t v23 = v1;
      std::__introsort<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *,false>((uint64_t)v9, v10, (uint64_t **)&v23, 126 - 2 * __clz(v7), 1);
      if (*((_WORD *)v1 + 5))
      {
        unint64_t v19 = 0;
        do
        {
          uint64_t v20 = v9->u32[v19];
          uint64_t v21 = *(char **)v1;
          *((_WORD *)v6 + v19) = *(_WORD *)(*(void *)v1 + 2 * v20);
          *v8++ = *(_OWORD *)&v21[16 * v20 + *((unsigned __int16 *)v1 + 4)];
          ++v19;
        }
        while (v19 < *((unsigned __int16 *)v1 + 5));
      }
      *((unsigned char *)v1 + 15) = 1;
      operator delete(v9);
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t gss::StylePropertySet<gss::PropertyID>::operator==(unsigned __int16 **a1, unsigned __int16 **a2)
{
  unint64_t v4 = *((unsigned __int16 *)a1 + 5);
  if (v4 != *((unsigned __int16 *)a2 + 5)) {
    return 0;
  }
  if (*((_WORD *)a1 + 5))
  {
    uint64_t v6 = (uint64_t)*a1;
    uint64_t v7 = (uint64_t)*a2;
    if (**a1 != **a2) {
      return 0;
    }
    uint64_t v8 = *((unsigned __int16 *)a2 + 4);
    uint64_t v9 = *((unsigned __int16 *)a1 + 4);
    if (*(unsigned __int8 *)(v6 + v9) != *(unsigned __int8 *)(v7 + v8)) {
      return 0;
    }
    uint64_t v10 = v6 + v9;
    uint64_t v11 = v7 + v8;
    uint64_t v12 = 1;
    while (v4 != v12)
    {
      unint64_t v13 = v12;
      if (*(unsigned __int16 *)(v6 + 2 * v12) == *(unsigned __int16 *)(v7 + 2 * v12))
      {
        ++v12;
        if (*(unsigned __int8 *)(v10 + v13) == *(unsigned __int8 *)(v11 + v13)) {
          continue;
        }
      }
      if (v13 < v4) {
        return 0;
      }
      break;
    }
  }
  unint64_t v14 = *((unsigned __int16 *)a1 + 13);
  if (v14 == *((unsigned __int16 *)a2 + 13))
  {
    if (*((_WORD *)a1 + 13))
    {
      unsigned int v15 = a1[2];
      int32x4_t v16 = a2[2];
      if (*v15 != *v16) {
        return 0;
      }
      uint64_t v17 = *((unsigned __int16 *)a2 + 12);
      uint64_t v18 = *((unsigned __int16 *)a1 + 12);
      if (*((unsigned __int8 *)v15 + v18) != *((unsigned __int8 *)v16 + v17)) {
        return 0;
      }
      unint64_t v19 = (char *)v15 + v18;
      uint64_t v20 = (char *)v16 + v17;
      uint64_t v21 = 1;
      while (v14 != v21)
      {
        unint64_t v22 = v21;
        if (v15[v21] == v16[v21])
        {
          ++v21;
          if (v19[v22] == v20[v22]) {
            continue;
          }
        }
        if (v22 < v14) {
          return 0;
        }
        break;
      }
    }
    unint64_t v23 = *((unsigned __int16 *)a1 + 21);
    if (v23 == *((unsigned __int16 *)a2 + 21))
    {
      if (*((_WORD *)a1 + 21))
      {
        unint64_t v24 = a1[4];
        unsigned int v25 = a2[4];
        if (*v24 != *v25) {
          return 0;
        }
        uint64_t v26 = *((unsigned __int16 *)a2 + 20);
        uint64_t v27 = *((unsigned __int16 *)a1 + 20);
        if (*(_DWORD *)((char *)v24 + v27) != *(_DWORD *)((char *)v25 + v26)) {
          return 0;
        }
        unint64_t v28 = 0;
        uint64_t v29 = v24 + 1;
        unint64_t v30 = v25 + 1;
        uint64_t v31 = (uint64_t)v24 + v27 + 4;
        uint64_t v32 = (uint64_t)v25 + v26 + 4;
        while (v23 - 1 != v28)
        {
          if (v29[v28] != v30[v28])
          {
            ++v28;
LABEL_29:
            if (v28 < v23) {
              return 0;
            }
            break;
          }
          int v33 = *(_DWORD *)(v31 + 4 * v28);
          int v34 = *(_DWORD *)(v32 + 4 * v28++);
          if (v33 != v34) {
            goto LABEL_29;
          }
        }
      }
      unint64_t v35 = *((unsigned __int16 *)a1 + 29);
      if (v35 == *((unsigned __int16 *)a2 + 29))
      {
        if (*((_WORD *)a1 + 29))
        {
          unint64_t v36 = a1[6];
          unsigned int v37 = a2[6];
          if (*v36 != *v37) {
            return 0;
          }
          int v38 = (void *)((char *)v37 + *((unsigned __int16 *)a2 + 28));
          uint64_t v39 = (void *)((char *)v36 + *((unsigned __int16 *)a1 + 28));
          if (*v39 != *v38) {
            return 0;
          }
          unint64_t v40 = 0;
          while (++v40 != v35)
          {
            if (v36[v40] != v37[v40] || v39[v40] != v38[v40])
            {
              if (v40 < v35) {
                return 0;
              }
              break;
            }
          }
        }
        unsigned int v41 = *((unsigned __int16 *)a1 + 37);
        if (v41 == *((unsigned __int16 *)a2 + 37))
        {
          if (!*((_WORD *)a1 + 37)) {
            return 1;
          }
          unint64_t v42 = 0;
          unsigned int v43 = 0;
          float v44 = 0;
          unsigned int v45 = 0;
          uint64_t v46 = a2[8];
          int v47 = (char *)v46 + *((unsigned __int16 *)a2 + 36);
          while (1)
          {
            if (v43 < v41)
            {
              unint64_t v50 = a1[8];
              unint64_t v42 = &v50[v43];
              int v3 = (unsigned __int8 *)&v50[8 * v43] + *((unsigned __int16 *)a1 + 36);
            }
            if (v45 < v41)
            {
              float v44 = &v46[v45];
              int v2 = &v47[16 * v45];
            }
            if (*v42 != *v44) {
              break;
            }
            int v51 = *v3;
            if (v51 != *v2) {
              break;
            }
            if (v51 == 2)
            {
              uint64_t v59 = (float *)*((void *)v3 + 1);
              uint64_t v60 = (float *)*((void *)v2 + 1);
              if (v59[8] != v60[8]) {
                return 0;
              }
              uint64_t v61 = *(void *)v59;
              uint64_t v62 = *(void *)(*((void *)v3 + 1) + 8);
              unint64_t v63 = (v62 - v61) >> 2;
              uint64_t v64 = *(void *)v60;
              if (v63 != (*(void *)(*((void *)v2 + 1) + 8) - v64) >> 2) {
                return 0;
              }
              if (v62 != v61)
              {
                unint64_t v65 = 0;
                unsigned int v66 = 1;
                while (vabds_f32(*(float *)(v61 + 4 * v65), *(float *)(v64 + 4 * v65)) <= 0.00000011921)
                {
                  unint64_t v65 = v66++;
                  if (v63 <= v65) {
                    goto LABEL_44;
                  }
                }
                return 0;
              }
            }
            else if (v51 == 1)
            {
              uint64_t v52 = (unsigned __int8 *)*((void *)v3 + 1);
              unsigned int v53 = (unsigned __int8 **)*((void *)v2 + 1);
              uint64_t v54 = v52[23];
              if ((v54 & 0x80u) == 0) {
                uint64_t v55 = (unsigned __int8 *)v52[23];
              }
              else {
                uint64_t v55 = (unsigned __int8 *)*((void *)v52 + 1);
              }
              unsigned int v56 = (unsigned __int8 *)*((unsigned __int8 *)v53 + 23);
              int v57 = (char)v56;
              if ((char)v56 < 0) {
                unsigned int v56 = v53[1];
              }
              if (v55 != v56) {
                return 0;
              }
              if (v57 >= 0) {
                uint64_t v58 = (unsigned __int8 *)*((void *)v2 + 1);
              }
              else {
                uint64_t v58 = *v53;
              }
              if ((v54 & 0x80) != 0)
              {
                if (memcmp(*(const void **)v52, v58, *((void *)v52 + 1))) {
                  return 0;
                }
              }
              else if (v52[23])
              {
                while (*v52 == *v58)
                {
                  ++v52;
                  ++v58;
                  if (!--v54) {
                    goto LABEL_44;
                  }
                }
                return 0;
              }
            }
LABEL_44:
            unsigned int v49 = v43 + 1;
            if (v45 + 1 < v41) {
              ++v45;
            }
            else {
              unsigned int v45 = v41;
            }
            uint64_t result = 1;
            if (v49 < v41) {
              ++v43;
            }
            else {
              unsigned int v43 = v41;
            }
            if (v49 >= v41) {
              return result;
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *,false>(uint64_t result, unsigned int *a2, uint64_t **a3, uint64_t a4, char a5)
{
  uint64_t v11 = (unsigned int *)result;
LABEL_2:
  uint64_t v12 = a2 - 1;
  unint64_t v13 = v11;
  while (1)
  {
    uint64_t v11 = v13;
    uint64_t v14 = (char *)a2 - (char *)v13;
    uint64_t v15 = a2 - v13;
    if (v6 || !v5)
    {
      switch(v15)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v91 = *v12;
          uint64_t v92 = *v13;
          if (*(unsigned __int16 *)(**a3 + 2 * v91) < *(unsigned __int16 *)(**a3 + 2 * v92))
          {
            *unint64_t v13 = v91;
            *uint64_t v12 = v92;
          }
          return result;
        case 3:
          uint64_t v93 = *v13;
          uint64_t v94 = v13[1];
          uint64_t v95 = **a3;
          unsigned int v96 = *(unsigned __int16 *)(v95 + 2 * v94);
          unsigned int v97 = *(unsigned __int16 *)(v95 + 2 * v93);
          uint64_t v98 = *v12;
          unsigned int v99 = *(unsigned __int16 *)(v95 + 2 * v98);
          if (v96 >= v97)
          {
            if (v99 < v96)
            {
              v13[1] = v98;
              *uint64_t v12 = v94;
              uint64_t v136 = *v13;
              uint64_t v135 = v13[1];
              if (*(unsigned __int16 *)(v95 + 2 * v135) < *(unsigned __int16 *)(v95 + 2 * v136))
              {
                *unint64_t v13 = v135;
                v13[1] = v136;
              }
            }
          }
          else if (v99 >= v96)
          {
            *unint64_t v13 = v94;
            v13[1] = v93;
            uint64_t v161 = *v12;
            if (*(unsigned __int16 *)(v95 + 2 * v161) < v97)
            {
              v13[1] = v161;
              *uint64_t v12 = v93;
            }
          }
          else
          {
            *unint64_t v13 = v98;
            *uint64_t v12 = v93;
          }
          return result;
        case 4:
          unsigned int v101 = v13 + 1;
          uint64_t v102 = v13[1];
          uint64_t v103 = v13 + 2;
          uint64_t v104 = v13[2];
          uint64_t v105 = *v13;
          uint64_t v106 = **a3;
          unsigned int v107 = *(unsigned __int16 *)(v106 + 2 * v102);
          unsigned int v108 = *(unsigned __int16 *)(v106 + 2 * v105);
          unsigned int v109 = v104;
          unsigned int v110 = *(unsigned __int16 *)(v106 + 2 * v104);
          if (v107 >= v108)
          {
            if (v110 < v107)
            {
              uint64_t v111 = v13;
              _DWORD *v101 = v104;
              *uint64_t v103 = v102;
              uint64_t result = (uint64_t)(v13 + 1);
              uint64_t v112 = v102;
              uint64_t v104 = v102;
              if (v110 >= v108) {
                goto LABEL_173;
              }
              goto LABEL_171;
            }
          }
          else
          {
            if (v110 < v107)
            {
              uint64_t v111 = v13;
              uint64_t result = (uint64_t)(v13 + 2);
              uint64_t v112 = *v13;
              LODWORD(v102) = *v13;
LABEL_171:
              *uint64_t v111 = v109;
              *(_DWORD *)uint64_t result = v105;
              uint64_t v104 = v112;
              goto LABEL_173;
            }
            uint64_t v111 = v13 + 1;
            *unint64_t v13 = v102;
            v13[1] = v105;
            uint64_t result = (uint64_t)(v13 + 2);
            uint64_t v112 = v105;
            LODWORD(v102) = v105;
            if (v110 < v108) {
              goto LABEL_171;
            }
          }
          LODWORD(v102) = v104;
LABEL_173:
          uint64_t v162 = *v12;
          if (*(unsigned __int16 *)(v106 + 2 * v162) < *(unsigned __int16 *)(v106 + 2 * v104))
          {
            *uint64_t v103 = v162;
            *uint64_t v12 = v102;
            uint64_t v163 = *v103;
            uint64_t v164 = *v101;
            unsigned int v165 = *(unsigned __int16 *)(v106 + 2 * v163);
            if (v165 < *(unsigned __int16 *)(v106 + 2 * v164))
            {
              v13[1] = v163;
              v13[2] = v164;
              uint64_t v166 = *v13;
              if (v165 < *(unsigned __int16 *)(v106 + 2 * v166))
              {
                *unint64_t v13 = v163;
                v13[1] = v166;
              }
            }
          }
          return result;
        case 5:
          uint64_t v100 = **a3;
          return (uint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned long long *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v13, v13 + 1, v13 + 2, v13 + 3, a2 - 1, v100);
        default:
          JUMPOUT(0);
      }
    }
    if (v14 <= 95) {
      break;
    }
    if (!a4)
    {
      if (v13 != a2)
      {
        int64_t v123 = (unint64_t)(v15 - 2) >> 1;
        long long v124 = *a3;
        int64_t v125 = v123;
        do
        {
          if (v123 >= v125)
          {
            uint64_t v127 = (2 * v125) | 1;
            __n128 v128 = &v13[v127];
            uint64_t v129 = *v128;
            if (2 * v125 + 2 < v15)
            {
              uint64_t v130 = *v124;
              if (*(unsigned __int16 *)(*v124 + 2 * v129) < *(unsigned __int16 *)(*v124 + 2 * v128[1]))
              {
                LODWORD(v129) = v128[1];
                ++v128;
                uint64_t v127 = 2 * v125 + 2;
              }
            }
            else
            {
              uint64_t v130 = *v124;
            }
            unsigned int v131 = &v13[v125];
            uint64_t v132 = *v131;
            uint64_t result = *(unsigned __int16 *)(v130 + 2 * v132);
            if (*(unsigned __int16 *)(v130 + 2 * v129) >= result)
            {
              do
              {
                __n128 v133 = v128;
                *unsigned int v131 = v129;
                if (v123 < v127) {
                  break;
                }
                uint64_t v134 = (2 * v127) | 1;
                __n128 v128 = &v13[v134];
                uint64_t v127 = 2 * v127 + 2;
                uint64_t v129 = *v128;
                if (v127 < v15)
                {
                  if (*(unsigned __int16 *)(v130 + 2 * v129) >= *(unsigned __int16 *)(v130 + 2 * v128[1]))
                  {
                    uint64_t v127 = v134;
                  }
                  else
                  {
                    LODWORD(v129) = v128[1];
                    ++v128;
                  }
                }
                else
                {
                  uint64_t v127 = v134;
                }
                unsigned int v131 = v133;
              }
              while (*(unsigned __int16 *)(v130 + 2 * v129) >= result);
              *__n128 v133 = v132;
            }
          }
          BOOL v126 = v125-- <= 0;
        }
        while (!v126);
        uint64_t v143 = (unint64_t)v14 >> 2;
        do
        {
          uint64_t v144 = 0;
          unsigned int v145 = *v13;
          uint64_t v146 = *a3;
          uint64_t v147 = v13;
          do
          {
            unsigned __int16 v150 = &v147[v144];
            unsigned int v151 = v150[1];
            unsigned int v149 = v150 + 1;
            uint64_t v148 = v151;
            uint64_t v152 = (2 * v144) | 1;
            uint64_t v144 = 2 * v144 + 2;
            if (v144 < v143)
            {
              uint64_t result = v149[1];
              if (*(unsigned __int16 *)(*v146 + 2 * v148) >= *(unsigned __int16 *)(*v146 + 2 * result))
              {
                uint64_t v144 = v152;
              }
              else
              {
                LODWORD(v148) = v149[1];
                ++v149;
              }
            }
            else
            {
              uint64_t v144 = v152;
            }
            unsigned int *v147 = v148;
            uint64_t v147 = v149;
          }
          while (v144 <= (uint64_t)((unint64_t)(v143 - 2) >> 1));
          if (v149 == --a2)
          {
            unsigned int *v149 = v145;
          }
          else
          {
            unsigned int *v149 = *a2;
            *a2 = v145;
            uint64_t v153 = (char *)v149 - (char *)v13 + 4;
            if (v153 >= 5)
            {
              unint64_t v154 = (((unint64_t)v153 >> 2) - 2) >> 1;
              unint64_t v155 = &v13[v154];
              uint64_t v156 = *v155;
              uint64_t v157 = *v149;
              uint64_t v158 = *v146;
              unsigned int v159 = *(unsigned __int16 *)(v158 + 2 * v157);
              if (*(unsigned __int16 *)(v158 + 2 * v156) < v159)
              {
                do
                {
                  uint64_t v160 = v155;
                  unsigned int *v149 = v156;
                  if (!v154) {
                    break;
                  }
                  unint64_t v154 = (v154 - 1) >> 1;
                  unint64_t v155 = &v13[v154];
                  uint64_t v156 = *v155;
                  unsigned int v149 = v160;
                }
                while (*(unsigned __int16 *)(v158 + 2 * v156) < v159);
                unsigned int *v160 = v157;
              }
            }
          }
          BOOL v126 = v143-- <= 2;
        }
        while (!v126);
      }
      return result;
    }
    unint64_t v16 = (unint64_t)v15 >> 1;
    uint64_t v17 = &v13[(unint64_t)v15 >> 1];
    uint64_t v18 = **a3;
    uint64_t v19 = *v12;
    unsigned int v20 = *(unsigned __int16 *)(v18 + 2 * v19);
    if ((unint64_t)v14 >= 0x201)
    {
      uint64_t v21 = *v17;
      uint64_t v22 = *v13;
      unsigned int v23 = *(unsigned __int16 *)(v18 + 2 * v21);
      unsigned int v24 = *(unsigned __int16 *)(v18 + 2 * v22);
      if (v23 >= v24)
      {
        if (v20 < v23)
        {
          *uint64_t v17 = v19;
          *uint64_t v12 = v21;
          uint64_t v29 = *v17;
          uint64_t v30 = *v13;
          if (*(unsigned __int16 *)(v18 + 2 * v29) < *(unsigned __int16 *)(v18 + 2 * v30))
          {
            *unint64_t v13 = v29;
            *uint64_t v17 = v30;
          }
        }
      }
      else
      {
        if (v20 < v23)
        {
          *unint64_t v13 = v19;
          goto LABEL_22;
        }
        *unint64_t v13 = v21;
        *uint64_t v17 = v22;
        uint64_t v33 = *v12;
        if (*(unsigned __int16 *)(v18 + 2 * v33) < v24)
        {
          *uint64_t v17 = v33;
LABEL_22:
          *uint64_t v12 = v22;
        }
      }
      int v34 = &v13[v16];
      unsigned int v37 = *(v34 - 1);
      unint64_t v35 = v34 - 1;
      unsigned int v36 = v37;
      uint64_t v38 = v13[1];
      unsigned int v39 = *(unsigned __int16 *)(v18 + 2 * v37);
      unsigned int v40 = *(unsigned __int16 *)(v18 + 2 * v38);
      uint64_t v41 = *(a2 - 2);
      unsigned int v42 = *(unsigned __int16 *)(v18 + 2 * v41);
      if (v39 >= v40)
      {
        if (v42 < v39)
        {
          unsigned int *v35 = v41;
          *(a2 - 2) = v36;
          uint64_t v43 = *v35;
          uint64_t v44 = v13[1];
          if (*(unsigned __int16 *)(v18 + 2 * v43) < *(unsigned __int16 *)(v18 + 2 * v44))
          {
            v13[1] = v43;
            unsigned int *v35 = v44;
          }
        }
      }
      else
      {
        if (v42 < v39)
        {
          v13[1] = v41;
          goto LABEL_34;
        }
        v13[1] = v36;
        unsigned int *v35 = v38;
        uint64_t v46 = *(a2 - 2);
        if (*(unsigned __int16 *)(v18 + 2 * v46) < v40)
        {
          unsigned int *v35 = v46;
LABEL_34:
          *(a2 - 2) = v38;
        }
      }
      int v47 = &v13[v16];
      unsigned int v50 = v47[1];
      float v48 = v47 + 1;
      unsigned int v49 = v50;
      uint64_t v51 = v13[2];
      unsigned int v52 = *(unsigned __int16 *)(v18 + 2 * v50);
      unsigned int v53 = *(unsigned __int16 *)(v18 + 2 * v51);
      uint64_t v54 = *(a2 - 3);
      unsigned int v55 = *(unsigned __int16 *)(v18 + 2 * v54);
      if (v52 >= v53)
      {
        if (v55 < v52)
        {
          unsigned int *v48 = v54;
          *(a2 - 3) = v49;
          uint64_t v56 = *v48;
          uint64_t v57 = v13[2];
          if (*(unsigned __int16 *)(v18 + 2 * v56) < *(unsigned __int16 *)(v18 + 2 * v57))
          {
            v13[2] = v56;
            unsigned int *v48 = v57;
          }
        }
      }
      else
      {
        if (v55 < v52)
        {
          v13[2] = v54;
          goto LABEL_43;
        }
        v13[2] = v49;
        unsigned int *v48 = v51;
        uint64_t v58 = *(a2 - 3);
        if (*(unsigned __int16 *)(v18 + 2 * v58) < v53)
        {
          unsigned int *v48 = v58;
LABEL_43:
          *(a2 - 3) = v51;
        }
      }
      uint64_t v59 = *v17;
      uint64_t v60 = *v35;
      unsigned int v61 = *(unsigned __int16 *)(v18 + 2 * v59);
      unsigned int v62 = *(unsigned __int16 *)(v18 + 2 * v60);
      uint64_t v63 = *v48;
      unsigned int v64 = *(unsigned __int16 *)(v18 + 2 * v63);
      if (v61 >= v62)
      {
        if (v64 >= v61) {
          goto LABEL_51;
        }
        *uint64_t v17 = v63;
        unsigned int *v48 = v59;
        float v48 = v17;
        LODWORD(v59) = v60;
        if (v64 >= v62)
        {
          LODWORD(v59) = v63;
          goto LABEL_51;
        }
      }
      else if (v64 >= v61)
      {
        unsigned int *v35 = v59;
        *uint64_t v17 = v60;
        unint64_t v35 = v17;
        LODWORD(v59) = v63;
        if (v64 >= v62)
        {
          LODWORD(v59) = v60;
LABEL_51:
          unsigned int v65 = *v13;
          *unint64_t v13 = v59;
          *uint64_t v17 = v65;
          goto LABEL_52;
        }
      }
      unsigned int *v35 = v63;
      unsigned int *v48 = v60;
      goto LABEL_51;
    }
    uint64_t v25 = *v13;
    uint64_t v26 = *v17;
    unsigned int v27 = *(unsigned __int16 *)(v18 + 2 * v25);
    unsigned int v28 = *(unsigned __int16 *)(v18 + 2 * v26);
    if (v27 >= v28)
    {
      if (v20 < v27)
      {
        *unint64_t v13 = v19;
        *uint64_t v12 = v25;
        uint64_t v31 = *v13;
        uint64_t v32 = *v17;
        if (*(unsigned __int16 *)(v18 + 2 * v31) < *(unsigned __int16 *)(v18 + 2 * v32))
        {
          *uint64_t v17 = v31;
          *unint64_t v13 = v32;
        }
      }
      goto LABEL_52;
    }
    if (v20 < v27)
    {
      *uint64_t v17 = v19;
LABEL_31:
      *uint64_t v12 = v26;
      goto LABEL_52;
    }
    *uint64_t v17 = v25;
    *unint64_t v13 = v26;
    uint64_t v45 = *v12;
    if (*(unsigned __int16 *)(v18 + 2 * v45) < v28)
    {
      *unint64_t v13 = v45;
      goto LABEL_31;
    }
LABEL_52:
    --a4;
    uint64_t v66 = *v13;
    if (a5)
    {
      unsigned int v67 = *(unsigned __int16 *)(v18 + 2 * v66);
LABEL_55:
      uint64_t v68 = v13;
      do
      {
        uint64_t v69 = v68;
        unsigned int v71 = v68[1];
        ++v68;
        unsigned int v70 = v71;
      }
      while (*(unsigned __int16 *)(v18 + 2 * v71) < v67);
      size_t v72 = a2;
      if (v69 == v13)
      {
        size_t v72 = a2;
        do
        {
          if (v68 >= v72) {
            break;
          }
          unsigned int v74 = *--v72;
        }
        while (*(unsigned __int16 *)(v18 + 2 * v74) >= v67);
      }
      else
      {
        do
          unsigned int v73 = *--v72;
        while (*(unsigned __int16 *)(v18 + 2 * v73) >= v67);
      }
      if (v68 < v72)
      {
        unsigned int v75 = *v72;
        unsigned int v76 = v70;
        uint64_t v77 = v68;
        unint64_t v78 = v72;
        do
        {
          *uint64_t v77 = v75;
          *unint64_t v78 = v76;
          do
          {
            uint64_t v69 = v77;
            unsigned int v79 = v77[1];
            ++v77;
            unsigned int v76 = v79;
          }
          while (*(unsigned __int16 *)(v18 + 2 * v79) < v67);
          do
          {
            unsigned int v80 = *--v78;
            unsigned int v75 = v80;
          }
          while (*(unsigned __int16 *)(v18 + 2 * v80) >= v67);
        }
        while (v77 < v78);
      }
      if (v69 != v13) {
        *unint64_t v13 = *v69;
      }
      *uint64_t v69 = v66;
      if (v68 < v72) {
        goto LABEL_74;
      }
      BOOL v81 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v13, v69, *a3);
      unint64_t v13 = v69 + 1;
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v69 + 1, a2, *a3);
      if (result)
      {
        a2 = v69;
        if (v81) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v81)
      {
LABEL_74:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *,false>(v11, v69, a3, a4, a5 & 1);
        a5 = 0;
        unint64_t v13 = v69 + 1;
      }
    }
    else
    {
      unsigned int v67 = *(unsigned __int16 *)(v18 + 2 * v66);
      if (*(unsigned __int16 *)(v18 + 2 * *(v13 - 1)) < v67) {
        goto LABEL_55;
      }
      if (v67 < *(unsigned __int16 *)(v18 + 2 * *v12))
      {
        do
        {
          unsigned int v82 = v13[1];
          ++v13;
        }
        while (v67 >= *(unsigned __int16 *)(v18 + 2 * v82));
      }
      else
      {
        size_t v83 = v13 + 1;
        do
        {
          unint64_t v13 = v83;
          if (v83 >= a2) {
            break;
          }
          ++v83;
        }
        while (v67 >= *(unsigned __int16 *)(v18 + 2 * *v13));
      }
      uint64_t v84 = a2;
      if (v13 < a2)
      {
        uint64_t v84 = a2;
        do
          unsigned int v85 = *--v84;
        while (v67 < *(unsigned __int16 *)(v18 + 2 * v85));
      }
      if (v13 < v84)
      {
        unsigned int v86 = *v13;
        unsigned int v87 = *v84;
        do
        {
          *unint64_t v13 = v87;
          *uint64_t v84 = v86;
          do
          {
            unsigned int v88 = v13[1];
            ++v13;
            unsigned int v86 = v88;
          }
          while (v67 >= *(unsigned __int16 *)(v18 + 2 * v88));
          do
          {
            unsigned int v89 = *--v84;
            unsigned int v87 = v89;
          }
          while (v67 < *(unsigned __int16 *)(v18 + 2 * v89));
        }
        while (v13 < v84);
      }
      uint64_t v90 = v13 - 1;
      BOOL v5 = v13 - 1 >= v11;
      BOOL v6 = v13 - 1 == v11;
      if (v13 - 1 != v11) {
        *uint64_t v11 = *v90;
      }
      a5 = 0;
      *uint64_t v90 = v66;
    }
  }
  if (a5)
  {
    if (v13 != a2)
    {
      uint64_t v113 = v13 + 1;
      if (v13 + 1 != a2)
      {
        uint64_t v114 = **a3;
        uint64_t v115 = 4;
        char v116 = v13;
        do
        {
          uint64_t v119 = *v116;
          uint64_t v118 = v116[1];
          char v116 = v113;
          unsigned int v120 = *(unsigned __int16 *)(v114 + 2 * v118);
          if (v120 < *(unsigned __int16 *)(v114 + 2 * v119))
          {
            uint64_t v121 = v115;
            do
            {
              *(unsigned int *)((char *)v13 + v121) = v119;
              uint64_t v122 = v121 - 4;
              if (v121 == 4)
              {
                unsigned int v117 = v13;
                goto LABEL_112;
              }
              uint64_t v119 = *(unsigned int *)((char *)v13 + v121 - 8);
              v121 -= 4;
            }
            while (v120 < *(unsigned __int16 *)(v114 + 2 * v119));
            unsigned int v117 = (unsigned int *)((char *)v13 + v122);
LABEL_112:
            *unsigned int v117 = v118;
          }
          uint64_t v113 = v116 + 1;
          v115 += 4;
        }
        while (v116 + 1 != a2);
      }
    }
  }
  else if (v13 != a2)
  {
    unsigned __int16 v137 = v13 + 1;
    if (v13 + 1 != a2)
    {
      uint64_t v138 = **a3;
      do
      {
        uint64_t v140 = *v11;
        uint64_t v139 = v11[1];
        uint64_t v11 = v137;
        unsigned int v141 = *(unsigned __int16 *)(v138 + 2 * v139);
        if (v141 < *(unsigned __int16 *)(v138 + 2 * v140))
        {
          int v142 = v11;
          do
          {
            *int v142 = v140;
            uint64_t v140 = *(v142 - 2);
            --v142;
          }
          while (v141 < *(unsigned __int16 *)(v138 + 2 * v140));
          *int v142 = v139;
        }
        unsigned __int16 v137 = v11 + 1;
      }
      while (v11 + 1 != a2);
    }
  }
  return result;
}

{
  char v5;
  char v6;
  unsigned int *v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int *v19;
  char v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t vars8;

  uint64_t v10 = (unsigned int *)result;
LABEL_2:
  uint64_t v11 = v10;
LABEL_3:
  uint64_t v12 = 1 - a4;
  while (1)
  {
    uint64_t v10 = v11;
    unint64_t v13 = v12;
    uint64_t v14 = (char *)a2 - (char *)v11;
    uint64_t v15 = a2 - v11;
    if (!(!v6 & v5))
    {
      switch(v15)
      {
        case 0uLL:
        case 1uLL:
          return result;
        case 2uLL:
          uint64_t v22 = *(a2 - 1);
          unsigned int v23 = *v11;
          if (*(unsigned __int16 *)(**a3 + 2 * v22) < *(unsigned __int16 *)(**a3 + 2 * v23))
          {
            *uint64_t v11 = v22;
            *(a2 - 1) = v23;
          }
          break;
        case 3uLL:
          uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11, v11 + 1, a2 - 1, a3);
          break;
        case 4uLL:
          uint64_t result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11, v11 + 1, v11 + 2, a2 - 1, a3);
          break;
        case 5uLL:
          uint64_t result = std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11, v11 + 1, v11 + 2, v11 + 3, a2 - 1, a3);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v14 <= 95) {
      break;
    }
    if (v13 == 1)
    {
      if (v11 != a2)
      {
        return (uint64_t)std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *,unsigned int *>(v11, a2, a2, a3);
      }
      return result;
    }
    unint64_t v16 = v15 >> 1;
    uint64_t v17 = &v11[v15 >> 1];
    if ((unint64_t)v14 >= 0x201)
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11, &v11[v15 >> 1], a2 - 1, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11 + 1, v17 - 1, a2 - 2, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11 + 2, &v11[v16 + 1], a2 - 3, a3);
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v17 - 1, v17, &v11[v16 + 1], a3);
      uint64_t v18 = *v11;
      *uint64_t v11 = *v17;
      *uint64_t v17 = v18;
      if (a5) {
        goto LABEL_14;
      }
    }
    else
    {
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(&v11[v15 >> 1], v11, a2 - 1, a3);
      if (a5) {
        goto LABEL_14;
      }
    }
    if (*(unsigned __int16 *)(**a3 + 2 * *(v11 - 1)) >= *(unsigned __int16 *)(**a3 + 2 * *v11))
    {
      uint64_t result = (uint64_t)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,unsigned int *,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &>(v11, a2, a3);
      uint64_t v11 = (unsigned int *)result;
      goto LABEL_19;
    }
LABEL_14:
    uint64_t v19 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,unsigned int *,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &>(v11, a2, a3);
    if ((v20 & 1) == 0) {
      goto LABEL_17;
    }
    uint64_t v21 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11, v19, a3);
    uint64_t v11 = v19 + 1;
    uint64_t result = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v19 + 1, a2, a3);
    if (result)
    {
      a4 = -v13;
      a2 = v19;
      if (v21) {
        return result;
      }
      goto LABEL_2;
    }
    uint64_t v12 = v13 + 1;
    if (!v21)
    {
LABEL_17:
      uint64_t result = std::__introsort<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *,false>(v10, v19, a3, -v13, a5 & 1);
      uint64_t v11 = v19 + 1;
LABEL_19:
      a5 = 0;
      a4 = -v13;
      goto LABEL_3;
    }
  }
  if (a5)
  {
    return (uint64_t)std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11, a2, a3);
  }
  else
  {
    return (uint64_t)std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::PropertyID*,unsigned char *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v11, a2, a3);
  }
}

uint64_t geo::intern_linear_map<gss::ScenePropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable(unsigned __int16 *a1)
{
  int v1 = a1[5];
  if (v1 != a1[6]) {
    return 1;
  }
  if (v1 == 0xFFFF) {
    return 0;
  }
  unsigned int v3 = 2 * (v1 & 0x7FFF);
  if (v3 <= 4) {
    __int16 v4 = 4;
  }
  else {
    __int16 v4 = v3;
  }
  unsigned __int16 v5 = (v4 & 0xFFF8) + 8;
  uint64_t v6 = gss::Allocator::instance((gss::Allocator *)a1);
  uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v6 + 16))(v6, (unsigned __int16)(v5 + 8 * v4) & 0xFFF8, 1);
  uint64_t v8 = v7;
  if (*(void *)a1)
  {
    if (a1[5])
    {
      uint64_t v7 = (char *)memmove(v7, *(const void **)a1, a1[5]);
      if (a1[5]) {
        uint64_t v7 = (char *)memmove(&v8[v5], (const void *)(*(void *)a1 + a1[4]), 8 * a1[5]);
      }
    }
    uint64_t v9 = gss::Allocator::instance((gss::Allocator *)v7);
    (*(void (**)(uint64_t, void, void))(*(void *)v9 + 40))(v9, *(void *)a1, a1[6]);
  }
  a1[6] = v4;
  *(void *)a1 = v8;
  uint64_t result = 1;
  a1[4] = v5;
  return result;
}

{
  int v1;
  unsigned int v3;
  __int16 v4;
  uint64_t v5;
  unsigned __int16 v6;
  char *v7;
  char *v8;
  uint64_t v9;
  uint64_t result;

  int v1 = a1[5];
  if (v1 != a1[6]) {
    return 1;
  }
  if (v1 == 0xFFFF) {
    return 0;
  }
  unsigned int v3 = 2 * (v1 & 0x7FFF);
  if (v3 <= 4) {
    __int16 v4 = 4;
  }
  else {
    __int16 v4 = v3;
  }
  unsigned __int16 v5 = gss::Allocator::instance((gss::Allocator *)a1);
  uint64_t v6 = (v4 & 0xFFF8) + 8;
  uint64_t v7 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)(v6 + 8 * v4), 1);
  uint64_t v8 = v7;
  if (*(void *)a1)
  {
    if (a1[5])
    {
      uint64_t v7 = (char *)memmove(v7, *(const void **)a1, a1[5]);
      if (a1[5]) {
        uint64_t v7 = (char *)memmove(&v8[v6], (const void *)(*(void *)a1 + a1[4]), 8 * a1[5]);
      }
    }
    uint64_t v9 = gss::Allocator::instance((gss::Allocator *)v7);
    (*(void (**)(uint64_t, void, void))(*(void *)v9 + 40))(v9, *(void *)a1, a1[6]);
  }
  a1[6] = v4;
  *(void *)a1 = v8;
  uint64_t result = 1;
  a1[4] = v6;
  return result;
}

gss::Allocator *geo::intern_vector<gss::StylePropertySet<gss::PropertyID>,geo::StdAllocator<gss::StylePropertySet<gss::PropertyID>,gss::Allocator>>::reallocate(gss::Allocator **a1, uint64_t a2)
{
  uint64_t v4 = gss::Allocator::instance((gss::Allocator *)a1);
  uint64_t result = (gss::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4 + 16))(v4, 80 * a2, 8);
  uint64_t v6 = result;
  uint64_t v7 = *a1;
  if (*a1)
  {
    uint64_t v8 = a1 + 1;
    __int16 v9 = *((_WORD *)a1 + 4);
    if (v9)
    {
      int v10 = *((unsigned __int16 *)a1 + 4);
      uint64_t v11 = result;
      do
      {
        *(void *)((char *)v11 + 7) = 0;
        *(void *)uint64_t v11 = 0;
        *((unsigned char *)v11 + 15) = 1;
        uint64_t v12 = *(void *)v7;
        uint64_t v13 = *((void *)v7 + 1);
        *((_DWORD *)v11 + 2) = v13;
        *((_WORD *)v11 + 6) = WORD2(v13);
        *(void *)uint64_t v11 = v12;
        *((unsigned char *)v11 + 14) = *((unsigned char *)v7 + 14);
        *((unsigned char *)v11 + 15) = *((unsigned char *)v7 + 15);
        *(void *)((char *)v7 + 7) = 0;
        *(void *)uint64_t v7 = 0;
        *((unsigned char *)v7 + 15) = 1;
        *(void *)((char *)v11 + 23) = 0;
        *((void *)v11 + 2) = 0;
        *((unsigned char *)v11 + 31) = 1;
        uint64_t v14 = *((void *)v7 + 2);
        uint64_t v15 = *((void *)v7 + 3);
        *((_DWORD *)v11 + 6) = v15;
        *((_WORD *)v11 + 14) = WORD2(v15);
        *((void *)v11 + 2) = v14;
        *((unsigned char *)v11 + 30) = *((unsigned char *)v7 + 30);
        *((unsigned char *)v11 + 31) = *((unsigned char *)v7 + 31);
        *(void *)((char *)v7 + 23) = 0;
        *((void *)v7 + 2) = 0;
        *((unsigned char *)v7 + 31) = 1;
        *(void *)((char *)v11 + 39) = 0;
        *((void *)v11 + 4) = 0;
        *((unsigned char *)v11 + 47) = 1;
        uint64_t v16 = *((void *)v7 + 4);
        uint64_t v17 = *((void *)v7 + 5);
        *((_DWORD *)v11 + 10) = v17;
        *((_WORD *)v11 + 22) = WORD2(v17);
        *((void *)v11 + 4) = v16;
        *((unsigned char *)v11 + 46) = *((unsigned char *)v7 + 46);
        *((unsigned char *)v11 + 47) = *((unsigned char *)v7 + 47);
        *(void *)((char *)v7 + 39) = 0;
        *((void *)v7 + 4) = 0;
        *((unsigned char *)v7 + 47) = 1;
        *(void *)((char *)v11 + 55) = 0;
        *((void *)v11 + 6) = 0;
        *((unsigned char *)v11 + 63) = 1;
        uint64_t v18 = *((void *)v7 + 6);
        uint64_t v19 = *((void *)v7 + 7);
        *((_DWORD *)v11 + 14) = v19;
        *((_WORD *)v11 + 30) = WORD2(v19);
        *((void *)v11 + 6) = v18;
        *((unsigned char *)v11 + 62) = *((unsigned char *)v7 + 62);
        *((unsigned char *)v11 + 63) = *((unsigned char *)v7 + 63);
        *(void *)((char *)v7 + 55) = 0;
        *((void *)v7 + 6) = 0;
        *((unsigned char *)v7 + 63) = 1;
        *(void *)((char *)v11 + 71) = 0;
        *((void *)v11 + 8) = 0;
        uint64_t v20 = *((void *)v7 + 8);
        uint64_t v21 = *((void *)v7 + 9);
        *((_DWORD *)v11 + 18) = v21;
        *((_WORD *)v11 + 38) = WORD2(v21);
        *((unsigned char *)v11 + 79) = 1;
        *((void *)v11 + 8) = v20;
        *((unsigned char *)v11 + 78) = *((unsigned char *)v7 + 78);
        *((unsigned char *)v11 + 79) = *((unsigned char *)v7 + 79);
        *(void *)((char *)v7 + 71) = 0;
        --v10;
        uint64_t v11 = (gss::Allocator *)((char *)v11 + 80);
        *((void *)v7 + 8) = 0;
        *((unsigned char *)v7 + 79) = 1;
        uint64_t v7 = (gss::Allocator *)((char *)v7 + 80);
      }
      while ((_WORD)v10);
    }
    if (!*((unsigned char *)a1 + 12))
    {
      uint64_t result = *a1;
      if (*a1)
      {
        if (*v8)
        {
          uint64_t v22 = 80 * (unsigned __int16)*v8;
          do
          {
            uint64_t result = (gss::Allocator *)(gss::StylePropertySet<gss::PropertyID>::~StylePropertySet((uint64_t)result) + 80);
            v22 -= 80;
          }
          while (v22);
        }
        uint64_t v23 = gss::Allocator::instance(result);
        uint64_t result = (gss::Allocator *)(*(uint64_t (**)(uint64_t, gss::Allocator *, uint64_t))(*(void *)v23 + 40))(v23, *a1, 80 * *((unsigned __int16 *)a1 + 5));
      }
    }
    *(_DWORD *)uint64_t v8 = 0;
    *((unsigned char *)a1 + 12) = 0;
    _WORD *v8 = v9;
  }
  *((_WORD *)a1 + 5) = a2;
  *a1 = v6;
  return result;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::__unordered_map_hasher<gss::StylePropertySet<gss::ScenePropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::hash<gss::StylePropertySet<gss::ScenePropertyID>>,std::equal_to<gss::StylePropertySet<gss::ScenePropertyID>>,true>,std::__unordered_map_equal<gss::StylePropertySet<gss::ScenePropertyID>,std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>,std::equal_to<gss::StylePropertySet<gss::ScenePropertyID>>,std::hash<gss::StylePropertySet<gss::ScenePropertyID>>,true>,std::allocator<std::__hash_value_type<gss::StylePropertySet<gss::ScenePropertyID>,unsigned char>>>::__emplace_unique_key_args<gss::StylePropertySet<gss::ScenePropertyID>,gss::StylePropertySet<gss::ScenePropertyID>,unsigned char &>(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  unsigned int v9 = *(unsigned __int16 *)(a2 + 10);
  if (!*(_WORD *)(a2 + 10))
  {
    unint64_t v10 = 0;
    unsigned int v14 = *(unsigned __int16 *)(a2 + 26);
    if (!*(_WORD *)(a2 + 26)) {
      goto LABEL_19;
    }
    goto LABEL_12;
  }
  unint64_t v10 = 0;
  uint64_t v11 = 0;
  unsigned int v12 = 0;
  do
  {
    if (v12 < v9) {
      uint64_t v11 = (unsigned __int8 *)(*(void *)a2 + v12);
    }
    uint64_t v4 = (void *)((v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2));
    v10 ^= (unint64_t)v4 + *v11;
    unsigned int v13 = v12 + 1;
    if (v12 + 1 < v9) {
      ++v12;
    }
    else {
      unsigned int v12 = *(unsigned __int16 *)(a2 + 10);
    }
  }
  while (v13 < v9);
  unsigned int v14 = *(unsigned __int16 *)(a2 + 26);
  if (*(_WORD *)(a2 + 26))
  {
LABEL_12:
    uint64_t v15 = 0;
    unsigned int v16 = 0;
    uint64_t v17 = *(void *)(a2 + 16);
    do
    {
      if (v16 < v14)
      {
        uint64_t v15 = (unsigned __int8 *)(v17 + v16);
        uint64_t v4 = (void *)(v17 + *(unsigned __int16 *)(a2 + 24) + v16);
      }
      unint64_t v18 = ((v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + *v15) ^ v10;
      unint64_t v10 = (*(unsigned __int8 *)v4 - 0x61C8864680B583EBLL + (v18 << 6) + (v18 >> 2)) ^ v18;
      unsigned int v19 = v16 + 1;
      if (v16 + 1 < v14) {
        ++v16;
      }
      else {
        unsigned int v16 = v14;
      }
    }
    while (v19 < v14);
  }
LABEL_19:
  unsigned int v20 = *(unsigned __int16 *)(a2 + 42);
  if (*(_WORD *)(a2 + 42))
  {
    uint64_t v21 = 0;
    unsigned int v22 = 0;
    uint64_t v23 = *(void *)(a2 + 32);
    do
    {
      if (v22 < v20)
      {
        uint64_t v21 = (unsigned __int8 *)(v23 + v22);
        uint64_t v4 = (void *)(v23 + *(unsigned __int16 *)(a2 + 40) + 4 * v22);
      }
      unint64_t v24 = ((v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + *v21) ^ v10;
      unint64_t v10 = (*(unsigned int *)v4 - 0x61C8864680B583EBLL + (v24 << 6) + (v24 >> 2)) ^ v24;
      unsigned int v25 = v22 + 1;
      if (v22 + 1 < v20) {
        ++v22;
      }
      else {
        unsigned int v22 = *(unsigned __int16 *)(a2 + 42);
      }
    }
    while (v25 < v20);
  }
  unsigned int v26 = *(unsigned __int16 *)(a2 + 58);
  if (*(_WORD *)(a2 + 58))
  {
    unsigned int v27 = 0;
    unsigned int v28 = 0;
    uint64_t v29 = *(void *)(a2 + 48);
    do
    {
      if (v28 < v26)
      {
        unsigned int v27 = (unsigned __int8 *)(v29 + v28);
        uint64_t v4 = (void *)(v29 + *(unsigned __int16 *)(a2 + 56) + 8 * v28);
      }
      unint64_t v30 = ((v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + *v27) ^ v10;
      unint64_t v10 = (*v4 - 0x61C8864680B583EBLL + (v30 << 6) + (v30 >> 2)) ^ v30;
      unsigned int v31 = v28 + 1;
      if (v28 + 1 < v26) {
        ++v28;
      }
      else {
        unsigned int v28 = *(unsigned __int16 *)(a2 + 58);
      }
    }
    while (v31 < v26);
  }
  unsigned int v32 = *(unsigned __int16 *)(a2 + 74);
  if (*(_WORD *)(a2 + 74))
  {
    LODWORD(v6) = 0;
    uint64_t v33 = 0;
    uint64_t v34 = *(void *)(a2 + 64);
    uint64_t v35 = v34 + *(unsigned __int16 *)(a2 + 72);
    do
    {
      if (v6 < v32)
      {
        unsigned __int16 v5 = (unsigned __int8 *)(v35 + 16 * v6);
        uint64_t v33 = (unsigned __int8 *)(v34 + v6);
      }
      v10 ^= (v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + *v33;
      int v38 = *v5;
      if (v38 == 2)
      {
        uint64_t v43 = *((void *)v5 + 1);
        float v44 = *(float *)(v43 + 32);
        unint64_t v45 = (LODWORD(v44) - 0x61C8864680B57FA7) ^ 0x11;
        if (v44 == 0.0) {
          unint64_t v45 = 0x9E3779B97F4A8048;
        }
        uint64_t v46 = *(float **)v43;
        for (unint64_t i = *(float **)(v43 + 8); v46 != i; v45 ^= (v45 >> 2) + (v45 << 6) + v49)
        {
          float v48 = *v46++;
          uint64_t v49 = LODWORD(v48) - 0x61C8864680B583EBLL;
          if (v48 == 0.0) {
            uint64_t v49 = 0x9E3779B97F4A7C15;
          }
        }
        unint64_t v36 = (v10 << 6) - 0x61C8864680B583EBLL + (v10 >> 2) + v45;
      }
      else
      {
        if (v38 != 1) {
          goto LABEL_39;
        }
        uint64_t v39 = *((void *)v5 + 1);
        int v40 = *(char *)(v39 + 23);
        if (v40 >= 0) {
          uint64_t v41 = (uint64_t *)*((void *)v5 + 1);
        }
        else {
          uint64_t v41 = *(uint64_t **)v39;
        }
        if (v40 >= 0) {
          unint64_t v42 = *(unsigned __int8 *)(v39 + 23);
        }
        else {
          unint64_t v42 = *(void *)(v39 + 8);
        }
        unint64_t v36 = (v10 << 6)
            - 0x61C8864680B583EBLL
            + (v10 >> 2)
            + std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v41, v42);
      }
      v10 ^= v36;
LABEL_39:
      unsigned int v37 = v6 + 1;
      if ((int)v6 + 1 < v32) {
        unint64_t v6 = (v6 + 1);
      }
      else {
        unint64_t v6 = v32;
      }
    }
    while (v37 < v32);
  }
  unint64_t v50 = *(void *)(a1 + 8);
  if (v50)
  {
    uint8x8_t v51 = (uint8x8_t)vcnt_s8((int8x8_t)v50);
    v51.i16[0] = vaddlv_u8(v51);
    if (v51.u32[0] > 1uLL)
    {
      unint64_t v6 = v10;
      if (v10 >= v50) {
        unint64_t v6 = v10 % v50;
      }
    }
    else
    {
      unint64_t v6 = (v50 - 1) & v10;
    }
    unsigned int v52 = *(unsigned __int8 ***)(*(void *)a1 + 8 * v6);
    if (v52)
    {
      unsigned int v53 = *v52;
      if (*v52)
      {
        if (v51.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v55 = *((void *)v53 + 1);
            if (v55 == v10)
            {
              if (gss::StylePropertySet<gss::ScenePropertyID>::operator==((unsigned __int8 **)v53 + 2, (unsigned __int8 **)a2))return v53; {
            }
              }
            else if ((v55 & (v50 - 1)) != v6)
            {
              goto LABEL_83;
            }
            unsigned int v53 = *(unsigned __int8 **)v53;
            if (!v53) {
              goto LABEL_83;
            }
          }
        }
        do
        {
          unint64_t v54 = *((void *)v53 + 1);
          if (v54 == v10)
          {
            if (gss::StylePropertySet<gss::ScenePropertyID>::operator==((unsigned __int8 **)v53 + 2, (unsigned __int8 **)a2))return v53; {
          }
            }
          else
          {
            if (v54 >= v50) {
              v54 %= v50;
            }
            if (v54 != v6) {
              break;
            }
          }
          unsigned int v53 = *(unsigned __int8 **)v53;
        }
        while (v53);
      }
    }
  }
LABEL_83:
  uint64_t v56 = (void *)(a1 + 16);
  uint64_t v90 = operator new(0x68uLL);
  *uint64_t v90 = 0;
  v90[1] = v10;
  uint64_t v57 = *(void *)(a3 + 8);
  v90[2] = *(void *)a3;
  *((_DWORD *)v90 + 6) = v57;
  *((_WORD *)v90 + 14) = WORD2(v57);
  *((_WORD *)v90 + 15) = *(_WORD *)(a3 + 14);
  *(void *)(a3 + 7) = 0;
  *(void *)a3 = 0;
  uint64_t v58 = *(void *)(a3 + 24);
  v90[4] = *(void *)(a3 + 16);
  *((_DWORD *)v90 + 10) = v58;
  *((_WORD *)v90 + 22) = WORD2(v58);
  *((_WORD *)v90 + 23) = *(_WORD *)(a3 + 30);
  uint64_t v59 = *(void *)(a3 + 40);
  v90[6] = *(void *)(a3 + 32);
  *((_DWORD *)v90 + 14) = v59;
  *((_WORD *)v90 + 30) = WORD2(v59);
  *((_WORD *)v90 + 31) = *(_WORD *)(a3 + 46);
  uint64_t v60 = *(void *)(a3 + 56);
  v90[8] = *(void *)(a3 + 48);
  *((_DWORD *)v90 + 18) = v60;
  *((_WORD *)v90 + 38) = WORD2(v60);
  *((unsigned char *)v90 + 78) = *(unsigned char *)(a3 + 62);
  *((unsigned char *)v90 + 79) = *(unsigned char *)(a3 + 63);
  uint64_t v61 = *(void *)(a3 + 72);
  v90[10] = *(void *)(a3 + 64);
  *(unsigned char *)(a3 + 15) = 1;
  *(void *)(a3 + 16) = 0;
  *(void *)(a3 + 23) = 0;
  *(unsigned char *)(a3 + 31) = 1;
  *(void *)(a3 + 39) = 0;
  *(void *)(a3 + 32) = 0;
  *(unsigned char *)(a3 + 47) = 1;
  *(void *)(a3 + 48) = 0;
  *(void *)(a3 + 55) = 0;
  *(unsigned char *)(a3 + 63) = 1;
  *((_DWORD *)v90 + 22) = v61;
  *((_WORD *)v90 + 46) = WORD2(v61);
  *((unsigned char *)v90 + 94) = *(unsigned char *)(a3 + 78);
  *((unsigned char *)v90 + 95) = *(unsigned char *)(a3 + 79);
  *(void *)(a3 + 64) = 0;
  *(void *)(a3 + 71) = 0;
  *(unsigned char *)(a3 + 79) = 1;
  *((unsigned char *)v90 + 96) = *a4;
  float v62 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v63 = *(float *)(a1 + 32);
  if (!v50 || (float)(v63 * (float)v50) < v62)
  {
    BOOL v64 = v50 < 3 || (v50 & (v50 - 1)) != 0;
    unint64_t v65 = v64 | (2 * v50);
    unint64_t v66 = vcvtps_u32_f32(v62 / v63);
    if (v65 <= v66) {
      size_t prime = v66;
    }
    else {
      size_t prime = v65;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v50 = *(void *)(a1 + 8);
    if (prime <= v50)
    {
      if (prime >= v50) {
        goto LABEL_121;
      }
      unint64_t v78 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v50 < 3 || (uint8x8_t v79 = (uint8x8_t)vcnt_s8((int8x8_t)v50), v79.i16[0] = vaddlv_u8(v79), v79.u32[0] > 1uLL))
      {
        unint64_t v78 = std::__next_prime(v78);
      }
      else
      {
        uint64_t v80 = 1 << -(char)__clz(v78 - 1);
        if (v78 >= 2) {
          unint64_t v78 = v80;
        }
      }
      if (prime <= v78) {
        size_t prime = v78;
      }
      if (prime >= v50)
      {
        unint64_t v50 = *(void *)(a1 + 8);
LABEL_121:
        if ((v50 & (v50 - 1)) != 0)
        {
          if (v10 >= v50) {
            unint64_t v6 = v10 % v50;
          }
          else {
            unint64_t v6 = v10;
          }
        }
        else
        {
          unint64_t v6 = (v50 - 1) & v10;
        }
        goto LABEL_134;
      }
      if (!prime)
      {
        unsigned int v87 = *(void **)a1;
        *(void *)a1 = 0;
        if (v87) {
          operator delete(v87);
        }
        unint64_t v50 = 0;
        *(void *)(a1 + 8) = 0;
        goto LABEL_121;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v68 = operator new(8 * prime);
    uint64_t v69 = *(void **)a1;
    *(void *)a1 = v68;
    if (v69) {
      operator delete(v69);
    }
    uint64_t v70 = 0;
    *(void *)(a1 + 8) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v70++) = 0;
    while (prime != v70);
    unsigned int v71 = (void *)*v56;
    if (!*v56)
    {
LABEL_120:
      unint64_t v50 = prime;
      goto LABEL_121;
    }
    size_t v72 = v71[1];
    size_t v73 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v74 = v72 & v73;
      *(void *)(*(void *)a1 + 8 * v74) = v56;
      for (j = (void *)*v71; *v71; j = (void *)*v71)
      {
        size_t v76 = j[1] & v73;
        if (v76 == v74)
        {
          unsigned int v71 = j;
        }
        else if (*(void *)(*(void *)a1 + 8 * v76))
        {
          void *v71 = *j;
          uint64_t v77 = 8 * v76;
          void *j = **(void **)(*(void *)a1 + v77);
          **(void **)(*(void *)a1 + v77) = j;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v76) = v71;
          unsigned int v71 = j;
          size_t v74 = v76;
        }
      }
      goto LABEL_120;
    }
    if (v72 >= prime) {
      v72 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v72) = v56;
    BOOL v81 = (void *)*v71;
    if (!*v71) {
      goto LABEL_120;
    }
    while (1)
    {
      size_t v83 = v81[1];
      if (v83 >= prime) {
        v83 %= prime;
      }
      if (v83 != v72)
      {
        if (!*(void *)(*(void *)a1 + 8 * v83))
        {
          *(void *)(*(void *)a1 + 8 * v83) = v71;
          goto LABEL_125;
        }
        void *v71 = *v81;
        uint64_t v82 = 8 * v83;
        void *v81 = **(void **)(*(void *)a1 + v82);
        **(void **)(*(void *)a1 + v82) = v81;
        BOOL v81 = v71;
      }
      size_t v83 = v72;
LABEL_125:
      unsigned int v71 = v81;
      BOOL v81 = (void *)*v81;
      size_t v72 = v83;
      if (!v81) {
        goto LABEL_120;
      }
    }
  }
LABEL_134:
  uint64_t v84 = *(void **)(*(void *)a1 + 8 * v6);
  unsigned int v53 = (unsigned __int8 *)v90;
  if (v84)
  {
    *uint64_t v90 = *v84;
LABEL_142:
    *uint64_t v84 = v90;
    goto LABEL_143;
  }
  *uint64_t v90 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v90;
  *(void *)(*(void *)a1 + 8 * v6) = v56;
  if (*v90)
  {
    unint64_t v85 = *(void *)(*v90 + 8);
    if ((v50 & (v50 - 1)) != 0)
    {
      if (v85 >= v50) {
        v85 %= v50;
      }
    }
    else
    {
      v85 &= v50 - 1;
    }
    uint64_t v84 = (void *)(*(void *)a1 + 8 * v85);
    goto LABEL_142;
  }
LABEL_143:
  ++*(void *)(a1 + 24);
  return v53;
}

void sub_1A17D8E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gss::StylePropertySet<gss::PropertyID>,unsigned char>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t geo::intern_linear_map<gss::ScenePropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit(uint64_t result)
{
  if (!*(unsigned char *)(result + 14))
  {
    uint64_t v1 = result;
    int v2 = *(unsigned __int16 *)(result + 10);
    int v3 = *(unsigned __int8 *)(result + 15);
    if (v2 != *(unsigned __int16 *)(result + 12) || !*(unsigned char *)(result + 15))
    {
      unsigned __int16 v4 = (v2 & 0xFFF8) + 8;
      uint64_t v5 = gss::Allocator::instance((gss::Allocator *)result);
      uint64_t result = (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)(v4 + 8 * v2) & 0xFFF8, 1);
      uint64_t v6 = result;
      if (*(void *)v1)
      {
        geo::intern_linear_map<gss::ScenePropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(v1, (unsigned char *)result, (void *)(result + v4), v3 == 0);
        uint64_t v8 = gss::Allocator::instance(v7);
        uint64_t result = (*(uint64_t (**)(uint64_t, void, void))(*(void *)v8 + 40))(v8, *(void *)v1, *(unsigned __int16 *)(v1 + 12));
      }
      *(_WORD *)(v1 + 12) = v2;
      *(void *)uint64_t v1 = v6;
      *(_WORD *)(v1 + 8) = v4;
    }
  }
  return result;
}

gss::Allocator *geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit(gss::Allocator *result)
{
  if (!*((unsigned char *)result + 14))
  {
    uint64_t v1 = result;
    int v2 = *((unsigned __int16 *)result + 5);
    int v3 = *((unsigned __int8 *)result + 15);
    if (v2 != *((unsigned __int16 *)result + 6) || !*((unsigned char *)result + 15))
    {
      __int16 v4 = (v2 & 0xFFF8) + 8;
      uint64_t v5 = gss::Allocator::instance(result);
      uint64_t result = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v5 + 16))(v5, (unsigned __int16)(v4 + 16 * v2) & 0xFFF8, 1);
      uint64_t v6 = result;
      if (!*(void *)v1)
      {
LABEL_21:
        *((_WORD *)v1 + 6) = v2;
        *(void *)uint64_t v1 = v6;
        *((_WORD *)v1 + 4) = v4;
        return result;
      }
      unint64_t v7 = *((unsigned __int16 *)v1 + 5);
      if (!*((_WORD *)v1 + 5))
      {
LABEL_20:
        uint64_t v22 = gss::Allocator::instance(result);
        uint64_t result = (gss::Allocator *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v22 + 40))(v22, *(void *)v1, *((unsigned __int16 *)v1 + 6));
        goto LABEL_21;
      }
      uint64_t v8 = (unsigned __int16)((v2 & 0xFFF8) + 8);
      if (v3)
      {
        uint64_t result = (gss::Allocator *)memmove(result, *(const void **)v1, *((unsigned __int16 *)v1 + 5));
        if (*((_WORD *)v1 + 5)) {
          uint64_t result = (gss::Allocator *)memmove((char *)v6 + v8, (const void *)(*(void *)v1 + *((unsigned __int16 *)v1 + 4)), 16 * *((unsigned __int16 *)v1 + 5));
        }
        goto LABEL_20;
      }
      unsigned int v9 = (int32x4_t *)operator new(4 * v7);
      bzero(v9, 4 * v7);
      unint64_t v10 = (unsigned int *)v9 + v7;
      if (4 * v7 - 4 >= 0x1C)
      {
        unint64_t v13 = ((4 * v7 - 4) >> 2) + 1;
        uint64_t v11 = v13 & 0x7FFFFFFFFFFFFFF8;
        int32x4_t v14 = (int32x4_t)xmmword_1A28FC7A0;
        uint64_t v15 = v9 + 1;
        v16.i64[0] = 0x400000004;
        v16.i64[1] = 0x400000004;
        v17.i64[0] = 0x800000008;
        v17.i64[1] = 0x800000008;
        uint64_t v18 = v13 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          v15[-1] = v14;
          int32x4_t *v15 = vaddq_s32(v14, v16);
          int32x4_t v14 = vaddq_s32(v14, v17);
          v15 += 2;
          v18 -= 8;
        }
        while (v18);
        if (v13 == v11) {
          goto LABEL_16;
        }
        unsigned int v12 = (unsigned int *)v9 + (v13 & 0x7FFFFFFFFFFFFFF8);
      }
      else
      {
        LODWORD(v11) = 0;
        unsigned int v12 = (unsigned int *)v9;
      }
      do
      {
        *v12++ = v11;
        LODWORD(v11) = v11 + 1;
      }
      while (v12 != v10);
LABEL_16:
      uint64_t v23 = v1;
      std::__introsort<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::ScenePropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *,false>((uint64_t)v9, v10, (uint64_t **)&v23, 126 - 2 * __clz(v7), 1);
      if (*((_WORD *)v1 + 5))
      {
        unint64_t v19 = 0;
        do
        {
          uint64_t v20 = v9->u32[v19];
          uint64_t v21 = *(char **)v1;
          *((unsigned char *)v6 + v19) = *(unsigned char *)(*(void *)v1 + v20);
          *(_OWORD *)((char *)v6 + v8) = *(_OWORD *)&v21[16 * v20 + *((unsigned __int16 *)v1 + 4)];
          ++v19;
          v8 += 16;
        }
        while (v19 < *((unsigned __int16 *)v1 + 5));
      }
      *((unsigned char *)v1 + 15) = 1;
      operator delete(v9);
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t gss::StylePropertySet<gss::ScenePropertyID>::operator==(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unint64_t v4 = *((unsigned __int16 *)a1 + 5);
  if (v4 != *((unsigned __int16 *)a2 + 5)) {
    return 0;
  }
  if (*((_WORD *)a1 + 5))
  {
    uint64_t v6 = (uint64_t)*a1;
    uint64_t v7 = (uint64_t)*a2;
    if (**a1 != **a2) {
      return 0;
    }
    uint64_t v8 = *((unsigned __int16 *)a2 + 4);
    uint64_t v9 = *((unsigned __int16 *)a1 + 4);
    if (*(unsigned __int8 *)(v6 + v9) != *(unsigned __int8 *)(v7 + v8)) {
      return 0;
    }
    uint64_t v10 = v6 + v9;
    uint64_t v11 = v7 + v8;
    uint64_t v12 = 1;
    while (v4 != v12)
    {
      unint64_t v13 = v12;
      if (*(unsigned __int8 *)(v6 + v12) == *(unsigned __int8 *)(v7 + v12))
      {
        ++v12;
        if (*(unsigned __int8 *)(v10 + v13) == *(unsigned __int8 *)(v11 + v13)) {
          continue;
        }
      }
      if (v13 < v4) {
        return 0;
      }
      break;
    }
  }
  unint64_t v14 = *((unsigned __int16 *)a1 + 13);
  if (v14 == *((unsigned __int16 *)a2 + 13))
  {
    if (*((_WORD *)a1 + 13))
    {
      uint64_t v15 = a1[2];
      int32x4_t v16 = a2[2];
      if (*v15 != *v16) {
        return 0;
      }
      uint64_t v17 = *((unsigned __int16 *)a2 + 12);
      uint64_t v18 = *((unsigned __int16 *)a1 + 12);
      if (v15[v18] != v16[v17]) {
        return 0;
      }
      unint64_t v19 = &v15[v18];
      uint64_t v20 = &v16[v17];
      uint64_t v21 = 1;
      while (v14 != v21)
      {
        unint64_t v22 = v21;
        if (v15[v21] == v16[v21])
        {
          ++v21;
          if (v19[v22] == v20[v22]) {
            continue;
          }
        }
        if (v22 < v14) {
          return 0;
        }
        break;
      }
    }
    unint64_t v23 = *((unsigned __int16 *)a1 + 21);
    if (v23 == *((unsigned __int16 *)a2 + 21))
    {
      if (*((_WORD *)a1 + 21))
      {
        unint64_t v24 = a1[4];
        unsigned int v25 = a2[4];
        if (*v24 != *v25) {
          return 0;
        }
        unsigned int v26 = &v25[*((unsigned __int16 *)a2 + 20)];
        unsigned int v27 = &v24[*((unsigned __int16 *)a1 + 20)];
        if (*(_DWORD *)v27 != *(_DWORD *)v26) {
          return 0;
        }
        unint64_t v28 = 0;
        while (++v28 != v23)
        {
          if (v24[v28] != v25[v28] || *(_DWORD *)&v27[4 * v28] != *(_DWORD *)&v26[4 * v28])
          {
            if (v28 < v23) {
              return 0;
            }
            break;
          }
        }
      }
      unint64_t v29 = *((unsigned __int16 *)a1 + 29);
      if (v29 == *((unsigned __int16 *)a2 + 29))
      {
        if (*((_WORD *)a1 + 29))
        {
          unint64_t v30 = a1[6];
          unsigned int v31 = a2[6];
          if (*v30 != *v31) {
            return 0;
          }
          unsigned int v32 = &v31[*((unsigned __int16 *)a2 + 28)];
          uint64_t v33 = &v30[*((unsigned __int16 *)a1 + 28)];
          if (*(void *)v33 != *(void *)v32) {
            return 0;
          }
          unint64_t v34 = 0;
          while (++v34 != v29)
          {
            if (v30[v34] != v31[v34] || *(void *)&v33[8 * v34] != *(void *)&v32[8 * v34])
            {
              if (v34 < v29) {
                return 0;
              }
              break;
            }
          }
        }
        unsigned int v35 = *((unsigned __int16 *)a1 + 37);
        if (v35 == *((unsigned __int16 *)a2 + 37))
        {
          if (!*((_WORD *)a1 + 37)) {
            return 1;
          }
          unint64_t v36 = 0;
          unsigned int v37 = 0;
          int v38 = 0;
          unsigned int v39 = 0;
          int v40 = a2[8];
          uint64_t v41 = &v40[*((unsigned __int16 *)a2 + 36)];
          while (1)
          {
            if (v37 < v35)
            {
              float v44 = a1[8];
              unint64_t v36 = &v44[v37];
              int v3 = &v44[16 * v37 + *((unsigned __int16 *)a1 + 36)];
            }
            if (v39 < v35)
            {
              int v38 = &v40[v39];
              int v2 = &v41[16 * v39];
            }
            if (*v36 != *v38) {
              break;
            }
            int v45 = *v3;
            if (v45 != *v2) {
              break;
            }
            if (v45 == 2)
            {
              unsigned int v53 = (float *)*((void *)v3 + 1);
              unint64_t v54 = (float *)*((void *)v2 + 1);
              if (v53[8] != v54[8]) {
                return 0;
              }
              uint64_t v55 = *(void *)v53;
              uint64_t v56 = *(void *)(*((void *)v3 + 1) + 8);
              unint64_t v57 = (v56 - v55) >> 2;
              uint64_t v58 = *(void *)v54;
              if (v57 != (*(void *)(*((void *)v2 + 1) + 8) - v58) >> 2) {
                return 0;
              }
              if (v56 != v55)
              {
                unint64_t v59 = 0;
                unsigned int v60 = 1;
                while (vabds_f32(*(float *)(v55 + 4 * v59), *(float *)(v58 + 4 * v59)) <= 0.00000011921)
                {
                  unint64_t v59 = v60++;
                  if (v57 <= v59) {
                    goto LABEL_42;
                  }
                }
                return 0;
              }
            }
            else if (v45 == 1)
            {
              uint64_t v46 = (unsigned __int8 *)*((void *)v3 + 1);
              int v47 = (unsigned __int8 **)*((void *)v2 + 1);
              uint64_t v48 = v46[23];
              if ((v48 & 0x80u) == 0) {
                uint64_t v49 = (unsigned __int8 *)v46[23];
              }
              else {
                uint64_t v49 = (unsigned __int8 *)*((void *)v46 + 1);
              }
              unint64_t v50 = (unsigned __int8 *)*((unsigned __int8 *)v47 + 23);
              int v51 = (char)v50;
              if ((char)v50 < 0) {
                unint64_t v50 = v47[1];
              }
              if (v49 != v50) {
                return 0;
              }
              if (v51 >= 0) {
                unsigned int v52 = (unsigned __int8 *)*((void *)v2 + 1);
              }
              else {
                unsigned int v52 = *v47;
              }
              if ((v48 & 0x80) != 0)
              {
                if (memcmp(*(const void **)v46, v52, *((void *)v46 + 1))) {
                  return 0;
                }
              }
              else if (v46[23])
              {
                while (*v46 == *v52)
                {
                  ++v46;
                  ++v52;
                  if (!--v48) {
                    goto LABEL_42;
                  }
                }
                return 0;
              }
            }
LABEL_42:
            unsigned int v43 = v37 + 1;
            if (v39 + 1 < v35) {
              ++v39;
            }
            else {
              unsigned int v39 = v35;
            }
            uint64_t result = 1;
            if (v43 < v35) {
              ++v37;
            }
            else {
              unsigned int v37 = v35;
            }
            if (v43 >= v35) {
              return result;
            }
          }
        }
      }
    }
  }
  return 0;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::ScenePropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *,false>(uint64_t result, unsigned int *a2, uint64_t **a3, uint64_t a4, char a5)
{
  uint64_t v11 = (unsigned int *)result;
LABEL_2:
  uint64_t v12 = a2 - 1;
  unint64_t v13 = v11;
  while (1)
  {
    uint64_t v11 = v13;
    uint64_t v14 = (char *)a2 - (char *)v13;
    uint64_t v15 = a2 - v13;
    if (v6 || !v5)
    {
      switch(v15)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t v91 = *v12;
          uint64_t v92 = *v13;
          if (*(unsigned __int8 *)(**a3 + v91) < *(unsigned __int8 *)(**a3 + v92))
          {
            *unint64_t v13 = v91;
            *uint64_t v12 = v92;
          }
          return result;
        case 3:
          uint64_t v93 = *v13;
          uint64_t v94 = v13[1];
          uint64_t v95 = **a3;
          unsigned int v96 = *(unsigned __int8 *)(v95 + v94);
          unsigned int v97 = *(unsigned __int8 *)(v95 + v93);
          uint64_t v98 = *v12;
          unsigned int v99 = *(unsigned __int8 *)(v95 + v98);
          if (v96 >= v97)
          {
            if (v99 < v96)
            {
              v13[1] = v98;
              *uint64_t v12 = v94;
              uint64_t v135 = *v13;
              uint64_t v134 = v13[1];
              if (*(unsigned __int8 *)(v95 + v134) < *(unsigned __int8 *)(v95 + v135))
              {
                *unint64_t v13 = v134;
                v13[1] = v135;
              }
            }
          }
          else if (v99 >= v96)
          {
            *unint64_t v13 = v94;
            v13[1] = v93;
            uint64_t v160 = *v12;
            if (*(unsigned __int8 *)(v95 + v160) < v97)
            {
              v13[1] = v160;
              *uint64_t v12 = v93;
            }
          }
          else
          {
            *unint64_t v13 = v98;
            *uint64_t v12 = v93;
          }
          return result;
        case 4:
          unsigned int v101 = v13 + 1;
          uint64_t v102 = v13[1];
          uint64_t v103 = v13 + 2;
          uint64_t v104 = v13[2];
          unsigned int v105 = v13[1];
          uint64_t v106 = **a3;
          unsigned int v107 = *(unsigned __int8 *)(v106 + v102);
          uint64_t v108 = *v13;
          unsigned int v109 = *(unsigned __int8 *)(v106 + v108);
          unsigned int v110 = *(unsigned __int8 *)(v106 + v104);
          if (v107 >= v109)
          {
            if (v110 < v107)
            {
              _DWORD *v101 = v104;
              *uint64_t v103 = v102;
              uint64_t v111 = v13;
              uint64_t result = (uint64_t)(v13 + 1);
              if (v110 >= v109) {
                goto LABEL_173;
              }
              goto LABEL_171;
            }
          }
          else
          {
            if (v110 < v107)
            {
              uint64_t v111 = v13;
              uint64_t result = (uint64_t)(v13 + 2);
              uint64_t v102 = *v13;
              unsigned int v105 = *v13;
LABEL_171:
              *uint64_t v111 = v104;
              *(_DWORD *)uint64_t result = v108;
              goto LABEL_173;
            }
            uint64_t v111 = v13 + 1;
            *unint64_t v13 = v102;
            v13[1] = v108;
            uint64_t result = (uint64_t)(v13 + 2);
            uint64_t v102 = v108;
            unsigned int v105 = v108;
            if (v110 < v109) {
              goto LABEL_171;
            }
          }
          uint64_t v102 = v104;
          unsigned int v105 = v104;
LABEL_173:
          uint64_t v161 = *v12;
          if (*(unsigned __int8 *)(v106 + v161) < *(unsigned __int8 *)(v106 + v102))
          {
            *uint64_t v103 = v161;
            *uint64_t v12 = v105;
            uint64_t v162 = *v103;
            uint64_t v163 = *v101;
            unsigned int v164 = *(unsigned __int8 *)(v106 + v162);
            if (v164 < *(unsigned __int8 *)(v106 + v163))
            {
              v13[1] = v162;
              v13[2] = v163;
              uint64_t v165 = *v13;
              if (v164 < *(unsigned __int8 *)(v106 + v165))
              {
                *unint64_t v13 = v162;
                v13[1] = v165;
              }
            }
          }
          return result;
        case 5:
          uint64_t v100 = **a3;
          return (uint64_t)std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::ScenePropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::ScenePropertyID*,unsigned long long *,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v13, v13 + 1, v13 + 2, v13 + 3, a2 - 1, v100);
        default:
          JUMPOUT(0);
      }
    }
    if (v14 <= 95) {
      break;
    }
    if (!a4)
    {
      if (v13 != a2)
      {
        int64_t v122 = (unint64_t)(v15 - 2) >> 1;
        int64_t v123 = *a3;
        int64_t v124 = v122;
        do
        {
          if (v122 >= v124)
          {
            uint64_t v126 = (2 * v124) | 1;
            uint64_t v127 = &v13[v126];
            uint64_t v128 = *v127;
            if (2 * v124 + 2 < v15)
            {
              uint64_t v129 = *v123;
              if (*(unsigned __int8 *)(*v123 + v128) < *(unsigned __int8 *)(*v123 + v127[1]))
              {
                LODWORD(v128) = v127[1];
                ++v127;
                uint64_t v126 = 2 * v124 + 2;
              }
            }
            else
            {
              uint64_t v129 = *v123;
            }
            uint64_t v130 = &v13[v124];
            uint64_t v131 = *v130;
            uint64_t result = *(unsigned __int8 *)(v129 + v131);
            if (*(unsigned __int8 *)(v129 + v128) >= result)
            {
              do
              {
                uint64_t v132 = v127;
                *uint64_t v130 = v128;
                if (v122 < v126) {
                  break;
                }
                uint64_t v133 = (2 * v126) | 1;
                uint64_t v127 = &v13[v133];
                uint64_t v126 = 2 * v126 + 2;
                uint64_t v128 = *v127;
                if (v126 < v15)
                {
                  if (*(unsigned __int8 *)(v129 + v128) >= *(unsigned __int8 *)(v129 + v127[1]))
                  {
                    uint64_t v126 = v133;
                  }
                  else
                  {
                    LODWORD(v128) = v127[1];
                    ++v127;
                  }
                }
                else
                {
                  uint64_t v126 = v133;
                }
                uint64_t v130 = v132;
              }
              while (*(unsigned __int8 *)(v129 + v128) >= result);
              *uint64_t v132 = v131;
            }
          }
          BOOL v125 = v124-- <= 0;
        }
        while (!v125);
        uint64_t v142 = (unint64_t)v14 >> 2;
        do
        {
          uint64_t v143 = 0;
          unsigned int v144 = *v13;
          unsigned int v145 = *a3;
          uint64_t v146 = v13;
          do
          {
            unsigned int v149 = &v146[v143];
            unsigned int v150 = v149[1];
            uint64_t v148 = v149 + 1;
            uint64_t v147 = v150;
            uint64_t v151 = (2 * v143) | 1;
            uint64_t v143 = 2 * v143 + 2;
            if (v143 < v142)
            {
              uint64_t result = v148[1];
              if (*(unsigned __int8 *)(*v145 + v147) >= *(unsigned __int8 *)(*v145 + result))
              {
                uint64_t v143 = v151;
              }
              else
              {
                LODWORD(v147) = v148[1];
                ++v148;
              }
            }
            else
            {
              uint64_t v143 = v151;
            }
            unsigned int *v146 = v147;
            uint64_t v146 = v148;
          }
          while (v143 <= (uint64_t)((unint64_t)(v142 - 2) >> 1));
          if (v148 == --a2)
          {
            unsigned int *v148 = v144;
          }
          else
          {
            unsigned int *v148 = *a2;
            *a2 = v144;
            uint64_t v152 = (char *)v148 - (char *)v13 + 4;
            if (v152 >= 5)
            {
              unint64_t v153 = (((unint64_t)v152 >> 2) - 2) >> 1;
              unint64_t v154 = &v13[v153];
              uint64_t v155 = *v154;
              uint64_t v156 = *v148;
              uint64_t v157 = *v145;
              unsigned int v158 = *(unsigned __int8 *)(v157 + v156);
              if (*(unsigned __int8 *)(v157 + v155) < v158)
              {
                do
                {
                  unsigned int v159 = v154;
                  unsigned int *v148 = v155;
                  if (!v153) {
                    break;
                  }
                  unint64_t v153 = (v153 - 1) >> 1;
                  unint64_t v154 = &v13[v153];
                  uint64_t v155 = *v154;
                  uint64_t v148 = v159;
                }
                while (*(unsigned __int8 *)(v157 + v155) < v158);
                *unsigned int v159 = v156;
              }
            }
          }
          BOOL v125 = v142-- <= 2;
        }
        while (!v125);
      }
      return result;
    }
    unint64_t v16 = (unint64_t)v15 >> 1;
    uint64_t v17 = &v13[(unint64_t)v15 >> 1];
    uint64_t v18 = **a3;
    uint64_t v19 = *v12;
    unsigned int v20 = *(unsigned __int8 *)(v18 + v19);
    if ((unint64_t)v14 >= 0x201)
    {
      uint64_t v21 = *v17;
      uint64_t v22 = *v13;
      unsigned int v23 = *(unsigned __int8 *)(v18 + v21);
      unsigned int v24 = *(unsigned __int8 *)(v18 + v22);
      if (v23 >= v24)
      {
        if (v20 < v23)
        {
          *uint64_t v17 = v19;
          *uint64_t v12 = v21;
          uint64_t v29 = *v17;
          uint64_t v30 = *v13;
          if (*(unsigned __int8 *)(v18 + v29) < *(unsigned __int8 *)(v18 + v30))
          {
            *unint64_t v13 = v29;
            *uint64_t v17 = v30;
          }
        }
      }
      else
      {
        if (v20 < v23)
        {
          *unint64_t v13 = v19;
          goto LABEL_22;
        }
        *unint64_t v13 = v21;
        *uint64_t v17 = v22;
        uint64_t v33 = *v12;
        if (*(unsigned __int8 *)(v18 + v33) < v24)
        {
          *uint64_t v17 = v33;
LABEL_22:
          *uint64_t v12 = v22;
        }
      }
      unint64_t v34 = &v13[v16];
      unsigned int v37 = *(v34 - 1);
      unsigned int v35 = v34 - 1;
      unsigned int v36 = v37;
      uint64_t v38 = v13[1];
      unsigned int v39 = *(unsigned __int8 *)(v18 + v37);
      unsigned int v40 = *(unsigned __int8 *)(v18 + v38);
      uint64_t v41 = *(a2 - 2);
      unsigned int v42 = *(unsigned __int8 *)(v18 + v41);
      if (v39 >= v40)
      {
        if (v42 < v39)
        {
          unsigned int *v35 = v41;
          *(a2 - 2) = v36;
          uint64_t v43 = *v35;
          uint64_t v44 = v13[1];
          if (*(unsigned __int8 *)(v18 + v43) < *(unsigned __int8 *)(v18 + v44))
          {
            v13[1] = v43;
            unsigned int *v35 = v44;
          }
        }
      }
      else
      {
        if (v42 < v39)
        {
          v13[1] = v41;
          goto LABEL_34;
        }
        v13[1] = v36;
        unsigned int *v35 = v38;
        uint64_t v46 = *(a2 - 2);
        if (*(unsigned __int8 *)(v18 + v46) < v40)
        {
          unsigned int *v35 = v46;
LABEL_34:
          *(a2 - 2) = v38;
        }
      }
      int v47 = &v13[v16];
      unsigned int v50 = v47[1];
      uint64_t v48 = v47 + 1;
      unsigned int v49 = v50;
      uint64_t v51 = v13[2];
      unsigned int v52 = *(unsigned __int8 *)(v18 + v50);
      unsigned int v53 = *(unsigned __int8 *)(v18 + v51);
      uint64_t v54 = *(a2 - 3);
      unsigned int v55 = *(unsigned __int8 *)(v18 + v54);
      if (v52 >= v53)
      {
        if (v55 < v52)
        {
          unsigned int *v48 = v54;
          *(a2 - 3) = v49;
          uint64_t v56 = *v48;
          uint64_t v57 = v13[2];
          if (*(unsigned __int8 *)(v18 + v56) < *(unsigned __int8 *)(v18 + v57))
          {
            v13[2] = v56;
            unsigned int *v48 = v57;
          }
        }
      }
      else
      {
        if (v55 < v52)
        {
          v13[2] = v54;
          goto LABEL_43;
        }
        v13[2] = v49;
        unsigned int *v48 = v51;
        uint64_t v58 = *(a2 - 3);
        if (*(unsigned __int8 *)(v18 + v58) < v53)
        {
          unsigned int *v48 = v58;
LABEL_43:
          *(a2 - 3) = v51;
        }
      }
      uint64_t v59 = *v17;
      uint64_t v60 = *v35;
      unsigned int v61 = *(unsigned __int8 *)(v18 + v59);
      unsigned int v62 = *(unsigned __int8 *)(v18 + v60);
      uint64_t v63 = *v48;
      unsigned int v64 = *(unsigned __int8 *)(v18 + v63);
      if (v61 >= v62)
      {
        if (v64 >= v61) {
          goto LABEL_51;
        }
        *uint64_t v17 = v63;
        unsigned int *v48 = v59;
        uint64_t v48 = v17;
        LODWORD(v59) = v60;
        if (v64 >= v62)
        {
          LODWORD(v59) = v63;
          goto LABEL_51;
        }
      }
      else if (v64 >= v61)
      {
        unsigned int *v35 = v59;
        *uint64_t v17 = v60;
        unsigned int v35 = v17;
        LODWORD(v59) = v63;
        if (v64 >= v62)
        {
          LODWORD(v59) = v60;
LABEL_51:
          unsigned int v65 = *v13;
          *unint64_t v13 = v59;
          *uint64_t v17 = v65;
          goto LABEL_52;
        }
      }
      unsigned int *v35 = v63;
      unsigned int *v48 = v60;
      goto LABEL_51;
    }
    uint64_t v25 = *v13;
    uint64_t v26 = *v17;
    unsigned int v27 = *(unsigned __int8 *)(v18 + v25);
    unsigned int v28 = *(unsigned __int8 *)(v18 + v26);
    if (v27 >= v28)
    {
      if (v20 < v27)
      {
        *unint64_t v13 = v19;
        *uint64_t v12 = v25;
        uint64_t v31 = *v13;
        uint64_t v32 = *v17;
        if (*(unsigned __int8 *)(v18 + v31) < *(unsigned __int8 *)(v18 + v32))
        {
          *uint64_t v17 = v31;
          *unint64_t v13 = v32;
        }
      }
      goto LABEL_52;
    }
    if (v20 < v27)
    {
      *uint64_t v17 = v19;
LABEL_31:
      *uint64_t v12 = v26;
      goto LABEL_52;
    }
    *uint64_t v17 = v25;
    *unint64_t v13 = v26;
    uint64_t v45 = *v12;
    if (*(unsigned __int8 *)(v18 + v45) < v28)
    {
      *unint64_t v13 = v45;
      goto LABEL_31;
    }
LABEL_52:
    --a4;
    uint64_t v66 = *v13;
    if (a5)
    {
      unsigned int v67 = *(unsigned __int8 *)(v18 + v66);
LABEL_55:
      uint64_t v68 = v13;
      do
      {
        uint64_t v69 = v68;
        unsigned int v71 = v68[1];
        ++v68;
        unsigned int v70 = v71;
      }
      while (*(unsigned __int8 *)(v18 + v71) < v67);
      size_t v72 = a2;
      if (v69 == v13)
      {
        size_t v72 = a2;
        do
        {
          if (v68 >= v72) {
            break;
          }
          unsigned int v74 = *--v72;
        }
        while (*(unsigned __int8 *)(v18 + v74) >= v67);
      }
      else
      {
        do
          unsigned int v73 = *--v72;
        while (*(unsigned __int8 *)(v18 + v73) >= v67);
      }
      if (v68 < v72)
      {
        unsigned int v75 = *v72;
        unsigned int v76 = v70;
        uint64_t v77 = v68;
        unint64_t v78 = v72;
        do
        {
          *uint64_t v77 = v75;
          *unint64_t v78 = v76;
          do
          {
            uint64_t v69 = v77;
            unsigned int v79 = v77[1];
            ++v77;
            unsigned int v76 = v79;
          }
          while (*(unsigned __int8 *)(v18 + v79) < v67);
          do
          {
            unsigned int v80 = *--v78;
            unsigned int v75 = v80;
          }
          while (*(unsigned __int8 *)(v18 + v80) >= v67);
        }
        while (v77 < v78);
      }
      if (v69 != v13) {
        *unint64_t v13 = *v69;
      }
      *uint64_t v69 = v66;
      if (v68 < v72) {
        goto LABEL_74;
      }
      BOOL v81 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::ScenePropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v13, v69, *a3);
      unint64_t v13 = v69 + 1;
      uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::ScenePropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *>(v69 + 1, a2, *a3);
      if (result)
      {
        a2 = v69;
        if (v81) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v81)
      {
LABEL_74:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,geo::intern_linear_map<gss::ScenePropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::moveContent(gss::ScenePropertyID*,gss::StylePropertySetInternObject*,BOOL)::{lambda(unsigned long,unsigned long)#1} &,unsigned int *,false>(v11, v69, a3, a4, a5 & 1);
        a5 = 0;
        unint64_t v13 = v69 + 1;
      }
    }
    else
    {
      unsigned int v67 = *(unsigned __int8 *)(v18 + v66);
      if (*(unsigned __int8 *)(v18 + *(v13 - 1)) < v67) {
        goto LABEL_55;
      }
      if (v67 < *(unsigned __int8 *)(v18 + *v12))
      {
        do
        {
          unsigned int v82 = v13[1];
          ++v13;
        }
        while (v67 >= *(unsigned __int8 *)(v18 + v82));
      }
      else
      {
        size_t v83 = v13 + 1;
        do
        {
          unint64_t v13 = v83;
          if (v83 >= a2) {
            break;
          }
          ++v83;
        }
        while (v67 >= *(unsigned __int8 *)(v18 + *v13));
      }
      uint64_t v84 = a2;
      if (v13 < a2)
      {
        uint64_t v84 = a2;
        do
          unsigned int v85 = *--v84;
        while (v67 < *(unsigned __int8 *)(v18 + v85));
      }
      if (v13 < v84)
      {
        unsigned int v86 = *v13;
        unsigned int v87 = *v84;
        do
        {
          *unint64_t v13 = v87;
          *uint64_t v84 = v86;
          do
          {
            unsigned int v88 = v13[1];
            ++v13;
            unsigned int v86 = v88;
          }
          while (v67 >= *(unsigned __int8 *)(v18 + v88));
          do
          {
            unsigned int v89 = *--v84;
            unsigned int v87 = v89;
          }
          while (v67 < *(unsigned __int8 *)(v18 + v89));
        }
        while (v13 < v84);
      }
      uint64_t v90 = v13 - 1;
      BOOL v5 = v13 - 1 >= v11;
      BOOL v6 = v13 - 1 == v11;
      if (v13 - 1 != v11) {
        *uint64_t v11 = *v90;
      }
      a5 = 0;
      *uint64_t v90 = v66;
    }
  }
  if (a5)
  {
    if (v13 != a2)
    {
      uint64_t v112 = v13 + 1;
      if (v13 + 1 != a2)
      {
        uint64_t v113 = **a3;
        uint64_t v114 = 4;
        uint64_t v115 = v13;
        do
        {
          uint64_t v118 = *v115;
          uint64_t v117 = v115[1];
          uint64_t v115 = v112;
          unsigned int v119 = *(unsigned __int8 *)(v113 + v117);
          if (v119 < *(unsigned __int8 *)(v113 + v118))
          {
            uint64_t v120 = v114;
            do
            {
              *(unsigned int *)((char *)v13 + v120) = v118;
              uint64_t v121 = v120 - 4;
              if (v120 == 4)
              {
                char v116 = v13;
                goto LABEL_112;
              }
              uint64_t v118 = *(unsigned int *)((char *)v13 + v120 - 8);
              v120 -= 4;
            }
            while (v119 < *(unsigned __int8 *)(v113 + v118));
            char v116 = (unsigned int *)((char *)v13 + v121);
LABEL_112:
            unsigned int *v116 = v117;
          }
          uint64_t v112 = v115 + 1;
          v114 += 4;
        }
        while (v115 + 1 != a2);
      }
    }
  }
  else if (v13 != a2)
  {
    uint64_t v136 = v13 + 1;
    if (v13 + 1 != a2)
    {
      uint64_t v137 = **a3;
      do
      {
        uint64_t v139 = *v11;
        uint64_t v138 = v11[1];
        uint64_t v11 = v136;
        unsigned int v140 = *(unsigned __int8 *)(v137 + v138);
        if (v140 < *(unsigned __int8 *)(v137 + v139))
        {
          unsigned int v141 = v11;
          do
          {
            unsigned int *v141 = v139;
            uint64_t v139 = *(v141 - 2);
            --v141;
          }
          while (v140 < *(unsigned __int8 *)(v137 + v139));
          unsigned int *v141 = v138;
        }
        uint64_t v136 = v11 + 1;
      }
      while (v11 + 1 != a2);
    }
  }
  return result;
}

void *geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator=(unsigned char *a1, uint64_t a2)
{
  int v3 = a1;
  if (a1 != (unsigned char *)a2)
  {
    if (!a1[14] && *(void *)a1)
    {
      uint64_t v5 = gss::Allocator::instance((gss::Allocator *)a1);
      a1 = (unsigned char *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v5 + 40))(v5, *v3, *((unsigned __int16 *)v3 + 6));
    }
    *(void *)((char *)v3 + 7) = 0;
    *int v3 = 0;
    *((unsigned char *)v3 + 15) = 1;
    if (*(unsigned char *)(a2 + 14))
    {
      *int v3 = *(void *)a2;
      *((_DWORD *)v3 + 2) = *(_DWORD *)(a2 + 8);
    }
    else
    {
      __int16 v7 = *(_WORD *)(a2 + 10);
      if (v7)
      {
        unsigned __int16 v8 = v7 + 1;
        uint64_t v9 = gss::Allocator::instance((gss::Allocator *)a1);
        uint64_t v10 = (char *)(*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)v9 + 16))(v9, (unsigned __int16)(v7 + 1 + v7), 1);
        uint64_t v11 = v10;
        if (*v3)
        {
          if (*((_WORD *)v3 + 5))
          {
            uint64_t v10 = (char *)memmove(v10, (const void *)*v3, *((unsigned __int16 *)v3 + 5));
            if (*((_WORD *)v3 + 5)) {
              uint64_t v10 = (char *)memmove(&v11[v8], (const void *)(*v3 + *((unsigned __int16 *)v3 + 4)), *((unsigned __int16 *)v3 + 5));
            }
          }
          uint64_t v12 = gss::Allocator::instance((gss::Allocator *)v10);
          (*(void (**)(uint64_t, void, void))(*(void *)v12 + 40))(v12, *v3, *((unsigned __int16 *)v3 + 6));
        }
        *((_WORD *)v3 + 6) = v7;
        *int v3 = v11;
        *((_WORD *)v3 + 4) = v8;
        int v13 = *(unsigned __int16 *)(a2 + 10);
        if (*(_WORD *)(a2 + 10))
        {
          unsigned int v14 = 0;
          uint64_t v15 = 0;
          do
          {
            if (!geo::intern_linear_map<gss::ScenePropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::isSpaceAvailable((unsigned __int16 *)v3)) {
              break;
            }
            if (v14 < *(unsigned __int16 *)(a2 + 10))
            {
              uint64_t v15 = (unsigned char *)(*(void *)a2 + v14);
              int v2 = &v15[*(unsigned __int16 *)(a2 + 8)];
            }
            uint64_t v16 = *((unsigned __int16 *)v3 + 5);
            uint64_t v17 = (unsigned char *)*v3;
            v17[v16] = *v15;
            v17[*((unsigned __int16 *)v3 + 4) + v16] = *v2;
            ++*((_WORD *)v3 + 5);
            if (v14 + 1 < *(unsigned __int16 *)(a2 + 10)) {
              ++v14;
            }
            else {
              unsigned int v14 = *(unsigned __int16 *)(a2 + 10);
            }
          }
          while (v14 != v13);
        }
      }
    }
    *((_WORD *)v3 + 7) = *(_WORD *)(a2 + 14);
  }
  return v3;
}

uint64_t ggl::MetalResourceAccessor::beginAccess(uint64_t a1, std::mutex *this, uint64_t a3, uint64_t a4, int a5, int a6)
{
  ggl::BufferData::prepareBufferForDevice(this, *(ggl::Device **)(a1 + 8), a6 == 1);
  int v12 = this->__m_.__opaque[8];
  int v13 = ~v12 & 6;
  int v14 = v12 & 1;
  if (v13) {
    BOOL v15 = a6 == 1;
  }
  else {
    BOOL v15 = 0;
  }
  if (!v15 || v14 == 0)
  {
    if (a4 == a3) {
      return 0;
    }
    else {
      return *(void *)this[1].__m_.__opaque + a3;
    }
  }
  else
  {
    uint64_t v18 = *(void *)&this->__m_.__opaque[32] + a3;
    uint64_t v19 = *(const ggl::Buffer **)&this->__m_.__opaque[16];
    if (a5 == 3 || (unsigned int v20 = (uint64_t *)*((void *)v19 + 3)) == 0) {
      unsigned int v20 = ggl::MetalResourceManager::newBuffer(*(ggl::MetalResourceManager **)(*(void *)(a1 + 8) + 80), v19);
    }
    return [(id)v20[4] contents] + v18;
  }
}

void *ggl::RenderItem::gatherTextureLoadItems(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = a1;
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  uint64_t result = *(void **)(a1 + 32);
  if (result)
  {
    uint64_t v5 = result[12];
    if (v5 != result[13])
    {
      unint64_t v8 = 0;
      uint64_t v9 = (_OWORD *)((char *)&v120 + 4);
      uint64_t v10 = &v121;
      do
      {
        uint64_t v11 = *(void *)(v5 + 8 * v8);
        if (!v11 || !(*(unsigned int (**)(void *, unint64_t))(*result + 24))(result, v8)) {
          goto LABEL_6;
        }
        if (*(void *)(v11 + 24) == 3735927469 && os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR))
        {
          uint64_t v113 = *(void *)(v3 + 16);
          *(_DWORD *)buf = 134218498;
          *(void *)&buf[4] = v11;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = v113;
          __int16 v119 = 1024;
          LODWORD(v120) = a3;
          _os_log_error_impl(&dword_1A1780000, MEMORY[0x1E4F14500], OS_LOG_TYPE_ERROR, "Detected stale texture resource %p in render item %s within command buffer %d Please file a radar!", buf, 0x1Cu);
        }
        int v12 = *(_DWORD *)(v11 + 56);
        if (v12 == 3)
        {
          if (*(void *)(v11 + 96)) {
            BOOL v16 = *(void *)(v11 + 112) == 0;
          }
          else {
            BOOL v16 = 1;
          }
          BOOL v20 = v16
             || *(void *)(v11 + 128) == 0
             || *(void *)(v11 + 144) == 0
             || *(void *)(v11 + 160) == 0
             || *(void *)(v11 + 176) == 0;
          if (v20 || *(unsigned char *)(v11 + 193)) {
            goto LABEL_6;
          }
          ggl::TextureCube::vendImplicitLoadItems(v11, (uint64_t *)a2);
          int v14 = (unsigned char *)(v11 + 193);
          goto LABEL_5;
        }
        if (v12 != 2)
        {
          if (v12 != 1 || !*(void *)(v11 + 112) || *(unsigned char *)(v11 + 129)) {
            goto LABEL_6;
          }
          ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)buf, v11);
          unint64_t v13 = *(void *)(a2 + 8);
          if (v13 >= *(void *)(a2 + 16))
          {
            BOOL v15 = std::vector<ggl::Texture2DLoadItem,geo::StdAllocator<ggl::Texture2DLoadItem,ggl::Allocator>>::__emplace_back_slow_path<ggl::Texture2DLoadItem>((char **)a2, (uint64_t)buf);
            int v14 = (unsigned char *)(v11 + 129);
          }
          else
          {
            int v14 = (unsigned char *)(v11 + 129);
            if (!v13)
            {
LABEL_26:
              BOOL v15 = (char *)(v13 + 80);
              goto LABEL_127;
            }
            *(_OWORD *)unint64_t v13 = *(_OWORD *)buf;
            *(unsigned char *)(v13 + 16) = 0;
            if (buf[16])
            {
              *(unsigned char *)(v13 + 17) = buf[17];
              *(unsigned char *)(v13 + 16) = 1;
            }
            *(unsigned char *)(v13 + 20) = 0;
            if (buf[20])
            {
              *(_DWORD *)(v13 + 24) = v120;
              *(unsigned char *)(v13 + 20) = 1;
            }
            *(_OWORD *)(v13 + 28) = *v9;
            if (v122)
            {
              if (v122 != v10)
              {
                *(void *)(v13 + 72) = v122;
                int64_t v122 = 0;
                goto LABEL_26;
              }
              *(void *)(v13 + 72) = v13 + 48;
              (*(void (**)(uint64_t *))(*v122 + 24))(v122);
              BOOL v15 = (char *)(v13 + 80);
            }
            else
            {
              *(void *)(v13 + 72) = 0;
              BOOL v15 = (char *)(v13 + 80);
            }
          }
LABEL_127:
          *(void *)(a2 + 8) = v15;
          if (v122 == v10)
          {
            (*(void (**)(uint64_t *))(v121 + 32))(v10);
          }
          else if (v122)
          {
            (*(void (**)(void))(*v122 + 40))();
          }
          goto LABEL_5;
        }
        uint64_t v21 = *(unsigned int *)(v11 + 88);
        if (!v21)
        {
          int v25 = *(unsigned __int8 *)(v11 + 129);
          int v14 = (unsigned char *)(v11 + 129);
          if (v25) {
            goto LABEL_6;
          }
          goto LABEL_5;
        }
        uint64_t v22 = *(void *)(v11 + 96);
        if (v21 >= 9)
        {
          if (v21 >= 0x21)
          {
            unint64_t v26 = 32;
            if ((v21 & 0x1F) != 0) {
              unint64_t v26 = v21 & 0x1F;
            }
            uint64_t v23 = v21 - v26;
            unsigned int v27 = (const double *)(v22 + 256);
            v28.i64[0] = 0x101010101010101;
            v28.i64[1] = 0x101010101010101;
            uint64_t v29 = *(unsigned int *)(v11 + 88);
            v30.i64[0] = 0x101010101010101;
            v30.i64[1] = 0x101010101010101;
            do
            {
              uint64_t v31 = v27 - 32;
              unsigned long long v32 = (unsigned __int128)vld2q_f64(v31);
              uint64_t v33 = v27 - 28;
              unsigned long long v34 = (unsigned __int128)vld2q_f64(v33);
              unsigned int v35 = v27 - 24;
              unsigned long long v36 = (unsigned __int128)vld2q_f64(v35);
              unsigned int v37 = v27 - 20;
              unsigned long long v38 = (unsigned __int128)vld2q_f64(v37);
              unsigned int v39 = v27 - 16;
              unsigned long long v40 = (unsigned __int128)vld2q_f64(v39);
              uint64_t v41 = v27 - 12;
              unsigned long long v42 = (unsigned __int128)vld2q_f64(v41);
              uint64_t v43 = v27 - 8;
              unsigned long long v44 = (unsigned __int128)vld2q_f64(v43);
              uint64_t v45 = v27 - 4;
              unsigned long long v46 = (unsigned __int128)vld2q_f64(v45);
              int v47 = v27;
              unsigned long long v48 = (unsigned __int128)vld2q_f64(v47);
              v47 += 4;
              unsigned int v49 = v27 + 20;
              unsigned long long v50 = (unsigned __int128)vld2q_f64(v49);
              uint64_t v51 = v27 + 24;
              unsigned long long v52 = (unsigned __int128)vld2q_f64(v51);
              unsigned int v53 = v27 + 28;
              unsigned long long v54 = (unsigned __int128)vld2q_f64(v53);
              int8x16_t v55 = vuzp1q_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v32), (int32x4_t)vceqzq_s64((int64x2_t)v34)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v36), (int32x4_t)vceqzq_s64((int64x2_t)v38)))), vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v40), (int32x4_t)vceqzq_s64((int64x2_t)v42)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v44), (int32x4_t)vceqzq_s64((int64x2_t)v46)))));
              uint64_t v56 = v27 + 16;
              unsigned long long v57 = (unsigned __int128)vld2q_f64(v56);
              uint64_t v58 = v27 + 12;
              int16x8_t v59 = (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v57), (int32x4_t)vceqzq_s64((int64x2_t)v50));
              unsigned long long v60 = (unsigned __int128)vld2q_f64(v58);
              unsigned int v61 = v27 + 8;
              int8x16_t v62 = (int8x16_t)vuzp1q_s16(v59, (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v52), (int32x4_t)vceqzq_s64((int64x2_t)v54)));
              int32x4_t v63 = (int32x4_t)vceqzq_s64((int64x2_t)v60);
              unsigned long long v64 = (unsigned __int128)vld2q_f64(v61);
              int16x8_t v65 = (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v64), v63);
              unsigned long long v66 = (unsigned __int128)vld2q_f64(v47);
              int8x16_t v28 = vandq_s8(v28, v55);
              int8x16_t v30 = vandq_s8(v30, vuzp1q_s8(vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v48), (int32x4_t)vceqzq_s64((int64x2_t)v66)), v65)), vmvnq_s8(v62)));
              v29 -= 32;
              v27 += 64;
            }
            while (v26 != v29);
            LOBYTE(v24) = vminvq_u8((uint8x16_t)vcltzq_s8(vshlq_n_s8(vandq_s8(v30, v28), 7uLL)));
            if (v26 < 9) {
              goto LABEL_62;
            }
          }
          else
          {
            uint64_t v23 = 0;
            LOBYTE(v24) = 1;
          }
          uint64_t v67 = 8;
          if ((v21 & 7) != 0) {
            uint64_t v67 = v21 & 7;
          }
          uint64_t v68 = v67 + v23;
          uint64_t v69 = (const double *)(v22 + 16 * v23);
          uint64_t v23 = v21 - v67;
          int8x8_t v70 = (int8x8_t)-1;
          v70.i8[0] = v24;
          uint64_t v71 = v68 - v21;
          do
          {
            size_t v72 = v69;
            unsigned long long v73 = (unsigned __int128)vld2q_f64(v72);
            v72 += 4;
            unsigned long long v74 = (unsigned __int128)vld2q_f64(v72);
            unsigned int v75 = v69 + 8;
            unsigned long long v76 = (unsigned __int128)vld2q_f64(v75);
            uint64_t v77 = v69 + 12;
            unsigned long long v78 = (unsigned __int128)vld2q_f64(v77);
            int8x8_t v70 = vand_s8(v70, vmovn_s16((int16x8_t)vmvnq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v73), (int32x4_t)vceqzq_s64((int64x2_t)v74)), (int16x8_t)vuzp1q_s32((int32x4_t)vceqzq_s64((int64x2_t)v76), (int32x4_t)vceqzq_s64((int64x2_t)v78))))));
            v69 += 16;
            v71 += 8;
          }
          while (v71);
          LOBYTE(v24) = vminv_u8((uint8x8_t)vcltz_s8(vshl_n_s8(v70, 7uLL)));
        }
        else
        {
          uint64_t v23 = 0;
          LOBYTE(v24) = 1;
        }
LABEL_62:
        uint64_t v79 = v21 - v23;
        unsigned int v80 = (uint64_t *)(v22 + 16 * v23);
        do
        {
          uint64_t v81 = *v80;
          v80 += 2;
          int v24 = v24 & (v81 != 0);
          --v79;
        }
        while (v79);
        if (!v24 || *(unsigned char *)(v11 + 129)) {
          goto LABEL_6;
        }
        uint64_t v114 = v10;
        uint64_t v115 = v9;
        uint64_t v116 = v3;
        int v117 = a3;
        unint64_t v82 = 0;
        unint64_t v83 = *(void *)(a2 + 8);
        do
        {
          uint64_t v84 = *(void *)(*(void *)(v11 + 96) + 16 * v82);
          uint64_t v85 = *(void *)(v11 + 80);
          unint64_t v86 = *(void *)(a2 + 16);
          if (v83 < v86)
          {
            if (v83)
            {
              unsigned int v87 = operator new(0x20uLL);
              void *v87 = &unk_1EF56B8D8;
              v87[1] = ggl::Texture2DArray::onImplicitLoadComplete;
              v87[2] = 0;
              v87[3] = v11;
              uint64_t v120 = v87;
              *(void *)unint64_t v83 = v84;
              *(void *)(v83 + 8) = v11;
              *(unsigned char *)(v83 + 16) = 0;
              *(unsigned char *)(v83 + 20) = 1;
              *(_DWORD *)(v83 + 24) = v82;
              *(void *)(v83 + 28) = 0;
              *(void *)(v83 + 36) = v85;
              if (v120)
              {
                if (v120 == buf)
                {
                  *(void *)(v83 + 72) = v83 + 48;
                  loc_1A27FC5B4(buf);
                }
                else
                {
                  *(void *)(v83 + 72) = (*(uint64_t (**)(void))(*(void *)v120 + 16))();
                }
                if (v120 == buf)
                {
                  (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
                }
                else if (v120)
                {
                  (*(void (**)(void))(*(void *)v120 + 40))();
                }
              }
              else
              {
                *(void *)(v83 + 72) = 0;
              }
            }
            v83 += 80;
            goto LABEL_69;
          }
          unint64_t v88 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v83 - *(void *)a2) >> 4);
          unint64_t v89 = v88 + 1;
          if (v88 + 1 > 0x333333333333333) {
            abort();
          }
          unint64_t v90 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v86 - *(void *)a2) >> 4);
          if (2 * v90 > v89) {
            unint64_t v89 = 2 * v90;
          }
          if (v90 >= 0x199999999999999) {
            uint64_t v91 = 0x333333333333333;
          }
          else {
            uint64_t v91 = v89;
          }
          if (v91)
          {
            uint64_t v92 = 80 * v91;
            uint64_t v93 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 24) + 16))(*(void *)(a2 + 24), 80 * v91, 8);
            uint64_t v94 = v93 + 80 * v88;
            uint64_t v95 = v93 + v92;
            if (v93)
            {
              uint64_t v96 = v93;
              unsigned int v97 = operator new(0x20uLL);
              *unsigned int v97 = &unk_1EF56B8D8;
              v97[1] = ggl::Texture2DArray::onImplicitLoadComplete;
              v97[2] = 0;
              v97[3] = v11;
              uint64_t v120 = v97;
              *(void *)uint64_t v94 = v84;
              unint64_t v98 = v96 + 80 * v88;
              *(void *)(v98 + 8) = v11;
              *(unsigned char *)(v98 + 16) = 0;
              *(unsigned char *)(v98 + 20) = 1;
              *(_DWORD *)(v98 + 24) = v82;
              *(void *)(v98 + 28) = 0;
              *(void *)(v98 + 36) = v85;
              if (v120)
              {
                if (v120 == buf)
                {
                  *(void *)(v96 + 80 * v88 + 72) = v98 + 48;
                  (*(void (**)(unsigned char *))(*(void *)v120 + 24))(v120);
                }
                else
                {
                  *(void *)(v96 + 80 * v88 + 72) = (*(uint64_t (**)(void))(*(void *)v120 + 16))();
                }
              }
              else
              {
                *(void *)(v96 + 80 * v88 + 72) = 0;
              }
              if (v120 == buf)
              {
                (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
              }
              else if (v120)
              {
                (*(void (**)(void))(*(void *)v120 + 40))();
              }
            }
          }
          else
          {
            uint64_t v95 = 0;
            uint64_t v94 = 80 * v88;
          }
          unint64_t v83 = v94 + 80;
          uint64_t v99 = *(void *)a2;
          uint64_t v100 = *(void *)(a2 + 8);
          if (v100 == *(void *)a2)
          {
            *(void *)a2 = v94;
            *(void *)(a2 + 8) = v83;
            uint64_t v108 = *(void *)(a2 + 16);
            *(void *)(a2 + 16) = v95;
          }
          else
          {
            uint64_t v101 = 0;
            do
            {
              uint64_t v102 = v94 + v101;
              uint64_t v103 = v100 + v101;
              *(_OWORD *)(v102 - 80) = *(_OWORD *)(v100 + v101 - 80);
              *(unsigned char *)(v102 - 64) = 0;
              if (*(unsigned char *)(v100 + v101 - 64))
              {
                *(unsigned char *)(v102 - 63) = *(unsigned char *)(v103 - 63);
                *(unsigned char *)(v102 - 64) = 1;
              }
              *(unsigned char *)(v102 - 60) = 0;
              if (*(unsigned char *)(v103 - 60))
              {
                *(_DWORD *)(v94 + v101 - 56) = *(_DWORD *)(v100 + v101 - 56);
                *(unsigned char *)(v102 - 60) = 1;
              }
              uint64_t v104 = v94 + v101;
              uint64_t v105 = v100 + v101;
              *(_OWORD *)(v94 + v101 - 52) = *(_OWORD *)(v100 + v101 - 52);
              uint64_t v106 = *(void *)(v100 + v101 - 8);
              if (v106)
              {
                if (v105 - 32 == v106)
                {
                  *(void *)(v104 - 8) = v104 - 32;
                  (*(void (**)(void))(**(void **)(v105 - 8) + 24))(*(void *)(v105 - 8));
                }
                else
                {
                  *(void *)(v104 - 8) = v106;
                  *(void *)(v105 - 8) = 0;
                }
              }
              else
              {
                *(void *)(v104 - 8) = 0;
              }
              v101 -= 80;
            }
            while (v100 + v101 != v99);
            uint64_t v100 = *(void *)a2;
            uint64_t v107 = *(void *)(a2 + 8);
            *(void *)a2 = v94 + v101;
            *(void *)(a2 + 8) = v83;
            uint64_t v108 = *(void *)(a2 + 16);
            *(void *)(a2 + 16) = v95;
            if (v107 != v100)
            {
              uint64_t v109 = v107 - 32;
              unsigned int v110 = (void *)(v107 - 32);
              do
              {
                uint64_t v112 = (void *)v110[3];
                if (v110 == v112)
                {
                  (*(void (**)(void *))(*v110 + 32))(v110);
                  if (!*((unsigned char *)v110 - 28)) {
                    goto LABEL_118;
                  }
                }
                else
                {
                  if (v112) {
                    (*(void (**)(void *))(*v112 + 40))(v112);
                  }
                  if (!*((unsigned char *)v110 - 28)) {
                    goto LABEL_118;
                  }
                }
                *((unsigned char *)v110 - 28) = 0;
LABEL_118:
                if (*((unsigned char *)v110 - 32)) {
                  *((unsigned char *)v110 - 32) = 0;
                }
                uint64_t v111 = v110 - 6;
                v110 -= 10;
                v109 -= 80;
              }
              while (v111 != (void *)v100);
            }
          }
          if (v100) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 24) + 40))(*(void *)(a2 + 24), v100, v108 - v100);
          }
LABEL_69:
          *(void *)(a2 + 8) = v83;
          ++v82;
        }
        while (v82 < *(unsigned int *)(v11 + 88));
        a3 = v117;
        uint64_t v9 = v115;
        uint64_t v3 = v116;
        uint64_t v10 = v114;
        int v14 = (unsigned char *)(v11 + 129);
LABEL_5:
        *int v14 = 1;
LABEL_6:
        ++v8;
        uint64_t result = *(void **)(v3 + 32);
        uint64_t v5 = result[12];
      }
      while (v8 < (result[13] - v5) >> 3);
    }
  }
  return result;
}

void ggl::MetalRenderItemEncoder::encode(uint64_t a1, uint64_t a2)
{
  uint64_t v495 = *MEMORY[0x1E4F143B8];
  v443 = *(ggl::Device **)a1;
  v449 = *(ggl::MetalResourceManager **)(*(void *)a1 + 80);
  id v4 = *(id *)(a1 + 8);
  uint64_t v5 = *(void **)(a1 + 64);
  uint64_t v455 = a2;
  v460 = *(void **)(a2 + 32);
  id v461 = v4;
  BOOL v6 = (const ggl::PipelineState *)v460[2];
  uint64_t v7 = *((void *)v6 + 3);
  if (!v7)
  {
    uint64_t v7 = ggl::MetalResourceManager::newPipelineState(v449, v6);
    if (!v7) {
      goto LABEL_769;
    }
  }
  v458 = v5;
  unint64_t v8 = *(void *)(a1 + 40);
  unint64_t v9 = atomic_load((unint64_t *)(v7 + 16));
  if (v9 < v8)
  {
    unint64_t v10 = v9;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v7 + 16), &v10, v8);
      if (v10 == v9) {
        break;
      }
      unint64_t v9 = v10;
    }
    while (v10 < v8);
  }
  uint64_t v11 = *(void **)(v7 + 32);
  id v12 = v11;
  v459 = (void *)a1;
  unint64_t v13 = *(id **)(a1 + 48);
  v441 = v12;
  if (*v13 != v12)
  {
    objc_storeStrong(v13, v11);
    [v461 setRenderPipelineState:**(void **)(a1 + 48)];
  }
  uint64_t v14 = *(void *)(a2 + 24);
  uint64_t v15 = *(void *)(v14 + 24);
  if (!v15)
  {
    id v16 = objc_alloc_init(MEMORY[0x1E4F35218]);
    uint64_t v17 = v16;
    if (*(unsigned char *)(v14 + 36))
    {
      uint64_t v18 = 7;
    }
    else if (*(unsigned __int8 *)(v14 + 37) - 1 < 7)
    {
      uint64_t v18 = (*(unsigned char *)(v14 + 37) - 1) + 1;
    }
    else
    {
      uint64_t v18 = 0;
    }
    [v16 setDepthCompareFunction:v18];
    [v17 setDepthWriteEnabled:*(unsigned char *)(v14 + 38) == 0];
    id v19 = objc_alloc_init(MEMORY[0x1E4F35318]);
    BOOL v20 = v19;
    if (*(unsigned __int8 *)(v14 + 50) - 1 > 2) {
      uint64_t v21 = 0;
    }
    else {
      uint64_t v21 = qword_1A29CAA98[(*(unsigned char *)(v14 + 50) - 1)];
    }
    [v19 setStencilFailureOperation:v21];
    if (*(unsigned __int8 *)(v14 + 51) - 1 > 2) {
      uint64_t v22 = 0;
    }
    else {
      uint64_t v22 = qword_1A29CAA98[(*(unsigned char *)(v14 + 51) - 1)];
    }
    [v20 setDepthFailureOperation:v22];
    if (*(unsigned __int8 *)(v14 + 52) - 1 > 2) {
      uint64_t v23 = 0;
    }
    else {
      uint64_t v23 = qword_1A29CAA98[(*(unsigned char *)(v14 + 52) - 1)];
    }
    [v20 setDepthStencilPassOperation:v23];
    if (*(unsigned char *)(v14 + 48))
    {
      uint64_t v24 = 7;
    }
    else if (*(unsigned __int8 *)(v14 + 49) - 1 >= 7)
    {
      uint64_t v24 = 0;
    }
    else
    {
      uint64_t v24 = qword_1A29CAAB0[(*(unsigned char *)(v14 + 49) - 1)];
    }
    [v20 setStencilCompareFunction:v24];
    [v20 setReadMask:*(unsigned __int8 *)(v14 + 53)];
    [v20 setWriteMask:*(unsigned __int8 *)(v14 + 54)];
    [v17 setFrontFaceStencil:v20];
    [v17 setBackFaceStencil:v20];
    int v25 = (void *)[*(id *)(*((void *)v449 + 32) + 104) newDepthStencilStateWithDescriptor:v17];
    unint64_t v26 = &qword_1EB32C000;
    while (1)
    {
      uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v26[287] + 16))(v26[287], 40, 8);
      *(void *)uint64_t v15 = 0;
      *(_WORD *)(v15 + 8) = 1793;
      *(void *)(v15 + 16) = 0;
      *(void *)(v15 + 24) = 0;
      *(void *)(v15 + 32) = 0;
      objc_storeStrong((id *)(v15 + 32), v25);
      unsigned int v27 = (std::__shared_weak_count *)*((void *)v449 + 2);
      if (v27)
      {
        unint64_t v26 = (uint64_t *)*((void *)v449 + 1);
        int8x16_t v28 = std::__shared_weak_count::lock(v27);
        if (v28) {
          break;
        }
      }
      std::__throw_bad_weak_ptr[abi:nn180100]();
LABEL_775:
        operator new();
    }
    uint64_t v29 = *(std::__shared_weak_count **)(v14 + 16);
    *(void *)(v14 + 8) = v26;
    *(void *)(v14 + 16) = v28;
    if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
      std::__shared_weak_count::__release_weak(v29);
    }
    *(void *)(v14 + 24) = v15;
    ++*(_DWORD *)(v14 + 32);
    ggl::ResourceManager::_addResourceStat((uint64_t)v449, "DepthStencilState", 0x38AB5BF400000011uLL, 0);
  }
  unint64_t v30 = v459[5];
  unint64_t v31 = atomic_load((unint64_t *)(v15 + 16));
  if (v31 < v30)
  {
    unint64_t v32 = v31;
    do
    {
      atomic_compare_exchange_strong((atomic_ullong *volatile)(v15 + 16), &v32, v30);
      if (v32 == v31) {
        break;
      }
      unint64_t v31 = v32;
    }
    while (v32 < v30);
  }
  uint64_t v33 = *(void **)(v15 + 32);
  id v34 = v33;
  unsigned int v35 = v459;
  uint64_t v36 = v459[6];
  id v38 = *(id *)(v36 + 8);
  unsigned int v37 = (id *)(v36 + 8);
  if (v38 != v34)
  {
    objc_storeStrong(v37, v33);
    unsigned int v35 = v459;
    [v461 setDepthStencilState:*(void *)(v459[6] + 8)];
  }

  if (*(void *)(v35[6] + 16) == v14) {
    goto LABEL_374;
  }
  if (!*(unsigned char *)(v14 + 48) && !*(unsigned char *)(v14 + 208)) {
    [v461 setStencilReferenceValue:*(unsigned __int8 *)(v14 + 55)];
  }
  LODWORD(v39) = *(_DWORD *)(v14 + 40);
  LODWORD(v40) = *(_DWORD *)(v14 + 44);
  [v461 setDepthBias:v39 slopeScale:v40 clamp:0.0];
  unsigned long long v42 = (void *)v459[2];
  uint64_t v43 = *(unsigned __int8 *)(v14 + 188);
  if (!*(unsigned char *)(v14 + 188))
  {
    v465[0] = 0;
    v465[1] = 0;
    uint64_t v92 = (_DWORD *)v42[42];
    if (v92)
    {
      LODWORD(v41) = v92[9];
      double v466 = (double)v41;
      LODWORD(v92) = v92[10];
      goto LABEL_173;
    }
    uint64_t v93 = v42[11];
    if (v93)
    {
      uint64_t v94 = v42 + 12;
    }
    else
    {
      uint64_t v93 = v42[35];
      if (!v93) {
        goto LABEL_162;
      }
      uint64_t v94 = v42 + 36;
    }
    uint64_t v95 = 80;
    if (*(_DWORD *)(v93 + 56) == 3) {
      uint64_t v95 = 196;
    }
    unsigned int v96 = *(_DWORD *)(v93 + v95);
    unsigned int v97 = v96 >> *v94;
    if (v97 <= 1) {
      unsigned int v97 = 1;
    }
    if (v96) {
      LODWORD(v93) = v97;
    }
    else {
      LODWORD(v93) = 0;
    }
LABEL_162:
    double v466 = (double)v93;
    uint64_t v92 = (_DWORD *)v42[11];
    if (v92)
    {
      unint64_t v98 = v42 + 12;
    }
    else
    {
      uint64_t v92 = (_DWORD *)v42[35];
      if (!v92) {
        goto LABEL_173;
      }
      unint64_t v98 = v42 + 36;
    }
    uint64_t v99 = 21;
    if (v92[14] == 3) {
      uint64_t v99 = 49;
    }
    unsigned int v100 = v92[v99];
    unsigned int v101 = v100 >> *v98;
    if (v101 <= 1) {
      unsigned int v101 = 1;
    }
    if (v100) {
      LODWORD(v92) = v101;
    }
    else {
      LODWORD(v92) = 0;
    }
LABEL_173:
    double v467 = (double)v92;
    long long v468 = xmmword_1A28FCCC0;
    [v461 setViewport:v465];
    uint64_t v102 = (_DWORD *)v42[42];
    if (v102)
    {
      LODWORD(v103) = v102[9];
      LODWORD(v102) = v102[10];
LABEL_197:
      v480[0] = 0;
      LOBYTE(v480[1]) = v103;
      BYTE1(v480[1]) = BYTE1(v103);
      BYTE2(v480[1]) = BYTE2(v103);
      BYTE3(v480[1]) = BYTE3(v103);
      BYTE4(v480[1]) = (_BYTE)v102;
      BYTE5(v480[1]) = BYTE1(v102);
      BYTE6(v480[1]) = BYTE2(v102);
      HIBYTE(v480[1]) = BYTE3(v102);
      uint64_t v112 = v459[8];
      if (!*(void *)(v112 + 32) && *(void *)(v112 + 40) == v480[1])
      {
        *(void *)(v112 + 32) = 0;
        *(_DWORD *)(v112 + 40) = v103;
        *(_DWORD *)(v112 + 44) = v102;
      }
      goto LABEL_200;
    }
    uint64_t v103 = v42[11];
    if (v103)
    {
      uint64_t v104 = v42 + 12;
    }
    else
    {
      uint64_t v103 = v42[35];
      if (!v103) {
        goto LABEL_186;
      }
      uint64_t v104 = v42 + 36;
    }
    uint64_t v105 = 80;
    if (*(_DWORD *)(v103 + 56) == 3) {
      uint64_t v105 = 196;
    }
    unsigned int v106 = *(_DWORD *)(v103 + v105);
    unsigned int v107 = v106 >> *v104;
    if (v107 <= 1) {
      unsigned int v107 = 1;
    }
    if (v106) {
      LODWORD(v103) = v107;
    }
    else {
      LODWORD(v103) = 0;
    }
LABEL_186:
    uint64_t v102 = (_DWORD *)v42[11];
    if (v102)
    {
      uint64_t v108 = v42 + 12;
    }
    else
    {
      uint64_t v102 = (_DWORD *)v42[35];
      if (!v102) {
        goto LABEL_197;
      }
      uint64_t v108 = v42 + 36;
    }
    uint64_t v109 = 21;
    if (v102[14] == 3) {
      uint64_t v109 = 49;
    }
    unsigned int v110 = v102[v109];
    unsigned int v111 = v110 >> *v108;
    if (v111 <= 1) {
      unsigned int v111 = 1;
    }
    if (v110) {
      LODWORD(v102) = v111;
    }
    else {
      LODWORD(v102) = 0;
    }
    goto LABEL_197;
  }
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v46 = v459[8];
  uint64_t v47 = v42[42];
  unsigned long long v48 = (double *)&v480[2];
  uint64_t v49 = v47;
  uint64_t v50 = v47;
  do
  {
    long long v472 = *(_OWORD *)(v14 + 124 + v44);
    LODWORD(v56) = DWORD2(v472);
    unsigned int v57 = v472;
    if (v472 != 0)
    {
      if (v50)
      {
        if (*(_DWORD *)(v50 + 36) < DWORD2(v472)) {
          goto LABEL_94;
        }
        unsigned int v70 = *(_DWORD *)(v50 + 40);
      }
      else
      {
        uint64_t v65 = v42[11];
        unsigned long long v66 = v42 + 12;
        if (v65 || (uint64_t v65 = v42[35], v66 = v42 + 36, v65))
        {
          if (*(_DWORD *)(v65 + 56) == 3) {
            uint64_t v67 = 196;
          }
          else {
            uint64_t v67 = 80;
          }
          unsigned int v68 = *(_DWORD *)(v65 + v67);
          unsigned int v69 = v68 >> *v66;
          if (v69 <= 1) {
            unsigned int v69 = 1;
          }
          if (v68) {
            LODWORD(v65) = v69;
          }
          else {
            LODWORD(v65) = 0;
          }
        }
        if (v65 < DWORD2(v472)) {
          goto LABEL_93;
        }
        uint64_t v86 = v42[11];
        unsigned int v87 = v42 + 12;
        if (v86 || (uint64_t v86 = v42[35], v87 = v42 + 36, v86))
        {
          if (*(_DWORD *)(v86 + 56) == 3) {
            uint64_t v88 = 196;
          }
          else {
            uint64_t v88 = 84;
          }
          unsigned int v89 = *(_DWORD *)(v86 + v88);
          unsigned int v90 = v89 >> *v87;
          if (v90 <= 1) {
            unsigned int v90 = 1;
          }
          if (v89) {
            unsigned int v70 = v90;
          }
          else {
            unsigned int v70 = 0;
          }
        }
        else
        {
          unsigned int v70 = 0;
        }
      }
      uint64_t v58 = (_DWORD *)HIDWORD(*((void *)&v472 + 1));
      unint64_t v71 = DWORD1(v472);
      if (v70 >= HIDWORD(v472) && v472 < DWORD2(v472) && DWORD1(v472) < HIDWORD(v472))
      {
        int32x2_t v81 = (int32x2_t)v472;
        goto LABEL_107;
      }
LABEL_93:
      if (!v50)
      {
        uint64_t v56 = v42[11];
        unint64_t v82 = v42 + 12;
        if (v56 || (v56 = v42[35], unint64_t v82 = v42 + 36, v56))
        {
          if (*(_DWORD *)(v56 + 56) == 3) {
            uint64_t v83 = 196;
          }
          else {
            uint64_t v83 = 80;
          }
          unsigned int v84 = *(_DWORD *)(v56 + v83);
          unsigned int v85 = v84 >> *v82;
          if (v85 <= 1) {
            unsigned int v85 = 1;
          }
          if (v84) {
            LODWORD(v56) = v85;
          }
          else {
            LODWORD(v56) = 0;
          }
        }
        goto LABEL_95;
      }
LABEL_94:
      LODWORD(v56) = *(_DWORD *)(v50 + 36);
LABEL_95:
      if (v50)
      {
        LODWORD(v58) = *(_DWORD *)(v50 + 40);
        goto LABEL_106;
      }
      uint64_t v64 = v42[11];
      uint64_t v58 = v42 + 12;
      if (v64) {
        goto LABEL_99;
      }
      uint64_t v64 = v42[35];
      uint64_t v58 = v42 + 36;
      if (v64) {
        goto LABEL_99;
      }
LABEL_142:
      uint64_t v50 = 0;
      LODWORD(v58) = 0;
      goto LABEL_106;
    }
    if (v49)
    {
      LODWORD(v56) = *(_DWORD *)(v49 + 36);
      if (!v47) {
        goto LABEL_69;
      }
    }
    else
    {
      uint64_t v59 = v42[11];
      unsigned long long v60 = v42 + 12;
      if (!v59)
      {
        uint64_t v59 = v42[35];
        unsigned long long v60 = v42 + 36;
        if (!v59)
        {
          LODWORD(v56) = 0;
          if (!v47) {
            goto LABEL_69;
          }
          goto LABEL_54;
        }
      }
      if (*(_DWORD *)(v59 + 56) == 3) {
        uint64_t v61 = 196;
      }
      else {
        uint64_t v61 = 80;
      }
      unsigned int v62 = *(_DWORD *)(v59 + v61);
      unsigned int v63 = v62 >> *v60;
      if (v63 <= 1) {
        unsigned int v63 = 1;
      }
      if (v62) {
        LODWORD(v56) = v63;
      }
      else {
        LODWORD(v56) = 0;
      }
      if (!v47)
      {
LABEL_69:
        uint64_t v64 = v42[11];
        uint64_t v58 = v42 + 12;
        if (v64 || (v64 = v42[35], uint64_t v58 = v42 + 36, v64))
        {
          uint64_t v49 = 0;
LABEL_99:
          uint64_t v50 = 0;
          if (*(_DWORD *)(v64 + 56) == 3) {
            uint64_t v74 = 196;
          }
          else {
            uint64_t v74 = 84;
          }
          unsigned int v75 = *(_DWORD *)(v64 + v74);
          LODWORD(v58) = v75 >> *v58;
          if (v58 <= 1) {
            LODWORD(v58) = 1;
          }
          if (!v75) {
            LODWORD(v58) = 0;
          }
          goto LABEL_106;
        }
        uint64_t v49 = 0;
        goto LABEL_142;
      }
    }
LABEL_54:
    LODWORD(v58) = *(_DWORD *)(v47 + 40);
    uint64_t v49 = v47;
    uint64_t v50 = v47;
LABEL_106:
    unsigned int v57 = 0;
    LODWORD(v71) = 0;
    int32x2_t v81 = 0;
    *(void *)&long long v472 = 0;
    *((void *)&v472 + 1) = __PAIR64__(v58, v56);
LABEL_107:
    uint64_t v76 = v46 + v44;
    if (*(_OWORD *)(v46 + v44 + 32) == v472)
    {
      *(_DWORD *)(v76 + 32) = v57;
      uint64_t v51 = v46 + v44;
      *(_DWORD *)(v51 + 36) = v71;
      *(_DWORD *)(v76 + 40) = v56;
      *(_DWORD *)(v51 + 44) = v58;
      buf[v45] = 0;
      if (v47) {
        goto LABEL_49;
      }
    }
    else
    {
      buf[v45] = 1;
      if (v47)
      {
LABEL_49:
        LODWORD(v52) = *(_DWORD *)(v47 + 40);
        goto LABEL_50;
      }
    }
    uint64_t v52 = v42[11];
    uint64_t v77 = v42 + 12;
    if (v52 || (uint64_t v52 = v42[35], v77 = v42 + 36, v52))
    {
      if (*(_DWORD *)(v52 + 56) == 3) {
        uint64_t v78 = 196;
      }
      else {
        uint64_t v78 = 84;
      }
      unsigned int v79 = *(_DWORD *)(v52 + v78);
      unsigned int v80 = v79 >> *v77;
      if (v80 <= 1) {
        unsigned int v80 = 1;
      }
      if (v79) {
        LODWORD(v52) = v80;
      }
      else {
        LODWORD(v52) = 0;
      }
    }
LABEL_50:
    int32x2_t v53 = vsub_s32(*(int32x2_t *)((char *)&v472 + 8), v81);
    double v54 = (double)(v52 - HIDWORD(v472));
    v55.i64[0] = v53.u32[0];
    v55.i64[1] = v53.u32[1];
    *(v48 - 2) = (double)v57;
    *(v48 - 1) = v54;
    *(float64x2_t *)unsigned long long v48 = vcvtq_f64_u64(v55);
    *((_OWORD *)v48 + 1) = xmmword_1A28FCCC0;
    v48 += 6;
    ++v45;
    v44 += 16;
  }
  while (16 * v43 != v44);
  uint64_t v91 = 0;
  while (buf[v91])
  {
    if (v43 == ++v91) {
      goto LABEL_200;
    }
  }
  objc_msgSend(v461, "setViewports:count:", v480);
LABEL_200:
  uint64_t v113 = *(unsigned __int8 *)(v14 + 188);
  if (!*(unsigned char *)(v14 + 188))
  {
    v462[0] = 0;
    v462[1] = 0;
    uint64_t v162 = (unsigned int *)v42[42];
    if (v162)
    {
      uint64_t v163 = v162[9];
      LODWORD(v162) = v162[10];
      uint64_t v463 = v163;
      goto LABEL_327;
    }
    uint64_t v164 = v42[11];
    if (v164)
    {
      uint64_t v165 = v42 + 12;
    }
    else
    {
      uint64_t v164 = v42[35];
      if (!v164) {
        goto LABEL_316;
      }
      uint64_t v165 = v42 + 36;
    }
    uint64_t v166 = 80;
    if (*(_DWORD *)(v164 + 56) == 3) {
      uint64_t v166 = 196;
    }
    unsigned int v167 = *(_DWORD *)(v164 + v166);
    unsigned int v168 = v167 >> *v165;
    if (v168 <= 1) {
      unsigned int v168 = 1;
    }
    if (v167) {
      LODWORD(v164) = v168;
    }
    else {
      LODWORD(v164) = 0;
    }
LABEL_316:
    uint64_t v463 = v164;
    uint64_t v162 = (unsigned int *)v42[11];
    if (v162)
    {
      long long v169 = v42 + 12;
    }
    else
    {
      uint64_t v162 = (unsigned int *)v42[35];
      if (!v162) {
        goto LABEL_327;
      }
      long long v169 = v42 + 36;
    }
    uint64_t v170 = 21;
    if (v162[14] == 3) {
      uint64_t v170 = 49;
    }
    unsigned int v171 = v162[v170];
    unsigned int v172 = v171 >> *v169;
    if (v172 <= 1) {
      unsigned int v172 = 1;
    }
    if (v171) {
      LODWORD(v162) = v172;
    }
    else {
      LODWORD(v162) = 0;
    }
LABEL_327:
    uint64_t v464 = v162;
    [v461 setScissorRect:v462];
    long long v173 = (_DWORD *)v42[42];
    if (v173)
    {
      LODWORD(v174) = v173[9];
      LODWORD(v173) = v173[10];
LABEL_351:
      v480[0] = 0;
      LOBYTE(v480[1]) = v174;
      BYTE1(v480[1]) = BYTE1(v174);
      BYTE2(v480[1]) = BYTE2(v174);
      BYTE3(v480[1]) = BYTE3(v174);
      BYTE4(v480[1]) = (_BYTE)v173;
      BYTE5(v480[1]) = BYTE1(v173);
      BYTE6(v480[1]) = BYTE2(v173);
      HIBYTE(v480[1]) = BYTE3(v173);
      uint64_t v183 = v459[8];
      if (!*(void *)(v183 + 96) && *(void *)(v183 + 104) == v480[1])
      {
        *(void *)(v183 + 96) = 0;
        *(_DWORD *)(v183 + 104) = v174;
        *(_DWORD *)(v183 + 108) = v173;
      }
      goto LABEL_354;
    }
    uint64_t v174 = v42[11];
    if (v174)
    {
      long long v175 = v42 + 12;
    }
    else
    {
      uint64_t v174 = v42[35];
      if (!v174) {
        goto LABEL_340;
      }
      long long v175 = v42 + 36;
    }
    uint64_t v176 = 80;
    if (*(_DWORD *)(v174 + 56) == 3) {
      uint64_t v176 = 196;
    }
    unsigned int v177 = *(_DWORD *)(v174 + v176);
    unsigned int v178 = v177 >> *v175;
    if (v178 <= 1) {
      unsigned int v178 = 1;
    }
    if (v177) {
      LODWORD(v174) = v178;
    }
    else {
      LODWORD(v174) = 0;
    }
LABEL_340:
    long long v173 = (_DWORD *)v42[11];
    if (v173)
    {
      long long v179 = v42 + 12;
    }
    else
    {
      long long v173 = (_DWORD *)v42[35];
      if (!v173) {
        goto LABEL_351;
      }
      long long v179 = v42 + 36;
    }
    uint64_t v180 = 21;
    if (v173[14] == 3) {
      uint64_t v180 = 49;
    }
    unsigned int v181 = v173[v180];
    unsigned int v182 = v181 >> *v179;
    if (v182 <= 1) {
      unsigned int v182 = 1;
    }
    if (v181) {
      LODWORD(v173) = v182;
    }
    else {
      LODWORD(v173) = 0;
    }
    goto LABEL_351;
  }
  uint64_t v114 = 0;
  uint64_t v115 = 0;
  uint64_t v116 = v459[8];
  uint64_t v117 = v42[42];
  uint64_t v118 = &v480[2];
  uint64_t v119 = v117;
  uint64_t v120 = v117;
  do
  {
    long long v472 = *(_OWORD *)(v14 + 60 + v114);
    LODWORD(v126) = DWORD2(v472);
    unsigned int v127 = v472;
    if (v472 != 0)
    {
      if (v120)
      {
        if (*(_DWORD *)(v120 + 36) < DWORD2(v472)) {
          goto LABEL_248;
        }
        unsigned int v140 = *(_DWORD *)(v120 + 40);
      }
      else
      {
        uint64_t v135 = v42[11];
        uint64_t v136 = v42 + 12;
        if (v135 || (v135 = v42[35], uint64_t v136 = v42 + 36, v135))
        {
          if (*(_DWORD *)(v135 + 56) == 3) {
            uint64_t v137 = 196;
          }
          else {
            uint64_t v137 = 80;
          }
          unsigned int v138 = *(_DWORD *)(v135 + v137);
          unsigned int v139 = v138 >> *v136;
          if (v139 <= 1) {
            unsigned int v139 = 1;
          }
          if (v138) {
            LODWORD(v135) = v139;
          }
          else {
            LODWORD(v135) = 0;
          }
        }
        if (v135 < DWORD2(v472)) {
          goto LABEL_247;
        }
        uint64_t v156 = v42[11];
        uint64_t v157 = v42 + 12;
        if (v156 || (uint64_t v156 = v42[35], v157 = v42 + 36, v156))
        {
          if (*(_DWORD *)(v156 + 56) == 3) {
            uint64_t v158 = 196;
          }
          else {
            uint64_t v158 = 84;
          }
          unsigned int v159 = *(_DWORD *)(v156 + v158);
          unsigned int v160 = v159 >> *v157;
          if (v160 <= 1) {
            unsigned int v160 = 1;
          }
          if (v159) {
            unsigned int v140 = v160;
          }
          else {
            unsigned int v140 = 0;
          }
        }
        else
        {
          unsigned int v140 = 0;
        }
      }
      uint64_t v128 = (_DWORD *)HIDWORD(*((void *)&v472 + 1));
      unint64_t v141 = DWORD1(v472);
      if (v140 >= HIDWORD(v472) && v472 < DWORD2(v472) && DWORD1(v472) < HIDWORD(v472))
      {
        int32x2_t v151 = (int32x2_t)v472;
        goto LABEL_261;
      }
LABEL_247:
      if (!v120)
      {
        uint64_t v126 = v42[11];
        uint64_t v152 = v42 + 12;
        if (v126 || (uint64_t v126 = v42[35], v152 = v42 + 36, v126))
        {
          if (*(_DWORD *)(v126 + 56) == 3) {
            uint64_t v153 = 196;
          }
          else {
            uint64_t v153 = 80;
          }
          unsigned int v154 = *(_DWORD *)(v126 + v153);
          unsigned int v155 = v154 >> *v152;
          if (v155 <= 1) {
            unsigned int v155 = 1;
          }
          if (v154) {
            LODWORD(v126) = v155;
          }
          else {
            LODWORD(v126) = 0;
          }
        }
        goto LABEL_249;
      }
LABEL_248:
      LODWORD(v126) = *(_DWORD *)(v120 + 36);
LABEL_249:
      if (v120)
      {
        LODWORD(v128) = *(_DWORD *)(v120 + 40);
        goto LABEL_260;
      }
      uint64_t v134 = v42[11];
      uint64_t v128 = v42 + 12;
      if (v134) {
        goto LABEL_253;
      }
      uint64_t v134 = v42[35];
      uint64_t v128 = v42 + 36;
      if (v134) {
        goto LABEL_253;
      }
LABEL_296:
      uint64_t v120 = 0;
      LODWORD(v128) = 0;
      goto LABEL_260;
    }
    if (v119)
    {
      LODWORD(v126) = *(_DWORD *)(v119 + 36);
      if (!v117) {
        goto LABEL_223;
      }
    }
    else
    {
      uint64_t v129 = v42[11];
      uint64_t v130 = v42 + 12;
      if (!v129)
      {
        uint64_t v129 = v42[35];
        uint64_t v130 = v42 + 36;
        if (!v129)
        {
          LODWORD(v126) = 0;
          if (!v117) {
            goto LABEL_223;
          }
          goto LABEL_208;
        }
      }
      if (*(_DWORD *)(v129 + 56) == 3) {
        uint64_t v131 = 196;
      }
      else {
        uint64_t v131 = 80;
      }
      unsigned int v132 = *(_DWORD *)(v129 + v131);
      unsigned int v133 = v132 >> *v130;
      if (v133 <= 1) {
        unsigned int v133 = 1;
      }
      if (v132) {
        LODWORD(v126) = v133;
      }
      else {
        LODWORD(v126) = 0;
      }
      if (!v117)
      {
LABEL_223:
        uint64_t v134 = v42[11];
        uint64_t v128 = v42 + 12;
        if (v134 || (v134 = v42[35], uint64_t v128 = v42 + 36, v134))
        {
          uint64_t v119 = 0;
LABEL_253:
          uint64_t v120 = 0;
          if (*(_DWORD *)(v134 + 56) == 3) {
            uint64_t v144 = 196;
          }
          else {
            uint64_t v144 = 84;
          }
          unsigned int v145 = *(_DWORD *)(v134 + v144);
          LODWORD(v128) = v145 >> *v128;
          if (v128 <= 1) {
            LODWORD(v128) = 1;
          }
          if (!v145) {
            LODWORD(v128) = 0;
          }
          goto LABEL_260;
        }
        uint64_t v119 = 0;
        goto LABEL_296;
      }
    }
LABEL_208:
    LODWORD(v128) = *(_DWORD *)(v117 + 40);
    uint64_t v119 = v117;
    uint64_t v120 = v117;
LABEL_260:
    unsigned int v127 = 0;
    LODWORD(v141) = 0;
    int32x2_t v151 = 0;
    *(void *)&long long v472 = 0;
    *((void *)&v472 + 1) = __PAIR64__(v128, v126);
LABEL_261:
    uint64_t v146 = v116 + v114;
    if (*(_OWORD *)(v116 + v114 + 96) == v472)
    {
      *(_DWORD *)(v146 + 96) = v127;
      uint64_t v121 = v116 + v114;
      *(_DWORD *)(v121 + 100) = v141;
      *(_DWORD *)(v146 + 104) = v126;
      *(_DWORD *)(v121 + 108) = v128;
      buf[v115] = 0;
      if (v117) {
        goto LABEL_203;
      }
    }
    else
    {
      buf[v115] = 1;
      if (v117)
      {
LABEL_203:
        LODWORD(v122) = *(_DWORD *)(v117 + 40);
        goto LABEL_204;
      }
    }
    uint64_t v122 = v42[11];
    uint64_t v147 = v42 + 12;
    if (v122 || (uint64_t v122 = v42[35], v147 = v42 + 36, v122))
    {
      if (*(_DWORD *)(v122 + 56) == 3) {
        uint64_t v148 = 196;
      }
      else {
        uint64_t v148 = 84;
      }
      unsigned int v149 = *(_DWORD *)(v122 + v148);
      unsigned int v150 = v149 >> *v147;
      if (v150 <= 1) {
        unsigned int v150 = 1;
      }
      if (v149) {
        LODWORD(v122) = v150;
      }
      else {
        LODWORD(v122) = 0;
      }
    }
LABEL_204:
    uint64_t v123 = (v122 - HIDWORD(v472));
    int32x2_t v124 = vsub_s32(*(int32x2_t *)((char *)&v472 + 8), v151);
    *(void *)&long long v125 = v124.u32[0];
    *((void *)&v125 + 1) = v124.u32[1];
    *((void *)v118 - 2) = v127;
    *((void *)v118 - 1) = v123;
    *uint64_t v118 = v125;
    v118 += 2;
    ++v115;
    v114 += 16;
  }
  while (16 * v113 != v114);
  uint64_t v161 = 0;
  while (buf[v161])
  {
    if (v113 == ++v161) {
      goto LABEL_354;
    }
  }
  objc_msgSend(v461, "setScissorRects:count:", v480);
LABEL_354:
  unint64_t v184 = *(unsigned __int8 *)(v14 + 56);
  if (v184 <= 2) {
    [v461 setCullMode:qword_1A29C69E0[v184]];
  }
  if (!*(unsigned char *)(v14 + 57) || *(unsigned char *)(v14 + 57) == 1) {
    objc_msgSend(v461, "setTriangleFillMode:");
  }
  if (!*(unsigned char *)(v14 + 39) || *(unsigned char *)(v14 + 39) == 1) {
    objc_msgSend(v461, "setDepthClipMode:");
  }
  if (*((unsigned char *)v443 + 22))
  {
    uint64_t v185 = *(unsigned __int8 *)(v14 + 189);
    if (*(unsigned char *)(v14 + 189))
    {
      if (v185 <= 7
        || (unint64_t)v480 < v14 + 192 + 8 * v185 && v14 + 192 < (unint64_t)&v480[v185])
      {
        uint64_t v186 = 0;
        goto LABEL_368;
      }
      uint64_t v186 = v185 & 0xF8;
      v434 = (float *)&v481;
      v435 = (const float *)(v14 + 224);
      uint64_t v436 = v186;
      do
      {
        uint64_t v437 = v435 - 8;
        float32x4x2_t v496 = vld2q_f32(v437);
        float32x4x2_t v497 = vld2q_f32(v435);
        float32x4_t v438 = v496.val[0];
        v439 = v434 - 8;
        vst2q_f32(v439, *(float32x4x2_t *)((char *)&v496 + 16));
        float32x4_t v440 = v497.val[0];
        vst2q_f32(v434, *(float32x4x2_t *)((char *)&v497 + 16));
        v434 += 16;
        v435 += 16;
        v436 -= 8;
      }
      while (v436);
      if (v186 != v185)
      {
LABEL_368:
        uint64_t v187 = v185 - v186;
        uint64_t v188 = 8 * v186;
        long long v189 = (int32x2_t *)&v480[v186];
        long long v190 = (int32x2_t *)(v188 + v14 + 192);
        do
        {
          int32x2_t v191 = *v190++;
          *v189++ = vrev64_s32(v191);
          --v187;
        }
        while (v187);
      }
    }
    else
    {
      uint64_t v185 = 0;
      v480[0] = 0;
    }
    [v461 setVertexAmplificationCount:v185 viewMappings:v480];
  }
  *(void *)(v459[6] + 16) = v14;
LABEL_374:
  if (!*(unsigned char *)(v14 + 48) && *(unsigned char *)(v14 + 208)) {
    [v461 setStencilReferenceValue:*(unsigned int *)(v455 + 40)];
  }
  uint64_t v192 = *(void *)(v455 + 64);
  if (v192) {
    *(void *)(*(void *)(v455 + 32) + 224) = v192;
  }
  uint64_t v193 = v460[28];
  uint64_t v194 = *(void **)(*(void *)(*(void *)(v460[2] + 40) + 8) + 8);
  uint64_t v448 = v193;
  if (v193)
  {
    long long v485 = 0u;
    long long v486 = 0u;
    long long v483 = 0u;
    long long v484 = 0u;
    long long v481 = 0u;
    long long v482 = 0u;
    memset(v480, 0, sizeof(v480));
    long long v478 = 0u;
    long long v479 = 0u;
    long long v476 = 0u;
    long long v477 = 0u;
    long long v474 = 0u;
    long long v475 = 0u;
    long long v472 = 0u;
    long long v473 = 0u;
    uint64_t v195 = *(void *)(v193 + 64);
    uint64_t v196 = *(void *)(v193 + 72);
    if (v195 == v196)
    {
      uint64_t v197 = 0;
      uint64_t v199 = 0;
    }
    else
    {
      uint64_t v197 = 0;
      unint64_t v198 = 0;
      uint64_t v199 = 0;
      do
      {
        long long v200 = *(void **)v195;
        unsigned int v201 = *(_DWORD *)(*(void *)v195 + 112);
        if (v201 >= 2 && !v200[13]) {
          v200[13] = v459[7];
        }
        uint64_t v202 = v200[3];
        if (v201 <= 1) {
          uint64_t v203 = 0;
        }
        else {
          uint64_t v203 = v459[3];
        }
        uint64_t v204 = v200[5] + v203 * v200[15];
        uint64_t v205 = *(void *)(v202 + 24);
        uint64_t v206 = v458[20];
        uint64_t v207 = *(void *)(v206 + 8 * v197);
        if (v207) {
          BOOL v208 = v207 == v205;
        }
        else {
          BOOL v208 = 0;
        }
        if (v208)
        {
          uint64_t v215 = v458[1];
          if (*(void *)(v215 + 8 * v197) != v204)
          {
            *(void *)(v215 + 8 * v197) = v204;
            unint64_t v216 = v459[5];
            unint64_t v217 = atomic_load((unint64_t *)(v205 + 16));
            if (v217 < v216)
            {
              unint64_t v218 = v217;
              do
              {
                atomic_compare_exchange_strong((atomic_ullong *volatile)(v205 + 16), &v218, v216);
                if (v218 == v217) {
                  break;
                }
                unint64_t v217 = v218;
              }
              while (v218 < v216);
            }
            objc_msgSend(v461, "setVertexBufferOffset:atIndex:");
          }
        }
        else
        {
          uint64_t v209 = 8 * v197;
          *(void *)(v206 + v209) = v205;
          *(void *)(v458[1] + v209) = v204;
          if (v198 >= 0x10)
          {
            objc_msgSend(v461, "setVertexBuffers:offsets:withRange:", v480, &v472, v197, v198);
            v197 += v198;
            unint64_t v198 = 0;
          }
          uint64_t v210 = *(void *)(v202 + 24);
          unint64_t v211 = v459[5];
          unint64_t v212 = atomic_load((unint64_t *)(v210 + 16));
          if (v212 < v211)
          {
            unint64_t v213 = v212;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v210 + 16), &v213, v211);
              if (v213 == v212) {
                break;
              }
              unint64_t v212 = v213;
            }
            while (v213 < v211);
          }
          objc_storeStrong((id *)&v480[v197 + v198], *(id *)(v210 + 32));
          uint64_t v214 = v459[3];
          if (*(_DWORD *)(*(void *)v195 + 112) <= 1u) {
            uint64_t v214 = 0;
          }
          *((void *)&v472 + v197 + v198++) = *(void *)(*(void *)v195 + 40)
                                             + v214 * *(void *)(*(void *)v195 + 120);
        }
        ++v199;
        v195 += 16;
      }
      while (v195 != v196);
      if (v198 == 1) {
        objc_msgSend(v461, "setVertexBuffers:offsets:withRange:", v480, &v472, v197, 1);
      }
    }

    uint64_t v219 = v197 + v199;
  }
  else
  {
    uint64_t v219 = 0;
  }
  long long v485 = 0u;
  long long v486 = 0u;
  long long v483 = 0u;
  long long v484 = 0u;
  long long v481 = 0u;
  long long v482 = 0u;
  memset(v480, 0, sizeof(v480));
  long long v478 = 0u;
  long long v479 = 0u;
  long long v476 = 0u;
  long long v477 = 0u;
  long long v474 = 0u;
  long long v475 = 0u;
  long long v472 = 0u;
  long long v473 = 0u;
  if (v194[7])
  {
    unint64_t v220 = 0;
    uint64_t v221 = 0;
    uint64_t v222 = v219;
    while (2)
    {
      uint64_t v223 = (unsigned __int8 *)(v194[6] + 2 * v221);
      uint64_t v224 = *(void *)(v460[4] + 16 * *v223);
      if (!v224) {
        goto LABEL_417;
      }
      uint64_t v225 = v219;
      uint64_t v226 = *(void *)(v224 + 24);
      if (v226)
      {
        uint64_t v227 = *(void *)(v224 + 40);
        if (*(_DWORD *)(v224 + 112) < 2u) {
          uint64_t v228 = *(void *)(v224 + 8) * v227;
        }
        else {
          uint64_t v228 = v227 + v459[3] * *(void *)(v224 + 120);
        }
        uint64_t v229 = v223[1];
        uint64_t v230 = *(void *)(v226 + 24);
        uint64_t v231 = v458[20];
        uint64_t v232 = *(void *)(v231 + 8 * v229);
        if (v232) {
          BOOL v233 = v232 == v230;
        }
        else {
          BOOL v233 = 0;
        }
        int v234 = v233;
        if (!v233) {
          *(void *)(v231 + 8 * v229) = v230;
        }
        if (v220)
        {
          if (v220 > 0xF || v222 + v220 != v229)
          {
            objc_msgSend(v461, "setVertexBuffers:offsets:withRange:", v480, &v472, v222, v220);
            unint64_t v220 = 0;
            goto LABEL_435;
          }
        }
        else
        {
LABEL_435:
          uint64_t v222 = v229;
        }
        uint64_t v235 = v458[1];
        if (!v234)
        {
          *(void *)(v235 + 8 * v229) = v228;
          uint64_t v240 = *(void *)(v226 + 24);
          unint64_t v241 = v459[5];
          unint64_t v242 = atomic_load((unint64_t *)(v240 + 16));
          if (v242 < v241)
          {
            unint64_t v243 = v242;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v240 + 16), &v243, v241);
              if (v243 == v242) {
                break;
              }
              unint64_t v242 = v243;
            }
            while (v243 < v241);
          }
          float v244 = *(void **)(v240 + 32);
          id v245 = v244;
          objc_storeStrong((id *)&v480[v220], v244);
          uint64_t v219 = v225;
          *((void *)&v472 + v220) = v228;

          ++v220;
          goto LABEL_417;
        }
        if (*(void *)(v235 + 8 * v229) != v228)
        {
          *(void *)(v235 + 8 * v229) = v228;
          uint64_t v236 = *(void *)(v226 + 24);
          unint64_t v237 = v459[5];
          unint64_t v238 = atomic_load((unint64_t *)(v236 + 16));
          if (v238 < v237)
          {
            unint64_t v239 = v238;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v236 + 16), &v239, v237);
              if (v239 == v238) {
                break;
              }
              unint64_t v238 = v239;
            }
            while (v239 < v237);
          }
          [v461 setVertexBufferOffset:v228 atIndex:v229];
          uint64_t v219 = v225;
          goto LABEL_417;
        }
      }
      uint64_t v219 = v225;
LABEL_417:
      if ((unint64_t)++v221 >= v194[7])
      {
        if (v220) {
          objc_msgSend(v461, "setVertexBuffers:offsets:withRange:", v480, &v472, v222, v220);
        }
        break;
      }
      continue;
    }
  }

  long long v485 = 0u;
  long long v486 = 0u;
  long long v483 = 0u;
  long long v484 = 0u;
  long long v481 = 0u;
  long long v482 = 0u;
  memset(v480, 0, sizeof(v480));
  long long v478 = 0u;
  long long v479 = 0u;
  long long v476 = 0u;
  long long v477 = 0u;
  long long v474 = 0u;
  long long v475 = 0u;
  long long v472 = 0u;
  long long v473 = 0u;
  if (!v194[5])
  {
    uint64_t v453 = 0;
    goto LABEL_504;
  }
  uint64_t v453 = 0;
  unint64_t v246 = 0;
  uint64_t v247 = 0;
  while (2)
  {
    uint64_t v248 = (unsigned __int8 *)(v194[4] + 2 * v247);
    uint64_t v249 = *v248;
    uint64_t v250 = v248[1];
    if ((*(unsigned int (**)(void *, uint64_t))(*v460 + 16))(v460, v249))
    {
      uint64_t v251 = 16 * v249;
      uint64_t v252 = *(void *)(v460[8] + 16 * v249);
      if (v252)
      {
        uint64_t v253 = *(void *)(v252 + 24);
        if (v253) {
          goto LABEL_456;
        }
LABEL_462:
        uint64_t v254 = v219;
        uint64_t v255 = 0;
      }
      else
      {
        if (GEOGetGeoGLDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetGeoGLDefaultLog_onceToken, &__block_literal_global_53364);
        }
        uint64_t v256 = (id)GEOGetGeoGLDefaultLog_log;
        if (os_log_type_enabled(v256, OS_LOG_TYPE_ERROR))
        {
          uint64_t v257 = **(void **)(*(void *)(v460[1] + 24) + 8 * v249);
          *(_DWORD *)buf = 136315906;
          *(void *)&buf[4] = v257;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "false";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&buf[24] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalRenderItemEncoder.mm";
          LOWORD(v470[0]) = 1024;
          *(_DWORD *)((char *)v470 + 2) = 487;
          _os_log_impl(&dword_1A1780000, v256, OS_LOG_TYPE_ERROR, "You must bind constant data for every one you use in your shader:%s: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
        }

        uint64_t v253 = MEMORY[0x18];
        if (!MEMORY[0x18]) {
          goto LABEL_462;
        }
LABEL_456:
        uint64_t v254 = v219;
        uint64_t v255 = *(void *)(v253 + 24);
      }
      uint64_t v258 = 1 << v249;
      if ((v453 & (1 << v249)) != 0)
      {
        uint64_t v219 = v254;
        if (!v255) {
          goto LABEL_452;
        }
LABEL_489:
        uint64_t v270 = v458[20];
        uint64_t v271 = *(void *)(v270 + 8 * v250);
        if (v271) {
          BOOL v272 = v271 == v255;
        }
        else {
          BOOL v272 = 0;
        }
        if (!v272)
        {
          *(void *)(v270 + 8 * v250) = v255;
          v273 = *(void **)(v255 + 32);
          id v274 = v273;
          if (v246)
          {
            if (v246 <= 0xF && v219 + v246 == v250)
            {
              uint64_t v250 = v219;
            }
            else
            {
              objc_msgSend(v461, "setVertexBuffers:offsets:withRange:", v480, &v472, v219, v246);
              unint64_t v246 = 0;
            }
          }
          objc_storeStrong((id *)&v480[v246], v273);
          uint64_t v275 = v459[3];
          if (*(_DWORD *)(v252 + 112) <= 1u) {
            uint64_t v275 = 0;
          }
          *((void *)&v472 + v246) = *(void *)(v252 + 40) + v275 * *(void *)(v252 + 120);

          ++v246;
          uint64_t v219 = v250;
        }
      }
      else
      {
        uint64_t v259 = *(void *)(v460[8] + 16 * v249);
        uint64_t v260 = v459[3];
        uint64_t v261 = v459[4];
        if (!*(void *)(v259 + 24)) {
          ggl::BufferData::prepareBufferForDevice(*(std::mutex **)(v460[8] + v251), v443, 0);
        }
        if (*(unsigned char *)(v259 + 18) == 1 && *(void *)(v259 + 192) != v261 && *(_DWORD *)(v259 + 112))
        {
          *(void *)(v259 + 192) = v261;
          *(_OWORD *)(v259 + 56) = *(_OWORD *)(v259 + 40);
        }
        if (*(_DWORD *)(v259 + 112) <= 1u) {
          uint64_t v262 = 0;
        }
        else {
          uint64_t v262 = v260;
        }
        int64x2_t v263 = *(int64x2_t *)(v259 + 56);
        int64x2_t v264 = vaddq_s64(vdupq_n_s64(v262 * *(void *)(v259 + 120)), v263);
        *(void *)(v259 + 56) = 0;
        *(void *)(v259 + 64) = 0;
        uint64_t v265 = *(void *)(v259 + 24);
        *(void *)buf = *(void *)(v259 + 72) + v263.i64[0];
        *(void *)&buf[8] = v265;
        *(int64x2_t *)&buf[16] = v264;
        v471 = 0;
        uint64_t v252 = *(void *)(v460[8] + v251);
        uint64_t v266 = *(void *)(v252 + 24);
        if (*(_DWORD *)(v252 + 112) >= 2u && !*(void *)(v252 + 104)) {
          *(void *)(v252 + 104) = v459[7];
        }
        if ((vmovn_s64(vceqq_s64(v264, vdupq_laneq_s64(v264, 1))).u32[0] & 1) == 0) {
          ggl::MetalResourceManager::upload((uint64_t *)v449, (uint64_t)buf, v252);
        }
        uint64_t v255 = *(void *)(v266 + 24);
        unint64_t v267 = v459[5];
        unint64_t v268 = atomic_load((unint64_t *)(v255 + 16));
        if (v268 < v267)
        {
          unint64_t v269 = v268;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v255 + 16), &v269, v267);
            if (v269 == v268) {
              break;
            }
            unint64_t v268 = v269;
          }
          while (v269 < v267);
        }
        if (v471 == v470)
        {
          (*(void (**)(void *))(v470[0] + 32))(v470);
        }
        else if (v471)
        {
          (*(void (**)(void))(*v471 + 40))();
        }
        v453 |= v258;
        uint64_t v219 = v254;
        if (v255) {
          goto LABEL_489;
        }
      }
    }
LABEL_452:
    if ((unint64_t)++v247 < v194[5]) {
      continue;
    }
    break;
  }
  if (v246) {
    objc_msgSend(v461, "setVertexBuffers:offsets:withRange:", v480, &v472, v219, v246);
  }
LABEL_504:

  if (v194[9])
  {
    uint64_t v451 = 0;
    uint64_t v276 = 0;
    while (1)
    {
      int v277 = (unsigned __int8 *)(v194[8] + 2 * v276);
      uint64_t v278 = *v277;
      uint64_t v279 = v277[1];
      uint64_t v280 = *(unsigned __int8 *)(v194[10] + 2 * v276 + 1);
      if ((*(unsigned int (**)(void *, uint64_t))(*v460 + 24))(v460, v278))
      {
        if (*(void *)(v460[12] + 8 * v278)) {
          v281 = *(Texture **)(v460[12] + 8 * v278);
        }
        else {
          v281 = (Texture *)v459[9];
        }
        uint64_t v282 = *((void *)v281 + 3);
        uint64_t v283 = 1 << v278;
        if ((v451 & (1 << v278)) != 0)
        {
          v284 = v449;
          if (!v282) {
            goto LABEL_506;
          }
        }
        else
        {
          unint64_t v285 = v459[5];
          uint64_t v286 = *((void *)v281 + 3);
          v284 = v449;
          if (v282 == 3735927469)
          {
            BOOL v287 = *(const char **)(v455 + 16);
            if (GEOGetGeoGLDefaultLog_onceToken != -1) {
              dispatch_once(&GEOGetGeoGLDefaultLog_onceToken, &__block_literal_global_53364);
            }
            v288 = (id)GEOGetGeoGLDefaultLog_log;
            if (os_log_type_enabled(v288, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v480[0]) = 136315906;
              int v289 = "";
              if (v287) {
                int v289 = v287;
              }
              *(void *)((char *)v480 + 4) = v289;
              WORD2(v480[1]) = 2080;
              *(void *)((char *)&v480[1] + 6) = "!dataHolder->isStale()";
              HIWORD(v480[2]) = 2080;
              v480[3] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalRenderItemEncoder.mm";
              LOWORD(v481) = 1024;
              *(_DWORD *)((char *)&v481 + 2) = 61;
              _os_log_impl(&dword_1A1780000, v288, OS_LOG_TYPE_ERROR, "Marking stale resource as used by gpu - %s: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)v480, 0x26u);
            }

            uint64_t v286 = *((void *)v281 + 3);
            v284 = v449;
          }
          unint64_t v290 = atomic_load((unint64_t *)(v286 + 16));
          if (v290 < v285)
          {
            unint64_t v291 = v290;
            do
            {
              atomic_compare_exchange_strong((atomic_ullong *volatile)(v286 + 16), &v291, v285);
              if (v291 == v290) {
                break;
              }
              unint64_t v290 = v291;
            }
            while (v291 < v285);
          }
          v451 |= v283;
          if (!v282) {
            goto LABEL_506;
          }
        }
        SamplerStateResource = ggl::MetalResourceManager::getSamplerStateResource(v284, v281);
        if (SamplerStateResource)
        {
          if (*(unsigned char *)(v282 + 120) == 1)
          {
            v293 = (id *)(*(void *)(v282 + 32) + 8 * *(unsigned int *)(v282 + 64));
LABEL_532:
            v281 = (Texture *)*v293;
          }
          else if (!*(unsigned char *)(v282 + 120))
          {
            v293 = *(id **)(v282 + 32);
            goto LABEL_532;
          }
          uint64_t v294 = v458[26];
          uint64_t v295 = *(void *)(v294 + 8 * v279);
          if (v295) {
            BOOL v296 = v295 == v282;
          }
          else {
            BOOL v296 = 0;
          }
          if (!v296)
          {
            *(void *)(v294 + 8 * v279) = v282;
            [v461 setVertexTexture:v281 atIndex:v279];
          }
          id v297 = (id)SamplerStateResource[4];
          uint64_t v298 = v458[32];
          v299 = *(uint64_t **)(v298 + 8 * v280);
          if (v299) {
            BOOL v300 = v299 == SamplerStateResource;
          }
          else {
            BOOL v300 = 0;
          }
          char v301 = v300;
          if (!v300) {
            *(void *)(v298 + 8 * v280) = SamplerStateResource;
          }
          unint64_t v302 = v459[5];
          unint64_t v303 = atomic_load((unint64_t *)SamplerStateResource + 2);
          if (v303 < v302)
          {
            unint64_t v304 = v303;
            do
            {
              atomic_compare_exchange_strong(SamplerStateResource + 2, &v304, v302);
              if (v304 == v303) {
                break;
              }
              unint64_t v303 = v304;
            }
            while (v304 < v302);
          }
          if ((v301 & 1) == 0) {
            [v461 setVertexSamplerState:v297 atIndex:v280];
          }
        }
      }
LABEL_506:
      if ((unint64_t)++v276 >= v194[9]) {
        goto LABEL_554;
      }
    }
  }
  uint64_t v451 = 0;
LABEL_554:
  uint64_t v305 = *(void **)(*(void *)(*(void *)(v460[2] + 40) + 8) + 24);
  long long v485 = 0u;
  long long v486 = 0u;
  long long v483 = 0u;
  long long v484 = 0u;
  long long v481 = 0u;
  long long v482 = 0u;
  memset(v480, 0, sizeof(v480));
  long long v478 = 0u;
  long long v479 = 0u;
  long long v476 = 0u;
  long long v477 = 0u;
  long long v474 = 0u;
  long long v475 = 0u;
  long long v472 = 0u;
  long long v473 = 0u;
  v456 = v305;
  v306 = (void *)v305[7];
  if (!v306) {
    goto LABEL_577;
  }
  uint64_t v307 = 0;
  unint64_t v308 = 0;
  unint64_t v309 = 0;
  unint64_t v310 = v456;
  while (2)
  {
    uint64_t v311 = (unsigned __int8 *)(v310[6] + 2 * v309);
    uint64_t v312 = *v311;
    uint64_t v313 = v311[1];
    if (v308)
    {
      if (v308 > 0xF || v307 + v308 != v313)
      {
        objc_msgSend(v461, "setFragmentBuffers:offsets:withRange:", v480, &v472, v307, v308);
        unint64_t v308 = 0;
        goto LABEL_560;
      }
    }
    else
    {
LABEL_560:
      uint64_t v307 = v313;
    }
    uint64_t v314 = *(void *)(v460[4] + 16 * v312);
    uint64_t v315 = *(void *)(v314 + 24);
    uint64_t v316 = *(void *)(v315 + 24);
    unint64_t v317 = v459[5];
    uint64_t v318 = v316;
    if (v316 == 3735927469)
    {
      v319 = *(const char **)(v455 + 16);
      if (GEOGetGeoGLDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoGLDefaultLog_onceToken, &__block_literal_global_53364);
      }
      v320 = (id)GEOGetGeoGLDefaultLog_log;
      if (os_log_type_enabled(v320, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315906;
        v321 = "";
        if (v319) {
          v321 = v319;
        }
        *(void *)&buf[4] = v321;
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "!dataHolder->isStale()";
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&buf[24] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalRenderItemEncoder.mm";
        LOWORD(v470[0]) = 1024;
        *(_DWORD *)((char *)v470 + 2) = 61;
        _os_log_impl(&dword_1A1780000, v320, OS_LOG_TYPE_ERROR, "Marking stale resource as used by gpu - %s: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
      }

      uint64_t v318 = *(void *)(v315 + 24);
    }
    unint64_t v322 = atomic_load((unint64_t *)(v318 + 16));
    if (v322 < v317)
    {
      unint64_t v323 = v322;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v318 + 16), &v323, v317);
        if (v323 == v322) {
          break;
        }
        unint64_t v322 = v323;
      }
      while (v323 < v317);
    }
    v324 = *(void **)(v316 + 32);
    id v325 = v324;
    objc_storeStrong((id *)&v480[v308], v324);
    uint64_t v326 = v459[3];
    if (*(_DWORD *)(v314 + 112) <= 1u) {
      uint64_t v326 = 0;
    }
    *((void *)&v472 + v308) = *(void *)(v314 + 40) + v326 * *(void *)(v314 + 120);

    ++v308;
    ++v309;
    unint64_t v310 = v456;
    if (v309 < v456[7]) {
      continue;
    }
    break;
  }
  objc_msgSend(v461, "setFragmentBuffers:offsets:withRange:", v480, &v472, v307, v308);
  v306 = (void *)*((void *)&v486 + 1);
LABEL_577:

  long long v485 = 0u;
  long long v486 = 0u;
  long long v483 = 0u;
  long long v484 = 0u;
  long long v481 = 0u;
  long long v482 = 0u;
  memset(v480, 0, sizeof(v480));
  long long v478 = 0u;
  long long v479 = 0u;
  long long v476 = 0u;
  long long v477 = 0u;
  long long v474 = 0u;
  long long v475 = 0u;
  long long v472 = 0u;
  long long v473 = 0u;
  v327 = v456;
  if (!v456[5]) {
    goto LABEL_640;
  }
  uint64_t v446 = 0;
  unint64_t v328 = 0;
  uint64_t v329 = 0;
  while (2)
  {
    v331 = (unsigned __int8 *)(v327[4] + 2 * v329);
    uint64_t v332 = *v331;
    uint64_t v330 = v331[1];
    if ((*(unsigned int (**)(void *, uint64_t))(*v460 + 16))(v460, v332))
    {
      uint64_t v333 = *(void *)(v460[8] + 16 * v332);
      if (v333)
      {
        uint64_t v334 = *(void *)(v333 + 24);
        if (v334) {
          goto LABEL_585;
        }
LABEL_591:
        uint64_t v335 = 0;
      }
      else
      {
        if (GEOGetGeoGLDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetGeoGLDefaultLog_onceToken, &__block_literal_global_53364);
        }
        v336 = (id)GEOGetGeoGLDefaultLog_log;
        if (os_log_type_enabled(v336, OS_LOG_TYPE_ERROR))
        {
          uint64_t v337 = **(void **)(*(void *)(v460[1] + 24) + 8 * v332);
          *(_DWORD *)buf = 136315906;
          *(void *)&buf[4] = v337;
          *(_WORD *)&buf[12] = 2080;
          *(void *)&buf[14] = "false";
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&buf[24] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalRenderItemEncoder.mm";
          LOWORD(v470[0]) = 1024;
          *(_DWORD *)((char *)v470 + 2) = 647;
          _os_log_impl(&dword_1A1780000, v336, OS_LOG_TYPE_ERROR, "You must bind constant data for every one you use in your shader:%s: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
        }

        uint64_t v334 = MEMORY[0x18];
        if (!MEMORY[0x18]) {
          goto LABEL_591;
        }
LABEL_585:
        uint64_t v335 = *(void *)(v334 + 24);
      }
      uint64_t v338 = 1 << v332;
      if ((v453 & (1 << v332)) != 0)
      {
        v327 = v456;
        if (!v335) {
          goto LABEL_581;
        }
LABEL_626:
        double v354 = *(void **)(v335 + 32);
        id v355 = v354;
        uint64_t v356 = v458[23];
        uint64_t v357 = *(void *)(v356 + 8 * v330);
        if (v357) {
          BOOL v358 = v357 == v335;
        }
        else {
          BOOL v358 = 0;
        }
        if (v358)
        {
          uint64_t v330 = v446;
        }
        else
        {
          *(void *)(v356 + 8 * v330) = v335;
          if (v328)
          {
            if (v328 <= 0xF && v446 + v328 == v330)
            {
              uint64_t v330 = v446;
            }
            else
            {
              objc_msgSend(v461, "setFragmentBuffers:offsets:withRange:", v480, &v472, v446, v328);
              unint64_t v328 = 0;
            }
          }
          objc_storeStrong((id *)&v480[v328], v354);
          uint64_t v359 = v459[3];
          if (*(_DWORD *)(v333 + 112) <= 1u) {
            uint64_t v359 = 0;
          }
          *((void *)&v472 + v328++) = *(void *)(v333 + 40) + v359 * *(void *)(v333 + 120);
        }

        uint64_t v446 = v330;
        v327 = v456;
      }
      else
      {
        unint64_t v444 = v328;
        uint64_t v339 = *(void *)(v460[8] + 16 * v332);
        uint64_t v341 = v459[3];
        uint64_t v340 = v459[4];
        if (!*(void *)(v339 + 24)) {
          ggl::BufferData::prepareBufferForDevice(*(std::mutex **)(v460[8] + 16 * v332), v443, 0);
        }
        if (*(unsigned char *)(v339 + 18) == 1 && *(void *)(v339 + 192) != v340 && *(_DWORD *)(v339 + 112))
        {
          *(void *)(v339 + 192) = v340;
          *(_OWORD *)(v339 + 56) = *(_OWORD *)(v339 + 40);
        }
        if (*(_DWORD *)(v339 + 112) <= 1u) {
          uint64_t v342 = 0;
        }
        else {
          uint64_t v342 = v341;
        }
        int64x2_t v343 = *(int64x2_t *)(v339 + 56);
        int64x2_t v344 = vaddq_s64(vdupq_n_s64(v342 * *(void *)(v339 + 120)), v343);
        *(void *)(v339 + 56) = 0;
        *(void *)(v339 + 64) = 0;
        uint64_t v345 = *(void *)(v339 + 24);
        *(void *)buf = *(void *)(v339 + 72) + v343.i64[0];
        *(void *)&buf[8] = v345;
        *(int64x2_t *)&buf[16] = v344;
        v471 = 0;
        uint64_t v333 = *(void *)(v460[8] + 16 * v332);
        uint64_t v346 = *(void *)(v333 + 24);
        if (*(_DWORD *)(v333 + 112) >= 2u && !*(void *)(v333 + 104)) {
          *(void *)(v333 + 104) = v459[7];
        }
        unint64_t v328 = v444;
        if ((vmovn_s64(vceqq_s64(v344, vdupq_laneq_s64(v344, 1))).u32[0] & 1) == 0) {
          ggl::MetalResourceManager::upload((uint64_t *)v449, (uint64_t)buf, v333);
        }
        uint64_t v335 = *(void *)(v346 + 24);
        unint64_t v347 = v459[5];
        uint64_t v348 = v335;
        if (v335 == 3735927469)
        {
          int v349 = *(const char **)(v455 + 16);
          if (GEOGetGeoGLDefaultLog_onceToken != -1) {
            dispatch_once(&GEOGetGeoGLDefaultLog_onceToken, &__block_literal_global_53364);
          }
          BOOL v350 = (id)GEOGetGeoGLDefaultLog_log;
          if (os_log_type_enabled(v350, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v487 = 136315906;
            v351 = "";
            if (v349) {
              v351 = v349;
            }
            v488 = v351;
            __int16 v489 = 2080;
            v490 = "!dataHolder->isStale()";
            __int16 v491 = 2080;
            v492 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalRenderItemEncoder.mm";
            __int16 v493 = 1024;
            int v494 = 61;
            _os_log_impl(&dword_1A1780000, v350, OS_LOG_TYPE_ERROR, "Marking stale resource as used by gpu - %s: Assertion with expression - %s : Failed in file - %s line - %i", v487, 0x26u);
          }

          unint64_t v328 = v444;
          uint64_t v348 = *(void *)(v346 + 24);
        }
        unint64_t v352 = atomic_load((unint64_t *)(v348 + 16));
        if (v352 < v347)
        {
          unint64_t v353 = v352;
          do
          {
            atomic_compare_exchange_strong((atomic_ullong *volatile)(v348 + 16), &v353, v347);
            if (v353 == v352) {
              break;
            }
            unint64_t v352 = v353;
          }
          while (v353 < v347);
        }
        if (v471 == v470)
        {
          (*(void (**)(void *))(v470[0] + 32))(v470);
        }
        else if (v471)
        {
          (*(void (**)(void))(*v471 + 40))();
        }
        v453 |= v338;
        v327 = v456;
        if (v335) {
          goto LABEL_626;
        }
      }
    }
LABEL_581:
    if ((unint64_t)++v329 < v327[5]) {
      continue;
    }
    break;
  }
  if (v328) {
    objc_msgSend(v461, "setFragmentBuffers:offsets:withRange:", v480, &v472, v446, v328);
  }
LABEL_640:

  BOOL v360 = v456;
  if (v456[9])
  {
    unint64_t v361 = 0;
    while (2)
    {
      BOOL v362 = (unsigned __int8 *)(v360[8] + 2 * v361);
      uint64_t v363 = *v362;
      uint64_t v364 = v362[1];
      uint64_t v365 = *(unsigned __int8 *)(v360[10] + 2 * v361 + 1);
      if (!(*(unsigned int (**)(void *, uint64_t))(*v460 + 24))(v460, v363)) {
        goto LABEL_642;
      }
      if (*(void *)(v460[12] + 8 * v363)) {
        v366 = *(Texture **)(v460[12] + 8 * v363);
      }
      else {
        v366 = (Texture *)v459[9];
      }
      double v367 = (uint64_t *)*((void *)v366 + 3);
      uint64_t v368 = 1 << v363;
      if ((v451 & (1 << v363)) != 0)
      {
        if (!v367) {
          goto LABEL_642;
        }
LABEL_670:
        uint64_t v378 = ggl::MetalResourceManager::getSamplerStateResource(v449, v366);
        if (v378)
        {
          if (*((unsigned char *)v367 + 120) == 1)
          {
            v379 = (id *)(v367[4] + 8 * *((unsigned int *)v367 + 16));
LABEL_675:
            v366 = (Texture *)*v379;
          }
          else if (!*((unsigned char *)v367 + 120))
          {
            v379 = (id *)v367[4];
            goto LABEL_675;
          }
          uint64_t v380 = v458[29];
          float v381 = *(uint64_t **)(v380 + 8 * v364);
          if (v381) {
            BOOL v382 = v381 == v367;
          }
          else {
            BOOL v382 = 0;
          }
          if (!v382)
          {
            *(void *)(v380 + 8 * v364) = v367;
            [v461 setFragmentTexture:v366 atIndex:v364];
          }
          id v383 = (id)v378[4];
          uint64_t v384 = v458[35];
          uint64_t v385 = *(uint64_t **)(v384 + 8 * v365);
          if (v385) {
            BOOL v386 = v385 == v378;
          }
          else {
            BOOL v386 = 0;
          }
          char v387 = v386;
          if (!v386) {
            *(void *)(v384 + 8 * v365) = v378;
          }
          unint64_t v388 = v459[5];
          unint64_t v389 = atomic_load((unint64_t *)v378 + 2);
          if (v389 < v388)
          {
            unint64_t v390 = v389;
            do
            {
              atomic_compare_exchange_strong(v378 + 2, &v390, v388);
              if (v390 == v389) {
                break;
              }
              unint64_t v389 = v390;
            }
            while (v390 < v388);
          }
          if ((v387 & 1) == 0) {
            [v461 setFragmentSamplerState:v383 atIndex:v365];
          }
        }
LABEL_642:
        ++v361;
        BOOL v360 = v456;
        if (v361 >= v456[9]) {
          goto LABEL_696;
        }
        continue;
      }
      break;
    }
    if (!v367)
    {
      int v369 = *((_DWORD *)v366 + 14);
      if (v369 == 1)
      {
        v370 = ggl::MetalResourceManager::newTexture(v449, v366);
LABEL_655:
        double v367 = v370;
      }
      else
      {
        if (v369 == 4)
        {
          v370 = ggl::MetalResourceManager::prepareTexture((std::__shared_weak_count **)v449, v366, v459[5]);
          goto LABEL_655;
        }
        double v367 = 0;
      }
    }
    unint64_t v371 = v459[5];
    uint64_t v372 = *((void *)v366 + 3);
    if (v372 == 3735927469)
    {
      float v373 = *(const char **)(v455 + 16);
      if (GEOGetGeoGLDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoGLDefaultLog_onceToken, &__block_literal_global_53364);
      }
      char v374 = (id)GEOGetGeoGLDefaultLog_log;
      if (os_log_type_enabled(v374, OS_LOG_TYPE_ERROR))
      {
        LODWORD(v480[0]) = 136315906;
        v375 = "";
        if (v373) {
          v375 = v373;
        }
        *(void *)((char *)v480 + 4) = v375;
        WORD2(v480[1]) = 2080;
        *(void *)((char *)&v480[1] + 6) = "!dataHolder->isStale()";
        HIWORD(v480[2]) = 2080;
        v480[3] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalRenderItemEncoder.mm";
        LOWORD(v481) = 1024;
        *(_DWORD *)((char *)&v481 + 2) = 61;
        _os_log_impl(&dword_1A1780000, v374, OS_LOG_TYPE_ERROR, "Marking stale resource as used by gpu - %s: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)v480, 0x26u);
      }

      uint64_t v372 = *((void *)v366 + 3);
    }
    unint64_t v376 = atomic_load((unint64_t *)(v372 + 16));
    if (v376 < v371)
    {
      unint64_t v377 = v376;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v372 + 16), &v377, v371);
        if (v377 == v376) {
          break;
        }
        unint64_t v376 = v377;
      }
      while (v377 < v371);
    }
    v451 |= v368;
    if (!v367) {
      goto LABEL_642;
    }
    goto LABEL_670;
  }
LABEL_696:
  if (((*(unsigned char *)(*(void *)(v455 + 24) + 58) - 1) & 0xFC) != 0) {
    uint64_t v391 = 0;
  }
  else {
    uint64_t v391 = (*(unsigned char *)(*(void *)(v455 + 24) + 58) - 1) + 1;
  }
  if (v448 && (uint64_t v392 = *(void *)(v448 + 96)) != 0)
  {
    uint64_t v442 = v391;
    uint64_t v393 = *(void *)(v392 + 24);
    if (*(_DWORD *)(v392 + 112) >= 2u && !*(void *)(v392 + 104)) {
      *(void *)(v392 + 104) = v459[7];
    }
    uint64_t v394 = *(void *)(v393 + 24);
    unint64_t v395 = v459[5];
    uint64_t v396 = v394;
    if (v394 == 3735927469)
    {
      unint64_t v397 = *(const char **)(v455 + 16);
      if (GEOGetGeoGLDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoGLDefaultLog_onceToken, &__block_literal_global_53364);
      }
      unint64_t v398 = (id)GEOGetGeoGLDefaultLog_log;
      if (os_log_type_enabled(v398, OS_LOG_TYPE_ERROR))
      {
        v399 = "";
        if (v397) {
          v399 = v397;
        }
        LODWORD(v480[0]) = 136315906;
        *(void *)((char *)v480 + 4) = v399;
        WORD2(v480[1]) = 2080;
        *(void *)((char *)&v480[1] + 6) = "!dataHolder->isStale()";
        HIWORD(v480[2]) = 2080;
        v480[3] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalRenderItemEncoder.mm";
        LOWORD(v481) = 1024;
        *(_DWORD *)((char *)&v481 + 2) = 61;
        _os_log_impl(&dword_1A1780000, v398, OS_LOG_TYPE_ERROR, "Marking stale resource as used by gpu - %s: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)v480, 0x26u);
      }

      uint64_t v396 = *(void *)(v393 + 24);
    }
    unint64_t v400 = atomic_load((unint64_t *)(v396 + 16));
    if (v400 < v395)
    {
      unint64_t v401 = v400;
      do
      {
        atomic_compare_exchange_strong((atomic_ullong *volatile)(v396 + 16), &v401, v395);
        if (v401 == v400) {
          break;
        }
        unint64_t v400 = v401;
      }
      while (v401 < v395);
    }
    id v445 = *(id *)(v394 + 32);
    uint64_t v402 = v455;
    uint64_t v403 = v442;
    if (*(void *)(v455 + 96))
    {
      for (uint64_t i = 0; i != *(void *)(v455 + 96); ++i)
      {
        uint64_t v405 = *(void *)(v402 + 88);
        if (!v405) {
          uint64_t v405 = v455 + 72;
        }
        uint64_t v406 = (uint64_t *)(v405 + 16 * i);
        uint64_t v408 = *v406;
        uint64_t v407 = v406[1];
        uint64_t v409 = *(void *)(v448 + 96);
        uint64_t v410 = v407 - v408;
        uint64_t v457 = *(void *)(v409 + 40);
        unint64_t v454 = *(void *)(v409 + 8);
        if (v407 == v408) {
          uint64_t v410 = (*(void *)(v409 + 48) - v457) / v454 - v408;
        }
        uint64_t v411 = v459[3];
        if (*(_DWORD *)(v409 + 112) <= 1u) {
          uint64_t v411 = 0;
        }
        v450 = *(ggl::MetalResourceManager **)(v409 + 120);
        uint64_t v452 = v411;
        long long v485 = 0u;
        long long v486 = 0u;
        long long v483 = 0u;
        long long v484 = 0u;
        long long v481 = 0u;
        long long v482 = 0u;
        memset(v480, 0, sizeof(v480));
        if (v194[7])
        {
          uint64_t v447 = v410;
          uint64_t v412 = 0;
          unint64_t v413 = 0;
          unint64_t v414 = 0;
          v415 = v458;
          while (2)
          {
            v416 = (unsigned __int8 *)(v194[6] + 2 * v412);
            uint64_t v417 = *(void *)(v460[4] + 16 * *v416);
            if (!v417 || !*(void *)(v417 + 24)) {
              goto LABEL_730;
            }
            uint64_t v418 = *(void *)(v417 + 40);
            if (*(_DWORD *)(v417 + 112) < 2u) {
              uint64_t v419 = *(void *)(v417 + 8) * v418;
            }
            else {
              uint64_t v419 = v418 + v459[3] * *(void *)(v417 + 120);
            }
            unint64_t v420 = v416[1];
            uint64_t v421 = v415[1];
            uint64_t v422 = *(void *)(v421 + 8 * v420);
            if (v422 != v419) {
              *(void *)(v421 + 8 * v420) = v419;
            }
            if (v414)
            {
              unint64_t v423 = v413 + v414;
              if (v414 <= 0xF && v423 == v420)
              {
                unint64_t v420 = v413;
                if (v422 != v419) {
LABEL_747:
                }
                  v480[v414++] = v419;
LABEL_729:
                unint64_t v413 = v420;
                v415 = v458;
LABEL_730:
                if ((unint64_t)++v412 >= v194[7])
                {
                  uint64_t v403 = v442;
                  uint64_t v410 = v447;
                  if (v414 && v413 < v413 + v414)
                  {
                    int v426 = v480;
                    do
                    {
                      uint64_t v427 = *v426++;
                      [v461 setVertexBufferOffset:v427 atIndex:v413++];
                      --v414;
                    }
                    while (v414);
                  }
                  goto LABEL_754;
                }
                continue;
              }
              if (v413 >= v423)
              {
                unint64_t v414 = 0;
                if (v422 != v419) {
                  goto LABEL_747;
                }
                goto LABEL_729;
              }
              v424 = v480;
              do
              {
                uint64_t v425 = *v424++;
                [v461 setVertexBufferOffset:v425 atIndex:v413++];
                --v414;
              }
              while (v414);
            }
            break;
          }
          if (v422 != v419) {
            goto LABEL_747;
          }
          goto LABEL_729;
        }
LABEL_754:
        uint64_t v428 = v457 + v454 * v408 + v452 * (void)v450;
        uint64_t v429 = *(void *)(v455 + 112);
        uint64_t v430 = *(void *)(v448 + 96);
        if (*(void *)(v455 + 104) == 1)
        {
          if (!v429)
          {
            [v461 drawIndexedPrimitives:v403 indexCount:v410 indexType:*(_DWORD *)(v430 + 216) != 0 indexBuffer:v445 indexBufferOffset:v428];
            goto LABEL_720;
          }
        }
        else if (!v429)
        {
          objc_msgSend(v461, "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:", v403, v410, *(_DWORD *)(v430 + 216) != 0, v445, v428);
          goto LABEL_720;
        }
        objc_msgSend(v461, "drawIndexedPrimitives:indexCount:indexType:indexBuffer:indexBufferOffset:instanceCount:baseVertex:baseInstance:", v403, v410, *(_DWORD *)(v430 + 216) != 0, v445, 0, v429);
LABEL_720:
        uint64_t v402 = v455;
      }
    }
  }
  else if (*(void *)(v455 + 96))
  {
    uint64_t v431 = 0;
    uint64_t v432 = 0;
    do
    {
      if (*(void *)(v455 + 104) == 1 && *(void *)(v455 + 112) == 0) {
        objc_msgSend(v461, "drawPrimitives:vertexStart:vertexCount:", v391);
      }
      else {
        objc_msgSend(v461, "drawPrimitives:vertexStart:vertexCount:instanceCount:baseInstance:", v391);
      }
      ++v432;
      v431 += 16;
    }
    while (v432 != *(void *)(v455 + 96));
  }

LABEL_769:
}

void sub_1A17DDC20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Unwind_Resume(a1);
}

BOOL ggl::SolidRibbon::PipelineSetup::constantDataIsEnabled(ggl::SolidRibbon::PipelineSetup *this, unint64_t a2)
{
  if (a2 < 3) {
    return 1;
  }
  if (a2 == 3) {
    return *(unsigned char *)(*((void *)this + 2) + 309) != 0;
  }
  return 0;
}

BOOL ggl::SolidRibbon::PipelineSetup::textureIsEnabled(ggl::SolidRibbon::PipelineSetup *this, uint64_t a2)
{
  if (a2 == 1)
  {
    int v2 = *(unsigned __int8 *)(*((void *)this + 2) + 308);
    return v2 != 0;
  }
  if (!a2)
  {
    int v2 = *(unsigned __int8 *)(*((void *)this + 2) + 307);
    return v2 != 0;
  }
  return 0;
}

uint64_t *ggl::MetalResourceManager::upload(uint64_t *result, uint64_t a2, uint64_t a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (*(void *)(a2 + 24) != *(void *)(a2 + 16))
  {
    uint64_t v5 = *(const ggl::Buffer **)(a2 + 8);
    BOOL v6 = (uint64_t *)*((void *)v5 + 3);
    uint64_t v7 = v6;
    if (!v6)
    {
      uint64_t result = ggl::MetalResourceManager::newBuffer((ggl::MetalResourceManager *)result, v5);
      if (!result) {
        return result;
      }
      uint64_t v7 = result;
      BOOL v6 = *(uint64_t **)(*(void *)(a2 + 8) + 24);
    }
    if (v6 == (uint64_t *)3735927469)
    {
      if (!a3) {
        goto LABEL_11;
      }
    }
    else if (!a3 || v7[4])
    {
      goto LABEL_11;
    }
    if (os_log_type_enabled(MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT))
    {
      uint64_t v8 = **(void **)(a3 + 200);
      int v9 = 136315138;
      uint64_t v10 = v8;
      _os_log_fault_impl(&dword_1A1780000, MEMORY[0x1E4F14500], OS_LOG_TYPE_FAULT, "Trying to upload a stale buffer. Name : %s", (uint8_t *)&v9, 0xCu);
      uint64_t result = (uint64_t *)v7[4];
      if (!result) {
        return result;
      }
LABEL_12:
      memcpy((void *)([result contents] + *(void *)(a2 + 16)), *(const void **)a2, *(void *)(a2 + 24) - *(void *)(a2 + 16));
      uint64_t result = *(uint64_t **)(a2 + 56);
      if (result) {
        return (uint64_t *)(*(uint64_t (**)(uint64_t *, uint64_t))(*result + 48))(result, a2);
      }
      return result;
    }
LABEL_11:
    uint64_t result = (uint64_t *)v7[4];
    if (!result) {
      return result;
    }
    goto LABEL_12;
  }
  return result;
}

BOOL ggl::Grid::GridPipelineSetup::constantDataIsEnabled(ggl::Grid::GridPipelineSetup *this, uint64_t a2)
{
  if ((unint64_t)(a2 - 2) < 2 || a2 == 0) {
    return 1;
  }
  if (a2 == 1) {
    return *(unsigned char *)(*((void *)this + 2) + 305) != 0;
  }
  return 0;
}

uint64_t *ggl::MetalResourceManager::getSamplerStateResource(ggl::MetalResourceManager *this, const Texture *a2)
{
  switch(*((_DWORD *)a2 + 14))
  {
    case 1:
    case 2:
    case 4:
      uint64_t v3 = *((void *)a2 + 17);
      id v4 = *(uint64_t **)(v3 + 24);
      if (!v4) {
        goto LABEL_6;
      }
      break;
    case 3:
      uint64_t v3 = *((void *)a2 + 26);
      id v4 = *(uint64_t **)(v3 + 24);
      if (!v4)
      {
LABEL_6:
        id v5 = objc_alloc_init(MEMORY[0x1E4F35300]);
        BOOL v6 = v5;
        unsigned int v7 = *(_DWORD *)(v3 + 36) - 1;
        if (v7 > 2) {
          uint64_t v8 = 2;
        }
        else {
          uint64_t v8 = qword_1A29CAE68[v7];
        }
        [v5 setSAddressMode:v8];
        unsigned int v9 = *(_DWORD *)(v3 + 40) - 1;
        if (v9 > 2) {
          uint64_t v10 = 2;
        }
        else {
          uint64_t v10 = qword_1A29CAE68[v9];
        }
        [v6 setTAddressMode:v10];
        [v6 setMinFilter:*(_DWORD *)(v3 + 52) != 0];
        [v6 setMagFilter:*(_DWORD *)(v3 + 48) != 0];
        if (*(_DWORD *)(v3 + 56)) {
          uint64_t v11 = 2;
        }
        else {
          uint64_t v11 = 1;
        }
        [v6 setMipFilter:v11];
        [v6 setMaxAnisotropy:*(unsigned int *)(v3 + 44)];
        uint64_t v12 = (*(_DWORD *)(v3 + 60) - 1);
        if (v12 < 7) {
          uint64_t v13 = v12 + 1;
        }
        else {
          uint64_t v13 = 0;
        }
        [v6 setCompareFunction:v13];
        uint64_t v14 = (void *)[*(id *)(*((void *)this + 32) + 104) newSamplerStateWithDescriptor:v6];
        id v4 = &qword_1EB32C000;
        while (1)
        {
          id v4 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v4[287] + 16))(v4[287], 40, 8);
          *id v4 = 0;
          *((_WORD *)v4 + 4) = 513;
          v4[2] = 0;
          v4[3] = 0;
          v4[4] = 0;
          objc_storeStrong((id *)v4 + 4, v14);
          uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 2);
          if (v15)
          {
            uint64_t v16 = *((void *)this + 1);
            uint64_t v17 = std::__shared_weak_count::lock(v15);
            if (v17) {
              break;
            }
          }
          std::__throw_bad_weak_ptr[abi:nn180100]();
LABEL_27:
            operator new();
        }
        uint64_t v18 = *(std::__shared_weak_count **)(v3 + 16);
        *(void *)(v3 + 8) = v16;
        *(void *)(v3 + 16) = v17;
        if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
        *(void *)(v3 + 24) = v4;
        ++*(_DWORD *)(v3 + 32);
        ggl::ResourceManager::_addResourceStat((uint64_t)this, "SamplerState", 0xC9803BE00000000CLL, 0);
      }
      break;
    default:
      id v4 = 0;
      break;
  }
  return v4;
}

void sub_1A17DE4C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup::constantDataIsEnabled(ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup *this, uint64_t a2)
{
  BOOL result = 1;
  switch(a2)
  {
    case 0:
    case 1:
    case 3:
      return result;
    case 2:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 336);
      goto LABEL_5;
    case 4:
      int v4 = *(unsigned __int8 *)(*((void *)this + 2) + 339);
LABEL_5:
      BOOL result = v4 != 0;
      break;
    default:
      BOOL result = 0;
      break;
  }
  return result;
}

BOOL ggl::DaVinci::ElevatedFillColorWithDistancePipelineSetup::constantDataIsEnabled(ggl::DaVinci::ElevatedFillColorWithDistancePipelineSetup *this, unint64_t a2)
{
  if (a2 < 3) {
    return 1;
  }
  if (a2 == 3) {
    return *(unsigned char *)(*((void *)this + 2) + 336) != 0;
  }
  return 0;
}

BOOL ggl::GlobeAtmosphere::BasePipelineSetup::constantDataIsEnabled(ggl::GlobeAtmosphere::BasePipelineSetup *this, unint64_t a2)
{
  return a2 < 2;
}

BOOL ggl::Clear::ClearPipelineSetup::constantDataIsEnabled(ggl::Clear::ClearPipelineSetup *this, uint64_t a2)
{
  return a2 == 0;
}

BOOL ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup::textureIsEnabled(ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup *this, uint64_t a2)
{
  return !a2 && *(unsigned char *)(*((void *)this + 2) + 339) != 0;
}

char *std::vector<ggl::Texture2DLoadItem,geo::StdAllocator<ggl::Texture2DLoadItem,ggl::Allocator>>::__emplace_back_slow_path<ggl::Texture2DLoadItem>(char **a1, uint64_t a2)
{
  uint64_t v2 = 0x333333333333333;
  unint64_t v3 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 4);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0x333333333333333) {
    abort();
  }
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 4) > v4) {
    unint64_t v4 = 0x999999999999999ALL * ((a1[2] - *a1) >> 4);
  }
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 4) < 0x199999999999999) {
    uint64_t v2 = v4;
  }
  if (v2)
  {
    uint64_t v7 = 80 * v2;
    uint64_t v8 = (*(uint64_t (**)(char *, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 80 * v2, 8);
    unsigned int v9 = (char *)(v8 + 80 * v3);
    uint64_t v10 = v8 + v7;
    if (v8)
    {
      *(_OWORD *)unsigned int v9 = *(_OWORD *)a2;
      unint64_t v11 = v8 + 80 * v3;
      *(unsigned char *)(v11 + 16) = 0;
      uint64_t v12 = (unsigned char *)(v11 + 16);
      if (*(unsigned char *)(a2 + 16))
      {
        *(unsigned char *)(v8 + 80 * v3 + 17) = *(unsigned char *)(a2 + 17);
        *uint64_t v12 = 1;
      }
      unint64_t v13 = v8 + 80 * v3;
      *(unsigned char *)(v13 + 20) = 0;
      uint64_t v14 = (unsigned char *)(v13 + 20);
      if (*(unsigned char *)(a2 + 20))
      {
        *(_DWORD *)(v8 + 80 * v3 + 24) = *(_DWORD *)(a2 + 24);
        *uint64_t v14 = 1;
      }
      unint64_t v15 = v8 + 80 * v3;
      *(_OWORD *)(v15 + 28) = *(_OWORD *)(a2 + 28);
      uint64_t v16 = *(void *)(a2 + 72);
      if (v16)
      {
        uint64_t v17 = (void *)(v8 + 80 * v3 + 72);
        if (v16 == a2 + 48)
        {
          *uint64_t v17 = v15 + 48;
          (*(void (**)(void))(**(void **)(a2 + 72) + 24))(*(void *)(a2 + 72));
        }
        else
        {
          *uint64_t v17 = v16;
          *(void *)(a2 + 72) = 0;
        }
      }
      else
      {
        *(void *)(v8 + 80 * v3 + 72) = 0;
      }
    }
  }
  else
  {
    uint64_t v10 = 0;
    unsigned int v9 = (char *)(16 * ((a1[1] - *a1) >> 4));
  }
  uint64_t v18 = v9 + 80;
  BOOL v20 = *a1;
  id v19 = a1[1];
  if (v19 == *a1)
  {
    *a1 = v9;
    a1[1] = v18;
    int8x16_t v28 = a1[2];
    a1[2] = (char *)v10;
  }
  else
  {
    unint64_t v21 = 0;
    do
    {
      uint64_t v22 = &v9[v21];
      uint64_t v23 = &v19[v21];
      *((_OWORD *)v22 - 5) = *(_OWORD *)&v19[v21 - 80];
      *(v22 - 64) = 0;
      if (v19[v21 - 64])
      {
        *(v22 - 63) = *(v23 - 63);
        *(v22 - 64) = 1;
      }
      *(v22 - 60) = 0;
      if (*(v23 - 60))
      {
        *(_DWORD *)&v9[v21 - 56] = *(_DWORD *)&v19[v21 - 56];
        *(v22 - 60) = 1;
      }
      uint64_t v24 = &v9[v21];
      int v25 = &v19[v21];
      *(_OWORD *)&v9[v21 - 52] = *(_OWORD *)&v19[v21 - 52];
      unint64_t v26 = *(char **)&v19[v21 - 8];
      if (v26)
      {
        if (v25 - 32 == v26)
        {
          *((void *)v24 - 1) = v24 - 32;
          (*(void (**)(void))(**((void **)v25 - 1) + 24))(*((void *)v25 - 1));
        }
        else
        {
          *((void *)v24 - 1) = v26;
          *((void *)v25 - 1) = 0;
        }
      }
      else
      {
        *((void *)v24 - 1) = 0;
      }
      v21 -= 80;
    }
    while (&v19[v21] != v20);
    id v19 = *a1;
    unsigned int v27 = a1[1];
    *a1 = &v9[v21];
    a1[1] = v18;
    int8x16_t v28 = a1[2];
    a1[2] = (char *)v10;
    if (v27 != v19)
    {
      uint64_t v29 = v27 - 32;
      unint64_t v30 = v27 - 32;
      do
      {
        unint64_t v32 = (char *)*((void *)v30 + 3);
        if (v30 == v32)
        {
          (*(void (**)(char *))(*(void *)v30 + 32))(v30);
          if (!*(v30 - 28)) {
            goto LABEL_38;
          }
        }
        else
        {
          if (v32) {
            (*(void (**)(char *))(*(void *)v32 + 40))(v32);
          }
          if (!*(v30 - 28)) {
            goto LABEL_38;
          }
        }
        *(v30 - 28) = 0;
LABEL_38:
        if (*(v30 - 32)) {
          *(v30 - 32) = 0;
        }
        unint64_t v31 = v30 - 48;
        v30 -= 80;
        v29 -= 80;
      }
      while (v31 != v19);
    }
  }
  if (v19) {
    (*(void (**)(char *, char *, int64_t))(*(void *)a1[3] + 40))(a1[3], v19, v28 - v19);
  }
  return v18;
}

uint64_t __copy_helper_block_8_40c37_ZTSNSt3__110shared_ptrIN3geo4TaskEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t md::StandardLabeler::layoutForDisplay(md::StandardLabeler *this, const md::LayoutContext *a2, __n128 a3)
{
  __int16 v12 = 257;
  char v13 = 1;
  unint64_t v4 = (uint64_t *)*((void *)this + 13);
  id v5 = (uint64_t *)*((void *)this + 14);
  while (v4 != v5)
  {
    uint64_t v6 = *v4;
    v4 += 2;
    md::Label::layoutForDisplay(v6, *((void *)this + 3), (uint64_t)&v12);
  }
  if (!*(unsigned char *)(*((void *)this + 3) + 3382))
  {
    uint64_t v7 = (md::Label **)*((void *)this + 13);
    uint64_t v8 = (md::Label **)*((void *)this + 14);
    while (v7 != v8)
    {
      unsigned int v9 = *v7;
      v7 += 2;
      a3.n128_u32[0] = 1148846080;
      md::Label::animate(v9, a3);
    }
  }
  (*(void (**)(md::StandardLabeler *, const md::LayoutContext *))(*(void *)this + 320))(this, a2);
  uint64_t v10 = ***(uint64_t (****)(void))(*(void *)(*((void *)this + 3) + 168) + 72);
  return v10();
}

void md::Label::layoutForStaging(md::Label *a1, uint64_t a2, md::LabelPool *this, unsigned char *a4)
{
  uint64_t v8 = *(void *)(a2 + 432);
  *((unsigned char *)a1 + 1270) = *(unsigned char *)(v8 + 12);
  if (*((unsigned char *)a1 + 1249))
  {
    *(_WORD *)((char *)a1 + 1249) = 256;
    BOOL v9 = 1;
  }
  else if (*((unsigned char *)a1 + 1250))
  {
    BOOL v9 = 1;
  }
  else
  {
    BOOL v9 = *((unsigned char *)a1 + 1255) != 0;
  }
  *((unsigned char *)a1 + 405) = v9;
  *((unsigned char *)a1 + 482) = 0;
  if (this && (*((unsigned char *)a1 + 1261) || *((unsigned char *)a1 + 1262)))
  {
    double v10 = *(double *)(v8 + 336);
    double v11 = *((double *)a1 + 153);
    if (v11 == 0.0)
    {
      *((double *)a1 + 153) = v10;
      double v11 = v10;
    }
    if (vabdd_f64(v10, v11) > 1.0
      || (uint64_t v12 = md::LabelPool::replacementForLabel(this, a1)) == 0
      || *(unsigned char *)(v12 + 1263))
    {
      if (*((unsigned char *)a1 + 1262))
      {
        *((unsigned char *)a1 + 1262) = 0;
        md::Label::updateStateMachineForStaging((uint64_t)a1, 2, 28);
      }
      if (*((unsigned char *)a1 + 1261))
      {
        *((unsigned char *)a1 + 1261) = 0;
        md::Label::updateStateMachineForStaging((uint64_t)a1, 1, 37);
      }
    }
  }
  *((void *)a1 + 44) = 0;
  if (*((unsigned char *)a1 + 820))
  {
    if (((*(uint64_t (**)(void, char *))(**((void **)a1 + 1) + 440))(*((void *)a1 + 1), (char *)a1 + 48) & 1) == 0)
    {
      char v13 = a1;
      char v14 = 0;
      goto LABEL_29;
    }
    if (*(unsigned char *)(v8 + 25) && !*((unsigned char *)a1 + 835))
    {
      char v13 = a1;
      char v14 = 32;
      goto LABEL_29;
    }
    if (!*((unsigned char *)a1 + 1264))
    {
      uint64_t v15 = *((unsigned int *)a1 + 326);
      if (v15 != -1 && *((unsigned char *)a1 + 1213) == 1)
      {
        uint64_t v16 = *(void *)(a2 + 3576);
        if (v16)
        {
          id v17 = *(id *)(v16 + 8);
          uint64_t v18 = v17;
          if (v17)
          {
            char v19 = [v17 isEqual:0];

            if ((v19 & 1) == 0 && ([*(id *)(v16 + 8) shouldDisplayPOIWithType:v15] & 1) == 0) {
              goto LABEL_27;
            }
          }
          else
          {
          }
        }
      }
    }
    if (*(unsigned char *)(a2 + 3040) || !*(unsigned char *)(a2 + 3039))
    {
      if (!*((unsigned char *)a1 + 1264) || *((unsigned char *)a1 + 1258) && !*((unsigned char *)a1 + 1257))
      {
LABEL_27:
        char v13 = a1;
        char v14 = 33;
LABEL_29:
        md::Label::updateStateMachineForStaging((uint64_t)v13, 2, v14);
        return;
      }
    }
    else if (*(unsigned char *)(a2 + 3033) {
           && (!*(unsigned char *)(a2 + 3036) && *((unsigned char *)a1 + 1210) == 1 && !*((unsigned char *)a1 + 1264)
    }
            || !*(unsigned char *)(a2 + 3034) && *((unsigned char *)a1 + 1211) == 2
            || !*(unsigned char *)(a2 + 3035) && *((unsigned char *)a1 + 1210) == 7
            || !*(unsigned char *)(a2 + 3037) && *((unsigned char *)a1 + 1211) == 4
            || !*(unsigned char *)(a2 + 3038) && *((unsigned char *)a1 + 1211) == 3))
    {
      goto LABEL_27;
    }
    if (*(unsigned char *)(a2 + 3641))
    {
      switch(*((unsigned char *)a1 + 1211))
      {
        case 0:
        case 6:
        case 0xA:
        case 0xF:
        case 0x10:
        case 0x13:
        case 0x14:
        case 0x15:
        case 0x16:
        case 0x17:
        case 0x18:
        case 0x19:
        case 0x1A:
        case 0x1B:
          if (!*(unsigned char *)(a2 + 3636)) {
            break;
          }
          goto LABEL_55;
        case 1:
        case 7:
        case 8:
        case 0xB:
        case 0xC:
        case 0x11:
        case 0x12:
          if (!*(unsigned char *)(a2 + 3638)) {
            break;
          }
          goto LABEL_55;
        case 2:
        case 4:
        case 5:
        case 9:
        case 0xD:
        case 0xE:
          if (*((unsigned char *)a1 + 1210) == 8)
          {
            if (!*(unsigned char *)(a2 + 3640)) {
              break;
            }
          }
          else if (!*(unsigned char *)(a2 + 3637))
          {
            break;
          }
LABEL_55:
          char v13 = a1;
          char v14 = 5;
          goto LABEL_29;
        case 3:
          if (!*(unsigned char *)(a2 + 3639)) {
            break;
          }
          goto LABEL_55;
        default:
          break;
      }
    }
    uint64_t v20 = *((void *)a1 + 85);
    if (v20)
    {
      float v21 = *((float *)a1 + 98);
      float v22 = *(float *)(v8 + 32);
      if (v21 != v22)
      {
        LOBYTE(v22) = *(unsigned char *)(v20 + 40);
        float v23 = exp2f(v21 - (float)LODWORD(v22));
        float64x2_t v174 = *(float64x2_t *)(v20 + 24);
        long long v200 = 0u;
        uint64_t v202 = 0;
        long long v198 = 0u;
        long long v199 = 0u;
        long long v201 = 0u;
        uint64_t v196 = 0x3FF0000000000000;
        uint64_t v197 = 0x3FF0000000000000;
        *(void *)&long long v200 = 0x3FF0000000000000;
        uint64_t v203 = 0x3FF0000000000000;
        uint64_t v204 = 0;
        float64x2_t v205 = v174;
        long long v206 = xmmword_1A28FCCC0;
        long long v190 = 0u;
        uint64_t v192 = 0;
        long long v195 = 0u;
        long long v194 = 0u;
        long long v191 = 0u;
        long long v189 = 0u;
        long long v188 = 0u;
        double v187 = 1.0 / v23;
        *(double *)&long long v190 = v187;
        double v193 = v187;
        gm::operator*<double,4,4,4>((double *)v207, (double *)&v197, &v187);
        uint64_t v182 = 0;
        long long v181 = 0u;
        long long v179 = 0u;
        long long v178 = 0u;
        uint64_t v177 = 0x3FF0000000000000;
        long long v180 = 0x3FF0000000000000uLL;
        uint64_t v183 = 0x3FF0000000000000;
        uint64_t v184 = 0;
        float64x2_t v185 = vnegq_f64(v174);
        long long v186 = xmmword_1A28FCCC0;
        gm::operator*<double,4,4,4>(v208.f64, (double *)v207, (double *)&v177);
        double v24 = *(double *)(v20 + 8);
        double v25 = *(double *)(v20 + 16);
        double v26 = 1.0 / (v219 + v210 * *(double *)v20 + v213 * v24 + v216 * v25);
        double v27 = v26 * (v218 + v209 * *(double *)v20 + v212 * v24 + v215 * v25);
        *((float64x2_t *)a1 + 31) = vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v217, v208, *(double *)v20), v211, v24), v214, v25), v26);
        *((double *)a1 + 64) = v27;
      }
    }
    int8x16_t v28 = (float64x2_t *)((char *)a1 + 520);
    uint64_t v29 = *(int8x8_t **)(v8 + 1232);
    if ((*(unsigned int (**)(void))(**((void **)a1 + 1) + 360))(*((void *)a1 + 1)))
    {
      if ((*(uint64_t (**)(void))(**((void **)a1 + 1) + 376))(*((void *)a1 + 1)))
      {
        if (v29)
        {
          uint64_t v30 = (*(uint64_t (**)(void))(**((void **)a1 + 1) + 376))(*((void *)a1 + 1));
          unsigned __int16 v31 = md::VenueLogicContext::displayedFloorOrdinalForVenueBuildingId(v29, v30);
          uint64_t v32 = (*(uint64_t (**)(void))(**((void **)a1 + 1) + 376))();
          md::VenueLogicContext::getVenueLevelElevation((md::VenueLogicContext *)v29, v32, v31, 0);
          if (v34)
          {
            double v35 = *((double *)a1 + 29) * v33;
            *((double *)a1 + 82) = v35;
            double v36 = *((double *)a1 + 67) * v35;
            *((float64x2_t *)a1 + 34) = vmulq_n_f64(*v28, v35);
            *((double *)a1 + 70) = v36;
          }
        }
      }
    }
    double v37 = *(float *)(v8 + 48);
    double v38 = *((double *)a1 + 64) + *((double *)a1 + 70) * v37;
    *(float64x2_t *)((char *)a1 + 616) = vmlaq_n_f64(*((float64x2_t *)a1 + 31), *((float64x2_t *)a1 + 34), v37);
    *((double *)a1 + 79) = v38;
    float64x2_t v208 = (float64x2_t)xmmword_1A28FCDD0;
    double v209 = 0.0;
    LOWORD(v211.f64[0]) = 0;
    md::LabelLayoutContext::evaluateWorldPoint(v8, (uint64_t)a1 + 616, (uint64_t)a1 + 152, *((unsigned __int8 *)a1 + 1219), 1, (uint64_t)&v208, *((double *)a1 + 28));
    *((_DWORD *)a1 + 190) = HIDWORD(v208.f64[1]);
    float v39 = *(float *)&v208.f64[1];
    float v40 = fmaxf(*(float *)v208.f64, 0.0);
    float v41 = v209;
    *((float *)a1 + 195) = v41;
    *((float *)a1 + 98) = v40;
    int v42 = (int)v40;
    if ((int)v40 >= 0x17) {
      LOBYTE(v42) = 23;
    }
    *((unsigned char *)a1 + 404) = v42;
    *((float *)a1 + 191) = v39;
    if (a4[2] && (LOBYTE(v211.f64[0]) || *((float *)a1 + 196) > v41 || *((float *)a1 + 197) < v41))
    {
      uint64_t v43 = a1;
      int v44 = 2;
      char v45 = 3;
LABEL_93:
      md::Label::updateStateMachineForStaging((uint64_t)v43, v44, v45);
      return;
    }
    *((float *)a1 + 100) = v41;
    if (a4[1])
    {
      double v46 = v39;
      if (*((double *)a1 + 99) > v46 || *((double *)a1 + 100) < v46)
      {
        uint64_t v43 = a1;
        int v44 = 2;
        char v45 = 34;
        goto LABEL_93;
      }
    }
    int v47 = (*(uint64_t (**)(void, uint64_t, md::Label *))(**((void **)a1 + 1) + 48))(*((void *)a1 + 1), a2, a1);
    atomic_load((unsigned __int8 *)a1 + 1240);
    unsigned long long v48 = (uint64_t *)(*(uint64_t (**)(void))(**((void **)a1 + 1) + 552))();
    if (!*v48) {
      goto LABEL_92;
    }
    int v176 = v47;
    md::LabelStyle::setVariantStyleType(*v48, *(void *)(*(void *)(a2 + 336) + 161));
    md::LabelStyle::setZoom((md::LabelStyle *)*v48, *((float *)a1 + 98));
    uint64_t v49 = (*(uint64_t (**)(void))(**((void **)a1 + 1) + 560))();
    uint64_t v50 = *(uint64_t **)v49;
    uint64_t v51 = *(uint64_t **)(v49 + 8);
    while (v50 != v51)
    {
      if (*v50)
      {
        md::LabelStyle::setVariantStyleType(*v50, *(void *)(*(void *)(a2 + 336) + 161));
        md::LabelStyle::setZoom((md::LabelStyle *)*v50, *((float *)a1 + 98));
      }
      v50 += 2;
    }
    uint64_t v52 = *v48;
    if (!*(unsigned char *)(*v48 + 125) || *(unsigned __int8 *)(v52 + 136) == 255)
    {
LABEL_92:
      uint64_t v43 = a1;
      int v44 = 2;
      char v45 = 1;
      goto LABEL_93;
    }
    std::shared_ptr<ggl::VertexData>::operator=[abi:nn180100]<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4UV>,void>((void *)a1 + 47, v52, v48[1]);
    if (*((unsigned char *)a1 + 1218) || (unsigned __int8 v56 = *(unsigned char *)(a2 + 3051)) != 0 && (unsigned __int8 v56 = *(unsigned char *)(*v48 + 141)) != 0)
    {
      LODWORD(v54) = *(_DWORD *)(*(void *)(a2 + 232) + 36);
      unsigned __int8 v56 = *((float *)a1 + 98) >= *(float *)&v54
         && (unsigned __int8 v55 = atomic_load((unsigned __int8 *)a1 + 1243), (v55 & 1) == 0)
         && *(unsigned char *)(a2 + 3612) != 0;
    }
    atomic_store(v56, (unsigned __int8 *)a1 + 481);
    unsigned __int8 v57 = atomic_load((unsigned __int8 *)a1 + 481);
    if ((v57 & 1) == 0) {
      *((unsigned char *)a1 + 1284) = 0;
    }
    if (*((unsigned char *)a1 + 483))
    {
      unsigned __int8 v58 = atomic_load((unsigned __int8 *)a1 + 481);
      uint64_t v59 = *((void *)a1 + 57);
      if (v58)
      {
        unsigned __int8 v60 = atomic_load((unsigned __int8 *)(v59 + 286));
        if (v60)
        {
          if (*(unsigned char *)(*((void *)a1 + 57) + 280)) {
            *((unsigned char *)a1 + 485) = *(unsigned char *)(*((void *)a1 + 57) + 280);
          }
          *((unsigned char *)a1 + 483) = 0;
          if (*((unsigned char *)a1 + 484)) {
            *((unsigned char *)a1 + 1284) = 0;
          }
        }
      }
      else
      {
        *(unsigned char *)(v59 + 285) = 1;
        *((unsigned char *)a1 + 483) = 0;
      }
    }
    if (*(unsigned char *)(a2 + 3050)) {
      BOOL v61 = *(unsigned char *)(a2 + 3056) == 0;
    }
    else {
      BOOL v61 = 1;
    }
    *((unsigned char *)a1 + 1245) = v61;
    uint64_t v62 = *v48;
    *((unsigned char *)a1 + 822) = *(unsigned char *)(*v48 + 252);
    LODWORD(v53) = *(_DWORD *)(v62 + 152);
    *((_DWORD *)a1 + 189) = LODWORD(v53);
    if (*((unsigned char *)a1 + 1271))
    {
      float64x2_t v63 = (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL);
      float64x2_t v64 = vmaxnmq_f64(vmlaq_f64(v63, (float64x2_t)vdupq_n_s64(0xBF91DF46A2529D39), vcvtq_f64_f32(*(float32x2_t *)(v62 + 228))), (float64x2_t)0);
      int32x2_t v65 = vmovn_s64(vcgtq_f64(v64, v63));
      __int8 v66 = v65.i8[4];
      if (v65.i8[0]) {
        double v67 = 3.14159265;
      }
      else {
        double v67 = v64.f64[0];
      }
      if (v66) {
        double v68 = 3.14159265;
      }
      else {
        double v68 = v64.f64[1];
      }
      long double v69 = cos(v67);
      long double v53 = cos(v68);
      *((long double *)a1 + 99) = v69;
      *((long double *)a1 + 100) = v53;
    }
    if (*((unsigned char *)a1 + 1272))
    {
      double v54 = *((double *)a1 + 28);
      float v70 = v54 * *(float *)(v62 + 220);
      *((float *)a1 + 196) = v70;
      long double v53 = v54 * *(float *)(v62 + 216);
      *(float *)&long double v53 = v53;
      *((_DWORD *)a1 + 197) = LODWORD(v53);
    }
    int v71 = *(unsigned __int8 *)(v62 + 123);
    *((unsigned char *)a1 + 823) = v71;
    switch(v71)
    {
      case 1:
      case 3:
        LODWORD(v54) = LODWORD(v209);
        long double v53 = *(double *)(v8 + 256) / v209;
        float v72 = v53;
        if (v71 == 3)
        {
          if (*((unsigned char *)a1 + 827) && *((unsigned char *)a1 + 816))
          {
            LODWORD(v53) = *((_DWORD *)a1 + 203);
          }
          else
          {
            LODWORD(v53) = *(_DWORD *)(v62 + 196);
            *((_DWORD *)a1 + 203) = LODWORD(v53);
            *((unsigned char *)a1 + 816) = 1;
          }
          float v72 = *(float *)&v53 * v72;
        }
        break;
      case 2:
        float v72 = *(float *)(v62 + 196);
        uint64_t v73 = *(void *)(v62 + 392);
        if (!v73)
        {
          md::LabelStyle::prepareDisplayCoreStyleGroup((md::LabelStyle *)v62);
          uint64_t v73 = *(void *)(v62 + 392);
        }
        std::shared_ptr<ggl::VertexData>::operator=[abi:nn180100]<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4UV>,void>((void *)a1 + 88, v73, *(void *)(v62 + 400));
        break;
      case 4:
        *(float *)&long double v53 = exp2f(*((float *)a1 + 98) + -5.0);
        float v72 = *(float *)&v53;
        break;
      default:
        float v72 = 1.0;
        break;
    }
    *((float *)a1 + 99) = v72;
    md::LabelStyle::getLabelKnobs((uint64_t *)*v48, (uint64_t)a1 + 720, *((unsigned __int8 *)a1 + 1210), *((unsigned char *)a1 + 1274), v53, *(float *)&v54);
    int v74 = *((_DWORD *)a1 + 181) != *((_DWORD *)a1 + 180);
    if (*((unsigned __int8 *)a1 + 825) != v74)
    {
      *((unsigned char *)a1 + 825) = v74;
      *((unsigned char *)a1 + 1247) = 1;
    }
    float v75 = (*(float (**)(void))(**((void **)a1 + 1) + 240))(*((void *)a1 + 1));
    if (v75 <= 252.0)
    {
      float v77 = roundf(v75 * 10.0) * 0.1;
      float v78 = *((float *)a1 + 186);
      *((unsigned char *)a1 + 836) = v77 > v78;
      if (v77 <= v78) {
        float v77 = v78;
      }
      *((float *)a1 + 186) = v77;
      float v76 = fmaxf(*((float *)a1 + 182), v75);
    }
    else
    {
      *((unsigned char *)a1 + 836) = 0;
      float v76 = *((float *)a1 + 182);
      if (v76 == 0.0) {
        float v76 = *((float *)a1 + 186);
      }
    }
    float v79 = v76 + *((float *)a1 + 184);
    *((float *)a1 + 182) = v79;
    if (*((unsigned char *)a1 + 1252)) {
      *((float *)a1 + 182) = *((float *)a1 + 183) + v79;
    }
    float v81 = (*(float (**)(void))(**((void **)a1 + 1) + 248))(*((void *)a1 + 1));
    if (v81 < 252.0) {
      *((float *)a1 + 187) = fminf(roundf(v81 * 10.0) * 0.1, *((float *)a1 + 187));
    }
    if (*((unsigned char *)a1 + 1246))
    {
      *((void *)a1 + 90) = 0xFFFFFFFF00000000;
      *((_DWORD *)a1 + 186) = 0;
    }
    unsigned __int8 v82 = atomic_load((unsigned __int8 *)a1 + 1243);
    if ((v82 & 1) == 0)
    {
      unsigned __int8 v83 = atomic_load((unsigned __int8 *)a1 + 1240);
      if ((v83 & 1) == 0)
      {
        float v84 = *((float *)a1 + 98);
        float v85 = *((float *)a1 + 186);
        if (v84 < v85)
        {
          int v86 = 6;
          int v87 = 1;
          if (v84 < (float)(v85 + -0.4))
          {
            int v88 = 0;
            BOOL v89 = 1;
            goto LABEL_160;
          }
          goto LABEL_220;
        }
        float v90 = *((float *)a1 + 187);
        if (v84 >= v90)
        {
          int v87 = 7;
          if (v84 > (float)(v90 + 0.4))
          {
            int v88 = 0;
            BOOL v89 = 1;
            int v86 = 7;
            goto LABEL_160;
          }
          int v86 = 7;
LABEL_220:
          int v88 = 0;
          BOOL v89 = *((unsigned char *)a1 + 1276) != 0;
LABEL_160:
          int v91 = *((unsigned __int8 *)a1 + 831);
          if (v91 == v87)
          {
            if (v88) {
              goto LABEL_162;
            }
          }
          else
          {
            if (!*((unsigned char *)a1 + 831)) {
              LOBYTE(v91) = v87;
            }
            *((unsigned char *)a1 + 832) = v91;
            *((unsigned char *)a1 + 831) = v87;
            if (v88)
            {
LABEL_162:
              unsigned __int8 v92 = atomic_load((unsigned __int8 *)a1 + 1243);
              if ((v92 & 1) == 0)
              {
                if (*((unsigned char *)a1 + 824) && !*((unsigned char *)a1 + 1262))
                {
                  int v86 = 28;
                  if (!v89)
                  {
LABEL_180:
                    *((void *)a1 + 71) = 0;
                    *((void *)a1 + 72) = 0;
                    unsigned int v96 = (float64x2_t *)((char *)a1 + 568);
                    *((void *)a1 + 73) = 0;
                    if ((*(unsigned int (**)(void))(**((void **)a1 + 1) + 360))(*((void *)a1 + 1)))
                    {
                      *((_DWORD *)a1 + 193) = 1065353216;
                      float v97 = *(float *)(*v48 + 200);
                      if (v97 != 0.0)
                      {
                        float v98 = v97 * (40075017.0 * *(double *)(v8 + 304)) / *(float *)(v8 + 476) + 1.0;
                        *((float *)a1 + 193) = v98;
                      }
                      *((_DWORD *)a1 + 192) = 0;
                      goto LABEL_207;
                    }
                    if (*((unsigned char *)a1 + 257))
                    {
                      if (*((unsigned char *)a1 + 164))
                      {
                        BOOL v99 = *((float *)a1 + 61) <= 10.0 && *((float *)a1 + 98) < 18.0;
                        if (*(unsigned char *)(v8 + 23)) {
                          BOOL v99 = 1;
                        }
                        if (v99) {
                          unsigned __int8 v101 = 2;
                        }
                        else {
                          unsigned __int8 v101 = 3;
                        }
                      }
                      else
                      {
                        unsigned __int8 v101 = 1;
                      }
                      int v102 = *((unsigned __int8 *)a1 + 256);
                      if (v102 != v101)
                      {
                        *((unsigned char *)a1 + 1295) = v102 != 0;
                        *((unsigned char *)a1 + 256) = v101;
                      }
                      md::Label::updatePoiPositionOffsets((uint64_t)a1, (const LabelLayoutContext *)*(unsigned __int8 *)(v8 + 19), *(float *)(v8 + 424));
                      goto LABEL_207;
                    }
                    if ((*(unsigned int (**)(void))(**((void **)a1 + 1) + 328))(*((void *)a1 + 1)))
                    {
                      float v100 = *(float *)(v8 + 52);
                    }
                    else if (*((unsigned char *)a1 + 1211) == 4)
                    {
                      float v100 = *(float *)(v8 + 60);
                    }
                    else
                    {
                      if (!*((unsigned char *)a1 + 830)) {
                        *((_DWORD *)a1 + 194) = *(_DWORD *)(*v48 + 208);
                      }
                      if (*((unsigned char *)a1 + 829))
                      {
LABEL_207:
                        float v103 = *((float *)a1 + 192);
                        if (v103 != 0.0)
                        {
                          double v104 = *((double *)a1 + 67);
                          double v105 = *((double *)a1 + 29) * v103;
                          *(float64x2_t *)((char *)a1 + 568) = vmlaq_n_f64(*(float64x2_t *)((char *)a1 + 568), *(float64x2_t *)((char *)a1 + 520), v105);
                          *((double *)a1 + 73) = *((double *)a1 + 73) + v105 * v104;
                        }
                        float v106 = *((float *)a1 + 194);
                        if (v106 == 0.0)
                        {
                          if (!*((unsigned char *)a1 + 164)) {
                            goto LABEL_224;
                          }
                        }
                        else
                        {
                          if (!*((unsigned char *)a1 + 164)) {
                            goto LABEL_224;
                          }
                          float v107 = *((double *)a1 + 28) * v106;
                          double v108 = (float)(*((float *)a1 + 40) * v107);
                          *unsigned int v96 = vaddq_f64(*v96, vcvtq_f64_f32(vmul_n_f32(*(float32x2_t *)((char *)a1 + 152), v107)));
                          *((double *)a1 + 73) = *((double *)a1 + 73) + v108;
                        }
                        if (*((unsigned char *)a1 + 180))
                        {
                          if (!*((unsigned char *)a1 + 828))
                          {
                            float v109 = fabsf(*((float *)a1 + 191));
                            if (v109 > 0.93)
                            {
                              double v110 = v109;
                              if (v109 <= 0.985 && *((unsigned __int8 *)a1 + 184) == BYTE1(v211.f64[0])) {
                                float v111 = fminf(-*((float *)a1 + 54), 0.0);
                              }
                              else {
                                float v111 = fmaxf(*((float *)a1 + 53), 0.0);
                              }
                              float v112 = v110 * 66.6667302 + -65.6667302;
                              float v113 = fmin(fmax(v112, 0.0), 1.0) * v111;
                              *((float *)a1 + 202) = v113;
                            }
                          }
                          double v114 = *((float *)a1 + 44);
                          double v115 = *((double *)a1 + 28) * *((float *)a1 + 202);
                          *unsigned int v96 = vmlaq_n_f64(*v96, vcvtq_f64_f32(*(float32x2_t *)((char *)a1 + 168)), v115);
                          *((double *)a1 + 73) = *((double *)a1 + 73) + v115 * v114;
                        }
LABEL_224:
                        float64x2_t v116 = vaddq_f64(*v96, *(float64x2_t *)((char *)a1 + 616));
                        double v117 = *((double *)a1 + 73) + *((double *)a1 + 79);
                        *((float64x2_t *)a1 + 37) = v116;
                        *((double *)a1 + 76) = v117;
                        float v118 = *((float *)a1 + 193);
                        if (v118 != 0.0)
                        {
                          double v119 = *((double *)a1 + 29) * v118 * *(float *)(v8 + 1184);
                          double v120 = *((double *)a1 + 67);
                          *((float64x2_t *)a1 + 37) = vmlaq_n_f64(v116, *v28, v119);
                          *((double *)a1 + 76) = v117 + v120 * v119;
                        }
                        if (*((unsigned char *)a1 + 259))
                        {
                          v121.n128_u64[0] = (unint64_t)md::LabelLayoutContext::projectPointToPixel((float64x2_t *)v8, (double *)a1 + 74, (float32x2_t *)a1 + 83);
                        }
                        else
                        {
                          v121.n128_f32[0] = md::Label::featurePixel((uint64_t)a1, a2, 0);
                          *((_DWORD *)a1 + 166) = v121.n128_u32[0];
                          *((_DWORD *)a1 + 167) = v122;
                        }
                        if (*a4)
                        {
                          if (*((unsigned char *)a1 + 1266))
                          {
                            uint64_t v123 = *(float **)(a2 + 432);
                            v121.n128_u32[0] = *((_DWORD *)a1 + 166);
                            if (v121.n128_f32[0] < v123[284]
                              || v121.n128_f32[0] >= v123[286]
                              || (v121.n128_u32[0] = *((_DWORD *)a1 + 167), v121.n128_f32[0] < v123[285])
                              || v121.n128_f32[0] >= v123[287])
                            {
                              int v86 = 2;
                            }
                          }
                        }
                        if ((*(unsigned int (**)(void, __n128))(**(void **)(*(void *)(a2 + 168) + 32)
                                                                            + 24))(*(void *)(*(void *)(a2 + 168) + 32), v121))
                        {
                          if (*((unsigned char *)a1 + 1210) == 1 && *(unsigned __int8 *)(*v48 + 261) <= 3u)
                          {
                            unsigned int v124 = (*(uint64_t (**)(void, char *, void))(**(void **)(*(void *)(a2 + 168) + 32)
                                                                                     + 96))(*(void *)(*(void *)(a2 + 168) + 32), (char *)a1 + 664, *((unsigned __int8 *)a1 + 1215));
                            if (v124 != *((unsigned __int8 *)a1 + 1215))
                            {
                              *((unsigned char *)a1 + 320) = v124;
                              char v125 = 32 * v124;
                              if (v124 >= 8) {
                                char v125 = 0;
                              }
                              *((unsigned char *)a1 + 321) = v125;
                              *((unsigned char *)a1 + 1215) = v124;
                            }
                          }
                        }
                        if (v86 != 37)
                        {
                          unsigned __int8 v126 = atomic_load((unsigned __int8 *)a1 + 1240);
                          if ((v126 & 1) == 0)
                          {
                            if (*((void *)a1 + 36))
                            {
                              *((void *)a1 + 36) = 0;
                              *((unsigned char *)a1 + 1247) = 1;
                            }
                            if (*((unsigned char *)a1 + 820) == 1)
                            {
                              *((unsigned char *)a1 + 821) = v86;
                              *((unsigned char *)a1 + 1290) = 0;
                              return;
                            }
                            goto LABEL_310;
                          }
                        }
                        uint64_t v127 = *((void *)a1 + 33);
                        uint64_t v128 = v127;
                        if (!v127) {
                          uint64_t v128 = *((void *)a1 + 34);
                        }
                        int v129 = *((_DWORD *)a1 + 14);
                        int v130 = *(_DWORD *)(a2 + 3312);
                        if (!*(unsigned char *)(a2 + 3375) || v129 == v130)
                        {
                          if (v128)
                          {
                            BOOL v172 = v127 == 0;
                            int v134 = *((unsigned __int8 *)a1 + 404);
                            int v135 = *((unsigned __int8 *)a1 + 1214);
                            *((unsigned char *)a1 + 1214) = v134;
                            if (v127)
                            {
                              (*(void (**)(uint64_t, uint64_t))(*(void *)v127 + 72))(v127, a2);
                              uint64_t v136 = *((void *)a1 + 33);
                              *(void *)uint64_t v207 = 0;
                              int v86 = (*(uint64_t (**)(uint64_t, uint64_t, char *, unsigned char *))(*(void *)v136 + 80))(v136, a2, (char *)a1 + 664, v207);
                              BOOL v171 = 0;
                              int v173 = 37;
                              int v175 = 1;
                            }
                            else
                            {
                              if (v134 == v135) {
                                (*(void (**)(void, uint64_t))(**((void **)a1 + 34) + 72))(*((void *)a1 + 34), a2);
                              }
                              BOOL v171 = v134 == v135;
                              uint64_t v141 = *((void *)a1 + 34);
                              *(void *)uint64_t v207 = 0;
                              int v173 = (*(uint64_t (**)(uint64_t, uint64_t, char *, unsigned char *))(*(void *)v141
                                                                                                  + 80))(v141, a2, (char *)a1 + 664, v207);
                              int v175 = 0;
                              int v86 = 37;
                            }
                            *(_DWORD *)&v207[8] = 0;
                            *(void *)&v207[1] = 0x100000000000000;
                            v207[0] = 0;
                            if (((v176 | (*(unsigned int (**)(uint64_t, uint64_t, BOOL, unsigned char *))(*(void *)v128 + 760))(v128, a2, v134 != v135, v207)) & 1) != 0|| md::LabelPlacement::operator!=((unsigned __int8 *)a1 + 312, (unsigned __int8 *)a1 + 317)|| *((_DWORD *)a1 + 13) != *(_DWORD *)(*((void *)a1 + 1) + 132)|| v129 != v130|| *((unsigned char *)a1 + 1295))
                            {
                              md::Label::createNextPart((uint64_t)a1, a2, (uint64_t)v207);
                              if (!*((void *)a1 + 33)) {
                                goto LABEL_280;
                              }
                              int v175 = 0;
                            }
                            int v140 = v173;
                            BOOL v139 = v175 != 0;
                            char v137 = v171;
                            BOOL v138 = v172;
LABEL_274:
                            uint64_t v142 = *((void *)a1 + 34);
                            if (v142)
                            {
                              uint64_t v143 = *((void *)a1 + 33);
                              if (v143) {
                                char v137 = 1;
                              }
                              if (v137)
                              {
                                if (v138)
                                {
LABEL_285:
                                  if (v143)
                                  {
                                    if (!v139)
                                    {
                                      (*(void (**)(uint64_t, uint64_t))(*(void *)v143 + 72))(v143, a2);
                                      uint64_t v145 = *((void *)a1 + 33);
                                      *(void *)uint64_t v207 = 0;
                                      int v86 = (*(uint64_t (**)(uint64_t, uint64_t, char *, unsigned char *))(*(void *)v145 + 80))(v145, a2, (char *)a1 + 664, v207);
                                      uint64_t v143 = *((void *)a1 + 33);
                                    }
                                    if (v143 && (v86 & 0xFB) != 0xB && !*((unsigned char *)a1 + 1284))
                                    {
                                      if (v86 == 37)
                                      {
                                        *((unsigned char *)a1 + 1283) = 1;
                                        (*(void (**)(uint64_t, uint64_t))(*(void *)v143 + 104))(v143, a2);
                                        long long v169 = (uint64_t *)md::LabelStyle::animationStyleGroup((md::LabelStyle *)*v48);
                                        std::shared_ptr<ggl::VertexData>::operator=[abi:nn180100]<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4UV>,void>((void *)a1 + 86, *v169, v169[1]);
                                        goto LABEL_293;
                                      }
                                      int v155 = 2;
LABEL_312:
                                      md::Label::updateStateMachineForStaging((uint64_t)a1, v155, v86);
                                      if (*((void *)a1 + 36))
                                      {
                                        *((void *)a1 + 36) = 0;
LABEL_314:
                                        *((unsigned char *)a1 + 1247) = 1;
                                        goto LABEL_315;
                                      }
                                      goto LABEL_315;
                                    }
                                  }
                                  *((unsigned char *)a1 + 1283) = 0;
                                  if (*((void *)a1 + 34))
                                  {
                                    if (v140 == 37)
                                    {
LABEL_293:
                                      uint64_t v146 = *(float **)(a2 + 432);
                                      if (v146[278] <= md::Label::boundsForStaging(a1)
                                        || v146[276] >= v148
                                        || v146[279] <= v147
                                        || v146[277] >= v149)
                                      {
                                        if (*a4)
                                        {
                                          LOBYTE(v86) = 2;
                                          goto LABEL_310;
                                        }
                                      }
                                      else
                                      {
                                        unsigned __int8 v150 = atomic_load((unsigned __int8 *)a1 + 481);
                                        if (v150)
                                        {
                                          if (*(unsigned char *)(a2 + 3615)
                                            || !*(unsigned char *)(*(void *)(a2 + 232) + 23)
                                            || *(unsigned char *)(a2 + 3152)
                                            || *((unsigned char *)a1 + 485) != 2)
                                          {
                                            float v151 = *(float *)(a2 + 3308);
                                            float v152 = *((float *)a1 + 166);
                                            float v153 = *((float *)a1 + 167);
                                            if (vabds_f32(v152, *((float *)a1 + 118)) >= v151
                                              || *(unsigned char *)(a2 + 3615)
                                              || vabds_f32(v153, *((float *)a1 + 119)) >= v151)
                                            {
                                              *((unsigned char *)a1 + 480) = 1;
                                              *((float *)a1 + 118) = v152;
                                              *((float *)a1 + 119) = v153;
                                            }
                                          }
                                          char v154 = *((unsigned char *)a1 + 480);
                                          if (v154) {
                                            char v154 = *(unsigned char *)(a2 + 3153) != 0;
                                          }
                                          *((unsigned char *)a1 + 482) = v154;
                                          if (*((unsigned char *)a1 + 485) != 2)
                                          {
                                            atomic_store(1u, (unsigned __int8 *)a1 + 1244);
                                            LOBYTE(v86) = 22;
LABEL_310:
                                            int v155 = 3;
                                            goto LABEL_312;
                                          }
                                        }
                                      }
                                      if (!*((unsigned char *)a1 + 1290))
                                      {
                                        *((unsigned char *)a1 + 1106) = *((unsigned char *)a1 + 832);
                                        *((unsigned char *)a1 + 832) = *((unsigned char *)a1 + 831);
                                        *((_WORD *)a1 + 645) = 1;
                                        *((unsigned char *)a1 + 1263) = 1;
                                      }
                                      uint64_t v168 = *((void *)a1 + 33);
                                      if (v168 && *((unsigned char *)a1 + 1283))
                                      {
                                        if (*((void *)a1 + 36) != v168)
                                        {
                                          *((void *)a1 + 36) = v168;
                                          *((unsigned char *)a1 + 1247) = 1;
                                        }
                                        if (*((unsigned char *)a1 + 1285)) {
                                          *((unsigned char *)a1 + 1291) = 0;
                                        }
                                        goto LABEL_315;
                                      }
                                      uint64_t v170 = *((void *)a1 + 34);
                                      if (*((void *)a1 + 36) != v170)
                                      {
                                        *((void *)a1 + 36) = v170;
                                        goto LABEL_314;
                                      }
LABEL_315:
                                      if (*((unsigned char *)a1 + 1290))
                                      {
                                        unint64_t v156 = md::LabelStyle::collisionGroupInfo(*v48, *((unsigned __int8 *)a1 + 1210));
                                        if (__PAIR64__(*((unsigned __int8 *)a1 + 365), *((unsigned __int8 *)a1 + 364)) != __PAIR64__(BYTE5(v156), BYTE4(v156))
                                          || *((unsigned __int8 *)a1 + 366) != BYTE6(v156)
                                          || *((_DWORD *)a1 + 90) != v156)
                                        {
                                          *((_DWORD *)a1 + 90) = v156;
                                          *((unsigned char *)a1 + 364) = BYTE4(v156);
                                          *((unsigned char *)a1 + 365) = BYTE5(v156);
                                          *((unsigned char *)a1 + 366) = BYTE6(v156);
                                          uint64_t v157 = *((void *)a1 + 45);
                                          int v158 = md::Label::resolvedCollisionOverlayGroup(a1);
                                          *((unsigned char *)a1 + 369) = v158;
                                          unsigned int v159 = (_DWORD *)*((void *)a1 + 41);
                                          char v160 = BYTE4(v157) + 3;
                                          char v161 = BYTE4(v157) + 3;
                                          if ((BYTE4(v157) + 3) >= 0xBu)
                                          {
                                            int v162 = SBYTE4(v157);
                                            if (SBYTE4(v157) >= 7) {
                                              int v162 = 7;
                                            }
                                            if (v162 <= -3) {
                                              LOBYTE(v162) = -3;
                                            }
                                            char v161 = v162 + 3;
                                          }
                                          int v163 = 1 << v161;
                                          v159[8] = v163;
                                          int v164 = LabelCollisionOverlayGroupToLayersCollided[v158];
                                          v159[9] = v164 | v163;
                                          v159[11] = 1 << SBYTE6(v157);
                                          v159[12] = v157;
                                          uint64_t v165 = (_DWORD *)*((void *)a1 + 42);
                                          if (v165)
                                          {
                                            if ((BYTE4(v157) + 3) >= 0xBu)
                                            {
                                              int v166 = SBYTE4(v157);
                                              if (SBYTE4(v157) >= 7) {
                                                int v166 = 7;
                                              }
                                              if (v166 <= -3) {
                                                LOBYTE(v166) = -3;
                                              }
                                              char v160 = v166 + 3;
                                            }
                                            int v167 = 1 << v160;
                                            v165[8] = v167;
                                            v165[9] = v164 | v167;
                                            v165[11] = 1 << SBYTE6(v157);
                                            v165[12] = v157;
                                          }
                                        }
                                      }
                                      return;
                                    }
                                    int v155 = 2;
                                    LOBYTE(v86) = v140;
                                    goto LABEL_312;
                                  }
                                  uint64_t v43 = a1;
                                  int v44 = 2;
LABEL_178:
                                  char v45 = v86;
                                  goto LABEL_93;
                                }
                              }
                              else
                              {
                                (*(void (**)(void, uint64_t))(*(void *)v142 + 72))(*((void *)a1 + 34), a2);
                              }
                              if (!*((unsigned char *)a1 + 1284))
                              {
                                uint64_t v144 = *((void *)a1 + 34);
                                *(void *)uint64_t v207 = 0;
                                int v140 = (*(uint64_t (**)(uint64_t, uint64_t, char *, unsigned char *))(*(void *)v144 + 80))(v144, a2, (char *)a1 + 664, v207);
                              }
                            }
                            uint64_t v143 = *((void *)a1 + 33);
                            goto LABEL_285;
                          }
                          unsigned int v132 = a1;
                          uint64_t v133 = a2;
                          uint64_t v131 = 0;
                        }
                        else
                        {
                          v207[0] = 1;
                          *(void *)&v207[1] = 0;
                          *(_DWORD *)&v207[8] = 0;
                          if (v128 && *((unsigned char *)a1 + 820) == 2)
                          {
                            v207[8] = 1;
                            v207[0] = 0;
                          }
                          uint64_t v131 = v207;
                          unsigned int v132 = a1;
                          uint64_t v133 = a2;
                        }
                        md::Label::createNextPart((uint64_t)v132, v133, (uint64_t)v131);
                        if (*((void *)a1 + 33))
                        {
                          char v137 = 0;
                          BOOL v138 = 0;
                          BOOL v139 = 0;
                          int v140 = 37;
                          int v86 = 37;
                          goto LABEL_274;
                        }
LABEL_280:
                        uint64_t v43 = a1;
                        int v44 = 2;
                        char v45 = 8;
                        goto LABEL_93;
                      }
                      float v100 = *(float *)(*v48 + 204);
                      if (v100 == 0.0) {
                        float v100 = *((float *)a1 + 50);
                      }
                    }
                    *((float *)a1 + 192) = v100;
                    goto LABEL_207;
                  }
LABEL_177:
                  uint64_t v43 = a1;
                  int v44 = 8;
                  goto LABEL_178;
                }
                uint64_t v93 = *((void *)a1 + 149);
                if (v93)
                {
                  unsigned __int8 v94 = atomic_load((unsigned __int8 *)(v93 + 55));
                  if ((v94 & 1) == 0)
                  {
                    unsigned __int8 v95 = atomic_load((unsigned __int8 *)a1 + 1241);
                    if ((v95 & 1) == 0
                      && (!this
                       || !*((unsigned char *)a1 + 1264)
                       || md::Label::checkReplacementLabelReady(a1, (LabelManager *)this, v80, *(double *)(*(void *)(a2 + 432) + 336))))
                    {
                      int v86 = 29;
                      if (!v89) {
                        goto LABEL_180;
                      }
                      goto LABEL_177;
                    }
                  }
                }
              }
              int v86 = 37;
              if (!v89) {
                goto LABEL_180;
              }
              goto LABEL_177;
            }
          }
          if (!v89) {
            goto LABEL_180;
          }
          goto LABEL_177;
        }
      }
    }
    BOOL v89 = 0;
    int v86 = 37;
    int v88 = 1;
    int v87 = 4;
    goto LABEL_160;
  }
}

void sub_1A17E0430(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::LabelStyle::setZoom(md::LabelStyle *this, float a2)
{
  if (*((unsigned char *)this + 125))
  {
    float v4 = fminf(fmaxf(a2, 0.0), 23.0);
LABEL_4:
    if (*((unsigned __int8 *)this + 136) != 255)
    {
      float v5 = *((float *)this + 26);
      if (vabds_f32(v4, v5) < 0.01 && SLODWORD(v4) == SLODWORD(v5)) {
        return;
      }
    }
    goto LABEL_9;
  }
  md::LabelStyle::updateZoomInvariantStyles((uint64_t)this);
  float v4 = fminf(fmaxf(a2, 0.0), 23.0);
  if (*((unsigned char *)this + 125)) {
    goto LABEL_4;
  }
LABEL_9:
  *((float *)this + 26) = v4;
  if (v4 >= 24.0) {
    return;
  }
  int v7 = (int)v4;
  uint64_t v8 = *(void *)this;
  if (*(void *)this)
  {
    BOOL v9 = (std::__shared_weak_count *)*((void *)this + 1);
    if (v9) {
      atomic_fetch_add_explicit(&v9->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v21, v8, (uint64_t)v9);
    if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
      std::__shared_weak_count::__release_weak(v9);
      if (!*((unsigned char *)this + 456)) {
        goto LABEL_25;
      }
    }
    else if (!*((unsigned char *)this + 456))
    {
      goto LABEL_25;
    }
    if (*((unsigned __int8 *)this + 136) == v7)
    {
      if (v22) {
        md::LabelCoreStyleGroup::update((uint64_t)this + 140, (uint64_t)v21, *((void *)this + 2), *((unsigned __int8 *)this + 93), 0, *((float *)this + 26), *((float *)this + 22));
      }
      else {
        *((unsigned char *)this + 456) = 0;
      }
LABEL_42:
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v21);
      return;
    }
LABEL_25:
    *((unsigned char *)this + 136) = v7;
    if (v22)
    {
      *((unsigned char *)this + 456) = 1;
      md::LabelCoreStyleGroup::update((uint64_t)this + 140, (uint64_t)v21, *((void *)this + 2), *((unsigned __int8 *)this + 93), 1, *((float *)this + 26), *((float *)this + 22));
    }
    else
    {
      *((unsigned char *)this + 456) = 0;
    }
    *((unsigned char *)this + 457) = 0;
    uint64_t v11 = *((void *)this + 42);
    uint64_t v12 = *((void *)this + 43);
    if (v11 == v12) {
      goto LABEL_35;
    }
    unint64_t v13 = v12 - v11 - 16;
    if (v13 > 0xF)
    {
      uint64_t v14 = (v13 >> 4) + 1;
      uint64_t v15 = (uint64_t *)(v11 + 24);
      uint64_t v16 = v14 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        uint64_t v17 = *(v15 - 2);
        uint64_t v18 = *v15;
        v15 += 4;
        *(unsigned char *)(v17 + 12) = 0;
        *(unsigned char *)(v18 + 12) = 0;
        v16 -= 2;
      }
      while (v16);
      if (v14 == (v14 & 0x1FFFFFFFFFFFFFFELL)) {
        goto LABEL_35;
      }
      v11 += 16 * (v14 & 0x1FFFFFFFFFFFFFFELL);
    }
    do
    {
      *(unsigned char *)(*(void *)(v11 + 8) + 12) = 0;
      v11 += 16;
    }
    while (v11 != v12);
LABEL_35:
    *(_OWORD *)((char *)this + 296) = 0u;
    *(_OWORD *)((char *)this + 312) = 0u;
    *(_OWORD *)((char *)this + 264) = 0u;
    *(_OWORD *)((char *)this + 280) = 0u;
    char v19 = (std::__shared_weak_count *)*((void *)this + 41);
    *((void *)this + 41) = 0;
    if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
    if (*((float *)this + 59) >= 1.0) {
      float v20 = *((float *)this + 59);
    }
    else {
      float v20 = 20.0;
    }
    *((long double *)this + 16) = ldexp(1.0, v7) * 768.0 / v20;
    goto LABEL_42;
  }
  if (*((unsigned __int8 *)this + 136) != v7)
  {
    *((unsigned char *)this + 136) = v7;
    if (*((float *)this + 59) >= 1.0) {
      float v10 = *((float *)this + 59);
    }
    else {
      float v10 = 20.0;
    }
    *((long double *)this + 16) = ldexp(1.0, v7) * 768.0 / v10;
  }
}

void sub_1A17E0754(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void md::LabelStyle::setVariantStyleType(uint64_t a1, unint64_t a2)
{
  if (*(unsigned __int8 *)(a1 + 94) != a2
    || __PAIR64__(*(unsigned __int8 *)(a1 + 96), *(unsigned __int8 *)(a1 + 95)) != __PAIR64__(BYTE2(a2), BYTE1(a2))
    || *(unsigned __int8 *)(a1 + 97) != BYTE3(a2)
    || *(unsigned __int8 *)(a1 + 98) != BYTE4(a2)
    || *(unsigned __int8 *)(a1 + 99) != BYTE5(a2)
    || *(unsigned __int8 *)(a1 + 100) != BYTE6(a2)
    || *(unsigned __int8 *)(a1 + 101) != HIBYTE(a2))
  {
    uint64_t v3 = a1 + 408;
    *(void *)(a1 + 94) = a2;
    *(unsigned char *)(a1 + 136) = -1;
    *(unsigned char *)(a1 + 125) = 0;
    float v4 = *(std::__shared_weak_count **)(a1 + 416);
    *(void *)(a1 + 408) = 0;
    *(void *)(a1 + 416) = 0;
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    float v5 = *(std::__shared_weak_count **)(a1 + 432);
    *(void *)(v3 + 16) = 0;
    *(void *)(v3 + 24) = 0;
    if (v5 && !atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

uint64_t md::LabelFeature::style(uint64_t a1)
{
  return a1 + 80;
}

void *std::shared_ptr<ggl::VertexData>::operator=[abi:nn180100]<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4UV>,void>(void *a1, uint64_t a2, uint64_t a3)
{
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
  }
  float v4 = (std::__shared_weak_count *)a1[1];
  *a1 = a2;
  a1[1] = a3;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

void md::Label::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 296);
  if (!v6) {
    goto LABEL_19;
  }
  if ((*(unsigned int (**)(uint64_t))(*(void *)v6 + 680))(v6) && !*(unsigned char *)(a2 + 3375))
  {
    uint64_t v7 = *(void *)(a1 + 296);
    if (v7 && (*(unsigned int (**)(uint64_t))(*(void *)v7 + 680))(v7))
    {
      if (*(unsigned char *)(a1 + 1082))
      {
        *(unsigned char *)(a1 + 1082) = 0;
        atomic_store(0, (unsigned __int8 *)(a1 + 1243));
      }
      if (*(unsigned char *)(a1 + 1081))
      {
        *(unsigned char *)(a1 + 1081) = 0;
        atomic_store(0, (unsigned __int8 *)(a1 + 1244));
        *(_DWORD *)(a1 + 1120) = 0;
        *(float *)(a1 + 1124) = (*(float (**)(double))(a1 + 1144))(0.0);
        md::Label::updateStateMachineForDisplay(a1, 8, *(unsigned char *)(a1 + 1073), 0);
      }
      uint64_t v8 = *(void *)(a1 + 296);
      *(void *)(a1 + 296) = 0;
      if (v8) {
        (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
      }
      uint64_t v9 = *(void *)(a1 + 280);
      *(void *)(a1 + 280) = 0;
      if (v9) {
        (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
      }
    }
    uint64_t v10 = *(void *)(a1 + 272);
    if (v10) {
      (*(void (**)(uint64_t))(*(void *)v10 + 552))(v10);
    }
  }
  uint64_t v11 = *(void *)(a1 + 296);
  if (v11)
  {
    if (!*(unsigned char *)(a2 + 465)) {
      goto LABEL_21;
    }
  }
  else
  {
LABEL_19:
    uint64_t v11 = *(void *)(a1 + 272);
    if (!*(unsigned char *)(a2 + 465)) {
      goto LABEL_21;
    }
  }
  if (!*(unsigned char *)(a1 + 1083))
  {
LABEL_31:
    uint64_t v26 = a1;
    int v27 = 2;
    char v28 = 32;
    goto LABEL_33;
  }
LABEL_21:
  if (!v11)
  {
    uint64_t v26 = a1;
    int v27 = 2;
    char v28 = 8;
    goto LABEL_33;
  }
  if (((*(uint64_t (**)(uint64_t))(*(void *)v11 + 88))(v11) & 1) == 0) {
    goto LABEL_31;
  }
  uint64_t v12 = (float64x2_t *)(a1 + 840);
  uint64_t v13 = *(void *)(a1 + 1000);
  if (v13)
  {
    float v14 = *(float *)(a1 + 440);
    float v15 = *(float *)(a2 + 472);
    if (v14 != v15)
    {
      LOBYTE(v15) = *(unsigned char *)(v13 + 40);
      float v16 = exp2f(v14 - (float)LODWORD(v15));
      float64x2_t v69 = *(float64x2_t *)(v13 + 24);
      long long v109 = 0u;
      uint64_t v111 = 0;
      long long v107 = 0u;
      long long v108 = 0u;
      long long v110 = 0u;
      uint64_t v106 = 0x3FF0000000000000;
      *(void *)&long long v109 = 0x3FF0000000000000;
      uint64_t v112 = 0x3FF0000000000000;
      uint64_t v113 = 0;
      float64x2_t v114 = v69;
      long long v115 = xmmword_1A28FCCC0;
      long long v96 = 0u;
      uint64_t v98 = 0;
      long long v101 = 0u;
      long long v100 = 0u;
      long long v97 = 0u;
      long long v95 = 0u;
      long long v94 = 0u;
      uint64_t v102 = 0x3FF0000000000000;
      double v93 = 1.0 / v16;
      *(double *)&long long v96 = v93;
      double v99 = v93;
      gm::operator*<double,4,4,4>((double *)&v103, (double *)&v106, &v93);
      long long v86 = 0u;
      uint64_t v88 = 0;
      long long v87 = 0u;
      long long v85 = 0u;
      long long v84 = 0u;
      uint64_t v83 = 0x3FF0000000000000;
      *(void *)&long long v86 = 0x3FF0000000000000;
      uint64_t v90 = 0;
      uint64_t v89 = 0x3FF0000000000000;
      float64x2_t v91 = vnegq_f64(v69);
      long long v92 = xmmword_1A28FCCC0;
      gm::operator*<double,4,4,4>(v71.f64, (double *)&v103, (double *)&v83);
      double v17 = *(double *)(v13 + 8);
      double v18 = *(double *)(v13 + 16);
      double v19 = 1.0 / (v82 + v73 * *(double *)v13 + v76 * v17 + v79 * v18);
      double v20 = v19 * (v81 + v72 * *(double *)v13 + v75 * v17 + v78 * v18);
      *uint64_t v12 = vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(v80, v71, *(double *)v13), v74, v17), v77, v18), v19);
      *(double *)(a1 + 856) = v20;
    }
  }
  double v21 = *(float *)(a2 + 488);
  double v22 = *(double *)(a1 + 856) + *(double *)(a1 + 904) * v21;
  *(float64x2_t *)(a1 + 960) = vmlaq_n_f64(*v12, *(float64x2_t *)(a1 + 888), v21);
  *(double *)(a1 + 976) = v22;
  long long v103 = xmmword_1A28FCDD0;
  double v104 = 0.0;
  __int16 v105 = 0;
  LOBYTE(v71.f64[0]) = 0;
  BYTE4(v71.f64[1]) = 0;
  md::LabelLayoutContext::evaluateWorldPoint(a2 + 440, a1 + 960, (uint64_t)&v71, *(unsigned __int8 *)(a1 + 1219), 0, (uint64_t)&v103, *(double *)(a1 + 224));
  *(_DWORD *)(a1 + 1040) = HIDWORD(v103);
  int v23 = DWORD2(v103);
  float v24 = fmaxf(*(float *)&v103, 0.0);
  *(float *)(a1 + 440) = v24;
  int v25 = (int)v24;
  if ((int)v24 >= 0x17) {
    LOBYTE(v25) = 23;
  }
  *(unsigned char *)(a1 + 452) = v25;
  *(_DWORD *)(a1 + 1052) = v23;
  if (*(unsigned char *)(a3 + 2) && (_BYTE)v105)
  {
    uint64_t v26 = a1;
    int v27 = 2;
    char v28 = 3;
LABEL_33:
    md::Label::updateStateMachineForDisplay(v26, v27, v28, 0);
    return;
  }
  float v29 = v104;
  *(float *)(a1 + 448) = v29;
  unsigned __int8 v30 = atomic_load((unsigned __int8 *)(a1 + 1243));
  if (v30) {
    goto LABEL_42;
  }
  unsigned __int8 v31 = atomic_load((unsigned __int8 *)(a1 + 1240));
  if (v31) {
    goto LABEL_42;
  }
  float v32 = *(float *)(a1 + 440);
  float v33 = *(float *)(a1 + 1044);
  if (v32 >= v33)
  {
    float v37 = *(float *)(a1 + 1048);
    if (v32 >= v37)
    {
      int v34 = 7;
      if (v32 > (float)(v37 + 0.4)) {
        goto LABEL_40;
      }
LABEL_70:
      int v35 = 0;
      BOOL v36 = *(unsigned char *)(a1 + 1276) != 0;
      goto LABEL_43;
    }
LABEL_42:
    BOOL v36 = 0;
    int v34 = 37;
    int v35 = 1;
    goto LABEL_43;
  }
  int v34 = 6;
  if (v32 >= (float)(v33 + -0.4)) {
    goto LABEL_70;
  }
LABEL_40:
  int v35 = 0;
  BOOL v36 = 1;
LABEL_43:
  if (*(unsigned __int8 *)(a1 + 1109) != v34)
  {
    *(unsigned char *)(a1 + 1109) = v34;
    if (!*(unsigned char *)(a1 + 1105))
    {
      if (*(unsigned char *)(a1 + 1104)) {
        md::Label::updateClusterState((unsigned __int8 *)a1, a2, v34, *(unsigned __int8 *)(a1 + 1085));
      }
    }
  }
  uint64_t v38 = *(void *)(a2 + 1672);
  int v39 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 360))(*(void *)(a1 + 8));
  BOOL v40 = 0;
  if (v39 && v38) {
    BOOL v40 = *(float *)(v38 + 280) > 0.0;
  }
  *(unsigned char *)(a1 + 1077) = v40;
  if (v36)
  {
    uint64_t v26 = a1;
    int v27 = 8;
    char v28 = v34;
    goto LABEL_33;
  }
  if (v35)
  {
    if (!*(unsigned char *)(a1 + 1252))
    {
      LOBYTE(v34) = 30;
      md::Label::updateStateMachineForDisplay(a1, 3, 30, (md::LabelManager *)a2);
      uint64_t v11 = *(void *)(a1 + 296);
      if (!v11) {
        uint64_t v11 = *(void *)(a1 + 272);
      }
      goto LABEL_66;
    }
    if (!*(void *)(a1 + 1192))
    {
      LOBYTE(v34) = 37;
      goto LABEL_72;
    }
    *(void *)&v71.f64[0] = a1;
    md::LabelLayoutContext::LabelLayoutContext((md::LabelLayoutContext *)&v71.f64[1], (const md::LabelLayoutContext *)(a2 + 440));
    uint64_t v41 = *(void *)(a1 + 1192);
    if (*(unsigned char *)(v41 + 52) == 2) {
      *(unsigned char *)(a1 + 1084) = 0;
    }
    unsigned int v42 = *(unsigned __int8 *)(a1 + 1209);
    md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0::$_0((uint64_t)v70, (uint64_t)&v71);
    std::function<gm::Matrix<float,2,1> ()(void)>::function<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,void>((uint64_t)&v106, (uint64_t)v70);
    md::LabelScene::shouldHideLabel(v41, v42, v108, *(unsigned __int8 *)(a1 + 1208));
    *(unsigned char *)(a1 + 1208) = v43;
    std::function<gm::Matrix<float,2,1> ()(void)>::~function(&v106);
    md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0::~$_0(v70);
    if (!*(unsigned char *)(a1 + 1208)
      || (unsigned __int8 v44 = atomic_load((unsigned __int8 *)(a1 + 1241)), (v44 & 1) != 0)
      || (unsigned __int8 v45 = atomic_load((unsigned __int8 *)(a1 + 1240)), (v45 & 1) != 0))
    {
      int v34 = 37;
    }
    else
    {
      int v34 = 29;
    }
    md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0::~$_0(&v71);
  }
  if (v34 != 37)
  {
LABEL_66:
    if (!*(unsigned char *)(a1 + 1072))
    {
      *(unsigned char *)(a1 + 1073) = v34;
      return;
    }
    int v46 = 3;
    goto LABEL_73;
  }
LABEL_72:
  int v46 = 4;
LABEL_73:
  if (!*(unsigned char *)(a2 + 3382) || *(unsigned char *)(a1 + 1255))
  {
    md::Label::setupShowAnimation((md::Label *)a1);
    *(_DWORD *)(a1 + 1152) = 1065353216;
    *(float *)(a1 + 1156) = (*(float (**)(float))(a1 + 1168))(1.0);
    *(_DWORD *)(a1 + 1120) = 1065353216;
    *(float *)(a1 + 1124) = (*(float (**)(float))(a1 + 1136))(1.0);
    int v47 = *(md::LabelAnimator **)(a1 + 1184);
    *(void *)(a1 + 1184) = 0;
    if (v47)
    {
      md::LabelAnimator::~LabelAnimator(v47);
      MEMORY[0x1A6239270]();
    }
  }
  if (((*(uint64_t (**)(void))(**(void **)(a1 + 8) + 360))(*(void *)(a1 + 8)) & 1) == 0) {
    *(_DWORD *)(a1 + 1300) = *(_DWORD *)(a2 + 3344);
  }
  if (*(unsigned char *)(a1 + 1211) == 4) {
    *(_DWORD *)(a1 + 1068) = *(_DWORD *)(a2 + 504);
  }
  switch(*(unsigned char *)(a1 + 1075))
  {
    case 1:
    case 3:
      float v48 = *(double *)(a2 + 696) / v104;
      if (*(unsigned char *)(a1 + 823) == 3) {
        float v48 = *(float *)(a1 + 1064) * v48;
      }
      break;
    case 2:
      md::LabelDisplayCoreStyleGroup::setZoom(*(md::LabelDisplayCoreStyleGroup **)(a1 + 1024), *(float *)(a1 + 440));
      float v48 = *(float *)(*(void *)(a1 + 1024) + 112);
      break;
    case 4:
      float v48 = exp2f(*(float *)(a1 + 440) + -5.0);
      break;
    default:
      float v48 = 1.0;
      break;
  }
  uint64_t v49 = (float64x2_t *)(a1 + 408);
  *(float *)(a1 + 444) = v48;
  if (*(void *)(a1 + 304))
  {
    float64x2_t v50 = vaddq_f64(*(float64x2_t *)(a1 + 936), *(float64x2_t *)(a1 + 960));
    double v51 = *(double *)(a1 + 952) + *(double *)(a1 + 976);
    *uint64_t v49 = v50;
    *(double *)(a1 + 424) = v51;
    float v52 = *(float *)(a1 + 1060);
    if (v52 != 0.0)
    {
      double v53 = *(double *)(a1 + 232) * v52 * *(float *)(a2 + 1624);
      double v54 = *(double *)(a1 + 880);
      *uint64_t v49 = vmlaq_n_f64(v50, *(float64x2_t *)(a1 + 864), v53);
      *(double *)(a1 + 424) = v51 + v54 * v53;
    }
    if (*(unsigned char *)(a1 + 259))
    {
      v55.n128_u64[0] = (unint64_t)md::LabelLayoutContext::projectPointToPixel((float64x2_t *)(a2 + 440), (double *)(a1 + 408), (float32x2_t *)(a1 + 432));
    }
    else
    {
      v55.n128_f32[0] = md::Label::featurePixel(a1, a2, 1);
      *(_DWORD *)(a1 + 432) = v55.n128_u32[0];
      *(_DWORD *)(a1 + 436) = v56;
    }
    uint64_t v57 = *(void *)(a1 + 304);
    v71.f64[0] = 0.0;
    (*(void (**)(uint64_t, uint64_t, void, uint64_t, float64x2_t *, __n128))(*(void *)v57 + 120))(v57, a2, 0, a1 + 432, &v71, v55);
  }
  float64x2_t v58 = vaddq_f64(*(float64x2_t *)(a1 + 912), *(float64x2_t *)(a1 + 960));
  double v59 = *(double *)(a1 + 928) + *(double *)(a1 + 976);
  *uint64_t v49 = v58;
  *(double *)(a1 + 424) = v59;
  float v60 = *(float *)(a1 + 1056);
  if (v60 != 0.0)
  {
    double v61 = *(double *)(a1 + 232) * v60 * *(float *)(a2 + 1624);
    double v62 = *(double *)(a1 + 880);
    float64x2_t v58 = vmlaq_n_f64(v58, *(float64x2_t *)(a1 + 864), v61);
    *uint64_t v49 = v58;
    double v59 = v59 + v62 * v61;
    *(double *)(a1 + 424) = v59;
  }
  if (*(unsigned char *)(a1 + 259))
  {
    v63.f64[0] = *(float64_t *)(a2 + 1328);
    v63.f64[1] = *(float64_t *)(a2 + 1360);
    *(float32x2_t *)(a1 + 432) = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v58.f64[0]), *(float64x2_t *)(a2 + 1336), v58, 1), *(float64x2_t *)(a2 + 1368), v59), 1.0/ (vaddvq_f64(vmulq_f64(v63, v58))+ *(double *)(a2 + 1392) * v59+ *(double *)(a2 + 1424))));
  }
  else
  {
    *(float *)(a1 + 432) = md::Label::featurePixel(a1, a2, 1);
    *(_DWORD *)(a1 + 436) = v64;
  }
  v71.f64[0] = 0.0;
  int v65 = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, float64x2_t *))(*(void *)v11 + 120))(v11, a2, 0, a1 + 432, &v71);
  if ((v65 & 0xFE) == 0x12) {
    int v66 = 3;
  }
  else {
    int v66 = 2;
  }
  if (v65 == 37) {
    char v67 = v34;
  }
  else {
    char v67 = v65;
  }
  if (v65 == 37) {
    int v68 = v46;
  }
  else {
    int v68 = v66;
  }
  md::Label::updateStateMachineForDisplay(a1, v68, v67, (md::LabelManager *)a2);
}

void sub_1A17E144C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::function<gm::Matrix<float,2,1> ()(void)>::~function((void *)(v5 - 248));
  md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0::~$_0(va);
  md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0::~$_0(&STACK[0x530]);
  _Unwind_Resume(a1);
}

uint64_t md::PointLabelFeature::isVenue(md::PointLabelFeature *this)
{
  return *((unsigned __int8 *)this + 648);
}

void md::LabelLayoutContext::evaluateWorldPoint(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, uint64_t a6, double a7)
{
  *(_DWORD *)a6 = *(_DWORD *)(a1 + 32);
  double v7 = *(double *)(a1 + 256);
  *(double *)(a6 + 16) = v7;
  *(double *)(a6 + 24) = v7 / a7;
  *(_WORD *)(a6 + 32) = 0;
  *(_DWORD *)(a6 + 12) = 1065353216;
  *(void *)(a6 + 4) = 0x3F80000000000000;
  if (a4 != 6)
  {
    uint64_t v10 = *(unsigned char **)a1;
    if (*(unsigned char *)(*(void *)a1 + 24) && *(unsigned char *)(a3 + 12))
    {
      uint64_t v11 = a1 + 112;
      uint64_t v12 = 136;
      if (a5) {
        uint64_t v12 = 112;
      }
      else {
        uint64_t v11 = a1 + 136;
      }
      double v13 = *(double *)(a1 + v12) - *(double *)a2;
      double v14 = *(double *)(v11 + 8) - *(double *)(a2 + 8);
      double v15 = *(double *)(v11 + 16) - *(double *)(a2 + 16);
      double v16 = 1.0 / sqrt(v13 * v13 + v14 * v14 + v15 * v15);
      float v17 = v16 * v13;
      float v18 = v16 * v14;
      if (v10[25])
      {
        float v19 = (float)((float)(*(float *)a3 * v17) + (float)(*(float *)(a3 + 4) * v18))
            / sqrtf((float)((float)(v17 * v17) + (float)(v18 * v18))* (float)((float)(*(float *)a3 * *(float *)a3) + (float)(*(float *)(a3 + 4) * *(float *)(a3 + 4))));
      }
      else
      {
        float v20 = v16 * v15;
        float v19 = (float)((float)(*(float *)a3 * v17) + (float)(*(float *)(a3 + 4) * v18))
            + (float)(*(float *)(a3 + 8) * v20);
      }
      *(float *)(a6 + 8) = v19;
      if (v10[26]) {
        *(unsigned char *)(a6 + 33) = COERCE__INT64(-(*(float *)(a3 + 4) * v17 - *(float *)a3 * v18)) < 0;
      }
    }
    if (!v10[18]
      || *(unsigned char *)(a1 + 15)
      || (float64x2_t v21 = vmulq_f64(*(float64x2_t *)(a2 + 8), *(float64x2_t *)(a1 + 168)),
          v21.f64[0] + *(double *)a2 * *(double *)(a1 + 160) + v21.f64[1] <= *(double *)(a1 + 288)))
    {
      if (!*(unsigned char *)(a1 + 9))
      {
        uint64_t v22 = a1 + 112;
        uint64_t v23 = 136;
        if (a5) {
          uint64_t v23 = 112;
        }
        else {
          uint64_t v22 = a1 + 136;
        }
        double v24 = *(double *)a2 - *(double *)(a1 + v23);
        double v25 = *(double *)(a2 + 8) - *(double *)(v22 + 8);
        double v26 = *(double *)(a2 + 16) - *(double *)(v22 + 16);
        double v27 = *(double *)(a1 + 160) * v24 + *(double *)(a1 + 168) * v25 + *(double *)(a1 + 176) * v26;
        if (a4 > 1
          || (double v28 = *(double *)(a1 + 160) * v24 + *(double *)(a1 + 168) * v25 + *(double *)(a1 + 176) * v26,
              *(unsigned char *)(a1 + 15)))
        {
          double v28 = sqrt(v24 * v24 + v25 * v25 + v26 * v26);
        }
        double v29 = v28 / a7;
        *(double *)(a6 + 16) = v28;
        *(double *)(a6 + 24) = v29;
        if (*(unsigned char *)(a1 + 1273) && (float v30 = *(float *)(a1 + 1276), v31 = *(float *)(a1 + 1280), v30 > v31))
        {
          double v32 = *(double *)(a1 + 256);
          double v33 = v32 * v31 / v30;
          BOOL v34 = v27 < v32 - v33;
          if (v27 > v33 + v32) {
            BOOL v34 = 1;
          }
        }
        else
        {
          BOOL v34 = v27 < *(double *)(a1 + 272) || v27 > *(double *)(a1 + 280);
        }
        *(unsigned char *)(a6 + 32) = v34;
        if (*(unsigned char *)(a1 + 16) || !v34)
        {
          double v35 = *(double *)(a1 + 264);
          float v36 = *(double *)(a1 + 256) / v27;
          *(float *)(a6 + 12) = v36;
          int v37 = *(unsigned __int8 *)(a1 + 8);
          if (*(unsigned char *)(a1 + 8))
          {
            double v38 = v26 / sqrt(v24 * v24 + v25 * v25 + v26 * v26);
          }
          else
          {
            double v39 = *(double *)a2;
            double v40 = *(double *)(a2 + 8);
            double v41 = *(double *)(a2 + 16);
            double v42 = sqrt(v39 * v39 + v40 * v40 + v41 * v41);
            if (v42 <= 0.001)
            {
              double v44 = *(double *)(a1 + 208);
              double v45 = *(double *)(a1 + 216);
              double v46 = *(double *)(a1 + 224);
            }
            else
            {
              double v43 = 1.0 / v42;
              double v44 = v43 * v39;
              double v45 = v43 * v40;
              double v46 = v43 * v41;
            }
            double v38 = *(double *)(a1 + 160) * v44 + *(double *)(a1 + 168) * v45 + *(double *)(a1 + 176) * v46;
          }
          float v47 = v38 + 1.0;
          float v48 = fminf(fmaxf(v47, 0.0), 1.0);
          *(float *)(a6 + 4) = v48;
          float v49 = 0.0;
          switch(a4)
          {
            case 0u:
            case 6u:
              float v49 = *(float *)(a1 + 32);
              break;
            case 1u:
              float v51 = *(float *)(a1 + 428);
              float v52 = log2(v35 * v27);
              float v49 = v51 - v52;
              if (!v37) {
                float v49 = *(double *)(a1 + 296) + v49;
              }
              if (!*(unsigned char *)(a1 + 15) && v48 > 0.8) {
                float v49 = fmaxf(v49 + log2f(fmaxf(1.0 - v48, 0.01)), 0.0);
              }
              break;
            case 2u:
            case 3u:
            case 4u:
            case 5u:
              float v50 = v29;
              switch(a4)
              {
                case 2u:
                  float v49 = log2f(fmaxf(v50, 1.0));
                  break;
                case 3u:
                  float v53 = log2f(fmaxf(v50 + -3.0, 1.0));
                  float v54 = 1.7095;
                  goto LABEL_49;
                case 4u:
                  float v53 = log2f(fmaxf(v50 + -3.0, 1.0));
                  float v54 = 3.1063;
LABEL_49:
                  float v49 = v53 * v54;
                  break;
                case 5u:
                  float v55 = 220.0 / v50;
                  float v56 = v55 + -1.0;
                  BOOL v57 = v55 < 0.1;
                  float v58 = -0.9;
                  if (!v57) {
                    float v58 = v56;
                  }
                  float v49 = (float)(logf(v58) * -5.0) + 25.0;
                  break;
                default:
                  goto LABEL_53;
              }
              break;
            default:
              break;
          }
LABEL_53:
          float v59 = floor((float)(v49 * 100.0) + 0.5) * 0.01;
          *(float *)a6 = fmaxf(v59, 0.0);
        }
      }
    }
    else
    {
      *(unsigned char *)(a6 + 32) = 1;
    }
  }
}

void md::Label::updateStateMachineForDisplay(uint64_t a1, int a2, char a3, md::LabelManager *a4)
{
  uint64_t v5 = a1;
  if (a4
    && (*((unsigned char *)a4 + *(unsigned __int8 *)(a1 + 1211) + 3316) || !*((unsigned char *)a4 + 3382) || *(unsigned char *)(a1 + 1255)))
  {
    if ((0x27u >> (a2 - 3))) {
      char v6 = 0x80808050508uLL >> (8 * (a2 - 3));
    }
    else {
      char v6 = a2;
    }
    int v7 = 1;
    if ((a2 - 3) <= 5) {
      LOBYTE(a2) = v6;
    }
  }
  else
  {
    int v7 = 0;
  }
  int v8 = *(unsigned __int8 *)(a1 + 1072);
  int v9 = byte_1A29C636E[4 * a2 + *(char *)(a1 + 1072)];
  if (*(unsigned char *)(a1 + 1078))
  {
    if (v9 == 1)
    {
      int v9 = 3;
      goto LABEL_16;
    }
    if (v9 == 2)
    {
      int v9 = 0;
LABEL_16:
      *(unsigned char *)(a1 + 1078) = 0;
      goto LABEL_20;
    }
    if (v8 != v9) {
      *(unsigned char *)(a1 + 1078) = 0;
    }
  }
  if (v9 == 255)
  {
    int v9 = v8;
    if (v8) {
      goto LABEL_21;
    }
    goto LABEL_25;
  }
LABEL_20:
  *(unsigned char *)(a1 + 1072) = v9;
  *(unsigned char *)(a1 + 1073) = a3;
  if (v9)
  {
LABEL_21:
    if (v9 == 3)
    {
      *(_DWORD *)(a1 + 1120) = 1065353216;
      *(float *)(a1 + 1124) = (*(float (**)(float))(a1 + 1136))(1.0);
      if (v7)
      {
        *(_DWORD *)(v5 + 1152) = 1065353216;
        *(float *)(v5 + 1156) = (*(float (**)(float))(v5 + 1168))(1.0);
      }
    }
    goto LABEL_33;
  }
LABEL_25:
  *(_DWORD *)(a1 + 1120) = 0;
  *(float *)(a1 + 1124) = (*(float (**)(double))(a1 + 1144))(0.0);
  *(_DWORD *)(v5 + 1152) = 0;
  *(float *)(v5 + 1156) = (*(float (**)(double))(v5 + 1176))(0.0);
  *(unsigned char *)(v5 + 1109) = 38;
  if (*(unsigned char *)(v5 + 1082))
  {
    *(unsigned char *)(v5 + 1082) = 0;
    atomic_store(0, (unsigned __int8 *)(v5 + 1243));
  }
  if (*(unsigned char *)(v5 + 1081))
  {
    *(unsigned char *)(v5 + 1081) = 0;
    atomic_store(0, (unsigned __int8 *)(v5 + 1244));
    *(_DWORD *)(v5 + 1120) = 0;
    *(float *)(v5 + 1124) = (*(float (**)(double))(v5 + 1144))(0.0);
    md::Label::updateStateMachineForDisplay(v5, 8, *(unsigned __int8 *)(v5 + 1073), 0);
  }
  uint64_t v10 = *(void *)(v5 + 296);
  *(void *)(v5 + 296) = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  a1 = *(void *)(v5 + 280);
  *(void *)(v5 + 280) = 0;
  if (a1) {
    a1 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 8))(a1);
  }
LABEL_33:
  int v11 = *(unsigned __int8 *)(v5 + 1072);
  if (v8 != 2 && v11 == 2)
  {
    *(_DWORD *)(v5 + 1112) = *(_DWORD *)(v5 + 440);
    goto LABEL_38;
  }
  if (v11 != 1)
  {
    if (v11 != 2) {
      return;
    }
LABEL_38:
    unsigned __int8 v12 = atomic_load((unsigned __int8 *)(v5 + 1243));
    if ((v12 & 1) == 0)
    {
      unsigned __int8 v13 = atomic_load((unsigned __int8 *)(v5 + 1244));
      if ((v13 & 1) == 0)
      {
        uint64_t v14 = *(void *)(v5 + 1192);
        if (v14
          && (*(unsigned char *)(v14 + 52) & 0xFD) == 1
          && ((int v15 = *(unsigned __int8 *)(v14 + 8), v15 == 2) || v15 == 4 && !*(unsigned char *)(v5 + 1209)))
        {
          *(void *)(v5 + 1144) = EaseQuadIn;
          *(_DWORD *)(v5 + 1132) = 1053609165;
          int v17 = *(unsigned __int8 *)(v5 + 1077);
          BOOL v16 = *(unsigned char *)(v5 + 1077) == 0;
          if (!*(unsigned char *)(v5 + 1077)) {
            goto LABEL_69;
          }
        }
        else
        {
          BOOL v16 = *(unsigned char *)(v5 + 1077) == 0;
          if (!*(unsigned char *)(v5 + 1077))
          {
            int v17 = 1;
            goto LABEL_69;
          }
          *(void *)(v5 + 1144) = EaseConstantOne;
          *(_DWORD *)(v5 + 1132) = 897988541;
        }
        int v17 = 0;
        *(void *)(v5 + 1176) = EaseConstantOne;
        *(_DWORD *)(v5 + 1164) = 897988541;
        if (!v16) {
          goto LABEL_109;
        }
LABEL_69:
        uint64_t v24 = *(void *)(v5 + 1008);
        if (!v24 || (float v25 = *(float *)(v24 + 12), v25 == 0.0))
        {
          float v25 = 0.4;
          if (v17)
          {
LABEL_72:
            *(void *)(v5 + 1144) = EaseQuadIn;
            *(float *)(v5 + 1132) = fmaxf(v25, 0.000001);
            if (v16) {
              goto LABEL_76;
            }
            goto LABEL_109;
          }
        }
        else if (v17)
        {
          goto LABEL_72;
        }
        if (v16)
        {
LABEL_76:
          if (v24)
          {
            float v26 = *(float *)(v24 + 20);
            BOOL v27 = v26 == 0.0;
            if (v26 != 0.0) {
              float v25 = *(float *)(v24 + 20);
            }
            unsigned int v28 = *(unsigned __int8 *)(v24 + 25);
          }
          else
          {
            unsigned int v28 = 0;
            BOOL v27 = 1;
          }
          *(float *)(v5 + 1164) = v25;
          if (v28 <= 1) {
            unsigned int v28 = 1;
          }
          switch(v28)
          {
            case 1u:
            case 6u:
              BOOL v34 = EaseConstantOne;
              goto LABEL_107;
            case 2u:
              *(void *)(v5 + 1176) = EaseLinear;
              break;
            case 3u:
              *(void *)(v5 + 1176) = EaseQuadIn;
              break;
            case 4u:
              *(void *)(v5 + 1176) = EaseCubicIn;
              break;
            case 5u:
              if (v27)
              {
                float v25 = v25 + v25;
                *(float *)(v5 + 1164) = v25;
              }
              *(void *)(v5 + 1176) = EaseBounceOut;
              break;
            case 7u:
              BOOL v34 = EaseConstantZero;
LABEL_107:
              *(void *)(v5 + 1176) = v34;
              *(_DWORD *)(v5 + 1164) = 897988541;
              float v25 = 0.000001;
              break;
            default:
              break;
          }
          *(float *)(v5 + 1164) = fmaxf(v25, 0.000001);
        }
LABEL_109:
        *(float *)(v5 + 1124) = (*(float (**)(uint64_t, float))(v5 + 1144))(a1, *(float *)(v5 + 1120));
        *(float *)(v5 + 1156) = (*(float (**)(float))(v5 + 1176))(*(float *)(v5 + 1152));
        return;
      }
      uint64_t v19 = *(void *)(v5 + 296);
      if (v19)
      {
        if (*(unsigned char *)(v5 + 1081)) {
          return;
        }
        if (*(unsigned char *)(v5 + 1082))
        {
          *(unsigned char *)(v5 + 1082) = 0;
          atomic_store(0, (unsigned __int8 *)(v5 + 1243));
        }
        *(void *)(v5 + 296) = 0;
        (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
        uint64_t v20 = *(void *)(v5 + 280);
        *(void *)(v5 + 280) = 0;
        if (v20) {
          (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
        }
      }
      *(unsigned char *)(v5 + 1081) = 1;
      {
        operator new();
      }
      uint64_t v21 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 576, 8);
      bzero((void *)(v21 + 8), 0x238uLL);
      *(_DWORD *)(v21 + 8) = 1065353216;
      *(void *)(v21 + 24) = v21;
      *(_OWORD *)(v21 + 32) = 0u;
      *(_OWORD *)(v21 + 48) = 0u;
      *(_OWORD *)(v21 + 72) = xmmword_1A28FC750;
      *(void *)(v21 + 64) = 0;
      *(void *)(v21 + 88) = 1065353216;
      *(_DWORD *)(v21 + 96) = 1065353216;
      *(void *)(v21 + 108) = 0;
      *(void *)(v21 + 100) = 0;
      *(_DWORD *)(v21 + 116) = 0;
      *(_OWORD *)(v21 + 120) = xmmword_1A28FC750;
      *(_OWORD *)(v21 + 136) = xmmword_1A28FC750;
      *(_OWORD *)(v21 + 152) = xmmword_1A28FC750;
      *(_OWORD *)(v21 + 168) = xmmword_1A28FCDA0;
      *(void *)(v21 + 184) = 0;
      *(void *)(v21 + 192) = 0;
      *(unsigned char *)(v21 + 200) = 0;
      *(_OWORD *)(v21 + 232) = 0u;
      *(_OWORD *)(v21 + 248) = 0u;
      *(_OWORD *)(v21 + 257) = 0u;
      *(_OWORD *)(v21 + 280) = xmmword_1A28FCE90;
      *(_OWORD *)(v21 + 296) = xmmword_1A28FCEA0;
      *(_OWORD *)(v21 + 312) = xmmword_1A28FC750;
      *(void *)(v21 + 328) = 1065353216;
      *(_DWORD *)(v21 + 336) = 1065353216;
      *(_DWORD *)(v21 + 356) = 0;
      *(void *)(v21 + 340) = 0;
      *(void *)(v21 + 348) = 0;
      *(_OWORD *)(v21 + 360) = xmmword_1A28FC750;
      *(_OWORD *)(v21 + 376) = xmmword_1A28FC750;
      *(_OWORD *)(v21 + 392) = xmmword_1A28FC750;
      *(_OWORD *)(v21 + 408) = xmmword_1A28FCDA0;
      *(void *)(v21 + 424) = 0;
      *(void *)(v21 + 432) = 0;
      *(unsigned char *)(v21 + 440) = 0;
      *(_OWORD *)(v21 + 472) = 0u;
      *(_OWORD *)(v21 + 488) = 0u;
      *(_OWORD *)(v21 + 497) = 0u;
      *(_OWORD *)(v21 + 520) = xmmword_1A28FCE90;
      *(_DWORD *)(v21 + 536) = 1065353216;
      *(_WORD *)(v21 + 556) = 512;
      *(void *)(v21 + 540) = 0;
      *(void *)(v21 + 548) = 0;
      *(unsigned char *)(v21 + 562) = 0;
      *(_DWORD *)(v21 + 558) = 0;
      *(_WORD *)(v21 + 563) = -1;
      *(void *)uint64_t v21 = &unk_1EF532910;
      uint64_t v22 = *(void *)(v5 + 280);
      *(void *)(v5 + 280) = v21;
      if (v22) {
        (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
      }
      {
        operator new();
      }
      uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 744, 8);
      md::AnimatedCrossFadeLabelPart::AnimatedCrossFadeLabelPart(v23, a4, (md::Label *)v5, 8, *(md::LabelPart **)(v5 + 272), *(md::LabelPart **)(v5 + 280), 0);
      goto LABEL_89;
    }
    uint64_t v18 = *(void *)(v5 + 296);
    if (!v18)
    {
LABEL_84:
      {
        operator new();
      }
      uint64_t v30 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 576, 8);
      bzero((void *)(v30 + 8), 0x238uLL);
      *(_DWORD *)(v30 + 8) = 1065353216;
      *(void *)(v30 + 24) = v30;
      *(_OWORD *)(v30 + 32) = 0u;
      *(_OWORD *)(v30 + 48) = 0u;
      *(_OWORD *)(v30 + 72) = xmmword_1A28FC750;
      *(void *)(v30 + 64) = 0;
      *(void *)(v30 + 88) = 1065353216;
      *(_DWORD *)(v30 + 96) = 1065353216;
      *(void *)(v30 + 108) = 0;
      *(void *)(v30 + 100) = 0;
      *(_DWORD *)(v30 + 116) = 0;
      *(_OWORD *)(v30 + 120) = xmmword_1A28FC750;
      *(_OWORD *)(v30 + 136) = xmmword_1A28FC750;
      *(_OWORD *)(v30 + 152) = xmmword_1A28FC750;
      *(_OWORD *)(v30 + 168) = xmmword_1A28FCDA0;
      *(void *)(v30 + 184) = 0;
      *(void *)(v30 + 192) = 0;
      *(unsigned char *)(v30 + 200) = 0;
      *(_OWORD *)(v30 + 232) = 0u;
      *(_OWORD *)(v30 + 248) = 0u;
      *(_OWORD *)(v30 + 257) = 0u;
      *(_OWORD *)(v30 + 280) = xmmword_1A28FCE90;
      *(_OWORD *)(v30 + 296) = xmmword_1A28FCEA0;
      *(_OWORD *)(v30 + 312) = xmmword_1A28FC750;
      *(void *)(v30 + 328) = 1065353216;
      *(_DWORD *)(v30 + 336) = 1065353216;
      *(_DWORD *)(v30 + 356) = 0;
      *(void *)(v30 + 340) = 0;
      *(void *)(v30 + 348) = 0;
      *(_OWORD *)(v30 + 360) = xmmword_1A28FC750;
      *(_OWORD *)(v30 + 376) = xmmword_1A28FC750;
      *(_OWORD *)(v30 + 392) = xmmword_1A28FC750;
      *(_OWORD *)(v30 + 408) = xmmword_1A28FCDA0;
      *(void *)(v30 + 424) = 0;
      *(void *)(v30 + 432) = 0;
      *(unsigned char *)(v30 + 440) = 0;
      *(_OWORD *)(v30 + 472) = 0u;
      *(_OWORD *)(v30 + 488) = 0u;
      *(_OWORD *)(v30 + 497) = 0u;
      *(_OWORD *)(v30 + 520) = xmmword_1A28FCE90;
      *(_DWORD *)(v30 + 536) = 1065353216;
      *(_WORD *)(v30 + 556) = 512;
      *(void *)(v30 + 540) = 0;
      *(void *)(v30 + 548) = 0;
      *(unsigned char *)(v30 + 562) = 0;
      *(_DWORD *)(v30 + 558) = 0;
      *(_WORD *)(v30 + 563) = -1;
      *(void *)uint64_t v30 = &unk_1EF532910;
      uint64_t v31 = *(void *)(v5 + 280);
      *(void *)(v5 + 280) = v30;
      if (v31) {
        (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
      }
      *(_WORD *)(v5 + 1081) = 257;
      {
        operator new();
      }
      uint64_t v23 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 16))(mdm::Allocator::instance(void)::alloc, 744, 8);
      md::AnimatedCrossFadeLabelPart::AnimatedCrossFadeLabelPart(v23, a4, (md::Label *)v5, *(unsigned __int8 *)(v5 + 1289), *(md::LabelPart **)(v5 + 272), *(md::LabelPart **)(v5 + 280), 0);
LABEL_89:
      uint64_t v32 = *(void *)(v5 + 296);
      *(void *)(v5 + 296) = v23;
      if (v32)
      {
        double v33 = *(void (**)(void))(*(void *)v32 + 8);
        v33();
      }
      return;
    }
    if (*(unsigned char *)(v5 + 1082)) {
      return;
    }
    if (*(unsigned char *)(v5 + 1081))
    {
      *(unsigned char *)(v5 + 1081) = 0;
      atomic_store(0, (unsigned __int8 *)(v5 + 1244));
      *(_DWORD *)(v5 + 1120) = 0;
      *(float *)(v5 + 1124) = (*(float (**)(double))(v5 + 1144))(0.0);
      md::Label::updateStateMachineForDisplay(v5, 8, *(unsigned __int8 *)(v5 + 1073), 0);
      uint64_t v18 = *(void *)(v5 + 296);
      *(void *)(v5 + 296) = 0;
      if (!v18)
      {
LABEL_82:
        uint64_t v29 = *(void *)(v5 + 280);
        *(void *)(v5 + 280) = 0;
        if (v29) {
          (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
        }
        goto LABEL_84;
      }
    }
    else
    {
      *(void *)(v5 + 296) = 0;
    }
    (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
    goto LABEL_82;
  }
  md::Label::setupShowAnimation((md::Label *)v5);
}

void sub_1A17E250C(mdm::Allocator *a1)
{
  uint64_t v3 = mdm::Allocator::instance(a1);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3 + 40))(v3, v1, 744);
  _Unwind_Resume((_Unwind_Exception *)a1);
}

float EaseQuadOut(float a1)
{
  return (float)(2.0 - a1) * a1;
}

uint64_t md::LabelPart::isDisplayable(md::LabelPart *this)
{
  return *((unsigned __int8 *)this + 560);
}

float md::PointLabelFeature::minZoomRank(md::PointLabelFeature *this)
{
  unsigned int v1 = atomic_load((unsigned __int8 *)this + 653);
  return *((float *)this + v1 + 88);
}

uint64_t non-virtual thunk to'md::MapNavLabeler::isNavHighZoomActive(md::MapNavLabeler *this)
{
  uint64_t result = (*(uint64_t (**)(void))(*((void *)this - 1) + 352))();
  if (result) {
    return *((unsigned __int8 *)this + 122) == 1;
  }
  return result;
}

uint64_t md::MapNavLabeler::isNavActive(md::MapNavLabeler *this)
{
  return *((unsigned __int8 *)this + 128);
}

void *md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0::~$_0(void *a1)
{
  uint64_t v2 = (void *)a1[152];
  if (v2)
  {
    a1[153] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)a1[145];
  if (v3)
  {
    a1[146] = v3;
    operator delete(v3);
  }
  return a1;
}

uint64_t md::LabelFeature::isVenue(md::LabelFeature *this)
{
  return 0;
}

uint64_t *md::LabelStyle::getLabelKnobs(uint64_t *result, uint64_t a2, int a3, char a4, double a5, float a6)
{
  int v6 = *((_DWORD *)result + 45);
  if (!v6) {
    int v6 = 0x7FFFFFFF;
  }
  *(_DWORD *)a2 = v6;
  *(_DWORD *)(a2 + 4) = v6;
  unsigned int v7 = *((_DWORD *)result + 46);
  *(_DWORD *)(a2 + 20) = v7;
  *(unsigned char *)(a2 + 33) = *((unsigned char *)result + 240);
  LOBYTE(v7) = *((unsigned char *)result + 112);
  float v8 = (float)v7;
  *(float *)(a2 + 24) = v8;
  LOBYTE(a6) = *((unsigned char *)result + 113);
  float v9 = (float)LODWORD(a6);
  *(float *)(a2 + 28) = v9;
  *(unsigned char *)(a2 + 32) = *((unsigned char *)result + 142);
  *(float *)(a2 + 8) = v8;
  uint64_t v10 = *(uint64_t *)((char *)result + 188);
  *(void *)(a2 + 12) = v10;
  unsigned __int8 v12 = result;
  switch(a3)
  {
    case 1:
      uint64_t v17 = result[34];
      if (!v17)
      {
        uint64_t result = md::LabelStyle::prepareStyleGroup<md::LabelPointStyleGroup>((uint64_t)result);
        uint64_t v17 = *result;
        v12[34] = *result;
        int v6 = *(_DWORD *)a2;
      }
      int v18 = *(_DWORD *)(v17 + 60);
      if (v6 >= v18) {
        int v19 = v18;
      }
      else {
        int v19 = v6;
      }
      int v20 = v6 + v18;
      if (v18 >= 1) {
        int v20 = v19;
      }
      *(_DWORD *)(a2 + 4) = v20;
      return result;
    case 2:
    case 5:
    case 6:
      LOBYTE(v10) = *((unsigned char *)result + 114);
      float v13 = (float)v10;
      LOBYTE(v10) = *((unsigned char *)result + 115);
      float v14 = (float)v10;
      if ((a4 & 1) == 0) {
        goto LABEL_7;
      }
      goto LABEL_8;
    case 3:
    case 9:
      LOBYTE(v10) = *((unsigned char *)result + 116);
      float v13 = (float)v10;
      LOBYTE(v10) = *((unsigned char *)result + 117);
      float v14 = (float)v10;
      if ((a4 & 1) == 0)
      {
LABEL_7:
        LOBYTE(v10) = *((unsigned char *)result + 112);
        float v15 = (float)v10;
        float v13 = fmaxf(v13, v15);
        LOBYTE(v15) = *((unsigned char *)result + 113);
        float v14 = fminf((float)LODWORD(v15), v14);
      }
      goto LABEL_8;
    case 4:
      LOBYTE(v10) = *((unsigned char *)result + 114);
      float v21 = (float)v10;
      LOBYTE(v9) = *((unsigned char *)result + 118);
      float v22 = (float)LODWORD(v9);
      float v13 = fminf(v22, v21);
      LOBYTE(v21) = *((unsigned char *)result + 115);
      *(float *)&uint64_t v10 = (float)LODWORD(v21);
      LOBYTE(v22) = *((unsigned char *)result + 119);
      float v14 = fmaxf(*(float *)&v10, (float)LODWORD(v22));
      if ((a4 & 1) == 0)
      {
        LOBYTE(v10) = *((unsigned char *)result + 112);
        float v23 = (float)v10;
        float v13 = fmaxf(v13, v23);
        LOBYTE(v23) = *((unsigned char *)result + 113);
        float v14 = fminf(v14, (float)LODWORD(v23));
      }
LABEL_8:
      uint64_t v16 = result[33];
      if (!v16)
      {
        uint64_t result = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)result);
        uint64_t v16 = *result;
        v12[33] = *result;
      }
      LODWORD(v10) = *(_DWORD *)(v16 + 16);
      *(float *)(a2 + 24) = fmaxf(*(float *)&v10, v13);
      *(float *)(a2 + 28) = v14;
      goto LABEL_11;
    case 7:
      LOBYTE(v10) = *((unsigned char *)result + 118);
      float v24 = (float)v10;
      LOBYTE(v10) = *((unsigned char *)result + 119);
      float v25 = (float)v10;
      if ((a4 & 1) == 0)
      {
        LOBYTE(v10) = *((unsigned char *)result + 112);
        float v26 = (float)v10;
        float v24 = fmaxf(v24, v26);
        LOBYTE(v26) = *((unsigned char *)result + 113);
        float v25 = fminf((float)LODWORD(v26), v25);
      }
      uint64_t v27 = result[33];
      if (!v27)
      {
        uint64_t result = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)result);
        uint64_t v27 = *result;
        v12[33] = *result;
      }
      int v28 = *(_DWORD *)(v27 + 16);
      *(float *)(a2 + 24) = fmaxf(*(float *)(v27 + 20), v24);
      *(float *)(a2 + 28) = v25;
      *(_DWORD *)(a2 + 8) = v28;
      return result;
    case 8:
      uint64_t v29 = result[33];
      if (!v29)
      {
        uint64_t result = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>((uint64_t)result);
        uint64_t v29 = *result;
        v12[33] = *result;
      }
      *(unsigned char *)(a2 + 33) = *(unsigned char *)(v29 + 63);
      LOBYTE(v10) = *((unsigned char *)v12 + 120);
      *(float *)&uint64_t v10 = (float)v10;
      *(_DWORD *)(a2 + 24) = v10;
      *(_DWORD *)(a2 + 28) = 1132199936;
LABEL_11:
      *(_DWORD *)(a2 + 8) = v10;
      break;
    case 10:
      *(unsigned char *)(a2 + 32) = 1;
      break;
    default:
      return result;
  }
  return result;
}

float32x2_t md::LabelLayoutContext::projectPointToPixel(float64x2_t *a1, double *a2, float32x2_t *a3)
{
  float32x2_t result = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(a1[60], a1[54], *a2), a1[56], a2[1]), a1[58], a2[2]), 1.0 / (a1[61].f64[1] + a1[55].f64[1] * *a2 + a1[57].f64[1] * a2[1] + a1[59].f64[1] * a2[2])));
  *a3 = result;
  return result;
}

uint64_t md::LabelFeature::styles(md::LabelFeature *this)
{
  return (uint64_t)this + 96;
}

float md::Label::boundsForStaging(md::Label *this)
{
  uint64_t v2 = *((void *)this + 33);
  if (v2 && *((unsigned char *)this + 1283)) {
    return *(float *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 248))(v2);
  }
  uint64_t v2 = *((void *)this + 34);
  if (v2) {
    return *(float *)(*(uint64_t (**)(uint64_t))(*(void *)v2 + 248))(v2);
  }
  else {
    return 3.4028e38;
  }
}

BOOL md::LabelPlacement::operator!=(unsigned __int8 *a1, unsigned __int8 *a2)
{
  if (*a1 != *a2) {
    return 1;
  }
  if (a1[1] != a2[1]) {
    return 1;
  }
  int v2 = a1[3];
  if (v2 != a2[3]) {
    return 1;
  }
  if (v2 == 10) {
    return a1[4] != a2[4];
  }
  return 0;
}

float md::PointLabelFeature::maxZoomRank(md::PointLabelFeature *this)
{
  float result = *((float *)this + 92);
  if (result == 254.0) {
    return 252.0;
  }
  return result;
}

uint64_t md::PointLabelFeature::updateDynamicStyling(md::PointLabelFeature *this, md::LabelManager *a2, md::Label *a3)
{
  int v5 = *((_DWORD *)a3 + 25);
  if (*((_DWORD *)this + 104) != v5)
  {
    uint64_t v6 = *((void *)a2 + 432);
LABEL_6:
    *((_DWORD *)this + 104) = v5;
    *((void *)this + 53) = v6;
    if (*((unsigned char *)this + 655)) {
      *((unsigned char *)this + 655) = 0;
    }
    uint64_t v8 = *((void *)a3 + 10);
    if (v8)
    {
      uint64_t v9 = *(void *)(v8 + 24);
      int v11 = *(int8x8_t **)v9;
      uint64_t v10 = *(std::__shared_weak_count **)(v9 + 8);
      double v33 = *(int8x8_t **)v9;
      BOOL v34 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v11)
      {
        unsigned __int8 v12 = (unsigned __int8 **)geo::codec::VectorTile::liveMetadataForID(v11, *((void *)this + 62));
        if (v12)
        {
          uint64_t v13 = geo::codec::VectorTile::liveVariants((geo::codec::VectorTile *)v11);
          float v14 = *v12;
          float v15 = v12[1];
          if (*v12 == v15)
          {
            float v19 = 0.0;
            int v17 = 1;
            float v18 = 0.0;
          }
          else
          {
            uint64_t v16 = v13 + 8;
            int v17 = 1;
            float v18 = 0.0;
            float v19 = 0.0;
            do
            {
              int v20 = *v14;
              uint64_t v21 = *((unsigned int *)v14 + 1);
              uint64_t v22 = *((unsigned __int16 *)v14 + 4);
              if (*v14)
              {
                if (v20 == 1)
                {
                  if (*((_WORD *)v14 + 4))
                  {
                    float v23 = (float *)(v16 + 16 * v21);
                    do
                    {
                      if ((*((void *)this + 53) & *((void *)v23 - 1)) != 0) {
                        float v24 = *v23;
                      }
                      else {
                        float v24 = 0.0;
                      }
                      float v19 = v24 + v19;
                      v23 += 4;
                      --v22;
                    }
                    while (v22);
                  }
                }
                else if (v20 == 2 && v22 != 0)
                {
                  int v17 = *(unsigned __int8 *)(v13 + 16 * v21);
                }
              }
              else if (*((_WORD *)v14 + 4))
              {
                float v25 = (float *)(v16 + 16 * v21);
                do
                {
                  if ((*((void *)this + 53) & *((void *)v25 - 1)) != 0) {
                    float v26 = *v25;
                  }
                  else {
                    float v26 = 0.0;
                  }
                  float v18 = v26 + v18;
                  v25 += 4;
                  --v22;
                }
                while (v22);
              }
              v14 += 12;
            }
            while (v14 != v15);
          }
          if (*((unsigned char *)this + 400)
            && *((float *)this + 99) == v19
            && *((unsigned char *)this + 408)
            && *((float *)this + 101) == v18
            && *((unsigned char *)this + 413)
            && *((unsigned __int8 *)this + 412) == v17)
          {
            int v28 = 0;
            float v19 = *((float *)this + 99);
            if (v17 != 2) {
              goto LABEL_52;
            }
          }
          else
          {
            *((float *)this + 99) = v19;
            int v28 = 1;
            *((unsigned char *)this + 400) = 1;
            *((float *)this + 101) = v18;
            *((unsigned char *)this + 408) = 1;
            *((_WORD *)this + 206) = v17 | 0x100;
            if (v17 != 2)
            {
LABEL_52:
              if (v19 == 0.0) {
                __int16 v29 = 258;
              }
              else {
                __int16 v29 = 259;
              }
              goto LABEL_57;
            }
          }
          __int16 v29 = 257;
LABEL_57:
          *((_WORD *)this + 327) = v29;
          goto LABEL_58;
        }
      }
    }
    else
    {
      uint64_t v10 = 0;
      double v33 = 0;
      BOOL v34 = 0;
    }
    if (*((unsigned char *)this + 400))
    {
      *((unsigned char *)this + 400) = 0;
      if (!*((unsigned char *)this + 408))
      {
        if (*((unsigned char *)this + 413))
        {
LABEL_39:
          *((unsigned char *)this + 413) = 0;
          int v28 = 1;
LABEL_58:
          if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
            std::__shared_weak_count::__release_weak(v10);
            if (*((unsigned char *)this + 448))
            {
LABEL_61:
              *((unsigned char *)this + 448) = 0;
              if (md::DebugStreamingPOIFeatureID) {
                BOOL v30 = md::DebugStreamingPOIFeatureID == *((void *)this + 62);
              }
              else {
                BOOL v30 = 0;
              }
              if (v30)
              {
                if (GEOGetVectorKitStreamingPOILog_onceToken != -1) {
                  dispatch_once(&GEOGetVectorKitStreamingPOILog_onceToken, &__block_literal_global_61);
                }
                uint64_t v31 = (id)GEOGetVectorKitStreamingPOILog_log;
                if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
                {
                  LOWORD(v33) = 0;
                  _os_log_impl(&dword_1A1780000, v31, OS_LOG_TYPE_DEBUG, "PointLabelFeature::updateDynamicStyling [CrossFade]", (uint8_t *)&v33, 2u);
                }

                uint64_t v7 = 1;
              }
              else
              {
                uint64_t v7 = 1;
              }
              goto LABEL_73;
            }
          }
          else if (*((unsigned char *)this + 448))
          {
            goto LABEL_61;
          }
          uint64_t v7 = 0;
          if (!v28) {
            return v7;
          }
LABEL_73:
          (*(void (**)(md::PointLabelFeature *, md::LabelManager *))(*(void *)this + 536))(this, a2);
          return v7;
        }
LABEL_42:
        int v28 = 1;
        goto LABEL_58;
      }
    }
    else if (!*((unsigned char *)this + 408))
    {
      int v28 = 0;
      goto LABEL_58;
    }
    *((unsigned char *)this + 408) = 0;
    if (*((unsigned char *)this + 413)) {
      goto LABEL_39;
    }
    goto LABEL_42;
  }
  uint64_t v6 = *((void *)a2 + 432);
  if (*((void *)this + 53) != v6) {
    goto LABEL_6;
  }
  if (*((unsigned char *)this + 448)) {
    goto LABEL_61;
  }
  return 0;
}

void sub_1A17E2D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t md::PointLabelFeature::hasIdentifier(uint64_t a1, unsigned int *a2)
{
  int v2 = *(uint64_t **)(a1 + 464);
  if (!v2) {
    return 0;
  }
  unsigned int v3 = *a2;
  while (1)
  {
    unsigned int v4 = *((_DWORD *)v2 + 8);
    if (v3 >= v4) {
      break;
    }
LABEL_3:
    int v2 = (uint64_t *)*v2;
    if (!v2) {
      return 0;
    }
  }
  if (v4 < v3)
  {
    ++v2;
    goto LABEL_3;
  }
  return 1;
}

unint64_t md::LabelStyle::collisionGroupInfo(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 256);
  uint64_t v4 = *(unsigned __int16 *)(a1 + 261) | (*(unsigned __int8 *)(a1 + 263) << 16);
  if (a2 == 8)
  {
    uint64_t v5 = *(void *)(a1 + 264);
    if (!v5)
    {
      uint64_t v6 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>(a1);
      uint64_t v5 = *v6;
      *(void *)(a1 + 264) = *v6;
    }
    uint64_t v7 = (unsigned __int8 *)(v5 + 63);
  }
  else
  {
    uint64_t v7 = (unsigned __int8 *)(a1 + 260);
  }
  return v3 | (v4 << 40) | ((unint64_t)*v7 << 32);
}

uint64_t md::CrossFadeLabelPart::isDisplayable(md::CrossFadeLabelPart *this)
{
  return 1;
}

uint64_t md::LabelPart::isStyleFadeNode(md::LabelPart *this)
{
  return 0;
}

uint64_t md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0::$_0(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = *(void *)a2;
  memcpy((void *)(a1 + 8), (const void *)(a2 + 8), 0x480uLL);
  *(void *)(a1 + 1160) = 0;
  *(void *)(a1 + 1176) = 0;
  *(void *)(a1 + 1168) = 0;
  if (a1 != a2) {
    std::vector<gm::Matrix<double,2,1>>::__assign_with_size[abi:nn180100]<gm::Matrix<double,2,1>*,gm::Matrix<double,2,1>*>(a1 + 1160, *(void *)(a2 + 1160), *(char **)(a2 + 1168), (uint64_t)(*(void *)(a2 + 1168) - *(void *)(a2 + 1160)) >> 4);
  }
  long long v4 = *(_OWORD *)(a2 + 1184);
  *(_OWORD *)(a1 + 1200) = *(_OWORD *)(a2 + 1200);
  *(_OWORD *)(a1 + 1184) = v4;
  *(void *)(a1 + 1216) = 0;
  *(void *)(a1 + 1232) = 0;
  *(void *)(a1 + 1224) = 0;
  uint64_t v5 = *(unsigned char **)(a2 + 1216);
  uint64_t v6 = *(unsigned char **)(a2 + 1224);
  int64_t v7 = v6 - v5;
  if (v6 != v5)
  {
    if (v7 < 0) {
      abort();
    }
    uint64_t v8 = (char *)operator new(v6 - v5);
    *(void *)(a1 + 1216) = v8;
    *(void *)(a1 + 1224) = v8;
    uint64_t v9 = &v8[16 * (v7 >> 4)];
    *(void *)(a1 + 1232) = v9;
    memcpy(v8, v5, v7);
    *(void *)(a1 + 1224) = v9;
  }
  long long v10 = *(_OWORD *)(a2 + 1240);
  long long v11 = *(_OWORD *)(a2 + 1256);
  long long v12 = *(_OWORD *)(a2 + 1272);
  *(_DWORD *)(a1 + 1288) = *(_DWORD *)(a2 + 1288);
  *(_OWORD *)(a1 + 1272) = v12;
  *(_OWORD *)(a1 + 1256) = v11;
  *(_OWORD *)(a1 + 1240) = v10;
  return a1;
}

void sub_1A17E2F4C(_Unwind_Exception *exception_object)
{
  long long v4 = *v2;
  if (*v2)
  {
    *(void *)(v1 + 1168) = v4;
    operator delete(v4);
  }
  _Unwind_Resume(exception_object);
}

void *std::function<gm::Matrix<float,2,1> ()(void)>::~function(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0,std::allocator<md::Label::layoutForDisplay(md::LabelManager *,md::LabelLayoutOptions const&)::$_0>,gm::Matrix<float,2,1> ()(void)>::destroy_deallocate(void *__p)
{
  int v2 = (void *)__p[153];
  if (v2)
  {
    __p[154] = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)__p[146];
  if (v3)
  {
    __p[147] = v3;
    operator delete(v3);
  }
  operator delete(__p);
}

void md::LabelScene::shouldHideLabel(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  uint64_t v4 = *(void *)(a1 + 56);
  if (0xCCCCCCCCCCCCCCCDLL * ((*(void *)(a1 + 64) - v4) >> 2) > a2)
  {
    int v5 = *(unsigned __int8 *)(a1 + 52);
    if (*(unsigned char *)(a1 + 52))
    {
      if (v5 != 3 && v5 != 2 && *(unsigned char *)(v4 + 20 * a2 + 16) && a4)
      {
        if (a3)
        {
          (*(void (**)(uint64_t))(*(void *)a3 + 48))(a3);
        }
        else
        {
          std::__throw_bad_function_call[abi:nn180100]();
          md::Label::setupShowAnimation(v6);
        }
      }
    }
  }
}

void md::Label::setupShowAnimation(md::Label *this)
{
  __int16 v16 = 0;
  uint64_t v2 = *((void *)this + 149);
  if (v2 && (*(unsigned char *)(v2 + 52) & 0xFD) == 1)
  {
    int v3 = *(unsigned __int8 *)(v2 + 8);
    if ((v3 - 2) < 3)
    {
      *((void *)this + 142) = EaseQuadOut;
      *((_DWORD *)this + 282) = 1053609165;
      uint64_t v4 = (__int16 *)((char *)&v16 + 1);
      goto LABEL_7;
    }
    if (v3 == 1)
    {
      *((void *)this + 142) = EaseQuadOut;
      *((_DWORD *)this + 282) = 1053609165;
      HIBYTE(v16) = 1;
      *((void *)this + 146) = EaseCubicOut;
      *((_DWORD *)this + 290) = 1056964608;
      uint64_t v4 = &v16;
LABEL_7:
      *(unsigned char *)uint64_t v4 = 1;
      int v5 = HIBYTE(v16) == 0;
      if (!*((unsigned char *)this + 1077)) {
        goto LABEL_8;
      }
      goto LABEL_11;
    }
  }
  int v5 = 1;
  if (!*((unsigned char *)this + 1077))
  {
LABEL_8:
    BOOL v6 = (_BYTE)v16 == 0;
    if (v5) {
      goto LABEL_17;
    }
    goto LABEL_16;
  }
LABEL_11:
  if (v5)
  {
    *((void *)this + 142) = EaseConstantOne;
    *((_DWORD *)this + 282) = 897988541;
  }
  int v5 = v16;
  if ((_BYTE)v16)
  {
    BOOL v6 = 0;
    int v5 = 0;
  }
  else
  {
    BOOL v6 = 0;
    *((void *)this + 146) = EaseConstantOne;
    *((_DWORD *)this + 290) = 897988541;
    if (v5) {
      goto LABEL_17;
    }
  }
LABEL_16:
  if (!v6) {
    goto LABEL_43;
  }
LABEL_17:
  uint64_t v7 = *((void *)this + 126);
  if (!v7 || (float v8 = *(float *)(v7 + 8), v8 == 0.0))
  {
    float v8 = 0.4;
    if (v5)
    {
LABEL_20:
      *((void *)this + 142) = EaseQuadOut;
      *((float *)this + 282) = fmaxf(v8, 0.000001);
      if (!v6) {
        goto LABEL_43;
      }
      goto LABEL_24;
    }
  }
  else if (v5)
  {
    goto LABEL_20;
  }
  if (!v6) {
    goto LABEL_43;
  }
LABEL_24:
  float v9 = v8 * 1.25;
  if (v7)
  {
    float v10 = *(float *)(v7 + 16);
    BOOL v11 = v10 == 0.0;
    if (v10 != 0.0) {
      float v9 = *(float *)(v7 + 16);
    }
    unsigned int v12 = *(unsigned __int8 *)(v7 + 24);
  }
  else
  {
    unsigned int v12 = 0;
    BOOL v11 = 1;
  }
  if (v12 <= 1) {
    int v13 = 1;
  }
  else {
    int v13 = v12;
  }
  float v14 = (float (*)(float))EaseLinear;
  switch(v13)
  {
    case 1:
    case 6:
      float v15 = EaseConstantOne;
      goto LABEL_40;
    case 2:
      goto LABEL_41;
    case 3:
      float v14 = EaseQuadOut;
      goto LABEL_41;
    case 4:
      float v14 = EaseCubicOut;
      goto LABEL_41;
    case 5:
      if (v11)
      {
        float v9 = v9 + v9;
        *((float *)this + 290) = v9;
      }
      float v14 = EaseBounceOut;
      goto LABEL_41;
    case 7:
      float v15 = (float (*)(float))EaseConstantZero;
LABEL_40:
      float v14 = v15;
      float v9 = 0.000001;
LABEL_41:
      *((void *)this + 146) = v14;
      break;
    default:
      break;
  }
  *((float *)this + 290) = fmaxf(v9, 0.000001);
LABEL_43:
  *((float *)this + 281) = (*((float (**)(float))this + 142))(*((float *)this + 280));
  *((float *)this + 289) = (*((float (**)(float))this + 146))(*((float *)this + 288));
}

uint64_t md::LabelStyle::animationStyleGroup(md::LabelStyle *this)
{
  if (!*((void *)this + 40))
  {
    __int16 v38 = 0;
    char v39 = 6;
    uint64_t v3 = *((void *)this + 42);
    uint64_t v4 = *((void *)this + 43);
    if (v3 != v4)
    {
      while (1)
      {
        BOOL v5 = !*(unsigned char *)v3 && *(unsigned char *)(v3 + 1) == 0;
        if (v5 && *(unsigned char *)(v3 + 2) == 6) {
          break;
        }
        v3 += 16;
        if (v3 == v4) {
          goto LABEL_15;
        }
      }
    }
    if (v3 == v4) {
LABEL_15:
    }
      operator new();
    uint64_t v7 = *(uint64_t **)(v3 + 8);
    if (!*((unsigned char *)v7 + 12))
    {
      uint64_t v12 = *v7;
      *((unsigned char *)v7 + 12) = 1;
      if (*(void *)this)
      {
        int v13 = (uint64_t *)md::LabelStyle::styleQueryForComponent((unsigned __int8 **)this, 0, 0);
        uint64_t v14 = *v13;
        if (*v13)
        {
          float v15 = (std::__shared_weak_count *)v13[1];
          v35[0] = *v13;
          v35[1] = v15;
          if (v15) {
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v36, v14, (uint64_t)v15);
          if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
            std::__shared_weak_count::__release_weak(v15);
          }
          if (v37)
          {
            if ((int)*((float *)this + 26) >= 0x17) {
              unsigned int v16 = 23;
            }
            else {
              unsigned int v16 = (int)*((float *)this + 26);
            }
            *(void *)(v12 + 8) = 0;
            *(void *)(v12 + 16) = 0;
            *(_DWORD *)(v12 + 24) = 0;
            uint64_t v17 = *(void *)(v36[0] + 24);
            unsigned int v18 = *(unsigned __int8 *)(v17 + 12);
            if (v18 == 2)
            {
              LOBYTE(v35[0]) = 1;
              char v40 = 1;
              int v19 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v17, 0x120u, v16, 0, v35);
              gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v17, 0x120u, v16, 1u, &v40);
            }
            else
            {
              int v19 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v36[0] + 24), 0x120u, v16, v18, 0);
            }
            *(_DWORD *)(v12 + 8) = v19;
            uint64_t v20 = *(void *)(v36[0] + 24);
            unsigned int v21 = *(unsigned __int8 *)(v20 + 12);
            if (v21 == 2)
            {
              LOBYTE(v35[0]) = 1;
              char v40 = 1;
              int v22 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v20, 0x121u, v16, 0, v35);
              gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v20, 0x121u, v16, 1u, &v40);
            }
            else
            {
              int v22 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v36[0] + 24), 0x121u, v16, v21, 0);
            }
            *(_DWORD *)(v12 + 12) = v22;
            uint64_t v23 = *(void *)(v36[0] + 24);
            unsigned int v24 = *(unsigned __int8 *)(v23 + 12);
            if (v24 == 2)
            {
              LOBYTE(v35[0]) = 1;
              char v40 = 1;
              int v25 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v23, 0x122u, v16, 0, v35);
              gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v23, 0x122u, v16, 1u, &v40);
            }
            else
            {
              int v25 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v36[0] + 24), 0x122u, v16, v24, 0);
            }
            *(_DWORD *)(v12 + 16) = v25;
            uint64_t v26 = *(void *)(v36[0] + 24);
            unsigned int v27 = *(unsigned __int8 *)(v26 + 12);
            if (v27 == 2)
            {
              LOBYTE(v35[0]) = 1;
              char v40 = 1;
              int v28 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v26, 0x124u, v16, 0, v35);
              gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v26, 0x124u, v16, 1u, &v40);
            }
            else
            {
              int v28 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(v36[0] + 24), 0x124u, v16, v27, 0);
            }
            *(_DWORD *)(v12 + 20) = v28;
            uint64_t v29 = *(void *)(v36[0] + 24);
            unsigned int v30 = *(unsigned __int8 *)(v29 + 12);
            if (v30 == 2)
            {
              LOBYTE(v35[0]) = 1;
              char v40 = 1;
              int v31 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v29, 0x123u, v16, 0, v35);
              gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v29, 0x123u, v16, 1u, &v40);
            }
            else
            {
              int v31 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v36[0] + 24), 0x123u, v16, v30, 0);
            }
            *(unsigned char *)(v12 + 24) = v31;
            uint64_t v32 = *(void *)(v36[0] + 24);
            unsigned int v33 = *(unsigned __int8 *)(v32 + 12);
            if (v33 == 2)
            {
              LOBYTE(v35[0]) = 1;
              char v40 = 1;
              int v34 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v32, 0x125u, v16, 0, v35);
              gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v32, 0x125u, v16, 1u, &v40);
              *(unsigned char *)(v12 + 25) = v34;
            }
            else
            {
              *(unsigned char *)(v12 + 25) = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v36[0] + 24), 0x125u, v16, v33, 0);
            }
          }
          gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v36);
        }
      }
    }
    uint64_t v8 = *v7;
    float v9 = operator new(0x38uLL);
    v9[1] = 0;
    v9[2] = 0;
    *float v9 = &unk_1EF581A28;
    v9[3] = &unk_1EF545190;
    int v10 = *(_DWORD *)(v8 + 24);
    *((_OWORD *)v9 + 2) = *(_OWORD *)(v8 + 8);
    *((_DWORD *)v9 + 12) = v10;
    BOOL v11 = (std::__shared_weak_count *)*((void *)this + 41);
    *((void *)this + 40) = v9 + 3;
    *((void *)this + 41) = v9;
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
  }
  return (uint64_t)this + 320;
}

void sub_1A17E3A60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1A17E3A74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::unique_ptr<md::LabelStyleGroupInfo>::~unique_ptr[abi:nn180100]((uint64_t **)va);
  _Unwind_Resume(a1);
}

uint64_t md::LabelFeature::isOnRouteFeature(md::LabelFeature *this)
{
  return 0;
}

uint64_t md::Label::updatePoiPositionOffsets(uint64_t this, const LabelLayoutContext *a2, float a3)
{
  *(_DWORD *)(this + 776) = 0;
  *(void *)(this + 768) = 0;
  if (!*(unsigned char *)(this + 258))
  {
    float v6 = *(float *)(this + 240);
LABEL_14:
    *(float *)(this + 768) = v6;
    return this;
  }
  int v3 = *(unsigned __int8 *)(this + 256);
  if ((v3 & 0xFE) == 2)
  {
    float v4 = -1.5;
    if (v3 == 3) {
      float v4 = 1.0;
    }
    *(float *)(this + 776) = v4;
  }
  if ((v3 - 1) <= 1 && a2 != 0) {
    *(_DWORD *)(this + 772) = *(_DWORD *)(this + 244);
  }
  float v6 = 1.0;
  if (a3 > 0.0) {
    goto LABEL_14;
  }
  return this;
}

uint64_t md::LineLabelFeature::updateDynamicStyling(md::LineLabelFeature *this, LabelManager *a2, md::Label *a3)
{
  if (*((unsigned char *)this + 432))
  {
    (*(void (**)(md::LineLabelFeature *, LabelManager *, md::Label *))(*(void *)this + 536))(this, a2, a3);
    *((unsigned char *)this + 432) = 0;
  }
  return 0;
}

BOOL md::UniLineLabelFeature::isOnRouteFeature(md::UniLineLabelFeature *this)
{
  return *((unsigned char *)this + 448) == 14;
}

float md::LabelFeature::maxZoomRank(md::LabelFeature *this)
{
  return 252.0;
}

uint64_t md::Label::resolvedCollisionOverlayGroup(md::Label *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 1240);
  if (v1) {
    return 1;
  }
  uint64_t result = *((unsigned __int8 *)this + 365);
  if (!result)
  {
    unsigned int v4 = *((unsigned __int8 *)this + 1211);
    if (v4 <= 0x17)
    {
      if (((1 << v4) & 0xF17000) != 0) {
        return 4;
      }
      if (((1 << v4) & 0x300) != 0) {
        return 3;
      }
      if (v4 == 2
        && (*(unsigned int (**)(void))(**((void **)this + 1) + 280))(*((void *)this + 1)) == 1)
      {
        return 4;
      }
    }
    if (*((unsigned char *)this + 1210) == 1)
    {
      uint64_t v5 = *((void *)this + 1);
      uint64_t v6 = *((unsigned int *)this + 12);
      unsigned __int8 v7 = atomic_load((unsigned __int8 *)this + 1240);
      uint64_t v8 = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, void, void, void))(*(void *)v5 + 552))(v5, v6, 0, v7 & 1, 0);
      uint64_t v9 = *v8;
      if (*v8)
      {
        uint64_t v10 = *(void *)(v9 + 296);
        if (!v10)
        {
          BOOL v11 = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelIconStyleGroup>(*v8, 0);
          uint64_t v10 = *v11;
          *(void *)(v9 + 296) = *v11;
        }
        if (*(unsigned char *)(v10 + 88) == 2) {
          return 4;
        }
      }
    }
    return 2;
  }
  return result;
}

uint64_t md::CrossFadeLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if ((*(unsigned int (**)(void))(***(void ***)(a1 + 576) + 88))(**(void **)(a1 + 576))) {
    char v10 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(***(void ***)(a1 + 576) + 120))(**(void **)(a1 + 576), a2, a3, a4, a5);
  }
  else {
    char v10 = 32;
  }
  *(unsigned char *)(a1 + 636) = v10;
  if ((*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 576) + 8) + 88))(*(void *)(*(void *)(a1 + 576) + 8))) {
    LODWORD(result) = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 576) + 8)
  }
                                                                                            + 120))(*(void *)(*(void *)(a1 + 576) + 8), a2, a3, a4, a5);
  else {
    LODWORD(result) = 32;
  }
  *(unsigned char *)(a1 + 637) = result;
  if (*(unsigned char *)(a1 + 636) == 37) {
    return 37;
  }
  else {
    return result;
  }
}

float md::Label::featurePixel(uint64_t a1, uint64_t a2, int a3)
{
  float result = 0.0;
  if (*(unsigned char *)(a1 + 1211) == 6)
  {
    objc_msgSend(*(id *)(*(void *)(a1 + 8) + 192), "position", 0.0, 0.0);
    if (a3 == 1) {
      uint64_t v7 = a2 + 440;
    }
    else {
      uint64_t v7 = *(void *)(a2 + 432);
    }
    return v6 * *(float *)(v7 + 40);
  }
  return result;
}

uint64_t md::CurvedTextLabelPart::needsCrossfade(uint64_t a1, float *a2, int a3, uint64_t a4)
{
  double v6 = a2;
  uint64_t v8 = *(uint64_t **)(a1 + 32);
  if (*(unsigned char *)(a1 + 1458) == 4)
  {
    uint64_t v9 = *v8;
    BOOL v10 = *(unsigned __int8 *)(a1 + 864) == 1;
    uint64_t v11 = *v8 + 280;
    uint64_t v12 = *(unsigned char *)(a1 + 864) == 1 ? 6 : 0;
    a2 = *(float **)(v11 + 8 * (*(unsigned char *)(a1 + 864) == 1));
    if (a2)
    {
      if (vabds_f32(a2[2], *(float *)(v9 + 104)) >= 0.01)
      {
        md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)v9, (uint64_t)a2, v12);
        a2 = *(float **)(v11 + 8 * v10);
      }
    }
    else
    {
      a2 = (float *)md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>(v9, v12);
      *(void *)(v11 + 8 * v10) = a2;
    }
    float v13 = *(float *)(*(void *)a2 + 100);
    if (v13 != 0.0)
    {
      float v14 = v13 / v6[44];
      float v15 = *(float *)(*v8 + 152) + *(float *)(*v8 + 152);
      if (*(unsigned char *)(a1 + 1461) == 8)
      {
        if (v14 < v15) {
          goto LABEL_12;
        }
LABEL_22:
        char v16 = 1;
        *(unsigned char *)(a4 + 8) = 1;
        *(unsigned char *)a4 = 1;
        if (*(unsigned char *)(a1 + 1457)) {
          goto LABEL_23;
        }
        goto LABEL_13;
      }
      if (v14 < v15) {
        goto LABEL_22;
      }
    }
  }
LABEL_12:
  char v16 = 0;
  if (*(unsigned char *)(a1 + 1457)) {
    goto LABEL_23;
  }
LABEL_13:
  if (*(unsigned char *)(a1 + 1465) && *(unsigned char *)(a1 + 1466) && *(unsigned char *)(a1 + 1140) == 37)
  {
    *(unsigned char *)(a1 + 1466) = 0;
    if (*((unsigned char *)v6 + 3029) && !*((unsigned char *)v6 + 3031))
    {
      uint64_t v25 = *(void *)(a1 + 16);
      uint64_t v26 = *(void *)(v25 + 64);
      unsigned int v27 = *(std::__shared_weak_count **)(v25 + 72);
      if (v27) {
        atomic_fetch_add_explicit(&v27->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v26)
      {
        uint64_t v28 = v26 + 144;
        if ((*(uint64_t (**)(void, uint64_t, double))(**(void **)(a1 + 1072) + 72))(*(void *)(a1 + 1072), v26 + 144, 0.0) & 1) != 0|| ((*(uint64_t (**)(void, uint64_t, double))(**(void **)(a1 + 1088) + 72))(*(void *)(a1 + 1088), v28, 0.0))
        {
          int v17 = 1;
        }
        else
        {
          int v17 = (*(uint64_t (**)(void, uint64_t, double))(**(void **)(a1 + 1104) + 72))(*(void *)(a1 + 1104), v28, 0.0);
        }
      }
      else
      {
        int v17 = 0;
      }
      if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
        std::__shared_weak_count::__release_weak(v27);
      }
    }
    else
    {
      int v17 = 0;
    }
    int v18 = *(unsigned __int8 *)(a1 + 1456);
    if (v18 != v17)
    {
      char v16 = 1;
      *(unsigned char *)(a4 + 10) = 1;
      *(unsigned char *)(a4 + 2) = v18 ^ 1;
    }
  }
LABEL_23:
  int v19 = *(unsigned __int8 *)(a1 + 1452);
  if (*(unsigned __int8 *)(a1 + 1141) != v19 && v19 != 0)
  {
    char v16 = 1;
    *(unsigned char *)(a4 + 11) = 1;
    *(unsigned char *)(a4 + 3) = v19;
    *(unsigned char *)(a4 + 9) = 1;
    *(unsigned char *)(a4 + 1) = 0;
    if (!a3) {
      goto LABEL_42;
    }
LABEL_34:
    if (*(unsigned __int8 *)(*v8 + 253) == *(unsigned __int8 *)(a1 + 1398)) {
      char v23 = v16;
    }
    else {
      char v23 = 1;
    }
    if (v23) {
      return 1;
    }
    goto LABEL_38;
  }
  int v21 = *(unsigned __int8 *)(a1 + 1454);
  if (*(unsigned __int8 *)(a1 + 1136) != v21 && v21 != 0)
  {
    char v16 = 1;
    *(unsigned char *)(a4 + 9) = 1;
    *(unsigned char *)(a4 + 1) = v21;
    *(_WORD *)(a4 + 6) = *(unsigned __int8 *)(a1 + 1137) | 0x100;
  }
  if (a3) {
    goto LABEL_34;
  }
LABEL_42:
  if (v16) {
    return 1;
  }
LABEL_38:
  return md::TextLabelPart::needsCrossfade(a1, (uint64_t)a2, a3);
}

void sub_1A17E41AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t md::CurvedTextLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, md::LabelAnimator *a3, __int32 *a4, _DWORD *a5, double a6, double a7, double a8, float64x2_t a9)
{
  uint64_t v12 = md::TextLabelPart::layoutForDisplay((float32x2_t *)a1, (md::LabelManager *)a2, a3, a4, a5, a6, a7, a8, a9);
  if (v12 != 37) {
    return v12;
  }
  LOBYTE(v59) = 0;
  uint64_t v13 = *(void *)(a1 + 592);
  if (*(unsigned __int16 *)(a1 + 804) == *(unsigned __int16 *)(a1 + 806)
    || (int v14 = md::FontAtlas::commitGlyphs(*(void *)(a2 + 304), v13 + 96, (unsigned __int16 *)(a1 + 804), &v59)) != 0)
  {
    LOBYTE(v14) = md::FontAtlas::commitGlyphs(*(void *)(a2 + 304), v13 + 32, (unsigned __int16 *)(a1 + 800), &v59);
  }
  *(unsigned char *)(a1 + 867) = v14;
  uint64_t v18 = *(void *)(a1 + 32);
  float v19 = *(float *)(v18 + 68) * *(float *)(a1 + 740);
  int v20 = *(_DWORD *)(a1 + 1192);
  int v21 = *(_DWORD *)(a2 + 1616);
  if (*(unsigned char *)(a1 + 1331))
  {
    if (v20 == v21) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  if (v20 != v21)
  {
LABEL_12:
    *(_DWORD *)(a1 + 1192) = v21;
LABEL_13:
    float v22 = *(float *)(v18 + 64);
    *(unsigned char *)(a1 + 1329) = (int)v22;
    if (*(unsigned char *)(a1 + 871)) {
      float v22 = *(float *)(a2 + 476);
    }
    *(float *)(a1 + 1152) = v22;
    *(float *)(a1 + 1172) = v19;
    *(void *)(a1 + 1200) = a1 + 312;
    uint64_t v23 = *(void *)(a1 + 16);
    *(void *)(a1 + 1208) = *(void *)(v23 + 408);
    *(void *)(a1 + 1216) = *(void *)(v23 + 416);
    *(void *)(a1 + 1224) = *(void *)(v23 + 424);
    *(void *)(a1 + 1248) = *(void *)(v23 + 984);
    *(_DWORD *)(a1 + 1256) = *(_DWORD *)(v23 + 1040);
    *(_DWORD *)(a1 + 1188) = *(_DWORD *)(a2 + 176);
    float v24 = *(double *)(v23 + 880);
    *(float32x2_t *)(a1 + 1232) = vcvt_f32_f64(*(float64x2_t *)(v23 + 864));
    *(float *)(a1 + 1240) = v24;
    uint64_t v25 = *(void *)(a1 + 720);
    uint64_t v26 = *(std::__shared_weak_count **)(a1 + 728);
    if (v26)
    {
      atomic_fetch_add_explicit(&v26->__shared_owners_, 1uLL, memory_order_relaxed);
      *(_DWORD *)(a1 + 1340) = *(_DWORD *)(v25 + 468);
      if (!atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
        std::__shared_weak_count::__release_weak(v26);
      }
    }
    else
    {
      *(_DWORD *)(a1 + 1340) = *(_DWORD *)(v25 + 468);
    }
    (*(void (**)(std::mutex **__return_ptr))(**(void **)(a1 + 1264) + 32))(&v59);
    if (!v59 || v60)
    {
      unsigned int v27 = *(double **)(a1 + 16);
      float32x2_t v28 = vcvt_f32_f64(vmulq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a2 + 1400), *(float64x2_t *)(a2 + 1304), v27[120]), *(float64x2_t *)(a2 + 1336), v27[121]), *(float64x2_t *)(a2 + 1368), v27[122]), 1.0/ (*(double *)(a2 + 1424)+ *(double *)(a2 + 1328) * v27[120]+ *(double *)(a2 + 1360) * v27[121]+ *(double *)(a2 + 1392) * v27[122])));
      uint64_t v12 = md::CurvedTextLabelPart::placeGlyphsOnRoadPath(a1, 1, (unsigned __int8 *)(a1 + 1458), a1 + 1152, a2 + 440, a2, v28.f32[0], v28.f32[1]);
      *(unsigned char *)(a1 + 1331) = 0;
      *(unsigned char *)(a1 + 1332) = v12;
      if (v60) {
        std::mutex::unlock(v59);
      }
    }
    else
    {
      *(unsigned char *)(a1 + 1331) = 1;
      if (*(unsigned char *)(a1 + 1332) == 37) {
        uint64_t v12 = 37;
      }
      else {
        uint64_t v12 = 31;
      }
    }
    goto LABEL_26;
  }
  if ((_BYTE)v59) {
    goto LABEL_13;
  }
  LODWORD(v16) = *(_DWORD *)(a1 + 1172);
  if (*(float *)&v16 != v19) {
    goto LABEL_13;
  }
  uint64_t v12 = *(unsigned __int8 *)(a1 + 1332);
LABEL_26:
  if (*(unsigned char *)(a1 + 565))
  {
    uint64_t v29 = *(double **)(a1 + 16);
    double v30 = *(double *)(a2 + 576) - v29[51];
    double v31 = *(double *)(a2 + 584) - v29[52];
    double v32 = *(double *)(a2 + 592) - v29[53];
    double v33 = sqrt(v30 * v30 + v31 * v31 + v32 * v32);
    double v16 = v29[109] * v31 + v29[110] * v32;
    double v15 = (v16 + v29[108] * v30) / v33;
    *(float *)&double v15 = v15;
    LODWORD(v16) = 1.0;
    HIDWORD(v17) = 0;
    *(float *)&double v15 = fmaxf(fminf(*(float *)&v15, 1.0), 0.0);
    *(float *)&double v17 = *(float *)&v15 + *(float *)&v15;
    if (*(float *)&v15 >= 0.5) {
      float v34 = 1.0;
    }
    else {
      float v34 = *(float *)&v15 + *(float *)&v15;
    }
    *(float *)(a1 + 1184) = v34;
  }
  *(_DWORD *)(a1 + 520) = *a4;
  *(_DWORD *)(a1 + 524) = a4[1];
  *(_DWORD *)(a1 + 344) = *a4;
  LODWORD(v15) = a4[1];
  *(_DWORD *)(a1 + 348) = LODWORD(v15);
  md::CollisionObject::setupShapeData(a1 + 312, v15, v16, v17);
  int v35 = *(unsigned __int8 *)(a1 + 565);
  if (*(unsigned char *)(a1 + 565))
  {
    if (*(unsigned char *)(a1 + 1399) == 2)
    {
      double v36 = *(double *)(a2 + 768);
      char v37 = *(double **)(a1 + 16);
      double v38 = v37[51];
      double v39 = v37[52];
      double v40 = v37[53];
      float64x2_t v41 = 0uLL;
      float64x2_t v42 = (float64x2_t)*(unint64_t *)&v36;
      double v43 = 0.0;
      double v44 = 0.0;
      float64x2_t v45 = (float64x2_t)*(unint64_t *)&v36;
    }
    else
    {
      double v46 = *(double **)(a1 + 16);
      double v38 = v46[51];
      double v39 = v46[52];
      double v40 = v46[53];
      double v47 = (*(double *)(a2 + 600) * (v38 - *(double *)(a2 + 576))
           + *(double *)(a2 + 608) * (v39 - *(double *)(a2 + 584))
           + *(double *)(a2 + 616) * (v40 - *(double *)(a2 + 592)))
          * (*(double *)(a2 + 760)
           * *(float *)(*(void *)(a1 + 32) + 68));
      float64x2_t v42 = vmulq_n_f64(*(float64x2_t *)(a2 + 1432), v47);
      double v43 = *(double *)(a2 + 1448) * v47;
      double v44 = *(double *)(a2 + 1456) * v47;
      float64x2_t v45 = vmulq_n_f64(*(float64x2_t *)(a2 + 1464), v47);
      float64x2_t v41 = vmulq_n_f64(*(float64x2_t *)(a2 + 1480), v47);
      double v36 = *(double *)(a2 + 1496) * v47;
    }
    uint64_t v48 = *(void *)(a1 + 840);
    *(float64x2_t *)uint64_t v48 = v42;
    *(double *)(v48 + 16) = v43;
    *(void *)(v48 + 24) = 0;
    *(double *)(v48 + 32) = v44;
    *(float64x2_t *)(v48 + 40) = v45;
    *(void *)(v48 + 56) = 0;
    *(float64x2_t *)(v48 + 64) = v41;
    *(double *)(v48 + 80) = v36;
    *(void *)(v48 + 88) = 0;
    *(double *)(v48 + 96) = v38;
    *(double *)(v48 + 104) = v39;
    *(double *)(v48 + 112) = v40;
    *(void *)(v48 + 120) = 0x3FF0000000000000;
  }
  float v49 = *(float *)(a1 + 792);
  if (vabds_f32(*(float *)(a1 + 1432), v49) >= 0.1)
  {
    float v50 = *(float *)(a1 + 796);
  }
  else
  {
    float v50 = *(float *)(a1 + 796);
    if (vabds_f32(*(float *)(a1 + 1436), v50) < 0.1) {
      return v12;
    }
  }
  *(float *)(a1 + 1432) = v49;
  *(float *)(a1 + 1436) = v50;
  if (v35 && !*(unsigned char *)(*(void *)(a2 + 232) + 17))
  {
    float v53 = *(double **)(a1 + 16);
    float v54 = v53[108];
    float v55 = v53[109];
    float v56 = v53[110];
    float v52 = -(float)(v50 * (float)((float)(v54 * v54) + (float)(v55 * v55)));
    float v57 = v50 * v56;
    float v51 = (float)(v57 * v55) + (float)(v49 * v54);
    float v49 = -(float)((float)(v49 * v55) - (float)(v57 * v54));
  }
  else
  {
    float v51 = -v50;
    float v52 = 0.0;
  }
  *(float *)(a1 + 1440) = v49;
  *(float *)(a1 + 1444) = v51;
  *(float *)(a1 + 1448) = v52;
  return v12;
}

void sub_1A17E46C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, std::mutex *a9, char a10)
{
  if (a10) {
    std::mutex::unlock(a9);
  }
  _Unwind_Resume(exception_object);
}

float md::PhysicalLabelFeature::maxZoomRank(md::PhysicalLabelFeature *this)
{
  float result = *((float *)this + 115);
  if (result == 254.0) {
    return 252.0;
  }
  return result;
}

uint64_t md::UniLineLabelFeature::labelFeatureTrait(md::UniLineLabelFeature *this)
{
  return *((unsigned __int8 *)this + 450);
}

float md::MultipleShieldLabelPart::updateWithStyle(md::MultipleShieldLabelPart *this, md::LabelManager *a2)
{
  unsigned int v4 = (uint64_t *)*((void *)this + 72);
  uint64_t v5 = (uint64_t *)*((void *)this + 73);
  if (v4 == v5)
  {
    uint64_t v8 = (uint64_t *)*((void *)this + 4);
    uint64_t v9 = *v8;
    float v6 = *(float *)(*v8 + 172);
  }
  else
  {
    float v6 = -3.4028e38;
    do
    {
      uint64_t v7 = *v4++;
      (*(void (**)(uint64_t, md::LabelManager *))(*(void *)v7 + 72))(v7, a2);
      float v6 = fmaxf(v6, (*(float (**)(uint64_t))(*(void *)v7 + 240))(v7));
    }
    while (v4 != v5);
    uint64_t v8 = (uint64_t *)*((void *)this + 4);
    uint64_t v9 = *v8;
  }
  *((float *)this + 42) = v6;
  uint64_t v10 = *(void *)(v9 + 264);
  if (!v10)
  {
    uint64_t v11 = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>(v9);
    uint64_t v10 = *v11;
    *(void *)(v9 + 264) = *v11;
    uint64_t v9 = *v8;
  }
  *((float *)this + 162) = *((float *)a2 + 44) * *(float *)(v10 + 36);
  float result = *(float *)(v9 + 172);
  *((float *)this + 42) = result;
  return result;
}

BOOL md::CaptionedIconLabelPart::snapToDefaultPlacement(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5)
{
  if (md::CaptionedIconLabelPart::collideIconPart(a1, *(float **)(a2 + 432), a3, a4)) {
    return 0;
  }
  char v11 = *(unsigned char *)(a1 + 959);
  return md::CaptionedIconLabelPart::tryAlternatePlacements(a1, 0, (const md::LabelLayoutContext *)(v11 == 0), v11, a2, a3, a4, a5);
}

uint64_t md::LabelCollider::collideItems(uint64_t this, md::LabelCollisionItemBase **a2, uint64_t a3)
{
  if (a3)
  {
    int v3 = (void *)this;
    uint64_t v4 = 0;
    long long v108 = (unint64_t *)(this + 112);
    long long v109 = (int *)(this + 96);
    do
    {
      uint64_t v5 = a2[v4];
      uint64_t v6 = (*(uint64_t (**)(md::LabelCollisionItemBase *))(*(void *)v5 + 104))(v5);
      if (v6)
      {
        uint64_t v7 = (float *)v6;
        this = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 120))(v6);
        if (this) {
          goto LABEL_4;
        }
        float v8 = v7[6];
        float v9 = v7[2];
        if (v8 == 1.0)
        {
          float v18 = v7[3];
        }
        else
        {
          float v10 = v7[7];
          float v11 = fabsf(v9 * v8);
          float v12 = fabsf(v10 * v9);
          float v13 = v7[3];
          float v14 = -(float)(v10 * v13);
          float v15 = v13 * v8;
          float v16 = fabsf(v14);
          float v17 = fabsf(v15);
          float v9 = v16 + v11;
          float v18 = v17 + v12;
        }
        float v19 = v7[4];
        float v20 = v7[5];
        float v21 = v19 + v9;
        float v22 = v20 + v18;
        float v24 = *((float *)v3 + 8);
        float v23 = *((float *)v3 + 9);
        float v25 = v19 - (float)(v9 + v23);
        float v26 = *((float *)v3 + 10);
        float v27 = (float)(v20 - (float)(v18 + v26)) * v24;
        float v28 = (float)(v22 - v26) * v24;
        int v29 = (int)(float)(v24 * (float)(v21 - v23));
        int v30 = *((_DWORD *)v3 + 12);
        int v31 = *((_DWORD *)v3 + 11);
        if (v31 - 1 < v29) {
          int v29 = v31 - 1;
        }
        int v32 = (int)(float)(v24 * v25) & ~((int)(float)(v24 * v25) >> 31);
        int v33 = (int)v27 & ~((int)v27 >> 31);
        int v34 = v30 - 1;
        if (v30 - 1 >= (int)v28) {
          int v34 = (int)v28;
        }
        BOOL v35 = v33 <= v34 && v32 <= v29;
        if (v35)
        {
          uint64_t v87 = v3[7] + 24 * (v32 + v33 * v31);
          do
          {
            int v89 = (int)(float)(v24 * v25) & ~((int)(float)(v24 * v25) >> 31);
            uint64_t v90 = (uint64_t *)v87;
            do
            {
              uint64_t v92 = *v90;
              if (*v90)
              {
                uint64_t v93 = 0;
                uint64_t v94 = v90[2];
                while (*(float **)(v94 + 8 * v93) != v7)
                {
                  if (v92 == ++v93) {
                    goto LABEL_79;
                  }
                }
                uint64_t v91 = v92 - 1;
                *(void *)(v94 + 8 * v93) = *(void *)(v94 + 8 * v91);
                *uint64_t v90 = v91;
              }
LABEL_79:
              v90 += 3;
              BOOL v88 = v89++ == v29;
            }
            while (!v88);
            v87 += 24 * v31;
            BOOL v88 = v33++ == v34;
          }
          while (!v88);
        }
      }
      __int16 v112 = 256;
      uint64_t v113 = 0;
      uint64_t v36 = (*(uint64_t (**)(md::LabelCollisionItemBase *))(*(void *)v5 + 88))(v5);
      if (v36)
      {
        uint64_t v37 = v36;
        unsigned __int8 v38 = (*(uint64_t (**)(md::LabelCollisionItemBase *))(*(void *)v5 + 96))(v5);
        if ((*(unsigned int (**)(uint64_t, void))(*(void *)v37 + 24))(v37, v38))
        {
          LOBYTE(v112) = 1;
          this = (*(uint64_t (**)(md::LabelCollisionItemBase *, __int16 *))(*(void *)v5 + 72))(v5, &v112);
          goto LABEL_4;
        }
      }
      char v39 = (*(uint64_t (**)(md::LabelCollisionItemBase *))(*(void *)v5 + 112))(v5);
      uint64_t v40 = (*(uint64_t (**)(md::LabelCollisionItemBase *, void, void *))(*(void *)v5 + 56))(v5, *v3, v3);
      if (v40)
      {
        LODWORD(v41) = 0;
        do
        {
          float64x2_t v42 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v40 + 16))(v40);
          float32x2_t v43 = *v42;
          float32x2_t v44 = v42[1];
          uint64_t v113 = 0;
          int32x2_t v45 = vcgt_f32(v43, v44);
          if (((v45.i32[0] | v45.i32[1]) & 1) != 0
            || *((unsigned char *)v3 + 92)
            && (v43.f32[0] < *((float *)v3 + 3)
             || v44.f32[0] > *((float *)v3 + 5)
             || v43.f32[1] < *((float *)v3 + 4)
             || v44.f32[1] > *((float *)v3 + 6)))
          {
            goto LABEL_65;
          }
          float v46 = *((float *)v3 + 8);
          float32x2_t v47 = vmul_f32(vsub_f32(v44, v43), (float32x2_t)0x3F0000003F000000);
          float32x2_t v48 = vadd_f32(v47, v43);
          float32x2_t v49 = *(float32x2_t *)((char *)v3 + 36);
          int32x2_t v50 = vcvt_s32_f32(vmul_n_f32(vsub_f32(vadd_f32(v48, v47), v49), v46));
          *(int32x2_t *)&long long v51 = vmax_s32(vcvt_s32_f32(vmul_n_f32(vsub_f32(v43, v49), v46)), 0);
          *((int32x2_t *)&v51 + 1) = vmin_s32(vadd_s32(*(int32x2_t *)((char *)v3 + 44), (int32x2_t)-1), v50);
          int32x2_t v52 = vcgt_s32(*(int32x2_t *)&v51, *(int32x2_t *)((char *)&v51 + 8));
          *((_OWORD *)v3 + 6) = v51;
          if (vorr_s8((int8x8_t)v52, (int8x8_t)vdup_lane_s32(v52, 1)).u32[0])
          {
LABEL_65:
            HIBYTE(v112) = 1;
            break;
          }
          float32x2_t v110 = v48;
          float32x2_t v111 = v47;
          md::LabelCollider::getGridItems((uint64_t)v3, v109, v5, v108);
          float v54 = v110.f32[0];
          float v53 = v111.f32[0];
          *(float32x2_t *)&long long v55 = v111;
          *((float32x2_t *)&v55 + 1) = v110;
          long long v114 = v55;
          uint64_t v115 = 1065353216;
          HIBYTE(v112) = 0;
          uint64_t v56 = v3[14];
          if (!v56) {
            goto LABEL_71;
          }
          if (v111.f32[1] <= 0.0 || v111.f32[0] <= 0.0) {
            goto LABEL_71;
          }
          float v58 = (float **)v3[16];
          uint64_t v59 = 8 * v56;
          while (1)
          {
            float v70 = *v58;
            float v71 = (*v58)[2];
            if (v71 > 0.0)
            {
              float v72 = v70[3];
              if (v72 > 0.0)
              {
                float v73 = v54 - v70[4];
                float v74 = v110.f32[1] - v70[5];
                float v75 = fabsf(v73);
                float v76 = fabsf(v74);
                if (*((void *)v70 + 3) == v115)
                {
                  if (v75 > (float)(v71 + v53) || v76 > (float)(v111.f32[1] + v72)) {
                    goto LABEL_56;
                  }
                }
                else
                {
                  float v60 = v70[6];
                  float v61 = v70[7];
                  float v62 = fabsf((float)(v60 * v73) + (float)(v61 * v74));
                  float v63 = fabsf(-(float)((float)(v61 * v73) - (float)(v60 * v74)));
                  float v64 = (float)(fabsf(-(float)(v61 * v53)) + v72) + fabsf(v60 * v111.f32[1]);
                  BOOL v65 = v62 <= (float)((float)(fabsf(v60 * v53) + v71) + fabsf(v61 * v111.f32[1])) && v63 <= v64;
                  float v66 = (float)(fabsf(v60 * v71) + v53) + fabsf(-(float)(v72 * v61));
                  BOOL v67 = v65 && v75 <= v66;
                  float v68 = (float)(fabsf(v61 * v71) + v111.f32[1]) + fabsf(v60 * v72);
                  if (!v67 || v76 > v68) {
                    goto LABEL_56;
                  }
                }
                int v78 = (*(uint64_t (**)(uint64_t, float *))(*(void *)v40 + 24))(v40, *v58);
                float v54 = v110.f32[0];
                float v53 = v111.f32[0];
                if (v78) {
                  break;
                }
              }
            }
LABEL_56:
            ++v58;
            v59 -= 8;
            if (!v59)
            {
              int v79 = HIBYTE(v112);
              goto LABEL_58;
            }
          }
          int v79 = 1;
          HIBYTE(v112) = 1;
          uint64_t v113 = v70;
LABEL_58:
          if (v79) {
            char v80 = v39;
          }
          else {
            char v80 = 1;
          }
          if (v80) {
            goto LABEL_67;
          }
          uint64_t v41 = (v41 + 1);
          uint64_t v40 = (*(uint64_t (**)(md::LabelCollisionItemBase *, uint64_t, __int16 *, void, void *))(*(void *)v5 + 64))(v5, v41, &v112, *v3, v3);
        }
        while (v40);
      }
      int v79 = HIBYTE(v112);
LABEL_67:
      if (v79
        && (*(unsigned int (**)(md::LabelCollisionItemBase *))(*(void *)v5 + 32))(v5)
        && (*(unsigned int (**)(md::LabelCollisionItemBase *))(*(void *)v5 + 40))(v5))
      {
        uint64_t v40 = (*(uint64_t (**)(md::LabelCollisionItemBase *, void, void *))(*(void *)v5 + 56))(v5, *v3, v3);
        HIBYTE(v112) = 0;
        uint64_t v113 = 0;
      }
LABEL_71:
      this = (*(uint64_t (**)(md::LabelCollisionItemBase *, __int16 *))(*(void *)v5 + 72))(v5, &v112);
      if (HIBYTE(v112)) {
        goto LABEL_4;
      }
      *((_DWORD *)v5 + 10) = 0;
      int v81 = *((_DWORD *)v3 + 25);
      int v82 = *((_DWORD *)v3 + 27);
      if (v81 > v82) {
        goto LABEL_74;
      }
      int v83 = *((_DWORD *)v3 + 24);
      int v84 = *((_DWORD *)v3 + 26);
      if (v83 > v84) {
        goto LABEL_74;
      }
      int v95 = *((_DWORD *)v3 + 11);
      uint64_t v96 = v3[7] + 24 * (v83 + v95 * v81);
      do
      {
        if (*v109 > v84) {
          goto LABEL_86;
        }
        int v97 = *v109 - 1;
        uint64_t v98 = (void **)(v96 + 16);
        do
        {
          unint64_t v99 = (unint64_t)*(v98 - 2);
          unint64_t v100 = (unint64_t)*(v98 - 1);
          unint64_t v101 = (2 * v99) | 1;
          if (v99 < v100 || v100 >= v101) {
            goto LABEL_95;
          }
          int v103 = 20;
          if (v101 > 0x14) {
            int v103 = v101;
          }
          unint64_t v104 = (1 << -__clz(v103 - 1));
          __int16 v105 = malloc_type_realloc(*v98, 8 * v104, 0x2004093837F09uLL);
          if (v105)
          {
            *(v98 - 1) = (void *)v104;
            *uint64_t v98 = v105;
            unint64_t v99 = (unint64_t)*(v98 - 2);
LABEL_95:
            *((void *)*v98 + v99) = v5;
            *(v98 - 2) = (void *)(v99 + 1);
          }
          int v84 = *((_DWORD *)v3 + 26);
          ++v97;
          v98 += 3;
        }
        while (v97 < v84);
        int v95 = *((_DWORD *)v3 + 11);
        int v82 = *((_DWORD *)v3 + 27);
LABEL_86:
        v96 += 24 * v95;
        BOOL v35 = v81++ < v82;
      }
      while (v35);
LABEL_74:
      this = (*(uint64_t (**)(uint64_t))(*(void *)v40 + 16))(v40);
      float32x2_t v85 = vmul_f32(vsub_f32(*(float32x2_t *)(this + 8), *(float32x2_t *)this), (float32x2_t)0x3F0000003F000000);
      float32x2_t v86 = vadd_f32(v85, *(float32x2_t *)this);
      *((float32x2_t *)v5 + 1) = v85;
      *((float32x2_t *)v5 + 2) = v86;
      *((void *)v5 + 3) = 1065353216;
LABEL_4:
      ++v4;
    }
    while (v4 != a3);
  }
  return this;
}

uint64_t md::LabelPart::collisionBoundsForStaging(md::LabelPart *this)
{
  return *((void *)this + 3) + 152;
}

uint64_t non-virtual thunk to'md::Label::collisionBounds(md::Label *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 31) + 248))();
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::LabelCollider::getGridItems(gm::Box<int,2> const&,md::LabelCollidableItem const&,md::SimpleBuffer<md::LabelCollidableItem*,20ul> &)::$_0 &,md::LabelCollidableItem**,false>(uint64_t result, unint64_t *a2, uint64_t a3, char a4)
{
  float v9 = (unint64_t *)result;
LABEL_2:
  float v10 = a2 - 1;
  float v11 = v9;
  while (1)
  {
    float v9 = v11;
    uint64_t v12 = (char *)a2 - (char *)v11;
    uint64_t v13 = a2 - v11;
    if (v5 || !v4) {
      break;
    }
    if (v12 <= 191)
    {
      uint64_t v182 = v11 + 1;
      BOOL v184 = v11 == a2 || v182 == a2;
      if (a4)
      {
        if (!v184)
        {
          uint64_t v185 = 8;
          long long v186 = v11;
          do
          {
            unint64_t v189 = *v186;
            unint64_t v188 = v186[1];
            long long v186 = v182;
            unsigned int v190 = *(unsigned __int8 *)(v188 + 52);
            unsigned int v191 = *(unsigned __int8 *)(v189 + 52);
            BOOL v5 = v190 == v191;
            BOOL v192 = v190 < v191;
            if (v5) {
              BOOL v192 = v188 < v189;
            }
            if (v192)
            {
              uint64_t v193 = v185;
              do
              {
                *(unint64_t *)((char *)v11 + v193) = v189;
                uint64_t v194 = v193 - 8;
                if (v193 == 8)
                {
                  double v187 = v11;
                  goto LABEL_200;
                }
                unint64_t v189 = *(unint64_t *)((char *)v11 + v193 - 16);
                unsigned int v195 = *(unsigned __int8 *)(v189 + 52);
                BOOL v196 = v188 < v189;
                BOOL v5 = v190 == v195;
                BOOL v197 = v190 < v195;
                if (!v5) {
                  BOOL v196 = v197;
                }
                uint64_t v193 = v194;
              }
              while (v196);
              double v187 = (unint64_t *)((char *)v11 + v194);
LABEL_200:
              *double v187 = v188;
            }
            uint64_t v182 = v186 + 1;
            v185 += 8;
          }
          while (v186 + 1 != a2);
        }
      }
      else if (!v184)
      {
        do
        {
          unint64_t v253 = *v9;
          unint64_t v252 = v9[1];
          float v9 = v182;
          unsigned int v254 = *(unsigned __int8 *)(v252 + 52);
          unsigned int v255 = *(unsigned __int8 *)(v253 + 52);
          BOOL v5 = v254 == v255;
          BOOL v256 = v254 < v255;
          if (v5) {
            BOOL v256 = v252 < v253;
          }
          if (v256)
          {
            uint64_t v257 = v9;
            do
            {
              *uint64_t v257 = v253;
              unint64_t v253 = *(v257 - 2);
              unsigned int v258 = *(unsigned __int8 *)(v253 + 52);
              BOOL v5 = v254 == v258;
              BOOL v259 = v254 < v258;
              if (v5) {
                BOOL v259 = v252 < v253;
              }
              --v257;
            }
            while (v259);
            *uint64_t v257 = v252;
          }
          uint64_t v182 = v9 + 1;
        }
        while (v9 + 1 != a2);
      }
      return result;
    }
    if (!a3)
    {
      if (v11 != a2)
      {
        int64_t v198 = (unint64_t)(v13 - 2) >> 1;
        int64_t v199 = v198;
        do
        {
          if (v198 >= v199)
          {
            uint64_t v201 = (2 * v199) | 1;
            uint64_t v202 = &v11[v201];
            unint64_t v203 = *v202;
            if (2 * v199 + 2 < v13)
            {
              unint64_t v204 = v202[1];
              unsigned int v205 = *(unsigned __int8 *)(v203 + 52);
              unsigned int v206 = *(unsigned __int8 *)(v204 + 52);
              BOOL v5 = v205 == v206;
              BOOL v207 = v205 < v206;
              if (v5) {
                BOOL v207 = v203 < v204;
              }
              if (v207)
              {
                unint64_t v203 = v202[1];
                ++v202;
                uint64_t v201 = 2 * v199 + 2;
              }
            }
            float64x2_t v208 = &v11[v199];
            unint64_t v209 = *v208;
            unsigned int v210 = *(unsigned __int8 *)(v203 + 52);
            unsigned int v211 = *(unsigned __int8 *)(*v208 + 52);
            float result = v203 < *v208;
            BOOL v5 = v210 == v211;
            BOOL v212 = v210 < v211;
            if (v5) {
              BOOL v212 = v203 < *v208;
            }
            if (!v212)
            {
              do
              {
                double v216 = v202;
                *float64x2_t v208 = v203;
                if (v198 < v201) {
                  break;
                }
                float result = (2 * v201) | 1;
                uint64_t v202 = &v11[result];
                uint64_t v217 = 2 * v201 + 2;
                unint64_t v203 = *v202;
                if (v217 < v13)
                {
                  unint64_t v218 = v202[1];
                  unsigned int v219 = *(unsigned __int8 *)(v203 + 52);
                  unsigned int v220 = *(unsigned __int8 *)(v218 + 52);
                  BOOL v5 = v219 == v220;
                  BOOL v221 = v219 < v220;
                  if (v5) {
                    BOOL v221 = v203 < v218;
                  }
                  if (v221)
                  {
                    unint64_t v203 = v202[1];
                    ++v202;
                    float result = v217;
                  }
                }
                unsigned int v213 = *(unsigned __int8 *)(v203 + 52);
                BOOL v5 = v213 == v211;
                BOOL v214 = v213 < v211;
                int v215 = v5 ? v203 < v209 : v214;
                float64x2_t v208 = v216;
                uint64_t v201 = result;
              }
              while (v215 != 1);
              *double v216 = v209;
            }
          }
          BOOL v200 = v199-- <= 0;
        }
        while (!v200);
        uint64_t v222 = (unint64_t)v12 >> 3;
        do
        {
          uint64_t v223 = 0;
          unint64_t v224 = *v11;
          uint64_t v225 = v11;
          do
          {
            uint64_t v226 = &v225[v223];
            unint64_t v229 = v226[1];
            uint64_t v227 = v226 + 1;
            unint64_t v228 = v229;
            uint64_t v230 = (2 * v223) | 1;
            uint64_t v231 = 2 * v223 + 2;
            if (v231 < v222)
            {
              unint64_t v232 = v227[1];
              unsigned int v233 = *(unsigned __int8 *)(v228 + 52);
              unsigned int v234 = *(unsigned __int8 *)(v232 + 52);
              BOOL v5 = v233 == v234;
              LODWORD(result) = v233 < v234;
              float result = v5 ? v228 < v232 : result;
              if (result)
              {
                unint64_t v228 = v227[1];
                ++v227;
                uint64_t v230 = v231;
              }
            }
            *uint64_t v225 = v228;
            uint64_t v225 = v227;
            uint64_t v223 = v230;
          }
          while (v230 <= (uint64_t)((unint64_t)(v222 - 2) >> 1));
          if (v227 == --a2)
          {
            unint64_t *v227 = v224;
          }
          else
          {
            unint64_t *v227 = *a2;
            *a2 = v224;
            uint64_t v235 = (char *)v227 - (char *)v11 + 8;
            if (v235 >= 9)
            {
              unint64_t v236 = (((unint64_t)v235 >> 3) - 2) >> 1;
              unint64_t v237 = &v11[v236];
              unint64_t v238 = *v237;
              unint64_t v239 = *v227;
              unsigned int v240 = *(unsigned __int8 *)(*v237 + 52);
              unsigned int v241 = *(unsigned __int8 *)(*v227 + 52);
              BOOL v5 = v240 == v241;
              BOOL v242 = v240 < v241;
              if (v5) {
                BOOL v242 = *v237 < *v227;
              }
              if (v242)
              {
                do
                {
                  unint64_t v243 = v237;
                  unint64_t *v227 = v238;
                  if (!v236) {
                    break;
                  }
                  unint64_t v236 = (v236 - 1) >> 1;
                  unint64_t v237 = &v11[v236];
                  unint64_t v238 = *v237;
                  unsigned int v244 = *(unsigned __int8 *)(*v237 + 52);
                  BOOL v5 = v244 == v241;
                  BOOL v245 = v244 < v241;
                  BOOL v246 = v5 ? *v237 < v239 : v245;
                  uint64_t v227 = v243;
                }
                while (v246);
                *unint64_t v243 = v239;
              }
            }
          }
          BOOL v200 = v222-- <= 2;
        }
        while (!v200);
      }
      return result;
    }
    unint64_t v14 = (unint64_t)v13 >> 1;
    float v15 = &v11[(unint64_t)v13 >> 1];
    unint64_t v16 = *v10;
    unsigned int v17 = *(unsigned __int8 *)(*v10 + 52);
    if ((unint64_t)v12 >= 0x401)
    {
      unint64_t v18 = *v15;
      unint64_t v19 = *v11;
      unsigned int v20 = *(unsigned __int8 *)(*v15 + 52);
      unsigned int v21 = *(unsigned __int8 *)(*v11 + 52);
      BOOL v22 = *v15 < *v11;
      if (v20 != v21) {
        BOOL v22 = v20 < v21;
      }
      BOOL v5 = v17 == v20;
      BOOL v23 = v17 < v20;
      if (v5) {
        BOOL v23 = v16 < v18;
      }
      if (v22)
      {
        if (v23)
        {
          *float v11 = v16;
          goto LABEL_36;
        }
        *float v11 = v18;
        unint64_t *v15 = v19;
        unsigned int v38 = *(unsigned __int8 *)(*v10 + 52);
        BOOL v5 = v38 == v21;
        BOOL v39 = v38 < v21;
        if (v5) {
          BOOL v39 = *v10 < v19;
        }
        if (v39)
        {
          unint64_t *v15 = *v10;
LABEL_36:
          *float v10 = v19;
        }
      }
      else if (v23)
      {
        unint64_t *v15 = v16;
        *float v10 = v18;
        unint64_t v30 = *v11;
        unsigned int v31 = *(unsigned __int8 *)(*v15 + 52);
        unsigned int v32 = *(unsigned __int8 *)(*v11 + 52);
        BOOL v5 = v31 == v32;
        BOOL v33 = v31 < v32;
        if (v5) {
          BOOL v33 = *v15 < *v11;
        }
        if (v33)
        {
          *float v11 = *v15;
          unint64_t *v15 = v30;
        }
      }
      uint64_t v40 = &v11[v14];
      unint64_t v43 = *(v40 - 1);
      uint64_t v41 = v40 - 1;
      unint64_t v42 = v43;
      unint64_t v44 = v11[1];
      unsigned int v45 = *(unsigned __int8 *)(v43 + 52);
      unsigned int v46 = *(unsigned __int8 *)(v44 + 52);
      BOOL v47 = v43 < v44;
      BOOL v48 = v45 < v46;
      if (v45 == v46) {
        BOOL v48 = v47;
      }
      unint64_t v49 = *(a2 - 2);
      unsigned int v50 = *(unsigned __int8 *)(v49 + 52);
      BOOL v5 = v50 == v45;
      BOOL v51 = v50 < v45;
      if (v5) {
        BOOL v51 = v49 < v42;
      }
      if (v48)
      {
        if (v51)
        {
          v11[1] = v49;
          goto LABEL_58;
        }
        v11[1] = v42;
        unint64_t *v41 = v44;
        unint64_t v58 = *(a2 - 2);
        unsigned int v59 = *(unsigned __int8 *)(v58 + 52);
        BOOL v5 = v59 == v46;
        BOOL v60 = v59 < v46;
        if (v5) {
          BOOL v60 = v58 < v44;
        }
        if (v60)
        {
          unint64_t *v41 = v58;
LABEL_58:
          *(a2 - 2) = v44;
        }
      }
      else if (v51)
      {
        unint64_t *v41 = v49;
        *(a2 - 2) = v42;
        unint64_t v52 = v11[1];
        unsigned int v53 = *(unsigned __int8 *)(*v41 + 52);
        unsigned int v54 = *(unsigned __int8 *)(v52 + 52);
        BOOL v5 = v53 == v54;
        BOOL v55 = v53 < v54;
        if (v5) {
          BOOL v55 = *v41 < v52;
        }
        if (v55)
        {
          v11[1] = *v41;
          unint64_t *v41 = v52;
        }
      }
      float v61 = &v11[v14];
      unint64_t v64 = v61[1];
      float v62 = v61 + 1;
      unint64_t v63 = v64;
      unint64_t v65 = v11[2];
      unsigned int v66 = *(unsigned __int8 *)(v64 + 52);
      unsigned int v67 = *(unsigned __int8 *)(v65 + 52);
      BOOL v68 = v64 < v65;
      BOOL v69 = v66 < v67;
      if (v66 == v67) {
        BOOL v69 = v68;
      }
      unint64_t v70 = *(a2 - 3);
      unsigned int v71 = *(unsigned __int8 *)(v70 + 52);
      BOOL v5 = v71 == v66;
      BOOL v72 = v71 < v66;
      if (v5) {
        BOOL v72 = v70 < v63;
      }
      if (v69)
      {
        if (v72)
        {
          v11[2] = v70;
          goto LABEL_75;
        }
        v11[2] = v63;
        *float v62 = v65;
        unint64_t v77 = *(a2 - 3);
        unsigned int v78 = *(unsigned __int8 *)(v77 + 52);
        BOOL v5 = v78 == v67;
        BOOL v79 = v78 < v67;
        if (v5) {
          BOOL v79 = v77 < v65;
        }
        if (v79)
        {
          *float v62 = v77;
LABEL_75:
          *(a2 - 3) = v65;
        }
      }
      else if (v72)
      {
        *float v62 = v70;
        *(a2 - 3) = v63;
        unint64_t v73 = v11[2];
        unsigned int v74 = *(unsigned __int8 *)(*v62 + 52);
        unsigned int v75 = *(unsigned __int8 *)(v73 + 52);
        BOOL v5 = v74 == v75;
        BOOL v76 = v74 < v75;
        if (v5) {
          BOOL v76 = *v62 < v73;
        }
        if (v76)
        {
          v11[2] = *v62;
          *float v62 = v73;
        }
      }
      unint64_t v80 = *v15;
      unint64_t v81 = *v41;
      unsigned int v82 = *(unsigned __int8 *)(*v15 + 52);
      unsigned int v83 = *(unsigned __int8 *)(*v41 + 52);
      if (v82 == v83) {
        BOOL v84 = *v15 < *v41;
      }
      else {
        BOOL v84 = v82 < v83;
      }
      unint64_t v85 = *v62;
      unsigned int v86 = *(unsigned __int8 *)(*v62 + 52);
      float result = *v62 < v80;
      BOOL v5 = v86 == v82;
      BOOL v87 = v86 < v82;
      if (v5) {
        BOOL v87 = *v62 < v80;
      }
      if (v84)
      {
        if (!v87)
        {
          unint64_t *v41 = v80;
          unint64_t *v15 = v81;
          BOOL v88 = v86 == v83 ? v85 < v81 : v86 < v83;
          uint64_t v41 = v15;
          unint64_t v80 = v85;
          if (!v88)
          {
            unint64_t v80 = v81;
LABEL_94:
            unint64_t v90 = *v11;
            *float v11 = v80;
            unint64_t *v15 = v90;
            goto LABEL_95;
          }
        }
      }
      else
      {
        if (!v87) {
          goto LABEL_94;
        }
        unint64_t *v15 = v85;
        *float v62 = v80;
        if (v86 == v83) {
          BOOL v89 = v85 < v81;
        }
        else {
          BOOL v89 = v86 < v83;
        }
        float v62 = v15;
        unint64_t v80 = v81;
        if (!v89)
        {
          unint64_t v80 = v85;
          goto LABEL_94;
        }
      }
      unint64_t *v41 = v85;
      *float v62 = v81;
      goto LABEL_94;
    }
    unint64_t v24 = *v11;
    unint64_t v25 = *v15;
    unsigned int v26 = *(unsigned __int8 *)(*v11 + 52);
    unsigned int v27 = *(unsigned __int8 *)(*v15 + 52);
    BOOL v28 = *v11 < *v15;
    if (v26 != v27) {
      BOOL v28 = v26 < v27;
    }
    BOOL v5 = v17 == v26;
    BOOL v29 = v17 < v26;
    if (v5) {
      BOOL v29 = v16 < v24;
    }
    if (v28)
    {
      if (v29)
      {
        unint64_t *v15 = v16;
LABEL_53:
        *float v10 = v25;
        goto LABEL_95;
      }
      unint64_t *v15 = v24;
      *float v11 = v25;
      unsigned int v56 = *(unsigned __int8 *)(*v10 + 52);
      BOOL v5 = v56 == v27;
      BOOL v57 = v56 < v27;
      if (v5) {
        BOOL v57 = *v10 < v25;
      }
      if (v57)
      {
        *float v11 = *v10;
        goto LABEL_53;
      }
    }
    else if (v29)
    {
      *float v11 = v16;
      *float v10 = v24;
      unint64_t v34 = *v15;
      unsigned int v35 = *(unsigned __int8 *)(*v11 + 52);
      unsigned int v36 = *(unsigned __int8 *)(*v15 + 52);
      BOOL v5 = v35 == v36;
      BOOL v37 = v35 < v36;
      if (v5) {
        BOOL v37 = *v11 < *v15;
      }
      if (v37)
      {
        unint64_t *v15 = *v11;
        *float v11 = v34;
      }
    }
LABEL_95:
    --a3;
    unint64_t v91 = *v11;
    if (a4)
    {
      unsigned int v92 = *(unsigned __int8 *)(v91 + 52);
      goto LABEL_100;
    }
    unint64_t v93 = *(v11 - 1);
    unsigned int v94 = *(unsigned __int8 *)(v93 + 52);
    unsigned int v92 = *(unsigned __int8 *)(v91 + 52);
    BOOL v95 = v93 < v91;
    BOOL v5 = v94 == v92;
    BOOL v96 = v94 < v92;
    if (!v5) {
      BOOL v95 = v96;
    }
    if (v95)
    {
LABEL_100:
      int v97 = v11;
      do
      {
        uint64_t v98 = v97;
        unint64_t v100 = v97[1];
        ++v97;
        unint64_t v99 = v100;
        unsigned int v101 = *(unsigned __int8 *)(v100 + 52);
        BOOL v102 = v100 < v91;
        BOOL v5 = v101 == v92;
        BOOL v103 = v101 < v92;
        if (v5) {
          BOOL v103 = v102;
        }
      }
      while (v103);
      unint64_t v104 = a2;
      if (v98 == v11)
      {
        unint64_t v104 = a2;
        do
        {
          if (v97 >= v104) {
            break;
          }
          unint64_t v109 = *--v104;
          unsigned int v110 = *(unsigned __int8 *)(v109 + 52);
          BOOL v111 = v109 < v91;
          BOOL v5 = v110 == v92;
          BOOL v112 = v110 < v92;
          if (!v5) {
            BOOL v111 = v112;
          }
        }
        while (!v111);
      }
      else
      {
        do
        {
          unint64_t v105 = *--v104;
          unsigned int v106 = *(unsigned __int8 *)(v105 + 52);
          BOOL v107 = v105 < v91;
          BOOL v5 = v106 == v92;
          BOOL v108 = v106 < v92;
          if (!v5) {
            BOOL v107 = v108;
          }
        }
        while (!v107);
      }
      if (v97 < v104)
      {
        unint64_t v113 = *v104;
        long long v114 = v97;
        uint64_t v115 = v104;
        do
        {
          *long long v114 = v113;
          unint64_t *v115 = v99;
          do
          {
            uint64_t v98 = v114;
            unint64_t v116 = v114[1];
            ++v114;
            unint64_t v99 = v116;
            unsigned int v117 = *(unsigned __int8 *)(v116 + 52);
            BOOL v118 = v116 < v91;
            BOOL v5 = v117 == v92;
            BOOL v119 = v117 < v92;
            if (v5) {
              BOOL v119 = v118;
            }
          }
          while (v119);
          do
          {
            unint64_t v120 = *--v115;
            unint64_t v113 = v120;
            unsigned int v121 = *(unsigned __int8 *)(v120 + 52);
            BOOL v122 = v120 < v91;
            BOOL v5 = v121 == v92;
            BOOL v123 = v121 < v92;
            if (v5) {
              BOOL v123 = v122;
            }
          }
          while (!v123);
        }
        while (v114 < v115);
      }
      if (v98 != v11) {
        *float v11 = *v98;
      }
      *uint64_t v98 = v91;
      if (v97 < v104) {
        goto LABEL_129;
      }
      BOOL v124 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::getGridItems(gm::Box<int,2> const&,md::LabelCollidableItem const&,md::SimpleBuffer<md::LabelCollidableItem*,20ul> &)::$_0 &,md::LabelCollidableItem**>(v11, v98);
      float v11 = v98 + 1;
      float result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::getGridItems(gm::Box<int,2> const&,md::LabelCollidableItem const&,md::SimpleBuffer<md::LabelCollidableItem*,20ul> &)::$_0 &,md::LabelCollidableItem**>(v98 + 1, a2);
      if (result)
      {
        a2 = v98;
        if (v124) {
          return result;
        }
        goto LABEL_2;
      }
      if (!v124)
      {
LABEL_129:
        float result = std::__introsort<std::_ClassicAlgPolicy,md::LabelCollider::getGridItems(gm::Box<int,2> const&,md::LabelCollidableItem const&,md::SimpleBuffer<md::LabelCollidableItem*,20ul> &)::$_0 &,md::LabelCollidableItem**,false>(v9, v98, a3, a4 & 1);
        a4 = 0;
        float v11 = v98 + 1;
      }
    }
    else
    {
      unsigned int v125 = *(unsigned __int8 *)(*v10 + 52);
      BOOL v126 = v91 < *v10;
      BOOL v5 = v92 == v125;
      BOOL v127 = v92 < v125;
      if (!v5) {
        BOOL v126 = v127;
      }
      if (v126)
      {
        do
        {
          unint64_t v128 = v11[1];
          ++v11;
          unsigned int v129 = *(unsigned __int8 *)(v128 + 52);
          BOOL v130 = v91 < v128;
          BOOL v5 = v92 == v129;
          BOOL v131 = v92 < v129;
          if (!v5) {
            BOOL v130 = v131;
          }
        }
        while (!v130);
      }
      else
      {
        unsigned int v132 = v11 + 1;
        do
        {
          float v11 = v132;
          if (v132 >= a2) {
            break;
          }
          ++v132;
          unsigned int v133 = *(unsigned __int8 *)(*v11 + 52);
          BOOL v134 = v91 < *v11;
          BOOL v5 = v92 == v133;
          BOOL v135 = v92 < v133;
          if (!v5) {
            BOOL v134 = v135;
          }
        }
        while (!v134);
      }
      uint64_t v136 = a2;
      if (v11 < a2)
      {
        uint64_t v136 = a2;
        do
        {
          unint64_t v137 = *--v136;
          unsigned int v138 = *(unsigned __int8 *)(v137 + 52);
          BOOL v139 = v91 < v137;
          BOOL v5 = v92 == v138;
          BOOL v140 = v92 < v138;
          if (!v5) {
            BOOL v139 = v140;
          }
        }
        while (v139);
      }
      if (v11 < v136)
      {
        unint64_t v141 = *v11;
        unint64_t v142 = *v136;
        do
        {
          *float v11 = v142;
          *uint64_t v136 = v141;
          do
          {
            unint64_t v143 = v11[1];
            ++v11;
            unint64_t v141 = v143;
            unsigned int v144 = *(unsigned __int8 *)(v143 + 52);
            BOOL v145 = v91 < v143;
            BOOL v5 = v92 == v144;
            BOOL v146 = v92 < v144;
            if (v5) {
              BOOL v146 = v145;
            }
          }
          while (!v146);
          do
          {
            unint64_t v147 = *--v136;
            unint64_t v142 = v147;
            unsigned int v148 = *(unsigned __int8 *)(v147 + 52);
            BOOL v149 = v91 < v147;
            BOOL v5 = v92 == v148;
            BOOL v150 = v92 < v148;
            if (v5) {
              BOOL v150 = v149;
            }
          }
          while (v150);
        }
        while (v11 < v136);
      }
      float v151 = v11 - 1;
      BOOL v4 = v11 - 1 >= v9;
      BOOL v5 = v11 - 1 == v9;
      if (v11 - 1 != v9) {
        *float v9 = *v151;
      }
      a4 = 0;
      *float v151 = v91;
    }
  }
  switch(v13)
  {
    case 0:
    case 1:
      return result;
    case 2:
      unint64_t v152 = *v11;
      unsigned int v153 = *(unsigned __int8 *)(*v10 + 52);
      unsigned int v154 = *(unsigned __int8 *)(*v11 + 52);
      BOOL v5 = v153 == v154;
      BOOL v155 = v153 < v154;
      if (v5) {
        BOOL v155 = *v10 < *v11;
      }
      if (v155)
      {
        *float v11 = *v10;
        *float v10 = v152;
      }
      return result;
    case 3:
      unint64_t v156 = *v11;
      unint64_t v157 = v11[1];
      unsigned int v158 = *(unsigned __int8 *)(v157 + 52);
      unsigned int v159 = *(unsigned __int8 *)(*v11 + 52);
      BOOL v160 = v158 < v159;
      if (v158 == v159) {
        BOOL v160 = v157 < *v11;
      }
      unint64_t v161 = *v10;
      unsigned int v162 = *(unsigned __int8 *)(*v10 + 52);
      BOOL v5 = v162 == v158;
      BOOL v163 = v162 < v158;
      if (v5) {
        BOOL v163 = *v10 < v157;
      }
      if (v160)
      {
        if (v163)
        {
          *float v11 = v161;
        }
        else
        {
          *float v11 = v157;
          v11[1] = v156;
          unsigned int v260 = *(unsigned __int8 *)(*v10 + 52);
          BOOL v5 = v260 == v159;
          BOOL v261 = v260 < v159;
          if (v5) {
            BOOL v261 = *v10 < v156;
          }
          if (!v261) {
            return result;
          }
          v11[1] = *v10;
        }
        *float v10 = v156;
        return result;
      }
      if (v163)
      {
        v11[1] = v161;
        *float v10 = v157;
        unint64_t v248 = *v11;
        unint64_t v247 = v11[1];
        unsigned int v249 = *(unsigned __int8 *)(v247 + 52);
        unsigned int v250 = *(unsigned __int8 *)(*v11 + 52);
        BOOL v5 = v249 == v250;
        BOOL v251 = v249 < v250;
        if (v5) {
          BOOL v251 = v247 < *v11;
        }
        if (v251)
        {
          *float v11 = v247;
          v11[1] = v248;
        }
      }
      break;
    case 4:
      return (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::getGridItems(gm::Box<int,2> const&,md::LabelCollidableItem const&,md::SimpleBuffer<md::LabelCollidableItem*,20ul> &)::$_0 &,md::LabelCollidableItem**>(v11, v11 + 1, v11 + 2, a2 - 1);
    case 5:
      int v164 = v11 + 1;
      uint64_t v165 = v11 + 2;
      int v166 = v11 + 3;
      float result = (uint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::getGridItems(gm::Box<int,2> const&,md::LabelCollidableItem const&,md::SimpleBuffer<md::LabelCollidableItem*,20ul> &)::$_0 &,md::LabelCollidableItem**>(v11, v11 + 1, v11 + 2, v11 + 3);
      unint64_t v167 = v11[3];
      unsigned int v168 = *(unsigned __int8 *)(*v10 + 52);
      unsigned int v169 = *(unsigned __int8 *)(v167 + 52);
      BOOL v5 = v168 == v169;
      BOOL v170 = v168 < v169;
      if (v5) {
        BOOL v170 = *v10 < v167;
      }
      if (v170)
      {
        unint64_t *v166 = *v10;
        *float v10 = v167;
        unint64_t v171 = *v166;
        unint64_t v172 = *v165;
        unsigned int v173 = *(unsigned __int8 *)(*v166 + 52);
        unsigned int v174 = *(unsigned __int8 *)(*v165 + 52);
        BOOL v5 = v173 == v174;
        BOOL v175 = v173 < v174;
        if (v5) {
          BOOL v175 = *v166 < *v165;
        }
        if (v175)
        {
          unint64_t *v165 = v171;
          unint64_t *v166 = v172;
          unint64_t v176 = *v164;
          unsigned int v177 = *(unsigned __int8 *)(*v164 + 52);
          BOOL v5 = v173 == v177;
          BOOL v178 = v173 < v177;
          if (v5) {
            BOOL v178 = v171 < *v164;
          }
          if (v178)
          {
            v11[1] = v171;
            v11[2] = v176;
            unint64_t v179 = *v11;
            unsigned int v180 = *(unsigned __int8 *)(*v11 + 52);
            BOOL v5 = v173 == v180;
            BOOL v181 = v173 < v180;
            if (v5) {
              BOOL v181 = v171 < *v11;
            }
            if (v181)
            {
              *float v11 = v171;
              v11[1] = v179;
            }
          }
        }
      }
      return result;
    default:
      JUMPOUT(0);
  }
  return result;
}

uint64_t md::LabelCollider::getGridItems(uint64_t a1, int *a2, _DWORD *a3, unint64_t *a4)
{
  *a4 = 0;
  ++*(_DWORD *)(a1 + 88);
  int v5 = a2[1];
  int v6 = a2[3];
  if (v5 > v6 || (int v8 = a2[2], *a2 > v8))
  {
    float v9 = (unint64_t *)a4[2];
    uint64_t v10 = (uint64_t)v9;
LABEL_4:
    uint64_t v11 = 0;
    goto LABEL_5;
  }
  int v15 = *(_DWORD *)(a1 + 44);
  unint64_t v16 = (void *)(*(void *)(a1 + 56) + 24 * (*a2 + v15 * v5));
  do
  {
    int v30 = v5;
    int v17 = *a2;
    BOOL v29 = v16;
    if (*a2 <= v8)
    {
      while (!*v16)
      {
LABEL_13:
        v16 += 3;
        if (v17++ >= v8)
        {
          int v15 = *(_DWORD *)(a1 + 44);
          int v6 = a2[3];
          goto LABEL_9;
        }
      }
      uint64_t v19 = v16[2];
      uint64_t v20 = 8 * *v16;
      while (1)
      {
        BOOL v22 = *(_DWORD **)v19;
        int v23 = *(_DWORD *)(a1 + 88);
        if (*(_DWORD *)(*(void *)v19 + 40) != v23
          && (a3[9] & v22[8]) != 0
          && (a3[12] & v22[11]) == 0
          && (a3[11] & v22[12]) == 0)
        {
          v22[10] = v23;
          unint64_t v24 = *a4;
          unint64_t v25 = a4[1];
          if (*a4 < v25)
          {
            unsigned int v21 = (void *)a4[2];
          }
          else
          {
            unint64_t v26 = (2 * v24) | 1;
            unsigned int v21 = (void *)a4[2];
            if (v25 < v26)
            {
              int v27 = 20;
              if (v26 > 0x14) {
                int v27 = v26;
              }
              unint64_t v28 = (1 << -__clz(v27 - 1));
              unsigned int v21 = malloc_type_realloc(v21, 8 * v28, 0x2004093837F09uLL);
              if (!v21) {
                goto LABEL_19;
              }
              a4[1] = v28;
              a4[2] = (unint64_t)v21;
              unint64_t v24 = *a4;
            }
          }
          *((void *)v21 + v24) = v22;
          *a4 = v24 + 1;
        }
LABEL_19:
        v19 += 8;
        v20 -= 8;
        if (!v20)
        {
          int v8 = a2[2];
          goto LABEL_13;
        }
      }
    }
LABEL_9:
    unint64_t v16 = &v29[3 * v15];
    int v5 = v30 + 1;
  }
  while (v30 < v6);
  uint64_t v10 = a4[2];
  float v9 = (unint64_t *)(v10 + 8 * *a4);
  if (!*a4) {
    goto LABEL_4;
  }
  uint64_t v11 = 126 - 2 * __clz(*a4);
LABEL_5:
  return std::__introsort<std::_ClassicAlgPolicy,md::LabelCollider::getGridItems(gm::Box<int,2> const&,md::LabelCollidableItem const&,md::SimpleBuffer<md::LabelCollidableItem*,20ul> &)::$_0 &,md::LabelCollidableItem**,false>(v10, v9, v11, 1);
}

uint64_t md::Label::updateStateMachineForStaging(uint64_t result, int a2, char a3)
{
  uint64_t v3 = result;
  char v4 = byte_1A29C6350[3 * a2 + *(char *)(result + 820)];
  if (v4 == -1)
  {
    char v4 = *(unsigned char *)(result + 820);
  }
  else
  {
    if ((*(unsigned char *)(result + 820) != 0) == (byte_1A29C6350[3 * a2 + *(char *)(result + 820)] == 0))
    {
      float result = *(void *)(result + 264);
      uint64_t v6 = *(void *)(v3 + 272);
      if (v4)
      {
        if (result) {
          float result = (*(uint64_t (**)(uint64_t))(*(void *)result + 152))(result);
        }
        if (v6) {
          float result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 152))(v6);
        }
      }
      else
      {
        if (result) {
          float result = (*(uint64_t (**)(uint64_t))(*(void *)result + 160))(result);
        }
        if (v6) {
          float result = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 160))(v6);
        }
      }
    }
    *(unsigned char *)(v3 + 820) = v4;
    *(unsigned char *)(v3 + 821) = a3;
  }
  if (v4 != 2)
  {
    if (!v4)
    {
      *(unsigned char *)(v3 + 1283) = 0;
      *(unsigned char *)(v3 + 1285) = 0;
      float result = *(void *)(v3 + 264);
      *(void *)(v3 + 264) = 0;
      if (result) {
        float result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
      if (*(void *)(v3 + 288))
      {
        *(void *)(v3 + 288) = 0;
        *(unsigned char *)(v3 + 1247) = 1;
      }
    }
    *(unsigned char *)(v3 + 1290) = 0;
    *(unsigned char *)(v3 + 832) = *(unsigned char *)(v3 + 831);
    if (*(unsigned char *)(v3 + 1250))
    {
      *(unsigned char *)(v3 + 1250) = 0;
      unsigned __int8 v7 = atomic_load((unsigned __int8 *)(v3 + 1240));
      if ((v7 & 1) == 0) {
        *(unsigned char *)(v3 + 834) = 1;
      }
    }
  }
  unsigned __int8 v8 = atomic_load((unsigned __int8 *)(v3 + 481));
  if ((v8 & 1) == 0) {
    *(unsigned char *)(v3 + 485) = 2 * (*(unsigned char *)(v3 + 820) == 2);
  }
  return result;
}

uint64_t md::LabelCollisionItem::placementCandidate(md::LabelCollisionItem *this, md::LabelManager *a2, md::LabelCollider *a3)
{
  uint64_t v3 = *((void *)this + 7);
  if (*((unsigned char *)this + 64) == 1) {
    return *(void *)(v3 + 344);
  }
  uint64_t v7 = *(void *)(v3 + 288);
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 440))(v7);
  }
  if (!*((unsigned char *)a2 + 3624)
    || (*(unsigned int (**)(void))(**(void **)(*((void *)a2 + 21) + 32) + 8))(*(void *)(*((void *)a2 + 21) + 32)))
  {
    return v3 + 40;
  }
  uint64_t v8 = *(void *)(v3 + 264);
  uint64_t v9 = *(void *)(v3 + 288);
  BOOL v10 = !v8 || v9 == v8;
  if (!v10
    || ((*(uint64_t (**)(uint64_t))(*(void *)v9 + 544))(v9) & 1) == 0
    && ((*(uint64_t (**)(void))(**(void **)(v3 + 288) + 560))(*(void *)(v3 + 288)) & 1) == 0)
  {
    return v3 + 40;
  }
  int v23 = 150994944;
  char v24 = 0;
  if (!(*(unsigned int (**)(void, md::LabelManager *, md::LabelCollider *, void, int *))(**(void **)(v3 + 288) + 568))(*(void *)(v3 + 288), a2, a3, *(void *)(v3 + 328), &v23))return v3 + 40; {
  char v11 = *(unsigned char *)(v3 + 312);
  }
  char v12 = *(unsigned char *)(v3 + 313);
  __int16 v13 = *(_WORD *)(v3 + 315);
  *(unsigned char *)(v3 + 321) = v24;
  *(_DWORD *)(v3 + 317) = v23;
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(v3 + 288) + 600))(&v22);
  uint64_t v14 = v22;
  uint64_t v22 = 0;
  uint64_t v15 = *(void *)(v3 + 1232);
  *(void *)(v3 + 1232) = v14;
  if (v15)
  {
    unint64_t v16 = *(std::__shared_weak_count **)(v15 + 8);
    if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
    MEMORY[0x1A6239270](v15, 0x20C40A4A59CD2);
    uint64_t v17 = v22;
    uint64_t v22 = 0;
    if (v17)
    {
      unint64_t v18 = *(std::__shared_weak_count **)(v17 + 8);
      if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
      MEMORY[0x1A6239270](v17, 0x20C40A4A59CD2);
    }
  }
  if (*(void *)(v3 + 288))
  {
    *(void *)(v3 + 288) = 0;
    *(unsigned char *)(v3 + 1247) = 1;
  }
  LOWORD(v22) = 257;
  BYTE2(v22) = 1;
  md::Label::layoutForStaging((md::Label *)v3, (uint64_t)a2, 0, &v22);
  uint64_t v19 = *(void *)(v3 + 1232);
  *(void *)(v3 + 1232) = 0;
  if (v19)
  {
    uint64_t v20 = *(std::__shared_weak_count **)(v19 + 8);
    if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
    MEMORY[0x1A6239270](v19, 0x20C40A4A59CD2);
  }
  if (!*(unsigned char *)(v3 + 1290))
  {
    if (!*(unsigned char *)(v3 + 1246)) {
      goto LABEL_39;
    }
    *(unsigned char *)(v3 + 317) = v11;
    *(unsigned char *)(v3 + 318) = v12;
    *(unsigned char *)(v3 + 319) = 0;
    *(_WORD *)(v3 + 320) = v13;
    LOWORD(v22) = 257;
    BYTE2(v22) = 1;
    md::Label::layoutForStaging((md::Label *)v3, (uint64_t)a2, 0, &v22);
    if (!*(unsigned char *)(v3 + 1290)) {
      goto LABEL_39;
    }
  }
  uint64_t v21 = *(void *)(v3 + 288);
  if (v21)
  {
    (*(void (**)(uint64_t))(*(void *)v21 + 440))(v21);
    if (!*(unsigned char *)(v3 + 1290)) {
LABEL_39:
    }
      uint64_t v3 = 0;
  }
  if (v3) {
    return v3 + 40;
  }
  else {
    return 0;
  }
}

uint64_t md::LabelCollisionItem::dedupingGroup(md::LabelCollisionItem *this)
{
  return *(void *)(*((void *)this + 7) + 24);
}

uint64_t md::LabelCollisionItem::reserveSpaceItem(md::LabelCollisionItem *this)
{
  if (*((unsigned char *)this + 64)) {
    return 0;
  }
  uint64_t v2 = *((void *)this + 7);
  if (*(unsigned char *)(v2 + 1247)) {
    md::Label::updateReserveSpaceCollisionItem(*((md::Label **)this + 7));
  }
  return *(void *)(v2 + 336);
}

uint64_t md::Label::setCollisionResult(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 352) = *(void *)(a2 + 8);
  int v4 = *(unsigned __int8 *)(a2 + 1);
  uint64_t v5 = *(void *)(a1 + 24);
  if (v5)
  {
    if (*(unsigned char *)(a2 + 1))
    {
      if (*(unsigned char *)a2) {
        *(unsigned char *)(a1 + 821) = 21;
      }
    }
    else
    {
      (*(void (**)(uint64_t, uint64_t, void))(*(void *)v5 + 32))(v5, a1, 0);
    }
  }
  int v6 = v4 ^ 1;
  if (*(unsigned char *)(a1 + 1285) && *(void *)(a1 + 288) == *(void *)(a1 + 264))
  {
    *(unsigned char *)(a1 + 1285) = 0;
    *(unsigned char *)(a1 + 1250) = 0;
  }
  if (*(unsigned __int8 *)(a1 + 1291) != v6)
  {
    *(unsigned char *)(a1 + 1291) = v6;
    if (!v4)
    {
      if (*(unsigned char *)(a1 + 1290)) {
        md::Label::updateStateMachineForStaging(a1, 4, 37);
      }
    }
  }
  uint64_t result = *(void *)(a1 + 288);
  if (result) {
    uint64_t result = (*(uint64_t (**)(uint64_t, BOOL))(*(void *)result + 448))(result, v4 == 0);
  }
  if (!*(unsigned char *)(a1 + 1291))
  {
    unsigned __int8 v8 = *(unsigned char *)a2 ? 21 : 20;
    if (*(unsigned char *)(a1 + 820) == 2 || *(unsigned __int8 *)(a1 + 821) != v8)
    {
      return md::Label::updateStateMachineForStaging(a1, 6, v8);
    }
  }
  return result;
}

uint64_t md::LabelCollisionItem::setCollisionResult(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 65) = *(unsigned char *)(a2 + 1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 112))(a1);
  if (!result || *(unsigned char *)(a1 + 65))
  {
    uint64_t v5 = *(void *)(a1 + 56);
    return md::Label::setCollisionResult(v5, a2);
  }
  return result;
}

BOOL md::LabelCollisionItem::isReserveSpaceItem(md::LabelCollisionItem *this)
{
  return *((unsigned char *)this + 64) == 1;
}

BOOL md::CaptionedIconLabelPart::shouldSnapToDefaultPlacement(md::CaptionedIconLabelPart *this)
{
  return *((unsigned char *)this + 956) && *((unsigned char *)this + 957) != 0;
}

uint64_t md::CaptionedIconLabelPart::shouldSnapToVisiblePlacement(md::CaptionedIconLabelPart *this)
{
  return *((unsigned __int8 *)this + 959);
}

uint64_t md::CaptionedIconLabelPart::setCollisionResult(uint64_t this, uint64_t a2)
{
  uint64_t v3 = this;
  int v4 = *(uint64_t **)(this + 576);
  for (uint64_t i = *(uint64_t **)(this + 584);
        v4 != i;
        this = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v6 + 448))(v6, a2))
  {
    uint64_t v6 = *v4++;
  }
  if (a2)
  {
    char v7 = *(unsigned char *)(v3 + 953);
    *(unsigned char *)(v3 + 680) = v7;
    if (*(unsigned char *)(*(void *)(v3 + 16) + 1260)) {
      *(unsigned char *)(v3 + 954) = v7;
    }
  }
  return this;
}

uint64_t md::CaptionedIconLabelPart::collisionWillStart(uint64_t this)
{
  unsigned __int8 v1 = (unsigned char *)this;
  uint64_t v2 = *(uint64_t **)(this + 576);
  for (uint64_t i = *(uint64_t **)(this + 584); v2 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v4 + 440))(v4))
    uint64_t v4 = *v2++;
  BOOL v5 = v1[946] == 3 || v1[954] != 0;
  v1[953] = v5;
  v1[931] = 0;
  return this;
}

uint64_t non-virtual thunk to'md::Label::collidesWithItem(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 248) + 456))(*(void *)(a1 + 248), a2, 0);
}

uint64_t md::LabelCollisionItem::nextPlacementCandidate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a1 + 56);
  if ((*(unsigned int (**)(void))(**(void **)(v8 + 288) + 536))(*(void *)(v8 + 288)))
  {
    int v22 = 150994944;
    char v23 = 0;
    if ((*(unsigned int (**)(void, uint64_t, uint64_t, void, uint64_t, int *))(**(void **)(v8 + 288)
                                                                                          + 576))(*(void *)(v8 + 288), a4, a5, *(void *)(v8 + 328), a3, &v22))
    {
      if (__PAIR64__(BYTE1(v22), v22) != __PAIR64__(*(unsigned __int8 *)(v8 + 313), *(unsigned __int8 *)(v8 + 312))|| HIBYTE(v22) != *(unsigned __int8 *)(v8 + 315)|| HIBYTE(v22) == 10 && v23 != *(unsigned char *)(v8 + 316))
      {
        (*(void (**)(uint64_t *__return_ptr))(**(void **)(v8 + 288) + 600))(&v21);
        uint64_t v9 = v21;
        uint64_t v21 = 0;
        uint64_t v10 = *(void *)(v8 + 1232);
        *(void *)(v8 + 1232) = v9;
        if (v10)
        {
          char v11 = *(std::__shared_weak_count **)(v10 + 8);
          if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
            std::__shared_weak_count::__release_weak(v11);
          }
          MEMORY[0x1A6239270](v10, 0x20C40A4A59CD2);
          uint64_t v12 = v21;
          uint64_t v21 = 0;
          if (v12)
          {
            __int16 v13 = *(std::__shared_weak_count **)(v12 + 8);
            if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
            MEMORY[0x1A6239270](v12, 0x20C40A4A59CD2);
          }
        }
        (*(void (**)(void, void))(**(void **)(v8 + 288) + 448))(*(void *)(v8 + 288), 0);
        if (*(void *)(v8 + 288))
        {
          *(void *)(v8 + 288) = 0;
          *(unsigned char *)(v8 + 1247) = 1;
        }
        char v14 = *(unsigned char *)(v8 + 312);
        char v15 = *(unsigned char *)(v8 + 313);
        __int16 v16 = *(_WORD *)(v8 + 315);
        *(unsigned char *)(v8 + 321) = v23;
        *(_DWORD *)(v8 + 317) = v22;
        LOWORD(v21) = 257;
        BYTE2(v21) = 1;
        md::Label::layoutForStaging((md::Label *)v8, a4, 0, &v21);
        uint64_t v17 = *(void *)(v8 + 1232);
        *(void *)(v8 + 1232) = 0;
        if (v17)
        {
          unint64_t v18 = *(std::__shared_weak_count **)(v17 + 8);
          if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
          MEMORY[0x1A6239270](v17, 0x20C40A4A59CD2);
        }
        if (!*(unsigned char *)(v8 + 1290))
        {
          if (!*(unsigned char *)(v8 + 1246)) {
            return 0;
          }
          *(unsigned char *)(v8 + 317) = v14;
          *(unsigned char *)(v8 + 318) = v15;
          *(unsigned char *)(v8 + 319) = 0;
          *(_WORD *)(v8 + 320) = v16;
          LOWORD(v21) = 257;
          BYTE2(v21) = 1;
          md::Label::layoutForStaging((md::Label *)v8, a4, 0, &v21);
          if (!*(unsigned char *)(v8 + 1290)) {
            return 0;
          }
        }
        uint64_t v19 = *(void *)(v8 + 288);
        if (v19) {
          (*(void (**)(uint64_t))(*(void *)v19 + 440))(v19);
        }
      }
      return v8 + 40;
    }
  }
  return 0;
}

uint64_t md::LabelCollisionItem::isAlwaysVisible(md::LabelCollisionItem *this)
{
  return *(unsigned __int8 *)(*((void *)this + 7) + 1246);
}

uint64_t md::LabelCollider::collideCandidate(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)a3 + 16))(a3);
  float32x2_t v9 = *v8;
  float32x2_t v10 = v8[1];
  *(void *)(a4 + 8) = 0;
  int32x2_t v11 = vcgt_f32(v9, v10);
  if (((v11.i32[0] | v11.i32[1]) & 1) != 0
    || *(unsigned char *)(a1 + 92)
    && (v9.f32[0] < *(float *)(a1 + 12)
     || v10.f32[0] > *(float *)(a1 + 20)
     || v9.f32[1] < *(float *)(a1 + 16)
     || v10.f32[1] > *(float *)(a1 + 24)))
  {
    goto LABEL_8;
  }
  float v12 = *(float *)(a1 + 32);
  float32x2_t v13 = vmul_f32(vsub_f32(v10, v9), (float32x2_t)0x3F0000003F000000);
  float32x2_t v14 = vadd_f32(v13, v9);
  float32x2_t v15 = *(float32x2_t *)(a1 + 36);
  *(int32x2_t *)&long long v16 = vmax_s32(vcvt_s32_f32(vmul_n_f32(vsub_f32(v9, v15), v12)), 0);
  int32x2_t v17 = vmin_s32(vadd_s32(*(int32x2_t *)(a1 + 44), (int32x2_t)-1), vcvt_s32_f32(vmul_n_f32(vsub_f32(vadd_f32(v14, v13), v15), v12)));
  int32x2_t v18 = vcgt_s32(*(int32x2_t *)&v16, v17);
  *((int32x2_t *)&v16 + 1) = v17;
  *(_OWORD *)(a1 + 96) = v16;
  if (vorr_s8((int8x8_t)v18, (int8x8_t)vdup_lane_s32(v18, 1)).u32[0])
  {
LABEL_8:
    uint64_t result = 0;
    *(unsigned char *)(a4 + 1) = 1;
  }
  else
  {
    float32x2_t v25 = v13;
    float32x2_t v26 = v14;
    md::LabelCollider::getGridItems(a1, (int *)(a1 + 96), a2, (unint64_t *)(a1 + 112));
    *(float32x2_t *)&long long v20 = v25;
    *((float32x2_t *)&v20 + 1) = v26;
    long long v27 = v20;
    uint64_t v28 = 1065353216;
    *(unsigned char *)(a4 + 1) = 0;
    uint64_t v21 = *(void *)(a1 + 112);
    if (v21)
    {
      int v22 = *(uint64_t **)(a1 + 128);
      uint64_t v23 = 8 * v21;
      while (1)
      {
        uint64_t v24 = *v22;
        if (gm::OBRect<float>::intersectsUsingInset((float *)(*v22 + 8), (float *)&v27))
        {
          if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)a3 + 24))(a3, v24)) {
            break;
          }
        }
        ++v22;
        v23 -= 8;
        if (!v23) {
          return 1;
        }
      }
      *(unsigned char *)(a4 + 1) = 1;
      *(void *)(a4 + 8) = v24;
    }
    return 1;
  }
  return result;
}

BOOL gm::OBRect<float>::intersectsUsingInset(float *a1, float *a2)
{
  float v2 = *a1;
  if (*a1 <= 0.0) {
    return 0;
  }
  float v3 = a1[1];
  uint64_t v4 = 0;
  if (v3 > 0.0)
  {
    float v5 = *a2;
    if (*a2 > 0.0)
    {
      float v6 = a2[1];
      if (v6 > 0.0)
      {
        float v7 = a2[2] - a1[2];
        float v8 = a2[3] - a1[3];
        if (*((void *)a1 + 2) == *((void *)a2 + 2))
        {
          if (fabsf(v7) > (float)(v5 + v2)) {
            return 0;
          }
          float v19 = fabsf(v8);
        }
        else
        {
          float v9 = a2[4];
          float v10 = a2[5];
          float v11 = a1[4];
          float v12 = a1[5];
          float v13 = -(float)(v10 * v6);
          if (fabsf((float)(v11 * v7) + (float)(v12 * v8)) > (float)((float)(fabsf((float)(v11 * (float)(v9 * v5))+ (float)(v12 * (float)(v10 * v5)))+ v2)+ fabsf((float)(v13 * v11)+ (float)((float)(v6 * v9) * v12))))return 0; {
          if (fabsf(-(float)((float)(v12 * v7) - (float)(v11 * v8))) > (float)((float)(fabsf(-(float)((float)(v12 * (float)(v9 * v5)) - (float)((float)(v10 * v5) * v11)))
          }
                                                                                      + v3)
                                                                              + fabsf(-(float)((float)(v13 * v12)
                                                                                             - (float)((float)(v6 * v9) * v11)))))
            return 0;
          float v14 = v11 * v2;
          float v15 = v12 * v2;
          float v16 = -(float)(v3 * v12);
          float v17 = v11 * v3;
          if (fabsf((float)(v9 * v7) + (float)(v10 * v8)) > (float)((float)(fabsf((float)(v14 * v9) + (float)(v15 * v10))
                                                                           + v5)
                                                                   + fabsf((float)(v17 * v10) + (float)(v16 * v9))))
            return 0;
          float v19 = fabsf(-(float)((float)(v10 * v7) - (float)(v9 * v8)));
          float v6 = fabsf(-(float)((float)(v14 * v10) - (float)(v15 * v9))) + v6;
          float v3 = fabsf(-(float)((float)(v16 * v10) - (float)(v17 * v9)));
        }
        return v19 <= (float)(v6 + v3);
      }
    }
  }
  return v4;
}

uint64_t md::CaptionedIconLabelPart::collidesWithItem(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a1 + 925) && !*(unsigned char *)(*(void *)(a1 + 16) + 1259))
  {
    uint64_t v7 = **(void **)(a1 + 576);
    float v8 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v7 + 248))(v7);
    float32x2_t v9 = vmul_f32(vsub_f32(v8[1], *v8), (float32x2_t)0x3F0000003F000000);
    float32x2_t v10 = vadd_f32(v9, *v8);
    float32x2_t v16 = v9;
    float32x2_t v17 = v10;
    uint64_t v18 = 1065353216;
    if (gm::OBRect<float>::intersectsUsingInset((float *)(a2 + 8), (float *)&v16)
      && (*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 456))(v7, a2, a3)
      && !*(unsigned char *)(*(void *)(a1 + 16) + 1246))
    {
      return 1;
    }
    unsigned int v11 = (*(uint64_t (**)(void))(***(void ***)(a1 + 576) + 208))(**(void **)(a1 + 576));
    if (v11 != 255 && !*(unsigned char *)(a1 + v11 + 792)) {
      *(unsigned char *)(a1 + 953) = 1;
    }
  }
  if (!*(unsigned char *)(a1 + 926) || *(unsigned char *)(a1 + 953)) {
    return 0;
  }
  uint64_t v12 = *(void *)(*(void *)(a1 + 576) + 8 * *(unsigned __int8 *)(a1 + 925));
  float v13 = (float32x2_t *)(*(uint64_t (**)(uint64_t))(*(void *)v12 + 248))(v12);
  float32x2_t v14 = vmul_f32(vsub_f32(v13[1], *v13), (float32x2_t)0x3F0000003F000000);
  float32x2_t v15 = vadd_f32(v14, *v13);
  float32x2_t v16 = v14;
  float32x2_t v17 = v15;
  uint64_t v18 = 1065353216;
  uint64_t result = gm::OBRect<float>::intersectsUsingInset((float *)(a2 + 8), (float *)&v16);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v12 + 456))(v12, a2, a3);
    if (result)
    {
      if (*(unsigned char *)(a1 + 955)) {
        return 1;
      }
      uint64_t result = 1;
      if (*(unsigned char *)(a1 + 946) == 1)
      {
        *(unsigned char *)(a1 + 953) = 1;
        return 0;
      }
    }
  }
  return result;
}

uint64_t md::LabelCollisionItem::collidesWithObject(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 56);
  if (*(unsigned char *)(a1 + 64) == 1)
  {
    uint64_t v2 = *(void *)(v1 + 344);
    if (v2) {
      return (*(uint64_t (**)(void))(*(void *)v2 + 32))();
    }
  }
  else
  {
    uint64_t v4 = *(void *)(v1 + 288);
    if (v4) {
      return (*(uint64_t (**)(void))(*(void *)v4 + 464))();
    }
  }
  return 0;
}

uint64_t md::LabelPart::collidesWithItem(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, a1 + 72);
}

uint64_t md::CaptionedIconLabelPart::collidesWithObject(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 925)
    && ((*(uint64_t (**)(void, uint64_t))(***(void ***)(a1 + 576) + 840))(**(void **)(a1 + 576), a2) & 1) != 0)
  {
    return 1;
  }
  if (!*(unsigned char *)(a1 + 926) || *(unsigned char *)(a1 + 680)) {
    return 0;
  }
  uint64_t v4 = *(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 576) + 8 * *(unsigned __int8 *)(a1 + 925)) + 840);
  return v4();
}

uint64_t md::LabelPart::collidesWithObject(md::LabelPart *this, const md::CollisionObject *a2)
{
  if (!*((void *)this + 29) && !*((void *)this + 30) || (*((unsigned char *)a2 + 200) & *((unsigned char *)this + 272)) != 0) {
    return 0;
  }
  float v3 = (md::LabelPart *)((char *)this + 72);
  uint64_t v4 = *((void *)a2 + 21);
  if (!*((void *)this + 30))
  {
    if (!v4)
    {
      if (*((unsigned char *)this + 268) || *((unsigned char *)a2 + 196)) {
        return md::CollisionObject::rectsCollideWithRectsOBB((md::LabelPart *)((char *)this + 72), a2);
      }
      else {
        return md::CollisionObject::rectsCollideWithRects((uint64_t)this + 72, (uint64_t)a2);
      }
    }
    float32x2_t v14 = a2;
    a2 = v3;
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  if (!v4)
  {
    float32x2_t v14 = (md::LabelPart *)((char *)this + 72);
    return md::CollisionObject::circlesCollideWithRects((uint64_t)v14, (uint64_t)a2);
  }
  unint64_t v5 = *((unsigned int *)a2 + 44);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = 0;
  BOOL v7 = 1;
  while (1)
  {
    float v8 = (float32x2_t *)(*((void *)a2 + 23) + 24 * v6);
    float v9 = v8[*((unsigned __int8 *)this + 271) + 1].f32[0];
    if (v9 > 0.0)
    {
      uint64_t v10 = *((unsigned int *)this + 62);
      if (v10) {
        break;
      }
    }
LABEL_9:
    BOOL v7 = ++v6 < v5;
    if (v6 == v5) {
      return 0;
    }
  }
  unsigned int v11 = (float32x2_t *)*((void *)this + 32);
  while (1)
  {
    float v12 = v11[*((unsigned __int8 *)a2 + 199) + 1].f32[0];
    if (v12 > 0.0)
    {
      float32x2_t v13 = vsub_f32(*v11, *v8);
      if (vaddv_f32(vmul_f32(v13, v13)) < (float)((float)(v12 + v9) * (float)(v12 + v9))) {
        return v7;
      }
    }
    v11 += 3;
    if (!--v10) {
      goto LABEL_9;
    }
  }
}

uint64_t md::LabelPart::partCollidesWithObject(uint64_t a1, float *a2)
{
  uint64_t v4 = (float *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 248))(a1);
  if (v4[2] <= a2[20] || *v4 >= a2[22] || v4[3] <= a2[21] || v4[1] >= a2[23]) {
    return 0;
  }
  unint64_t v5 = *(uint64_t (**)(uint64_t, float *))(*(void *)a1 + 464);
  return v5(a1, a2);
}

uint64_t md::LabelPartPlacementCandidate::collidesWithItem(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(**(void **)(a1 + 8) + 456))(*(void *)(a1 + 8), a2, *(unsigned __int8 *)(a1 + 16));
}

BOOL md::CaptionedIconLabelPart::supportsAlternatePlacements(uint64_t a1, unsigned int a2)
{
  if (a2 > 1 || !*(unsigned char *)(a1 + 926)) {
    return 0;
  }
  if (*(void *)(a1 + 800) != *(void *)(a1 + 808)) {
    return 1;
  }
  if (*(unsigned char *)(a1 + 946) == 1) {
    return 1;
  }
  return *(unsigned char *)(a1 + 794) != 0;
}

uint64_t md::LabelPartPlacementCandidate::collisionBounds(md::LabelPartPlacementCandidate *this)
{
  return (*(uint64_t (**)(void))(**((void **)this + 1) + 248))();
}

uint64_t md::CaptionedIconLabelPart::findAlternatePlacement(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, uint64_t a5, uint64_t a6)
{
  if ((md::CaptionedIconLabelPart::collideIconPart(a1, *(float **)(a2 + 432), a3, a4) & 1) == 0)
  {
    if (*(unsigned char *)(a2 + 3624))
    {
      if (((*(uint64_t (**)(void))(**(void **)(*(void *)(a2 + 168) + 32) + 8))(*(void *)(*(void *)(a2 + 168) + 32)) & 1) == 0)
      {
        char v11 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 560))(a1);
        if (md::CaptionedIconLabelPart::tryAlternatePlacements(a1, v11, 0, 0, a2, a3, a4, a6)) {
          return 1;
        }
      }
    }
    int v12 = *(unsigned __int8 *)(a1 + 946);
    if (v12 == 1) {
      goto LABEL_10;
    }
    if (v12 == 2)
    {
      if (*(unsigned char *)(*(void *)(a1 + 16) + 1246))
      {
LABEL_11:
        int v13 = *(_DWORD *)(a1 + 832);
        *(unsigned char *)(a6 + 4) = *(unsigned char *)(a1 + 836);
        *(_DWORD *)a6 = v13;
        return 1;
      }
      if (*(unsigned char *)(a1 + 794))
      {
        (*(void (**)(void, void))(***(void ***)(a1 + 576) + 216))(**(void **)(a1 + 576), *(unsigned __int8 *)(a1 + 795));
LABEL_10:
        *(unsigned char *)(a1 + 953) = 1;
        goto LABEL_11;
      }
    }
  }
  return 0;
}

uint64_t md::CaptionedIconLabelPart::collideIconPart(uint64_t a1, float *a2, uint64_t a3, _DWORD *a4)
{
  if (*(unsigned char *)(a1 + 931)) {
    return *(unsigned __int8 *)(a1 + 932);
  }
  *(unsigned char *)(a1 + 931) = 1;
  if (!*(unsigned char *)(a1 + 925) || (uint64_t v5 = *(void *)(a1 + 16), *(unsigned char *)(v5 + 1259)))
  {
    *(unsigned char *)(a1 + 932) = 0;
    *(_OWORD *)(a1 + 872) = 0u;
    return *(unsigned __int8 *)(a1 + 932);
  }
  BOOL v7 = *(void **)(a1 + 576);
  uint64_t v8 = *v7;
  if (*(unsigned char *)(v5 + 1246))
  {
    if ((*(float (**)(void))(*(void *)v8 + 264))(*v7) < a2[276]
      || v11 > a2[278]
      || v10 < a2[277]
      || v12 > a2[279])
    {
      *(unsigned char *)(a1 + 932) = 1;
      return *(unsigned __int8 *)(a1 + 932);
    }
    *(unsigned char *)(a1 + 932) = 0;
    goto LABEL_15;
  }
  v27[0] = &unk_1EF5484F0;
  v27[1] = v8;
  char v28 = 0;
  char v26 = 1;
  int v13 = md::LabelCollider::collideCandidate(a3, a4, (uint64_t)v27, (uint64_t)&v25) ^ 1;
  if (v26) {
    int v13 = 1;
  }
  *(unsigned char *)(a1 + 932) = v13;
  if (!v13)
  {
LABEL_15:
    float v14 = (*(float (**)(uint64_t))(*(void *)v8 + 264))(v8);
    if (v16 < v14 || v17 < v15)
    {
      float v22 = 3.4028e38;
      float v24 = -3.4028e38;
      float v23 = -3.4028e38;
      float v20 = 3.4028e38;
    }
    else
    {
      float v19 = *(float *)(a1 + 280);
      float v20 = v14 - v19;
      float v21 = *(float *)(a1 + 284);
      float v22 = v15 - v21;
      float v23 = v16 - v19;
      float v24 = v17 - v21;
    }
    *(float *)(a1 + 872) = v20;
    *(float *)(a1 + 876) = v22;
    *(float *)(a1 + 880) = v23;
    *(float *)(a1 + 884) = v24;
  }
  return *(unsigned __int8 *)(a1 + 932);
}

uint64_t md::LabelPart::shouldSnapToVisiblePlacement(md::LabelPart *this)
{
  return 0;
}

uint64_t md::LabelCollisionItem::dedupingGroupSubID(md::LabelCollisionItem *this)
{
  return *(unsigned __int16 *)(*((void *)this + 7) + 36);
}

uint64_t md::LabelPart::shouldSnapToDefaultPlacement(md::LabelPart *this)
{
  return 0;
}

BOOL md::LabelSpacingDedupingGroup::isResolved(md::LabelSpacingDedupingGroup *this, unsigned int a2)
{
  uint64_t v2 = *((void *)this + 1);
  if (a2 >= (unint64_t)((*((void *)this + 2) - v2) >> 3)) {
    return 0;
  }
  uint64_t v4 = *((void *)this + 5);
  uint64_t v3 = *((void *)this + 6);
  if (v4 == v3) {
    return 0;
  }
  float v5 = *((float *)this + 24);
  uint64_t v6 = v4 + 8;
  do
  {
    float32x2_t v7 = vsub_f32(*(float32x2_t *)(*(void *)(v2 + 8 * a2) + 664), *(float32x2_t *)(*(void *)(v6 - 8) + 664));
    v7.f32[0] = vaddv_f32(vmul_f32(v7, v7));
    BOOL result = v7.f32[0] < v5;
    BOOL v9 = v7.f32[0] < v5 || v6 == v3;
    v6 += 8;
  }
  while (!v9);
  return result;
}

uint64_t md::LabelDedupingGroup::addResolvedLabel(uint64_t result, uint64_t a2)
{
  uint64_t v3 = result;
  uint64_t v4 = *(void **)(result + 48);
  unint64_t v5 = *(void *)(result + 56);
  if ((unint64_t)v4 < v5)
  {
    if (v4) {
      *uint64_t v4 = a2;
    }
    uint64_t v6 = v4 + 1;
    goto LABEL_27;
  }
  uint64_t v7 = *(void *)(result + 40);
  uint64_t v8 = ((uint64_t)v4 - v7) >> 3;
  unint64_t v9 = v8 + 1;
  if ((unint64_t)(v8 + 1) >> 61) {
    abort();
  }
  uint64_t v10 = v5 - v7;
  if (v10 >> 2 > v9) {
    unint64_t v9 = v10 >> 2;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v9)
  {
    uint64_t v11 = 8 * v9;
    BOOL result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(result + 64) + 16))(*(void *)(result + 64), 8 * v9, 8);
    float v12 = (void *)(result + 8 * v8);
    unint64_t v9 = result + v11;
    if (result) {
      *float v12 = a2;
    }
  }
  else
  {
    float v12 = (void *)(8 * v8);
  }
  uint64_t v6 = v12 + 1;
  uint64_t v14 = *(void *)(v3 + 40);
  uint64_t v13 = *(void *)(v3 + 48);
  if (v13 != v14)
  {
    unint64_t v15 = v13 - v14 - 8;
    if (v15 < 0x38)
    {
      uint64_t v17 = *(void *)(v3 + 48);
    }
    else if ((unint64_t)(v13 - (void)v12) < 0x20)
    {
      uint64_t v17 = *(void *)(v3 + 48);
    }
    else
    {
      uint64_t v16 = (v15 >> 3) + 1;
      uint64_t v17 = v13 - 8 * (v16 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v18 = v12 - 2;
      float v19 = (long long *)(v13 - 16);
      uint64_t v20 = v16 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v21 = *v19;
        *(v18 - 1) = *(v19 - 1);
        _OWORD *v18 = v21;
        v18 -= 2;
        v19 -= 2;
        v20 -= 4;
      }
      while (v20);
      v12 -= v16 & 0x3FFFFFFFFFFFFFFCLL;
      if (v16 == (v16 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_24;
      }
    }
    do
    {
      uint64_t v22 = *(void *)(v17 - 8);
      v17 -= 8;
      *--float v12 = v22;
    }
    while (v17 != v14);
LABEL_24:
    uint64_t v13 = *(void *)(v3 + 40);
  }
  *(void *)(v3 + 40) = v12;
  *(void *)(v3 + 48) = v6;
  uint64_t v23 = *(void *)(v3 + 56);
  *(void *)(v3 + 56) = v9;
  if (v13) {
    BOOL result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v3 + 64) + 40))(*(void *)(v3 + 64), v13, v23 - v13);
  }
LABEL_27:
  *(void *)(v3 + 48) = v6;
  return result;
}

unint64_t *std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::getGridItems(gm::Box<int,2> const&,md::LabelCollidableItem const&,md::SimpleBuffer<md::LabelCollidableItem*,20ul> &)::$_0 &,md::LabelCollidableItem**>(unint64_t *result, unint64_t *a2, unint64_t *a3, unint64_t *a4)
{
  unint64_t v4 = *a2;
  unint64_t v5 = *result;
  unsigned int v6 = *(unsigned __int8 *)(*a2 + 52);
  unsigned int v7 = *(unsigned __int8 *)(*result + 52);
  BOOL v8 = v6 < v7;
  if (v6 == v7) {
    BOOL v8 = *a2 < *result;
  }
  unint64_t v9 = *a3;
  unsigned int v10 = *(unsigned __int8 *)(*a3 + 52);
  BOOL v11 = v10 == v6;
  BOOL v12 = v10 < v6;
  if (v11) {
    BOOL v12 = *a3 < v4;
  }
  if (v8)
  {
    if (v12)
    {
      void *result = v9;
LABEL_17:
      *a3 = v5;
      unint64_t v4 = v5;
      goto LABEL_19;
    }
    void *result = v4;
    *a2 = v5;
    unint64_t v4 = *a3;
    unsigned int v17 = *(unsigned __int8 *)(*a3 + 52);
    BOOL v11 = v17 == v7;
    BOOL v18 = v17 < v7;
    if (v11) {
      BOOL v18 = *a3 < v5;
    }
    if (v18)
    {
      *a2 = v4;
      goto LABEL_17;
    }
  }
  else if (v12)
  {
    *a2 = v9;
    *a3 = v4;
    unint64_t v13 = *result;
    unsigned int v14 = *(unsigned __int8 *)(*a2 + 52);
    unsigned int v15 = *(unsigned __int8 *)(*result + 52);
    BOOL v11 = v14 == v15;
    BOOL v16 = v14 < v15;
    if (v11) {
      BOOL v16 = *a2 < *result;
    }
    if (v16)
    {
      void *result = *a2;
      *a2 = v13;
      unint64_t v4 = *a3;
    }
  }
  else
  {
    unint64_t v4 = *a3;
  }
LABEL_19:
  unsigned int v19 = *(unsigned __int8 *)(*a4 + 52);
  unsigned int v20 = *(unsigned __int8 *)(v4 + 52);
  BOOL v11 = v19 == v20;
  BOOL v21 = v19 < v20;
  if (v11) {
    BOOL v21 = *a4 < v4;
  }
  if (v21)
  {
    *a3 = *a4;
    *a4 = v4;
    unint64_t v22 = *a2;
    unsigned int v23 = *(unsigned __int8 *)(*a3 + 52);
    unsigned int v24 = *(unsigned __int8 *)(*a2 + 52);
    BOOL v11 = v23 == v24;
    BOOL v25 = v23 < v24;
    if (v11) {
      BOOL v25 = *a3 < *a2;
    }
    if (v25)
    {
      *a2 = *a3;
      *a3 = v22;
      unint64_t v26 = *result;
      unsigned int v27 = *(unsigned __int8 *)(*a2 + 52);
      unsigned int v28 = *(unsigned __int8 *)(*result + 52);
      BOOL v11 = v27 == v28;
      BOOL v29 = v27 < v28;
      if (v11) {
        BOOL v29 = *a2 < *result;
      }
      if (v29)
      {
        void *result = *a2;
        *a2 = v26;
      }
    }
  }
  return result;
}

uint64_t md::CollisionObject::circlesCollideWithRects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(a2 + 176);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = 0;
  unint64_t v4 = *(unsigned int *)(a1 + 176);
  int v5 = *(_DWORD *)(a1 + 176);
  while (!v5)
  {
LABEL_4:
    if (++v3 == v2) {
      return 0;
    }
  }
  unsigned int v6 = (float32x2_t *)(*(void *)(a2 + 184) + 24 * v3);
  float32x2_t v7 = v6[*(unsigned __int8 *)(a1 + 199) + 1];
  if (v7.f32[1] < 0.0 || v7.f32[0] < 0.0)
  {
    unint64_t v9 = 0;
    do
      ++v9;
    while (v9 < v4);
LABEL_3:
    int v5 = *(_DWORD *)(a1 + 176);
    goto LABEL_4;
  }
  unint64_t v10 = 0;
  BOOL v11 = *(float32x2_t **)(a1 + 184);
  while (1)
  {
    float v15 = v11[*(unsigned __int8 *)(a2 + 199) + 1].f32[0];
    if (v15 > 0.0)
    {
      float32x2_t v16 = vsub_f32(*v11, *v6);
      if (*(unsigned char *)(a2 + 196))
      {
        float32x2_t v17 = vmul_n_f32(v16, *(float *)(a2 + 16));
        float32x2_t v18 = vmul_n_f32((float32x2_t)vrev64_s32((int32x2_t)v16), *(float *)(a2 + 20));
        v16.i32[0] = vadd_f32(v17, v18).u32[0];
        v16.i32[1] = vsub_f32(v17, v18).i32[1];
      }
      float32x2_t v12 = vmaxnm_f32(vsub_f32(v16, v7), vneg_f32(vadd_f32(v7, v16)));
      BOOL v13 = v15 != 0.0 && v12.f32[0] < v15;
      BOOL v14 = v13 && v12.f32[1] < v15;
      if (v14 && (v12.f32[0] <= 0.0 || v12.f32[1] <= 0.0 || vaddv_f32(vmul_f32(v12, v12)) < (float)(v15 * v15))) {
        return 1;
      }
    }
    ++v10;
    v11 += 3;
    if (v10 >= v4) {
      goto LABEL_3;
    }
  }
}

uint64_t md::LabelPart::alternateStyleIndex(md::LabelPart *this)
{
  return 255;
}

uint64_t md::LabelPart::supportsAlternatePlacements()
{
  return 0;
}

uint64_t md::CompositeLabelPart::markInactive(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 576);
  for (uint64_t i = *(uint64_t **)(this + 584); v1 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 160))(v3))
    uint64_t v3 = *v1++;
  return this;
}

BOOL md::CollisionObject::rectsCollideWithRects(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a2 + 176);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = *(unsigned int *)(a1 + 176);
  if (!v3) {
    return 0;
  }
  uint64_t v4 = 0;
  uint64_t v5 = *(unsigned __int8 *)(a1 + 199);
  uint64_t v6 = *(void *)(a2 + 184);
  float32x2_t v7 = *(float **)(a1 + 184);
  uint64_t v8 = 2 * *(unsigned __int8 *)(a2 + 199);
  BOOL v9 = 1;
LABEL_5:
  unint64_t v10 = (float *)(v6 + 24 * v4);
  BOOL v11 = &v10[2 * v5];
  float v13 = v11[2];
  float32x2_t v12 = v11 + 2;
  float v14 = v13;
  float v15 = v7;
  uint64_t v16 = v3;
  while (vabds_f32(*v15, *v10) >= (float)(v14 + v15[v8 + 2])
       || vabds_f32(v15[1], v10[1]) >= (float)(v12[1] + v15[v8 + 3]))
  {
    v15 += 6;
    if (!--v16)
    {
      BOOL v9 = ++v4 < v2;
      if (v4 == v2) {
        return 0;
      }
      goto LABEL_5;
    }
  }
  return v9;
}

uint64_t md::MultiCollisionObjectPlacementCandidate::collisionBounds(md::MultiCollisionObjectPlacementCandidate *this)
{
  if (!*((unsigned char *)this + 72))
  {
    *((unsigned char *)this + 72) = 1;
    *(_OWORD *)((char *)this + 40) = xmmword_1A28FC750;
    uint64_t v1 = (float *)*((void *)this + 1);
    unint64_t v2 = (float *)*((void *)this + 2);
    if (v1 != v2)
    {
      float v3 = 3.4028e38;
      float v4 = -3.4028e38;
      float v5 = -3.4028e38;
      float v6 = 3.4028e38;
      do
      {
        float v6 = fminf(v1[20], v6);
        *((float *)this + 10) = v6;
        float v5 = fmaxf(v5, v1[22]);
        *((float *)this + 12) = v5;
        float v3 = fminf(v1[21], v3);
        *((float *)this + 11) = v3;
        float v4 = fmaxf(v4, v1[23]);
        *((float *)this + 13) = v4;
        v1 += 52;
      }
      while (v1 != v2);
    }
  }
  return (uint64_t)this + 40;
}

uint64_t md::MultiCollisionObjectPlacementCandidate::collidesWithItem(uint64_t a1, float *a2)
{
  unint64_t v2 = *(float32x2_t **)(a1 + 8);
  float v3 = *(float32x2_t **)(a1 + 16);
  if (v2 == v3) {
    return 0;
  }
  float v5 = a2 + 2;
  while (1)
  {
    float32x2_t v6 = v2[10];
    v8[0] = vmul_f32(vsub_f32(v2[11], v6), (float32x2_t)0x3F0000003F000000);
    v8[1] = vadd_f32(v8[0], v6);
    v8[2] = (float32x2_t)1065353216;
    if (gm::OBRect<float>::intersectsUsingInset(v5, (float *)v8)
      && ((*(uint64_t (**)(float *, float32x2_t *))(*(void *)a2 + 16))(a2, v2) & 1) != 0)
    {
      break;
    }
    v2 += 26;
    if (v2 == v3) {
      return 0;
    }
  }
  return 1;
}

uint64_t md::CurvedTextLabelPart::shouldSnapToDefaultPlacement(md::CurvedTextLabelPart *this)
{
  return *((unsigned __int8 *)this + 1467);
}

BOOL md::LabelDedupingGroup::isResolved(md::LabelDedupingGroup *this)
{
  return *((void *)this + 5) != *((void *)this + 6);
}

uint64_t UserAnnotationCollidableItem::collidesWithObject()
{
  return 1;
}

void md::LabelPart::transferResource(void *a1@<X8>)
{
  *a1 = 0;
}

uint64_t md::CaptionedIconLabelPart::transferResource@<X0>(uint64_t this@<X0>, void *a2@<X8>)
{
  if (*(unsigned char *)(this + 925)) {
    return (*(uint64_t (**)(void))(***(void ***)(this + 576) + 600))();
  }
  *a2 = 0;
  return this;
}

void md::LabelStyleContext::setScaleOptions(md::LabelStyleContext *this, const char *__s)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  size_t v3 = strlen(__s);
  if (v3 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v4 = v3;
  if (v3 >= 0x17)
  {
    uint64_t v6 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v6 = v3 | 7;
    }
    uint64_t v7 = v6 + 1;
    float v5 = operator new(v6 + 1);
    __dst[1] = v4;
    unint64_t v10 = v7 | 0x8000000000000000;
    __dst[0] = v5;
  }
  else
  {
    HIBYTE(v10) = v3;
    float v5 = __dst;
    if (!v3)
    {
LABEL_9:
      *((unsigned char *)v5 + v4) = 0;
      md::StyleSettingsParser::StyleSettingsParser((uint64_t)&__p);
    }
  }
  memcpy(v5, __s, v4);
  goto LABEL_9;
}

double md::StyleSettingsParser::parseNode(uint64_t a1, uint64_t a2, unsigned __int8 **a3)
{
  size_t v3 = *a3;
  unint64_t v4 = (unint64_t)a3[1];
  unint64_t v5 = v4;
  if (!v4)
  {
LABEL_8:
    unint64_t v10 = -1;
    goto LABEL_10;
  }
  uint64_t v6 = a3[1];
  uint64_t v7 = *a3;
  while (1)
  {
    unint64_t v8 = *v7;
    if (v8 > 0x3F || ((1 << v8) & 0x100002600) == 0) {
      break;
    }
    ++v7;
    if (!--v6) {
      goto LABEL_8;
    }
  }
  unint64_t v10 = v7 - v3;
  do
  {
LABEL_10:
    if (!v5)
    {
      float v13 = 0;
      unint64_t v14 = 0;
      goto LABEL_27;
    }
    unint64_t v11 = v3[--v5];
  }
  while (v11 <= 0x3F && ((1 << v11) & 0x100002600) != 0);
  float v13 = 0;
  if (v10 == -1)
  {
    unint64_t v14 = 0;
  }
  else
  {
    unint64_t v14 = 0;
    if (v5 != -1)
    {
      if (v3[v10] == 123 && v3[v5] == 125)
      {
        ++v10;
        --v5;
      }
      BOOL v15 = v4 >= v10;
      unint64_t v16 = v4 - v10;
      if (!v15) {
        abort();
      }
      unint64_t v17 = v5 - v10;
      float v13 = &v3[v10];
      if (v16 >= v17 + 1) {
        unint64_t v14 = v17 + 1;
      }
      else {
        unint64_t v14 = v16;
      }
    }
  }
LABEL_27:
  v22[0] = v13;
  v22[1] = v14;
  double result = md::StyleSettingsParser::parseNextElement((uint64_t)__p, a1, 1, (uint64_t)v22);
  if (v21)
  {
    if (v20 != 2)
    {
      if (!v20) {
        operator new();
      }
      operator new();
    }
    operator new();
  }
  return result;
}

{
  unsigned __int8 *v3;
  unint64_t v4;
  unint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unint64_t v8;
  unint64_t v10;
  unint64_t v11;
  unsigned __int8 *v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  unint64_t v17;
  double result;
  void *__p;
  char v20;
  char v21;
  void v22[2];

  size_t v3 = *a3;
  unint64_t v4 = (unint64_t)a3[1];
  unint64_t v5 = v4;
  if (!v4)
  {
LABEL_8:
    unint64_t v10 = -1;
    goto LABEL_10;
  }
  uint64_t v6 = a3[1];
  uint64_t v7 = *a3;
  while (1)
  {
    unint64_t v8 = *v7;
    if (v8 > 0x3F || ((1 << v8) & 0x100002600) == 0) {
      break;
    }
    ++v7;
    if (!--v6) {
      goto LABEL_8;
    }
  }
  unint64_t v10 = v7 - v3;
  do
  {
LABEL_10:
    if (!v5)
    {
      float v13 = 0;
      unint64_t v14 = 0;
      goto LABEL_27;
    }
    unint64_t v11 = v3[--v5];
  }
  while (v11 <= 0x3F && ((1 << v11) & 0x100002600) != 0);
  float v13 = 0;
  if (v10 == -1)
  {
    unint64_t v14 = 0;
  }
  else
  {
    unint64_t v14 = 0;
    if (v5 != -1)
    {
      if (v3[v10] == 91 && v3[v5] == 93)
      {
        ++v10;
        --v5;
      }
      BOOL v15 = v4 >= v10;
      unint64_t v16 = v4 - v10;
      if (!v15) {
        abort();
      }
      unint64_t v17 = v5 - v10;
      float v13 = &v3[v10];
      if (v16 >= v17 + 1) {
        unint64_t v14 = v17 + 1;
      }
      else {
        unint64_t v14 = v16;
      }
    }
  }
LABEL_27:
  v22[0] = v13;
  v22[1] = v14;
  double result = md::StyleSettingsParser::parseNextElement((uint64_t)&__p, a1, 0, (uint64_t)v22);
  if (v21)
  {
    if (v20 != 2)
    {
      if (!v20) {
        operator new();
      }
      operator new();
    }
    operator new();
  }
  return result;
}

double md::StyleSettingsParser::parseNextElement(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  memset(v48, 0, 7);
  if (!a3)
  {
    int v13 = 0;
    std::string::size_type __sz = 0;
    __p = 0;
    unint64_t v14 = 0;
    goto LABEL_10;
  }
  unint64_t v7 = *(void *)(a4 + 8);
  if (!v7
    || ((v8 = *(char **)a4, v9 = memchr(*(void **)a4, 58, *(void *)(a4 + 8)), unint64_t v11 = v9 - v8, v9)
      ? (BOOL v12 = v11 == -1)
      : (BOOL v12 = 1),
        v12))
  {
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 48) = 0;
    return result;
  }
  if (v7 >= v11) {
    unint64_t v25 = v9 - v8;
  }
  else {
    unint64_t v25 = v7;
  }
  unint64_t v26 = TrimWhitespace(v8, v25, " \"'\n\r\t");
  if (v27 >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_79;
  }
  unsigned int v28 = v26;
  std::string::size_type v29 = v27;
  if (v27 >= 0x17)
  {
    uint64_t v31 = (v27 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v27 | 7) != 0x17) {
      uint64_t v31 = v27 | 7;
    }
    uint64_t v32 = v31 + 1;
    p_dst = (std::string *)operator new(v31 + 1);
    __dst.__r_.__value_.__l.__size_ = v29;
    __dst.__r_.__value_.__r.__words[2] = v32 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
  }
  else
  {
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v27;
    p_dst = &__dst;
    if (!v27) {
      goto LABEL_54;
    }
  }
  memmove(p_dst, v28, v29);
LABEL_54:
  p_dst->__r_.__value_.__s.__data_[v29] = 0;
  __p = (std::string::value_type *)__dst.__r_.__value_.__r.__words[0];
  v48[0] = __dst.__r_.__value_.__r.__words[2];
  *(_DWORD *)((char *)v48 + 3) = *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[2] + 3);
  std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  int v13 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = __dst.__r_.__value_.__l.__size_;
  }
  if (!size)
  {
    *(unsigned char *)(a2 + 64) = 1;
    goto LABEL_40;
  }
  std::string::size_type __sz = __dst.__r_.__value_.__l.__size_;
  unint64_t v14 = v11 + 1;
LABEL_10:
  uint64_t v44 = a2;
  unint64_t v15 = *(void *)(a4 + 8);
  if (v15 > v14)
  {
    char v16 = 0;
    int v17 = 0;
    int v18 = 0;
    unsigned int v19 = *(char **)a4;
    int64_t v20 = v14;
    while (1)
    {
      int v21 = v19[v20];
      if (v21 <= 90)
      {
        if (v21 == 34 || v21 == 39)
        {
          if (v15 <= v20 + 1) {
            goto LABEL_39;
          }
          unsigned int v23 = memchr(&v19[v20 + 1], v21, v15 - (v20 + 1));
          int64_t v20 = v23 - v19;
          if (!v23 || v20 == -1) {
            goto LABEL_39;
          }
        }
        else if (v21 == 44 && (v18 | v17) == 0)
        {
          goto LABEL_59;
        }
      }
      else
      {
        switch(v19[v20])
        {
          case '[':
            ++v17;
            if (!v16) {
              char v16 = 2;
            }
            break;
          case ']':
            --v17;
            break;
          case '{':
            ++v18;
            if ((v16 & 0xFE) == 0) {
              char v16 = 1;
            }
            break;
          case '}':
            --v18;
            break;
          default:
            break;
        }
      }
      if (++v20 >= v15) {
        goto LABEL_38;
      }
    }
  }
  char v16 = 0;
  int v18 = 0;
  int v17 = 0;
  int64_t v20 = v14;
LABEL_38:
  if (v18 | v17) {
    goto LABEL_39;
  }
LABEL_59:
  if (v15 < v14) {
LABEL_79:
  }
    abort();
  if (v15 - v14 >= v20 - v14) {
    unint64_t v34 = v20 - v14;
  }
  else {
    unint64_t v34 = v15 - v14;
  }
  if (v16) {
    unsigned int v35 = " \n\r\t";
  }
  else {
    unsigned int v35 = " \"'\n\r\t";
  }
  unsigned int v36 = TrimWhitespace((char *)(*(void *)a4 + v14), v34, v35);
  if (!v37)
  {
    std::string::size_type v42 = v13;
    if (v13 < 0) {
      std::string::size_type v42 = __sz;
    }
    if (v42) {
LABEL_39:
    }
      *(unsigned char *)(v44 + 64) = 1;
LABEL_40:
    *(unsigned char *)a1 = 0;
    *(unsigned char *)(a1 + 48) = 0;
    if ((v13 & 0x80000000) == 0) {
      return result;
    }
    goto LABEL_41;
  }
  unsigned int v38 = v36;
  uint64_t v39 = v37;
  unint64_t v40 = *(void *)(a4 + 8);
  if (v20 + 1 < v40) {
    int64_t v41 = v20 + 1;
  }
  else {
    int64_t v41 = *(void *)(a4 + 8);
  }
  *(void *)a4 += v41;
  *(void *)(a4 + 8) = v40 - v41;
  if (v13 < 0)
  {
    std::string::__init_copy_ctor_external(&__dst, __p, __sz);
  }
  else
  {
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)__p;
    __dst.__r_.__value_.__l.__size_ = __sz;
    LODWORD(__dst.__r_.__value_.__r.__words[2]) = v48[0];
    *(_DWORD *)((char *)&__dst.__r_.__value_.__r.__words[2] + 3) = *(_DWORD *)((char *)v48 + 3);
    *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v13;
  }
  *(void *)&long long v47 = v38;
  *((void *)&v47 + 1) = v39;
  *(std::string *)a1 = __dst;
  *(unsigned char *)(a1 + 40) = v16;
  double result = *(double *)&v47;
  *(_OWORD *)(a1 + 24) = v47;
  *(unsigned char *)(a1 + 48) = 1;
  if (v13 < 0) {
LABEL_41:
  }
    operator delete(__p);
  return result;
}

char *TrimWhitespace(char *a1, unint64_t a2, char *__s)
{
  size_t v6 = strlen(__s);
  size_t v7 = v6;
  if (!a2)
  {
    if (!v6) {
      return 0;
    }
    unint64_t v10 = -1;
LABEL_12:
    unint64_t v12 = a2;
    while (v12)
    {
      if (!memchr(__s, a1[--v12], v7))
      {
        uint64_t v11 = (uint64_t)&a1[v12];
        goto LABEL_16;
      }
    }
    return 0;
  }
  unint64_t v8 = a1;
  if (v6)
  {
    unint64_t v9 = a2;
    unint64_t v8 = a1;
    while (memchr(__s, *v8, v7))
    {
      ++v8;
      if (!--v9)
      {
        unint64_t v10 = -1;
        if (v7) {
          goto LABEL_12;
        }
        goto LABEL_9;
      }
    }
  }
  unint64_t v10 = v8 - a1;
  if (v7) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v11 = (uint64_t)&a1[a2 - 1];
LABEL_16:
  double result = 0;
  if (v10 != -1 && v11 - (void)a1 != -1)
  {
    if (a2 < v10) {
      abort();
    }
    return &a1[v10];
  }
  return result;
}

void md::StyleSettingsObjectNode::~StyleSettingsObjectNode(char **this)
{
  *this = (char *)&unk_1EF5440A8;
  std::__tree<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>>>::destroy(this[3]);
  JUMPOUT(0x1A6239270);
}

{
  *this = (char *)&unk_1EF5440A8;
  std::__tree<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>>>::destroy(this[3]);
}

void std::__tree<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::unique_ptr<md::StyleSettingsNode>>>>::destroy(*((void *)a1 + 1));
    uint64_t v2 = *((void *)a1 + 7);
    *((void *)a1 + 7) = 0;
    if (v2) {
      (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
    }
    if (a1[55] < 0) {
      operator delete(*((void **)a1 + 4));
    }
    operator delete(a1);
  }
}

void md::StyleSettingsValueNode::~StyleSettingsValueNode(md::StyleSettingsValueNode *this)
{
}

void md::StyleSettingsParser::StyleSettingsParser(uint64_t a1)
{
  *(void *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 32) = 1;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = &unk_1EF5440A8;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 40) = a1 + 48;
  *(unsigned char *)(a1 + 64) = 0;
  MEMORY[0x1A6239040](&v1);
  uint64_t v2 = std::locale::use_facet(&v1, MEMORY[0x1E4FBA258]);
  size_t v3 = std::locale::use_facet(&v1, MEMORY[0x1E4FBA280]);
  long long v4 = 0u;
  long long v5 = 0u;
  uint64_t v6 = 0;
  std::basic_regex<char,std::regex_traits<char>>::__parse<char const*>();
}

void std::__loop<char>::~__loop(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1EF57F3B0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  size_t v3 = a1[1];
  if (v3) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  }
  JUMPOUT(0x1A6239270);
}

void std::__alternate<char>::~__alternate(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  *a1 = (void (__cdecl **)(std::__owns_one_state<char> *__hidden))&unk_1EF57F3B0;
  uint64_t v2 = a1[2];
  if (v2) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v2 + 1))(v2);
  }
  size_t v3 = a1[1];
  if (v3) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v3 + 1))(v3);
  }
  JUMPOUT(0x1A6239270);
}

void std::__match_char<char>::~__match_char(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  std::locale v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1A6239270);
}

void std::__empty_state<char>::~__empty_state(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  std::locale v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1A6239270);
}

void std::__empty_non_own_state<char>::~__empty_non_own_state()
{
}

void std::__repeat_one_loop<char>::~__repeat_one_loop()
{
}

void std::__match_any_but_newline<char>::~__match_any_but_newline(void (__cdecl ***a1)(std::__owns_one_state<char> *__hidden this))
{
  std::locale v1 = a1[1];
  if (v1) {
    (*((void (**)(void (__cdecl **)(std::__owns_one_state<char> *__hidden)))*v1 + 1))(v1);
  }
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_pointer<std::__empty_state<char> *,std::shared_ptr<std::__empty_state<char>>::__shared_ptr_default_delete<std::__empty_state<char>,std::__empty_state<char>>,std::allocator<std::__empty_state<char>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

void std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(std::locale *a1)
{
  std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(a1);
  JUMPOUT(0x1A6239270);
}

std::locale *std::__bracket_expression<char,std::regex_traits<char>>::~__bracket_expression(std::locale *a1)
{
  locale = a1[17].__locale_;
  if (locale)
  {
    size_t v3 = a1[18].__locale_;
    long long v4 = a1[17].__locale_;
    if (v3 != locale)
    {
      do
      {
        if (*((char *)v3 - 1) < 0) {
          operator delete(*((void **)v3 - 3));
        }
        size_t v3 = (std::locale::__imp *)((char *)v3 - 24);
      }
      while (v3 != locale);
      long long v4 = a1[17].__locale_;
    }
    a1[18].__locale_ = locale;
    operator delete(v4);
  }
  long long v5 = a1[14].__locale_;
  if (v5)
  {
    a1[15].__locale_ = v5;
    operator delete(v5);
  }
  uint64_t v6 = a1[11].__locale_;
  if (v6)
  {
    size_t v7 = a1[12].__locale_;
    unint64_t v8 = a1[11].__locale_;
    if (v7 == v6)
    {
LABEL_21:
      a1[12].__locale_ = v6;
      operator delete(v8);
      goto LABEL_22;
    }
    while (1)
    {
      if (*((char *)v7 - 1) < 0)
      {
        operator delete(*((void **)v7 - 3));
        if (*((char *)v7 - 25) < 0) {
LABEL_19:
        }
          operator delete(*((void **)v7 - 6));
      }
      else if (*((char *)v7 - 25) < 0)
      {
        goto LABEL_19;
      }
      size_t v7 = (std::locale::__imp *)((char *)v7 - 48);
      if (v7 == v6)
      {
        unint64_t v8 = a1[11].__locale_;
        goto LABEL_21;
      }
    }
  }
LABEL_22:
  unint64_t v9 = a1[8].__locale_;
  if (v9)
  {
    a1[9].__locale_ = v9;
    operator delete(v9);
  }
  unint64_t v10 = a1[5].__locale_;
  if (v10)
  {
    a1[6].__locale_ = v10;
    operator delete(v10);
  }
  std::locale::~locale(a1 + 2);
  uint64_t v11 = a1[1].__locale_;
  if (v11) {
    (*(void (**)(std::locale::__imp *))(*(void *)v11 + 8))(v11);
  }
  return a1;
}

void std::regex_replace[abi:nn180100]<std::back_insert_iterator<std::string>,std::__wrap_iter<char const*>,std::regex_traits<char>,char>(std::string *a1, std::sub_match<const char *> *a2, std::sub_match<const char *> *a3, uint64_t a4, const char *a5)
{
  uint64_t v6 = (std::string::value_type *)a2;
  int v47 = 0;
  unsigned int v50 = 0;
  BOOL v51 = 0;
  char v52 = 0;
  unsigned int v53 = 0;
  unsigned int v54 = 0;
  char v55 = 0;
  char v56 = 0;
  uint64_t v57 = 0;
  *(_OWORD *)__p = 0u;
  memset(v49, 0, 25);
  uint64_t v59 = 0;
  uint64_t v60 = 0;
  char v61 = 0;
  uint64_t v62 = 0;
  uint64_t v63 = 0;
  char v64 = 0;
  char v65 = 0;
  uint64_t v66 = 0;
  memset(v58, 0, 41);
  std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a4, a2, a3, v58, 0);
  std::match_results<std::__wrap_iter<char const*>>::__assign[abi:nn180100]<char const*,std::allocator<std::sub_match<char const*>>>((uint64_t)__p, (uint64_t)v6, (uint64_t)a3, (uint64_t *)v58, 0);
  if (v58[0].__begin_) {
    operator delete(v58[0].__begin_);
  }
  unint64_t v8 = (char *)__p[0];
  uint64_t v44 = (char *)__p[1];
  if (__p[1] != __p[0])
  {
    size_t v9 = strlen(a5);
    unint64_t v10 = (unsigned __int8 *)&a5[v9];
    size_t v43 = v9;
    while (1)
    {
      uint64_t v11 = v50;
      unint64_t v12 = v51;
      for (uint64_t i = v50; i != v12; ++i)
        std::string::push_back(a1, *i);
      if (v43)
      {
        unint64_t v15 = v53;
        unint64_t v14 = v54;
        char v16 = a5;
        while (1)
        {
          int v17 = *(unsigned __int8 *)v16;
          if (v17 == 36)
          {
            int v18 = (unsigned __int8 *)(v16 + 1);
            if (v16 + 1 != (const char *)v10)
            {
              int v19 = (char)*v18;
              int v17 = *v18;
              if (v19 > 38)
              {
                if (v19 == 39)
                {
                  if (v15 != v14)
                  {
                    BOOL v33 = v15;
                    do
                      std::string::push_back(a1, *v33++);
                    while (v33 != v14);
                  }
                  goto LABEL_13;
                }
                if (v19 == 96)
                {
                  if (v11 != v12)
                  {
                    unint64_t v22 = v11;
                    do
                      std::string::push_back(a1, *v22++);
                    while (v22 != v12);
                  }
                  goto LABEL_13;
                }
              }
              else
              {
                if (v19 == 36)
                {
                  ++v16;
                  goto LABEL_12;
                }
                if (v19 == 38)
                {
                  int v21 = *(std::string::value_type **)v8;
                  int64_t v20 = (std::string::value_type *)*((void *)v8 + 1);
                  if (*(std::string::value_type **)v8 != v20)
                  {
                    do
                      std::string::push_back(a1, *v21++);
                    while (v21 != v20);
                  }
                  goto LABEL_13;
                }
              }
              if ((v17 - 48) <= 9)
              {
                unint64_t v23 = *v18 - 48;
                if (v16 + 2 != (const char *)v10)
                {
                  uint64_t v24 = *((unsigned __int8 *)v16 + 2);
                  unsigned int v25 = v24 - 48;
                  uint64_t v26 = v24 + 10 * (int)v23 - 48;
                  if (v25 > 9)
                  {
                    int v18 = (unsigned __int8 *)(v16 + 1);
                  }
                  else
                  {
                    unint64_t v23 = v26;
                    int v18 = (unsigned __int8 *)(v16 + 2);
                  }
                }
                unint64_t v27 = (std::string::value_type **)&v8[24 * (int)v23];
                BOOL v28 = 0xAAAAAAAAAAAAAAABLL * ((v44 - v8) >> 3) > v23;
                std::string::size_type v29 = (std::string::value_type **)v49 + 1;
                if (v28) {
                  std::string::size_type v29 = v27;
                }
                int v30 = *v29;
                uint64_t v31 = v27 + 1;
                if (!v28) {
                  uint64_t v31 = (std::string::value_type **)&v49[1];
                }
                for (j = *v31; v30 != j; ++v30)
                  std::string::push_back(a1, *v30);
                goto LABEL_13;
              }
            }
            LOBYTE(v17) = 36;
          }
LABEL_12:
          std::string::push_back(a1, v17);
          int v18 = (unsigned __int8 *)v16;
LABEL_13:
          char v16 = (const char *)(v18 + 1);
          if (v18 + 1 == v10) {
            goto LABEL_47;
          }
        }
      }
      unint64_t v15 = v53;
      unint64_t v14 = v54;
LABEL_47:
      int v34 = v47;
      int v35 = v47 | 0x800;
      v47 |= 0x800u;
      unsigned int v36 = (std::sub_match<const char *> **)v49 + 1;
      if (v44 != v8) {
        unsigned int v36 = (std::sub_match<const char *> **)v8;
      }
      uint64_t v37 = (std::sub_match<const char *> **)(v8 + 8);
      if (v44 == v8) {
        uint64_t v37 = (std::sub_match<const char *> **)&v49[1];
      }
      unsigned int v38 = *v37;
      uint64_t v39 = a3;
      if (*v36 != *v37) {
        goto LABEL_52;
      }
      if (a3 == v38) {
        goto LABEL_61;
      }
      uint64_t v59 = 0;
      uint64_t v60 = 0;
      char v61 = 0;
      uint64_t v62 = 0;
      uint64_t v63 = 0;
      char v64 = 0;
      char v65 = 0;
      uint64_t v66 = 0;
      memset(v58, 0, 41);
      int v41 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a4, v38, a3, v58, v34 | 0x860u);
      std::match_results<std::__wrap_iter<char const*>>::__assign[abi:nn180100]<char const*,std::allocator<std::sub_match<char const*>>>((uint64_t)__p, (uint64_t)v38, (uint64_t)a3, (uint64_t *)v58, 1);
      if (v58[0].__begin_) {
        operator delete(v58[0].__begin_);
      }
      if (!v41) {
        break;
      }
      unint64_t v8 = (char *)__p[0];
LABEL_6:
      uint64_t v44 = (char *)__p[1];
      if (__p[1] == v8)
      {
        while (v15 != v14)
          std::string::push_back(a1, *v15++);
        if (v8) {
          goto LABEL_67;
        }
        return;
      }
    }
    unsigned int v38 = (std::sub_match<const char *> *)((char *)v38 + 1);
    int v35 = v47;
    uint64_t v39 = a3;
LABEL_52:
    int v47 = v35 | 0x80;
    uint64_t v59 = 0;
    uint64_t v60 = 0;
    char v61 = 0;
    uint64_t v62 = 0;
    uint64_t v63 = 0;
    char v64 = 0;
    char v65 = 0;
    uint64_t v66 = 0;
    memset(v58, 0, 41);
    char v40 = std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(a4, v38, v39, v58, v35 | 0x80u);
    std::match_results<std::__wrap_iter<char const*>>::__assign[abi:nn180100]<char const*,std::allocator<std::sub_match<char const*>>>((uint64_t)__p, (uint64_t)v38, (uint64_t)v39, (uint64_t *)v58, (v35 & 0x800) != 0);
    if (v58[0].__begin_) {
      operator delete(v58[0].__begin_);
    }
    unint64_t v8 = (char *)__p[0];
    if (v40) {
      goto LABEL_6;
    }
LABEL_61:
    if (v8) {
      operator delete(v8);
    }
    unint64_t v8 = 0;
    char v56 = 0;
    *(_OWORD *)__p = 0u;
    memset(v49, 0, 25);
    unsigned int v50 = 0;
    BOOL v51 = 0;
    char v52 = 0;
    unsigned int v53 = 0;
    unsigned int v54 = 0;
    char v55 = 0;
    uint64_t v57 = 0;
    goto LABEL_6;
  }
  while (v6 != (std::string::value_type *)a3)
    std::string::push_back(a1, *v6++);
  unint64_t v8 = v44;
  if (v44)
  {
LABEL_67:
    operator delete(v8);
  }
}

void sub_1A17E9F08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p)
{
  unint64_t v27 = *(void **)(v25 - 208);
  if (v27)
  {
    operator delete(v27);
    BOOL v28 = __p;
    if (!__p) {
LABEL_3:
    }
      _Unwind_Resume(exception_object);
  }
  else
  {
    BOOL v28 = __p;
    if (!__p) {
      goto LABEL_3;
    }
  }
  operator delete(v28);
  _Unwind_Resume(exception_object);
}

void std::match_results<std::__wrap_iter<char const*>>::__assign[abi:nn180100]<char const*,std::allocator<std::sub_match<char const*>>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, char a5)
{
  uint64_t v10 = a4[6];
  unint64_t v11 = 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3);
  unint64_t v12 = *(char **)a1;
  int v13 = *(char **)(a1 + 8);
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v13[-*(void *)a1] >> 3);
  unint64_t v15 = v11 - v14;
  if (v11 <= v14)
  {
    if (v11 < v14)
    {
      int v13 = &v12[8 * ((a4[1] - *a4) >> 3)];
      *(void *)(a1 + 8) = v13;
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 16);
    if (0xAAAAAAAAAAAAAAABLL * ((v16 - (uint64_t)v13) >> 3) >= v15)
    {
      unint64_t v22 = &v13[24 * v15];
      uint64_t v27 = 8 * ((a4[1] - *a4) >> 3) - 8 * ((uint64_t)&v13[-*(void *)a1] >> 3);
      do
      {
        *(void *)int v13 = 0;
        *((void *)v13 + 1) = 0;
        uint8_t v13[16] = 0;
        v13 += 24;
        v27 -= 24;
      }
      while (v27);
      *(void *)(a1 + 8) = v22;
    }
    else
    {
      if (v11 > 0xAAAAAAAAAAAAAAALL) {
        abort();
      }
      unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((v16 - (uint64_t)v12) >> 3);
      uint64_t v18 = 2 * v17;
      if (2 * v17 <= v11) {
        uint64_t v18 = 0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3);
      }
      if (v17 >= 0x555555555555555) {
        unint64_t v19 = 0xAAAAAAAAAAAAAAALL;
      }
      else {
        unint64_t v19 = v18;
      }
      if (v19 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int64_t v20 = (char *)operator new(24 * v19);
      int v21 = &v20[24 * v14];
      unint64_t v22 = &v20[24 * v11];
      uint64_t v23 = 24 * v11 - 24 * v14;
      uint64_t v24 = v21;
      do
      {
        *(void *)uint64_t v24 = 0;
        *((void *)v24 + 1) = 0;
        v24[16] = 0;
        v24 += 24;
        v23 -= 24;
      }
      while (v23);
      uint64_t v25 = *(char **)a1;
      if (v13 != *(char **)a1)
      {
        do
        {
          long long v26 = *(_OWORD *)(v13 - 24);
          *((void *)v21 - 1) = *((void *)v13 - 1);
          *(_OWORD *)(v21 - 24) = v26;
          v21 -= 24;
          v13 -= 24;
        }
        while (v13 != v25);
        int v13 = *(char **)a1;
      }
      *(void *)a1 = v21;
      *(void *)(a1 + 8) = v22;
      *(void *)(a1 + 16) = &v20[24 * v19];
      if (v13)
      {
        operator delete(v13);
        unint64_t v22 = *(char **)(a1 + 8);
      }
    }
    unint64_t v12 = *(char **)a1;
    int v13 = v22;
  }
  if (v13 != v12)
  {
    unint64_t v28 = 0;
    unint64_t v29 = 0;
    uint64_t v31 = *a4;
    uint64_t v30 = a4[1];
    do
    {
      unint64_t v32 = 0xAAAAAAAAAAAAAAABLL * ((v30 - v31) >> 3);
      BOOL v33 = (void *)(v31 + v28);
      if (v32 <= v29) {
        int v34 = a4 + 3;
      }
      else {
        int v34 = v33;
      }
      *(void *)&v12[v28] = a2 + *v34 - v10;
      if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) <= v29) {
        int v35 = a4 + 3;
      }
      else {
        int v35 = (uint64_t *)(*a4 + v28);
      }
      *(void *)(*(void *)a1 + v28 + 8) = a2 + v35[1] - v10;
      uint64_t v31 = *a4;
      uint64_t v30 = a4[1];
      if (0xAAAAAAAAAAAAAAABLL * ((v30 - *a4) >> 3) <= v29) {
        unsigned int v36 = a4 + 3;
      }
      else {
        unsigned int v36 = (uint64_t *)(*a4 + v28);
      }
      char v37 = *((unsigned char *)v36 + 16);
      unint64_t v12 = *(char **)a1;
      uint64_t v38 = *(void *)(a1 + 8);
      *(unsigned char *)(*(void *)a1 + v28 + 16) = v37;
      ++v29;
      v28 += 24;
    }
    while (v29 < 0xAAAAAAAAAAAAAAABLL * ((v38 - (uint64_t)v12) >> 3));
  }
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a3;
  *(unsigned char *)(a1 + 40) = 0;
  uint64_t v39 = a2 + a4[6] - v10;
  *(void *)(a1 + 48) = v39;
  *(void *)(a1 + 56) = a2 + a4[7] - v10;
  *(unsigned char *)(a1 + 64) = *((unsigned char *)a4 + 64);
  *(void *)(a1 + 72) = a2 + a4[9] - v10;
  *(void *)(a1 + 80) = a2 + a4[10] - v10;
  *(unsigned char *)(a1 + 88) = *((unsigned char *)a4 + 88);
  if ((a5 & 1) == 0) {
    *(void *)(a1 + 104) = v39;
  }
  *(unsigned char *)(a1 + 96) = *((unsigned char *)a4 + 96);
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__search<std::allocator<std::sub_match<char const*>>>(uint64_t a1, std::sub_match<const char *> *a2, std::sub_match<const char *> *a3, std::vector<std::csub_match> *this, int a5)
{
  if ((a5 & 0x80) != 0) {
    int v9 = a5 & 0xFFA;
  }
  else {
    int v9 = a5;
  }
  int v10 = *(_DWORD *)(a1 + 28);
  this[1].__begin_ = a3;
  unint64_t v11 = (const std::vector<std::csub_match>::value_type *)&this[1];
  this[1].__end_ = a3;
  LOBYTE(this[1].__end_cap_.__value_) = 0;
  std::vector<std::sub_match<char const*>>::assign(this, (v10 + 1), (std::vector<std::csub_match>::const_reference)&this[1]);
  this[2].__begin_ = a2;
  this[2].__end_ = a2;
  LOBYTE(this[2].__end_cap_.__value_) = 0;
  *(std::pair<const char *, const char *> *)&this[3].__begin_ = v11->std::pair<const char *, const char *>;
  LOBYTE(this[3].__end_cap_.__value_) = this[1].__end_cap_.__value_;
  if ((v9 & 0x800) == 0) {
    this[4].__end_ = a2;
  }
  LOBYTE(this[4].__begin_) = 1;
  if ((*(_WORD *)(a1 + 24) & 0x1F0) == 0)
  {
    if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1, (const char *)a2, (const char *)a3, (uint64_t *)this, v9, (v9 & 0x800) == 0))goto LABEL_28; {
    goto LABEL_13;
    }
  }
  if (*(_DWORD *)(a1 + 28))
  {
    if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(a1, (const char *)a2, (const char *)a3, (uint64_t *)this, v9, (v9 & 0x800) == 0))goto LABEL_28; {
LABEL_13:
    }
    if (a2 != a3 && (v9 & 0x40) == 0)
    {
      int v12 = v9 | 0x80;
      for (uint64_t i = (char *)&a2->first + 1; i != (const char *)a3; ++i)
      {
        std::vector<std::sub_match<char const*>>::assign(this, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3), v11);
        if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0)
        {
          if (*(_DWORD *)(a1 + 28))
          {
            if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(a1, i, (const char *)a3, (uint64_t *)this, v12, 0))goto LABEL_28; {
          }
            }
          else if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(a1, (uint64_t)i, (uint64_t)a3, (uint64_t *)this, v12, 0))
          {
            goto LABEL_28;
          }
        }
        else if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1, i, (const char *)a3, (uint64_t *)this, v12, 0))
        {
          goto LABEL_28;
        }
        std::vector<std::sub_match<char const*>>::assign(this, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3), v11);
      }
      std::vector<std::sub_match<char const*>>::assign(this, 0xAAAAAAAAAAAAAAABLL * (((char *)this->__end_ - (char *)this->__begin_) >> 3), v11);
      if ((*(_WORD *)(a1 + 24) & 0x1F0) != 0)
      {
        if (*(_DWORD *)(a1 + 28))
        {
          if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_subs<std::allocator<std::sub_match<char const*>>>(a1, (const char *)a3, (const char *)a3, (uint64_t *)this, v12, 0))goto LABEL_28; {
        }
          }
        else if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(a1, (uint64_t)a3, (uint64_t)a3, (uint64_t *)this, v12, 0))
        {
          goto LABEL_28;
        }
      }
      else if (std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(a1, (const char *)a3, (const char *)a3, (uint64_t *)this, v12, 0))
      {
        goto LABEL_28;
      }
    }
    uint64_t result = 0;
    this->__end_ = this->__begin_;
    return result;
  }
  if ((std::basic_regex<char,std::regex_traits<char>>::__match_at_start_posix_nosubs<std::allocator<std::sub_match<char const*>>>(a1, (uint64_t)a2, (uint64_t)a3, (uint64_t *)this, v9, (v9 & 0x800) == 0) & 1) == 0)goto LABEL_13; {
LABEL_28:
  }
  if (this->__end_ == this->__begin_) {
    std::vector<std::csub_match>::pointer begin = (std::vector<std::csub_match>::pointer)v11;
  }
  else {
    std::vector<std::csub_match>::pointer begin = this->__begin_;
  }
  first = (std::sub_match<const char *> *)begin->first;
  this[2].__end_ = (std::vector<std::csub_match>::pointer)begin->first;
  LOBYTE(this[2].__end_cap_.__value_) = this[2].__begin_ != first;
  second = (std::sub_match<const char *> *)begin->second;
  this[3].__begin_ = second;
  LOBYTE(this[3].__end_cap_.__value_) = second != this[3].__end_;
  return 1;
}

void std::vector<std::sub_match<char const*>>::assign(std::vector<std::csub_match> *this, std::vector<std::csub_match>::size_type __n, std::vector<std::csub_match>::const_reference __u)
{
  value = this->__end_cap_.__value_;
  std::vector<std::csub_match>::pointer begin = this->__begin_;
  if (0xAAAAAAAAAAAAAAABLL * (((char *)value - (char *)begin) >> 3) < __n)
  {
    if (begin)
    {
      this->__end_ = begin;
      operator delete(begin);
      value = 0;
      this->__begin_ = 0;
      this->__end_ = 0;
      this->__end_cap_.__value_ = 0;
    }
    if (__n > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_26;
    }
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)value >> 3);
    std::vector<std::csub_match>::size_type v9 = 2 * v8;
    if (2 * v8 <= __n) {
      std::vector<std::csub_match>::size_type v9 = __n;
    }
    unint64_t v10 = v8 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v9;
    if (v10 > 0xAAAAAAAAAAAAAAALL) {
LABEL_26:
    }
      abort();
    uint64_t v11 = v10;
    int v12 = (std::sub_match<const char *> *)operator new(24 * v10);
    this->__begin_ = v12;
    this->__end_ = v12;
    this->__end_cap_.__value_ = &v12[v11];
    std::vector<std::csub_match>::size_type v13 = 24 * __n;
    unint64_t v14 = &v12[__n];
    do
    {
      v12->std::pair<const char *, const char *> = __u->std::pair<const char *, const char *>;
      *(void *)&v12->matched = *(void *)&__u->matched;
      ++v12;
      v13 -= 24;
    }
    while (v13);
    goto LABEL_25;
  }
  std::vector<std::csub_match>::pointer end = this->__end_;
  unint64_t v16 = end - begin;
  if (v16 >= __n) {
    std::vector<std::csub_match>::size_type v17 = __n;
  }
  else {
    std::vector<std::csub_match>::size_type v17 = end - begin;
  }
  if (v17)
  {
    uint64_t v18 = begin;
    do
    {
      *v18++ = *__u;
      --v17;
    }
    while (v17);
  }
  if (__n <= v16)
  {
    unint64_t v14 = &begin[__n];
LABEL_25:
    this->__end_ = v14;
    return;
  }
  unint64_t v19 = &end[__n - v16];
  std::vector<std::csub_match>::size_type v20 = 24 * __n - 24 * v16;
  do
  {
    std::pair<const char *, const char *> v21 = __u->std::pair<const char *, const char *>;
    *(void *)&end->matched = *(void *)&__u->matched;
    end->std::pair<const char *, const char *> = v21;
    ++end;
    v20 -= 24;
  }
  while (v20);
  this->__end_ = v19;
}

uint64_t std::basic_regex<char,std::regex_traits<char>>::__match_at_start_ecma<std::allocator<std::sub_match<char const*>>>(uint64_t a1, const char *a2, const char *a3, uint64_t *a4, int a5, char a6)
{
  char v65 = 0;
  uint64_t v66 = 0;
  unint64_t v67 = 0;
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6) {
    return v6;
  }
  __x.first = a3;
  __x.second = a3;
  __x.matched = 0;
  *(_DWORD *)char v61 = 0;
  memset(&v61[8], 0, 48);
  *(_OWORD *)__p = 0u;
  memset(v63, 0, 21);
  uint64_t v11 = std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((void **)&v65, (uint64_t)v61);
  uint64_t v66 = v11;
  if (__p[0]) {
    operator delete(__p[0]);
  }
  if (*(void *)&v61[32]) {
    operator delete(*(void **)&v61[32]);
  }
  uint64_t v12 = *((void *)v11 - 8);
  *((_DWORD *)v11 - 24) = 0;
  *((void *)v11 - 11) = a2;
  *((void *)v11 - 10) = a2;
  *((void *)v11 - 9) = a3;
  unint64_t v13 = *(unsigned int *)(a1 + 28);
  unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((*((void *)v11 - 7) - v12) >> 3);
  if (v13 <= v14)
  {
    if (v13 < v14) {
      *((void *)v11 - 7) = v12 + 24 * v13;
    }
  }
  else
  {
    std::vector<std::sub_match<char const*>>::__append((std::vector<std::csub_match> *)(v11 - 64), v13 - v14, &__x);
  }
  uint64_t v15 = *((void *)v11 - 5);
  unint64_t v16 = *(unsigned int *)(a1 + 32);
  unint64_t v17 = (*((void *)v11 - 4) - v15) >> 4;
  if (v16 <= v17)
  {
    if (v16 < v17) {
      *((void *)v11 - 4) = v15 + 16 * v16;
    }
  }
  else
  {
    std::vector<geo::Mercator2<double>>::__append((std::vector<std::pair<unsigned long, const char *>> *)(v11 - 40), v16 - v17);
  }
  uint64_t v57 = a4;
  unint64_t v58 = a3;
  uint64_t v18 = (a3 - a2);
  *((void *)v11 - 2) = v6;
  __int16 v19 = a5;
  *((_DWORD *)v11 - 2) = a5;
  *(v11 - 4) = a6;
  unsigned int v20 = 1;
  while (2)
  {
    if ((v20 & 0xFFF) != 0 || (int)(v20 >> 12) < (int)v18)
    {
      uint64_t v23 = v11 - 16;
      uint64_t v22 = *((void *)v11 - 2);
      uint64_t v24 = v11 - 96;
      if (v22) {
        (*(void (**)(uint64_t, char *))(*(void *)v22 + 16))(v22, v11 - 96);
      }
      switch(*(_DWORD *)v24)
      {
        case 0xFFFFFC18:
          uint64_t v25 = (const char *)*((void *)v11 - 10);
          if ((v19 & 0x20) != 0 && v25 == a2 || (v19 & 0x1000) != 0 && v25 != v58) {
            goto LABEL_26;
          }
          uint64_t v48 = *v57;
          *(void *)uint64_t v48 = a2;
          *(void *)(v48 + 8) = v25;
          *(unsigned char *)(v48 + 16) = 1;
          uint64_t v49 = *((void *)v11 - 8);
          uint64_t v50 = *((void *)v11 - 7) - v49;
          if (v50)
          {
            unint64_t v51 = 0xAAAAAAAAAAAAAAABLL * (v50 >> 3);
            char v52 = (unsigned char *)(v49 + 16);
            unsigned int v53 = 1;
            do
            {
              uint64_t v54 = v48 + 24 * v53;
              *(_OWORD *)uint64_t v54 = *((_OWORD *)v52 - 1);
              char v55 = *v52;
              v52 += 24;
              *(unsigned char *)(v54 + 16) = v55;
            }
            while (v51 > v53++);
          }
          uint64_t v6 = 1;
          std::pair<const char *, const char *> v21 = v65;
          if (!v65) {
            return v6;
          }
          goto LABEL_43;
        case 0xFFFFFC1D:
        case 0xFFFFFC1E:
        case 0xFFFFFC21:
          goto LABEL_16;
        case 0xFFFFFC1F:
LABEL_26:
          long long v26 = v66;
          uint64_t v27 = (void *)*((void *)v66 - 5);
          if (v27)
          {
            *((void *)v66 - 4) = v27;
            operator delete(v27);
          }
          unint64_t v28 = (void *)*((void *)v26 - 8);
          if (v28)
          {
            *((void *)v26 - 7) = v28;
            operator delete(v28);
          }
          uint64_t v66 = v26 - 96;
          goto LABEL_16;
        case 0xFFFFFC20:
          uint64_t v29 = v18;
          long long v30 = *((_OWORD *)v11 - 5);
          *(_OWORD *)char v61 = *(_OWORD *)v24;
          *(_OWORD *)&v61[16] = v30;
          memset(&v61[32], 0, 24);
          unint64_t v32 = (unsigned char *)*((void *)v11 - 8);
          uint64_t v31 = (unsigned char *)*((void *)v11 - 7);
          int64_t v33 = v31 - v32;
          if (v31 != v32)
          {
            if (0xAAAAAAAAAAAAAAABLL * (v33 >> 3) >= 0xAAAAAAAAAAAAAABLL) {
              abort();
            }
            int v34 = (char *)operator new(v33);
            *(void *)&v61[32] = v34;
            *(void *)&v61[40] = v34;
            *(void *)&v61[48] = &v34[8 * (v33 >> 3)];
            size_t v35 = 24 * ((v33 - 24) / 0x18uLL) + 24;
            memcpy(v34, v32, v35);
            *(void *)&v61[40] = &v34[v35];
            __int16 v19 = a5;
          }
          __p[0] = 0;
          __p[1] = 0;
          v63[0] = 0;
          char v37 = (unsigned char *)*((void *)v11 - 5);
          unsigned int v36 = (unsigned char *)*((void *)v11 - 4);
          uint64_t v38 = v36 - v37;
          if (v36 != v37)
          {
            if (v38 < 0) {
              abort();
            }
            uint64_t v39 = (char *)operator new(v36 - v37);
            __p[0] = v39;
            __p[1] = v39;
            v63[0] = &v39[16 * (v38 >> 4)];
            memcpy(v39, v37, v38 & 0xFFFFFFFFFFFFFFF0);
            __p[1] = &v39[v38 & 0xFFFFFFFFFFFFFFF0];
          }
          uint64_t v40 = *(void *)v23;
          *(void *)((char *)&v63[1] + 5) = *(void *)(v23 + 5);
          v63[1] = v40;
          (*(void (**)(void, uint64_t, char *))(**(void **)v23 + 24))(*(void *)v23, 1, v24);
          uint64_t v18 = v29;
          (*(void (**)(void, void, unsigned char *))(*(void *)v63[1] + 24))(v63[1], 0, v61);
          int v41 = v66;
          if ((unint64_t)v66 >= v67)
          {
            uint64_t v66 = std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>((void **)&v65, (uint64_t)v61);
            if (__p[0])
            {
              __p[1] = __p[0];
              operator delete(__p[0]);
            }
          }
          else
          {
            long long v42 = *(_OWORD *)&v61[16];
            *(_OWORD *)uint64_t v66 = *(_OWORD *)v61;
            *((_OWORD *)v41 + 1) = v42;
            *((void *)v41 + 4) = 0;
            *((void *)v41 + 5) = 0;
            *((void *)v41 + 6) = 0;
            *((void *)v41 + 7) = 0;
            *((_OWORD *)v41 + 2) = *(_OWORD *)&v61[32];
            *((void *)v41 + 6) = *(void *)&v61[48];
            memset(&v61[32], 0, 24);
            *((void *)v41 + 8) = 0;
            *((void *)v41 + 9) = 0;
            *(_OWORD *)(v41 + 56) = *(_OWORD *)__p;
            *((void *)v41 + 9) = v63[0];
            __p[0] = 0;
            __p[1] = 0;
            v63[0] = 0;
            uint64_t v43 = v63[1];
            *(void *)(v41 + 85) = *(void *)((char *)&v63[1] + 5);
            *((void *)v41 + 10) = v43;
            uint64_t v66 = v41 + 96;
          }
          if (*(void *)&v61[32])
          {
            *(void *)&v61[40] = *(void *)&v61[32];
            operator delete(*(void **)&v61[32]);
          }
LABEL_16:
          std::pair<const char *, const char *> v21 = v65;
          uint64_t v11 = v66;
          ++v20;
          if (v65 != v66) {
            continue;
          }
          uint64_t v6 = 0;
          if (v65)
          {
LABEL_43:
            for (uint64_t i = v66; i != v21; i -= 96)
            {
              unsigned int v45 = (void *)*((void *)i - 5);
              if (v45)
              {
                *((void *)i - 4) = v45;
                operator delete(v45);
              }
              unsigned int v46 = (void *)*((void *)i - 8);
              if (v46)
              {
                *((void *)i - 7) = v46;
                operator delete(v46);
              }
            }
            operator delete(v21);
          }
          break;
        default:
          goto LABEL_57;
      }
      return v6;
    }
    break;
  }
LABEL_57:
  uint64_t result = std::__throw_regex_error[abi:nn180100]<(std::regex_constants::error_type)12>();
  __break(1u);
  return result;
}

void sub_1A17EAC34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20)
{
  std::vector<std::__state<char>>::~vector[abi:nn180100]((void **)(v20 - 112));
  _Unwind_Resume(a1);
}

uint64_t std::__alternate<char>::__exec_split(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  uint64_t v3 = 8;
  if (a2) {
    uint64_t v3 = 16;
  }
  *(void *)(a3 + 80) = *(void *)(result + v3);
  return result;
}

uint64_t std::__match_char<char>::__exec(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 **)(a2 + 16);
  if (v2 == *(unsigned __int8 **)(a2 + 24) || *v2 != *(unsigned __int8 *)(result + 16))
  {
    *(_DWORD *)a2 = -993;
    *(void *)(a2 + 80) = 0;
  }
  else
  {
    *(_DWORD *)a2 = -995;
    *(void *)(a2 + 16) = v2 + 1;
    *(void *)(a2 + 80) = *(void *)(result + 8);
  }
  return result;
}

char *std::vector<std::__state<char>>::__push_back_slow_path<std::__state<char>>(void **a1, uint64_t a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 5);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0x2AAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 5) >= 0x155555555555555) {
    unint64_t v6 = 0x2AAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0x2AAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    size_t v7 = (char *)operator new(96 * v6);
  }
  else
  {
    size_t v7 = 0;
  }
  long long v8 = *(_OWORD *)(a2 + 16);
  std::vector<std::csub_match>::size_type v9 = &v7[96 * v2];
  *(_OWORD *)std::vector<std::csub_match>::size_type v9 = *(_OWORD *)a2;
  *((_OWORD *)v9 + 1) = v8;
  unint64_t v10 = &v7[96 * v6];
  *((_OWORD *)v9 + 2) = *(_OWORD *)(a2 + 32);
  *((void *)v9 + 6) = *(void *)(a2 + 48);
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  *(void *)(v9 + 85) = *(void *)(a2 + 85);
  uint64_t v11 = *(void *)(a2 + 72);
  uint64_t v12 = *(void *)(a2 + 80);
  *((void *)v9 + 9) = 0;
  *((void *)v9 + 10) = v12;
  *(_OWORD *)(v9 + 56) = *(_OWORD *)(a2 + 56);
  *((void *)v9 + 9) = v11;
  *(void *)(a2 + 64) = 0;
  *(void *)(a2 + 72) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  unint64_t v13 = v9 + 96;
  unint64_t v14 = (char *)*a1;
  uint64_t v15 = (char *)a1[1];
  if (v15 == *a1)
  {
    *a1 = v9;
    a1[1] = v13;
    a1[2] = v10;
  }
  else
  {
    uint64_t v16 = 0;
    do
    {
      unint64_t v17 = &v9[v16];
      uint64_t v18 = &v15[v16];
      long long v19 = *(_OWORD *)&v15[v16 - 80];
      *((_OWORD *)v17 - 6) = *(_OWORD *)&v15[v16 - 96];
      *((_OWORD *)v17 - 5) = v19;
      *((void *)v17 - 7) = 0;
      *((void *)v17 - 6) = 0;
      *((_OWORD *)v17 - 4) = *(_OWORD *)&v15[v16 - 64];
      *((void *)v17 - 6) = *(void *)&v15[v16 - 48];
      *((void *)v18 - 8) = 0;
      *((void *)v18 - 7) = 0;
      *((void *)v18 - 6) = 0;
      *((void *)v17 - 4) = 0;
      *((void *)v17 - 3) = 0;
      *(_OWORD *)(v17 - 40) = *(_OWORD *)&v15[v16 - 40];
      *((void *)v17 - 3) = *(void *)&v15[v16 - 24];
      *((void *)v18 - 5) = 0;
      *((void *)v18 - 4) = 0;
      *((void *)v18 - 3) = 0;
      uint64_t v20 = *(void *)&v15[v16 - 16];
      *(void *)(v17 - 11) = *(void *)&v15[v16 - 11];
      *((void *)v17 - 2) = v20;
      v16 -= 96;
    }
    while (&v15[v16] != v14);
    uint64_t v15 = (char *)*a1;
    std::pair<const char *, const char *> v21 = (char *)a1[1];
    *a1 = &v9[v16];
    a1[1] = v13;
    a1[2] = v10;
    while (v21 != v15)
    {
      uint64_t v22 = (void *)*((void *)v21 - 5);
      if (v22)
      {
        *((void *)v21 - 4) = v22;
        operator delete(v22);
      }
      uint64_t v23 = (void *)*((void *)v21 - 8);
      if (v23)
      {
        *((void *)v21 - 7) = v23;
        operator delete(v23);
      }
      v21 -= 96;
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

void std::__empty_state<char>::__exec(const std::__empty_state<char> *this, std::__empty_state<char>::__state *a2)
{
  a2->__do_ = -994;
  a2->__node_ = this->__first_;
}

void std::__alternate<char>::__exec(uint64_t a1, _DWORD *a2)
{
  *a2 = -992;
}

void std::vector<geo::Mercator2<double>>::__append(std::vector<std::pair<unsigned long, const char *>> *this, std::vector<std::pair<unsigned long, const char *>>::size_type __n)
{
  std::vector<std::csub_match>::pointer end = this->__end_;
  value = this->__end_cap_.__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      std::vector<std::pair<unsigned long, const char *>>::size_type v12 = 16 * __n;
      bzero(this->__end_, 16 * __n);
      std::vector<std::csub_match>::pointer end = (std::pair<unsigned long, const char *> *)((char *)end + v12);
    }
    this->__end_ = end;
  }
  else
  {
    std::vector<std::pair<unsigned long, const char *>>::pointer begin = this->__begin_;
    uint64_t v7 = end - this->__begin_;
    unint64_t v8 = v7 + __n;
    if ((v7 + __n) >> 60) {
      abort();
    }
    uint64_t v9 = (char *)value - (char *)begin;
    if (v9 >> 3 > v8) {
      unint64_t v8 = v9 >> 3;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v10 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 >> 60) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v11 = (char *)operator new(16 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    unint64_t v13 = (std::pair<unsigned long, const char *> *)&v11[16 * v7];
    size_t v14 = __n;
    uint64_t v15 = (std::pair<unsigned long, const char *> *)&v11[16 * v10];
    bzero(v13, v14 * 16);
    uint64_t v16 = &v13[v14];
    if (end != begin)
    {
      do
      {
        v13[-1] = end[-1];
        --v13;
        --end;
      }
      while (end != begin);
      std::vector<std::csub_match>::pointer end = this->__begin_;
    }
    this->__begin_ = v13;
    this->__end_ = v16;
    this->__end_cap_.__value_ = v15;
    if (end)
    {
      operator delete(end);
    }
  }
}

uint64_t std::__loop<char>::__exec_split(uint64_t result, int a2, uint64_t a3)
{
  *(_DWORD *)a3 = -994;
  if (*(unsigned __int8 *)(result + 52) == a2)
  {
    *(void *)(a3 + 80) = *(void *)(result + 16);
    return result;
  }
  *(void *)(a3 + 80) = *(void *)(result + 8);
  int v3 = *(_DWORD *)(result + 44);
  *(void *)(*(void *)(a3 + 56) + 16 * *(unsigned int *)(result + 40) + 8) = *(void *)(a3 + 16);
  int v4 = *(_DWORD *)(result + 48);
  if (v3 != v4)
  {
    uint64_t v5 = (v4 - 1);
    uint64_t v6 = (v3 - 1);
    uint64_t v7 = *(void *)(a3 + 24);
    uint64_t v8 = *(void *)(a3 + 32);
    uint64_t v9 = v5 - v6;
    if ((unint64_t)(v5 - v6) < 2) {
      goto LABEL_9;
    }
    unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFFELL;
    uint64_t v11 = v8 + 24 * v6 + 24;
    unint64_t v12 = v9 & 0xFFFFFFFFFFFFFFFELL;
    do
    {
      *(void *)(v11 - 24) = v7;
      *(void *)(v11 - 16) = v7;
      *(void *)uint64_t v11 = v7;
      *(void *)(v11 + 8) = v7;
      *(unsigned char *)(v11 - 8) = 0;
      *(unsigned char *)(v11 + 16) = 0;
      v11 += 48;
      v12 -= 2;
    }
    while (v12);
    if (v9 != v10)
    {
      v6 += v10;
LABEL_9:
      uint64_t v13 = v5 - v6;
      size_t v14 = (unsigned char *)(v8 + 24 * v6 + 16);
      do
      {
        *((void *)v14 - 2) = v7;
        *((void *)v14 - 1) = v7;
        *size_t v14 = 0;
        v14 += 24;
        --v13;
      }
      while (v13);
    }
  }
  return result;
}

uint64_t std::__loop<char>::__exec(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(unsigned int *)(result + 40);
  uint64_t v3 = *(void *)(a2 + 56);
  int v4 = (unint64_t *)(v3 + 16 * v2);
  if (*(_DWORD *)a2 != -991)
  {
    *int v4 = 0;
    if (!*(void *)(result + 32))
    {
      *(_DWORD *)a2 = -994;
      goto LABEL_40;
    }
    if (*(void *)(result + 24))
    {
      *(_DWORD *)a2 = -994;
      *(void *)(a2 + 80) = *(void *)(result + 8);
      *(void *)(v3 + 16 * v2 + 8) = *(void *)(a2 + 16);
      int v24 = *(_DWORD *)(result + 44);
      int v25 = *(_DWORD *)(result + 48);
      if (v24 == v25) {
        return result;
      }
      uint64_t v26 = (v25 - 1);
      uint64_t v27 = (v24 - 1);
      uint64_t v28 = *(void *)(a2 + 24);
      uint64_t v29 = *(void *)(a2 + 32);
      uint64_t v30 = v26 - v27;
      if ((unint64_t)(v26 - v27) >= 2)
      {
        unint64_t v31 = v30 & 0xFFFFFFFFFFFFFFFELL;
        uint64_t v32 = v29 + 24 * v27 + 24;
        unint64_t v33 = v30 & 0xFFFFFFFFFFFFFFFELL;
        do
        {
          *(void *)(v32 - 24) = v28;
          *(void *)(v32 - 16) = v28;
          *(void *)uint64_t v32 = v28;
          *(void *)(v32 + 8) = v28;
          *(unsigned char *)(v32 - 8) = 0;
          *(unsigned char *)(v32 + 16) = 0;
          v32 += 48;
          v33 -= 2;
        }
        while (v33);
        if (v30 == v31) {
          return result;
        }
        v27 += v31;
      }
      uint64_t v34 = v26 - v27;
      size_t v35 = (unsigned char *)(v29 + 24 * v27 + 16);
      do
      {
        *((void *)v35 - 2) = v28;
        *((void *)v35 - 1) = v28;
        unsigned char *v35 = 0;
        v35 += 24;
        --v34;
      }
      while (v34);
      return result;
    }
LABEL_38:
    *(_DWORD *)a2 = -992;
    return result;
  }
  unint64_t v5 = *v4 + 1;
  *int v4 = v5;
  unint64_t v6 = *(void *)(result + 24);
  unint64_t v7 = *(void *)(result + 32);
  BOOL v8 = v5 < v7;
  if (v5 < v7 && v5 >= v6) {
    BOOL v8 = v5 < v7 && *(void *)(v3 + 16 * v2 + 8) != *(void *)(a2 + 16);
  }
  if (v8 && v5 >= v6) {
    goto LABEL_38;
  }
  *(_DWORD *)a2 = -994;
  if (!v8)
  {
LABEL_40:
    *(void *)(a2 + 80) = *(void *)(result + 16);
    return result;
  }
  *(void *)(a2 + 80) = *(void *)(result + 8);
  *(void *)(v3 + 16 * v2 + 8) = *(void *)(a2 + 16);
  int v12 = *(_DWORD *)(result + 44);
  int v13 = *(_DWORD *)(result + 48);
  if (v12 == v13) {
    return result;
  }
  uint64_t v14 = (v13 - 1);
  uint64_t v15 = (v12 - 1);
  uint64_t v16 = *(void *)(a2 + 24);
  uint64_t v17 = *(void *)(a2 + 32);
  uint64_t v18 = v14 - v15;
  if ((unint64_t)(v14 - v15) < 2) {
    goto LABEL_24;
  }
  unint64_t v19 = v18 & 0xFFFFFFFFFFFFFFFELL;
  uint64_t v20 = v17 + 24 * v15 + 24;
  unint64_t v21 = v18 & 0xFFFFFFFFFFFFFFFELL;
  do
  {
    *(void *)(v20 - 24) = v16;
    *(void *)(v20 - 16) = v16;
    *(void *)uint64_t v20 = v16;
    *(void *)(v20 + 8) = v16;
    *(unsigned char *)(v20 - 8) = 0;
    *(unsigned char *)(v20 + 16) = 0;
    v20 += 48;
    v21 -= 2;
  }
  while (v21);
  if (v18 != v19)
  {
    v15 += v19;
LABEL_24:
    uint64_t v22 = v14 - v15;
    uint64_t v23 = (unsigned char *)(v17 + 24 * v15 + 16);
    do
    {
      *((void *)v23 - 2) = v16;
      *((void *)v23 - 1) = v16;
      *uint64_t v23 = 0;
      v23 += 24;
      --v22;
    }
    while (v22);
  }
  return result;
}

void std::__bracket_expression<char,std::regex_traits<char>>::__exec(const std::__bracket_expression<char, std::regex_traits<char>> *this, std::__bracket_expression<char, std::regex_traits<char>>::__state *a2)
{
  uint64_t v2 = a2;
  current = a2->__current_;
  last = a2->__last_;
  if (current == last)
  {
    uint64_t v10 = 0;
    BOOL negate = this->__negate_;
    goto LABEL_261;
  }
  if (!this->__might_have_digraph_ || current + 1 == last) {
    goto LABEL_41;
  }
  char v6 = *current;
  LOBYTE(__src) = *current;
  char v7 = current[1];
  HIBYTE(__src) = v7;
  if (this->__icase_)
  {
    LOBYTE(__src) = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, v6);
    HIBYTE(__src) = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, v7);
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
  LOWORD(__s.__r_.__value_.__l.__data_) = __src;
  __s.__r_.__value_.__s.__data_[2] = 0;
  std::__get_collation_name(&v138, (const char *)&__s);
  std::string __p = v138;
  std::string::size_type size = HIBYTE(v138.__r_.__value_.__r.__words[2]);
  int v9 = SHIBYTE(v138.__r_.__value_.__r.__words[2]);
  if ((v138.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type size = v138.__r_.__value_.__l.__size_;
  }
  if (size) {
    goto LABEL_9;
  }
  if ((SHIBYTE(__s.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (HIBYTE(__s.__r_.__value_.__r.__words[2]) >= 3u) {
      goto LABEL_14;
    }
    goto LABEL_164;
  }
  if (__s.__r_.__value_.__l.__size_ < 3)
  {
LABEL_164:
    (*(void (**)(std::string *__return_ptr))(*(void *)this->__traits_.__col_ + 32))(&v138);
    if (v9 < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    std::string __p = v138;
    if (SHIBYTE(v138.__r_.__value_.__r.__words[2]) < 0)
    {
      if (__p.__r_.__value_.__l.__size_ == 1 || __p.__r_.__value_.__l.__size_ == 12)
      {
        if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_s = &__s;
        }
        else {
          p_s = (std::string *)__s.__r_.__value_.__r.__words[0];
        }
        if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          size_t v89 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
        }
        else {
          size_t v89 = __s.__r_.__value_.__l.__size_;
        }
        std::string::__assign_no_alias<false>((void **)&__p.__r_.__value_.__l.__data_, p_s, v89);
      }
      else
      {
        *__p.__r_.__value_.__l.__data_ = 0;
        __p.__r_.__value_.__l.__size_ = 0;
      }
    }
    else if (HIBYTE(v138.__r_.__value_.__r.__words[2]) == 1 || HIBYTE(v138.__r_.__value_.__r.__words[2]) == 12)
    {
      if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
        std::string::__assign_no_alias<true>(&__p, __s.__r_.__value_.__l.__data_, __s.__r_.__value_.__l.__size_);
      }
      else {
        std::string __p = __s;
      }
    }
    else
    {
      __p.__r_.__value_.__s.__data_[0] = 0;
      *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
    }
  }
LABEL_9:
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
LABEL_14:
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::size_type v28 = __p.__r_.__value_.__l.__size_;
    operator delete(__p.__r_.__value_.__l.__data_);
    if (v28) {
      goto LABEL_16;
    }
LABEL_41:
    BOOL negate = 0;
    uint64_t v10 = 1;
    goto LABEL_42;
  }
  if (!*((unsigned char *)&__p.__r_.__value_.__s + 23)) {
    goto LABEL_41;
  }
LABEL_16:
  std::vector<std::pair<char, char>>::pointer begin = this->__digraphs_.__begin_;
  uint64_t v13 = (char *)this->__digraphs_.__end_ - (char *)begin;
  if (v13)
  {
    uint64_t v14 = v13 >> 1;
    if ((unint64_t)(v13 >> 1) <= 1) {
      uint64_t v14 = 1;
    }
    p_second = &begin->second;
    while (__src != *(p_second - 1) || HIBYTE(__src) != *p_second)
    {
      p_second += 2;
      if (!--v14) {
        goto LABEL_25;
      }
    }
    goto LABEL_258;
  }
LABEL_25:
  if (!this->__collate_ || this->__ranges_.__begin_ == this->__ranges_.__end_)
  {
    BOOL negate = 0;
    goto LABEL_197;
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 2;
  LOWORD(__s.__r_.__value_.__l.__data_) = __src;
  __s.__r_.__value_.__s.__data_[2] = 0;
  (*(void (**)(std::string *__return_ptr))(*(void *)this->__traits_.__col_ + 32))(&v138);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  std::vector<std::pair<std::string, std::string>>::pointer v17 = this->__ranges_.__begin_;
  char v18 = HIBYTE(v138.__r_.__value_.__r.__words[2]);
  int64_t v19 = (char *)this->__ranges_.__end_ - (char *)v17;
  if (!v19)
  {
    BOOL v27 = 0;
    int v70 = 0;
    int v69 = 0;
    goto LABEL_194;
  }
  unsigned int v129 = v2;
  uint64_t v20 = 0;
  unint64_t v21 = v19 / 48;
  if ((v138.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    uint64_t v22 = &v138;
  }
  else {
    uint64_t v22 = (std::string *)v138.__r_.__value_.__r.__words[0];
  }
  char v23 = HIBYTE(v138.__r_.__value_.__r.__words[2]);
  if ((v138.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v24 = HIBYTE(v138.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v24 = v138.__r_.__value_.__l.__size_;
  }
  if (v21 <= 1) {
    uint64_t v25 = 1;
  }
  else {
    uint64_t v25 = v19 / 48;
  }
  uint64_t v26 = (unsigned __int8 *)&v17->second.__r_.__value_.__r.__words[2] + 7;
  BOOL v27 = 1;
  do
  {
    int v59 = (char)*(v26 - 24);
    if (v59 >= 0) {
      uint64_t v60 = (char *)(v26 - 47);
    }
    else {
      uint64_t v60 = *(char **)(v26 - 47);
    }
    if (v59 >= 0) {
      size_t v61 = *(v26 - 24);
    }
    else {
      size_t v61 = *(void *)(v26 - 39);
    }
    if (v24 >= v61) {
      size_t v62 = v61;
    }
    else {
      size_t v62 = v24;
    }
    int v63 = memcmp(v60, v22, v62);
    if (v63)
    {
      if ((v63 & 0x80000000) == 0) {
        goto LABEL_103;
      }
    }
    else if (v61 > v24)
    {
      goto LABEL_103;
    }
    int v64 = (char)*v26;
    if (v64 >= 0) {
      char v65 = (char *)(v26 - 23);
    }
    else {
      char v65 = *(char **)(v26 - 23);
    }
    if (v64 >= 0) {
      size_t v66 = *v26;
    }
    else {
      size_t v66 = *(void *)(v26 - 15);
    }
    if (v66 >= v24) {
      size_t v67 = v24;
    }
    else {
      size_t v67 = v66;
    }
    int v68 = memcmp(v22, v65, v67);
    if (v68)
    {
      if (v68 < 0)
      {
LABEL_128:
        int v69 = 1;
        int v70 = 5;
        goto LABEL_174;
      }
    }
    else if (v24 <= v66)
    {
      goto LABEL_128;
    }
LABEL_103:
    BOOL v27 = ++v20 < v21;
    v26 += 48;
  }
  while (v25 != v20);
  int v70 = 0;
  int v69 = 0;
LABEL_174:
  uint64_t v2 = v129;
  char v18 = v23;
LABEL_194:
  if (v18 < 0) {
    operator delete(v138.__r_.__value_.__l.__data_);
  }
  BOOL negate = v69;
  if (v27) {
    goto LABEL_238;
  }
LABEL_197:
  if (this->__equivalences_.__begin_ == this->__equivalences_.__end_) {
    goto LABEL_240;
  }
  int v135 = negate;
  unint64_t v90 = v2;
  std::regex_traits<char>::__transform_primary<char *>((uint64_t)&__s, (uint64_t)&this->__traits_, &__src, &v138);
  std::vector<std::string>::pointer v91 = this->__equivalences_.__begin_;
  int v92 = SHIBYTE(__s.__r_.__value_.__r.__words[2]);
  int64_t v93 = (char *)this->__equivalences_.__end_ - (char *)v91;
  if (!v93) {
    goto LABEL_218;
  }
  unint64_t v94 = v93 / 24;
  size_t v95 = __s.__r_.__value_.__l.__size_;
  if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v96 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v96 = __s.__r_.__value_.__l.__size_;
  }
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0)
  {
    int v132 = SHIBYTE(__s.__r_.__value_.__r.__words[2]);
    uint64_t v105 = 0;
    unsigned int v106 = (const void *)__s.__r_.__value_.__r.__words[0];
    if (v94 <= 1) {
      uint64_t v107 = 1;
    }
    else {
      uint64_t v107 = v93 / 24;
    }
    BOOL v99 = 1;
    do
    {
      std::string::size_type v108 = HIBYTE(v91->__r_.__value_.__r.__words[2]);
      int v109 = (char)v108;
      if ((v108 & 0x80u) != 0) {
        std::string::size_type v108 = v91->__r_.__value_.__l.__size_;
      }
      if (v96 == v108)
      {
        std::vector<std::string>::pointer v110 = v109 >= 0 ? v91 : (std::vector<std::string>::pointer)v91->__r_.__value_.__r.__words[0];
        if (!memcmp(v106, v110, v95))
        {
          int v135 = 1;
          int v70 = 5;
          goto LABEL_234;
        }
      }
      BOOL v99 = ++v105 < v94;
      ++v91;
    }
    while (v107 != v105);
    int v70 = 0;
LABEL_234:
    uint64_t v2 = v90;
    int v92 = v132;
    goto LABEL_235;
  }
  if (!*((unsigned char *)&__s.__r_.__value_.__s + 23))
  {
    std::string::size_type v118 = HIBYTE(v91->__r_.__value_.__r.__words[2]);
    if ((v118 & 0x80u) != 0) {
      std::string::size_type v118 = v91->__r_.__value_.__l.__size_;
    }
    if (v118 != HIBYTE(__s.__r_.__value_.__r.__words[2]))
    {
      unint64_t v119 = 0;
      if (v94 <= 1) {
        uint64_t v120 = 1;
      }
      else {
        uint64_t v120 = v94;
      }
      uint64_t v121 = v120 - 1;
      BOOL v122 = &v91[1].__r_.__value_.__s.__data_[8];
      uint64_t v2 = v90;
      while (v121 != v119)
      {
        ++v119;
        uint64_t v123 = v122[15];
        uint64_t v125 = *(void *)v122;
        v122 += 24;
        uint64_t v124 = v125;
        if ((v123 & 0x80u) != 0) {
          uint64_t v123 = v124;
        }
        if (v96 == v123)
        {
          BOOL v99 = v119 < v94;
          int v135 = 1;
          int v70 = 5;
          goto LABEL_235;
        }
      }
      BOOL v99 = 0;
      int v70 = 0;
      goto LABEL_235;
    }
    uint64_t v2 = v90;
    BOOL negate = 1;
LABEL_260:
    uint64_t v10 = 2;
    goto LABEL_261;
  }
  uint64_t v97 = 0;
  uint64_t v98 = v94 <= 1 ? 1 : v93 / 24;
  BOOL v99 = 1;
  do
  {
    unint64_t v100 = &v91[v97];
    std::string::size_type v101 = HIBYTE(v100->__r_.__value_.__r.__words[2]);
    int v102 = (char)v101;
    if ((v101 & 0x80u) != 0) {
      std::string::size_type v101 = v100->__r_.__value_.__l.__size_;
    }
    if (v96 == v101)
    {
      if (v102 < 0) {
        unint64_t v100 = (std::string *)v100->__r_.__value_.__r.__words[0];
      }
      BOOL v103 = &__s;
      uint64_t v104 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
      while (v103->__r_.__value_.__s.__data_[0] == v100->__r_.__value_.__s.__data_[0])
      {
        BOOL v103 = (std::string *)((char *)v103 + 1);
        unint64_t v100 = (std::string *)((char *)v100 + 1);
        if (!--v104)
        {
          int v135 = 1;
          int v70 = 5;
          uint64_t v2 = v90;
          goto LABEL_235;
        }
      }
    }
    BOOL v99 = ++v97 < v94;
  }
  while (v97 != v98);
LABEL_218:
  BOOL v99 = 0;
  int v70 = 0;
  uint64_t v2 = v90;
LABEL_235:
  if (v92 < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  BOOL negate = v135;
  if (!v99)
  {
LABEL_240:
    if ((char)__src < 0)
    {
      neg_std::regex_traits<char>::char_class_type mask = this->__neg_mask_;
    }
    else
    {
      std::regex_traits<char>::char_class_type mask = this->__mask_;
      tab = this->__traits_.__ct_->__tab_;
      std::ctype_base::mask v113 = tab[__src];
      if (((v113 & mask) != 0 || __src == 95 && (mask & 0x80) != 0)
        && (SHIBYTE(__src) & 0x80000000) == 0
        && ((tab[HIBYTE(__src)] & mask) != 0 || (mask & 0x80) != 0 && HIBYTE(__src) == 95))
      {
        goto LABEL_258;
      }
      neg_std::regex_traits<char>::char_class_type mask = this->__neg_mask_;
      if ((v113 & neg_mask) != 0 || __src == 95 && (neg_mask & 0x80) != 0)
      {
LABEL_257:
        int v115 = negate;
LABEL_259:
        BOOL negate = v115;
        goto LABEL_260;
      }
    }
    if ((SHIBYTE(__src) & 0x80000000) == 0)
    {
      if ((this->__traits_.__ct_->__tab_[HIBYTE(__src)] & neg_mask) == 0)
      {
        int v115 = 1;
        if (HIBYTE(__src) != 95 || (neg_mask & 0x80) == 0) {
          goto LABEL_259;
        }
      }
      goto LABEL_257;
    }
LABEL_258:
    int v115 = 1;
    goto LABEL_259;
  }
LABEL_238:
  if (v70) {
    goto LABEL_260;
  }
  uint64_t v10 = 2;
LABEL_42:
  unsigned __int8 v29 = *v2->__current_;
  __p.__r_.__value_.__s.__data_[0] = v29;
  if (this->__icase_)
  {
    unsigned __int8 v29 = ((uint64_t (*)(const std::ctype<char> *, void))this->__traits_.__ct_->do_tolower)(this->__traits_.__ct_, (char)v29);
    __p.__r_.__value_.__s.__data_[0] = v29;
  }
  std::vector<char>::pointer v30 = this->__chars_.__begin_;
  unint64_t v31 = this->__chars_.__end_ - v30;
  if (v31)
  {
    if (v31 <= 1) {
      unint64_t v31 = 1;
    }
    while (1)
    {
      int v32 = *v30++;
      if (v32 == v29) {
        break;
      }
      if (!--v31) {
        goto LABEL_49;
      }
    }
LABEL_183:
    BOOL negate = 1;
    goto LABEL_261;
  }
LABEL_49:
  std::regex_traits<char>::char_class_type v33 = this->__neg_mask_;
  if (v33 || this->__neg_chars_.__begin_ != this->__neg_chars_.__end_)
  {
    if ((v29 & 0x80) != 0 || (this->__traits_.__ct_->__tab_[v29] & v33) == 0) {
      int v34 = (v29 == 95) & (v33 >> 7);
    }
    else {
      LOBYTE(v34) = 1;
    }
    std::vector<char>::pointer end = this->__neg_chars_.__end_;
    std::vector<char>::pointer v36 = (std::vector<char>::pointer)memchr(this->__neg_chars_.__begin_, (char)v29, end - this->__neg_chars_.__begin_);
    char v37 = v36 ? v36 : end;
    if ((v34 & 1) == 0 && v37 == end) {
      goto LABEL_183;
    }
  }
  std::vector<std::pair<std::string, std::string>>::pointer v38 = this->__ranges_.__begin_;
  std::vector<std::pair<std::string, std::string>>::pointer v39 = this->__ranges_.__end_;
  if (v38 == v39) {
    goto LABEL_134;
  }
  if (!this->__collate_)
  {
    unsigned int v40 = 1;
    *((unsigned char *)&v138.__r_.__value_.__s + 23) = 1;
    LOWORD(v138.__r_.__value_.__l.__data_) = v29;
    int64_t v41 = (char *)v39 - (char *)v38;
    if (v41) {
      goto LABEL_65;
    }
LABEL_161:
    BOOL v48 = 0;
    if ((v40 & 0x80) != 0) {
      goto LABEL_132;
    }
    goto LABEL_133;
  }
  *((unsigned char *)&__s.__r_.__value_.__s + 23) = 1;
  LOWORD(__s.__r_.__value_.__l.__data_) = v29;
  (*(void (**)(std::string *__return_ptr))(*(void *)this->__traits_.__col_ + 32))(&v138);
  if (SHIBYTE(__s.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__s.__r_.__value_.__l.__data_);
  }
  std::vector<std::pair<std::string, std::string>>::pointer v38 = this->__ranges_.__begin_;
  unsigned int v40 = HIBYTE(v138.__r_.__value_.__r.__words[2]);
  int64_t v41 = (char *)this->__ranges_.__end_ - (char *)v38;
  if (!v41) {
    goto LABEL_161;
  }
LABEL_65:
  uint64_t v127 = v10;
  BOOL v130 = v2;
  BOOL v133 = negate;
  uint64_t v42 = 0;
  unint64_t v43 = v41 / 48;
  char v126 = v40;
  if ((v40 & 0x80u) == 0) {
    uint64_t v44 = &v138;
  }
  else {
    uint64_t v44 = (std::string *)v138.__r_.__value_.__r.__words[0];
  }
  if ((v40 & 0x80u) == 0) {
    std::string::size_type v45 = v40;
  }
  else {
    std::string::size_type v45 = v138.__r_.__value_.__l.__size_;
  }
  if (v43 <= 1) {
    uint64_t v46 = 1;
  }
  else {
    uint64_t v46 = v41 / 48;
  }
  int v47 = (unsigned __int8 *)&v38->second.__r_.__value_.__r.__words[2] + 7;
  BOOL v48 = 1;
  while (2)
  {
    int v49 = (char)*(v47 - 24);
    if (v49 >= 0) {
      uint64_t v50 = (char *)(v47 - 47);
    }
    else {
      uint64_t v50 = *(char **)(v47 - 47);
    }
    if (v49 >= 0) {
      size_t v51 = *(v47 - 24);
    }
    else {
      size_t v51 = *(void *)(v47 - 39);
    }
    if (v45 >= v51) {
      size_t v52 = v51;
    }
    else {
      size_t v52 = v45;
    }
    int v53 = memcmp(v50, v44, v52);
    if (v53)
    {
      if (v53 < 0) {
        goto LABEL_90;
      }
    }
    else if (v51 <= v45)
    {
LABEL_90:
      int v54 = (char)*v47;
      if (v54 >= 0) {
        char v55 = (char *)(v47 - 23);
      }
      else {
        char v55 = *(char **)(v47 - 23);
      }
      if (v54 >= 0) {
        size_t v56 = *v47;
      }
      else {
        size_t v56 = *(void *)(v47 - 15);
      }
      if (v56 >= v45) {
        size_t v57 = v45;
      }
      else {
        size_t v57 = v56;
      }
      int v58 = memcmp(v44, v55, v57);
      if (v58)
      {
        if (v58 < 0)
        {
LABEL_101:
          BOOL negate = 1;
          uint64_t v2 = v130;
          goto LABEL_131;
        }
      }
      else if (v45 <= v56)
      {
        goto LABEL_101;
      }
    }
    BOOL v48 = ++v42 < v43;
    v47 += 48;
    if (v46 != v42) {
      continue;
    }
    break;
  }
  uint64_t v2 = v130;
  BOOL negate = v133;
LABEL_131:
  uint64_t v10 = v127;
  if (v126 < 0) {
LABEL_132:
  }
    operator delete(v138.__r_.__value_.__l.__data_);
LABEL_133:
  if (v48) {
    goto LABEL_261;
  }
LABEL_134:
  if (this->__equivalences_.__begin_ == this->__equivalences_.__end_)
  {
LABEL_178:
    if ((v29 & 0x80) != 0) {
      goto LABEL_261;
    }
    std::regex_traits<char>::char_class_type v86 = this->__mask_;
    if ((this->__traits_.__ct_->__tab_[v29] & v86) == 0)
    {
      int v87 = (v86 >> 7) & 1;
      if (v29 != 95) {
        int v87 = 0;
      }
      if (v87 != 1) {
        goto LABEL_261;
      }
    }
    goto LABEL_183;
  }
  std::regex_traits<char>::__transform_primary<char *>((uint64_t)&__s, (uint64_t)&this->__traits_, &__p, &__p.__r_.__value_.__s.__data_[1]);
  std::vector<std::string>::pointer v71 = this->__equivalences_.__begin_;
  uint64_t v72 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
  int64_t v73 = (char *)this->__equivalences_.__end_ - (char *)v71;
  if (!v73)
  {
    if ((*((unsigned char *)&__s.__r_.__value_.__s + 23) & 0x80) != 0) {
      operator delete(__s.__r_.__value_.__l.__data_);
    }
LABEL_177:
    unsigned __int8 v29 = __p.__r_.__value_.__s.__data_[0];
    goto LABEL_178;
  }
  uint64_t v128 = v10;
  BOOL v131 = v2;
  int v134 = negate;
  uint64_t v74 = 0;
  unint64_t v75 = v73 / 24;
  long long v76 = *(_OWORD *)&__s.__r_.__value_.__l.__data_;
  if ((__s.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type v77 = HIBYTE(__s.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type v77 = __s.__r_.__value_.__l.__size_;
  }
  if (v75 <= 1) {
    uint64_t v78 = 1;
  }
  else {
    uint64_t v78 = v73 / 24;
  }
  BOOL v79 = 1;
  while (2)
  {
    unint64_t v80 = &v71[v74];
    std::string::size_type v81 = HIBYTE(v80->__r_.__value_.__r.__words[2]);
    int v82 = (char)v81;
    if ((v81 & 0x80u) != 0) {
      std::string::size_type v81 = v80->__r_.__value_.__l.__size_;
    }
    if (v77 != v81)
    {
LABEL_144:
      BOOL v79 = ++v74 < v75;
      if (v74 != v78) {
        continue;
      }
LABEL_157:
      uint64_t v10 = v128;
      uint64_t v2 = v131;
      if ((v72 & 0x80) == 0)
      {
        BOOL negate = v134;
        if (!v79) {
          goto LABEL_177;
        }
        goto LABEL_261;
      }
      BOOL negate = v134;
      goto LABEL_176;
    }
    break;
  }
  if (v82 >= 0) {
    unsigned int v83 = &v71[v74];
  }
  else {
    unsigned int v83 = (std::string *)v80->__r_.__value_.__r.__words[0];
  }
  if ((v72 & 0x80) != 0)
  {
    if (memcmp((const void *)v76, v83, *((size_t *)&v76 + 1))) {
      goto LABEL_144;
    }
    uint64_t v10 = v128;
    uint64_t v2 = v131;
    BOOL negate = 1;
LABEL_176:
    operator delete(__s.__r_.__value_.__l.__data_);
    if (v79) {
      goto LABEL_261;
    }
    goto LABEL_177;
  }
  if (v72)
  {
    BOOL v84 = &__s;
    uint64_t v85 = v72;
    while (v84->__r_.__value_.__s.__data_[0] == v83->__r_.__value_.__s.__data_[0])
    {
      BOOL v84 = (std::string *)((char *)v84 + 1);
      unsigned int v83 = (std::string *)((char *)v83 + 1);
      if (!--v85)
      {
        int v134 = 1;
        goto LABEL_157;
      }
    }
    goto LABEL_144;
  }
  uint64_t v10 = v128;
  uint64_t v2 = v131;
  BOOL negate = 1;
  if (!v79) {
    goto LABEL_177;
  }
LABEL_261:
  if (negate == this->__negate_)
  {
    first = 0;
    int v117 = -993;
  }
  else
  {
    v2->__current_ += v10;
    first = this->__first_;
    int v117 = -995;
  }
  v2->__do_ = v117;
  v2->__node_ = first;
}

void sub_1A17EBEB4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if ((a25 & 0x80000000) == 0) {
    _Unwind_Resume(exception_object);
  }
  operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::__empty_non_own_state<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -994;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

uint64_t std::__repeat_one_loop<char>::__exec(uint64_t result, uint64_t a2)
{
  *(_DWORD *)a2 = -991;
  *(void *)(a2 + 80) = *(void *)(result + 8);
  return result;
}

void std::__end_state<char>::~__end_state()
{
}

void std::__end_state<char>::__exec(uint64_t a1, _DWORD *a2)
{
  *a2 = -1000;
}

void *gms::BasicMaterial<ggl::Texture2D>::alpha@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  float v3 = a3.n128_f32[0];
  float v6 = **(float **)(a1 + 48);
  a3.n128_u32[1] = 872415232;
  if ((v6 > 0.00000011921 || (uint64_t v7 = *(void *)(a1 + 16)) == 0) && (v6 < 1.0 || (uint64_t v7 = *(void *)(a1 + 32)) == 0))
  {
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      (*(void (**)(uint64_t *__return_ptr, float))(*(void *)v10 + 624))(&v14, a3.n128_f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      LOBYTE(v14) = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(uint64_t *__return_ptr, float))(*result + 624))(&v13, v3);
        if ((_BYTE)v14)
        {
LABEL_11:
          if ((_BYTE)v13)
          {
            float v11 = *((float *)&v14 + 1) + (float)((float)(*((float *)&v13 + 1) - *((float *)&v14 + 1)) * v6);
            *(unsigned char *)a2 = 1;
            *(float *)(a2 + 4) = v11;
            return result;
          }
          int v12 = HIDWORD(v14);
LABEL_18:
          *(_DWORD *)(a2 + 4) = v12;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!(_BYTE)v13) {
          return result;
        }
        int v12 = HIDWORD(v13);
        goto LABEL_18;
      }
    }
    LOBYTE(v13) = 0;
    if ((_BYTE)v14) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  BOOL v8 = *(uint64_t (**)(__n128))(*(void *)v7 + 624);
  return (void *)v8(a3);
}

grl::IconRenderer *std::__shared_ptr_emplace<grl::IconImage>::__on_zero_shared(uint64_t a1)
{
  std::mutex::~mutex((std::mutex *)(a1 + 232));
  if (*(unsigned char *)(a1 + 207)) {
    *(unsigned char *)(a1 + 207) = 0;
  }
  if (*(unsigned char *)(a1 + 202)) {
    *(unsigned char *)(a1 + 202) = 0;
  }
  if (*(unsigned char *)(a1 + 197)) {
    *(unsigned char *)(a1 + 197) = 0;
  }
  if (*(unsigned char *)(a1 + 192)) {
    *(unsigned char *)(a1 + 192) = 0;
  }
  if (*(unsigned char *)(a1 + 187)) {
    *(unsigned char *)(a1 + 187) = 0;
  }
  if (*(unsigned char *)(a1 + 182)) {
    *(unsigned char *)(a1 + 182) = 0;
  }
  if (*(unsigned char *)(a1 + 177)) {
    *(unsigned char *)(a1 + 177) = 0;
  }
  if (*(unsigned char *)(a1 + 172)) {
    *(unsigned char *)(a1 + 172) = 0;
  }
  if (*(unsigned char *)(a1 + 167)) {
    *(unsigned char *)(a1 + 167) = 0;
  }
  if (*(unsigned char *)(a1 + 162)) {
    *(unsigned char *)(a1 + 162) = 0;
  }
  if (*(unsigned char *)(a1 + 160)) {
    *(unsigned char *)(a1 + 160) = 0;
  }
  std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::destroy(a1 + 120, *(void *)(a1 + 128));
  if (*(unsigned char *)(a1 + 156)) {
    *(unsigned char *)(a1 + 156) = 0;
  }
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 40);
  if (v2) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v2);
  }
  return std::unique_ptr<grl::IconRenderer>::reset[abi:nn180100]((grl::IconRenderer **)(a1 + 24), 0);
}

void geo::make_unique<grl::IconRenderer,grl::codec::IconData const&,float &,grl::IconModifiers const&,std::map<unsigned short,grl::ImageData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::ImageData>,grl::Allocator>> const&,std::map<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,std::less<std::string>,geo::StdAllocator<std::pair<std::string const,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,grl::Allocator>> const&>()
{
}

void grl::IconMetrics::setupBasicIcon(uint64_t a1, grl::IconRenderer *a2, uint64_t a3)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  unint64_t v115 = 0;
  unint64_t v116 = 0;
  uint64_t v7 = (void **)(a3 + 40);
  BOOL v8 = (void **)(a3 + 72);
  uint64_t LayerRenderer = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 3, 0);
  if (LayerRenderer && *(_WORD *)(LayerRenderer + 8) == 3)
  {
    uint64_t v10 = *v7;
    if (!*v7) {
      goto LABEL_7;
    }
    do
    {
      float v11 = v10;
      uint64_t v10 = (void *)*v10;
    }
    while (v10);
    if (v11 == v7 || *((_WORD *)v11 + 14))
    {
LABEL_7:
      char v12 = 0;
      int v13 = 1;
    }
    else
    {
      int v13 = 0;
      *(_OWORD *)buf_4 = *((_OWORD *)v11 + 2);
      char v12 = 1;
    }
    LOBYTE(buf) = v12;
    uint64_t v14 = *v8;
    if (*v8)
    {
      do
      {
        uint64_t v15 = v14;
        uint64_t v14 = (void *)*v14;
      }
      while (v14);
      if (v15 != v8 && ((*((_WORD *)v15 + 14) == 0) & ~v13) != 0) {
        operator new();
      }
    }
    if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
    }
    size_t v52 = GEOGetGeoResourceLibMetricsLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v112) = 0;
      int v53 = "[Warning][Text Layer] Failed to get text bounds and text baseline for text layer. Probably because a font wasn't found.";
      p_float buf = (uint8_t *)&v112;
LABEL_104:
      _os_log_impl(&dword_1A1780000, v52, OS_LOG_TYPE_ERROR, v53, p_buf, 2u);
    }
  }
  else
  {
    unsigned __int16 v16 = 0;
    do
    {
      uint64_t v17 = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 2, v16);
      if (v17)
      {
        if (*(_WORD *)(v17 + 8) == 2) {
          uint64_t v18 = v17 + 16;
        }
        else {
          uint64_t v18 = 0;
        }
      }
      else
      {
        uint64_t v18 = 0;
      }
      uint64_t v19 = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 2, v16);
      if (!v19) {
        break;
      }
      if (*(_WORD *)(v19 + 8) != 2) {
        break;
      }
      uint64_t v20 = *(void *)(v19 + 272);
      LOBYTE(buf) = 1;
      *(void *)buf_4 = v20;
      if (!v18) {
        break;
      }
      if (!*(unsigned char *)(v18 + 136)) {
        operator new();
      }
      unsigned int v21 = v16++;
    }
    while (v21 < 4);
    float v23 = *((float *)&v115 + 1);
    float v22 = *(float *)&v115;
    uint64_t v24 = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 1, 0);
    if (v24 && *(_WORD *)(v24 + 8) == 1) {
      operator new();
    }
    unsigned __int16 v25 = 0;
    int v109 = 0;
    unint64_t v116 = v115;
    uint64_t v112 = 0;
    float v113 = *(float *)&v115 + 0.0;
    float v114 = *((float *)&v115 + 1) + 0.0;
    float v26 = *(float *)&v115 * 0.5;
    float v27 = *((float *)&v115 + 1) * 0.5;
    float v110 = 0.0;
    float v111 = 0.0;
    while (1)
    {
      uint64_t v28 = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 1, v25);
      if (!v28 || *(_WORD *)(v28 + 8) != 1) {
        break;
      }
      unsigned __int8 v29 = (float *)grl::IconMetrics::privateLayerMetrics(a1, 1, v25);
      if (!v29)
      {
        if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
        }
        char v55 = GEOGetGeoResourceLibMetricsLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
        {
          float buf = 4.8152e-34;
          *(void *)buf_4 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
          *(_WORD *)&buf_4[8] = 2080;
          *(void *)&buf_4[10] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconMetrics.cpp";
          __int16 v119 = 1024;
          int v120 = 250;
          _os_log_impl(&dword_1A1780000, v55, OS_LOG_TYPE_ERROR, "Failed to find layer metrics for image layer.: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&buf, 0x1Cu);
        }
        break;
      }
      if (!*((unsigned char *)a2 + 258))
      {
        std::vector<char>::pointer v30 = v29;
        uint64_t v31 = (uint64_t)(v29 + 11);
        float v32 = ceilf(v26 - (float)(v29[11] * 0.5));
        v29[13] = v32;
        std::regex_traits<char>::char_class_type v33 = v29 + 13;
        float v34 = ceilf(v27 - (float)(v29[12] * 0.5));
        v29[14] = v34;
        if (!v25)
        {
          float v3 = gm::Box<float,2>::operator+(v29 + 29, v33);
          float v4 = v35;
          float v107 = v37;
          float v108 = v36;
          float v110 = gm::Box<float,2>::operator+(v30 + 3, v33);
          float v111 = v38;
          float v22 = v39;
          float v23 = v40;
          float v32 = v30[13];
          float v34 = v30[14];
          float v105 = v30[16] + v34;
          float v106 = v30[15] + v32;
          float v103 = v34 + v30[18];
          float v104 = v32 + v30[17];
          int v109 = 1;
        }
        if (*((unsigned char *)a2 + 259))
        {
          float v41 = (float)(ceilf(*((float *)&v115 + 1) * 0.175) * (float)v25) + v34;
          v30[13] = v32 + 0.0;
          v30[14] = v41;
          float v42 = gm::Box<float,2>::create(v31);
          uint64_t v43 = 0;
          float buf = v42;
          *(_DWORD *)buf_4 = v44;
          *(_DWORD *)&buf_4[4] = v45;
          *(_DWORD *)&buf_4[8] = v46;
          char v47 = 1;
          do
          {
            char v48 = v47;
            float v49 = *(float *)&buf_4[4 * v43 - 4];
            if (v49 >= *((float *)&v112 + v43)) {
              float v49 = *((float *)&v112 + v43);
            }
            *((float *)&v112 + v43) = v49;
            float v50 = *(&v113 + v43);
            if (v50 < *(float *)&buf_4[4 * v43 + 4]) {
              float v50 = *(float *)&buf_4[4 * v43 + 4];
            }
            *(&v113 + v43) = v50;
            uint64_t v43 = 1;
            char v47 = 0;
          }
          while ((v48 & 1) != 0);
        }
        unsigned int v51 = v25++;
        if (v51 < 2) {
          continue;
        }
      }
      break;
    }
    float v101 = v4;
    unsigned __int16 v56 = 0;
    float v57 = v113 - *(float *)&v112;
    float v58 = v114 - *((float *)&v112 + 1);
    float v102 = v22;
    float v59 = v110 + (float)((float)(v22 - v110) * 0.5);
    float v60 = v111 + (float)((float)(v23 - v111) * 0.5);
    while (1)
    {
      uint64_t v61 = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 2, v56);
      if (!v61 || (uint64_t v62 = v61, *(_WORD *)(v61 + 8) != 2))
      {
LABEL_66:
        unint64_t v116 = __PAIR64__(LODWORD(v58), LODWORD(v57));
        float v77 = v102;
        goto LABEL_67;
      }
      if (*(unsigned char *)(v61 + 152))
      {
        uint64_t v63 = grl::IconMetrics::privateLayerMetrics(a1, 1, 0);
        int v64 = (float *)(v63 + 116);
        char v65 = (float *)(v63 + 52);
        gm::Box<float,2>::operator+((float *)(v63 + 116), (float *)(v63 + 52));
        float v67 = v66;
        float buf = v69 - gm::Box<float,2>::operator+(v64, v65);
        *(float *)buf_4 = v67 - v68;
        operator new();
      }
      int v70 = (float *)grl::IconMetrics::privateLayerMetrics(a1, 2, v56);
      if (!v70) {
        break;
      }
      float v71 = ceilf(v59 - (float)(v70[11] * 0.5));
      float v72 = ceilf(v60 - (float)(v70[12] * 0.5));
      if (*(unsigned char *)(v62 + 165))
      {
        float v71 = v71 + *(float *)(v62 + 120);
        float v72 = v72 + *(float *)(v62 + 124);
      }
      v70[13] = v71;
      v70[14] = v72;
      int64_t v73 = v70 + 13;
      gm::Box<float,2>::operator+(v70 + 3, v70 + 13);
      if (v57 < v74) {
        float v57 = v74;
      }
      gm::Box<float,2>::operator+(v73 - 10, v73);
      if (v58 < v75) {
        float v58 = v75;
      }
      unsigned int v76 = v56++;
      if (v76 >= 4) {
        goto LABEL_66;
      }
    }
    unint64_t v116 = __PAIR64__(LODWORD(v58), LODWORD(v57));
    if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
    }
    float v77 = v102;
    unint64_t v100 = GEOGetGeoResourceLibMetricsLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
    {
      float buf = 4.8152e-34;
      *(void *)buf_4 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      *(_WORD *)&buf_4[8] = 2080;
      *(void *)&buf_4[10] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconMetrics.cpp";
      __int16 v119 = 1024;
      int v120 = 299;
      _os_log_impl(&dword_1A1780000, v100, OS_LOG_TYPE_ERROR, "Failed to find layer metrics for image layer.: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&buf, 0x1Cu);
    }
LABEL_67:
    unsigned __int16 v78 = 0;
    do
    {
      uint64_t v79 = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 3, v78);
      if (!v79) {
        break;
      }
      uint64_t v80 = v79;
      if (*(_WORD *)(v79 + 8) != 3) {
        break;
      }
      uint64_t v81 = grl::IconMetrics::privateLayerMetrics(a1, 3, v78);
      if (!v81)
      {
        if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
        }
        BOOL v88 = GEOGetGeoResourceLibMetricsLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
        {
          float buf = 4.8152e-34;
          *(void *)buf_4 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
          *(_WORD *)&buf_4[8] = 2080;
          *(void *)&buf_4[10] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconMetrics.cpp";
          __int16 v119 = 1024;
          int v120 = 326;
          _os_log_impl(&dword_1A1780000, v88, OS_LOG_TYPE_ERROR, "Failed to find layer metrics for text layer.: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&buf, 0x1Cu);
        }
        break;
      }
      int v82 = (float *)v81;
      if (!grl::IconRenderer::hasPathLayers(a2)
        || (uint64_t v83 = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 1, 0)) == 0
        || *(_WORD *)(v83 + 8) != 1
        || (float v84 = v23, *(unsigned char *)(v83 + 136) != 3))
      {
        float v84 = v58;
      }
      float v85 = (float)(v59 - (float)(v82[11] * 0.5)) + (float)(v82[23] + v82[13]);
      if (*(unsigned char *)(v80 + 193))
      {
        float v85 = v85 + *(float *)(v80 + 184);
        float v86 = v84 - *(float *)(v80 + 188);
      }
      else
      {
        float v86 = (float)(v60 - (float)(v82[12] * 0.5)) + (float)(v82[24] + v82[14]);
      }
      v82[13] = ceilf(v85);
      v82[14] = ceilf(v86);
      unsigned int v87 = v78++;
    }
    while (v87 < 4);
    uint64_t v89 = grl::IconRenderer::findLayerRenderer((uint64_t)a2, 0, 0);
    if (v89 && !*(_WORD *)(v89 + 8)) {
      operator new();
    }
    if (v116)
    {
      float v90 = ceilf(v57);
      float v91 = ceilf(v58);
      *(float *)(a1 + 32) = v90;
      *(float *)(a1 + 36) = v91;
      *(void *)(a1 + 40) = 0;
      float v92 = v90 * 0.5;
      float v93 = v91 * 0.5;
      *(float *)(a1 + 48) = v92;
      *(float *)(a1 + 52) = v93;
      *(float *)(a1 + 16) = v110;
      *(float *)(a1 + 20) = v111;
      *(float *)(a1 + 24) = v77;
      *(float *)(a1 + 28) = v23;
      float v94 = v107;
      float v95 = v108;
      if (!v109)
      {
        float v94 = v23;
        float v95 = v77;
      }
      float v96 = v3;
      if (!v109) {
        float v96 = v110;
      }
      float v97 = v101;
      if (!v109) {
        float v97 = v111;
      }
      *(float *)a1 = v96;
      *(float *)(a1 + 4) = v97;
      *(float *)(a1 + 8) = v95;
      *(float *)(a1 + 12) = v94;
      float v98 = v105;
      float v99 = v106;
      if (!v109)
      {
        float v98 = v93;
        float v99 = v92;
      }
      *(float *)(a1 + 56) = v99;
      *(float *)(a1 + 60) = v98;
      if (v109)
      {
        float v93 = v103;
        float v92 = v104;
      }
      *(float *)(a1 + 64) = v92;
      *(float *)(a1 + 68) = v93;
    }
    else
    {
      if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
      }
      size_t v52 = GEOGetGeoResourceLibMetricsLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf) = 0;
        int v53 = "An icon with a size of 0 was generated.";
        p_float buf = (uint8_t *)&buf;
        goto LABEL_104;
      }
    }
  }
}

uint64_t grl::IconRenderer::findLayerRenderer(uint64_t a1, __int16 a2, __int16 a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  LOWORD(v13) = a2;
  HIWORD(v13) = a3;
  LOBYTE(v14) = 0;
  uint64_t v3 = a1 + 40;
  uint64_t v4 = *(void *)(a1 + 40);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = a1 + 64;
  uint64_t v6 = a1 + 40;
  do
  {
    int v7 = grl::IconLayerMapKey::operator()(v5, (__int16 *)(v4 + 32), (__int16 *)&v13);
    BOOL v8 = (uint64_t *)(v4 + 8);
    if (!v7)
    {
      BOOL v8 = (uint64_t *)v4;
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v6 == v3 || grl::IconLayerMapKey::operator()(v5, (__int16 *)&v13, (__int16 *)(v6 + 32))) {
    return 0;
  }
  uint64_t result = *(void *)(v6 + 40);
  if (!result)
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v10 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      int v11 = *(unsigned __int16 *)(v6 + 32);
      int v12 = *(unsigned __int16 *)(v6 + 34);
      int v13 = 67110146;
      int v14 = v11;
      __int16 v15 = 1024;
      int v16 = v12;
      __int16 v17 = 2080;
      uint64_t v18 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      __int16 v19 = 2080;
      uint64_t v20 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconRenderer.cpp";
      __int16 v21 = 1024;
      int v22 = 645;
      _os_log_impl(&dword_1A1780000, v10, OS_LOG_TYPE_ERROR, "Nullptr LayerRenderer found in IconRenderer. This should never occur. LayerType: %hu, LayerIndex: %d: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v13, 0x28u);
    }
    return 0;
  }
  return result;
}

uint64_t grl::IconLayerMapKey::operator()(uint64_t a1, __int16 *a2, __int16 *a3)
{
  unint64_t v3 = *a2;
  if (v3 > 4) {
    unsigned int v4 = 0;
  }
  else {
    unsigned int v4 = dword_1A29CE1E4[v3];
  }
  unint64_t v5 = *a3;
  if (v5 > 4) {
    unsigned int v6 = 0;
  }
  else {
    unsigned int v6 = dword_1A29CE1E4[v5];
  }
  if (v4 != v6) {
    return v4 < v6;
  }
  unsigned int v7 = (unsigned __int16)a2[1];
  unsigned int v8 = (unsigned __int16)a3[1];
  BOOL v9 = v7 > v8;
  BOOL v10 = v7 < v8;
  unsigned int v11 = v9;
  if (v3 == 1) {
    return v11;
  }
  else {
    return v10;
  }
}

float gm::Box<float,2>::operator+(float *a1, float *a2)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    float v4 = a1[v2 + 2];
    float v5 = a1[v2];
    if ((v3 & 1) == 0) {
      break;
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while (v4 >= v5);
  if (v4 < v5) {
    return 3.4028e38;
  }
  long long v7 = *(_OWORD *)a1;
  gm::Box<float,2>::operator+=((float *)&v7, a2);
  return *(float *)&v7;
}

float gm::Box<float,2>::operator+=(float *a1, float *a2)
{
  uint64_t v2 = 0;
  char v3 = 1;
  do
  {
    float result = a1[v2 + 2];
    float v5 = a1[v2];
    if ((v3 & 1) == 0) {
      break;
    }
    char v3 = 0;
    uint64_t v2 = 1;
  }
  while (result >= v5);
  if (result >= v5)
  {
    float v6 = a1[1];
    *a1 = *a2 + *a1;
    a1[1] = a2[1] + v6;
    float v7 = a1[3];
    a1[2] = *a2 + a1[2];
    float result = a2[1] + v7;
    a1[3] = result;
  }
  return result;
}

uint64_t grl::IconMetrics::privateLayerMetrics(uint64_t a1, __int16 a2, __int16 a3)
{
  v10[0] = a2;
  v10[1] = a3;
  char v11 = 0;
  uint64_t v3 = a1 + 80;
  uint64_t v4 = *(void *)(a1 + 80);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = a1 + 104;
  uint64_t v6 = a1 + 80;
  do
  {
    int v7 = grl::IconLayerMapKey::operator()(v5, (__int16 *)(v4 + 32), v10);
    unsigned int v8 = (uint64_t *)(v4 + 8);
    if (!v7)
    {
      unsigned int v8 = (uint64_t *)v4;
      uint64_t v6 = v4;
    }
    uint64_t v4 = *v8;
  }
  while (*v8);
  if (v6 == v3 || grl::IconLayerMapKey::operator()(v5, v10, (__int16 *)(v6 + 32))) {
    return 0;
  }
  else {
    return *(void *)(v6 + 40);
  }
}

void grl::IconMetrics::cacheLayerMetrics(uint64_t a1, unsigned int a2, __int16 a3, uint64_t *a4)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v9[0] = a2;
  v9[1] = a3;
  char v10 = 0;
  if ((std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::__emplace_unique_key_args<grl::IconLayerMapKey,grl::IconLayerMapKey const&,std::unique_ptr<grl::LayerMetrics>>((uint64_t **)(a1 + 72), v9, (uint64_t)v9, a4) & 1) == 0)
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v5 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      grl::toString<grl::LayerType>(a2, __p);
      if (v8 >= 0) {
        uint64_t v6 = __p;
      }
      else {
        uint64_t v6 = (void **)__p[0];
      }
      *(_DWORD *)float buf = 136315906;
      int v12 = v6;
      __int16 v13 = 2080;
      int v14 = "result.second";
      __int16 v15 = 2080;
      int v16 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconMetrics.cpp";
      __int16 v17 = 1024;
      int v18 = 582;
      _os_log_impl(&dword_1A1780000, v5, OS_LOG_TYPE_ERROR, "Failed to insert LayerMetrics for an %s layer, due to the LayerMetrics already existing.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x26u);
      if (v8 < 0) {
        operator delete(__p[0]);
      }
    }
  }
}

uint64_t grl::IconRenderer::IconRenderer(uint64_t a1, grl::codec::IconData *a2, uint64_t a3, void *a4, uint64_t a5, _DWORD *a6, float a7)
{
  v98[6] = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)a1 = &unk_1EF5672F0;
  *(unsigned char *)(a1 + 24) = 4;
  *(void *)(a1 + 40) = 0;
  char v11 = (void *)(a1 + 40);
  int v12 = (grl::Allocator *)grl::Allocator::instance((grl::Allocator *)a1);
  *(void *)(a1 + 32) = v11;
  *(void *)(a1 + 48) = v12;
  *(void *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(unsigned char *)(a1 + 68) = 0;
  *(unsigned char *)(a1 + 72) = 0;
  *(_OWORD *)(a1 + 120) = 0u;
  uint64_t v13 = a1 + 120;
  *(void *)(a1 + 200) = 0;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_OWORD *)(a1 + 152) = 0u;
  *(_OWORD *)(a1 + 168) = 0u;
  *(void *)(a1 + 184) = 0;
  uint64_t v14 = grl::Allocator::instance(v12);
  *(void *)(a1 + 192) = a1 + 200;
  *(void *)(a1 + 208) = v14;
  *(void *)(a1 + 216) = 0;
  *(_DWORD *)(a1 + 224) = 0;
  *(unsigned char *)(a1 + 228) = 0;
  *(unsigned char *)(a1 + 232) = 0;
  *(unsigned char *)(a1 + 244) = 0;
  *(unsigned char *)(a1 + 256) = *(unsigned char *)(a3 + 4);
  *(_WORD *)(a1 + 257) = 0;
  *(unsigned char *)(a1 + 259) = 0;
  *(float *)(a1 + 260) = a7;
  *(void *)(a1 + 264) = 0;
  *(void *)(a1 + 272) = 0;
  *(_DWORD *)(a1 + 280) = *a6;
  __int16 v15 = (grl::Allocator *)geo::optional<std::string>::optional((unsigned char *)(a1 + 288), (uint64_t)(a6 + 2));
  *(void *)(a1 + 328) = 0;
  int v16 = (grl::Allocator *)grl::Allocator::instance(v15);
  *(void *)(a1 + 336) = v16;
  *(void *)(a1 + 344) = 0;
  *(_DWORD *)(a1 + 352) = 0;
  *(unsigned char *)(a1 + 356) = 0;
  *(void *)(a1 + 320) = a1 + 328;
  *(void *)(a1 + 360) = a1 + 360;
  *(void *)(a1 + 368) = a1 + 360;
  *(void *)(a1 + 376) = 0;
  float v72 = 0;
  int64_t v73 = (grl::Allocator *)grl::Allocator::instance(v16);
  uint64_t v74 = 0;
  float v71 = &v72;
  unsigned int v76 = 0;
  float v77 = (grl::Allocator *)grl::Allocator::instance(v73);
  uint64_t v78 = 0;
  float v75 = &v76;
  v80[0] = 0;
  v80[1] = (void *)grl::Allocator::instance(v77);
  v80[2] = 0;
  uint64_t v79 = v80;
  if (*(void *)(a3 + 144) != *(void *)(a3 + 152)) {
    *(unsigned char *)(a1 + 259) = 1;
  }
  __int16 v17 = operator new(0x20uLL);
  *__int16 v17 = &unk_1EF57CC18;
  v17[1] = a2;
  v17[2] = a3;
  v17[3] = a1;
  *(void *)&buf[24] = v17;
  grl::codec::IconData::forEachPathLayer((uint64_t)a2, (grl::IconModifiers *)a3, (uint64_t)buf);
  if (*(unsigned char **)&buf[24] == buf)
  {
    (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
  }
  else if (*(void *)&buf[24])
  {
    (*(void (**)(void))(**(void **)&buf[24] + 40))();
  }
  char v86 = 0;
  char v84 = 0;
  char v83 = 0;
  int v18 = (void **)operator new(0x38uLL);
  const char *v18 = &unk_1EF57CCA8;
  v18[1] = a4;
  v18[2] = (void *)a1;
  v18[3] = &v86;
  v18[4] = &v84;
  v18[5] = &v83;
  v18[6] = (void *)a3;
  float v91 = v18;
  grl::codec::IconData::forEachImageLayer(a2, (grl::IconModifiers *)a3, (uint64_t)v89);
  if (v91 == v89)
  {
    (*((void (**)(void **))v89[0] + 4))(v89);
  }
  else if (v91)
  {
    (*((void (**)(void))*v91 + 5))();
  }
  float v67 = (void *)(a1 + 32);
  if (!v83) {
    goto LABEL_32;
  }
  if (v84)
  {
    if (v86)
    {
      if ((float)(*(float *)&v85 + *((float *)&v85 + 1)) < *(float *)&v87) {
        goto LABEL_32;
      }
      if (*(float *)&v87 > 4295000000.0)
      {
        unsigned int v19 = -1;
LABEL_17:
        float v20 = floorf((float)v19 * 0.5);
LABEL_31:
        *(float *)&uint64_t v85 = v20;
        *((float *)&v85 + 1) = v20;
LABEL_32:
        if (*(unsigned char *)(a1 + 288))
        {
          uint64_t v24 = (void *)*a4;
          int v70 = a4 + 1;
          if (v24 != v70)
          {
            unsigned int v25 = 0;
            do
            {
              *(_WORD *)float buf = *((_WORD *)v24 + 16);
              *(void *)&buf[8] = v24[5];
              std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::__value_func[abi:nn180100]((uint64_t)&buf[16], (uint64_t)(v24 + 6));
              if (*(char *)(a1 + 319) >= 0) {
                size_t v26 = *(unsigned __int8 *)(a1 + 319);
              }
              else {
                size_t v26 = *(void *)(a1 + 304);
              }
              std::string::basic_string[abi:nn180100]((uint64_t)&v82, v26 + 10);
              if ((v82.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                float v27 = &v82;
              }
              else {
                float v27 = (std::string *)v82.__r_.__value_.__r.__words[0];
              }
              if (v26)
              {
                if (*(char *)(a1 + 319) >= 0) {
                  uint64_t v28 = (const void *)(a1 + 296);
                }
                else {
                  uint64_t v28 = *(const void **)(a1 + 296);
                }
                memmove(v27, v28, v26);
              }
              strcpy((char *)v27 + v26, "inputImage");
              std::to_string(&v81, v25);
              if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                unsigned __int8 v29 = &v81;
              }
              else {
                unsigned __int8 v29 = (std::string *)v81.__r_.__value_.__r.__words[0];
              }
              if ((v81.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
                std::string::size_type size = HIBYTE(v81.__r_.__value_.__r.__words[2]);
              }
              else {
                std::string::size_type size = v81.__r_.__value_.__l.__size_;
              }
              uint64_t v31 = std::string::append(&v82, (const std::string::value_type *)v29, size);
              std::string::size_type v32 = v31->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v88.__r_.__value_.__l.__data_ = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
              v88.__r_.__value_.__r.__words[2] = v32;
              v31->__r_.__value_.__l.__size_ = 0;
              v31->__r_.__value_.__r.__words[2] = 0;
              v31->__r_.__value_.__r.__words[0] = 0;
              std::regex_traits<char>::char_class_type v33 = std::string::append(&v88, ".png");
              std::string::size_type v34 = v33->__r_.__value_.__r.__words[2];
              *(_OWORD *)std::string __p = *(_OWORD *)&v33->__r_.__value_.__l.__data_;
              uint64_t v93 = v34;
              v33->__r_.__value_.__l.__size_ = 0;
              v33->__r_.__value_.__r.__words[2] = 0;
              v33->__r_.__value_.__r.__words[0] = 0;
              if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v88.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v81.__r_.__value_.__l.__data_);
              }
              if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v82.__r_.__value_.__l.__data_);
              }
              if (!v97) {
                std::__throw_bad_function_call[abi:nn180100]();
              }
              (*(void (**)(std::string *__return_ptr))(*(void *)v97 + 48))(&v88);
              (*(void (**)(void))(*(void *)v88.__r_.__value_.__l.__data_ + 112))();
              if (v88.__r_.__value_.__l.__size_) {
                std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v88.__r_.__value_.__l.__size_);
              }
              if (SHIBYTE(v93) < 0) {
                operator delete(__p[0]);
              }
              std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](&buf[16]);
              float v35 = (void *)v24[1];
              if (v35)
              {
                do
                {
                  float v36 = v35;
                  float v35 = (void *)*v35;
                }
                while (v35);
              }
              else
              {
                do
                {
                  float v36 = (void *)v24[2];
                  BOOL v37 = *v36 == (void)v24;
                  uint64_t v24 = v36;
                }
                while (!v37);
              }
              ++v25;
              uint64_t v24 = v36;
            }
            while (v36 != v70);
          }
        }
        int v38 = *(unsigned __int8 *)(a1 + 232);
        if (v86)
        {
          __int16 v21 = a2;
          uint64_t v13 = a1 + 120;
          *(void *)(a1 + 236) = v87;
          if (!v38) {
            *(unsigned char *)(a1 + 232) = 1;
          }
        }
        else
        {
          __int16 v21 = a2;
          uint64_t v13 = a1 + 120;
          if (*(unsigned char *)(a1 + 232)) {
            *(unsigned char *)(a1 + 232) = 0;
          }
        }
        int v39 = *(unsigned __int8 *)(a1 + 244);
        if (v84)
        {
          *(void *)(a1 + 248) = v85;
          if (!v39) {
            *(unsigned char *)(a1 + 244) = 1;
          }
        }
        else if (*(unsigned char *)(a1 + 244))
        {
          *(unsigned char *)(a1 + 244) = 0;
        }
        *(unsigned char *)(a1 + 257) = v83;
        goto LABEL_82;
      }
      if (*(float *)&v87 >= 0.0)
      {
        unsigned int v19 = vcvtas_u32_f32(*(float *)&v87);
        if (v19) {
          goto LABEL_17;
        }
      }
      else
      {
        unsigned int v19 = 0;
      }
      float v20 = (float)((float)v19 * 0.5) + -1.0;
      goto LABEL_31;
    }
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    __int16 v21 = a2;
    int v22 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconRenderer.cpp";
      *(_WORD *)&unsigned char buf[22] = 1024;
      *(_DWORD *)&buf[24] = 459;
      uint64_t v23 = "Failed to find image size for stretched icon at index 0.: Assertion with expression - %s : Failed in file - %s line - %i";
      goto LABEL_26;
    }
  }
  else
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    __int16 v21 = a2;
    int v22 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconRenderer.cpp";
      *(_WORD *)&unsigned char buf[22] = 1024;
      *(_DWORD *)&buf[24] = 456;
      uint64_t v23 = "Failed to find HorizontalStretchPadding property for the image layer at index 0.: Assertion with expression "
            "- %s : Failed in file - %s line - %i";
LABEL_26:
      _os_log_impl(&dword_1A1780000, v22, OS_LOG_TYPE_ERROR, v23, buf, 0x1Cu);
    }
  }
LABEL_82:
  float v40 = operator new(0x28uLL);
  *float v40 = &unk_1EF57CC60;
  v40[1] = a3;
  v40[2] = a1;
  v40[3] = a5;
  v40[4] = &v71;
  *(void *)&buf[24] = v40;
  grl::codec::IconData::forEachTextLayer((uint64_t)v21, (const IconModifiers *)a3, (uint64_t)buf);
  std::__function::__value_func<void ()(unsigned short,grl::codec::TextLayerData const&)>::~__value_func[abi:nn180100](buf);
  uint64_t v41 = a1 + 200;
  if (*((unsigned char *)v21 + 32))
  {
    grl::codec::IconData::colorLayer(v21, (uint64_t)buf);
    if (BYTE5(v97)) {
      operator new();
    }
    if (*(void *)buf)
    {
      *(void *)&buf[8] = *(void *)buf;
      (*(void (**)(void, void, void))(**(void **)&buf[24] + 40))(*(void *)&buf[24], *(void *)buf, *(void *)&buf[16] - *(void *)buf);
    }
  }
  if (*((unsigned char *)v21 + 184))
  {
    grl::codec::IconData::infoLayer(v21, (const grl::IconModifiers *)a3, (uint64_t)buf);
    if (!*(unsigned char *)(a1 + 72)) {
      *(unsigned char *)(a1 + 72) = 1;
    }
    *(void *)(a1 + 76) = *(void *)buf;
    *(void *)(a1 + 84) = *(void *)&buf[8];
    *(unsigned char *)(a1 + 92) = buf[16];
    *(void *)(a1 + 93) = *(void *)&buf[17];
    *(_DWORD *)(a1 + 101) = *(_DWORD *)&buf[25];
    *(_DWORD *)(a1 + 108) = v95;
    *(_WORD *)(a1 + 112) = v96;
  }
  grl::IconMetrics::IconMetrics((uint64_t)buf, (grl::IconRenderer *)a1, (uint64_t)&v71);
  grl::IconMetrics::operator=(v13, (uint64_t)buf);
  std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::destroy((uint64_t)v98, v98[1]);
  *(void *)float buf = buf;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0;
  float v42 = *(void **)(a1 + 32);
  if (v42 != v11)
  {
    while (1)
    {
      uint64_t v43 = v42[5];
      if (!v43) {
        break;
      }
      LODWORD(v89[0]) = *((_DWORD *)v42 + 8);
      BYTE4(v89[0]) = 0;
      uint64_t v44 = std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::find<grl::IconLayerMapKey>(a1 + 192, (__int16 *)v89);
      if (v41 == v44 || !*(void *)(v44 + 40))
      {
        if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
        }
        int v45 = GEOGetGeoResourceLibRendererLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
        {
          grl::toString<grl::LayerType>(*((unsigned __int16 *)v42 + 16), v89);
          if (v90 >= 0) {
            int v46 = v89;
          }
          else {
            int v46 = (void **)v89[0];
          }
          grl::IconRenderer::description((uint64_t *)__p, (grl::IconRenderer *)a1);
          char v47 = __p;
          if (v93 < 0) {
            char v47 = (void **)__p[0];
          }
          LODWORD(v88.__r_.__value_.__l.__data_) = 136315394;
          *(std::string::size_type *)((char *)v88.__r_.__value_.__r.__words + 4) = (std::string::size_type)v46;
          WORD2(v88.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&v88.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v47;
          _os_log_impl(&dword_1A1780000, v45, OS_LOG_TYPE_ERROR, "A LayerMetrics of type %s failed to generate. %s", (uint8_t *)&v88, 0x16u);
          if (SHIBYTE(v93) < 0) {
            operator delete(__p[0]);
          }
          if (v90 < 0) {
            operator delete(v89[0]);
          }
          uint64_t v41 = a1 + 200;
        }
LABEL_116:
        std::list<grl::IconLayerMapKey>::push_back((uint64_t *)buf, (uint64_t)(v42 + 4));
        goto LABEL_117;
      }
      (*(void (**)(uint64_t))(*(void *)v43 + 24))(v43);
LABEL_117:
      float v50 = (void *)v42[1];
      if (v50)
      {
        do
        {
          unsigned int v51 = v50;
          float v50 = (void *)*v50;
        }
        while (v50);
      }
      else
      {
        do
        {
          unsigned int v51 = (void *)v42[2];
          BOOL v37 = *v51 == (void)v42;
          float v42 = v51;
        }
        while (!v37);
      }
      float v42 = v51;
      if (v51 == v11)
      {
        for (uint64_t i = *(void *)&buf[8]; (unsigned char *)i != buf; uint64_t i = *(void *)(i + 8))
        {
          LODWORD(v89[0]) = *(_DWORD *)(i + 16);
          BYTE4(v89[0]) = 0;
          if (*(unsigned char *)(i + 20))
          {
            BYTE5(v89[0]) = *(unsigned char *)(i + 21);
            BYTE4(v89[0]) = 1;
          }
          uint64_t v53 = *v11;
          if (*v11)
          {
            int v54 = v11;
            do
            {
              int v55 = grl::IconLayerMapKey::operator()(a1 + 64, (__int16 *)(v53 + 32), (__int16 *)v89);
              unsigned __int16 v56 = (uint64_t *)(v53 + 8);
              if (!v55)
              {
                unsigned __int16 v56 = (uint64_t *)v53;
                int v54 = (void *)v53;
              }
              uint64_t v53 = *v56;
            }
            while (*v56);
            if (v54 != v11 && (grl::IconLayerMapKey::operator()(a1 + 64, (__int16 *)v89, (__int16 *)v54 + 16) & 1) == 0)
            {
              float v57 = (void *)v54[1];
              float v58 = v54;
              if (v57)
              {
                do
                {
                  float v59 = v57;
                  float v57 = (void *)*v57;
                }
                while (v57);
              }
              else
              {
                do
                {
                  float v59 = (void *)v58[2];
                  BOOL v37 = *v59 == (void)v58;
                  float v58 = v59;
                }
                while (!v37);
              }
              if ((void *)*v67 == v54) {
                void *v67 = v59;
              }
              --*(void *)(a1 + 56);
              std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 40), v54);
              uint64_t v60 = v54[5];
              v54[5] = 0;
              if (v60) {
                (*(void (**)(uint64_t))(*(void *)v60 + 8))(v60);
              }
              if (*((unsigned char *)v54 + 36)) {
                *((unsigned char *)v54 + 36) = 0;
              }
              (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v54, 48);
            }
          }
        }
        if (*(void *)&buf[16])
        {
          uint64_t v62 = *(void *)buf;
          uint64_t v61 = *(void **)&buf[8];
          uint64_t v63 = **(void **)&buf[8];
          *(void *)(v63 + 8) = *(void *)(*(void *)buf + 8);
          **(void **)(v62 + 8) = v63;
          *(void *)&buf[16] = 0;
          if (v61 != (void *)buf)
          {
            do
            {
              int v64 = (unsigned char *)v61[1];
              operator delete(v61);
              uint64_t v61 = v64;
            }
            while (v64 != buf);
          }
        }
        goto LABEL_149;
      }
    }
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    char v48 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      grl::IconRenderer::description((uint64_t *)v89, (grl::IconRenderer *)a1);
      float v49 = v89;
      if (v90 < 0) {
        float v49 = (void **)v89[0];
      }
      LODWORD(__p[0]) = 136315138;
      *(void **)((char *)__p + 4) = v49;
      _os_log_impl(&dword_1A1780000, v48, OS_LOG_TYPE_ERROR, "Nullptr LayerRenderer found, invalid object. %s", (uint8_t *)__p, 0xCu);
      if (v90 < 0) {
        operator delete(v89[0]);
      }
    }
    goto LABEL_116;
  }
LABEL_149:
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&v79, v80[0]);
  std::__tree<std::__value_type<VKTrafficFeatureType,unsigned long>,std::__map_value_compare<VKTrafficFeatureType,std::__value_type<VKTrafficFeatureType,unsigned long>,std::less<VKTrafficFeatureType>,true>,geo::StdAllocator<std::__value_type<VKTrafficFeatureType,unsigned long>,mdm::Allocator>>::destroy((uint64_t)&v75, v76);
  std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&v71, v72);
  return a1;
}

uint64_t grl::IconMetrics::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(a2 + 4);
    *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
    *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
    *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(a1 + 36) = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 44);
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
    *(_DWORD *)(a1 + 52) = *(_DWORD *)(a2 + 52);
    *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 56);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
    *(_DWORD *)(a1 + 64) = *(_DWORD *)(a2 + 64);
    *(_DWORD *)(a1 + 68) = *(_DWORD *)(a2 + 68);
    std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::destroy(a1 + 72, *(void *)(a1 + 80));
    *(void *)(a1 + 96) = 0;
    *(void *)(a1 + 72) = a1 + 80;
    *(void *)(a1 + 80) = 0;
    uint64_t v4 = *(__int16 **)(a2 + 72);
    if (v4 != (__int16 *)(a2 + 80))
    {
      do
      {
        (*(void (**)(uint64_t *__return_ptr))(**((void **)v4 + 5) + 16))(&v10);
        std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::__emplace_unique_key_args<grl::IconLayerMapKey,grl::IconLayerMapKey const&,std::unique_ptr<grl::LayerMetrics>>((uint64_t **)(a1 + 72), v4 + 16, (uint64_t)(v4 + 16), &v10);
        uint64_t v5 = v10;
        uint64_t v10 = 0;
        if (v5) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
        uint64_t v6 = (__int16 *)*((void *)v4 + 1);
        if (v6)
        {
          do
          {
            int v7 = v6;
            uint64_t v6 = *(__int16 **)v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            int v7 = (__int16 *)*((void *)v4 + 2);
            BOOL v8 = *(void *)v7 == (void)v4;
            uint64_t v4 = v7;
          }
          while (!v8);
        }
        uint64_t v4 = v7;
      }
      while (v7 != (__int16 *)(a2 + 80));
    }
  }
  return a1;
}

uint64_t std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    uint64_t v4 = *(void *)(a2 + 40);
    *(void *)(a2 + 40) = 0;
    if (v4) {
      (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
    }
    if (*(unsigned char *)(a2 + 36)) {
      *(unsigned char *)(a2 + 36) = 0;
    }
    uint64_t v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

uint64_t std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::__emplace_unique_key_args<grl::IconLayerMapKey,grl::IconLayerMapKey const&,std::unique_ptr<grl::LayerMetrics>>(uint64_t **a1, __int16 *a2, uint64_t a3, uint64_t *a4)
{
  BOOL v8 = (uint64_t *)(a1 + 1);
  uint64_t v7 = (uint64_t)a1[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v10 = (uint64_t *)v7;
        char v11 = (__int16 *)(v7 + 32);
        if (!grl::IconLayerMapKey::operator()((uint64_t)(a1 + 4), a2, (__int16 *)(v7 + 32))) {
          break;
        }
        uint64_t v7 = *v10;
        BOOL v8 = v10;
        if (!*v10) {
          goto LABEL_9;
        }
      }
      if (!grl::IconLayerMapKey::operator()((uint64_t)(a1 + 4), v11, a2)) {
        break;
      }
      BOOL v8 = v10 + 1;
      uint64_t v7 = v10[1];
      if (!v7) {
        goto LABEL_9;
      }
    }
    if (*v8) {
      return 0;
    }
  }
  else
  {
    uint64_t v10 = (uint64_t *)(a1 + 1);
  }
LABEL_9:
  uint64_t v12 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*a1[2] + 16))(a1[2], 48, 8);
  uint64_t v13 = (uint64_t *)v12;
  *(_DWORD *)(v12 + 32) = *(_DWORD *)a3;
  *(unsigned char *)(v12 + 36) = 0;
  if (*(unsigned char *)(a3 + 4))
  {
    *(unsigned char *)(v12 + 37) = *(unsigned char *)(a3 + 5);
    *(unsigned char *)(v12 + 36) = 1;
  }
  uint64_t v14 = *a4;
  *a4 = 0;
  *(void *)(v12 + 40) = v14;
  *(void *)uint64_t v12 = 0;
  *(void *)(v12 + 8) = 0;
  *(void *)(v12 + 16) = v10;
  uint64_t *v8 = v12;
  __int16 v15 = (uint64_t *)**a1;
  if (v15)
  {
    *a1 = v15;
    uint64_t v13 = (uint64_t *)*v8;
  }
  std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v13);
  a1[3] = (uint64_t *)((char *)a1[3] + 1);
  return 1;
}

void grl::LayerMetrics::~LayerMetrics(grl::LayerMetrics *this)
{
}

void grl::PathLayerMetrics::~PathLayerMetrics(grl::PathLayerMetrics *this)
{
  *(void *)this = &unk_1EF567050;
  if (*((unsigned char *)this + 92)) {
    *((unsigned char *)this + 92) = 0;
  }
  JUMPOUT(0x1A6239270);
}

{
  *(void *)this = &unk_1EF567050;
  if (*((unsigned char *)this + 92)) {
    *((unsigned char *)this + 92) = 0;
  }
}

void *std::__function::__value_func<void ()(unsigned short,grl::codec::TextLayerData const&)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerMetrics>>,grl::Allocator>>::find<grl::IconLayerMapKey>(uint64_t a1, __int16 *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 32;
  uint64_t v6 = a1 + 8;
  do
  {
    int v7 = grl::IconLayerMapKey::operator()(v5, (__int16 *)(v3 + 32), a2);
    BOOL v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      BOOL v8 = (uint64_t *)v3;
      uint64_t v6 = v3;
    }
    uint64_t v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || grl::IconLayerMapKey::operator()(v5, a2, (__int16 *)(v6 + 32))) {
    return v2;
  }
  return v6;
}

void grl::LayerMetrics::copy(grl::LayerMetrics *this)
{
}

void grl::PathLayerMetrics::copy(grl::PathLayerMetrics *this)
{
}

uint64_t std::__tree<std::__value_type<VKTrafficFeatureType,unsigned long>,std::__map_value_compare<VKTrafficFeatureType,std::__value_type<VKTrafficFeatureType,unsigned long>,std::less<VKTrafficFeatureType>,true>,geo::StdAllocator<std::__value_type<VKTrafficFeatureType,unsigned long>,mdm::Allocator>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<VKTrafficFeatureType,unsigned long>,std::__map_value_compare<VKTrafficFeatureType,std::__value_type<VKTrafficFeatureType,unsigned long>,std::less<VKTrafficFeatureType>,true>,geo::StdAllocator<std::__value_type<VKTrafficFeatureType,unsigned long>,mdm::Allocator>>::destroy(result, *a2);
    std::__tree<std::__value_type<VKTrafficFeatureType,unsigned long>,std::__map_value_compare<VKTrafficFeatureType,std::__value_type<VKTrafficFeatureType,unsigned long>,std::less<VKTrafficFeatureType>,true>,geo::StdAllocator<std::__value_type<VKTrafficFeatureType,unsigned long>,mdm::Allocator>>::destroy(v3, a2[1]);
    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

double grl::codec::IconData::infoLayer@<D0>(grl::codec::IconData *this@<X0>, const grl::IconModifiers *a2@<X1>, uint64_t a3@<X8>)
{
  if (*((float *)a2 + 3) != 1.0 || *((unsigned char *)a2 + 2) != 0)
  {
    int v4 = *((unsigned __int8 *)this + 184);
    goto LABEL_7;
  }
  int v4 = *((unsigned __int8 *)this + 184);
  if (*((unsigned char *)a2 + 25))
  {
LABEL_7:
    if (v4)
    {
      *(float *)&double result = grl::codec::InfoLayerData::InfoLayerData(a3, (uint64_t)this + 188);
      return result;
    }
    return grl::codec::InfoLayerData::InfoLayerData((grl::codec::InfoLayerData *)a3);
  }
  if (*((unsigned char *)this + 184))
  {
    *(void *)a3 = *(void *)((char *)this + 188);
    *(void *)(a3 + 8) = *(void *)((char *)this + 196);
    *(unsigned char *)(a3 + 16) = *((unsigned char *)this + 204);
    double result = *(double *)((char *)this + 205);
    *(double *)(a3 + 17) = result;
    *(_DWORD *)(a3 + 25) = *(_DWORD *)((char *)this + 213);
    *(_DWORD *)(a3 + 32) = *((_DWORD *)this + 55);
    *(_WORD *)(a3 + 36) = *((_WORD *)this + 112);
    return result;
  }
  return grl::codec::InfoLayerData::InfoLayerData((grl::codec::InfoLayerData *)a3);
}

uint64_t grl::IconMetrics::IconMetrics(uint64_t a1, grl::IconRenderer *a2, uint64_t a3)
{
  *(void *)(a1 + 80) = 0;
  uint64_t v6 = a1 + 80;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 88) = grl::Allocator::instance((grl::Allocator *)a1);
  *(void *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 104) = 0;
  *(unsigned char *)(a1 + 108) = 0;
  *(void *)(a1 + 72) = v6;
  if (*((unsigned char *)a2 + 257)) {
    grl::IconMetrics::setupStretchedIcon(a1, (uint64_t)a2, a3);
  }
  else {
    grl::IconMetrics::setupBasicIcon(a1, a2, a3);
  }
  grl::IconMetrics::isValid((grl::IconMetrics *)a1, a2);
  grl::IconMetrics::scaleIcon((float32x2_t *)a1, (uint64_t)a2);
  return a1;
}

float grl::codec::InfoLayerData::InfoLayerData(uint64_t a1, uint64_t a2)
{
  *(void *)a1 = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0xFF000000FF000000;
  *(_DWORD *)(a1 + 16) = 0;
  LODWORD(result) = 255;
  *(void *)(a1 + 20) = 0xFF000000FFLL;
  *(unsigned char *)(a1 + 28) = -1;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_WORD *)(a1 + 36) = 0;
  if (a2)
  {
    uint64_t v3 = 0;
    *(void *)a1 = *(void *)a2;
    do
    {
      *(unsigned char *)(a1 + 8 + v3) = *(unsigned char *)(a2 + 8 + v3);
      ++v3;
    }
    while (v3 != 4);
    for (uint64_t i = 0; i != 4; ++i)
      *(unsigned char *)(a1 + 12 + i) = *(unsigned char *)(a2 + 12 + i);
    uint64_t v5 = 0;
    *(unsigned char *)(a1 + 16) = *(unsigned char *)(a2 + 16);
    do
    {
      *(unsigned char *)(a1 + 17 + v5) = *(unsigned char *)(a2 + 17 + v5);
      ++v5;
    }
    while (v5 != 4);
    for (uint64_t j = 0; j != 4; ++j)
      *(unsigned char *)(a1 + 21 + j) = *(unsigned char *)(a2 + 21 + j);
    for (uint64_t k = 0; k != 4; ++k)
      *(unsigned char *)(a1 + 25 + k) = *(unsigned char *)(a2 + 25 + k);
    float result = *(float *)(a2 + 32);
    *(float *)(a1 + 32) = result;
    *(_WORD *)(a1 + 36) = *(_WORD *)(a2 + 36);
  }
  return result;
}

void *grl::codec::IconData::forEachImageLayer(void *this, grl::IconModifiers *a2, uint64_t a3)
{
  uint64_t v3 = (void *)this[15];
  int v4 = this + 16;
  if (v3 != this + 16)
  {
    int v7 = (grl::codec::IconData *)this;
    do
    {
      unsigned __int16 v8 = *((_WORD *)v3 + 16);
      grl::codec::IconData::imageLayer(v7, a2, v8, (uint64_t)v12);
      this = (void *)std::function<void ()(unsigned short,grl::codec::ImageLayerData const&)>::operator()(a3, v8);
      if (v12[0])
      {
        v12[1] = v12[0];
        this = (void *)(*(uint64_t (**)(uint64_t, void, void))(*(void *)v13 + 40))(v13, v12[0], v12[2] - v12[0]);
      }
      BOOL v9 = (void *)v3[1];
      if (v9)
      {
        do
        {
          uint64_t v10 = v9;
          BOOL v9 = (void *)*v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          uint64_t v10 = (void *)v3[2];
          BOOL v11 = *v10 == (void)v3;
          uint64_t v3 = v10;
        }
        while (!v11);
      }
      uint64_t v3 = v10;
    }
    while (v10 != v4);
  }
  return this;
}

uint64_t std::function<void ()(unsigned short,grl::codec::ImageLayerData const&)>::operator()(uint64_t a1, __int16 a2)
{
  __int16 v7 = a2;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)v2 + 48))(v2, &v7);
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return grl::codec::IconData::imageLayer(v4, v5, v6);
}

__n128 grl::codec::IconData::imageLayer@<Q0>(grl::codec::IconData *this@<X0>, const grl::IconModifiers *a2@<X2>, unsigned int a3@<W1>, uint64_t a4@<X8>)
{
  unsigned __int16 v5 = a3;
  if (*((float *)a2 + 2) == 1.0 && *((unsigned char *)a2 + 1) == 0 && *((unsigned char *)a2 + 25) == 0 && *((unsigned char *)a2 + 5) == 0)
  {
    BOOL v11 = (char *)this + 128;
    uint64_t v10 = (uint64_t **)*((void *)this + 16);
    if (!*((void *)a2 + 24))
    {
      if (v10)
      {
        unsigned int v19 = v11;
        float v20 = v10;
        do
        {
          unsigned int v21 = *((unsigned __int16 *)v20 + 16);
          BOOL v22 = v21 >= a3;
          if (v21 >= a3) {
            uint64_t v23 = (uint64_t ***)v20;
          }
          else {
            uint64_t v23 = (uint64_t ***)(v20 + 1);
          }
          if (v22) {
            unsigned int v19 = (char *)v20;
          }
          float v20 = *v23;
        }
        while (*v23);
        if (v19 != v11 && *((unsigned __int16 *)v19 + 16) <= a3)
        {
          uint64_t v24 = std::map<unsigned short,grl::codec::PathLayerData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::codec::PathLayerData>,grl::Allocator>>::at(v10, a3);
          *(void *)a4 = 0;
          *(void *)(a4 + 8) = 0;
          uint64_t v25 = v24[3];
          *(void *)(a4 + 16) = 0;
          *(void *)(a4 + 24) = v25;
          std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__init_with_size[abi:nn180100]<grl::LayerStyle*,grl::LayerStyle*>(a4, (unsigned char *)*v24, (unsigned char *)v24[1], v24[1] - *v24);
          *(_WORD *)(a4 + 32) = *((_WORD *)v24 + 16);
          *(_DWORD *)(a4 + 34) = *(_DWORD *)((char *)v24 + 34);
          long long v26 = *(_OWORD *)((char *)v24 + 38);
          *(_WORD *)(a4 + 54) = *((_WORD *)v24 + 27);
          *(_OWORD *)(a4 + 38) = v26;
          *(_DWORD *)(a4 + 56) = *((_DWORD *)v24 + 14);
          *(_DWORD *)(a4 + 60) = *((_DWORD *)v24 + 15);
          *(_DWORD *)(a4 + 64) = *((_DWORD *)v24 + 16);
          int v27 = *((_DWORD *)v24 + 17);
          *(unsigned char *)(a4 + 72) = *((unsigned char *)v24 + 72);
          *(_DWORD *)(a4 + 68) = v27;
          *(_DWORD *)(a4 + 73) = *(_DWORD *)((char *)v24 + 73);
          long long v28 = *((_OWORD *)v24 + 5);
          long long v29 = *((_OWORD *)v24 + 6);
          *(void *)(a4 + 112) = v24[14];
          *(_OWORD *)(a4 + 80) = v28;
          *(_OWORD *)(a4 + 96) = v29;
          *(_DWORD *)(a4 + 120) = *((_DWORD *)v24 + 30);
          __n128 result = *(__n128 *)((char *)v24 + 124);
          *(_OWORD *)(a4 + 134) = *(_OWORD *)((char *)v24 + 134);
          *(__n128 *)(a4 + 124) = result;
          return result;
        }
      }
      goto LABEL_38;
    }
  }
  else
  {
    BOOL v11 = (char *)this + 128;
    uint64_t v10 = (uint64_t **)*((void *)this + 16);
  }
  if (v10)
  {
    uint64_t v12 = v11;
    uint64_t v13 = v10;
    do
    {
      unsigned int v14 = *((unsigned __int16 *)v13 + 16);
      BOOL v15 = v14 >= a3;
      if (v14 >= a3) {
        int v16 = (uint64_t ***)v13;
      }
      else {
        int v16 = (uint64_t ***)(v13 + 1);
      }
      if (v15) {
        uint64_t v12 = (char *)v13;
      }
      uint64_t v13 = *v16;
    }
    while (*v16);
    if (v12 != v11 && *((unsigned __int16 *)v12 + 16) <= a3)
    {
      __int16 v17 = std::map<unsigned short,grl::codec::PathLayerData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::codec::PathLayerData>,grl::Allocator>>::at(v10, a3);
      grl::codec::ImageLayerData::ImageLayerData((grl::codec::ImageLayerData *)a4, (const grl::codec::ImageLayerData *)v17, v5, a2);
      return result;
    }
  }
LABEL_38:
  grl::codec::ImageLayerData::ImageLayerData((grl::codec::ImageLayerData *)a4);
  return result;
}

void grl::codec::IconData::forEachTextLayer(uint64_t a1, const IconModifiers *a2, uint64_t a3)
{
  if (*(void *)&a2->_textLocale._value.type && !*(void *)(a1 + 112))
  {
    grl::codec::TextLayerData::TextLayerData((grl::codec::TextLayerData *)&v27, 0, 0, a2);
    std::function<void ()(unsigned short,grl::codec::TextLayerData const&)>::operator()(*(void *)(a3 + 24), 0);
    if (v36 < 0) {
      operator delete(__p);
    }
    if (v34 < 0) {
      operator delete(v33);
    }
    if (v32 < 0) {
      operator delete(v31);
    }
    if (v27)
    {
      uint64_t v28 = v27;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v30 + 40))(v30, v27, v29 - v27);
    }
  }
  uint64_t v6 = *(uint64_t ***)(a1 + 88);
  __int16 v7 = (uint64_t **)(a1 + 96);
  if (v6 != (uint64_t **)(a1 + 96))
  {
    do
    {
      unsigned int v8 = *((unsigned __int16 *)v6 + 16);
      if (*(void *)&a2->_textLocale._value.type) {
        BOOL v9 = 0;
      }
      else {
        BOOL v9 = *(&a2->_component + 4) == 0;
      }
      if (v9 && !a2->_isClusterIcon && !a2->_isSelected)
      {
        uint64_t v12 = *v7;
        if (!a2->_pathScale._value.data[1])
        {
          if (v12)
          {
            unsigned int v19 = v7;
            float v20 = *v7;
            do
            {
              unsigned int v21 = *((unsigned __int16 *)v20 + 16);
              BOOL v22 = v21 >= v8;
              if (v21 >= v8) {
                uint64_t v23 = (uint64_t **)v20;
              }
              else {
                uint64_t v23 = (uint64_t **)(v20 + 1);
              }
              if (v22) {
                unsigned int v19 = (uint64_t **)v20;
              }
              float v20 = *v23;
            }
            while (*v23);
            if (v19 != v7 && *((unsigned __int16 *)v19 + 16) <= v8)
            {
              while (1)
              {
                while (1)
                {
                  unsigned int v26 = *((unsigned __int16 *)v12 + 16);
                  if (v26 <= v8) {
                    break;
                  }
                  uint64_t v12 = (uint64_t *)*v12;
                  if (!v12) {
                    goto LABEL_71;
                  }
                }
                if (v26 >= v8) {
                  break;
                }
                uint64_t v12 = (uint64_t *)v12[1];
                if (!v12) {
LABEL_71:
                }
                  abort();
              }
              grl::codec::TextLayerData::TextLayerData((grl::codec::TextLayerData *)&v27, (const grl::codec::TextLayerData *)(v12 + 5));
              goto LABEL_48;
            }
          }
LABEL_47:
          grl::codec::TextLayerData::TextLayerData((grl::codec::TextLayerData *)&v27);
          goto LABEL_48;
        }
      }
      else
      {
        uint64_t v12 = *v7;
      }
      if (!v12) {
        goto LABEL_47;
      }
      uint64_t v13 = v7;
      unsigned int v14 = v12;
      do
      {
        unsigned int v15 = *((unsigned __int16 *)v14 + 16);
        BOOL v16 = v15 >= v8;
        if (v15 >= v8) {
          __int16 v17 = (uint64_t **)v14;
        }
        else {
          __int16 v17 = (uint64_t **)(v14 + 1);
        }
        if (v16) {
          uint64_t v13 = (uint64_t **)v14;
        }
        unsigned int v14 = *v17;
      }
      while (*v17);
      if (v13 == v7 || *((unsigned __int16 *)v13 + 16) > v8) {
        goto LABEL_47;
      }
      int v18 = std::map<unsigned short,grl::codec::PathLayerData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::codec::PathLayerData>,grl::Allocator>>::at((uint64_t **)v12, *((_WORD *)v6 + 16));
      grl::codec::TextLayerData::TextLayerData((grl::codec::TextLayerData *)&v27, (const grl::codec::TextLayerData *)v18, v8, a2);
LABEL_48:
      std::function<void ()(unsigned short,grl::codec::TextLayerData const&)>::operator()(*(void *)(a3 + 24), v8);
      if (v36 < 0) {
        operator delete(__p);
      }
      if (v34 < 0) {
        operator delete(v33);
      }
      if (v32 < 0) {
        operator delete(v31);
      }
      if (v27)
      {
        uint64_t v28 = v27;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v30 + 40))(v30, v27, v29 - v27);
      }
      uint64_t v24 = v6[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = (uint64_t **)v24;
          uint64_t v24 = (uint64_t *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (uint64_t **)v6[2];
          BOOL v9 = *v25 == (uint64_t *)v6;
          uint64_t v6 = v25;
        }
        while (!v9);
      }
      uint64_t v6 = v25;
    }
    while (v25 != v7);
  }
}

uint64_t *std::map<unsigned short,grl::codec::PathLayerData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::codec::PathLayerData>,grl::Allocator>>::at(uint64_t **a1, unsigned __int16 a2)
{
  if (!a1) {
LABEL_7:
  }
    abort();
  while (1)
  {
    while (1)
    {
      unsigned int v2 = *((unsigned __int16 *)a1 + 16);
      if (v2 <= a2) {
        break;
      }
      a1 = (uint64_t **)*a1;
      if (!a1) {
        goto LABEL_7;
      }
    }
    if (v2 >= a2) {
      return (uint64_t *)(a1 + 5);
    }
    a1 = (uint64_t **)a1[1];
    if (!a1) {
      goto LABEL_7;
    }
  }
}

uint64_t std::function<void ()(unsigned short,grl::codec::TextLayerData const&)>::operator()(uint64_t a1, __int16 a2)
{
  __int16 v7 = a2;
  if (a1) {
    return (*(uint64_t (**)(uint64_t, __int16 *))(*(void *)a1 + 48))(a1, &v7);
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return grl::codec::ImageLayerData::ImageLayerData(v3, v4, v5, v6);
}

grl::codec::ImageLayerData *grl::codec::ImageLayerData::ImageLayerData(grl::codec::ImageLayerData *this, const grl::codec::ImageLayerData *a2, unsigned __int16 a3, const grl::IconModifiers *a4)
{
  __int16 v17 = 515;
  char v18 = 1;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  uint64_t v8 = grl::Allocator::instance(this);
  *((void *)this + 3) = v8;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 16))(v8, 3, 1);
  uint64_t v10 = 0;
  *(void *)this = v9;
  *((void *)this + 2) = v9 + 3;
  do
  {
    if (v9 + v10) {
      *(unsigned char *)(v9 + v10) = *((unsigned char *)&v17 + v10);
    }
    ++v10;
  }
  while (v10 != 3);
  *((void *)this + 1) = v9 + 3;
  *((_DWORD *)this + 30) = -16777216;
  *((_DWORD *)this + 8) = 0;
  *((_WORD *)this + 18) = -256;
  *((unsigned char *)this + 38) = 0;
  *((void *)this + 5) = 0;
  *((unsigned char *)this + 48) = 0;
  *((_DWORD *)this + 14) = -16777216;
  *((_DWORD *)this + 13) = 1119092736;
  *((_DWORD *)this + 15) = 1065353216;
  *((_DWORD *)this + 16) = -16777216;
  *((_DWORD *)this + 17) = 0;
  *((_DWORD *)this + 18) = 1;
  *((unsigned char *)this + 76) = -1;
  *((void *)this + 13) = 0;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *(void *)((char *)this + 93) = 0;
  *((unsigned char *)this + 112) = 2;
  *((_DWORD *)this + 29) = 1065353216;
  *(void *)((char *)this + 140) = 0;
  *(void *)((char *)this + 129) = 0;
  *(void *)((char *)this + 124) = 0;
  *((_WORD *)this + 74) = 1;
  if (a2)
  {
    uint64_t v11 = 0;
    *((_WORD *)this + 16) = *((_WORD *)a2 + 16);
    do
    {
      *((unsigned char *)this + v11 + 34) = *((unsigned char *)a2 + v11 + 34);
      ++v11;
    }
    while (v11 != 4);
    uint64_t v12 = 0;
    *((unsigned char *)this + 38) = *((unsigned char *)a2 + 38);
    *((_DWORD *)this + 10) = *((_DWORD *)a2 + 10);
    *((_DWORD *)this + 11) = *((_DWORD *)a2 + 11);
    *((unsigned char *)this + 48) = *((unsigned char *)a2 + 48);
    *((_DWORD *)this + 13) = *((_DWORD *)a2 + 13);
    do
    {
      *((unsigned char *)this + v12 + 56) = *((unsigned char *)a2 + v12 + 56);
      ++v12;
    }
    while (v12 != 4);
    uint64_t v13 = 0;
    *((_DWORD *)this + 15) = *((_DWORD *)a2 + 15);
    do
    {
      *((unsigned char *)this + v13 + 64) = *((unsigned char *)a2 + v13 + 64);
      ++v13;
    }
    while (v13 != 4);
    uint64_t v14 = 0;
    *((_DWORD *)this + 17) = *((_DWORD *)a2 + 17);
    *((unsigned char *)this + 72) = *((unsigned char *)a2 + 72);
    do
    {
      *((unsigned char *)this + v14 + 73) = *((unsigned char *)a2 + v14 + 73);
      ++v14;
    }
    while (v14 != 4);
    uint64_t v15 = 0;
    *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
    *((_DWORD *)this + 21) = *((_DWORD *)a2 + 21);
    *((_DWORD *)this + 22) = *((_DWORD *)a2 + 22);
    *((_DWORD *)this + 23) = *((_DWORD *)a2 + 23);
    *((_DWORD *)this + 24) = *((_DWORD *)a2 + 24);
    *((unsigned char *)this + 100) = *((unsigned char *)a2 + 100);
    *((_DWORD *)this + 26) = *((_DWORD *)a2 + 26);
    *((_DWORD *)this + 27) = *((_DWORD *)a2 + 27);
    *((unsigned char *)this + 112) = *((unsigned char *)a2 + 112);
    *((_DWORD *)this + 29) = *((_DWORD *)a2 + 29);
    do
    {
      *((unsigned char *)this + v15 + 120) = *((unsigned char *)a2 + v15 + 120);
      ++v15;
    }
    while (v15 != 4);
    *((_DWORD *)this + 31) = *((_DWORD *)a2 + 31);
    *((_DWORD *)this + 32) = *((_DWORD *)a2 + 32);
    *((_DWORD *)this + 33) = *((_DWORD *)a2 + 33);
    *((unsigned char *)this + 136) = *((unsigned char *)a2 + 136);
    *((_DWORD *)this + 35) = *((_DWORD *)a2 + 35);
    *((_DWORD *)this + 36) = *((_DWORD *)a2 + 36);
    *((_WORD *)this + 74) = *((_WORD *)a2 + 74);
  }
  grl::codec::ImageLayerData::applyModifiers(this, a3, a4);
  return this;
}

void *grl::codec::ImageLayerData::applyModifiers(void *this, unsigned __int16 a2, const grl::IconModifiers *a3)
{
  int v4 = this;
  if (*((unsigned char *)this + 38) == 1 && *((unsigned char *)a3 + 25) != 0) {
    *(_DWORD *)((char *)this + 34) = *(_DWORD *)((char *)a3 + 26);
  }
  if (*((unsigned char *)this + 33))
  {
    __int16 __src = 770;
    char v7 = 1;
    this = std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__assign_with_size[abi:nn180100]<grl::LayerStyle const*,grl::LayerStyle const*>(this, (char *)&__src, (char *)&v8, 3uLL);
  }
  if (*((unsigned char *)a3 + 5)) {
    *((unsigned char *)v4 + 112) = 0;
  }
  return this;
}

grl::codec::TextLayerData *grl::codec::TextLayerData::TextLayerData(grl::codec::TextLayerData *this)
{
  __int16 v6 = 515;
  char v7 = 1;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  uint64_t v2 = grl::Allocator::instance(this);
  *((void *)this + 3) = v2;
  uint64_t v3 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2 + 16))(v2, 3, 1);
  uint64_t v4 = 0;
  *(void *)this = v3;
  *((void *)this + 2) = v3 + 3;
  do
  {
    if (v3 + v4) {
      *(unsigned char *)(v3 + v4) = *((unsigned char *)&v6 + v4);
    }
    ++v4;
  }
  while (v4 != 3);
  *((void *)this + 1) = v3 + 3;
  *((_DWORD *)this + 8) = -16777216;
  *((unsigned char *)this + 36) = 0;
  std::string::basic_string[abi:nn180100]<0>((void *)this + 5, "");
  *(_DWORD *)((char *)this + 67) = 0;
  *((_DWORD *)this + 16) = 0;
  *((unsigned char *)this + 71) = -1;
  *((void *)this + 9) = 0;
  *(void *)((char *)this + 79) = 0;
  *((unsigned char *)this + 87) = -1;
  std::string::basic_string[abi:nn180100]<0>((void *)this + 11, "");
  *(_DWORD *)((char *)this + 115) = 0;
  *((_DWORD *)this + 28) = 0;
  *((unsigned char *)this + 119) = -1;
  *((_DWORD *)this + 30) = 0;
  *(_DWORD *)((char *)this + 123) = 0;
  *((unsigned char *)this + 127) = -1;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  std::string::basic_string[abi:nn180100]<0>((void *)this + 18, "");
  *((void *)this + 21) = 0;
  *((_WORD *)this + 88) = 1;
  return this;
}

grl::codec::TextLayerData *grl::codec::TextLayerData::TextLayerData(grl::codec::TextLayerData *this, const grl::codec::TextLayerData *a2, unsigned int a3, const IconModifiers *a4)
{
  __int16 v19 = 515;
  char v20 = 1;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  uint64_t v8 = grl::Allocator::instance(this);
  *((void *)this + 3) = v8;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 16))(v8, 3, 1);
  uint64_t v10 = 0;
  *(void *)this = v9;
  *((void *)this + 2) = v9 + 3;
  do
  {
    if (v9 + v10) {
      *(unsigned char *)(v9 + v10) = *((unsigned char *)&v19 + v10);
    }
    ++v10;
  }
  while (v10 != 3);
  *((void *)this + 1) = v9 + 3;
  *((_DWORD *)this + 8) = -16777216;
  *((unsigned char *)this + 36) = 0;
  std::string::basic_string[abi:nn180100]<0>((void *)this + 5, "");
  *(_DWORD *)((char *)this + 67) = 0;
  *((_DWORD *)this + 16) = 0;
  *((unsigned char *)this + 71) = -1;
  *((void *)this + 9) = 0;
  *(void *)((char *)this + 79) = 0;
  *((unsigned char *)this + 87) = -1;
  std::string::basic_string[abi:nn180100]<0>((void *)this + 11, "");
  *((_DWORD *)this + 28) = 0;
  *(_DWORD *)((char *)this + 115) = 0;
  *((unsigned char *)this + 119) = -1;
  *((_DWORD *)this + 30) = 0;
  *(_DWORD *)((char *)this + 123) = 0;
  *((unsigned char *)this + 127) = -1;
  *((void *)this + 16) = 0;
  *((_DWORD *)this + 34) = 0;
  uint64_t v11 = (std::string *)std::string::basic_string[abi:nn180100]<0>((void *)this + 18, "");
  *((void *)this + 21) = 0;
  *((_WORD *)this + 88) = 1;
  if (a2)
  {
    char v18 = v11;
    for (uint64_t i = 0; i != 4; ++i)
      *((unsigned char *)this + i + 32) = *((unsigned char *)a2 + i + 32);
    *((unsigned char *)this + 36) = *((unsigned char *)a2 + 36);
    std::string::operator=((std::string *)((char *)this + 40), (const std::string *)((char *)a2 + 40));
    uint64_t v13 = 0;
    *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
    do
    {
      *((unsigned char *)this + v13 + 68) = *((unsigned char *)a2 + v13 + 68);
      ++v13;
    }
    while (v13 != 4);
    uint64_t v14 = 0;
    *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
    *((_DWORD *)this + 19) = *((_DWORD *)a2 + 19);
    *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
    do
    {
      *((unsigned char *)this + v14 + 84) = *((unsigned char *)a2 + v14 + 84);
      ++v14;
    }
    while (v14 != 4);
    std::string::operator=((std::string *)((char *)this + 88), (const std::string *)((char *)a2 + 88));
    uint64_t v15 = 0;
    *((_DWORD *)this + 28) = *((_DWORD *)a2 + 28);
    do
    {
      *((unsigned char *)this + v15 + 116) = *((unsigned char *)a2 + v15 + 116);
      ++v15;
    }
    while (v15 != 4);
    uint64_t v16 = 0;
    *((_DWORD *)this + 30) = *((_DWORD *)a2 + 30);
    do
    {
      *((unsigned char *)this + v16 + 124) = *((unsigned char *)a2 + v16 + 124);
      ++v16;
    }
    while (v16 != 4);
    *((_DWORD *)this + 32) = *((_DWORD *)a2 + 32);
    *((_DWORD *)this + 33) = *((_DWORD *)a2 + 33);
    *((_DWORD *)this + 34) = *((_DWORD *)a2 + 34);
    std::string::operator=(v18, (const std::string *)a2 + 6);
    *((_DWORD *)this + 42) = *((_DWORD *)a2 + 42);
    *((_DWORD *)this + 43) = *((_DWORD *)a2 + 43);
    *((_WORD *)this + 88) = *((_WORD *)a2 + 88);
  }
  grl::codec::TextLayerData::applyModifiers(this, a3, a4);
  return this;
}

void *std::string::basic_string[abi:nn180100]<0>(void *a1, char *__s)
{
  size_t v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  size_t v5 = v4;
  if (v4 >= 0x17)
  {
    uint64_t v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17) {
      uint64_t v7 = v4 | 7;
    }
    uint64_t v8 = v7 + 1;
    __int16 v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((unsigned char *)a1 + 23) = v4;
    __int16 v6 = a1;
    if (!v4) {
      goto LABEL_9;
    }
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((unsigned char *)v6 + v5) = 0;
  return a1;
}

double grl::codec::TextLayerData::applyModifiers(grl::codec::TextLayerData *this, unsigned int a2, const IconModifiers *a3)
{
  if (*((unsigned char *)this + 36) == 1 && a3->_pathScale._value.data[1] != 0)
  {
    int v6 = *(_DWORD *)((char *)&a3->_pathScale._value.type + 2);
    *((_DWORD *)this + 8) = v6;
    *((_DWORD *)this + 21) = v6;
  }
  double type = a3->_tailDirection._value.type;
  if (type != 0.0)
  {
    p_value = &a3->_tailDirection._value;
    do
    {
      unsigned int v9 = *(unsigned __int16 *)(*(void *)&type + 32);
      BOOL v10 = v9 >= a2;
      if (v9 >= a2) {
        double v11 = type;
      }
      else {
        *(void *)&double v11 = *(void *)&type + 8;
      }
      if (v10) {
        p_value = *(ValueUnion **)&type;
      }
      double type = **(double **)&v11;
    }
    while (**(void **)&v11);
    if (p_value != &a3->_tailDirection._value && LOWORD(p_value[4].type) <= a2) {
      std::string::operator=((std::string *)this + 6, (const std::string *)&p_value[5]);
    }
  }
  if (*(&a3->_component + 4))
  {
    LODWORD(result) = *(_DWORD *)&a3->_customColor._hasValue;
    *((_DWORD *)this + 16) = LODWORD(result);
  }
  if (a3->_isClusterIcon)
  {
    std::string::basic_string[abi:nn180100]<0>(&v14, "%$default,heavy");
    uint64_t v13 = (void **)((char *)this + 40);
    if (*((char *)this + 63) < 0) {
      operator delete(*v13);
    }
    double result = *(double *)&v14;
    *(_OWORD *)uint64_t v13 = v14;
    *((void *)this + 7) = v15;
  }
  return result;
}

uint64_t grl::codec::IconData::forEachPathLayer(uint64_t result, grl::IconModifiers *this, uint64_t a3)
{
  uint64_t v5 = result;
  if (*((void *)this + 18) != *((void *)this + 19) && *((unsigned __int8 *)this + 24) <= 1u)
  {
    unsigned __int16 v7 = 0;
    do
    {
      ++v7;
      uint64_t v8 = std::map<unsigned short,grl::codec::PathLayerData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::codec::PathLayerData>,grl::Allocator>>::at(*(uint64_t ***)(v5 + 160), 0);
      grl::codec::PathLayerData::PathLayerData((grl::codec::PathLayerData *)&v34, (const grl::codec::PathLayerData *)v8, v7, this);
      double result = std::function<void ()(unsigned short,grl::codec::PathLayerData const&)>::operator()(*(void *)(a3 + 24), v7);
      if (v34)
      {
        uint64_t v35 = v34;
        double result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37 + 40))(v37, v34, v36 - v34);
      }
    }
    while ((uint64_t)(*((void *)this + 19) - *((void *)this + 18)) >> 2 > (unint64_t)v7);
  }
  unsigned int v9 = *(void **)(v5 + 152);
  BOOL v10 = (void *)(v5 + 160);
  if (v9 != (void *)(v5 + 160))
  {
    do
    {
      unsigned int v11 = *((unsigned __int16 *)v9 + 16);
      BOOL isPathDefault = grl::IconModifiers::isPathDefault(this);
      uint64_t v13 = (uint64_t *)*v10;
      if (isPathDefault)
      {
        if (v13)
        {
          long long v14 = v10;
          uint64_t v15 = *v10;
          do
          {
            unsigned int v16 = *(unsigned __int16 *)(v15 + 32);
            BOOL v17 = v16 >= v11;
            if (v16 >= v11) {
              char v18 = (uint64_t *)v15;
            }
            else {
              char v18 = (uint64_t *)(v15 + 8);
            }
            if (v17) {
              long long v14 = (void *)v15;
            }
            uint64_t v15 = *v18;
          }
          while (*v18);
          if (v14 != v10 && *((unsigned __int16 *)v14 + 16) <= v11)
          {
            while (1)
            {
              while (1)
              {
                unsigned int v19 = *((unsigned __int16 *)v13 + 16);
                if (v19 <= v11) {
                  break;
                }
                uint64_t v13 = (uint64_t *)*v13;
                if (!v13) {
                  goto LABEL_58;
                }
              }
              if (v19 >= v11) {
                break;
              }
              uint64_t v13 = (uint64_t *)v13[1];
              if (!v13) {
                goto LABEL_58;
              }
            }
            uint64_t v34 = 0;
            uint64_t v35 = 0;
            uint64_t v29 = v13[8];
            uint64_t v36 = 0;
            uint64_t v37 = v29;
            std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__init_with_size[abi:nn180100]<grl::LayerStyle*,grl::LayerStyle*>((uint64_t)&v34, (unsigned char *)v13[5], (unsigned char *)v13[6], v13[6] - v13[5]);
            __int16 v38 = *((_WORD *)v13 + 36);
            int v39 = *(_DWORD *)((char *)v13 + 74);
            int v40 = *((_DWORD *)v13 + 20);
            int v30 = *((_DWORD *)v13 + 27);
            int v43 = *((_DWORD *)v13 + 26);
            int v31 = *((_DWORD *)v13 + 21);
            long long v42 = *(_OWORD *)(v13 + 11);
            int v41 = v31;
            int v44 = v30;
            int v45 = *((_DWORD *)v13 + 28);
            int v32 = *((_DWORD *)v13 + 30);
            int v46 = *((_DWORD *)v13 + 29);
            int v47 = v32;
            char v48 = *((unsigned char *)v13 + 124);
            int v49 = *(_DWORD *)((char *)v13 + 125);
            int v33 = *((_DWORD *)v13 + 36);
            int v51 = *((_DWORD *)v13 + 35);
            uint64_t v50 = *(uint64_t *)((char *)v13 + 132);
            int v52 = v33;
            *(_OWORD *)uint64_t v53 = *(_OWORD *)((char *)v13 + 148);
            *(void *)&v53[13] = *(uint64_t *)((char *)v13 + 161);
            goto LABEL_40;
          }
        }
      }
      else if (v13)
      {
        char v20 = v10;
        uint64_t v21 = *v10;
        do
        {
          unsigned int v22 = *(unsigned __int16 *)(v21 + 32);
          BOOL v23 = v22 >= v11;
          if (v22 >= v11) {
            uint64_t v24 = (uint64_t *)v21;
          }
          else {
            uint64_t v24 = (uint64_t *)(v21 + 8);
          }
          if (v23) {
            char v20 = (void *)v21;
          }
          uint64_t v21 = *v24;
        }
        while (*v24);
        if (v20 != v10 && *((unsigned __int16 *)v20 + 16) <= v11)
        {
          while (1)
          {
            while (1)
            {
              unsigned int v28 = *((unsigned __int16 *)v13 + 16);
              if (v28 <= v11) {
                break;
              }
              uint64_t v13 = (uint64_t *)*v13;
              if (!v13) {
                goto LABEL_58;
              }
            }
            if (v28 >= v11) {
              break;
            }
            uint64_t v13 = (uint64_t *)v13[1];
            if (!v13) {
LABEL_58:
            }
              abort();
          }
          grl::codec::PathLayerData::PathLayerData((grl::codec::PathLayerData *)&v34, (const grl::codec::PathLayerData *)(v13 + 5), v11, this);
          goto LABEL_40;
        }
      }
      grl::codec::PathLayerData::PathLayerData((grl::codec::PathLayerData *)&v34);
LABEL_40:
      double result = std::function<void ()(unsigned short,grl::codec::PathLayerData const&)>::operator()(*(void *)(a3 + 24), v11);
      if (v34)
      {
        uint64_t v35 = v34;
        double result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v37 + 40))(v37, v34, v36 - v34);
      }
      uint64_t v25 = (void *)v9[1];
      if (v25)
      {
        do
        {
          unsigned int v26 = v25;
          uint64_t v25 = (void *)*v25;
        }
        while (v25);
      }
      else
      {
        do
        {
          unsigned int v26 = (void *)v9[2];
          BOOL v27 = *v26 == (void)v9;
          unsigned int v9 = v26;
        }
        while (!v27);
      }
      unsigned int v9 = v26;
    }
    while (v26 != v10);
  }
  return result;
}

__n128 grl::ImageLayerRenderer::setLayerMetrics(grl::ImageLayerRenderer *this, const grl::LayerMetrics *a2)
{
  if (*((unsigned char *)this + 168)) {
    (**((void (***)(void))this + 22))();
  }
  else {
    *((unsigned char *)this + 168) = 1;
  }
  *((void *)this + 22) = &unk_1EF567000;
  long long v4 = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 184) = v4;
  __n128 result = *(__n128 *)((char *)a2 + 40);
  long long v6 = *(_OWORD *)((char *)a2 + 56);
  long long v7 = *(_OWORD *)((char *)a2 + 72);
  *((_DWORD *)this + 66) = *((_DWORD *)a2 + 22);
  *(_OWORD *)((char *)this + 248) = v7;
  *(_OWORD *)((char *)this + 232) = v6;
  *(__n128 *)((char *)this + 216) = result;
  return result;
}

float32x2_t grl::IconMetrics::scaleIcon(float32x2_t *a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 72))
  {
    a1[1] = vmul_n_f32(a1[1], COERCE_FLOAT(*(void *)(a2 + 108)));
    float32x2_t v2 = a1[4];
    a1[3] = vmul_n_f32(a1[3], COERCE_FLOAT(*(void *)(a2 + 108)));
    a1[4] = vmul_n_f32(v2, COERCE_FLOAT(*(void *)(a2 + 108)));
    float32x2_t v3 = a1[6];
    a1[5] = vmul_n_f32(a1[5], COERCE_FLOAT(*(void *)(a2 + 108)));
    a1[6] = vmul_n_f32(v3, COERCE_FLOAT(*(void *)(a2 + 108)));
    float32x2_t result = vmul_n_f32(a1[7], COERCE_FLOAT(*(void *)(a2 + 108)));
    a1[7] = result;
  }
  return result;
}

uint64_t grl::IconMetrics::isValid(grl::IconMetrics *this, const grl::IconRenderer *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)a2 + 257))
  {
    int v4 = grl::IconRenderer::layerCount((uint64_t)a2, 3);
    BOOL v5 = v4 == 1;
    if (v4 != 1)
    {
      if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
      }
      long long v6 = GEOGetGeoResourceLibMetricsLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)float buf = 0;
        _os_log_impl(&dword_1A1780000, v6, OS_LOG_TYPE_ERROR, "Stretched icons should never have more than one TextLayer.", buf, 2u);
      }
    }
    if (*((unsigned char *)a2 + 257))
    {
      long long v7 = (grl::IconMetrics *)*((void *)this + 9);
      if (v7 != (grl::IconMetrics *)((char *)this + 80))
      {
        int v8 = 0;
        do
        {
          if (*((_WORD *)v7 + 16) == 2)
          {
            if (!*((void *)v7 + 5))
            {
              if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
                dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
              }
              unsigned int v9 = GEOGetGeoResourceLibMetricsLog::log;
              if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)float buf = 136315650;
                unsigned int v22 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
                __int16 v23 = 2080;
                uint64_t v24 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconMetrics.cpp";
                __int16 v25 = 1024;
                int v26 = 551;
                _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_ERROR, "A nullptr for LayerMetrics for an ImageLayer has been found.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
              }
              BOOL v5 = 0;
            }
            uint64_t v10 = *((void *)v7 + 5);
            if (v8)
            {
              if (v20 != *(void *)(v10 + 44))
              {
                if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
                  dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
                }
                unsigned int v11 = GEOGetGeoResourceLibMetricsLog::log;
                if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)float buf = 136315650;
                  unsigned int v22 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
                  __int16 v23 = 2080;
                  uint64_t v24 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconMetrics.cpp";
                  __int16 v25 = 1024;
                  int v26 = 556;
                  _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_ERROR, "Image layers are different sizes after being stretched, unsupported behavior.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
                }
                BOOL v5 = 0;
              }
            }
            else
            {
              uint64_t v20 = *(void *)(v10 + 44);
              int v8 = 1;
            }
          }
          uint64_t v12 = (grl::IconMetrics *)*((void *)v7 + 1);
          if (v12)
          {
            do
            {
              uint64_t v13 = v12;
              uint64_t v12 = *(grl::IconMetrics **)v12;
            }
            while (v12);
          }
          else
          {
            do
            {
              uint64_t v13 = (grl::IconMetrics *)*((void *)v7 + 2);
              BOOL v14 = *(void *)v13 == (void)v7;
              long long v7 = v13;
            }
            while (!v14);
          }
          long long v7 = v13;
        }
        while (v13 != (grl::IconMetrics *)((char *)this + 80));
      }
    }
  }
  else
  {
    BOOL v5 = 1;
  }
  if (*((float *)this + 8) < 16384.0 && *((float *)this + 9) < 16384.0)
  {
    int v16 = 1;
  }
  else
  {
    if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
    }
    uint64_t v15 = GEOGetGeoResourceLibMetricsLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      unsigned int v22 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      __int16 v23 = 2080;
      uint64_t v24 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconMetrics.cpp";
      __int16 v25 = 1024;
      int v26 = 566;
      _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_ERROR, "Unusally large size icon, if this is intended please adjust maxIconSizeDimension.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
    }
    int v16 = 0;
  }
  if (*((float *)this + 8) > 0.0 && *((float *)this + 9) > 0.0)
  {
    int v18 = 1;
  }
  else
  {
    if (GEOGetGeoResourceLibMetricsLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibMetricsLog::onceToken, &__block_literal_global_21_0);
    }
    BOOL v17 = GEOGetGeoResourceLibMetricsLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMetricsLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)float buf = 0;
      _os_log_impl(&dword_1A1780000, v17, OS_LOG_TYPE_ERROR, "An icon with size of 0 or less has been generated.", buf, 2u);
    }
    int v18 = 0;
  }
  return v16 & v18 & v5;
}

unsigned char *geo::optional<std::string>::optional(unsigned char *a1, uint64_t a2)
{
  *a1 = 0;
  float32x2_t v3 = (std::string *)(a1 + 8);
  if (*(unsigned char *)a2)
  {
    if (*(char *)(a2 + 31) < 0)
    {
      std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(a2 + 8), *(void *)(a2 + 16));
    }
    else
    {
      long long v4 = *(_OWORD *)(a2 + 8);
      v3->__r_.__value_.__r.__words[2] = *(void *)(a2 + 24);
      *(_OWORD *)&v3->__r_.__value_.__l.__data_ = v4;
    }
    *a1 = 1;
  }
  return a1;
}

BOOL grl::IconModifiers::isPathDefault(grl::IconModifiers *this)
{
  return !*((unsigned char *)this + 24)
      && *((void *)this + 18) == *((void *)this + 19)
      && !*((unsigned char *)this + 25)
      && !*(unsigned char *)this
      && !*((unsigned char *)this + 2)
      && !*((unsigned char *)this + 16)
      && !*((unsigned char *)this + 44)
      && !*((unsigned char *)this + 5)
      && !*((unsigned char *)this + 7)
      && *((unsigned char *)this + 30) == 0;
}

__n128 grl::ShapeLayerRenderer::setLayerMetrics(grl::ShapeLayerRenderer *this, const grl::LayerMetrics *a2)
{
  if (*((unsigned char *)this + 152)) {
    (**((void (***)(void))this + 20))();
  }
  else {
    *((unsigned char *)this + 152) = 1;
  }
  *((void *)this + 20) = &unk_1EF567000;
  long long v4 = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 184) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 168) = v4;
  long long v5 = *(_OWORD *)((char *)a2 + 40);
  long long v6 = *(_OWORD *)((char *)a2 + 56);
  long long v7 = *(_OWORD *)((char *)a2 + 72);
  *((_DWORD *)this + 62) = *((_DWORD *)a2 + 22);
  *(_OWORD *)((char *)this + 232) = v7;
  *(_OWORD *)((char *)this + 216) = v6;
  *(_OWORD *)((char *)this + 200) = v5;
  *((void *)this + 20) = &unk_1EF567050;
  *((unsigned char *)this + 252) = 0;
  if (*((unsigned char *)a2 + 92))
  {
    *((unsigned char *)this + 253) = *((unsigned char *)a2 + 93);
    *((unsigned char *)this + 252) = 1;
  }
  __n128 result = *((__n128 *)a2 + 6);
  long long v9 = *((_OWORD *)a2 + 7);
  *((_DWORD *)this + 72) = *((_DWORD *)a2 + 32);
  *((__n128 *)this + 16) = result;
  *((_OWORD *)this + 17) = v9;
  return result;
}

uint64_t grl::PathLayerMetrics::PathLayerMetrics(uint64_t a1, uint64_t a2, float *a3, double a4, double a5, double a6, double a7, double a8)
{
  *(_WORD *)(a1 + 8) = 1;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 76) = 0u;
  *(void *)a1 = &unk_1EF567050;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_DWORD *)(a1 + 128) = 0;
  unsigned int v9 = *(unsigned __int8 *)(a2 + 120);
  *(unsigned char *)(a1 + 92) = 1;
  *(unsigned char *)(a1 + 93) = v9;
  if (v9 <= 9)
  {
    if (((1 << v9) & 0x3D8) != 0) {
      grl::PathLayerMetrics::constructBalloonMetrics(a1, a2, a3, 0.0, *(int32x2_t *)&a5, a6, a7);
    }
    else {
      grl::PathLayerMetrics::constructPathMetrics(a1, a2, (int8x8_t *)a3, 0.0, a5, a6, a7, a8);
    }
  }
  return a1;
}

grl::codec::PathLayerData *grl::codec::PathLayerData::PathLayerData(grl::codec::PathLayerData *this, const grl::codec::PathLayerData *a2, unsigned int a3, const grl::IconModifiers *a4)
{
  __int16 v18 = 515;
  char v19 = 1;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = 0;
  uint64_t v8 = grl::Allocator::instance(this);
  *((void *)this + 3) = v8;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v8 + 16))(v8, 3, 1);
  uint64_t v10 = 0;
  *(void *)this = v9;
  *((void *)this + 2) = v9 + 3;
  do
  {
    if (v9 + v10) {
      *(unsigned char *)(v9 + v10) = *((unsigned char *)&v18 + v10);
    }
    ++v10;
  }
  while (v10 != 3);
  *((void *)this + 1) = v9 + 3;
  *(_DWORD *)((char *)this + 34) = -1;
  *((_WORD *)this + 16) = 0;
  *((_DWORD *)this + 10) = 0;
  *(_DWORD *)((char *)this + 43) = 0;
  *(_WORD *)((char *)this + 47) = 255;
  *(void *)((char *)this + 52) = 0;
  *((unsigned char *)this + 60) = 0;
  *((_DWORD *)this + 16) = 1119092736;
  *((_DWORD *)this + 17) = -16777216;
  *((_DWORD *)this + 18) = 1065353216;
  *((_DWORD *)this + 19) = -16777216;
  *((_DWORD *)this + 20) = 0;
  *((_DWORD *)this + 21) = 1;
  *((unsigned char *)this + 88) = -1;
  *((_DWORD *)this + 23) = 0;
  *((unsigned char *)this + 96) = 0;
  *((_DWORD *)this + 26) = -16777216;
  *((_DWORD *)this + 25) = 1065353216;
  *((_DWORD *)this + 31) = 0;
  *(void *)((char *)this + 113) = 0;
  *(void *)((char *)this + 108) = 0;
  *((unsigned char *)this + 128) = 1;
  if (a2)
  {
    uint64_t v11 = 0;
    *((_WORD *)this + 16) = *((_WORD *)a2 + 16);
    do
    {
      *((unsigned char *)this + v11 + 34) = *((unsigned char *)a2 + v11 + 34);
      ++v11;
    }
    while (v11 != 4);
    uint64_t v12 = 0;
    *((_DWORD *)this + 10) = *((_DWORD *)a2 + 10);
    do
    {
      *((unsigned char *)this + v12 + 44) = *((unsigned char *)a2 + v12 + 44);
      ++v12;
    }
    while (v12 != 4);
    uint64_t v13 = 0;
    *((unsigned char *)this + 48) = *((unsigned char *)a2 + 48);
    *((_DWORD *)this + 13) = *((_DWORD *)a2 + 13);
    *((_DWORD *)this + 14) = *((_DWORD *)a2 + 14);
    *((unsigned char *)this + 60) = *((unsigned char *)a2 + 60);
    *((_DWORD *)this + 16) = *((_DWORD *)a2 + 16);
    do
    {
      *((unsigned char *)this + v13 + 68) = *((unsigned char *)a2 + v13 + 68);
      ++v13;
    }
    while (v13 != 4);
    uint64_t v14 = 0;
    *((_DWORD *)this + 18) = *((_DWORD *)a2 + 18);
    do
    {
      *((unsigned char *)this + v14 + 76) = *((unsigned char *)a2 + v14 + 76);
      ++v14;
    }
    while (v14 != 4);
    uint64_t v15 = 0;
    *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
    *((unsigned char *)this + 84) = *((unsigned char *)a2 + 84);
    do
    {
      *((unsigned char *)this + v15 + 85) = *((unsigned char *)a2 + v15 + 85);
      ++v15;
    }
    while (v15 != 4);
    uint64_t v16 = 0;
    *((_DWORD *)this + 23) = *((_DWORD *)a2 + 23);
    *((unsigned char *)this + 96) = *((unsigned char *)a2 + 96);
    *((_DWORD *)this + 25) = *((_DWORD *)a2 + 25);
    do
    {
      *((unsigned char *)this + v16 + 104) = *((unsigned char *)a2 + v16 + 104);
      ++v16;
    }
    while (v16 != 4);
    *((_DWORD *)this + 27) = *((_DWORD *)a2 + 27);
    *((_DWORD *)this + 28) = *((_DWORD *)a2 + 28);
    *((_DWORD *)this + 29) = *((_DWORD *)a2 + 29);
    *((unsigned char *)this + 120) = *((unsigned char *)a2 + 120);
    *((_DWORD *)this + 31) = *((_DWORD *)a2 + 31);
    *((unsigned char *)this + 128) = *((unsigned char *)a2 + 128);
  }
  grl::codec::PathLayerData::applyModifiers(this, a3, a4);
  return this;
}

void *grl::codec::PathLayerData::applyModifiers(grl::codec::PathLayerData *this, unsigned int a2, const grl::IconModifiers *a3)
{
  __src[4] = *MEMORY[0x1E4F143B8];
  if (*((unsigned char *)this + 48) == 1 && *((unsigned char *)a3 + 25) != 0) {
    *((_DWORD *)this + 11) = *(_DWORD *)((char *)a3 + 26);
  }
  if (*((unsigned char *)this + 33))
  {
    LOWORD(__src[0]) = 770;
    BYTE2(__src[0]) = 1;
    std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__assign_with_size[abi:nn180100]<grl::LayerStyle const*,grl::LayerStyle const*>(this, (char *)__src, (char *)__src + 3, 3uLL);
  }
  if (*((unsigned char *)a3 + 44)) {
    *((_DWORD *)this + 31) = *((_DWORD *)a3 + 12);
  }
  std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::__value_func[abi:nn180100]((uint64_t)__src, (uint64_t)a3 + 168);
  uint64_t v7 = __src[3];
  __n128 result = std::function<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~function(__src);
  if (v7) {
    *((_DWORD *)this + 11) = *(_DWORD *)((char *)this + 85);
  }
  if (*((unsigned char *)a3 + 24))
  {
    LOWORD(__src[0]) = 258;
    __n128 result = std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__assign_with_size[abi:nn180100]<grl::LayerStyle const*,grl::LayerStyle const*>(this, (char *)__src, (char *)__src + 2, 2uLL);
    if (*((unsigned char *)a3 + 24) == 5)
    {
      LOBYTE(__src[0]) = 3;
      __n128 result = std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__assign_with_size[abi:nn180100]<grl::LayerStyle const*,grl::LayerStyle const*>(this, (char *)__src, (char *)__src + 1, 1uLL);
    }
    *((unsigned char *)this + 96) = 1;
  }
  if (*((unsigned char *)a3 + 30))
  {
    uint64_t v9 = 0;
    uint64_t v10 = (char *)a3 + 31;
    do
    {
      *((unsigned char *)this + v9 + 44) = v10[v9];
      ++v9;
    }
    while (v9 != 4);
    for (uint64_t i = 0; i != 4; ++i)
      *((unsigned char *)this + i + 85) = v10[i];
  }
  if (*((unsigned char *)a3 + 16)) {
    *((_DWORD *)this + 25) = *((_DWORD *)a3 + 5);
  }
  if (*((unsigned char *)a3 + 7))
  {
    *((unsigned char *)this + 120) = 4;
    *((_DWORD *)this + 31) = 1083623604;
    *(_DWORD *)((char *)this + 85) = *((_DWORD *)this + 11);
  }
  uint64_t v13 = *((void *)a3 + 18);
  uint64_t v12 = *((void *)a3 + 19);
  if (v13 != v12 && *((unsigned __int8 *)a3 + 24) <= 1u)
  {
    unint64_t v15 = (unsigned __int16)(a2 - 1);
    if (v15 < (v12 - v13) >> 2)
    {
      uint64_t v16 = 0;
      uint64_t v17 = v13 + 4 * v15;
      do
      {
        *((unsigned char *)this + v16 + 44) = *(unsigned char *)(v17 + v16);
        ++v16;
      }
      while (v16 != 4);
      *((unsigned char *)this + 60) = 1;
      *((unsigned char *)this + 96) = 0;
      *((float *)this + 25) = powf(0.95, (float)a2);
    }
    LOWORD(__src[0]) = 258;
    return std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__assign_with_size[abi:nn180100]<grl::LayerStyle const*,grl::LayerStyle const*>(this, (char *)__src, (char *)__src + 2, 2uLL);
  }
  return result;
}

void grl::TextLayerMetrics::copy(grl::TextLayerMetrics *this)
{
}

void grl::TextLayerMetrics::~TextLayerMetrics(grl::TextLayerMetrics *this)
{
}

__n128 grl::TextLayerRenderer::setLayerMetrics(grl::TextLayerRenderer *this, const grl::LayerMetrics *a2)
{
  if (*((unsigned char *)this + 200)) {
    (**((void (***)(void))this + 26))();
  }
  else {
    *((unsigned char *)this + 200) = 1;
  }
  *((void *)this + 26) = &unk_1EF567000;
  long long v4 = *(_OWORD *)((char *)a2 + 8);
  *(_OWORD *)((char *)this + 232) = *(_OWORD *)((char *)a2 + 24);
  *(_OWORD *)((char *)this + 216) = v4;
  __n128 result = *(__n128 *)((char *)a2 + 40);
  long long v6 = *(_OWORD *)((char *)a2 + 56);
  long long v7 = *(_OWORD *)((char *)a2 + 72);
  *((_DWORD *)this + 74) = *((_DWORD *)a2 + 22);
  *(_OWORD *)((char *)this + 264) = v6;
  *(_OWORD *)((char *)this + 280) = v7;
  *(__n128 *)((char *)this + 248) = result;
  *((void *)this + 26) = &unk_1EF5670C8;
  *(void *)((char *)this + 300) = *(void *)((char *)a2 + 92);
  return result;
}

uint64_t grl::TextLayerMetrics::TextLayerMetrics(uint64_t a1, uint64_t a2, float32x2_t *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  *(_WORD *)(a1 + 8) = 3;
  *(_OWORD *)(a1 + 76) = 0u;
  *(_OWORD *)(a1 + 60) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 12) = 0u;
  *(void *)a1 = &unk_1EF5670C8;
  *(void *)(a1 + 92) = 0;
  float v4 = roundf(a3[1].f32[1] - a3->f32[1]);
  float v5 = *(float *)(a2 + 76);
  float v6 = roundf(a3[1].f32[0] - a3->f32[0]) + v5;
  float v7 = v6 + *(float *)(a2 + 80);
  *(float *)(a1 + 12) = v5;
  *(_DWORD *)(a1 + 16) = 0;
  *(float *)(a1 + 20) = v6;
  *(float *)(a1 + 24) = v4 + 0.0;
  *(float *)(a1 + 28) = v5;
  *(_DWORD *)(a1 + 32) = 0;
  *(float *)(a1 + 36) = v6;
  *(float *)(a1 + 40) = v4 + 0.0;
  *(float *)(a1 + 44) = v7;
  *(float *)(a1 + 48) = v4;
  float32x2_t v8 = *a3;
  *(float32x2_t *)(a1 + 92) = vneg_f32(*a3);
  *(float *)(a1 + 92) = *(float *)(a2 + 76) - v8.f32[0];
  *(void *)uint64_t v11 = 0;
  if (!*(void *)(a1 + 44))
  {
    if (GEOGetGeoResourceLibMathLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibMathLog::onceToken, &__block_literal_global_25_0);
    }
    uint64_t v9 = GEOGetGeoResourceLibMathLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibMathLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)uint64_t v11 = 136315650;
      *(void *)&v11[4] = "_size != gm::Vector2f::zero()";
      __int16 v12 = 2080;
      uint64_t v13 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/TextLayerMetrics.cpp";
      __int16 v14 = 1024;
      int v15 = 39;
      _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_ERROR, "A TextLayer of size zero has been generated.: Assertion with expression - %s : Failed in file - %s line - %i", v11, 0x1Cu);
    }
  }
  return a1;
}

void sub_1A17F0D10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t md::LabelCoreStyleGroup::update(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, float a6, float a7)
{
  if ((int)a6 >= 0x17) {
    unsigned int v14 = 23;
  }
  else {
    unsigned int v14 = (int)a6;
  }
  if (a5)
  {
    *(_OWORD *)(a1 + 107) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)a1 = 0u;
  }
  float v15 = *(float *)(a3 + 20 * a4);
  uint64_t v16 = *(void *)(*(void *)a2 + 24);
  unsigned int v17 = *(unsigned __int8 *)(v16 + 12);
  if (v17 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    float v18 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v16, 0xC1u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v16, 0xC1u, v14, 1u, &v174);
  }
  else
  {
    float v18 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0xC1u, v14, v17, 0);
  }
  float v19 = v15 * a7;
  float v20 = v19 * v18;
  *(float *)(a1 + 32) = v20;
  unint64_t v21 = *(void *)(*(void *)a2 + 24);
  unsigned int v22 = *(unsigned __int8 *)(v21 + 12);
  if (v22 != 2)
  {
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v21, 0x172u, v14, *(unsigned __int8 *)(v21 + 12)) & 1) == 0)
    {
      *(float *)(a1 + 36) = v20;
      float v24 = fminf(fmaxf(a6, 0.0), 23.0);
      goto LABEL_19;
    }
    float v23 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v21, 0x172u, v14, v22, 0);
    goto LABEL_15;
  }
  if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v21, 0x172u, v14, 0) & 1) != 0
    || (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v21, 0x172u, v14, 1u) & 1) != 0)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    float v23 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v21, 0x172u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v21, 0x172u, v14, 1u, &v174);
LABEL_15:
    float v20 = fminf(v19 * v23, *(float *)(a1 + 32));
    unint64_t v21 = *(void *)(*(void *)a2 + 24);
    unsigned int v22 = *(unsigned __int8 *)(v21 + 12);
  }
  *(float *)(a1 + 36) = v20;
  float v24 = fminf(fmaxf(a6, 0.0), 23.0);
  if (v22 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v21, 0x5Eu, 0, (BOOL *)&v171, v24);
    int v26 = v25;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v21, 0x5Eu, 1u, (BOOL *)&v174, v24);
    goto LABEL_20;
  }
LABEL_19:
  gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v21, 0x5Eu, v22, 0, v24);
  int v26 = v27;
LABEL_20:
  *(_DWORD *)(a1 + 12) = v26;
  unint64_t v28 = *(void *)(*(void *)a2 + 24);
  unsigned int v29 = *(unsigned __int8 *)(v28 + 12);
  if (v29 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v28, 0xEAu, 0, (BOOL *)&v171, v24);
    float v31 = v30;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v28, 0xEAu, 1u, (BOOL *)&v174, v24);
  }
  else
  {
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0xEAu, v29, 0, v24);
    float v31 = v32;
  }
  *(float *)(a1 + 8) = v31 * a7;
  unint64_t v33 = *(void *)(*(void *)a2 + 24);
  unsigned int v34 = *(unsigned __int8 *)(v33 + 12);
  if (v34 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v33, 0x149u, 0, (BOOL *)&v171, v24);
    float v36 = v35;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v33, 0x149u, 1u, (BOOL *)&v174, v24);
  }
  else
  {
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x149u, v34, 0, v24);
    float v36 = v37;
  }
  *(float *)(a1 + 60) = v36 * a7;
  unint64_t v38 = *(void *)(*(void *)a2 + 24);
  unsigned int v39 = *(unsigned __int8 *)(v38 + 12);
  if (v39 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v38, 0x159u, 0, (BOOL *)&v171, v24);
    float v41 = v40;
    unint64_t result = gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v38, 0x159u, 1u, (BOOL *)&v174, v24);
  }
  else
  {
    unint64_t result = gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x159u, v39, 0, v24);
    float v41 = v43;
  }
  *(float *)(a1 + 56) = fmaxf(v41, 0.01);
  if (!a5) {
    return result;
  }
  uint64_t v44 = *(void *)(*(void *)a2 + 24);
  int v45 = *(unsigned __int8 *)(v44 + 12);
  if (v45 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    char v46 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v44, 0x5Bu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v44, 0x5Bu, v14, 1, &v174);
  }
  else
  {
    char v46 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)a2 + 24), 0x5Bu, v14, v45, 0);
  }
  *(unsigned char *)a1 = v46;
  uint64_t v47 = *(void *)(*(void *)a2 + 24);
  unsigned int v48 = *(unsigned __int8 *)(v47 + 12);
  if (v48 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v49 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v47, 0x7Bu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v47, 0x7Bu, v14, 1u, &v174);
  }
  else
  {
    int v49 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0x7Bu, v14, v48, 0);
  }
  *(unsigned char *)(a1 + 101) = v49;
  uint64_t v50 = *(void *)(*(void *)a2 + 24);
  int v51 = *(unsigned __int8 *)(v50 + 12);
  if (v51 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    char v52 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v50, 0x13Au, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v50, 0x13Au, v14, 1, &v174);
  }
  else
  {
    char v52 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)a2 + 24), 0x13Au, v14, v51, 0);
  }
  *(unsigned char *)(a1 + 1) = v52;
  uint64_t v53 = *(void *)(*(void *)a2 + 24);
  unsigned int v54 = *(unsigned __int8 *)(v53 + 12);
  if (v54 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v55 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x68u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v53, 0x68u, v14, 1u, &v174);
  }
  else
  {
    int v55 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0x68u, v14, v54, 0);
  }
  *(_DWORD *)(a1 + 16) = v55;
  uint64_t v56 = *(void *)(*(void *)a2 + 24);
  unsigned int v57 = *(unsigned __int8 *)(v56 + 12);
  if (v57 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v58 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(v56, 0x84u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(v56, 0x84u, v14, 1u, &v174);
  }
  else
  {
    int v58 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(*(void *)(*(void *)a2 + 24), 0x84u, v14, v57, 0);
  }
  int v59 = (char)v58;
  if ((char)v58 <= -3) {
    int v59 = -3;
  }
  if (v59 >= 7) {
    LOBYTE(v59) = 7;
  }
  if ((v58 - 8) >= 0xF5u) {
    LOBYTE(v59) = v58;
  }
  *(unsigned char *)(a1 + 100) = v59;
  uint64_t v60 = *(void *)(*(void *)a2 + 24);
  unsigned int v61 = *(unsigned __int8 *)(v60 + 12);
  if (v61 == 2)
  {
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v60, 0xD6u, v14, 0) & 1) != 0
      || (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v60, 0xD6u, v14, 1u) & 1) != 0)
    {
      LOBYTE(v171) = 1;
      v174.i8[0] = 1;
      int v62 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v60, 0xD6u, v14, 0, &v171);
      gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v60, 0xD6u, v14, 1, &v174);
LABEL_57:
      LOBYTE(v63) = v62 != 0;
      goto LABEL_63;
    }
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v64 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0xAAu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0xAAu, v14, 1u, &v174);
  }
  else
  {
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v60, 0xD6u, v14, *(unsigned __int8 *)(v60 + 12)))
    {
      int v62 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v60, 0xD6u, v14, v61, 0);
      goto LABEL_57;
    }
    int v64 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v60, 0xAAu, v14, v61, 0);
  }
  if (v64 > 0xBu) {
    LOBYTE(v63) = 0;
  }
  else {
    unsigned int v63 = (0xFFEu >> v64) & 1;
  }
LABEL_63:
  *(unsigned char *)(a1 + 2) = v63;
  uint64_t v65 = *(void *)(*(void *)a2 + 24);
  unsigned int v66 = *(unsigned __int8 *)(v65 + 12);
  if (v66 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v67 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v65, 0x15Bu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v65, 0x15Bu, v14, 1u, &v174);
  }
  else
  {
    int v67 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x15Bu, v14, v66, 0);
  }
  *(_DWORD *)(a1 + 64) = v67;
  uint64_t v68 = *(void *)(*(void *)a2 + 24);
  unsigned int v69 = *(unsigned __int8 *)(v68 + 12);
  if (v69 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v70 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v68, 0x15Cu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v68, 0x15Cu, v14, 1u, &v174);
  }
  else
  {
    int v70 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x15Cu, v14, v69, 0);
  }
  *(_DWORD *)(a1 + 68) = v70;
  uint64_t v71 = *(void *)(*(void *)a2 + 24);
  unsigned int v72 = *(unsigned __int8 *)(v71 + 12);
  if (v72 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v73 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(v71, 0xEBu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(v71, 0xEBu, v14, 1u, &v174);
  }
  else
  {
    int v73 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(*(void *)(*(void *)a2 + 24), 0xEBu, v14, v72, 0);
  }
  *(_DWORD *)(a1 + 20) = v73;
  uint64_t v74 = *(void *)(*(void *)a2 + 24);
  unsigned int v75 = *(unsigned __int8 *)(v74 + 12);
  if (v75 == 2)
  {
    if ((gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v74, 0xEDu, v14, 0) & 1) != 0
      || (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v74, 0xEDu, v14, 1u) & 1) != 0)
    {
      LOBYTE(v171) = 1;
      v174.i8[0] = 1;
      int v76 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(v74, 0xEDu, v14, 0, &v171);
      uint64_t v77 = v74;
      unsigned int v78 = 237;
    }
    else
    {
      LOBYTE(v171) = 1;
      v174.i8[0] = 1;
      int v76 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(v74, 0x84u, v14, 0, &v171);
      uint64_t v77 = v74;
      unsigned int v78 = 132;
    }
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(v77, v78, v14, 1u, &v174);
  }
  else
  {
    if (gss::RenderStyle<gss::PropertyID>::hasValueForKeyAtZAtEnd(v74, 0xEDu, v14, *(unsigned __int8 *)(v74 + 12)))
    {
      uint64_t v79 = v74;
      unsigned int v80 = 237;
    }
    else
    {
      uint64_t v79 = v74;
      unsigned int v80 = 132;
    }
    int v76 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(v79, v80, v14, v75, 0);
  }
  int v81 = (char)v76;
  if ((char)v76 <= -3) {
    int v81 = -3;
  }
  if (v81 >= 7) {
    LOBYTE(v81) = 7;
  }
  if ((v76 - 8) >= 0xF5u) {
    LOBYTE(v81) = v76;
  }
  *(unsigned char *)(a1 + 120) = v81;
  uint64_t v82 = *(void *)(*(void *)a2 + 24);
  unsigned int v83 = *(unsigned __int8 *)(v82 + 12);
  if (v83 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v84 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v82, 0xECu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v82, 0xECu, v14, 1u, &v174);
  }
  else
  {
    int v84 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xECu, v14, v83, 0);
  }
  *(unsigned char *)(a1 + 121) = v84;
  uint64_t v85 = *(void *)(*(void *)a2 + 24);
  int v86 = *(unsigned __int8 *)(v85 + 12);
  if (v86 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    unsigned int v87 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned char>((unsigned __int16 *)v85, 0x1D5u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned char>((unsigned __int16 *)v85, 0x1D5u, v14, 1, &v174);
  }
  else
  {
    unsigned int v87 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned char>(*(unsigned __int16 **)(*(void *)a2 + 24), 0x1D5u, v14, v86, 0);
  }
  if (v87 >= 0x1F) {
    char v88 = 31;
  }
  else {
    char v88 = v87;
  }
  *(unsigned char *)(a1 + 122) = v88;
  uint64_t v89 = *(void *)(*(void *)a2 + 24);
  unsigned int v90 = *(unsigned __int8 *)(v89 + 12);
  if (v90 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v91 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v89, 0x1D6u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v89, 0x1D6u, v14, 1u, &v174);
  }
  else
  {
    int v91 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0x1D6u, v14, v90, 0);
  }
  *(_DWORD *)(a1 + 116) = v91;
  uint64_t v92 = *(void *)(*(void *)a2 + 24);
  unsigned int v93 = *(unsigned __int8 *)(v92 + 12);
  if (v93 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v94 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v92, 0x9Du, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v92, 0x9Du, v14, 1u, &v174);
  }
  else
  {
    int v94 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0x9Du, v14, v93, 0);
  }
  *(_DWORD *)(a1 + 40) = v94;
  uint64_t v95 = *(void *)(*(void *)a2 + 24);
  unsigned int v96 = *(unsigned __int8 *)(v95 + 12);
  if (v96 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v97 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v95, 0x9Eu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v95, 0x9Eu, v14, 1u, &v174);
  }
  else
  {
    int v97 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x9Eu, v14, v96, 0);
  }
  *(_DWORD *)(a1 + 44) = v97;
  uint64_t v98 = *(void *)(*(void *)a2 + 24);
  unsigned int v99 = *(unsigned __int8 *)(v98 + 12);
  if (v99 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v100 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v98, 0x1B3u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v98, 0x1B3u, v14, 1u, &v174);
  }
  else
  {
    int v100 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x1B3u, v14, v99, 0);
  }
  *(_DWORD *)(a1 + 48) = v100;
  uint64_t v101 = *(void *)(*(void *)a2 + 24);
  unsigned int v102 = *(unsigned __int8 *)(v101 + 12);
  if (v102 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v103 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v101, 0x1BFu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v101, 0x1BFu, v14, 1u, &v174);
  }
  else
  {
    int v103 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x1BFu, v14, v102, 0);
  }
  *(_DWORD *)(a1 + 52) = v103;
  uint64_t v104 = *(void *)(*(void *)a2 + 24);
  unsigned int v105 = *(unsigned __int8 *)(v104 + 12);
  if (v105 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v106 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v104, 0xA9u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v104, 0xA9u, v14, 1u, &v174);
  }
  else
  {
    int v106 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xA9u, v14, v105, 0);
  }
  *(unsigned char *)(a1 + 110) = v106;
  uint64_t v107 = *(void *)(*(void *)a2 + 24);
  unsigned int v108 = *(unsigned __int8 *)(v107 + 12);
  if (v108 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v109 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v107, 0xDFu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v107, 0xDFu, v14, 1u, &v174);
  }
  else
  {
    int v109 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xDFu, v14, v108, 0);
  }
  *(unsigned char *)(a1 + 111) = v109;
  uint64_t v110 = *(void *)(*(void *)a2 + 24);
  unsigned int v111 = *(unsigned __int8 *)(v110 + 12);
  if (v111 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v112 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v110, 0x13Bu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v110, 0x13Bu, v14, 1u, &v174);
  }
  else
  {
    int v112 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0x13Bu, v14, v111, 0);
  }
  *(unsigned char *)(a1 + 102) = v112;
  uint64_t v113 = *(void *)(*(void *)a2 + 24);
  unsigned int v114 = *(unsigned __int8 *)(v113 + 12);
  if (v114 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v115 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v113, 0xE0u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v113, 0xE0u, v14, 1u, &v174);
  }
  else
  {
    int v115 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xE0u, v14, v114, 0);
  }
  *(unsigned char *)(a1 + 104) = gss::MaskToLabelPosition((unsigned __int16)v115);
  uint64_t v116 = *(void *)(*(void *)a2 + 24);
  unsigned int v117 = *(unsigned __int8 *)(v116 + 12);
  if (v117 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v118 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v116, 0xE1u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v116, 0xE1u, v14, 1u, &v174);
  }
  else
  {
    int v118 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xE1u, v14, v117, 0);
  }
  *(_WORD *)(a1 + 106) = v118;
  uint64_t v119 = *(void *)(*(void *)a2 + 24);
  unsigned int v120 = *(unsigned __int8 *)(v119 + 12);
  if (v120 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v121 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v119, 0xA7u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v119, 0xA7u, v14, 1u, &v174);
  }
  else
  {
    int v121 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xA7u, v14, v120, 0);
  }
  *(unsigned char *)(a1 + 108) = v121;
  uint64_t v122 = *(void *)(*(void *)a2 + 24);
  unsigned int v123 = *(unsigned __int8 *)(v122 + 12);
  if (v123 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v124 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v122, 0xA8u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v122, 0xA8u, v14, 1u, &v174);
  }
  else
  {
    int v124 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xA8u, v14, v123, 0);
  }
  *(unsigned char *)(a1 + 109) = v124;
  uint64_t v125 = *(void *)(*(void *)a2 + 24);
  int v126 = *(unsigned __int8 *)(v125 + 12);
  if (v126 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    char v127 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v125, 0x110u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v125, 0x110u, v14, 1, &v174);
  }
  else
  {
    char v127 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(*(void *)a2 + 24), 0x110u, v14, v126, 0);
  }
  *(unsigned char *)(a1 + 3) = v127;
  uint64_t v128 = *(void *)(*(void *)a2 + 24);
  unsigned int v129 = *(unsigned __int8 *)(v128 + 12);
  if (v129 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v130 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v128, 0x14Eu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v128, 0x14Eu, v14, 1u, &v174);
  }
  else
  {
    int v130 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0x14Eu, v14, v129, 0);
  }
  *(unsigned char *)(a1 + 112) = v130;
  uint64_t v131 = *(void *)(*(void *)a2 + 24);
  unsigned int v132 = *(unsigned __int8 *)(v131 + 12);
  if (v132 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v133 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v131, 0x157u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v131, 0x157u, v14, 1u, &v174);
  }
  else
  {
    int v133 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0x157u, v14, v132, 0);
  }
  *(unsigned char *)(a1 + 113) = v133;
  uint64_t v134 = *(void *)(*(void *)a2 + 24);
  unsigned int v135 = *(unsigned __int8 *)(v134 + 12);
  if (v135 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v136 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v134, 0x161u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v134, 0x161u, v14, 1u, &v174);
  }
  else
  {
    int v136 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0x161u, v14, v135, 0);
  }
  *(unsigned char *)(a1 + 103) = v136;
  uint64_t v137 = *(void *)(*(void *)a2 + 24);
  unsigned int v138 = *(unsigned __int8 *)(v137 + 12);
  if (v138 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v139 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v137, 0x163u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v137, 0x163u, v14, 1u, &v174);
  }
  else
  {
    int v139 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x163u, v14, v138, 0);
  }
  *(_DWORD *)(a1 + 72) = v139;
  unsigned __int8 v173 = 1;
  uint64_t v140 = *(void *)(*(void *)a2 + 24);
  unsigned int v141 = *(unsigned __int8 *)(v140 + 12);
  if (v141 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    float v142 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v140, 0x165u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v140, 0x165u, v14, 1u, &v174);
    int v143 = (v171 | v174.u8[0]) != 0;
  }
  else
  {
    float v142 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x165u, v14, v141, &v173);
    int v143 = v173;
  }
  float v144 = 3.4028e38;
  if (v143) {
    float v144 = v142;
  }
  *(float *)(a1 + 76) = v144;
  uint64_t v145 = *(void *)(*(void *)a2 + 24);
  unsigned int v146 = *(unsigned __int8 *)(v145 + 12);
  if (v146 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v147 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v145, 0x1B4u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v145, 0x1B4u, v14, 1u, &v174);
  }
  else
  {
    int v147 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x1B4u, v14, v146, 0);
  }
  *(_DWORD *)(a1 + 80) = v147;
  uint64_t v148 = *(void *)(*(void *)a2 + 24);
  unsigned int v149 = *(unsigned __int8 *)(v148 + 12);
  if (v149 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v150 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v148, 0x1BEu, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v148, 0x1BEu, v14, 1u, &v174);
  }
  else
  {
    int v150 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x1BEu, v14, v149, 0);
  }
  *(_DWORD *)(a1 + 84) = v150;
  unsigned __int8 v173 = 1;
  uint64_t v151 = *(void *)(*(void *)a2 + 24);
  unsigned int v152 = *(unsigned __int8 *)(v151 + 12);
  if (v152 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    float v153 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v151, 0x1C1u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v151, 0x1C1u, v14, 1u, &v174);
    int v154 = (v171 | v174.u8[0]) != 0;
  }
  else
  {
    float v153 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x1C1u, v14, v152, &v173);
    int v154 = v173;
  }
  float v155 = 0.0;
  if (v154) {
    float v155 = v153;
  }
  *(float *)(a1 + 88) = v155;
  unsigned __int8 v173 = 1;
  uint64_t v156 = *(void *)(*(void *)a2 + 24);
  unsigned int v157 = *(unsigned __int8 *)(v156 + 12);
  if (v157 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    float v158 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v156, 0x1C2u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v156, 0x1C2u, v14, 1u, &v174);
    int v159 = (v171 | v174.u8[0]) != 0;
  }
  else
  {
    float v158 = *(float *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x1C2u, v14, v157, &v173);
    int v159 = v173;
  }
  float v160 = 180.0;
  if (v159) {
    float v160 = v158;
  }
  *(float *)(a1 + 92) = v160;
  uint64_t v161 = *(void *)(*(void *)a2 + 24);
  unsigned int v162 = *(unsigned __int8 *)(v161 + 12);
  if (v162 == 2)
  {
    LOBYTE(v171) = 1;
    v174.i8[0] = 1;
    int v163 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v161, 0xD2u, v14, 0, &v171);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v161, 0xD2u, v14, 1u, &v174);
  }
  else
  {
    int v163 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xD2u, v14, v162, 0);
  }
  *(unsigned char *)(a1 + 4) = v163;
  char v172 = 0;
  uint64_t v171 = 0;
  md::FontSizeInfo::update((uint64_t)&v171, a2, a3, a4, 0, a6);
  *(_DWORD *)(a1 + 96) = HIDWORD(v171);
  uint64_t v164 = *(void *)(*(void *)a2 + 24);
  unsigned int v165 = *(unsigned __int8 *)(v164 + 12);
  if (v165 == 2)
  {
    v174.i8[0] = 1;
    unsigned __int8 v173 = 1;
    int v166 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v164, 0x15Eu, v14, 0, &v174);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(v164, 0x15Eu, v14, 1u, &v173);
  }
  else
  {
    int v166 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<float>(*(void *)(*(void *)a2 + 24), 0x15Eu, v14, v165, 0);
  }
  *(_DWORD *)(a1 + 24) = v166;
  uint64_t v167 = *(void *)(*(void *)a2 + 24);
  unsigned int v168 = *(unsigned __int8 *)(v167 + 12);
  if (v168 == 2)
  {
    v174.i8[0] = 1;
    unsigned __int8 v173 = 1;
    int v169 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v167, 0xD2u, v14, 0, &v174);
    gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v167, 0xD2u, v14, 1u, &v173);
  }
  else
  {
    int v169 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a2 + 24), 0xD2u, v14, v168, 0);
  }
  *(unsigned char *)(a1 + 4) = v169;
  unint64_t result = (unint64_t)gss::RenderStyle<gss::PropertyID>::valueForKeyAtZ<geo::Color<unsigned short,4,(geo::ColorSpace)0>>((unint64_t *)&v174, *(void *)(*(void *)a2 + 24), 0x1B6u, v14, 1u, 0);
  int16x8_t v170 = (int16x8_t)vcvtq_s32_f32(vmulq_f32(vcvtq_f32_u32(vmovl_u16(v174)), (float32x4_t)vdupq_n_s32(0x3B7F00FFu)));
  *(int16x4_t *)v170.i8 = vmovn_s32((int32x4_t)v170);
  *(_DWORD *)(a1 + 28) = vmovn_s16(v170).u32[0];
  return result;
}

void *gss::defaultValueForKey<gss::PropertyID,unsigned int>(int a1)
{
  if (a1 > 286)
  {
    if (a1 <= 364)
    {
      if (a1 <= 327)
      {
        switch(a1)
        {
          case 287:
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotationColorSource;
          case 315:
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelTextPlacementSource;
          case 316:
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultNavLabelShieldSize;
        }
        return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
      }
      switch(a1)
      {
        case 334:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultPickedLabelBalloonBehavior;
          break;
        case 335:
        case 336:
        case 337:
        case 338:
        case 340:
        case 342:
          return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
        case 339:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotationTextSource;
          break;
        case 341:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultTransitPlacement;
          break;
        case 343:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelMeshPositioningMode;
          break;
        default:
          if (a1 != 328) {
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
          }
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelTextSizingMode;
          break;
      }
    }
    else
    {
      if (a1 > 453)
      {
        if (a1 > 476)
        {
          if (a1 == 477) {
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotationOffsetPosition;
          }
          if (a1 == 480) {
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultManeuverDisplayMode;
          }
        }
        else
        {
          if (a1 == 454) {
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultExternalFeatureCategory;
          }
          if (a1 == 470) {
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelCollisionExclusionGroups;
          }
        }
        return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
      }
      switch(a1)
      {
        case 365:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotationImageSource;
          break;
        case 367:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelSecondaryAnnotationTextSource;
          break;
        case 368:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelSecondaryAnnotationImageSource;
          break;
        case 374:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotationLayout;
          break;
        case 375:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotation2Layout;
          break;
        case 376:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotation2TextSource;
          break;
        case 377:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotation2ImageSource;
          break;
        case 383:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultAlt1LabelIconImageSource;
          break;
        case 384:
          unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultAlt2LabelIconImageSource;
          break;
        default:
          return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
      }
    }
  }
  else
  {
    if (a1 <= 206)
    {
      if (a1 <= 188)
      {
        switch(a1)
        {
          case 167:
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelTextOrientation;
            break;
          case 168:
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelTextAlternateOrientations;
            break;
          case 169:
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelLayoutStyle;
            break;
          case 170:
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelIconStyle;
            break;
          case 171:
          case 172:
          case 173:
          case 174:
          case 175:
          case 176:
          case 177:
          case 178:
          case 180:
          case 182:
          case 184:
            return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
          case 179:
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelIconGlyphStyle;
            break;
          case 181:
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelIconGlyphBlendMode;
            break;
          case 183:
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelIconBadgeLightBlendMode;
            break;
          case 185:
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelIconGlowBlendMode;
            break;
          default:
            if (a1 != 123) {
              return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
            }
            unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelTextVisibility;
            break;
        }
        return result;
      }
      if (a1 == 189) {
        return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelIconSize;
      }
      if (a1 == 192) {
        return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAnnotationIconSize;
      }
      return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
    }
    if (a1 > 232)
    {
      switch(a1)
      {
        case 233:
          return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelOffsetPosition;
        case 236:
          return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelCollisionOverlayGroup;
        case 275:
          return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelShieldVariant;
      }
      return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
    }
    switch(a1)
    {
      case 207:
        unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultShieldSize;
        break;
      case 209:
        unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelIconTextSource;
        break;
      case 210:
        unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelTextSource;
        break;
      case 212:
        unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelIconColorSource;
        break;
      case 213:
        unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelColorSource;
        break;
      case 223:
        unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelPositioningMode;
        break;
      case 224:
        unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelDefaultTextPosition;
        break;
      case 225:
        unint64_t result = &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::kDefaultLabelAlternateTextPositions;
        break;
      default:
        return &gss::defaultValueForKey<gss::PropertyID,unsigned int>(gss::PropertyID)::_defaultValue;
    }
  }
  return result;
}

void md::RoadBatch::setRenderOrdersForStrokeAndFill(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int a8, unsigned char *a9, uint64_t a10, unsigned __int8 a11)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (!a9[32])
  {
    unsigned int v23 = 0;
    int v24 = 0;
    goto LABEL_68;
  }
  uint64_t v15 = *(void *)(*(void *)a9 + 24);
  if (*(unsigned __int8 *)(a10 + 12) >= 0x17u) {
    unsigned int v16 = 23;
  }
  else {
    unsigned int v16 = *(unsigned __int8 *)(a10 + 12);
  }
  unsigned int v17 = *(float **)v15;
  if (*(void *)v15
    && (float v18 = *v17, LODWORD(v17) = *v17 == 1.0, *(unsigned char *)(v15 + 10))
    && (v18 != 0.0 ? (BOOL v19 = v18 == 1.0) : (BOOL v19 = 1), !v19)
    || (v20 = *(unsigned __int8 *)(v15 + v17 + 11), float v18 = 0.0, v20 == 2))
  {
    buf[0] = 1;
    char v58 = 1;
    unsigned int v21 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v15, 0x68u, v16, 0, buf);
    int v22 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v15, 0x68u, v16, 1u, &v58);
    if (v18 >= 1.0) {
      unsigned int v21 = v22;
    }
  }
  else
  {
    unsigned int v21 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a9 + 24), 0x68u, v16, v20, 0);
  }
  uint64_t v25 = *(void *)(*(void *)a9 + 24);
  if (*(unsigned __int8 *)(a10 + 12) >= 0x17u) {
    unsigned int v26 = 23;
  }
  else {
    unsigned int v26 = *(unsigned __int8 *)(a10 + 12);
  }
  int v27 = *(float **)v25;
  if (!*(void *)v25
    || (float v28 = *v27, LODWORD(v27) = *v27 == 1.0, !*(unsigned char *)(v25 + 10))
    || (v28 != 0.0 ? (BOOL v29 = v28 == 1.0) : (BOOL v29 = 1), v29))
  {
    unsigned int v30 = *(unsigned __int8 *)(v25 + v27 + 11);
    float v28 = 0.0;
    if (v30 != 2)
    {
      unsigned int v23 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(*(void *)a9 + 24), 0x6Au, v26, v30, 0);
      if (v21 >= 0x100) {
        goto LABEL_31;
      }
LABEL_44:
      int v24 = v21;
      if (v23 < 0x100)
      {
        int v24 = v21;
        goto LABEL_68;
      }
      goto LABEL_45;
    }
  }
  buf[0] = 1;
  char v58 = 1;
  unsigned int v23 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v25, 0x6Au, v26, 0, buf);
  int v31 = *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v25, 0x6Au, v26, 1u, &v58);
  if (v28 >= 1.0) {
    unsigned int v23 = v31;
  }
  if (v21 < 0x100) {
    goto LABEL_44;
  }
LABEL_31:
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  float v32 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
  {
    uint64_t v33 = *(void *)(*(void *)a9 + 24);
    uint64_t v34 = *(void *)(v33 + 16);
    float v35 = *(std::__shared_weak_count **)(v33 + 24);
    if (v35) {
      atomic_fetch_add_explicit(&v35->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    float v36 = *(const char **)(v34 + 104);
    if (!v36) {
      float v36 = "";
    }
    *(_DWORD *)float buf = 67109378;
    unsigned int v60 = v21;
    __int16 v61 = 2080;
    int v62 = v36;
    _os_log_impl(&dword_1A1780000, v32, OS_LOG_TYPE_INFO, "Stroke Z index (%d) in style %s is too large - clamping to 255", buf, 0x12u);
    if (v35 && !atomic_fetch_add(&v35->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v35->__on_zero_shared)(v35);
      std::__shared_weak_count::__release_weak(v35);
    }
  }

  int v24 = 255;
  if (v23 <= 0xFF) {
    goto LABEL_56;
  }
LABEL_45:
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  float v37 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
  {
    uint64_t v38 = *(void *)(*(void *)a9 + 24);
    uint64_t v39 = *(void *)(v38 + 16);
    float v40 = *(std::__shared_weak_count **)(v38 + 24);
    if (v40) {
      atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    float v41 = *(const char **)(v39 + 104);
    if (!v41) {
      float v41 = "";
    }
    *(_DWORD *)float buf = 67109378;
    unsigned int v60 = v23;
    __int16 v61 = 2080;
    int v62 = v41;
    _os_log_impl(&dword_1A1780000, v37, OS_LOG_TYPE_INFO, "Fill Z index (%d) in style %s is too large - clamping to 255", buf, 0x12u);
    if (v40 && !atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
      std::__shared_weak_count::__release_weak(v40);
    }
  }

  unsigned int v23 = 255;
  if (v21 > 0xFF)
  {
LABEL_56:
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    long long v42 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v42, OS_LOG_TYPE_INFO))
    {
      uint64_t v43 = *(void *)(*(void *)a9 + 24);
      uint64_t v44 = *(void *)(v43 + 16);
      int v45 = *(std::__shared_weak_count **)(v43 + 24);
      if (v45) {
        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v46 = *(const char **)(v44 + 104);
      if (!v46) {
        char v46 = "";
      }
      *(_DWORD *)float buf = 67109378;
      unsigned int v60 = v21;
      __int16 v61 = 2080;
      int v62 = v46;
      _os_log_impl(&dword_1A1780000, v42, OS_LOG_TYPE_INFO, "Stroke2 Z index (%d) in style %s is too large - clamping to 255", buf, 0x12u);
      if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
        std::__shared_weak_count::__release_weak(v45);
      }
    }
  }
LABEL_68:
  unint64_t v47 = a11 | ((unint64_t)a7 << 28) | 4;
  if (a2) {
    *(void *)(a2 + 48) = v47;
  }
  unint64_t v48 = v47 | (v24 << 19) | (v23 << 8);
  if (a3) {
    *(void *)(a3 + 48) = v48;
  }
  int v49 = +[VKDebugSettings sharedSettings];
  int v50 = [v49 prioritizeTrafficSkeleton];

  if (a4)
  {
    uint64_t v51 = 196608;
    if (a1) {
      uint64_t v51 = 0x20000;
    }
    uint64_t v52 = 0x10000;
    if (v50 ^ 1 | a8) {
      uint64_t v52 = v51;
    }
    *(void *)(a4 + 48) = v52 | v48;
  }
  if (a5) {
    *(void *)(a5 + 48) = v48 | 0x40000;
  }
  if (a6)
  {
    uint64_t v53 = 0x20000;
    if (a1) {
      uint64_t v53 = 196608;
    }
    *(void *)(a6 + 48) = v48 | v53;
  }
}

void sub_1A17F2E20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

int *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(uint64_t a1, unsigned int a2, unsigned int a3, unsigned int a4, unsigned char *a5)
{
  uint64_t v6 = *(void *)(a1 + 16 * a4 + 16);
  if (!v6)
  {
    if (a5) {
      *a5 = 0;
    }
    return (int *)gss::defaultValueForKey<gss::PropertyID,unsigned int>(a2);
  }
  uint64_t v7 = a1 + 16 * a4;
  uint64_t v8 = *(unsigned __int16 *)(v7 + 56);
  if (!*(_WORD *)(v7 + 56))
  {
LABEL_33:
    unsigned int v30 = *(int **)(v6 + 72);
    return gss::CartoStyle<gss::PropertyID>::valueForKeyAtZ<unsigned int>(v30, a2, a3, a5);
  }
  uint64_t v9 = *(void *)(v7 + 48);
  uint64_t v10 = v9 + 8 * v8;
  if (a3 >= 0x17) {
    uint64_t v11 = 23;
  }
  else {
    uint64_t v11 = a3;
  }
  while (1)
  {
    uint64_t v13 = *(uint64_t **)(*(void *)v9 + 72);
    if (v13)
    {
      uint64_t v16 = *v13;
      uint64_t v15 = v13 + 2;
      uint64_t v14 = v16;
      unsigned int v17 = (unsigned __int16 **)(v16 + 80 * *((unsigned __int8 *)v15 + a3));
      unint64_t v18 = *((unsigned __int16 *)v17 + 5);
      if (*((_WORD *)v17 + 5))
      {
        BOOL v19 = *v17;
        if (*((unsigned char *)v17 + 15))
        {
          if (v18 >= 0x1E)
          {
            int v24 = *v17;
            unint64_t v25 = v18;
            do
            {
              unint64_t v26 = v25 >> 1;
              int v27 = &v24[v25 >> 1];
              unsigned int v29 = *v27;
              float v28 = v27 + 1;
              v25 += ~(v25 >> 1);
              if (v29 < a2) {
                int v24 = v28;
              }
              else {
                unint64_t v25 = v26;
              }
            }
            while (v25);
            if (v24 == &v19[v18] || *v24 != a2) {
              goto LABEL_8;
            }
            unint64_t v12 = (unint64_t)((char *)v24 - (char *)v19) >> 1;
          }
          else
          {
            uint64_t v20 = 0;
            while (1)
            {
              unsigned int v21 = v19[v20];
              if (v21 >= a2) {
                break;
              }
              if (v18 == ++v20) {
                goto LABEL_8;
              }
            }
            LOWORD(v12) = v21 == a2 ? v20 : (unsigned __int16)v18;
          }
        }
        else
        {
          uint64_t v22 = 2 * v18;
          unsigned int v23 = *v17;
          while (*v23 != a2)
          {
            ++v23;
            v22 -= 2;
            if (!v22)
            {
              unsigned int v23 = &v19[v18];
              break;
            }
          }
          unint64_t v12 = (unint64_t)((char *)v23 - (char *)v19) >> 1;
        }
      }
      else
      {
        LOWORD(v12) = 0;
      }
      if (v18 != (unsigned __int16)v12) {
        break;
      }
    }
LABEL_8:
    v9 += 8;
    if (v9 == v10) {
      goto LABEL_33;
    }
  }
  unsigned int v32 = *((unsigned __int8 *)v15 + v11);
  uint64_t v33 = v14 + 80 * *((unsigned __int8 *)v15 + v11);
  unint64_t v34 = *(unsigned __int16 *)(v33 + 42);
  if (!*(_WORD *)(v33 + 42)) {
    return &gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  uint64_t v35 = v14 + 80 * *((unsigned __int8 *)v15 + v11);
  uint64_t v36 = *(void *)(v35 + 32);
  if (*(unsigned char *)(v35 + 47))
  {
    if (v34 < 0x1E)
    {
      unint64_t v37 = 0;
      unint64_t result = &gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      while (1)
      {
        unsigned int v38 = *(unsigned __int16 *)(v36 + 2 * v37);
        if (v38 >= a2) {
          break;
        }
        if (v34 == ++v37) {
          return result;
        }
      }
      if (v38 != a2) {
        LOWORD(v37) = v34;
      }
      goto LABEL_63;
    }
    float v41 = *(unsigned __int16 **)(v35 + 32);
    unint64_t v42 = v34;
    do
    {
      unint64_t v43 = v42 >> 1;
      uint64_t v44 = &v41[v42 >> 1];
      unsigned int v46 = *v44;
      int v45 = v44 + 1;
      v42 += ~(v42 >> 1);
      if (v46 < a2) {
        float v41 = v45;
      }
      else {
        unint64_t v42 = v43;
      }
    }
    while (v42);
    if (v41 != (unsigned __int16 *)(v36 + 2 * v34) && *v41 == a2)
    {
      unint64_t v37 = ((unint64_t)v41 - v36) >> 1;
      goto LABEL_63;
    }
    return &gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  else
  {
    uint64_t v39 = 2 * v34;
    float v40 = *(unsigned __int16 **)(v35 + 32);
    while (*v40 != a2)
    {
      ++v40;
      v39 -= 2;
      if (!v39)
      {
        float v40 = (unsigned __int16 *)(v36 + 2 * v34);
        break;
      }
    }
    unint64_t v37 = ((unint64_t)v40 - v36) >> 1;
LABEL_63:
    if (v34 <= (unsigned __int16)v37) {
      return &gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    }
    return (int *)(v36 + *(unsigned __int16 *)(v14 + 80 * v32 + 40) + 4 * (unsigned __int16)v37);
  }
}

int *gss::CartoStyle<gss::PropertyID>::valueForKeyAtZ<unsigned int>(int *result, unsigned int a2, unsigned int a3, unsigned char *a4)
{
  if (!result) {
    goto LABEL_38;
  }
  uint64_t v4 = a3 >= 0x17 ? 23 : a3;
  unsigned int v5 = *((unsigned __int8 *)result + v4 + 16);
  uint64_t v6 = *(void *)result;
  uint64_t v7 = *(void *)result + 80 * v5;
  unint64_t v8 = *(unsigned __int16 *)(v7 + 10);
  if (!*(_WORD *)(v7 + 10)) {
    goto LABEL_38;
  }
  uint64_t v9 = *(unsigned __int16 **)v7;
  if (!*(unsigned char *)(v7 + 15))
  {
    uint64_t v12 = 2 * v8;
    uint64_t v13 = *(unsigned __int16 **)v7;
    while (*v13 != a2)
    {
      ++v13;
      v12 -= 2;
      if (!v12)
      {
        uint64_t v13 = &v9[v8];
        break;
      }
    }
    if (v8 == (unsigned __int16)((unint64_t)((char *)v13 - (char *)v9) >> 1)) {
      goto LABEL_38;
    }
    goto LABEL_27;
  }
  if (v8 < 0x1E)
  {
    uint64_t v10 = 0;
    while (1)
    {
      unsigned int v11 = v9[v10];
      if (v11 >= a2) {
        break;
      }
      if (v8 == ++v10) {
        goto LABEL_38;
      }
    }
    if (v11 == a2) {
      unsigned __int16 v26 = v10;
    }
    else {
      unsigned __int16 v26 = v8;
    }
    if (v8 == v26) {
      goto LABEL_38;
    }
    goto LABEL_27;
  }
  uint64_t v14 = *(unsigned __int16 **)v7;
  unint64_t v15 = v8;
  do
  {
    unint64_t v16 = v15 >> 1;
    unsigned int v17 = &v14[v15 >> 1];
    unsigned int v19 = *v17;
    unint64_t v18 = v17 + 1;
    v15 += ~(v15 >> 1);
    if (v19 < a2) {
      uint64_t v14 = v18;
    }
    else {
      unint64_t v15 = v16;
    }
  }
  while (v15);
  if (v14 == &v9[v8]
    || *v14 != a2
    || v8 == (unsigned __int16)((unint64_t)((char *)v14 - (char *)v9) >> 1))
  {
LABEL_38:
    if (a4) {
      *a4 = 0;
    }
    return (int *)gss::defaultValueForKey<gss::PropertyID,unsigned int>(a2);
  }
LABEL_27:
  uint64_t v20 = v6 + 80 * v5;
  unint64_t v21 = *(unsigned __int16 *)(v20 + 42);
  if (!*(_WORD *)(v20 + 42)) {
    return &gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  uint64_t v22 = v6 + 80 * v5;
  uint64_t v23 = *(void *)(v22 + 32);
  if (*(unsigned char *)(v22 + 47))
  {
    if (v21 >= 0x1E)
    {
      unsigned int v29 = *(unsigned __int16 **)(v22 + 32);
      unint64_t v30 = v21;
      do
      {
        unint64_t v31 = v30 >> 1;
        unsigned int v32 = &v29[v30 >> 1];
        unsigned int v34 = *v32;
        uint64_t v33 = v32 + 1;
        v30 += ~(v30 >> 1);
        if (v34 < a2) {
          unsigned int v29 = v33;
        }
        else {
          unint64_t v30 = v31;
        }
      }
      while (v30);
      if (v29 == (unsigned __int16 *)(v23 + 2 * v21) || *v29 != a2) {
        return &gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      }
      unint64_t v24 = ((unint64_t)v29 - v23) >> 1;
    }
    else
    {
      unint64_t v24 = 0;
      unint64_t result = &gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      while (1)
      {
        unsigned int v25 = *(unsigned __int16 *)(v23 + 2 * v24);
        if (v25 >= a2) {
          break;
        }
        if (v21 == ++v24) {
          return result;
        }
      }
      if (v25 != a2) {
        LOWORD(v24) = v21;
      }
    }
  }
  else
  {
    uint64_t v27 = 2 * v21;
    float v28 = *(unsigned __int16 **)(v22 + 32);
    while (*v28 != a2)
    {
      ++v28;
      v27 -= 2;
      if (!v27)
      {
        float v28 = (unsigned __int16 *)(v23 + 2 * v21);
        break;
      }
    }
    unint64_t v24 = ((unint64_t)v28 - v23) >> 1;
  }
  if (v21 == (unsigned __int16)v24) {
    return &gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  if (v21 > (unsigned __int16)v24) {
    return (int *)(v23 + *(unsigned __int16 *)(v6 + 80 * v5 + 40) + 4 * (unsigned __int16)v24);
  }
  return result;
}

uint64_t gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<int>(uint64_t result, unsigned int a2, unsigned int a3, unsigned int a4, unsigned char *a5)
{
  uint64_t v6 = *(void *)(result + 16 * a4 + 16);
  if (!v6) {
    goto LABEL_69;
  }
  uint64_t v7 = result + 16 * a4;
  uint64_t v8 = *(unsigned __int16 *)(v7 + 56);
  if (!*(_WORD *)(v7 + 56))
  {
LABEL_33:
    unsigned __int16 v26 = *(uint64_t **)(v6 + 72);
    if (!v26) {
      goto LABEL_69;
    }
    if (a3 >= 0x17) {
      uint64_t v27 = 23;
    }
    else {
      uint64_t v27 = a3;
    }
    unsigned int v28 = *((unsigned __int8 *)v26 + v27 + 16);
    uint64_t v29 = *v26;
    unint64_t v30 = (unsigned __int16 **)(v29 + 80 * v28);
    unint64_t v31 = *((unsigned __int16 *)v30 + 5);
    if (*((_WORD *)v30 + 5))
    {
      unsigned int v32 = *v30;
      if (*((unsigned char *)v30 + 15))
      {
        if (v31 >= 0x1E)
        {
          int v45 = *v30;
          unint64_t v46 = v31;
          do
          {
            unint64_t v47 = v46 >> 1;
            unint64_t v48 = &v45[v46 >> 1];
            unsigned int v50 = *v48;
            int v49 = v48 + 1;
            v46 += ~(v46 >> 1);
            if (v50 < a2) {
              int v45 = v49;
            }
            else {
              unint64_t v46 = v47;
            }
          }
          while (v46);
          if (v45 == &v32[v31] || *v45 != a2) {
            goto LABEL_69;
          }
          unint64_t v42 = (unint64_t)((char *)v45 - (char *)v32) >> 1;
        }
        else
        {
          uint64_t v33 = 0;
          while (1)
          {
            unsigned int v34 = v32[v33];
            if (v34 >= a2) {
              break;
            }
            if (v31 == ++v33) {
              goto LABEL_69;
            }
          }
          if (v34 == a2) {
            LOWORD(v42) = v33;
          }
          else {
            LOWORD(v42) = v31;
          }
        }
      }
      else
      {
        uint64_t v43 = 2 * v31;
        uint64_t v44 = *v30;
        while (*v44 != a2)
        {
          ++v44;
          v43 -= 2;
          if (!v43)
          {
            uint64_t v44 = &v32[v31];
            break;
          }
        }
        unint64_t v42 = (unint64_t)((char *)v44 - (char *)v32) >> 1;
      }
    }
    else
    {
      LOWORD(v42) = 0;
    }
    if (v31 != (unsigned __int16)v42)
    {
      uint64_t v51 = v29 + 80 * v28;
      unint64_t v52 = *(unsigned __int16 *)(v51 + 42);
      if (!*(_WORD *)(v51 + 42)) {
        return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      }
      uint64_t v53 = v29 + 80 * v28;
      uint64_t v39 = *(void *)(v53 + 32);
      if (*(unsigned char *)(v53 + 47))
      {
        if (v52 >= 0x1E)
        {
          uint64_t v65 = *(unsigned __int16 **)(v53 + 32);
          unint64_t v66 = v52;
          do
          {
            unint64_t v67 = v66 >> 1;
            uint64_t v68 = &v65[v66 >> 1];
            unsigned int v70 = *v68;
            unsigned int v69 = v68 + 1;
            v66 += ~(v66 >> 1);
            if (v70 < a2) {
              uint64_t v65 = v69;
            }
            else {
              unint64_t v66 = v67;
            }
          }
          while (v66);
          if (v65 == (unsigned __int16 *)(v39 + 2 * v52) || *v65 != a2) {
            return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          }
          unint64_t v40 = ((unint64_t)v65 - v39) >> 1;
        }
        else
        {
          unint64_t v40 = 0;
          unint64_t result = (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          while (1)
          {
            unsigned int v54 = *(unsigned __int16 *)(v39 + 2 * v40);
            if (v54 >= a2) {
              break;
            }
            if (v52 == ++v40) {
              return result;
            }
          }
          if (v54 != a2) {
            LOWORD(v40) = v52;
          }
        }
      }
      else
      {
        uint64_t v57 = 2 * v52;
        char v58 = *(unsigned __int16 **)(v53 + 32);
        while (*v58 != a2)
        {
          ++v58;
          v57 -= 2;
          if (!v57)
          {
            char v58 = (unsigned __int16 *)(v39 + 2 * v52);
            break;
          }
        }
        unint64_t v40 = ((unint64_t)v58 - v39) >> 1;
      }
      if (v52 == (unsigned __int16)v40) {
        return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      }
      if (v52 <= (unsigned __int16)v40) {
        return result;
      }
      uint64_t v71 = v29 + 80 * v28;
      return v39 + *(unsigned __int16 *)(v71 + 40) + 4 * (unsigned __int16)v40;
    }
LABEL_69:
    if (a5) {
      *a5 = 0;
    }
    return (uint64_t)gss::defaultValueForKey<gss::PropertyID,int>(a2);
  }
  uint64_t v9 = *(void *)(v7 + 48);
  uint64_t v10 = v9 + 8 * v8;
  if (a3 >= 0x17) {
    uint64_t v11 = 23;
  }
  else {
    uint64_t v11 = a3;
  }
  while (1)
  {
    uint64_t v13 = *(uint64_t **)(*(void *)v9 + 72);
    if (v13)
    {
      uint64_t v16 = *v13;
      unint64_t v15 = v13 + 2;
      uint64_t v14 = v16;
      unint64_t result = v16 + 80 * *((unsigned __int8 *)v15 + a3);
      unint64_t v17 = *(unsigned __int16 *)(result + 10);
      if (*(_WORD *)(result + 10))
      {
        uint64_t v18 = *(void *)result;
        if (*(unsigned char *)(result + 15))
        {
          if (v17 >= 0x1E)
          {
            unint64_t result = *(void *)result;
            unint64_t v21 = v17;
            do
            {
              unint64_t v22 = v21 >> 1;
              uint64_t v23 = (unsigned __int16 *)(result + 2 * (v21 >> 1));
              unsigned int v25 = *v23;
              unint64_t v24 = v23 + 1;
              v21 += ~(v21 >> 1);
              if (v25 < a2) {
                unint64_t result = (uint64_t)v24;
              }
              else {
                unint64_t v21 = v22;
              }
            }
            while (v21);
            if (result == v18 + 2 * v17 || *(unsigned __int16 *)result != a2) {
              goto LABEL_8;
            }
            unint64_t v12 = (unint64_t)(result - v18) >> 1;
          }
          else
          {
            unint64_t result = 0;
            while (1)
            {
              unsigned int v19 = *(unsigned __int16 *)(v18 + 2 * result);
              if (v19 >= a2) {
                break;
              }
              if (v17 == ++result) {
                goto LABEL_8;
              }
            }
            LOWORD(v12) = v19 == a2 ? result : (unsigned __int16)v17;
          }
        }
        else
        {
          uint64_t v20 = 2 * v17;
          unint64_t result = *(void *)result;
          while (*(unsigned __int16 *)result != a2)
          {
            result += 2;
            v20 -= 2;
            if (!v20)
            {
              unint64_t result = v18 + 2 * v17;
              break;
            }
          }
          unint64_t v12 = (unint64_t)(result - v18) >> 1;
        }
      }
      else
      {
        LOWORD(v12) = 0;
      }
      if (v17 != (unsigned __int16)v12) {
        break;
      }
    }
LABEL_8:
    v9 += 8;
    if (v9 == v10) {
      goto LABEL_33;
    }
  }
  unsigned int v35 = *((unsigned __int8 *)v15 + v11);
  uint64_t v36 = v14 + 80 * *((unsigned __int8 *)v15 + v11);
  unint64_t v37 = *(unsigned __int16 *)(v36 + 42);
  if (!*(_WORD *)(v36 + 42)) {
    return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  uint64_t v38 = v14 + 80 * *((unsigned __int8 *)v15 + v11);
  uint64_t v39 = *(void *)(v38 + 32);
  if (!*(unsigned char *)(v38 + 47))
  {
    uint64_t v55 = 2 * v37;
    uint64_t v56 = *(unsigned __int16 **)(v38 + 32);
    while (*v56 != a2)
    {
      ++v56;
      v55 -= 2;
      if (!v55)
      {
        uint64_t v56 = (unsigned __int16 *)(v39 + 2 * v37);
        break;
      }
    }
    unint64_t v40 = ((unint64_t)v56 - v39) >> 1;
LABEL_109:
    if (v37 <= (unsigned __int16)v40) {
      return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    }
    uint64_t v71 = v14 + 80 * v35;
    return v39 + *(unsigned __int16 *)(v71 + 40) + 4 * (unsigned __int16)v40;
  }
  if (v37 < 0x1E)
  {
    unint64_t v40 = 0;
    unint64_t result = (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    while (1)
    {
      unsigned int v41 = *(unsigned __int16 *)(v39 + 2 * v40);
      if (v41 >= a2) {
        break;
      }
      if (v37 == ++v40) {
        return result;
      }
    }
    if (v41 != a2) {
      LOWORD(v40) = v37;
    }
    goto LABEL_109;
  }
  int v59 = *(unsigned __int16 **)(v38 + 32);
  unint64_t v60 = v37;
  do
  {
    unint64_t v61 = v60 >> 1;
    int v62 = &v59[v60 >> 1];
    unsigned int v64 = *v62;
    uint64_t v63 = v62 + 1;
    v60 += ~(v60 >> 1);
    if (v64 < a2) {
      int v59 = v63;
    }
    else {
      unint64_t v60 = v61;
    }
  }
  while (v60);
  if (v59 != (unsigned __int16 *)(v39 + 2 * v37) && *v59 == a2)
  {
    unint64_t v40 = ((unint64_t)v59 - v39) >> 1;
    goto LABEL_109;
  }
  return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
}

void *gss::defaultValueForKey<gss::PropertyID,int>(int a1)
{
  std::locale v1 = &gss::defaultValueForKey<gss::PropertyID,int>(gss::PropertyID)::_defaultValue;
  if (a1 == 235) {
    std::locale v1 = &gss::defaultValueForKey<gss::PropertyID,int>(gss::PropertyID)::kDefaultLabelShieldDisplayThreshold;
  }
  if (a1 == 219) {
    return &gss::defaultValueForKey<gss::PropertyID,int>(gss::PropertyID)::kDefaultLabelRoadCrossingThreshold;
  }
  else {
    return v1;
  }
}

unsigned __int16 *gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned char>(unsigned __int16 *result, unsigned int a2, unsigned int a3, int a4, unsigned char *a5)
{
  uint64_t v6 = *(void *)&result[8 * a4 + 8];
  if (!v6) {
    goto LABEL_69;
  }
  uint64_t v7 = &result[8 * a4];
  uint64_t v8 = v7[28];
  if (!v7[28])
  {
LABEL_33:
    unsigned __int16 v26 = *(uint64_t **)(v6 + 72);
    if (!v26) {
      goto LABEL_69;
    }
    if (a3 >= 0x17) {
      uint64_t v27 = 23;
    }
    else {
      uint64_t v27 = a3;
    }
    unsigned int v28 = *((unsigned __int8 *)v26 + v27 + 16);
    uint64_t v29 = *v26;
    unint64_t v30 = (unsigned __int16 **)(v29 + 80 * v28);
    unint64_t v31 = *((unsigned __int16 *)v30 + 5);
    if (*((_WORD *)v30 + 5))
    {
      unsigned int v32 = *v30;
      if (*((unsigned char *)v30 + 15))
      {
        if (v31 >= 0x1E)
        {
          int v45 = *v30;
          unint64_t v46 = v31;
          do
          {
            unint64_t v47 = v46 >> 1;
            unint64_t v48 = &v45[v46 >> 1];
            unsigned int v50 = *v48;
            int v49 = v48 + 1;
            v46 += ~(v46 >> 1);
            if (v50 < a2) {
              int v45 = v49;
            }
            else {
              unint64_t v46 = v47;
            }
          }
          while (v46);
          if (v45 == &v32[v31] || *v45 != a2) {
            goto LABEL_69;
          }
          unint64_t v42 = (unint64_t)((char *)v45 - (char *)v32) >> 1;
        }
        else
        {
          uint64_t v33 = 0;
          while (1)
          {
            unsigned int v34 = v32[v33];
            if (v34 >= a2) {
              break;
            }
            if (v31 == ++v33) {
              goto LABEL_69;
            }
          }
          if (v34 == a2) {
            LOWORD(v42) = v33;
          }
          else {
            LOWORD(v42) = v31;
          }
        }
      }
      else
      {
        uint64_t v43 = 2 * v31;
        uint64_t v44 = *v30;
        while (*v44 != a2)
        {
          ++v44;
          v43 -= 2;
          if (!v43)
          {
            uint64_t v44 = &v32[v31];
            break;
          }
        }
        unint64_t v42 = (unint64_t)((char *)v44 - (char *)v32) >> 1;
      }
    }
    else
    {
      LOWORD(v42) = 0;
    }
    if (v31 != (unsigned __int16)v42)
    {
      uint64_t v51 = v29 + 80 * v28;
      unint64_t v52 = *(unsigned __int16 *)(v51 + 26);
      if (!*(_WORD *)(v51 + 26)) {
        return (unsigned __int16 *)&gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      }
      uint64_t v53 = v29 + 80 * v28;
      uint64_t v39 = *(void *)(v53 + 16);
      if (*(unsigned char *)(v53 + 31))
      {
        if (v52 >= 0x1E)
        {
          uint64_t v65 = *(unsigned __int16 **)(v53 + 16);
          unint64_t v66 = v52;
          do
          {
            unint64_t v67 = v66 >> 1;
            uint64_t v68 = &v65[v66 >> 1];
            unsigned int v70 = *v68;
            unsigned int v69 = v68 + 1;
            v66 += ~(v66 >> 1);
            if (v70 < a2) {
              uint64_t v65 = v69;
            }
            else {
              unint64_t v66 = v67;
            }
          }
          while (v66);
          if (v65 == (unsigned __int16 *)(v39 + 2 * v52) || *v65 != a2) {
            return (unsigned __int16 *)&gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          }
          unint64_t v40 = ((unint64_t)v65 - v39) >> 1;
        }
        else
        {
          unint64_t v40 = 0;
          unint64_t result = (unsigned __int16 *)&gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          while (1)
          {
            unsigned int v54 = *(unsigned __int16 *)(v39 + 2 * v40);
            if (v54 >= a2) {
              break;
            }
            if (v52 == ++v40) {
              return result;
            }
          }
          if (v54 != a2) {
            LOWORD(v40) = v52;
          }
        }
      }
      else
      {
        uint64_t v57 = 2 * v52;
        char v58 = *(unsigned __int16 **)(v53 + 16);
        while (*v58 != a2)
        {
          ++v58;
          v57 -= 2;
          if (!v57)
          {
            char v58 = (unsigned __int16 *)(v39 + 2 * v52);
            break;
          }
        }
        unint64_t v40 = ((unint64_t)v58 - v39) >> 1;
      }
      if (v52 == (unsigned __int16)v40) {
        return (unsigned __int16 *)&gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      }
      if (v52 <= (unsigned __int16)v40) {
        return result;
      }
      uint64_t v71 = v29 + 80 * v28;
      return (unsigned __int16 *)(v39 + *(unsigned __int16 *)(v71 + 24) + (unsigned __int16)v40);
    }
LABEL_69:
    if (a5) {
      *a5 = 0;
    }
    return (unsigned __int16 *)gss::defaultValueForKey<gss::PropertyID,unsigned char>(a2);
  }
  uint64_t v9 = *((void *)v7 + 6);
  uint64_t v10 = v9 + 8 * v8;
  if (a3 >= 0x17) {
    uint64_t v11 = 23;
  }
  else {
    uint64_t v11 = a3;
  }
  while (1)
  {
    uint64_t v13 = *(uint64_t **)(*(void *)v9 + 72);
    if (v13)
    {
      uint64_t v16 = *v13;
      unint64_t v15 = v13 + 2;
      uint64_t v14 = v16;
      unint64_t result = (unsigned __int16 *)(v16 + 80 * *((unsigned __int8 *)v15 + a3));
      unint64_t v17 = result[5];
      if (result[5])
      {
        uint64_t v18 = *(void *)result;
        if (*((unsigned char *)result + 15))
        {
          if (v17 >= 0x1E)
          {
            unint64_t result = *(unsigned __int16 **)result;
            unint64_t v21 = (unsigned __int16 *)v17;
            do
            {
              unint64_t v22 = (unsigned __int16 *)((unint64_t)v21 >> 1);
              uint64_t v23 = &result[(unint64_t)v21 >> 1];
              unsigned int v25 = *v23;
              unint64_t v24 = v23 + 1;
              unint64_t v21 = (unsigned __int16 *)((char *)v21 + ~((unint64_t)v21 >> 1));
              if (v25 < a2) {
                unint64_t result = v24;
              }
              else {
                unint64_t v21 = v22;
              }
            }
            while (v21);
            if (result == (unsigned __int16 *)(v18 + 2 * v17) || *result != a2) {
              goto LABEL_8;
            }
            unint64_t v12 = ((unint64_t)result - v18) >> 1;
          }
          else
          {
            unint64_t result = 0;
            while (1)
            {
              unsigned int v19 = *(unsigned __int16 *)(v18 + 2 * (void)result);
              if (v19 >= a2) {
                break;
              }
              unint64_t result = (unsigned __int16 *)((char *)result + 1);
              if ((unsigned __int16 *)v17 == result) {
                goto LABEL_8;
              }
            }
            LOWORD(v12) = v19 == a2 ? (unsigned __int16)result : v17;
          }
        }
        else
        {
          uint64_t v20 = 2 * v17;
          unint64_t result = *(unsigned __int16 **)result;
          while (*result != a2)
          {
            ++result;
            v20 -= 2;
            if (!v20)
            {
              unint64_t result = (unsigned __int16 *)(v18 + 2 * v17);
              break;
            }
          }
          unint64_t v12 = ((unint64_t)result - v18) >> 1;
        }
      }
      else
      {
        LOWORD(v12) = 0;
      }
      if (v17 != (unsigned __int16)v12) {
        break;
      }
    }
LABEL_8:
    v9 += 8;
    if (v9 == v10) {
      goto LABEL_33;
    }
  }
  unsigned int v35 = *((unsigned __int8 *)v15 + v11);
  uint64_t v36 = v14 + 80 * *((unsigned __int8 *)v15 + v11);
  unint64_t v37 = *(unsigned __int16 *)(v36 + 26);
  if (!*(_WORD *)(v36 + 26)) {
    return (unsigned __int16 *)&gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  uint64_t v38 = v14 + 80 * *((unsigned __int8 *)v15 + v11);
  uint64_t v39 = *(void *)(v38 + 16);
  if (!*(unsigned char *)(v38 + 31))
  {
    uint64_t v55 = 2 * v37;
    uint64_t v56 = *(unsigned __int16 **)(v38 + 16);
    while (*v56 != a2)
    {
      ++v56;
      v55 -= 2;
      if (!v55)
      {
        uint64_t v56 = (unsigned __int16 *)(v39 + 2 * v37);
        break;
      }
    }
    unint64_t v40 = ((unint64_t)v56 - v39) >> 1;
LABEL_109:
    if (v37 <= (unsigned __int16)v40) {
      return (unsigned __int16 *)&gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    }
    uint64_t v71 = v14 + 80 * v35;
    return (unsigned __int16 *)(v39 + *(unsigned __int16 *)(v71 + 24) + (unsigned __int16)v40);
  }
  if (v37 < 0x1E)
  {
    unint64_t v40 = 0;
    unint64_t result = (unsigned __int16 *)&gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    while (1)
    {
      unsigned int v41 = *(unsigned __int16 *)(v39 + 2 * v40);
      if (v41 >= a2) {
        break;
      }
      if (v37 == ++v40) {
        return result;
      }
    }
    if (v41 != a2) {
      LOWORD(v40) = v37;
    }
    goto LABEL_109;
  }
  int v59 = *(unsigned __int16 **)(v38 + 16);
  unint64_t v60 = v37;
  do
  {
    unint64_t v61 = v60 >> 1;
    int v62 = &v59[v60 >> 1];
    unsigned int v64 = *v62;
    uint64_t v63 = v62 + 1;
    v60 += ~(v60 >> 1);
    if (v64 < a2) {
      int v59 = v63;
    }
    else {
      unint64_t v60 = v61;
    }
  }
  while (v60);
  if (v59 != (unsigned __int16 *)(v39 + 2 * v37) && *v59 == a2)
  {
    unint64_t v40 = ((unint64_t)v59 - v39) >> 1;
    goto LABEL_109;
  }
  return (unsigned __int16 *)&gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
}

uint64_t gss::MaskToLabelPosition(int a1)
{
  uint64_t v1 = 0;
  while (word_1A2A7038A[v1] != a1)
  {
    if (++v1 == 10)
    {
      LOBYTE(v1) = 9;
      return v1;
    }
  }
  return v1;
}

uint64_t md::LabelStyle::updateZoomInvariantStyles(uint64_t this)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(this + 125))
  {
    uint64_t v1 = this;
    *(unsigned char *)(this + 125) = 1;
    uint64_t v2 = *(void *)this;
    if (*(void *)this)
    {
      float32x2_t v3 = *(std::__shared_weak_count **)(this + 8);
      unint64_t v66 = *(void (***)(void **))this;
      unint64_t v67 = (uint64_t *)v3;
      if (v3) {
        atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v49, v2, (uint64_t)v3);
      if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
        std::__shared_weak_count::__release_weak(v3);
        if (v50)
        {
LABEL_8:
          unint64_t v66 = (void (**)(void **))&unk_1EF56D320;
          unint64_t v67 = v49;
          uint64_t v68 = (void **)&v66;
          v64[0] = &unk_1EF56D368;
          v64[1] = v49;
          uint64_t v65 = v64;
          v62[0] = &unk_1EF56D3B0;
          v62[1] = v49;
          uint64_t v63 = v62;
          v60[0] = &unk_1EF56D3F8;
          v60[1] = v49;
          unint64_t v61 = v60;
          int v59 = v58;
          v58[0] = &unk_1EF56D320;
          v58[1] = v49;
          *(_WORD *)(v1 + 112) = md::LabelStyle::getZoomRange((uint64_t)v58);
          if (v59 == v58)
          {
            (*(void (**)(void *))(v58[0] + 32))(v58);
            uint64_t v4 = v65;
            if (!v65) {
              goto LABEL_18;
            }
          }
          else
          {
            if (v59) {
              (*(void (**)(void))(*v59 + 40))();
            }
            uint64_t v4 = v65;
            if (!v65) {
              goto LABEL_18;
            }
          }
          if (v4 == v64)
          {
            uint64_t v57 = v56;
            (*(void (**)(void *, void *))(v64[0] + 24))(v64, v56);
LABEL_20:
            *(_WORD *)(v1 + 114) = md::LabelStyle::getZoomRange((uint64_t)v56);
            if (v57 == v56)
            {
              (*(void (**)(void *))(v56[0] + 32))(v56);
              uint64_t v5 = v61;
              if (!v61) {
                goto LABEL_28;
              }
            }
            else
            {
              if (v57) {
                (*(void (**)(void))(*v57 + 40))();
              }
              uint64_t v5 = v61;
              if (!v61) {
                goto LABEL_28;
              }
            }
            if (v5 == v60)
            {
              uint64_t v55 = v54;
              (*(void (**)(void *, void *))(v60[0] + 24))(v60, v54);
LABEL_30:
              *(_WORD *)(v1 + 116) = md::LabelStyle::getZoomRange((uint64_t)v54);
              if (v55 == v54)
              {
                (*(void (**)(void *))(v54[0] + 32))(v54);
                uint64_t v6 = v63;
                if (!v63) {
                  goto LABEL_38;
                }
              }
              else
              {
                if (v55) {
                  (*(void (**)(void))(*v55 + 40))();
                }
                uint64_t v6 = v63;
                if (!v63) {
                  goto LABEL_38;
                }
              }
              if (v6 == v62)
              {
                uint64_t v53 = v52;
                (*(void (**)(void *, void *))(v62[0] + 24))(v62, v52);
                goto LABEL_40;
              }
              uint64_t v6 = (void *)(*(uint64_t (**)(void *))(*v6 + 16))(v6);
LABEL_38:
              uint64_t v53 = v6;
LABEL_40:
              *(_WORD *)(v1 + 118) = md::LabelStyle::getZoomRange((uint64_t)v52);
              if (v53 == v52)
              {
                (*(void (**)(void *))(v52[0] + 32))(v52);
              }
              else if (v53)
              {
                (*(void (**)(void))(*v53 + 40))();
              }
              unsigned __int8 v7 = 0;
              do
              {
                uint64_t v10 = *(void *)(v49[0] + 24);
                unsigned int v11 = *(unsigned __int8 *)(v10 + 12);
                if (v11 == 2)
                {
                  LOBYTE(v47) = 1;
                  char v51 = 1;
                  int v12 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v10, 0x7Bu, v7, 0, &v47);
                  gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(v10, 0x7Bu, v7, 1u, &v51);
                }
                else
                {
                  int v12 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<unsigned int>(*(void *)(v49[0] + 24), 0x7Bu, v7, v11, 0);
                }
                unsigned int v8 = v7++;
                if (v12) {
                  BOOL v9 = 1;
                }
                else {
                  BOOL v9 = v8 >= 0x17;
                }
              }
              while (!v9);
              *(unsigned char *)(v1 + 121) = v12 != 0;
              unsigned int v13 = *(unsigned __int16 *)(v1 + 112);
              if (v13 >> 8 >= 0x18) {
                unsigned int v14 = 24;
              }
              else {
                unsigned int v14 = v13 >> 8;
              }
              for (; v14 > v13; LOBYTE(v13) = v13 + 1)
              {
                uint64_t v16 = *(void *)(v49[0] + 24);
                if (v13 >= 0x17u) {
                  unsigned int v17 = 23;
                }
                else {
                  unsigned int v17 = v13;
                }
                int v18 = *(unsigned __int8 *)(v16 + 12);
                if (v18 == 2)
                {
                  LOBYTE(v47) = 1;
                  char v51 = 1;
                  int v19 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v16, 0x5Bu, v17, 0, &v47);
                  gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v16, 0x5Bu, v17, 1, &v51);
                  if (!v19) {
                    continue;
                  }
                }
                else if (!*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v49[0] + 24), 0x5Bu, v17, v18, 0))
                {
                  continue;
                }
                uint64_t v20 = *(void *)(v49[0] + 24);
                int v21 = *(unsigned __int8 *)(v20 + 12);
                if (v21 == 2)
                {
                  LOBYTE(v47) = 1;
                  char v51 = 1;
                  int v15 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v20, 0x81u, v17, 0, &v47);
                  gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v20, 0x81u, v17, 1, &v51);
                }
                else
                {
                  int v15 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v49[0] + 24), 0x81u, v17, v21, 0);
                }
                if (v15) {
                  goto LABEL_70;
                }
              }
              LOBYTE(v13) = -4;
LABEL_70:
              *(unsigned char *)(v1 + 120) = v13;
              uint64_t v22 = *(void *)(v49[0] + 24);
              unsigned int v23 = *(unsigned __int8 *)(v22 + 12);
              if (v23 == 2)
              {
                LOBYTE(v47) = 1;
                char v51 = 1;
                unint64_t v24 = (int *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v22, 0x7Du, 0, &v47);
                gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v22, 0x7Du, 1u, &v51);
                int v25 = *v24;
              }
              else
              {
                int v25 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(*(void *)(v49[0] + 24), 0x7Du, v23, 0);
              }
              *(unsigned char *)(v1 + 122) = v25;
              uint64_t v26 = *(void *)(v49[0] + 24);
              unsigned int v27 = *(unsigned __int8 *)(v26 + 12);
              if (v27 == 2)
              {
                LOBYTE(v47) = 1;
                char v51 = 1;
                unsigned int v28 = (int *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v26, 0x158u, 0, &v47);
                gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v26, 0x158u, 1u, &v51);
                int v29 = *v28;
              }
              else
              {
                int v29 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(*(void *)(v49[0] + 24), 0x158u, v27, 0);
              }
              *(unsigned char *)(v1 + 123) = v29;
              uint64_t v30 = *(void *)(v49[0] + 24);
              unsigned int v31 = *(unsigned __int8 *)(v30 + 12);
              if (v31 == 2)
              {
                LOBYTE(v47) = 1;
                char v51 = 1;
                unsigned int v32 = (int *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v30, 0x1C6u, 0, &v47);
                gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v30, 0x1C6u, 1u, &v51);
                int v33 = *v32;
              }
              else
              {
                int v33 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(*(void *)(v49[0] + 24), 0x1C6u, v31, 0);
              }
              *(unsigned char *)(v1 + 124) = v33;
              uint64_t v34 = *(void *)(v49[0] + 24);
              unsigned int v35 = *(unsigned __int8 *)(v34 + 12);
              if (v35 == 2)
              {
                LOBYTE(v47) = 1;
                char v51 = 1;
                uint64_t v36 = gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned char>((void *)v34, 0, &v47);
                gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned char>((void *)v34, 1u, &v51);
                char v37 = *(unsigned char *)v36;
              }
              else
              {
                char v37 = *(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned char>(*(void **)(v49[0] + 24), v35, 0);
              }
              *(unsigned char *)(v1 + 126) = v37;
              uint64_t v38 = *(void *)v1;
              uint64_t v47 = 0;
              unint64_t v48 = 0;
              uint64_t v39 = *(std::__shared_weak_count **)(v38 + 16);
              float v40 = 1.0;
              if (v39)
              {
                unint64_t v48 = std::__shared_weak_count::lock(v39);
                if (v48)
                {
                  uint64_t v41 = *(void *)(v38 + 8);
                  uint64_t v47 = v41;
                  if (v41)
                  {
                    if (*(unsigned char *)(v1 + 94) == 1)
                    {
                      uint64_t v42 = *(void *)(v41 + 16);
                      unsigned __int8 v43 = atomic_load((unsigned __int8 *)(v42 + 2784));
                      if ((v43 & 1) == 0) {
                        std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v42 + 2808));
                      }
                      uint64_t v44 = *(void *)(v42 + 120);
                      int v45 = *(std::__shared_weak_count **)(v42 + 128);
                      if (v45) {
                        atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      if (v44) {
                        float v40 = *(float *)(v44 + 88);
                      }
                      if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
                        std::__shared_weak_count::__release_weak(v45);
                      }
                    }
                  }
                }
              }
              *(float *)(v1 + 108) = v40;
              unint64_t v46 = v48;
              if (v48 && !atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v46->__on_zero_shared)(v46);
                std::__shared_weak_count::__release_weak(v46);
              }
              if (v61 == v60)
              {
                (*(void (**)(void *))(v60[0] + 32))(v60);
              }
              else if (v61)
              {
                (*(void (**)(void))(*v61 + 40))();
              }
              if (v63 == v62)
              {
                (*(void (**)(void *))(v62[0] + 32))(v62);
              }
              else if (v63)
              {
                (*(void (**)(void))(*v63 + 40))();
              }
              if (v65 == v64)
              {
                (*(void (**)(void *))(v64[0] + 32))(v64);
              }
              else if (v65)
              {
                (*(void (**)(void))(*v65 + 40))();
              }
              if (v68 == (void **)&v66)
              {
                v66[4]((void **)&v66);
              }
              else if (v68)
              {
                (*((void (**)(void))*v68 + 5))();
              }
              return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v49);
            }
            uint64_t v5 = (void *)(*(uint64_t (**)(void *))(*v5 + 16))(v5);
LABEL_28:
            uint64_t v55 = v5;
            goto LABEL_30;
          }
          uint64_t v4 = (void *)(*(uint64_t (**)(void *))(*v4 + 16))(v4);
LABEL_18:
          uint64_t v57 = v4;
          goto LABEL_20;
        }
      }
      else if (v50)
      {
        goto LABEL_8;
      }
      *(_WORD *)(v1 + 112) = 0;
      *(_WORD *)(v1 + 120) = 0;
      *(unsigned char *)(v1 + 122) = 0;
      *(_DWORD *)(v1 + 108) = 1065353216;
      return gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v49);
    }
  }
  return this;
}

void sub_1A17F4734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a10);
  std::function<BOOL ()(unsigned char)>::~function(&a34);
  std::function<BOOL ()(unsigned char)>::~function((void *)(v34 - 200));
  std::function<BOOL ()(unsigned char)>::~function((void *)(v34 - 168));
  std::function<BOOL ()(unsigned char)>::~function((void *)(v34 - 136));
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void *gss::defaultValueForKey<gss::PropertyID,unsigned char>(int a1)
{
  uint64_t v1 = &gss::defaultValueForKey<gss::PropertyID,unsigned char>(gss::PropertyID)::_defaultValue;
  if (a1 == 474) {
    uint64_t v1 = &gss::defaultValueForKey<gss::PropertyID,unsigned char>(gss::PropertyID)::kDefaultLabelClusterElementCount;
  }
  if (a1 == 469) {
    return &gss::defaultValueForKey<gss::PropertyID,unsigned char>(gss::PropertyID)::kDefaultLabelCollisionGroup;
  }
  else {
    return v1;
  }
}

void *gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned char>(void *result, unsigned int a2, unsigned char *a3)
{
  uint64_t v3 = result[2 * a2 + 2];
  if (!v3)
  {
    if (a3) {
      *a3 = 0;
    }
    return gss::defaultValueForKey<gss::PropertyID,unsigned char>(393);
  }
  uint64_t v4 = (char *)&result[2 * a2];
  uint64_t v5 = *((unsigned __int16 *)v4 + 28);
  if (*((_WORD *)v4 + 28))
  {
    uint64_t v6 = *((void *)v4 + 6);
    uint64_t v7 = v6 + 8 * v5;
    while (1)
    {
      BOOL v9 = *(uint64_t **)(*(void *)v6 + 72);
      if (!v9) {
        goto LABEL_6;
      }
      uint64_t v10 = *v9;
      uint64_t v11 = *(unsigned __int16 *)(v10 + 10);
      if (!*(_WORD *)(v10 + 10))
      {
        int v8 = 0;
        goto LABEL_5;
      }
      int v12 = *(unsigned __int16 **)v10;
      if (!*(unsigned char *)(v10 + 15)) {
        break;
      }
      unsigned int v13 = *(unsigned __int16 **)v10;
      unint64_t v14 = *(unsigned __int16 *)(v10 + 10);
      if (v11 >= 0x1E)
      {
        do
        {
          unint64_t v17 = v14 >> 1;
          int v18 = &v13[v14 >> 1];
          unsigned int v20 = *v18;
          int v19 = v18 + 1;
          unint64_t result = (void *)v20;
          v14 += ~(v14 >> 1);
          if (v20 < 0x189) {
            unsigned int v13 = v19;
          }
          else {
            unint64_t v14 = v17;
          }
        }
        while (v14);
        if (v13 == &v12[v11] || *v13 != 393) {
          goto LABEL_6;
        }
        goto LABEL_26;
      }
      uint64_t v15 = 0;
      while (1)
      {
        unsigned int v16 = v12[v15];
        if (v16 >= 0x189) {
          break;
        }
        if (v11 == ++v15) {
          goto LABEL_6;
        }
      }
      int v8 = (unsigned __int16)v15;
      if (v16 != 393) {
        int v8 = *(unsigned __int16 *)(v10 + 10);
      }
LABEL_5:
      if (v8 != v11)
      {
        unint64_t v27 = *(unsigned __int16 *)(v10 + 26);
        if (!*(_WORD *)(v10 + 26)) {
          return &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
        }
        uint64_t v28 = *(void *)(v10 + 16);
        if (*(unsigned char *)(v10 + 31))
        {
          if (v27 < 0x1E)
          {
            int v29 = 0;
            unint64_t result = &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
            while (1)
            {
              unsigned int v30 = *(unsigned __int16 *)(v28 + 2 * (void)v29);
              if (v30 >= 0x189) {
                break;
              }
              int v29 = (unsigned __int16 *)((char *)v29 + 1);
              if ((unsigned __int16 *)v27 == v29) {
                return result;
              }
            }
            LODWORD(v29) = (unsigned __int16)v29;
            if (v30 != 393) {
              LODWORD(v29) = *(unsigned __int16 *)(v10 + 26);
            }
            if (v29 < v27) {
              return (void *)(v28 + *(unsigned __int16 *)(v10 + 24) + v29);
            }
            return &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          }
          int v29 = *(unsigned __int16 **)(v10 + 16);
          unint64_t v43 = *(unsigned __int16 *)(v10 + 26);
          do
          {
            unint64_t v44 = v43 >> 1;
            int v45 = &v29[v43 >> 1];
            unsigned int v47 = *v45;
            unint64_t v46 = v45 + 1;
            v43 += ~(v43 >> 1);
            if (v47 < 0x189) {
              int v29 = v46;
            }
            else {
              unint64_t v43 = v44;
            }
          }
          while (v43);
          if (v29 == (unsigned __int16 *)(v28 + 2 * v27) || *v29 != 393) {
            return &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          }
        }
        else
        {
          uint64_t v41 = 2 * v27;
          int v29 = *(unsigned __int16 **)(v10 + 16);
          while (*v29 != 393)
          {
            ++v29;
            v41 -= 2;
            if (!v41)
            {
              LODWORD(v29) = v28 + 2 * v27;
              break;
            }
          }
        }
        LODWORD(v29) = (unsigned __int16)((v29 - v28) >> 1);
        if (v29 < v27) {
          return (void *)(v28 + *(unsigned __int16 *)(v10 + 24) + v29);
        }
        return &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      }
LABEL_6:
      v6 += 8;
      if (v6 == v7) {
        goto LABEL_29;
      }
    }
    uint64_t v21 = 2 * v11;
    unsigned int v13 = *(unsigned __int16 **)v10;
    while (*v13 != 393)
    {
      ++v13;
      v21 -= 2;
      if (!v21)
      {
        LODWORD(v13) = v12 + 2 * v11;
        break;
      }
    }
LABEL_26:
    int v8 = (unsigned __int16)((v13 - v12) >> 1);
    goto LABEL_5;
  }
LABEL_29:
  uint64_t v22 = *(uint64_t **)(v3 + 72);
  if (!v22) {
    goto LABEL_60;
  }
  uint64_t v10 = *v22;
  uint64_t v23 = *(unsigned __int16 *)(v10 + 10);
  if (!*(_WORD *)(v10 + 10)) {
    goto LABEL_60;
  }
  unint64_t v24 = *(unsigned __int16 **)v10;
  if (!*(unsigned char *)(v10 + 15))
  {
    uint64_t v31 = 2 * v23;
    unsigned int v32 = *(unsigned __int16 **)v10;
    while (*v32 != 393)
    {
      ++v32;
      v31 -= 2;
      if (!v31)
      {
        LODWORD(v32) = v24 + 2 * v23;
        break;
      }
    }
LABEL_59:
    if ((unsigned __int16)((v32 - v24) >> 1) != v23) {
      goto LABEL_66;
    }
    goto LABEL_60;
  }
  if (v23 >= 0x1E)
  {
    unsigned int v32 = *(unsigned __int16 **)v10;
    unint64_t v33 = *(unsigned __int16 *)(v10 + 10);
    do
    {
      unint64_t v34 = v33 >> 1;
      unsigned int v35 = &v32[v33 >> 1];
      unsigned int v37 = *v35;
      uint64_t v36 = v35 + 1;
      v33 += ~(v33 >> 1);
      if (v37 < 0x189) {
        unsigned int v32 = v36;
      }
      else {
        unint64_t v33 = v34;
      }
    }
    while (v33);
    if (v32 != &v24[v23] && *v32 == 393) {
      goto LABEL_59;
    }
LABEL_60:
    if (a3) {
      *a3 = 0;
    }
    return gss::defaultValueForKey<gss::PropertyID,unsigned char>(393);
  }
  uint64_t v25 = 0;
  while (1)
  {
    unsigned int v26 = v24[v25];
    if (v26 >= 0x189) {
      break;
    }
    if (v23 == ++v25) {
      goto LABEL_60;
    }
  }
  int v38 = (unsigned __int16)v25;
  if (v26 != 393) {
    int v38 = *(unsigned __int16 *)(v10 + 10);
  }
  if (v38 == v23) {
    goto LABEL_60;
  }
LABEL_66:
  unint64_t v39 = *(unsigned __int16 *)(v10 + 26);
  if (!*(_WORD *)(v10 + 26)) {
    return &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  uint64_t v28 = *(void *)(v10 + 16);
  if (*(unsigned char *)(v10 + 31))
  {
    if (v39 < 0x1E)
    {
      int v29 = 0;
      unint64_t result = &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      while (1)
      {
        unsigned int v40 = *(unsigned __int16 *)(v28 + 2 * (void)v29);
        if (v40 >= 0x189) {
          break;
        }
        int v29 = (unsigned __int16 *)((char *)v29 + 1);
        if ((unsigned __int16 *)v39 == v29) {
          return result;
        }
      }
      LODWORD(v29) = (unsigned __int16)v29;
      if (v40 != 393) {
        LODWORD(v29) = *(unsigned __int16 *)(v10 + 26);
      }
      BOOL v53 = v29 >= v39;
      if (v29 == v39) {
        return &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
      }
      goto LABEL_107;
    }
    int v29 = *(unsigned __int16 **)(v10 + 16);
    unint64_t v48 = *(unsigned __int16 *)(v10 + 26);
    do
    {
      unint64_t v49 = v48 >> 1;
      char v50 = &v29[v48 >> 1];
      unsigned int v52 = *v50;
      char v51 = v50 + 1;
      v48 += ~(v48 >> 1);
      if (v52 < 0x189) {
        int v29 = v51;
      }
      else {
        unint64_t v48 = v49;
      }
    }
    while (v48);
    if (v29 == (unsigned __int16 *)(v28 + 2 * v39) || *v29 != 393) {
      return &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    }
  }
  else
  {
    uint64_t v42 = 2 * v39;
    int v29 = *(unsigned __int16 **)(v10 + 16);
    while (*v29 != 393)
    {
      ++v29;
      v42 -= 2;
      if (!v42)
      {
        LODWORD(v29) = v28 + 2 * v39;
        break;
      }
    }
  }
  LODWORD(v29) = (unsigned __int16)((v29 - v28) >> 1);
  BOOL v53 = v29 >= v39;
  if (v29 == v39) {
    return &gss::PropertySetValueHelper<gss::PropertyID,unsigned char>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
LABEL_107:
  if (!v53) {
    return (void *)(v28 + *(unsigned __int16 *)(v10 + 24) + v29);
  }
  return result;
}

uint64_t std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_2,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_2>,BOOL ()(unsigned char)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D3B0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_1,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_1>,BOOL ()(unsigned char)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D368;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::LabelStyle::updateZoomInvariantStyles(void)::$_3,std::allocator<md::LabelStyle::updateZoomInvariantStyles(void)::$_3>,BOOL ()(unsigned char)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56D3F8;
  a2[1] = v2;
  return result;
}

void __destroy_helper_block_ea8_48c23_ZTSN3gdc11ResourceKeyE(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 56);
  if (v2 != *(void **)(a1 + 72)) {
    free(v2);
  }
}

uint64_t ggl::CommonMesh::Pos2Mesh::Pos2Mesh(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  {
    uint64_t v15 = a3;
    uint64_t v22 = a2;
    a2 = v22;
    a3 = v15;
    if (v16)
    {
      {
        ggl::MeshTyped<ggl::CommonMesh::BufferPos2>::attributesReflection(void)::r = (uint64_t)&ggl::CommonMesh::bufferPos2Reflection;
      }
      ggl::MeshTyped<ggl::CommonMesh::BufferPos2>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2>::attributesReflection(void)::r;
      unk_1EB32B400 = 1;
      a3 = v15;
      a2 = v22;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EF5606B0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1EF5606D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = &ggl::MeshTyped<ggl::CommonMesh::BufferPos2>::typedReflection(void)::r;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  {
    unsigned int v20 = a3;
    a3 = v20;
    uint64_t v6 = a1 + 64;
    if (v17) {
      operator new();
    }
  }
  uint64_t v7 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = a1 + 120;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v7;
  {
    uint64_t v21 = a3;
    uint64_t v23 = v6;
    uint64_t v8 = a1 + 120;
    a3 = v21;
    int v19 = v18;
    uint64_t v6 = v23;
    if (v19) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = v8;
  *(void *)a1 = &unk_1EF561BE0;
  *(void *)(a1 + 16) = &unk_1EF561C00;
  uint64_t v9 = a3[1];
  uint64_t v24 = *a3;
  uint64_t v25 = (std::__shared_weak_count *)v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(v6, &v24, &v26, 1uLL);
  uint64_t v10 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v12 = *a4;
  uint64_t v11 = a4[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned int v13 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 104) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)a1 = &unk_1EF55A290;
  *(void *)(a1 + 16) = &unk_1EF55A2B0;
  return a1;
}

uint64_t std::__function::__func<ggl::MetalClearItemProcessor::createClearMesh(ggl::ProcessClearItemContext &)::$_0,std::allocator<ggl::MetalClearItemProcessor::createClearMesh(ggl::ProcessClearItemContext &)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  uint64_t v3 = *a2;
  uint64_t v4 = **(void **)(result + 8);
  unint64_t v5 = 4 * *(void *)(v4 + 8);
  if (v5)
  {
    if (v3 && *(unsigned char *)(v4 + 17) != 2)
    {
      unint64_t result = (*(uint64_t (**)(void, uint64_t, void, uint64_t, uint64_t, void))(*(void *)v3 + 56))(*a2, v4, 0, 4 * *(void *)(v4 + 8), 1, 0);
      uint64_t v6 = (_OWORD *)result;
    }
    else
    {
      uint64_t v6 = *(_OWORD **)(v4 + 72);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  _OWORD *v6 = xmmword_1A28FCD00;
  v6[1] = xmmword_1A28FCD10;
  uint64_t v7 = **(void **)(v2 + 16);
  unint64_t v8 = 6 * *(void *)(v7 + 8);
  if (v3)
  {
    if (*(unsigned char *)(v7 + 17) == 2)
    {
      uint64_t v9 = *(void *)(v7 + 72);
    }
    else
    {
      unint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, uint64_t, void))(*(void *)v3 + 56))(v3, v7, 0, 6 * *(void *)(v7 + 8), 1, 0);
      uint64_t v9 = result;
    }
    *(void *)uint64_t v9 = 0x2000200010000;
    *(_DWORD *)(v9 + 8) = 3;
    if (*(unsigned char *)(v7 + 17) != 2) {
      unint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 64))(v3);
    }
  }
  else
  {
    uint64_t v10 = *(void *)(v7 + 72);
    *(void *)uint64_t v10 = 0x2000200010000;
    *(_DWORD *)(v10 + 8) = 3;
  }
  unint64_t v11 = *(void *)(v7 + 64);
  if (v11 <= v8) {
    unint64_t v11 = v8;
  }
  *(void *)(v7 + 56) = 0;
  *(void *)(v7 + 64) = v11;
  if (v5)
  {
    if (v3 && *(unsigned char *)(v4 + 17) != 2) {
      unint64_t result = (*(uint64_t (**)(uint64_t, _OWORD *, uint64_t, void, unint64_t, uint64_t, void))(*(void *)v3 + 64))(v3, v6, v4, 0, v5, 1, 0);
    }
    unint64_t v12 = *(void *)(v4 + 64);
    if (v12 <= v5) {
      unint64_t v12 = v5;
    }
    *(void *)(v4 + 56) = 0;
    *(void *)(v4 + 64) = v12;
  }
  return result;
}

void *md::RoadLayer::RoadLayer(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5, char *a6, int a7)
{
  int v12 = a6[24];
  if (a6[24])
  {
    char v7 = a6[1];
    char v13 = *a6;
    uint64_t v8 = *(void *)(a6 + 4);
  }
  else
  {
    char v13 = 0;
  }
  md::RibbonLayer<md::Ribbons::RoadRibbonDescriptor>::batch(&v353, *(void *)(a3 + 16), a4, (uint64_t)a5, a7);
  a1[1] = 0;
  *a1 = &unk_1EF553B10;
  a1[2] = 0;
  a1[3] = 0;
  uint64_t v314 = a1;
  unint64_t v14 = (const void *)v353;
  uint64_t v15 = *((void *)&v353 + 1) - v353;
  if (*((void *)&v353 + 1) == (void)v353)
  {
    uint64_t v334 = 0;
    int v18 = 0;
    unsigned int v20 = v314;
  }
  else
  {
    if (v15 < 0) {
      abort();
    }
    int v16 = operator new(*((void *)&v353 + 1) - v353);
    v314[1] = v16;
    v314[2] = v16;
    int v17 = (char *)&v16[v15 >> 3];
    v314[3] = v17;
    int v18 = v16;
    size_t v19 = v15;
    unsigned int v20 = v314;
    memcpy(v16, v14, v19);
    uint64_t v334 = v17;
    v314[2] = v17;
  }
  *((_OWORD *)v20 + 2) = 0u;
  *((_OWORD *)v20 + 5) = 0u;
  *((_OWORD *)v20 + 6) = 0u;
  *((_OWORD *)v20 + 3) = 0u;
  *((_OWORD *)v20 + 4) = 0u;
  *((unsigned char *)v20 + 112) = a7;
  v20[15] = 0;
  *((unsigned char *)v20 + 128) = 0;
  *((unsigned char *)v20 + 152) = 0;
  if (v12)
  {
    *((unsigned char *)v20 + 128) = v13;
    *((unsigned char *)v20 + 129) = v7;
    *(void *)((char *)v20 + 132) = v8;
    *((unsigned char *)v20 + 152) = 1;
  }
  uint64_t v329 = (void *)a4;
  if (v18 != v334)
  {
    uint64_t v21 = 0;
    uint64_t v346 = 0;
    uint64_t v339 = 0;
    while (1)
    {
      uint64_t v22 = (void *)*v18;
      v22[1] = v20;
      uint64_t v23 = (void **)v22[127];
      uint64_t v24 = (void **)v22[128];
      uint64_t v335 = v18;
      uint64_t v337 = v24;
      while (v23 != v24)
      {
        uint64_t v341 = v21;
        int64x2_t v343 = v23;
        uint64_t v26 = *v23;
        v26[1] = **v23;
        v26[3] = v26[2];
        v26[5] = v26[4];
        memset(v352, 0, 24);
        memset(&v355, 0, sizeof(v355));
        uint64_t v28 = (uint64_t *)v26[7];
        unint64_t v27 = (uint64_t *)v26[8];
        if (v28 != v27)
        {
          int v349 = (uint64_t *)v26[8];
          do
          {
            uint64_t v36 = *v28;
            v351[0] = (void *)1;
            md::Ribbons::RibbonWriter<md::Ribbons::DaVinciTrafficRibbonDescriptor>::eliminateDuplicates(v36, (uint64_t)v352, &v355, (uint64_t *)v351);
            unsigned int v37 = v351[0];
            if (v351[0] >= (void *)2)
            {
              uint64_t v38 = *(void *)v352;
              if (*(unsigned char *)(v36 + 98))
              {
                uint64_t v39 = 0;
                unint64_t v40 = 0;
                float v41 = *(float *)(v36 + 100);
                float v42 = *(float *)(v36 + 104);
              }
              else
              {
                unint64_t v43 = (float *)(*(void *)v352 + 12);
                float v44 = **(float **)v352;
                int v45 = (char *)v351[0] - 1;
                while (1)
                {
                  if (vabds_f32(*v43, v44) >= 1.0e-10)
                  {
                    float v48 = v43[1] - *(float *)(*(void *)v352 + 4);
                    goto LABEL_35;
                  }
                  float v46 = *(float *)(*(void *)v352 + 4);
                  float v47 = v43[1];
                  if (vabds_f32(v47, v46) >= 1.0e-10) {
                    break;
                  }
                  v43 += 3;
                  if (!--v45)
                  {
                    float v42 = 0.0;
                    float v41 = 1.0;
                    goto LABEL_36;
                  }
                }
                float v48 = v47 - v46;
LABEL_35:
                float v49 = *v43 - v44;
                float v50 = 1.0 / sqrtf((float)(v49 * v49) + (float)(v48 * v48));
                float v41 = v50 * v49;
                float v42 = v50 * v48;
LABEL_36:
                uint64_t v39 = 2;
                unint64_t v40 = 1;
              }
              char v51 = (char *)v351[0] - 1;
              if ((void *)v40 < (char *)v351[0] - 1)
              {
                uint64_t v52 = *(void *)v352 + 12 * v40 + 16;
                do
                {
                  float v57 = v41;
                  float v58 = v42;
                  unint64_t v59 = v40++;
                  if (v40 < (unint64_t)v37)
                  {
                    unint64_t v60 = (float *)(v38 + 12 * v59);
                    float v61 = *v60;
                    float v62 = v60[1];
                    uint64_t v63 = (float *)v52;
                    unint64_t v64 = v40;
                    while (1)
                    {
                      float v65 = *(v63 - 1);
                      float v66 = vabds_f32(*v63, v62);
                      BOOL v67 = vabds_f32(v65, v61) < 1.0e-10 && v66 < 1.0e-10;
                      if (!v67) {
                        break;
                      }
                      ++v64;
                      v63 += 3;
                      if (v64 >= (unint64_t)v37) {
                        goto LABEL_52;
                      }
                    }
                    float v68 = v65 - v61;
                    float v69 = *v63 - v62;
                    float v70 = 1.0 / sqrtf((float)(v68 * v68) + (float)(v69 * v69));
                    float v41 = v70 * v68;
                    float v42 = v70 * v69;
                  }
LABEL_52:
                  float v71 = atan2f(v42, v41);
                  float v54 = v71 - atan2f(v58, v57);
                  double v72 = v54;
                  if (v54 > 3.14159265)
                  {
                    double v53 = v72 + -6.28318531;
                  }
                  else
                  {
                    if (v72 >= -3.14159265) {
                      goto LABEL_41;
                    }
                    double v53 = v72 + 6.28318531;
                  }
                  float v54 = v53;
LABEL_41:
                  float v55 = fmaxf(ceilf(fabsf(v54) * 1.2732), 1.0);
                  unint64_t v56 = 2;
                  if ((unint64_t)v55 >= 2) {
                    unint64_t v56 = 2 * (unint64_t)v55;
                  }
                  v39 += v56;
                  v52 += 12;
                }
                while ((char *)v40 != v51);
              }
              uint64_t v73 = 2;
              if (*(unsigned char *)(v36 + 96)) {
                uint64_t v73 = 4;
              }
              unint64_t v74 = v73 + v39;
              if (*(unsigned char *)(v36 + 97)) {
                v74 += 2;
              }
              if (v74 < 0x10000)
              {
                uint64_t v29 = 3 * v74 + *(void *)(v36 + 24);
                if (*(unsigned char *)(v36 + 96)) {
                  uint64_t v30 = -1;
                }
                else {
                  uint64_t v30 = 0;
                }
                unint64_t v31 = ((v74 + 2 * (v30 - (*(unsigned char *)(v36 + 97) != 0))) & 0xFFFFFFFFFFFFFFFELL) + *(void *)(v36 + 40);
                unint64_t v32 = *(void *)(v36 + 8) + v74;
                uint64_t v33 = v29 - 6;
                unint64_t v34 = v31 - 2;
              }
              else
              {
                unint64_t v32 = *(void *)(v36 + 8);
                uint64_t v33 = *(void *)(v36 + 24);
                unint64_t v34 = *(void *)(v36 + 40);
              }
              unint64_t v27 = v349;
              *(void *)(v36 + 16) = v32;
              *(void *)(v36 + 32) = v33;
              *(void *)(v36 + 48) = v34;
            }
            unsigned int v35 = (void *)*v28++;
            v26[1] = v35[2] + v26[1] - v35[1];
            v26[3] = v35[4] + v26[3] - v35[3];
            v26[5] = v35[6] + v26[5] - v35[5];
          }
          while (v28 != v27);
          if (v355.__begin_) {
            operator delete(v355.__begin_);
          }
        }
        uint64_t v21 = v341;
        if (*(void *)v352) {
          operator delete(*(void **)v352);
        }
        unsigned int v75 = v343;
        uint64_t v76 = *v343;
        if (v346 < v339)
        {
          *(void *)uint64_t v346 = v76;
          uint64_t v25 = v346 + 8;
          unsigned int v20 = v314;
          goto LABEL_15;
        }
        uint64_t v77 = (v346 - v341) >> 3;
        unint64_t v78 = v77 + 1;
        if ((unint64_t)(v77 + 1) >> 61) {
          abort();
        }
        if ((v339 - v341) >> 2 > v78) {
          unint64_t v78 = (v339 - v341) >> 2;
        }
        if ((unint64_t)(v339 - v341) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v79 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v79 = v78;
        }
        if (v79)
        {
          if (v79 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          unsigned int v80 = operator new(8 * v79);
        }
        else
        {
          unsigned int v80 = 0;
        }
        int v81 = &v80[8 * v77];
        *(void *)int v81 = v76;
        uint64_t v25 = v81 + 8;
        if (v346 == v341)
        {
          unsigned int v20 = v314;
          goto LABEL_85;
        }
        unint64_t v82 = v346 - 8 - v341;
        if (v82 < 0x168)
        {
          unsigned int v83 = v346;
          unsigned int v20 = v314;
          goto LABEL_84;
        }
        if (&v80[v346 - v341 - 8 - (v82 & 0xFFFFFFFFFFFFFFF8)] > &v80[v346 - v341 - 8]
          || &v346[-(v82 & 0xFFFFFFFFFFFFFFF8) - 8] > v346 - 8
          || (unint64_t)(v341 - v80) < 0x20)
        {
          unsigned int v83 = v346;
          unsigned int v20 = v314;
          do
          {
LABEL_84:
            uint64_t v84 = *((void *)v83 - 1);
            v83 -= 8;
            *((void *)v81 - 1) = v84;
            v81 -= 8;
          }
          while (v83 != v341);
          goto LABEL_85;
        }
        uint64_t v85 = (v82 >> 3) + 1;
        unsigned int v83 = &v346[-8 * (v85 & 0x3FFFFFFFFFFFFFFCLL)];
        int v86 = &v80[8 * v77 - 16];
        unsigned int v87 = v346 - 16;
        uint64_t v88 = v85 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v89 = *(_OWORD *)v87;
          *(v86 - 1) = *((_OWORD *)v87 - 1);
          *int v86 = v89;
          v86 -= 2;
          v87 -= 32;
          v88 -= 4;
        }
        while (v88);
        v81 -= 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
        unsigned int v20 = v314;
        if (v85 != (v85 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_84;
        }
LABEL_85:
        uint64_t v339 = &v80[8 * v79];
        if (v341) {
          operator delete(v341);
        }
        uint64_t v21 = v81;
        unsigned int v75 = v343;
LABEL_15:
        uint64_t v23 = (void **)(v75 + 1);
        uint64_t v346 = v25;
        uint64_t v24 = v337;
      }
      int v18 = v335 + 1;
      if (v335 + 1 == v334)
      {
        if (!*((unsigned char *)v20 + 112)) {
          goto LABEL_96;
        }
LABEL_95:
        operator new();
      }
    }
  }
  uint64_t v346 = 0;
  uint64_t v21 = 0;
  if (a7) {
    goto LABEL_95;
  }
LABEL_96:
  unint64_t v90 = 0;
  uint64_t v91 = 0;
  uint64_t v92 = 0;
  unint64_t v93 = (v346 - v21) >> 3;
  do
  {
    if (v90 == v93
      || (unint64_t)(*(void *)(*(void *)&v21[8 * v90] + 8) + v92 - **(void **)&v21[8 * v90]) >= 0x10000)
    {
      int v94 = operator new(0xF8uLL);
      v94[1] = 0;
      v94[2] = 0;
      *int v94 = &unk_1EF584FF8;
      ggl::BufferData::BufferData((uint64_t)(v94 + 3), 16, 0, 0, 1, v92);
      v94[29] = "BatchType/VData";
      v94[30] = &ggl::Ribbon::defaultVboReflection;
      v94[3] = &unk_1EF55CC48;
      v94[28] = &unk_1EF55CC68;
      uint64_t v95 = operator new(0xF8uLL);
      v95[1] = 0;
      v95[2] = 0;
      *uint64_t v95 = &unk_1EF583D28;
      ggl::BufferData::BufferData((uint64_t)(v95 + 3), 2, 1, 0, 1, v91);
      *((_DWORD *)v95 + 60) = 0;
      v95[3] = &unk_1EF55B630;
      v95[4] = 2;
      v95[28] = &unk_1EF55B650;
      v95[29] = "BatchType/IData";
      operator new();
    }
    if (v90 < v93)
    {
      unsigned int v96 = *(void **)&v21[8 * v90];
      uint64_t v92 = v96[1] + v92 - *v96;
      uint64_t v91 = v96[3] + v91 + v96[5] - (v96[2] + v96[4]);
    }
    ++v90;
  }
  while (v90 <= v93);
  if (v21) {
    operator delete(v21);
  }
  int v97 = "se_cfENS_8_hash_cfENS_9_equal_cfEEE";
  uint64_t v98 = "se_cfENS_8_hash_cfENS_9_equal_cfEEE";
  if ((void)v353) {
    operator delete((void *)v353);
  }
  void *v20 = &unk_1EF530FF8;
  v20[20] = *v329;
  uint64_t v99 = v329[1];
  v20[21] = v99;
  if (v99) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v99 + 8), 1uLL, memory_order_relaxed);
  }
  v20[22] = *a5;
  uint64_t v100 = a5[1];
  v20[23] = v100;
  if (v100) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v100 + 8), 1uLL, memory_order_relaxed);
  }
  v20[24] = 0;
  uint64_t v101 = v20[1];
  uint64_t v311 = v20[2];
  if (v101 != v311)
  {
    float v102 = 1.0;
    do
    {
      uint64_t v103 = *(void *)(*(void *)v101 + 1016);
      uint64_t v104 = *(void *)(*(void *)v101 + 1024);
      uint64_t v312 = v101;
      uint64_t v313 = v104;
      while (v103 != v104)
      {
        unsigned int v105 = *(void **)v103;
        uint64_t v106 = **(void **)(*(void *)(*(void *)v103 + 88) + 64);
        uint64_t v107 = *(void *)(v106 + 8);
        uint64_t v319 = v107 * *(void *)(*(void *)v103 + 8);
        uint64_t v323 = v107 * **(void **)v103;
        uint64_t v317 = v106;
        uint64_t v315 = v103;
        if (v319 == v323)
        {
          uint64_t v325 = 0;
        }
        else if (a2 && *(unsigned char *)(v106 + 17) != 2)
        {
          uint64_t v325 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
        }
        else
        {
          uint64_t v325 = *(void *)(v106 + 72) + v323;
        }
        unint64_t v108 = v105[2];
        unint64_t v110 = v105[4];
        unint64_t v109 = v105[5];
        if (v109 == v110)
        {
          unint64_t v109 = v105[3];
        }
        else
        {
          if (v110 < v108) {
            unint64_t v108 = v105[4];
          }
          if (v105[3] > v109) {
            unint64_t v109 = v105[3];
          }
        }
        uint64_t v111 = *(void *)(v105[11] + 96);
        uint64_t v112 = *(void *)(v111 + 8);
        uint64_t v318 = v112 * v109;
        uint64_t v322 = v112 * v108;
        uint64_t v316 = v111;
        if (v112 * v109 == v112 * v108)
        {
          uint64_t v324 = 0;
        }
        else if (a2 && *(unsigned char *)(v111 + 17) != 2)
        {
          uint64_t v324 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 56))(a2);
        }
        else
        {
          uint64_t v324 = *(void *)(v111 + 72) + v322;
        }
        uint64_t v113 = v105[2];
        uint64_t v114 = v105[4];
        memset(v351, 0, sizeof(v351));
        memset(&__p, 0, sizeof(__p));
        v321 = v105;
        int v115 = (uint64_t *)v105[7];
        v320 = v105 + 7;
        uint64_t v116 = (uint64_t *)v105[8];
        if (v115 != v116)
        {
          uint64_t v117 = 2 * v108;
          uint64_t v118 = v324 + 2 * v114 - 2 * v108;
          uint64_t v119 = v324 + 2 * v113 - v117;
          uint64_t v333 = v325;
          v327 = (uint64_t *)v105[8];
          while (1)
          {
            uint64_t v121 = *v115;
            *(_OWORD *)unint64_t v352 = xmmword_1A28FC870;
            *(_OWORD *)&v352[16] = xmmword_1A28FC880;
            uint64_t v122 = *(void *)(v121 + 16);
            if (v122 != *(void *)(v121 + 8)) {
              break;
            }
            uint64_t v120 = *(void *)(v121 + 16);
LABEL_138:
            v333 += 16 * (v120 - v122);
            v119 += 2 * (*(void *)(v121 + 32) - *(void *)(v121 + 24));
            v118 += 2 * (*(void *)(v121 + 48) - *(void *)(v121 + 40));
            if (++v115 == v116) {
              goto LABEL_263;
            }
          }
          uint64_t v330 = (_WORD *)v119;
          unint64_t v356 = 1;
          md::Ribbons::RibbonWriter<md::Ribbons::DaVinciTrafficRibbonDescriptor>::eliminateDuplicates(v121, (uint64_t)v351, &__p, (uint64_t *)&v356);
          uint64_t v332 = (_WORD *)v118;
          unint64_t v124 = v356;
          if (v356 >= 2)
          {
            uint64_t v125 = (char *)v351[0];
            unint64_t v126 = v356 - 1;
            int32x2_t v127 = *(int32x2_t *)v351[0];
            if (v356 > 9)
            {
              uint64_t v131 = v126 & 7;
              if ((v126 & 7) == 0) {
                uint64_t v131 = 8;
              }
              unint64_t v128 = v126 - v131;
              v123.i64[1] = *(void *)v351[0];
              int8x16_t v132 = (int8x16_t)vdupq_lane_s32(v127, 0);
              int v133 = (int32x4_t *)((char *)v351[0] + 60);
              float32x4_t v134 = 0uLL;
              unint64_t v135 = v128;
              float32x4_t v136 = 0uLL;
              do
              {
                i32 = (const float *)v133[-3].i32;
                float32x4x3_t v358 = vld3q_f32(i32);
                int32x4_t v139 = v133[1];
                int32x4_t v138 = v133[2];
                int32x4_t v140 = *v133;
                v133 += 6;
                v141.i64[0] = __PAIR64__(v140.u32[3], v140.u32[0]);
                float32x4_t v142 = (float32x4_t)vrev64q_s32(v139);
                v142.i32[0] = v140.i32[1];
                v141.i64[1] = __PAIR64__(v138.u32[1], v139.u32[2]);
                v142.i32[3] = v138.i32[2];
                float32x4_t v143 = vsubq_f32(v358.val[0], (float32x4_t)vextq_s8(v132, (int8x16_t)v358.val[0], 0xCuLL));
                float32x4_t v144 = vsubq_f32((float32x4_t)v141, (float32x4_t)vextq_s8((int8x16_t)v358.val[0], v141, 0xCuLL));
                float32x4_t v145 = vsubq_f32(v358.val[1], (float32x4_t)vextq_s8(v123, (int8x16_t)v358.val[1], 0xCuLL));
                v358.val[0] = vsubq_f32(v142, (float32x4_t)vextq_s8((int8x16_t)v358.val[1], (int8x16_t)v142, 0xCuLL));
                float32x4_t v134 = vaddq_f32(vsqrtq_f32(vmlaq_f32(vmulq_f32(v143, v143), v145, v145)), v134);
                float32x4_t v136 = vaddq_f32(vsqrtq_f32(vmlaq_f32(vmulq_f32(v144, v144), v358.val[0], v358.val[0])), v136);
                int8x16_t v123 = (int8x16_t)v142;
                int8x16_t v132 = v141;
                v135 -= 8;
              }
              while (v135);
              float32x2_t v130 = *(float32x2_t *)((char *)v138.i64 + 4);
              float32x4_t v146 = vaddq_f32(v136, v134);
              float v129 = vaddv_f32((float32x2_t)*(_OWORD *)&vpaddq_f32(v146, v146));
            }
            else
            {
              unint64_t v128 = 0;
              float v129 = 0.0;
              float32x2_t v130 = *(float32x2_t *)v351[0];
            }
            unint64_t v147 = v128 + 1;
            uint64_t v148 = (char *)v351[0] + 12 * v128 + 12;
            do
            {
              float32x2_t v149 = *(float32x2_t *)v148;
              uint64_t v148 = (void *)((char *)v148 + 12);
              float32x2_t v150 = vsub_f32(v149, v130);
              float v129 = sqrtf(vaddv_f32(vmul_f32(v150, v150))) + v129;
              ++v147;
              float32x2_t v130 = v149;
            }
            while (v356 != v147);
            double v151 = v129;
            float v152 = v102 / v129;
            if (v151 <= 1.0e-10) {
              float v152 = 0.0;
            }
            float v336 = v152;
            unint64_t v328 = v115;
            if (*(unsigned char *)(v121 + 98))
            {
              unint64_t v153 = 0;
              float v155 = *(float *)(v121 + 100);
              float v154 = *(float *)(v121 + 104);
              float v156 = 0.0;
              uint64_t v157 = v333;
            }
            else
            {
              float v158 = (float *)((char *)v351[0] + 16);
              float v156 = sqrtf((float)((float)(*((float *)v351[0] + 3) - *(float *)v127.i32)* (float)(*((float *)v351[0] + 3) - *(float *)v127.i32))+ (float)((float)(*((float *)v351[0] + 4) - *(float *)&v127.i32[1])* (float)(*((float *)v351[0] + 4) - *(float *)&v127.i32[1])));
              unint64_t v159 = v356 - 1;
              do
              {
                float v160 = *(v158 - 1);
                float v161 = vabds_f32(*v158, *(float *)&v127.i32[1]);
                if (vabds_f32(v160, *(float *)v127.i32) >= 1.0e-10 || v161 >= 1.0e-10)
                {
                  float v163 = v160 - *(float *)v127.i32;
                  float v164 = *v158 - *(float *)&v127.i32[1];
                  float v165 = v102 / sqrtf((float)(v163 * v163) + (float)(v164 * v164));
                  float v155 = v165 * v163;
                  float v154 = v165 * v164;
                  goto LABEL_162;
                }
                v158 += 3;
                --v159;
              }
              while (v159);
              float v155 = 1.0;
              float v154 = 0.0;
LABEL_162:
              int v166 = *((_DWORD *)v351[0] + 2);
              uint64_t v354 = 0;
              *(float *)&v355.__end_cap_.__value_ = -v154;
              *((float *)&v355.__end_cap_.__value_ + 1) = v155;
              uint64_t v167 = v333;
              if (*(unsigned char *)(v121 + 96))
              {
                *(float *)&v355.__begin_ = (float)-v154 - v155;
                *((float *)&v355.__begin_ + 1) = v155 - v154;
                *(float *)&v355.__end_ = v154 - v155;
                *((float *)&v355.__end_ + 1) = -(float)(v154 + v155);
                long long v353 = xmmword_1A28FC890;
                float v168 = fmaxf(*(float *)v127.i32, 0.0);
                if (v168 >= v102) {
                  float v169 = 65535.0;
                }
                else {
                  float v169 = v168 * 65535.0;
                }
                int v170 = (int)v169;
                float v171 = fmaxf(*(float *)&v127.i32[1], 0.0);
                if (v171 >= v102) {
                  float v172 = 65535.0;
                }
                else {
                  float v172 = v171 * 65535.0;
                }
                int v173 = (int)v172;
                *(_WORD *)uint64_t v333 = v170;
                *(_WORD *)(v333 + 2) = (int)v172;
                *(_DWORD *)(v333 + 12) = v166;
                v174.i64[0] = (uint64_t)v355.__begin_;
                v174.i64[1] = 0xBF8000003F800000;
                v175.i64[0] = 0xBF000000BF000000;
                v175.i64[1] = 0xBF000000BF000000;
                *(int16x4_t *)(v333 + 4) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v175, (float32x4_t)xmmword_1A28FC8B0, v174)));
                *(_WORD *)(v333 + 16) = v170;
                *(_WORD *)(v333 + 18) = v173;
                *(_DWORD *)(v333 + 28) = v166;
                v174.i64[0] = (uint64_t)v355.__end_;
                v174.i64[1] = *((void *)&v353 + 1);
                v175.i64[0] = 0xBF000000BF000000;
                v175.i64[1] = 0xBF000000BF000000;
                *(int16x4_t *)(v333 + 20) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v175, (float32x4_t)xmmword_1A28FC8B0, v174)));
                uint64_t v167 = v333 + 32;
              }
              *(float *)&v355.__begin_ = -v154;
              *((float *)&v355.__begin_ + 1) = v155;
              *(float *)&v355.__end_ = v154;
              *((float *)&v355.__end_ + 1) = -v155;
              long long v353 = xmmword_1A28FC8C0;
              float v176 = fmaxf(*(float *)v127.i32, 0.0);
              if (v176 >= v102) {
                *(float *)v127.i32 = 65535.0;
              }
              else {
                *(float *)v127.i32 = v176 * 65535.0;
              }
              int v177 = (int)*(float *)v127.i32;
              float v178 = fmaxf(*(float *)&v127.i32[1], 0.0);
              if (v178 >= v102) {
                float v179 = 65535.0;
              }
              else {
                float v179 = v178 * 65535.0;
              }
              int v180 = (int)v179;
              *(_WORD *)uint64_t v167 = v177;
              *(_WORD *)(v167 + 2) = (int)v179;
              *(_DWORD *)(v167 + 12) = v166;
              v181.i64[0] = (uint64_t)v355.__begin_;
              v181.i64[1] = v353;
              v182.i64[0] = 0xBF000000BF000000;
              v182.i64[1] = 0xBF000000BF000000;
              *(int16x4_t *)(v167 + 4) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v182, (float32x4_t)xmmword_1A28FC8B0, v181)));
              *(_WORD *)(v167 + 16) = v177;
              *(_WORD *)(v167 + 18) = v180;
              *(_DWORD *)(v167 + 28) = v166;
              v181.i64[0] = (uint64_t)v355.__end_;
              v181.i64[1] = *((void *)&v353 + 1);
              v182.i64[0] = 0xBF000000BF000000;
              v182.i64[1] = 0xBF000000BF000000;
              *(int16x4_t *)(v167 + 20) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v182, (float32x4_t)xmmword_1A28FC8B0, v181)));
              uint64_t v157 = v167 + 32;
              unint64_t v153 = 1;
            }
            if (v153 >= v126)
            {
              float v184 = v154;
              float v185 = v155;
            }
            else
            {
              uint64_t v183 = (uint64_t)&v125[12 * v153 + 16];
              float v184 = v154;
              float v185 = v155;
              do
              {
                BOOL v196 = (float *)&v125[12 * v153];
                float v198 = *v196;
                float v197 = v196[1];
                if (++v153 < v124)
                {
                  int64_t v199 = (float *)v183;
                  unint64_t v200 = v153;
                  do
                  {
                    float v201 = *(v199 - 1);
                    float v202 = vabds_f32(*v199, v197);
                    if (vabds_f32(v201, v198) >= 1.0e-10 || v202 >= 1.0e-10)
                    {
                      float v204 = v201 - v198;
                      float v205 = *v199 - v197;
                      float v206 = v102 / sqrtf((float)(v204 * v204) + (float)(v205 * v205));
                      float v185 = v206 * v204;
                      float v184 = v206 * v205;
                      goto LABEL_196;
                    }
                    ++v200;
                    v199 += 3;
                  }
                  while (v200 < v124);
                  float v184 = v154;
                  float v185 = v155;
                }
LABEL_196:
                BOOL v207 = v125;
                float v208 = v185 + v155;
                float v209 = v184 + v154;
                float v210 = (float)(v208 * v208) + (float)(v209 * v209);
                float v211 = v154;
                float v212 = v155;
                if (v210 > 0.0)
                {
                  float v213 = v102 / sqrtf(v210);
                  float v212 = -(float)(v209 * v213);
                  float v211 = v213 * v208;
                }
                float v340 = v196[4];
                int v214 = *((_DWORD *)v196 + 2);
                float v338 = v196[3];
                float v347 = v156;
                *(float *)&uint64_t v354 = v156;
                *((float *)&v354 + 1) = v156 * v336;
                long long v353 = xmmword_1A28FC8C0;
                float v344 = v184;
                float v342 = v185;
                float v215 = atan2f(v184, v185);
                float v216 = v215 - atan2f(v154, v155);
                double v217 = v216;
                if (v216 <= *((double *)v97 + 138))
                {
                  float v102 = 1.0;
                  float v218 = -0.5;
                  if (v217 < -3.14159265) {
                    float v216 = v217 + 6.28318531;
                  }
                }
                else
                {
                  float v216 = v217 + *((double *)v98 + 181);
                  float v102 = 1.0;
                  float v218 = -0.5;
                }
                unint64_t v219 = (unint64_t)fmaxf(ceilf(fabsf(v216) * 1.2732), v102);
                if (v219 <= 1)
                {
                  float v185 = v342;
                  float v184 = v344;
                  float v186 = sqrtf(fmaxf(-(float)((float)((float)((float)(v212 * v342) + (float)(v211 * v344))* (float)((float)(v212 * v342) + (float)(v211 * v344)))+ -1.0), 0.1));
                  v355.__end_cap_.__value_ = (unsigned int *)__PAIR64__(LODWORD(v211), LODWORD(v212));
                  *(float *)&v355.__begin_ = v212 / v186;
                  *((float *)&v355.__begin_ + 1) = v211 / v186;
                  *(float *)&v355.__end_ = -(float)(v212 / v186);
                  *((float *)&v355.__end_ + 1) = -(float)(v211 / v186);
                  float v187 = fmaxf(v198, 0.0);
                  if (v187 >= v102) {
                    float v188 = 65535.0;
                  }
                  else {
                    float v188 = v187 * 65535.0;
                  }
                  int v189 = (int)v188;
                  float v190 = fmaxf(v197, 0.0);
                  if (v190 >= v102) {
                    float v191 = 65535.0;
                  }
                  else {
                    float v191 = v190 * 65535.0;
                  }
                  int v192 = (int)v191;
                  *(_WORD *)uint64_t v157 = v189;
                  *(_WORD *)(v157 + 2) = (int)v191;
                  *(_DWORD *)(v157 + 12) = v214;
                  v193.i64[0] = (uint64_t)v355.__begin_;
                  v193.i64[1] = v353;
                  v194.i64[0] = 0xBF000000BF000000;
                  v194.i64[1] = 0xBF000000BF000000;
                  *(int16x4_t *)(v157 + 4) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v194, (float32x4_t)xmmword_1A28FC8B0, v193)));
                  *(_WORD *)(v157 + 16) = v189;
                  *(_WORD *)(v157 + 18) = v192;
                  *(_DWORD *)(v157 + 28) = v214;
                  v193.i64[0] = (uint64_t)v355.__end_;
                  v193.i64[1] = *((void *)&v353 + 1);
                  v194.i64[0] = 0xBF000000BF000000;
                  v194.i64[1] = 0xBF000000BF000000;
                  *(int16x4_t *)(v157 + 20) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v194, (float32x4_t)xmmword_1A28FC8B0, v193)));
                  v157 += 32;
                  uint64_t v125 = v207;
                  float v195 = v347;
                }
                else
                {
                  uint64_t v220 = 0;
                  float v221 = fmaxf(v198, 0.0);
                  if (v221 >= v102) {
                    float v222 = 65535.0;
                  }
                  else {
                    float v222 = v221 * 65535.0;
                  }
                  int v223 = (int)v222;
                  float v224 = fmaxf(v197, 0.0);
                  if (v224 >= v102) {
                    float v225 = 65535.0;
                  }
                  else {
                    float v225 = v224 * 65535.0;
                  }
                  int v226 = (int)v225;
                  do
                  {
                    __float2 v227 = __sincosf_stret((float)(v218 + (float)((float)(int)v220 * (float)(1.0 / (float)((float)v219 + -1.0))))* v216);
                    *(float *)&v355.__end_cap_.__value_ = -(float)((float)(v227.__sinval * v211)
                                                                 - (float)(v227.__cosval * v212));
                    *((float *)&v355.__end_cap_.__value_ + 1) = (float)(v227.__sinval * v212)
                                                              + (float)(v227.__cosval * v211);
                    v355.__begin_ = (std::vector<unsigned int>::pointer)v355.__end_cap_;
                    *(float *)&v355.__end_ = -(float)((float)(v227.__cosval * v212) - (float)(v227.__sinval * v211));
                    *((float *)&v355.__end_ + 1) = -*((float *)&v355.__end_cap_.__value_ + 1);
                    *(_WORD *)uint64_t v157 = v223;
                    *(_WORD *)(v157 + 2) = v226;
                    *(_DWORD *)(v157 + 12) = v214;
                    v228.i64[0] = (uint64_t)v355.__begin_;
                    v228.i64[1] = v353;
                    v229.i64[0] = 0xBF000000BF000000;
                    v229.i64[1] = 0xBF000000BF000000;
                    *(int16x4_t *)(v157 + 4) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v229, (float32x4_t)xmmword_1A28FC8B0, v228)));
                    *(_WORD *)(v157 + 16) = v223;
                    *(_WORD *)(v157 + 18) = v226;
                    *(_DWORD *)(v157 + 28) = v214;
                    v228.i64[0] = (uint64_t)v355.__end_;
                    v228.i64[1] = *((void *)&v353 + 1);
                    v229.i64[0] = 0xBF000000BF000000;
                    v229.i64[1] = 0xBF000000BF000000;
                    *(int16x4_t *)(v157 + 20) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v229, (float32x4_t)xmmword_1A28FC8B0, v228)));
                    v157 += 32;
                    ++v220;
                  }
                  while (v219 != v220);
                  int v97 = "N3geo11_retain_ptrIP9CGContextNS_10_retain_cfIS2_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE"
                      + 62;
                  uint64_t v98 = "N3geo11_retain_ptrIP9CGContextNS_10_retain_cfIS2_EENS_11_release_cfENS_8_hash_cfENS_9_equal_cfEEE"
                      + 62;
                  float v102 = 1.0;
                  uint64_t v125 = v207;
                  float v195 = v347;
                  float v184 = v344;
                  float v185 = v342;
                }
                float v156 = sqrtf((float)((float)(v338 - v198) * (float)(v338 - v198))+ (float)((float)(v340 - v197) * (float)(v340 - v197)))+ v195;
                v183 += 12;
                float v154 = v184;
                float v155 = v185;
                unint64_t v126 = v124 - 1;
              }
              while (v153 != v124 - 1);
            }
            uint64_t v230 = (float *)&v125[12 * v126];
            uint64_t v231 = (float *)&v125[12 * v124];
            float v233 = *(v231 - 6);
            unint64_t v232 = (char *)(v231 - 6);
            float v234 = v233;
            float v235 = *v230;
            if (vabds_f32(*v230, v233) >= 1.0e-10)
            {
              float v237 = v230[1];
              float v242 = v237 - *((float *)v232 + 1);
            }
            else
            {
              float v236 = *((float *)v232 + 1);
              float v237 = v230[1];
              if (vabds_f32(v237, v236) < 1.0e-10)
              {
                if (!*(unsigned char *)(v121 + 99)) {
                  goto LABEL_216;
                }
LABEL_220:
                float v345 = v237;
                float v348 = v156;
                float v245 = *(float *)(v121 + 108);
                float v246 = *(float *)(v121 + 112);
                float v247 = v185 + v245;
                float v248 = v184 + v246;
                float v249 = (float)(v247 * v247) + (float)(v248 * v248);
                float v250 = v185;
                float v238 = v185;
                float v251 = v184;
                float v241 = v184;
                if (v249 > 0.0)
                {
                  float v252 = v102 / sqrtf(v249);
                  float v238 = -(float)(v248 * v252);
                  float v241 = v252 * v247;
                }
                float v253 = atan2f(*(float *)(v121 + 112), *(float *)(v121 + 108));
                float v254 = v253 - atan2f(v251, v250);
                double v255 = v254;
                if (v254 <= *((double *)v97 + 138))
                {
                  float v102 = 1.0;
                  float v156 = v348;
                  float v237 = v345;
                  if (v255 < -3.14159265) {
                    float v254 = v255 + 6.28318531;
                  }
                }
                else
                {
                  float v254 = v255 + *((double *)v98 + 181);
                  float v102 = 1.0;
                  float v156 = v348;
                  float v237 = v345;
                }
                BOOL v67 = (unint64_t)fmaxf(ceilf(fabsf(v254) * 1.2732), v102) > 1;
                float v256 = sqrtf(fmaxf(-(float)((float)((float)((float)(v238 * v245) + (float)(v241 * v246))* (float)((float)(v238 * v245) + (float)(v241 * v246)))+ -1.0), 0.1));
                float v257 = v238 / v256;
                float v239 = v241 / v256;
                if (v67)
                {
                  float v257 = v238;
                  float v239 = v241;
                }
                v355.__begin_ = (std::vector<unsigned int>::pointer)__PAIR64__(LODWORD(v239), LODWORD(v257));
                float v240 = -v257;
                float v184 = v251;
                float v185 = v250;
                goto LABEL_229;
              }
              float v242 = v237 - v236;
            }
            float v243 = v235 - v234;
            float v244 = v102 / sqrtf((float)(v243 * v243) + (float)(v242 * v242));
            float v185 = v244 * v243;
            float v184 = v244 * v242;
            if (*(unsigned char *)(v121 + 99)) {
              goto LABEL_220;
            }
LABEL_216:
            float v238 = -v184;
            *(float *)&v355.__begin_ = -v184;
            *((float *)&v355.__begin_ + 1) = v185;
            float v239 = v185;
            float v240 = v184;
            float v241 = v185;
LABEL_229:
            *(float *)&v355.__end_ = v240;
            *((float *)&v355.__end_ + 1) = -v239;
            int v258 = *((_DWORD *)v230 + 2);
            v355.__end_cap_.__value_ = (unsigned int *)__PAIR64__(LODWORD(v241), LODWORD(v238));
            *(float *)&uint64_t v354 = v156;
            *((float *)&v354 + 1) = v156 * v336;
            float v259 = fmaxf(v235, 0.0);
            if (v259 >= v102) {
              float v260 = 65535.0;
            }
            else {
              float v260 = v259 * 65535.0;
            }
            int v261 = (int)v260;
            float v262 = fmaxf(v237, 0.0);
            if (v262 >= v102) {
              float v263 = 65535.0;
            }
            else {
              float v263 = v262 * 65535.0;
            }
            int v264 = (int)v263;
            *(_WORD *)uint64_t v157 = v261;
            *(_WORD *)(v157 + 2) = (int)v263;
            *(_DWORD *)(v157 + 12) = v258;
            v265.i64[0] = (uint64_t)v355.__begin_;
            v265.i64[1] = v353;
            v266.i64[0] = 0xBF000000BF000000;
            v266.i64[1] = 0xBF000000BF000000;
            *(int16x4_t *)(v157 + 4) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v266, (float32x4_t)xmmword_1A28FC8B0, v265)));
            *(_WORD *)(v157 + 16) = v261;
            *(_WORD *)(v157 + 18) = v264;
            *(_DWORD *)(v157 + 28) = v258;
            v265.i64[0] = (uint64_t)v355.__end_;
            v265.i64[1] = *((void *)&v353 + 1);
            v266.i64[0] = 0xBF000000BF000000;
            v266.i64[1] = 0xBF000000BF000000;
            *(int16x4_t *)(v157 + 20) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v266, (float32x4_t)xmmword_1A28FC8B0, v265)));
            uint64_t v267 = *(char *)(v121 + 97);
            if (*(unsigned char *)(v121 + 97))
            {
              *(float *)&v355.__begin_ = v185 + v238;
              *((float *)&v355.__begin_ + 1) = v184 + v241;
              *(float *)&v355.__end_ = v185 - v238;
              *((float *)&v355.__end_ + 1) = v184 - v241;
              uint64_t v268 = *(void *)&v352[8];
              long long v353 = *(_OWORD *)&v352[8];
              *(_WORD *)(v157 + 32) = v261;
              *(_WORD *)(v157 + 34) = v264;
              v269.i64[0] = (uint64_t)v355.__begin_;
              v269.i64[1] = v268;
              *(_DWORD *)(v157 + 44) = v258;
              v270.i64[0] = 0xBF000000BF000000;
              v270.i64[1] = 0xBF000000BF000000;
              *(int16x4_t *)(v157 + 36) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v270, (float32x4_t)xmmword_1A28FC8B0, v269)));
              *(_WORD *)(v157 + 48) = v261;
              *(_WORD *)(v157 + 50) = v264;
              v270.i64[0] = (uint64_t)v355.__end_;
              v270.i64[1] = *((void *)&v353 + 1);
              *(_DWORD *)(v157 + 60) = v258;
              v271.i64[0] = 0xBF000000BF000000;
              v271.i64[1] = 0xBF000000BF000000;
              *(int16x4_t *)(v157 + 52) = vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v271, (float32x4_t)xmmword_1A28FC8B0, v270)));
            }
            unint64_t v272 = *(void *)(v121 + 8);
            unint64_t v273 = *(void *)(v121 + 16) - v272;
            unint64_t v274 = v273 >> 1;
            v275.i64[0] = 0x1000100010001;
            v275.i64[1] = 0x1000100010001;
            int v115 = v328;
            if (v273 >= 4)
            {
              uint64_t v276 = *(void *)(v121 + 8);
              unint64_t v277 = 2;
              if (v274 > 2) {
                unint64_t v277 = v274;
              }
              if (v277 >= 3)
              {
                uint64_t v280 = 0;
                unint64_t v281 = v277 - 1;
                unint64_t v282 = (v277 - 1) & 0xFFFFFFFFFFFFFFFELL;
                uint64_t v283 = v330 + 6;
                do
                {
                  __int16 v284 = v272 + 2 * v280;
                  *(v283 - 6) = v284;
                  _WORD *v283 = v284 + 2;
                  *(v283 - 5) = v284 + 1;
                  v283[1] = v284 + 3;
                  *(v283 - 4) = v284 + 2;
                  v283[2] = v284 + 4;
                  *(v283 - 3) = v284 + 1;
                  v283[3] = v284 + 3;
                  *(v283 - 2) = v284 + 3;
                  v283[4] = v284 + 5;
                  v280 += 2;
                  *(v283 - 1) = v284 + 2;
                  v283[5] = v284 + 4;
                  v283 += 12;
                }
                while (v282 != v280);
                if (v281 != v282)
                {
                  uint64_t v278 = v281 | 1;
                  LODWORD(v276) = 2 * v282 + v272;
                  uint64_t v279 = &v330[6 * v282];
                  goto LABEL_246;
                }
              }
              else
              {
                uint64_t v278 = 1;
                uint64_t v279 = v330;
LABEL_246:
                unint64_t v285 = v277 - v278;
                do
                {
                  *uint64_t v279 = v276;
                  __int16 v286 = v276 + 1;
                  v279[1] = v276 + 1;
                  __int16 v287 = v276 + 3;
                  LODWORD(v276) = v276 + 2;
                  v279[2] = v276;
                  v279[3] = v286;
                  v279[4] = v287;
                  v279[5] = v276;
                  v279 += 6;
                  --v285;
                }
                while (v285);
              }
            }
            if (*(void *)(v121 + 48) != *(void *)(v121 + 40))
            {
              unint64_t v288 = *(unsigned char *)(v121 + 96) ? 2 : 1;
              if (v274 - v267 > v288)
              {
                unint64_t v289 = v274 - (v288 + v267);
                unint64_t v290 = v332;
                if (v289 < 8)
                {
LABEL_258:
                  unint64_t v300 = v288 + v267 - v274;
                  unint64_t v301 = v272 + 2 * v288;
                  do
                  {
                    *unint64_t v290 = v301 - 2;
                    v290[1] = v301;
                    v301 += 2;
                    v290 += 2;
                  }
                  while (!__CFADD__(v300++, 1));
                }
                else
                {
                  unint64_t v291 = v289 & 0xFFFFFFFFFFFFFFF8;
                  int64x2_t v292 = vdupq_n_s64(v288);
                  int64x2_t v293 = vaddq_s64(v292, (int64x2_t)xmmword_1A28FC8F0);
                  int64x2_t v294 = vaddq_s64(v292, (int64x2_t)xmmword_1A28FC900);
                  int64x2_t v295 = vaddq_s64(v292, (int64x2_t)xmmword_1A28FC910);
                  int64x2_t v296 = vaddq_s64(v292, (int64x2_t)xmmword_1A28FC760);
                  int64x2_t v297 = vdupq_n_s64(v272);
                  uint64_t v298 = v332;
                  unint64_t v299 = v289 & 0xFFFFFFFFFFFFFFF8;
                  do
                  {
                    v357.val[1] = vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v297, vaddq_s64(v296, v296)), (int32x4_t)vaddq_s64(v297, vaddq_s64(v295, v295))), (int16x8_t)vuzp1q_s32((int32x4_t)vaddq_s64(v297, vaddq_s64(v294, v294)), (int32x4_t)vaddq_s64(v297, vaddq_s64(v293, v293))));
                    v357.val[0] = vaddq_s16(v357.val[1], v275);
                    vst2q_s16(v298, v357);
                    v298 += 16;
                    v357.val[0] = (int16x8_t)vdupq_n_s64(8uLL);
                    int64x2_t v294 = vaddq_s64(v294, (int64x2_t)v357.val[0]);
                    int64x2_t v295 = vaddq_s64(v295, (int64x2_t)v357.val[0]);
                    int64x2_t v296 = vaddq_s64(v296, (int64x2_t)v357.val[0]);
                    int64x2_t v293 = vaddq_s64(v293, (int64x2_t)v357.val[0]);
                    v299 -= 8;
                  }
                  while (v299);
                  if (v289 != v291)
                  {
                    v288 |= v291;
                    unint64_t v290 = &v332[2 * (v289 & 0xFFFFFFFFFFFFFFF8)];
                    goto LABEL_258;
                  }
                }
              }
            }
            uint64_t v116 = v327;
          }
          uint64_t v121 = *v115;
          uint64_t v122 = *(void *)(*v115 + 8);
          uint64_t v120 = *(void *)(*v115 + 16);
          uint64_t v119 = (uint64_t)v330;
          uint64_t v118 = (uint64_t)v332;
          goto LABEL_138;
        }
LABEL_263:
        {
          operator new();
        }
        unint64_t v304 = v320;
        unint64_t v303 = v321;
        uint64_t v305 = (void *)*v320;
        if (*v320)
        {
          v306 = (void *)v321[8];
          uint64_t v307 = *v320;
          if (v306 != v305)
          {
            do
            {
              unint64_t v309 = (void (***)(void, uint64_t))*--v306;
              unint64_t v308 = v309;
              void *v306 = 0;
              if (v309)
              {
                (**v308)(v308, v307);
                {
                  operator new();
                }
                (*(void (**)(uint64_t, void (***)(void, uint64_t), uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                                 + 40))(mdm::Allocator::instance(void)::alloc, v308, 120);
              }
            }
            while (v306 != v305);
            unint64_t v304 = v320;
            unint64_t v303 = v321;
            uint64_t v307 = *v320;
          }
          v303[8] = v305;
          (*(void (**)(void, uint64_t, uint64_t))(*(void *)v303[10] + 40))(v303[10], v307, v303[9] - v307);
          *unint64_t v304 = 0;
          v304[1] = 0;
          v304[2] = 0;
        }
        *unint64_t v304 = 0;
        v304[1] = 0;
        v304[2] = 0;
        if (__p.__begin_) {
          operator delete(__p.__begin_);
        }
        if (v351[0]) {
          operator delete(v351[0]);
        }
        if (v324 && v318 != v322 && a2 && *(unsigned char *)(v316 + 17) != 2) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 64))(a2, v324, v316, v322, v318, 1, 1);
        }
        if (v325 && v319 != v323 && a2 && *(unsigned char *)(v317 + 17) != 2) {
          (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)a2 + 64))(a2, v325, v317, v323, v319, 1, 1);
        }
        uint64_t v103 = v315 + 8;
        uint64_t v104 = v313;
      }
      uint64_t v101 = v312 + 8;
    }
    while (v312 + 8 != v311);
  }
  unint64_t result = v314;
  void *v314 = &unk_1EF554620;
  v314[25] = 0;
  *((_DWORD *)v314 + 52) = 0;
  return result;
}

void sub_1A17F72AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void **a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void **a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *__p,uint64_t a52,uint64_t a53,void *a54)
{
  MEMORY[0x1A6239270](v54, 0x1020C4007FF0C4BLL);
  if (v55) {
    operator delete(v55);
  }
  uint64_t v58 = a12[15];
  a12[15] = 0;
  if (v58)
  {
    uint64_t v59 = *(void *)(v58 + 2584);
    if (v59) {
      MEMORY[0x1A6239250](v59, 0x1000C8000313F17);
    }
    MEMORY[0x1A6239270](v58, 0x1020C4007FF0C4BLL);
  }
  unint64_t v60 = *a40;
  if (*a40)
  {
    a12[5] = v60;
    operator delete(v60);
    float v61 = *a33;
    if (!*a33)
    {
LABEL_9:
      float v62 = *(void **)(v56 - 224);
      if (!v62) {
        goto LABEL_10;
      }
      goto LABEL_13;
    }
  }
  else
  {
    float v61 = *a33;
    if (!*a33) {
      goto LABEL_9;
    }
  }
  a12[2] = v61;
  operator delete(v61);
  float v62 = *(void **)(v56 - 224);
  if (!v62) {
LABEL_10:
  }
    _Unwind_Resume(a1);
LABEL_13:
  operator delete(v62);
  _Unwind_Resume(a1);
}

void md::Ribbons::RibbonWriter<md::Ribbons::DaVinciTrafficRibbonDescriptor>::eliminateDuplicates(uint64_t a1, uint64_t a2, std::vector<unsigned int> *a3, uint64_t *a4)
{
  *a4 = 1;
  unint64_t v8 = *(void *)(a1 + 88);
  unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a2 + 8) - *(void *)a2) >> 2);
  if (v8 <= v9)
  {
    if (v8 < v9) {
      *(void *)(a2 + 8) = *(void *)a2 + 12 * v8;
    }
  }
  else
  {
    std::vector<gm::Matrix<float,3,1>>::__append((char **)a2, v8 - v9);
    unint64_t v8 = *(void *)(a1 + 88);
  }
  std::vector<unsigned int>::pointer begin = a3->__begin_;
  unint64_t v11 = a3->__end_ - a3->__begin_;
  if (v8 <= v11)
  {
    if (v8 < v11) {
      a3->__end_ = &begin[v8];
    }
  }
  else
  {
    std::vector<unsigned int>::__append(a3, v8 - v11);
    std::vector<unsigned int>::pointer begin = a3->__begin_;
    unint64_t v8 = *(void *)(a1 + 88);
  }
  int v12 = *(char **)a2;
  char v13 = *(_DWORD **)(a1 + 72);
  *(_DWORD *)int v12 = *v13;
  *((_DWORD *)v12 + 1) = v13[1];
  *((_DWORD *)v12 + 2) = v13[2];
  *std::vector<unsigned int>::pointer begin = 0;
  if (v8 >= 2)
  {
    uint64_t v14 = *a4;
    uint64_t v15 = v13 + 3;
    for (unint64_t i = 1; i < v8; ++i)
    {
      int v17 = &v12[12 * v14];
      uint64_t v18 = *(void *)(v17 - 12);
      uint64_t v19 = *((unsigned int *)v17 - 1);
      if (*(void *)v15 != v18 || v15[2] != v19)
      {
        begin[v14] = i;
        uint64_t v21 = &v12[12 * v14++];
        *a4 = v14;
        *(_DWORD *)uint64_t v21 = *v15;
        *((_DWORD *)v21 + 1) = v15[1];
        *((_DWORD *)v21 + 2) = v15[2];
        unint64_t v8 = *(void *)(a1 + 88);
      }
      v15 += 3;
    }
  }
}

void md::RoadRibbon::~RoadRibbon(md::RoadRibbon *this)
{
  *(void *)this = &unk_1EF553D90;
  if (*((unsigned char *)this + 64))
  {
    uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v3) {
        operator new();
      }
    }
    (*(void (**)(void, void, void))(**((void **)v2 + 91) + 40))(*((void *)v2 + 91), *((void *)this + 9), 0);
  }
}

{
  float *v2;
  int v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF553D90;
  if (*((unsigned char *)this + 64))
  {
    uint64_t v2 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
      uint64_t v2 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
      if (v3) {
        operator new();
      }
    }
    (*(void (**)(void, void, void))(**((void **)v2 + 91) + 40))(*((void *)v2 + 91), *((void *)this + 9), 0);
  }
  JUMPOUT(0x1A6239270);
}

void std::vector<unsigned int>::__append(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  std::vector<unsigned int>::pointer end = this->__end_;
  value = this->__end_cap_.__value_;
  uint64_t v6 = end;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(end, 4 * __n);
      uint64_t v6 = &end[__n];
    }
    this->__end_ = v6;
  }
  else
  {
    std::vector<unsigned int>::pointer begin = this->__begin_;
    uint64_t v8 = (char *)end - (char *)this->__begin_;
    uint64_t v9 = v8 >> 2;
    unint64_t v10 = (v8 >> 2) + __n;
    if (v10 >> 62) {
      abort();
    }
    uint64_t v11 = (char *)value - (char *)begin;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      char v13 = operator new(4 * v12);
    }
    else
    {
      char v13 = 0;
    }
    uint64_t v14 = &v13[4 * v9];
    size_t v15 = 4 * __n;
    int v16 = (unsigned int *)&v13[4 * v12];
    bzero(v14, v15);
    int v17 = (unsigned int *)&v14[v15];
    if (end != begin)
    {
      unint64_t v18 = (char *)end - (char *)begin - 4;
      if (v18 < 0x2C) {
        goto LABEL_31;
      }
      if ((unint64_t)((char *)end - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      uint64_t v6 = &end[-(v19 & 0x7FFFFFFFFFFFFFF8)];
      unsigned int v20 = &v13[4 * v9 - 16];
      uint64_t v21 = (long long *)(end - 4);
      uint64_t v22 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v23 = *v21;
        *(v20 - 1) = *(v21 - 1);
        _OWORD *v20 = v23;
        v20 -= 2;
        v21 -= 2;
        v22 -= 8;
      }
      while (v22);
      v14 -= 4 * (v19 & 0x7FFFFFFFFFFFFFF8);
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_31:
        do
        {
          int v24 = *--v6;
          *((_DWORD *)v14 - 1) = v24;
          v14 -= 4;
        }
        while (v6 != begin);
      }
    }
    this->__begin_ = (std::vector<unsigned int>::pointer)v14;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void std::vector<gm::Matrix<float,3,1>>::__append(char **a1, unint64_t a2)
{
  unint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 2) >= a2)
  {
    a1[1] = &v5[12 * (12 * a2 / 0xC)];
  }
  else
  {
    uint64_t v6 = *a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 2);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x1555555555555555) {
      abort();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 2);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x1555555555555555;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x1555555555555555) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v11 = (char *)operator new(12 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    unint64_t v12 = &v11[12 * v7];
    char v13 = &v12[12 * (12 * a2 / 0xC)];
    if (v5 != v6)
    {
      do
      {
        uint64_t v14 = *(void *)(v5 - 12);
        v5 -= 12;
        int v15 = *((_DWORD *)v5 + 2);
        *(void *)(v12 - 12) = v14;
        v12 -= 12;
        *((_DWORD *)v12 + 2) = v15;
      }
      while (v5 != v6);
      unint64_t v5 = *a1;
    }
    *a1 = v12;
    a1[1] = v13;
    a1[2] = &v11[12 * v10];
    if (v5)
    {
      operator delete(v5);
    }
  }
}

{
  char *v4;
  char *v5;
  char *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  int v15;
  uint64_t vars8;

  unint64_t v5 = a1[1];
  uint64_t v4 = a1[2];
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - v5) >> 2) >= a2)
  {
    a1[1] = &v5[12 * (12 * a2 / 0xC)];
  }
  else
  {
    uint64_t v6 = *a1;
    unint64_t v7 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 2);
    unint64_t v8 = v7 + a2;
    if (v7 + a2 > 0x1555555555555555) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((v4 - v6) >> 2);
    if (2 * v9 > v8) {
      unint64_t v8 = 2 * v9;
    }
    if (v9 >= 0xAAAAAAAAAAAAAAALL) {
      unint64_t v10 = 0x1555555555555555;
    }
    else {
      unint64_t v10 = v8;
    }
    if (v10)
    {
      if (v10 > 0x1555555555555555) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v11 = (char *)operator new(12 * v10);
    }
    else
    {
      uint64_t v11 = 0;
    }
    unint64_t v12 = &v11[12 * v7];
    char v13 = &v12[12 * (12 * a2 / 0xC)];
    if (v5 != v6)
    {
      do
      {
        uint64_t v14 = *(void *)(v5 - 12);
        v5 -= 12;
        int v15 = *((_DWORD *)v5 + 2);
        *(void *)(v12 - 12) = v14;
        v12 -= 12;
        *((_DWORD *)v12 + 2) = v15;
      }
      while (v5 != v6);
      unint64_t v5 = *a1;
    }
    *a1 = v12;
    a1[1] = v13;
    a1[2] = &v11[12 * v10];
    if (v5)
    {
      operator delete(v5);
    }
  }
}

void *ggl::MetalResourceAccessor::endAccess(void *result, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  if (a6)
  {
    int v7 = *(unsigned __int8 *)(a3 + 16);
    int v8 = ~v7 & 6;
    int v9 = v7 & 1;
    BOOL v10 = v8 && a7 == 1;
    if (!v10 || v9 == 0)
    {
      uint64_t v13 = *(void *)(a3 + 40);
      uint64_t v14 = v13 + a4;
      uint64_t v15 = v13 + a5;
      int v16 = *(const ggl::Buffer **)(a3 + 24);
      if (a6 == 3 || (int v17 = (uint64_t *)*((void *)v16 + 3)) == 0) {
        int v17 = ggl::MetalResourceManager::newBuffer(*(ggl::MetalResourceManager **)(result[1] + 80), v16);
      }
      unint64_t v18 = (void *)([(id)v17[4] contents] + v14);
      return memcpy(v18, a2, v15 - v14);
    }
  }
  return result;
}

uint64_t ggl::Ribbon::BaseMesh::BaseMesh(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  {
    uint64_t v15 = a3;
    uint64_t v22 = a2;
    a2 = v22;
    a3 = v15;
    if (v16)
    {
      {
        ggl::MeshTyped<ggl::Ribbon::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::Ribbon::defaultVboReflection;
      }
      ggl::MeshTyped<ggl::Ribbon::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::Ribbon::DefaultVbo>::attributesReflection(void)::r;
      unk_1EB32B738 = 1;
      a3 = v15;
      a2 = v22;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EF5606B0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1EF5606D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = &ggl::MeshTyped<ggl::Ribbon::DefaultVbo>::typedReflection(void)::r;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  {
    unsigned int v20 = a3;
    a3 = v20;
    uint64_t v6 = a1 + 64;
    if (v17) {
      operator new();
    }
  }
  uint64_t v7 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = a1 + 120;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v7;
  {
    uint64_t v21 = a3;
    uint64_t v23 = v6;
    uint64_t v8 = a1 + 120;
    a3 = v21;
    int v19 = v18;
    uint64_t v6 = v23;
    if (v19) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = v8;
  *(void *)a1 = &unk_1EF5628A0;
  *(void *)(a1 + 16) = &unk_1EF5628C0;
  uint64_t v9 = a3[1];
  uint64_t v24 = *a3;
  uint64_t v25 = (std::__shared_weak_count *)v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(v6, &v24, &v26, 1uLL);
  BOOL v10 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v12 = *a4;
  uint64_t v11 = a4[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 104) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)a1 = &unk_1EF560C98;
  *(void *)(a1 + 16) = &unk_1EF560CB8;
  return a1;
}

uint64_t ggl::CommonMesh::Pos2UVMesh::Pos2UVMesh(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  {
    uint64_t v15 = a3;
    uint64_t v22 = a2;
    a2 = v22;
    a3 = v15;
    if (v16)
    {
      {
        ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r = (uint64_t)&ggl::CommonMesh::bufferPos2UVReflection;
      }
      ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::attributesReflection(void)::r;
      unk_1EB32B448 = 1;
      a3 = v15;
      a2 = v22;
    }
  }
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 48) = 0;
  *(void *)a1 = &unk_1EF5606B0;
  *(void *)(a1 + 8) = a2;
  *(void *)(a1 + 16) = &unk_1EF5606D0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 56) = &ggl::MeshTyped<ggl::CommonMesh::BufferPos2UV>::typedReflection(void)::r;
  *(void *)(a1 + 64) = 0;
  uint64_t v6 = a1 + 64;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  {
    unsigned int v20 = a3;
    a3 = v20;
    uint64_t v6 = a1 + 64;
    if (v17) {
      operator new();
    }
  }
  uint64_t v7 = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 120) = 0;
  uint64_t v8 = a1 + 120;
  *(void *)(a1 + 96) = 0;
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 88) = v7;
  {
    uint64_t v21 = a3;
    uint64_t v23 = v6;
    uint64_t v8 = a1 + 120;
    a3 = v21;
    int v19 = v18;
    uint64_t v6 = v23;
    if (v19) {
      operator new();
    }
  }
  *(void *)(a1 + 128) = ggl::Allocator::instance(void)::alloc;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 112) = v8;
  *(void *)a1 = &unk_1EF561CA0;
  *(void *)(a1 + 16) = &unk_1EF561CC0;
  uint64_t v9 = a3[1];
  uint64_t v24 = *a3;
  uint64_t v25 = (std::__shared_weak_count *)v9;
  if (v9) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
  }
  std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(v6, &v24, &v26, 1uLL);
  BOOL v10 = v25;
  if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  uint64_t v12 = *a4;
  uint64_t v11 = a4[1];
  if (v11) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 104);
  *(void *)(a1 + 96) = v12;
  *(void *)(a1 + 104) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  *(void *)a1 = &unk_1EF55A210;
  *(void *)(a1 + 16) = &unk_1EF55A230;
  return a1;
}

void std::vector<std::shared_ptr<ggl::VertexData>,geo::StdAllocator<std::shared_ptr<ggl::VertexData>,ggl::Allocator>>::__assign_with_size[abi:nn180100]<std::shared_ptr<ggl::VertexData> const*,std::shared_ptr<ggl::VertexData> const*>(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v6 = a2;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(char **)a1;
  uint64_t v10 = v8 - *(void *)a1;
  if (a4 <= v10 >> 4)
  {
    uint64_t v13 = *(char **)(a1 + 8);
    unint64_t v14 = (v13 - v9) >> 4;
    if (v14 >= a4)
    {
      if (a2 != a3)
      {
        do
        {
          uint64_t v20 = *v6;
          uint64_t v19 = v6[1];
          if (v19) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v19 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v21 = (std::__shared_weak_count *)*((void *)v9 + 1);
          *(void *)uint64_t v9 = v20;
          *((void *)v9 + 1) = v19;
          if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
          v9 += 16;
          v6 += 2;
        }
        while (v6 != a3);
        uint64_t v13 = *(char **)(a1 + 8);
      }
      for (; v13 != v9; v13 -= 16)
      {
        uint64_t v25 = (std::__shared_weak_count *)*((void *)v13 - 1);
        if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
          std::__shared_weak_count::__release_weak(v25);
        }
      }
      *(void *)(a1 + 8) = v9;
    }
    else
    {
      uint64_t v15 = &a2[2 * v14];
      if (v13 != v9)
      {
        do
        {
          uint64_t v17 = *v6;
          uint64_t v16 = v6[1];
          if (v16) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v16 + 8), 1uLL, memory_order_relaxed);
          }
          int v18 = (std::__shared_weak_count *)*((void *)v9 + 1);
          *(void *)uint64_t v9 = v17;
          *((void *)v9 + 1) = v16;
          if (v18 && !atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
            std::__shared_weak_count::__release_weak(v18);
          }
          v6 += 2;
          v9 += 16;
        }
        while (v6 != v15);
        uint64_t v9 = *(char **)(a1 + 8);
      }
      uint64_t v23 = v9;
      if (v15 != a3)
      {
        uint64_t v23 = v9;
        do
        {
          if (v23)
          {
            uint64_t v24 = v15[1];
            *(void *)uint64_t v23 = *v15;
            *((void *)v23 + 1) = v24;
            if (v24) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v24 + 8), 1uLL, memory_order_relaxed);
            }
          }
          v15 += 2;
          v23 += 16;
        }
        while (v15 != a3);
      }
      *(void *)(a1 + 8) = v23;
    }
  }
  else
  {
    if (v9)
    {
      uint64_t v11 = *(char **)(a1 + 8);
      if (v11 == v9)
      {
        uint64_t v22 = *(char **)a1;
      }
      else
      {
        do
        {
          uint64_t v12 = (std::__shared_weak_count *)*((void *)v11 - 1);
          if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
            std::__shared_weak_count::__release_weak(v12);
          }
          v11 -= 16;
        }
        while (v11 != v9);
        uint64_t v22 = *(char **)a1;
        uint64_t v10 = *(void *)(a1 + 16) - *(void *)a1;
      }
      *(void *)(a1 + 8) = v9;
      (*(void (**)(void, char *, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v22, v10);
      uint64_t v8 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    uint64_t v26 = v8 >> 3;
    if (v8 >> 3 <= a4) {
      uint64_t v26 = a4;
    }
    BOOL v27 = (unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0;
    unint64_t v28 = 0xFFFFFFFFFFFFFFFLL;
    if (!v27) {
      unint64_t v28 = v26;
    }
    if (v28 >> 60) {
      abort();
    }
    uint64_t v29 = 2 * v28;
    uint64_t v30 = (uint64_t *)(*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 16 * v28, 8);
    *(void *)a1 = v30;
    *(void *)(a1 + 8) = v30;
    for (*(void *)(a1 + 16) = &v30[v29]; v6 != a3; v30 += 2)
    {
      if (v30)
      {
        uint64_t v31 = v6[1];
        *uint64_t v30 = *v6;
        v30[1] = v31;
        if (v31) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v31 + 8), 1uLL, memory_order_relaxed);
        }
      }
      v6 += 2;
    }
    *(void *)(a1 + 8) = v30;
  }
}

gdc::GlobeTileGrid *gdc::GlobeTileGrid::GlobeTileGrid(gdc::GlobeTileGrid *this, const QuadTile *a2)
{
  *(_WORD *)this = 255;
  *((_DWORD *)this + 1) = 0;
  *((_DWORD *)this + 2) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  int64x2_t v3 = vdupq_n_s64(0x7FEFFFFFFFFFFFFFuLL);
  *(_OWORD *)((char *)this + 72) = xmmword_1A28FC920;
  *(int64x2_t *)((char *)this + 88) = v3;
  int64x2_t v4 = vdupq_n_s64(0xFFEFFFFFFFFFFFFFLL);
  *(int64x2_t *)((char *)this + 104) = v4;
  *((void *)this + 15) = 0xFFEFFFFFFFFFFFFFLL;
  *((_OWORD *)this + 8) = 0u;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_OWORD *)this + 11) = xmmword_1A28FC920;
  *((int64x2_t *)this + 12) = v3;
  *((int64x2_t *)this + 13) = v4;
  *((void *)this + 28) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *((void *)this + 35) = 0x3FF0000000000000;
  *((int64x2_t *)this + 18) = v3;
  *((_OWORD *)this + 19) = xmmword_1A28FC720;
  *((int64x2_t *)this + 20) = v4;
  *((_OWORD *)this + 21) = 0u;
  *((_OWORD *)this + 22) = 0u;
  *((_OWORD *)this + 23) = 0u;
  *((_OWORD *)this + 24) = xmmword_1A28FC920;
  *((int64x2_t *)this + 25) = v3;
  *((int64x2_t *)this + 26) = v4;
  *((void *)this + 54) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)((char *)this + 440) = 0u;
  *(_OWORD *)((char *)this + 456) = 0u;
  *(_OWORD *)((char *)this + 472) = 0u;
  *((void *)this + 61) = 0x3FF0000000000000;
  *((int64x2_t *)this + 31) = v3;
  *((_OWORD *)this + 32) = xmmword_1A28FC720;
  *((int64x2_t *)this + 33) = v4;
  *((_OWORD *)this + 34) = 0u;
  *((_OWORD *)this + 35) = 0u;
  *((_OWORD *)this + 36) = 0u;
  *((_OWORD *)this + 37) = xmmword_1A28FC920;
  *((int64x2_t *)this + 38) = v3;
  *((int64x2_t *)this + 39) = v4;
  *((void *)this + 80) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)((char *)this + 664) = 0u;
  *(_OWORD *)((char *)this + 680) = 0u;
  *(_OWORD *)((char *)this + 648) = 0u;
  *((void *)this + 87) = 0x3FF0000000000000;
  *((int64x2_t *)this + 44) = v3;
  *((_OWORD *)this + 45) = xmmword_1A28FC720;
  *((int64x2_t *)this + 46) = v4;
  *((_OWORD *)this + 47) = 0u;
  *((_OWORD *)this + 48) = 0u;
  *((_OWORD *)this + 49) = 0u;
  *((_OWORD *)this + 50) = xmmword_1A28FC920;
  *((int64x2_t *)this + 51) = v3;
  *((int64x2_t *)this + 52) = v4;
  *((void *)this + 106) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)((char *)this + 872) = 0u;
  *(_OWORD *)((char *)this + 888) = 0u;
  *(_OWORD *)((char *)this + 856) = 0u;
  *((void *)this + 113) = 0x3FF0000000000000;
  *((int64x2_t *)this + 57) = v3;
  *((_OWORD *)this + 58) = xmmword_1A28FC720;
  *((int64x2_t *)this + 59) = v4;
  *((_OWORD *)this + 60) = 0u;
  *((_OWORD *)this + 61) = 0u;
  *((_OWORD *)this + 62) = 0u;
  *((_OWORD *)this + 63) = xmmword_1A28FC920;
  *((int64x2_t *)this + 64) = v3;
  *((int64x2_t *)this + 65) = v4;
  *((void *)this + 132) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)((char *)this + 1096) = 0u;
  *(_OWORD *)((char *)this + 1080) = 0u;
  *(_OWORD *)((char *)this + 1064) = 0u;
  *((void *)this + 139) = 0x3FF0000000000000;
  *((int64x2_t *)this + 70) = v3;
  *((_OWORD *)this + 71) = xmmword_1A28FC720;
  *((int64x2_t *)this + 72) = v4;
  *((_OWORD *)this + 75) = 0u;
  *((_OWORD *)this + 74) = 0u;
  *((_OWORD *)this + 73) = 0u;
  *((_OWORD *)this + 76) = xmmword_1A28FC920;
  *((int64x2_t *)this + 77) = v3;
  *((int64x2_t *)this + 78) = v4;
  *((void *)this + 158) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)((char *)this + 1304) = 0u;
  *(_OWORD *)((char *)this + 1288) = 0u;
  *(_OWORD *)((char *)this + 1272) = 0u;
  *((void *)this + 165) = 0x3FF0000000000000;
  *((int64x2_t *)this + 83) = v3;
  *((_OWORD *)this + 84) = xmmword_1A28FC720;
  *((int64x2_t *)this + 85) = v4;
  *((_OWORD *)this + 88) = 0u;
  *((_OWORD *)this + 87) = 0u;
  *((_OWORD *)this + 86) = 0u;
  *((_OWORD *)this + 89) = xmmword_1A28FC920;
  *((int64x2_t *)this + 90) = v3;
  *((int64x2_t *)this + 91) = v4;
  *((void *)this + 184) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)((char *)this + 1512) = 0u;
  *(_OWORD *)((char *)this + 1496) = 0u;
  *(_OWORD *)((char *)this + 1480) = 0u;
  *((void *)this + 191) = 0x3FF0000000000000;
  *((int64x2_t *)this + 96) = v3;
  *((_OWORD *)this + 97) = xmmword_1A28FC720;
  *((int64x2_t *)this + 98) = v4;
  *((_OWORD *)this + 101) = 0u;
  *((_OWORD *)this + 100) = 0u;
  *((_OWORD *)this + 99) = 0u;
  *((_OWORD *)this + 102) = xmmword_1A28FC920;
  *((int64x2_t *)this + 103) = v3;
  *((int64x2_t *)this + 104) = v4;
  *((void *)this + 210) = 0xFFEFFFFFFFFFFFFFLL;
  *(_OWORD *)((char *)this + 1704) = 0u;
  *(_OWORD *)((char *)this + 1720) = 0u;
  *(_OWORD *)((char *)this + 1688) = 0u;
  *((void *)this + 217) = 0x3FF0000000000000;
  *((_OWORD *)this + 111) = 0u;
  *((_OWORD *)this + 110) = 0u;
  *((_OWORD *)this + 109) = 0u;
  *((void *)this + 224) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1816) = 0u;
  *(_OWORD *)((char *)this + 1832) = 0u;
  *(_OWORD *)((char *)this + 1800) = 0u;
  *((void *)this + 231) = 0x3FF0000000000000;
  *((_OWORD *)this + 118) = 0u;
  *((_OWORD *)this + 117) = 0u;
  *((_OWORD *)this + 116) = 0u;
  *((void *)this + 238) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 1928) = 0u;
  *(_OWORD *)((char *)this + 1944) = 0u;
  *(_OWORD *)((char *)this + 1912) = 0u;
  *((void *)this + 245) = 0x3FF0000000000000;
  *((_OWORD *)this + 125) = 0u;
  *((_OWORD *)this + 124) = 0u;
  *((_OWORD *)this + 123) = 0u;
  *((void *)this + 252) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 2040) = 0u;
  *(_OWORD *)((char *)this + 2056) = 0u;
  *(_OWORD *)((char *)this + 2024) = 0u;
  *((void *)this + 259) = 0x3FF0000000000000;
  *((_OWORD *)this + 132) = 0u;
  *((_OWORD *)this + 131) = 0u;
  *((_OWORD *)this + 130) = 0u;
  *((void *)this + 266) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 2152) = 0u;
  *(_OWORD *)((char *)this + 2168) = 0u;
  *(_OWORD *)((char *)this + 2136) = 0u;
  *((void *)this + 273) = 0x3FF0000000000000;
  *((_OWORD *)this + 139) = 0u;
  *((_OWORD *)this + 138) = 0u;
  *((_OWORD *)this + 137) = 0u;
  *((void *)this + 280) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 2264) = 0u;
  *(_OWORD *)((char *)this + 2280) = 0u;
  *(_OWORD *)((char *)this + 2248) = 0u;
  *((void *)this + 287) = 0x3FF0000000000000;
  *((_OWORD *)this + 146) = 0u;
  *((_OWORD *)this + 145) = 0u;
  *((_OWORD *)this + 144) = 0u;
  *((void *)this + 294) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 2376) = 0u;
  *(_OWORD *)((char *)this + 2392) = 0u;
  *(_OWORD *)((char *)this + 2360) = 0u;
  *((void *)this + 301) = 0x3FF0000000000000;
  *((_OWORD *)this + 153) = 0u;
  *((_OWORD *)this + 152) = 0u;
  *((_OWORD *)this + 151) = 0u;
  *((void *)this + 308) = 0x3FF0000000000000;
  *(_OWORD *)((char *)this + 2488) = 0u;
  *(_OWORD *)((char *)this + 2504) = 0u;
  *(_OWORD *)((char *)this + 2472) = 0u;
  *((void *)this + 315) = 0x3FF0000000000000;
  *((_OWORD *)this + 160) = 0u;
  *((_OWORD *)this + 159) = 0u;
  *((_OWORD *)this + 158) = 0u;
  *((void *)this + 322) = 0x3FF0000000000000;
  *((void *)this + 323) = 0;
  *((_DWORD *)this + 648) = 0;
  long long v5 = *(_OWORD *)&a2->_type;
  *((void *)this + 2) = a2->_hash;
  *(_OWORD *)this = v5;
  __powidf2();
  *(float *)&double v6 = v6 * 0.0000000748596064;
  *((_DWORD *)this + 648) = LODWORD(v6);
  return this;
}

uint64_t gdc::GlobeTileGrid::endBuildingHeightRange(gdc::GlobeTileGrid *this)
{
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t v4 = 0;
  int v44 = 4 * *((_DWORD *)this + 2);
  int v5 = 1 << (*((unsigned char *)this + 1) + 2);
  double v6 = 1.0 / (double)v5;
  uint64_t v7 = *((void *)this + 323);
  int v8 = v5 - 4 * *((_DWORD *)this + 1) - 4;
  uint64_t v9 = 4;
  do
  {
    uint64_t v10 = 0;
    double v11 = (double)(v44 + (int)v4);
    double v12 = v6 * v11;
    double v13 = v6 + v11 * v6;
    uint64_t v45 = v2;
    uint64_t v14 = v3;
    uint64_t v15 = v9;
    do
    {
      double v16 = *(float *)(v7 + v15 - 4);
      double v17 = *(float *)(v7 + v15);
      v54[0] = v12;
      v54[1] = v6 * (double)(v8 + (int)v10);
      v54[2] = v13;
      void v54[3] = v6 + (double)(v8 + (int)v10) * v6;
      gdc::GlobeTileUtils::boundsFromMercatorRect((uint64_t)&v46, v54, v16, v17);
      int v18 = (float64x2_t *)((char *)this + v2);
      double v19 = v49;
      double v20 = v50;
      v18[4].f64[0] = v49;
      v18[4].f64[1] = v20;
      _D2 = v46;
      float64x2_t v22 = v51;
      v18[1].f64[1] = v46;
      float64x2_t v23 = v52;
      v18[5] = v22;
      v18[6] = v23;
      v18[7] = v53;
      v22.f64[0] = -v19;
      uint64_t v24 = (float64x2_t *)((char *)this + v14);
      _Q4 = v48;
      float64x2_t v26 = v47;
      v27.f64[1] = v47.f64[1];
      v27.f64[0] = _D2;
      float64x2_t v28 = vnegq_f64(v48);
      v29.f64[1] = v48.f64[1];
      v29.f64[0] = v19;
      int8x16_t v30 = (int8x16_t)vmulq_f64(v27, v29);
      float64x2_t v31 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v48.f64[0], 0);
      v31.f64[0] = v19;
      float64x2_t v32 = vmlaq_f64(vnegq_f64((float64x2_t)vextq_s8(v30, v30, 8uLL)), v31, v47);
      __asm { FMLA            D17, D2, V4.D[1] }
      float64x2_t v38 = vaddq_f64(v32, v32);
      v18[2] = v47;
      v18[3] = _Q4;
      _D17 = _D17 + _D17;
      v40.f64[0] = v26.f64[0];
      v40.f64[1] = _D17 * v20;
      float64x2_t v41 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v38.f64[0], 0);
      v41.f64[0] = _D17;
      v26.f64[0] = vmuld_lane_f64(v20, v38, 1);
      __asm { FMLA            D0, D17, V4.D[1] }
      v24[107] = v28;
      v24[108].f64[1] = v20;
      ++v10;
      v24[108].f64[0] = v22.f64[0];
      v24[105].f64[1] = _D0;
      v24[106] = vmlaq_f64(vnegq_f64(vaddq_f64(v26, vmlaq_f64(v40, _Q4, v41))), v31, v38);
      v15 += 32;
      v14 += 224;
      v2 += 416;
    }
    while (v10 != 4);
    ++v4;
    v9 += 8;
    v3 += 56;
    uint64_t v2 = v45 + 104;
  }
  while (v4 != 4);
  uint64_t result = MEMORY[0x1A6239250](v7, 0x1000C8000313F17);
  *((void *)this + 323) = 0;
  return result;
}

void __destroy_helper_block_ea8_56c51_ZTSNSt3__110shared_ptrIN3ggl17RenderTransactionEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 64);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void md::RenderQueue<md::StandardCommandBufferIdInfo>::~RenderQueue(void *a1)
{
  *a1 = &unk_1EF535298;
  uint64_t v2 = (void *)a1[3];
  if (v2)
  {
    uint64_t v3 = (void *)a1[4];
    uint64_t v4 = (void *)a1[3];
    if (v3 != v2)
    {
      do
      {
        uint64_t v6 = *--v3;
        uint64_t v5 = v6;
        *uint64_t v3 = 0;
        if (v6) {
          (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
        }
      }
      while (v3 != v2);
      uint64_t v4 = (void *)a1[3];
    }
    a1[4] = v2;
    operator delete(v4);
  }
  uint64_t v7 = (std::__shared_weak_count *)a1[2];
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  JUMPOUT(0x1A6239270);
}

void ggl::CommandBuffer::~CommandBuffer(ggl::CommandBuffer *this)
{
  ggl::CommandBuffer::~CommandBuffer(this);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  void **v6;
  void **v7;
  unint64_t v8;
  void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  std::__shared_weak_count *v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  void **v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  std::__shared_weak_count *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  void **v32;
  void **v33;
  unint64_t v34;
  void **v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  std::__shared_weak_count *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  uint64_t v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;

  *(void *)this = &unk_1EF55AF18;
  uint64_t v2 = *((void *)this + 3);
  if (v2)
  {
    uint64_t v4 = *(void *)(v2 + 104);
    uint64_t v3 = *(void *)(v2 + 112);
    if (v3 != v4)
    {
      uint64_t v5 = 0;
      do
      {
        if (*(ggl::CommandBuffer **)(v4 + 8 * v5) == this)
        {
          *(void *)(v4 + 8 * v5) = 0;
          uint64_t v4 = *(void *)(v2 + 104);
          uint64_t v3 = *(void *)(v2 + 112);
        }
        ++v5;
      }
      while (v5 < (v3 - v4) >> 3);
    }
  }
  uint64_t v6 = (void **)*((void *)this + 40);
  uint64_t v7 = (void **)*((void *)this + 41);
  if (v7 == v6)
  {
    double v17 = (uint64_t *)((char *)this + 344);
    uint64_t v7 = (void **)*((void *)this + 40);
    uint64_t v21 = (void *)((char *)this + 352);
  }
  else
  {
    int v8 = *((void *)this + 43);
    uint64_t v9 = &v6[v8 >> 7];
    uint64_t v10 = (uint64_t)*v9;
    double v11 = (uint64_t)*v9 + 32 * (v8 & 0x7F);
    double v12 = *(uint64_t *)((char *)v6 + (((*((void *)this + 44) + v8) >> 4) & 0xFFFFFFFFFFFFFF8))
        + 32 * ((*((void *)this + 44) + v8) & 0x7F);
    if (v11 != v12)
    {
      do
      {
        double v13 = *(void *)(v11 + 16);
        if (v13)
        {
          *(unsigned char *)(v13 + 136) = 2;
          uint64_t v14 = *(void *)(v13 + 120);
          if (v14)
          {
            uint64_t v15 = *(std::__shared_weak_count **)(v14 + 24);
            *(void *)(v14 + 16) = 0;
            *(void *)(v14 + 24) = 0;
            if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
              std::__shared_weak_count::__release_weak(v15);
            }
            *(void *)(v13 + 120) = 0;
            uint64_t v10 = (uint64_t)*v9;
          }
        }
        v11 += 32;
        if (v11 - v10 == 4096)
        {
          double v16 = (uint64_t)v9[1];
          ++v9;
          uint64_t v10 = v16;
          double v11 = v16;
        }
      }
      while (v11 != v12);
      uint64_t v6 = (void **)*((void *)this + 40);
      uint64_t v7 = (void **)*((void *)this + 41);
    }
    double v17 = (uint64_t *)((char *)this + 344);
    if (v7 == v6)
    {
      uint64_t v6 = v7;
      uint64_t v21 = (void *)((char *)this + 352);
    }
    else
    {
      int v18 = *((void *)this + 43);
      double v19 = &v6[v18 >> 7];
      double v20 = (uint64_t)*v19 + 32 * (v18 & 0x7F);
      uint64_t v21 = (void *)((char *)this + 352);
      float64x2_t v22 = *(uint64_t *)((char *)v6 + (((*((void *)this + 44) + v18) >> 4) & 0xFFFFFFFFFFFFFF8))
          + 32 * ((*((void *)this + 44) + v18) & 0x7F);
      if (v20 != v22)
      {
        do
        {
          float64x2_t v23 = *(std::__shared_weak_count **)(v20 + 24);
          if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
            std::__shared_weak_count::__release_weak(v23);
          }
          v20 += 32;
          if (v20 - (void)*v19 == 4096)
          {
            uint64_t v24 = (uint64_t)v19[1];
            ++v19;
            double v20 = v24;
          }
        }
        while (v20 != v22);
        uint64_t v6 = (void **)*((void *)this + 40);
        uint64_t v7 = (void **)*((void *)this + 41);
      }
    }
  }
  *uint64_t v21 = 0;
  uint64_t v25 = (char *)v7 - (char *)v6;
  if ((unint64_t)((char *)v7 - (char *)v6) >= 0x11)
  {
    do
    {
      operator delete(*v6);
      uint64_t v7 = (void **)*((void *)this + 41);
      uint64_t v6 = (void **)(*((void *)this + 40) + 8);
      *((void *)this + 40) = v6;
      uint64_t v25 = (char *)v7 - (char *)v6;
    }
    while ((unint64_t)((char *)v7 - (char *)v6) > 0x10);
  }
  float64x2_t v26 = v25 >> 3;
  if (v26 == 1)
  {
    float64x2_t v27 = 64;
    goto LABEL_38;
  }
  if (v26 == 2)
  {
    float64x2_t v27 = 128;
LABEL_38:
    *double v17 = v27;
  }
  if (v6 != v7)
  {
    do
    {
      float64x2_t v28 = *v6++;
      operator delete(v28);
    }
    while (v6 != v7);
    int8x16_t v30 = *((void *)this + 40);
    float64x2_t v29 = *((void *)this + 41);
    if (v29 != v30) {
      *((void *)this + 41) = v29 + ((v30 - v29 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  float64x2_t v31 = (void *)*((void *)this + 39);
  if (v31) {
    operator delete(v31);
  }
  float64x2_t v32 = (void **)*((void *)this + 34);
  uint64_t v33 = (void **)*((void *)this + 35);
  if (v33 == v32)
  {
    unsigned int v37 = (void *)((char *)this + 304);
    uint64_t v33 = (void **)*((void *)this + 34);
  }
  else
  {
    unint64_t v34 = *((void *)this + 37);
    unsigned int v35 = &v32[v34 >> 8];
    uint64_t v36 = (uint64_t)*v35 + 16 * v34;
    unsigned int v37 = (void *)((char *)this + 304);
    float64x2_t v38 = *(uint64_t *)((char *)v32 + (((*((void *)this + 38) + v34) >> 5) & 0x7FFFFFFFFFFFFF8))
        + 16 * (*((unsigned char *)this + 304) + v34);
    if (v36 != v38)
    {
      do
      {
        uint64_t v39 = *(std::__shared_weak_count **)(v36 + 8);
        if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v39);
        }
        v36 += 16;
        if (v36 - (void)*v35 == 4096)
        {
          float64x2_t v40 = (uint64_t)v35[1];
          ++v35;
          uint64_t v36 = v40;
        }
      }
      while (v36 != v38);
      float64x2_t v32 = (void **)*((void *)this + 34);
      uint64_t v33 = (void **)*((void *)this + 35);
    }
  }
  void *v37 = 0;
  float64x2_t v41 = (char *)v33 - (char *)v32;
  if ((unint64_t)((char *)v33 - (char *)v32) >= 0x11)
  {
    do
    {
      operator delete(*v32);
      uint64_t v33 = (void **)*((void *)this + 35);
      float64x2_t v32 = (void **)(*((void *)this + 34) + 8);
      *((void *)this + 34) = v32;
      float64x2_t v41 = (char *)v33 - (char *)v32;
    }
    while ((unint64_t)((char *)v33 - (char *)v32) > 0x10);
  }
  float v42 = v41 >> 3;
  if (v42 == 1)
  {
    unint64_t v43 = 128;
  }
  else
  {
    if (v42 != 2) {
      goto LABEL_63;
    }
    unint64_t v43 = 256;
  }
  *((void *)this + 37) = v43;
LABEL_63:
  if (v32 != v33)
  {
    do
    {
      int v44 = *v32++;
      operator delete(v44);
    }
    while (v32 != v33);
    double v46 = *((void *)this + 34);
    uint64_t v45 = *((void *)this + 35);
    if (v45 != v46) {
      *((void *)this + 35) = v45 + ((v46 - v45 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  float64x2_t v47 = (void *)*((void *)this + 33);
  if (v47) {
    operator delete(v47);
  }
  float64x2_t v48 = (void *)*((void *)this + 29);
  if (v48)
  {
    double v49 = (void *)*((void *)this + 30);
    double v50 = *((void *)this + 29);
    if (v49 != v48)
    {
      float64x2_t v51 = v49 - 4;
      float64x2_t v52 = v49 - 4;
      do
      {
        uint64_t v54 = (void *)v52[3];
        if (v52 == v54)
        {
          (*(void (**)(void *))(*v52 + 32))(v52);
        }
        else if (v54)
        {
          (*(void (**)(void *, uint64_t))(*v54 + 40))(v54, v50);
        }
        float64x2_t v53 = v52 - 4;
        v52 -= 8;
        v51 -= 8;
      }
      while (v53 != v48);
      double v50 = *((void *)this + 29);
    }
    *((void *)this + 30) = v48;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 32) + 40))(*((void *)this + 32), v50, *((void *)this + 31) - v50);
  }
  float v55 = (void *)*((void *)this + 25);
  if (!v55) {
    goto LABEL_94;
  }
  uint64_t v56 = (void *)*((void *)this + 26);
  float v57 = *((void *)this + 25);
  if (v56 == v55) {
    goto LABEL_93;
  }
  uint64_t v58 = v56 - 4;
  uint64_t v59 = v56 - 4;
  do
  {
    float v61 = (void *)v59[3];
    if (v59 == v61)
    {
      (*(void (**)(void *, uint64_t))(*v59 + 32))(v59, v57);
      if (*((unsigned char *)v59 - 28)) {
        goto LABEL_87;
      }
    }
    else
    {
      if (v61) {
        (*(void (**)(void *, uint64_t))(*v61 + 40))(v61, v57);
      }
      if (*((unsigned char *)v59 - 28)) {
LABEL_87:
      }
        *((unsigned char *)v59 - 28) = 0;
    }
    if (*((unsigned char *)v59 - 32)) {
      *((unsigned char *)v59 - 32) = 0;
    }
    unint64_t v60 = v59 - 6;
    v59 -= 10;
    v58 -= 10;
  }
  while (v60 != v55);
  float v57 = *((void *)this + 25);
LABEL_93:
  *((void *)this + 26) = v55;
  (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 28) + 40))(*((void *)this + 28), v57, *((void *)this + 27) - v57);
LABEL_94:
  float v62 = *((void *)this + 21);
  if (v62)
  {
    *((void *)this + 22) = v62;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 24) + 40))(*((void *)this + 24), v62, *((void *)this + 23) - v62);
  }
  uint64_t v63 = *((void *)this + 17);
  if (v63)
  {
    *((void *)this + 18) = v63;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 20) + 40))(*((void *)this + 20), v63, *((void *)this + 19) - v63);
  }
  unint64_t v64 = *((void *)this + 13);
  if (v64)
  {
    *((void *)this + 14) = v64;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 16) + 40))(*((void *)this + 16), v64, *((void *)this + 15) - v64);
  }
  float v65 = *((void *)this + 9);
  if (v65)
  {
    *((void *)this + 10) = v65;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 12) + 40))(*((void *)this + 12), v65, *((void *)this + 11) - v65);
  }
  float v66 = *((void *)this + 5);
  if (v66)
  {
    *((void *)this + 6) = v66;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 8) + 40))(*((void *)this + 8), v66, *((void *)this + 7) - v66);
  }
}

void std::__shared_ptr_emplace<ggl::RenderQueue>::__on_zero_shared(uint64_t a1)
{
}

void ggl::RenderQueue::~RenderQueue(ggl::RenderQueue *this)
{
  uint64_t v2 = *((void *)this + 13);
  uint64_t v3 = *((void *)this + 14);
  while (v2 != v3)
  {
    if (*(void *)v2) {
      *(void *)(*(void *)v2 + 24) = 0;
    }
    v2 += 8;
  }
  if ((*((char *)this + 311) & 0x80000000) == 0)
  {
    uint64_t v4 = *((void *)this + 31);
    if (!v4) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  operator delete(*((void **)this + 36));
  uint64_t v4 = *((void *)this + 31);
  if (v4)
  {
LABEL_8:
    *((void *)this + 32) = v4;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 34) + 40))(*((void *)this + 34), v4, *((void *)this + 33) - v4);
  }
LABEL_9:
  uint64_t v5 = *((void *)this + 27);
  if (v5)
  {
    *((void *)this + 28) = v5;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 30) + 40))(*((void *)this + 30), v5, *((void *)this + 29) - v5);
  }
  uint64_t v6 = *((void *)this + 23);
  if (v6)
  {
    *((void *)this + 24) = v6;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 26) + 40))(*((void *)this + 26), v6, *((void *)this + 25) - v6);
  }
  uint64_t v7 = *((void *)this + 19);
  if (v7)
  {
    *((void *)this + 20) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 22) + 40))(*((void *)this + 22), v7, *((void *)this + 21) - v7);
  }
  int v8 = (std::__shared_weak_count *)*((void *)this + 18);
  if (!v8 || atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    uint64_t v9 = *((void *)this + 13);
    if (!v9) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
  std::__shared_weak_count::__release_weak(v8);
  uint64_t v9 = *((void *)this + 13);
  if (v9)
  {
LABEL_18:
    *((void *)this + 14) = v9;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 16) + 40))(*((void *)this + 16), v9, *((void *)this + 15) - v9);
  }
LABEL_19:
  uint64_t v10 = *((void *)this + 9);
  if (v10)
  {
    *((void *)this + 10) = v10;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 12) + 40))(*((void *)this + 12), v10, *((void *)this + 11) - v10);
  }
  if (*((unsigned char *)this + 48)) {
    *((unsigned char *)this + 48) = 0;
  }
}

void std::__shared_ptr_emplace<ggl::RenderTransaction>::__on_zero_shared(void *a1)
{
  uint64_t v2 = a1 + 11;
  uint64_t v3 = (void *)a1[14];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  uint64_t v4 = (void *)a1[10];
  if (v4 == a1 + 7)
  {
    (*(void (**)(void *))(a1[7] + 32))(a1 + 7);
    uint64_t v5 = (std::__shared_weak_count *)a1[6];
    if (!v5) {
      return;
    }
    goto LABEL_11;
  }
  if (v4) {
    (*(void (**)(void *))(*v4 + 40))(v4);
  }
  uint64_t v5 = (std::__shared_weak_count *)a1[6];
  if (v5)
  {
LABEL_11:
    if (!atomic_fetch_add(&v5->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v5->__on_zero_shared)(v5);
      std::__shared_weak_count::__release_weak(v5);
    }
  }
}

uint64_t esl::QuartzImage::hasAlphaChannel(CGImageRef *this)
{
  uint64_t result = (*((uint64_t (**)(CGImageRef *))*this + 5))(this);
  if (result) {
    return CGImageGetAlphaInfo(this[2]) != kCGImageAlphaNone;
  }
  return result;
}

void grl::codec::IconDataPack::imageForID(grl::codec::IconDataPack *this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  *(void *)a3 = 0;
  *(void *)(a3 + 32) = 0;
  uint64_t v3 = (char *)*((void *)this + 6);
  if (v3)
  {
    uint64_t v5 = (void *)(a3 + 8);
    uint64_t v6 = (char *)this + 48;
    do
    {
      unsigned int v7 = *((_DWORD *)v3 + 7);
      BOOL v8 = v7 >= a2;
      if (v7 >= a2) {
        uint64_t v9 = (char **)v3;
      }
      else {
        uint64_t v9 = (char **)(v3 + 8);
      }
      if (v8) {
        uint64_t v6 = v3;
      }
      uint64_t v3 = *v9;
    }
    while (*v9);
    if (v6 != (char *)this + 48 && *((_DWORD *)v6 + 7) <= a2)
    {
      *(_DWORD *)a3 = *((_DWORD *)v6 + 11);
      *(_DWORD *)(a3 + 4) = *((_DWORD *)v6 + 12);
      uint64_t v10 = (std::mutex *)((char *)this + 336);
      std::mutex::lock((std::mutex *)((char *)this + 336));
      double v11 = (void *)geo::LRUPolicy<unsigned short,std::shared_ptr<esl::QuartzImage>,std::hash<unsigned short>>::get((uint64_t)this + 120, (void *)this + 10, (unsigned __int16 *)v6 + 16);
      if ((void *)((char *)this + 120) == v11
        || (double v12 = v11, (v13 = v11[3]) == 0)
        || !(*(unsigned int (**)(uint64_t))(*(void *)v13 + 40))(v13))
      {
        uint64_t v15 = 0;
LABEL_20:
        double v16 = (char **)*((void *)this + 20);
        if (v16)
        {
          unsigned int v17 = *((unsigned __int16 *)v6 + 16);
          int v18 = (char **)((char *)this + 160);
          do
          {
            unsigned int v19 = *((unsigned __int16 *)v16 + 14);
            BOOL v20 = v19 >= v17;
            if (v19 >= v17) {
              uint64_t v21 = v16;
            }
            else {
              uint64_t v21 = v16 + 1;
            }
            if (v20) {
              int v18 = v16;
            }
            double v16 = (char **)*v21;
          }
          while (*v21);
          if (v18 != (char **)((char *)this + 160) && v17 >= *((unsigned __int16 *)v18 + 14))
          {
            uint64_t v23 = *((unsigned int *)v18 + 8);
            size_t v22 = *((unsigned int *)v18 + 9);
            if (v22)
            {
              uint64_t v24 = operator new(*((unsigned int *)v18 + 9));
              bzero(v24, v22);
            }
            uint64_t v40 = *((void *)this + 41);
            long long v25 = *(_OWORD *)((char *)this + 216);
            long long v26 = *(_OWORD *)((char *)this + 248);
            long long v34 = *(_OWORD *)((char *)this + 232);
            long long v35 = v26;
            *(_OWORD *)uint64_t v33 = *(_OWORD *)((char *)this + 200);
            *(_OWORD *)&v33[16] = v25;
            long long v27 = *(_OWORD *)((char *)this + 312);
            long long v38 = *(_OWORD *)((char *)this + 296);
            long long v39 = v27;
            long long v28 = *(_OWORD *)((char *)this + 280);
            long long v36 = *(_OWORD *)((char *)this + 264);
            long long v37 = v28;
            v40 += v23;
            std::istream::seekg();
            std::istream::read();
            operator new();
          }
        }
        std::mutex::unlock((std::mutex *)((char *)this + 336));
        if (v15)
        {
          std::__shared_weak_count::__release_shared[abi:ne180100](v15);
        }
        return;
      }
      uint64_t v14 = v12[3];
      uint64_t v15 = (std::__shared_weak_count *)v12[4];
      if (v15) {
        atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      ++*((_DWORD *)this + 36);
      if (!v14) {
        goto LABEL_20;
      }
      if (!*((void *)this + 22))
      {
        float64x2_t v29 = (std::__shared_weak_count *)*((void *)this + 24);
        *((void *)this + 23) = 0;
        *((void *)this + 24) = 0;
        if (v29) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v29);
        }
      }
      std::mutex::unlock(v10);
      if ((*(unsigned int (**)(uint64_t))(*(void *)v14 + 40))(v14))
      {
        float32x2_t v30 = vadd_f32(*(float32x2_t *)(v6 + 36), *(float32x2_t *)(v6 + 44));
        v32[0] = *(void *)(v6 + 36);
        v32[1] = v30;
        (*(void (**)(unsigned char *__return_ptr, uint64_t, void *))(*(void *)v14 + 56))(v33, v14, v32);
        long long v31 = *(_OWORD *)v33;
        if (*(void *)&v33[8])
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v33[8] + 8), 1uLL, memory_order_relaxed);
          if (*(void *)&v33[8]) {
            std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v33[8]);
          }
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v31 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)uint64_t v33 = &unk_1EF57CCF0;
        *(_OWORD *)&v33[8] = v31;
        *(void *)&v33[24] = v33;
        std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::swap[abi:nn180100](v33, v5);
        std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](v33);
        if (*((void *)&v31 + 1)) {
          std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v31 + 1));
        }
      }
      if (v15) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v15);
      }
    }
  }
}

BOOL esl::QuartzImage::isValid(esl::QuartzImage *this)
{
  return *((void *)this + 2) != 0;
}

grl *std::__function::__func<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconData const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::ImageData>,grl::Allocator>> const&)::$_0,std::allocator<grl::IconRenderer::setupImageLayerRenderer(grl::codec::IconData const&,grl::IconModifiers const&,std::map<unsigned short,grl::ImageData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::ImageData>,grl::Allocator>> const&)::$_0>,void ()(unsigned short,grl::codec::ImageLayerData const&)>::operator()(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  v67[4] = *MEMORY[0x1E4F143B8];
  unsigned int v5 = *a2;
  uint64_t v33 = 0;
  uint64_t v34 = 0;
  uint64_t v6 = *(void *)(a3 + 24);
  uint64_t v35 = 0;
  uint64_t v36 = v6;
  uint64_t result = (grl *)std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__init_with_size[abi:nn180100]<grl::LayerStyle*,grl::LayerStyle*>((uint64_t)&v33, *(unsigned char **)a3, *(unsigned char **)(a3 + 8), *(void *)(a3 + 8) - *(void *)a3);
  __int16 v37 = *(_WORD *)(a3 + 32);
  int v38 = *(_DWORD *)(a3 + 34);
  long long v39 = *(_OWORD *)(a3 + 38);
  __int16 v40 = *(_WORD *)(a3 + 54);
  int v41 = *(_DWORD *)(a3 + 56);
  int v42 = *(_DWORD *)(a3 + 60);
  int v8 = *(_DWORD *)(a3 + 68);
  int v43 = *(_DWORD *)(a3 + 64);
  int v44 = v8;
  char v45 = *(unsigned char *)(a3 + 72);
  int v46 = *(_DWORD *)(a3 + 73);
  long long v9 = *(_OWORD *)(a3 + 96);
  *(_OWORD *)float64x2_t v47 = *(_OWORD *)(a3 + 80);
  *(_OWORD *)&v47[16] = v9;
  uint64_t v48 = *(void *)(a3 + 112);
  int v49 = *(_DWORD *)(a3 + 120);
  *(_OWORD *)&v50[10] = *(_OWORD *)(a3 + 134);
  *(_OWORD *)double v50 = *(_OWORD *)(a3 + 124);
  if (!v50[24]) {
    goto LABEL_66;
  }
  uint64_t v10 = *(void *)(a1 + 8);
  uint64_t v11 = *(void *)(a1 + 16);
  uint64_t v14 = *(void *)(v10 + 8);
  uint64_t v12 = v10 + 8;
  uint64_t v13 = v14;
  if (!v14) {
    goto LABEL_13;
  }
  uint64_t v15 = v12;
  do
  {
    unsigned int v16 = *(unsigned __int16 *)(v13 + 32);
    BOOL v17 = v16 >= v5;
    if (v16 >= v5) {
      int v18 = (uint64_t *)v13;
    }
    else {
      int v18 = (uint64_t *)(v13 + 8);
    }
    if (v17) {
      uint64_t v15 = v13;
    }
    uint64_t v13 = *v18;
  }
  while (*v18);
  if (v15 != v12 && *(unsigned __int16 *)(v15 + 32) <= v5)
  {
    uint64_t v59 = 0;
    uint64_t v61 = 0;
    if (*(void *)(v15 + 72))
    {
      uint64_t v59 = *(void *)(v15 + 40);
      long long v26 = (void *)std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::__value_func[abi:nn180100]((uint64_t)buf, v15 + 48);
      std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::swap[abi:nn180100](v26, v60);
      std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](buf);
      if (v5) {
        goto LABEL_21;
      }
      goto LABEL_36;
    }
  }
  else
  {
LABEL_13:
    uint64_t v59 = 0;
    uint64_t v61 = 0;
  }
  if (*(unsigned char *)(v11 + 280))
  {
    grl::createPlaceholderGlyph(result);
    if (!v51)
    {
      if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
      }
      long long v25 = GEOGetGeoResourceLibRendererLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        *(void *)&uint8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconRenderer.cpp";
        *(_WORD *)&unsigned char buf[22] = 1024;
        LODWORD(v63) = 394;
        _os_log_impl(&dword_1A1780000, v25, OS_LOG_TYPE_ERROR, "Failed to generate placeholder glyph.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
      }
      if (v52) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v52);
      }
      goto LABEL_65;
    }
    float v19 = (float)(*((unsigned int (**)(void (**)(void, void)))*v51 + 3))(v51);
    unsigned int v20 = (*((uint64_t (**)(void (**)(void, void)))*v51 + 4))(v51);
    *(float *)&uint64_t v59 = v19;
    *((float *)&v59 + 1) = (float)v20;
    size_t v22 = v51;
    uint64_t v21 = v52;
    if (v52) {
      atomic_fetch_add_explicit(&v52->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    *(void *)float buf = &unk_1EF57EEB0;
    *(void *)&buf[8] = v22;
    *(void *)&buf[16] = v21;
    uint64_t v63 = buf;
    std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::swap[abi:nn180100](buf, v60);
    std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](buf);
    if (v52) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v52);
    }
    if (v5)
    {
LABEL_21:
      if (**(unsigned char **)(a1 + 40))
      {
        uint64_t v23 = *(void *)(a1 + 24);
        if (!*(unsigned char *)v23 || *(void *)(v23 + 4) != v59)
        {
          if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
            dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
          }
          uint64_t v24 = GEOGetGeoResourceLibRendererLog::log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)float buf = 0;
            _os_log_impl(&dword_1A1780000, v24, OS_LOG_TYPE_ERROR, "All image layers must be the same size in a stretched icon.", buf, 2u);
          }
          goto LABEL_65;
        }
      }
LABEL_41:
      std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::__value_func[abi:nn180100]((uint64_t)v57, *(void *)(a1 + 48) + 168);
      if (v47[20] == 1 && v58)
      {
        std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::__value_func[abi:nn180100]((uint64_t)&v51, (uint64_t)v57);
        uint64_t v54 = v59;
        std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::__value_func[abi:nn180100]((uint64_t)v55, (uint64_t)v60);
        if (v53)
        {
          if (v53 == &v51)
          {
            uint64_t v63 = buf;
            ((void (**)(void, unsigned char *))v51)[3](&v51, buf);
          }
          else
          {
            uint64_t v63 = v53;
            float64x2_t v53 = 0;
          }
        }
        else
        {
          uint64_t v63 = 0;
        }
        uint64_t v64 = v54;
        if (v56)
        {
          if (v56 == v55)
          {
            float v66 = v65;
            (*(void (**)(void *, void *))(v55[0] + 24))(v55, v65);
          }
          else
          {
            float v66 = v56;
            uint64_t v56 = 0;
          }
        }
        else
        {
          float v66 = 0;
        }
        float32x2_t v30 = operator new(0x50uLL);
        long long v31 = v30;
        *float32x2_t v30 = &unk_1EF57EE68;
        if (v63)
        {
          if (v63 == buf)
          {
            v30[4] = v30 + 1;
            (*(void (**)(unsigned char *))(*(void *)buf + 24))(buf);
          }
          else
          {
            v30[4] = v63;
            uint64_t v63 = 0;
          }
        }
        else
        {
          v30[4] = 0;
        }
        float64x2_t v32 = v66;
        v31[5] = v64;
        if (v32)
        {
          if (v32 == v65)
          {
            v31[9] = v31 + 6;
            (*(void (**)(void *))(v65[0] + 24))(v65);
          }
          else
          {
            v31[9] = v32;
            float v66 = 0;
          }
        }
        else
        {
          v31[9] = 0;
        }
        v67[3] = v31;
        std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::swap[abi:nn180100](v67, v60);
        std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](v67);
        std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](v65);
        std::function<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~function(buf);
        std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](v55);
        std::function<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~function(&v51);
      }
      operator new();
    }
LABEL_36:
    uint64_t v27 = *(void *)(a1 + 24);
    if (!*(unsigned char *)v27) {
      *(unsigned char *)uint64_t v27 = 1;
    }
    *(void *)(v27 + 4) = v59;
    uint64_t v28 = *(void *)(a1 + 32);
    uint64_t v29 = *(void *)&v47[12];
    if (!*(unsigned char *)v28) {
      *(unsigned char *)uint64_t v28 = 1;
    }
    *(void *)(v28 + 4) = v29;
    **(unsigned char **)(a1 + 40) = v48 == 1;
    goto LABEL_41;
  }
LABEL_65:
  uint64_t result = (grl *)std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](v60);
LABEL_66:
  if (v33)
  {
    uint64_t v34 = v33;
    return (grl *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v36 + 40))(v36, v33, v35 - v33);
  }
  return result;
}

void *std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void std::__function::__func<grl::codec::IconDataPack::imageForID(unsigned int)::$_0,std::allocator<grl::codec::IconDataPack::imageForID(unsigned int)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::destroy(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 16);
  if (v1) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v1);
  }
}

uint64_t std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__init_with_size[abi:nn180100]<grl::LayerStyle*,grl::LayerStyle*>(uint64_t result, unsigned char *a2, unsigned char *a3, uint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__vallocate[abi:nn180100](result, a4);
    unsigned int v7 = *(unsigned char **)(v6 + 8);
    while (a2 != a3)
    {
      if (v7) {
        unsigned char *v7 = *a2;
      }
      ++a2;
      ++v7;
    }
    *(void *)(v6 + 8) = v7;
  }
  return result;
}

uint64_t std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__vallocate[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2 < 0) {
    abort();
  }
  uint64_t result = (*(uint64_t (**)(void))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24));
  *(void *)a1 = result;
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 16) = result + a2;
  return result;
}

void *std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    unsigned int v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        void v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        void v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      void v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

uint64_t std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

uint64_t std::__function::__func<grl::codec::IconDataPack::imageForID(unsigned int)::$_0,std::allocator<grl::codec::IconDataPack::imageForID(unsigned int)::$_0>,std::shared_ptr<esl::QuartzImage> ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v3 = *(void *)(result + 8);
  uint64_t v2 = *(void *)(result + 16);
  *a2 = &unk_1EF57CCF0;
  a2[1] = v3;
  a2[2] = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerRenderer>>,std::__map_value_compare<grl::IconLayerMapKey,std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerRenderer>>,grl::IconLayerMapKey,false>,geo::StdAllocator<std::__value_type<grl::IconLayerMapKey,std::unique_ptr<grl::LayerRenderer>>,grl::Allocator>>::__emplace_unique_key_args<grl::IconLayerMapKey,std::piecewise_construct_t const&,std::tuple<grl::IconLayerMapKey&&>,std::tuple<>>(uint64_t **a1, __int16 *a2, _DWORD **a3)
{
  uint64_t v6 = (uint64_t *)(a1 + 1);
  uint64_t v5 = (uint64_t)a1[1];
  if (!v5)
  {
    int v8 = (uint64_t *)(a1 + 1);
LABEL_10:
    uint64_t v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*a1[2] + 16))(a1[2], 48, 8);
    uint64_t v10 = (uint64_t *)v11;
    uint64_t v12 = *a3;
    *(_DWORD *)(v11 + 32) = **a3;
    *(unsigned char *)(v11 + 36) = 0;
    if (*((unsigned char *)v12 + 4))
    {
      *(unsigned char *)(v11 + 37) = *((unsigned char *)v12 + 5);
      *(unsigned char *)(v11 + 36) = 1;
    }
    *(void *)(v11 + 40) = 0;
    *(void *)uint64_t v11 = 0;
    *(void *)(v11 + 8) = 0;
    *(void *)(v11 + 16) = v8;
    uint64_t *v6 = v11;
    uint64_t v13 = (uint64_t *)**a1;
    uint64_t v14 = (uint64_t *)v11;
    if (v13)
    {
      *a1 = v13;
      uint64_t v14 = (uint64_t *)*v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v14);
    a1[3] = (uint64_t *)((char *)a1[3] + 1);
    return v10;
  }
  while (1)
  {
    while (1)
    {
      int v8 = (uint64_t *)v5;
      long long v9 = (__int16 *)(v5 + 32);
      if (!grl::IconLayerMapKey::operator()((uint64_t)(a1 + 4), a2, (__int16 *)(v5 + 32))) {
        break;
      }
      uint64_t v5 = *v8;
      uint64_t v6 = v8;
      if (!*v8) {
        goto LABEL_10;
      }
    }
    if (!grl::IconLayerMapKey::operator()((uint64_t)(a1 + 4), v9, a2)) {
      break;
    }
    uint64_t v6 = v8 + 1;
    uint64_t v5 = v8[1];
    if (!v5) {
      goto LABEL_10;
    }
  }
  uint64_t v10 = (uint64_t *)*v6;
  if (!*v6) {
    goto LABEL_10;
  }
  return v10;
}

void *std::function<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~function(void *a1)
{
  uint64_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

uint64_t std::__function::__value_func<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::__value_func[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 24);
  if (v3)
  {
    if (v3 == a2)
    {
      *(void *)(a1 + 24) = a1;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      *(void *)(a1 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    *(void *)(a1 + 24) = 0;
  }
  return a1;
}

void grl::IconManager::image(void *a1, uint64_t a2, uint64_t a3, const grl::IconModifiers *a4, unsigned int a5, uint64_t **a6, uint64_t a7, uint64_t a8, float a9)
{
  uint64_t v275 = *MEMORY[0x1E4F143B8];
  long long v252 = 0uLL;
  v251[1] = &unk_1EF5672F0;
  unsigned __int8 v253 = 4;
  unsigned int v11 = *(_DWORD *)(a3 + 16);
  unsigned int v267 = a5;
  unsigned int v268 = v11;
  float v12 = ceilf(a9);
  std::string::basic_string[abi:nn180100]<0>(&v263, "Default");
  *(float *)&uint64_t v266 = v12;
  grl::IconManager::retrieveResourcePack(buf, a2, (float *)&v263, 2);
  uint64_t v14 = *(grl::codec::IconMapPack **)buf;
  uint64_t v13 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8])
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:ne180100](v13);
  }
  uint64_t v248 = a2;
  if (!v14) {
    grl::IconManager::loadGlobalResourcePack((uint64_t)buf, a2);
  }
  uint64_t v15 = (grl::Allocator *)grl::codec::IconMapPack::regionsForIconID(v14, &v268, &v259);
  float v240 = v13;
  if (a5 == 0xFFFF)
  {
    long long v249 = 0uLL;
    float v250 = 0;
    unsigned int v16 = (grl::Allocator *)grl::Allocator::instance(v15);
    v251[0] = v16;
    unint64_t v17 = (char *)v260 - (char *)v259;
    uint64_t v18 = v260 - v259;
    if (v18)
    {
      if (v17 >= 0x1FFFFFFFFFFFFFFDLL) {
        goto LABEL_398;
      }
      uint64_t v19 = *((void *)&v249 + 1) - v249;
      unint64_t v274 = v251;
      uint64_t v20 = (*(uint64_t (**)(grl::Allocator *, unint64_t, uint64_t))(*(void *)v16 + 16))(v16, 8 * v17, 8);
      uint64_t v21 = *((void *)&v249 + 1);
      uint64_t v22 = v249;
      if (*((void *)&v249 + 1) == (void)v249)
      {
        int64x2_t v25 = vdupq_n_s64(*((unint64_t *)&v249 + 1));
        uint64_t v23 = v20 + v19;
      }
      else
      {
        uint64_t v23 = v20 + v19;
        do
        {
          long long v24 = *(_OWORD *)(v21 - 32);
          *(void *)(v23 - 16) = *(void *)(v21 - 16);
          *(_OWORD *)(v23 - 32) = v24;
          *(void *)(v21 - 24) = 0;
          *(void *)(v21 - 16) = 0;
          *(void *)(v21 - 32) = 0;
          *(_DWORD *)(v23 - 8) = *(_DWORD *)(v21 - 8);
          v23 -= 32;
          v21 -= 32;
        }
        while (v21 != v22);
        int64x2_t v25 = (int64x2_t)v249;
      }
      *(void *)&long long v249 = v23;
      *((void *)&v249 + 1) = v20 + v19;
      *(int64x2_t *)&buf[8] = v25;
      uint64_t v92 = v250;
      float v250 = (unsigned char *)(v20 + 32 * v18);
      unint64_t v273 = v92;
      *(void *)float buf = v25.i64[0];
      unsigned int v16 = (grl::Allocator *)std::__split_buffer<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
    }
    int64x2_t v256 = 0uLL;
    float v257 = 0;
    uint64_t v258 = grl::Allocator::instance(v16);
    int v94 = v260;
    unint64_t v93 = (unsigned int *)v259;
    if (v259 != v260)
    {
      uint64_t v95 = (void *)((char *)v14 + 272);
      float v244 = (void *)((char *)v14 + 272);
      float v239 = v14;
      do
      {
        grl::codec::IconMapPack::regionNameForID(v14, v93, &v271);
        int64_t size = HIBYTE(v271.__r_.__value_.__r.__words[2]);
        int v97 = SHIBYTE(v271.__r_.__value_.__r.__words[2]);
        long long v98 = *(_OWORD *)&v271.__r_.__value_.__l.__data_;
        if ((v271.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        {
          uint64_t v99 = &v271;
        }
        else
        {
          int64_t size = v271.__r_.__value_.__l.__size_;
          uint64_t v99 = (std::string *)v271.__r_.__value_.__r.__words[0];
        }
        if (size < 7) {
          goto LABEL_122;
        }
        uint64_t v100 = (char *)v99 + size;
        uint64_t v101 = v99;
        while (1)
        {
          float v102 = (char *)memchr(v101, 68, size - 6);
          if (!v102) {
            goto LABEL_122;
          }
          BOOL v103 = *(_DWORD *)v102 == 1634100548 && *(_DWORD *)(v102 + 3) == 1953264993;
          if (v103) {
            break;
          }
          uint64_t v101 = (std::string *)(v102 + 1);
          int64_t size = v100 - (char *)v101;
          if (v100 - (char *)v101 < 7) {
            goto LABEL_122;
          }
        }
        if (v102 == v100 || v102 - (char *)v99 == -1)
        {
LABEL_122:
          uint64_t v104 = *v95;
          if (*v95)
          {
            unsigned int v105 = *v93;
            uint64_t v106 = v95;
            do
            {
              unsigned int v107 = *(_DWORD *)(v104 + 28);
              BOOL v108 = v107 >= v105;
              if (v107 >= v105) {
                unint64_t v109 = (uint64_t *)v104;
              }
              else {
                unint64_t v109 = (uint64_t *)(v104 + 8);
              }
              if (v108) {
                uint64_t v106 = (void *)v104;
              }
              uint64_t v104 = *v109;
            }
            while (*v109);
            if (v106 != v95 && v105 >= *((_DWORD *)v106 + 7))
            {
              uint64_t v121 = v249;
              if (v97 < 0) {
                std::string::__init_copy_ctor_external(&__p, (const std::string::value_type *)v98, *((std::string::size_type *)&v98 + 1));
              }
              else {
                std::string __p = v271;
              }
              uint64_t v122 = v249;
              float v255 = v12;
              uint64_t v130 = v121 - v249;
              uint64_t v131 = (v121 - (uint64_t)v249) >> 5;
              std::string::size_type v132 = v121;
              if (*((void *)&v249 + 1) < (unint64_t)v250)
              {
                if (v121 == *((void *)&v249 + 1))
                {
                  uint64_t v95 = v244;
                  if ((void)v249)
                  {
                    long long v139 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                    *(void *)(v121 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
                    *(_OWORD *)uint64_t v121 = v139;
                    memset(&__p, 0, sizeof(__p));
                    *(float *)(v122 + 32 * v131 + 24) = v255;
                  }
                  *((void *)&v249 + 1) = v121 + 32;
                }
                else
                {
                  std::vector<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator>>::__move_range((uint64_t)&v249, v121, *((unint64_t *)&v249 + 1), v121 + 32);
                  uint64_t v95 = v244;
                  if (*(char *)(v121 + 23) < 0) {
                    operator delete(*(void **)v121);
                  }
                  long long v133 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                  *(void *)(v121 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
                  *(_OWORD *)uint64_t v121 = v133;
                  *((unsigned char *)&__p.__r_.__value_.__s + 23) = 0;
                  __p.__r_.__value_.__s.__data_[0] = 0;
                  *(float *)(v122 + 32 * v131 + 24) = v255;
                }
                goto LABEL_217;
              }
              unint64_t v134 = ((uint64_t)(*((void *)&v249 + 1) - v249) >> 5) + 1;
              if (v134 >> 59) {
                goto LABEL_398;
              }
              unint64_t v135 = v94;
              uint64_t v136 = (uint64_t)&v250[-v249];
              if ((uint64_t)&v250[-v249] >> 4 > v134) {
                unint64_t v134 = v136 >> 4;
              }
              if ((unint64_t)v136 >= 0x7FFFFFFFFFFFFFE0) {
                uint64_t v137 = 0x7FFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v137 = v134;
              }
              v270[1] = v251;
              if (v137) {
                uint64_t v138 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v251[0] + 16))(v251[0], 32 * v137, 8);
              }
              else {
                uint64_t v138 = 0;
              }
              std::string::size_type v140 = v138 + 32 * v131;
              v269.__r_.__value_.__r.__words[0] = v138;
              v269.__r_.__value_.__l.__size_ = v140;
              v270[0] = v138 + 32 * v137;
              if (v131 == v137)
              {
                if (v130 >= 1)
                {
                  int v94 = v135;
                  unint64_t v141 = v131 + 2;
                  if (v131 >= -1) {
                    unint64_t v141 = v131 + 1;
                  }
                  v140 -= 32 * (v141 >> 1);
                  v269.__r_.__value_.__l.__size_ = v140;
                  goto LABEL_204;
                }
                unint64_t v153 = (unsigned char *)(v138 + 32 * v137);
                if (v122 == v121) {
                  unint64_t v154 = 1;
                }
                else {
                  unint64_t v154 = v130 >> 4;
                }
                unint64_t v274 = v251;
                uint64_t v155 = (*(uint64_t (**)(void, unint64_t, uint64_t))(*(void *)v251[0] + 16))(v251[0], 32 * v154, 8);
                std::string::size_type v156 = v155 + 32 * (v154 >> 2);
                v269.__r_.__value_.__r.__words[0] = v155;
                v269.__r_.__value_.__l.__size_ = v156;
                *(void *)float buf = v138;
                *(void *)&buf[8] = v140;
                v270[0] = v155 + 32 * v154;
                *(void *)&buf[16] = v140;
                unint64_t v273 = v153;
                std::__split_buffer<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
                std::string::size_type v140 = v156;
              }
              int v94 = v135;
LABEL_204:
              uint64_t v95 = v244;
              if (v140)
              {
                long long v157 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                *(void *)(v140 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
                *(_OWORD *)std::string::size_type v140 = v157;
                memset(&__p, 0, sizeof(__p));
                *(float *)(v140 + 24) = v255;
              }
              std::string::size_type v158 = v140 + 32;
              v269.__r_.__value_.__r.__words[2] = v140 + 32;
              std::string::size_type v159 = v269.__r_.__value_.__l.__size_;
              uint64_t v160 = v249;
              if ((void)v249 == v121)
              {
                uint64_t v14 = v239;
              }
              else
              {
                uint64_t v161 = v121;
                uint64_t v14 = v239;
                do
                {
                  long long v162 = *(_OWORD *)(v161 - 32);
                  *(void *)(v159 - 16) = *(void *)(v161 - 16);
                  *(_OWORD *)(v159 - 32) = v162;
                  *(void *)(v161 - 24) = 0;
                  *(void *)(v161 - 16) = 0;
                  *(void *)(v161 - 32) = 0;
                  *(_DWORD *)(v159 - 8) = *(_DWORD *)(v161 - 8);
                  v159 -= 32;
                  v161 -= 32;
                }
                while (v161 != v160);
                std::string::size_type v158 = v269.__r_.__value_.__r.__words[2];
              }
              v269.__r_.__value_.__l.__size_ = v159;
              uint64_t v163 = *((void *)&v249 + 1);
              if (*((void *)&v249 + 1) != v121)
              {
                do
                {
                  if (v158)
                  {
                    long long v164 = *(_OWORD *)v132;
                    *(void *)(v158 + 16) = *(void *)(v132 + 16);
                    *(_OWORD *)std::string::size_type v158 = v164;
                    *(void *)(v132 + 8) = 0;
                    *(void *)(v132 + 16) = 0;
                    *(void *)std::string::size_type v132 = 0;
                    *(_DWORD *)(v158 + 24) = *(_DWORD *)(v132 + 24);
                  }
                  v132 += 32;
                  v158 += 32;
                }
                while (v132 != v163);
                std::string::size_type v159 = v269.__r_.__value_.__l.__size_;
                std::string::size_type v132 = *((void *)&v249 + 1);
              }
              std::string::size_type v165 = v249;
              int v166 = v250;
              *(void *)&long long v249 = v159;
              *((void *)&v249 + 1) = v158;
              float v250 = (unsigned char *)v270[0];
              v269.__r_.__value_.__r.__words[2] = v132;
              v270[0] = v166;
              v269.__r_.__value_.__r.__words[0] = v165;
              v269.__r_.__value_.__l.__size_ = v165;
              std::__split_buffer<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator> &>::~__split_buffer((uint64_t)&v269);
LABEL_217:
              if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                goto LABEL_218;
              }
              float v129 = (void *)__p.__r_.__value_.__r.__words[0];
LABEL_161:
              operator delete(v129);
              goto LABEL_218;
            }
          }
          if (v97 < 0) {
            std::string::__init_copy_ctor_external(&v269, (const std::string::value_type *)v98, *((std::string::size_type *)&v98 + 1));
          }
          else {
            std::string v269 = v271;
          }
          *(float *)float32x4_t v270 = v12;
          uint64_t v110 = v256.i64[1];
          if (v256.i64[1] >= (unint64_t)v257)
          {
            uint64_t v113 = (v256.i64[1] - v256.i64[0]) >> 5;
            unint64_t v114 = v113 + 1;
            if ((unint64_t)(v113 + 1) >> 59) {
              goto LABEL_398;
            }
            uint64_t v115 = (uint64_t)&v257[-v256.i64[0]];
            if ((uint64_t)&v257[-v256.i64[0]] >> 4 > v114) {
              unint64_t v114 = v115 >> 4;
            }
            if ((unint64_t)v115 >= 0x7FFFFFFFFFFFFFE0) {
              uint64_t v116 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v116 = v114;
            }
            unint64_t v274 = &v258;
            if (v116)
            {
              uint64_t v117 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v258 + 16))(v258, 32 * v116, 8);
              uint64_t v118 = v117 + 32 * v113;
              uint64_t v119 = v117 + 32 * v116;
              if (v117)
              {
                long long v120 = *(_OWORD *)&v269.__r_.__value_.__l.__data_;
                *(void *)(v118 + 16) = *((void *)&v269.__r_.__value_.__l + 2);
                *(_OWORD *)uint64_t v118 = v120;
                memset(&v269, 0, sizeof(v269));
                *(_DWORD *)(v118 + 24) = v270[0];
              }
            }
            else
            {
              uint64_t v119 = 0;
              uint64_t v118 = 32 * v113;
            }
            uint64_t v123 = v256.i64[1];
            uint64_t v124 = v256.i64[0];
            if (v256.i64[1] == v256.i64[0])
            {
              int64x2_t v127 = vdupq_n_s64(v256.u64[1]);
              uint64_t v125 = v118;
            }
            else
            {
              uint64_t v125 = v118;
              do
              {
                long long v126 = *(_OWORD *)(v123 - 32);
                *(void *)(v125 - 16) = *(void *)(v123 - 16);
                *(_OWORD *)(v125 - 32) = v126;
                *(void *)(v123 - 24) = 0;
                *(void *)(v123 - 16) = 0;
                *(void *)(v123 - 32) = 0;
                *(_DWORD *)(v125 - 8) = *(_DWORD *)(v123 - 8);
                v125 -= 32;
                v123 -= 32;
              }
              while (v123 != v124);
              int64x2_t v127 = v256;
            }
            uint64_t v112 = v118 + 32;
            v256.i64[0] = v125;
            v256.i64[1] = v118 + 32;
            *(int64x2_t *)&buf[8] = v127;
            unint64_t v128 = v257;
            float v257 = (unsigned char *)v119;
            unint64_t v273 = v128;
            *(void *)float buf = v127.i64[0];
            std::__split_buffer<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
          }
          else
          {
            if (v256.i64[1])
            {
              long long v111 = *(_OWORD *)&v269.__r_.__value_.__l.__data_;
              *(void *)(v256.i64[1] + 16) = *((void *)&v269.__r_.__value_.__l + 2);
              *(_OWORD *)uint64_t v110 = v111;
              memset(&v269, 0, sizeof(v269));
              *(_DWORD *)(v110 + 24) = v270[0];
            }
            uint64_t v112 = v110 + 32;
          }
          v256.i64[1] = v112;
        }
        else
        {
          if (v97 < 0) {
            std::string::__init_copy_ctor_external(&v269, (const std::string::value_type *)v98, *((std::string::size_type *)&v98 + 1));
          }
          else {
            std::string v269 = v271;
          }
          *(float *)float32x4_t v270 = v12;
          uint64_t v142 = *((void *)&v249 + 1);
          if (*((void *)&v249 + 1) >= (unint64_t)v250)
          {
            uint64_t v145 = (uint64_t)(*((void *)&v249 + 1) - v249) >> 5;
            unint64_t v146 = v145 + 1;
            if ((unint64_t)(v145 + 1) >> 59) {
              goto LABEL_398;
            }
            uint64_t v147 = (uint64_t)&v250[-v249];
            if ((uint64_t)&v250[-v249] >> 4 > v146) {
              unint64_t v146 = v147 >> 4;
            }
            if ((unint64_t)v147 >= 0x7FFFFFFFFFFFFFE0) {
              uint64_t v148 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v148 = v146;
            }
            unint64_t v274 = v251;
            if (v148)
            {
              uint64_t v149 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v251[0] + 16))(v251[0], 32 * v148, 8);
              uint64_t v150 = v149 + 32 * v145;
              uint64_t v151 = v149 + 32 * v148;
              if (v149)
              {
                long long v152 = *(_OWORD *)&v269.__r_.__value_.__l.__data_;
                *(void *)(v150 + 16) = *((void *)&v269.__r_.__value_.__l + 2);
                *(_OWORD *)uint64_t v150 = v152;
                memset(&v269, 0, sizeof(v269));
                *(_DWORD *)(v150 + 24) = v270[0];
              }
            }
            else
            {
              uint64_t v151 = 0;
              uint64_t v150 = 32 * v145;
            }
            uint64_t v167 = *((void *)&v249 + 1);
            uint64_t v168 = v249;
            if (*((void *)&v249 + 1) == (void)v249)
            {
              int64x2_t v171 = vdupq_n_s64(*((unint64_t *)&v249 + 1));
              uint64_t v169 = v150;
            }
            else
            {
              uint64_t v169 = v150;
              do
              {
                long long v170 = *(_OWORD *)(v167 - 32);
                *(void *)(v169 - 16) = *(void *)(v167 - 16);
                *(_OWORD *)(v169 - 32) = v170;
                *(void *)(v167 - 24) = 0;
                *(void *)(v167 - 16) = 0;
                *(void *)(v167 - 32) = 0;
                *(_DWORD *)(v169 - 8) = *(_DWORD *)(v167 - 8);
                v169 -= 32;
                v167 -= 32;
              }
              while (v167 != v168);
              int64x2_t v171 = (int64x2_t)v249;
            }
            uint64_t v144 = v150 + 32;
            *(void *)&long long v249 = v169;
            *((void *)&v249 + 1) = v150 + 32;
            *(int64x2_t *)&buf[8] = v171;
            float v172 = v250;
            float v250 = (unsigned char *)v151;
            unint64_t v273 = v172;
            *(void *)float buf = v171.i64[0];
            std::__split_buffer<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
          }
          else
          {
            if (*((void *)&v249 + 1))
            {
              long long v143 = *(_OWORD *)&v269.__r_.__value_.__l.__data_;
              *(void *)(*((void *)&v249 + 1) + 16) = *((void *)&v269.__r_.__value_.__l + 2);
              *(_OWORD *)uint64_t v142 = v143;
              memset(&v269, 0, sizeof(v269));
              *(_DWORD *)(v142 + 24) = v270[0];
            }
            uint64_t v144 = v142 + 32;
          }
          *((void *)&v249 + 1) = v144;
        }
        if (SHIBYTE(v269.__r_.__value_.__r.__words[2]) < 0)
        {
          float v129 = (void *)v269.__r_.__value_.__r.__words[0];
          goto LABEL_161;
        }
LABEL_218:
        if (SHIBYTE(v271.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v271.__r_.__value_.__l.__data_);
        }
        ++v93;
      }
      while (v93 != (unsigned int *)v94);
    }
    float32x4_t v174 = (long long *)v256.i64[1];
    uint64_t v173 = v256.i64[0];
    if (v256.i64[1] - v256.i64[0] < 1) {
      goto LABEL_262;
    }
    uint64_t v175 = (v256.i64[1] - v256.i64[0]) >> 5;
    float v176 = (long long *)*((void *)&v249 + 1);
    if (v175 <= (uint64_t)&v250[-*((void *)&v249 + 1)] >> 5)
    {
      if (v175 <= 0)
      {
        uint64_t v184 = v256.i64[0] + 32 * v175;
        std::vector<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator>>::__move_range((uint64_t)&v249, *((uint64_t *)&v249 + 1), *((unint64_t *)&v249 + 1), *((void *)&v249 + 1) + 32 * v175);
        for (; v173 != v184; v176 += 2)
        {
          std::string::operator=((std::string *)v176, (const std::string *)v173);
          *((_DWORD *)v176 + 6) = *(_DWORD *)(v173 + 24);
          v173 += 32;
        }
      }
      else
      {
        uint64_t v181 = *((void *)&v249 + 1);
        if (v256.i64[0] != v256.i64[1])
        {
          float32x4_t v182 = (long long *)v256.i64[0];
          uint64_t v183 = (std::string *)*((void *)&v249 + 1);
          do
          {
            geo::StdAllocator<std::pair<std::string,float>,grl::Allocator>::construct<std::pair<std::string,float>,std::pair<std::string,float>&>(v183, v182);
            v182 += 2;
            uint64_t v183 = (std::string *)((char *)v183 + 32);
            v181 += 32;
          }
          while (v182 != v174);
        }
        *((void *)&v249 + 1) = v181;
      }
      goto LABEL_262;
    }
    uint64_t v177 = (uint64_t)(*((void *)&v249 + 1) - v249) >> 5;
    if (!((unint64_t)(v177 + v175) >> 59))
    {
      unint64_t v178 = (uint64_t)&v250[-v249] >> 4;
      if (v178 <= v177 + v175) {
        unint64_t v178 = v177 + v175;
      }
      if ((unint64_t)&v250[-v249] >= 0x7FFFFFFFFFFFFFE0) {
        uint64_t v179 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v179 = v178;
      }
      unint64_t v274 = v251;
      if (v179) {
        uint64_t v180 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v251[0] + 16))(v251[0], 32 * v179, 8);
      }
      else {
        uint64_t v180 = 0;
      }
      float v185 = (std::string *)(v180 + 32 * v177);
      *(void *)float buf = v180;
      *(void *)&buf[8] = v185;
      unint64_t v273 = (unsigned char *)(v180 + 32 * v179);
      uint64_t v186 = 32 * v175;
      float v187 = (char *)v185 + 32 * v175;
      do
      {
        geo::StdAllocator<std::pair<std::string,float>,grl::Allocator>::construct<std::pair<std::string,float>,std::pair<std::string,float>&>(v185, (long long *)v173);
        float v185 = (std::string *)((char *)v185 + 32);
        v173 += 32;
        v186 -= 32;
      }
      while (v186);
      *(void *)&buf[16] = v187;
      uint64_t v188 = *(void *)&buf[8];
      int v189 = (long long *)v249;
      if ((long long *)v249 != v176)
      {
        float v190 = v176;
        do
        {
          long long v191 = *(v190 - 2);
          *(void *)(v188 - 16) = *((void *)v190 - 2);
          *(_OWORD *)(v188 - 32) = v191;
          *((void *)v190 - 3) = 0;
          *((void *)v190 - 2) = 0;
          *((void *)v190 - 4) = 0;
          *(_DWORD *)(v188 - 8) = *((_DWORD *)v190 - 2);
          v188 -= 32;
          v190 -= 2;
        }
        while (v190 != v189);
        float v187 = *(char **)&buf[16];
      }
      *(void *)&buf[8] = v188;
      int v192 = (long long *)*((void *)&v249 + 1);
      if (*((long long **)&v249 + 1) != v176)
      {
        do
        {
          if (v187)
          {
            long long v193 = *v176;
            *((void *)v187 + 2) = *((void *)v176 + 2);
            *(_OWORD *)float v187 = v193;
            *((void *)v176 + 1) = 0;
            *((void *)v176 + 2) = 0;
            *(void *)float v176 = 0;
            *((_DWORD *)v187 + 6) = *((_DWORD *)v176 + 6);
          }
          v176 += 2;
          v187 += 32;
        }
        while (v176 != v192);
        uint64_t v188 = *(void *)&buf[8];
        float v176 = (long long *)*((void *)&v249 + 1);
      }
      uint64_t v194 = v249;
      float v195 = v250;
      *(void *)&long long v249 = v188;
      *((void *)&v249 + 1) = v187;
      float v250 = v273;
      *(void *)&buf[16] = v176;
      unint64_t v273 = v195;
      *(void *)float buf = v194;
      *(void *)&buf[8] = v194;
      std::__split_buffer<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
LABEL_262:
      *(void *)float buf = &v256;
      std::vector<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100]((uint64_t **)buf);
      uint64_t v90 = v248;
      uint64_t v91 = v240;
      goto LABEL_263;
    }
LABEL_398:
    abort();
  }
  long long v26 = (grl::Allocator *)grl::codec::IconMapPack::regionsForCountryCode(v14, &v267, &v269);
  int64x2_t v256 = 0uLL;
  float v257 = 0;
  uint64_t v258 = grl::Allocator::instance(v26);
  uint64_t v27 = (grl::Allocator *)std::vector<unsigned int,geo::StdAllocator<unsigned int,grl::Allocator>>::reserve((unint64_t *)&v256, v260 - v259);
  std::string::size_type v29 = v269.__r_.__value_.__l.__size_;
  for (unint64_t i = (__int32 *)v269.__r_.__value_.__r.__words[0]; i != (__int32 *)v29; ++i)
  {
    __int32 v30 = *i;
    long long v31 = v260;
    uint64_t v27 = (grl::Allocator *)wmemchr(v259, *i, v260 - v259);
    if (v27) {
      float64x2_t v32 = (__int32 *)v27;
    }
    else {
      float64x2_t v32 = v31;
    }
    if (v32 != v260)
    {
      uint64_t v33 = v256.i64[1];
      if (v256.i64[1] >= (unint64_t)v257)
      {
        uint64_t v35 = (v256.i64[1] - v256.i64[0]) >> 2;
        unint64_t v36 = v35 + 1;
        if ((unint64_t)(v35 + 1) >> 62) {
          goto LABEL_398;
        }
        uint64_t v37 = (uint64_t)&v257[-v256.i64[0]];
        if ((uint64_t)&v257[-v256.i64[0]] >> 1 > v36) {
          unint64_t v36 = v37 >> 1;
        }
        if ((unint64_t)v37 >= 0x7FFFFFFFFFFFFFFCLL) {
          uint64_t v38 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v38 = v36;
        }
        unint64_t v274 = &v258;
        if (v38)
        {
          uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v258 + 16))(v258, 4 * v38, 4);
          __int16 v40 = (__int32 *)(v39 + 4 * v35);
          uint64_t v41 = v39 + 4 * v38;
          if (v39) {
            *__int16 v40 = v30;
          }
        }
        else
        {
          uint64_t v41 = 0;
          __int16 v40 = (__int32 *)(4 * v35);
        }
        int64x2_t v42 = v256;
        int v43 = v40;
        if (v256.i64[1] != v256.i64[0])
        {
          uint64_t v44 = v256.i64[1];
          int v43 = v40;
          do
          {
            __int32 v45 = *(_DWORD *)(v44 - 4);
            v44 -= 4;
            *--int v43 = v45;
          }
          while (v44 != v42.i64[0]);
        }
        uint64_t v34 = v40 + 1;
        v256.i64[0] = (uint64_t)v43;
        v256.i64[1] = (uint64_t)(v40 + 1);
        int v46 = v257;
        float v257 = (unsigned char *)v41;
        unint64_t v273 = v46;
        *(void *)float buf = v42.i64[0];
        *(int64x2_t *)&buf[8] = v42;
        uint64_t v27 = (grl::Allocator *)std::__split_buffer<unsigned int,geo::StdAllocator<unsigned int,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
      }
      else
      {
        if (v256.i64[1]) {
          *(_DWORD *)v256.i64[1] = v30;
        }
        uint64_t v34 = (_DWORD *)(v33 + 4);
      }
      v256.i64[1] = (uint64_t)v34;
    }
  }
  uint64_t v48 = v260;
  float64x2_t v47 = v259;
  if (v259 != v260)
  {
    int v49 = (char *)v14 + 272;
    do
    {
      double v50 = *(char **)v49;
      if (*(void *)v49)
      {
        unsigned __int32 v51 = *v47;
        float64x2_t v52 = (char *)v14 + 272;
        do
        {
          unsigned __int32 v53 = *((_DWORD *)v50 + 7);
          BOOL v54 = v53 >= v51;
          if (v53 >= v51) {
            float v55 = (char **)v50;
          }
          else {
            float v55 = (char **)(v50 + 8);
          }
          if (v54) {
            float64x2_t v52 = v50;
          }
          double v50 = *v55;
        }
        while (*v55);
        if (v52 != v49 && v51 >= *((_DWORD *)v52 + 7))
        {
          uint64_t v56 = v256.i64[1];
          if (v256.i64[1] >= (unint64_t)v257)
          {
            uint64_t v58 = (v256.i64[1] - v256.i64[0]) >> 2;
            unint64_t v59 = v58 + 1;
            if ((unint64_t)(v58 + 1) >> 62) {
              goto LABEL_398;
            }
            uint64_t v60 = (uint64_t)&v257[-v256.i64[0]];
            if ((uint64_t)&v257[-v256.i64[0]] >> 1 > v59) {
              unint64_t v59 = v60 >> 1;
            }
            if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFFCLL) {
              uint64_t v61 = 0x3FFFFFFFFFFFFFFFLL;
            }
            else {
              uint64_t v61 = v59;
            }
            unint64_t v274 = &v258;
            if (v61)
            {
              uint64_t v62 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v258 + 16))(v258, 4 * v61, 4);
              uint64_t v63 = (unsigned __int32 *)(v62 + 4 * v58);
              uint64_t v64 = v62 + 4 * v61;
              if (v62) {
                unsigned __int32 *v63 = v51;
              }
            }
            else
            {
              uint64_t v64 = 0;
              uint64_t v63 = (unsigned __int32 *)(4 * v58);
            }
            int64x2_t v65 = v256;
            float v66 = v63;
            if (v256.i64[1] != v256.i64[0])
            {
              uint64_t v67 = v256.i64[1];
              float v66 = v63;
              do
              {
                unsigned __int32 v68 = *(_DWORD *)(v67 - 4);
                v67 -= 4;
                *--float v66 = v68;
              }
              while (v67 != v65.i64[0]);
            }
            float v57 = v63 + 1;
            v256.i64[0] = (uint64_t)v66;
            v256.i64[1] = (uint64_t)(v63 + 1);
            float v69 = v257;
            float v257 = (unsigned char *)v64;
            unint64_t v273 = v69;
            *(void *)float buf = v65.i64[0];
            *(int64x2_t *)&buf[8] = v65;
            uint64_t v27 = (grl::Allocator *)std::__split_buffer<unsigned int,geo::StdAllocator<unsigned int,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
          }
          else
          {
            if (v256.i64[1]) {
              *(_DWORD *)v256.i64[1] = v51;
            }
            float v57 = (_DWORD *)(v56 + 4);
          }
          v256.i64[1] = (uint64_t)v57;
        }
      }
      ++v47;
    }
    while (v47 != v48);
  }
  long long v249 = 0uLL;
  float v250 = 0;
  v251[0] = grl::Allocator::instance(v27);
  float v71 = (unsigned int *)v256.i64[1];
  float v70 = (unsigned int *)v256.i64[0];
  if (v256.i64[0] != v256.i64[1])
  {
    do
    {
      grl::codec::IconMapPack::regionNameForID(v14, v70, &__p);
      v271.__r_.__value_.__r.__words[0] = __p.__r_.__value_.__l.__size_;
      double v72 = (void *)__p.__r_.__value_.__r.__words[0];
      *(std::string::size_type *)((char *)v271.__r_.__value_.__r.__words + 7) = *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 7);
      char v73 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      memset(&__p, 0, sizeof(__p));
      uint64_t v74 = *((void *)&v249 + 1);
      if (*((void *)&v249 + 1) >= (unint64_t)v250)
      {
        uint64_t v76 = (uint64_t)(*((void *)&v249 + 1) - v249) >> 5;
        unint64_t v77 = v76 + 1;
        if ((unint64_t)(v76 + 1) >> 59) {
          goto LABEL_398;
        }
        unint64_t v78 = v14;
        uint64_t v79 = (uint64_t)&v250[-v249];
        if ((uint64_t)&v250[-v249] >> 4 > v77) {
          unint64_t v77 = v79 >> 4;
        }
        if ((unint64_t)v79 >= 0x7FFFFFFFFFFFFFE0) {
          uint64_t v80 = 0x7FFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v80 = v77;
        }
        unint64_t v274 = v251;
        if (v80)
        {
          uint64_t v81 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v251[0] + 16))(v251[0], 32 * v80, 8);
          uint64_t v82 = v81 + 32 * v76;
          uint64_t v83 = v81 + 32 * v80;
          if (v81)
          {
            *(void *)uint64_t v82 = v72;
            double v72 = 0;
            *(void *)(v82 + 8) = v271.__r_.__value_.__r.__words[0];
            *(void *)(v82 + 15) = *(std::string::size_type *)((char *)v271.__r_.__value_.__r.__words + 7);
            *(unsigned char *)(v82 + 23) = v73;
            v271.__r_.__value_.__r.__words[0] = 0;
            *(std::string::size_type *)((char *)v271.__r_.__value_.__r.__words + 7) = 0;
            *(float *)(v82 + 24) = v12;
            char v73 = 0;
          }
        }
        else
        {
          uint64_t v83 = 0;
          uint64_t v82 = 32 * v76;
        }
        uint64_t v14 = v78;
        uint64_t v84 = *((void *)&v249 + 1);
        uint64_t v85 = v249;
        if (*((void *)&v249 + 1) == (void)v249)
        {
          int64x2_t v88 = vdupq_n_s64(*((unint64_t *)&v249 + 1));
          uint64_t v86 = v82;
        }
        else
        {
          uint64_t v86 = v82;
          do
          {
            long long v87 = *(_OWORD *)(v84 - 32);
            *(void *)(v86 - 16) = *(void *)(v84 - 16);
            *(_OWORD *)(v86 - 32) = v87;
            *(void *)(v84 - 24) = 0;
            *(void *)(v84 - 16) = 0;
            *(void *)(v84 - 32) = 0;
            *(_DWORD *)(v86 - 8) = *(_DWORD *)(v84 - 8);
            v86 -= 32;
            v84 -= 32;
          }
          while (v84 != v85);
          int64x2_t v88 = (int64x2_t)v249;
        }
        uint64_t v75 = v82 + 32;
        *(void *)&long long v249 = v86;
        *((void *)&v249 + 1) = v82 + 32;
        *(int64x2_t *)&buf[8] = v88;
        long long v89 = v250;
        float v250 = (unsigned char *)v83;
        unint64_t v273 = v89;
        *(void *)float buf = v88.i64[0];
        std::__split_buffer<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator> &>::~__split_buffer((uint64_t)buf);
      }
      else
      {
        if (*((void *)&v249 + 1))
        {
          **((void **)&v249 + 1) = v72;
          *(void *)(v74 + 8) = v271.__r_.__value_.__r.__words[0];
          *(void *)(v74 + 15) = *(std::string::size_type *)((char *)v271.__r_.__value_.__r.__words + 7);
          *(unsigned char *)(v74 + 23) = v73;
          v271.__r_.__value_.__r.__words[0] = 0;
          *(std::string::size_type *)((char *)v271.__r_.__value_.__r.__words + 7) = 0;
          *(float *)(v74 + 24) = v12;
          double v72 = 0;
          char v73 = 0;
        }
        uint64_t v75 = v74 + 32;
      }
      *((void *)&v249 + 1) = v75;
      if (v73 < 0) {
        operator delete(v72);
      }
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__p.__r_.__value_.__l.__data_);
      }
      ++v70;
    }
    while (v70 != v71);
    float v70 = (unsigned int *)v256.i64[0];
  }
  uint64_t v90 = v248;
  uint64_t v91 = v240;
  if (v70)
  {
    v256.i64[1] = (uint64_t)v70;
    (*(void (**)(uint64_t, unsigned int *, int64_t))(*(void *)v258 + 40))(v258, v70, v257 - (unsigned char *)v70);
  }
  if (v269.__r_.__value_.__r.__words[0])
  {
    v269.__r_.__value_.__l.__size_ = v269.__r_.__value_.__r.__words[0];
    (*(void (**)(void, std::string::size_type, std::string::size_type))(*(void *)v270[0] + 40))(v270[0], v269.__r_.__value_.__r.__words[0], v269.__r_.__value_.__r.__words[2] - v269.__r_.__value_.__r.__words[0]);
  }
LABEL_263:
  if (v259)
  {
    float v260 = v259;
    (*(void (**)(uint64_t, __int32 *, uint64_t))(*(void *)v262 + 40))(v262, v259, v261 - (void)v259);
  }
  if (v91) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v91);
  }
  if (SHIBYTE(v265) < 0) {
    operator delete(v263);
  }
  uint64_t v197 = *((void *)&v249 + 1);
  uint64_t v196 = v249;
  if ((void)v249 != *((void *)&v249 + 1))
  {
    float v245 = 0;
    uint64_t v246 = 0;
    std::string::size_type v241 = 0;
    float v198 = 0;
    float v234 = (std::string *)(a8 + 32);
    float v235 = (std::string *)(a8 + 8);
    while (1)
    {
      grl::IconManager::retrieveResourcePack(buf, v90, (float *)v196, 1);
      uint64_t v200 = *(void *)buf;
      int64_t v199 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](v199);
      }
      if (v200)
      {
        float v201 = v199;
      }
      else
      {
        grl::IconManager::loadResourcePack(buf, v90, v196, 1u, a6);
        uint64_t v200 = *(void *)buf;
        float v201 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
        }
        if (v199) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v199);
        }
        if (v201) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v201);
        }
        if (!v200)
        {
          if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
            dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
          }
          float v213 = GEOGetGeoResourceLibIconManagerLog::log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
          {
            uint64_t v214 = v196;
            if (*(char *)(v196 + 23) < 0) {
              uint64_t v214 = *(void *)v196;
            }
            *(_DWORD *)float buf = 136315138;
            *(void *)&uint8_t buf[4] = v214;
            _os_log_impl(&dword_1A1780000, v213, OS_LOG_TYPE_ERROR, "No config pack found for key %s", buf, 0xCu);
          }
          int v210 = 3;
          goto LABEL_347;
        }
      }
      grl::IconManager::retrieveResourcePack(buf, v90, (float *)v196, 0);
      uint64_t v202 = *(void *)buf;
      unint64_t v203 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8])
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
        std::__shared_weak_count::__release_shared[abi:ne180100](v203);
      }
      if (v202)
      {
        float v204 = v203;
      }
      else
      {
        grl::IconManager::loadResourcePack(buf, v248, v196, 0, a6);
        uint64_t v202 = *(void *)buf;
        float v204 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 1uLL, memory_order_relaxed);
        }
        if (v203) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v203);
        }
        if (v204) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v204);
        }
        if (!v202)
        {
          if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
            dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
          }
          uint64_t v90 = v248;
          uint64_t v215 = GEOGetGeoResourceLibIconManagerLog::log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
          {
            uint64_t v216 = v196;
            if (*(char *)(v196 + 23) < 0) {
              uint64_t v216 = *(void *)v196;
            }
            *(_DWORD *)float buf = 136315138;
            *(void *)&uint8_t buf[4] = v216;
            float v206 = v215;
            BOOL v207 = "No data pack found for key %s";
            uint32_t v208 = 12;
LABEL_344:
            _os_log_impl(&dword_1A1780000, v206, OS_LOG_TYPE_ERROR, v207, buf, v208);
          }
LABEL_345:
          int v210 = 3;
          if (!v204) {
            goto LABEL_347;
          }
LABEL_346:
          std::__shared_weak_count::__release_shared[abi:ne180100](v204);
          goto LABEL_347;
        }
      }
      if (*(float *)(v200 + 32) != *(float *)(v202 + 32))
      {
        if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
        }
        uint64_t v90 = v248;
        uint64_t v205 = GEOGetGeoResourceLibIconManagerLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)float buf = 0;
          float v206 = v205;
          BOOL v207 = "Mismatching config and data packs";
          uint32_t v208 = 2;
          goto LABEL_344;
        }
        goto LABEL_345;
      }
      *(void *)float buf = &unk_1EF5672F0;
      *(void *)&buf[8] = 0;
      *(void *)&buf[16] = 0;
      LOBYTE(v273) = 4;
      grl::codec::IconConfigPack::iconForKey((grl::codec::IconConfigPack *)v200, (const grl::IconKey *)a3, (grl::IconKey *)buf, &v269);
      std::string::size_type v209 = v269.__r_.__value_.__r.__words[0];
      if (v269.__r_.__value_.__r.__words[0]
        && *(_DWORD *)&buf[16] == *(_DWORD *)(a3 + 16)
        && __PAIR64__(*(unsigned __int16 *)&buf[22], *(unsigned __int16 *)&buf[20]) == __PAIR64__(*(unsigned __int16 *)(a3 + 22), *(unsigned __int16 *)(a3 + 20))&& v273 == *(unsigned __int8 *)(a3 + 24))
      {
        if (v204) {
          atomic_fetch_add_explicit(&v204->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        if (v245) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v245);
        }
        if (a8)
        {
          std::string::operator=(v235, (const std::string *)(v202 + 8));
          std::string::operator=(v234, (const std::string *)(v200 + 8));
        }
        int v210 = 1;
        float v245 = v204;
      }
      else
      {
        BOOL v211 = DWORD2(v252) >= *(_DWORD *)&buf[16];
        if (DWORD2(v252) == *(_DWORD *)&buf[16])
        {
          BOOL v211 = WORD6(v252) >= *(unsigned __int16 *)&buf[20];
          if (WORD6(v252) == *(unsigned __int16 *)&buf[20])
          {
            BOOL v211 = HIWORD(v252) >= *(unsigned __int16 *)&buf[22];
            if (HIWORD(v252) == *(unsigned __int16 *)&buf[22]) {
              BOOL v211 = v253 >= v273;
            }
          }
        }
        if (v211)
        {
          uint64_t v202 = v246;
          std::string::size_type v212 = (std::string::size_type)v198;
        }
        else
        {
          long long v252 = *(_OWORD *)&buf[8];
          unsigned __int8 v253 = v273;
          if (v204) {
            atomic_fetch_add_explicit(&v204->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (v245)
          {
            std::__shared_weak_count::__release_shared[abi:ne180100](v245);
            std::string::size_type v209 = v269.__r_.__value_.__r.__words[0];
          }
          std::string::size_type v241 = v209;
          std::string::size_type v212 = v269.__r_.__value_.__l.__size_;
          if (v269.__r_.__value_.__l.__size_) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v269.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
          }
          if (v198) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v198);
          }
          if (a8)
          {
            std::string::operator=(v235, (const std::string *)(v202 + 8));
            std::string::operator=(v234, (const std::string *)(v200 + 8));
          }
          float v245 = v204;
        }
        if (v269.__r_.__value_.__l.__size_) {
          std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v269.__r_.__value_.__l.__size_);
        }
        int v210 = 0;
        float v198 = (std::__shared_weak_count *)v212;
      }
      uint64_t v246 = v202;
      uint64_t v90 = v248;
      if (v204) {
        goto LABEL_346;
      }
LABEL_347:
      if (v201) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v201);
      }
      if (v210 != 3 && v210)
      {
        *(void *)float buf = &v249;
        std::vector<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100]((uint64_t **)buf);
        if (v198) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v198);
        }
        goto LABEL_355;
      }
      v196 += 32;
      if (v196 == v197) {
        goto LABEL_354;
      }
    }
  }
  float v245 = 0;
  uint64_t v246 = 0;
  float v198 = 0;
  std::string::size_type v241 = 0;
LABEL_354:
  v269.__r_.__value_.__r.__words[0] = v241;
  v269.__r_.__value_.__l.__size_ = (std::string::size_type)v198;
  *(void *)float buf = &v249;
  std::vector<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100]((uint64_t **)buf);
LABEL_355:
  long long v217 = *(_OWORD *)&v269.__r_.__value_.__l.__data_;
  if (v269.__r_.__value_.__r.__words[0] && v246)
  {
    grl::codec::IconData::alternativeTextFamily((grl::codec::IconData *)v269.__r_.__value_.__l.__data_, a4, (uint64_t)&v256);
    if (!v256.i8[0])
    {
      v269.__r_.__value_.__l.__size_ = 0;
      v269.__r_.__value_.__r.__words[2] = grl::Allocator::instance(v218);
      v270[0] = 0;
      v269.__r_.__value_.__r.__words[0] = (std::string::size_type)&v269.__r_.__value_.__l.__size_;
      uint64_t v264 = 0;
      uint64_t v265 = grl::Allocator::instance((grl::Allocator *)v269.__r_.__value_.__r.__words[2]);
      uint64_t v266 = 0;
      float v263 = &v264;
      if (*(void *)(v248 + 496))
      {
        *(void *)float buf = &unk_1EF57DF80;
        *(void *)&buf[8] = &v263;
        unint64_t v273 = buf;
        grl::codec::IconData::forEachTextLayer(v217, (const IconModifiers *)a4, (uint64_t)buf);
        std::__function::__value_func<void ()(unsigned short,grl::codec::TextLayerData const&)>::~__value_func[abi:nn180100](buf);
        if (v266)
        {
          float v221 = (char *)v263;
          if (v263 != &v264)
          {
            do
            {
              grl::FontManager::fontForKey(*(grl::FontManager **)(v248 + 496), (long long *)v221 + 2, buf, 0.0);
              std::string::size_type v222 = v269.__r_.__value_.__l.__size_;
              p_int64_t size = &v269.__r_.__value_.__l.__size_;
              float v224 = &v269.__r_.__value_.__l.__size_;
              if (!v269.__r_.__value_.__l.__size_) {
                goto LABEL_379;
              }
              p_int64_t size = &v269.__r_.__value_.__l.__size_;
              while (1)
              {
                while (1)
                {
                  float v224 = (std::string::size_type *)v222;
                  float v225 = (const void **)(v222 + 32);
                  if (!std::less<std::string>::operator()[abi:nn180100]((uint64_t)v270, (const void **)v221 + 4, (const void **)(v222 + 32)))break; {
                  std::string::size_type v222 = *v224;
                  }
                  p_int64_t size = v224;
                  if (!*v224) {
                    goto LABEL_379;
                  }
                }
                if (!std::less<std::string>::operator()[abi:nn180100]((uint64_t)v270, v225, (const void **)v221 + 4)) {
                  break;
                }
                p_int64_t size = v224 + 1;
                std::string::size_type v222 = v224[1];
                if (!v222) {
                  goto LABEL_379;
                }
              }
              int v226 = (void *)*p_size;
              if (!*p_size)
              {
LABEL_379:
                int v226 = (void *)(*(uint64_t (**)(std::string::size_type, uint64_t, uint64_t))(*(void *)v269.__r_.__value_.__r.__words[2] + 16))(v269.__r_.__value_.__r.__words[2], 80, 8);
                __float2 v227 = (std::string *)(v226 + 4);
                if (v221[55] < 0)
                {
                  std::string::__init_copy_ctor_external(v227, *((const std::string::value_type **)v221 + 4), *((void *)v221 + 5));
                }
                else
                {
                  long long v228 = *((_OWORD *)v221 + 2);
                  v226[6] = *((void *)v221 + 6);
                  *(_OWORD *)&v227->__r_.__value_.__l.__data_ = v228;
                }
                v226[7] = &unk_1EF5592F8;
                v226[8] = 0;
                *int v226 = 0;
                v226[1] = 0;
                v226[2] = v224;
                *p_int64_t size = (std::string::size_type)v226;
                float32x4_t v229 = v226;
                if (*(void *)v269.__r_.__value_.__l.__data_)
                {
                  v269.__r_.__value_.__r.__words[0] = *(void *)v269.__r_.__value_.__l.__data_;
                  float32x4_t v229 = (uint64_t *)*p_size;
                }
                std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v269.__r_.__value_.__l.__size_, v229);
                ++v270[0];
              }
              uint64_t v230 = (const void *)v226[8];
              if (v230) {
                CFRelease(v230);
              }
              v226[8] = *(void *)&buf[8];
              uint64_t v231 = (char *)*((void *)v221 + 1);
              if (v231)
              {
                do
                {
                  unint64_t v232 = v231;
                  uint64_t v231 = *(char **)v231;
                }
                while (v231);
              }
              else
              {
                do
                {
                  unint64_t v232 = (char *)*((void *)v221 + 2);
                  BOOL v103 = *(void *)v232 == (void)v221;
                  float v221 = v232;
                }
                while (!v103);
              }
              float v221 = v232;
            }
            while (v232 != (char *)&v264);
          }
        }
      }
      *(void *)float buf = v246;
      *(void *)&buf[8] = v245;
      if (v245) {
        atomic_fetch_add_explicit(&v245->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (*(void *)(a7 + 24)) {
        grl::codec::IconData::imageWithImageData(a9);
      }
      grl::codec::IconData::imageWithPack((grl::Allocator *)v217, (grl::codec::IconDataPack **)buf, a9);
    }
    *(_OWORD *)&buf[8] = *(_OWORD *)(a3 + 8);
    LOBYTE(v273) = *(unsigned char *)(a3 + 24);
    *(_DWORD *)&buf[16] = v256.i32[1];
    unint64_t v219 = (*(unsigned __int16 *)&buf[20]
          + ((v256.u32[1] - 0x61C8864680B583EBLL) << 6)
          + (((unint64_t)v256.u32[1] - 0x61C8864680B583EBLL) >> 2)
          - 0x61C8864680B583EBLL) ^ (v256.u32[1] - 0x61C8864680B583EBLL);
    unint64_t v220 = (*(unsigned __int16 *)&buf[22] + (v219 << 6) + (v219 >> 2) - 0x61C8864680B583EBLL) ^ v219;
    *(void *)float buf = &unk_1EF5672F0;
    *(void *)&buf[8] = (v273 + (v220 << 6) + (v220 >> 2) - 0x61C8864680B583EBLL) ^ v220;
    v269.__r_.__value_.__l.__size_ = 0;
    v269.__r_.__value_.__r.__words[2] = grl::Allocator::instance(v218);
    v270[0] = 0;
    v269.__r_.__value_.__r.__words[0] = (std::string::size_type)&v269.__r_.__value_.__l.__size_;
    grl::IconManager::image(a1, v248, buf, a4, a5, a6, &v269, 0, a9);
    std::__tree<std::__value_type<unsigned short,grl::ImageData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageData>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::ImageData>,grl::Allocator>>::destroy((uint64_t)&v269, (void *)v269.__r_.__value_.__l.__size_);
  }
  else
  {
    *a1 = 0;
    a1[1] = 0;
  }
  if (v245) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v245);
  }
  if (*((void *)&v217 + 1)) {
    std::__shared_weak_count::__release_shared[abi:ne180100](*((std::__shared_weak_count **)&v217 + 1));
  }
}

void std::__shared_weak_count::__release_shared[abi:ne180100](std::__shared_weak_count *a1)
{
  if (!atomic_fetch_add(&a1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))a1->__on_zero_shared)(a1);
    std::__shared_weak_count::__release_weak(a1);
  }
}

void grl::IconManager::retrieveResourcePack(void *a1, uint64_t a2, float *a3, int a4)
{
  int v8 = (std::__shared_mutex_base *)(a2 + 104);
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(a2 + 104));
  uint64_t v9 = *(void *)(a2 + 96);
  if (!v9)
  {
    if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
    }
    uint64_t v14 = GEOGetGeoResourceLibIconManagerLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v22 = 0;
      _os_log_impl(&dword_1A1780000, v14, OS_LOG_TYPE_ERROR, "No packinfo available", v22, 2u);
    }
    goto LABEL_26;
  }
  if (a4 != 2)
  {
    if (a4 == 1)
    {
      uint64_t v10 = (std::mutex *)(v9 + 304);
      std::mutex::lock((std::mutex *)(v9 + 304));
      uint64_t v11 = geo::LRUPolicy<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash>::get(*(void *)(a2 + 96) + 152, (void *)(*(void *)(a2 + 96) + 112), a3);
      uint64_t v12 = *(void *)(a2 + 96);
      uint64_t v13 = v12 + 152;
    }
    else
    {
      if (a4)
      {
LABEL_25:
        ++*(_DWORD *)(v9 + 372);
LABEL_26:
        *a1 = 0;
        a1[1] = 0;
        goto LABEL_27;
      }
      uint64_t v10 = (std::mutex *)(v9 + 240);
      std::mutex::lock((std::mutex *)(v9 + 240));
      uint64_t v11 = geo::LRUPolicy<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash>::get(*(void *)(a2 + 96) + 80, (void *)(*(void *)(a2 + 96) + 40), a3);
      uint64_t v12 = *(void *)(a2 + 96);
      uint64_t v13 = v12 + 80;
    }
    if (v13 != v11)
    {
      ++*(_DWORD *)(v12 + 368);
      uint64_t v21 = *(void *)(v11 + 48);
      uint64_t v20 = *(void *)(v11 + 56);
      goto LABEL_21;
    }
LABEL_24:
    std::mutex::unlock(v10);
    uint64_t v9 = *(void *)(a2 + 96);
    goto LABEL_25;
  }
  uint64_t v10 = (std::mutex *)(v9 + 176);
  std::mutex::lock((std::mutex *)(v9 + 176));
  uint64_t v15 = *(void *)(a2 + 96);
  uint64_t v16 = *(void *)(v15 + 8);
  if (!v16) {
    goto LABEL_24;
  }
  uint64_t v17 = v15 + 8;
  do
  {
    BOOL v18 = std::less<std::pair<std::string,float>>::operator()[abi:nn180100]((const void **)(v16 + 32), (const void **)a3);
    uint64_t v19 = (uint64_t *)(v16 + 8);
    if (!v18)
    {
      uint64_t v19 = (uint64_t *)v16;
      uint64_t v17 = v16;
    }
    uint64_t v16 = *v19;
  }
  while (*v19);
  if (v17 == v15 + 8
    || std::less<std::pair<std::string,float>>::operator()[abi:nn180100]((const void **)a3, (const void **)(v17 + 32)))
  {
    goto LABEL_24;
  }
  ++*(_DWORD *)(v15 + 368);
  uint64_t v21 = *(void *)(v17 + 64);
  uint64_t v20 = *(void *)(v17 + 72);
LABEL_21:
  *a1 = v21;
  a1[1] = v20;
  if (v20) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
  }
  std::mutex::unlock(v10);
LABEL_27:
  std::__shared_mutex_base::unlock_shared(v8);
}

BOOL std::less<std::pair<std::string,float>>::operator()[abi:nn180100](const void **a1, const void **a2)
{
  int v4 = *((char *)a2 + 23);
  int v5 = *((char *)a1 + 23);
  if (v5 >= 0) {
    size_t v6 = *((unsigned __int8 *)a1 + 23);
  }
  else {
    size_t v6 = (size_t)a1[1];
  }
  if (v5 >= 0) {
    unsigned int v7 = a1;
  }
  else {
    unsigned int v7 = *a1;
  }
  if (v4 >= 0) {
    size_t v8 = *((unsigned __int8 *)a2 + 23);
  }
  else {
    size_t v8 = (size_t)a2[1];
  }
  if (v4 >= 0) {
    uint64_t v9 = a2;
  }
  else {
    uint64_t v9 = *a2;
  }
  if (v8 >= v6) {
    size_t v10 = v6;
  }
  else {
    size_t v10 = v8;
  }
  int v11 = memcmp(v7, v9, v10);
  BOOL v12 = v6 < v8;
  if (v11) {
    BOOL v12 = v11 < 0;
  }
  if (v12) {
    return 1;
  }
  int v14 = memcmp(v9, v7, v10);
  BOOL v15 = v8 < v6;
  if (v14) {
    BOOL v15 = v14 < 0;
  }
  return !v15 && *((float *)a1 + 6) < *((float *)a2 + 6);
}

uint64_t std::__tree<std::string,std::less<std::string>,geo::StdAllocator<std::string,grl::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::string,std::less<std::string>,geo::StdAllocator<std::string,grl::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::string,std::less<std::string>,geo::StdAllocator<std::string,grl::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    if (*(char *)(a2 + 55) < 0) {
      operator delete(*(void **)(a2 + 32));
    }
    int v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

uint64_t std::__tree<std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,std::__map_value_compare<std::string,std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,std::less<std::string>,true>,geo::StdAllocator<std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,grl::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,std::__map_value_compare<std::string,std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,std::less<std::string>,true>,geo::StdAllocator<std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,grl::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,std::__map_value_compare<std::string,std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,std::less<std::string>,true>,geo::StdAllocator<std::__value_type<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,grl::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    *(void *)(a2 + 56) = &unk_1EF5592F8;
    int v4 = *(const void **)(a2 + 64);
    if (v4) {
      CFRelease(v4);
    }
    if (*(char *)(a2 + 55) < 0) {
      operator delete(*(void **)(a2 + 32));
    }
    int v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

uint64_t geo::LRUPolicy<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash>::get(uint64_t a1, void *a2, float *a3)
{
  int v4 = std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::find<std::pair<std::string,float>>(a2, a3);
  if (v4)
  {
    int v5 = *(uint64_t **)(a1 + 8);
    size_t v6 = (uint64_t *)*((void *)v4 + 6);
    if (v5 == v6) {
      return *(void *)(a1 + 8);
    }
    unsigned int v7 = (uint64_t *)v6[1];
    if (v7 == v5)
    {
      return *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v8 = *v6;
      *(void *)(v8 + 8) = v7;
      *(void *)v6[1] = v8;
      uint64_t v9 = *v5;
      *(void *)(v9 + 8) = v6;
      uint64_t *v6 = v9;
      uint64_t *v5 = (uint64_t)v6;
      v6[1] = (uint64_t)v5;
      return *(void *)(a1 + 8);
    }
  }
  return a1;
}

unsigned __int8 *std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::find<std::pair<std::string,float>>(void *a1, float *a2)
{
  unint64_t v4 = grl::codec::PackKeyHash::operator()((uint64_t)a2);
  int8x8_t v5 = (int8x8_t)a1[1];
  if (!*(void *)&v5) {
    return 0;
  }
  unint64_t v6 = v4;
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v5);
  v7.i16[0] = vaddlv_u8(v7);
  unint64_t v8 = v7.u32[0];
  if (v7.u32[0] > 1uLL)
  {
    unint64_t v9 = v4;
    if (v4 >= *(void *)&v5) {
      unint64_t v9 = v4 % *(void *)&v5;
    }
  }
  else
  {
    unint64_t v9 = (*(void *)&v5 - 1) & v4;
  }
  size_t v10 = *(unsigned __int8 ***)(*a1 + 8 * v9);
  if (!v10) {
    return 0;
  }
  for (unint64_t i = *v10; i; unint64_t i = *(unsigned __int8 **)i)
  {
    unint64_t v12 = *((void *)i + 1);
    if (v12 == v6)
    {
      if (std::equal_to<std::pair<std::string,float>>::operator()[abi:nn180100](i + 16, a2)) {
        return i;
      }
    }
    else
    {
      if (v8 > 1)
      {
        if (v12 >= *(void *)&v5) {
          v12 %= *(void *)&v5;
        }
      }
      else
      {
        v12 &= *(void *)&v5 - 1;
      }
      if (v12 != v9) {
        return 0;
      }
    }
  }
  return i;
}

unint64_t grl::codec::PackKeyHash::operator()(uint64_t a1)
{
  int v2 = *(char *)(a1 + 23);
  if (v2 >= 0) {
    uint64_t v3 = (uint64_t *)a1;
  }
  else {
    uint64_t v3 = *(uint64_t **)a1;
  }
  if (v2 >= 0) {
    unint64_t v4 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    unint64_t v4 = *(void *)(a1 + 8);
  }
  unint64_t v5 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100]((uint64_t)&v9, v3, v4);
  uint64_t v6 = 0x9E3779B97F4A7C15;
  float v7 = *(float *)(a1 + 24);
  if (v7 != 0.0) {
    uint64_t v6 = LODWORD(v7) - 0x61C8864680B583EBLL;
  }
  return (((v5 - 0x61C8864680B583EBLL) >> 2) + ((v5 - 0x61C8864680B583EBLL) << 6) + v6) ^ (v5 - 0x61C8864680B583EBLL);
}

unint64_t std::__murmur2_or_cityhash<unsigned long,64ul>::__hash_len_17_to_32[abi:nn180100](void *a1, uint64_t a2)
{
  uint64_t v2 = a1[1];
  unint64_t v3 = 0xB492B66FBE98F273 * *a1;
  uint64_t v4 = __ROR8__(0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8), 30) + __ROR8__(v3 - v2, 43);
  unint64_t v5 = v3 + a2 + __ROR8__(v2 ^ 0xC949D7C7509E6557, 20) - 0x9AE16A3B2F90404FLL * *(void *)((char *)a1 + a2 - 8);
  unint64_t v6 = 0x9DDFEA08EB382D69 * ((v4 - 0x3C5A37A36834CED9 * *(void *)((char *)a1 + a2 - 16)) ^ v5);
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) ^ ((0x9DDFEA08EB382D69 * (v5 ^ (v6 >> 47) ^ v6)) >> 47));
}

BOOL std::equal_to<std::pair<std::string,float>>::operator()[abi:nn180100](unsigned __int8 *a1, float *a2)
{
  uint64_t v2 = a2;
  uint64_t v4 = a1[23];
  if ((v4 & 0x80u) == 0) {
    uint64_t v5 = a1[23];
  }
  else {
    uint64_t v5 = *((void *)a1 + 1);
  }
  uint64_t v6 = *((unsigned __int8 *)a2 + 23);
  int v7 = (char)v6;
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *((void *)a2 + 1);
  }
  if (v5 == v6)
  {
    if (v7 < 0) {
      a2 = *(float **)a2;
    }
    if ((v4 & 0x80) != 0)
    {
      BOOL v17 = memcmp(*(const void **)a1, a2, *((void *)a1 + 1)) == 0;
    }
    else if (a1[23])
    {
      uint64_t v8 = v4 - 1;
      char v9 = a1;
      do
      {
        int v11 = *v9++;
        int v10 = v11;
        int v13 = *(unsigned __int8 *)a2;
        a2 = (float *)((char *)a2 + 1);
        int v12 = v13;
        BOOL v15 = v8-- != 0;
        BOOL v16 = v10 == v12;
        BOOL v17 = v10 == v12;
      }
      while (v16 && v15);
    }
    else
    {
      BOOL v17 = 1;
    }
  }
  else
  {
    BOOL v17 = 0;
  }
  return *((float *)a1 + 6) == v2[6] && v17;
}

uint64_t std::vector<unsigned int,geo::StdAllocator<unsigned int,grl::Allocator>>::__init_with_size[abi:nn180100]<unsigned int *,unsigned int *>(uint64_t result, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  if (a4)
  {
    uint64_t v6 = result;
    uint64_t result = std::vector<unsigned int,geo::StdAllocator<unsigned int,grl::Allocator>>::__vallocate[abi:nn180100](result, a4);
    int v7 = *(_DWORD **)(v6 + 8);
    while (a2 != a3)
    {
      if (v7) {
        _DWORD *v7 = *a2;
      }
      ++a2;
      ++v7;
    }
    *(void *)(v6 + 8) = v7;
  }
  return result;
}

uint64_t std::vector<unsigned int,geo::StdAllocator<unsigned int,grl::Allocator>>::__vallocate[abi:nn180100](uint64_t a1, unint64_t a2)
{
  if (a2 >> 62) {
    abort();
  }
  uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 4 * a2, 4);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 16) = result + 4 * a2;
  return result;
}

uint64_t std::__shared_ptr_emplace<esl::QuartzImage>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void esl::QuartzImage::~QuartzImage(esl::QuartzImage *this)
{
  *(void *)this = &unk_1EF554B38;
  uint64_t v2 = (CGImage *)*((void *)this + 2);
  if (v2)
  {
    CGImageRelease(v2);
    *((void *)this + 2) = 0;
  }
  unint64_t v3 = (void *)*((void *)this + 3);
  if (v3)
  {
    free(v3);
    *((void *)this + 3) = 0;
    *((void *)this + 4) = 0;
  }
}

{
  uint64_t vars8;

  esl::QuartzImage::~QuartzImage(this);
  JUMPOUT(0x1A6239270);
}

uint64_t **std::vector<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100](uint64_t **result)
{
  uint64_t v1 = *result;
  uint64_t v2 = **result;
  if (v2)
  {
    uint64_t v3 = v1[1];
    uint64_t v4 = *result;
    if (v3 != v2)
    {
      uint64_t v5 = result;
      do
      {
        if (*(char *)(v3 - 9) < 0) {
          operator delete(*(void **)(v3 - 32));
        }
        v3 -= 32;
      }
      while (v3 != v2);
      uint64_t v4 = *v5;
    }
    v1[1] = v2;
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)v4[3] + 40);
    return (uint64_t **)v6();
  }
  return result;
}

uint64_t geo::LRUPolicy<unsigned short,std::shared_ptr<esl::QuartzImage>,std::hash<unsigned short>>::get(uint64_t a1, void *a2, unsigned __int16 *a3)
{
  uint64_t v4 = std::__hash_table<std::__hash_value_type<unsigned short,std::__list_iterator<std::pair<unsigned short,std::shared_ptr<esl::QuartzImage>>,void *>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,std::__list_iterator<std::pair<unsigned short,std::shared_ptr<esl::QuartzImage>>,void *>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,std::__list_iterator<std::pair<unsigned short,std::shared_ptr<esl::QuartzImage>>,void *>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,std::__list_iterator<std::pair<unsigned short,std::shared_ptr<esl::QuartzImage>>,void *>>>>::find<unsigned short>(a2, a3);
  if (v4)
  {
    uint64_t v5 = *(uint64_t **)(a1 + 8);
    uint64_t v6 = v4[3];
    if (v5 == v6) {
      return *(void *)(a1 + 8);
    }
    int v7 = (uint64_t *)v6[1];
    if (v7 == v5)
    {
      return *(void *)(a1 + 8);
    }
    else
    {
      uint64_t v8 = *v6;
      *(void *)(v8 + 8) = v7;
      *(void *)v6[1] = v8;
      uint64_t v9 = *v5;
      *(void *)(v9 + 8) = v6;
      uint64_t *v6 = v9;
      uint64_t *v5 = (uint64_t)v6;
      v6[1] = (uint64_t)v5;
      return *(void *)(a1 + 8);
    }
  }
  return a1;
}

uint64_t **std::__hash_table<std::__hash_value_type<unsigned short,std::__list_iterator<std::pair<unsigned short,std::shared_ptr<esl::QuartzImage>>,void *>>,std::__unordered_map_hasher<unsigned short,std::__hash_value_type<unsigned short,std::__list_iterator<std::pair<unsigned short,std::shared_ptr<esl::QuartzImage>>,void *>>,std::hash<unsigned short>,std::equal_to<unsigned short>,true>,std::__unordered_map_equal<unsigned short,std::__hash_value_type<unsigned short,std::__list_iterator<std::pair<unsigned short,std::shared_ptr<esl::QuartzImage>>,void *>>,std::equal_to<unsigned short>,std::hash<unsigned short>,true>,std::allocator<std::__hash_value_type<unsigned short,std::__list_iterator<std::pair<unsigned short,std::shared_ptr<esl::QuartzImage>>,void *>>>>::find<unsigned short>(void *a1, unsigned __int16 *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = *a2;
  uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    unint64_t v5 = *a2;
    if (*(void *)&v2 <= v3) {
      unint64_t v5 = v3 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v5 = (v2.i32[0] - 1) & v3;
  }
  uint64_t v6 = *(uint64_t ****)(*a1 + 8 * v5);
  if (!v6) {
    return 0;
  }
  for (uint64_t result = *v6; result; uint64_t result = (uint64_t **)*result)
  {
    unint64_t v8 = (unint64_t)result[1];
    if (v8 == v3)
    {
      if (*((unsigned __int16 *)result + 8) == v3) {
        return result;
      }
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(void *)&v2) {
          v8 %= *(void *)&v2;
        }
      }
      else
      {
        v8 &= *(void *)&v2 - 1;
      }
      if (v8 != v5) {
        return 0;
      }
    }
  }
  return result;
}

uint64_t grl::codec::IconMapPack::regionsForIconID@<X0>(grl::codec::IconMapPack *this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  uint8x8_t v4 = (char *)*((void *)this + 42);
  if (!v4) {
    goto LABEL_12;
  }
  unsigned int v5 = *a2;
  uint64_t v6 = (char *)this + 336;
  do
  {
    unsigned int v7 = *((_DWORD *)v4 + 8);
    BOOL v8 = v7 >= v5;
    if (v7 >= v5) {
      uint64_t v9 = (char **)v4;
    }
    else {
      uint64_t v9 = (char **)(v4 + 8);
    }
    if (v8) {
      uint64_t v6 = v4;
    }
    uint8x8_t v4 = *v9;
  }
  while (*v9);
  if (v6 != (char *)this + 336 && v5 >= *((_DWORD *)v6 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    uint64_t v11 = *((void *)v6 + 8);
    a3[2] = 0;
    a3[3] = v11;
    int v12 = (_DWORD *)*((void *)v6 + 5);
    int v13 = (_DWORD *)*((void *)v6 + 6);
    return std::vector<unsigned int,geo::StdAllocator<unsigned int,grl::Allocator>>::__init_with_size[abi:nn180100]<unsigned int *,unsigned int *>((uint64_t)a3, v12, v13, v13 - v12);
  }
  else
  {
LABEL_12:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    uint64_t result = grl::Allocator::instance(this);
    a3[3] = result;
  }
  return result;
}

uint64_t std::__split_buffer<std::pair<std::string,float>,geo::StdAllocator<std::pair<std::string,float>,grl::Allocator> &>::~__split_buffer(uint64_t a1)
{
  unint64_t v3 = *(void ***)(a1 + 8);
  int8x8_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint8x8_t v4 = v2 - 4;
      *(void *)(a1 + 16) = v2 - 4;
      if (*((char *)v2 - 9) < 0)
      {
        operator delete(*v4);
        uint8x8_t v4 = *(void ***)(a1 + 16);
      }
      int8x8_t v2 = v4;
    }
    while (v4 != v3);
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

void grl::codec::IconMapPack::regionNameForID(grl::codec::IconMapPack *this@<X0>, unsigned int *a2@<X1>, std::string *a3@<X8>)
{
  unint64_t v3 = (char *)*((void *)this + 38);
  if (!v3) {
    goto LABEL_12;
  }
  unsigned int v4 = *a2;
  unsigned int v5 = (char *)this + 304;
  do
  {
    unsigned int v6 = *((_DWORD *)v3 + 8);
    BOOL v7 = v6 >= v4;
    if (v6 >= v4) {
      BOOL v8 = (char **)v3;
    }
    else {
      BOOL v8 = (char **)(v3 + 8);
    }
    if (v7) {
      unsigned int v5 = v3;
    }
    unint64_t v3 = *v8;
  }
  while (*v8);
  if (v5 != (char *)this + 304 && v4 >= *((_DWORD *)v5 + 8))
  {
    if (v5[63] < 0)
    {
      std::string::__init_copy_ctor_external(a3, *((const std::string::value_type **)v5 + 5), *((void *)v5 + 6));
    }
    else
    {
      long long v9 = *(_OWORD *)(v5 + 40);
      a3->__r_.__value_.__r.__words[2] = *((void *)v5 + 7);
      *(_OWORD *)&a3->__r_.__value_.__l.__data_ = v9;
    }
  }
  else
  {
LABEL_12:
    std::string::basic_string[abi:nn180100]<0>(a3, "Default");
  }
}

void grl::codec::IconData::alternativeTextFamily(grl::codec::IconData *this@<X0>, const grl::IconModifiers *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v4 = (void *)*((void *)a2 + 11);
  unsigned int v5 = (char *)a2 + 96;
  if (v4 == (void *)((char *)a2 + 96))
  {
LABEL_12:
    *(unsigned char *)a3 = 0;
  }
  else
  {
    while (1)
    {
      grl::codec::IconData::infoLayer(this, a2, (uint64_t)v13);
      unint64_t v8 = *((char *)v4 + 63) < 0 ? v4[6] : *((unsigned __int8 *)v4 + 63);
      if (v8 > v13[1]) {
        break;
      }
      long long v9 = (char *)v4[1];
      if (v9)
      {
        do
        {
          int v10 = v9;
          long long v9 = *(char **)v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          int v10 = (char *)v4[2];
          BOOL v11 = *(void *)v10 == (void)v4;
          unsigned int v4 = v10;
        }
        while (!v11);
      }
      unsigned int v4 = v10;
      if (v10 == v5) {
        goto LABEL_12;
      }
    }
    int v12 = v13[0];
    *(unsigned char *)a3 = 1;
    *(_DWORD *)(a3 + 4) = v12;
  }
}

uint64_t grl::ImageLayerRenderer::ImageLayerRenderer(uint64_t a1, uint64_t a2, void *a3)
{
  *(_WORD *)(a1 + 8) = 2;
  *(unsigned char *)(a1 + 10) = 1;
  *(void *)a1 = &unk_1EF567160;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  uint64_t v6 = *(void *)(a2 + 24);
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 40) = v6;
  std::vector<grl::LayerStyle,geo::StdAllocator<grl::LayerStyle,grl::Allocator>>::__init_with_size[abi:nn180100]<grl::LayerStyle*,grl::LayerStyle*>(a1 + 16, *(unsigned char **)a2, *(unsigned char **)(a2 + 8), *(void *)(a2 + 8) - *(void *)a2);
  *(_WORD *)(a1 + 48) = *(_WORD *)(a2 + 32);
  *(_DWORD *)(a1 + 50) = *(_DWORD *)(a2 + 34);
  long long v7 = *(_OWORD *)(a2 + 38);
  *(_WORD *)(a1 + 70) = *(_WORD *)(a2 + 54);
  *(_OWORD *)(a1 + 54) = v7;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 56);
  *(_DWORD *)(a1 + 76) = *(_DWORD *)(a2 + 60);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 64);
  int v8 = *(_DWORD *)(a2 + 68);
  *(unsigned char *)(a1 + 88) = *(unsigned char *)(a2 + 72);
  *(_DWORD *)(a1 + 84) = v8;
  *(_DWORD *)(a1 + 89) = *(_DWORD *)(a2 + 73);
  long long v9 = *(_OWORD *)(a2 + 80);
  long long v10 = *(_OWORD *)(a2 + 96);
  *(void *)(a1 + 128) = *(void *)(a2 + 112);
  *(_OWORD *)(a1 + 96) = v9;
  *(_OWORD *)(a1 + 112) = v10;
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a2 + 120);
  long long v11 = *(_OWORD *)(a2 + 124);
  *(_OWORD *)(a1 + 150) = *(_OWORD *)(a2 + 134);
  *(_OWORD *)(a1 + 140) = v11;
  *(unsigned char *)(a1 + 168) = 0;
  *(void *)(a1 + 272) = *a3;
  std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::__value_func[abi:nn180100](a1 + 280, (uint64_t)(a3 + 1));
  return a1;
}

uint64_t grl::codec::IconMapPack::regionsForCountryCode@<X0>(grl::codec::IconMapPack *this@<X0>, unsigned int *a2@<X1>, void *a3@<X8>)
{
  unsigned int v4 = (char *)*((void *)this + 46);
  if (!v4) {
    goto LABEL_12;
  }
  unsigned int v5 = *a2;
  uint64_t v6 = (char *)this + 368;
  do
  {
    unsigned int v7 = *((_DWORD *)v4 + 8);
    BOOL v8 = v7 >= v5;
    if (v7 >= v5) {
      long long v9 = (char **)v4;
    }
    else {
      long long v9 = (char **)(v4 + 8);
    }
    if (v8) {
      uint64_t v6 = v4;
    }
    unsigned int v4 = *v9;
  }
  while (*v9);
  if (v6 != (char *)this + 368 && v5 >= *((_DWORD *)v6 + 8))
  {
    *a3 = 0;
    a3[1] = 0;
    uint64_t v11 = *((void *)v6 + 8);
    a3[2] = 0;
    a3[3] = v11;
    int v12 = (_DWORD *)*((void *)v6 + 5);
    int v13 = (_DWORD *)*((void *)v6 + 6);
    return std::vector<unsigned int,geo::StdAllocator<unsigned int,grl::Allocator>>::__init_with_size[abi:nn180100]<unsigned int *,unsigned int *>((uint64_t)a3, v12, v13, v13 - v12);
  }
  else
  {
LABEL_12:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    uint64_t result = grl::Allocator::instance(this);
    a3[3] = result;
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<esl::QuartzContext>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void esl::QuartzContext::~QuartzContext(esl::QuartzContext *this)
{
  *(void *)this = &unk_1EF554BE0;
  int8x8_t v2 = (CGContext *)*((void *)this + 1);
  if (v2)
  {
    CGContextRelease(v2);
    *((void *)this + 1) = 0;
  }
}

{
  uint64_t vars8;

  esl::QuartzContext::~QuartzContext(this);
  JUMPOUT(0x1A6239270);
}

uint64_t std::__shared_ptr_emplace<esl::QuartzPath>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void esl::QuartzPath::~QuartzPath(esl::QuartzPath *this)
{
  *(void *)this = &unk_1EF554A58;
  int8x8_t v2 = (const CGPath *)*((void *)this + 1);
  if (v2)
  {
    CGPathRelease(v2);
    *((void *)this + 1) = 0;
  }
}

{
  uint64_t vars8;

  esl::QuartzPath::~QuartzPath(this);
  JUMPOUT(0x1A6239270);
}

esl::QuartzImage *esl::QuartzImage::QuartzImage(esl::QuartzImage *this, const unsigned __int8 *a2, CFIndex a3)
{
  *((void *)this + 2) = 0;
  unsigned int v4 = (CGImageRef *)((char *)this + 16);
  *(void *)this = &unk_1EF554B38;
  *((void *)this + 1) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 4) = 0;
  CFDataRef v5 = CFDataCreate(0, a2, a3);
  uint64_t v6 = CGDataProviderCreateWithCFData(v5);
  *unsigned int v4 = CGImageCreateWithPNGDataProvider(v6, 0, 0, kCGRenderingIntentDefault);
  CGDataProviderRelease(v6);
  CFRelease(v5);
  return this;
}

void sub_1A17FDE08(_Unwind_Exception *a1)
{
  esl::QuartzImage::~QuartzImage(v1);
  _Unwind_Resume(a1);
}

double grl::codec::InfoLayerData::InfoLayerData(grl::codec::InfoLayerData *this)
{
  *(void *)this = 0xFFFFFFFF00000000;
  *((void *)this + 1) = 0xFF000000FF000000;
  *((_DWORD *)this + 4) = 0;
  *(void *)&double result = 0xFF000000FFLL;
  *(void *)((char *)this + 20) = 0xFF000000FFLL;
  *((unsigned char *)this + 28) = -1;
  *((_DWORD *)this + 8) = 1065353216;
  *((_WORD *)this + 18) = 0;
  return result;
}

uint64_t std::__shared_ptr_emplace<std::ifstream>::__on_zero_shared(uint64_t a1)
{
  return (**(uint64_t (***)(void))(a1 + 24))();
}

void *gms::BasicMaterial<ggl::Texture2D>::albedoFactorRGB@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float32x4_t a3@<Q0>, float32x4_t a4@<Q1>)
{
  float v4 = a3.f32[0];
  float v7 = **(float **)(a1 + 48);
  a3.i32[1] = 872415232;
  if ((v7 > 0.00000011921 || (uint64_t v8 = *(void *)(a1 + 16)) == 0) && (v7 < 1.0 || (uint64_t v8 = *(void *)(a1 + 32)) == 0))
  {
    float v14 = v7;
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11)
    {
      (*(void (**)(char *__return_ptr, float32_t))(*(void *)v11 + 648))(v18, a3.f32[0]);
      double result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      v18[0] = 0;
      double result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        double result = (*(void *(**)(char *__return_ptr, float))(*result + 648))(v15, v4);
        if (v18[0])
        {
LABEL_11:
          if (v15[0])
          {
            *(unsigned char *)a2 = 1;
            a3.i64[0] = v19;
            a3.i32[2] = v20;
            a4.i64[0] = v16;
            a4.i32[2] = v17;
            float32x4_t v12 = vmlaq_n_f32(a3, vsubq_f32(a4, a3), v14);
            *(_DWORD *)(a2 + 12) = v12.i32[2];
            *(void *)(a2 + 4) = v12.i64[0];
            return result;
          }
          *(void *)(a2 + 4) = v19;
          unsigned __int32 v13 = v20;
LABEL_18:
          *(_DWORD *)(a2 + 12) = v13;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!v15[0]) {
          return result;
        }
        *(void *)(a2 + 4) = v16;
        unsigned __int32 v13 = v17;
        goto LABEL_18;
      }
    }
    v15[0] = 0;
    if (v18[0]) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  long long v9 = *(uint64_t (**)(__n128))(*(void *)v8 + 648);
  return (void *)v9((__n128)a3);
}

float md::MultipleShieldLabelPart::hikerWidth(uint64_t a1, uint64_t a2)
{
  int8x8_t v2 = *(void **)(a1 + 576);
  unint64_t v3 = *(void **)(a1 + 584);
  if (v2 == v3) {
    return 0.0;
  }
  unsigned int v6 = 0;
  float v7 = 0.0;
  do
  {
    uint64_t v8 = *v2;
    if ((*(unsigned int (**)(void, uint64_t))(*(void *)*v2 + 736))(*v2, a2))
    {
      ++v6;
      (*(void (**)(uint64_t, uint64_t))(*(void *)v8 + 592))(v8, a2);
      float v7 = (*(float (**)(uint64_t, uint64_t))(*(void *)v8 + 336))(v8, a2) + v7;
    }
    ++v2;
  }
  while (v2 != v3);
  if (v6 > 1)
  {
    uint64_t v9 = a1 + 632;
    if (a2) {
      uint64_t v9 = a1 + 664;
    }
    return v7 + (float)(*(float *)(v9 + 16) * (float)(v6 - 1));
  }
  return v7;
}

uint64_t md::CaptionedIconLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, float *a3)
{
  uint64_t v6 = *(void *)(a2 + 432);
  int v7 = *(unsigned __int8 *)(v6 + 18);
  if (*(unsigned char *)(a1 + 565) && *(unsigned char *)(a1 + 566)) {
    md::CaptionedIconLabelPart::generateModelMatrix(a1, *(_OWORD **)(a1 + 896), *(_OWORD **)(a1 + 912), v6, (double *)(*(void *)(a1 + 16) + 592), *(float *)(*(void *)(a1 + 32) + 24), *(float *)(*(void *)(a1 + 32) + 20));
  }
  if (!*(unsigned char *)(a1 + 925))
  {
    if (*(unsigned char *)(a1 + 926) && *(unsigned char *)(a1 + 946) != 3)
    {
      unsigned __int32 v20 = **(void ***)(a1 + 576);
      if (*(unsigned char *)(a1 + 927))
      {
        unsigned __int8 v21 = *(unsigned char *)(a1 + 928);
        if (v21)
        {
          if (*(unsigned char *)(a1 + 930)) {
            unsigned __int8 v21 = 2;
          }
          else {
            unsigned __int8 v21 = 1;
          }
        }
      }
      else
      {
        int v29 = *(unsigned __int8 *)(a1 + 848);
        __int32 v30 = (unsigned __int8 *)&horizontalLabelAnchors;
        if (v29 == 4) {
          __int32 v30 = (unsigned __int8 *)&diagonalUpLabelAnchors;
        }
        if (v29 == 8) {
          long long v31 = (unsigned __int8 *)&diagonalDownLabelAnchors;
        }
        else {
          long long v31 = v30;
        }
        int v32 = v31[2 * *(unsigned __int8 *)(a1 + 847)];
        if (v32 == 1) {
          unsigned __int8 v21 = 1;
        }
        else {
          unsigned __int8 v21 = 2 * (v32 == 2);
        }
      }
      uint64_t v33 = v21;
      (*(void (**)(void, void, uint64_t))(*v20 + 352))(**(void **)(a1 + 576), 0, v33);
      (*(void (**)(void *, void, uint64_t))(*v20 + 360))(v20, 0, v33);
      unint64_t v80 = 0;
      (*(void (**)(void *, uint64_t, float *, unint64_t *))(*v20 + 80))(v20, a2, a3, &v80);
      uint64_t v34 = (float *)(v20[3] + 72);
      unint64_t v80 = 0;
      unint64_t v81 = 0;
      float v35 = md::CaptionedIconLabelPart::textOriginOffsetForPosition(a1, 0, *(unsigned __int8 *)(a1 + 847), *(unsigned __int8 *)(a1 + 855), *(unsigned __int8 *)(a1 + 848), (float *)&v80, v34, (uint64_t)v20);
      uint64_t v37 = (float32x2_t *)(a1 + 656);
      *(float *)(a1 + 656) = v35;
      *(float *)(a1 + 660) = v36;
      if (v7)
      {
        float32x2_t v38 = *(float32x2_t *)(v6 + 464);
        float32x2_t v39 = vmul_n_f32(v38, v35);
        float32x2_t v40 = (float32x2_t)vrev64_s32((int32x2_t)vmul_n_f32(v38, v36));
        v38.i32[0] = vsub_f32(v39, v40).u32[0];
        v38.i32[1] = vadd_f32(v39, v40).i32[1];
        float32x2_t *v37 = v38;
      }
      uint64_t v41 = (*(uint64_t (**)(void *, uint64_t, float *, float32x2_t *))(*v20 + 80))(v20, a2, a3, v37);
      if (v41 != 37) {
        return v41;
      }
      int64x2_t v42 = (_DWORD *)(*(uint64_t (**)(void *))(*v20 + 248))(v20);
      *(_DWORD *)(a1 + 152) = *v42;
      *(_DWORD *)(a1 + 156) = v42[1];
      *(_DWORD *)(a1 + 160) = v42[2];
      *(_DWORD *)(a1 + 164) = v42[3];
      float v43 = (*(float (**)(void *))(*v20 + 264))(v20);
      if (v45 < v43 || v46 < v44)
      {
        float v50 = 3.4028e38;
        float v52 = -3.4028e38;
        float v51 = -3.4028e38;
        float v49 = 3.4028e38;
      }
      else
      {
        float v48 = a3[1];
        float v49 = v43 - *a3;
        float v50 = v44 - v48;
        float v51 = v45 - *a3;
        float v52 = v46 - v48;
      }
      *(float *)(a1 + 664) = v49;
      *(float *)(a1 + 668) = v50;
      *(float *)(a1 + 672) = v51;
      *(float *)(a1 + 676) = v52;
      goto LABEL_64;
    }
    return 14;
  }
  if (!*(unsigned char *)(a1 + 926) || *(unsigned char *)(a1 + 946) == 3)
  {
    uint64_t v8 = **(void **)(a1 + 576);
    unint64_t v80 = 0;
    uint64_t v9 = (*(uint64_t (**)(uint64_t, uint64_t, float *, unint64_t *))(*(void *)v8 + 80))(v8, a2, a3, &v80);
    if (v9 != 37) {
      return v9;
    }
    long long v10 = (_DWORD *)(*(uint64_t (**)(uint64_t))(*(void *)v8 + 248))(v8);
    *(_DWORD *)(a1 + 152) = *v10;
    *(_DWORD *)(a1 + 156) = v10[1];
    *(_DWORD *)(a1 + 160) = v10[2];
    *(_DWORD *)(a1 + 164) = v10[3];
    goto LABEL_64;
  }
  uint64_t v11 = *(void *)(a1 + 576);
  unsigned __int32 v13 = *(void **)v11;
  float32x4_t v12 = *(void **)(v11 + 8);
  unint64_t v80 = 0;
  uint64_t v14 = (*(uint64_t (**)(void *, uint64_t, float *, unint64_t *))(*v13 + 80))(v13, a2, a3, &v80);
  uint64_t v9 = v14;
  if (v14 == 37 || v14 == 15)
  {
    int v16 = *(unsigned __int8 *)(a1 + 848);
    if (!*(unsigned char *)(a1 + 925) && *(unsigned char *)(a1 + 927)) {
      goto LABEL_33;
    }
    unsigned __int32 v17 = &horizontalLabelAnchors;
    if (v16 == 4) {
      unsigned __int32 v17 = &diagonalUpLabelAnchors;
    }
    BOOL v18 = (unsigned __int8 *)(v16 == 8 ? &diagonalDownLabelAnchors : v17);
    int v19 = v18[2 * *(unsigned __int8 *)(a1 + 847)];
    if (v19 != 1 && v19 != 2)
    {
      LOBYTE(v19) = *(unsigned char *)(a1 + 927);
      if ((_BYTE)v19)
      {
LABEL_33:
        LOBYTE(v19) = *(unsigned char *)(a1 + 928);
        if ((_BYTE)v19)
        {
          if (*(unsigned char *)(a1 + 930)) {
            LOBYTE(v19) = 2;
          }
          else {
            LOBYTE(v19) = 1;
          }
        }
      }
    }
    uint64_t v22 = v19;
    (*(void (**)(void *, void, uint64_t))(*v12 + 352))(v12, 0, v22);
    (*(void (**)(void *, void, uint64_t))(*v12 + 360))(v12, 0, v22);
    uint64_t v23 = (*(uint64_t (**)(void *, uint64_t, float *, uint64_t))(*v12 + 80))(v12, a2, a3, a1 + 656);
    if (v9 == 37)
    {
      uint64_t v9 = v23;
      if (v23 == 37)
      {
        float v24 = (*(float (**)(void *))(*v13 + 264))(v13);
        if (v26 < v24 || v27 < v25)
        {
          float v61 = 3.4028e38;
          float v63 = -3.4028e38;
          float v62 = -3.4028e38;
          float v60 = 3.4028e38;
        }
        else
        {
          float v59 = a3[1];
          float v60 = v24 - *a3;
          float v61 = v25 - v59;
          float v62 = v26 - *a3;
          float v63 = v27 - v59;
        }
        unint64_t v80 = __PAIR64__(LODWORD(v61), LODWORD(v60));
        uint64_t v9 = 16;
        unint64_t v81 = __PAIR64__(LODWORD(v63), LODWORD(v62));
        if (v62 >= v60 && v63 >= v61)
        {
          uint64_t v64 = (float *)v12[3];
          if (v64[20] >= v64[18] && v64[21] >= v64[19])
          {
            int64x2_t v65 = v64 + 18;
            if (!*(unsigned char *)(a1 + 854))
            {
              char v66 = *(unsigned char *)(a1 + 853);
              if (!v66)
              {
                uint64_t v67 = (float *)v13[3];
                float v68 = v67[20];
                float v69 = v67[18];
                float v70 = 0.0;
                if (v68 >= v69)
                {
                  float v70 = v68 - v69;
                  if (v67[21] < v67[19]) {
                    float v70 = 0.0;
                  }
                }
                if (v70 <= (float)(*(float *)(a2 + 176) * 14.1)) {
                  char v66 = 1;
                }
                else {
                  char v66 = 2;
                }
              }
              *(unsigned char *)(a1 + 854) = v66;
            }
            float v71 = md::CaptionedIconLabelPart::textOriginOffsetForPosition(a1, 0, *(unsigned __int8 *)(a1 + 847), *(unsigned __int8 *)(a1 + 855), *(unsigned __int8 *)(a1 + 848), (float *)&v80, v65, (uint64_t)v12);
            if (v7)
            {
              float v73 = *(float *)(v6 + 464);
              float v74 = *(float *)(v6 + 468);
              float v75 = v74 * v72;
              float v72 = (float)(v73 * v72) + (float)(v74 * v71);
              float v71 = -(float)(v75 - (float)(v73 * v71));
            }
            if (vabds_f32(v71, *(float *)(a1 + 656)) >= 0.1 || vabds_f32(v72, *(float *)(a1 + 660)) >= 0.1)
            {
              *(float *)(a1 + 656) = v71;
              *(float *)(a1 + 660) = v72;
              (*(void (**)(void *, uint64_t, float *, uint64_t))(*v12 + 80))(v12, a2, a3, a1 + 656);
            }
            uint64_t v76 = (int8x16_t *)(*(uint64_t (**)(void *))(*v13 + 248))(v13);
            unint64_t v77 = (int8x16_t *)(*(uint64_t (**)(void *))(*v12 + 248))(v12);
            v78.i64[0] = v77->i64[0];
            v78.i64[1] = v76->i64[1];
            v79.i64[0] = v76->i64[0];
            v79.i64[1] = v77->i64[1];
            *(int8x16_t *)(a1 + 152) = vbslq_s8((int8x16_t)vcgtq_f32(v79, v78), *v77, *v76);
LABEL_64:
            *(float *)(a1 + 280) = *a3;
            *(float *)(a1 + 284) = a3[1];
            *(unsigned char *)(a1 + 959) = *(unsigned char *)(a1 + 960)
                                && *(unsigned char *)(a1 + 926)
                                && *(unsigned char *)(a1 + 946) != 3
                                && ((uint64_t v54 = *(void *)(*(void *)(a1 + 576) + 8 * *(unsigned __int8 *)(a1 + 925)),
                                     float v55 = *(float **)(a2 + 432),
                                     (*(float (**)(uint64_t))(*(void *)v54 + 264))(v54) < v55[284])
                                 || v57 > v55[286]
                                 || v56 < v55[285]
                                 || v58 > v55[287]);
            *(void *)(a1 + 184) = *(void *)(a1 + 896);
            return 37;
          }
          return 14;
        }
      }
    }
  }
  return v9;
}

uint64_t md::IconLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, float32x2_t *a3, float32x2_t *a4)
{
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 344))(a1);
  if (v8 == 37)
  {
    (*(void (**)(uint64_t, void))(*(void *)a1 + 592))(a1, 0);
    float v9 = *(float *)(*(void *)(a1 + 32) + 20);
    *(float *)(a1 + 176) = v9;
    *(_DWORD *)(a1 + 112) = a3->i32[0];
    *(_DWORD *)(a1 + 116) = a3->i32[1];
    *(unsigned char *)(a1 + 270) = fabsf(v9 + -1.0) > 0.000001;
    uint64_t v10 = *(void *)(a2 + 432);
    float v11 = *(float *)(v10 + 464);
    *(float *)(a1 + 296) = v11;
    float v12 = *(float *)(v10 + 468);
    *(float *)(a1 + 300) = v12;
    float v13 = *(float *)(a1 + 288);
    float v14 = v13 * v12;
    float v15 = *(float *)(a1 + 292);
    *(float *)&double v16 = -(float)((float)(v15 * v12) - (float)(v13 * v11));
    *(_DWORD *)(a1 + 88) = LODWORD(v16);
    *(float *)(a1 + 92) = v14 + (float)(v15 * v11);
    *(unsigned char *)(a1 + 268) = fabsf(*(float *)&v16 + -1.0) > 0.000001;
    *(_DWORD *)(a1 + 304) = a4->i32[0];
    *(_DWORD *)(a1 + 308) = a4->i32[1];
    double v17 = *(double *)a4;
    double v18 = COERCE_DOUBLE(vadd_f32(*a4, *a3));
    *(double *)(a1 + 280) = v18;
    *(double *)(a1 + 104) = v18;
    md::CollisionObject::setupShapeData(a1 + 72, v18, v17, v16);
    if (*(unsigned char *)(a1 + 565))
    {
      if (*(unsigned char *)(a1 + 566))
      {
        float v25 = *(long long **)(a1 + 736);
        if (!v25) {
          operator new();
        }
        v19.n128_u64[0] = *(void *)(a1 + 88);
        v20.i32[0] = 1.0;
        md::IconLabelPart::generateModelMatrix(v25, *(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 268), (float32x2_t *)(a1 + 304), 0.0, v19, v20, *(float *)(*(void *)(a1 + 32) + 20), v21, v22, v23, v24);
        *(void *)(a1 + 184) = *(void *)(a1 + 736);
      }
    }
  }
  return v8;
}

uint64_t md::IconLabelPart::checkResourcesReady(md::IconLabelPart *this, LabelManager *a2)
{
  uint64_t v2 = *((void *)this + 80);
  if (!v2) {
    return 37;
  }
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v2 + 142));
  if ((v3 & 1) == 0) {
    return 15;
  }
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(*((void *)this + 80) + 143));
  if (v5) {
    return 37;
  }
  else {
    return 16;
  }
}

void md::IconLabelPart::updateCollisionObject(uint64_t a1, int a2)
{
  if (!a2)
  {
    uint64_t v3 = a1 + 640;
    uint64_t v4 = *(void *)(a1 + 640);
    if (!v4) {
      goto LABEL_17;
    }
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 143));
    if ((v5 & 1) == 0) {
      return;
    }
    if (!*(void *)v3 || (unsigned __int8 v6 = atomic_load((unsigned __int8 *)(*(void *)v3 + 143)), (v6 & 1) != 0))
    {
LABEL_17:
      if (*(unsigned char *)(a1 + 629))
      {
        *(unsigned char *)(a1 + 629) = 0;
        double v7 = (*(double (**)(uint64_t, void))(*(void *)a1 + 936))(a1, *(void *)(a1 + 640));
        *(float *)&double v7 = 0.5 - (float)(fminf(v10 - v9, v8 - *(float *)&v7) * 0.5);
        *(float32x2_t *)(a1 + 168) = vmaxnm_f32(*(float32x2_t *)(a1 + 620), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v7, 0));
        *(unsigned char *)(a1 + 271) = *(unsigned char *)(a1 + 631);
        *(unsigned char *)(a1 + 272) = *(unsigned char *)(a1 + 630);
      }
    }
    if (*(unsigned char *)(a1 + 628) || *(float *)(a1 + 80) < *(float *)(a1 + 72) || *(float *)(a1 + 84) < *(float *)(a1 + 76))
    {
      *(unsigned char *)(a1 + 628) = 0;
      float v11 = *(void (**)(uint64_t, void, uint64_t, uint64_t))(*(void *)a1 + 912);
      v11(a1, 0, v3, a1 + 72);
    }
  }
}

uint64_t md::PointIconLabelPart::layoutForStaging(uint64_t a1, uint64_t a2, float32x2_t *a3, float32x2_t *a4)
{
  uint64_t v8 = *(void *)(a1 + 832);
  if (v8) {
    (*(void (**)(uint64_t, uint64_t, float32x2_t *, float32x2_t *))(*(void *)v8 + 80))(v8, a2, a3, a4);
  }
  return md::IconLabelPart::layoutForStaging(a1, a2, a3, a4);
}

uint64_t md::AnimatedCrossFadeLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = a1 + 640;
  if ((*(unsigned int (**)(void))(***(void ***)(a1 + 576) + 88))(**(void **)(a1 + 576))) {
    char v10 = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(***(void ***)(a1 + 576) + 120))(**(void **)(a1 + 576), a2, v9, a4, a5);
  }
  else {
    char v10 = 32;
  }
  *(unsigned char *)(a1 + 636) = v10;
  if ((*(unsigned int (**)(void))(**(void **)(*(void *)(a1 + 576) + 8) + 88))(*(void *)(*(void *)(a1 + 576) + 8))) {
    LODWORD(result) = (*(uint64_t (**)(void, uint64_t, uint64_t, uint64_t, uint64_t))(**(void **)(*(void *)(a1 + 576) + 8)
  }
                                                                                            + 120))(*(void *)(*(void *)(a1 + 576) + 8), a2, v9, a4, a5);
  else {
    LODWORD(result) = 32;
  }
  *(unsigned char *)(a1 + 637) = result;
  if (*(unsigned char *)(a1 + 636) == 37) {
    return 37;
  }
  else {
    return result;
  }
}

uint64_t md::CaptionedIconLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4)
{
  uint64_t v8 = (float64x2_t *)(a2 + 440);
  int v9 = *(unsigned __int8 *)(a2 + 458);
  float32x2_t v81 = 0;
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(void *)(v10 + 1184);
  if (!v11) {
    goto LABEL_45;
  }
  float v12 = *(char **)(v11 + 24);
  float v13 = *(char **)(v11 + 32);
  if (0x8E38E38E38E38E39 * ((v13 - v12) >> 4) <= *(unsigned __int8 *)(a1 + 564))
  {
    int v14 = *(unsigned __int8 *)(v11 + 89);
    if (v12 == v13 || v14 == 0) {
      goto LABEL_45;
    }
  }
  else
  {
    v12 += 144 * *(unsigned __int8 *)(a1 + 564);
  }
  if (v12)
  {
    if (*(unsigned char *)(v10 + 1104))
    {
      unsigned __int8 v16 = atomic_load((unsigned __int8 *)(v10 + 1240));
      if ((v16 & 1) == 0)
      {
        uint64_t v17 = *(void *)v12;
        uint64_t v18 = *((void *)v12 + 1);
        if (v17 != v18)
        {
          uint64_t v19 = v17;
          while (*(unsigned char *)(v19 + 16) != 1)
          {
            v19 += 24;
            if (v19 == v18) {
              goto LABEL_45;
            }
          }
          while (*(unsigned char *)(v17 + 16) != 1)
          {
            v17 += 24;
            if (v17 == v18)
            {
              float v20 = 1.0;
              goto LABEL_21;
            }
          }
          float v20 = *(float *)(v17 + 8)
              + (float)(*(float *)(**(void **)v17 + 32 * *(unsigned int *)(*(void *)v17 + 32) + 8)
                      * (float)(*(float *)(v17 + 12) - *(float *)(v17 + 8)));
          if (v20 == 0.0) {
            goto LABEL_45;
          }
LABEL_21:
          float v80 = v20;
          uint64_t v86 = 0;
          long long v84 = 0u;
          long long v85 = 0u;
          *(_DWORD *)long long v87 = 2139095039;
          *(_WORD *)&v87[4] = 0;
          v87[6] = 0;
          uint64_t v21 = (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 16) + 8) + 72))(*(void *)(*(void *)(a1 + 16) + 8));
          if (v21)
          {
            uint64_t v22 = v21;
            double v23 = *(std::__shared_weak_count **)(v21 + 304);
            if (v23)
            {
              if (v23->__shared_owners_ != -1)
              {
                float32x4_t v24 = std::__shared_weak_count::lock(v23);
                float v25 = v24;
                if (v24) {
                  BOOL v26 = *(void *)(v22 + 296) == 0;
                }
                else {
                  BOOL v26 = 1;
                }
                if (v26)
                {
                  if (!v24) {
                    goto LABEL_45;
                  }
                }
                else
                {
                  uint64_t v27 = *(void *)(v22 + 288);
                  if (v27)
                  {
                    uint64_t v28 = *(void *)(v27 + 72);
                    if (v28)
                    {
                      long long v29 = *(_OWORD *)(v28 + 32);
                      long long v84 = *(_OWORD *)(v28 + 16);
                      long long v85 = v29;
                      uint64_t v86 = *(void *)(v28 + 48);
                      *(_DWORD *)&v87[3] = *(_DWORD *)(v28 + 59);
                      *(_DWORD *)long long v87 = *(_DWORD *)(v28 + 56);
                      float v30 = *(float *)(v28 + 64);
                      int v31 = *(unsigned __int8 *)(v28 + 68);
                      if (atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
LABEL_38:
                        uint64_t v33 = *(void *)(a1 + 16);
                        uint64_t v34 = *(void *)(a2 + 232);
                        double v35 = *(double *)(v34 + 56);
                        double v36 = *(double *)(v33 + 984) / v35;
                        if (*(unsigned char *)(v22 + 237) || *(void *)(v22 + 248))
                        {
                          double v37 = v36 * *(float *)(a2 + 488);
                          float v38 = *(float *)(v33 + 1056);
                        }
                        else
                        {
                          if (*(unsigned char *)(v34 + 30))
                          {
                            double v37 = v36 * *(float *)(a2 + 488);
                          }
                          else
                          {
                            float v79 = v36;
                            if (*(float *)v87 != 3.4028e38) {
                              float v79 = *(float *)v87;
                            }
                            double v37 = (float)(v79 * *(float *)(a2 + 488));
                          }
                          float v38 = 0.0;
                          if (v31) {
                            float v38 = v30;
                          }
                        }
                        double v39 = v37 + (float)(*(float *)(a2 + 1624) * v38);
                        if (*(unsigned char *)(a2 + 448))
                        {
                          double v40 = v39 * v35;
                          double v41 = *(double *)md::LabelPoint::mercatorPoint((md::LabelPoint *)&v84);
                          double v42 = *(double *)(md::LabelPoint::mercatorPoint((md::LabelPoint *)&v84) + 8);
                        }
                        else
                        {
                          md::LabelPoint::geocentricPoint((md::LabelPoint *)&v84);
                          double v43 = md::LabelPoint::geocentricNormal((md::LabelPoint *)&v84);
                          double v41 = *(double *)&v84 + v43 * v39;
                          double v42 = *((double *)&v84 + 1) + v44 * v39;
                          double v40 = *(double *)&v85 + v45 * v39;
                        }
                        v83[0] = v41;
                        v83[1] = v42;
                        v83[2] = v40;
                        md::LabelLayoutContext::projectPointToPixel(v8, v83, &v82);
                        float32x2_t v81 = vmla_n_f32(v81, vsub_f32(v82, *a4), v80);
                        goto LABEL_45;
                      }
                      int v32 = 1;
LABEL_37:
                      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
                      std::__shared_weak_count::__release_weak(v25);
                      if (!v32) {
                        goto LABEL_45;
                      }
                      goto LABEL_38;
                    }
                  }
                }
                if (atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                  goto LABEL_45;
                }
                int v32 = 0;
                int v31 = 0;
                float v30 = 0.0;
                goto LABEL_37;
              }
            }
          }
        }
      }
    }
  }
LABEL_45:
  if (*(unsigned char *)(a1 + 565)) {
    md::CaptionedIconLabelPart::generateModelMatrix(a1, *(_OWORD **)(a1 + 888), *(_OWORD **)(a1 + 904), (uint64_t)v8, (double *)(*(void *)(a1 + 16) + 408), *(float *)(*(void *)(a1 + 32) + 72), *(float *)(*(void *)(a1 + 32) + 68));
  }
  if (*(unsigned char *)(a1 + 925))
  {
    if (!*(unsigned char *)(a1 + 926) || *(unsigned char *)(a1 + 732))
    {
      float v46 = **(void ***)(a1 + 576);
      uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t, float32x2_t *, float32x2_t *))(*v46 + 120))(v46, a2, a3, a4, &v81);
      goto LABEL_51;
    }
    float v49 = *(void **)(a1 + 576);
    uint64_t v51 = *v49;
    float v50 = (void *)v49[1];
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, float32x2_t *, float32x2_t *))(*(void *)*v49 + 120))(*v49, a2, a3, a4, &v81);
    if (result != 37) {
      return result;
    }
    *(float32x2_t *)&long long v84 = vadd_f32(*(float32x2_t *)(a1 + 708), v81);
    uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t, float32x2_t *, long long *))(*v50 + 120))(v50, a2, a3, a4, &v84);
    if (result != 37) {
      return result;
    }
    float v52 = *(float **)(v51 + 24);
    float v53 = v52[96];
    float v54 = v52[94];
    if (v53 >= v54 && (float v55 = v52[97], v56 = v52[95], v55 >= v56))
    {
      float v68 = a4->f32[1];
      float v60 = v54 - a4->f32[0];
      float v57 = v56 - v68;
      float v59 = v53 - a4->f32[0];
      float v58 = v55 - v68;
    }
    else
    {
      float v57 = 3.4028e38;
      float v58 = -3.4028e38;
      float v59 = -3.4028e38;
      float v60 = 3.4028e38;
    }
    *(void *)&long long v84 = __PAIR64__(LODWORD(v57), LODWORD(v60));
    uint64_t result = 16;
    *((void *)&v84 + 1) = __PAIR64__(LODWORD(v58), LODWORD(v59));
    if (v59 < v60 || v58 < v57) {
      return result;
    }
    float v69 = (float *)v50[3];
    if (v69[80] >= v69[78] && v69[81] >= v69[79])
    {
      float v70 = md::CaptionedIconLabelPart::textOriginOffsetForPosition(a1, 1, *(unsigned __int8 *)(a1 + 847), *(unsigned __int8 *)(a1 + 855), *(unsigned __int8 *)(a1 + 848), (float *)&v84, v69 + 78, (uint64_t)v50);
      if (v9)
      {
        float v72 = *(float *)(a2 + 904);
        float v73 = *(float *)(a2 + 908);
        float v74 = v73 * v71;
        float v71 = (float)(v72 * v71) + (float)(v73 * v70);
        float v70 = -(float)(v74 - (float)(v72 * v70));
      }
      if (vabds_f32(v70, *(float *)(a1 + 708)) >= 0.1 || vabds_f32(v71, *(float *)(a1 + 712)) >= 0.1)
      {
        *(float *)(a1 + 708) = v70;
        *(float *)(a1 + 712) = v71;
        *(float *)uint64_t v83 = v81.f32[0] + v70;
        *((float *)v83 + 1) = v81.f32[1] + v71;
        (*(void (**)(void *, uint64_t, uint64_t, float32x2_t *, double *))(*v50 + 120))(v50, a2, a3, a4, v83);
      }
      float v75 = (int8x16_t *)(*(void *)(v51 + 24) + 392);
      uint64_t v76 = (int8x16_t *)(v50[3] + 392);
      v77.i64[0] = v76->i64[0];
      v77.i64[1] = *(void *)(*(void *)(v51 + 24) + 400);
      v78.i64[0] = v75->i64[0];
      v78.i64[1] = *(void *)(v50[3] + 400);
      *(int8x16_t *)(a1 + 392) = vbslq_s8((int8x16_t)vcgtq_f32(v78, v77), *v76, *v75);
      goto LABEL_53;
    }
    return 14;
  }
  if (!*(unsigned char *)(a1 + 926) || *(unsigned char *)(a1 + 732)) {
    return 14;
  }
  float v46 = **(void ***)(a1 + 576);
  *(void *)&long long v84 = 0;
  (*(void (**)(void *, uint64_t, uint64_t, float32x2_t *, long long *))(*v46 + 120))(v46, a2, a3, a4, &v84);
  float v61 = (float *)(v46[3] + 312);
  long long v84 = 0uLL;
  float v62 = md::CaptionedIconLabelPart::textOriginOffsetForPosition(a1, 1, *(unsigned __int8 *)(a1 + 847), *(unsigned __int8 *)(a1 + 855), *(unsigned __int8 *)(a1 + 848), (float *)&v84, v61, (uint64_t)v46);
  float32x2_t v64 = (float32x2_t)__PAIR64__(v63, LODWORD(v62));
  if (v9)
  {
    float32x2_t v65 = *(float32x2_t *)(a2 + 904);
    float32x2_t v66 = vmul_n_f32(v65, v62);
    float32x2_t v67 = (float32x2_t)vrev64_s32((int32x2_t)vmul_lane_f32(v65, v64, 1));
    v64.i32[0] = vsub_f32(v66, v67).u32[0];
    v64.i32[1] = vadd_f32(v66, v67).i32[1];
  }
  *(float32x2_t *)&v83[0] = vadd_f32(v81, v64);
  uint64_t result = (*(uint64_t (**)(void *, uint64_t, uint64_t, float32x2_t *, double *))(*v46 + 120))(v46, a2, a3, a4, v83);
LABEL_51:
  if (result == 37)
  {
    float v48 = (_DWORD *)v46[3];
    *(_DWORD *)(a1 + 392) = v48[98];
    *(_DWORD *)(a1 + 396) = v48[99];
    *(_DWORD *)(a1 + 400) = v48[100];
    *(_DWORD *)(a1 + 404) = v48[101];
LABEL_53:
    *(_DWORD *)(a1 + 520) = a4->i32[0];
    *(_DWORD *)(a1 + 524) = a4->i32[1];
    *(void *)(a1 + 424) = *(void *)(a1 + 888);
    return 37;
  }
  return result;
}

uint64_t md::PointIconLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5, double a6, double a7, double a8)
{
  uint64_t v13 = *(void *)(a1 + 832);
  if (v13) {
    a6 = (*(double (**)(uint64_t, uint64_t, uint64_t, float32x2_t *, float32x2_t *))(*(void *)v13 + 120))(v13, a2, a3, a4, a5);
  }
  md::IconLabelPart::layoutForDisplay(a1, a2, a3, a4, a5, a6, a7, a8);
  return 37;
}

uint64_t md::IconLabelPart::layoutForDisplay(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, float32x2_t *a5, double a6, double a7, double a8)
{
  *(_DWORD *)(a1 + 544) = a5->i32[0];
  *(_DWORD *)(a1 + 548) = a5->i32[1];
  if (*(unsigned char *)(a1 + 756)) {
    *(unsigned char *)(a1 + 756) = 0;
  }
  *(void *)(a1 + 744) = 1065353216;
  uint64_t v12 = *(void *)(a1 + 16);
  if (v12) {
    uint64_t v13 = *(void *)(v12 + 1184);
  }
  else {
    uint64_t v13 = 0;
  }
  if (v13) {
    a3 = v13;
  }
  float v15 = 1.0;
  if (a3)
  {
    BOOL v21 = v13 == 0;
    uint64_t v16 = 563;
    if (!v21) {
      uint64_t v16 = 564;
    }
    unint64_t v17 = *(unsigned __int8 *)(a1 + v16);
    uint64_t v19 = *(float32x2_t **)(a3 + 24);
    uint64_t v18 = *(float32x2_t **)(a3 + 32);
    if (0x8E38E38E38E38E39 * (((char *)v18 - (char *)v19) >> 4) <= v17)
    {
      int v20 = *(unsigned __int8 *)(a3 + 89);
      BOOL v21 = v19 == v18 || v20 == 0;
      if (v21) {
        goto LABEL_43;
      }
    }
    else
    {
      v19 += 18 * v17;
    }
    if (v19)
    {
      float32x2_t v22 = v19[9];
      if (v22)
      {
        float v23 = fmaxf(fminf(v19[10].f32[0]+ (float)(*(float *)(**(void **)&v22 + 32 * *(unsigned int *)(*(void *)&v22 + 32) + 8)* (float)(v19[10].f32[1] - v19[10].f32[0])), 1.0), 0.0);
        *(unsigned char *)(a1 + 756) = 1;
        *(float *)(a1 + 760) = v23;
      }
      float32x2_t v24 = v19[7];
      if (v24)
      {
        float v15 = fmaxf(v19[8].f32[0]+ (float)(*(float *)(**(void **)&v24 + 32 * *(unsigned int *)(*(void *)&v24 + 32) + 8)* (float)(v19[8].f32[1] - v19[8].f32[0])), 0.0);
        *(float *)(a1 + 744) = v15;
      }
      float32x2_t v25 = *v19;
      float32x2_t v26 = v19[1];
      if (*v19 != *(void *)&v26)
      {
        float32x2_t v27 = *v19;
        while (*(unsigned char *)(*(void *)&v27 + 16) != 2)
        {
          *(void *)&v27 += 24;
          if (*(void *)&v27 == *(void *)&v26) {
            goto LABEL_32;
          }
        }
        do
        {
          if (*(unsigned char *)(*(void *)&v25 + 16) == 2)
          {
            float v15 = *(float *)(*(void *)&v25 + 8)
                + (float)(*(float *)(***(void ***)&v25 + 32 * *(unsigned int *)(**(void **)&v25 + 32) + 8)
                        * (float)(*(float *)(*(void *)&v25 + 12) - *(float *)(*(void *)&v25 + 8)));
            goto LABEL_32;
          }
          *(void *)&v25 += 24;
        }
        while (*(void *)&v25 != *(void *)&v26);
        float v15 = 1.0;
      }
LABEL_32:
      float32x2_t v28 = v19[11];
      if (v28)
      {
        float32x2_t v29 = vneg_f32(vmla_n_f32(v19[12], vsub_f32(v19[13], v19[12]), *(float *)(**(void **)&v28 + 32 * *(unsigned int *)(*(void *)&v28 + 32) + 8)));
        v30.f32[0] = (*(float (**)(uint64_t))(*(void *)a1 + 304))(a1);
        v30.i32[1] = v31;
        *(float32x2_t *)(a1 + 544) = vneg_f32(vmla_n_f32(v29, v30, *(float *)(a1 + 744)));
      }
      float32x2_t v32 = v19[15];
      if (v32)
      {
        uint64_t v33 = **(void **)&v32 + 32 * *(unsigned int *)(*(void *)&v32 + 32);
        float v34 = *(float *)(v33 + 8);
        float v35 = v19[17].f32[0];
        if (v35 == 0.0)
        {
          float v36 = v19[16].f32[0] + (float)((float)(v19[16].f32[1] - v19[16].f32[0]) * v34);
        }
        else
        {
          float v37 = *(float *)(v33 + 12);
          if (v37 <= 0.0)
          {
            float v36 = v19[16].f32[0];
          }
          else if (v37 >= 1.0)
          {
            float v36 = v19[16].f32[1];
          }
          else
          {
            float v36 = v35 * v34;
          }
        }
        *(float *)(a1 + 748) = v36;
      }
    }
  }
LABEL_43:
  float v38 = *(float *)(*(void *)(a1 + 32) + 68);
  *(float *)(a1 + 416) = v38;
  *(_DWORD *)(a1 + 352) = a4->i32[0];
  *(_DWORD *)(a1 + 356) = a4->i32[1];
  *(unsigned char *)(a1 + 510) = fabsf(v38 + -1.0) > 0.000001;
  *(float *)(a1 + 420) = v15;
  float v39 = *(float *)(a2 + 904);
  *(float *)(a1 + 536) = v39;
  LODWORD(a8) = *(_DWORD *)(a2 + 908);
  *(_DWORD *)(a1 + 540) = LODWORD(a8);
  float v40 = *(float *)(a1 + 528);
  float v41 = v40 * *(float *)&a8;
  float v42 = *(float *)(a1 + 532);
  *(float *)&a8 = -(float)((float)(v42 * *(float *)&a8) - (float)(v40 * v39));
  *(_DWORD *)(a1 + 328) = LODWORD(a8);
  *(float *)(a1 + 332) = v41 + (float)(v42 * v39);
  *(unsigned char *)(a1 + 508) = fabsf(*(float *)&a8 + -1.0) > 0.000001;
  double v43 = *(double *)a5;
  double v44 = COERCE_DOUBLE(vadd_f32(*a5, *a4));
  *(double *)(a1 + 520) = v44;
  *(double *)(a1 + 344) = v44;
  md::CollisionObject::setupShapeData(a1 + 312, v44, v43, a8);
  uint64_t v45 = *(void *)(a1 + 16);
  if (v45)
  {
    *(float *)(a1 + 744) = *(float *)(a1 + 744) * *(float *)(v45 + 1156);
    *(_DWORD *)(a1 + 608) = *(_DWORD *)(v45 + 1300);
    *(unsigned char *)(a1 + 764) = *(unsigned char *)(v45 + 1079);
  }
  float v53 = (*(float (**)(uint64_t))(*(void *)a1 + 920))(a1);
  float v54 = v46.n128_f32[0];
  float v55 = v47.f32[0];
  float v56 = v48;
  float v57 = *(float *)(a1 + 612);
  if (v57 == 1.0)
  {
    if (*(unsigned char *)(a1 + 565))
    {
LABEL_47:
      *(float *)(a1 + 696) = v53;
      *(float *)(a1 + 700) = v54;
      *(float *)(a1 + 704) = v55;
      *(float *)(a1 + 708) = v54;
      *(float *)(a1 + 712) = v55;
      *(float *)(a1 + 716) = v56;
      *(float *)(a1 + 720) = v53;
      *(float *)(a1 + 724) = v56;
LABEL_48:
      v47.i32[0] = *(_DWORD *)(a1 + 744);
      v46.n128_u64[0] = *(void *)(a1 + 328);
      md::IconLabelPart::generateModelMatrix(*(long long **)(a1 + 728), *(void *)(a1 + 48), *(unsigned __int8 *)(a1 + 508), (float32x2_t *)(a1 + 544), *(float *)(a1 + 748), v46, v47, *(float *)(*(void *)(a1 + 32) + 68), v49, v50, v51, v52);
      *(void *)(a1 + 424) = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 144))(a1);
      return 37;
    }
  }
  else
  {
    float v53 = v53 * v57;
    float v54 = v46.n128_f32[0] * v57;
    float v55 = v47.f32[0] * v57;
    float v56 = v48 * v57;
    if (*(unsigned char *)(a1 + 565)) {
      goto LABEL_47;
    }
  }
  float v58 = *(float *)(*(void *)(a1 + 32) + 68);
  *(float *)&double v50 = *(float *)(a1 + 744) * v58;
  LODWORD(v49) = a4->i32[1];
  *(float *)&double v51 = fabsf(*(float *)&v50 + -1.0);
  v52.i32[0] = 897988541;
  if (*(float *)&v51 > 0.000001)
  {
    float v53 = *(float *)&v50 * v53;
    float v54 = *(float *)&v50 * v54;
    float v55 = *(float *)&v50 * v55;
    float v56 = *(float *)&v50 * v56;
  }
  float v59 = a4->f32[0] + (float)(*(float *)(a1 + 544) * v58);
  float v60 = *(float *)&v49 + (float)(*(float *)(a1 + 548) * v58);
  float v61 = *(float *)(a1 + 748);
  if (!*(unsigned char *)(a1 + 508) && v61 == 0.0)
  {
    float v62 = 3.4028e38;
    float v63 = -3.4028e38;
    if (v55 < v53)
    {
      float v64 = -3.4028e38;
      float v65 = 3.4028e38;
      if (!*(unsigned char *)(a2 + 3028)) {
        goto LABEL_68;
      }
    }
    else
    {
      float v64 = -3.4028e38;
      float v65 = 3.4028e38;
      if (v56 >= v54)
      {
        float v65 = v53 + v59;
        float v62 = v54 + v60;
        float v64 = v55 + v59;
        float v63 = v56 + v60;
      }
      if (!*(unsigned char *)(a2 + 3028))
      {
LABEL_68:
        *(float *)(a1 + 696) = v65;
        *(float *)(a1 + 700) = v62;
        *(float *)(a1 + 704) = v64;
        *(float *)(a1 + 708) = v62;
        *(float *)(a1 + 712) = v64;
        *(float *)(a1 + 716) = v63;
        int v78 = *(unsigned __int8 *)(a1 + 565);
        *(float *)(a1 + 720) = v65;
        *(float *)(a1 + 724) = v63;
        if (!v78) {
          return 37;
        }
        goto LABEL_48;
      }
    }
    float v75 = v64;
    float v76 = v65;
    if ((*(uint64_t (**)(void))(**(void **)(*(void *)(a2 + 168) + 32) + 8))(*(void *)(*(void *)(a2 + 168) + 32)))
    {
      float v65 = v76;
      float v64 = v75;
    }
    else
    {
      float v65 = v76;
      float v64 = v75;
      if (v75 >= v76 && v63 >= v62)
      {
        float v77 = v63 - v62;
        float v62 = roundf(v62);
        float v65 = roundf(v76);
        float v64 = (float)(v75 - v76) + v65;
        float v63 = v77 + v62;
      }
    }
    goto LABEL_68;
  }
  float v66 = *(float *)(a1 + 328);
  float v67 = *(float *)(a1 + 332);
  if (v61 != 0.0)
  {
    __float2 v68 = __sincosf_stret(v61);
    float v69 = v68.__sinval * v66;
    float v66 = -(float)((float)(v68.__sinval * v67) - (float)(v68.__cosval * v66));
    float v67 = v69 + (float)(v68.__cosval * v67);
  }
  float v70 = v59 + (float)(v66 * v53);
  float v71 = v60 + (float)(v66 * v54);
  *(float *)(a1 + 696) = v70 - (float)(v54 * v67);
  *(float *)(a1 + 700) = v71 + (float)(v67 * v53);
  float v72 = v59 + (float)(v66 * v55);
  *(float *)(a1 + 704) = v72 - (float)(v54 * v67);
  *(float *)(a1 + 708) = v71 + (float)(v67 * v55);
  float v73 = v72 - (float)(v56 * v67);
  float v74 = v60 + (float)(v66 * v56);
  *(float *)(a1 + 712) = v73;
  *(float *)(a1 + 716) = v74 + (float)(v67 * v55);
  *(float *)(a1 + 720) = v70 - (float)(v56 * v67);
  *(float *)(a1 + 724) = v74 + (float)(v67 * v53);
  return 37;
}

uint64_t md::CollisionObject::setupShapeData(uint64_t this, double a2, double a3, double a4)
{
  float32x2_t v4 = *(float32x2_t *)(this + 32);
  int v5 = *(unsigned __int8 *)(this + 198);
  if (*(unsigned char *)(this + 198))
  {
    float32x2_t v6 = *(float32x2_t *)(this + 40);
    a4 = COERCE_DOUBLE(vsub_f32(v4, v6));
    float32x2_t v4 = vmla_n_f32(v6, *(float32x2_t *)&a4, *(float *)(this + 104));
  }
  float32x2_t v8 = *(float32x2_t *)this;
  float32x2_t v7 = *(float32x2_t *)(this + 8);
  float32x2_t v9 = vsub_f32(v7, *(float32x2_t *)this);
  float32x2_t v10 = vmul_f32(v9, (float32x2_t)0x3F0000003F000000);
  float32x2_t v11 = vadd_f32(v10, *(float32x2_t *)this);
  float32x2_t v12 = vadd_f32(v11, v4);
  int v13 = *(unsigned __int8 *)(this + 196);
  if (!*(unsigned char *)(this + 196) || *(void *)(this + 168) && *(_DWORD *)(this + 176) == 1)
  {
    LODWORD(a4) = *(_DWORD *)(this + 96);
    float v14 = *(float *)(this + 108);
    float32x2_t v15 = vmaxnm_f32(v9, 0);
    float64x2_t v16 = vcvtq_f64_f32(v15);
    float32x2_t v17 = vsub_f32(v11, vcvt_f32_f64(vmulq_n_f64(v16, v14 * 0.5)));
    float32x2_t v18 = vmla_n_f32(v17, v15, v14);
    int32x2_t v19 = vcgt_f32(v17, v18);
    char v20 = v19.i8[0] | v19.i8[4];
    int8x8_t v21 = (int8x8_t)vadd_f32(v17, v4);
    float32x2_t v22 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    if (v20) {
      unsigned int v23 = -1;
    }
    else {
      unsigned int v23 = 0;
    }
    int8x8_t v24 = (int8x8_t)vdup_n_s32(v23);
    int8x8_t v25 = vbsl_s8(v24, (int8x8_t)v22, v21);
    float32x2_t v26 = (float32x2_t)0x80000000800000;
    *(int8x8_t *)(this + 64) = v25;
    *(int8x8_t *)(this + 72) = vbsl_s8(v24, (int8x8_t)0x80000000800000, (int8x8_t)vadd_f32(v18, v4));
    if (v5)
    {
      float v27 = *(float *)(this + 104);
      *(float *)&a4 = v27 * *(float *)&a4;
      float32x2_t v28 = vsub_f32(v11, vcvt_f32_f64(vmulq_n_f64(v16, v27 * 0.5)));
      float32x2_t v29 = vmla_n_f32(v28, v15, v27);
      int32x2_t v30 = vcgt_f32(v28, v29);
      if (((v30.i32[0] | v30.i32[1]) & 1) == 0)
      {
        float32x2_t v22 = vadd_f32(v28, v4);
        float32x2_t v26 = vadd_f32(v29, v4);
      }
    }
    else
    {
      int32x2_t v60 = vcgt_f32(v8, v7);
      if (((v60.i32[0] | v60.i32[1]) & 1) == 0)
      {
        float32x2_t v22 = vadd_f32(v8, v4);
        float32x2_t v26 = vadd_f32(v7, v4);
      }
    }
    *(float32x2_t *)&long long v61 = v22;
    *((float32x2_t *)&v61 + 1) = v26;
    *(_OWORD *)(this + 48) = v61;
    *(int32x2_t *)&long long v61 = vcgt_f32(v22, v26);
    int8x8_t v62 = (int8x8_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
    if ((v61 | BYTE4(v61))) {
      unsigned int v63 = -1;
    }
    else {
      unsigned int v63 = 0;
    }
    int8x8_t v64 = (int8x8_t)vdup_n_s32(v63);
    *(float32x2_t *)(this + 80) = vsub_f32(v22, (float32x2_t)vbic_s8(v62, v64));
    *(float32x2_t *)(this + 88) = vadd_f32(v26, (float32x2_t)vbsl_s8(v64, (int8x8_t)0x8000000080000000, v62));
    double v44 = *(float32x2_t **)(this + 160);
    if (!v44)
    {
LABEL_28:
      uint64_t v65 = *(void *)(this + 168);
      if (v65)
      {
        uint64_t v66 = *(unsigned int *)(this + 176);
        if (v66)
        {
          float v67 = (float *)(v65 + 8);
          uint64_t v68 = *(void *)(this + 184) + 12;
          do
          {
            float v69 = *(float *)(this + 96) + *v67;
            *(float *)(v68 - 4) = v69;
            *(float *)uint64_t v68 = v69;
            float v70 = *(float *)(this + 100) + *v67;
            *(float *)(v68 + 4) = v70;
            *(float *)(v68 + 8) = v70;
            float32x2_t v71 = vsub_f32(*(float32x2_t *)(v67 - 2), v11);
            if (v5)
            {
              *(float32x2_t *)(v68 - 4) = vmul_n_f32(*(float32x2_t *)(v68 - 4), *(float *)(this + 104));
              *(float32x2_t *)(v68 + 4) = vmul_n_f32(*(float32x2_t *)(v68 + 4), *(float *)(this + 104));
              float32x2_t v71 = vmul_n_f32(v71, *(float *)(this + 104));
            }
            if (v13)
            {
              float32x2_t v72 = *(float32x2_t *)(this + 16);
              float32x2_t v73 = vmul_n_f32(v72, v71.f32[0]);
              float32x2_t v74 = (float32x2_t)vrev64_s32((int32x2_t)vmul_lane_f32(v72, v71, 1));
              v71.i32[0] = vsub_f32(v73, v74).u32[0];
              v71.i32[1] = vadd_f32(v73, v74).i32[1];
            }
            *(float32x2_t *)(v68 - 12) = vadd_f32(v71, v12);
            v67 += 3;
            v68 += 24;
            --v66;
          }
          while (v66);
        }
      }
      return this;
    }
  }
  else
  {
    __int32 v31 = (const float *)(this + 96);
    float v32 = *(float *)(this + 16);
    float v33 = *(float *)(this + 20);
    float32x2_t v34 = vld1_dup_f32(v31);
    float32x2_t v35 = vadd_f32(v34, (float32x2_t)vbic_s8((int8x8_t)v10, (int8x8_t)vcltz_f32(v9)));
    v34.f32[0] = v33;
    v34.f32[1] = -v33;
    float32x2_t v36 = vadd_f32(vabs_f32((float32x2_t)vrev64_s32((int32x2_t)vmul_f32(v35, v34))), vabs_f32(vmul_n_f32(v35, v32)));
    float32x2_t v37 = vsub_f32(v12, v36);
    float32x2_t v38 = vadd_f32(v36, v12);
    *(float32x2_t *)(this + 80) = v37;
    *(float32x2_t *)(this + 88) = v38;
    *(float32x2_t *)(this + 48) = v37;
    *(float32x2_t *)(this + 56) = v38;
    *(float32x2_t *)(this + 64) = v37;
    *(float32x2_t *)(this + 72) = v38;
    if (v5)
    {
      float v39 = *(float *)(this + 104);
      float v40 = v39 * v35.f32[0];
      float v41 = vmuls_lane_f32(v39, v35, 1);
      float v42 = fabsf(v41 * (float)-v33) + fabsf(v40 * v32);
      float v43 = fabsf(v41 * v32) + fabsf(v40 * v33);
      *(float *)(this + 80) = v12.f32[0] - v42;
      *(float *)(this + 84) = v12.f32[1] - v43;
      *(float *)(this + 88) = v42 + v12.f32[0];
      *(float *)(this + 92) = v43 + v12.f32[1];
    }
    double v44 = *(float32x2_t **)(this + 160);
    if (!v44) {
      goto LABEL_28;
    }
  }
  uint64_t v45 = *(unsigned int *)(this + 176);
  if (v45)
  {
    __n128 v46 = (float32x2_t *)(*(void *)(this + 184) + 16);
    float32x4_t v47 = v44 + 1;
    do
    {
      float v48 = (const float *)(this + 96);
      float32x2_t v49 = vsub_f32(*v47, v47[-1]);
      float32x2_t v50 = vmaxnm_f32((float32x2_t)vbic_s8((int8x8_t)vmul_f32(v49, (float32x2_t)0x3F0000003F000000), (int8x8_t)vcltz_f32(v49)), 0);
      float32x2_t v51 = vld1_dup_f32(v48);
      float32x2_t v52 = vadd_f32(v50, v51);
      v46[-1] = v52;
      float v53 = (const float *)(this + 100);
      float32x2_t v54 = vld1_dup_f32(v53);
      float32x2_t v55 = vadd_f32(v54, v50);
      float32x2_t *v46 = v55;
      float32x2_t v56 = vmla_f32(vsub_f32(v47[-1], v11), (float32x2_t)0x3F0000003F000000, vsub_f32(*v47, v47[-1]));
      if (v5)
      {
        v46[-1] = vmul_n_f32(v52, *(float *)(this + 104));
        float32x2_t *v46 = vmul_n_f32(v55, *(float *)(this + 104));
        float32x2_t v56 = vmul_n_f32(v56, *(float *)(this + 104));
      }
      if (v13)
      {
        float32x2_t v57 = *(float32x2_t *)(this + 16);
        float32x2_t v58 = vmul_n_f32(v57, v56.f32[0]);
        float32x2_t v59 = (float32x2_t)vrev64_s32((int32x2_t)vmul_lane_f32(v57, v56, 1));
        v56.i32[0] = vsub_f32(v58, v59).u32[0];
        v56.i32[1] = vadd_f32(v58, v59).i32[1];
      }
      v46[-2] = vadd_f32(v56, v12);
      v46 += 3;
      v47 += 2;
      --v45;
    }
    while (v45);
  }
  return this;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::isNavActive(md::MapNavLabeler *this)
{
  return *((unsigned __int8 *)this + 120);
}

double md::IconLabelPart::meshRect(md::IconLabelPart *this)
{
  int v1 = *((unsigned __int8 *)this + 562);
  uint64_t v2 = (float32x2_t *)*((void *)this + 80);
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)&v2[18]);
  if (v1 == 1)
  {
    if (v3)
    {
      LODWORD(result) = v2[6].i32[0];
      return result;
    }
    goto LABEL_5;
  }
  if ((v3 & 1) == 0)
  {
LABEL_5:
    LODWORD(result) = 2139095039;
    return result;
  }
  *(float32x2_t *)v5.f32 = vmaxnm_f32(vsub_f32(v2[7], v2[6]), 0);
  v5.i64[1] = v5.i64[0];
  *(void *)&double result = vmulq_f32(v5, (float32x4_t)xmmword_1A28FF850).u64[0];
  return result;
}

float md::CaptionedIconLabelPart::textOriginOffsetForPosition(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5, float *a6, float *a7, uint64_t a8)
{
  if (a2) {
    float v14 = (float *)(a1 + 684);
  }
  else {
    float v14 = (float *)(a1 + 632);
  }
  if (a5 == 4)
  {
    float32x2_t v15 = (unsigned __int8 *)&diagonalUpIconLabelAnchors + 2 * a3;
  }
  else if (a5 == 8)
  {
    float32x2_t v15 = (unsigned __int8 *)&diagonalDownIconLabelAnchors + 2 * a3;
  }
  else
  {
    if (a4)
    {
      float64x2_t v16 = (unsigned __int8 *)&perpendicularIconLabelAnchors + 2 * a3;
      int v17 = *v16;
      int v18 = v16[1];
      char v19 = gss::LabelPositionToMask(a3);
      if (v17 == 3 || v18 == 3) {
        goto LABEL_30;
      }
LABEL_13:
      int v21 = 0;
LABEL_36:
      v14 += 5;
      goto LABEL_37;
    }
    float32x2_t v15 = (unsigned __int8 *)&iconLabelAnchors + 2 * a3;
  }
  int v17 = *v15;
  BOOL v22 = v17 == 3 || v15[1] == 3;
  char v23 = v22;
  if (!v22 && (a4 & 1) == 0 && *(unsigned char *)(a1 + 854) == 2)
  {
    if (v17 == 1) {
      int v17 = 2;
    }
    else {
      int v17 = 1;
    }
    char v24 = gss::LabelPositionToMask(a3);
    if ((v24 & 0xE) != 0 || (v24 & 0xE0) != 0) {
      int v21 = 1;
    }
    else {
      int v21 = 1;
    }
    goto LABEL_36;
  }
  char v19 = gss::LabelPositionToMask(a3);
  if ((v23 & 1) == 0) {
    goto LABEL_13;
  }
LABEL_30:
  if ((v19 & 0xE) != 0 || (v19 & 0xE0) != 0)
  {
    if ((v19 & 0x38) != 0)
    {
LABEL_33:
      int v21 = 0;
      goto LABEL_37;
    }
  }
  else if ((v19 & 0x38) != 0)
  {
    goto LABEL_33;
  }
  if ((v19 & 0x83) != 0)
  {
    int v21 = 0;
    ++v14;
LABEL_37:
    float v25 = *v14;
    if (v17 != 3) {
      goto LABEL_38;
    }
LABEL_47:
    float v26 = (float)(a6[2] + *a6) * 0.5;
    goto LABEL_48;
  }
  int v21 = 0;
  float v25 = 0.0;
  if (v17 == 3) {
    goto LABEL_47;
  }
LABEL_38:
  if (v17 == 2)
  {
    float v26 = a6[2] + v25;
  }
  else
  {
    float v26 = 0.0;
    if (v17 == 1) {
      float v26 = *a6 - v25;
    }
  }
LABEL_48:
  if (v21) {
    float v27 = (char *)&horizontalAlignWithIconLabelAnchors;
  }
  else {
    float v27 = (char *)&horizontalLabelAnchors;
  }
  float32x2_t v28 = (unsigned __int8 *)&v27[2 * a3];
  float v29 = 1.0;
  float v30 = 0.0;
  float v31 = -0.57358;
  if (a5 == 8) {
    float32x2_t v28 = (unsigned __int8 *)&diagonalDownLabelAnchors + 2 * a3;
  }
  else {
    float v31 = 0.0;
  }
  if (a5 == 8) {
    float v29 = 0.81915;
  }
  if (a5 == 4)
  {
    float32x2_t v28 = (unsigned __int8 *)&diagonalUpLabelAnchors + 2 * a3;
    float v32 = 0.57358;
  }
  else
  {
    float v32 = v31;
  }
  if (a5 == 4) {
    float v33 = 0.81915;
  }
  else {
    float v33 = v29;
  }
  int v34 = *v28;
  int v35 = v28[1];
  if (v34 == 2)
  {
    float v36 = a7[2] - *a7;
    float v37 = -0.5;
  }
  else
  {
    if (v34 != 1) {
      goto LABEL_67;
    }
    float v36 = a7[2] - *a7;
    float v37 = 0.5;
  }
  float v30 = v36 * v37;
LABEL_67:
  switch(v35)
  {
    case 4:
      float v38 = a7[1] - a7[3];
      float v39 = -(float)((*(float (**)(uint64_t, uint64_t, uint64_t))(*(void *)a8 + 328))(a8, a2, a3)
                   + (float)(v38 * 0.5));
      break;
    case 5:
      float v40 = a7[3] - a7[1];
      float v41 = 0.5;
      goto LABEL_75;
    case 6:
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a8 + 328))(a8, a2, a3);
      goto LABEL_74;
    case 7:
      float v42 = a7[1] - a7[3];
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a8 + 320))(a8, a2, a3);
      goto LABEL_77;
    case 8:
      float v40 = a7[3] - a7[1];
LABEL_74:
      float v41 = -0.5;
LABEL_75:
      float v39 = v40 * v41;
      break;
    case 9:
      float v42 = a7[1] - a7[3];
      float v43 = (*(float (**)(uint64_t, uint64_t, uint64_t))(*(void *)a8 + 312))(a8, a2, a3);
LABEL_77:
      float v39 = v43 + (float)(v42 * 0.5);
      break;
    default:
      float v39 = 0.0;
      break;
  }
  float v44 = -(float)((float)(v39 * v32) - (float)(v30 * v33));
  if (v33 == 1.0) {
    float v44 = v30;
  }
  return v44 + v26;
}

uint64_t md::NullLabelPart::isDisplayable(md::NullLabelPart *this)
{
  return 1;
}

uint64_t md::NullLabelPart::layoutForDisplay()
{
  return 37;
}

float md::HorizontalTextLabelPart::bottomAlignInset(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 960;
  if (a2) {
    uint64_t v2 = a1 + 1032;
  }
  return *(float *)(v2 + 32);
}

uint64_t md::HorizontalTextLabelPart::layoutForDisplay(float32x2_t *a1, uint64_t a2, md::LabelAnimator *a3, float32x2_t *a4, float32x2_t *a5, double a6, double a7, double a8, float64x2_t a9)
{
  float v13 = *(float *)(a2 + 904);
  a1[67].f32[0] = v13;
  float v14 = *(float *)(a2 + 908);
  a1[67].f32[1] = v14;
  LODWORD(a8) = a1[66].i32[0];
  *(float *)a9.f64 = *(float *)&a8 * v14;
  float v15 = a1[66].f32[1];
  float32_t v16 = -(float)((float)(v15 * v14) - (float)(*(float *)&a8 * v13));
  a1[41].f32[0] = v16;
  a1[41].f32[1] = *(float *)a9.f64 + (float)(v15 * v13);
  double v17 = fabsf(v16 + -1.0);
  a1[63].i8[4] = v17 > 0.000001;
  uint64_t v18 = md::TextLabelPart::layoutForDisplay(a1, (md::LabelManager *)a2, a3, (__int32 *)a4, a5, v17, 0.000001, a8, a9);
  if (v18 == 37)
  {
    float v19 = a1[92].f32[1];
    if (!a1[137].i8[3] && v19 == a1[130].f32[0] && a1[92].f32[0] == a1[130].f32[1])
    {
      int v20 = a1[100].u16[2];
      int v21 = a1[100].u16[3];
    }
    else
    {
      a1[137].i8[3] = 0;
      a1[130].f32[0] = v19;
      a1[130].i32[1] = a1[92].i32[0];
      a1[129].f32[0] = a1[129].f32[1] * v19;
      md::HorizontalTextLabelPart::placeLines((uint64_t)&a1[74], a1 + 129, a2, (uint64_t)&a1[39]);
      int v20 = 0;
      int v21 = a1[137].u16[0];
      a1[100].i32[0] = a1[136].i32[1];
      a1[100].i32[1] = v21 << 16;
    }
    float32x2_t v22 = a1[74];
    if (v20 == v21
      || (int v23 = md::FontAtlas::commitGlyphs(*(void *)(a2 + 304), *(void *)&v22 + 96, (unsigned __int16 *)&a1[100] + 2, v75)) != 0)
    {
      LOBYTE(v23) = md::FontAtlas::commitGlyphs(*(void *)(a2 + 304), *(void *)&v22 + 32, (unsigned __int16 *)&a1[100], v75);
    }
    a1[108].i8[3] = v23;
    float v25 = *(float *)(*(void *)&a1[4] + 68);
    a1[52].f32[0] = v25;
    a1[44].i32[0] = a4->i32[0];
    a1[44].i32[1] = a4->i32[1];
    a1[63].i8[6] = fabsf(v25 + -1.0) > 0.000001;
    double v26 = *(double *)a5;
    double v27 = COERCE_DOUBLE(vadd_f32(*a5, *a4));
    *(double *)&a1[65] = v27;
    *(double *)&a1[43] = v27;
    md::CollisionObject::setupShapeData((uint64_t)&a1[39], v27, v26, v24);
    if (a1[70].i8[5])
    {
      float32x2_t v28 = a1[105];
      if (v28)
      {
        float32x2_t v29 = a1[6];
        if (a1[103].i8[6]) {
          float v30 = 1.1;
        }
        else {
          float v30 = 1.0;
        }
        float v31 = a1[68].f32[0];
        float v32 = a1[68].f32[1];
        if (!*(void *)&v29)
        {
          float v33 = *(float *)(*(void *)&a1[4] + 68);
          float v30 = (float)(v30 * a1[114].f32[0]) * v33;
          float v31 = v33 * v31;
          float v32 = v33 * v32;
        }
        float v34 = fabsf(v30 + -1.0);
        if (LODWORD(v31) | LODWORD(v32) || v34 > 0.000001)
        {
          double v43 = v30;
          if (v34 <= 0.000001) {
            double v43 = 1.0;
          }
          *(double *)float v75 = v43;
          *(double *)&v75[40] = v43;
          memset(&v75[8], 0, 32);
          long long v78 = *(unint64_t *)&v43;
          long long v76 = 0u;
          long long v77 = 0u;
          *(double *)&long long v79 = v31;
          *((double *)&v79 + 1) = v32;
          long long v80 = xmmword_1A28FCCC0;
          if (v29)
          {
            gm::operator*<double,4,4,4>((double *)&v67, (double *)v29, (double *)v75);
          }
          else
          {
            long long v71 = v77;
            long long v72 = v78;
            long long v73 = v79;
            long long v74 = v80;
            long long v67 = *(_OWORD *)v75;
            long long v68 = *(_OWORD *)&v75[16];
            long long v69 = *(_OWORD *)&v75[32];
            long long v70 = v76;
          }
          long long v44 = v68;
          *(_OWORD *)*(void *)&float32x2_t v28 = v67;
          *(_OWORD *)(*(void *)&v28 + 16) = v44;
          long long v45 = v70;
          *(_OWORD *)(*(void *)&v28 + 32) = v69;
          *(_OWORD *)(*(void *)&v28 + 48) = v45;
          long long v46 = v72;
          *(_OWORD *)(*(void *)&v28 + 64) = v71;
          *(_OWORD *)(*(void *)&v28 + 80) = v46;
          long long v47 = v74;
          *(_OWORD *)(*(void *)&v28 + 96) = v73;
          *(_OWORD *)(*(void *)&v28 + 112) = v47;
        }
        else
        {
          if (v29)
          {
            long long v35 = *(_OWORD *)*(void *)&v29;
            long long v36 = *(_OWORD *)(*(void *)&v29 + 16);
            long long v37 = *(_OWORD *)(*(void *)&v29 + 32);
            long long v38 = *(_OWORD *)(*(void *)&v29 + 48);
            long long v39 = *(_OWORD *)(*(void *)&v29 + 64);
            long long v40 = *(_OWORD *)(*(void *)&v29 + 80);
            long long v41 = *(_OWORD *)(*(void *)&v29 + 96);
            long long v42 = *(_OWORD *)(*(void *)&v29 + 112);
          }
          else
          {
            long long v37 = xmmword_1A28FCCC0;
            long long v35 = xmmword_1A28FCBD0;
            long long v36 = 0uLL;
            long long v38 = 0uLL;
            long long v39 = 0uLL;
            long long v40 = xmmword_1A28FCBD0;
            long long v41 = 0uLL;
            long long v42 = xmmword_1A28FCCC0;
          }
          *(_OWORD *)*(void *)&float32x2_t v28 = v35;
          *(_OWORD *)(*(void *)&v28 + 16) = v36;
          *(_OWORD *)(*(void *)&v28 + 32) = v37;
          *(_OWORD *)(*(void *)&v28 + 48) = v38;
          *(_OWORD *)(*(void *)&v28 + 64) = v39;
          *(_OWORD *)(*(void *)&v28 + 80) = v40;
          *(_OWORD *)(*(void *)&v28 + 96) = v41;
          *(_OWORD *)(*(void *)&v28 + 112) = v42;
        }
      }
      a1[53] = v28;
      float32x2_t v48 = a1[74];
      uint64_t v50 = *(void *)(*(void *)&v48 + 32);
      uint64_t v49 = *(void *)(*(void *)&v48 + 40);
      if (v49 != v50)
      {
        gm::operator*<double,4,4,4>((double *)v75, (double *)(a2 + 920), (double *)v28);
        double v51 = *(float *)(v50 + 40);
        double v52 = *(float *)(v50 + 44);
        double v53 = *(double *)&v79 + *(double *)v75 * v51 + *(double *)&v75[32] * v52;
        double v54 = *((double *)&v79 + 1) + *(double *)&v75[8] * v51 + *(double *)&v75[40] * v52;
        double v55 = *(double *)&v80 + *(double *)&v75[16] * v51 + *(double *)&v76 * v52;
        double v56 = 1.0 / (*((double *)&v80 + 1) + *(double *)&v75[24] * v51 + *((double *)&v76 + 1) * v52);
        double v57 = v56 * v53;
        double v58 = v56 * v54;
        double v59 = v56 * v55;
        double v60 = *(float *)(v49 - 48);
        double v61 = *(float *)(v49 - 44);
        double v62 = *((double *)&v80 + 1) + *(double *)&v75[24] * v60 + *((double *)&v76 + 1) * v61;
        double v63 = 1.0 / v62 * (*(double *)&v79 + *(double *)v75 * v60 + *(double *)&v75[32] * v61);
        double v64 = 1.0 / v62 * (*((double *)&v79 + 1) + *(double *)&v75[8] * v60 + *(double *)&v75[40] * v61);
        double v65 = 1.0 / v62 * (*(double *)&v80 + *(double *)&v75[16] * v60 + *(double *)&v76 * v61);
        a1[101].i8[0] = v57 * v57 + v58 * v58 + v59 * v59 < v63 * v63 + v64 * v64 + v65 * v65;
      }
    }
  }
  return v18;
}

uint64_t md::FontAtlas::commitGlyphs(uint64_t a1, void *a2, unsigned __int16 *a3, uint64_t a4)
{
  uint64_t v4 = *a3;
  char v59 = 1;
  if (v4 < a3[1])
  {
    float32x2_t v9 = (void *)(a1 + 80);
    double v60 = (void *)(a1 + 88);
    char v59 = 1;
    double v58 = (void *)(a1 + 80);
    while (1)
    {
      uint64_t v10 = *(void *)(*a2 + 88 * v4);
      if (!v10 || !*(unsigned char *)(v10 + 61)) {
        goto LABEL_4;
      }
      if (a4) {
        float32x2_t v11 = (void *)(*a2 + 88 * v4 + 16);
      }
      else {
        float32x2_t v11 = (void *)(*a2 + 88 * v4);
      }
      uint64_t v12 = *v11;
      uint64_t v13 = *(void *)(*v11 + 96);
      if (v13) {
        goto LABEL_11;
      }
      unsigned __int8 v19 = atomic_load((unsigned __int8 *)(v12 + 109));
      if ((v19 & 1) == 0) {
        break;
      }
LABEL_72:
      if (!*(void *)(v12 + 80)) {
        goto LABEL_4;
      }
      uint64_t v46 = 8;
      if (*(unsigned char *)(v12 + 60)) {
        uint64_t v46 = 16;
      }
      (*(void (**)(uint64_t *__return_ptr))(**(void **)(*(void *)(a1 + 8) + v46) + 32))(&v61);
      uint64_t v47 = v61;
      if (v61)
      {
        uint64_t v48 = *(void *)(a1 + 56);
        if (*(void *)(a1 + 48) == v48) {
          operator new[]();
        }
        uint64_t v13 = *(void *)(v48 - 8);
        *(void *)(a1 + 56) = v48 - 8;
        uint64_t v50 = v62;
        if (v62) {
          atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        double v51 = *(std::__shared_weak_count **)(v13 + 40);
        *(void *)(v13 + 32) = v47;
        *(void *)(v13 + 40) = v50;
        if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
          std::__shared_weak_count::__release_weak(v51);
        }
        unint64_t v52 = (unint64_t)(float)(*(float *)(v12 + 48) * 0.0625);
        uint64_t v53 = *(void *)(a1 + 136);
        if (((*(void *)(a1 + 144) - v53) >> 2) - 1 < v52) {
          unint64_t v52 = ((*(void *)(a1 + 144) - v53) >> 2) - 1;
        }
        ++*(_DWORD *)(v53 + 4 * v52);
        uint64_t v49 = v62;
        if (!v62) {
          goto LABEL_89;
        }
      }
      else
      {
        uint64_t v13 = 0;
        uint64_t v49 = v62;
        if (!v62) {
          goto LABEL_89;
        }
      }
      if (!atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
        std::__shared_weak_count::__release_weak(v49);
        if (!v13)
        {
LABEL_95:
          float32x2_t v9 = v58;
          goto LABEL_4;
        }
        goto LABEL_90;
      }
LABEL_89:
      if (!v13) {
        goto LABEL_95;
      }
LABEL_90:
      atomic_store(0, (unsigned __int8 *)(v12 + 109));
      *(unsigned char *)(v12 + 108) = 0;
      double v54 = *(std::__shared_weak_count **)(v12 + 88);
      *(void *)(v12 + 80) = 0;
      *(void *)(v12 + 88) = 0;
      if (v54 && !atomic_fetch_add(&v54->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v54->__on_zero_shared)(v54);
        std::__shared_weak_count::__release_weak(v54);
      }
      *(void *)(v12 + 96) = v13;
      *(void *)(v13 + 8) = v12;
      float32x2_t v9 = v58;
LABEL_11:
      int v14 = *(_DWORD *)(a1 + 112);
      if (*(_DWORD *)v13 != v14)
      {
        *(_DWORD *)uint64_t v13 = v14;
        float v15 = (void *)(v13 + 16);
        uint64_t v16 = *(void *)(v13 + 16);
        if (v16)
        {
          uint64_t v17 = *v9;
          uint64_t v18 = *(void *)(v13 + 24);
          goto LABEL_19;
        }
        uint64_t v18 = *(void *)(v13 + 24);
        uint64_t v17 = *v9;
        if (v18)
        {
LABEL_19:
          if (v17 == v13) {
            int v23 = v9;
          }
          else {
            int v23 = (void *)(v16 + 24);
          }
          *int v23 = v18;
          double v24 = v60;
          if (*v60 == v13)
          {
LABEL_25:
            *double v24 = v16;
          }
          else
          {
            uint64_t v25 = *(void *)(v13 + 24);
            if (v25)
            {
              double v24 = (void *)(v25 + 16);
              goto LABEL_25;
            }
          }
          void *v15 = 0;
          *(void *)(v13 + 24) = 0;
          --*(_DWORD *)(a1 + 96);
          uint64_t v26 = *(void *)(a1 + 88);
        }
        else
        {
          if (v17 == v13)
          {
            uint64_t v18 = 0;
            uint64_t v17 = v13;
            goto LABEL_19;
          }
          uint64_t v26 = *v60;
          if (*v60 == v13)
          {
            uint64_t v18 = 0;
            goto LABEL_19;
          }
        }
        void *v15 = v26;
        if (v26) {
          *(void *)(v26 + 24) = v13;
        }
        void *v60 = v13;
        if (!*v9) {
          *float32x2_t v9 = v13;
        }
        ++*(_DWORD *)(a1 + 96);
        ++*(_DWORD *)(a1 + 116);
        if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
          dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
        }
        atomic_fetch_add((atomic_ullong *volatile)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 144), 1uLL);
      }
LABEL_4:
      if (++v4 >= (unint64_t)a3[1]) {
        return v59 & 1;
      }
    }
    if (*(unsigned char *)(v12 + 108))
    {
LABEL_71:
      unsigned __int8 v45 = atomic_load((unsigned __int8 *)(v12 + 109));
      if ((v45 & 1) == 0)
      {
        char v59 = 0;
        goto LABEL_4;
      }
      goto LABEL_72;
    }
    *(unsigned char *)(v12 + 108) = 1;
    uint64_t v20 = *(void *)(a1 + 104);
    if (*(unsigned __int8 *)(*(void *)(v20 + 24) + 3383) | *(unsigned __int8 *)(a1 + 120))
    {
      uint64_t v21 = *v11;
      (***(void (****)(void, void))v20)(*(void *)v20, *v11);
      unsigned int v22 = atomic_load((unsigned int *)(v20 + 76));
      atomic_store(v22, (unsigned int *)(v21 + 52));
      atomic_store(1u, (unsigned __int8 *)(v21 + 109));
LABEL_68:
      if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
        dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
      }
      float32x2_t v9 = v58;
      atomic_fetch_add((atomic_ullong *volatile)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 136), 1uLL);
      goto LABEL_71;
    }
    double v27 = *(void **)(v20 + 40);
    unint64_t v28 = *(void *)(v20 + 48);
    if ((unint64_t)v27 < v28)
    {
      if (v27)
      {
        void *v27 = *v11;
        uint64_t v29 = v11[1];
        v27[1] = v29;
        if (v29) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v29 + 8), 1uLL, memory_order_relaxed);
        }
      }
      float v30 = v27 + 2;
LABEL_67:
      *(void *)(v20 + 40) = v30;
      goto LABEL_68;
    }
    uint64_t v31 = a4;
    uint64_t v32 = *(void *)(v20 + 32);
    uint64_t v33 = ((uint64_t)v27 - v32) >> 4;
    unint64_t v34 = v33 + 1;
    if ((unint64_t)(v33 + 1) >> 60) {
      abort();
    }
    uint64_t v35 = v28 - v32;
    if (v35 >> 3 > v34) {
      unint64_t v34 = v35 >> 3;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF0) {
      unint64_t v34 = 0xFFFFFFFFFFFFFFFLL;
    }
    if (v34)
    {
      uint64_t v36 = 16 * v34;
      uint64_t v37 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v20 + 56) + 16))(*(void *)(v20 + 56), 16 * v34, 8);
      long long v38 = (_OWORD *)(v37 + 16 * v33);
      unint64_t v34 = v37 + v36;
      if (v37)
      {
        long long v39 = *(_OWORD *)v11;
        *long long v38 = *(_OWORD *)v11;
        a4 = v31;
        if (*((void *)&v39 + 1)) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v39 + 1) + 8), 1uLL, memory_order_relaxed);
        }
        goto LABEL_54;
      }
    }
    else
    {
      long long v38 = (_OWORD *)(16 * v33);
    }
    a4 = v31;
LABEL_54:
    float v30 = v38 + 1;
    long long v40 = *(void **)(v20 + 32);
    long long v41 = *(void **)(v20 + 40);
    if (v41 == v40)
    {
      *(void *)(v20 + 32) = v38;
      *(void *)(v20 + 40) = v30;
      uint64_t v57 = *(void *)(v20 + 48);
      *(void *)(v20 + 48) = v34;
    }
    else
    {
      do
      {
        long long v42 = *((_OWORD *)v41 - 1);
        v41 -= 2;
        *--long long v38 = v42;
        void *v41 = 0;
        v41[1] = 0;
      }
      while (v41 != v40);
      long long v41 = *(void **)(v20 + 32);
      double v43 = *(void **)(v20 + 40);
      *(void *)(v20 + 32) = v38;
      *(void *)(v20 + 40) = v30;
      uint64_t v57 = *(void *)(v20 + 48);
      *(void *)(v20 + 48) = v34;
      if (v43 == v41)
      {
        a4 = v31;
      }
      else
      {
        double v56 = v30;
        do
        {
          long long v44 = (std::__shared_weak_count *)*(v43 - 1);
          if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
          v43 -= 2;
        }
        while (v43 != v41);
        a4 = v31;
        float v30 = v56;
      }
    }
    if (v41) {
      (*(void (**)(void, void *, uint64_t))(**(void **)(v20 + 56) + 40))(*(void *)(v20 + 56), v41, v57 - (void)v41);
    }
    goto LABEL_67;
  }
  return v59 & 1;
}

void sub_1A18017D0(_Unwind_Exception *exception_object)
{
  unsigned __int8 v3 = *(std::__shared_weak_count **)(v1 - 88);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::FontAtlas::commitGlyphs(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned char *a4)
{
  if (*(float *)(a2 + 36) > 0.0 && md::FontAtlas::commitGlyphs(a1, (void *)a2, a3, 1))
  {
    *a4 = 1;
    float32x2_t v8 = *(void **)a2;
    float32x2_t v9 = *(void **)(a2 + 8);
    if (*(void **)a2 != v9)
    {
      do
      {
        uint64_t v11 = v8[2];
        uint64_t v10 = v8[3];
        if (v10) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v12 = (std::__shared_weak_count *)v8[1];
        void *v8 = v11;
        v8[1] = v10;
        if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        uint64_t v13 = (std::__shared_weak_count *)v8[3];
        v8[2] = 0;
        float32x2_t v8[3] = 0;
        if (v13)
        {
          if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        v8 += 11;
      }
      while (v8 != v9);
    }
    *(_DWORD *)(a2 + 32) = *(_DWORD *)(a2 + 36);
    *(_DWORD *)(a2 + 36) = -1082130432;
    return 1;
  }
  else
  {
    return md::FontAtlas::commitGlyphs(a1, (void *)a2, a3, 0);
  }
}

uint64_t md::TextLabelPart::layoutForDisplay(float32x2_t *this, md::LabelManager *a2, md::LabelAnimator *a3, __int32 *a4, _DWORD *a5, double a6, double a7, double a8, float64x2_t a9)
{
  LODWORD(a6) = *a5;
  this[68].i32[0] = *a5;
  LODWORD(a7) = a5[1];
  this[68].i32[1] = LODWORD(a7);
  this[51].i32[0] = this[98].i32[0];
  this[104].i32[0] = *a4;
  LODWORD(a8) = a4[1];
  this[104].i32[1] = LODWORD(a8);
  if (this[115].i8[0]) {
    this[115].i8[0] = 0;
  }
  uint64_t v10 = (md::LabelAnimator *)this[2];
  if (v10) {
    uint64_t v10 = (md::LabelAnimator *)*((void *)v10 + 148);
  }
  BOOL v11 = v10 == 0;
  if (v10) {
    uint64_t v12 = v10;
  }
  else {
    uint64_t v12 = a3;
  }
  if (v12)
  {
    uint64_t v13 = 563;
    if (!v11) {
      uint64_t v13 = 564;
    }
    unint64_t v14 = this->u8[v13];
    float v15 = (float32x2_t *)*((void *)v12 + 3);
    uint64_t v16 = (float32x2_t *)*((void *)v12 + 4);
    if (0x8E38E38E38E38E39 * (((char *)v16 - (char *)v15) >> 4) <= v14)
    {
      if (v15 == v16 || !*((unsigned char *)v12 + 89)) {
        goto LABEL_22;
      }
    }
    else
    {
      v15 += 18 * v14;
    }
    if (v15)
    {
      float32x2_t v17 = v15[9];
      if (v17)
      {
        a9.f64[0] = 0.0;
        *(float *)&a8 = fmaxf(fminf(v15[10].f32[0]+ (float)(*(float *)(**(void **)&v17 + 32 * *(unsigned int *)(*(void *)&v17 + 32) + 8)* (float)(v15[10].f32[1] - v15[10].f32[0])), 1.0), 0.0);
        this[115].i8[0] = 1;
        this[115].i32[1] = LODWORD(a8);
      }
      float32x2_t v18 = v15[11];
      if (v18)
      {
        a8 = COERCE_DOUBLE(vmla_n_f32(v15[12], vsub_f32(v15[13], v15[12]), *(float *)(**(void **)&v18 + 32 * *(unsigned int *)(*(void *)&v18 + 32) + 8)));
        if (this[63].i8[4])
        {
          float32x2_t v19 = this[41];
          float32x2_t v20 = vmul_n_f32(v19, *(float *)&a8);
          float32x2_t v21 = (float32x2_t)vrev64_s32((int32x2_t)vmul_lane_f32(v19, *(float32x2_t *)&a8, 1));
          LODWORD(a8) = vsub_f32(v20, v21).u32[0];
          HIDWORD(a8) = vadd_f32(v20, v21).i32[1];
        }
        *(int32x2_t *)&a9.f64[0] = vcltz_s32(vshl_n_s32(vdup_n_s32(v15[14].u8[0] == 0), 0x1FuLL));
        HIDWORD(a6) = LODWORD(a7);
        *(void *)&a7 = 0x8000000080000000;
        a6 = COERCE_DOUBLE(vadd_f32(*(float32x2_t *)&a8, (float32x2_t)vbsl_s8(*(int8x8_t *)&a9.f64[0], (int8x8_t)0x8000000080000000, *(int8x8_t *)&a6)));
        *(double *)&this[68] = a6;
      }
    }
  }
LABEL_22:
  uint64_t result = md::TextLabelPart::prepareQuadsForDisplay((md::TextLabelPart *)this, a2, a3, a6, a7, a8, a9);
  if (result == 37)
  {
    uint64_t v23 = *(void *)(*(void *)&this[74] + 16);
    unsigned __int8 v24 = atomic_load((unsigned __int8 *)(v23 + 125));
    if ((v24 & 1) == 0 || *(void *)(v23 + 56) == *(void *)(v23 + 64))
    {
      return 12;
    }
    else if (*(void *)(*(void *)&this[74] + 32) == *(void *)(*(void *)&this[74] + 40))
    {
      return 13;
    }
    else
    {
      float32x2_t v25 = this[2];
      if (v25)
      {
        this[95].i32[1] = *(_DWORD *)(*(void *)&v25 + 1300);
        this[103].i8[6] = *(unsigned char *)(*(void *)&v25 + 1079);
      }
      return 37;
    }
  }
  return result;
}

uint64_t md::HorizontalTextLabelPart::setTextAlignment(uint64_t result, int a2, int a3)
{
  uint64_t v3 = result + 960;
  if (a2) {
    uint64_t v3 = result + 1032;
  }
  if (*(unsigned __int8 *)(v3 + 66) != a3)
  {
    *(unsigned char *)(v3 + 66) = a3;
    *(unsigned char *)(v3 + 67) = 1;
  }
  return result;
}

void md::IconLabelPart::prepareCollisionObject(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  uint64_t v5 = 612;
  if (!a2) {
    uint64_t v5 = 588;
  }
  float v6 = *(float *)(a1 + v5);
  float v7 = (*(float (**)(uint64_t, void))(*(void *)a1 + 936))(a1, *a3);
  BOOL v11 = v6 == 1.0;
  float v12 = v9 * v6;
  float v13 = v10 * v6;
  if (v6 == 1.0) {
    float v14 = v7;
  }
  else {
    float v14 = v7 * v6;
  }
  if (v6 == 1.0) {
    float v15 = v8;
  }
  else {
    float v15 = v8 * v6;
  }
  if (v11) {
    float v16 = v9;
  }
  else {
    float v16 = v12;
  }
  if (v11) {
    float v17 = v10;
  }
  else {
    float v17 = v13;
  }
  float v18 = v17 - v15;
  float v19 = v16 - v14;
  if (vabds_f32(v17 - v15, v16 - v14) <= 5.0)
  {
    float v27 = v14 + (float)(v19 * 0.5);
    float v28 = v15 + (float)(v18 * 0.5);
    float v29 = fmaxf(v19, v18) * 0.5;
    md::CollisionObject::resetWithCircles((void **)a4, 1u);
    uint64_t v30 = *(void *)(a4 + 168);
    unsigned int v31 = *(_DWORD *)(a4 + 176);
    *(_DWORD *)(a4 + 176) = v31 + 1;
    uint64_t v32 = (float *)(v30 + 12 * v31);
    float *v32 = v27;
    v32[1] = v28;
    void v32[2] = v29;
    if (v29 == 0.0) {
      return;
    }
    float v33 = *(float *)(a4 + 12);
    float v34 = fmaxf(*(float *)(a4 + 8), v29 + v27);
    float v35 = fminf(v28 - v29, *(float *)(a4 + 4));
    *(float *)a4 = fminf(v27 - v29, *(float *)a4);
    *(float *)(a4 + 4) = v35;
    float v26 = fmaxf(v33, v29 + v28);
    *(float *)(a4 + 8) = v34;
  }
  else
  {
    md::CollisionObject::resetWithRects((void **)a4, 1u);
    uint64_t v20 = *(unsigned int *)(a4 + 176);
    float32x2_t v21 = (float *)(*(void *)(a4 + 160) + 16 * v20);
    *float32x2_t v21 = v14;
    v21[1] = v15;
    v21[2] = v16;
    v21[3] = v17;
    float v22 = fminf(v14, *(float *)a4);
    float v23 = *(float *)(a4 + 12);
    float v24 = fmaxf(*(float *)(a4 + 8), v16);
    float v25 = fminf(v15, *(float *)(a4 + 4));
    *(_DWORD *)(a4 + 176) = v20 + 1;
    *(float *)a4 = v22;
    *(float *)(a4 + 4) = v25;
    float v26 = fmaxf(v23, v17);
    *(float *)(a4 + 8) = v24;
  }
  *(float *)(a4 + 12) = v26;
}

double md::IconLabelPart::collisionBounds(md::IconLabelPart *this, const LabelIcon *a2)
{
  int v2 = *((unsigned __int8 *)this + 562);
  unsigned __int8 v3 = atomic_load((unsigned __int8 *)a2 + 144);
  if (v2 == 1)
  {
    if (v3)
    {
      LODWORD(result) = *((_DWORD *)a2 + 16);
      return result;
    }
    goto LABEL_5;
  }
  if ((v3 & 1) == 0)
  {
LABEL_5:
    LODWORD(result) = 2139095039;
    return result;
  }
  *(float32x2_t *)v5.f32 = vmaxnm_f32(vsub_f32(*(float32x2_t *)((char *)a2 + 72), *(float32x2_t *)((char *)a2 + 64)), 0);
  v5.i64[1] = v5.i64[0];
  *(void *)&double result = vmulq_f32(v5, (float32x4_t)xmmword_1A28FF850).u64[0];
  return result;
}

double md::CollisionObject::resetWithCircles(void **this, unsigned int a2)
{
  if (*((_DWORD *)this + 48) < a2)
  {
    free(this[23]);
    this[23] = malloc_type_calloc(a2, 0x18uLL, 0x1000040504FFAC1uLL);
    *((_DWORD *)this + 48) = a2;
  }
  uint64_t v4 = this[20];
  if (v4)
  {
    free(v4);
    this[20] = 0;
    *((_DWORD *)this + 45) = 0;
    if (!a2) {
      goto LABEL_9;
    }
  }
  else if (*((_DWORD *)this + 45) >= a2)
  {
    goto LABEL_9;
  }
  free(this[21]);
  float32x4_t v5 = malloc_type_malloc(12 * a2, 0x10000403E1C8BA9uLL);
  this[21] = v5;
  if (v5) {
    unsigned int v6 = a2;
  }
  else {
    unsigned int v6 = 0;
  }
  *((_DWORD *)this + 45) = v6;
LABEL_9:
  *((_DWORD *)this + 44) = 0;
  double result = 1.40444743e306;
  *(_OWORD *)this = xmmword_1A28FC750;
  return result;
}

float md::HorizontalTextLabelPart::topRightAlignInset(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 960;
  if (a2) {
    uint64_t v2 = a1 + 1032;
  }
  return *(float *)(v2 + 28);
}

__n128 ta2::TextureAtlas::allocateTextureRegion@<Q0>(uint64_t a1@<X0>, void *a2@<X1>, int a3@<W2>, __n128 *a4@<X8>)
{
  uint64_t v7 = *a2;
  uint64_t v8 = *(unsigned int *)(*a2 + 16);
  uint64_t v9 = *(unsigned int *)(*a2 + 20);
  unsigned int v10 = v8 + 2;
  unsigned int v11 = v9 + 2;
  if (!a3)
  {
    if (*(_DWORD *)(a1 + 56) >= v10 && *(_DWORD *)(a1 + 60) >= v11) {
      goto LABEL_8;
    }
LABEL_7:
    a4->n128_u64[0] = 0;
    a4->n128_u64[1] = 0;
    return result;
  }
  if (*(_DWORD *)(a1 + 64) < v10 || *(_DWORD *)(a1 + 68) < v11) {
    goto LABEL_7;
  }
LABEL_8:
  float v12 = (char *)operator new(0x78uLL);
  float v13 = (atomic_ullong *)v12;
  *((void *)v12 + 1) = 0;
  *((void *)v12 + 2) = 0;
  *(void *)float v12 = &unk_1EF58A7B0;
  float v14 = v12 + 24;
  uint64_t v16 = *(void *)(a1 + 272);
  uint64_t v15 = *(void *)(a1 + 280);
  *((void *)v12 + 3) = &unk_1EF567638;
  *((void *)v12 + 4) = v16;
  *((void *)v12 + 5) = v15;
  if (v15)
  {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
    uint64_t v7 = *a2;
  }
  *((void *)v12 + 6) = 0;
  *((void *)v12 + 7) = 0;
  *((void *)v12 + 8) = v8 | (v9 << 32);
  *(_OWORD *)(v12 + 72) = xmmword_1A28FC750;
  uint64_t v17 = a2[1];
  *((void *)v12 + 11) = v7;
  *((void *)v12 + 12) = v17;
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  *((_WORD *)v12 + 52) = 7680;
  *((void *)v12 + 14) = 0;
  v18.n128_u64[0] = (unint64_t)(v12 + 24);
  v18.n128_u64[1] = (unint64_t)v12;
  __n128 v22 = v18;
  std::mutex::lock((std::mutex *)(a1 + 160));
  float v19 = *(__n128 **)(a1 + 232);
  if ((unint64_t)v19 >= *(void *)(a1 + 240))
  {
    uint64_t v20 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>(a1 + 224, v22);
  }
  else
  {
    v19->n128_u64[0] = (unint64_t)v14;
    v19->n128_u64[1] = (unint64_t)v13;
    atomic_fetch_add_explicit(v13 + 1, 1uLL, memory_order_relaxed);
    uint64_t v20 = v19 + 1;
  }
  *(void *)(a1 + 232) = v20;
  std::mutex::unlock((std::mutex *)(a1 + 160));
  __n128 result = v22;
  *a4 = v22;
  return result;
}

float md::HorizontalTextLabelPart::topLeftAlignInset(uint64_t a1, int a2)
{
  uint64_t v2 = a1 + 960;
  if (a2) {
    uint64_t v2 = a1 + 1032;
  }
  return *(float *)(v2 + 24);
}

uint64_t __copy_helper_block_ea8_32c47_ZTSNSt3__18weak_ptrIN2md17RunLoopControllerEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(result + 32) = *(void *)(a2 + 32);
  *(void *)(result + 40) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 16), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t *geo::codec::forEachRoad(uint64_t *result, uint64_t a2)
{
  uint64_t v2 = *result;
  if (*result)
  {
    if (*(void *)(a2 + 24))
    {
      uint64_t v4 = *(void *)(v2 + 32);
      uint64_t v5 = *(void *)(v2 + 40) - v4;
      if (v5)
      {
        uint64_t v6 = v5 / 168;
        do
        {
          if (*(unsigned char *)(v4 + 154) == 1)
          {
            uint64_t v8 = v4;
            uint64_t v7 = *(void *)(a2 + 24);
            if (!v7) {
              std::__throw_bad_function_call[abi:ne180100]();
            }
            __n128 result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v7 + 48))(v7, &v8);
          }
          v4 += 168;
          --v6;
        }
        while (v6);
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<md::MuninAvailabilityData::MuninAvailabilityData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_1,std::allocator<md::MuninAvailabilityData::MuninAvailabilityData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_1>,void ()(GeoCodecsRoadFeature const*)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a2;
  md::createFeatureAttributeSet((gss::Allocator *)v9, (uint64_t *)(*a2 + 24));
  __int16 v8 = 0;
  uint64_t result = gss::FeatureAttributeSet::getValueForAttributeKey(v9, 74, &v8);
  if (!result)
  {
LABEL_5:
    uint64_t v7 = v9[0];
    if (!v9[0]) {
      return result;
    }
    goto LABEL_6;
  }
  uint64_t v5 = *(uint64_t **)(a1 + 8);
  uint64_t v6 = **(void **)(a1 + 16);
  v11[0] = &unk_1EF5756C0;
  v11[1] = v6;
  float v12 = v11;
  geo::codec::forEachEdgeInRoad(v5, v3, 0, (uint64_t)v11);
  uint64_t result = (uint64_t)v12;
  if (v12 != v11)
  {
    if (v12) {
      uint64_t result = (*(uint64_t (**)(void))(*v12 + 40))();
    }
    goto LABEL_5;
  }
  uint64_t result = (*(uint64_t (**)(void *))(v11[0] + 32))(v11);
  uint64_t v7 = v9[0];
  if (!v9[0]) {
    return result;
  }
LABEL_6:
  v9[1] = v7;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v10 + 40))(v10, v7, v9[2] - v7);
}

void sub_1A180227C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17 == v17)
  {
    (*(void (**)(uint64_t *))(a14 + 32))(&a14);
  }
  else if (a17)
  {
    (*(void (**)(void))(*(void *)a17 + 40))();
  }
  if (a10)
  {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a13 + 40))(a13, a10, a12 - a10);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t *geo::codec::forEachEdgeInRoad(uint64_t *result, uint64_t a2, char a3, uint64_t a4)
{
  if (a2)
  {
    uint64_t v4 = *result;
    if (*result)
    {
      if (*(void *)(a4 + 24))
      {
        uint64_t v8 = *(void *)(v4 + 688);
        uint64_t v9 = *(void *)(v4 + 728);
        if (*(_DWORD *)(a2 + 100)
          && (uint64_t result = geo::codec::vertexPoolForFeature(a2)) != 0
          && (uint64_t v10 = result[4]) != 0
          && (unint64_t v11 = *(unsigned int *)(a2 + 96), result[5] > v11)
          && *(void *)(v10 + 16 * v11) < (unint64_t)result[2])
        {
          unint64_t v12 = *(void *)(v10 + 16 * v11 + 8) - 1;
        }
        else
        {
          unint64_t v12 = -1;
        }
        uint64_t v13 = *(unsigned int *)(a2 + 132);
        unint64_t v14 = *(unsigned __int16 *)(a2 + 144);
        uint64_t v31 = a2;
        int8x16_t v32 = 0u;
        int8x16_t v33 = 0u;
        int8x16_t v34 = 0u;
        unint64_t v15 = 0;
        if (a3)
        {
          unint64_t v16 = 0;
          uint64_t v17 = v9 + 8 * v13;
          while (1)
          {
            if (v16 >= v14)
            {
              uint64_t v20 = 0;
              uint64_t v21 = 0;
              unint64_t v19 = v12;
              v32.i64[1] = v12;
              v33.i64[1] = 0;
              v34.i64[1] = 0;
              if (v15 >= v12) {
                goto LABEL_13;
              }
            }
            else
            {
              __n128 v18 = *(unsigned int **)(v17 + 8 * v16);
              unint64_t v19 = v18[3];
              uint64_t v20 = *v18;
              uint64_t v21 = v8 + 32 * v20;
              v32.i64[1] = v19;
              v33.i64[1] = v20;
              v34.i64[1] = v21;
              if (v15 >= v19) {
                goto LABEL_13;
              }
            }
            float v35 = &v31;
            uint64_t v22 = *(void *)(a4 + 24);
            if (!v22) {
              goto LABEL_30;
            }
            (*(void (**)(uint64_t, uint64_t **))(*(void *)v22 + 48))(v22, &v35);
            int8x16_t v32 = vextq_s8(v32, v32, 8uLL);
            int8x16_t v33 = vextq_s8(v33, v33, 8uLL);
            int8x16_t v34 = vextq_s8(v34, v34, 8uLL);
            float v35 = &v31;
            uint64_t v23 = *(void *)(a4 + 24);
            if (!v23) {
              goto LABEL_30;
            }
            uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)v23 + 48))(v23, &v35);
            unint64_t v19 = v32.i64[0];
            uint64_t v20 = v33.i64[0];
            v32.i64[1] = v32.i64[0];
            v33.i64[1] = v33.i64[0];
            uint64_t v21 = v34.i64[0];
            v34.i64[1] = v34.i64[0];
LABEL_13:
            v32.i64[0] = v19;
            v33.i64[0] = v20;
            v34.i64[0] = v21;
            ++v16;
            unint64_t v15 = v19;
            if (v14 + 1 == v16) {
              return result;
            }
          }
        }
        unint64_t v24 = 0;
        uint64_t v25 = v9 + 8 * v13;
        do
        {
          if (v24 >= v14)
          {
            uint64_t v28 = 0;
            uint64_t v29 = 0;
            unint64_t v27 = v12;
            v32.i64[1] = v12;
            v33.i64[1] = 0;
            v34.i64[1] = 0;
            if (v15 < v12)
            {
LABEL_27:
              float v35 = &v31;
              uint64_t v30 = *(void *)(a4 + 24);
              if (!v30) {
LABEL_30:
              }
                std::__throw_bad_function_call[abi:ne180100]();
              uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t **))(*(void *)v30 + 48))(v30, &v35);
              unint64_t v27 = v32.u64[1];
              uint64_t v28 = v33.i64[1];
              uint64_t v29 = v34.i64[1];
            }
          }
          else
          {
            float v26 = *(unsigned int **)(v25 + 8 * v24);
            unint64_t v27 = v26[3];
            uint64_t v28 = *v26;
            uint64_t v29 = v8 + 32 * v28;
            v32.i64[1] = v27;
            v33.i64[1] = v28;
            v34.i64[1] = v29;
            if (v15 < v27) {
              goto LABEL_27;
            }
          }
          v32.i64[0] = v27;
          v33.i64[0] = v28;
          v34.i64[0] = v29;
          ++v24;
          unint64_t v15 = v27;
        }
        while (v14 + 1 != v24);
      }
    }
  }
  return result;
}

void std::__function::__func<md::MuninAvailabilityData::MuninAvailabilityData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_0,std::allocator<md::MuninAvailabilityData::MuninAvailabilityData(gdc::LayerDataRequestKey const&,std::shared_ptr<geo::codec::VectorTile> const&)::$_0>,void ()(GeoCodecsRoadEdge *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = *a2;
  if (*a2)
  {
    uint64_t v3 = *(void *)(a1 + 8);
    unint64_t v28 = 0;
    uint64_t v4 = geo::codec::multiSectionFeaturePoints(*(void **)v2, 0, &v28);
    unint64_t v5 = *(void *)(v2 + 8);
    if (v5 < v28)
    {
      unint64_t v6 = *(void *)(v2 + 16);
      if (v6 < v28)
      {
        float32x2_t v7 = (float32x2_t)v4[v5];
        *(float32x2_t *)v8.f32 = v7;
        *(float32x2_t *)&v8.u32[2] = v7;
        v14.i64[0] = v4[v6];
        v9.i64[0] = v14.i64[0];
        v9.i64[1] = v14.i64[0];
        float32x4_t v10 = *(float32x4_t *)(v3 + 744);
        v11.i32[0] = vmovn_s32(vcgtq_f32(v10, v8)).u32[0];
        v11.i32[1] = vmovn_s32(vcgtq_f32(v8, v10)).i32[1];
        int8x16_t v12 = vbslq_s8((int8x16_t)vmovl_s16(v11), (int8x16_t)v8, (int8x16_t)v10);
        v13.i64[0] = v12.i64[0];
        v13.i64[1] = v14.i64[0];
        v14.i64[1] = vextq_s8(v12, v12, 8uLL).u64[0];
        *(int8x16_t *)(v3 + 744) = vbslq_s8((int8x16_t)vcgtq_f32(v13, v14), v9, v12);
        unint64_t v15 = *(float32x2_t **)(v3 + 728);
        unint64_t v16 = *(void *)(v3 + 736);
        if ((unint64_t)v15 >= v16)
        {
          __n128 v18 = *(float32x2_t **)(v3 + 720);
          uint64_t v19 = ((char *)v15 - (char *)v18) >> 4;
          unint64_t v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 60) {
            abort();
          }
          uint64_t v21 = v16 - (void)v18;
          if (v21 >> 3 > v20) {
            unint64_t v20 = v21 >> 3;
          }
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v22 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v22 = v20;
          }
          if (v22)
          {
            uint64_t v25 = v14.i64[0];
            float32x2_t v26 = v7;
            float32x2_t v27 = v7;
            if (v22 >> 60) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v23 = (char *)operator new(16 * v22);
            *(float32x2_t *)v8.f32 = v26;
            float32x2_t v7 = v27;
            v9.i64[0] = v25;
          }
          else
          {
            uint64_t v23 = 0;
          }
          unint64_t v24 = (float32x2_t *)&v23[16 * v19];
          *unint64_t v24 = v7;
          v24[1] = vsub_f32(*(float32x2_t *)v9.i8, *(float32x2_t *)v8.f32);
          uint64_t v17 = v24 + 2;
          if (v15 != v18)
          {
            do
            {
              *(_OWORD *)v24[-2].f32 = *(_OWORD *)v15[-2].f32;
              v24 -= 2;
              v15 -= 2;
            }
            while (v15 != v18);
            unint64_t v15 = *(float32x2_t **)(v3 + 720);
          }
          *(void *)(v3 + 720) = v24;
          *(void *)(v3 + 728) = v17;
          *(void *)(v3 + 736) = &v23[16 * v22];
          if (v15) {
            operator delete(v15);
          }
        }
        else
        {
          float32x2_t *v15 = v7;
          v15[1] = vsub_f32(*(float32x2_t *)v14.f32, v7);
          uint64_t v17 = v15 + 2;
        }
        *(void *)(v3 + 728) = v17;
      }
    }
  }
}

uint64_t ___ZN2md18LabelFeatureStyler18styleLabelFeaturesERNSt3__16vectorINS_22LabelFeatureStylerItemEN3geo12StdAllocatorIS3_N3mdm9AllocatorEEEEEbbPNS4_9TaskQueueE_block_invoke(uint64_t result, uint64_t a2)
{
  unint64_t v2 = 20 * a2;
  unint64_t v3 = 20 * a2 + 20;
  if (*(void *)(result + 32) < v3) {
    unint64_t v3 = *(void *)(result + 32);
  }
  unint64_t v4 = v3 - v2;
  if (v3 > v2)
  {
    uint64_t v5 = result;
    uint64_t v6 = 480 * a2;
    do
    {
      float32x2_t v7 = (void *)(**(void **)(v5 + 40) + v6);
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t, void, void, void, void))(*(void *)*v7 + 576))(*v7, **(void **)(v5 + 48) + 16 * v7[1], **(void **)(v5 + 56) + 16 * v7[1], v7[2], *(unsigned __int8 *)(v5 + 68), *(unsigned int *)(v5 + 64), 0);
      v6 += 24;
      --v4;
    }
    while (v4);
  }
  return result;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **,false>(uint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  float32x4_t v8 = (uint64_t *)result;
LABEL_2:
  int8x16_t v9 = a2 - 1;
  long long v79 = a2 - 3;
  long long v80 = a2 - 2;
  uint64_t j = v8;
  float32x2_t v81 = a2;
  while (1)
  {
    float32x4_t v8 = j;
    uint64_t v11 = (char *)a2 - (char *)j;
    uint64_t v12 = a2 - j;
    if (v5 || !v4)
    {
      switch(v12)
      {
        case 0:
        case 1:
          return result;
        case 2:
          uint64_t result = *v9;
          if (*v9 != *v8)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
            if (result)
            {
              uint64_t v38 = *v8;
              uint64_t *v8 = *v9;
              *int8x16_t v9 = v38;
            }
          }
          break;
        case 3:
          uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(v8, v8 + 1, v9);
          break;
        case 4:
          uint64_t result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(v8, v8 + 1, v8 + 2, v9);
          break;
        case 5:
          uint64_t result = std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **,0>(v8, v8 + 1, v8 + 2, v8 + 3, v9);
          break;
        default:
          JUMPOUT(0);
      }
      return result;
    }
    if (v11 <= 191) {
      break;
    }
    if (!a3)
    {
      if (v8 == a2) {
        return result;
      }
      int64_t v50 = (unint64_t)(v12 - 2) >> 1;
      int64_t v83 = v50;
      while (1)
      {
        int64_t v52 = v50;
        if (v83 >= v50)
        {
          uint64_t v53 = (2 * v50) | 1;
          double v54 = &v8[v53];
          if (2 * v50 + 2 < v12
            && *v54 != v54[1]
            && (*(unsigned int (**)(uint64_t))(*(void *)*v54 + 80))(*v54))
          {
            ++v54;
            uint64_t v53 = 2 * v52 + 2;
          }
          uint64_t result = *v54;
          if (*v54 == v8[v52])
          {
            uint64_t v55 = *v54;
LABEL_123:
            v8[v52] = result;
            if (v83 >= v53)
            {
              while (1)
              {
                uint64_t v57 = 2 * v53;
                uint64_t v53 = (2 * v53) | 1;
                double v51 = &v8[v53];
                uint64_t v58 = v57 + 2;
                if (v57 + 2 < v12
                  && *v51 != v51[1]
                  && (*(unsigned int (**)(uint64_t))(*(void *)*v51 + 80))(*v51))
                {
                  ++v51;
                  uint64_t v53 = v58;
                }
                uint64_t result = *v51;
                uint64_t v56 = v55;
                if (*v51 != v55)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 80))(result, v55);
                  if (result) {
                    break;
                  }
                  uint64_t v56 = *v51;
                }
                *double v54 = v56;
                double v54 = v51;
                if (v83 < v53) {
                  goto LABEL_112;
                }
              }
            }
            double v51 = v54;
LABEL_112:
            uint64_t *v51 = v55;
            goto LABEL_113;
          }
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
          if ((result & 1) == 0)
          {
            uint64_t v55 = v8[v52];
            uint64_t result = *v54;
            goto LABEL_123;
          }
        }
LABEL_113:
        int64_t v50 = v52 - 1;
        if (!v52)
        {
          uint64_t v59 = (unint64_t)v11 >> 3;
          double v60 = v81;
          do
          {
            double v62 = v60;
            uint64_t v63 = 0;
            uint64_t v64 = *v8;
            double v65 = v8;
            do
            {
              uint64_t v66 = v65;
              v65 += v63 + 1;
              uint64_t v67 = 2 * v63;
              uint64_t v63 = (2 * v63) | 1;
              uint64_t v68 = v67 + 2;
              if (v67 + 2 < v59)
              {
                uint64_t result = *v65;
                if (*v65 != v65[1])
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
                  if (result)
                  {
                    ++v65;
                    uint64_t v63 = v68;
                  }
                }
              }
              uint64_t *v66 = *v65;
            }
            while (v63 <= (uint64_t)((unint64_t)(v59 - 2) >> 1));
            long long v69 = v62 - 1;
            if (v65 == v69)
            {
              double v60 = v69;
              *double v65 = v64;
            }
            else
            {
              *double v65 = *v69;
              double v60 = v69;
              *long long v69 = v64;
              uint64_t v70 = (char *)v65 - (char *)v8 + 8;
              if (v70 >= 9)
              {
                unint64_t v71 = (((unint64_t)v70 >> 3) - 2) >> 1;
                long long v72 = &v8[v71];
                uint64_t result = *v72;
                if (*v72 != *v65)
                {
                  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
                  if (result)
                  {
                    uint64_t v73 = *v65;
                    do
                    {
                      long long v74 = v72;
                      *double v65 = *v72;
                      if (!v71) {
                        break;
                      }
                      unint64_t v71 = (v71 - 1) >> 1;
                      long long v72 = &v8[v71];
                      uint64_t result = *v72;
                      if (*v72 == v73) {
                        break;
                      }
                      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 80))(result, v73);
                      double v65 = v74;
                    }
                    while ((result & 1) != 0);
                    *long long v74 = v73;
                  }
                }
              }
            }
          }
          while (v59-- > 2);
          return result;
        }
      }
    }
    unint64_t v13 = (unint64_t)v12 >> 1;
    float32x4_t v14 = &v8[(unint64_t)v12 >> 1];
    if ((unint64_t)v11 < 0x401)
    {
      uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(v14, v8, v9);
    }
    else
    {
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(v8, v14, v9);
      uint64_t v15 = v13;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(v8 + 1, &v8[v15 - 1], v80);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(v8 + 2, &v8[v15 + 1], v79);
      uint64_t result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(&v8[v15 - 1], v14, &v8[v15 + 1]);
      uint64_t v16 = *v8;
      uint64_t *v8 = v8[v15];
      v8[v15] = v16;
    }
    --a3;
    if (a4)
    {
LABEL_13:
      __n128 v18 = v8 + 1;
      uint64_t v19 = *v8;
      do
      {
        unint64_t v20 = v18;
        if (*v18 == v19) {
          break;
        }
        char v21 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)*v18 + 80))(*v18, v19);
        __n128 v18 = v20 + 1;
      }
      while ((v21 & 1) != 0);
      unint64_t v22 = v20 - 1;
      unint64_t i = v9;
      if (v20 - 1 == v8)
      {
        unint64_t i = v81;
        if (v20 < v81)
        {
          for (unint64_t i = v9; ; --i)
          {
            if (*i == v19)
            {
              if (v20 >= i) {
                break;
              }
            }
            else
            {
              char v32 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)*i + 80))(*i, v19);
              if (v20 >= i || (v32 & 1) != 0) {
                break;
              }
            }
          }
        }
      }
      else
      {
        while (*i == v19 || ((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)*i + 80))(*i, v19) & 1) == 0)
          --i;
      }
      if (v20 < i)
      {
        unint64_t v24 = v20;
        uint64_t v25 = i;
        do
        {
          uint64_t v26 = *v24;
          *unint64_t v24 = *v25;
          uint64_t *v25 = v26;
          float32x2_t v27 = v24 + 1;
          do
          {
            unint64_t v24 = v27;
            if (*v27 == v19) {
              break;
            }
            char v28 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)*v27 + 80))(*v27, v19);
            float32x2_t v27 = v24 + 1;
          }
          while ((v28 & 1) != 0);
          unint64_t v22 = v24 - 1;
          do
          {
            do
            {
              uint64_t v30 = *--v25;
              uint64_t v29 = v30;
            }
            while (v30 == v19);
          }
          while (((*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v29 + 80))(v29, v19) & 1) == 0);
        }
        while (v24 < v25);
      }
      if (v22 != v8) {
        uint64_t *v8 = *v22;
      }
      uint64_t *v22 = v19;
      BOOL v4 = v20 >= i;
      a2 = v81;
      if (v4)
      {
        BOOL v31 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(v8, v22);
        uint64_t j = v22 + 1;
        uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(v22 + 1, v81);
        if (result)
        {
          a2 = v22;
          if (v31) {
            return result;
          }
          goto LABEL_2;
        }
        if (!v31) {
          goto LABEL_37;
        }
      }
      else
      {
LABEL_37:
        uint64_t result = std::__introsort<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **,false>(v8, v22, a3, a4 & 1);
        a4 = 0;
        uint64_t j = v22 + 1;
      }
    }
    else
    {
      uint64_t v17 = *(v8 - 1);
      if (v17 != *v8)
      {
        uint64_t result = (*(uint64_t (**)(void))(*(void *)v17 + 80))(*(v8 - 1));
        if (result) {
          goto LABEL_13;
        }
        uint64_t v17 = *v8;
      }
      if (v17 == *v9 || (uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17), !result))
      {
        for (uint64_t j = v8 + 1; j < a2; ++j)
        {
          if (v17 != *j)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17);
            if (result) {
              break;
            }
          }
        }
      }
      else
      {
        for (uint64_t j = v8 + 1; ; ++j)
        {
          if (v17 != *j)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17);
            if (result) {
              break;
            }
          }
        }
      }
      int8x16_t v33 = a2;
      if (j < a2)
      {
        int8x16_t v34 = v9;
        do
        {
          int8x16_t v33 = v34;
          if (v17 == *v34) {
            break;
          }
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17);
          int8x16_t v34 = v33 - 1;
        }
        while ((result & 1) != 0);
      }
      while (j < v33)
      {
        uint64_t v35 = *j;
        *j++ = *v33;
        uint64_t *v33 = v35;
        while (1)
        {
          if (v17 != *j)
          {
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17);
            if (result) {
              break;
            }
          }
          ++j;
        }
        uint64_t v36 = v33 - 1;
        do
        {
          int8x16_t v33 = v36;
          if (v17 == *v36) {
            break;
          }
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v17 + 80))(v17);
          uint64_t v36 = v33 - 1;
        }
        while ((result & 1) != 0);
      }
      uint64_t v37 = j - 1;
      BOOL v4 = j - 1 >= v8;
      BOOL v5 = j - 1 == v8;
      if (j - 1 != v8) {
        uint64_t *v8 = *v37;
      }
      a4 = 0;
      uint64_t *v37 = v17;
    }
  }
  long long v39 = v8 + 1;
  BOOL v41 = v8 == a2 || v39 == a2;
  if (a4)
  {
    if (v41) {
      return result;
    }
    uint64_t v42 = 0;
    double v43 = v8;
    while (1)
    {
      uint64_t v45 = *v43;
      uint64_t result = v43[1];
      double v43 = v39;
      if (result != v45)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
        if (result)
        {
          uint64_t v46 = *v43;
          uint64_t v47 = v42;
          while (1)
          {
            uint64_t v48 = v47;
            uint64_t v49 = (uint64_t *)((char *)v8 + v47);
            v49[1] = *v49;
            if (!v48) {
              break;
            }
            if (v46 != *(v49 - 1))
            {
              uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v46 + 80))(v46);
              uint64_t v47 = v48 - 8;
              if (result) {
                continue;
              }
            }
            long long v44 = (uint64_t *)((char *)v8 + v48);
            goto LABEL_99;
          }
          long long v44 = v8;
LABEL_99:
          *long long v44 = v46;
        }
      }
      long long v39 = v43 + 1;
      v42 += 8;
      if (v43 + 1 == a2) {
        return result;
      }
    }
  }
  if (!v41)
  {
    do
    {
      float v75 = v8;
      float32x4_t v8 = v39;
      uint64_t result = v75[1];
      if (result != *v75)
      {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
        if (result)
        {
          uint64_t v76 = *v8;
          do
          {
            long long v77 = v75;
            v75[1] = *v75;
            uint64_t v78 = *--v75;
            if (v76 == v78) {
              break;
            }
            uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)v76 + 80))(v76);
          }
          while ((result & 1) != 0);
          *long long v77 = v76;
        }
      }
      long long v39 = v8 + 1;
    }
    while (v8 + 1 != a2);
  }
  return result;
}

BOOL md::Label::collisionPriorityCmp(unint64_t a1, unsigned int a2, unint64_t a3, unsigned int a4, int a5)
{
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)(a1 + 1240));
  unsigned __int8 v6 = atomic_load((unsigned __int8 *)(a3 + 1240));
  if ((v5 & 1) != (v6 & 1))
  {
    unsigned __int8 v7 = atomic_load((unsigned __int8 *)(a1 + 1240));
    return v7 & 1;
  }
  unint64_t v9 = a3;
  unint64_t v10 = a1;
  if (a5)
  {
    uint64_t v11 = *(void *)(a1 + 24);
    uint64_t v12 = *(void *)(a3 + 24);
    if (v11)
    {
      if (v11 == v12)
      {
        BOOL v28 = a2 > a4;
        if (a2 == a4)
        {
          BOOL v29 = *(_DWORD *)(a1 + 32) >= *(_DWORD *)(a3 + 32);
          return !v29;
        }
        return v28;
      }
      unint64_t v13 = *(void *)(v11 + 72);
      if (v13) {
        unint64_t v10 = v13;
      }
    }
    if (v12)
    {
      unint64_t v14 = *(void *)(v12 + 72);
      if (v14) {
        unint64_t v9 = v14;
      }
    }
  }
  if (a2 == 1 || *(unsigned char *)(v10 + 1248)) {
    uint64_t v15 = (int *)(v10 + 724);
  }
  else {
    uint64_t v15 = (int *)(v10 + 720);
  }
  int v16 = *v15;
  if (a4 == 1 || *(unsigned char *)(v9 + 1248)) {
    uint64_t v17 = (int *)(v9 + 724);
  }
  else {
    uint64_t v17 = (int *)(v9 + 720);
  }
  int v18 = *v17;
  BOOL v19 = v16 < v18;
  if (v16 != v18) {
    return v19;
  }
  float v20 = *(float *)(v10 + 728);
  float v21 = *(float *)(v9 + 728);
  BOOL v19 = v20 < v21;
  if (v20 != v21) {
    return v19;
  }
  float v22 = *(float *)(v10 + 740);
  float v23 = *(float *)(v9 + 740);
  BOOL v19 = v22 < v23;
  if (v22 != v23) {
    return v19;
  }
  int v24 = *(_DWORD *)(v10 + 60);
  int v25 = *(_DWORD *)(v9 + 60);
  BOOL v19 = v24 < v25;
  if (v24 != v25) {
    return v19;
  }
  unsigned int v26 = *(unsigned __int8 *)(v10 + 1222);
  unsigned int v27 = *(unsigned __int8 *)(v9 + 1222);
  BOOL v28 = v26 > v27;
  if (v26 != v27) {
    return v28;
  }
  if (a5)
  {
    if (*(unsigned char *)(v10 + 1277))
    {
      if (*(unsigned char *)(v9 + 1277))
      {
        BOOL result = *(unsigned char *)(v10 + 1252) != 0;
        if ((*(unsigned char *)(v10 + 1252) != 0) != (*(unsigned char *)(v9 + 1252) != 0)) {
          return result;
        }
        goto LABEL_39;
      }
      return *(unsigned char *)(v10 + 1277) != 0;
    }
    if (*(unsigned char *)(v9 + 1277)) {
      return *(unsigned char *)(v10 + 1277) != 0;
    }
  }
LABEL_39:
  float v30 = *(float *)(v10 + 196);
  float v31 = *(float *)(v9 + 196);
  BOOL v19 = v30 < v31;
  if (v30 != v31) {
    return v19;
  }
  unint64_t v32 = (*(uint64_t (**)(void, void))(**(void **)(v10 + 8) + 472))(*(void *)(v10 + 8), 0);
  uint64_t v33 = (*(uint64_t (**)(void))(**(void **)(v9 + 8) + 472))();
  BOOL result = v32 != 0;
  if (!(v32 | v33)) {
    goto LABEL_49;
  }
  if (v32 && v33)
  {
    unsigned int v34 = std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::compare((const void **)v32, (unsigned char *)v33);
    if (v34) {
      return v34 >> 31;
    }
LABEL_49:
    BOOL v29 = v10 >= v9;
    return !v29;
  }
  return result;
}

BOOL md::LabelCollisionItem::outranksItem(md::LabelCollisionItem *this, const md::LabelCollisionItemBase *a2)
{
  unsigned int v2 = *((unsigned __int8 *)a2 + 52);
  if (v2 == 4) {
    return md::Label::collisionPriorityCmp(*((void *)this + 7), *((unsigned __int8 *)this + 64), *((void *)a2 + 7), *((unsigned __int8 *)a2 + 64), 1);
  }
  else {
    return *((unsigned __int8 *)this + 52) <= v2;
  }
}

void md::LabelFeature::setStyle(md::LabelFeature *this, uint64_t a2, uint64_t a3, unint64_t a4, int a5, int a6)
{
  unint64_t v8 = a4;
  uint64_t v11 = *((void *)this + 12);
  uint64_t v12 = (void *)*((void *)this + 13);
  unint64_t v13 = ((uint64_t)v12 - v11) >> 4;
  unint64_t v14 = a4 - v13;
  if (a4 > v13)
  {
    uint64_t v15 = *((void *)this + 14);
    if (v14 <= (v15 - (uint64_t)v12) >> 4)
    {
      unsigned int v26 = &v12[2 * v14];
      uint64_t v27 = 16 * a4 - 16 * v13;
      do
      {
        if (v12)
        {
          *uint64_t v12 = 0;
          v12[1] = 0;
        }
        v12 += 2;
        v27 -= 16;
      }
      while (v27);
      *((void *)this + 13) = v26;
    }
    else
    {
      if (a4 >> 60) {
        abort();
      }
      uint64_t v16 = v15 - v11;
      uint64_t v17 = v16 >> 3;
      if (v16 >> 3 <= a4) {
        uint64_t v17 = a4;
      }
      if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0) {
        uint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v18 = v17;
      }
      uint64_t v19 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 15) + 16))(*((void *)this + 15), 16 * v18, 8);
      float v20 = (void *)(v19 + 16 * v13);
      uint64_t v21 = v19 + 16 * v8;
      uint64_t v22 = 16 * v8 - 16 * v13;
      float v23 = v20;
      do
      {
        if (v23)
        {
          *float v23 = 0;
          v23[1] = 0;
        }
        v23 += 2;
        v22 -= 16;
      }
      while (v22);
      uint64_t v45 = v19 + 16 * v18;
      uint64_t v46 = (void *)*((void *)this + 12);
      uint64_t v47 = (void *)*((void *)this + 13);
      if (v47 == v46)
      {
        *((void *)this + 12) = v20;
        *((void *)this + 13) = v21;
        uint64_t v50 = *((void *)this + 14);
        *((void *)this + 14) = v45;
      }
      else
      {
        do
        {
          long long v48 = *((_OWORD *)v47 - 1);
          v47 -= 2;
          *((_OWORD *)v20 - 1) = v48;
          v20 -= 2;
          void *v47 = 0;
          v47[1] = 0;
        }
        while (v47 != v46);
        uint64_t v47 = (void *)*((void *)this + 12);
        uint64_t v49 = (void *)*((void *)this + 13);
        *((void *)this + 12) = v20;
        *((void *)this + 13) = v21;
        uint64_t v50 = *((void *)this + 14);
        for (*((void *)this + 14) = v45; v49 != v47; v49 -= 2)
        {
          double v51 = (std::__shared_weak_count *)*(v49 - 1);
          if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
            std::__shared_weak_count::__release_weak(v51);
          }
        }
      }
      if (v47) {
        (*(void (**)(void, void *, uint64_t))(**((void **)this + 15) + 40))(*((void *)this + 15), v47, v50 - (void)v47);
      }
    }
LABEL_69:
    uint64_t v52 = 0;
    do
    {
      uint64_t v53 = *((void *)this + 12);
      long long v54 = *(_OWORD *)(a3 + v52);
      uint64_t v55 = *(void *)(a3 + v52 + 8);
      if (v55) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v55 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v56 = v53 + v52;
      uint64_t v57 = *(std::__shared_weak_count **)(v56 + 8);
      *(_OWORD *)uint64_t v56 = v54;
      if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
        std::__shared_weak_count::__release_weak(v57);
      }
      v52 += 16;
      --v8;
    }
    while (v8);
    goto LABEL_26;
  }
  if (a4 < v13)
  {
    for (unint64_t i = (void *)(v11 + 16 * a4); v12 != i; v12 -= 2)
    {
      int v25 = (std::__shared_weak_count *)*(v12 - 1);
      if (v25 && !atomic_fetch_add(&v25->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v25->__on_zero_shared)(v25);
        std::__shared_weak_count::__release_weak(v25);
      }
    }
    *((void *)this + 13) = i;
  }
  if (v8) {
    goto LABEL_69;
  }
LABEL_26:
  if (*((_DWORD *)this + 32) == a6)
  {
    int v28 = *((_DWORD *)this + 33);
    if ((v28 + 1) > 1) {
      int v29 = v28 + 1;
    }
    else {
      int v29 = 1;
    }
  }
  else
  {
    int v29 = 1;
    *((_DWORD *)this + 32) = a6;
  }
  *((_DWORD *)this + 33) = v29;
  float v30 = (uint64_t *)*((void *)this + 12);
  if (v30 == *((uint64_t **)this + 13) || (uint64_t v31 = *v30) == 0)
  {
    uint64_t v42 = (std::__shared_weak_count *)*((void *)this + 11);
    *((void *)this + 10) = 0;
    *((void *)this + 11) = 0;
    if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
      std::__shared_weak_count::__release_weak(v42);
    }
    uint64_t v44 = *((void *)this + 20);
    for (uint64_t j = *((void *)this + 21); j != v44; geo::StdAllocator<md::TextDataEntry,mdm::Allocator>::destroy(j))
      j -= 56;
    *((void *)this + 21) = v44;
    md::LabelFeature::updateTextVector(this);
    *((unsigned char *)this + 136) = 0;
    *((unsigned char *)this + 138) = 0;
    return;
  }
  uint64_t v32 = v30[1];
  if (v32) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v33 = (std::__shared_weak_count *)*((void *)this + 11);
  *((void *)this + 10) = v31;
  *((void *)this + 11) = v32;
  if (v33 && !atomic_fetch_add(&v33->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  if (!(*(uint64_t (**)(md::LabelFeature *))(*(void *)this + 488))(this)) {
    return;
  }
  uint64_t v34 = (*(uint64_t (**)(md::LabelFeature *, void))(*(void *)this + 472))(this, 0);
  if (v34)
  {
    if (*(char *)(v34 + 23) < 0)
    {
      if (*(void *)(v34 + 8)) {
        goto LABEL_42;
      }
    }
    else if (*(unsigned char *)(v34 + 23))
    {
LABEL_42:
      uint64_t v35 = (uint64_t *)*((void *)this + 10);
      uint64_t v36 = *v35;
      uint64_t v37 = (std::__shared_weak_count *)v35[1];
      uint64_t v84 = *v35;
      long long v85 = v37;
      if (v37) {
        atomic_fetch_add_explicit(&v37->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v86, v36, (uint64_t)v37);
      if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
      if (v87)
      {
        uint64_t v38 = *(void *)(v86[0] + 24);
        unsigned int v39 = *(unsigned __int8 *)(v38 + 12);
        if (v39 == 2)
        {
          LOBYTE(v84) = 1;
          char v88 = 1;
          long long v40 = (int *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v38, 0x7Du, 0, &v84);
          gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(v38, 0x7Du, 1u, &v88);
          int v41 = *v40;
        }
        else
        {
          int v41 = *(_DWORD *)gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(*(void *)(v86[0] + 24), 0x7Du, v39, 0);
        }
      }
      else
      {
        LOBYTE(v41) = 0;
      }
      gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v86);
      goto LABEL_81;
    }
  }
  LOBYTE(v41) = 0;
LABEL_81:
  *((unsigned char *)this + 138) = v41;
  uint64_t v58 = (*(uint64_t (**)(md::LabelFeature *, void))(*(void *)this + 472))(this, 0);
  uint64_t v59 = (*(uint64_t (**)(md::LabelFeature *, void))(*(void *)this + 480))(this, 0);
  if (!v58 || !v59) {
    return;
  }
  if (*(char *)(v58 + 23) < 0)
  {
    if (!*(void *)(v58 + 8)) {
      return;
    }
  }
  else if (!*(unsigned char *)(v58 + 23))
  {
    return;
  }
  uint64_t v60 = (*(uint64_t (**)(md::LabelFeature *))(*(void *)this + 488))(this);
  uint64_t v62 = *((void *)this + 20);
  uint64_t v61 = *((void *)this + 21);
  if (v60 == 0x6DB6DB6DB6DB6DB7 * ((v61 - v62) >> 3) && !a5) {
    goto LABEL_102;
  }
  if (v62 == v61) {
    goto LABEL_101;
  }
  uint64_t v63 = *((void *)this + 20);
  do
  {
    uint64_t v64 = *(char **)(v63 + 24);
    double v65 = *(char **)(v63 + 32);
    if (v64 == v65) {
      goto LABEL_91;
    }
    unint64_t v66 = v65 - v64 - 16;
    if (v66 <= 0xF) {
      goto LABEL_98;
    }
    uint64_t v67 = (v66 >> 4) + 1;
    uint64_t v68 = (uint64_t *)(v64 + 16);
    uint64_t v69 = v67 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      uint64_t v70 = *(v68 - 2);
      uint64_t v71 = *v68;
      v68 += 4;
      *(unsigned char *)(v70 + 120) = 0;
      *(unsigned char *)(v71 + 120) = 0;
      v69 -= 2;
    }
    while (v69);
    if (v67 != (v67 & 0x1FFFFFFFFFFFFFFELL))
    {
      v64 += 16 * (v67 & 0x1FFFFFFFFFFFFFFELL);
      do
      {
LABEL_98:
        uint64_t v72 = *(void *)v64;
        v64 += 16;
        *(unsigned char *)(v72 + 120) = 0;
      }
      while (v64 != v65);
    }
LABEL_91:
    v63 += 56;
  }
  while (v63 != v61);
  do
  {
    v61 -= 56;
    geo::StdAllocator<md::TextDataEntry,mdm::Allocator>::destroy(v61);
  }
  while (v61 != v62);
LABEL_101:
  *((void *)this + 21) = v62;
  md::LabelFeature::updateTextVector(this);
LABEL_102:
  uint64_t v73 = (uint64_t *)*((void *)this + 10);
  uint64_t v74 = *v73;
  if (*v73)
  {
    float v75 = (std::__shared_weak_count *)v73[1];
    uint64_t v84 = *v73;
    long long v85 = v75;
    if (v75) {
      atomic_fetch_add_explicit(&v75->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    gss::QueryableLocker<gss::PropertyID>::QueryableLocker(v86, v74, (uint64_t)v75);
    if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
      std::__shared_weak_count::__release_weak(v75);
    }
    if (v87)
    {
      unsigned __int8 v76 = 0;
      do
      {
        uint64_t v78 = *(void *)(v86[0] + 24);
        int v79 = *(unsigned __int8 *)(v78 + 12);
        if (v79 == 2)
        {
          LOBYTE(v84) = 1;
          char v88 = 1;
          int v80 = *(unsigned __int8 *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v78, 0x5Bu, v76, 0, &v84);
          gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>((unsigned __int16 *)v78, 0x5Bu, v76, 1, &v88);
          if (v80) {
            goto LABEL_117;
          }
        }
        else if (*(unsigned char *)gss::RenderStyle<gss::PropertyID>::styleValueForKeyAtZ<BOOL>(*(unsigned __int16 **)(v86[0] + 24), 0x5Bu, v76, v79, 0))
        {
          goto LABEL_117;
        }
        unsigned int v77 = v76++;
      }
      while (v77 < 0x17);
    }
    unsigned __int8 v76 = -4;
LABEL_117:
    gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)v86);
  }
  else
  {
    unsigned __int8 v76 = 0;
  }
  *((unsigned char *)this + 137) = v76;
  if (!*((unsigned char *)this + 140))
  {
    BOOL v81 = (*(float (**)(md::LabelFeature *))(*(void *)this + 240))(this) == 254.0;
    float v82 = 0.0;
    if (!v81) {
      float v82 = (*(float (**)(md::LabelFeature *, double))(*(void *)this + 240))(this, 0.0);
    }
    unsigned int v83 = (int)fminf(fmaxf(v82, 0.0), 252.0);
    if (*((unsigned __int8 *)this + 137) <= v83) {
      unsigned __int8 v76 = v83;
    }
    else {
      unsigned __int8 v76 = *((unsigned char *)this + 137);
    }
  }
  *((unsigned char *)this + 136) = v76;
}

void sub_1A1803F54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t md::PointLabelFeature::publicName(md::PointLabelFeature *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 68);
  uint64_t v3 = *((void *)this + 69) - v2;
  uint64_t v4 = v2 + (a2 << 6);
  if (a2 >= v3 >> 6) {
    return 0;
  }
  else {
    return v4;
  }
}

uint64_t gss::RenderStyle<gss::PropertyID>::styleValueForKey<unsigned int>(uint64_t result, unsigned int a2, unsigned int a3, unsigned char *a4)
{
  uint64_t v4 = *(void *)(result + 16 * a3 + 16);
  if (!v4)
  {
    if (a4) {
      *a4 = 0;
    }
    return (uint64_t)gss::defaultValueForKey<gss::PropertyID,unsigned int>(a2);
  }
  uint64_t v5 = result + 16 * a3;
  uint64_t v6 = *(unsigned __int16 *)(v5 + 56);
  if (!*(_WORD *)(v5 + 56))
  {
LABEL_31:
    int v24 = *(unsigned __int16 ****)(v4 + 72);
    if (v24)
    {
      uint64_t v11 = *v24;
      uint64_t v25 = *((unsigned __int16 *)v11 + 5);
      if (!*((_WORD *)v11 + 5))
      {
        LOWORD(v33) = 0;
        goto LABEL_66;
      }
      uint64_t v26 = (uint64_t)*v11;
      if (!*((unsigned char *)v11 + 15))
      {
        uint64_t v34 = 2 * v25;
        uint64_t v35 = *v11;
        while (*v35 != a2)
        {
          ++v35;
          v34 -= 2;
          if (!v34)
          {
            uint64_t v35 = (unsigned __int16 *)(v26 + 2 * v25);
            break;
          }
        }
        unint64_t v33 = ((unint64_t)v35 - v26) >> 1;
LABEL_66:
        if (v25 != (unsigned __int16)v33)
        {
          uint64_t v42 = *((unsigned __int16 *)v11 + 21);
          if (!*((_WORD *)v11 + 21)) {
            return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          }
          float v30 = v11[4];
          if (*((unsigned char *)v11 + 47))
          {
            if (v42 >= 0x1E)
            {
              long long v54 = v11[4];
              unint64_t v55 = *((unsigned __int16 *)v11 + 21);
              do
              {
                unint64_t v56 = v55 >> 1;
                uint64_t v57 = &v54[v55 >> 1];
                unsigned int v59 = *v57;
                uint64_t v58 = v57 + 1;
                v55 += ~(v55 >> 1);
                if (v59 < a2) {
                  long long v54 = v58;
                }
                else {
                  unint64_t v55 = v56;
                }
              }
              while (v55);
              if (v54 == &v30[v42] || *v54 != a2) {
                return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
              }
              unint64_t v31 = (unint64_t)((char *)v54 - (char *)v30) >> 1;
            }
            else
            {
              unint64_t v31 = 0;
              BOOL result = (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
              while (1)
              {
                unsigned int v43 = v30[v31];
                if (v43 >= a2) {
                  break;
                }
                if (v42 == ++v31) {
                  return result;
                }
              }
              if (v43 != a2) {
                LOWORD(v31) = *((_WORD *)v11 + 21);
              }
            }
          }
          else
          {
            uint64_t v46 = 2 * v42;
            uint64_t v47 = v11[4];
            while (*v47 != a2)
            {
              ++v47;
              v46 -= 2;
              if (!v46)
              {
                uint64_t v47 = &v30[v42];
                break;
              }
            }
            unint64_t v31 = (unint64_t)((char *)v47 - (char *)v30) >> 1;
          }
          if (v42 == (unsigned __int16)v31) {
            return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
          }
          if (v42 <= (unsigned __int16)v31) {
            return result;
          }
          return (uint64_t)&v30[2 * (unsigned __int16)v31] + *((unsigned __int16 *)v11 + 20);
        }
        goto LABEL_67;
      }
      if (v25 < 0x1E)
      {
        uint64_t v27 = 0;
        while (1)
        {
          unsigned int v28 = *(unsigned __int16 *)(v26 + 2 * v27);
          if (v28 >= a2) {
            break;
          }
          if (v25 == ++v27) {
            goto LABEL_67;
          }
        }
        if (v28 == a2) {
          LOWORD(v33) = v27;
        }
        else {
          LOWORD(v33) = *((_WORD *)v11 + 5);
        }
        goto LABEL_66;
      }
      uint64_t v36 = *v11;
      unint64_t v37 = *((unsigned __int16 *)v11 + 5);
      do
      {
        unint64_t v38 = v37 >> 1;
        unsigned int v39 = &v36[v37 >> 1];
        unsigned int v41 = *v39;
        long long v40 = v39 + 1;
        v37 += ~(v37 >> 1);
        if (v41 < a2) {
          uint64_t v36 = v40;
        }
        else {
          unint64_t v37 = v38;
        }
      }
      while (v37);
      if (v36 != (unsigned __int16 *)(v26 + 2 * v25) && *v36 == a2)
      {
        unint64_t v33 = ((unint64_t)v36 - v26) >> 1;
        goto LABEL_66;
      }
    }
LABEL_67:
    if (a4) {
      *a4 = 0;
    }
    return (uint64_t)gss::defaultValueForKey<gss::PropertyID,unsigned int>(a2);
  }
  uint64_t v7 = *(void *)(v5 + 48);
  uint64_t v8 = v7 + 8 * v6;
  while (1)
  {
    unint64_t v10 = *(unsigned __int16 ****)(*(void *)v7 + 72);
    if (v10)
    {
      uint64_t v11 = *v10;
      uint64_t v12 = *((unsigned __int16 *)v11 + 5);
      if (*((_WORD *)v11 + 5))
      {
        uint64_t v13 = (uint64_t)*v11;
        if (*((unsigned char *)v11 + 15))
        {
          if (v12 >= 0x1E)
          {
            uint64_t v18 = *v11;
            unint64_t v19 = *((unsigned __int16 *)v11 + 5);
            do
            {
              unint64_t v20 = v19 >> 1;
              uint64_t v21 = &v18[v19 >> 1];
              unsigned int v23 = *v21;
              uint64_t v22 = v21 + 1;
              BOOL result = v23;
              v19 += ~(v19 >> 1);
              if (v23 < a2) {
                uint64_t v18 = v22;
              }
              else {
                unint64_t v19 = v20;
              }
            }
            while (v19);
            if (v18 == (unsigned __int16 *)(v13 + 2 * v12) || *v18 != a2) {
              goto LABEL_6;
            }
            unint64_t v9 = ((unint64_t)v18 - v13) >> 1;
          }
          else
          {
            uint64_t v14 = 0;
            while (1)
            {
              unsigned int v15 = *(unsigned __int16 *)(v13 + 2 * v14);
              if (v15 >= a2) {
                break;
              }
              if (v12 == ++v14) {
                goto LABEL_6;
              }
            }
            LOWORD(v9) = v15 == a2 ? v14 : *((_WORD *)v11 + 5);
          }
        }
        else
        {
          uint64_t v16 = 2 * v12;
          uint64_t v17 = *v11;
          while (*v17 != a2)
          {
            ++v17;
            v16 -= 2;
            if (!v16)
            {
              uint64_t v17 = (unsigned __int16 *)(v13 + 2 * v12);
              break;
            }
          }
          unint64_t v9 = ((unint64_t)v17 - v13) >> 1;
        }
      }
      else
      {
        LOWORD(v9) = 0;
      }
      if (v12 != (unsigned __int16)v9) {
        break;
      }
    }
LABEL_6:
    v7 += 8;
    if (v7 == v8) {
      goto LABEL_31;
    }
  }
  uint64_t v29 = *((unsigned __int16 *)v11 + 21);
  if (!*((_WORD *)v11 + 21)) {
    return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
  }
  float v30 = v11[4];
  if (!*((unsigned char *)v11 + 47))
  {
    uint64_t v44 = 2 * v29;
    uint64_t v45 = v11[4];
    while (*v45 != a2)
    {
      ++v45;
      v44 -= 2;
      if (!v44)
      {
        uint64_t v45 = &v30[v29];
        break;
      }
    }
    unint64_t v31 = (unint64_t)((char *)v45 - (char *)v30) >> 1;
LABEL_105:
    if (v29 <= (unsigned __int16)v31) {
      return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    }
    return (uint64_t)&v30[2 * (unsigned __int16)v31] + *((unsigned __int16 *)v11 + 20);
  }
  if (v29 < 0x1E)
  {
    unint64_t v31 = 0;
    BOOL result = (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
    while (1)
    {
      unsigned int v32 = v30[v31];
      if (v32 >= a2) {
        break;
      }
      if (v29 == ++v31) {
        return result;
      }
    }
    if (v32 != a2) {
      LOWORD(v31) = *((_WORD *)v11 + 21);
    }
    goto LABEL_105;
  }
  long long v48 = v11[4];
  unint64_t v49 = *((unsigned __int16 *)v11 + 21);
  do
  {
    unint64_t v50 = v49 >> 1;
    double v51 = &v48[v49 >> 1];
    unsigned int v53 = *v51;
    uint64_t v52 = v51 + 1;
    v49 += ~(v49 >> 1);
    if (v53 < a2) {
      long long v48 = v52;
    }
    else {
      unint64_t v49 = v50;
    }
  }
  while (v49);
  if (v48 != &v30[v29] && *v48 == a2)
  {
    unint64_t v31 = (unint64_t)((char *)v48 - (char *)v30) >> 1;
    goto LABEL_105;
  }
  return (uint64_t)&gss::PropertySetValueHelper<gss::PropertyID,unsigned int>::value(gss::PropertyID,gss::StylePropertySet<gss::PropertyID> const&)::_defaultValue;
}

float md::LabelFeature::minZoomRank(md::LabelFeature *this)
{
  return 254.0;
}

void md::PointLabelFeature::populateStyleQueries(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v14 = 0;
  if ((*(uint64_t (**)(uint64_t))(*(void *)a1 + 488))(a1)
    && (*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 480))(a1, 0))
  {
    operator new();
  }
  (*(void (**)(uint64_t *__return_ptr, uint64_t, void))(*(void *)a1 + 584))(&v11, a1, 0);
  md::createFeatureAttributeSet((gss::Allocator *)v15, &v11);
  md::LabelStyleCache::styleQueryForFeatureAttributes((uint64_t)&v13, a3, v15, 0);
  if (v15[0])
  {
    v15[1] = v15[0];
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 40))(v16, v15[0], v15[2] - v15[0]);
  }
  uint64_t v6 = *(_OWORD **)(a2 + 8);
  if ((unint64_t)v6 >= *(void *)(a2 + 16))
  {
    uint64_t v7 = std::vector<std::shared_ptr<md::RouteAnnotationLabelFeature>,geo::StdAllocator<std::shared_ptr<md::RouteAnnotationLabelFeature>,mdm::Allocator>>::__emplace_back_slow_path<std::shared_ptr<md::RouteAnnotationLabelFeature>>(a2, (uint64_t)&v13);
  }
  else
  {
    if (v6)
    {
      _OWORD *v6 = v13;
      long long v13 = 0uLL;
    }
    uint64_t v7 = v6 + 1;
  }
  *(void *)(a2 + 8) = v7;
  uint64_t v8 = (std::__shared_weak_count *)*((void *)&v13 + 1);
  if (*((void *)&v13 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v13 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  unint64_t v9 = v12;
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
  uint64_t v10 = v14;
  if (v14)
  {
    if (*(char *)(v14 + 23) < 0) {
      (*(void (**)(void, void, uint64_t))(**(void **)(v14 + 24) + 40))(*(void *)(v14 + 24), *(void *)v14, *(void *)(v14 + 16) & 0x7FFFFFFFFFFFFFFFLL);
    }
    MEMORY[0x1A6239270](v10, 0x1032C402ED93987);
  }
}

void sub_1A1804670(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
}

uint64_t md::PointLabelFeature::publicLocale(md::PointLabelFeature *this, unint64_t a2)
{
  uint64_t v2 = *((void *)this + 68);
  uint64_t v3 = *((void *)this + 69) - v2;
  uint64_t v4 = v2 + (a2 << 6) + 32;
  if (a2 >= v3 >> 6) {
    return 0;
  }
  else {
    return v4;
  }
}

unsigned int *gss::FeatureAttributeSet::setByReplacingAttributes@<X0>(gss::Allocator *a1@<X0>, unsigned int **a2@<X1>, unsigned int **a3@<X8>)
{
  uint64_t v5 = *a2;
  uint64_t v6 = a2[1];
  uint64_t v8 = *(void *)a1;
  uint64_t v7 = *((void *)a1 + 1);
  int64x2_t v71 = 0uLL;
  unint64_t v72 = 0;
  uint64_t v9 = gss::Allocator::instance(a1);
  unint64_t v10 = (v7 - v8) >> 3;
  if (v6 == v5) {
    unint64_t v11 = 0;
  }
  else {
    unint64_t v11 = ((unint64_t)((char *)v6 - (char *)v5 - 8) >> 3) + 1;
  }
  uint64_t v70 = a3;
  v73[0] = v9;
  unint64_t v12 = v10 + v11;
  if (v10 + v11)
  {
    if (v12 >> 61) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    unsigned int v77 = v73;
    v71.i64[0] = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v9 + 16))(v9, 8 * v12, 4);
    v71.i64[1] = v71.i64[0];
    int64x2_t v75 = vdupq_n_s64(0);
    unint64_t v72 = v71.i64[0] + 8 * v12;
    uint64_t v76 = 0;
    uint64_t v74 = v75.i64[0];
    std::__split_buffer<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator> &>::~__split_buffer((uint64_t)&v74);
    uint64_t v14 = (void *)v71.i64[0];
    uint64_t v13 = v71.i64[0];
  }
  else
  {
    uint64_t v13 = 0;
    uint64_t v14 = 0;
  }
  uint64_t v16 = *(void *)a1;
  unsigned int v15 = (void *)*((void *)a1 + 1);
  uint64_t v17 = (uint64_t)v15 - *(void *)a1;
  if (v17 >= 1)
  {
    uint64_t v18 = v17 >> 3;
    uint64_t v19 = (uint64_t)v14 - v13;
    uint64_t v20 = v13 + (((unint64_t)v14 - v13) & 0xFFFFFFFFFFFFFFF8);
    if (v17 >> 3 > (uint64_t)(v72 - (void)v14) >> 3)
    {
      uint64_t v21 = v19 >> 3;
      unint64_t v22 = v18 + (v19 >> 3);
      if (v22 >> 61) {
        std::vector<double>::__throw_length_error[abi:ne180100]();
      }
      uint64_t v23 = v72 - v13;
      if (v23 >> 2 > v22) {
        unint64_t v22 = v23 >> 2;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v24 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v24 = v22;
      }
      unsigned int v77 = v73;
      if (v24) {
        uint64_t v25 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v73[0] + 16))(v73[0], 8 * v24, 4);
      }
      else {
        uint64_t v25 = 0;
      }
      uint64_t v36 = (void *)(v25 + 8 * v21);
      uint64_t v76 = v25 + 8 * v24;
      uint64_t v37 = 8 * v18;
      unint64_t v38 = v36;
      unsigned int v39 = &v36[v18];
      do
      {
        if (v38) {
          *unint64_t v38 = *(void *)v16;
        }
        ++v38;
        v16 += 8;
        v37 -= 8;
      }
      while (v37);
      v75.i64[1] = (uint64_t)&v36[v18];
      if (v71.i64[0] != v20)
      {
        uint64_t v40 = v20;
        do
        {
          uint64_t v41 = *(void *)(v40 - 8);
          v40 -= 8;
          *--uint64_t v36 = v41;
        }
        while (v40 != v71.i64[0]);
        unsigned int v39 = (void *)v75.i64[1];
      }
      if (v71.i64[1] != v20)
      {
        do
        {
          if (v39) {
            *unsigned int v39 = *(void *)v20;
          }
          v20 += 8;
          ++v39;
        }
        while (v20 != v71.i64[1]);
        uint64_t v20 = v71.i64[1];
      }
      uint64_t v42 = v71.i64[0];
      uint64_t v43 = v72;
      v71.i64[0] = (uint64_t)v36;
      v71.i64[1] = (uint64_t)v39;
      unint64_t v72 = v76;
      v75.i64[1] = v20;
      uint64_t v76 = v43;
      uint64_t v74 = v42;
      v75.i64[0] = v42;
      std::__split_buffer<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator> &>::~__split_buffer((uint64_t)&v74);
      goto LABEL_53;
    }
    uint64_t v26 = ((uint64_t)v14 - v20) >> 3;
    if (v26 >= v18)
    {
      uint64_t v27 = (void *)(v16 + 8 * v18);
      unsigned int v28 = v14;
    }
    else
    {
      uint64_t v27 = (void *)(v16 + 8 * v26);
      unsigned int v28 = v14;
      if (v27 != v15)
      {
        uint64_t v29 = v27;
        float v30 = v14;
        do
        {
          if (v30) {
            *float v30 = *v29;
          }
          ++v29;
          ++v30;
          ++v28;
        }
        while (v29 != v15);
      }
      v71.i64[1] = (uint64_t)v28;
      if ((uint64_t)v14 - v20 < 1) {
        goto LABEL_53;
      }
    }
    unint64_t v31 = (void *)(v20 + 8 * v18);
    unsigned int v32 = &v28[-v18];
    unint64_t v33 = v28;
    if (v32 < v14)
    {
      unint64_t v33 = v28;
      do
      {
        if (v33) {
          void *v33 = *v32;
        }
        ++v32;
        ++v33;
      }
      while (v32 < v14);
    }
    v71.i64[1] = (uint64_t)v33;
    if (v28 != v31)
    {
      uint64_t v34 = (_WORD *)v28 - 2;
      uint64_t v35 = 8 * (v28 - v31);
      do
      {
        *((_DWORD *)v34 - 1) = *(_DWORD *)(v20 + v35 - 8);
        *uint64_t v34 = *(_WORD *)(v20 + v35 - 4);
        v34 -= 4;
        v35 -= 8;
      }
      while (v35);
    }
    for (; (void *)v16 != v27; v20 += 8)
    {
      *(_DWORD *)uint64_t v20 = *(_DWORD *)v16;
      *(_WORD *)(v20 + 4) = *(_WORD *)(v16 + 4);
      v16 += 8;
    }
  }
LABEL_53:
  if (v5 != v6)
  {
    if (v10 <= 1) {
      uint64_t v44 = 1;
    }
    else {
      uint64_t v44 = (v7 - v8) >> 3;
    }
    do
    {
      uint64_t v45 = *v5;
      if (v7 == v8)
      {
LABEL_61:
        uint64_t v48 = *((unsigned __int16 *)v5 + 2);
        if (v71.i64[1] >= v72)
        {
          uint64_t v50 = (v71.i64[1] - v71.i64[0]) >> 3;
          unint64_t v51 = v50 + 1;
          if ((unint64_t)(v50 + 1) >> 61) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v52 = v72 - v71.i64[0];
          if ((uint64_t)(v72 - v71.i64[0]) >> 2 > v51) {
            unint64_t v51 = v52 >> 2;
          }
          if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v53 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v53 = v51;
          }
          unsigned int v77 = v73;
          if (v53)
          {
            uint64_t v54 = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)v73[0] + 16))(v73[0], 8 * v53, 4);
            unint64_t v55 = (uint64_t *)(v54 + 8 * v50);
            uint64_t v56 = v54 + 8 * v53;
            if (v54) {
              *unint64_t v55 = v45 | (v48 << 32);
            }
          }
          else
          {
            uint64_t v56 = 0;
            unint64_t v55 = (uint64_t *)(8 * v50);
          }
          uint64_t v57 = v71.i64[1];
          if (v71.i64[1] == v71.i64[0])
          {
            int64x2_t v60 = vdupq_n_s64(v71.u64[1]);
            uint64_t v58 = v55;
          }
          else
          {
            uint64_t v58 = v55;
            do
            {
              uint64_t v59 = *(void *)(v57 - 8);
              v57 -= 8;
              *--uint64_t v58 = v59;
            }
            while (v57 != v71.i64[0]);
            int64x2_t v60 = v71;
          }
          uint64_t v49 = (uint64_t)(v55 + 1);
          v71.i64[0] = (uint64_t)v58;
          int64x2_t v75 = v60;
          uint64_t v61 = v72;
          unint64_t v72 = v56;
          uint64_t v76 = v61;
          uint64_t v74 = v60.i64[0];
          std::__split_buffer<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator> &>::~__split_buffer((uint64_t)&v74);
        }
        else
        {
          if (v71.i64[1]) {
            *(void *)v71.i64[1] = v45 | (v48 << 32);
          }
          uint64_t v49 = v71.i64[1] + 8;
        }
        v71.i64[1] = v49;
      }
      else
      {
        uint64_t v46 = (_WORD *)(v71.i64[0] + 4);
        uint64_t v47 = v44;
        while (*((_DWORD *)v46 - 1) != v45)
        {
          v46 += 4;
          if (!--v47) {
            goto LABEL_61;
          }
        }
        _WORD *v46 = *((_WORD *)v5 + 2);
      }
      v5 += 2;
    }
    while (v5 != v6);
  }
  unsigned int *v70 = 0;
  v70[1] = 0;
  uint64_t v62 = (unsigned int *)v73[0];
  v70[2] = 0;
  v70[3] = v62;
  if (v71.i64[1] == v71.i64[0])
  {
    double v65 = 0;
    unint64_t v66 = 0;
  }
  else
  {
    std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__vallocate[abi:ne180100]((uint64_t)v70, (v71.i64[1] - v71.i64[0]) >> 3);
    uint64_t v63 = 0;
    uint64_t v64 = v70[1];
    do
    {
      if (&v64[v63]) {
        *(void *)&v64[v63] = *(void *)(v71.i64[0] + v63 * 4);
      }
      v63 += 2;
    }
    while (v71.i64[0] + v63 * 4 != v71.i64[1]);
    double v65 = &v64[v63];
    v70[1] = &v64[v63];
    unint64_t v66 = *v70;
  }
  unint64_t v67 = 126 - 2 * __clz(((char *)v65 - (char *)v66) >> 3);
  if (v65 == v66) {
    uint64_t v68 = 0;
  }
  else {
    uint64_t v68 = v67;
  }
  BOOL result = std::__introsort<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *,false>(v66, v65, v68, 1);
  if (v71.i64[0]) {
    return (unsigned int *)(*(uint64_t (**)(void, uint64_t, unint64_t))(*(void *)v73[0] + 40))(v73[0], v71.i64[0], v72 - v71.i64[0]);
  }
  return result;
}

void sub_1A1804CFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a14 + 40))(a14, a11, a13 - a11);
  }
  _Unwind_Resume(exception_object);
}

gss::FeatureAttributeSet *md::createFeatureAttributeSet(gss::Allocator *a1, uint64_t *a2)
{
  uint64_t v53 = 0;
  uint64_t v54 = 0;
  uint64_t v55 = 0;
  uint64_t v4 = gss::Allocator::instance(a1);
  uint64_t v56 = v4;
  uint64_t v5 = *a2;
  uint64_t v52 = a1;
  if (*a2)
  {
    uint64_t v6 = v4;
    unint64_t v7 = *(unsigned __int8 *)(v5 + 32) + (unint64_t)*(unsigned __int8 *)(v5 + 33);
    if (v7)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v4 + 16))(v4, 8 * v7, 4);
      unint64_t v9 = v8 + 8 * v7;
      uint64_t v53 = v8;
      uint64_t v54 = v8;
      uint64_t v55 = v9;
      uint64_t v5 = *a2;
      if (*(unsigned char *)(*a2 + 33))
      {
LABEL_4:
        unint64_t v10 = 0;
        unint64_t v11 = v8;
        while (1)
        {
          unint64_t v12 = (int *)(*(void *)v5 + 8 * v10);
          int v14 = *v12;
          int v13 = v12[1];
          if (v11 >= v9) {
            break;
          }
          if (v11)
          {
            *(_DWORD *)unint64_t v11 = v14;
            *(_WORD *)(v11 + 4) = v13;
          }
          v11 += 8;
LABEL_6:
          uint64_t v54 = v11;
          ++v10;
          uint64_t v5 = *a2;
          if (v10 >= *(unsigned __int8 *)(*a2 + 33)) {
            goto LABEL_37;
          }
        }
        uint64_t v15 = (uint64_t)(v11 - v8) >> 3;
        unint64_t v16 = v15 + 1;
        if ((unint64_t)(v15 + 1) >> 61) {
          abort();
        }
        if ((uint64_t)(v9 - v8) >> 2 > v16) {
          unint64_t v16 = (uint64_t)(v9 - v8) >> 2;
        }
        if (v9 - v8 >= 0x7FFFFFFFFFFFFFF8) {
          uint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          uint64_t v17 = v16;
        }
        if (v17)
        {
          uint64_t v18 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 16))(v6, 8 * v17, 4);
          uint64_t v19 = v18 + 8 * v15;
          uint64_t v20 = v18 + 8 * v17;
          if (v18)
          {
            *(_DWORD *)uint64_t v19 = v14;
            *(_WORD *)(v19 + 4) = v13;
          }
        }
        else
        {
          uint64_t v20 = 0;
          uint64_t v19 = 8 * v15;
        }
        unint64_t v21 = v53;
        if (v11 != v53)
        {
          unint64_t v22 = v11 - v53 - 8;
          if (v22 < 0x38 || v11 - v19 < 0x20)
          {
            unint64_t v24 = v11;
            uint64_t v8 = v19;
          }
          else
          {
            uint64_t v23 = (v22 >> 3) + 1;
            unint64_t v24 = v11 - 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v25 = (_OWORD *)(v19 - 16);
            uint64_t v26 = (long long *)(v11 - 16);
            uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v28 = *v26;
              *(v25 - 1) = *(v26 - 1);
              _OWORD *v25 = v28;
              v25 -= 2;
              v26 -= 2;
              v27 -= 4;
            }
            while (v27);
            uint64_t v8 = v19 - 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
            if (v23 == (v23 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_31;
            }
          }
          do
          {
            uint64_t v29 = *(void *)(v24 - 8);
            v24 -= 8;
            *(void *)(v8 - 8) = v29;
            v8 -= 8;
          }
          while (v24 != v21);
          unint64_t v9 = v55;
          goto LABEL_31;
        }
        uint64_t v8 = v19;
        unint64_t v21 = v11;
LABEL_31:
        unint64_t v11 = v19 + 8;
        uint64_t v53 = v8;
        uint64_t v55 = v20;
        if (v21) {
          (*(void (**)(uint64_t, unint64_t, unint64_t))(*(void *)v6 + 40))(v6, v21, v9 - v21);
        }
        unint64_t v9 = v20;
        goto LABEL_6;
      }
    }
    else
    {
      unint64_t v9 = 0;
      uint64_t v8 = 0;
      if (*(unsigned char *)(v5 + 33)) {
        goto LABEL_4;
      }
    }
    unint64_t v11 = v8;
LABEL_37:
    if (*(unsigned char *)(v5 + 32))
    {
      unint64_t v30 = 0;
      while (1)
      {
        uint64_t v31 = *(void *)(v5 + 24) + 12 * v30;
        int v32 = *(_DWORD *)v31;
        __int16 v33 = *(_WORD *)(v31 + 4);
        if (v11 >= v9) {
          break;
        }
        if (v11)
        {
          *(_DWORD *)unint64_t v11 = v32;
          *(_WORD *)(v11 + 4) = v33;
        }
        v11 += 8;
LABEL_40:
        uint64_t v54 = v11;
        ++v30;
        uint64_t v5 = *a2;
        if (v30 >= *(unsigned __int8 *)(*a2 + 32)) {
          goto LABEL_68;
        }
      }
      unint64_t v34 = v53;
      uint64_t v35 = (uint64_t)(v11 - v53) >> 3;
      unint64_t v36 = v35 + 1;
      if ((unint64_t)(v35 + 1) >> 61) {
        abort();
      }
      if ((uint64_t)(v9 - v53) >> 2 > v36) {
        unint64_t v36 = (uint64_t)(v9 - v53) >> 2;
      }
      if (v9 - v53 >= 0x7FFFFFFFFFFFFFF8) {
        uint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v37 = v36;
      }
      if (v37)
      {
        uint64_t v38 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v6 + 16))(v6, 8 * v37, 4);
        uint64_t v39 = v38 + 8 * v35;
        uint64_t v37 = v38 + 8 * v37;
        if (v38)
        {
          *(_DWORD *)uint64_t v39 = v32;
          *(_WORD *)(v39 + 4) = v33;
        }
        unint64_t v40 = v11 - v34;
        if (v11 != v34)
        {
LABEL_54:
          unint64_t v41 = v40 - 8;
          if (v41 < 0x38 || v11 - v39 < 0x20)
          {
            unint64_t v43 = v11;
            uint64_t v48 = v39;
          }
          else
          {
            uint64_t v42 = (v41 >> 3) + 1;
            unint64_t v43 = v11 - 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v44 = (_OWORD *)(v39 - 16);
            uint64_t v45 = (long long *)(v11 - 16);
            uint64_t v46 = v42 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v47 = *v45;
              *(v44 - 1) = *(v45 - 1);
              *uint64_t v44 = v47;
              v44 -= 2;
              v45 -= 2;
              v46 -= 4;
            }
            while (v46);
            uint64_t v48 = v39 - 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
            if (v42 == (v42 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_65;
            }
          }
          do
          {
            uint64_t v49 = *(void *)(v43 - 8);
            v43 -= 8;
            *(void *)(v48 - 8) = v49;
            v48 -= 8;
          }
          while (v43 != v34);
          unint64_t v9 = v55;
          goto LABEL_65;
        }
      }
      else
      {
        uint64_t v39 = 8 * v35;
        unint64_t v40 = v11 - v53;
        if (v11 != v53) {
          goto LABEL_54;
        }
      }
      uint64_t v48 = v39;
      unint64_t v34 = v11;
LABEL_65:
      unint64_t v11 = v39 + 8;
      uint64_t v53 = v48;
      uint64_t v55 = v37;
      if (v34) {
        (*(void (**)(uint64_t, unint64_t, unint64_t))(*(void *)v6 + 40))(v6, v34, v9 - v34);
      }
      unint64_t v9 = v37;
      goto LABEL_40;
    }
  }
LABEL_68:
  BOOL result = gss::FeatureAttributeSet::FeatureAttributeSet(v52, (uint64_t)&v53);
  if (v53)
  {
    unint64_t v51 = *(uint64_t (**)(void))(*(void *)v56 + 40);
    return (gss::FeatureAttributeSet *)v51();
  }
  return result;
}

void sub_1A1805254(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  if (a11) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a14 + 40))(a14, a11, v14 - a11);
  }
  _Unwind_Resume(exception_object);
}

gss::FeatureAttributeSet *gss::FeatureAttributeSet::FeatureAttributeSet(gss::FeatureAttributeSet *this, uint64_t a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  uint64_t v3 = *(void *)(a2 + 24);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = v3;
  uint64_t v4 = *(void **)a2;
  uint64_t v5 = *(void **)(a2 + 8);
  uint64_t v6 = (uint64_t)v5 - *(void *)a2;
  if (v6)
  {
    if (v6 < 0) {
      abort();
    }
    uint64_t v7 = v6 >> 3;
    uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    *(void *)this = v8;
    *((void *)this + 1) = v8;
    *((void *)this + 2) = &v8[v7];
    do
    {
      if (v8) {
        void *v8 = *v4;
      }
      ++v4;
      ++v8;
    }
    while (v4 != v5);
    *((void *)this + 1) = v8;
  }
  gss::FeatureAttributeSet::sort(this);
  return this;
}

{
  uint64_t v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  *(void *)this = 0;
  *((void *)this + 1) = 0;
  uint64_t v3 = *(void *)(a2 + 24);
  *((void *)this + 2) = 0;
  *((void *)this + 3) = v3;
  uint64_t v4 = *(void **)a2;
  uint64_t v5 = *(void **)(a2 + 8);
  uint64_t v6 = (uint64_t)v5 - *(void *)a2;
  if (v6)
  {
    if (v6 < 0) {
      abort();
    }
    uint64_t v7 = v6 >> 3;
    uint64_t v8 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    *(void *)this = v8;
    *((void *)this + 1) = v8;
    *((void *)this + 2) = &v8[v7];
    do
    {
      if (v8) {
        void *v8 = *v4;
      }
      ++v4;
      ++v8;
    }
    while (v4 != v5);
    *((void *)this + 1) = v8;
  }
  gss::FeatureAttributeSet::sort(this);
  return this;
}

void sub_1A1805358(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *v1;
  if (*v1)
  {
    v1[1] = v3;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1[3] + 40))(v1[3], v3, v1[2] - v3);
  }
  _Unwind_Resume(exception_object);
}

unsigned int *std::__introsort<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *,false>(unsigned int *result, unsigned int *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (unint64_t)result;
  while (2)
  {
    unint64_t v10 = v9;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v9 = v10;
          uint64_t v11 = (uint64_t)a2 - v10;
          unint64_t v12 = (uint64_t)((uint64_t)a2 - v10) >> 3;
          if (v5 || !v4)
          {
            switch(v12)
            {
              case 0uLL:
              case 1uLL:
                return result;
              case 2uLL:
                unsigned int v39 = *(a2 - 2);
                unsigned int v40 = *(_DWORD *)v10;
                if (v39 < *(_DWORD *)v10)
                {
                  *(_DWORD *)unint64_t v10 = v39;
                  *(a2 - 2) = v40;
                  __int16 v41 = *(_WORD *)(v10 + 4);
                  *(_WORD *)(v10 + 4) = *((_WORD *)a2 - 2);
                  *((_WORD *)a2 - 2) = v41;
                }
                break;
              case 3uLL:
                BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>((unsigned int *)v10, (unsigned int *)(v10 + 8), a2 - 2);
                break;
              case 4uLL:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>(v10, v10 + 8, v10 + 16, (uint64_t)(a2 - 2));
                break;
              case 5uLL:
                BOOL result = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>(v10, v10 + 8, v10 + 16, v10 + 24);
                unsigned int v42 = *(a2 - 2);
                unsigned int v43 = *(_DWORD *)(v10 + 24);
                if (v42 < v43)
                {
                  *(_DWORD *)(v10 + 24) = v42;
                  *(a2 - 2) = v43;
                  __int16 v44 = *(_WORD *)(v10 + 28);
                  *(_WORD *)(v10 + 28) = *((_WORD *)a2 - 2);
                  *((_WORD *)a2 - 2) = v44;
                  unsigned int v45 = *(_DWORD *)(v10 + 24);
                  unsigned int v46 = *(_DWORD *)(v10 + 16);
                  if (v45 < v46)
                  {
                    *(_DWORD *)(v10 + 16) = v45;
                    *(_DWORD *)(v10 + 24) = v46;
                    __int16 v47 = *(_WORD *)(v10 + 20);
                    __int16 v48 = *(_WORD *)(v10 + 28);
                    *(_WORD *)(v10 + 20) = v48;
                    *(_WORD *)(v10 + 28) = v47;
                    unsigned int v49 = *(_DWORD *)(v10 + 8);
                    if (v45 < v49)
                    {
                      *(_DWORD *)(v10 + 8) = v45;
                      *(_DWORD *)(v10 + 16) = v49;
                      __int16 v50 = *(_WORD *)(v10 + 12);
                      *(_WORD *)(v10 + 12) = v48;
                      *(_WORD *)(v10 + 20) = v50;
                      unsigned int v51 = *(_DWORD *)v10;
                      if (v45 < *(_DWORD *)v10)
                      {
                        *(_DWORD *)unint64_t v10 = v45;
                        *(_DWORD *)(v10 + 8) = v51;
                        __int16 v52 = *(_WORD *)(v10 + 4);
                        *(_WORD *)(v10 + 4) = v48;
                        *(_WORD *)(v10 + 12) = v52;
                      }
                    }
                  }
                }
                break;
              default:
                JUMPOUT(0);
            }
            return result;
          }
          if (v11 <= 191)
          {
            uint64_t v53 = (unsigned int *)(v10 + 8);
            BOOL v55 = (unsigned int *)v10 == a2 || v53 == a2;
            if (a4)
            {
              if (!v55)
              {
                uint64_t v56 = 0;
                uint64_t v57 = (unsigned int *)v10;
                do
                {
                  unsigned int v58 = v57[2];
                  unsigned int v59 = *v57;
                  uint64_t v57 = v53;
                  if (v58 < v59)
                  {
                    uint64_t v60 = *(void *)v53;
                    uint64_t v61 = v56;
                    while (1)
                    {
                      uint64_t v62 = v10 + v61;
                      *(_DWORD *)(v62 + 8) = v59;
                      *(_WORD *)(v62 + 12) = *(_WORD *)(v10 + v61 + 4);
                      if (!v61) {
                        break;
                      }
                      unsigned int v59 = *(_DWORD *)(v62 - 8);
                      v61 -= 8;
                      if (v59 <= v60)
                      {
                        uint64_t v63 = v10 + v61 + 8;
                        goto LABEL_84;
                      }
                    }
                    uint64_t v63 = v10;
LABEL_84:
                    *(_DWORD *)uint64_t v63 = v60;
                    *(_WORD *)(v63 + 4) = WORD2(v60);
                  }
                  uint64_t v53 = v57 + 2;
                  v56 += 8;
                }
                while (v57 + 2 != a2);
              }
            }
            else if (!v55)
            {
              uint64_t v91 = (_WORD *)(v10 + 12);
              do
              {
                unsigned int v92 = *(_DWORD *)(v9 + 8);
                unsigned int v93 = *(_DWORD *)v9;
                unint64_t v9 = (unint64_t)v53;
                if (v92 < v93)
                {
                  uint64_t v94 = *(void *)v53;
                  uint64_t v95 = v91;
                  do
                  {
                    unsigned int v96 = v95;
                    *((_DWORD *)v95 - 1) = v93;
                    __int16 v97 = *(v95 - 4);
                    v95 -= 4;
                    *unsigned int v96 = v97;
                    unsigned int v93 = *((_DWORD *)v96 - 5);
                  }
                  while (v93 > v94);
                  *((_DWORD *)v95 - 1) = v94;
                  *uint64_t v95 = WORD2(v94);
                }
                uint64_t v53 = (unsigned int *)(v9 + 8);
                v91 += 4;
              }
              while ((unsigned int *)(v9 + 8) != a2);
            }
            return result;
          }
          if (!a3)
          {
            if ((unsigned int *)v10 != a2)
            {
              int64_t v64 = (v12 - 2) >> 1;
              int64_t v65 = v64;
              do
              {
                int64_t v66 = v65;
                if (v64 >= v65)
                {
                  uint64_t v67 = (2 * v65) | 1;
                  unint64_t v68 = v10 + 8 * v67;
                  if (2 * v66 + 2 < (uint64_t)v12)
                  {
                    unsigned int v70 = *(_DWORD *)(v68 + 8);
                    BOOL v69 = *(_DWORD *)v68 >= v70;
                    if (*(_DWORD *)v68 > v70) {
                      unsigned int v70 = *(_DWORD *)v68;
                    }
                    if (!v69)
                    {
                      v68 += 8;
                      uint64_t v67 = 2 * v66 + 2;
                    }
                  }
                  else
                  {
                    unsigned int v70 = *(_DWORD *)v68;
                  }
                  unint64_t v71 = v10 + 8 * v66;
                  if (v70 >= *(_DWORD *)v71)
                  {
                    uint64_t v72 = *(void *)v71;
                    do
                    {
                      unint64_t v73 = v71;
                      unint64_t v71 = v68;
                      *(_DWORD *)unint64_t v73 = v70;
                      *(_WORD *)(v73 + 4) = *(_WORD *)(v68 + 4);
                      if (v64 < v67) {
                        break;
                      }
                      uint64_t v74 = (2 * v67) | 1;
                      unint64_t v68 = v10 + 8 * v74;
                      uint64_t v67 = 2 * v67 + 2;
                      if (v67 < (uint64_t)v12)
                      {
                        unsigned int v70 = *(_DWORD *)v68;
                        BOOL result = (unsigned int *)(v68 + 8);
                        unsigned int v75 = *(_DWORD *)(v68 + 8);
                        if (*(_DWORD *)v68 <= v75) {
                          unsigned int v70 = *(_DWORD *)(v68 + 8);
                        }
                        if (*(_DWORD *)v68 >= v75) {
                          uint64_t v67 = v74;
                        }
                        else {
                          v68 += 8;
                        }
                      }
                      else
                      {
                        unsigned int v70 = *(_DWORD *)v68;
                        uint64_t v67 = v74;
                      }
                    }
                    while (v70 >= v72);
                    *(_DWORD *)unint64_t v71 = v72;
                    *(_WORD *)(v71 + 4) = WORD2(v72);
                  }
                }
                int64_t v65 = v66 - 1;
              }
              while (v66);
              uint64_t v76 = (unint64_t)v11 >> 3;
              do
              {
                uint64_t v77 = 0;
                uint64_t v78 = *(void *)v10;
                unint64_t v79 = v10;
                do
                {
                  uint64_t v80 = v79 + 8 * v77 + 8;
                  uint64_t v81 = (2 * v77) | 1;
                  uint64_t v77 = 2 * v77 + 2;
                  if (v77 < v76)
                  {
                    int v83 = *(_DWORD *)v80;
                    unsigned int v82 = *(_DWORD *)(v80 + 8);
                    if (*(_DWORD *)v80 <= v82) {
                      int v83 = *(_DWORD *)(v80 + 8);
                    }
                    if (*(_DWORD *)v80 >= v82) {
                      uint64_t v77 = v81;
                    }
                    else {
                      v80 += 8;
                    }
                  }
                  else
                  {
                    int v83 = *(_DWORD *)v80;
                    uint64_t v77 = v81;
                  }
                  *(_DWORD *)unint64_t v79 = v83;
                  *(_WORD *)(v79 + 4) = *(_WORD *)(v80 + 4);
                  unint64_t v79 = v80;
                }
                while (v77 <= (uint64_t)((unint64_t)(v76 - 2) >> 1));
                if ((unsigned int *)v80 == a2 - 2)
                {
                  *(_DWORD *)uint64_t v80 = v78;
                  *(_WORD *)(v80 + 4) = WORD2(v78);
                }
                else
                {
                  *(_DWORD *)uint64_t v80 = *(a2 - 2);
                  *(_WORD *)(v80 + 4) = *((_WORD *)a2 - 2);
                  *(a2 - 2) = v78;
                  *((_WORD *)a2 - 2) = WORD2(v78);
                  uint64_t v84 = v80 - v10 + 8;
                  if (v84 >= 9)
                  {
                    unint64_t v85 = (((unint64_t)v84 >> 3) - 2) >> 1;
                    uint64_t v86 = v10 + 8 * v85;
                    int v87 = *(_DWORD *)v86;
                    if (*(_DWORD *)v86 < *(_DWORD *)v80)
                    {
                      uint64_t v88 = *(void *)v80;
                      do
                      {
                        uint64_t v89 = v80;
                        uint64_t v80 = v86;
                        *(_DWORD *)uint64_t v89 = v87;
                        *(_WORD *)(v89 + 4) = *(_WORD *)(v86 + 4);
                        if (!v85) {
                          break;
                        }
                        unint64_t v85 = (v85 - 1) >> 1;
                        uint64_t v86 = v10 + 8 * v85;
                        int v87 = *(_DWORD *)v86;
                      }
                      while (*(_DWORD *)v86 < v88);
                      *(_DWORD *)uint64_t v80 = v88;
                      *(_WORD *)(v80 + 4) = WORD2(v88);
                    }
                  }
                }
                a2 -= 2;
              }
              while (v76-- > 2);
            }
            return result;
          }
          unint64_t v13 = v12 >> 1;
          unint64_t v14 = v10 + 8 * (v12 >> 1);
          if ((unint64_t)v11 >= 0x401)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>((unsigned int *)v9, (unsigned int *)(v9 + 8 * (v12 >> 1)), a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>((unsigned int *)(v9 + 8), (unsigned int *)(v14 - 8), a2 - 4);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>((unsigned int *)(v9 + 16), (unsigned int *)(v9 + 8 + 8 * v13), a2 - 6);
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>((unsigned int *)(v14 - 8), (unsigned int *)v14, (unsigned int *)(v9 + 8 + 8 * v13));
            unsigned int v15 = *(_DWORD *)v9;
            *(_DWORD *)unint64_t v9 = *(_DWORD *)v14;
            *(_DWORD *)unint64_t v14 = v15;
            LOWORD(v15) = *(_WORD *)(v9 + 4);
            *(_WORD *)(v9 + 4) = *(_WORD *)(v14 + 4);
            *(_WORD *)(v14 + 4) = v15;
          }
          else
          {
            BOOL result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>((unsigned int *)(v9 + 8 * (v12 >> 1)), (unsigned int *)v9, a2 - 2);
          }
          --a3;
          if ((a4 & 1) != 0 || *(_DWORD *)(v9 - 8) < *(_DWORD *)v9) {
            break;
          }
          uint64_t v29 = *(void *)v9;
          if (*(a2 - 2) <= *(void *)v9)
          {
            unint64_t v31 = v9 + 8;
            do
            {
              unint64_t v10 = v31;
              if (v31 >= (unint64_t)a2) {
                break;
              }
              v31 += 8;
            }
            while (*(_DWORD *)v10 <= v29);
          }
          else
          {
            unint64_t v10 = v9;
            do
            {
              unsigned int v30 = *(_DWORD *)(v10 + 8);
              v10 += 8;
            }
            while (v30 <= v29);
          }
          int v32 = a2;
          if (v10 < (unint64_t)a2)
          {
            int v32 = a2;
            do
            {
              unsigned int v33 = *(v32 - 2);
              v32 -= 2;
            }
            while (v33 > v29);
          }
          if (v10 < (unint64_t)v32)
          {
            unsigned int v34 = *(_DWORD *)v10;
            unsigned int v35 = *v32;
            do
            {
              *(_DWORD *)unint64_t v10 = v35;
              unsigned int *v32 = v34;
              __int16 v36 = *(_WORD *)(v10 + 4);
              *(_WORD *)(v10 + 4) = *((_WORD *)v32 + 2);
              *((_WORD *)v32 + 2) = v36;
              do
              {
                unsigned int v37 = *(_DWORD *)(v10 + 8);
                v10 += 8;
                unsigned int v34 = v37;
              }
              while (v37 <= v29);
              do
              {
                unsigned int v38 = *(v32 - 2);
                v32 -= 2;
                unsigned int v35 = v38;
              }
              while (v38 > v29);
            }
            while (v10 < (unint64_t)v32);
          }
          BOOL v4 = v10 - 8 >= v9;
          BOOL v5 = v10 - 8 == v9;
          if (v10 - 8 != v9)
          {
            *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 8);
            *(_WORD *)(v9 + 4) = *(_WORD *)(v10 - 4);
          }
          a4 = 0;
          *(_DWORD *)(v10 - 8) = v29;
          *(_WORD *)(v10 - 4) = WORD2(v29);
        }
        uint64_t v16 = 0;
        uint64_t v17 = *(void *)v9;
        do
        {
          unsigned int v18 = *(_DWORD *)(v9 + v16 + 8);
          v16 += 8;
        }
        while (v18 < v17);
        unint64_t v19 = v9 + v16;
        uint64_t v20 = a2;
        if (v16 == 8)
        {
          uint64_t v20 = a2;
          do
          {
            if (v19 >= (unint64_t)v20) {
              break;
            }
            unsigned int v22 = *(v20 - 2);
            v20 -= 2;
          }
          while (v22 >= v17);
        }
        else
        {
          do
          {
            unsigned int v21 = *(v20 - 2);
            v20 -= 2;
          }
          while (v21 >= v17);
        }
        if (v19 >= (unint64_t)v20)
        {
          unint64_t v10 = v9 + v16;
        }
        else
        {
          unsigned int v23 = *v20;
          unint64_t v10 = v9 + v16;
          unint64_t v24 = v20;
          do
          {
            *(_DWORD *)unint64_t v10 = v23;
            *unint64_t v24 = v18;
            __int16 v25 = *(_WORD *)(v10 + 4);
            *(_WORD *)(v10 + 4) = *((_WORD *)v24 + 2);
            *((_WORD *)v24 + 2) = v25;
            do
            {
              unsigned int v26 = *(_DWORD *)(v10 + 8);
              v10 += 8;
              unsigned int v18 = v26;
            }
            while (v26 < v17);
            do
            {
              unsigned int v27 = *(v24 - 2);
              v24 -= 2;
              unsigned int v23 = v27;
            }
            while (v27 >= v17);
          }
          while (v10 < (unint64_t)v24);
        }
        if (v10 - 8 != v9)
        {
          *(_DWORD *)unint64_t v9 = *(_DWORD *)(v10 - 8);
          *(_WORD *)(v9 + 4) = *(_WORD *)(v10 - 4);
        }
        *(_DWORD *)(v10 - 8) = v17;
        *(_WORD *)(v10 - 4) = WORD2(v17);
        if (v19 >= (unint64_t)v20) {
          break;
        }
LABEL_33:
        BOOL result = (unsigned int *)std::__introsort<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *,false>(v9, v10 - 8, a3, a4 & 1);
        a4 = 0;
      }
      BOOL v28 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>(v9, (unsigned int *)(v10 - 8));
      BOOL result = (unsigned int *)std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>(v10, a2);
      if (result) {
        break;
      }
      if (!v28) {
        goto LABEL_33;
      }
    }
    a2 = (unsigned int *)(v10 - 8);
    if (!v28) {
      continue;
    }
    return result;
  }
}

unsigned int *gss::FeatureAttributeSet::sort(gss::FeatureAttributeSet *this)
{
  uint64_t v1 = (unsigned int *)*((void *)this + 1);
  unint64_t v2 = 126 - 2 * __clz(((uint64_t)v1 - *(void *)this) >> 3);
  if (v1 == *(unsigned int **)this) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = v2;
  }
  return std::__introsort<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *,false>(*(unsigned int **)this, v1, v3, 1);
}

uint64_t std::vector<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::__vallocate[abi:ne180100](uint64_t a1, unint64_t a2)
{
  if (a2 >> 61) {
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 8 * a2, 4);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 16) = result + 8 * a2;
  return result;
}

uint64_t std::__split_buffer<std::pair<gss::StyleAttribute,unsigned short>,geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2 != v3) {
    *(void *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  }
  if (*(void *)a1) {
    std::allocator_traits<geo::StdAllocator<std::pair<gss::StyleAttribute,unsigned short>,gss::Allocator>>::deallocate[abi:ne180100](*(void **)(a1 + 32), *(void *)a1, (uint64_t)(*(void *)(a1 + 24) - *(void *)a1) >> 3);
  }
  return a1;
}

unsigned int *std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>((unsigned int *)a1, (unsigned int *)a2, (unsigned int *)a3);
  unsigned int v9 = *(_DWORD *)a3;
  if (*(_DWORD *)a4 < *(_DWORD *)a3)
  {
    *(_DWORD *)a3 = *(_DWORD *)a4;
    *(_DWORD *)a4 = v9;
    __int16 v10 = *(_WORD *)(a3 + 4);
    *(_WORD *)(a3 + 4) = *(_WORD *)(a4 + 4);
    *(_WORD *)(a4 + 4) = v10;
    unsigned int v11 = *(_DWORD *)a2;
    if (*(_DWORD *)a3 < *(_DWORD *)a2)
    {
      *(_DWORD *)a2 = *(_DWORD *)a3;
      *(_DWORD *)a3 = v11;
      __int16 v12 = *(_WORD *)(a2 + 4);
      *(_WORD *)(a2 + 4) = *(_WORD *)(a3 + 4);
      *(_WORD *)(a3 + 4) = v12;
      unsigned int v13 = *(_DWORD *)a1;
      if (*(_DWORD *)a2 < *(_DWORD *)a1)
      {
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v13;
        __int16 v14 = *(_WORD *)(a1 + 4);
        *(_WORD *)(a1 + 4) = *(_WORD *)(a2 + 4);
        *(_WORD *)(a2 + 4) = v14;
      }
    }
  }
  return result;
}

unsigned int *std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,gss::FeatureAttributeSet::sort(void)::$_0 &,std::pair<gss::StyleAttribute,unsigned short> *>(unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3 = *a2;
  unsigned int v4 = *result;
  unsigned int v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      *a2 = v5;
      *a3 = v3;
      __int16 v7 = *((_WORD *)a2 + 2);
      *((_WORD *)a2 + 2) = *((_WORD *)a3 + 2);
      *((_WORD *)a3 + 2) = v7;
      unsigned int v8 = *result;
      if (*a2 < *result)
      {
        unsigned int *result = *a2;
        *a2 = v8;
        __int16 v9 = *((_WORD *)result + 2);
        *((_WORD *)result + 2) = *((_WORD *)a2 + 2);
        *((_WORD *)a2 + 2) = v9;
      }
    }
  }
  else if (v5 >= v3)
  {
    unsigned int *result = v3;
    *a2 = v4;
    __int16 v10 = *((_WORD *)result + 2);
    *((_WORD *)result + 2) = *((_WORD *)a2 + 2);
    *((_WORD *)a2 + 2) = v10;
    if (*a3 < v4)
    {
      *a2 = *a3;
      *a3 = v4;
      *((_WORD *)a2 + 2) = *((_WORD *)a3 + 2);
      *((_WORD *)a3 + 2) = v10;
    }
  }
  else
  {
    unsigned int *result = v5;
    *a3 = v4;
    __int16 v6 = *((_WORD *)result + 2);
    *((_WORD *)result + 2) = *((_WORD *)a3 + 2);
    *((_WORD *)a3 + 2) = v6;
  }
  return result;
}

uint64_t std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::compare(const void **a1, unsigned char *a2)
{
  char v2 = a2[23];
  if (*((char *)a1 + 23) < 0)
  {
    unsigned int v4 = a1;
    a1 = (const void **)*a1;
    size_t v3 = (size_t)v4[1];
  }
  else
  {
    size_t v3 = *((unsigned __int8 *)a1 + 23);
  }
  if (v2 >= 0) {
    size_t v5 = a2[23];
  }
  else {
    size_t v5 = *((void *)a2 + 1);
  }
  if (v2 < 0) {
    a2 = *(unsigned char **)a2;
  }
  if (v5 >= v3) {
    size_t v6 = v3;
  }
  else {
    size_t v6 = v5;
  }
  LODWORD(result) = memcmp(a1, a2, v6);
  if (v3 < v5) {
    unsigned int v8 = -1;
  }
  else {
    unsigned int v8 = v5 < v3;
  }
  if (result) {
    return result;
  }
  else {
    return v8;
  }
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::LabelCollider::collideItems(void)::$_0 &,md::LabelCollisionItemBase **>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  unsigned int v4 = a2;
  size_t v5 = a1;
  uint64_t v6 = *a2;
  if (*a2 == *a1 || (v7 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 80))(v6), uint64_t v6 = *v4, (v7 & 1) == 0))
  {
    uint64_t result = *a3;
    if (*a3 != v6)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 80))(result, v6);
      if (result)
      {
        uint64_t v9 = *v4;
        *unsigned int v4 = *a3;
        *a3 = v9;
        uint64_t result = *v4;
        if (*v4 != *v5)
        {
          uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
          if (result) {
            goto LABEL_14;
          }
        }
      }
    }
  }
  else
  {
    if (*a3 != v6)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)*a3 + 80))(*a3, *v4);
      if (result)
      {
        unsigned int v4 = a3;
LABEL_14:
        uint64_t v11 = *v5;
        uint64_t *v5 = *v4;
        *unsigned int v4 = v11;
        return result;
      }
      uint64_t v6 = *v4;
    }
    uint64_t v10 = *v5;
    uint64_t *v5 = v6;
    *unsigned int v4 = v10;
    uint64_t result = *a3;
    if (*a3 != v10)
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 80))(result);
      size_t v5 = v4;
      unsigned int v4 = a3;
      if (result) {
        goto LABEL_14;
      }
    }
  }
  return result;
}

float md::PhysicalLabelFeature::minZoomRank(md::PhysicalLabelFeature *this)
{
  return *((float *)this + 114);
}

void *gms::ZoomablePropertyStore<geo::Color<float,3,(geo::ColorSpace)0>>::getProperty@<X0>(void *result@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  *(unsigned char *)a2 = 0;
  unsigned int v4 = vcvtms_s32_f32(a3);
  if (v4 >= 0x17) {
    unsigned int v5 = 23;
  }
  else {
    unsigned int v5 = v4;
  }
  uint64_t v6 = (void *)result[5];
  char v7 = result + 6;
  unsigned int v8 = v6;
  if (v6 != result + 6)
  {
    unint64_t v9 = 0;
    uint64_t v10 = (void *)result[5];
    do
    {
      uint64_t v11 = (void *)v10[1];
      if (v11)
      {
        do
        {
          __int16 v12 = v11;
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          __int16 v12 = (void *)v10[2];
          BOOL v13 = *v12 == (void)v10;
          uint64_t v10 = v12;
        }
        while (!v13);
      }
      ++v9;
      uint64_t v10 = v12;
    }
    while (v12 != v7);
    unsigned int v8 = (void *)result[5];
    do
    {
      unint64_t v14 = v9 >> 1;
      unsigned int v15 = v8;
      if (v9 != 1)
      {
        uint64_t v17 = v9 >> 1;
        unsigned int v18 = v8;
        do
        {
          uint64_t v20 = (void *)v18[1];
          if (v20)
          {
            do
            {
              unsigned int v15 = v20;
              uint64_t v20 = (void *)*v20;
            }
            while (v20);
          }
          else
          {
            do
            {
              unsigned int v15 = (void *)v18[2];
              BOOL v13 = *v15 == (void)v18;
              unsigned int v18 = v15;
            }
            while (!v13);
          }
          unsigned int v18 = v15;
          BOOL v19 = v17-- <= 1;
        }
        while (!v19);
      }
      if (v5 >= *((unsigned __int8 *)v15 + 29))
      {
        uint64_t v16 = (void *)v15[1];
        if (v16)
        {
          do
          {
            unsigned int v8 = v16;
            uint64_t v16 = (void *)*v16;
          }
          while (v16);
        }
        else
        {
          do
          {
            unsigned int v8 = (void *)v15[2];
            BOOL v13 = *v8 == (void)v15;
            unsigned int v15 = v8;
          }
          while (!v13);
        }
        unint64_t v14 = v9 + ~v14;
      }
      unint64_t v9 = v14;
    }
    while (v14);
  }
  if (v8 == v7 || (v5 >= *((unsigned __int8 *)v8 + 28) ? (BOOL v21 = v5 >= *((unsigned __int8 *)v8 + 29)) : (BOOL v21 = 1), v21)) {
    unsigned int v8 = result + 6;
  }
  unsigned __int8 v22 = v5 + 1;
  unsigned int v23 = (void *)result[5];
  if (v6 != v7)
  {
    unint64_t v24 = 0;
    __int16 v25 = (void *)result[5];
    do
    {
      unsigned int v26 = (void *)v25[1];
      if (v26)
      {
        do
        {
          unsigned int v27 = v26;
          unsigned int v26 = (void *)*v26;
        }
        while (v26);
      }
      else
      {
        do
        {
          unsigned int v27 = (void *)v25[2];
          BOOL v13 = *v27 == (void)v25;
          __int16 v25 = v27;
        }
        while (!v13);
      }
      ++v24;
      __int16 v25 = v27;
    }
    while (v27 != v7);
    unsigned int v23 = (void *)result[5];
    do
    {
      unint64_t v28 = v24 >> 1;
      uint64_t v29 = v23;
      if (v24 != 1)
      {
        uint64_t v31 = v24 >> 1;
        int v32 = v23;
        do
        {
          unsigned int v33 = (void *)v32[1];
          if (v33)
          {
            do
            {
              uint64_t v29 = v33;
              unsigned int v33 = (void *)*v33;
            }
            while (v33);
          }
          else
          {
            do
            {
              uint64_t v29 = (void *)v32[2];
              BOOL v13 = *v29 == (void)v32;
              int v32 = v29;
            }
            while (!v13);
          }
          int v32 = v29;
          BOOL v19 = v31-- <= 1;
        }
        while (!v19);
      }
      if (*((unsigned __int8 *)v29 + 29) <= v22)
      {
        unsigned int v30 = (void *)v29[1];
        if (v30)
        {
          do
          {
            unsigned int v23 = v30;
            unsigned int v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            unsigned int v23 = (void *)v29[2];
            BOOL v13 = *v23 == (void)v29;
            uint64_t v29 = v23;
          }
          while (!v13);
        }
        unint64_t v28 = v24 + ~v28;
      }
      unint64_t v24 = v28;
    }
    while (v28);
  }
  if (v23 == v7
    || *((unsigned __int8 *)v23 + 28) > v22
    || *((unsigned __int8 *)v23 + 29) <= v22)
  {
    unsigned int v23 = result + 6;
  }
  if (v8 != v7 && result[7])
  {
    if (v23 == v7 || (result = (void *)result[4]) == 0 || (float v34 = a3 - (float)v5, v34 > 1.0) || v34 < 0.0)
    {
      if (v6 != v7)
      {
        unint64_t v40 = 0;
        __int16 v41 = v6;
        do
        {
          unsigned int v42 = (void *)v41[1];
          if (v42)
          {
            do
            {
              unsigned int v43 = v42;
              unsigned int v42 = (void *)*v42;
            }
            while (v42);
          }
          else
          {
            do
            {
              unsigned int v43 = (void *)v41[2];
              BOOL v13 = *v43 == (void)v41;
              __int16 v41 = v43;
            }
            while (!v13);
          }
          ++v40;
          __int16 v41 = v43;
        }
        while (v43 != v7);
        do
        {
          unint64_t v44 = v40 >> 1;
          unsigned int v45 = v6;
          if (v40 != 1)
          {
            uint64_t v47 = v40 >> 1;
            __int16 v48 = v6;
            do
            {
              unsigned int v49 = (void *)v48[1];
              if (v49)
              {
                do
                {
                  unsigned int v45 = v49;
                  unsigned int v49 = (void *)*v49;
                }
                while (v49);
              }
              else
              {
                do
                {
                  unsigned int v45 = (void *)v48[2];
                  BOOL v13 = *v45 == (void)v48;
                  __int16 v48 = v45;
                }
                while (!v13);
              }
              __int16 v48 = v45;
              BOOL v19 = v47-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v45 + 29))
          {
            unsigned int v46 = (void *)v45[1];
            if (v46)
            {
              do
              {
                uint64_t v6 = v46;
                unsigned int v46 = (void *)*v46;
              }
              while (v46);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v45[2];
                BOOL v13 = *v6 == (void)v45;
                unsigned int v45 = v6;
              }
              while (!v13);
            }
            unint64_t v44 = v40 + ~v44;
          }
          unint64_t v40 = v44;
        }
        while (v44);
      }
      if (v6 == v7
        || (v5 >= *((unsigned __int8 *)v6 + 28) ? (BOOL v50 = v5 >= *((unsigned __int8 *)v6 + 29)) : (BOOL v50 = 1), v50))
      {
        uint64_t v6 = v7;
      }
      *(unsigned char *)a2 = 1;
      uint64_t v51 = v6[4];
      *(_DWORD *)(a2 + 12) = *((_DWORD *)v6 + 10);
      *(void *)(a2 + 4) = v51;
    }
    else
    {
      unsigned int v35 = v6;
      if (v6 != v7)
      {
        unint64_t v36 = 0;
        unsigned int v37 = v6;
        do
        {
          unsigned int v38 = (void *)v37[1];
          if (v38)
          {
            do
            {
              unsigned int v39 = v38;
              unsigned int v38 = (void *)*v38;
            }
            while (v38);
          }
          else
          {
            do
            {
              unsigned int v39 = (void *)v37[2];
              BOOL v13 = *v39 == (void)v37;
              unsigned int v37 = v39;
            }
            while (!v13);
          }
          ++v36;
          unsigned int v37 = v39;
        }
        while (v39 != v7);
        unsigned int v35 = v6;
        do
        {
          unint64_t v52 = v36 >> 1;
          uint64_t v53 = v35;
          if (v36 != 1)
          {
            uint64_t v55 = v36 >> 1;
            uint64_t v56 = v35;
            do
            {
              uint64_t v57 = (void *)v56[1];
              if (v57)
              {
                do
                {
                  uint64_t v53 = v57;
                  uint64_t v57 = (void *)*v57;
                }
                while (v57);
              }
              else
              {
                do
                {
                  uint64_t v53 = (void *)v56[2];
                  BOOL v13 = *v53 == (void)v56;
                  uint64_t v56 = v53;
                }
                while (!v13);
              }
              uint64_t v56 = v53;
              BOOL v19 = v55-- <= 1;
            }
            while (!v19);
          }
          if (v5 >= *((unsigned __int8 *)v53 + 29))
          {
            uint64_t v54 = (void *)v53[1];
            if (v54)
            {
              do
              {
                unsigned int v35 = v54;
                uint64_t v54 = (void *)*v54;
              }
              while (v54);
            }
            else
            {
              do
              {
                unsigned int v35 = (void *)v53[2];
                BOOL v13 = *v35 == (void)v53;
                uint64_t v53 = v35;
              }
              while (!v13);
            }
            unint64_t v52 = v36 + ~v52;
          }
          unint64_t v36 = v52;
        }
        while (v52);
      }
      if (v35 == v7
        || (v5 >= *((unsigned __int8 *)v35 + 28) ? (BOOL v58 = v5 >= *((unsigned __int8 *)v35 + 29)) : (BOOL v58 = 1), v58))
      {
        unsigned int v35 = v7;
      }
      uint64_t v73 = v35[4];
      int v74 = *((_DWORD *)v35 + 10);
      if (v6 != v7)
      {
        unint64_t v59 = 0;
        uint64_t v60 = v6;
        do
        {
          uint64_t v61 = (void *)v60[1];
          if (v61)
          {
            do
            {
              uint64_t v62 = v61;
              uint64_t v61 = (void *)*v61;
            }
            while (v61);
          }
          else
          {
            do
            {
              uint64_t v62 = (void *)v60[2];
              BOOL v13 = *v62 == (void)v60;
              uint64_t v60 = v62;
            }
            while (!v13);
          }
          ++v59;
          uint64_t v60 = v62;
        }
        while (v62 != v7);
        do
        {
          unint64_t v63 = v59 >> 1;
          int64_t v64 = v6;
          if (v59 != 1)
          {
            uint64_t v66 = v59 >> 1;
            uint64_t v67 = v6;
            do
            {
              unint64_t v68 = (void *)v67[1];
              if (v68)
              {
                do
                {
                  int64_t v64 = v68;
                  unint64_t v68 = (void *)*v68;
                }
                while (v68);
              }
              else
              {
                do
                {
                  int64_t v64 = (void *)v67[2];
                  BOOL v13 = *v64 == (void)v67;
                  uint64_t v67 = v64;
                }
                while (!v13);
              }
              uint64_t v67 = v64;
              BOOL v19 = v66-- <= 1;
            }
            while (!v19);
          }
          if (*((unsigned __int8 *)v64 + 29) <= v22)
          {
            int64_t v65 = (void *)v64[1];
            if (v65)
            {
              do
              {
                uint64_t v6 = v65;
                int64_t v65 = (void *)*v65;
              }
              while (v65);
            }
            else
            {
              do
              {
                uint64_t v6 = (void *)v64[2];
                BOOL v13 = *v6 == (void)v64;
                int64_t v64 = v6;
              }
              while (!v13);
            }
            unint64_t v63 = v59 + ~v63;
          }
          unint64_t v59 = v63;
        }
        while (v63);
      }
      if (v6 == v7
        || *((unsigned __int8 *)v6 + 28) > v22
        || *((unsigned __int8 *)v6 + 29) <= v22)
      {
        uint64_t v6 = v7;
      }
      uint64_t v71 = v6[4];
      int v72 = *((_DWORD *)v6 + 10);
      float v75 = v34;
      uint64_t result = (*(void *(**)(uint64_t *__return_ptr))(*result + 48))(&v69);
      *(unsigned char *)a2 = 1;
      *(void *)(a2 + 4) = v69;
      *(_DWORD *)(a2 + 12) = v70;
    }
  }
  return result;
}

uint64_t std::__function::__func<geo::Color<float,3,(geo::ColorSpace)0> (*)(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&),std::allocator<geo::Color<float,3,(geo::ColorSpace)0> (*)(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&)>,geo::Color<float,3,(geo::ColorSpace)0> ()(float,geo::Color<float,3,(geo::ColorSpace)0> const&,geo::Color<float,3,(geo::ColorSpace)0> const&)>::operator()(uint64_t a1, float *a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, float))(a1 + 8))(a3, a4, *a2);
}

uint64_t gms::lerp<geo::Color<float,3,(geo::ColorSpace)0>>@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>, float a4@<S0>, float32x4_t a5@<Q1>, float32x4_t a6@<Q2>)
{
  a5.i64[0] = *(void *)result;
  a5.i32[2] = *(_DWORD *)(result + 8);
  a6.i64[0] = *(void *)a2;
  a6.i32[2] = *(_DWORD *)(a2 + 8);
  float32x4_t v6 = vmlaq_n_f32(a5, vsubq_f32(a6, a5), a4);
  *(_DWORD *)(a3 + 8) = v6.i32[2];
  *(void *)a3 = v6.i64[0];
  return result;
}

uint64_t md::LabelFeaturePool::addLineFeature(void *a1, uint64_t a2, uint64_t *a3, char **a4, uint64_t a5, uint64_t a6, unint64_t a7, char a8)
{
  unsigned int v15 = *(uint64_t **)(a6 + 96);
  if (v15) {
    uint64_t v16 = *v15;
  }
  else {
    uint64_t v16 = 0;
  }
  {
    operator new();
  }
  uint64_t v17 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                       + 16))(mdm::Allocator::instance(void)::alloc, 104, 8);
  *uint64_t v17 = 1;
  md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::LabelFeatureThunk((uint64_t)(v17 + 1), a3, a8, v16);
  __int16 v41 = v17;
  unsigned int v18 = std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>((float *)(a2 + 64), &v41, &v41);
  *(unsigned char *)(a6 + 89) = v19;
  if (v19)
  {
    {
      operator new();
    }
    uint64_t v20 = mdm::Allocator::instance(void)::alloc;
    BOOL v21 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                         + 16))(mdm::Allocator::instance(void)::alloc, 528, 8);
    *BOOL v21 = &unk_1EF580DB0;
    v21[1] = 0;
    v21[2] = 0;
    v21[3] = v20;
    uint64_t v22 = md::UniLineLabelFeature::UniLineLabelFeature((uint64_t)(v21 + 4), a3, a4, a5, a6);
    if (v41) {
      unsigned int v23 = v41 + 1;
    }
    else {
      unsigned int v23 = 0;
    }
    unint64_t v24 = (std::__shared_weak_count *)v23[2];
    v23[1] = v22;
    v23[2] = v21;
    if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
      std::__shared_weak_count::__release_weak(v24);
    }
    uint64_t v25 = *(void *)(a2 + 672);
    unsigned int v26 = v41;
    unsigned int v27 = v41 + 1;
    if (!v41) {
      unsigned int v27 = 0;
    }
    uint64_t v28 = v27[1];
    *(void *)(v28 + 152) = v27;
    uint64_t v29 = v25 + 1;
    *(void *)(a2 + 672) = v29;
    *(void *)(v28 + 72) = v29;
    *(unsigned char *)(v28 + 147) = a8;
  }
  else
  {
    unsigned int v30 = v18;
    uint64_t v31 = (void *)v18[2];
    if (v31) {
      ++*v31;
    }
    BOOL v32 = (*v17)-- == 1;
    if (v32)
    {
      md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk((uint64_t)(v17 + 1));
      {
        operator new();
      }
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, v41, 104);
      uint64_t v31 = (void *)v30[2];
    }
    __int16 v41 = v31;
    if (v31) {
      unsigned int v33 = v31 + 1;
    }
    else {
      unsigned int v33 = 0;
    }
    md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::add(v33, a3);
    unsigned int v26 = v41;
    float v34 = v41 + 1;
    if (!v41) {
      float v34 = 0;
    }
    md::LabelLineStore::addRoadFeature(*(void *)(v34[1] + 192), a3, a4, a5, a6, v34[1] + 440);
  }
  std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>(a7, (uint64_t)v26, &v41);
  uint64_t result = (uint64_t)(v26 + 1);
  if (v26) {
    unint64_t v36 = v26 + 1;
  }
  else {
    unint64_t v36 = 0;
  }
  uint64_t v38 = v36[1];
  uint64_t v37 = v36[2];
  *a1 = v38;
  a1[1] = v37;
  if (v37) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v37 + 8), 1uLL, memory_order_relaxed);
  }
  if (v26)
  {
    BOOL v32 = (*v26)-- == 1;
    if (v32)
    {
      md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(result);
      {
        operator new();
      }
      unsigned int v39 = *(uint64_t (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
      return v39();
    }
  }
  return result;
}

void sub_1A1806B98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  std::__shared_weak_count::~__shared_weak_count(v11);
  (*(void (**)(uint64_t, std::__shared_weak_count *, uint64_t))(*(void *)v10 + 40))(v10, v11, 528);
  geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>::~fast_shared_ptr(&a10);
  _Unwind_Resume(a1);
}

void *std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>(float *a1, void *a2, void **a3)
{
  if (*a2) {
    uint64_t v7 = *a2 + 8;
  }
  else {
    uint64_t v7 = 0;
  }
  unint64_t v8 = md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::hash(v7);
  unint64_t v9 = v8;
  unint64_t v10 = *((void *)a1 + 1);
  if (v10)
  {
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v3 = v8;
      if (v8 >= v10) {
        unint64_t v3 = v8 % v10;
      }
    }
    else
    {
      unint64_t v3 = (v10 - 1) & v8;
    }
    __int16 v12 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v12)
    {
      BOOL v13 = *v12;
      if (*v12)
      {
        if (v11.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v17 = v13[1];
            if (v17 == v9)
            {
              uint64_t v18 = v13[2];
              if (v18) {
                uint64_t v19 = v18 + 8;
              }
              else {
                uint64_t v19 = 0;
              }
              if (!md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::compare(v19, *a2 + 8))return v13; {
            }
              }
            else if ((v17 & (v10 - 1)) != v3)
            {
              goto LABEL_32;
            }
            BOOL v13 = (void *)*v13;
            if (!v13) {
              goto LABEL_32;
            }
          }
        }
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v9)
          {
            uint64_t v15 = v13[2];
            if (v15) {
              uint64_t v16 = v15 + 8;
            }
            else {
              uint64_t v16 = 0;
            }
            if (!md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::compare(v16, *a2 + 8))return v13; {
          }
            }
          else
          {
            if (v14 >= v10) {
              v14 %= v10;
            }
            if (v14 != v3) {
              break;
            }
          }
          BOOL v13 = (void *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_32:
  BOOL v13 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 4) + 16))(*((void *)a1 + 4), 24, 8);
  *BOOL v13 = 0;
  v13[1] = v9;
  v13[2] = 0;
  uint64_t v20 = *a3;
  v13[2] = *a3;
  if (v20) {
    ++*v20;
  }
  float v21 = (float)(unint64_t)(*((void *)a1 + 5) + 1);
  float v22 = a1[12];
  if (!v10 || (float)(v22 * (float)v10) < v21)
  {
    BOOL v23 = 1;
    if (v10 >= 3) {
      BOOL v23 = (v10 & (v10 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v10);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t prime = v25;
    }
    else {
      size_t prime = v24;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v10 = *((void *)a1 + 1);
    if (prime <= v10)
    {
      if (prime >= v10) {
        goto LABEL_70;
      }
      unint64_t v38 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 5) / a1[12]);
      if (v10 < 3 || (uint8x8_t v39 = (uint8x8_t)vcnt_s8((int8x8_t)v10), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
      {
        unint64_t v38 = std::__next_prime(v38);
      }
      else
      {
        uint64_t v40 = 1 << -(char)__clz(v38 - 1);
        if (v38 >= 2) {
          unint64_t v38 = v40;
        }
      }
      if (prime <= v38) {
        size_t prime = v38;
      }
      if (prime >= v10)
      {
        unint64_t v10 = *((void *)a1 + 1);
LABEL_70:
        if ((v10 & (v10 - 1)) != 0)
        {
          if (v9 >= v10) {
            unint64_t v3 = v9 % v10;
          }
          else {
            unint64_t v3 = v9;
          }
        }
        else
        {
          unint64_t v3 = (v10 - 1) & v9;
        }
        goto LABEL_83;
      }
      if (!prime)
      {
        uint64_t v47 = *(void *)a1;
        *(void *)a1 = 0;
        if (v47) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v47, 8 * *((void *)a1 + 1));
        }
        unint64_t v10 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_70;
      }
    }
    uint64_t v27 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(**((void **)a1 + 2) + 16))(*((void *)a1 + 2), 8 * prime, 8);
    uint64_t v28 = *(void *)a1;
    *(void *)a1 = v27;
    if (v28) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v28, 8 * *((void *)a1 + 1));
    }
    uint64_t v29 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v29++) = 0;
    while (prime != v29);
    uint64_t v31 = (uint64_t *)(a1 + 6);
    unsigned int v30 = (void *)*((void *)a1 + 3);
    if (!v30)
    {
LABEL_69:
      unint64_t v10 = prime;
      goto LABEL_70;
    }
    size_t v32 = v30[1];
    size_t v33 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v34 = v32 & v33;
      *(void *)(*(void *)a1 + 8 * v34) = v31;
      for (unint64_t i = (void *)*v30; *v30; unint64_t i = (void *)*v30)
      {
        size_t v36 = i[1] & v33;
        if (v36 == v34)
        {
          unsigned int v30 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v36))
        {
          *unsigned int v30 = *i;
          uint64_t v37 = 8 * v36;
          void *i = **(void **)(*(void *)a1 + v37);
          **(void **)(*(void *)a1 + v37) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v36) = v30;
          unsigned int v30 = i;
          size_t v34 = v36;
        }
      }
      goto LABEL_69;
    }
    if (v32 >= prime) {
      v32 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v32) = v31;
    __int16 v41 = (void *)*v30;
    if (!*v30) {
      goto LABEL_69;
    }
    while (1)
    {
      size_t v43 = v41[1];
      if (v43 >= prime) {
        v43 %= prime;
      }
      if (v43 != v32)
      {
        if (!*(void *)(*(void *)a1 + 8 * v43))
        {
          *(void *)(*(void *)a1 + 8 * v43) = v30;
          goto LABEL_74;
        }
        *unsigned int v30 = *v41;
        uint64_t v42 = 8 * v43;
        void *v41 = **(void **)(*(void *)a1 + v42);
        **(void **)(*(void *)a1 + v42) = v41;
        __int16 v41 = v30;
      }
      size_t v43 = v32;
LABEL_74:
      unsigned int v30 = v41;
      __int16 v41 = (void *)*v41;
      size_t v32 = v43;
      if (!v41) {
        goto LABEL_69;
      }
    }
  }
LABEL_83:
  unint64_t v44 = *(void **)(*(void *)a1 + 8 * v3);
  if (v44)
  {
    *BOOL v13 = *v44;
LABEL_91:
    *unint64_t v44 = v13;
    goto LABEL_92;
  }
  *BOOL v13 = *((void *)a1 + 3);
  *((void *)a1 + 3) = v13;
  *(void *)(*(void *)a1 + 8 * v3) = a1 + 6;
  if (*v13)
  {
    unint64_t v45 = *(void *)(*v13 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v45 >= v10) {
        v45 %= v10;
      }
    }
    else
    {
      v45 &= v10 - 1;
    }
    unint64_t v44 = (void *)(*(void *)a1 + 8 * v45);
    goto LABEL_91;
  }
LABEL_92:
  ++*((void *)a1 + 5);
  return v13;
}

void sub_1A18071A8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

unint64_t std::__hash_table<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,md::LabelFeaturePoolTileInfo::FeatureHash<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,md::LabelFeaturePoolTileInfo::FeatureEqual<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>>,geo::StdAllocator<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,mdm::Allocator>>::__emplace_unique_key_args<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator> const&>(unint64_t result, uint64_t a2, void **a3)
{
  unint64_t v5 = result;
  uint64_t v6 = a2 + 8;
  if (!a2) {
    uint64_t v6 = 0;
  }
  uint64_t v7 = *(void *)(v6 + 8);
  unint64_t v8 = *(void *)(v7 + 72);
  unint64_t v9 = *(void *)(result + 8);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v3 = *(void *)(v7 + 72);
      if (v8 >= v9) {
        unint64_t v3 = v8 % v9;
      }
    }
    else
    {
      unint64_t v3 = (v9 - 1) & v8;
    }
    uint8x8_t v11 = *(void **)(*(void *)result + 8 * v3);
    if (v11)
    {
      __int16 v12 = (void *)*v11;
      if (v12)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v18 = v12[1];
            if (v18 == v8)
            {
              uint64_t v16 = v12[2];
              if (v16) {
                uint64_t v17 = v16 + 8;
              }
              else {
                uint64_t v17 = 0;
              }
              if (*(void *)(*(void *)(v17 + 8) + 72) == v8) {
                return result;
              }
            }
            else if ((v18 & (v9 - 1)) != v3)
            {
              goto LABEL_30;
            }
            __int16 v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_30;
            }
          }
        }
        do
        {
          unint64_t v15 = v12[1];
          if (v15 == v8)
          {
            uint64_t v13 = v12[2];
            if (v13) {
              uint64_t v14 = v13 + 8;
            }
            else {
              uint64_t v14 = 0;
            }
            if (*(void *)(*(void *)(v14 + 8) + 72) == v8) {
              return result;
            }
          }
          else
          {
            if (v15 >= v9) {
              v15 %= v9;
            }
            if (v15 != v3) {
              break;
            }
          }
          __int16 v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_30:
  uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(result + 32) + 16))(*(void *)(result + 32), 24, 8);
  unint64_t v19 = result;
  *(void *)uint64_t result = 0;
  *(void *)(result + 8) = v8;
  *(void *)(result + 16) = 0;
  uint64_t v20 = *a3;
  *(void *)(result + 16) = *a3;
  if (v20) {
    ++*v20;
  }
  float v21 = (float)(unint64_t)(*(void *)(v5 + 40) + 1);
  float v22 = *(float *)(v5 + 48);
  if (!v9 || (float)(v22 * (float)v9) < v21)
  {
    BOOL v23 = 1;
    if (v9 >= 3) {
      BOOL v23 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v24 = v23 | (2 * v9);
    unint64_t v25 = vcvtps_u32_f32(v21 / v22);
    if (v24 <= v25) {
      size_t v26 = v25;
    }
    else {
      size_t v26 = v24;
    }
    if (v26 == 1)
    {
      size_t v26 = 2;
    }
    else if ((v26 & (v26 - 1)) != 0)
    {
      uint64_t result = std::__next_prime(v26);
      size_t v26 = result;
    }
    unint64_t v9 = *(void *)(v5 + 8);
    if (v26 <= v9)
    {
      if (v26 >= v9) {
        goto LABEL_68;
      }
      uint64_t result = vcvtps_u32_f32((float)*(unint64_t *)(v5 + 40) / *(float *)(v5 + 48));
      if (v9 < 3 || (uint8x8_t v37 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        uint64_t result = std::__next_prime(result);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(result - 1);
        if (result >= 2) {
          uint64_t result = v38;
        }
      }
      if (v26 <= result) {
        size_t v26 = result;
      }
      if (v26 >= v9)
      {
        unint64_t v9 = *(void *)(v5 + 8);
LABEL_68:
        if ((v9 & (v9 - 1)) != 0)
        {
          if (v8 >= v9) {
            unint64_t v3 = v8 % v9;
          }
          else {
            unint64_t v3 = v8;
          }
        }
        else
        {
          unint64_t v3 = (v9 - 1) & v8;
        }
        goto LABEL_81;
      }
      if (!v26)
      {
        uint64_t v44 = *(void *)v5;
        *(void *)unint64_t v5 = 0;
        if (v44) {
          uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v5 + 16) + 40))(*(void *)(v5 + 16), v44, 8 * *(void *)(v5 + 8));
        }
        unint64_t v9 = 0;
        *(void *)(v5 + 8) = 0;
        goto LABEL_68;
      }
    }
    uint64_t result = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(v5 + 16) + 16))(*(void *)(v5 + 16), 8 * v26, 8);
    uint64_t v27 = *(void *)v5;
    *(void *)unint64_t v5 = result;
    if (v27) {
      uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v5 + 16) + 40))(*(void *)(v5 + 16), v27, 8 * *(void *)(v5 + 8));
    }
    uint64_t v28 = 0;
    *(void *)(v5 + 8) = v26;
    do
      *(void *)(*(void *)v5 + 8 * v28++) = 0;
    while (v26 != v28);
    unint64_t v30 = v5 + 24;
    uint64_t v29 = *(void **)(v5 + 24);
    if (!v29)
    {
LABEL_67:
      unint64_t v9 = v26;
      goto LABEL_68;
    }
    size_t v31 = v29[1];
    size_t v32 = v26 - 1;
    if ((v26 & (v26 - 1)) == 0)
    {
      size_t v33 = v31 & v32;
      *(void *)(*(void *)v5 + 8 * v33) = v30;
      for (unint64_t i = (void *)*v29; *v29; unint64_t i = (void *)*v29)
      {
        size_t v35 = i[1] & v32;
        if (v35 == v33)
        {
          uint64_t v29 = i;
        }
        else if (*(void *)(*(void *)v5 + 8 * v35))
        {
          *uint64_t v29 = *i;
          uint64_t v36 = 8 * v35;
          void *i = **(void **)(*(void *)v5 + v36);
          **(void **)(*(void *)v5 + v36) = i;
        }
        else
        {
          *(void *)(*(void *)v5 + 8 * v35) = v29;
          uint64_t v29 = i;
          size_t v33 = v35;
        }
      }
      goto LABEL_67;
    }
    if (v31 >= v26) {
      v31 %= v26;
    }
    *(void *)(*(void *)v5 + 8 * v31) = v30;
    uint8x8_t v39 = (void *)*v29;
    if (!*v29) {
      goto LABEL_67;
    }
    while (1)
    {
      size_t v41 = v39[1];
      if (v41 >= v26) {
        v41 %= v26;
      }
      if (v41 != v31)
      {
        if (!*(void *)(*(void *)v5 + 8 * v41))
        {
          *(void *)(*(void *)v5 + 8 * v41) = v29;
          goto LABEL_72;
        }
        *uint64_t v29 = *v39;
        uint64_t v40 = 8 * v41;
        *uint8x8_t v39 = **(void **)(*(void *)v5 + v40);
        **(void **)(*(void *)v5 + v40) = v39;
        uint8x8_t v39 = v29;
      }
      size_t v41 = v31;
LABEL_72:
      uint64_t v29 = v39;
      uint8x8_t v39 = (void *)*v39;
      size_t v31 = v41;
      if (!v39) {
        goto LABEL_67;
      }
    }
  }
LABEL_81:
  uint64_t v42 = *(unint64_t **)(*(void *)v5 + 8 * v3);
  if (v42)
  {
    *(void *)unint64_t v19 = *v42;
LABEL_89:
    unint64_t *v42 = v19;
    goto LABEL_90;
  }
  *(void *)unint64_t v19 = *(void *)(v5 + 24);
  *(void *)(v5 + 24) = v19;
  *(void *)(*(void *)v5 + 8 * v3) = v5 + 24;
  if (*(void *)v19)
  {
    unint64_t v43 = *(void *)(*(void *)v19 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v43 >= v9) {
        v43 %= v9;
      }
    }
    else
    {
      v43 &= v9 - 1;
    }
    uint64_t v42 = (unint64_t *)(*(void *)v5 + 8 * v43);
    goto LABEL_89;
  }
LABEL_90:
  ++*(void *)(v5 + 40);
  return result;
}

void sub_1A1807704(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<geo::fast_shared_ptr<md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>,mdm::MDAllocator>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::hash(uint64_t a1)
{
  unint64_t v1 = *(unsigned __int8 *)(a1 + 88);
  uint64_t v2 = *(void *)(a1 + 80);
  if (!v2)
  {
    unint64_t v4 = *(void *)(a1 + 56);
    uint64_t v5 = *(void *)(v4 + 24);
    if (v5)
    {
      unint64_t v6 = *(unsigned __int8 *)(v5 + 33);
      if (*(unsigned char *)(v5 + 33))
      {
        uint64_t v7 = *(_DWORD **)v5;
        if (*v7 == 189)
        {
          unint64_t v8 = 0;
LABEL_11:
          if (LOBYTE(v7[2 * v8 + 1]) == 1)
          {
            unint64_t v11 = *(void *)(v4 + 40);
            if (v11) {
              goto LABEL_30;
            }
          }
        }
        else
        {
          unint64_t v8 = 0;
          unint64_t v9 = v7 + 2;
          while (v6 - 1 != v8)
          {
            int v10 = *v9;
            v9 += 2;
            ++v8;
            if (v10 == 189)
            {
              if (v8 >= v6) {
                break;
              }
              goto LABEL_11;
            }
          }
        }
      }
    }
    uint64_t NativeShieldCount = geo::codec::featureGetNativeShieldCount(*(void *)(a1 + 56));
    if (NativeShieldCount)
    {
      uint64_t v13 = NativeShieldCount;
      unint64_t v14 = 0;
      unint64_t v11 = 0;
      do
      {
        uint64_t v31 = 0;
        std::string __s = 0;
        geo::codec::featureGetNativeShield(v4, v14, &__s, &v31, 0);
        unint64_t v15 = __s;
        if (__s)
        {
          size_t v16 = strlen(__s);
          unsigned int v17 = -2128831035;
          uint64_t v18 = 0x9E3779BA006719DALL;
          if (v16)
          {
            do
            {
              int v19 = *v15++;
              unsigned int v17 = (v17 * v19) ^ 0x1000193;
              --v16;
            }
            while (v16);
            uint64_t v18 = v17 - 0x61C8864680B583EBLL;
          }
          v11 ^= (v11 >> 2) + (v11 << 6) + v18;
        }
        v11 ^= v31 - 0x61C8864680B583EBLL + (v11 << 6) + (v11 >> 2);
        ++v14;
      }
      while (v14 != v13);
    }
    else
    {
      uint64_t NativeLabelCount = geo::codec::featureGetNativeLabelCount(v4);
      if (NativeLabelCount)
      {
        uint64_t v21 = NativeLabelCount;
        unint64_t v22 = 0;
        unint64_t v11 = 0;
        do
        {
          std::string __s = 0;
          geo::codec::featureGetNativeLabel(v4, v22, &__s, 0);
          BOOL v23 = __s;
          if (__s)
          {
            size_t v24 = strlen(__s);
            unsigned int v25 = -2128831035;
            uint64_t v26 = 0x9E3779BA006719DALL;
            if (v24)
            {
              do
              {
                int v27 = *v23++;
                unsigned int v25 = (v25 * v27) ^ 0x1000193;
                --v24;
              }
              while (v24);
              uint64_t v26 = v25 - 0x61C8864680B583EBLL;
            }
            v11 ^= (v11 >> 2) + (v11 << 6) + v26;
          }
          ++v22;
        }
        while (v22 != v21);
      }
      else
      {
        unint64_t v28 = 0x9DDFEA08EB382D69 * (((8 * v4) + 8) ^ HIDWORD(v4));
        unint64_t v29 = 0x9DDFEA08EB382D69 * (HIDWORD(v4) ^ (v28 >> 47) ^ v28);
        unint64_t v11 = 0x9DDFEA08EB382D69 * (v29 ^ (v29 >> 47));
      }
    }
LABEL_30:
    uint64_t v3 = (v1 << 6) - 0x61C8864680B583EBLL + (v1 >> 2) + v11;
    return v3 ^ v1;
  }
  uint64_t v3 = v2 - 0x61C8864680B583EBLL + (v1 << 6) + (v1 >> 2);
  return v3 ^ v1;
}

uint64_t geo::codec::featureGetNativeLabelCount(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 73);
  }
  return result;
}

void geo::codec::featureGetNativeLabel(uint64_t a1, unint64_t a2, void *a3, void *a4)
{
  if (!a1) {
    return;
  }
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 8);
  if (!v7)
  {
    unint64_t v9 = 0;
LABEL_11:
    if (a3) {
      *a3 = 0;
    }
    if (!a4)
    {
LABEL_16:
      if (!v9) {
        return;
      }
      goto LABEL_17;
    }
    uint64_t v12 = 0;
LABEL_15:
    *a4 = v12;
    goto LABEL_16;
  }
  unint64_t v9 = std::__shared_weak_count::lock(v7);
  if (!v9 || *(unsigned __int8 *)(a1 + 73) <= a2 || !*(void *)a1) {
    goto LABEL_11;
  }
  unint64_t v10 = *(unsigned int *)(a1 + 56) + a2;
  uint64_t v11 = *(void *)(*(void *)a1 + 1048);
  if (a3) {
    *a3 = *(void *)(v11 + 24 * v10);
  }
  if (a4)
  {
    uint64_t v12 = *(void *)(v11 + 24 * v10 + 8);
    goto LABEL_15;
  }
LABEL_17:
  if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
    std::__shared_weak_count::__release_weak(v9);
  }
}

uint64_t md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::LabelFeatureThunk(uint64_t a1, uint64_t *a2, char a3, uint64_t a4)
{
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  unint64_t v8 = (uint64_t *)(a1 + 24);
  *(void *)a1 = &unk_1EF537260;
  *(void *)(a1 + 40) = 0;
  unint64_t v9 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    unint64_t v9 = md::SignedDistanceFieldGenerator::_hypotCache + 131416;
    if (v15) {
      operator new();
    }
  }
  *(void *)(a1 + 48) = *((void *)v9 + 91);
  unint64_t v10 = (std::__shared_weak_count *)a2[1];
  if (v10 && (unint64_t v10 = std::__shared_weak_count::lock(v10)) != 0) {
    uint64_t v11 = (uint64_t *)*a2;
  }
  else {
    uint64_t v11 = 0;
  }
  *(void *)(a1 + 56) = a2;
  *(void *)(a1 + 64) = v11;
  *(void *)(a1 + 72) = v10;
  *(void *)(a1 + 80) = a4;
  *(unsigned char *)(a1 + 88) = a3;
  uint64_t v12 = *(uint64_t ***)(a1 + 32);
  if ((unint64_t)v12 >= *(void *)(a1 + 40))
  {
    uint64_t v13 = std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::StdAllocator<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::Allocator>>::__push_back_slow_path<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>> const&>(v8, a1 + 56);
  }
  else
  {
    if (v12)
    {
      *uint64_t v12 = a2;
      v12[1] = v11;
      v12[2] = (uint64_t *)v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
    }
    uint64_t v13 = (uint64_t)(v12 + 3);
  }
  *(void *)(a1 + 32) = v13;
  return a1;
}

void sub_1A1807C1C(_Unwind_Exception *a1)
{
  md::components::Material::~Material(v3);
  std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::StdAllocator<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::Allocator>>::~vector[abi:nn180100](v2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::StdAllocator<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::Allocator>>::__push_back_slow_path<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0xAAAAAAAAAAAAAAALL;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) < 0x555555555555555) {
    uint64_t v2 = v4;
  }
  if (v2)
  {
    uint64_t v7 = 24 * v2;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 24 * v2, 8);
    uint64_t v9 = v8 + 24 * v3;
    uint64_t v2 = v8 + v7;
    if (v8)
    {
      *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
      uint64_t v10 = *(void *)(a2 + 16);
      *(void *)(v8 + 24 * v3 + 16) = v10;
      if (v10) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
      }
    }
  }
  else
  {
    uint64_t v9 = 8 * ((a1[1] - *a1) >> 3);
  }
  uint64_t v11 = v9 + 24;
  uint64_t v12 = *a1;
  uint64_t v13 = a1[1];
  if (v13 == *a1)
  {
    *a1 = v9;
    a1[1] = v11;
    uint64_t v16 = a1[2];
    a1[2] = v2;
  }
  else
  {
    do
    {
      long long v14 = *(_OWORD *)(v13 - 24);
      v13 -= 24;
      *(_OWORD *)(v9 - 24) = v14;
      v9 -= 24;
      *(void *)(v9 + 16) = *(void *)(v13 + 16);
      *(void *)(v13 + 8) = 0;
      *(void *)(v13 + 16) = 0;
    }
    while (v13 != v12);
    uint64_t v13 = *a1;
    uint64_t v15 = a1[1];
    *a1 = v9;
    a1[1] = v11;
    uint64_t v16 = a1[2];
    for (a1[2] = v2; v15 != v13; v15 -= 24)
    {
      unsigned int v17 = *(std::__shared_weak_count **)(v15 - 8);
      if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
        std::__shared_weak_count::__release_weak(v17);
      }
    }
  }
  if (v13) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v13, v16 - v13);
  }
  return v11;
}

void md::LabelLineStore::addRoadFeature(uint64_t a1, uint64_t *a2, char **a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v29 = 0;
  if (a4)
  {
    uint64_t v11 = (std::__shared_weak_count *)a2[1];
    if (v11)
    {
      uint64_t v12 = std::__shared_weak_count::lock(v11);
      if (v12)
      {
        uint64_t v13 = *a2;
        {
LABEL_32:
            operator new();
        }
LABEL_10:
        uint64_t v16 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                   + 16))(mdm::Allocator::instance(void)::alloc, 248, 8);
        *(_DWORD *)uint64_t v16 = 5;
        *(void *)(v16 + 8) = v13;
        *(void *)(v16 + 16) = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *(void *)(v16 + 88) = 0;
        *(_OWORD *)(v16 + 72) = 0u;
        *(_OWORD *)(v16 + 56) = 0u;
        *(_OWORD *)(v16 + 40) = 0u;
        *(_OWORD *)(v16 + 24) = 0u;
        {
          uint64_t v27 = v16;
          uint64_t v16 = v27;
          if (v28) {
            operator new();
          }
        }
        *(void *)(v16 + 96) = mdm::Allocator::instance(void)::alloc;
        *(void *)(v16 + 104) = a4;
        *(void *)(v16 + 112) = 0;
        *(void *)(v16 + 120) = 0;
        *(void *)(v16 + 128) = a6;
        *(void *)(v16 + 136) = *(void *)a5;
        *(_WORD *)(v16 + 144) = *(_WORD *)(a5 + 8);
        *(void *)(v16 + 148) = *(void *)(a5 + 12);
        long long v17 = *(_OWORD *)(a5 + 32);
        long long v18 = *(_OWORD *)(a5 + 48);
        long long v19 = *(_OWORD *)(a5 + 64);
        *(_OWORD *)(v16 + 211) = *(_OWORD *)(a5 + 75);
        *(_OWORD *)(v16 + 200) = v19;
        *(_OWORD *)(v16 + 184) = v18;
        *(_OWORD *)(v16 + 168) = v17;
        *(void *)(v16 + 232) = *(void *)(a5 + 96);
        uint64_t v20 = *(void *)(a5 + 104);
        *(void *)(v16 + 240) = v20;
        if (v20) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v20 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v21 = v29;
        unint64_t v29 = (md::LabelLineStore::WorkUnit *)v16;
        if (v21)
        {
          md::LabelLineStore::WorkUnit::~WorkUnit(v21);
          {
            operator new();
          }
          (*(void (**)(uint64_t, md::LabelLineStore::WorkUnit *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                                   + 40))(mdm::Allocator::instance(void)::alloc, v21, 248);
        }
        if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
          std::__shared_weak_count::__release_weak(v12);
        }
        goto LABEL_21;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v13 = 0;
    goto LABEL_10;
  }
  {
    operator new();
  }
  uint64_t v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 16))(mdm::Allocator::instance(void)::alloc, 248, 8);
  unint64_t v29 = (md::LabelLineStore::WorkUnit *)md::LabelLineStore::WorkUnit::WorkUnit(v15, 0, a2, a3, a5, a6);
LABEL_21:
  std::mutex::lock((std::mutex *)(a1 + 16));
  unint64_t v22 = *(md::LabelLineStore::WorkUnit ***)(a1 + 96);
  if ((unint64_t)v22 >= *(void *)(a1 + 104))
  {
    size_t v24 = std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(a1 + 88, (uint64_t *)&v29);
  }
  else
  {
    if (v22)
    {
      BOOL v23 = v29;
      unint64_t v29 = 0;
      unsigned __int16 *v22 = v23;
    }
    size_t v24 = v22 + 1;
  }
  *(void *)(a1 + 96) = v24;
  atomic_store(1u, (unsigned __int8 *)(a1 + 80));
  std::mutex::unlock((std::mutex *)(a1 + 16));
  unsigned int v25 = v29;
  unint64_t v29 = 0;
  if (v25)
  {
    md::LabelLineStore::WorkUnit::~WorkUnit(v25);
    {
      operator new();
    }
    uint64_t v26 = *(void (**)(void))(*(void *)mdm::Allocator::instance(void)::alloc + 40);
    v26();
  }
}

void sub_1A18083B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, md::LabelLineStore::WorkUnit *a12)
{
  std::mutex::unlock(v12);
  std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>::~unique_ptr[abi:nn180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::compare(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int8 *)(a1 + 88);
  int v4 = *(unsigned __int8 *)(a2 + 88);
  uint64_t result = (v3 - v4);
  if (v3 != v4) {
    return result;
  }
  unint64_t v6 = *(void *)(a1 + 80);
  unint64_t v7 = *(void *)(a2 + 80);
  if (v6 | v7)
  {
    BOOL v15 = v6 >= v7;
    BOOL v16 = v6 == v7;
    goto LABEL_10;
  }
  uint64_t v8 = *(geo::codec **)(a1 + 56);
  unint64_t v9 = *(void *)(a2 + 56);
  uint64_t v10 = (_DWORD *)*((void *)v8 + 3);
  if (v10)
  {
    if (*((unsigned char *)v10 + 33))
    {
      uint64_t v11 = 0;
      uint64_t v12 = *(int **)v10;
      while (1)
      {
        int v13 = *v12;
        v12 += 2;
        if (v13 == 1) {
          break;
        }
        if (*((unsigned __int8 *)v10 + 33) == ++v11) {
          goto LABEL_8;
        }
      }
      int v14 = *(_DWORD *)(*(void *)v10 + 8 * v11 + 4);
    }
    else
    {
LABEL_8:
      int v14 = -1;
    }
    int v18 = (v14 & ~(v14 >> 31));
    long long v19 = *(_DWORD **)(v9 + 24);
    if (v19) {
      goto LABEL_20;
    }
LABEL_17:
    BOOL v20 = 0;
    goto LABEL_27;
  }
  int v18 = 0;
  long long v19 = *(_DWORD **)(v9 + 24);
  if (!v19) {
    goto LABEL_17;
  }
LABEL_20:
  if (*((unsigned char *)v19 + 33))
  {
    uint64_t v21 = 0;
    unint64_t v22 = *(int **)v19;
    while (1)
    {
      int v23 = *v22;
      v22 += 2;
      if (v23 == 1) {
        break;
      }
      if (*((unsigned __int8 *)v19 + 33) == ++v21) {
        goto LABEL_24;
      }
    }
    int v24 = *(_DWORD *)(*(void *)v19 + 8 * v21 + 4);
  }
  else
  {
LABEL_24:
    int v24 = -1;
  }
  BOOL v20 = (v24 & ~(v24 >> 31)) == 12;
LABEL_27:
  if (v20 != (v18 == 12))
  {
    if (v18 == 12) {
      return 1;
    }
    else {
      return 0xFFFFFFFFLL;
    }
  }
  if (v10)
  {
    unint64_t v25 = *((unsigned __int8 *)v10 + 33);
    if (*((unsigned char *)v10 + 33))
    {
      uint64_t v10 = *(_DWORD **)v10;
      if (*v10 == 189)
      {
        unint64_t v26 = 0;
LABEL_32:
        LODWORD(v10) = LOBYTE(v10[2 * v26 + 1]) == 1;
        goto LABEL_42;
      }
      unint64_t v26 = 0;
      uint64_t v27 = v10 + 2;
      while (v25 - 1 != v26)
      {
        int v28 = *v27;
        v27 += 2;
        ++v26;
        if (v28 == 189)
        {
          if (v26 < v25) {
            goto LABEL_32;
          }
          break;
        }
      }
    }
    LODWORD(v10) = 0;
  }
LABEL_42:
  if (v19)
  {
    unint64_t v29 = *((unsigned __int8 *)v19 + 33);
    if (*((unsigned char *)v19 + 33))
    {
      long long v19 = *(_DWORD **)v19;
      if (*v19 == 189)
      {
        unint64_t v30 = 0;
LABEL_46:
        LODWORD(v19) = LOBYTE(v19[2 * v30 + 1]) == 1;
        goto LABEL_52;
      }
      unint64_t v30 = 0;
      uint64_t v31 = v19 + 2;
      while (v29 - 1 != v30)
      {
        int v32 = *v31;
        v31 += 2;
        ++v30;
        if (v32 == 189)
        {
          if (v30 < v29) {
            goto LABEL_46;
          }
          break;
        }
      }
    }
    LODWORD(v19) = 0;
  }
LABEL_52:
  if ((v10 | v19) == 1)
  {
    if (v10 != v19)
    {
      if (v10) {
        return 1;
      }
      else {
        return 0xFFFFFFFFLL;
      }
    }
    unint64_t v33 = *((void *)v8 + 5);
    unint64_t v34 = *(void *)(v9 + 40);
    if (v33 | v34)
    {
      BOOL v15 = v33 >= v34;
      BOOL v16 = v33 == v34;
LABEL_10:
      if (v15) {
        unsigned int v17 = 1;
      }
      else {
        unsigned int v17 = -1;
      }
      goto LABEL_13;
    }
  }
  if (geo::codec::featureGetNativeShieldCount((uint64_t)v8) || geo::codec::featureGetNativeShieldCount(v9))
  {
    return geo::codec::roadFeatureCompareShields(v8, (const GeoCodecsRoadFeature *)v9, v35);
  }
  if (!geo::codec::featureGetNativeLabelCount((uint64_t)v8) && !geo::codec::featureGetNativeLabelCount(v9))
  {
    BOOL v16 = v8 == (geo::codec *)v9;
    if ((unint64_t)v8 > v9) {
      unsigned int v17 = 1;
    }
    else {
      unsigned int v17 = -1;
    }
LABEL_13:
    if (v16) {
      return 0;
    }
    else {
      return v17;
    }
  }
  return geo::codec::roadFeatureCompareRoadNames(v8, (const GeoCodecsRoadFeature *)v9, v36);
}

uint64_t geo::codec::featureGetNativeShieldCount(uint64_t result)
{
  if (result) {
    return *(unsigned __int8 *)(result + 72);
  }
  return result;
}

void md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::add(void *a1, void *a2)
{
  int v4 = (std::mutex *)(a1[1] + 8);
  std::mutex::lock(v4);
  uint64_t v5 = (std::__shared_weak_count *)a2[1];
  if (v5)
  {
    unint64_t v6 = std::__shared_weak_count::lock(v5);
    if (v6)
    {
      uint64_t v7 = *a2;
      goto LABEL_6;
    }
  }
  else
  {
    unint64_t v6 = 0;
  }
  uint64_t v7 = 0;
LABEL_6:
  uint64_t v10 = a2;
  uint64_t v11 = v7;
  uint64_t v12 = v6;
  uint64_t v8 = (void *)a1[4];
  if ((unint64_t)v8 >= a1[5])
  {
    uint64_t v9 = std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::StdAllocator<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::Allocator>>::__push_back_slow_path<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>>(a1 + 3, (uint64_t)&v10);
    unint64_t v6 = v12;
    a1[4] = v9;
    if (!v6) {
      goto LABEL_14;
    }
    goto LABEL_12;
  }
  if (v8)
  {
    void *v8 = a2;
    v8[1] = v7;
    v8[2] = v6;
    uint64_t v11 = 0;
    uint64_t v12 = 0;
    unint64_t v6 = 0;
  }
  a1[4] = v8 + 3;
  if (v6)
  {
LABEL_12:
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
LABEL_14:
  std::mutex::unlock(v4);
}

void sub_1A1808810(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  md::components::Material::~Material((md::components::Material *)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::mutex::unlock(v2);
  _Unwind_Resume(a1);
}

uint64_t md::LabelFeatureThunk<md::UniLineLabelFeature,GeoCodecsFeature,geo::codec::VectorTile>::~LabelFeatureThunk(uint64_t a1)
{
  *(void *)a1 = &unk_1EF537260;
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 72);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (!v3) {
      goto LABEL_12;
    }
  }
  uint64_t v4 = *(void *)(a1 + 32);
  uint64_t v5 = v3;
  if (v4 != v3)
  {
    do
    {
      uint64_t v6 = *(std::__shared_weak_count **)(v4 - 8);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *, uint64_t))v6->__on_zero_shared)(v6, v5);
        std::__shared_weak_count::__release_weak(v6);
      }
      v4 -= 24;
    }
    while (v4 != v3);
    uint64_t v5 = *(void *)(a1 + 24);
  }
  *(void *)(a1 + 32) = v3;
  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v5, *(void *)(a1 + 40) - v5);
LABEL_12:
  uint64_t v7 = *(std::__shared_weak_count **)(a1 + 16);
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  return a1;
}

uint64_t geo::codec::roadFeatureCompareRoadNames(geo::codec *this, const GeoCodecsRoadFeature *a2, const GeoCodecsRoadFeature *a3)
{
  uint64_t result = 0;
  if (this && a2)
  {
    uint64_t v6 = *((unsigned __int8 *)this + 73);
    unsigned int v7 = *((unsigned __int8 *)a2 + 73);
    uint64_t result = v6 < v7 ? 0xFFFFFFFFLL : 1;
    if (v6 == v7)
    {
      if (*((unsigned char *)this + 73))
      {
        for (unint64_t i = 0; v6 != i; ++i)
        {
          uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 1);
          if (!v9 || (uint64_t v10 = std::__shared_weak_count::lock(v9)) == 0)
          {
            int v14 = 0;
            goto LABEL_20;
          }
          uint64_t v11 = v10;
          uint64_t v12 = *(void *)this;
          if (i >= *((unsigned __int8 *)this + 73) || v12 == 0)
          {
            int v14 = 0;
            if (atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
              goto LABEL_20;
            }
          }
          else
          {
            int v14 = *(const char **)(*(void *)(v12 + 1048) + 24 * (i + *((unsigned int *)this + 14)));
            if (atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
              goto LABEL_20;
            }
          }
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v11);
LABEL_20:
          BOOL v15 = (std::__shared_weak_count *)*((void *)a2 + 1);
          if (v15)
          {
            BOOL v16 = std::__shared_weak_count::lock(v15);
            if (v16)
            {
              unsigned int v17 = v16;
              int v18 = 0;
              if (i < *((unsigned __int8 *)a2 + 73) && *(void *)a2) {
                int v18 = *(const char **)(*(void *)(*(void *)a2 + 1048) + 24 * (i + *((unsigned int *)a2 + 14)));
              }
              if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
                std::__shared_weak_count::__release_weak(v17);
              }
              if (v14)
              {
                if (v18)
                {
                  uint64_t result = strcmp(v14, v18);
                  if (result) {
                    return result;
                  }
                }
              }
            }
          }
        }
      }
      return 0;
    }
  }
  return result;
}

void *std::vector<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,geo::StdAllocator<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>,mdm::Allocator>>::__emplace_back_slow_path<std::unique_ptr<md::LabelLineStore::WorkUnit,mdm::TypeDeleter<md::LabelLineStore::WorkUnit>>>(uint64_t a1, uint64_t *a2)
{
  uint64_t v2 = (uint64_t)(*(void *)(a1 + 8) - *(void *)a1) >> 3;
  unint64_t v3 = v2 + 1;
  if ((unint64_t)(v2 + 1) >> 61) {
    abort();
  }
  uint64_t v5 = *(void *)(a1 + 16) - *(void *)a1;
  if (v5 >> 2 > v3) {
    unint64_t v3 = v5 >> 2;
  }
  BOOL v19 = (unint64_t)v5 >= 0x7FFFFFFFFFFFFFF8;
  uint64_t v6 = 0x1FFFFFFFFFFFFFFFLL;
  if (!v19) {
    uint64_t v6 = v3;
  }
  if (v6)
  {
    uint64_t v8 = 8 * v6;
    uint64_t v9 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 8 * v6, 8);
    uint64_t v10 = (void *)(v9 + 8 * v2);
    uint64_t v6 = v9 + v8;
    if (v9)
    {
      uint64_t v11 = *a2;
      *a2 = 0;
      *uint64_t v10 = v11;
    }
  }
  else
  {
    uint64_t v10 = (void *)(8 * v2);
  }
  uint64_t v12 = v10 + 1;
  int v13 = *(char **)a1;
  int v14 = *(char **)(a1 + 8);
  if (v14 == *(char **)a1)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    uint64_t v29 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v6;
    goto LABEL_32;
  }
  unint64_t v15 = (unint64_t)&v14[-*(void *)a1 - 8];
  if (v15 <= 0x57
    || ((unint64_t v16 = (v13 - v14 + 7) & 0xFFFFFFFFFFFFFFF8,
         unint64_t v17 = (unint64_t)&v14[v16],
         int v18 = (char *)v10 + v16,
         v17 < (unint64_t)v10)
      ? (BOOL v19 = v18 >= v14)
      : (BOOL v19 = 1),
        !v19))
  {
    uint64_t v21 = *(char **)(a1 + 8);
    do
    {
LABEL_22:
      uint64_t v27 = *((void *)v21 - 1);
      v21 -= 8;
      *(void *)uint64_t v21 = 0;
      *--uint64_t v10 = v27;
    }
    while (v21 != v13);
    goto LABEL_23;
  }
  uint64_t v20 = (v15 >> 3) + 1;
  uint64_t v21 = &v14[-8 * (v20 & 0x3FFFFFFFFFFFFFFCLL)];
  unint64_t v22 = v10 - 2;
  int v23 = v14 - 32;
  uint64_t v24 = v20 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v26 = *(_OWORD *)v23;
    long long v25 = *((_OWORD *)v23 + 1);
    *(_OWORD *)int v23 = 0uLL;
    *((_OWORD *)v23 + 1) = 0uLL;
    v23 -= 32;
    *(v22 - 1) = v26;
    _OWORD *v22 = v25;
    v22 -= 2;
    v24 -= 4;
  }
  while (v24);
  v10 -= v20 & 0x3FFFFFFFFFFFFFFCLL;
  if (v20 != (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_22;
  }
LABEL_23:
  int v14 = *(char **)a1;
  int v28 = *(char **)(a1 + 8);
  *(void *)a1 = v10;
  *(void *)(a1 + 8) = v12;
  uint64_t v29 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v6;
  while (v28 != v14)
  {
    uint64_t v31 = (md::LabelLineStore::WorkUnit *)*((void *)v28 - 1);
    v28 -= 8;
    unint64_t v30 = v31;
    *(void *)int v28 = 0;
    if (v31)
    {
      md::LabelLineStore::WorkUnit::~WorkUnit(v30);
      {
        operator new();
      }
      (*(void (**)(uint64_t, md::LabelLineStore::WorkUnit *, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                               + 40))(mdm::Allocator::instance(void)::alloc, v30, 248);
    }
  }
LABEL_32:
  if (v14) {
    (*(void (**)(void, char *, uint64_t))(**(void **)(a1 + 24) + 40))(*(void *)(a1 + 24), v14, v29 - (void)v14);
  }
  return v12;
}

uint64_t std::vector<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,geo::StdAllocator<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>,mdm::Allocator>>::__push_back_slow_path<std::pair<GeoCodecsFeature const*,std::shared_ptr<geo::codec::VectorTile>>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = 0xAAAAAAAAAAAAAAALL;
  unint64_t v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  unint64_t v4 = v3 + 1;
  if (v3 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((a1[2] - *a1) >> 3) > v4) {
    unint64_t v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) < 0x555555555555555) {
    uint64_t v2 = v4;
  }
  if (v2)
  {
    uint64_t v7 = 24 * v2;
    uint64_t v8 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 24 * v2, 8);
    uint64_t v9 = v8 + 24 * v3;
    uint64_t v2 = v8 + v7;
    if (v8)
    {
      *(_OWORD *)uint64_t v9 = *(_OWORD *)a2;
      *(void *)(v8 + 24 * v3 + 16) = *(void *)(a2 + 16);
      *(void *)(a2 + 8) = 0;
      *(void *)(a2 + 16) = 0;
    }
  }
  else
  {
    uint64_t v9 = 8 * ((a1[1] - *a1) >> 3);
  }
  uint64_t v10 = v9 + 24;
  uint64_t v11 = *a1;
  uint64_t v12 = a1[1];
  if (v12 == *a1)
  {
    *a1 = v9;
    a1[1] = v10;
    uint64_t v15 = a1[2];
    a1[2] = v2;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v12 - 24);
      v12 -= 24;
      *(_OWORD *)(v9 - 24) = v13;
      v9 -= 24;
      *(void *)(v9 + 16) = *(void *)(v12 + 16);
      *(void *)(v12 + 8) = 0;
      *(void *)(v12 + 16) = 0;
    }
    while (v12 != v11);
    uint64_t v12 = *a1;
    uint64_t v14 = a1[1];
    *a1 = v9;
    a1[1] = v10;
    uint64_t v15 = a1[2];
    for (a1[2] = v2; v14 != v12; v14 -= 24)
    {
      unint64_t v16 = *(std::__shared_weak_count **)(v14 - 8);
      if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
        std::__shared_weak_count::__release_weak(v16);
      }
    }
  }
  if (v12) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1[3] + 40))(a1[3], v12, v15 - v12);
  }
  return v10;
}

uint64_t md::LabelLineStore::WorkUnit::WorkUnit(uint64_t a1, int a2, uint64_t *a3, char **a4, uint64_t a5, uint64_t a6)
{
  *(_DWORD *)a1 = a2;
  *(_OWORD *)(a1 + 8) = 0u;
  *(void *)(a1 + 40) = a3;
  *(void *)(a1 + 48) = 0;
  *(void *)(a1 + 56) = 0;
  *(_OWORD *)(a1 + 24) = 0u;
  if (a3)
  {
    uint64_t v11 = (std::__shared_weak_count *)a3[1];
    if (v11 && (uint64_t v11 = std::__shared_weak_count::lock(v11)) != 0) {
      uint64_t v12 = *a3;
    }
    else {
      uint64_t v12 = 0;
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v11 = 0;
  }
  long long v13 = *(std::__shared_weak_count **)(a1 + 56);
  *(void *)(a1 + 48) = v12;
  *(void *)(a1 + 56) = v11;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v14 = *a4;
  uint64_t v15 = a4[1];
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  *(void *)(a1 + 80) = 0;
  *(void *)(a1 + 88) = 0;
  {
    operator new();
  }
  uint64_t v16 = mdm::Allocator::instance(void)::alloc;
  *(void *)(a1 + 96) = mdm::Allocator::instance(void)::alloc;
  uint64_t v17 = v15 - v14;
  if (v15 != v14)
  {
    if (v17 < 0) {
      abort();
    }
    int v18 = (_DWORD *)(*(uint64_t (**)(uint64_t, int64_t, uint64_t))(*(void *)v16 + 16))(v16, v15 - v14, 4);
    *(void *)(a1 + 72) = v18;
    *(void *)(a1 + 88) = &v18[v17 >> 2];
    do
    {
      if (v18) {
        _DWORD *v18 = *(_DWORD *)v14;
      }
      v14 += 4;
      ++v18;
    }
    while (v14 != v15);
    *(void *)(a1 + 80) = v18;
  }
  *(void *)(a1 + 104) = 0;
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  *(void *)(a1 + 128) = a6;
  *(void *)(a1 + 136) = *(void *)a5;
  *(_WORD *)(a1 + 144) = *(_WORD *)(a5 + 8);
  *(void *)(a1 + 148) = *(void *)(a5 + 12);
  long long v19 = *(_OWORD *)(a5 + 32);
  long long v20 = *(_OWORD *)(a5 + 48);
  long long v21 = *(_OWORD *)(a5 + 64);
  *(_OWORD *)(a1 + 211) = *(_OWORD *)(a5 + 75);
  *(_OWORD *)(a1 + 200) = v21;
  *(_OWORD *)(a1 + 184) = v20;
  *(_OWORD *)(a1 + 168) = v19;
  uint64_t v22 = *(void *)(a5 + 104);
  *(void *)(a1 + 232) = *(void *)(a5 + 96);
  *(void *)(a1 + 240) = v22;
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
  }
  return a1;
}

void sub_1A180922C(_Unwind_Exception *a1)
{
  md::components::Material::~Material(v3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1 + 24);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v2);
  _Unwind_Resume(a1);
}

void geo::codec::featureGetNativeShield(uint64_t a1, unint64_t a2, void *a3, void *a4, void *a5)
{
  if (!a1) {
    return;
  }
  uint64_t v9 = *(std::__shared_weak_count **)(a1 + 8);
  if (v9)
  {
    uint64_t v11 = std::__shared_weak_count::lock(v9);
    if (v11 && *(unsigned __int8 *)(a1 + 72) > a2 && *(void *)a1)
    {
      unint64_t v12 = *(unsigned int *)(a1 + 60) + a2;
      uint64_t v13 = *(void *)(*(void *)a1 + 1064);
      uint64_t v14 = (void *)(v13 + 32 * v12);
      if (a3) {
        *a3 = *v14;
      }
      if (a5) {
        *a5 = v14[1];
      }
      if (a4) {
        *a4 = *(void *)(v13 + 32 * v12 + 24);
      }
LABEL_20:
      if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
      return;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  if (a5) {
    *a5 = 0;
  }
  if (v11) {
    goto LABEL_20;
  }
}

uint64_t geo::codec::roadFeatureCompareShields(geo::codec *this, const GeoCodecsRoadFeature *a2, const GeoCodecsRoadFeature *a3)
{
  uint64_t result = 0;
  if (this && a2)
  {
    uint64_t v6 = *((unsigned __int8 *)this + 72);
    unsigned int v7 = *((unsigned __int8 *)a2 + 72);
    uint64_t result = v6 < v7 ? 0xFFFFFFFFLL : 1;
    if (v6 == v7)
    {
      if (!*((unsigned char *)this + 72)) {
        return 0;
      }
      unint64_t v8 = 0;
      while (1)
      {
        uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 1);
        if (v9 && (uint64_t v10 = std::__shared_weak_count::lock(v9)) != 0)
        {
          uint64_t v11 = v10;
          uint64_t v12 = *(void *)this;
          if (v8 >= *((unsigned __int8 *)this + 72) || v12 == 0)
          {
            uint64_t v14 = 0;
            uint64_t v15 = 0;
            if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
              goto LABEL_35;
            }
          }
          else
          {
            unint64_t v22 = *(void *)(v12 + 1064) + 32 * (v8 + *((unsigned int *)this + 15));
            uint64_t v14 = *(const char **)v22;
            uint64_t v15 = *(void *)(v22 + 24);
            if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
LABEL_35:
              ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
              std::__shared_weak_count::__release_weak(v11);
            }
          }
        }
        else
        {
          uint64_t v14 = 0;
          uint64_t v15 = 0;
        }
        uint64_t v16 = (std::__shared_weak_count *)*((void *)a2 + 1);
        if (!v16 || (uint64_t v17 = std::__shared_weak_count::lock(v16)) == 0)
        {
          long long v19 = 0;
          uint64_t v20 = 0;
          goto LABEL_28;
        }
        int v18 = v17;
        long long v19 = 0;
        if (v8 >= *((unsigned __int8 *)a2 + 72))
        {
          uint64_t v20 = 0;
          if (atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_28;
          }
LABEL_37:
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v18);
          goto LABEL_28;
        }
        uint64_t v20 = 0;
        if (*(void *)a2)
        {
          unint64_t v21 = *(void *)(*(void *)a2 + 1064) + 32 * (v8 + *((unsigned int *)a2 + 15));
          long long v19 = *(const char **)v21;
          uint64_t v20 = *(void *)(v21 + 24);
        }
        if (!atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_37;
        }
LABEL_28:
        if (v15 != v20)
        {
          if (v15 < v20) {
            return 0xFFFFFFFFLL;
          }
          else {
            return 1;
          }
        }
        if ((unint64_t)v14 | (unint64_t)v19)
        {
          if (!v14 || !v19)
          {
            if (v14) {
              return 1;
            }
            else {
              return 0xFFFFFFFFLL;
            }
          }
          uint64_t result = strcmp(v14, v19);
          if (result) {
            return result;
          }
        }
        if (v6 == ++v8) {
          return 0;
        }
      }
    }
  }
  return result;
}

void std::vector<ecs2::ModuleBucketDescriptor>::__init_with_size[abi:nn180100]<ecs2::ModuleBucketDescriptor*,ecs2::ModuleBucketDescriptor*>(void *a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 57) {
      abort();
    }
    uint64_t v7 = a4 << 7;
    unint64_t v8 = operator new(a4 << 7);
    *a1 = v8;
    a1[1] = v8;
    a1[2] = (char *)v8 + v7;
    if (a2 != a3)
    {
      uint64_t v9 = a2 + 1;
      do
      {
        *(_WORD *)unint64_t v8 = *((_WORD *)v9 - 4);
        ecs2::ModuleBucketExecutionDescriptor::ModuleBucketExecutionDescriptor((ecs2::ModuleBucketExecutionDescriptor *)(v8 + 1), (const ecs2::ModuleBucketExecutionDescriptor *)v9);
        v8[11] = 0;
        v8[12] = 0;
        v8[10] = 0;
        std::vector<ecs2::UtlityTaskDescriptor>::__init_with_size[abi:nn180100]<ecs2::UtlityTaskDescriptor*,ecs2::UtlityTaskDescriptor*>(v8 + 10, v9[9], v9[10], (v9[10] - v9[9]) >> 6);
        v8[13] = 0;
        v8[14] = 0;
        uint64_t v10 = v8 + 13;
        __int16 v10[2] = 0;
        std::vector<ecs2::UtlityTaskDescriptor>::__init_with_size[abi:nn180100]<ecs2::UtlityTaskDescriptor*,ecs2::UtlityTaskDescriptor*>(v10, v9[12], v9[13], (v9[13] - v9[12]) >> 6);
        unint64_t v8 = v10 + 3;
        uint64_t v11 = v9 + 15;
        v9 += 16;
      }
      while (v11 != a3);
    }
    a1[1] = v8;
  }
}

void std::vector<ecs2::UtlityTaskDescriptor>::__init_with_size[abi:nn180100]<ecs2::UtlityTaskDescriptor*,ecs2::UtlityTaskDescriptor*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >> 58) {
      abort();
    }
    uint64_t v7 = a4 << 6;
    unint64_t v8 = (char *)operator new(a4 << 6);
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[v7];
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        uint64_t v10 = a2 + v9;
        *(_WORD *)&v8[v9] = *(_WORD *)(a2 + v9);
        uint64_t v11 = (uint64_t)&v8[v9 + 8];
        uint64_t v12 = *(void *)(a2 + v9 + 32);
        if (v12)
        {
          if (v10 + 8 == v12)
          {
            *(void *)&v8[v9 + 32] = v11;
            (*(void (**)(uint64_t))(*(void *)v12 + 24))(v12);
          }
          else
          {
            *(void *)&v8[v9 + 32] = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v12 + 16))(v12, v11);
          }
        }
        else
        {
          *(void *)&v8[v9 + 32] = 0;
        }
        uint64_t v13 = (std::string *)&v8[v9 + 40];
        uint64_t v14 = (const std::string::value_type **)(a2 + v9 + 40);
        if (*(char *)(v10 + 63) < 0)
        {
          std::string::__init_copy_ctor_external(v13, *v14, *(void *)(a2 + v9 + 48));
        }
        else
        {
          *(_OWORD *)&v13->__r_.__value_.__l.__data_ = *(_OWORD *)v14;
          *(void *)&v8[v9 + 56] = *(void *)(a2 + v9 + 56);
        }
        v9 += 64;
      }
      while (v10 + 64 != a3);
      v8 += v9;
    }
    a1[1] = v8;
  }
}

ecs2::ModuleBucketExecutionDescriptor *ecs2::ModuleBucketExecutionDescriptor::ModuleBucketExecutionDescriptor(ecs2::ModuleBucketExecutionDescriptor *this, const ecs2::ModuleBucketExecutionDescriptor *a2)
{
  unint64_t v3 = this;
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  uint64_t v4 = *(void *)a2;
  uint64_t v5 = *((void *)a2 + 1);
  int64_t v6 = v5 - *(void *)a2;
  if (v5 != *(void *)a2)
  {
    if (v6 < 0) {
      abort();
    }
    uint64_t v7 = v6 >> 7;
    unint64_t v8 = (char *)operator new(v6);
    uint64_t v9 = 0;
    *(void *)unint64_t v3 = v8;
    *((void *)v3 + 1) = v8;
    *((void *)v3 + 2) = &v8[128 * v7];
    do
    {
      ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor((uint64_t)&v8[v9], v4 + v9);
      v9 += 128;
    }
    while (v4 + v9 != v5);
    *((void *)v3 + 1) = &v8[v9];
  }
  *((void *)v3 + 3) = 0;
  *((void *)v3 + 4) = 0;
  unint64_t v45 = v3;
  *((void *)v3 + 5) = 0;
  uint64_t v10 = *((void *)a2 + 3);
  uint64_t v11 = *((void *)a2 + 4);
  int64_t v12 = v11 - v10;
  if (v11 != v10)
  {
    unint64_t v13 = 0xAAAAAAAAAAAAAAABLL * (v12 >> 3);
    if (v13 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v14 = (char *)operator new(v12);
    uint64_t v15 = 0;
    *((void *)v3 + 3) = v14;
    *((void *)v3 + 4) = v14;
    *((void *)v3 + 5) = &v14[24 * v13];
    do
    {
      uint64_t v16 = v10 + v15;
      uint64_t v17 = &v14[v15];
      *(void *)uint64_t v17 = 0;
      *((void *)v17 + 1) = 0;
      *((void *)v17 + 2) = 0;
      long long v19 = *(unsigned char **)(v10 + v15);
      int v18 = *(unsigned char **)(v10 + v15 + 8);
      int64_t v20 = v18 - v19;
      if (v18 != v19)
      {
        if (v20 < 0) {
          abort();
        }
        unint64_t v21 = (char *)operator new(v18 - v19);
        *(void *)uint64_t v17 = v21;
        *((void *)v17 + 1) = v21;
        unint64_t v22 = &v21[8 * (v20 >> 3)];
        *((void *)v17 + 2) = v22;
        memcpy(v21, v19, v20);
        *((void *)v17 + 1) = v22;
      }
      v15 += 24;
    }
    while (v16 + 24 != v11);
    unint64_t v3 = v45;
    *((void *)v45 + 4) = &v14[v15];
  }
  *((void *)v3 + 6) = 0;
  *((void *)v3 + 7) = 0;
  *((void *)v3 + 8) = 0;
  uint64_t v23 = *((void *)a2 + 6);
  uint64_t v24 = *((void *)a2 + 7);
  int64_t v25 = v24 - v23;
  if (v24 != v23)
  {
    unint64_t v26 = 0xCCCCCCCCCCCCCCCDLL * (v25 >> 4);
    if (v26 >= 0x333333333333334) {
      abort();
    }
    uint64_t v27 = (char *)operator new(v25);
    uint64_t v28 = 0;
    *((void *)v45 + 6) = v27;
    *((void *)v45 + 7) = v27;
    *((void *)v45 + 8) = &v27[80 * v26];
    while (1)
    {
      unint64_t v30 = &v27[v28];
      *(void *)&v27[v28 + 8] = 0;
      uint64_t v31 = v23 + v28;
      *(void *)unint64_t v30 = 0;
      *((void *)v30 + 2) = 0;
      unint64_t v33 = *(unsigned char **)(v23 + v28);
      int v32 = *(unsigned char **)(v23 + v28 + 8);
      int64_t v34 = v32 - v33;
      if (v32 != v33)
      {
        if (v34 < 0) {
          abort();
        }
        size_t v35 = (char *)operator new(v32 - v33);
        *(void *)unint64_t v30 = v35;
        *((void *)v30 + 1) = v35;
        uint64_t v36 = &v35[2 * (v34 >> 1)];
        *((void *)v30 + 2) = v36;
        memcpy(v35, v33, v34);
        *((void *)v30 + 1) = v36;
      }
      *((void *)v30 + 3) = 0;
      *((void *)v30 + 4) = 0;
      *((void *)v30 + 5) = 0;
      uint64_t v38 = *(unsigned char **)(v31 + 24);
      uint8x8_t v37 = *(unsigned char **)(v31 + 32);
      int64_t v39 = v37 - v38;
      if (v37 != v38)
      {
        if (v39 < 0) {
          abort();
        }
        uint64_t v40 = (char *)operator new(v37 - v38);
        *((void *)v30 + 3) = v40;
        *((void *)v30 + 4) = v40;
        size_t v41 = &v40[2 * (v39 >> 1)];
        *((void *)v30 + 5) = v41;
        memcpy(v40, v38, v39);
        *((void *)v30 + 4) = v41;
      }
      uint64_t v42 = &v27[v28];
      uint64_t v43 = v23 + v28;
      uint64_t v29 = *(void *)(v23 + v28 + 72);
      if (v29)
      {
        if (v43 + 48 == v29)
        {
          *(void *)&v27[v28 + 72] = v42 + 48;
          (*(void (**)(void))(**(void **)(v43 + 72) + 24))(*(void *)(v43 + 72));
          goto LABEL_19;
        }
        uint64_t v29 = (*(uint64_t (**)(uint64_t))(*(void *)v29 + 16))(v29);
      }
      *((void *)v42 + 9) = v29;
LABEL_19:
      v28 += 80;
      if (v23 + v28 == v24)
      {
        unint64_t v3 = v45;
        *((void *)v45 + 7) = &v27[v28];
        return v3;
      }
    }
  }
  return v3;
}

void sub_1A1809AD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void **a11, void **a12)
{
}

void sub_1A1809B68(_Unwind_Exception *a1)
{
  *(void *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t ecs2::ExecutionTaskDescriptor::ExecutionTaskDescriptor(uint64_t a1, uint64_t a2)
{
  *(_WORD *)a1 = *(_WORD *)a2;
  uint64_t v4 = a1 + 8;
  uint64_t v5 = *(void *)(a2 + 32);
  if (v5)
  {
    if (v5 == a2 + 8)
    {
      *(void *)(a1 + 32) = v4;
      (*(void (**)(void, uint64_t))(**(void **)(a2 + 32) + 24))(*(void *)(a2 + 32), v4);
    }
    else
    {
      *(void *)(a1 + 32) = (*(uint64_t (**)(uint64_t))(*(void *)v5 + 16))(v5);
    }
  }
  else
  {
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v6 = *(void *)(a2 + 64);
  if (!v6) {
    goto LABEL_9;
  }
  if (v6 != a2 + 40)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)v6 + 16))(v6);
LABEL_9:
    *(void *)(a1 + 64) = v6;
    goto LABEL_11;
  }
  *(void *)(a1 + 64) = a1 + 40;
  (*(void (**)(void, uint64_t))(**(void **)(a2 + 64) + 24))(*(void *)(a2 + 64), a1 + 40);
LABEL_11:
  uint64_t v7 = *(void *)(a2 + 96);
  if (!v7)
  {
LABEL_14:
    *(void *)(a1 + 96) = v7;
    goto LABEL_16;
  }
  if (v7 != a2 + 72)
  {
    uint64_t v7 = (*(uint64_t (**)(uint64_t))(*(void *)v7 + 16))(v7);
    goto LABEL_14;
  }
  *(void *)(a1 + 96) = a1 + 72;
  (*(void (**)(void, uint64_t))(**(void **)(a2 + 96) + 24))(*(void *)(a2 + 96), a1 + 72);
LABEL_16:
  unint64_t v8 = (std::string *)(a1 + 104);
  if (*(char *)(a2 + 127) < 0)
  {
    std::string::__init_copy_ctor_external(v8, *(const std::string::value_type **)(a2 + 104), *(void *)(a2 + 112));
  }
  else
  {
    long long v9 = *(_OWORD *)(a2 + 104);
    *(void *)(a1 + 120) = *(void *)(a2 + 120);
    *(_OWORD *)&v8->__r_.__value_.__l.__data_ = v9;
  }
  return a1;
}

void sub_1A1809D40(_Unwind_Exception *a1)
{
  uint64_t v6 = v2[12];
  if (v6 == v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 32))(v4);
  }
  else if (v6)
  {
    (*(void (**)(uint64_t))(*(void *)v6 + 40))(v6);
  }
  uint64_t v7 = v2[8];
  if (v7 == v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  else if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 40))(v7);
  }
  uint64_t v8 = v2[4];
  if (v8 == v1)
  {
    (*(void (**)(uint64_t))(*(void *)v1 + 32))(v1);
    _Unwind_Resume(a1);
  }
  if (v8)
  {
    (*(void (**)(uint64_t))(*(void *)v8 + 40))(v8);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

void md::LabelImageLoader::loadIconImage(grl::Allocator *a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = a1;
  uint64_t v116 = *MEMORY[0x1E4F143B8];
  long long v97 = 0uLL;
  v103[0] = 0;
  __asm { FMOV            V0.2S, #1.0 }
  v103[1] = _D0;
  char v104 = 0;
  __int16 v105 = 0;
  char v106 = 0;
  char v107 = 0;
  char v108 = 0;
  char v109 = 0;
  v111[0] = 0;
  v111[1] = grl::Allocator::instance(a1);
  v111[2] = 0;
  uint64_t v110 = v111;
  uint64_t v115 = 0;
  v11.n128_u32[0] = 0;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  uint64_t v12 = *a3;
  if (*(unsigned char *)(*a3 + 112) == 6 && *(unsigned char *)(v12 + 180))
  {
    grl::IconModifiers::setTailDirection((uint64_t)v103, *(float *)(v12 + 184));
    uint64_t v12 = *a3;
  }
  if (*(unsigned char *)(v12 + 197))
  {
    grl::IconModifiers::setUseBalloonShape((uint64_t)v103, 1);
    uint64_t v12 = *a3;
  }
  unint64_t v13 = (void *)(v12 + 120);
  if (*(char *)(v12 + 143) < 0)
  {
    std::string::size_type v14 = *(void *)(v12 + 128);
    if (!v14) {
      goto LABEL_23;
    }
    if (v14 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    unint64_t v13 = (void *)*v13;
    if (v14 < 0x17) {
      goto LABEL_9;
    }
LABEL_13:
    uint64_t v16 = (v14 & 0x7FFFFFFFFFFFFFF8) + 8;
    if ((v14 | 7) != 0x17) {
      uint64_t v16 = v14 | 7;
    }
    uint64_t v17 = v16 + 1;
    p_dst = (std::string *)operator new(v16 + 1);
    __dst.__r_.__value_.__l.__size_ = v14;
    __dst.__r_.__value_.__r.__words[2] = v17 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_16;
  }
  std::string::size_type v14 = *(unsigned __int8 *)(v12 + 143);
  if (!*(unsigned char *)(v12 + 143)) {
    goto LABEL_23;
  }
  if (v14 >= 0x17) {
    goto LABEL_13;
  }
LABEL_9:
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v14;
  p_dst = &__dst;
LABEL_16:
  memmove(p_dst, v13, v14);
  p_dst->__r_.__value_.__s.__data_[v14] = 0;
  v11.n128_f64[0] = grl::IconModifiers::setText(v103, &__dst);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  if (*(unsigned char *)(*a3 + 112) != 6)
  {
    grl::IconModifiers::setScale((grl::IconModifiers *)v103, *(float *)(*a3 + 188));
    grl::IconModifiers::setPathScale((uint64_t)v103, *(float *)(*a3 + 200));
    grl::IconModifiers::setGlyphHidden((uint64_t)v103, 1);
    grl::IconModifiers::setClusterIcon(v103, 1);
    int v18 = *(unsigned __int8 *)(*a3 + 116);
    if (v18 == 2)
    {
      grl::IconModifiers::setLandmark((uint64_t)v103, 1);
    }
    else if (v18 == 10)
    {
      grl::IconModifiers::setSelected((uint64_t)v103, 1);
    }
  }
LABEL_23:
  uint64_t v19 = *(void *)(*a3 + 296);
  if (!v19) {
    goto LABEL_40;
  }
  if (v19 == *a3 + 272)
  {
    *(void *)&long long v99 = &__dst;
    (*(void (**)(uint64_t, std::string *))(*(void *)v19 + 24))(v19, &__dst);
    int64_t v20 = (std::string *)v99;
  }
  else
  {
    int64_t v20 = (std::string *)(*(uint64_t (**)(uint64_t))(*(void *)v19 + 16))(v19);
    *(void *)&long long v99 = v20;
  }
  if (v20 == &__dst)
  {
    (*(void (**)(std::string *))(__dst.__r_.__value_.__r.__words[0] + 32))(&__dst);
  }
  else
  {
    if (!v20) {
      goto LABEL_40;
    }
    (*(void (**)(std::string *))(v20->__r_.__value_.__r.__words[0] + 40))(v20);
  }
  uint64_t v21 = *(void *)(*a3 + 296);
  if (!v21) {
    goto LABEL_34;
  }
  if (v21 != *a3 + 272)
  {
    uint64_t v21 = (*(uint64_t (**)(uint64_t))(*(void *)v21 + 16))(v21);
LABEL_34:
    float v102 = (void *)v21;
    goto LABEL_36;
  }
  float v102 = v101;
  (*(void (**)(uint64_t, void *))(*(void *)v21 + 24))(v21, v101);
LABEL_36:
  grl::IconModifiers::setImageDataProvider((uint64_t)v103, (uint64_t)v101);
  if (v102 == v101)
  {
    __n128 v11 = ((__n128 (*)(void *))*(void *)(v101[0] + 32))(v101);
  }
  else if (v102)
  {
    (*(void (**)(void))(*v102 + 40))();
  }
LABEL_40:
  v11.n128_u8[0] = *(unsigned char *)(*a3 + 160);
  float v22 = (float)v11.n128_u32[0];
  v11.n128_u8[0] = *(unsigned char *)(*a3 + 161);
  float v23 = (float)v11.n128_u32[0];
  v11.n128_u8[0] = *(unsigned char *)(*a3 + 162);
  float v24 = (float)v11.n128_u32[0];
  int v25 = *(unsigned __int8 *)(*a3 + 163);
  if ((float)(v22 * 0.0039216) >= 0.0031308) {
    float v26 = (float)(powf(v22 * 0.0039216, 0.41667) * 1.055) + -0.055;
  }
  else {
    float v26 = v22 * 0.050667;
  }
  if ((float)(v23 * 0.0039216) >= 0.0031308) {
    float v27 = (float)(powf(v23 * 0.0039216, 0.41667) * 1.055) + -0.055;
  }
  else {
    float v27 = v23 * 0.050667;
  }
  if ((float)(v24 * 0.0039216) >= 0.0031308) {
    float v28 = (float)(powf(v24 * 0.0039216, 0.41667) * 1.055) + -0.055;
  }
  else {
    float v28 = v24 * 0.050667;
  }
  LODWORD(__dst.__r_.__value_.__l.__data_) = (v25 << 24) | ((int)(float)(v28 * 255.0) << 16) | ((int)(float)(v27 * 255.0) << 8) | (int)(float)(v26 * 255.0);
  grl::IconModifiers::setTransitLineColor((uint64_t)v103, &__dst);
  grl::IconRequestOptions::setSizeGroup((uint64_t)v103, *(unsigned char *)(*a3 + 196));
  uint64_t v29 = (uint32x4_t *)grl::IconModifiers::setComponent((uint64_t)v103, *(unsigned char *)(*a3 + 117));
  unint64_t v30 = *(uint16x4_t **)(*a3 + 72);
  uint64_t v31 = *(unsigned __int16 **)(*a3 + 80);
  uint64_t v95 = 0;
  unsigned int v96 = 0;
  uint64_t v94 = 0;
  uint64_t v32 = (char *)v31 - (char *)v30;
  if (v31 == (unsigned __int16 *)v30) {
    goto LABEL_59;
  }
  if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFFLL) {
    abort();
  }
  uint64_t v29 = (uint32x4_t *)operator new(2 * v32);
  uint64_t v94 = v29;
  unsigned int v96 = &v29->i8[4 * (v32 >> 1)];
  unint64_t v33 = v29;
  if ((unint64_t)(v32 - 2) < 0x1E) {
    goto LABEL_56;
  }
  unint64_t v34 = ((unint64_t)(v32 - 2) >> 1) + 1;
  size_t v35 = v29 + 2;
  uint64_t v36 = v30 + 2;
  unint64_t v37 = v34 & 0xFFFFFFFFFFFFFFF0;
  do
  {
    uint16x8_t v38 = *(uint16x8_t *)v36[-2].i8;
    uint32x4_t v39 = vmovl_u16(*v36);
    uint32x4_t v40 = vmovl_high_u16(*(uint16x8_t *)v36->i8);
    v35[-2] = vmovl_u16(*(uint16x4_t *)v38.i8);
    v35[-1] = vmovl_high_u16(v38);
    uint32x4_t *v35 = v39;
    v35[1] = v40;
    v35 += 4;
    v36 += 4;
    v37 -= 16;
  }
  while (v37);
  unint64_t v33 = (uint32x4_t *)((char *)v29 + 4 * (v34 & 0xFFFFFFFFFFFFFFF0));
  if (v34 != (v34 & 0xFFFFFFFFFFFFFFF0))
  {
    unint64_t v30 = (uint16x4_t *)((char *)v30 + 2 * (v34 & 0xFFFFFFFFFFFFFFF0));
    do
    {
LABEL_56:
      int v41 = v30->u16[0];
      unint64_t v30 = (uint16x4_t *)((char *)v30 + 2);
      v33->i32[0] = v41;
      unint64_t v33 = (uint32x4_t *)((char *)v33 + 4);
    }
    while (v30 != (uint16x4_t *)v31);
  }
  uint64_t v95 = v33;
  if (v33 != v29) {
    uint64_t v29 = (uint32x4_t *)grl::IconModifiers::setClusterIconValues((uint64_t)v103, (uint64_t)&v94);
  }
LABEL_59:
  int v85 = 1065353216;
  char v86 = 4;
  __int16 v88 = -1;
  int v87 = 0;
  char v89 = 0;
  uint64_t v91 = 0;
  uint64_t v92 = 0;
  uint64_t v90 = 0;
  uint64_t v93 = grl::Allocator::instance((grl::Allocator *)v29);
  grl::IconRequestOptions::setContentScale((float *)&v85, *(float *)(*a3 + 56));
  grl::IconRequestOptions::setSizeGroup((uint64_t)&v85, *(unsigned char *)(*a3 + 168));
  grl::IconRequestOptions::setVariant((uint64_t)&v85, *(_WORD *)(*a3 + 172));
  grl::IconRequestOptions::setDataVariant((uint64_t)&v85, *(_WORD *)(*a3 + 176));
  grl::IconRequestOptions::setCountryCode((uint64_t)&v85, *(_WORD *)(*a3 + 192));
  (*(void (**)(uint64_t **__return_ptr))(**(void **)(*(void *)(*(void *)(a2 + 112) + 168) + 64)
                                                 + 48))(&v83);
  if (v83)
  {
    std::string __p = 0;
    uint64_t v81 = 0;
    unsigned int v82 = 0;
    uint64_t v42 = *v83;
    uint64_t v43 = v83[1];
    int64_t v44 = v43 - *v83;
    if (v43 != *v83)
    {
      unint64_t v45 = 0xAAAAAAAAAAAAAAABLL * (v44 >> 3);
      if (v45 >= 0xAAAAAAAAAAAAAABLL) {
        abort();
      }
      unsigned int v46 = (char *)operator new(v44);
      uint64_t v47 = 0;
      std::string __p = v46;
      uint64_t v81 = v46;
      unsigned int v82 = &v46[24 * v45];
      do
      {
        unsigned int v49 = (long long *)(v42 + v47);
        BOOL v50 = (std::string *)&v46[v47];
        if (*(char *)(v42 + v47 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v50, *(const std::string::value_type **)v49, *((void *)v49 + 1));
        }
        else
        {
          long long v48 = *v49;
          v50->__r_.__value_.__r.__words[2] = *((void *)v49 + 2);
          *(_OWORD *)&v50->__r_.__value_.__l.__data_ = v48;
        }
        v47 += 24;
      }
      while (v42 + v47 != v43);
      uint64_t v81 = &v46[v47];
    }
  }
  else
  {
    std::string __p = 0;
    uint64_t v81 = 0;
    unsigned int v82 = 0;
  }
  grl::IconRequestOptions::setResourceNames((uint64_t)&v85, (long long **)&__p);
  long long v100 = 0u;
  long long v99 = 0u;
  *(_OWORD *)&__dst.__r_.__value_.__r.__words[1] = 0u;
  uint64_t v51 = *a3;
  if (*(_DWORD *)(*a3 + 60))
  {
    grl::IconManager::imageForKeyValue([*(id *)(*(void *)(a2 + 112) + 96) grlIconManager], *(_DWORD *)(*a3 + 60), *(unsigned __int16 *)(*a3 + 64), (const grl::IconModifiers *)v103, (float *)&v85, &__dst, v77);
    long long v97 = *(_OWORD *)v77;
    unint64_t v52 = v77[0];
    uint64_t v51 = *a3;
    if (v77[0])
    {
      char v53 = 8;
LABEL_94:
      md::LabelImageKey::setDebugInfo((void **)v51, (uint64_t)&__dst);
LABEL_95:
      *(unsigned char *)(*a3 + 113) = v53;
      uint64_t v65 = *((void *)&v97 + 1);
      *(void *)uint64_t v5 = v52;
      *((void *)v5 + 1) = v65;
      uint64_t v5 = (grl::Allocator *)&v97;
      goto LABEL_96;
    }
  }
  if ((*(char *)(v51 + 39) & 0x80000000) == 0)
  {
    uint64_t v54 = *(void *)(a2 + 112);
    if (*(unsigned char *)(v51 + 39)) {
      goto LABEL_74;
    }
LABEL_79:
    if (!*(unsigned char *)(v54 + 3662)) {
      goto LABEL_96;
    }
    goto LABEL_131;
  }
  uint64_t v54 = *(void *)(a2 + 112);
  if (!*(void *)(v51 + 24)) {
    goto LABEL_79;
  }
LABEL_74:
  uint64_t v55 = [*(id *)(v54 + 96) grlIconManager];
  int v56 = *(char *)(v51 + 39);
  if (v56 < 0)
  {
    size_t v58 = *(void *)(v51 + 24);
    if (v58 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    uint64_t v57 = *(const void **)(v51 + 16);
    if (v58 < 0x17)
    {
LABEL_76:
      HIBYTE(v78) = v58;
      unint64_t v59 = v77;
      if (!v58) {
        goto LABEL_87;
      }
      goto LABEL_86;
    }
  }
  else
  {
    uint64_t v57 = (const void *)(v51 + 16);
    size_t v58 = v56;
    if (v56 < 0x17uLL) {
      goto LABEL_76;
    }
  }
  uint64_t v60 = (v58 & 0x7FFFFFFFFFFFFFF8) + 8;
  if ((v58 | 7) != 0x17) {
    uint64_t v60 = v58 | 7;
  }
  uint64_t v61 = v60 + 1;
  unint64_t v59 = operator new(v60 + 1);
  v77[1] = (void *)v58;
  unint64_t v78 = v61 | 0x8000000000000000;
  v77[0] = v59;
LABEL_86:
  memmove(v59, v57, v58);
LABEL_87:
  *((unsigned char *)v59 + v58) = 0;
  grl::IconManager::imageForName(v55, (uint64_t)v77, (uint64_t)v103, (float *)&v85, &__dst, &v79);
  long long v62 = v79;
  long long v79 = 0uLL;
  unint64_t v63 = (std::__shared_weak_count *)*((void *)&v97 + 1);
  long long v97 = v62;
  if (v63 && !atomic_fetch_add(&v63->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
    std::__shared_weak_count::__release_weak(v63);
    int64_t v64 = (std::__shared_weak_count *)*((void *)&v79 + 1);
    if (!*((void *)&v79 + 1))
    {
LABEL_91:
      if ((SHIBYTE(v78) & 0x80000000) == 0) {
        goto LABEL_92;
      }
LABEL_129:
      operator delete(v77[0]);
      unint64_t v52 = (void *)v97;
      if ((void)v97) {
        goto LABEL_93;
      }
      goto LABEL_130;
    }
  }
  else
  {
    int64_t v64 = (std::__shared_weak_count *)*((void *)&v79 + 1);
    if (!*((void *)&v79 + 1)) {
      goto LABEL_91;
    }
  }
  if (atomic_fetch_add(&v64->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
    goto LABEL_91;
  }
  ((void (*)(std::__shared_weak_count *))v64->__on_zero_shared)(v64);
  std::__shared_weak_count::__release_weak(v64);
  if (SHIBYTE(v78) < 0) {
    goto LABEL_129;
  }
LABEL_92:
  unint64_t v52 = (void *)v97;
  if ((void)v97)
  {
LABEL_93:
    uint64_t v51 = *a3;
    char v53 = 9;
    goto LABEL_94;
  }
LABEL_130:
  uint64_t v54 = *(void *)(a2 + 112);
  if (!*(unsigned char *)(v54 + 3662)) {
    goto LABEL_96;
  }
LABEL_131:
  grl::IconManager::imageForKeyValue(objc_msgSend(*(id *)(v54 + 96), "grlIconManager", v77[0]), 0x10008u, 1, (const grl::IconModifiers *)v103, (float *)&v85, 0, v77);
  long long v74 = *(_OWORD *)v77;
  v77[0] = 0;
  v77[1] = 0;
  float v75 = (std::__shared_weak_count *)*((void *)&v97 + 1);
  long long v97 = v74;
  if (v75 && !atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
    std::__shared_weak_count::__release_weak(v75);
  }
  uint64_t v76 = (std::__shared_weak_count *)v77[1];
  if (v77[1] && !atomic_fetch_add((atomic_ullong *volatile)v77[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v76->__on_zero_shared)(v76);
    std::__shared_weak_count::__release_weak(v76);
  }
  unint64_t v52 = (void *)v97;
  if ((void)v97)
  {
    char v53 = 10;
    goto LABEL_95;
  }
LABEL_96:
  *(void *)uint64_t v5 = 0;
  *((void *)v5 + 1) = 0;
  if (SHIBYTE(v100) < 0)
  {
    operator delete(*((void **)&v99 + 1));
    if ((SBYTE7(v99) & 0x80000000) == 0)
    {
LABEL_98:
      uint64_t v66 = (char *)__p;
      if (__p) {
        goto LABEL_99;
      }
LABEL_109:
      uint64_t v69 = v84;
      if (!v84) {
        goto LABEL_112;
      }
      goto LABEL_110;
    }
  }
  else if ((SBYTE7(v99) & 0x80000000) == 0)
  {
    goto LABEL_98;
  }
  operator delete((void *)__dst.__r_.__value_.__l.__size_);
  uint64_t v66 = (char *)__p;
  if (!__p) {
    goto LABEL_109;
  }
LABEL_99:
  uint64_t v67 = (void **)v81;
  unint64_t v68 = v66;
  if (v81 != v66)
  {
    do
    {
      if (*((char *)v67 - 1) < 0) {
        operator delete(*(v67 - 3));
      }
      v67 -= 3;
    }
    while (v67 != (void **)v66);
    unint64_t v68 = __p;
  }
  uint64_t v81 = v66;
  operator delete(v68);
  uint64_t v69 = v84;
  if (v84)
  {
LABEL_110:
    if (!atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
      std::__shared_weak_count::__release_weak(v69);
    }
  }
LABEL_112:
  uint64_t v70 = v90;
  if (v90)
  {
    uint64_t v71 = v91;
    uint64_t v72 = v90;
    if (v91 != v90)
    {
      do
      {
        if (*(char *)(v71 - 1) < 0) {
          operator delete(*(void **)(v71 - 24));
        }
        v71 -= 24;
      }
      while (v71 != v70);
      uint64_t v72 = v90;
    }
    uint64_t v91 = v70;
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v93 + 40))(v93, v72, v92 - v72);
  }
  if (v94)
  {
    uint64_t v95 = v94;
    operator delete(v94);
  }
  grl::IconModifiers::~IconModifiers((grl::IconModifiers *)v103);
  uint64_t v73 = (std::__shared_weak_count *)*((void *)&v97 + 1);
  if (*((void *)&v97 + 1))
  {
    if (!atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v97 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
      std::__shared_weak_count::__release_weak(v73);
    }
  }
}

void sub_1A180AB58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *__p,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

uint64_t grl::IconRequestOptions::setSizeGroup(uint64_t result, char a2)
{
  *(unsigned char *)(result + 4) = a2;
  return result;
}

void grl::IconModifiers::~IconModifiers(grl::IconModifiers *this)
{
  uint64_t v2 = (char *)this + 168;
  uint64_t v3 = (char *)*((void *)this + 24);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    uint64_t v4 = (void *)*((void *)this + 18);
    if (v4)
    {
LABEL_5:
      *((void *)this + 19) = v4;
      operator delete(v4);
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    uint64_t v4 = (void *)*((void *)this + 18);
    if (v4) {
      goto LABEL_5;
    }
  }
  uint64_t v5 = (void *)*((void *)this + 15);
  if (v5)
  {
    *((void *)this + 16) = v5;
    operator delete(v5);
  }
  std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,std::string>,grl::Allocator>>::destroy((uint64_t)this + 88, *((void *)this + 12));
  if (*((unsigned char *)this + 56))
  {
    if (*((char *)this + 87) < 0) {
      operator delete(*((void **)this + 8));
    }
    *((unsigned char *)this + 56) = 0;
  }
  if (*((unsigned char *)this + 44)) {
    *((unsigned char *)this + 44) = 0;
  }
  if (*((unsigned char *)this + 36)) {
    *((unsigned char *)this + 36) = 0;
  }
  if (*((unsigned char *)this + 30)) {
    *((unsigned char *)this + 30) = 0;
  }
  if (*((unsigned char *)this + 25)) {
    *((unsigned char *)this + 25) = 0;
  }
  if (*((unsigned char *)this + 16)) {
    *((unsigned char *)this + 16) = 0;
  }
}

{
  void *v2;
  void *v3;

  std::function<CGImage * ()(gm::Matrix<unsigned int,2,1>,float)>::~function((void *)this + 21);
  uint64_t v2 = (void *)*((void *)this + 18);
  if (v2)
  {
    *((void *)this + 19) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 15);
  if (v3)
  {
    *((void *)this + 16) = v3;
    operator delete(v3);
  }
  std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,std::string>,grl::Allocator>>::destroy((uint64_t)this + 88, *((void *)this + 12));
  if (*((unsigned char *)this + 56))
  {
    if (*((char *)this + 87) < 0) {
      operator delete(*((void **)this + 8));
    }
    *((unsigned char *)this + 56) = 0;
  }
  if (*((unsigned char *)this + 44)) {
    *((unsigned char *)this + 44) = 0;
  }
  if (*((unsigned char *)this + 36)) {
    *((unsigned char *)this + 36) = 0;
  }
  if (*((unsigned char *)this + 30)) {
    *((unsigned char *)this + 30) = 0;
  }
  if (*((unsigned char *)this + 25)) {
    *((unsigned char *)this + 25) = 0;
  }
  if (*((unsigned char *)this + 16)) {
    *((unsigned char *)this + 16) = 0;
  }
}

uint64_t std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,std::string>,grl::Allocator>>::destroy(uint64_t result, uint64_t a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,std::string>,grl::Allocator>>::destroy(result, *(void *)a2);
    std::__tree<std::__value_type<unsigned short,std::string>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,std::string>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,std::string>,grl::Allocator>>::destroy(v3, *(void *)(a2 + 8));
    if (*(char *)(a2 + 63) < 0) {
      operator delete(*(void **)(a2 + 40));
    }
    uint64_t v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

float *grl::IconRequestOptions::setContentScale(float *this, float a2)
{
  *this = a2;
  return this;
}

uint64_t grl::IconRequestOptions::setDataVariant(uint64_t this, __int16 a2)
{
  *(_WORD *)(this + 6) = a2;
  return this;
}

uint64_t grl::IconRequestOptions::setCountryCode(uint64_t this, __int16 a2)
{
  *(_WORD *)(this + 10) = a2;
  return this;
}

uint64_t grl::IconRequestOptions::setVariant(uint64_t this, __int16 a2)
{
  *(_WORD *)(this + 8) = a2;
  return this;
}

void non-virtual thunk to'md::StandardLabeler::resourcesAtMercatorPoint(uint64_t a1@<X0>, double *a2@<X1>, void *a3@<X8>)
{
}

void md::LabelPool::resourcesAtMercatorPoint(void *a1, uint64_t a2, uint64_t a3, double *a4)
{
  *a1 = 0;
  a1[1] = 0;
  if (a2 != a3)
  {
    uint64_t v6 = a2;
    int v8 = -1;
    do
    {
      uint64_t v9 = *(void *)(*(void *)v6 + 152);
      uint64_t v10 = *(std::__shared_weak_count **)(*(void *)v6 + 160);
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v9)
      {
        int v11 = *(_DWORD *)(v9 + 48);
        if (v11 > v8 && *a4 >= *(double *)(v9 + 56) && *a4 < *(double *)(v9 + 72))
        {
          double v12 = a4[1];
          if (v12 >= *(double *)(v9 + 64) && v12 < *(double *)(v9 + 80))
          {
            if (v10) {
              atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            unint64_t v13 = (std::__shared_weak_count *)a1[1];
            *a1 = v9;
            a1[1] = v10;
            if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
              std::__shared_weak_count::__release_weak(v13);
            }
            int v8 = v11;
          }
        }
      }
      if (v10)
      {
        if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
          std::__shared_weak_count::__release_weak(v10);
        }
      }
      v6 += 16;
    }
    while (v6 != a3);
  }
}

uint64_t *grl::IconRequestOptions::setResourceNames(uint64_t a1, long long **a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v8 = 0;
  uint64_t v11 = grl::Allocator::instance((grl::Allocator *)a1);
  if (v4 == v3)
  {
    uint64_t v5 = 0;
  }
  else
  {
    std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__vallocate[abi:nn180100]((uint64_t)&v8, 0xAAAAAAAAAAAAAAABLL * (((char *)v4 - (char *)v3) >> 3));
    uint64_t v5 = std::__uninitialized_allocator_copy_impl[abi:nn180100]<geo::StdAllocator<std::string,grl::Allocator>,std::string const*,std::string const*,std::string*>((int)&v11, v3, v4, v9);
    uint64_t v9 = v5;
  }
  if (*(void *)(a1 + 16))
  {
    std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__clear[abi:nn180100]((uint64_t *)(a1 + 16));
    (*(void (**)(void, void, void))(**(void **)(a1 + 40) + 40))(*(void *)(a1 + 40), *(void *)(a1 + 16), *(void *)(a1 + 32) - *(void *)(a1 + 16));
    uint64_t v5 = v9;
  }
  uint64_t v6 = v10;
  *(void *)(a1 + 16) = v8;
  *(void *)(a1 + 24) = v5;
  *(void *)(a1 + 32) = v6;
  uint64_t v9 = 0;
  uint64_t v10 = 0;
  uint64_t v8 = 0;
  double v12 = &v8;
  uint64_t result = std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100](&v12);
  *(unsigned char *)(a1 + 12) = 1;
  return result;
}

void grl::IconManager::imageForIconID(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(unsigned __int16 *)(a4 + 6);
  uint64_t v5 = *(unsigned __int16 *)(a4 + 8);
  uint64_t v6 = *(unsigned __int8 *)(a4 + 4);
  unsigned int v10 = a2;
  __int16 v11 = v4;
  unint64_t v7 = a2 - 0x61C8864680B583EBLL;
  __int16 v12 = v5;
  char v13 = v6;
  unint64_t v8 = (v5
      + ((((v7 << 6) + (v7 >> 2) + v4 - 0x61C8864680B583EBLL) ^ v7) << 6)
      + ((((v7 << 6) + (v7 >> 2) + v4 - 0x61C8864680B583EBLL) ^ v7) >> 2)
      - 0x61C8864680B583EBLL) ^ ((v7 << 6) + (v7 >> 2) + v4 - 0x61C8864680B583EBLL) ^ v7;
  uint64_t v9[3] = &unk_1EF5672F0;
  v9[4] = (v6 + (v8 << 6) + (v8 >> 2) - 0x61C8864680B583EBLL) ^ v8;
  __int16 v9[2] = 0;
  if (*(unsigned char *)(a4 + 12))
  {
    (*(void (**)(void *__return_ptr))(**(void **)(a1 + 8) + 32))(v9);
    geo::make_unique<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>,std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const&>();
  }
  (*(void (**)(uint64_t *__return_ptr))(**(void **)(a1 + 8) + 32))(&v14);
  geo::make_unique<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>,std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const&>();
}

uint64_t **std::unique_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>>::reset[abi:nn180100](uint64_t **result, uint64_t *a2)
{
  uint64_t v2 = *result;
  uint64_t *result = a2;
  if (v2)
  {
    uint64_t v3 = v2;
    std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100](&v3);
    return (uint64_t **)MEMORY[0x1A6239270](v2, 0x20C40DC1BFBCFLL);
  }
  return result;
}

uint64_t *std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100](uint64_t **a1)
{
  uint64_t result = *a1;
  if (*result)
  {
    std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__clear[abi:nn180100](result);
    uint64_t v3 = *(uint64_t (**)(void))(*(void *)(*a1)[3] + 40);
    return (uint64_t *)v3();
  }
  return result;
}

void std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__clear[abi:nn180100](uint64_t *a1)
{
  uint64_t v2 = *a1;
  for (uint64_t i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0) {
      operator delete(*(void **)(i - 24));
    }
  }
  a1[1] = v2;
}

uint64_t std::__split_buffer<std::string,geo::StdAllocator<std::string,grl::Allocator> &>::~__split_buffer(uint64_t a1)
{
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

{
  void **v2;
  void **v3;
  void **v5;

  uint64_t v3 = *(void ***)(a1 + 8);
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != v3)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != v3);
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

void std::__split_buffer<std::string,geo::StdAllocator<std::string,grl::Allocator> &>::__destruct_at_end[abi:nn180100](uint64_t a1, void **a2)
{
  uint64_t v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      uint64_t v5 = v2 - 3;
      *(void *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        uint64_t v5 = *(void ***)(a1 + 16);
      }
      uint64_t v2 = v5;
    }
    while (v5 != a2);
  }
}

void grl::ResourceProvider::resourceNamesOfResourceType(uint64_t a1@<X0>, unsigned int a2@<W1>, unint64_t a3@<X2>, void *a4@<X8>)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  LOWORD(v46) = a2;
  *((void *)&v46 + 1) = a3;
  unint64_t v8 = (std::mutex *)(a1 + 176);
  std::mutex::lock((std::mutex *)(a1 + 176));
  uint64_t v9 = (uint64_t **)(a1 + 240);
  uint64_t v10 = std::__tree<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::__map_value_compare<grl::ResourceProvider::ResourceCacheKey,std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::less<grl::ResourceProvider::ResourceCacheKey>,true>,std::allocator<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>>>::find<grl::ResourceProvider::ResourceCacheKey>(a1 + 240, (unsigned __int8 *)&v46);
  if (a1 + 248 != v10)
  {
    uint64_t v11 = *(void *)(v10 + 56);
    *a4 = *(void *)(v10 + 48);
    a4[1] = v11;
    if (v11) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
    }
    std::mutex::unlock(v8);
    return;
  }
  std::mutex::unlock(v8);
  long long v43 = 0uLL;
  uint64_t v44 = 0;
  uint64_t v45 = grl::Allocator::instance(v12);
  (*(void (**)(uint64_t **__return_ptr, uint64_t, unint64_t))(*(void *)a1 + 24))(&v41, a1, a3);
  if (!v41)
  {
    float v24 = (grl::Allocator *)operator new(0x38uLL);
    *((void *)v24 + 3) = 0;
    *((void *)v24 + 1) = 0;
    *((void *)v24 + 2) = 0;
    *(void *)float v24 = &unk_1EF57F6F0;
    *((void *)v24 + 4) = 0;
    *((void *)v24 + 5) = 0;
    *((void *)v24 + 6) = grl::Allocator::instance(v24);
    *a4 = (char *)v24 + 24;
    a4[1] = v24;
    goto LABEL_30;
  }
  char v13 = (std::mutex *)(a1 + 112);
  std::mutex::lock(v13);
  uint64_t v14 = (std::string *)*v41;
  uint64_t v15 = (std::string *)v41[1];
  v39[0] = &v43;
  while (v14 != v15)
  {
    std::string::size_type v16 = std::string::rfind(v14, 46, 0xFFFFFFFFFFFFFFFFLL);
    if (v16 == -1) {
      goto LABEL_20;
    }
    std::string::basic_string(&v47, v14, v16 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v37);
    grl::ResourceTypeFromPackExtension((int64_t)&v47, v37);
    if (LOBYTE(v37[0])) {
      BOOL v17 = BYTE1(v37[0]) == a2;
    }
    else {
      BOOL v17 = 0;
    }
    int v18 = v17;
    if ((SHIBYTE(v47.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      if (!v18) {
        goto LABEL_20;
      }
LABEL_19:
      std::back_insert_iterator<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>>::operator=[abi:nn180100]((unint64_t **)v39, (long long *)v14);
      goto LABEL_20;
    }
    operator delete(v47.__r_.__value_.__l.__data_);
    if (v18) {
      goto LABEL_19;
    }
LABEL_20:
    ++v14;
  }
  if ((void)v43 == *((void *)&v43 + 1) && *v41 != v41[1])
  {
    if (qword_1EB34D538 != -1) {
      dispatch_once(&qword_1EB34D538, &__block_literal_global_2);
    }
    int v25 = _MergedGlobals_3;
    if (os_log_type_enabled((os_log_t)_MergedGlobals_3, OS_LOG_TYPE_ERROR))
    {
      float v26 = v39;
      grl::buildStringFromResourceNames(*v41, 0xAAAAAAAAAAAAAAABLL * ((v41[1] - *v41) >> 3), v39);
      if (v40 < 0) {
        float v26 = (void **)v39[0];
      }
      if (a2 > 3) {
        float v27 = (char *)&str_5_1;
      }
      else {
        float v27 = off_1E5AB2978[(char)a2];
      }
      char v28 = 0;
      uint64_t v29 = 0;
      char v38 = 2;
      strcpy((char *)v37, "00");
      do
      {
        char v30 = v28;
        if ((a3 >> v29))
        {
          uint64_t v31 = v29 ^ 1;
          if (v38 >= 0) {
            uint64_t v32 = v37;
          }
          else {
            uint64_t v32 = (void **)v37[0];
          }
          *((unsigned char *)v32 + v31) = 49;
        }
        char v28 = 1;
        uint64_t v29 = 1;
      }
      while ((v30 & 1) == 0);
      if (v38 >= 0) {
        unint64_t v33 = v37;
      }
      else {
        unint64_t v33 = (void **)v37[0];
      }
      grl::buildStringFromResourceNames(v43, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v43 + 1) - v43) >> 3), __p);
      if (v36 >= 0) {
        unint64_t v34 = __p;
      }
      else {
        unint64_t v34 = (void **)__p[0];
      }
      LODWORD(v47.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)v47.__r_.__value_.__r.__words + 4) = (std::string::size_type)v26;
      WORD2(v47.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v47.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v27;
      HIWORD(v47.__r_.__value_.__r.__words[2]) = 2080;
      long long v48 = v33;
      __int16 v49 = 2080;
      BOOL v50 = v34;
      _os_log_impl(&dword_1A1780000, v25, OS_LOG_TYPE_ERROR, "Resources names got filtered to empty set for resourceType:%s location:%s input:%s output:%s", (uint8_t *)&v47, 0x2Au);
      if (v36 < 0) {
        operator delete(__p[0]);
      }
      if (v38 < 0) {
        operator delete(v37[0]);
      }
      if (v40 < 0) {
        operator delete(v39[0]);
      }
    }
  }
  std::mutex::unlock(v13);
  std::mutex::lock(v8);
  uint64_t v19 = (char *)operator new(0x38uLL);
  *((void *)v19 + 1) = 0;
  *((void *)v19 + 2) = 0;
  *(void *)uint64_t v19 = &unk_1EF57F6F0;
  long long v20 = v43;
  uint64_t v21 = v45;
  *((void *)v19 + 5) = v44;
  *((void *)v19 + 6) = v21;
  v47.__r_.__value_.__l.__size_ = (std::string::size_type)v19;
  *(_OWORD *)(v19 + 24) = v20;
  long long v43 = 0uLL;
  uint64_t v44 = 0;
  v47.__r_.__value_.__r.__words[0] = (std::string::size_type)(v19 + 24);
  float v22 = std::__tree<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::__map_value_compare<grl::ResourceProvider::ResourceCacheKey,std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::less<grl::ResourceProvider::ResourceCacheKey>,true>,std::allocator<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>>>::__emplace_unique_key_args<grl::ResourceProvider::ResourceCacheKey,grl::ResourceProvider::ResourceCacheKey&,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>(v9, (unsigned __int8 *)&v46, &v46, (long long *)&v47);
  if (v47.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v47.__r_.__value_.__l.__size_);
  }
  uint64_t v23 = v22[7];
  *a4 = v22[6];
  a4[1] = v23;
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  std::mutex::unlock(v8);
LABEL_30:
  if (v42) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v42);
  }
  v47.__r_.__value_.__r.__words[0] = (std::string::size_type)&v43;
  std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100]((uint64_t **)&v47);
}

int64_t grl::ResourceTypeFromPackExtension@<X0>(int64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = 0;
  int v4 = *(char *)(a1 + 23);
  if (v4 >= 0) {
    int64_t v5 = a1;
  }
  else {
    int64_t v5 = *(void *)a1;
  }
  if (v4 >= 0) {
    int64_t v6 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    int64_t v6 = *(void *)(a1 + 8);
  }
  int64_t v7 = v5 + v6;
  while (1)
  {
    unint64_t v8 = off_1E5AB2998[v3];
    int64_t result = strlen(v8);
    if (!result) {
      break;
    }
    int64_t v10 = result;
    if (v6 >= result)
    {
      int v12 = *v8;
      int64_t v13 = v6;
      int64_t result = v5;
      do
      {
        int64_t v14 = v13 - v10;
        if (v14 == -1) {
          break;
        }
        int64_t result = (int64_t)memchr((void *)result, v12, v14 + 1);
        if (!result) {
          break;
        }
        int64_t v15 = result;
        int64_t result = memcmp((const void *)result, v8, v10);
        if (!result)
        {
          if (v15 == v7 || v15 - v5 == -1) {
            break;
          }
          goto LABEL_21;
        }
        int64_t result = v15 + 1;
        int64_t v13 = v7 - (v15 + 1);
      }
      while (v13 >= v10);
    }
    if (v3++ >= 3)
    {
      *a2 = 0;
      return result;
    }
  }
LABEL_21:
  *a2 = 1;
  a2[1] = v3;
  return result;
}

uint64_t std::__tree<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::__map_value_compare<grl::ResourceProvider::ResourceCacheKey,std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::less<grl::ResourceProvider::ResourceCacheKey>,true>,std::allocator<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>>>::find<grl::ResourceProvider::ResourceCacheKey>(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2 = a1 + 8;
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3) {
    return v2;
  }
  uint64_t v5 = a1 + 8;
  do
  {
    BOOL v6 = grl::ResourceProvider::ResourceCacheKey::operator<((unsigned __int8 *)(v3 + 32), a2);
    int64_t v7 = (uint64_t *)(v3 + 8);
    if (!v6)
    {
      int64_t v7 = (uint64_t *)v3;
      uint64_t v5 = v3;
    }
    uint64_t v3 = *v7;
  }
  while (*v7);
  if (v5 == v2 || grl::ResourceProvider::ResourceCacheKey::operator<(a2, (unsigned __int8 *)(v5 + 32))) {
    return v2;
  }
  return v5;
}

BOOL grl::ResourceProvider::ResourceCacheKey::operator<(unsigned __int8 *a1, unsigned __int8 *a2)
{
  unint64_t v2 = (a1[1]
      + (((unint64_t)*a1 - 0x61C8864680B583ABLL) >> 2)
      + (((*a1 - 0x61C8864680B583ABLL) ^ 1) << 6)
      - 0x61C8864680B583EBLL) ^ (*a1 - 0x61C8864680B583ABLL) ^ 1;
  unint64_t v3 = (a2[1]
      + (((unint64_t)*a2 - 0x61C8864680B583ABLL) >> 2)
      + (((*a2 - 0x61C8864680B583ABLL) ^ 1) << 6)
      - 0x61C8864680B583EBLL) ^ (*a2 - 0x61C8864680B583ABLL) ^ 1;
  return ((*((void *)a1 + 1) + (v2 << 6) + (v2 >> 2) - 0x61C8864680B583EBLL) ^ v2) < ((*((void *)a2 + 1)
                                                                                       + (v3 << 6)
                                                                                       + (v3 >> 2)
                                                                                       - 0x61C8864680B583EBLL) ^ v3);
}

uint64_t grl::IconModifiers::setTransitLineColor(uint64_t result, _DWORD *a2)
{
  if (!*(unsigned char *)(result + 25)) {
    *(unsigned char *)(result + 25) = 1;
  }
  *(_DWORD *)(result + 26) = *a2;
  return result;
}

std::string *std::__uninitialized_allocator_copy_impl[abi:nn180100]<geo::StdAllocator<std::string,grl::Allocator>,std::string const*,std::string const*,std::string*>(int a1, long long *a2, long long *a3, std::string *this)
{
  if (a2 != a3)
  {
    BOOL v6 = a2;
    do
    {
      if (this)
      {
        if (*((char *)v6 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)v6, *((void *)v6 + 1));
        }
        else
        {
          long long v7 = *v6;
          this->__r_.__value_.__r.__words[2] = *((void *)v6 + 2);
          *(_OWORD *)&this->__r_.__value_.__l.__data_ = v7;
        }
      }
      BOOL v6 = (long long *)((char *)v6 + 24);
      ++this;
    }
    while (v6 != a3);
  }
  return this;
}

void geo::make_unique<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>,std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const&>()
{
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    unint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

uint64_t std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__vallocate[abi:nn180100](uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL) {
    abort();
  }
  uint64_t v3 = 3 * a2;
  uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 24) + 16))(*(void *)(a1 + 24), 24 * a2, 8);
  *(void *)a1 = result;
  *(void *)(a1 + 8) = result;
  *(void *)(a1 + 16) = result + 8 * v3;
  return result;
}

void **md::LabelImageKey::setDebugInfo(void **result, uint64_t a2)
{
  *((_DWORD *)result + 52) = *(_DWORD *)a2;
  if (result + 26 != (void **)a2)
  {
    uint64_t v3 = result;
    int v4 = result + 27;
    size_t v5 = *(unsigned __int8 *)(a2 + 31);
    if (*((char *)v3 + 239) < 0)
    {
      if ((v5 & 0x80u) == 0) {
        std::string::size_type v7 = (void *)(a2 + 8);
      }
      else {
        std::string::size_type v7 = *(void **)(a2 + 8);
      }
      if ((v5 & 0x80u) == 0) {
        size_t v8 = v5;
      }
      else {
        size_t v8 = *(void *)(a2 + 16);
      }
      std::string::__assign_no_alias<false>(v4, v7, v8);
    }
    else if ((v5 & 0x80) != 0)
    {
      std::string::__assign_no_alias<true>(v4, *(void **)(a2 + 8), *(void *)(a2 + 16));
    }
    else
    {
      long long v6 = *(_OWORD *)(a2 + 8);
      v4[2] = *(void **)(a2 + 24);
      *(_OWORD *)int v4 = v6;
    }
    uint64_t result = v3 + 30;
    char v9 = *(unsigned char *)(a2 + 55);
    if (*((char *)v3 + 263) < 0)
    {
      if (v9 >= 0) {
        uint64_t v11 = (void *)(a2 + 32);
      }
      else {
        uint64_t v11 = *(void **)(a2 + 32);
      }
      if (v9 >= 0) {
        size_t v12 = *(unsigned __int8 *)(a2 + 55);
      }
      else {
        size_t v12 = *(void *)(a2 + 40);
      }
      return std::string::__assign_no_alias<false>(result, v11, v12);
    }
    else if ((*(unsigned char *)(a2 + 55) & 0x80) != 0)
    {
      int64_t v13 = *(void **)(a2 + 32);
      size_t v14 = *(void *)(a2 + 40);
      return (void **)std::string::__assign_no_alias<true>(result, v13, v14);
    }
    else
    {
      long long v10 = *(_OWORD *)(a2 + 32);
      v3[32] = *(void **)(a2 + 48);
      *(_OWORD *)uint64_t result = v10;
    }
  }
  return result;
}

uint64_t grl::IconModifiers::setComponent(uint64_t result, char a2)
{
  *(unsigned char *)(result + 24) = a2;
  return result;
}

void grl::IconManager::imageForKeyValue(uint64_t a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, const grl::IconModifiers *a4@<X3>, float *a5@<X4>, _DWORD *a6@<X5>, void *a7@<X8>)
{
  v27[25] = *MEMORY[0x1E4F143B8];
  int64_t v13 = (grl::Allocator *)grl::IconManager::identifierForMapKeyValue(a1, a2, a3, 1, ceilf(*a5));
  unsigned int v14 = v13;
  if (a6) {
    *a6 = v13;
  }
  if (v13)
  {
    int64_t v15 = (int *)*((void *)a4 + 15);
    std::string::size_type v16 = (int *)*((void *)a4 + 16);
    if (v15 != v16)
    {
      unsigned int v24 = v13;
      do
      {
        int v17 = *v15;
        unsigned int v18 = grl::IconManager::identifierForMapKeyValue(a1, a2, *v15, 1, ceilf(*a5));
        if (v18)
        {
          unsigned int v19 = v18;
          long long v20 = grl::IconModifiers::IconModifiers((grl::IconModifiers *)buf, a4);
          buf[3] = 1;
          grl::Allocator::instance(v20);
          grl::IconManager::imageForIconID(a1, v19, (uint64_t)buf, (uint64_t)a5);
        }
        if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
        }
        uint64_t v21 = GEOGetGeoResourceLibIconManagerLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = a2;
          LOWORD(v27[0]) = 1024;
          *(_DWORD *)((char *)v27 + 2) = v17;
          _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_ERROR, "Failed to find Icon ID for key: %i - value: %i", buf, 0xEu);
        }
        if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
        }
        float v22 = GEOGetGeoResourceLibIconManagerLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = a2;
          LOWORD(v27[0]) = 1024;
          *(_DWORD *)((char *)v27 + 2) = v17;
          _os_log_impl(&dword_1A1780000, v22, OS_LOG_TYPE_ERROR, "Failed to find clustercolor for key: %i - value: %i", buf, 0xEu);
        }
        ++v15;
      }
      while (v15 != v16);
      int64_t v13 = 0;
      unsigned int v14 = v24;
    }
    v27[0] = 0;
    v27[1] = grl::Allocator::instance(v13);
    void v27[2] = 0;
    *(void *)float buf = v27;
    grl::IconManager::imageForIconID(a1, v14, (uint64_t)a4, (uint64_t)a5);
  }
  if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
    dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
  }
  uint64_t v23 = GEOGetGeoResourceLibIconManagerLog::log;
  if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float buf = 67109376;
    *(_DWORD *)&uint8_t buf[4] = a2;
    LOWORD(v27[0]) = 1024;
    *(_DWORD *)((char *)v27 + 2) = a3;
    _os_log_impl(&dword_1A1780000, v23, OS_LOG_TYPE_ERROR, "Failed to find Icon ID for key: %i - value: %i", buf, 0xEu);
  }
  *a7 = 0;
  a7[1] = 0;
}

void grl::codec::IconData::imageWithPack(grl::Allocator *a1, grl::codec::IconDataPack **a2, float a3)
{
  char v15[4] = *MEMORY[0x1E4F143B8];
  v12[0] = 0;
  v12[1] = grl::Allocator::instance(a1);
  v12[2] = 0;
  uint64_t v11 = v12;
  long long v6 = *(void **)a1;
  if (*(grl::Allocator **)a1 != (grl::Allocator *)((char *)a1 + 8))
  {
    do
    {
      grl::codec::IconDataPack::imageForID(*a2, *((_DWORD *)v6 + 8), (uint64_t)&v14);
      int64_t v13 = (_WORD *)v6 + 14;
      std::string::size_type v7 = std::__tree<std::__value_type<unsigned short,grl::ImageData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageData>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::ImageData>,grl::Allocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(&v11, (unsigned __int16 *)v6 + 14, (uint64_t)&std::piecewise_construct, &v13);
      v7[5] = v14;
      std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::operator=[abi:nn180100](v7 + 6, (uint64_t)v15);
      std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](v15);
      size_t v8 = (void *)v6[1];
      if (v8)
      {
        do
        {
          char v9 = v8;
          size_t v8 = (void *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          char v9 = (void *)v6[2];
          BOOL v10 = *v9 == (void)v6;
          long long v6 = v9;
        }
        while (!v10);
      }
      long long v6 = v9;
    }
    while (v9 != (void *)((char *)a1 + 8));
  }
  grl::codec::IconData::imageWithImageData(a3);
}

uint64_t std::__tree<std::__value_type<unsigned short,grl::ImageData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageData>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::ImageData>,grl::Allocator>>::destroy(uint64_t result, void *a2)
{
  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<unsigned short,grl::ImageData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageData>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::ImageData>,grl::Allocator>>::destroy(result, *a2);
    std::__tree<std::__value_type<unsigned short,grl::ImageData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageData>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::ImageData>,grl::Allocator>>::destroy(v3, a2[1]);
    int v4 = (void *)a2[9];
    if (v4 == a2 + 6)
    {
      (*(void (**)(void *))(a2[6] + 32))(a2 + 6);
    }
    else if (v4)
    {
      (*(void (**)(void *))(*v4 + 40))(v4);
    }
    size_t v5 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v5();
  }
  return result;
}

{
  uint64_t v3;
  uint64_t (*v4)(void);
  uint64_t vars8;

  if (a2)
  {
    uint64_t v3 = result;
    std::__tree<std::__value_type<unsigned short,grl::ImageData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageData>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::ImageData>,grl::Allocator>>::destroy(result, *a2);
    std::__tree<std::__value_type<unsigned short,grl::ImageData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageData>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::ImageData>,grl::Allocator>>::destroy(v3, a2[1]);
    std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::~__value_func[abi:nn180100](a2 + 6);
    int v4 = *(uint64_t (**)(void))(**(void **)(v3 + 16) + 40);
    return v4();
  }
  return result;
}

uint64_t **std::__tree<std::__value_type<unsigned short,grl::ImageData>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::ImageData>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::ImageData>,grl::Allocator>>::__emplace_unique_key_args<unsigned short,std::piecewise_construct_t const&,std::tuple<unsigned short const&>,std::tuple<>>(uint64_t **a1, unsigned __int16 *a2, uint64_t a3, _WORD **a4)
{
  std::string::size_type v7 = a1 + 1;
  long long v6 = a1[1];
  if (v6)
  {
    unsigned int v8 = *a2;
    while (1)
    {
      while (1)
      {
        char v9 = (uint64_t **)v6;
        unsigned int v10 = *((unsigned __int16 *)v6 + 16);
        if (v8 >= v10) {
          break;
        }
        long long v6 = *v9;
        std::string::size_type v7 = v9;
        if (!*v9) {
          goto LABEL_10;
        }
      }
      if (v10 >= v8) {
        break;
      }
      long long v6 = v9[1];
      if (!v6)
      {
        std::string::size_type v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    char v9 = a1 + 1;
LABEL_10:
    uint64_t v11 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*a1[2] + 16))(a1[2], 80, 8);
    *(_WORD *)(v11 + 32) = **a4;
    *(_OWORD *)(v11 + 40) = 0u;
    *(_OWORD *)(v11 + 56) = 0u;
    *(void *)(v11 + 72) = 0;
    std::__tree<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::__map_value_compare<unsigned short,std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,std::less<unsigned short>,true>,geo::StdAllocator<std::__value_type<unsigned short,grl::codec::ResourcePack::ChapterInfo>,grl::Allocator>>::__insert_node_at(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void *std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::operator=[abi:nn180100](void *a1, uint64_t a2)
{
  std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::operator=[abi:nn180100](a1);
  uint64_t v4 = *(void *)(a2 + 24);
  if (v4)
  {
    if (v4 == a2)
    {
      a1[3] = a1;
      (*(void (**)(void, void *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1);
    }
    else
    {
      a1[3] = v4;
      *(void *)(a2 + 24) = 0;
    }
  }
  else
  {
    a1[3] = 0;
  }
  return a1;
}

void *std::__function::__value_func<std::shared_ptr<esl::QuartzImage> ()(void)>::operator=[abi:nn180100](void *a1)
{
  unint64_t v2 = (void *)a1[3];
  a1[3] = 0;
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
  }
  else if (v2)
  {
    (*(void (**)(void *))(*v2 + 40))(v2);
  }
  return a1;
}

void grl::codec::IconData::imageWithImageData(float a1)
{
  float v1 = a1;
  geo::make_unique<grl::IconRenderer,grl::codec::IconData const&,float &,grl::IconModifiers const&,std::map<unsigned short,grl::ImageData,std::less<unsigned short>,geo::StdAllocator<std::pair<unsigned short const,grl::ImageData>,grl::Allocator>> const&,std::map<std::string,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>,std::less<std::string>,geo::StdAllocator<std::pair<std::string const,geo::_retain_ptr<__CTFont const*,geo::_retain_cf<__CTFont const*>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>>,grl::Allocator>> const&>();
}

uint64_t *grl::IconImage::IconImage(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a2;
  *a2 = 0;
  *a1 = v5;
  a1[13] = 0;
  long long v6 = a1 + 13;
  *(_OWORD *)(a1 + 1) = 0u;
  *(_OWORD *)(a1 + 3) = 0u;
  *(_OWORD *)(a1 + 5) = 0u;
  *(_OWORD *)(a1 + 7) = 0u;
  *(_OWORD *)(a1 + 9) = 0u;
  a1[11] = 0;
  a1[14] = grl::Allocator::instance((grl::Allocator *)a1);
  a1[15] = 0;
  *((_DWORD *)a1 + 32) = 0;
  *((unsigned char *)a1 + 132) = 0;
  a1[12] = (uint64_t)v6;
  *((unsigned char *)a1 + 136) = 0;
  *((unsigned char *)a1 + 138) = 0;
  *((unsigned char *)a1 + 143) = 0;
  *((unsigned char *)a1 + 148) = 0;
  *((unsigned char *)a1 + 153) = 0;
  *((unsigned char *)a1 + 158) = 0;
  *((unsigned char *)a1 + 163) = 0;
  *((unsigned char *)a1 + 168) = 0;
  *((unsigned char *)a1 + 173) = 0;
  *((unsigned char *)a1 + 178) = 0;
  *((unsigned char *)a1 + 183) = 0;
  a1[26] = 850045863;
  *(_OWORD *)(a1 + 27) = 0u;
  *(_OWORD *)(a1 + 29) = 0u;
  *(_OWORD *)(a1 + 31) = 0u;
  a1[33] = 0;
  if (*a1)
  {
    grl::IconMetrics::operator=((uint64_t)(a1 + 3), *a1 + 120);
    uint64_t v7 = *a1;
    if (!*(unsigned char *)(*a1 + 72))
    {
LABEL_28:
      if (grl::IconRenderer::hasPathLayers((grl::IconRenderer *)v7))
      {
        uint64_t LayerRenderer = grl::IconRenderer::findLayerRenderer(*a1, 1, 0);
        if (*(_WORD *)(LayerRenderer + 8) == 1) {
          uint64_t v18 = LayerRenderer + 16;
        }
        else {
          uint64_t v18 = 0;
        }
        int v19 = *((unsigned __int8 *)a1 + 153);
        *(_DWORD *)((char *)a1 + 154) = *(_DWORD *)(v18 + 44);
        if (!v19) {
          *((unsigned char *)a1 + 153) = 1;
        }
        uint64_t v20 = grl::IconRenderer::findLayerRenderer(*a1, 1, 0);
        if (*(_WORD *)(v20 + 8) == 1) {
          uint64_t v21 = v20 + 16;
        }
        else {
          uint64_t v21 = 0;
        }
        int v22 = *((unsigned __int8 *)a1 + 163);
        *((_DWORD *)a1 + 41) = *(_DWORD *)(v21 + 85);
        if (!v22) {
          *((unsigned char *)a1 + 163) = 1;
        }
        uint64_t v23 = grl::IconRenderer::findLayerRenderer(*a1, 1, 0);
        if (*(_WORD *)(v23 + 8) == 1) {
          uint64_t v24 = v23 + 16;
        }
        else {
          uint64_t v24 = 0;
        }
        char v25 = *(unsigned char *)(v24 + 120);
        if (!*((unsigned char *)a1 + 183)) {
          *((unsigned char *)a1 + 183) = 1;
        }
        *((unsigned char *)a1 + 184) = v25;
        uint64_t v26 = grl::IconRenderer::findLayerRenderer(*a1, 1, 0);
        if (*(_WORD *)(v26 + 8) == 1) {
          uint64_t v27 = v26 + 16;
        }
        else {
          uint64_t v27 = 0;
        }
        int v28 = *((unsigned __int8 *)a1 + 173);
        *(_DWORD *)((char *)a1 + 174) = *(_DWORD *)(v27 + 104);
        if (!v28) {
          *((unsigned char *)a1 + 173) = 1;
        }
      }
      if (grl::IconRenderer::hasImageLayers((grl::IconRenderer *)*a1))
      {
        uint64_t v29 = grl::IconRenderer::findLayerRenderer(*a1, 2, 0);
        uint64_t v30 = *(_WORD *)(v29 + 8) == 2 ? v29 + 16 : 0;
        int v31 = *((unsigned __int8 *)a1 + 158);
        *(_DWORD *)((char *)a1 + 159) = *(_DWORD *)(v30 + 34);
        if (!v31) {
          *((unsigned char *)a1 + 158) = 1;
        }
      }
      *((_DWORD *)a1 + 48) = *(_DWORD *)(a3 + 8);
      *((_DWORD *)a1 + 47) = *(_DWORD *)(*a1 + 260);
      *(uint64_t *)((char *)a1 + 196) = a1[7];
      if (*(unsigned char *)(a3 + 3)) {
        std::unique_ptr<grl::IconRenderer>::reset[abi:nn180100]((grl::IconRenderer **)a1, 0);
      }
      return a1;
    }
    int v8 = *((unsigned __int8 *)a1 + 138);
    *(_DWORD *)((char *)a1 + 139) = *(_DWORD *)(v7 + 84);
    if (!v8) {
      *((unsigned char *)a1 + 138) = 1;
    }
    if (*(unsigned char *)(v7 + 112))
    {
      int v9 = *((unsigned __int8 *)a1 + 143);
      *((_DWORD *)a1 + 36) = *(_DWORD *)(v7 + 88);
      if (v9) {
        goto LABEL_15;
      }
      char v10 = 1;
    }
    else
    {
      if (!*((unsigned char *)a1 + 143)) {
        goto LABEL_15;
      }
      char v10 = 0;
    }
    *((unsigned char *)a1 + 143) = v10;
LABEL_15:
    if (*(unsigned char *)(v7 + 113))
    {
      int v12 = *((unsigned __int8 *)a1 + 148);
      *(_DWORD *)((char *)a1 + 149) = *(_DWORD *)(v7 + 93);
      if (!v12)
      {
        char v13 = 1;
LABEL_20:
        *((unsigned char *)a1 + 148) = v13;
      }
    }
    else if (*((unsigned char *)a1 + 148))
    {
      char v13 = 0;
      goto LABEL_20;
    }
    char v14 = *(unsigned char *)(v7 + 92);
    if (!*((unsigned char *)a1 + 136)) {
      *((unsigned char *)a1 + 136) = 1;
    }
    *((unsigned char *)a1 + 137) = v14;
    int v15 = *(_DWORD *)(v7 + 101);
    if (!*((unsigned char *)a1 + 168)) {
      *((unsigned char *)a1 + 168) = 1;
    }
    *(_DWORD *)((char *)a1 + 169) = v15;
    int v16 = *(_DWORD *)(v7 + 97);
    if (!*((unsigned char *)a1 + 178)) {
      *((unsigned char *)a1 + 178) = 1;
    }
    *(_DWORD *)((char *)a1 + 179) = v16;
    goto LABEL_28;
  }
  if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
    dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
  }
  uint64_t v11 = GEOGetGeoResourceLibRendererLog::log;
  if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
  {
    int v33 = 136315650;
    unint64_t v34 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    __int16 v35 = 2080;
    char v36 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/IconImage.cpp";
    __int16 v37 = 1024;
    int v38 = 19;
    _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_ERROR, "grl::IconImage should never be passed a nullptr grl::IconRenderer.: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v33, 0x1Cu);
  }
  return a1;
}

BOOL grl::IconRenderer::hasPathLayers(grl::IconRenderer *this)
{
  float v1 = (char *)*((void *)this + 4);
  unint64_t v2 = (char *)this + 40;
  if (v1 == (char *)this + 40) {
    return 0;
  }
  do
  {
    int v3 = *((unsigned __int16 *)v1 + 16);
    BOOL result = v3 == 1;
    if (v3 == 1) {
      break;
    }
    uint64_t v5 = (char *)*((void *)v1 + 1);
    if (v5)
    {
      do
      {
        long long v6 = v5;
        uint64_t v5 = *(char **)v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        long long v6 = (char *)*((void *)v1 + 2);
        BOOL v7 = *(void *)v6 == (void)v1;
        float v1 = v6;
      }
      while (!v7);
    }
    float v1 = v6;
  }
  while (v6 != v2);
  return result;
}

BOOL grl::IconRenderer::hasImageLayers(grl::IconRenderer *this)
{
  float v1 = (char *)*((void *)this + 4);
  unint64_t v2 = (char *)this + 40;
  if (v1 == (char *)this + 40) {
    return 0;
  }
  do
  {
    int v3 = *((unsigned __int16 *)v1 + 16);
    BOOL result = v3 == 2;
    if (v3 == 2) {
      break;
    }
    uint64_t v5 = (char *)*((void *)v1 + 1);
    if (v5)
    {
      do
      {
        long long v6 = v5;
        uint64_t v5 = *(char **)v5;
      }
      while (v5);
    }
    else
    {
      do
      {
        long long v6 = (char *)*((void *)v1 + 2);
        BOOL v7 = *(void *)v6 == (void)v1;
        float v1 = v6;
      }
      while (!v7);
    }
    float v1 = v6;
  }
  while (v6 != v2);
  return result;
}

uint64_t grl::IconManager::identifierForMapKeyValue(uint64_t a1, unsigned int a2, int a3, int a4, float a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  unsigned int v20 = a2;
  float v9 = ceilf(a5);
  std::string::basic_string[abi:nn180100]<0>(__p, "Default");
  float v19 = v9;
  grl::IconManager::retrieveResourcePack(buf, a1, (float *)__p, 2);
  uint64_t v11 = *(void *)buf;
  char v10 = v22;
  if (v22)
  {
    atomic_fetch_add_explicit(&v22->__shared_owners_, 1uLL, memory_order_relaxed);
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  if (!v11) {
    grl::IconManager::loadGlobalResourcePack((uint64_t)buf, a1);
  }
  *(_DWORD *)float buf = a2;
  *(_DWORD *)&uint8_t buf[4] = a3;
  int v12 = std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::StdAllocator<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::Allocator>>::find<grl::codec::IconMapKeyValue>((void *)(v11 + 40), (unsigned int *)buf);
  if (v12)
  {
    uint64_t v13 = *((unsigned int *)v12 + 6);
    if (!a4)
    {
LABEL_13:
      if (v13) {
        goto LABEL_19;
      }
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v13 = 0;
    if (!a4) {
      goto LABEL_13;
    }
  }
  if (v13) {
    goto LABEL_13;
  }
  char v14 = std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,geo::StdAllocator<std::__hash_value_type<unsigned int,unsigned int>,grl::Allocator>>::find<unsigned int>((void *)(v11 + 392), &v20);
  if (v14)
  {
    uint64_t v13 = *((unsigned int *)v14 + 5);
    goto LABEL_13;
  }
LABEL_14:
  if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
    dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
  }
  int v15 = GEOGetGeoResourceLibIconManagerLog::log;
  if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float buf = 67109632;
    *(_DWORD *)&uint8_t buf[4] = v20;
    LOWORD(v22) = 1024;
    *(_DWORD *)((char *)&v22 + 2) = a3;
    HIWORD(v22) = 2048;
    double v23 = v9;
    _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_ERROR, "Failed to find ID for Map Value\nKey: %i - Value: %i - Content Scale: %f", buf, 0x18u);
  }
  uint64_t v13 = 0;
LABEL_19:
  if (v10) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v10);
  }
  if (v18 < 0) {
    operator delete(__p[0]);
  }
  return v13;
}

uint64_t *std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::StdAllocator<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::Allocator>>::find<grl::codec::IconMapKeyValue>(void *a1, unsigned int *a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  unint64_t v5 = (v4
      + ((v3 - 0x61C8864680B583EBLL) << 6)
      + ((unint64_t)(v3 - 0x61C8864680B583EBLL) >> 2)
      - 0x61C8864680B583EBLL) ^ (v3 - 0x61C8864680B583EBLL);
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = (v4
        + ((v3 - 0x61C8864680B583EBLL) << 6)
        + ((unint64_t)(v3 - 0x61C8864680B583EBLL) >> 2)
        - 0x61C8864680B583EBLL) ^ (v3 - 0x61C8864680B583EBLL);
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = v5 & (*(void *)&v2 - 1);
  }
  int v8 = *(uint64_t ***)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  for (BOOL result = *v8; result; BOOL result = (uint64_t *)*result)
  {
    unint64_t v10 = result[1];
    if (v5 == v10)
    {
      if (*((_DWORD *)result + 4) == v3 && *((_DWORD *)result + 5) == v4) {
        return result;
      }
    }
    else
    {
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(void *)&v2) {
          v10 %= *(void *)&v2;
        }
      }
      else
      {
        v10 &= *(void *)&v2 - 1;
      }
      if (v10 != v7) {
        return 0;
      }
    }
  }
  return result;
}

unint64_t **std::back_insert_iterator<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>>::operator=[abi:nn180100](unint64_t **a1, long long *a2)
{
  uint64_t v4 = *a1;
  unint64_t v6 = (*a1)[1];
  unint64_t v5 = (*a1)[2];
  if (v6 >= v5)
  {
    unint64_t v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v6 - *v4) >> 3);
    if (v8 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v9 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *v4) >> 3);
    uint64_t v10 = 2 * v9;
    if (2 * v9 <= v8 + 1) {
      uint64_t v10 = v8 + 1;
    }
    if (v9 >= 0x555555555555555) {
      uint64_t v11 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      uint64_t v11 = v10;
    }
    v23[4] = v4 + 3;
    if (v11)
    {
      uint64_t v12 = (*(uint64_t (**)(unint64_t, uint64_t, uint64_t))(*(void *)v4[3] + 16))(v4[3], 24 * v11, 8);
      unint64_t v13 = v12 + 24 * v8;
      if (v12)
      {
        if (*((char *)a2 + 23) < 0)
        {
          std::string::__init_copy_ctor_external((std::string *)v13, *(const std::string::value_type **)a2, *((void *)a2 + 1));
        }
        else
        {
          long long v14 = *a2;
          *(void *)(v13 + 16) = *((void *)a2 + 2);
          *(_OWORD *)unint64_t v13 = v14;
        }
      }
    }
    else
    {
      uint64_t v12 = 0;
      unint64_t v13 = 24 * v8;
    }
    unint64_t v17 = *v4;
    unint64_t v16 = v4[1];
    if (v16 == *v4)
    {
      unint64_t v20 = v4[1];
      unint64_t v18 = v13;
    }
    else
    {
      unint64_t v18 = v13;
      do
      {
        long long v19 = *(_OWORD *)(v16 - 24);
        *(void *)(v18 - 8) = *(void *)(v16 - 8);
        *(_OWORD *)(v18 - 24) = v19;
        v18 -= 24;
        *(void *)(v16 - 16) = 0;
        *(void *)(v16 - 8) = 0;
        *(void *)(v16 - 24) = 0;
        v16 -= 24;
      }
      while (v16 != v17);
      unint64_t v20 = *v4;
      unint64_t v16 = v4[1];
    }
    int v15 = (std::string *)(v13 + 24);
    *uint64_t v4 = v18;
    v23[0] = v20;
    v23[1] = v20;
    v4[1] = (unint64_t)v15;
    v23[2] = v16;
    unint64_t v21 = v4[2];
    v4[2] = v12 + 24 * v11;
    v23[3] = v21;
    std::__split_buffer<std::string,geo::StdAllocator<std::string,grl::Allocator> &>::~__split_buffer((uint64_t)v23);
  }
  else
  {
    if (v6)
    {
      if (*((char *)a2 + 23) < 0)
      {
        std::string::__init_copy_ctor_external((std::string *)(*a1)[1], *(const std::string::value_type **)a2, *((void *)a2 + 1));
      }
      else
      {
        long long v7 = *a2;
        *(void *)(v6 + 16) = *((void *)a2 + 2);
        *(_OWORD *)unint64_t v6 = v7;
      }
    }
    int v15 = (std::string *)(v6 + 24);
  }
  v4[1] = (unint64_t)v15;
  return a1;
}

uint64_t std::__function::__func<ecs2::ForwardToExecute<md::erq::EncodeRenderQueue>,std::allocator<ecs2::ForwardToExecute<md::erq::EncodeRenderQueue>>,void ()(ecs2::Runtime &)>::__clone(uint64_t result, void *a2)
{
  *a2 = &unk_1EF51A120;
  a2[1] = *(void *)(result + 8);
  return result;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#1},std::allocator<md::erq::EncodeRenderQueue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::erq::EncodeRenderQueue>(md::erq::EncodeRenderQueue &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526E28;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ReserveStencilRangeTask>(md::ita::ReserveStencilRangeTask &&)::{lambda(void)#1},std::allocator<md::ita::ReserveStencilRangeTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ReserveStencilRangeTask>(md::ita::ReserveStencilRangeTask &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528FE8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ReserveStencilRangeTask>(md::ita::ReserveStencilRangeTask &&)::{lambda(void)#2},std::allocator<md::ita::ReserveStencilRangeTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ReserveStencilRangeTask>(md::ita::ReserveStencilRangeTask &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528FA0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutStartTask>(md::ita::LegacyLayoutStartTask &&)::{lambda(void)#1},std::allocator<md::ita::LegacyLayoutStartTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutStartTask>(md::ita::LegacyLayoutStartTask &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5284A8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutStartTask>(md::ita::LegacyLayoutStartTask &&)::{lambda(void)#2},std::allocator<md::ita::LegacyLayoutStartTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutStartTask>(md::ita::LegacyLayoutStartTask &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528460;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutTask>(md::ita::LegacyLayoutTask &&)::{lambda(void)#1},std::allocator<md::ita::LegacyLayoutTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutTask>(md::ita::LegacyLayoutTask &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527338;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutTask>(md::ita::LegacyLayoutTask &&)::{lambda(void)#2},std::allocator<md::ita::LegacyLayoutTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::LegacyLayoutTask>(md::ita::LegacyLayoutTask &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5272F0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::OnLayoutEndTask>(md::ita::OnLayoutEndTask &&)::{lambda(void)#1},std::allocator<md::ita::OnLayoutEndTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::OnLayoutEndTask>(md::ita::OnLayoutEndTask &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5270F8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::OnLayoutEndTask>(md::ita::OnLayoutEndTask &&)::{lambda(void)#2},std::allocator<md::ita::OnLayoutEndTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::OnLayoutEndTask>(md::ita::OnLayoutEndTask &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5270B0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAODOFCommonFrameGraph>(md::ita::BuildSSAODOFCommonFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildSSAODOFCommonFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAODOFCommonFrameGraph>(md::ita::BuildSSAODOFCommonFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A788;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAODOFCommonFrameGraph>(md::ita::BuildSSAODOFCommonFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::BuildSSAODOFCommonFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAODOFCommonFrameGraph>(md::ita::BuildSSAODOFCommonFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A740;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanUpFrameGraphResources>(md::ita::CleanUpFrameGraphResources &&)::{lambda(void)#1},std::allocator<md::ita::CleanUpFrameGraphResources &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanUpFrameGraphResources>(md::ita::CleanUpFrameGraphResources &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529CD8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanUpFrameGraphResources>(md::ita::CleanUpFrameGraphResources &&)::{lambda(void)#2},std::allocator<md::ita::CleanUpFrameGraphResources &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanUpFrameGraphResources>(md::ita::CleanUpFrameGraphResources &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529C90;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::EndFrameGraphPreparation>(md::ita::EndFrameGraphPreparation &&)::{lambda(void)#1},std::allocator<md::ita::EndFrameGraphPreparation &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::EndFrameGraphPreparation>(md::ita::EndFrameGraphPreparation &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529468;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::EndFrameGraphPreparation>(md::ita::EndFrameGraphPreparation &&)::{lambda(void)#2},std::allocator<md::ita::EndFrameGraphPreparation &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::EndFrameGraphPreparation>(md::ita::EndFrameGraphPreparation &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529420;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildRouteLineFrameGraph>(md::ita::BuildRouteLineFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildRouteLineFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildRouteLineFrameGraph>(md::ita::BuildRouteLineFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5293D8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildRouteLineFrameGraph>(md::ita::BuildRouteLineFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::BuildRouteLineFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildRouteLineFrameGraph>(md::ita::BuildRouteLineFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529390;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBuildFrameGraph>(md::ita::PrepareBuildFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::PrepareBuildFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBuildFrameGraph>(md::ita::PrepareBuildFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5289B8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBuildFrameGraph>(md::ita::PrepareBuildFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::PrepareBuildFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBuildFrameGraph>(md::ita::PrepareBuildFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528970;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildPrimaryFrameGraph>(md::ita::BuildPrimaryFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildPrimaryFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildPrimaryFrameGraph>(md::ita::BuildPrimaryFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528898;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildPrimaryFrameGraph>(md::ita::BuildPrimaryFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::BuildPrimaryFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildPrimaryFrameGraph>(md::ita::BuildPrimaryFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528850;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildShadowFrameGraph>(md::ita::BuildShadowFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildShadowFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildShadowFrameGraph>(md::ita::BuildShadowFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5281D8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildShadowFrameGraph>(md::ita::BuildShadowFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::BuildShadowFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildShadowFrameGraph>(md::ita::BuildShadowFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528190;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAOFrameGraph>(md::ita::BuildSSAOFrameGraph &&)::{lambda(void)#1},std::allocator<md::ita::BuildSSAOFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAOFrameGraph>(md::ita::BuildSSAOFrameGraph &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527BA8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAOFrameGraph>(md::ita::BuildSSAOFrameGraph &&)::{lambda(void)#2},std::allocator<md::ita::BuildSSAOFrameGraph &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::BuildSSAOFrameGraph>(md::ita::BuildSSAOFrameGraph &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527B60;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#1},std::allocator<PrepareFrameForRender &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526D08;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#2},std::allocator<PrepareFrameForRender &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForRender>(PrepareFrameForRender &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526CC0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#1},std::allocator<PrepareFrameForEncode &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526C78;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#2},std::allocator<PrepareFrameForEncode &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<PrepareFrameForEncode>(PrepareFrameForEncode &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526C30;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#1},std::allocator<CleanupEntities &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526BE8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#2},std::allocator<CleanupEntities &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupEntities>(CleanupEntities &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526BA0;
}

void grl::IconManager::imageForName(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, float *a4@<X3>, _DWORD *a5@<X4>, void *a6@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = (grl::Allocator *)grl::IconManager::identifierForName(a1, a2, ceilf(*a4));
  unsigned int v13 = v12;
  if (a5) {
    *a5 = v12;
  }
  if (v12)
  {
    *((void *)&v16 + 1) = 0;
    uint64_t v17 = grl::Allocator::instance(v12);
    uint64_t v18 = 0;
    *(void *)&long long v16 = (char *)&v16 + 8;
    grl::IconManager::imageForIconID(a1, v13, a3, (uint64_t)a4);
  }
  if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
    dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
  }
  long long v14 = GEOGetGeoResourceLibIconManagerLog::log;
  if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
  {
    if (*(char *)(a2 + 23) >= 0) {
      uint64_t v15 = a2;
    }
    else {
      uint64_t v15 = *(void *)a2;
    }
    LODWORD(v16) = 136315138;
    *(void *)((char *)&v16 + 4) = v15;
    _os_log_impl(&dword_1A1780000, v14, OS_LOG_TYPE_ERROR, "Failed to find Icon ID for name: %s", (uint8_t *)&v16, 0xCu);
  }
  *a6 = 0;
  a6[1] = 0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DE18;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorEmissiveTextureEnabled &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DDD0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSpecularContribution>(md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSpecularContribution>(md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DD88;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSpecularContribution>(md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSpecularContribution>(md::ita::PrepareFunctionConstantDescriptorSpecularContribution &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DD40;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth>(md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth>(md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DCF8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth>(md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth>(md::ita::PrepareFunctionConstantDescriptorOutputLinearDepth &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DCB0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled>(md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled>(md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DC68;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled>(md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled>(md::ita::PrepareFunctionConstantDescriptorEmmisiveEnabled &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DC20;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorColorCorrection>(md::ita::PrepareFunctionConstantDescriptorColorCorrection &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorColorCorrection &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorColorCorrection>(md::ita::PrepareFunctionConstantDescriptorColorCorrection &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DBD8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorColorCorrection>(md::ita::PrepareFunctionConstantDescriptorColorCorrection &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorColorCorrection &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorColorCorrection>(md::ita::PrepareFunctionConstantDescriptorColorCorrection &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DB90;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias>(md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias>(md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DB48;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias>(md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorUseCameraZBias>(md::ita::PrepareFunctionConstantDescriptorUseCameraZBias &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DB00;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DAB8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTextureEnabled>(md::ita::PrepareFunctionConstantDescriptorTextureEnabled &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DA70;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPreserveHeight>(md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPreserveHeight>(md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52DA28;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPreserveHeight>(md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPreserveHeight>(md::ita::PrepareFunctionConstantDescriptorPreserveHeight &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D9E0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix>(md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix>(md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D998;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix>(md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorIdentityMatrix>(md::ita::PrepareFunctionConstantDescriptorIdentityMatrix &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D950;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>(md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>(md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D908;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>(md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>(md::ita::PrepareFunctionConstantDescriptorRoutelineMask &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D8C0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPositionScale>(md::ita::PrepareFunctionConstantDescriptorPositionScale &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorPositionScale &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPositionScale>(md::ita::PrepareFunctionConstantDescriptorPositionScale &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D878;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPositionScale>(md::ita::PrepareFunctionConstantDescriptorPositionScale &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorPositionScale &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPositionScale>(md::ita::PrepareFunctionConstantDescriptorPositionScale &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D830;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorDualElevation>(md::ita::PrepareFunctionConstantDescriptorDualElevation &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorDualElevation &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorDualElevation>(md::ita::PrepareFunctionConstantDescriptorDualElevation &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D7E8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorDualElevation>(md::ita::PrepareFunctionConstantDescriptorDualElevation &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorDualElevation &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorDualElevation>(md::ita::PrepareFunctionConstantDescriptorDualElevation &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D7A0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTileClipping>(md::ita::PrepareFunctionConstantDescriptorTileClipping &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorTileClipping &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTileClipping>(md::ita::PrepareFunctionConstantDescriptorTileClipping &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D758;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTileClipping>(md::ita::PrepareFunctionConstantDescriptorTileClipping &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorTileClipping &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorTileClipping>(md::ita::PrepareFunctionConstantDescriptorTileClipping &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D710;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorBlendedWater>(md::ita::PrepareFunctionConstantDescriptorBlendedWater &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorBlendedWater &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorBlendedWater>(md::ita::PrepareFunctionConstantDescriptorBlendedWater &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D6C8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorBlendedWater>(md::ita::PrepareFunctionConstantDescriptorBlendedWater &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorBlendedWater &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorBlendedWater>(md::ita::PrepareFunctionConstantDescriptorBlendedWater &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D680;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorClimateTint>(md::ita::PrepareFunctionConstantDescriptorClimateTint &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorClimateTint &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorClimateTint>(md::ita::PrepareFunctionConstantDescriptorClimateTint &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D638;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorClimateTint>(md::ita::PrepareFunctionConstantDescriptorClimateTint &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorClimateTint &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorClimateTint>(md::ita::PrepareFunctionConstantDescriptorClimateTint &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D5F0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareGradientParametersConstantDataHandle>(md::ita::PrepareGradientParametersConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareGradientParametersConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareGradientParametersConstantDataHandle>(md::ita::PrepareGradientParametersConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D5A8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareGradientParametersConstantDataHandle>(md::ita::PrepareGradientParametersConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareGradientParametersConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareGradientParametersConstantDataHandle>(md::ita::PrepareGradientParametersConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D560;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLightDebug>(md::ita::PrepareFunctionConstantDescriptorLightDebug &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorLightDebug &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLightDebug>(md::ita::PrepareFunctionConstantDescriptorLightDebug &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D518;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLightDebug>(md::ita::PrepareFunctionConstantDescriptorLightDebug &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorLightDebug &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLightDebug>(md::ita::PrepareFunctionConstantDescriptorLightDebug &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D4D0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorGlobeLight>(md::ita::PrepareFunctionConstantDescriptorGlobeLight &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorGlobeLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorGlobeLight>(md::ita::PrepareFunctionConstantDescriptorGlobeLight &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D488;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorGlobeLight>(md::ita::PrepareFunctionConstantDescriptorGlobeLight &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorGlobeLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorGlobeLight>(md::ita::PrepareFunctionConstantDescriptorGlobeLight &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D440;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverS2TransformConstantDataHandle>(md::ita::PrepareFlyoverS2TransformConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFlyoverS2TransformConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverS2TransformConstantDataHandle>(md::ita::PrepareFlyoverS2TransformConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D3F8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverS2TransformConstantDataHandle>(md::ita::PrepareFlyoverS2TransformConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFlyoverS2TransformConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverS2TransformConstantDataHandle>(md::ita::PrepareFlyoverS2TransformConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D3B0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareColorCorrectionFactorsConstantHandle>(md::ita::PrepareColorCorrectionFactorsConstantHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareColorCorrectionFactorsConstantHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareColorCorrectionFactorsConstantHandle>(md::ita::PrepareColorCorrectionFactorsConstantHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D368;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareColorCorrectionFactorsConstantHandle>(md::ita::PrepareColorCorrectionFactorsConstantHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareColorCorrectionFactorsConstantHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareColorCorrectionFactorsConstantHandle>(md::ita::PrepareColorCorrectionFactorsConstantHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D320;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLandCover>(md::ita::PrepareFunctionConstantDescriptorLandCover &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorLandCover &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLandCover>(md::ita::PrepareFunctionConstantDescriptorLandCover &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D2D8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLandCover>(md::ita::PrepareFunctionConstantDescriptorLandCover &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorLandCover &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorLandCover>(md::ita::PrepareFunctionConstantDescriptorLandCover &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D290;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverTransformConstantDataHandle>(md::ita::PrepareFlyoverTransformConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFlyoverTransformConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverTransformConstantDataHandle>(md::ita::PrepareFlyoverTransformConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D248;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverTransformConstantDataHandle>(md::ita::PrepareFlyoverTransformConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFlyoverTransformConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFlyoverTransformConstantDataHandle>(md::ita::PrepareFlyoverTransformConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D200;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForDepthPrePass>(md::ita::CreateTileClearRenderItemsForDepthPrePass &&)::{lambda(void)#1},std::allocator<md::ita::CreateTileClearRenderItemsForDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForDepthPrePass>(md::ita::CreateTileClearRenderItemsForDepthPrePass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D1B8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForDepthPrePass>(md::ita::CreateTileClearRenderItemsForDepthPrePass &&)::{lambda(void)#2},std::allocator<md::ita::CreateTileClearRenderItemsForDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForDepthPrePass>(md::ita::CreateTileClearRenderItemsForDepthPrePass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D170;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleGroundOcclusion>(md::ita::ProcessRenderableForStyleGroundOcclusion &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForStyleGroundOcclusion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleGroundOcclusion>(md::ita::ProcessRenderableForStyleGroundOcclusion &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D128;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleGroundOcclusion>(md::ita::ProcessRenderableForStyleGroundOcclusion &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForStyleGroundOcclusion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleGroundOcclusion>(md::ita::ProcessRenderableForStyleGroundOcclusion &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D0E0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSplined>(md::ita::PrepareFunctionConstantDescriptorSplined &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSplined>(md::ita::PrepareFunctionConstantDescriptorSplined &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D098;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSplined>(md::ita::PrepareFunctionConstantDescriptorSplined &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorSplined &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSplined>(md::ita::PrepareFunctionConstantDescriptorSplined &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D050;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorShadows>(md::ita::PrepareFunctionConstantDescriptorShadows &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorShadows>(md::ita::PrepareFunctionConstantDescriptorShadows &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52D008;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorShadows>(md::ita::PrepareFunctionConstantDescriptorShadows &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorShadows &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorShadows>(md::ita::PrepareFunctionConstantDescriptorShadows &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CFC0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOverlay>(md::ita::PrepareFunctionConstantDescriptorOverlay &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorOverlay &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOverlay>(md::ita::PrepareFunctionConstantDescriptorOverlay &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CF78;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOverlay>(md::ita::PrepareFunctionConstantDescriptorOverlay &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorOverlay &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorOverlay>(md::ita::PrepareFunctionConstantDescriptorOverlay &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CF30;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPlanar>(md::ita::PrepareFunctionConstantDescriptorPlanar &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorPlanar &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPlanar>(md::ita::PrepareFunctionConstantDescriptorPlanar &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CEE8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPlanar>(md::ita::PrepareFunctionConstantDescriptorPlanar &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorPlanar &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorPlanar>(md::ita::PrepareFunctionConstantDescriptorPlanar &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CEA0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForShadowPass>(md::ita::CreateTileClearRenderItemsForShadowPass &&)::{lambda(void)#1},std::allocator<md::ita::CreateTileClearRenderItemsForShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForShadowPass>(md::ita::CreateTileClearRenderItemsForShadowPass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CE58;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForShadowPass>(md::ita::CreateTileClearRenderItemsForShadowPass &&)::{lambda(void)#2},std::allocator<md::ita::CreateTileClearRenderItemsForShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateTileClearRenderItemsForShadowPass>(md::ita::CreateTileClearRenderItemsForShadowPass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CE10;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleRouteLineMask>(md::ita::ProcessRenderableForStyleRouteLineMask &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForStyleRouteLineMask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleRouteLineMask>(md::ita::ProcessRenderableForStyleRouteLineMask &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CDC8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleRouteLineMask>(md::ita::ProcessRenderableForStyleRouteLineMask &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForStyleRouteLineMask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForStyleRouteLineMask>(md::ita::ProcessRenderableForStyleRouteLineMask &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CD80;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMaterialStyleConstantDataHandle>(md::ita::PrepareMaterialStyleConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMaterialStyleConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMaterialStyleConstantDataHandle>(md::ita::PrepareMaterialStyleConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CD38;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMaterialStyleConstantDataHandle>(md::ita::PrepareMaterialStyleConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMaterialStyleConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMaterialStyleConstantDataHandle>(md::ita::PrepareMaterialStyleConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CCF0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorWater>(md::ita::PrepareFunctionConstantDescriptorWater &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorWater &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorWater>(md::ita::PrepareFunctionConstantDescriptorWater &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CCA8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorWater>(md::ita::PrepareFunctionConstantDescriptorWater &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorWater &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorWater>(md::ita::PrepareFunctionConstantDescriptorWater &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CC60;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleGroundOcclusionConstantData>(md::ita::AssignStyleGroundOcclusionConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleGroundOcclusionConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleGroundOcclusionConstantData>(md::ita::AssignStyleGroundOcclusionConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CC18;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleGroundOcclusionConstantData>(md::ita::AssignStyleGroundOcclusionConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleGroundOcclusionConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleGroundOcclusionConstantData>(md::ita::AssignStyleGroundOcclusionConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CBD0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderStateStencilRefValue>(md::ita::SetupCustomRenderStateStencilRefValue &&)::{lambda(void)#1},std::allocator<md::ita::SetupCustomRenderStateStencilRefValue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderStateStencilRefValue>(md::ita::SetupCustomRenderStateStencilRefValue &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CB88;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderStateStencilRefValue>(md::ita::SetupCustomRenderStateStencilRefValue &&)::{lambda(void)#2},std::allocator<md::ita::SetupCustomRenderStateStencilRefValue &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderStateStencilRefValue>(md::ita::SetupCustomRenderStateStencilRefValue &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CB40;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSSAO>(md::ita::PrepareFunctionConstantDescriptorSSAO &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorSSAO &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSSAO>(md::ita::PrepareFunctionConstantDescriptorSSAO &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CAF8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSSAO>(md::ita::PrepareFunctionConstantDescriptorSSAO &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorSSAO &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorSSAO>(md::ita::PrepareFunctionConstantDescriptorSSAO &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CAB0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorECEF>(md::ita::PrepareFunctionConstantDescriptorECEF &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorECEF>(md::ita::PrepareFunctionConstantDescriptorECEF &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CA68;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorECEF>(md::ita::PrepareFunctionConstantDescriptorECEF &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorECEF &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorECEF>(md::ita::PrepareFunctionConstantDescriptorECEF &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52CA20;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleCameraLightingConstantData>(md::ita::AssignStyleCameraLightingConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleCameraLightingConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleCameraLightingConstantData>(md::ita::AssignStyleCameraLightingConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C9D8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleCameraLightingConstantData>(md::ita::AssignStyleCameraLightingConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleCameraLightingConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleCameraLightingConstantData>(md::ita::AssignStyleCameraLightingConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C990;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightingConfigurationVertexData>(md::ita::AssignLightingConfigurationVertexData &&)::{lambda(void)#1},std::allocator<md::ita::AssignLightingConfigurationVertexData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightingConfigurationVertexData>(md::ita::AssignLightingConfigurationVertexData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C948;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightingConfigurationVertexData>(md::ita::AssignLightingConfigurationVertexData &&)::{lambda(void)#2},std::allocator<md::ita::AssignLightingConfigurationVertexData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightingConfigurationVertexData>(md::ita::AssignLightingConfigurationVertexData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C900;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForPlanarParameters>(md::ita::ProcessRenderableForPlanarParameters &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForPlanarParameters &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForPlanarParameters>(md::ita::ProcessRenderableForPlanarParameters &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C8B8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForPlanarParameters>(md::ita::ProcessRenderableForPlanarParameters &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForPlanarParameters &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForPlanarParameters>(md::ita::ProcessRenderableForPlanarParameters &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C870;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorFog>(md::ita::PrepareFunctionConstantDescriptorFog &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorFog &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorFog>(md::ita::PrepareFunctionConstantDescriptorFog &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C828;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorFog>(md::ita::PrepareFunctionConstantDescriptorFog &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorFog &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorFog>(md::ita::PrepareFunctionConstantDescriptorFog &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C7E0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialRequiresEmissiveColor>(md::ita::CheckIfMaterialRequiresEmissiveColor &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfMaterialRequiresEmissiveColor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialRequiresEmissiveColor>(md::ita::CheckIfMaterialRequiresEmissiveColor &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C798;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialRequiresEmissiveColor>(md::ita::CheckIfMaterialRequiresEmissiveColor &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfMaterialRequiresEmissiveColor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialRequiresEmissiveColor>(md::ita::CheckIfMaterialRequiresEmissiveColor &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C750;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleRouteLineMaskConstantData>(md::ita::AssignStyleRouteLineMaskConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleRouteLineMaskConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleRouteLineMaskConstantData>(md::ita::AssignStyleRouteLineMaskConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C708;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleRouteLineMaskConstantData>(md::ita::AssignStyleRouteLineMaskConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleRouteLineMaskConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleRouteLineMaskConstantData>(md::ita::AssignStyleRouteLineMaskConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C6C0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleEmissiveColorConstantData>(md::ita::AssignStyleEmissiveColorConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleEmissiveColorConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleEmissiveColorConstantData>(md::ita::AssignStyleEmissiveColorConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C678;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleEmissiveColorConstantData>(md::ita::AssignStyleEmissiveColorConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleEmissiveColorConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleEmissiveColorConstantData>(md::ita::AssignStyleEmissiveColorConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C630;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradientParametersConstantData>(md::ita::AssignGradientParametersConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignGradientParametersConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradientParametersConstantData>(md::ita::AssignGradientParametersConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C5E8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradientParametersConstantData>(md::ita::AssignGradientParametersConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignGradientParametersConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradientParametersConstantData>(md::ita::AssignGradientParametersConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C5A0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverS2TransformConstantData>(md::ita::AssignFlyoverS2TransformConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverS2TransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverS2TransformConstantData>(md::ita::AssignFlyoverS2TransformConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C558;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverS2TransformConstantData>(md::ita::AssignFlyoverS2TransformConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverS2TransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverS2TransformConstantData>(md::ita::AssignFlyoverS2TransformConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C510;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareTileElevatedStrokeDataHandle>(md::ita::PrepareTileElevatedStrokeDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareTileElevatedStrokeDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareTileElevatedStrokeDataHandle>(md::ita::PrepareTileElevatedStrokeDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C4C8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareTileElevatedStrokeDataHandle>(md::ita::PrepareTileElevatedStrokeDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareTileElevatedStrokeDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareTileElevatedStrokeDataHandle>(md::ita::PrepareTileElevatedStrokeDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C480;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorAO>(md::ita::PrepareFunctionConstantDescriptorAO &&)::{lambda(void)#1},std::allocator<md::ita::PrepareFunctionConstantDescriptorAO &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorAO>(md::ita::PrepareFunctionConstantDescriptorAO &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C438;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorAO>(md::ita::PrepareFunctionConstantDescriptorAO &&)::{lambda(void)#2},std::allocator<md::ita::PrepareFunctionConstantDescriptorAO &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareFunctionConstantDescriptorAO>(md::ita::PrepareFunctionConstantDescriptorAO &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C3F0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLandCoverSettingsConstantData>(md::ita::AssignLandCoverSettingsConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignLandCoverSettingsConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLandCoverSettingsConstantData>(md::ita::AssignLandCoverSettingsConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C3A8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLandCoverSettingsConstantData>(md::ita::AssignLandCoverSettingsConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignLandCoverSettingsConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLandCoverSettingsConstantData>(md::ita::AssignLandCoverSettingsConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C360;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverAtmosphereTextureIndex>(md::ita::AssignFlyoverAtmosphereTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverAtmosphereTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverAtmosphereTextureIndex>(md::ita::AssignFlyoverAtmosphereTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C318;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverAtmosphereTextureIndex>(md::ita::AssignFlyoverAtmosphereTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverAtmosphereTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverAtmosphereTextureIndex>(md::ita::AssignFlyoverAtmosphereTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C2D0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleColorConstantDataHandle>(md::ita::UpdateStyleColorConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::UpdateStyleColorConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleColorConstantDataHandle>(md::ita::UpdateStyleColorConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C288;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleColorConstantDataHandle>(md::ita::UpdateStyleColorConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::UpdateStyleColorConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleColorConstantDataHandle>(md::ita::UpdateStyleColorConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C240;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderTargetSizeConstantData>(md::ita::AssignRenderTargetSizeConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignRenderTargetSizeConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderTargetSizeConstantData>(md::ita::AssignRenderTargetSizeConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C1F8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderTargetSizeConstantData>(md::ita::AssignRenderTargetSizeConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignRenderTargetSizeConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderTargetSizeConstantData>(md::ita::AssignRenderTargetSizeConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C1B0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPlanarParametersConstantData>(md::ita::AssignPlanarParametersConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignPlanarParametersConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPlanarParametersConstantData>(md::ita::AssignPlanarParametersConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C168;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPlanarParametersConstantData>(md::ita::AssignPlanarParametersConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignPlanarParametersConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPlanarParametersConstantData>(md::ita::AssignPlanarParametersConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C120;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGroundAtmosphereConstantData>(md::ita::AssignGroundAtmosphereConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignGroundAtmosphereConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGroundAtmosphereConstantData>(md::ita::AssignGroundAtmosphereConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C0D8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGroundAtmosphereConstantData>(md::ita::AssignGroundAtmosphereConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignGroundAtmosphereConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGroundAtmosphereConstantData>(md::ita::AssignGroundAtmosphereConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C090;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTransformConstantData>(md::ita::AssignFlyoverTransformConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverTransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTransformConstantData>(md::ita::AssignFlyoverTransformConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C048;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTransformConstantData>(md::ita::AssignFlyoverTransformConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverTransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTransformConstantData>(md::ita::AssignFlyoverTransformConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52C000;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTexcoordsConstantData>(md::ita::AssignFlyoverTexcoordsConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverTexcoordsConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTexcoordsConstantData>(md::ita::AssignFlyoverTexcoordsConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BFB8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTexcoordsConstantData>(md::ita::AssignFlyoverTexcoordsConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverTexcoordsConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverTexcoordsConstantData>(md::ita::AssignFlyoverTexcoordsConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BF70;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PerformVisibilityTestOnRenderItem>(md::ita::PerformVisibilityTestOnRenderItem &&)::{lambda(void)#1},std::allocator<md::ita::PerformVisibilityTestOnRenderItem &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PerformVisibilityTestOnRenderItem>(md::ita::PerformVisibilityTestOnRenderItem &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BF28;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PerformVisibilityTestOnRenderItem>(md::ita::PerformVisibilityTestOnRenderItem &&)::{lambda(void)#2},std::allocator<md::ita::PerformVisibilityTestOnRenderItem &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PerformVisibilityTestOnRenderItem>(md::ita::PerformVisibilityTestOnRenderItem &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BEE0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BE98;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfShouldDeleteUniqueMaterial &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteUniqueMaterial>(md::ita::CheckIfShouldDeleteUniqueMaterial &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BE50;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignInstanceTransformDeviceData>(md::ita::AssignInstanceTransformDeviceData &&)::{lambda(void)#1},std::allocator<md::ita::AssignInstanceTransformDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignInstanceTransformDeviceData>(md::ita::AssignInstanceTransformDeviceData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BE08;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignInstanceTransformDeviceData>(md::ita::AssignInstanceTransformDeviceData &&)::{lambda(void)#2},std::allocator<md::ita::AssignInstanceTransformDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignInstanceTransformDeviceData>(md::ita::AssignInstanceTransformDeviceData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BDC0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverMaterialConstantData>(md::ita::AssignFlyoverMaterialConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverMaterialConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverMaterialConstantData>(md::ita::AssignFlyoverMaterialConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BD78;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverMaterialConstantData>(md::ita::AssignFlyoverMaterialConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverMaterialConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverMaterialConstantData>(md::ita::AssignFlyoverMaterialConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BD30;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignCommandBuffersToRenderItems>(md::ita::AssignCommandBuffersToRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::AssignCommandBuffersToRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignCommandBuffersToRenderItems>(md::ita::AssignCommandBuffersToRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BCE8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignCommandBuffersToRenderItems>(md::ita::AssignCommandBuffersToRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::AssignCommandBuffersToRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignCommandBuffersToRenderItems>(md::ita::AssignCommandBuffersToRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BCA0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatusRenderables>(md::ita::UpdateProcessedStatusRenderables &&)::{lambda(void)#1},std::allocator<md::ita::UpdateProcessedStatusRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatusRenderables>(md::ita::UpdateProcessedStatusRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BC58;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatusRenderables>(md::ita::UpdateProcessedStatusRenderables &&)::{lambda(void)#2},std::allocator<md::ita::UpdateProcessedStatusRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatusRenderables>(md::ita::UpdateProcessedStatusRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BC10;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateColorRampGradientResources>(md::ita::UpdateColorRampGradientResources &&)::{lambda(void)#1},std::allocator<md::ita::UpdateColorRampGradientResources &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateColorRampGradientResources>(md::ita::UpdateColorRampGradientResources &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BBC8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateColorRampGradientResources>(md::ita::UpdateColorRampGradientResources &&)::{lambda(void)#2},std::allocator<md::ita::UpdateColorRampGradientResources &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateColorRampGradientResources>(md::ita::UpdateColorRampGradientResources &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BB80;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightSpecularConfiguration>(md::ita::AssignLightSpecularConfiguration &&)::{lambda(void)#1},std::allocator<md::ita::AssignLightSpecularConfiguration &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightSpecularConfiguration>(md::ita::AssignLightSpecularConfiguration &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BB38;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightSpecularConfiguration>(md::ita::AssignLightSpecularConfiguration &&)::{lambda(void)#2},std::allocator<md::ita::AssignLightSpecularConfiguration &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLightSpecularConfiguration>(md::ita::AssignLightSpecularConfiguration &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BAF0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverDiffuseTextureIndex>(md::ita::AssignFlyoverDiffuseTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverDiffuseTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverDiffuseTextureIndex>(md::ita::AssignFlyoverDiffuseTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BAA8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverDiffuseTextureIndex>(md::ita::AssignFlyoverDiffuseTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverDiffuseTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverDiffuseTextureIndex>(md::ita::AssignFlyoverDiffuseTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BA60;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverSharedConstantData>(md::ita::UpdateFlyoverSharedConstantData &&)::{lambda(void)#1},std::allocator<md::ita::UpdateFlyoverSharedConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverSharedConstantData>(md::ita::UpdateFlyoverSharedConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52BA18;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverSharedConstantData>(md::ita::UpdateFlyoverSharedConstantData &&)::{lambda(void)#2},std::allocator<md::ita::UpdateFlyoverSharedConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverSharedConstantData>(md::ita::UpdateFlyoverSharedConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B9D0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForFlyoverClip>(md::ita::ProcessRenderableForFlyoverClip &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForFlyoverClip &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForFlyoverClip>(md::ita::ProcessRenderableForFlyoverClip &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B988;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForFlyoverClip>(md::ita::ProcessRenderableForFlyoverClip &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForFlyoverClip &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForFlyoverClip>(md::ita::ProcessRenderableForFlyoverClip &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B940;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForUpdatedStyle>(md::ita::ProcessMaterialsForUpdatedStyle &&)::{lambda(void)#1},std::allocator<md::ita::ProcessMaterialsForUpdatedStyle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForUpdatedStyle>(md::ita::ProcessMaterialsForUpdatedStyle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B8F8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForUpdatedStyle>(md::ita::ProcessMaterialsForUpdatedStyle &&)::{lambda(void)#2},std::allocator<md::ita::ProcessMaterialsForUpdatedStyle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForUpdatedStyle>(md::ita::ProcessMaterialsForUpdatedStyle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B8B0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPassCommandBuffers>(md::ita::PrepareShadowPassCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowPassCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPassCommandBuffers>(md::ita::PrepareShadowPassCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B868;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPassCommandBuffers>(md::ita::PrepareShadowPassCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowPassCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPassCommandBuffers>(md::ita::PrepareShadowPassCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B820;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileTransformConstantData>(md::ita::AssignTileTransformConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignTileTransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileTransformConstantData>(md::ita::AssignTileTransformConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B7D8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileTransformConstantData>(md::ita::AssignTileTransformConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignTileTransformConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileTransformConstantData>(md::ita::AssignTileTransformConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B790;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTransitionToFlatData>(md::ita::AssignStyleTransitionToFlatData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleTransitionToFlatData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTransitionToFlatData>(md::ita::AssignStyleTransitionToFlatData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B748;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTransitionToFlatData>(md::ita::AssignStyleTransitionToFlatData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleTransitionToFlatData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTransitionToFlatData>(md::ita::AssignStyleTransitionToFlatData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B700;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignMaterialStyleConstantData>(md::ita::AssignMaterialStyleConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignMaterialStyleConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignMaterialStyleConstantData>(md::ita::AssignMaterialStyleConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B6B8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignMaterialStyleConstantData>(md::ita::AssignMaterialStyleConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignMaterialStyleConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignMaterialStyleConstantData>(md::ita::AssignMaterialStyleConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B670;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverSharedConstantData>(md::ita::AssignFlyoverSharedConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverSharedConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverSharedConstantData>(md::ita::AssignFlyoverSharedConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B628;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverSharedConstantData>(md::ita::AssignFlyoverSharedConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverSharedConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverSharedConstantData>(md::ita::AssignFlyoverSharedConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B5E0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForSeeThrough>(md::ita::SetupRenderStatesForSeeThrough &&)::{lambda(void)#1},std::allocator<md::ita::SetupRenderStatesForSeeThrough &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForSeeThrough>(md::ita::SetupRenderStatesForSeeThrough &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B598;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForSeeThrough>(md::ita::SetupRenderStatesForSeeThrough &&)::{lambda(void)#2},std::allocator<md::ita::SetupRenderStatesForSeeThrough &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForSeeThrough>(md::ita::SetupRenderStatesForSeeThrough &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B550;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialEmissiveTexture>(md::ita::ResolveMaterialEmissiveTexture &&)::{lambda(void)#1},std::allocator<md::ita::ResolveMaterialEmissiveTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialEmissiveTexture>(md::ita::ResolveMaterialEmissiveTexture &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B508;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialEmissiveTexture>(md::ita::ResolveMaterialEmissiveTexture &&)::{lambda(void)#2},std::allocator<md::ita::ResolveMaterialEmissiveTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialEmissiveTexture>(md::ita::ResolveMaterialEmissiveTexture &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B4C0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareStyleConstantDataHandle>(md::ita::PrepareStyleConstantDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareStyleConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareStyleConstantDataHandle>(md::ita::PrepareStyleConstantDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B478;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareStyleConstantDataHandle>(md::ita::PrepareStyleConstantDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareStyleConstantDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareStyleConstantDataHandle>(md::ita::PrepareStyleConstantDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B430;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRasterOverlayDataHandle>(md::ita::PrepareRasterOverlayDataHandle &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRasterOverlayDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRasterOverlayDataHandle>(md::ita::PrepareRasterOverlayDataHandle &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B3E8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRasterOverlayDataHandle>(md::ita::PrepareRasterOverlayDataHandle &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRasterOverlayDataHandle &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRasterOverlayDataHandle>(md::ita::PrepareRasterOverlayDataHandle &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B3A0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledDepthPrePassSlice>(md::ita::PrepareCulledDepthPrePassSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCulledDepthPrePassSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledDepthPrePassSlice>(md::ita::PrepareCulledDepthPrePassSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B358;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledDepthPrePassSlice>(md::ita::PrepareCulledDepthPrePassSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCulledDepthPrePassSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledDepthPrePassSlice>(md::ita::PrepareCulledDepthPrePassSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B310;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverNightTextureIndex>(md::ita::AssignFlyoverNightTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverNightTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverNightTextureIndex>(md::ita::AssignFlyoverNightTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B2C8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverNightTextureIndex>(md::ita::AssignFlyoverNightTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverNightTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverNightTextureIndex>(md::ita::AssignFlyoverNightTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B280;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDepthPrePassConstantData>(md::ita::AssignDepthPrePassConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignDepthPrePassConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDepthPrePassConstantData>(md::ita::AssignDepthPrePassConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B238;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDepthPrePassConstantData>(md::ita::AssignDepthPrePassConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignDepthPrePassConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDepthPrePassConstantData>(md::ita::AssignDepthPrePassConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B1F0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleTextureIfNecessary>(md::ita::UpdateStyleTextureIfNecessary &&)::{lambda(void)#1},std::allocator<md::ita::UpdateStyleTextureIfNecessary &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleTextureIfNecessary>(md::ita::UpdateStyleTextureIfNecessary &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B1A8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleTextureIfNecessary>(md::ita::UpdateStyleTextureIfNecessary &&)::{lambda(void)#2},std::allocator<md::ita::UpdateStyleTextureIfNecessary &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleTextureIfNecessary>(md::ita::UpdateStyleTextureIfNecessary &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B160;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialDiffuseTexture>(md::ita::ResolveMaterialDiffuseTexture &&)::{lambda(void)#1},std::allocator<md::ita::ResolveMaterialDiffuseTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialDiffuseTexture>(md::ita::ResolveMaterialDiffuseTexture &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B118;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialDiffuseTexture>(md::ita::ResolveMaterialDiffuseTexture &&)::{lambda(void)#2},std::allocator<md::ita::ResolveMaterialDiffuseTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialDiffuseTexture>(md::ita::ResolveMaterialDiffuseTexture &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B0D0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForLandCover>(md::ita::ProcessRenderableForLandCover &&)::{lambda(void)#1},std::allocator<md::ita::ProcessRenderableForLandCover &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForLandCover>(md::ita::ProcessRenderableForLandCover &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B088;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForLandCover>(md::ita::ProcessRenderableForLandCover &&)::{lambda(void)#2},std::allocator<md::ita::ProcessRenderableForLandCover &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessRenderableForLandCover>(md::ita::ProcessRenderableForLandCover &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52B040;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareUnflattenedCulledSlice>(md::ita::PrepareUnflattenedCulledSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareUnflattenedCulledSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareUnflattenedCulledSlice>(md::ita::PrepareUnflattenedCulledSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AFF8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareUnflattenedCulledSlice>(md::ita::PrepareUnflattenedCulledSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareUnflattenedCulledSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareUnflattenedCulledSlice>(md::ita::PrepareUnflattenedCulledSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AFB0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPassCommandBuffers>(md::ita::PrepareMainPassCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainPassCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPassCommandBuffers>(md::ita::PrepareMainPassCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AF68;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPassCommandBuffers>(md::ita::PrepareMainPassCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainPassCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPassCommandBuffers>(md::ita::PrepareMainPassCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AF20;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPrePassRenderItems>(md::ita::CreateDepthPrePassRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateDepthPrePassRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPrePassRenderItems>(md::ita::CreateDepthPrePassRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AED8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPrePassRenderItems>(md::ita::CreateDepthPrePassRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateDepthPrePassRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPrePassRenderItems>(md::ita::CreateDepthPrePassRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AE90;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectFlyoverMeshRenderables>(md::ita::CollectFlyoverMeshRenderables &&)::{lambda(void)#1},std::allocator<md::ita::CollectFlyoverMeshRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectFlyoverMeshRenderables>(md::ita::CollectFlyoverMeshRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AE48;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectFlyoverMeshRenderables>(md::ita::CollectFlyoverMeshRenderables &&)::{lambda(void)#2},std::allocator<md::ita::CollectFlyoverMeshRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectFlyoverMeshRenderables>(md::ita::CollectFlyoverMeshRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AE00;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectDaVinciMeshRenderables>(md::ita::CollectDaVinciMeshRenderables &&)::{lambda(void)#1},std::allocator<md::ita::CollectDaVinciMeshRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectDaVinciMeshRenderables>(md::ita::CollectDaVinciMeshRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52ADB8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectDaVinciMeshRenderables>(md::ita::CollectDaVinciMeshRenderables &&)::{lambda(void)#2},std::allocator<md::ita::CollectDaVinciMeshRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectDaVinciMeshRenderables>(md::ita::CollectDaVinciMeshRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AD70;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfShouldDeleteRenderable &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AD28;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfShouldDeleteRenderable &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfShouldDeleteRenderable>(md::ita::CheckIfShouldDeleteRenderable &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52ACE0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTemperatureTextureIndex>(md::ita::AssignTemperatureTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignTemperatureTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTemperatureTextureIndex>(md::ita::AssignTemperatureTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AC98;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTemperatureTextureIndex>(md::ita::AssignTemperatureTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignTemperatureTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTemperatureTextureIndex>(md::ita::AssignTemperatureTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AC50;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleShadowConstantData>(md::ita::AssignStyleShadowConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleShadowConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleShadowConstantData>(md::ita::AssignStyleShadowConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AC08;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleShadowConstantData>(md::ita::AssignStyleShadowConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleShadowConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleShadowConstantData>(md::ita::AssignStyleShadowConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52ABC0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLinearDepthConstantData>(md::ita::AssignLinearDepthConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignLinearDepthConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLinearDepthConstantData>(md::ita::AssignLinearDepthConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AB78;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLinearDepthConstantData>(md::ita::AssignLinearDepthConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignLinearDepthConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignLinearDepthConstantData>(md::ita::AssignLinearDepthConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AB30;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverClipConstantData>(md::ita::AssignFlyoverClipConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignFlyoverClipConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverClipConstantData>(md::ita::AssignFlyoverClipConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AAE8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverClipConstantData>(md::ita::AssignFlyoverClipConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignFlyoverClipConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignFlyoverClipConstantData>(md::ita::AssignFlyoverClipConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AAA0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyWantsDynamicShadowBounds>(md::ita::ApplyWantsDynamicShadowBounds &&)::{lambda(void)#1},std::allocator<md::ita::ApplyWantsDynamicShadowBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyWantsDynamicShadowBounds>(md::ita::ApplyWantsDynamicShadowBounds &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AA58;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyWantsDynamicShadowBounds>(md::ita::ApplyWantsDynamicShadowBounds &&)::{lambda(void)#2},std::allocator<md::ita::ApplyWantsDynamicShadowBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyWantsDynamicShadowBounds>(md::ita::ApplyWantsDynamicShadowBounds &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52AA10;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialAlbedoTexture>(md::ita::ResolveMaterialAlbedoTexture &&)::{lambda(void)#1},std::allocator<md::ita::ResolveMaterialAlbedoTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialAlbedoTexture>(md::ita::ResolveMaterialAlbedoTexture &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A9C8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialAlbedoTexture>(md::ita::ResolveMaterialAlbedoTexture &&)::{lambda(void)#2},std::allocator<md::ita::ResolveMaterialAlbedoTexture &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResolveMaterialAlbedoTexture>(md::ita::ResolveMaterialAlbedoTexture &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A980;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::MarkPipelineDataRequirements>(md::ita::MarkPipelineDataRequirements &&)::{lambda(void)#1},std::allocator<md::ita::MarkPipelineDataRequirements &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::MarkPipelineDataRequirements>(md::ita::MarkPipelineDataRequirements &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A938;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::MarkPipelineDataRequirements>(md::ita::MarkPipelineDataRequirements &&)::{lambda(void)#2},std::allocator<md::ita::MarkPipelineDataRequirements &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::MarkPipelineDataRequirements>(md::ita::MarkPipelineDataRequirements &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A8F0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateUnflattenedRenderItems>(md::ita::CreateUnflattenedRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateUnflattenedRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateUnflattenedRenderItems>(md::ita::CreateUnflattenedRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A8A8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateUnflattenedRenderItems>(md::ita::CreateUnflattenedRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateUnflattenedRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateUnflattenedRenderItems>(md::ita::CreateUnflattenedRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A860;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPeeledRenderItems>(md::ita::CreateDepthPeeledRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateDepthPeeledRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPeeledRenderItems>(md::ita::CreateDepthPeeledRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A818;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPeeledRenderItems>(md::ita::CreateDepthPeeledRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateDepthPeeledRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateDepthPeeledRenderItems>(md::ita::CreateDepthPeeledRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A7D0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileElevatedStrokeData>(md::ita::AssignTileElevatedStrokeData &&)::{lambda(void)#1},std::allocator<md::ita::AssignTileElevatedStrokeData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileElevatedStrokeData>(md::ita::AssignTileElevatedStrokeData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A6F8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileElevatedStrokeData>(md::ita::AssignTileElevatedStrokeData &&)::{lambda(void)#2},std::allocator<md::ita::AssignTileElevatedStrokeData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileElevatedStrokeData>(md::ita::AssignTileElevatedStrokeData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A6B0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleIndexTextureIndex>(md::ita::AssignStyleIndexTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleIndexTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleIndexTextureIndex>(md::ita::AssignStyleIndexTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A668;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleIndexTextureIndex>(md::ita::AssignStyleIndexTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleIndexTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleIndexTextureIndex>(md::ita::AssignStyleIndexTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A620;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleBlendConstantData>(md::ita::AssignStyleBlendConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleBlendConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleBlendConstantData>(md::ita::AssignStyleBlendConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A5D8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleBlendConstantData>(md::ita::AssignStyleBlendConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleBlendConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleBlendConstantData>(md::ita::AssignStyleBlendConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A590;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#1},std::allocator<md::ita::UpdateResourcesAfterRebuild &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A548;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#2},std::allocator<md::ita::UpdateResourcesAfterRebuild &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateResourcesAfterRebuild>(md::ita::UpdateResourcesAfterRebuild &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A500;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverTileViewMatrix>(md::ita::UpdateFlyoverTileViewMatrix &&)::{lambda(void)#1},std::allocator<md::ita::UpdateFlyoverTileViewMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverTileViewMatrix>(md::ita::UpdateFlyoverTileViewMatrix &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A4B8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverTileViewMatrix>(md::ita::UpdateFlyoverTileViewMatrix &&)::{lambda(void)#2},std::allocator<md::ita::UpdateFlyoverTileViewMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateFlyoverTileViewMatrix>(md::ita::UpdateFlyoverTileViewMatrix &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A470;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateDepthPrePassConstants>(md::ita::UpdateDepthPrePassConstants &&)::{lambda(void)#1},std::allocator<md::ita::UpdateDepthPrePassConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateDepthPrePassConstants>(md::ita::UpdateDepthPrePassConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A428;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateDepthPrePassConstants>(md::ita::UpdateDepthPrePassConstants &&)::{lambda(void)#2},std::allocator<md::ita::UpdateDepthPrePassConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateDepthPrePassConstants>(md::ita::UpdateDepthPrePassConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A3E0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMeshRenderableBounds>(md::ita::PrepareMeshRenderableBounds &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMeshRenderableBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMeshRenderableBounds>(md::ita::PrepareMeshRenderableBounds &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A398;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMeshRenderableBounds>(md::ita::PrepareMeshRenderableBounds &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMeshRenderableBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMeshRenderableBounds>(md::ita::PrepareMeshRenderableBounds &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A350;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBoundsScaleAndAdjust>(md::ita::PrepareBoundsScaleAndAdjust &&)::{lambda(void)#1},std::allocator<md::ita::PrepareBoundsScaleAndAdjust &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBoundsScaleAndAdjust>(md::ita::PrepareBoundsScaleAndAdjust &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A308;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBoundsScaleAndAdjust>(md::ita::PrepareBoundsScaleAndAdjust &&)::{lambda(void)#2},std::allocator<md::ita::PrepareBoundsScaleAndAdjust &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareBoundsScaleAndAdjust>(md::ita::PrepareBoundsScaleAndAdjust &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A2C0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateShadowPassRenderItems>(md::ita::CreateShadowPassRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateShadowPassRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateShadowPassRenderItems>(md::ita::CreateShadowPassRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A278;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateShadowPassRenderItems>(md::ita::CreateShadowPassRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateShadowPassRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateShadowPassRenderItems>(md::ita::CreateShadowPassRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A230;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSSAOConstantData>(md::ita::AssignStyleSSAOConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleSSAOConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSSAOConstantData>(md::ita::AssignStyleSSAOConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A1E8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSSAOConstantData>(md::ita::AssignStyleSSAOConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleSSAOConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSSAOConstantData>(md::ita::AssignStyleSSAOConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A1A0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRouteMaskTextureIndex>(md::ita::AssignRouteMaskTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignRouteMaskTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRouteMaskTextureIndex>(md::ita::AssignRouteMaskTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A158;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRouteMaskTextureIndex>(md::ita::AssignRouteMaskTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignRouteMaskTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRouteMaskTextureIndex>(md::ita::AssignRouteMaskTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A110;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOcclusionTextureIndex>(md::ita::AssignOcclusionTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignOcclusionTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOcclusionTextureIndex>(md::ita::AssignOcclusionTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A0C8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOcclusionTextureIndex>(md::ita::AssignOcclusionTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignOcclusionTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOcclusionTextureIndex>(md::ita::AssignOcclusionTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A080;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient2TextureIndex>(md::ita::AssignGradient2TextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignGradient2TextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient2TextureIndex>(md::ita::AssignGradient2TextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF52A038;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient2TextureIndex>(md::ita::AssignGradient2TextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignGradient2TextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient2TextureIndex>(md::ita::AssignGradient2TextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529FF0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient1TextureIndex>(md::ita::AssignGradient1TextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignGradient1TextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient1TextureIndex>(md::ita::AssignGradient1TextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529FA8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient1TextureIndex>(md::ita::AssignGradient1TextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignGradient1TextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignGradient1TextureIndex>(md::ita::AssignGradient1TextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529F60;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignColorCorrectionFactor>(md::ita::AssignColorCorrectionFactor &&)::{lambda(void)#1},std::allocator<md::ita::AssignColorCorrectionFactor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignColorCorrectionFactor>(md::ita::AssignColorCorrectionFactor &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529F18;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignColorCorrectionFactor>(md::ita::AssignColorCorrectionFactor &&)::{lambda(void)#2},std::allocator<md::ita::AssignColorCorrectionFactor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignColorCorrectionFactor>(md::ita::AssignColorCorrectionFactor &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529ED0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForDecals>(md::ita::SetupRenderStatesForDecals &&)::{lambda(void)#1},std::allocator<md::ita::SetupRenderStatesForDecals &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForDecals>(md::ita::SetupRenderStatesForDecals &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529E88;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForDecals>(md::ita::SetupRenderStatesForDecals &&)::{lambda(void)#2},std::allocator<md::ita::SetupRenderStatesForDecals &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStatesForDecals>(md::ita::SetupRenderStatesForDecals &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529E40;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupPredefinedRenderState>(md::ita::SetupPredefinedRenderState &&)::{lambda(void)#1},std::allocator<md::ita::SetupPredefinedRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupPredefinedRenderState>(md::ita::SetupPredefinedRenderState &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529DF8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupPredefinedRenderState>(md::ita::SetupPredefinedRenderState &&)::{lambda(void)#2},std::allocator<md::ita::SetupPredefinedRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupPredefinedRenderState>(md::ita::SetupPredefinedRenderState &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529DB0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSliceWithCulled>(md::ita::PrepareMainSliceWithCulled &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainSliceWithCulled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSliceWithCulled>(md::ita::PrepareMainSliceWithCulled &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529D68;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSliceWithCulled>(md::ita::PrepareMainSliceWithCulled &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainSliceWithCulled &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSliceWithCulled>(md::ita::PrepareMainSliceWithCulled &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529D20;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialNeedsUpdate>(md::ita::CheckIfMaterialNeedsUpdate &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfMaterialNeedsUpdate &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialNeedsUpdate>(md::ita::CheckIfMaterialNeedsUpdate &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529C48;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialNeedsUpdate>(md::ita::CheckIfMaterialNeedsUpdate &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfMaterialNeedsUpdate &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfMaterialNeedsUpdate>(md::ita::CheckIfMaterialNeedsUpdate &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529C00;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignEmissiveTextureIndex>(md::ita::AssignEmissiveTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignEmissiveTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignEmissiveTextureIndex>(md::ita::AssignEmissiveTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529BB8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignEmissiveTextureIndex>(md::ita::AssignEmissiveTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignEmissiveTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignEmissiveTextureIndex>(md::ita::AssignEmissiveTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529B70;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignElevationsDeviceData>(md::ita::AssignElevationsDeviceData &&)::{lambda(void)#1},std::allocator<md::ita::AssignElevationsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignElevationsDeviceData>(md::ita::AssignElevationsDeviceData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529B28;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignElevationsDeviceData>(md::ita::AssignElevationsDeviceData &&)::{lambda(void)#2},std::allocator<md::ita::AssignElevationsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignElevationsDeviceData>(md::ita::AssignElevationsDeviceData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529AE0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignClippingConstantData>(md::ita::AssignClippingConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignClippingConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignClippingConstantData>(md::ita::AssignClippingConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529A98;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignClippingConstantData>(md::ita::AssignClippingConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignClippingConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignClippingConstantData>(md::ita::AssignClippingConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529A50;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForZIndex>(md::ita::ProcessMaterialsForZIndex &&)::{lambda(void)#1},std::allocator<md::ita::ProcessMaterialsForZIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForZIndex>(md::ita::ProcessMaterialsForZIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529A08;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForZIndex>(md::ita::ProcessMaterialsForZIndex &&)::{lambda(void)#2},std::allocator<md::ita::ProcessMaterialsForZIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ProcessMaterialsForZIndex>(md::ita::ProcessMaterialsForZIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5299C0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DecidePipelineForMainPass>(md::ita::DecidePipelineForMainPass &&)::{lambda(void)#1},std::allocator<md::ita::DecidePipelineForMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DecidePipelineForMainPass>(md::ita::DecidePipelineForMainPass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529978;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DecidePipelineForMainPass>(md::ita::DecidePipelineForMainPass &&)::{lambda(void)#2},std::allocator<md::ita::DecidePipelineForMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DecidePipelineForMainPass>(md::ita::DecidePipelineForMainPass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529930;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfRenderableIsUnique>(md::ita::CheckIfRenderableIsUnique &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfRenderableIsUnique &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfRenderableIsUnique>(md::ita::CheckIfRenderableIsUnique &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5298E8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfRenderableIsUnique>(md::ita::CheckIfRenderableIsUnique &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfRenderableIsUnique &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfRenderableIsUnique>(md::ita::CheckIfRenderableIsUnique &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5298A0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOverlayTextureIndex>(md::ita::AssignOverlayTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignOverlayTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOverlayTextureIndex>(md::ita::AssignOverlayTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529858;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOverlayTextureIndex>(md::ita::AssignOverlayTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignOverlayTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignOverlayTextureIndex>(md::ita::AssignOverlayTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529810;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDiffuseTextureIndex>(md::ita::AssignDiffuseTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignDiffuseTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDiffuseTextureIndex>(md::ita::AssignDiffuseTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5297C8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDiffuseTextureIndex>(md::ita::AssignDiffuseTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignDiffuseTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignDiffuseTextureIndex>(md::ita::AssignDiffuseTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529780;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAridityTextureIndex>(md::ita::AssignAridityTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignAridityTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAridityTextureIndex>(md::ita::AssignAridityTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529738;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAridityTextureIndex>(md::ita::AssignAridityTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignAridityTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAridityTextureIndex>(md::ita::AssignAridityTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5296F0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAmbientTextureIndex>(md::ita::AssignAmbientTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignAmbientTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAmbientTextureIndex>(md::ita::AssignAmbientTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5296A8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAmbientTextureIndex>(md::ita::AssignAmbientTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignAmbientTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignAmbientTextureIndex>(md::ita::AssignAmbientTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529660;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleEmmisiveColor>(md::ita::UpdateStyleEmmisiveColor &&)::{lambda(void)#1},std::allocator<md::ita::UpdateStyleEmmisiveColor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleEmmisiveColor>(md::ita::UpdateStyleEmmisiveColor &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529618;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleEmmisiveColor>(md::ita::UpdateStyleEmmisiveColor &&)::{lambda(void)#2},std::allocator<md::ita::UpdateStyleEmmisiveColor &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateStyleEmmisiveColor>(md::ita::UpdateStyleEmmisiveColor &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5295D0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRouteLineMaskPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529588;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRouteLineMaskPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRouteLineMaskPass>(md::ita::PrepareRouteLineMaskPass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529540;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledShadowSlice>(md::ita::PrepareCulledShadowSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCulledShadowSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledShadowSlice>(md::ita::PrepareCulledShadowSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5294F8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledShadowSlice>(md::ita::PrepareCulledShadowSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCulledShadowSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledShadowSlice>(md::ita::PrepareCulledShadowSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5294B0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSunMatrixData>(md::ita::AssignStyleSunMatrixData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleSunMatrixData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSunMatrixData>(md::ita::AssignStyleSunMatrixData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529348;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSunMatrixData>(md::ita::AssignStyleSunMatrixData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleSunMatrixData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleSunMatrixData>(md::ita::AssignStyleSunMatrixData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529300;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowTextureIndex>(md::ita::AssignShadowTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignShadowTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowTextureIndex>(md::ita::AssignShadowTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5292B8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowTextureIndex>(md::ita::AssignShadowTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignShadowTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowTextureIndex>(md::ita::AssignShadowTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529270;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowConstantData>(md::ita::AssignShadowConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignShadowConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowConstantData>(md::ita::AssignShadowConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529228;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowConstantData>(md::ita::AssignShadowConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignShadowConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignShadowConstantData>(md::ita::AssignShadowConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5291E0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignSRGBBlendStyleData>(md::ita::AssignSRGBBlendStyleData &&)::{lambda(void)#1},std::allocator<md::ita::AssignSRGBBlendStyleData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignSRGBBlendStyleData>(md::ita::AssignSRGBBlendStyleData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529198;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignSRGBBlendStyleData>(md::ita::AssignSRGBBlendStyleData &&)::{lambda(void)#2},std::allocator<md::ita::AssignSRGBBlendStyleData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignSRGBBlendStyleData>(md::ita::AssignSRGBBlendStyleData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529150;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#1},std::allocator<md::ita::UpdateClippingConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529108;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#2},std::allocator<md::ita::UpdateClippingConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateClippingConstants>(md::ita::UpdateClippingConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5290C0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupDefaultRenderState>(md::ita::SetupDefaultRenderState &&)::{lambda(void)#1},std::allocator<md::ita::SetupDefaultRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupDefaultRenderState>(md::ita::SetupDefaultRenderState &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529078;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupDefaultRenderState>(md::ita::SetupDefaultRenderState &&)::{lambda(void)#2},std::allocator<md::ita::SetupDefaultRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupDefaultRenderState>(md::ita::SetupDefaultRenderState &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF529030;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanupRampMaterialData>(md::ita::CleanupRampMaterialData &&)::{lambda(void)#1},std::allocator<md::ita::CleanupRampMaterialData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanupRampMaterialData>(md::ita::CleanupRampMaterialData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528F58;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanupRampMaterialData>(md::ita::CleanupRampMaterialData &&)::{lambda(void)#2},std::allocator<md::ita::CleanupRampMaterialData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CleanupRampMaterialData>(md::ita::CleanupRampMaterialData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528F10;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTextureIndex>(md::ita::AssignStyleTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTextureIndex>(md::ita::AssignStyleTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528EC8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTextureIndex>(md::ita::AssignStyleTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleTextureIndex>(md::ita::AssignStyleTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528E80;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleConstantData>(md::ita::AssignStyleConstantData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleConstantData>(md::ita::AssignStyleConstantData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528E38;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleConstantData>(md::ita::AssignStyleConstantData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleConstantData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleConstantData>(md::ita::AssignStyleConstantData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528DF0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRasterOverlayData>(md::ita::AssignRasterOverlayData &&)::{lambda(void)#1},std::allocator<md::ita::AssignRasterOverlayData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRasterOverlayData>(md::ita::AssignRasterOverlayData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528DA8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRasterOverlayData>(md::ita::AssignRasterOverlayData &&)::{lambda(void)#2},std::allocator<md::ita::AssignRasterOverlayData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRasterOverlayData>(md::ita::AssignRasterOverlayData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528D60;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPositionScaleInfo>(md::ita::AssignPositionScaleInfo &&)::{lambda(void)#1},std::allocator<md::ita::AssignPositionScaleInfo &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPositionScaleInfo>(md::ita::AssignPositionScaleInfo &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528D18;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPositionScaleInfo>(md::ita::AssignPositionScaleInfo &&)::{lambda(void)#2},std::allocator<md::ita::AssignPositionScaleInfo &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignPositionScaleInfo>(md::ita::AssignPositionScaleInfo &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528CD0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignNormalsDeviceData>(md::ita::AssignNormalsDeviceData &&)::{lambda(void)#1},std::allocator<md::ita::AssignNormalsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignNormalsDeviceData>(md::ita::AssignNormalsDeviceData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528C88;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignNormalsDeviceData>(md::ita::AssignNormalsDeviceData &&)::{lambda(void)#2},std::allocator<md::ita::AssignNormalsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignNormalsDeviceData>(md::ita::AssignNormalsDeviceData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528C40;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyUsesIdentityMatrix>(md::ita::ApplyUsesIdentityMatrix &&)::{lambda(void)#1},std::allocator<md::ita::ApplyUsesIdentityMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyUsesIdentityMatrix>(md::ita::ApplyUsesIdentityMatrix &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528BF8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyUsesIdentityMatrix>(md::ita::ApplyUsesIdentityMatrix &&)::{lambda(void)#2},std::allocator<md::ita::ApplyUsesIdentityMatrix &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyUsesIdentityMatrix>(md::ita::ApplyUsesIdentityMatrix &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528BB0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#1},std::allocator<md::ita::UpdateCameraStyleLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528B68;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#2},std::allocator<md::ita::UpdateCameraStyleLight &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateCameraStyleLight>(md::ita::UpdateCameraStyleLight &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528B20;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderState>(md::ita::SetupCustomRenderState &&)::{lambda(void)#1},std::allocator<md::ita::SetupCustomRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderState>(md::ita::SetupCustomRenderState &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528AD8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderState>(md::ita::SetupCustomRenderState &&)::{lambda(void)#2},std::allocator<md::ita::SetupCustomRenderState &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCustomRenderState>(md::ita::SetupCustomRenderState &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528A90;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResetFunctionConstants>(md::ita::ResetFunctionConstants &&)::{lambda(void)#1},std::allocator<md::ita::ResetFunctionConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResetFunctionConstants>(md::ita::ResetFunctionConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528A48;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResetFunctionConstants>(md::ita::ResetFunctionConstants &&)::{lambda(void)#2},std::allocator<md::ita::ResetFunctionConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ResetFunctionConstants>(md::ita::ResetFunctionConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528A00;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DetermineDataIDsNeeded>(md::ita::DetermineDataIDsNeeded &&)::{lambda(void)#1},std::allocator<md::ita::DetermineDataIDsNeeded &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DetermineDataIDsNeeded>(md::ita::DetermineDataIDsNeeded &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528928;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DetermineDataIDsNeeded>(md::ita::DetermineDataIDsNeeded &&)::{lambda(void)#2},std::allocator<md::ita::DetermineDataIDsNeeded &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DetermineDataIDsNeeded>(md::ita::DetermineDataIDsNeeded &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5288E0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyPositionScaleInfo>(md::ita::ApplyPositionScaleInfo &&)::{lambda(void)#1},std::allocator<md::ita::ApplyPositionScaleInfo &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyPositionScaleInfo>(md::ita::ApplyPositionScaleInfo &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528808;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyPositionScaleInfo>(md::ita::ApplyPositionScaleInfo &&)::{lambda(void)#2},std::allocator<md::ita::ApplyPositionScaleInfo &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyPositionScaleInfo>(md::ita::ApplyPositionScaleInfo &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5287C0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#1},std::allocator<md::ita::UpdateTileRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528778;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#2},std::allocator<md::ita::UpdateTileRenderables &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileRenderables>(md::ita::UpdateTileRenderables &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528730;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateShadowConstants>(md::ita::UpdateShadowConstants &&)::{lambda(void)#1},std::allocator<md::ita::UpdateShadowConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateShadowConstants>(md::ita::UpdateShadowConstants &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5286E8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateShadowConstants>(md::ita::UpdateShadowConstants &&)::{lambda(void)#2},std::allocator<md::ita::UpdateShadowConstants &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateShadowConstants>(md::ita::UpdateShadowConstants &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5286A0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatus>(md::ita::UpdateProcessedStatus &&)::{lambda(void)#1},std::allocator<md::ita::UpdateProcessedStatus &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatus>(md::ita::UpdateProcessedStatus &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528658;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatus>(md::ita::UpdateProcessedStatus &&)::{lambda(void)#2},std::allocator<md::ita::UpdateProcessedStatus &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateProcessedStatus>(md::ita::UpdateProcessedStatus &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528610;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#1},std::allocator<md::ita::PrepareRenderableData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5285C8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#2},std::allocator<md::ita::PrepareRenderableData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareRenderableData>(md::ita::PrepareRenderableData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528580;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528538;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCommandBuffers>(md::ita::PrepareCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5284F0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#1},std::allocator<md::ita::DeletePendingDeletion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528418;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#2},std::allocator<md::ita::DeletePendingDeletion &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DeletePendingDeletion>(md::ita::DeletePendingDeletion &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5283D0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateMainRenderItems>(md::ita::CreateMainRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::CreateMainRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateMainRenderItems>(md::ita::CreateMainRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528388;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateMainRenderItems>(md::ita::CreateMainRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::CreateMainRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreateMainRenderItems>(md::ita::CreateMainRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528340;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfReadyToProcess &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5282F8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfReadyToProcess &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfReadyToProcess>(md::ita::CheckIfReadyToProcess &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5282B0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfNeedsDepthPeel>(md::ita::CheckIfNeedsDepthPeel &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfNeedsDepthPeel &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfNeedsDepthPeel>(md::ita::CheckIfNeedsDepthPeel &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528268;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfNeedsDepthPeel>(md::ita::CheckIfNeedsDepthPeel &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfNeedsDepthPeel &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfNeedsDepthPeel>(md::ita::CheckIfNeedsDepthPeel &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528220;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTexTextureIndex>(md::ita::AssignTexTextureIndex &&)::{lambda(void)#1},std::allocator<md::ita::AssignTexTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTexTextureIndex>(md::ita::AssignTexTextureIndex &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528148;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTexTextureIndex>(md::ita::AssignTexTextureIndex &&)::{lambda(void)#2},std::allocator<md::ita::AssignTexTextureIndex &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTexTextureIndex>(md::ita::AssignTexTextureIndex &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528100;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#1},std::allocator<md::ita::UpdateTileTransforms &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5280B8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#2},std::allocator<md::ita::UpdateTileTransforms &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::UpdateTileTransforms>(md::ita::UpdateTileTransforms &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528070;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#1},std::allocator<md::ita::DisconnectComponents &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF528028;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#2},std::allocator<md::ita::DisconnectComponents &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::DisconnectComponents>(md::ita::DisconnectComponents &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527FE0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelineStates>(md::ita::CreatePipelineStates &&)::{lambda(void)#1},std::allocator<md::ita::CreatePipelineStates &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelineStates>(md::ita::CreatePipelineStates &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527F98;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelineStates>(md::ita::CreatePipelineStates &&)::{lambda(void)#2},std::allocator<md::ita::CreatePipelineStates &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelineStates>(md::ita::CreatePipelineStates &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527F50;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfStyleZChanged>(md::ita::CheckIfStyleZChanged &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfStyleZChanged &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfStyleZChanged>(md::ita::CheckIfStyleZChanged &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527F08;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfStyleZChanged>(md::ita::CheckIfStyleZChanged &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfStyleZChanged &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfStyleZChanged>(md::ita::CheckIfStyleZChanged &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527EC0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleColorData>(md::ita::AssignStyleColorData &&)::{lambda(void)#1},std::allocator<md::ita::AssignStyleColorData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleColorData>(md::ita::AssignStyleColorData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527E78;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleColorData>(md::ita::AssignStyleColorData &&)::{lambda(void)#2},std::allocator<md::ita::AssignStyleColorData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignStyleColorData>(md::ita::AssignStyleColorData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527E30;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyColorCorrection>(md::ita::ApplyColorCorrection &&)::{lambda(void)#1},std::allocator<md::ita::ApplyColorCorrection &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyColorCorrection>(md::ita::ApplyColorCorrection &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527DE8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyColorCorrection>(md::ita::ApplyColorCorrection &&)::{lambda(void)#2},std::allocator<md::ita::ApplyColorCorrection &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyColorCorrection>(md::ita::ApplyColorCorrection &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527DA0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCommonDataTask>(md::ita::SetupCommonDataTask &&)::{lambda(void)#1},std::allocator<md::ita::SetupCommonDataTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCommonDataTask>(md::ita::SetupCommonDataTask &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527D58;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCommonDataTask>(md::ita::SetupCommonDataTask &&)::{lambda(void)#2},std::allocator<md::ita::SetupCommonDataTask &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupCommonDataTask>(md::ita::SetupCommonDataTask &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527D10;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowBounds>(md::ita::PrepareShadowBounds &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowBounds>(md::ita::PrepareShadowBounds &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527CC8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowBounds>(md::ita::PrepareShadowBounds &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowBounds &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowBounds>(md::ita::PrepareShadowBounds &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527C80;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527C38;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareDepthPrePass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareDepthPrePass>(md::ita::PrepareDepthPrePass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527BF0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignUVsDeviceData>(md::ita::AssignUVsDeviceData &&)::{lambda(void)#1},std::allocator<md::ita::AssignUVsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignUVsDeviceData>(md::ita::AssignUVsDeviceData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527B18;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignUVsDeviceData>(md::ita::AssignUVsDeviceData &&)::{lambda(void)#2},std::allocator<md::ita::AssignUVsDeviceData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignUVsDeviceData>(md::ita::AssignUVsDeviceData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527AD0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssembleRenderItems>(md::ita::AssembleRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::AssembleRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssembleRenderItems>(md::ita::AssembleRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527A88;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssembleRenderItems>(md::ita::AssembleRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::AssembleRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssembleRenderItems>(md::ita::AssembleRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527A40;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SortCommandBuffers>(md::ita::SortCommandBuffers &&)::{lambda(void)#1},std::allocator<md::ita::SortCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SortCommandBuffers>(md::ita::SortCommandBuffers &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5279F8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SortCommandBuffers>(md::ita::SortCommandBuffers &&)::{lambda(void)#2},std::allocator<md::ita::SortCommandBuffers &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SortCommandBuffers>(md::ita::SortCommandBuffers &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5279B0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowSlice>(md::ita::PrepareShadowSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowSlice>(md::ita::PrepareShadowSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527968;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowSlice>(md::ita::PrepareShadowSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowSlice>(md::ita::PrepareShadowSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527920;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledSlice>(md::ita::PrepareCulledSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareCulledSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledSlice>(md::ita::PrepareCulledSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5278D8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledSlice>(md::ita::PrepareCulledSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareCulledSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareCulledSlice>(md::ita::PrepareCulledSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527890;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileViewData>(md::ita::AssignTileViewData &&)::{lambda(void)#1},std::allocator<md::ita::AssignTileViewData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileViewData>(md::ita::AssignTileViewData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527848;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileViewData>(md::ita::AssignTileViewData &&)::{lambda(void)#2},std::allocator<md::ita::AssignTileViewData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignTileViewData>(md::ita::AssignTileViewData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527800;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::TransferPipelines>(md::ita::TransferPipelines &&)::{lambda(void)#1},std::allocator<md::ita::TransferPipelines &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::TransferPipelines>(md::ita::TransferPipelines &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5277B8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::TransferPipelines>(md::ita::TransferPipelines &&)::{lambda(void)#2},std::allocator<md::ita::TransferPipelines &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::TransferPipelines>(md::ita::TransferPipelines &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527770;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStates>(md::ita::SetupRenderStates &&)::{lambda(void)#1},std::allocator<md::ita::SetupRenderStates &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStates>(md::ita::SetupRenderStates &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527728;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStates>(md::ita::SetupRenderStates &&)::{lambda(void)#2},std::allocator<md::ita::SetupRenderStates &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::SetupRenderStates>(md::ita::SetupRenderStates &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5276E0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#1},std::allocator<md::ita::PushLegacyRibbons &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527698;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#2},std::allocator<md::ita::PushLegacyRibbons &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushLegacyRibbons>(md::ita::PushLegacyRibbons &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527650;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527608;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareShadowPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareShadowPass>(md::ita::PrepareShadowPass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5275C0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#1},std::allocator<md::ita::PrepareSSAOPasses &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527578;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#2},std::allocator<md::ita::PrepareSSAOPasses &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSSAOPasses>(md::ita::PrepareSSAOPasses &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527530;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectParameters>(md::ita::CollectParameters &&)::{lambda(void)#1},std::allocator<md::ita::CollectParameters &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectParameters>(md::ita::CollectParameters &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5274E8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectParameters>(md::ita::CollectParameters &&)::{lambda(void)#2},std::allocator<md::ita::CollectParameters &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectParameters>(md::ita::CollectParameters &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5274A0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderOrder>(md::ita::AssignRenderOrder &&)::{lambda(void)#1},std::allocator<md::ita::AssignRenderOrder &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderOrder>(md::ita::AssignRenderOrder &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527458;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderOrder>(md::ita::AssignRenderOrder &&)::{lambda(void)#2},std::allocator<md::ita::AssignRenderOrder &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::AssignRenderOrder>(md::ita::AssignRenderOrder &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527410;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSlice>(md::ita::PrepareMainSlice &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSlice>(md::ita::PrepareMainSlice &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5273C8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSlice>(md::ita::PrepareMainSlice &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainSlice &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainSlice>(md::ita::PrepareMainSlice &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527380;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectColorData>(md::ita::CollectColorData &&)::{lambda(void)#1},std::allocator<md::ita::CollectColorData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectColorData>(md::ita::CollectColorData &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5272A8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectColorData>(md::ita::CollectColorData &&)::{lambda(void)#2},std::allocator<md::ita::CollectColorData &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CollectColorData>(md::ita::CollectColorData &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527260;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushRenderItems>(md::ita::PushRenderItems &&)::{lambda(void)#1},std::allocator<md::ita::PushRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushRenderItems>(md::ita::PushRenderItems &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527218;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushRenderItems>(md::ita::PushRenderItems &&)::{lambda(void)#2},std::allocator<md::ita::PushRenderItems &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PushRenderItems>(md::ita::PushRenderItems &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5271D0;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#1},std::allocator<md::ita::PrepareMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527188;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#2},std::allocator<md::ita::PrepareMainPass &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareMainPass>(md::ita::PrepareMainPass &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527140;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelines>(md::ita::CreatePipelines &&)::{lambda(void)#1},std::allocator<md::ita::CreatePipelines &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelines>(md::ita::CreatePipelines &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527068;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelines>(md::ita::CreatePipelines &&)::{lambda(void)#2},std::allocator<md::ita::CreatePipelines &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CreatePipelines>(md::ita::CreatePipelines &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF527020;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyAlbedoTint>(md::ita::ApplyAlbedoTint &&)::{lambda(void)#1},std::allocator<md::ita::ApplyAlbedoTint &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyAlbedoTint>(md::ita::ApplyAlbedoTint &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526FD8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyAlbedoTint>(md::ita::ApplyAlbedoTint &&)::{lambda(void)#2},std::allocator<md::ita::ApplyAlbedoTint &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::ApplyAlbedoTint>(md::ita::ApplyAlbedoTint &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526F90;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSlices>(md::ita::PrepareSlices &&)::{lambda(void)#1},std::allocator<md::ita::PrepareSlices &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSlices>(md::ita::PrepareSlices &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526F48;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSlices>(md::ita::PrepareSlices &&)::{lambda(void)#2},std::allocator<md::ita::PrepareSlices &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::PrepareSlices>(md::ita::PrepareSlices &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526F00;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfOpaque>(md::ita::CheckIfOpaque &&)::{lambda(void)#1},std::allocator<md::ita::CheckIfOpaque &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfOpaque>(md::ita::CheckIfOpaque &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526EB8;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfOpaque>(md::ita::CheckIfOpaque &&)::{lambda(void)#2},std::allocator<md::ita::CheckIfOpaque &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<md::ita::CheckIfOpaque>(md::ita::CheckIfOpaque &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526E70;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupMeshRendererLayout>(CleanupMeshRendererLayout &&)::{lambda(void)#1},std::allocator<CleanupMeshRendererLayout &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupMeshRendererLayout>(CleanupMeshRendererLayout &&)::{lambda(void)#1}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526D98;
}

void std::__function::__func<ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupMeshRendererLayout>(CleanupMeshRendererLayout &&)::{lambda(void)#2},std::allocator<CleanupMeshRendererLayout &&>,std::vector<gdc::TypeInfo,ecs2::ExecutionTaskFunction::ExecutionTaskFunction<CleanupMeshRendererLayout>(CleanupMeshRendererLayout &&)::{lambda(void)#2}<gdc>> ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF526D50;
}

uint64_t geo::codec::VectorTile::daVinciMeshes(geo::codec::VectorTile *this)
{
  return *((void *)this + 257);
}

void ggl::BufferData::prepareBufferForDevice(std::mutex *this, ggl::Device *a2, char a3)
{
  unint64_t v6 = this + 2;
  std::mutex::lock(this + 2);
  if (*(void *)&this->__m_.__opaque[16]) {
    goto LABEL_2;
  }
  int v7 = *((_DWORD *)a2 + 24);
  if (a3)
  {
    unsigned int v8 = 1;
  }
  else
  {
    if (!v7)
    {
      if (this->__m_.__opaque[10]) {
        unsigned int v8 = 3;
      }
      else {
        unsigned int v8 = 1;
      }
      *(_DWORD *)&this[1].__m_.__opaque[40] = v8;
      goto LABEL_16;
    }
    unsigned int v8 = 0;
  }
  *(_DWORD *)&this[1].__m_.__opaque[40] = v8;
  if (v7 != 1)
  {
    if (v7) {
      goto LABEL_25;
    }
LABEL_16:
    uint64_t v9 = 4;
    switch(this->__m_.__opaque[9])
    {
      case 0:
        uint64_t v9 = 16;
        if (*((unsigned char *)a2 + 23)) {
          uint64_t v9 = 1;
        }
        if (v8 < 2) {
          goto LABEL_25;
        }
        goto LABEL_21;
      case 1:
        goto LABEL_20;
      case 2:
      case 3:
        uint64_t v9 = 16;
        if (v8 < 2) {
          goto LABEL_25;
        }
        goto LABEL_21;
      default:
        break;
    }
  }
  uint64_t v9 = 0;
LABEL_20:
  if (v8 >= 2)
  {
LABEL_21:
    uint64_t v10 = (*(void *)&this->__m_.__opaque[40] + v9 + ~*(void *)&this->__m_.__opaque[32]) & -v9;
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v10 = *(void *)&this->__m_.__opaque[40] - *(void *)&this->__m_.__opaque[32];
LABEL_26:
  *(void *)&this[1].__m_.__opaque[48] = v10;
  {
    operator new();
  }
  uint64_t v11 = ggl::Allocator::instance(void)::alloc;
  uint64_t v12 = *(void *)&this[1].__m_.__opaque[48] * *(unsigned int *)&this[1].__m_.__opaque[40];
  uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)ggl::Allocator::instance(void)::alloc + 16))(ggl::Allocator::instance(void)::alloc, 80, 8);
  *(void *)uint64_t v13 = &unk_1EF5892E8;
  *(void *)(v13 + 8) = 0;
  *(void *)(v13 + 16) = 0;
  *(void *)(v13 + 24) = v11;
  char v14 = this->__m_.__opaque[9];
  unsigned __int8 v15 = this->__m_.__opaque[10];
  *(void *)(v13 + 40) = 0;
  *(void *)(v13 + 48) = 0;
  *(_DWORD *)(v13 + 64) = 0;
  *(void *)(v13 + 56) = 0;
  *(void *)(v13 + 32) = &unk_1EF560BE0;
  *(unsigned char *)(v13 + 68) = 0;
  *(unsigned char *)(v13 + 69) = v14;
  *(_WORD *)(v13 + 70) = v15;
  *(void *)(v13 + 72) = v12;
  long long v16 = *(std::__shared_weak_count **)&this->__m_.__opaque[24];
  *(void *)&this->__m_.__opaque[16] = v13 + 32;
  *(void *)&this->__m_.__opaque[24] = v13;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
LABEL_2:
  std::mutex::unlock(v6);
}

uint64_t __copy_helper_block_ea8_40c40_ZTSNSt3__110shared_ptrINS_6atomicIbEEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(result + 48) = v2;
  if (v2) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v2 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void md::SceneStateManager::updateSceneTileSet(void *a1, BOOL *a2, unsigned __int16 a3)
{
  unint64_t v5 = a1;
  uint64_t v628 = *MEMORY[0x1E4F143B8];
  unsigned __int16 v613 = a3;
  unint64_t v6 = (unsigned __int8 **)*((void *)a2 + 12);
  v602 = std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>>>::__emplace_unique_key_args<md::TileSelectionTileSetType,std::piecewise_construct_t const&,std::tuple<md::TileSelectionTileSetType const&>,std::tuple<>>(a1 + 54, a3, &v613);
  if (*((void *)a2 + 4))
  {
    int v7 = (void *)*((void *)a2 + 3);
    if (v7)
    {
      do
      {
        unsigned int v8 = (void *)*v7;
        operator delete(v7);
        int v7 = v8;
      }
      while (v8);
    }
    *((void *)a2 + 3) = 0;
    uint64_t v9 = *((void *)a2 + 2);
    if (v9)
    {
      for (uint64_t i = 0; i != v9; ++i)
        *(void *)(*((void *)a2 + 1) + 8 * i) = 0;
    }
    *((void *)a2 + 4) = 0;
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy((void *)v5[42]);
  v5[42] = 0;
  v5[43] = 0;
  v584 = (uint64_t **)(v5 + 42);
  v5[41] = v5 + 42;
  uint64_t v11 = (void *)*((void *)v602 + 5);
  uint64_t v566 = (uint64_t)(a2 + 8);
  if (v11)
  {
    unint64_t v12 = *((void *)a2 + 8);
    if (v12)
    {
      unint64_t v13 = v12 - 1;
      uint64_t v14 = *((void *)a2 + 7);
      if ((v12 & (v12 - 1)) != 0)
      {
        do
        {
          for (uint64_t j = (uint64_t *)v11[5]; j; uint64_t j = (uint64_t *)*j)
          {
            if (*((unsigned char *)j + 40))
            {
              uint64_t v27 = *((unsigned __int8 *)j + 16);
              uint64_t v28 = *((unsigned __int8 *)j + 17);
              unint64_t v29 = (v28
                   - 0x61C8864680B583EBLL
                   + ((v27 - 0x61C8864680B583EBLL) << 6)
                   + ((unint64_t)(v27 - 0x61C8864680B583EBLL) >> 2)) ^ (v27 - 0x61C8864680B583EBLL);
              uint64_t v30 = *((int *)j + 5);
              uint64_t v31 = *((int *)j + 6);
              unint64_t v32 = (v30 - 0x61C8864680B583EBLL + (v29 << 6) + (v29 >> 2)) ^ v29;
              unint64_t v33 = (v31 - 0x61C8864680B583EBLL + (v32 << 6) + (v32 >> 2)) ^ v32;
              unint64_t v34 = v33;
              if (v33 >= v12) {
                unint64_t v34 = v33 % v12;
              }
              __int16 v35 = *(uint64_t **)(v14 + 8 * v34);
              if (v35)
              {
                while (1)
                {
                  __int16 v35 = (uint64_t *)*v35;
                  if (!v35) {
                    break;
                  }
                  unint64_t v36 = v35[1];
                  if (v33 == v36)
                  {
                    if (__PAIR64__(*((unsigned __int8 *)v35 + 17), *((unsigned __int8 *)v35 + 16)) == __PAIR64__(v28, v27)
                      && *(uint64_t *)((char *)v35 + 20) == __PAIR64__(v31, v30))
                    {
LABEL_28:
                      char v564 = 0;
                      goto LABEL_47;
                    }
                  }
                  else
                  {
                    if (v36 >= v12) {
                      v36 %= v12;
                    }
                    if (v36 != v34) {
                      break;
                    }
                  }
                }
              }
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
      else
      {
        do
        {
          for (uint64_t k = (uint64_t *)v11[5]; k; uint64_t k = (uint64_t *)*k)
          {
            if (*((unsigned char *)k + 40))
            {
              uint64_t v17 = *((unsigned __int8 *)k + 16);
              uint64_t v18 = *((unsigned __int8 *)k + 17);
              unint64_t v19 = (v18
                   - 0x61C8864680B583EBLL
                   + ((v17 - 0x61C8864680B583EBLL) << 6)
                   + ((unint64_t)(v17 - 0x61C8864680B583EBLL) >> 2)) ^ (v17 - 0x61C8864680B583EBLL);
              uint64_t v20 = *((int *)k + 5);
              uint64_t v21 = *((int *)k + 6);
              unint64_t v22 = (v20 - 0x61C8864680B583EBLL + (v19 << 6) + (v19 >> 2)) ^ v19;
              uint64_t v23 = (v21 - 0x61C8864680B583EBLL + (v22 << 6) + (v22 >> 2)) ^ v22;
              uint64_t v24 = *(uint64_t **)(v14 + 8 * (v23 & v13));
              if (v24)
              {
                while (1)
                {
                  uint64_t v24 = (uint64_t *)*v24;
                  if (!v24) {
                    break;
                  }
                  uint64_t v25 = v24[1];
                  if (v23 == v25)
                  {
                    if (__PAIR64__(*((unsigned __int8 *)v24 + 17), *((unsigned __int8 *)v24 + 16)) == __PAIR64__(v18, v17)
                      && *(uint64_t *)((char *)v24 + 20) == __PAIR64__(v21, v20))
                    {
                      goto LABEL_28;
                    }
                  }
                  else if ((v25 & v13) != (v23 & v13))
                  {
                    break;
                  }
                }
              }
            }
          }
          uint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
    else
    {
      do
      {
        for (m = (void *)v11[5]; m; m = (void *)*m)
          ;
        uint64_t v11 = (void *)*v11;
      }
      while (v11);
    }
  }
  char v564 = 1;
LABEL_47:
  *(_OWORD *)std::string __p = 0u;
  *(_OWORD *)v611 = 0u;
  float v612 = 1.0;
  int v38 = *v6;
  __int16 v37 = v6[1];
  uint64_t v39 = *v6;
  if (*v6 != v37)
  {
    char v40 = v38 + 144;
    int v41 = *v6;
    while (v40 != v37)
    {
      uint64_t v39 = v40;
      v41 += 144;
      if (v40[112] != v38[112] || v40[113] != v38[113] || *((_DWORD *)v40 + 29) != *((_DWORD *)v38 + 29))
      {
        uint64_t v39 = v41;
        goto LABEL_57;
      }
      v40 += 144;
      if (*((_DWORD *)v39 + 30) != *((_DWORD *)v38 + 30)) {
        goto LABEL_57;
      }
    }
    uint64_t v39 = v6[1];
  }
LABEL_57:
  v565 = a2;
  uint64_t v595 = (uint64_t)(v5 + 44);
  uint64_t v596 = (uint64_t)(v5 + 49);
  v568 = (unsigned __int16 **)(v6 + 3);
  v570 = v6 + 6;
  uint64_t v42 = v6[1];
  v593 = v5;
  v597 = v6;
  v580 = v42;
LABEL_60:
  if (v38 != v42)
  {
    uint64_t v44 = v38[113];
    uint64_t v45 = v38[112];
    uint64_t v46 = *(void *)(v38 + 116);
    LOBYTE(v617) = 0;
    char v623 = 0;
    int v588 = v45;
    unint64_t v47 = (v44
         - 0x61C8864680B583EBLL
         + ((v45 - 0x61C8864680B583EBLL) << 6)
         + ((unint64_t)(v45 - 0x61C8864680B583EBLL) >> 2)) ^ (v45 - 0x61C8864680B583EBLL);
    int v586 = v46;
    unint64_t v48 = ((int)v46 - 0x61C8864680B583EBLL + (v47 << 6) + (v47 >> 2)) ^ v47;
    unint64_t v598 = (SHIDWORD(v46) - 0x61C8864680B583EBLL + (v48 << 6) + (v48 >> 2)) ^ v48;
    int v585 = HIDWORD(v46);
    unsigned int v591 = v44;
    unsigned int v582 = vcvtmd_s64_f64((double)SHIDWORD(v46) / (double)(1 << v44));
    while (1)
    {
      if (v38 == v39)
      {
        if (v623 && *((long long **)&v617 + 1) != v619) {
          free(*((void **)&v617 + 1));
        }
        long long v43 = v580;
        if (v580 != v39)
        {
          float v201 = v39 + 144;
          long long v43 = v39;
          while (1)
          {
            if (v201 == v580)
            {
              long long v43 = v580;
              goto LABEL_59;
            }
            if (v201[112] != v39[112]) {
              break;
            }
            v43 += 144;
            if (v201[113] == v39[113] && *((_DWORD *)v201 + 29) == *((_DWORD *)v39 + 29))
            {
              int v202 = *((_DWORD *)v201 + 30);
              v201 += 144;
              if (v202 == *((_DWORD *)v39 + 30)) {
                continue;
              }
            }
            goto LABEL_59;
          }
          long long v43 = v201;
        }
LABEL_59:
        uint64_t v42 = v6[1];
        int v38 = v39;
        uint64_t v39 = v43;
        goto LABEL_60;
      }
      BOOL v50 = (long long *)(v38 + 8);
      unint64_t v49 = *((unsigned __int16 *)v38 + 4);
      int v51 = *v38;
      LOWORD(v614[0]) = *((_WORD *)v38 + 4);
      unint64_t v52 = (int8x8_t *)v5[59];
      int8x8_t v53 = v52[17];
      if (!*(void *)&v53) {
        goto LABEL_96;
      }
      uint8x8_t v54 = (uint8x8_t)vcnt_s8(v53);
      v54.i16[0] = vaddlv_u8(v54);
      if (v54.u32[0] > 1uLL)
      {
        unint64_t v55 = v49;
        if (*(void *)&v53 <= v49) {
          unint64_t v55 = v49 % *(void *)&v53;
        }
      }
      else
      {
        unint64_t v55 = (v53.i32[0] - 1) & v49;
      }
      uint64_t v61 = *(uint64_t ***)(*(void *)&v52[16] + 8 * v55);
      if (!v61 || (long long v62 = *v61) == 0)
      {
LABEL_96:
        BOOL v600 = 0;
        goto LABEL_97;
      }
      if (v54.u32[0] < 2uLL)
      {
        uint64_t v63 = *(void *)&v53 - 1;
        while (1)
        {
          uint64_t v65 = v62[1];
          if (v65 == v49)
          {
            if (*((unsigned __int16 *)v62 + 8) == v49) {
              goto LABEL_120;
            }
          }
          else if ((v65 & v63) != v55)
          {
            goto LABEL_96;
          }
          long long v62 = (uint64_t *)*v62;
          if (!v62) {
            goto LABEL_96;
          }
        }
      }
      while (1)
      {
        unint64_t v64 = v62[1];
        if (v64 == v49) {
          break;
        }
        if (v64 >= *(void *)&v53) {
          v64 %= *(void *)&v53;
        }
        if (v64 != v55) {
          goto LABEL_96;
        }
LABEL_86:
        long long v62 = (uint64_t *)*v62;
        if (!v62) {
          goto LABEL_96;
        }
      }
      if (*((unsigned __int16 *)v62 + 8) != v49) {
        goto LABEL_86;
      }
LABEL_120:
      BOOL v600 = *((unsigned char *)v62 + 18) == 0;
LABEL_97:
      int8x8_t v66 = *(int8x8_t *)(v602 + 16);
      if (!*(void *)&v66) {
        goto LABEL_168;
      }
      uint8x8_t v67 = (uint8x8_t)vcnt_s8(v66);
      v67.i16[0] = vaddlv_u8(v67);
      if (v67.u32[0] > 1uLL)
      {
        unint64_t v68 = v49;
        if (*(void *)&v66 <= v49) {
          unint64_t v68 = v49 % *(void *)&v66;
        }
      }
      else
      {
        unint64_t v68 = (v66.i32[0] - 1) & v49;
      }
      uint64_t v69 = *((void *)v602 + 3);
      uint64_t v70 = *(uint64_t ****)(v69 + 8 * v68);
      if (!v70) {
        goto LABEL_168;
      }
      uint64_t v71 = *v70;
      if (!*v70) {
        goto LABEL_168;
      }
      uint64_t v72 = *(void *)&v66 - 1;
      if (v67.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v73 = v71[1];
          if (v73 == (uint64_t *)v49)
          {
            if (*((unsigned __int16 *)v71 + 8) == v49) {
              goto LABEL_118;
            }
          }
          else if (((unint64_t)v73 & v72) != v68)
          {
            goto LABEL_168;
          }
          uint64_t v71 = (uint64_t **)*v71;
          if (!v71) {
            goto LABEL_168;
          }
        }
      }
      while (2)
      {
        unint64_t v74 = (unint64_t)v71[1];
        if (v74 != v49)
        {
          if (v74 >= *(void *)&v66) {
            v74 %= *(void *)&v66;
          }
          if (v74 != v68) {
            goto LABEL_168;
          }
          goto LABEL_112;
        }
        if (*((unsigned __int16 *)v71 + 8) != v49)
        {
LABEL_112:
          uint64_t v71 = (uint64_t **)*v71;
          if (!v71) {
            goto LABEL_168;
          }
          continue;
        }
        break;
      }
LABEL_118:
      if (v67.u32[0] > 1uLL)
      {
        unint64_t v75 = v49;
        if (*(void *)&v66 <= v49) {
          unint64_t v75 = v49 % *(void *)&v66;
        }
      }
      else
      {
        unint64_t v75 = (v66.i32[0] - 1) & v49;
      }
      uint64_t v76 = *(int8x8_t ***)(v69 + 8 * v75);
      if (!v76 || (uint64_t v77 = *v76) == 0) {
LABEL_1061:
      }
        abort();
      if (v67.u32[0] < 2uLL)
      {
        while (1)
        {
          int8x8_t v78 = v77[1];
          if (*(void *)&v78 == v49)
          {
            if (v77[2].u16[0] == v49) {
              goto LABEL_131;
            }
          }
          else if ((*(void *)&v78 & v72) != v75)
          {
            goto LABEL_1061;
          }
          uint64_t v77 = (int8x8_t *)*v77;
          if (!v77) {
            goto LABEL_1061;
          }
        }
      }
      while (2)
      {
        int8x8_t v82 = v77[1];
        if (*(void *)&v82 != v49)
        {
          if (*(void *)&v82 >= *(void *)&v66) {
            *(void *)&v82 %= *(void *)&v66;
          }
          if (*(void *)&v82 != v75) {
            goto LABEL_1061;
          }
LABEL_135:
          uint64_t v77 = (int8x8_t *)*v77;
          if (!v77) {
            goto LABEL_1061;
          }
          continue;
        }
        break;
      }
      if (v77[2].u16[0] != v49) {
        goto LABEL_135;
      }
LABEL_131:
      int8x8_t v79 = v77[4];
      if (!*(void *)&v79) {
        goto LABEL_168;
      }
      uint8x8_t v80 = (uint8x8_t)vcnt_s8(v79);
      v80.i16[0] = vaddlv_u8(v80);
      if (v80.u32[0] > 1uLL)
      {
        unint64_t v81 = v598;
        if (v598 >= *(void *)&v79) {
          unint64_t v81 = v598 % *(void *)&v79;
        }
      }
      else
      {
        unint64_t v81 = v598 & (*(void *)&v79 - 1);
      }
      int v83 = *(uint64_t ***)(*(void *)&v77[3] + 8 * v81);
      if (!v83) {
        goto LABEL_168;
      }
      uint64_t v84 = *v83;
      if (!v84) {
        goto LABEL_168;
      }
      if (v80.u32[0] < 2uLL)
      {
        uint64_t v85 = *(void *)&v79 - 1;
        while (1)
        {
          uint64_t v87 = v84[1];
          if (v598 == v87)
          {
            if (*((unsigned __int8 *)v84 + 16) == v588
              && *((unsigned __int8 *)v84 + 17) == v591
              && *((_DWORD *)v84 + 5) == v586
              && *((_DWORD *)v84 + 6) == v585)
            {
              goto LABEL_164;
            }
          }
          else if ((v87 & v85) != v81)
          {
            goto LABEL_168;
          }
          uint64_t v84 = (uint64_t *)*v84;
          if (!v84) {
            goto LABEL_168;
          }
        }
      }
      while (2)
      {
        unint64_t v86 = v84[1];
        if (v598 != v86)
        {
          if (v86 >= *(void *)&v79) {
            v86 %= *(void *)&v79;
          }
          if (v86 != v81) {
            goto LABEL_168;
          }
LABEL_148:
          uint64_t v84 = (uint64_t *)*v84;
          if (!v84) {
            goto LABEL_168;
          }
          continue;
        }
        break;
      }
      if (*((unsigned __int8 *)v84 + 16) != v588
        || *((unsigned __int8 *)v84 + 17) != v591
        || *((_DWORD *)v84 + 5) != v586
        || *((_DWORD *)v84 + 6) != v585)
      {
        goto LABEL_148;
      }
LABEL_164:
      uint64_t v88 = v84[5];
      if ((_BYTE)v88)
      {
        char v89 = std::__hash_table<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::__unordered_map_hasher<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,gdc::LayerDataRequestKeyHash,std::equal_to<gdc::LayerDataRequestKey>,true>,std::__unordered_map_equal<gdc::LayerDataRequestKey,std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>,std::equal_to<gdc::LayerDataRequestKey>,gdc::LayerDataRequestKeyHash,true>,std::allocator<std::__hash_value_type<gdc::LayerDataRequestKey,std::tuple<md::DaVinciGroundRenderable *,gdc::Entity>>>>::find<gdc::LayerDataRequestKey>(v570, v38);
        if (v89)
        {
          unint64_t v90 = (unint64_t)v89[16];
          uint64_t v91 = geo::linear_map<unsigned short,std::vector<gdc::LayerDataHolder>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>,std::vector<std::pair<unsigned short,std::vector<gdc::LayerDataHolder>>>>::operator[](v568, v49);
          if (0x8E38E38E38E38E39 * ((uint64_t)(*((void *)v91 + 1) - *(void *)v91) >> 4) > v90)
          {
            *(void *)(*(void *)v91 + 144 * v90 + 136) |= v88;
            goto LABEL_168;
          }
          goto LABEL_1062;
        }
      }
LABEL_168:
      unint64_t v92 = *((void *)v38 + 17);
      uint64_t v93 = (unsigned __int16 *)v6[3];
      uint64_t v94 = (unsigned __int16 *)v6[4];
      uint64_t v95 = v93;
      if (v93 != v94)
      {
        uint64_t v95 = (unsigned __int16 *)v6[3];
        while (*v95 != v49)
        {
          v95 += 16;
          if (v95 == v94) {
            goto LABEL_177;
          }
        }
      }
      if (v95 == v94)
      {
LABEL_177:
        unint64_t v3 = 0;
        if (v93 != v94)
        {
LABEL_178:
          while (*v93 != v49)
          {
            v93 += 16;
            if (v93 == v94)
            {
              uint64_t v93 = (unsigned __int16 *)v6[4];
              break;
            }
          }
        }
      }
      else
      {
        long long v97 = v95 + 4;
        uint64_t v96 = *((void *)v95 + 1);
        if (0x8E38E38E38E38E39 * ((*((void *)v97 + 1) - v96) >> 4) <= v92) {
          goto LABEL_1062;
        }
        unint64_t v3 = *(unsigned int *)(v96 + 144 * v92 + 128);
        if (v93 != v94) {
          goto LABEL_178;
        }
      }
      long long v99 = v93 + 4;
      uint64_t v98 = *((void *)v93 + 1);
      if (0x8E38E38E38E38E39 * ((*((void *)v99 + 1) - v98) >> 4) <= v92) {
LABEL_1062:
      }
        abort();
      uint64_t v100 = *(unsigned __int8 *)(v98 + 144 * v92 + 136);
      if (v3 != 3) {
        goto LABEL_63;
      }
      if (*(unsigned char *)(v98 + 144 * v92 + 136))
      {
        if (!v623) {
          goto LABEL_62;
        }
        goto LABEL_185;
      }
      if (!v623
        || (int v112 = (unsigned __int16)v617, (unsigned __int16)v617 != *(unsigned __int16 *)v50)
        || (long long v113 = (uint64_t *)v622, (void)v622 != *((void *)v38 + 10))
        || (long long v114 = &v618[-*((void *)&v617 + 1)],
            uint64_t v115 = (const void *)*((void *)v38 + 2),
            &v618[-*((void *)&v617 + 1)] != (char *)(*((void *)v38 + 3) - (void)v115))
        || (__s2 = (void *)*((void *)v38 + 2),
            memcmp(*((const void **)&v617 + 1), v115, (size_t)&v618[-*((void *)&v617 + 1)])))
      {
        if (!v600) {
          goto LABEL_312;
        }
        uint64_t v116 = *((void *)v38 + 2);
        unsigned int v117 = *(unsigned __int8 *)(v116 + 8);
        unsigned int v118 = v591;
        int v119 = v586;
        int v120 = v585;
        if (v591 <= v117)
        {
          int v120 = *(_DWORD *)v116;
          if (vcvtmd_s64_f64((double)*(int *)v116 / (double)(1 << v117)) == v582)
          {
            int v119 = *(_DWORD *)(v116 + 4);
            unsigned int v118 = *(unsigned __int8 *)(v116 + 8);
          }
          else
          {
            unsigned int v118 = v591;
            int v119 = v586;
            int v120 = v585;
          }
        }
        v604 &= 0xFFFFFFFFFFFF0000;
        if (v118 <= 0x1E
          && ((int v121 = 1 << v118, v122 = vcvtmd_s64_f64((double)v120 / (double)(1 << v118)), v122 >= 0)
            ? (unsigned int v123 = v122)
            : (unsigned int v123 = -v122),
              v123 <= 0x7F))
        {
          v604 |= v118 & 0xFFFF00FF | (v122 << 8);
          v125.i64[0] = ((v120 % v121 + v121) % v121) | ((unint64_t)((v120 % v121 + v121) % v121) << 16);
          v125.i64[1] = ((v119 % v121 + v121) % v121) | ((unint64_t)((v119 % v121 + v121) % v121) << 16);
          v126.i64[0] = 0xFFFF0000FFFFLL;
          v126.i64[1] = 0xFFFF0000FFFFLL;
          int64x2_t v127 = (int64x2_t)vandq_s8(v125, v126);
          unsigned long long v128 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64(v127, 8uLL), (int8x16_t)v127) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
          unsigned long long v129 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v128, 4uLL), (int8x16_t)v128) & __PAIR128__(0xFF0FFF0FFF0FFF0FLL, 0xFF0FFF0FFF0FFF0FLL);
          v126.i64[0] = 0x3333333333333333;
          v126.i64[1] = 0x3333333333333333;
          int8x16_t v130 = vandq_s8(vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v129, 2uLL), (int8x16_t)v129), v126);
          int8x16_t v131 = (int8x16_t)vshlq_u64((uint64x2_t)v130, (uint64x2_t)xmmword_1A28FC6E0);
          v130.i64[1] *= 2;
          int64x2_t v132 = (int64x2_t)vandq_s8(vorrq_s8(v131, v130), (int8x16_t)xmmword_1A28FC6F0);
          unint64_t v124 = vorrq_s8((int8x16_t)v132, (int8x16_t)vdupq_laneq_s64(v132, 1)).u64[0];
        }
        else
        {
          unint64_t v124 = 0;
        }
        long long v133 = v584;
        unint64_t v134 = *v584;
        unint64_t v135 = v584;
        if (!*v584)
        {
LABEL_246:
          long long v139 = (uint64_t *)operator new(0x40uLL);
          v139[4] = v124;
          v139[5] = v604;
          v139[6] = 0;
          v139[7] = 0;
          *long long v139 = 0;
          v139[1] = 0;
          v139[2] = (uint64_t)v135;
          *long long v133 = v139;
          unint64_t v5 = v593;
          uint64_t v140 = *(void *)v593[41];
          unint64_t v141 = v139;
          if (v140)
          {
            v593[41] = v140;
            unint64_t v141 = *v133;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>((uint64_t *)v593[42], v141);
          ++v593[43];
LABEL_250:
          unint64_t v6 = v597;
          uint64_t v100 = 0;
          if (v49 >= 0x52) {
            abort();
          }
          *(uint64_t *)((char *)v139 + ((v49 >> 3) & 0x1FF8) + 48) |= 1 << v49;
          if (!v623) {
            goto LABEL_62;
          }
          goto LABEL_185;
        }
        while (2)
        {
          while (2)
          {
            unint64_t v135 = (uint64_t **)v134;
            unsigned int v136 = *((unsigned __int8 *)v134 + 40);
            if (v136 > v604)
            {
              int v137 = *((unsigned __int8 *)v135 + 41);
              if (BYTE1(v604) == v137)
              {
                int v137 = BYTE1(v604);
                if (v124 <= (unint64_t)v135[4] >> (2 * (v136 - v604))) {
                  goto LABEL_216;
                }
              }
              else if (SBYTE1(v604) < (char)v137)
              {
                goto LABEL_216;
              }
              break;
            }
            int v137 = *((unsigned __int8 *)v135 + 41);
            if (v136 >= v604)
            {
              if (v137 != BYTE1(v604)) {
                goto LABEL_230;
              }
              int v137 = BYTE1(v604);
              if (v124 < (unint64_t)v135[4]) {
                goto LABEL_216;
              }
            }
            else
            {
              if (v137 == BYTE1(v604))
              {
                int v137 = BYTE1(v604);
                if (v124 >> (2 * (v604 - v136)) < (unint64_t)v135[4]) {
                  goto LABEL_216;
                }
                break;
              }
LABEL_230:
              if ((char)v137 > SBYTE1(v604))
              {
LABEL_216:
                unint64_t v134 = *v135;
                long long v133 = v135;
                if (!*v135) {
                  goto LABEL_246;
                }
                continue;
              }
            }
            break;
          }
          if (v136 >= v604)
          {
            if (v136 > v604)
            {
              int v138 = *((unsigned __int8 *)v135 + 41);
              if (BYTE1(v604) == v138)
              {
                if ((unint64_t)v135[4] >> (2 * (v136 - v604)) >= v124) {
                  goto LABEL_249;
                }
              }
              else if (SBYTE1(v604) <= (char)v138)
              {
LABEL_249:
                long long v139 = (uint64_t *)v135;
                unint64_t v5 = v593;
                goto LABEL_250;
              }
              goto LABEL_245;
            }
            if (v137 == BYTE1(v604))
            {
              if ((unint64_t)v135[4] >= v124) {
                goto LABEL_249;
              }
              goto LABEL_245;
            }
          }
          else if (v137 == BYTE1(v604))
          {
            if ((unint64_t)v135[4] > v124 >> (2 * (v604 - v136))) {
              goto LABEL_249;
            }
LABEL_245:
            long long v133 = v135 + 1;
            unint64_t v134 = v135[1];
            if (!v134) {
              goto LABEL_246;
            }
            continue;
          }
          break;
        }
        if ((char)v137 >= SBYTE1(v604)) {
          goto LABEL_249;
        }
        goto LABEL_245;
      }
      size_t __n = (size_t)v114;
      unint64_t v151 = *((void *)v38 + 11);
      unint64_t v578 = (unint64_t)__p[1];
      if (!__p[1]) {
        goto LABEL_315;
      }
      uint8x8_t v152 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
      v152.i16[0] = vaddlv_u8(v152);
      if (v152.u32[0] > 1uLL)
      {
        unint64_t v49 = *((void *)v38 + 11);
        if ((void *)v151 >= __p[1]) {
          unint64_t v49 = v151 % (unint64_t)__p[1];
        }
      }
      else
      {
        unint64_t v49 = ((unint64_t)__p[1] - 1) & v151;
      }
      int v166 = (uint64_t ***)*((void *)__p[0] + v49);
      if (!v166 || (uint64_t v167 = *v166) == 0)
      {
LABEL_314:
        unint64_t v5 = v593;
LABEL_315:
        float32x4_t v174 = operator new(0x68uLL);
        v624 = v174;
        v625 = (int8x8_t *)v611;
        *float32x4_t v174 = 0;
        v174[1] = v151;
        gdc::LayerDataKey::LayerDataKey((uint64_t)(v174 + 2), (uint64_t)(v38 + 8));
        char v626 = 1;
        float v175 = (float)((unint64_t)v611[1] + 1);
        unint64_t v6 = v597;
        uint64_t v100 = 0;
        unint64_t v176 = v578;
        if (!v578 || (float)(v612 * (float)v578) < v175)
        {
          BOOL v177 = (v578 & (v578 - 1)) != 0;
          if (v578 < 3) {
            BOOL v177 = 1;
          }
          unint64_t v178 = v177 | (2 * v578);
          unint64_t v179 = vcvtps_u32_f32(v175 / v612);
          if (v178 <= v179) {
            size_t prime = v179;
          }
          else {
            size_t prime = v178;
          }
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
          }
          if ((void *)prime > __p[1])
          {
LABEL_327:
            if (!(prime >> 61))
            {
              uint64_t v181 = operator new(8 * prime);
              float32x4_t v182 = __p[0];
              __p[0] = v181;
              if (v182) {
                operator delete(v182);
              }
              uint64_t v183 = 0;
              __p[1] = (void *)prime;
              do
                *((void *)__p[0] + v183++) = 0;
              while (prime != v183);
              uint64_t v184 = (void **)v611[0];
              if (!v611[0]) {
                goto LABEL_352;
              }
              size_t v185 = *((void *)v611[0] + 1);
              size_t v186 = prime - 1;
              if ((prime & (prime - 1)) == 0)
              {
                size_t v187 = v185 & v186;
                *((void *)__p[0] + v187) = v611;
                for (n = *v184; *v184; n = *v184)
                {
                  size_t v189 = n[1] & v186;
                  if (v189 == v187)
                  {
                    uint64_t v184 = (void **)n;
                  }
                  else if (*((void *)__p[0] + v189))
                  {
                    void *v184 = (void *)*n;
                    uint64_t v190 = 8 * v189;
                    void *n = **(void **)((char *)__p[0] + v190);
                    **(void **)((char *)__p[0] + v190) = n;
                  }
                  else
                  {
                    *((void *)__p[0] + v189) = v184;
                    uint64_t v184 = (void **)n;
                    size_t v187 = v189;
                  }
                }
                goto LABEL_352;
              }
              if (v185 >= prime) {
                v185 %= prime;
              }
              *((void *)__p[0] + v185) = v611;
              uint64_t v194 = *v184;
              if (!*v184)
              {
LABEL_352:
                unint64_t v176 = prime;
                goto LABEL_353;
              }
              while (2)
              {
                size_t v196 = v194[1];
                if (v196 >= prime) {
                  v196 %= prime;
                }
                if (v196 != v185)
                {
                  if (!*((void *)__p[0] + v196))
                  {
                    *((void *)__p[0] + v196) = v184;
LABEL_357:
                    uint64_t v184 = (void **)v194;
                    uint64_t v194 = (void *)*v194;
                    size_t v185 = v196;
                    if (!v194) {
                      goto LABEL_352;
                    }
                    continue;
                  }
                  void *v184 = (void *)*v194;
                  uint64_t v195 = 8 * v196;
                  *uint64_t v194 = **(void **)((char *)__p[0] + v195);
                  **(void **)((char *)__p[0] + v195) = v194;
                  uint64_t v194 = v184;
                }
                break;
              }
              size_t v196 = v185;
              goto LABEL_357;
            }
LABEL_1065:
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          if ((void *)prime >= __p[1])
          {
            unint64_t v176 = (unint64_t)__p[1];
          }
          else
          {
            unint64_t v191 = vcvtps_u32_f32((float)(unint64_t)v611[1] / v612);
            if (__p[1] < (void *)3
              || (uint8x8_t v192 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]), v192.i16[0] = vaddlv_u8(v192), v192.u32[0] > 1uLL))
            {
              unint64_t v191 = std::__next_prime(v191);
            }
            else
            {
              uint64_t v193 = 1 << -(char)__clz(v191 - 1);
              if (v191 >= 2) {
                unint64_t v191 = v193;
              }
            }
            if (prime <= v191) {
              size_t prime = v191;
            }
            if ((void *)prime >= __p[1])
            {
              unint64_t v176 = (unint64_t)__p[1];
            }
            else
            {
              if (prime) {
                goto LABEL_327;
              }
              uint64_t v200 = __p[0];
              __p[0] = 0;
              if (v200) {
                operator delete(v200);
              }
              unint64_t v176 = 0;
              __p[1] = 0;
            }
          }
LABEL_353:
          if ((v176 & (v176 - 1)) != 0)
          {
            if (v151 >= v176) {
              unint64_t v49 = v151 % v176;
            }
            else {
              unint64_t v49 = v151;
            }
          }
          else
          {
            unint64_t v49 = (v176 - 1) & v151;
          }
        }
        uint64_t v197 = (void *)*((void *)__p[0] + v49);
        float v198 = v624;
        if (v197)
        {
          void *v624 = *v197;
          goto LABEL_374;
        }
        void *v624 = v611[0];
        v611[0] = v198;
        *((void *)__p[0] + v49) = v611;
        if (*(void *)v198)
        {
          unint64_t v199 = *(void *)(*(void *)v198 + 8);
          if ((v176 & (v176 - 1)) != 0)
          {
            if (v199 >= v176) {
              v199 %= v176;
            }
          }
          else
          {
            v199 &= v176 - 1;
          }
          uint64_t v197 = (char *)__p[0] + 8 * v199;
LABEL_374:
          *uint64_t v197 = v198;
        }
        ++v611[1];
        if (!v623) {
          goto LABEL_62;
        }
        goto LABEL_185;
      }
      if (v152.u32[0] < 2uLL)
      {
        unint64_t v168 = (unint64_t)__p[1] - 1;
        while (1)
        {
          unint64_t v171 = (unint64_t)v167[1];
          if (v171 == v151)
          {
            if (*((unsigned __int16 *)v167 + 8) == v112 && v167[11] == v113)
            {
              float v172 = v167[3];
              if ((char *)v167[4] - (char *)v172 == __n)
              {
                int v173 = memcmp(v172, __s2, __n);
                unint64_t v168 = (unint64_t)__p[1] - 1;
                if (!v173) {
                  goto LABEL_311;
                }
              }
            }
          }
          else if ((v171 & v168) != v49)
          {
            goto LABEL_314;
          }
          uint64_t v167 = (uint64_t **)*v167;
          if (!v167) {
            goto LABEL_314;
          }
        }
      }
      while (2)
      {
        unint64_t v169 = (unint64_t)v167[1];
        if (v169 != v151)
        {
          if ((void *)v169 >= __p[1]) {
            v169 %= (unint64_t)__p[1];
          }
          if (v169 != v49) {
            goto LABEL_314;
          }
LABEL_295:
          uint64_t v167 = (uint64_t **)*v167;
          if (!v167) {
            goto LABEL_314;
          }
          continue;
        }
        break;
      }
      if (*((unsigned __int16 *)v167 + 8) != v112) {
        goto LABEL_295;
      }
      if (v167[11] != v113) {
        goto LABEL_295;
      }
      long long v170 = v167[3];
      if ((char *)v167[4] - (char *)v170 != __n || memcmp(v170, __s2, __n)) {
        goto LABEL_295;
      }
LABEL_311:
      unint64_t v5 = v593;
LABEL_312:
      unint64_t v6 = v597;
      uint64_t v100 = 0;
      if (!v623)
      {
LABEL_62:
        gdc::LayerDataKey::LayerDataKey((uint64_t)&v617, (uint64_t)(v38 + 8));
        char v623 = 1;
        goto LABEL_63;
      }
LABEL_185:
      LOWORD(v617) = *((_WORD *)v38 + 4);
      if (&v617 == v50) {
        goto LABEL_287;
      }
      if (*((long long **)&v617 + 1) != v619) {
        free(*((void **)&v617 + 1));
      }
      uint64_t v101 = v621;
      *((void *)&v617 + 1) = v621;
      v618 = v621;
      v619 = (long long *)v621;
      uint64_t v620 = 32;
      BOOL v103 = (char *)*((void *)v38 + 2);
      float v102 = (char *)*((void *)v38 + 3);
      unint64_t v104 = v102 - v103;
      if ((unint64_t)(v102 - v103) < 0x21) {
        goto LABEL_268;
      }
      uint64_t v105 = v100;
      if (v104 <= 0x40) {
        size_t v106 = 64;
      }
      else {
        size_t v106 = v102 - v103;
      }
      uint64_t v101 = malloc_type_malloc(v106, 0x100004077774924uLL);
      char v107 = (char *)*((void *)&v617 + 1);
      char v108 = v618;
      if (*((char **)&v617 + 1) == v618) {
        goto LABEL_267;
      }
      unint64_t v109 = (unint64_t)&v618[-*((void *)&v617 + 1)];
      if ((unint64_t)&v618[-*((void *)&v617 + 1)] < 8)
      {
        uint64_t v110 = v101;
        goto LABEL_266;
      }
      uint64_t v110 = v101;
      if ((unint64_t)&v101[-*((void *)&v617 + 1)] < 0x20) {
        goto LABEL_266;
      }
      if (v109 >= 0x20)
      {
        unint64_t v111 = v109 & 0xFFFFFFFFFFFFFFE0;
        uint64_t v142 = (long long *)(*((void *)&v617 + 1) + 16);
        long long v143 = v101 + 16;
        unint64_t v144 = v109 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v145 = *v142;
          *(v143 - 1) = *(v142 - 1);
          _OWORD *v143 = v145;
          v142 += 2;
          v143 += 2;
          v144 -= 32;
        }
        while (v144);
        if (v109 == v111) {
          goto LABEL_267;
        }
        if ((v109 & 0x18) != 0) {
          goto LABEL_258;
        }
        v107 += v111;
        uint64_t v110 = &v101[v111];
        do
        {
LABEL_266:
          char v153 = *v107++;
          *v110++ = v153;
        }
        while (v107 != v108);
        goto LABEL_267;
      }
      unint64_t v111 = 0;
LABEL_258:
      unint64_t v146 = v109 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v110 = &v101[v109 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v147 = v111 - (v109 & 0xFFFFFFFFFFFFFFF8);
      uint64_t v148 = (uint64_t *)&v107[v111];
      uint64_t v149 = &v101[v111];
      do
      {
        uint64_t v150 = *v148++;
        *v149++ = v150;
        v147 += 8;
      }
      while (v147);
      if (v109 != v146)
      {
        v107 += v146;
        goto LABEL_266;
      }
LABEL_267:
      *((void *)&v617 + 1) = v101;
      v618 = v101;
      uint64_t v620 = v106;
      uint64_t v100 = v105;
LABEL_268:
      if (v103 == v102) {
        goto LABEL_286;
      }
      if (v104 < 8)
      {
        uint64_t v155 = v101;
        goto LABEL_284;
      }
      if ((unint64_t)(v101 - v103) < 0x20)
      {
        uint64_t v155 = v101;
        goto LABEL_284;
      }
      if (v104 >= 0x20)
      {
        unint64_t v154 = v104 & 0xFFFFFFFFFFFFFFE0;
        std::string::size_type v156 = (long long *)(v103 + 16);
        long long v157 = v101 + 16;
        unint64_t v158 = v104 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v159 = *v156;
          *(v157 - 1) = *(v156 - 1);
          *long long v157 = v159;
          v156 += 2;
          v157 += 2;
          v158 -= 32;
        }
        while (v158);
        if (v104 == v154) {
          goto LABEL_285;
        }
        if ((v104 & 0x18) != 0) {
          goto LABEL_279;
        }
        v103 += v154;
        uint64_t v155 = &v101[v154];
        do
        {
LABEL_284:
          char v165 = *v103++;
          *v155++ = v165;
        }
        while (v103 != v102);
        goto LABEL_285;
      }
      unint64_t v154 = 0;
LABEL_279:
      unint64_t v160 = v104 & 0xFFFFFFFFFFFFFFF8;
      uint64_t v155 = &v101[v104 & 0xFFFFFFFFFFFFFFF8];
      unint64_t v161 = v154 - (v104 & 0xFFFFFFFFFFFFFFF8);
      long long v162 = (uint64_t *)&v103[v154];
      uint64_t v163 = &v101[v154];
      do
      {
        uint64_t v164 = *v162++;
        *v163++ = v164;
        v161 += 8;
      }
      while (v161);
      if (v104 != v160)
      {
        v103 += v160;
        goto LABEL_284;
      }
LABEL_285:
      uint64_t v101 = v618;
LABEL_286:
      v618 = &v101[v104];
      unint64_t v6 = v597;
LABEL_287:
      long long v622 = *((_OWORD *)v38 + 5);
LABEL_63:
      if (!v51)
      {
        BOOL v56 = v3 == 2 || v100 == 0;
        if (v56) {
          int v57 = v3;
        }
        else {
          int v57 = 1;
        }
        LODWORD(v624) = v57;
        if (v600) {
          uint64_t v58 = v596;
        }
        else {
          uint64_t v58 = v595;
        }
        unint64_t v59 = std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus const&>,std::tuple<>>(v58, v57, &v624);
        uint64_t v60 = std::__hash_table<std::__hash_value_type<md::MapDataType,unsigned long>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,unsigned long>,std::hash<md::MapDataType>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,unsigned long>,std::equal_to<md::MapDataType>,std::hash<md::MapDataType>,true>,std::allocator<std::__hash_value_type<md::MapDataType,unsigned long>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>((float *)v59 + 6, v614[0], v614);
        ++v60[3];
      }
      v38 += 144;
    }
  }
  unint64_t v203 = (uint64_t **)v5[41];
  if (v203 != v584)
  {
    do
    {
      uint32_t v208 = v203[1];
      std::string::size_type v209 = v208;
      int v210 = (uint64_t *)v203;
      if (v208)
      {
        do
        {
          BOOL v211 = (uint64_t **)v209;
          std::string::size_type v209 = (uint64_t *)*v209;
        }
        while (v209);
      }
      else
      {
        do
        {
          BOOL v211 = (uint64_t **)v210[2];
          BOOL v56 = *v211 == v210;
          int v210 = (uint64_t *)v211;
        }
        while (!v56);
      }
      if (v211 != v584)
      {
        int v212 = *((unsigned __int8 *)v203 + 41);
        unsigned int v213 = *((unsigned __int8 *)v203 + 40);
        uint64_t v214 = v203[4];
        do
        {
          if (v212 != *((unsigned __int8 *)v211 + 41)) {
            break;
          }
          unsigned int v215 = *((unsigned __int8 *)v211 + 40);
          BOOL v507 = v215 >= v213;
          unsigned int v216 = v215 - v213;
          if (v216 != 0 && v507)
          {
            if (v214 != (uint64_t *)((unint64_t)v211[4] >> (2 * v216))) {
              break;
            }
          }
          else if (v216 || v214 != v211[4])
          {
            break;
          }
          long long v217 = v211[7];
          v211[6] = (uint64_t *)((unint64_t)v211[6] | (unint64_t)v203[6]);
          v211[7] = (uint64_t *)((unint64_t)v217 | (unint64_t)v203[7]);
          float v218 = v211[1];
          if (v218)
          {
            do
            {
              unint64_t v219 = (uint64_t **)v218;
              float v218 = (uint64_t *)*v218;
            }
            while (v218);
          }
          else
          {
            do
            {
              unint64_t v219 = (uint64_t **)v211[2];
              BOOL v56 = *v219 == (uint64_t *)v211;
              BOOL v211 = v219;
            }
            while (!v56);
          }
          BOOL v211 = v219;
        }
        while (v219 != v584);
      }
      if (v208)
      {
        do
        {
          unint64_t v220 = (uint64_t **)v208;
          uint32_t v208 = (uint64_t *)*v208;
        }
        while (v208);
      }
      else
      {
        do
        {
          unint64_t v220 = (uint64_t **)v203[2];
          BOOL v56 = *v220 == (uint64_t *)v203;
          unint64_t v203 = v220;
        }
        while (!v56);
      }
      unint64_t v203 = v220;
    }
    while (v220 != v584);
  }
  v608 = 0;
  uint64_t v609 = 0;
  int v204 = v613;
  if (v613 != 5)
  {
    uint64_t v205 = v5[59];
    float v206 = (void (**)(void *))&unk_1EF573818;
    v615[0] = &unk_1EF573818;
    v615[1] = &v608;
    v616 = v615;
    BOOL v207 = *(uint64_t **)(v205 + 144);
    if (v207)
    {
      do
      {
        if (*((unsigned __int16 *)v207 + 10) == v204 && *((unsigned char *)v207 + 18) == 0)
        {
          LOWORD(v617) = *((_WORD *)v207 + 8);
          if (!v616)
          {
            std::__throw_bad_function_call[abi:nn180100]();
LABEL_1067:
            __break(1u);
          }
          (*(void (**)(void *, long long *))(*v616 + 48))(v616, &v617);
        }
        BOOL v207 = (uint64_t *)*v207;
      }
      while (v207);
      if (v616 == v615)
      {
        float v206 = (void (**)(void *))v615[0];
        goto LABEL_442;
      }
      if (v616) {
        (*(void (**)(void))(*v616 + 40))();
      }
    }
    else
    {
LABEL_442:
      v206[4](v615);
    }
  }
  std::string::size_type v222 = *v6;
  __s2a = v6[1];
  if (*v6 == __s2a) {
    goto LABEL_1042;
  }
  __na = v593 + 36;
  v589 = v593 + 11;
  uint64_t v569 = v593[33];
  v571 = v593 + 3;
  uint64_t v567 = v593[32];
  while (2)
  {
    unsigned int v223 = v222[113];
    int v224 = *((_DWORD *)v222 + 30);
    if (v222[113]) {
      BOOL v225 = 0;
    }
    else {
      BOOL v225 = *((_DWORD *)v222 + 29) == 0;
    }
    if (v225 && v224 == 0) {
      goto LABEL_447;
    }
    if (*v222 == 1)
    {
      unint64_t v3 = (unint64_t)__p[1];
      if (__p[1])
      {
        unint64_t v227 = *((void *)v222 + 11);
        uint8x8_t v228 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
        v228.i16[0] = vaddlv_u8(v228);
        if (v228.u32[0] > 1uLL)
        {
          unint64_t v229 = *((void *)v222 + 11);
          if ((void *)v227 >= __p[1]) {
            unint64_t v229 = v227 % (unint64_t)__p[1];
          }
        }
        else
        {
          unint64_t v229 = ((unint64_t)__p[1] - 1) & v227;
        }
        uint64_t v230 = (uint64_t ***)*((void *)__p[0] + v229);
        if (v230)
        {
          uint64_t v231 = *v230;
          if (*v230)
          {
            if (v228.u32[0] >= 2uLL)
            {
              while (1)
              {
                unint64_t v232 = (unint64_t)v231[1];
                if (v232 == v227)
                {
                  if (*((unsigned __int16 *)v231 + 8) == *((unsigned __int16 *)v222 + 4)
                    && v231[11] == *((uint64_t **)v222 + 10))
                  {
                    float v233 = v231[3];
                    size_t v234 = (char *)v231[4] - (char *)v233;
                    float v235 = (const void *)*((void *)v222 + 2);
                    if (v234 == *((void *)v222 + 3) - (void)v235 && !memcmp(v233, v235, v234)) {
                      goto LABEL_447;
                    }
                  }
                }
                else
                {
                  if (v232 >= v3) {
                    v232 %= v3;
                  }
                  if (v232 != v229) {
                    goto LABEL_483;
                  }
                }
                uint64_t v231 = (uint64_t **)*v231;
                if (!v231) {
                  goto LABEL_483;
                }
              }
            }
            unint64_t v3 = (unint64_t)__p[1] - 1;
            do
            {
              unint64_t v236 = (unint64_t)v231[1];
              if (v236 == v227)
              {
                if (*((unsigned __int16 *)v231 + 8) == *((unsigned __int16 *)v222 + 4)
                  && v231[11] == *((uint64_t **)v222 + 10))
                {
                  float v237 = v231[3];
                  size_t v238 = (char *)v231[4] - (char *)v237;
                  float v239 = (const void *)*((void *)v222 + 2);
                  if (v238 == *((void *)v222 + 3) - (void)v239 && !memcmp(v237, v239, v238)) {
                    goto LABEL_447;
                  }
                }
              }
              else if ((v236 & v3) != v229)
              {
                break;
              }
              uint64_t v231 = (uint64_t **)*v231;
            }
            while (v231);
          }
        }
      }
    }
LABEL_483:
    unint64_t v240 = *((unsigned __int16 *)v222 + 4);
    std::string::size_type v241 = (int32x2_t *)*((void *)v222 + 2);
    __int32 v242 = v241[1].i32[0];
    LOBYTE(v606) = v241[1].i32[1];
    BYTE1(v606) = v242;
    int32x2_t v243 = *v241;
    *(int32x2_t *)((char *)&v606 + 4) = vrev64_s32(*v241);
    v573 = (unsigned __int16 *)(v222 + 8);
    unint64_t v244 = *((void *)v222 + 17);
    float v245 = (unsigned __int16 *)v597[3];
    uint64_t v246 = (unsigned __int16 *)v597[4];
    if (v245 == v246)
    {
      uint64_t v251 = *((void *)v245 + 1);
      long long v249 = v593;
      float v250 = v584;
      if (0x8E38E38E38E38E39 * ((*((void *)v245 + 2) - v251) >> 4) <= v244) {
        goto LABEL_1062;
      }
      uint64_t v572 = *((void *)v245 + 1);
      v599 = (unint64_t *)(v251 + 144 * v244 + 112);
    }
    else
    {
      float v247 = (unsigned __int16 *)v597[3];
      while (*v247 != v240)
      {
        v247 += 16;
        if (v247 == v246)
        {
          float v247 = (unsigned __int16 *)v597[4];
          break;
        }
      }
      uint64_t v248 = *((void *)v247 + 1);
      long long v249 = v593;
      float v250 = v584;
      if (0x8E38E38E38E38E39 * ((*((void *)v247 + 2) - v248) >> 4) <= v244) {
        goto LABEL_1062;
      }
      uint64_t v572 = *((void *)v247 + 1);
      v599 = (unint64_t *)(v248 + 144 * v244 + 112);
      if (v245 != v246)
      {
        while (*v245 != v240)
        {
          v245 += 16;
          if (v245 == v246)
          {
            float v245 = (unsigned __int16 *)v597[4];
            break;
          }
        }
      }
    }
    unsigned __int8 v253 = v245 + 4;
    uint64_t v252 = *((void *)v245 + 1);
    uint64_t v579 = *((void *)v222 + 17);
    if (0x8E38E38E38E38E39 * ((*((void *)v253 + 1) - v252) >> 4) <= v244) {
      goto LABEL_1062;
    }
    if (v223 > v242
      || vcvtmd_s64_f64((double)v243.i32[0] / (double)(1 << v242)) != vcvtmd_s64_f64((double)v224 / (double)(1 << v223)))
    {
      long long v606 = *((_OWORD *)v222 + 7);
      uint64_t v607 = *((void *)v222 + 16);
    }
    uint64_t v594 = *(unsigned __int8 *)(v252 + 144 * v244 + 136);
    if (v569 != v567)
    {
      uint64_t v254 = v249[32];
      uint64_t v255 = v249[33];
      if (v254 != v255)
      {
        double v256 = 1.0 / (double)(1 << SBYTE1(v606));
        double v257 = v256 * (double)SDWORD2(v606);
        double v258 = v256 * (double)((1 << SBYTE1(v606)) + ~DWORD1(v606));
        double v259 = v257 + v256;
        double v260 = v258 + v256;
        if (v240 > 0x7F)
        {
          do
          {
            if (v257 >= *(double *)v254
              && v259 <= *(double *)(v254 + 16)
              && v258 >= *(double *)(v254 + 8)
              && v260 <= *(double *)(v254 + 24))
            {
              abort();
            }
            v254 += 64;
          }
          while (v254 != v255);
        }
        else
        {
          unint64_t v261 = v240 >> 6;
          uint64_t v262 = 1 << v240;
          do
          {
            if (v257 >= *(double *)v254
              && v259 <= *(double *)(v254 + 16)
              && v258 >= *(double *)(v254 + 8)
              && v260 <= *(double *)(v254 + 24))
            {
              long long v617 = 0uLL;
              *((void *)&v617 + v261) |= v262;
              if ((*(_OWORD *)(v254 + 48) & v617) != 0) {
                goto LABEL_447;
              }
              long long v617 = 0uLL;
              *((void *)&v617 + v261) |= v262;
              if ((*(void *)(v254 + 32) & (unint64_t)v617) == 0
                && (*(void *)(v254 + 40) & *((void *)&v617 + 1)) == 0)
              {
                goto LABEL_447;
              }
            }
            v254 += 64;
          }
          while (v254 != v255);
        }
      }
    }
    if (v249[39])
    {
      float v263 = (void *)v249[38];
      if (v263)
      {
        do
        {
          uint64_t v264 = (void *)*v263;
          operator delete(v263);
          float v263 = v264;
        }
        while (v264);
      }
      v249[38] = 0;
      uint64_t v265 = v249[37];
      if (v265)
      {
        for (iuint64_t i = 0; ii != v265; ++ii)
          *(void *)(*__na + 8 * ii) = 0;
      }
      v249[39] = 0;
    }
    v581 = v222;
    if (!v249[43])
    {
      int v272 = v606;
      goto LABEL_652;
    }
    v624 = &unk_1EF52DEF0;
    v625 = (int8x8_t *)&v608;
    v627 = (void **)&v624;
    if (BYTE1(v606) <= 0x1Eu
      && ((int v267 = 1 << SBYTE1(v606),
           int v268 = vcvtmd_s64_f64((double)SDWORD2(v606) / (double)(1 << SBYTE1(v606))),
           v268 >= 0)
        ? (unsigned int v269 = v268)
        : (unsigned int v269 = -v268),
          v269 <= 0x7F))
    {
      v273.i64[0] = ((SDWORD2(v606) % v267 + v267) % v267) | ((unint64_t)((SDWORD2(v606) % v267 + v267) % v267) << 16);
      v273.i64[1] = ((SDWORD1(v606) % v267 + v267) % v267) | ((unint64_t)((SDWORD1(v606) % v267 + v267) % v267) << 16);
      v274.i64[0] = 0xFFFF0000FFFFLL;
      v274.i64[1] = 0xFFFF0000FFFFLL;
      int64x2_t v275 = (int64x2_t)vandq_s8(v273, v274);
      unsigned long long v276 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64(v275, 8uLL), (int8x16_t)v275) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
      unsigned long long v277 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v276, 4uLL), (int8x16_t)v276) & __PAIR128__(0xFF0FFF0FFF0FFF0FLL, 0xFF0FFF0FFF0FFF0FLL);
      v274.i64[0] = 0x3333333333333333;
      v274.i64[1] = 0x3333333333333333;
      int8x16_t v278 = vandq_s8(vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v277, 2uLL), (int8x16_t)v277), v274);
      int8x16_t v279 = (int8x16_t)vshlq_u64((uint64x2_t)v278, (uint64x2_t)xmmword_1A28FC6E0);
      v278.i64[1] *= 2;
      int64x2_t v280 = (int64x2_t)vandq_s8(vorrq_s8(v279, v278), (int8x16_t)xmmword_1A28FC6F0);
      unint64_t v270 = vorrq_s8((int8x16_t)v280, (int8x16_t)vdupq_laneq_s64(v280, 1)).u64[0];
      unsigned int v271 = BYTE1(v606);
    }
    else
    {
      unint64_t v270 = 0;
      unsigned int v271 = 0;
      LOBYTE(v268) = 0;
    }
    unint64_t v281 = (uint64_t **)v249[41];
    if (v250 != v281)
    {
      unint64_t v282 = v250;
      do
      {
        uint64_t v283 = *v282;
        __int16 v284 = *v282;
        unint64_t v285 = v282;
        if (*v282)
        {
          do
          {
            __int16 v286 = v284;
            __int16 v284 = (uint64_t *)v284[1];
          }
          while (v284);
        }
        else
        {
          do
          {
            __int16 v286 = v285[2];
            BOOL v56 = *v286 == (void)v285;
            unint64_t v285 = (uint64_t **)v286;
          }
          while (v56);
        }
        if (*((unsigned __int8 *)v286 + 40) < v271)
        {
          __int16 v287 = *v282;
          unint64_t v288 = v282;
          if (v283)
          {
            do
            {
              unint64_t v289 = v287;
              __int16 v287 = (uint64_t *)v287[1];
            }
            while (v287);
          }
          else
          {
            do
            {
              unint64_t v289 = v288[2];
              BOOL v56 = *v289 == (void)v288;
              unint64_t v288 = (uint64_t **)v289;
            }
            while (v56);
          }
          if (*((unsigned __int8 *)v289 + 41) == v268)
          {
            unsigned int v290 = *((unsigned __int8 *)v289 + 40);
            BOOL v507 = v271 >= v290;
            unsigned int v291 = v271 - v290;
            if (v291 != 0 && v507)
            {
              if (v289[4] == v270 >> (2 * v291)) {
                goto LABEL_559;
              }
            }
            else if (!v291 && v289[4] == v270)
            {
LABEL_559:
              if (v283)
              {
                do
                {
                  int64x2_t v293 = (uint64_t **)v283;
                  uint64_t v283 = (uint64_t *)v283[1];
                }
                while (v283);
              }
              else
              {
                do
                {
                  int64x2_t v293 = (uint64_t **)v282[2];
                  BOOL v56 = *v293 == (uint64_t *)v282;
                  unint64_t v282 = v293;
                }
                while (v56);
              }
              if (v293[6] == v608 && ((v609 ^ *((_DWORD *)v293 + 14)) & 0x3FFFF) == 0)
              {
                std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__emplace_unique_key_args<geo::QuadTile,geo::QuadTile const&>((uint64_t)__na, (unsigned __int8 *)&v606, (uint64_t)&v606);
                goto LABEL_646;
              }
              break;
            }
          }
        }
        if (v283)
        {
          do
          {
            int64x2_t v292 = (uint64_t **)v283;
            uint64_t v283 = (uint64_t *)v283[1];
          }
          while (v283);
        }
        else
        {
          do
          {
            int64x2_t v292 = (uint64_t **)v282[2];
            BOOL v56 = *v292 == (uint64_t *)v282;
            unint64_t v282 = v292;
          }
          while (v56);
        }
        unint64_t v282 = v292;
      }
      while (v292 != v281);
    }
    int64x2_t v294 = (void (**)(_OWORD *))&unk_1EF52DF38;
    *(void *)&long long v617 = &unk_1EF52DF38;
    *((void *)&v617 + 1) = &v608;
    unint64_t v3 = (unint64_t)&v617;
    v619 = &v617;
    if (BYTE1(v606) <= 0x1Eu
      && ((int v295 = 1 << SBYTE1(v606),
           int v296 = vcvtmd_s64_f64((double)SDWORD2(v606) / (double)(1 << SBYTE1(v606))),
           v296 >= 0)
        ? (unsigned int v297 = v296)
        : (unsigned int v297 = -v296),
          v297 <= 0x7F))
    {
      unint64_t v299 = BYTE1(v606) | (v296 << 8);
      v300.i64[0] = ((SDWORD2(v606) % v295 + v295) % v295) | ((unint64_t)((SDWORD2(v606) % v295 + v295) % v295) << 16);
      v300.i64[1] = ((SDWORD1(v606) % v295 + v295) % v295) | ((unint64_t)((SDWORD1(v606) % v295 + v295) % v295) << 16);
      v301.i64[0] = 0xFFFF0000FFFFLL;
      v301.i64[1] = 0xFFFF0000FFFFLL;
      int64x2_t v302 = (int64x2_t)vandq_s8(v300, v301);
      unsigned long long v303 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64(v302, 8uLL), (int8x16_t)v302) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
      unsigned long long v304 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v303, 4uLL), (int8x16_t)v303) & __PAIR128__(0xFF0FFF0FFF0FFF0FLL, 0xFF0FFF0FFF0FFF0FLL);
      v301.i64[0] = 0x3333333333333333;
      v301.i64[1] = 0x3333333333333333;
      int8x16_t v305 = vandq_s8(vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v304, 2uLL), (int8x16_t)v304), v301);
      int8x16_t v306 = (int8x16_t)vshlq_u64((uint64x2_t)v305, (uint64x2_t)xmmword_1A28FC6E0);
      v305.i64[1] *= 2;
      int64x2_t v307 = (int64x2_t)vandq_s8(vorrq_s8(v306, v305), (int8x16_t)xmmword_1A28FC6F0);
      unint64_t v298 = vorrq_s8((int8x16_t)v307, (int8x16_t)vdupq_laneq_s64(v307, 1)).u64[0];
    }
    else
    {
      unint64_t v298 = 0;
      unint64_t v299 = 0;
      if (BYTE1(v606) > 0x1Eu)
      {
LABEL_577:
        unint64_t v311 = 0;
        unint64_t v312 = 0;
        uint64_t v313 = *v250;
        if (!*v250)
        {
LABEL_645:
          v294[4](&v617);
          goto LABEL_646;
        }
        goto LABEL_580;
      }
    }
    int v308 = 1 << SBYTE1(v606);
    int v309 = vcvtmd_s64_f64((double)SDWORD2(v606) / (double)(1 << SBYTE1(v606)));
    if (v309 >= 0) {
      unsigned int v310 = v309;
    }
    else {
      unsigned int v310 = -v309;
    }
    if (v310 > 0x7F) {
      goto LABEL_577;
    }
    unint64_t v311 = BYTE1(v606) | (v309 << 8);
    v314.i64[0] = ((SDWORD2(v606) % v308 + v308) % v308) | ((unint64_t)((SDWORD2(v606) % v308 + v308) % v308) << 16);
    v314.i64[1] = ((SDWORD1(v606) % v308 + v308) % v308) | ((unint64_t)((SDWORD1(v606) % v308 + v308) % v308) << 16);
    v315.i64[0] = 0xFFFF0000FFFFLL;
    v315.i64[1] = 0xFFFF0000FFFFLL;
    int64x2_t v316 = (int64x2_t)vandq_s8(v314, v315);
    unsigned long long v317 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64(v316, 8uLL), (int8x16_t)v316) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL);
    unsigned long long v318 = *(_OWORD *)&vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v317, 4uLL), (int8x16_t)v317) & __PAIR128__(0xFF0FFF0FFF0FFF0FLL, 0xFF0FFF0FFF0FFF0FLL);
    v315.i64[0] = 0x3333333333333333;
    v315.i64[1] = 0x3333333333333333;
    int8x16_t v319 = vandq_s8(vorrq_s8((int8x16_t)vshlq_n_s64((int64x2_t)v318, 2uLL), (int8x16_t)v318), v315);
    int8x16_t v320 = (int8x16_t)vshlq_u64((uint64x2_t)v319, (uint64x2_t)xmmword_1A28FC6E0);
    v319.i64[1] *= 2;
    int64x2_t v321 = (int64x2_t)vandq_s8(vorrq_s8(v320, v319), (int8x16_t)xmmword_1A28FC6F0);
    unint64_t v312 = vorrq_s8((int8x16_t)v321, (int8x16_t)vdupq_laneq_s64(v321, 1)).u64[0];
    uint64_t v313 = *v250;
    if (!*v250) {
      goto LABEL_645;
    }
LABEL_580:
    unint64_t v322 = (v298 + 1) & ~(-1 << (2 * v299));
    unint64_t v323 = v311 >> 8;
    uint64_t v324 = v250;
    uint64_t v325 = (uint64_t)v313;
    while (2)
    {
      unsigned int v329 = *(unsigned __int8 *)(v325 + 40);
      if (v329 >= v311)
      {
        if (v329 <= v311)
        {
          int v331 = *(unsigned __int8 *)(v325 + 41);
          if (v331 != v323)
          {
            int v331 = (char)v331;
LABEL_600:
            BOOL v326 = v331 < SBYTE1(v311);
            goto LABEL_582;
          }
          unint64_t v333 = *(void *)(v325 + 32);
        }
        else
        {
          int v332 = *(unsigned __int8 *)(v325 + 41);
          if (v323 != v332)
          {
            BOOL v326 = SBYTE1(v311) > (char)v332;
            goto LABEL_582;
          }
          unint64_t v333 = *(void *)(v325 + 32) >> (2 * (v329 - v311));
        }
        BOOL v326 = v333 < v312;
        goto LABEL_582;
      }
      int v330 = *(unsigned __int8 *)(v325 + 41);
      if (v330 != v323)
      {
        int v331 = (char)v330;
        goto LABEL_600;
      }
      BOOL v326 = *(void *)(v325 + 32) <= v312 >> (2 * (v311 - v329));
LABEL_582:
      BOOL v327 = !v326;
      if (v326) {
        unint64_t v328 = (uint64_t *)(v325 + 8);
      }
      else {
        unint64_t v328 = (uint64_t *)v325;
      }
      if (v327) {
        uint64_t v324 = (uint64_t **)v325;
      }
      uint64_t v325 = *v328;
      if (*v328) {
        continue;
      }
      break;
    }
    int v334 = (((v298 + 1) >> (2 * v299)) + BYTE1(v299));
    while (2)
    {
      unsigned int v338 = *((unsigned __int8 *)v313 + 40);
      if (v338 >= v299)
      {
        if (v338 <= v299)
        {
          int v340 = *((unsigned __int8 *)v313 + 41);
          if (v340 != v334)
          {
            int v340 = (char)v340;
LABEL_621:
            BOOL v335 = v340 < (char)v334;
            goto LABEL_603;
          }
          unint64_t v342 = v313[4];
        }
        else
        {
          int v341 = *((unsigned __int8 *)v313 + 41);
          if (v334 != v341)
          {
            BOOL v335 = (char)v334 > (char)v341;
            goto LABEL_603;
          }
          unint64_t v342 = (unint64_t)v313[4] >> (2 * (v338 - v299));
        }
        BOOL v335 = v342 < v322;
        goto LABEL_603;
      }
      int v339 = *((unsigned __int8 *)v313 + 41);
      if (v339 != v334)
      {
        int v340 = (char)v339;
        goto LABEL_621;
      }
      BOOL v335 = v313[4] <= v322 >> (2 * (v299 - v338));
LABEL_603:
      BOOL v336 = !v335;
      if (v335) {
        uint64_t v337 = (uint64_t **)(v313 + 1);
      }
      else {
        uint64_t v337 = (uint64_t **)v313;
      }
      if (v336) {
        float v250 = (uint64_t **)v313;
      }
      uint64_t v313 = *v337;
      if (*v337) {
        continue;
      }
      break;
    }
    if (v324 == v250)
    {
LABEL_644:
      long long v249 = v593;
      goto LABEL_645;
    }
    while (*((unsigned __int8 *)v324 + 41) == (v299 >> 8))
    {
      unsigned int v343 = *((unsigned __int8 *)v324 + 40);
      if (v343 <= v299)
      {
        if (v343 != v299 || (uint64_t *)v298 != v324[4]) {
          break;
        }
      }
      else if (v298 != (unint64_t)v324[4] >> (2 * (v343 - v299)))
      {
        break;
      }
      if (!v619)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        goto LABEL_1067;
      }
      if ((*(unsigned int (**)(long long *, uint64_t **))(*(void *)v619 + 48))(v619, v324 + 6))
      {
        unint64_t v344 = (unint64_t)v324[4];
        unint64_t v345 = v344 & 0x1111111111111111 | ((v344 & 0x5555555555555555) >> 1) & 0x3333333333333333;
        unint64_t v346 = (v345 | (v345 >> 2)) & 0xF000F000F000FLL | (((v345 | (v345 >> 2)) & 0xF0F0F0F0F0F0F0FLL) >> 4) & 0xFF00FF00FF00FFLL;
        int v347 = ((v346 | (v346 >> 8)) >> 16) & 0xFFFF0000 | (unsigned __int16)(v346 | (v346 >> 8));
        unint64_t v348 = ((((v344 >> 1) & 0x4444444444444444 | v344 & 0x2222222222222222) >> 3) | (((v344 >> 1) & 0x4444444444444444 | v344 & 0x2222222222222222) >> 1)) & 0xF0F0F0F0F0F0F0FLL;
        unint64_t v349 = (v348 | (v348 >> 4)) & 0xFF00FF00FF00FFLL | (((v348 | (v348 >> 4)) & 0xFF00FF00FF00FFLL) >> 8);
        LODWORD(v346) = (v349 >> 16) & 0xFFFF0000 | (unsigned __int16)v349;
        LOBYTE(v349) = *((unsigned char *)v324 + 40);
        int v350 = *((char *)v324 + 41) << v349;
        LOBYTE(v614[0]) = v606;
        BYTE1(v614[0]) = v349;
        DWORD1(v614[0]) = v346;
        DWORD2(v614[0]) = v350 + v347;
        std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__emplace_unique_key_args<geo::QuadTile,geo::QuadTile>((uint64_t)__na, (unsigned __int8 *)v614, (uint64_t)v614);
      }
      v351 = v324[1];
      if (v351)
      {
        do
        {
          unint64_t v352 = (uint64_t **)v351;
          v351 = (uint64_t *)*v351;
        }
        while (v351);
      }
      else
      {
        do
        {
          unint64_t v352 = (uint64_t **)v324[2];
          BOOL v56 = *v352 == (uint64_t *)v324;
          uint64_t v324 = v352;
        }
        while (!v56);
      }
      uint64_t v324 = v352;
      if (v352 == v250) {
        break;
      }
    }
    if (v619 == &v617)
    {
      int64x2_t v294 = (void (**)(_OWORD *))v617;
      goto LABEL_644;
    }
    long long v249 = v593;
    if (v619) {
      (*(void (**)(void))(*(void *)v619 + 40))();
    }
LABEL_646:
    if (v627 == (void **)&v624)
    {
      ((void (*)(void **))v624[4])(&v624);
    }
    else if (v627)
    {
      (*((void (**)(void))*v627 + 5))();
    }
    int v272 = v606;
    if (v249[39])
    {
      BOOL v353 = 1;
      goto LABEL_653;
    }
LABEL_652:
    uint8x8_t v354 = (uint8x8_t)vcnt_s8((int8x8_t)v608);
    v354.i16[0] = vaddlv_u8(v354);
    uint64_t v355 = v354.u32[0];
    uint8x8_t v356 = (uint8x8_t)vcnt_s8((int8x8_t)(v609 & 0x3FFFF));
    v356.i16[0] = vaddlv_u8(v356);
    BOOL v353 = v356.u32[0] + v355 == 0;
LABEL_653:
    if (v272 == 255 && !v353) {
      goto LABEL_1017;
    }
    std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__emplace_unique_key_args<geo::QuadTile,geo::QuadTile const&>(v566, v222 + 112, (uint64_t)(v222 + 112));
    float32x4x3_t v358 = (_DWORD *)*((void *)v222 + 2);
    int v359 = v358[2];
    unint64_t v360 = *((void *)v222 + 13);
    unint64_t v361 = v593[2];
    char v587 = v359;
    if (v361)
    {
      uint8x8_t v362 = (uint8x8_t)vcnt_s8((int8x8_t)v361);
      v362.i16[0] = vaddlv_u8(v362);
      if (v362.u32[0] > 1uLL)
      {
        unint64_t v3 = *((void *)v222 + 13);
        if (v360 >= v361) {
          unint64_t v3 = v360 % v361;
        }
      }
      else
      {
        unint64_t v3 = (v361 - 1) & v360;
      }
      uint64_t v363 = *(uint64_t ***)(v593[1] + 8 * v3);
      if (v363)
      {
        uint64_t v364 = *v363;
        if (v364)
        {
          uint64_t v365 = v364;
          if (v362.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v366 = v365[1];
              if (v366 == v360)
              {
                if (*((unsigned __int8 *)v365 + 16) == *v222
                  && *((unsigned __int16 *)v365 + 12) == *v573
                  && v365[12] == *((void *)v222 + 10))
                {
                  double v367 = (const void *)v365[4];
                  size_t v368 = v365[5] - (void)v367;
                  if (v368 == *((void *)v222 + 3) - (void)v358 && !memcmp(v367, v358, v368))
                  {
                    int v369 = v365;
                    unint64_t v370 = v593[38];
                    if (!v370) {
                      goto LABEL_1017;
                    }
                    goto LABEL_750;
                  }
                }
              }
              else if ((v366 & (v361 - 1)) != v3)
              {
                goto LABEL_688;
              }
              uint64_t v365 = (uint64_t *)*v365;
              if (!v365) {
                goto LABEL_688;
              }
            }
          }
          unint64_t v371 = v364;
          do
          {
            unint64_t v372 = v371[1];
            if (v372 == v360)
            {
              if (*((unsigned __int8 *)v371 + 16) == *v222
                && *((unsigned __int16 *)v371 + 12) == *v573
                && v371[12] == *((void *)v222 + 10))
              {
                float v373 = (const void *)v371[4];
                size_t v374 = v371[5] - (void)v373;
                if (v374 == *((void *)v222 + 3) - (void)v358 && !memcmp(v373, v358, v374))
                {
                  int v369 = v371;
                  unint64_t v370 = v593[38];
                  if (!v370) {
                    goto LABEL_1017;
                  }
                  goto LABEL_750;
                }
              }
            }
            else
            {
              if (v372 >= v361) {
                v372 %= v361;
              }
              if (v372 != v3) {
                break;
              }
            }
            unint64_t v371 = (uint64_t *)*v371;
          }
          while (v371);
        }
      }
    }
LABEL_688:
    v375 = operator new(0x160uLL);
    *(void *)&long long v617 = v375;
    *((void *)&v617 + 1) = v593 + 3;
    void *v375 = 0;
    v375[1] = v360;
    *((unsigned char *)v375 + 16) = *v222;
    gdc::LayerDataKey::LayerDataKey((uint64_t)(v375 + 3), (uint64_t)v573);
    *((unsigned char *)v375 + 112) = 0;
    if (v222[96])
    {
      *((_DWORD *)v375 + 29) = *((_DWORD *)v222 + 25);
      *((unsigned char *)v375 + 112) = 1;
    }
    v375[15] = *((void *)v222 + 13);
    v375[16] = v375 + 20;
    v375[17] = v375 + 20;
    v375[18] = v375 + 20;
    v375[19] = 8;
    LOBYTE(v618) = 1;
    float v376 = (float)(unint64_t)(v593[4] + 1);
    float v377 = *((float *)v593 + 10);
    if (!v361 || (float)(v377 * (float)v361) < v376)
    {
      BOOL v378 = (v361 & (v361 - 1)) != 0;
      if (v361 < 3) {
        BOOL v378 = 1;
      }
      unint64_t v379 = v378 | (2 * v361);
      unint64_t v380 = vcvtps_u32_f32(v376 / v377);
      if (v379 <= v380) {
        size_t v381 = v380;
      }
      else {
        size_t v381 = v379;
      }
      if (v381 == 1)
      {
        size_t v381 = 2;
      }
      else if ((v381 & (v381 - 1)) != 0)
      {
        size_t v381 = std::__next_prime(v381);
      }
      unint64_t v361 = v593[2];
      if (v381 > v361)
      {
LABEL_702:
        if (v381 >> 61) {
          goto LABEL_1065;
        }
        BOOL v382 = operator new(8 * v381);
        id v383 = (void *)v593[1];
        v593[1] = v382;
        if (v383) {
          operator delete(v383);
        }
        uint64_t v384 = 0;
        v593[2] = v381;
        do
          *(void *)(v593[1] + 8 * v384++) = 0;
        while (v381 != v384);
        uint64_t v385 = (void *)*v571;
        if (!*v571) {
          goto LABEL_725;
        }
        size_t v386 = v385[1];
        size_t v387 = v381 - 1;
        if ((v381 & (v381 - 1)) == 0)
        {
          size_t v388 = v386 & v387;
          *(void *)(v593[1] + 8 * v388) = v571;
          while (1)
          {
            unint64_t v389 = (void *)*v385;
            if (!*v385) {
              break;
            }
            size_t v390 = v389[1] & v387;
            if (v390 == v388)
            {
              uint64_t v385 = (void *)*v385;
            }
            else
            {
              uint64_t v391 = v593[1];
              if (*(void *)(v391 + 8 * v390))
              {
                *uint64_t v385 = *v389;
                uint64_t v392 = 8 * v390;
                *unint64_t v389 = **(void **)(v593[1] + v392);
                **(void **)(v593[1] + v392) = v389;
              }
              else
              {
                *(void *)(v391 + 8 * v390) = v385;
                uint64_t v385 = v389;
                size_t v388 = v390;
              }
            }
          }
          goto LABEL_725;
        }
        if (v386 >= v381) {
          v386 %= v381;
        }
        *(void *)(v593[1] + 8 * v386) = v571;
        uint64_t v396 = (void *)*v385;
        if (!*v385)
        {
LABEL_725:
          unint64_t v361 = v381;
          goto LABEL_726;
        }
        while (2)
        {
          size_t v398 = v396[1];
          if (v398 >= v381) {
            v398 %= v381;
          }
          if (v398 != v386)
          {
            uint64_t v399 = v593[1];
            if (!*(void *)(v399 + 8 * v398))
            {
              *(void *)(v399 + 8 * v398) = v385;
LABEL_731:
              uint64_t v385 = v396;
              uint64_t v396 = (void *)*v396;
              size_t v386 = v398;
              if (!v396) {
                goto LABEL_725;
              }
              continue;
            }
            *uint64_t v385 = *v396;
            uint64_t v397 = 8 * v398;
            *uint64_t v396 = **(void **)(v593[1] + v397);
            **(void **)(v593[1] + v397) = v396;
            uint64_t v396 = v385;
          }
          break;
        }
        size_t v398 = v386;
        goto LABEL_731;
      }
      if (v381 >= v361) {
        goto LABEL_726;
      }
      unint64_t v393 = vcvtps_u32_f32((float)(unint64_t)v593[4] / *((float *)v593 + 10));
      if (v361 < 3 || (uint8x8_t v394 = (uint8x8_t)vcnt_s8((int8x8_t)v361), v394.i16[0] = vaddlv_u8(v394), v394.u32[0] > 1uLL))
      {
        unint64_t v393 = std::__next_prime(v393);
      }
      else
      {
        uint64_t v395 = 1 << -(char)__clz(v393 - 1);
        if (v393 >= 2) {
          unint64_t v393 = v395;
        }
      }
      if (v381 <= v393) {
        size_t v381 = v393;
      }
      if (v381 >= v361)
      {
        unint64_t v361 = v593[2];
LABEL_726:
        LOBYTE(v359) = v587;
      }
      else
      {
        if (v381) {
          goto LABEL_702;
        }
        v539 = (void *)v593[1];
        v593[1] = 0;
        LOBYTE(v359) = v587;
        if (v539) {
          operator delete(v539);
        }
        unint64_t v361 = 0;
        v593[2] = 0;
      }
      if ((v361 & (v361 - 1)) != 0)
      {
        if (v360 >= v361) {
          unint64_t v3 = v360 % v361;
        }
        else {
          unint64_t v3 = v360;
        }
      }
      else
      {
        unint64_t v3 = (v361 - 1) & v360;
      }
    }
    unint64_t v400 = *(void **)(v593[1] + 8 * v3);
    int v369 = (void *)v617;
    if (v400)
    {
      *(void *)long long v617 = *v400;
      goto LABEL_748;
    }
    *(void *)long long v617 = v593[3];
    v593[3] = v369;
    *(void *)(v593[1] + 8 * v3) = v571;
    if (*v369)
    {
      unint64_t v401 = *(void *)(*v369 + 8);
      if ((v361 & (v361 - 1)) != 0)
      {
        if (v401 >= v361) {
          v401 %= v361;
        }
      }
      else
      {
        v401 &= v361 - 1;
      }
      unint64_t v400 = (void *)(v593[1] + 8 * v401);
LABEL_748:
      *unint64_t v400 = v369;
    }
    ++v593[4];
    unint64_t v370 = v593[38];
    if (!v370) {
      goto LABEL_1017;
    }
LABEL_750:
    v583 = v369;
    while (2)
    {
      uint64_t v403 = v369[16];
      uint64_t v402 = (char *)v369[17];
      unint64_t v404 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)&v402[-v403] >> 3);
      unint64_t v405 = v369[19];
      if (v405 < v404 + 1)
      {
        unint64_t v3 = v369[18];
        unint64_t v406 = (1 << -(char)__clz(v405 + 1));
        if (v405 >= 0xFFFFFFFFFFFFFFFELL) {
          unint64_t v406 = 1;
        }
        if (v406 <= v404 + 1) {
          unint64_t v407 = v404 + 1;
        }
        else {
          unint64_t v407 = v406;
        }
        uint64_t v408 = (char *)malloc_type_malloc(24 * v407, 0x1000040FC312AA6uLL);
        uint64_t v409 = (char *)v369[16];
        uint64_t v410 = (char *)v369[17];
        if (v409 != v410)
        {
          uint64_t v411 = v408;
          uint64_t v412 = (char *)v369[16];
          do
          {
            *(_WORD *)uint64_t v411 = *(_WORD *)v412;
            *(void *)(v411 + 4) = *(void *)(v412 + 4);
            v412 += 24;
            v411 += 24;
          }
          while (v412 != v410);
        }
        if (v403 != v3) {
          free(v409);
        }
        v369[16] = v408;
        uint64_t v402 = &v408[24 * v404];
        v369[19] = v407;
      }
      *(_WORD *)uint64_t v402 = *(_WORD *)(v370 + 16);
      *(void *)(v402 + 4) = *(void *)(v370 + 20);
      v369[17] = v402 + 24;
      unint64_t v413 = *v599;
      if (!*v599) {
        goto LABEL_751;
      }
      if (v594) {
        goto LABEL_751;
      }
      unsigned int v414 = *(unsigned __int8 *)(v370 + 17);
      if (v414 <= v359) {
        goto LABEL_751;
      }
      unsigned int v415 = (v414 - v359);
      if (v415 >= 5) {
        char v416 = 5;
      }
      else {
        char v416 = v414 - v359;
      }
      if (v415 <= 5) {
        char v417 = 0;
      }
      else {
        char v417 = v415 - 5;
      }
      v624 = (void *)*v599;
      v625 = *(int8x8_t **)(v572 + 144 * v579 + 120);
      v590 = v625;
      if (v625)
      {
        atomic_fetch_add_explicit((atomic_ullong *volatile)&v625[1], 1uLL, memory_order_relaxed);
        LOBYTE(v414) = *(unsigned char *)(v370 + 17);
      }
      uint64_t v418 = (1 << v416);
      double v419 = (double)(1 << v414);
      int v420 = *(_DWORD *)(v370 + 24);
      signed int v421 = vcvtmd_s64_f64((double)v420 / v419);
      char v626 = v421;
      char v601 = v421;
      unint64_t v603 = ((v413 << 6) - 0x61C8864680B583EBLL + (v413 >> 2) + v421) ^ v413;
      unint64_t v605 = v593[10];
      char v592 = v417;
      if (v605)
      {
        uint8x8_t v422 = (uint8x8_t)vcnt_s8((int8x8_t)v605);
        v422.i16[0] = vaddlv_u8(v422);
        if (v422.u32[0] > 1uLL)
        {
          uint64_t v423 = ((v413 << 6) - 0x61C8864680B583EBLL + (v413 >> 2) + v421) ^ v413;
          if (v603 >= v605) {
            uint64_t v423 = v603 % v605;
          }
        }
        else
        {
          uint64_t v423 = v603 & (v605 - 1);
        }
        v424 = *(char ***)(v593[9] + 8 * v423);
        if (v424)
        {
          uint64_t v425 = *v424;
          if (*v424)
          {
            if (v422.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v429 = *((void *)v425 + 1);
                if (v429 == v603)
                {
                  if (v425[32] == v421 && *((void *)v425 + 2) == v413) {
                    goto LABEL_908;
                  }
                }
                else if ((v429 & (v605 - 1)) != v423)
                {
                  goto LABEL_801;
                }
                uint64_t v425 = *(char **)v425;
                if (!v425) {
                  goto LABEL_801;
                }
              }
            }
            do
            {
              unint64_t v427 = *((void *)v425 + 1);
              if (v427 == v603)
              {
                if (v425[32] == v601 && *((void *)v425 + 2) == v413)
                {
LABEL_908:
                  long long v483 = (void **)*((void *)v425 + 5);
                  unint64_t v484 = (unint64_t)v483[3];
                  if (v418 <= v484)
                  {
                    if (v418 >= v484) {
                      goto LABEL_896;
                    }
                    uint64_t v500 = (uint64_t)v483[4];
                    LOBYTE(v359) = v587;
                    if (v500 != v484 * v484)
                    {
                      uint64_t v501 = v484 >> v416;
                      unint64_t v502 = (*(_DWORD *)(v370 + 20) & (v418 - 1)) * v501;
                      unint64_t v503 = v501 * (v420 & (v418 - 1));
                      uint64_t v504 = v501 - 1;
                      BOOL v505 = __CFADD__(v501 - 1, v502);
                      BOOL v507 = __CFADD__(v504, v503);
                      unint64_t v506 = v504 + v503;
                      if (!v507 && !v505)
                      {
                        BOOL v507 = v506 >= v484 || v501 - 1 + v502 >= v484;
                        if (!v507)
                        {
                          uint64_t v508 = v501 + v502;
                          do
                          {
                            uint64_t v509 = v484 >> v416;
                            unint64_t v510 = v503;
                            do
                            {
                              unint64_t v511 = (unint64_t)v483[3];
                              if (v500 != v511 * v511 && v511 > v510 && v511 > v502)
                              {
                                unint64_t v514 = v510 + v502 * v511;
                                unint64_t v515 = v514 >> 6;
                                uint64_t v516 = 1 << v514;
                                uint64_t v517 = *((void *)*v483 + v515);
                                if ((v517 & v516) == 0)
                                {
                                  *((void *)*v483 + v515) = v517 | v516;
                                  uint64_t v500 = (uint64_t)v483[4] + 1;
                                  v483[4] = (void *)v500;
                                }
                              }
                              ++v510;
                              --v509;
                            }
                            while (v509);
                            ++v502;
                          }
                          while (v502 != v508);
                        }
                      }
                    }
                    goto LABEL_903;
                  }
                  if (v484 == v418) {
                    goto LABEL_896;
                  }
                  long long v485 = v483[4];
                  BOOL v486 = v485 == (void *)(v484 * v484) || v485 == 0;
                  unint64_t v563 = (1 << v416);
                  if (!v486)
                  {
                    v483[4] = 0;
                    unint64_t v3 = v418 << v416;
                    unint64_t v518 = (unint64_t)((v418 << v416) - 1) >> 6;
                    v519 = operator new(8 * (v518 + 1));
                    v520 = v519;
                    if (v3 >= 0x41) {
                      unint64_t v521 = v518;
                    }
                    else {
                      unint64_t v521 = 0;
                    }
                    v519[v521] = 0;
                    if (v3 >= 0x40) {
                      bzero(v519, 8 * (v3 >> 6));
                    }
                    if ((v3 & 0x3D) != 0) {
                      v520[v3 >> 6] &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v3 & 0x3D));
                    }
                    v522 = *v483;
                    if (v484 - 1 < v563)
                    {
                      v523 = 0;
                      uint64_t v524 = 0;
                      unint64_t v525 = v563 / v484;
                      if (v563 / v484 <= 1) {
                        uint64_t v526 = 1;
                      }
                      else {
                        uint64_t v526 = v563 / v484;
                      }
                      do
                      {
                        uint64_t v527 = 0;
                        unint64_t v528 = v524 * v525;
                        do
                        {
                          unint64_t v529 = v527 * v525;
                          uint64_t v530 = *(void *)((unsigned char *)v522 + (((v484 * v524 + v527) >> 3) & 0x1FFFFFFFFFFFFFF8)) & (1 << (v484 * v524 + v527));
                          BOOL v531 = v530 != 0;
                          if (v530)
                          {
                            uint64_t v532 = 0;
                            do
                            {
                              uint64_t v533 = 0;
                              uint64_t v534 = v526;
                              do
                              {
                                *(void *)((char *)v520
                                          + (((((v532 + v528) << v416) + v529 + v533) >> 3) & 0x1FFFFFFFFFFFFFF8)) |= 1 << (((v532 + v528) << v416) + v529 + v533);
                                v523 += v531;
                                ++v533;
                                --v534;
                              }
                              while (v534);
                              ++v532;
                            }
                            while (v532 != v526);
                          }
                          else
                          {
                            do
                            {
                              uint64_t v535 = 0;
                              uint64_t v536 = v526;
                              do
                              {
                                *(void *)((char *)v520
                                          + (((((v530 + v528) << v416) + v529 + v535) >> 3) & 0x1FFFFFFFFFFFFFF8)) &= ~(1 << (((v530 + v528) << v416) + v529 + v535));
                                v523 += v531;
                                ++v535;
                                --v536;
                              }
                              while (v536);
                              ++v530;
                            }
                            while (v530 != v526);
                          }
                          v483[4] = v523;
                          ++v527;
                        }
                        while (v527 != v484);
                        ++v524;
                      }
                      while (v524 != v484);
                    }
                    if (v522) {
                      operator delete(v522);
                    }
                    *long long v483 = v520;
                    v483[1] = (void *)v3;
                    v483[2] = (void *)(v518 + 1);
LABEL_1005:
                    LODWORD(v418) = v563;
                    v483[3] = (void *)v563;
                    char v417 = v592;
                    goto LABEL_896;
                  }
                  uint64_t v487 = v418 << v416;
                  std::vector<BOOL>::resize((uint64_t)v483, v418 << v416);
                  uint64_t v488 = (void)v483[3] * (void)v483[3];
                  uint64_t v489 = v488 - 63;
                  if (v488 - 63 < 0) {
                    uint64_t v489 = (void)v483[3] * (void)v483[3];
                  }
                  uint64_t v490 = v489 >> 6;
                  if (v488 >= 0) {
                    uint64_t v490 = (unint64_t)v488 >> 6;
                  }
                  __int16 v491 = (char *)*v483 + 8 * v490;
                  char v492 = v488 & 0x3F;
                  unint64_t v493 = ((unint64_t)v483[1] & 0x3F)
                       - (v488 & 0x3F)
                       + 8 * ((unsigned char *)*v483 + 8 * ((unint64_t)v483[1] >> 6) - (unsigned char *)v491);
                  if (v493)
                  {
                    int v494 = v488 & 0x3F;
                    if (v483[4] == (void *)v488)
                    {
                      if ((v488 & 0x3F) != 0)
                      {
                        unint64_t v495 = (64 - v494);
                        if (v495 >= v493) {
                          unint64_t v496 = v493;
                        }
                        else {
                          unint64_t v496 = (64 - v494);
                        }
                        *v491++ |= (0xFFFFFFFFFFFFFFFFLL >> (v495 - v496)) & (-1 << v492);
                        v493 -= v496;
                      }
                      uint64_t v497 = v493 >> 6;
                      if (v493 >= 0x40) {
                        memset(v491, 255, 8 * (v493 >> 6));
                      }
                      if ((v493 & 0x3F) != 0)
                      {
                        unint64_t v498 = v491[v497] | (0xFFFFFFFFFFFFFFFFLL >> -(v493 & 0x3F));
                        goto LABEL_1002;
                      }
                    }
                    else
                    {
                      if ((v488 & 0x3F) != 0)
                      {
                        unint64_t v537 = (64 - v494);
                        if (v537 >= v493) {
                          unint64_t v538 = v493;
                        }
                        else {
                          unint64_t v538 = (64 - v494);
                        }
                        *v491++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (v537 - v538)) & (-1 << v492));
                        v493 -= v538;
                      }
                      uint64_t v497 = v493 >> 6;
                      if (v493 >= 0x40) {
                        bzero(v491, 8 * (v493 >> 6));
                      }
                      if ((v493 & 0x3F) != 0)
                      {
                        unint64_t v498 = v491[v497] & ~(0xFFFFFFFFFFFFFFFFLL >> -(v493 & 0x3F));
LABEL_1002:
                        v491[v497] = v498;
                      }
                    }
                  }
                  if (v483[4] == (void *)((void)v483[3] * (void)v483[3])) {
                    v483[4] = (void *)v487;
                  }
                  goto LABEL_1005;
                }
              }
              else
              {
                if (v427 >= v605) {
                  v427 %= v605;
                }
                if (v427 != v423) {
                  break;
                }
              }
              uint64_t v425 = *(char **)v425;
            }
            while (v425);
          }
        }
      }
LABEL_801:
      unint64_t v3 = v370;
      uint64_t v430 = (std::__shared_weak_count *)operator new(0x40uLL);
      v430->__shared_owners_ = 0;
      v430->__shared_weak_owners_ = 0;
      v430->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582D30;
      v430[1].__vftable = 0;
      uint64_t v431 = (std::__shared_weak_count_vtbl *)(1 << v416);
      unint64_t v432 = v418 << v416;
      v430[1].__shared_owners_ = 0;
      v430[1].__shared_weak_owners_ = 0;
      unint64_t v433 = (unint64_t)((v418 << v416) - 1) >> 6;
      v434 = (std::__shared_weak_count_vtbl *)operator new(8 * (v433 + 1));
      unint64_t v435 = (unint64_t)v434;
      v430[1].__shared_owners_ = v432;
      v430[1].__shared_weak_owners_ = v433 + 1;
      v430[1].__vftable = v434;
      if (v432 >= 0x41) {
        unint64_t v436 = v433;
      }
      else {
        unint64_t v436 = 0;
      }
      *((void *)&v434->~__shared_weak_count + v436) = 0;
      if (v432 >= 0x40) {
        bzero(v434, 8 * (v432 >> 6));
      }
      LODWORD(v418) = v431;
      if ((v432 & 0x3F) != 0) {
        *(void *)(v435 + 8 * (v432 >> 6)) &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v432 & 0x3F));
      }
      v430[2].__vftable = v431;
      v430[2].__shared_owners_ = 0;
      *(void *)&v614[0] = v430 + 1;
      *((void *)&v614[0] + 1) = v430;
      unint64_t v370 = v3;
      if (!v605) {
        goto LABEL_834;
      }
      uint8x8_t v437 = (uint8x8_t)vcnt_s8((int8x8_t)v605);
      v437.i16[0] = vaddlv_u8(v437);
      if (v437.u32[0] > 1uLL)
      {
        unint64_t v435 = v603;
        if (v603 >= v605) {
          unint64_t v435 = v603 % v605;
        }
      }
      else
      {
        unint64_t v435 = v603 & (v605 - 1);
      }
      float32x4_t v438 = *(char ***)(v593[9] + 8 * v435);
      if (!v438 || (uint64_t v425 = *v438) == 0)
      {
LABEL_834:
        v443 = (char *)operator new(0x38uLL);
        uint64_t v425 = v443;
        *(void *)&long long v617 = v443;
        *((void *)&v617 + 1) = v593 + 11;
        *(void *)v443 = 0;
        *((void *)v443 + 1) = v603;
        *((void *)v443 + 2) = v413;
        *((void *)v443 + 3) = v590;
        if (v590) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)&v590[1], 1uLL, memory_order_relaxed);
        }
        v443[32] = v601;
        *(_OWORD *)(v443 + 40) = v614[0];
        v614[0] = 0uLL;
        LOBYTE(v618) = 1;
        float v444 = (float)(unint64_t)(v593[12] + 1);
        float v445 = *((float *)v593 + 26);
        int8x8_t v446 = (int8x8_t)v605;
        if (v605 && (float)(v445 * (float)v605) >= v444)
        {
LABEL_886:
          uint64_t v469 = v593[9];
          v470 = *(void **)(v469 + 8 * v435);
          if (v470)
          {
            *(void *)uint64_t v425 = *v470;
            char v417 = v592;
          }
          else
          {
            *(void *)uint64_t v425 = *v589;
            void *v589 = v425;
            *(void *)(v469 + 8 * v435) = v589;
            char v417 = v592;
            if (!*(void *)v425)
            {
LABEL_895:
              ++v593[12];
              int v369 = v583;
              goto LABEL_896;
            }
            unint64_t v471 = *(void *)(*(void *)v425 + 8);
            if ((*(void *)&v446 & (*(void *)&v446 - 1)) != 0)
            {
              if (v471 >= *(void *)&v446) {
                v471 %= *(void *)&v446;
              }
            }
            else
            {
              v471 &= *(void *)&v446 - 1;
            }
            v470 = (void *)(v593[9] + 8 * v471);
          }
          void *v470 = v425;
          goto LABEL_895;
        }
        BOOL v447 = (v605 & (v605 - 1)) != 0;
        if (v605 < 3) {
          BOOL v447 = 1;
        }
        unint64_t v448 = v447 | (2 * v605);
        unint64_t v449 = vcvtps_u32_f32(v444 / v445);
        if (v448 <= v449) {
          size_t v450 = v449;
        }
        else {
          size_t v450 = v448;
        }
        if (v450 == 1)
        {
          size_t v450 = 2;
        }
        else if ((v450 & (v450 - 1)) != 0)
        {
          size_t v450 = std::__next_prime(v450);
        }
        int8x8_t v446 = (int8x8_t)v593[10];
        if (v450 <= *(void *)&v446)
        {
          if (v450 >= *(void *)&v446) {
            goto LABEL_873;
          }
          unint64_t v462 = vcvtps_u32_f32((float)(unint64_t)v593[12] / *((float *)v593 + 26));
          if (*(void *)&v446 < 3uLL
            || (uint8x8_t v463 = (uint8x8_t)vcnt_s8(v446), v463.i16[0] = vaddlv_u8(v463), v463.u32[0] > 1uLL))
          {
            unint64_t v462 = std::__next_prime(v462);
          }
          else
          {
            uint64_t v464 = 1 << -(char)__clz(v462 - 1);
            if (v462 >= 2) {
              unint64_t v462 = v464;
            }
          }
          if (v450 <= v462) {
            size_t v450 = v462;
          }
          if (v450 >= *(void *)&v446)
          {
            int8x8_t v446 = (int8x8_t)v593[10];
LABEL_873:
            if ((*(void *)&v446 & (*(void *)&v446 - 1)) != 0)
            {
              if (v603 >= *(void *)&v446) {
                unint64_t v435 = v603 % *(void *)&v446;
              }
              else {
                unint64_t v435 = v603;
              }
            }
            else
            {
              unint64_t v435 = (*(void *)&v446 - 1) & v603;
            }
            goto LABEL_886;
          }
          if (!v450)
          {
            v499 = (void *)v593[9];
            v593[9] = 0;
            if (v499) {
              operator delete(v499);
            }
            int8x8_t v446 = 0;
            v593[10] = 0;
            goto LABEL_873;
          }
        }
        if (v450 >> 61) {
          goto LABEL_1065;
        }
        uint64_t v451 = operator new(8 * v450);
        uint64_t v452 = (void *)v593[9];
        v593[9] = v451;
        if (v452) {
          operator delete(v452);
        }
        uint64_t v453 = 0;
        v593[10] = v450;
        do
          *(void *)(v593[9] + 8 * v453++) = 0;
        while (v450 != v453);
        unint64_t v454 = (void *)*v589;
        if (!*v589)
        {
LABEL_872:
          int8x8_t v446 = (int8x8_t)v450;
          goto LABEL_873;
        }
        size_t v455 = v454[1];
        size_t v456 = v450 - 1;
        if ((v450 & (v450 - 1)) == 0)
        {
          size_t v457 = v455 & v456;
          *(void *)(v593[9] + 8 * v457) = v589;
          for (juint64_t j = (void *)*v454; *v454; juint64_t j = (void *)*v454)
          {
            size_t v459 = jj[1] & v456;
            if (v459 == v457)
            {
              unint64_t v454 = jj;
            }
            else
            {
              uint64_t v460 = v593[9];
              if (*(void *)(v460 + 8 * v459))
              {
                *unint64_t v454 = *jj;
                uint64_t v461 = 8 * v459;
                *juint64_t j = **(void **)(v593[9] + v461);
                **(void **)(v593[9] + v461) = jj;
              }
              else
              {
                *(void *)(v460 + 8 * v459) = v454;
                unint64_t v454 = jj;
                size_t v457 = v459;
              }
            }
          }
          goto LABEL_872;
        }
        if (v455 >= v450) {
          v455 %= v450;
        }
        *(void *)(v593[9] + 8 * v455) = v589;
        v465 = (void *)*v454;
        if (!*v454) {
          goto LABEL_872;
        }
        while (1)
        {
          size_t v467 = v465[1];
          if (v467 >= v450) {
            v467 %= v450;
          }
          if (v467 != v455)
          {
            uint64_t v468 = v593[9];
            if (!*(void *)(v468 + 8 * v467))
            {
              *(void *)(v468 + 8 * v467) = v454;
              goto LABEL_877;
            }
            *unint64_t v454 = *v465;
            uint64_t v466 = 8 * v467;
            void *v465 = **(void **)(v593[9] + v466);
            **(void **)(v593[9] + v466) = v465;
            v465 = v454;
          }
          size_t v467 = v455;
LABEL_877:
          unint64_t v454 = v465;
          v465 = (void *)*v465;
          size_t v455 = v467;
          if (!v465) {
            goto LABEL_872;
          }
        }
      }
      if (v437.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v442 = *((void *)v425 + 1);
          if (v442 == v603)
          {
            if (v425[32] == v601 && *((void *)v425 + 2) == v413) {
              goto LABEL_930;
            }
          }
          else if ((v442 & (v605 - 1)) != v435)
          {
            goto LABEL_834;
          }
          uint64_t v425 = *(char **)v425;
          if (!v425) {
            goto LABEL_834;
          }
        }
      }
      while (1)
      {
        unint64_t v440 = *((void *)v425 + 1);
        if (v440 == v603) {
          break;
        }
        if (v440 >= v605) {
          v440 %= v605;
        }
        if (v440 != v435) {
          goto LABEL_834;
        }
LABEL_821:
        uint64_t v425 = *(char **)v425;
        if (!v425) {
          goto LABEL_834;
        }
      }
      if (v425[32] != v601 || *((void *)v425 + 2) != v413) {
        goto LABEL_821;
      }
LABEL_930:
      int v369 = v583;
      char v417 = v592;
      if (!atomic_fetch_add(&v430->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v430->__on_zero_shared)(v430);
        std::__shared_weak_count::__release_weak(v430);
      }
LABEL_896:
      unint64_t v472 = (*(_DWORD *)(v370 + 20) >> v417) & (v418 - 1);
      unint64_t v473 = (v418 - 1) & (*(_DWORD *)(v370 + 24) >> v417);
      long long v474 = (void *)*((void *)v425 + 5);
      unint64_t v475 = v474[3];
      BOOL v477 = v474[4] != v475 * v475 && v475 > v473 && v475 > v472;
      LOBYTE(v359) = v587;
      if (v477)
      {
        unint64_t v479 = v473 + v475 * v472;
        unint64_t v480 = v479 >> 6;
        uint64_t v481 = 1 << v479;
        uint64_t v482 = *(void *)(*v474 + 8 * v480);
        if ((v482 & v481) == 0)
        {
          *(void *)(*v474 + 8 * v480) = v482 | v481;
          ++v474[4];
        }
      }
LABEL_903:
      long long v478 = (std::__shared_weak_count *)v625;
      if (v625 && !atomic_fetch_add((atomic_ullong *volatile)&v625[1], 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v478->__on_zero_shared)(v478);
        std::__shared_weak_count::__release_weak(v478);
      }
LABEL_751:
      unint64_t v370 = *(void *)v370;
      if (v370) {
        continue;
      }
      break;
    }
LABEL_1017:
    std::string::size_type v222 = v581;
    if (*v599 && !v594 && (!v608 && (v609 & 0x3FFFF) == 0 || v593[39]))
    {
      v540 = geo::linear_map<unsigned short,std::set<gdc::LayerDataWithWorld>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::set<gdc::LayerDataWithWorld>>>,std::vector<std::pair<unsigned short,std::set<gdc::LayerDataWithWorld>>>>::operator[]((char **)v593 + 6, *v573);
      v541 = operator new(0x38uLL);
      v542 = v541;
      unint64_t v543 = *v599;
      v541[4] = *v599;
      v544 = *(std::__shared_weak_count **)(v572 + 144 * v579 + 120);
      v541[5] = v544;
      if (v544) {
        atomic_fetch_add_explicit(&v544->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v545 = (void **)(v540 + 4);
      signed int v546 = vcvtmd_s64_f64((double)*((int *)v581 + 30) / (double)(1 << v581[113]));
      *((unsigned char *)v541 + 48) = v546;
      v547 = (void **)*((void *)v540 + 1);
      v548 = (void **)(v540 + 4);
      if (v547)
      {
        while (1)
        {
          while (1)
          {
            v548 = v547;
            int v549 = *((unsigned __int8 *)v547 + 48);
            signed int v550 = (char)v549;
            unint64_t v551 = (unint64_t)v547[4];
            if (!(v549 == v546 ? v543 < v551 : (char)v549 > v546)) {
              break;
            }
            v547 = (void **)*v548;
            v545 = v548;
            if (!*v548) {
              goto LABEL_1036;
            }
          }
          BOOL v553 = v551 < v543;
          BOOL v56 = v550 == v546;
          BOOL v554 = v550 < v546;
          if (v56) {
            BOOL v554 = v553;
          }
          if (!v554) {
            break;
          }
          v547 = (void **)v548[1];
          if (!v547)
          {
            v545 = v548 + 1;
            goto LABEL_1036;
          }
        }
        if (v544 && !atomic_fetch_add(&v544->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v544->__on_zero_shared)(v544);
          std::__shared_weak_count::__release_weak(v544);
        }
        operator delete(v542);
      }
      else
      {
LABEL_1036:
        void *v541 = 0;
        v541[1] = 0;
        v541[2] = v548;
        *v545 = v541;
        uint64_t v555 = **(void **)v540;
        if (v555)
        {
          *(void *)v540 = v555;
          v542 = *v545;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v540 + 1), (uint64_t *)v542);
        ++*((void *)v540 + 2);
      }
      std::string::size_type v222 = v581;
    }
LABEL_447:
    v222 += 144;
    if (v222 != __s2a) {
      continue;
    }
    break;
  }
LABEL_1042:
  LODWORD(v617) = 2;
  if (*((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v596, 2, &v617)+ 6)|| (LODWORD(v624) = 1, *((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v596, 1, &v624)+ 6)))
  {
    BOOL v556 = 0;
  }
  else
  {
    LODWORD(v614[0]) = 0;
    BOOL v556 = *((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v596, 0, v614)+ 6) == 0;
  }
  LODWORD(v617) = 1;
  if (*((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v596, 1, &v617)+ 6)|| (LODWORD(v624) = 0, *((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v596, 0, &v624)+ 6))|| (LODWORD(v614[0]) = 1, *((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v595, 1, v614)+ 6)))
  {
    BOOL v557 = 0;
  }
  else
  {
    LODWORD(v606) = 0;
    BOOL v557 = *((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v595, 0, &v606)+ 6) == 0;
  }
  LODWORD(v617) = 2;
  if (*((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v596, 2, &v617)+ 6))
  {
    BOOL v558 = 1;
  }
  else
  {
    LODWORD(v624) = 2;
    BOOL v558 = *((void *)std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(v595, 2, &v624)+ 6) != 0;
  }
  BOOL *v565 = v556;
  v565[1] = v564 & v557;
  v565[2] = v558;
  v559 = v611[0];
  if (v611[0])
  {
    do
    {
      v561 = (void *)*v559;
      v562 = (void *)v559[3];
      if (v562 != (void *)v559[5]) {
        free(v562);
      }
      operator delete(v559);
      v559 = v561;
    }
    while (v561);
  }
  v560 = __p[0];
  __p[0] = 0;
  if (v560) {
    operator delete(v560);
  }
}

void sub_1A18149FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
}

uint64_t *std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = a2[2];
      if (*(unsigned char *)(v2 + 24)) {
        break;
      }
      unint64_t v3 = *(uint64_t **)(v2 + 16);
      uint64_t v4 = *v3;
      if (*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), unint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if (*(uint64_t **)v2 == a2)
          {
            uint64_t v9 = (uint64_t *)a2[2];
          }
          else
          {
            uint64_t v9 = *(uint64_t **)(v2 + 8);
            uint64_t v10 = *v9;
            *(void *)(v2 + 8) = *v9;
            if (v10)
            {
              *(void *)(v10 + 16) = v2;
              unint64_t v3 = *(uint64_t **)(v2 + 16);
            }
            __int16 v9[2] = (uint64_t)v3;
            *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = v9;
            *uint64_t v9 = v2;
            *(void *)(v2 + 16) = v9;
            unint64_t v3 = (uint64_t *)v9[2];
            uint64_t v2 = *v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v14 = *(void *)(v2 + 8);
          *unint64_t v3 = v14;
          if (v14) {
            *(void *)(v14 + 16) = v3;
          }
          *(void *)(v2 + 16) = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          *(void *)(v2 + 8) = v3;
          v3[2] = v2;
          return result;
        }
      }
      else if (!v4 || (v6 = *(unsigned __int8 *)(v4 + 24), unint64_t v5 = (unsigned char *)(v4 + 24), v6))
      {
        if (*(uint64_t **)v2 == a2)
        {
          uint64_t v11 = a2[1];
          *(void *)uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            unint64_t v3 = *(uint64_t **)(v2 + 16);
          }
          a2[2] = (uint64_t)v3;
          *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = a2;
          a2[1] = v2;
          *(void *)(v2 + 16) = a2;
          unint64_t v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        unint64_t v12 = (uint64_t *)v3[1];
        uint64_t v13 = *v12;
        v3[1] = *v12;
        if (v13) {
          *(void *)(v13 + 16) = v3;
        }
        v12[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v12;
        *unint64_t v12 = (uint64_t)v3;
        v3[2] = (uint64_t)v12;
        return result;
      }
      *(unsigned char *)(v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*a1);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a1[1]);
    operator delete(a1);
  }
}

char *std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus&&>,std::tuple<>>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (char *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = *((void *)v10 + 1);
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = *(char **)v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = (void *)(a1 + 16);
  uint64_t v10 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_34;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *(void *)uint64_t v10 = *v24;
LABEL_58:
    *uint64_t v24 = v10;
    goto LABEL_59;
  }
  *(void *)uint64_t v10 = *v13;
  *uint64_t v13 = v10;
  *(void *)(v23 + 8 * v3) = v13;
  if (*(void *)v10)
  {
    unint64_t v25 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A18150C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

BOOL std::__function::__func<gdc::FragmentCollector<md::MapDataType,82ul>::validFragmentsForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1},std::allocator<gdc::FragmentCollector<md::MapDataType,82ul>::validFragmentsForTile(geo::QuadTile const&,std::bitset<82ul> const&,std::unordered_set<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>> &)::{lambda(std::bitset<82ul> const&)#1}>,BOOL ()(std::bitset<82ul> const&)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  return *(void *)a2 == *(void *)v2 && ((*(_DWORD *)(v2 + 8) ^ *(_DWORD *)(a2 + 8)) & 0x3FFFFLL) == 0;
}

char *std::__hash_table<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::__unordered_map_hasher<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::hash<gdc::LayerDataStatus>,std::equal_to<gdc::LayerDataStatus>,true>,std::__unordered_map_equal<gdc::LayerDataStatus,std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>,std::equal_to<gdc::LayerDataStatus>,std::hash<gdc::LayerDataStatus>,true>,std::allocator<std::__hash_value_type<gdc::LayerDataStatus,std::unordered_map<md::MapDataType,unsigned long>>>>::__emplace_unique_key_args<gdc::LayerDataStatus,std::piecewise_construct_t const&,std::tuple<gdc::LayerDataStatus const&>,std::tuple<>>(uint64_t a1, int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (char *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = *((void *)v10 + 1);
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = *(char **)v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v13 = (void *)(a1 + 16);
  uint64_t v10 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  float v14 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v15 = *(float *)(a1 + 32);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(a1 + 8);
    }
    if (prime > v7) {
      goto LABEL_34;
    }
    if (prime < v7)
    {
      unint64_t v20 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v7 < 3 || (uint8x8_t v21 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v21.i16[0] = vaddlv_u8(v21), v21.u32[0] > 1uLL))
      {
        unint64_t v20 = std::__next_prime(v20);
      }
      else
      {
        uint64_t v22 = 1 << -(char)__clz(v20 - 1);
        if (v20 >= 2) {
          unint64_t v20 = v22;
        }
      }
      if (prime <= v20) {
        size_t prime = v20;
      }
      if (prime < v7) {
LABEL_34:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
      else {
        unint64_t v3 = v6;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
  }
  uint64_t v23 = *(void *)a1;
  uint64_t v24 = *(void **)(*(void *)a1 + 8 * v3);
  if (v24)
  {
    *(void *)uint64_t v10 = *v24;
LABEL_58:
    *uint64_t v24 = v10;
    goto LABEL_59;
  }
  *(void *)uint64_t v10 = *v13;
  *uint64_t v13 = v10;
  *(void *)(v23 + 8 * v3) = v13;
  if (*(void *)v10)
  {
    unint64_t v25 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v25 >= v7) {
        v25 %= v7;
      }
    }
    else
    {
      v25 &= v7 - 1;
    }
    uint64_t v24 = (void *)(*(void *)a1 + 8 * v25);
    goto LABEL_58;
  }
LABEL_59:
  ++*(void *)(a1 + 24);
  return v10;
}

void sub_1A1815408(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<md::MapDataType,unsigned long>,std::__unordered_map_hasher<md::MapDataType,std::__hash_value_type<md::MapDataType,unsigned long>,std::hash<md::MapDataType>,std::equal_to<md::MapDataType>,true>,std::__unordered_map_equal<md::MapDataType,std::__hash_value_type<md::MapDataType,unsigned long>,std::equal_to<md::MapDataType>,std::hash<md::MapDataType>,true>,std::allocator<std::__hash_value_type<md::MapDataType,unsigned long>>>::__emplace_unique_key_args<md::MapDataType,std::piecewise_construct_t const&,std::tuple<md::MapDataType const&>,std::tuple<>>(float *a1, unsigned __int16 a2, _WORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (*((unsigned __int16 *)v10 + 8) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_23;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (*((unsigned __int16 *)v10 + 8) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_23:
  uint64_t v10 = operator new(0x20uLL);
  *uint64_t v10 = 0;
  v10[1] = v6;
  *((_WORD *)v10 + 8) = *a3;
  v10[3] = 0;
  float v13 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v14 = a1[8];
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v15 = 1;
    if (v7 >= 3) {
      BOOL v15 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v16 = v15 | (2 * v7);
    unint64_t v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17) {
      size_t prime = v17;
    }
    else {
      size_t prime = v16;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *((void *)a1 + 1);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_60;
      }
      unint64_t v30 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_60:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_73;
      }
      if (!prime)
      {
        char v40 = *(void **)a1;
        *(void *)a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_60;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v19 = operator new(8 * prime);
    unint64_t v20 = *(void **)a1;
    *(void *)a1 = v19;
    if (v20) {
      operator delete(v20);
    }
    uint64_t v21 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v21++) = 0;
    while (prime != v21);
    uint64_t v23 = (uint64_t *)(a1 + 4);
    uint64_t v22 = (void *)*((void *)a1 + 2);
    if (!v22)
    {
LABEL_59:
      unint64_t v7 = prime;
      goto LABEL_60;
    }
    size_t v24 = v22[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*(void *)a1 + 8 * v26) = v23;
      for (uint64_t i = (void *)*v22; *v22; uint64_t i = (void *)*v22)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          uint64_t v22 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v28))
        {
          void *v22 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*(void *)a1 + v29);
          **(void **)(*(void *)a1 + v29) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v28) = v22;
          uint64_t v22 = i;
          size_t v26 = v28;
        }
      }
      goto LABEL_59;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v24) = v23;
    unint64_t v33 = (void *)*v22;
    if (!*v22) {
      goto LABEL_59;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*(void *)a1 + 8 * v35))
        {
          *(void *)(*(void *)a1 + 8 * v35) = v22;
          goto LABEL_64;
        }
        void *v22 = *v33;
        uint64_t v34 = 8 * v35;
        void *v33 = **(void **)(*(void *)a1 + v34);
        **(void **)(*(void *)a1 + v34) = v33;
        unint64_t v33 = v22;
      }
      size_t v35 = v24;
LABEL_64:
      uint64_t v22 = v33;
      unint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_59;
      }
    }
  }
LABEL_73:
  unint64_t v36 = *(void **)a1;
  __int16 v37 = *(void **)(*(void *)a1 + 8 * v3);
  if (v37)
  {
    *uint64_t v10 = *v37;
LABEL_81:
    void *v37 = v10;
    goto LABEL_82;
  }
  *uint64_t v10 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v10;
  v36[v3] = a1 + 4;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    __int16 v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_81;
  }
LABEL_82:
  ++*((void *)a1 + 3);
  return v10;
}

void sub_1A1815880(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

unsigned __int16 *geo::linear_map<unsigned short,std::set<gdc::LayerDataWithWorld>,std::equal_to<unsigned short>,std::allocator<std::pair<unsigned short,std::set<gdc::LayerDataWithWorld>>>,std::vector<std::pair<unsigned short,std::set<gdc::LayerDataWithWorld>>>>::operator[](char **a1, unsigned __int16 a2)
{
  uint64_t v4 = (unsigned __int16 *)*a1;
  unint64_t v5 = (unint64_t)a1[1];
  unint64_t v6 = (unsigned __int16 *)*a1;
  if (*a1 != (char *)v5)
  {
    unint64_t v6 = (unsigned __int16 *)*a1;
    while (*v6 != a2)
    {
      v6 += 16;
      if (v6 == (unsigned __int16 *)v5) {
        goto LABEL_7;
      }
    }
  }
  if (v6 == (unsigned __int16 *)v5)
  {
LABEL_7:
    v29[0] = 0;
    v29[1] = 0;
    unint64_t v6 = v4;
    if (v4 != (unsigned __int16 *)v5)
    {
      while (*v6 != a2)
      {
        v6 += 16;
        if (v6 == (unsigned __int16 *)v5) {
          goto LABEL_13;
        }
      }
    }
    if (v6 != (unsigned __int16 *)v5)
    {
      unint64_t v7 = 0;
LABEL_36:
      std::__tree<gdc::LayerDataWithWorld>::destroy(v7);
      std::__tree<gdc::LayerDataWithWorld>::destroy(0);
      return v6 + 4;
    }
LABEL_13:
    unint64_t v8 = (unint64_t)a1[2];
    if (v5 >= v8)
    {
      uint64_t v10 = (uint64_t)(v5 - (void)v4) >> 5;
      if ((unint64_t)(v10 + 1) >> 59) {
        abort();
      }
      uint64_t v11 = v8 - (void)v4;
      uint64_t v12 = v11 >> 4;
      if (v11 >> 4 <= (unint64_t)(v10 + 1)) {
        uint64_t v12 = v10 + 1;
      }
      if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFE0) {
        unint64_t v13 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v13 = v12;
      }
      unint64_t v33 = a1 + 2;
      if (v13)
      {
        if (v13 >> 59) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        float v14 = (char *)operator new(32 * v13);
      }
      else
      {
        float v14 = 0;
      }
      BOOL v15 = &v14[32 * v10];
      v29[2] = v14;
      unint64_t v30 = v15;
      uint8x8_t v31 = v15;
      uint64_t v32 = &v14[32 * v13];
      *(_WORD *)BOOL v15 = a2;
      *((void *)v15 + 2) = 0;
      *((void *)v15 + 3) = 0;
      *((void *)v15 + 1) = v15 + 16;
      std::set<gdc::LayerDataWithWorld>::insert[abi:nn180100]<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>((uint64_t *)v15 + 1, v29, v29);
      unint64_t v16 = v30;
      uint64_t v9 = v31 + 32;
      unint64_t v17 = (unsigned __int16 *)*a1;
      unint64_t v18 = a1[1];
      if (v18 == *a1)
      {
        *a1 = v30;
        a1[1] = v9;
        a1[2] = v32;
        if (!v18) {
          goto LABEL_35;
        }
      }
      else
      {
        uint64_t v19 = 0;
        do
        {
          unint64_t v20 = &v16[v19];
          *((_WORD *)v20 - 16) = *(_WORD *)&v18[v19 - 32];
          *((void *)v20 - 3) = *(void *)&v18[v19 - 24];
          uint64_t v21 = &v18[v19 - 16];
          uint64_t v22 = *(void *)v21;
          *(void *)&v16[v19 - 16] = *(void *)v21;
          uint64_t v23 = (uint64_t)&v16[v19 - 16];
          uint64_t v24 = *(void *)&v18[v19 - 8];
          *((void *)v20 - 1) = v24;
          if (v24)
          {
            *(void *)(v22 + 16) = v23;
            *(void *)&v18[v19 - 24] = v21;
            *(void *)uint64_t v21 = 0;
            *(void *)&v18[v19 - 8] = 0;
          }
          else
          {
            *((void *)v20 - 3) = v23;
          }
          v19 -= 32;
        }
        while (&v18[v19] != (char *)v17);
        size_t v25 = &v16[v19];
        unint64_t v18 = *a1;
        size_t v26 = a1[1];
        *a1 = v25;
        a1[1] = v9;
        a1[2] = v32;
        if (v26 != v18)
        {
          do
          {
            uint64_t v27 = v26 - 32;
            std::__tree<gdc::LayerDataWithWorld>::destroy(*((void **)v26 - 2));
            size_t v26 = v27;
          }
          while (v27 != v18);
        }
        if (!v18) {
          goto LABEL_35;
        }
      }
      operator delete(v18);
    }
    else
    {
      *(_WORD *)unint64_t v5 = a2;
      *(void *)(v5 + 24) = 0;
      *(void *)(v5 + 16) = 0;
      *(void *)(v5 + 8) = v5 + 16;
      std::set<gdc::LayerDataWithWorld>::insert[abi:nn180100]<std::__tree_const_iterator<gdc::LayerDataWithWorld,std::__tree_node<gdc::LayerDataWithWorld,void *> *,long>>((uint64_t *)(v5 + 8), v29, v29);
      uint64_t v9 = (char *)(v5 + 32);
      a1[1] = (char *)(v5 + 32);
    }
LABEL_35:
    a1[1] = v9;
    unint64_t v6 = (unsigned __int16 *)(v9 - 32);
    unint64_t v7 = (void *)v29[0];
    goto LABEL_36;
  }
  return v6 + 4;
}

void sub_1A1815B1C(_Unwind_Exception *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::__tree<gdc::LayerDataWithWorld>::destroy(*v8);
  std::__split_buffer<std::pair<unsigned short,std::set<gdc::LayerDataWithWorld>>>::~__split_buffer((uint64_t)va);
  std::__tree<gdc::LayerDataWithWorld>::destroy(a7);
  std::__tree<gdc::LayerDataWithWorld>::destroy(a3);
  _Unwind_Resume(a1);
}

unsigned __int16 *std::__hash_table<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::__unordered_map_hasher<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::hash<md::TileSelectionTileSetType>,std::equal_to<md::TileSelectionTileSetType>,true>,std::__unordered_map_equal<md::TileSelectionTileSetType,std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,std::equal_to<md::TileSelectionTileSetType>,std::hash<md::TileSelectionTileSetType>,true>,std::allocator<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>>>::__emplace_unique_key_args<md::TileSelectionTileSetType,std::piecewise_construct_t const&,std::tuple<md::TileSelectionTileSetType const&>,std::tuple<>>(uint64_t *a1, unsigned __int16 a2, unsigned __int16 *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (unsigned __int16 *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = *((void *)v10 + 1);
            if (v12 == a2)
            {
              if (v10[8] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = *(unsigned __int16 **)v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (v10[8] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = *(unsigned __int16 **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  unint64_t v13 = a1 + 2;
  uint64_t v10 = (unsigned __int16 *)operator new(0x40uLL);
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = v6;
  v10[8] = *a3;
  *(_OWORD *)(v10 + 12) = 0u;
  *(_OWORD *)(v10 + 20) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = a1[1];
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_59;
      }
      unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
      {
        unint64_t v30 = std::__next_prime(v30);
      }
      else
      {
        uint64_t v32 = 1 << -(char)__clz(v30 - 1);
        if (v30 >= 2) {
          unint64_t v30 = v32;
        }
      }
      if (prime <= v30) {
        size_t prime = v30;
      }
      if (prime >= v7)
      {
        unint64_t v7 = a1[1];
LABEL_59:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= v6) {
            unint64_t v3 = v6 % v7;
          }
          else {
            unint64_t v3 = v6;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & v6;
        }
        goto LABEL_72;
      }
      if (!prime)
      {
        char v40 = (void *)*a1;
        *a1 = 0;
        if (v40) {
          operator delete(v40);
        }
        unint64_t v7 = 0;
        a1[1] = 0;
        goto LABEL_59;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    unint64_t v20 = operator new(8 * prime);
    uint64_t v21 = (void *)*a1;
    *a1 = (uint64_t)v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v22++) = 0;
    while (prime != v22);
    uint64_t v23 = (void *)*v13;
    if (!*v13)
    {
LABEL_58:
      unint64_t v7 = prime;
      goto LABEL_59;
    }
    size_t v24 = v23[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*a1 + 8 * v26) = v13;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          uint64_t v23 = i;
        }
        else if (*(void *)(*a1 + 8 * v28))
        {
          *uint64_t v23 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*a1 + v29);
          **(void **)(*a1 + v29) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v28) = v23;
          uint64_t v23 = i;
          size_t v26 = v28;
        }
      }
      goto LABEL_58;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*a1 + 8 * v24) = v13;
    unint64_t v33 = (void *)*v23;
    if (!*v23) {
      goto LABEL_58;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*a1 + 8 * v35))
        {
          *(void *)(*a1 + 8 * v35) = v23;
          goto LABEL_63;
        }
        *uint64_t v23 = *v33;
        uint64_t v34 = 8 * v35;
        void *v33 = **(void **)(*a1 + v34);
        **(void **)(*a1 + v34) = v33;
        unint64_t v33 = v23;
      }
      size_t v35 = v24;
LABEL_63:
      uint64_t v23 = v33;
      unint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_58;
      }
    }
  }
LABEL_72:
  uint64_t v36 = *a1;
  __int16 v37 = *(void **)(*a1 + 8 * v3);
  if (v37)
  {
    *(void *)uint64_t v10 = *v37;
LABEL_80:
    void *v37 = v10;
    goto LABEL_81;
  }
  *(void *)uint64_t v10 = *v13;
  *unint64_t v13 = v10;
  *(void *)(v36 + 8 * v3) = v13;
  if (*(void *)v10)
  {
    unint64_t v38 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    __int16 v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_80;
  }
LABEL_81:
  ++a1[3];
  return v10;
}

void sub_1A1815FCC(_Unwind_Exception *a1)
{
  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::TileSelectionTileSetType,std::unordered_map<unsigned short,std::unordered_map<geo::QuadTile,std::bitset<8ul>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<std::pair<geo::QuadTile const,std::bitset<8ul>>>>>>,void *>>>::operator()[abi:nn180100](1, v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::SceneStateManager::updateSceneTileSet(md::SceneTileSet &,md::TileSelectionTileSetType)::$_0,std::allocator<md::SceneStateManager::updateSceneTileSet(md::SceneTileSet &,md::TileSelectionTileSetType)::$_0>,void ()(md::MapDataType)>::operator()(uint64_t result, unsigned __int16 *a2)
{
  unint64_t v2 = *a2;
  if (v2 >= 0x52) {
    abort();
  }
  *(void *)(*(void *)(result + 8) + ((v2 >> 3) & 0x1FF8)) |= 1 << v2;
  return result;
}

void gss::StyleSheet<gss::ScenePropertyID>::styleMatchingAttributes(void *a1, uint64_t a2, uint64_t a3)
{
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit(a3);
  uint64_t v7 = *(void *)(a3 + 8);
  *(void *)&long long v98 = *(void *)a3;
  DWORD2(v98) = v7;
  WORD6(v98) = WORD2(v7);
  HIWORD(v98) = *(_WORD *)(a3 + 14);
  *(void *)(a3 + 7) = 0;
  *(void *)a3 = 0;
  *(unsigned char *)(a3 + 15) = 1;
  uint8x8_t v8 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(a2 + 2528));
  if (v8) {
    geo::read_write_lock::logFailure(v8, (uint64_t)"read lock", v9);
  }
  if (WORD5(v98))
  {
    unint64_t v11 = 0;
    uint64_t v12 = 0;
    unsigned int v13 = 0;
    do
    {
      if (v13 < WORD5(v98))
      {
        uint64_t v12 = (unsigned int *)(v98 + 4 * v13);
        uint64_t v10 = (unsigned __int16 *)(v98 + WORD4(v98) + 2 * v13);
      }
      v11 ^= (*v10
            - 0x61C8864680B583EBLL
            + ((((v11 << 6) - 0x61C8864680B583EBLL + (v11 >> 2) + *v12) ^ v11) << 6)
            + ((((v11 << 6) - 0x61C8864680B583EBLL + (v11 >> 2) + *v12) ^ v11) >> 2)) ^ ((v11 << 6)
                                                                                       - 0x61C8864680B583EBLL
                                                                                       + (v11 >> 2)
                                                                                       + *v12);
      unsigned int v14 = v13 + 1;
      if (v13 + 1 < WORD5(v98)) {
        ++v13;
      }
      else {
        unsigned int v13 = WORD5(v98);
      }
    }
    while (v14 < WORD5(v98));
    int8x8_t v15 = *(int8x8_t *)(a2 + 2736);
    if (!*(void *)&v15)
    {
LABEL_63:
      size_t v35 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(a2 + 2528));
      if (v35) {
        geo::read_write_lock::logFailure(v35, (uint64_t)"unlock", v36);
      }
      unsigned __int8 v37 = atomic_load((unsigned __int8 *)(a2 + 2786));
      if ((v37 & 1) == 0) {
        std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(a2 + 2816));
      }
      unsigned __int8 v38 = atomic_load((unsigned __int8 *)(a2 + 2787));
      if ((v38 & 1) == 0)
      {
        *a1 = 0;
        a1[1] = 0;
        goto LABEL_194;
      }
      gss::StyleMatchingTreeNode<gss::CartoStyle<gss::ScenePropertyID>>::matchAttributes(a1, **(_DWORD ***)(a2 + 160), (uint64_t)&v98, v99, (uint64_t *)(*(void *)(a2 + 160) + 8), (uint64_t *)(a2 + 64), (void *)(*(void *)(a2 + 160) + 24));
      uint64_t v39 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(a2 + 2528));
      if (v39) {
        geo::read_write_lock::logFailure(v39, (uint64_t)"write lock", v40);
      }
      if (WORD5(v98))
      {
        unint64_t v42 = 0;
        long long v43 = 0;
        unsigned int v44 = 0;
        do
        {
          if (v44 < WORD5(v98))
          {
            long long v43 = (unsigned int *)(v98 + 4 * v44);
            int v41 = (unsigned __int16 *)(v98 + WORD4(v98) + 2 * v44);
          }
          unint64_t v45 = ((v42 << 6) - 0x61C8864680B583EBLL + (v42 >> 2) + *v43) ^ v42;
          unint64_t v42 = (*v41 - 0x61C8864680B583EBLL + (v45 << 6) + (v45 >> 2)) ^ v45;
          unsigned int v46 = v44 + 1;
          if (v44 + 1 < WORD5(v98)) {
            ++v44;
          }
          else {
            unsigned int v44 = WORD5(v98);
          }
        }
        while (v46 < WORD5(v98));
        unint64_t v47 = *(void *)(a2 + 2736);
        if (v47)
        {
LABEL_80:
          uint8x8_t v48 = (uint8x8_t)vcnt_s8((int8x8_t)v47);
          v48.i16[0] = vaddlv_u8(v48);
          if (v48.u32[0] > 1uLL)
          {
            unint64_t v3 = v42;
            if (v42 >= v47) {
              unint64_t v3 = v42 % v47;
            }
          }
          else
          {
            unint64_t v3 = (v47 - 1) & v42;
          }
          unint64_t v49 = *(uint64_t ***)(*(void *)(a2 + 2728) + 8 * v3);
          if (v49)
          {
            BOOL v50 = *v49;
            if (v50)
            {
              unint64_t v51 = v47 - 1;
              if (WORD5(v98))
              {
                unint64_t v52 = (unsigned __int16 *)(v98 + WORD4(v98));
                if (v48.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v53 = v50[1];
                    if (v53 == v42)
                    {
                      if (WORD5(v98) == *((unsigned __int16 *)v50 + 13))
                      {
                        uint8x8_t v54 = (_DWORD *)v50[2];
                        if (*(_DWORD *)v98 == *v54)
                        {
                          unint64_t v55 = (unsigned __int16 *)((char *)v54 + *((unsigned __int16 *)v50 + 12));
                          if (*v52 == *v55)
                          {
                            uint64_t v56 = 1;
                            do
                            {
                              if (WORD5(v98) == v56) {
                                goto LABEL_192;
                              }
                              unint64_t v57 = v56;
                              if (*(_DWORD *)(v98 + 4 * v56) != v54[v56]) {
                                break;
                              }
                              ++v56;
                            }
                            while (v52[v57] == v55[v57]);
                            if (v57 >= WORD5(v98)) {
                              goto LABEL_192;
                            }
                          }
                        }
                      }
                    }
                    else if ((v53 & v51) != v3)
                    {
                      goto LABEL_130;
                    }
                    BOOL v50 = (uint64_t *)*v50;
                    if (!v50) {
                      goto LABEL_130;
                    }
                  }
                }
                while (1)
                {
                  unint64_t v58 = v50[1];
                  if (v58 == v42)
                  {
                    if (WORD5(v98) == *((unsigned __int16 *)v50 + 13))
                    {
                      unint64_t v59 = (_DWORD *)v50[2];
                      if (*(_DWORD *)v98 == *v59)
                      {
                        uint64_t v60 = (unsigned __int16 *)((char *)v59 + *((unsigned __int16 *)v50 + 12));
                        if (*v52 == *v60)
                        {
                          uint64_t v61 = 1;
                          do
                          {
                            if (WORD5(v98) == v61) {
                              goto LABEL_192;
                            }
                            unint64_t v62 = v61;
                            if (*(_DWORD *)(v98 + 4 * v61) != v59[v61]) {
                              break;
                            }
                            ++v61;
                          }
                          while (v52[v62] == v60[v62]);
                          if (v62 >= WORD5(v98)) {
                            goto LABEL_192;
                          }
                        }
                      }
                    }
                  }
                  else
                  {
                    if (v58 >= v47) {
                      v58 %= v47;
                    }
                    if (v58 != v3) {
                      goto LABEL_130;
                    }
                  }
                  BOOL v50 = (uint64_t *)*v50;
                  if (!v50) {
                    goto LABEL_130;
                  }
                }
              }
              if (v48.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v63 = v50[1];
                  if (v63 == v42)
                  {
                    if (!*((_WORD *)v50 + 13)) {
                      goto LABEL_192;
                    }
                  }
                  else if ((v63 & v51) != v3)
                  {
                    goto LABEL_130;
                  }
                  BOOL v50 = (uint64_t *)*v50;
                  if (!v50) {
                    goto LABEL_130;
                  }
                }
              }
              do
              {
                unint64_t v64 = v50[1];
                if (v64 == v42)
                {
                  if (!*((_WORD *)v50 + 13)) {
                    goto LABEL_192;
                  }
                }
                else
                {
                  if (v64 >= v47) {
                    v64 %= v47;
                  }
                  if (v64 != v3) {
                    break;
                  }
                }
                BOOL v50 = (uint64_t *)*v50;
              }
              while (v50);
            }
          }
        }
      }
      else
      {
        unint64_t v42 = 0;
        unint64_t v47 = *(void *)(a2 + 2736);
        if (v47) {
          goto LABEL_80;
        }
      }
LABEL_130:
      uint64_t v65 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 2760) + 16))(*(void *)(a2 + 2760), 48, 8);
      v99[0] = v65;
      v99[1] = a2 + 2760;
      *(void *)uint64_t v65 = 0;
      *(void *)(v65 + 8) = v42;
      uint64_t v66 = *((void *)&v98 + 1);
      *(void *)(v65 + 16) = v98;
      *(_DWORD *)(v65 + 24) = v66;
      *(_WORD *)(v65 + 28) = WORD2(v66);
      *(_WORD *)(v65 + 30) = HIWORD(v98);
      *(void *)&long long v98 = 0;
      *(void *)((char *)&v98 + 7) = 0;
      HIBYTE(v98) = 1;
      *(void *)(v65 + 32) = *a1;
      uint64_t v67 = a1[1];
      *(void *)(v65 + 40) = v67;
      if (v67) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v67 + 8), 1uLL, memory_order_relaxed);
      }
      char v100 = 1;
      float v68 = (float)(unint64_t)(*(void *)(a2 + 2768) + 1);
      float v69 = *(float *)(a2 + 2776);
      if (v47 && (float)(v69 * (float)v47) >= v68)
      {
LABEL_182:
        uint64_t v93 = *(uint64_t **)(*(void *)(a2 + 2728) + 8 * v3);
        if (v93)
        {
          *(void *)uint64_t v65 = *v93;
        }
        else
        {
          *(void *)uint64_t v65 = *(void *)(a2 + 2752);
          *(void *)(a2 + 2752) = v65;
          *(void *)(*(void *)(a2 + 2728) + 8 * v3) = a2 + 2752;
          if (!*(void *)v65)
          {
LABEL_191:
            ++*(void *)(a2 + 2768);
            goto LABEL_192;
          }
          unint64_t v94 = *(void *)(*(void *)v65 + 8);
          if ((v47 & (v47 - 1)) != 0)
          {
            if (v94 >= v47) {
              v94 %= v47;
            }
          }
          else
          {
            v94 &= v47 - 1;
          }
          uint64_t v93 = (uint64_t *)(*(void *)(a2 + 2728) + 8 * v94);
        }
        *uint64_t v93 = v65;
        goto LABEL_191;
      }
      BOOL v70 = v47 < 3 || (v47 & (v47 - 1)) != 0;
      unint64_t v71 = v70 | (2 * v47);
      unint64_t v72 = vcvtps_u32_f32(v68 / v69);
      if (v71 <= v72) {
        size_t prime = v72;
      }
      else {
        size_t prime = v71;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
      }
      unint64_t v47 = *(void *)(a2 + 2736);
      if (prime <= v47)
      {
        if (prime >= v47) {
          goto LABEL_169;
        }
        unint64_t v86 = vcvtps_u32_f32((float)*(unint64_t *)(a2 + 2768) / *(float *)(a2 + 2776));
        if (v47 < 3 || (uint8x8_t v87 = (uint8x8_t)vcnt_s8((int8x8_t)v47), v87.i16[0] = vaddlv_u8(v87), v87.u32[0] > 1uLL))
        {
          unint64_t v86 = std::__next_prime(v86);
        }
        else
        {
          uint64_t v88 = 1 << -(char)__clz(v86 - 1);
          if (v86 >= 2) {
            unint64_t v86 = v88;
          }
        }
        if (prime <= v86) {
          size_t prime = v86;
        }
        if (prime >= v47)
        {
          unint64_t v47 = *(void *)(a2 + 2736);
LABEL_169:
          if ((v47 & (v47 - 1)) != 0)
          {
            if (v42 >= v47) {
              unint64_t v3 = v42 % v47;
            }
            else {
              unint64_t v3 = v42;
            }
          }
          else
          {
            unint64_t v3 = (v47 - 1) & v42;
          }
          goto LABEL_182;
        }
        if (!prime)
        {
          uint64_t v97 = *(void *)(a2 + 2728);
          *(void *)(a2 + 2728) = 0;
          if (v97) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 2744) + 40))(*(void *)(a2 + 2744), v97, 8 * *(void *)(a2 + 2736));
          }
          unint64_t v47 = 0;
          *(void *)(a2 + 2736) = 0;
          goto LABEL_169;
        }
      }
      uint64_t v74 = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(a2 + 2744) + 16))(*(void *)(a2 + 2744), 8 * prime, 8);
      uint64_t v75 = *(void *)(a2 + 2728);
      *(void *)(a2 + 2728) = v74;
      if (v75) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 2744) + 40))(*(void *)(a2 + 2744), v75, 8 * *(void *)(a2 + 2736));
      }
      uint64_t v76 = 0;
      *(void *)(a2 + 2736) = prime;
      do
        *(void *)(*(void *)(a2 + 2728) + 8 * v76++) = 0;
      while (prime != v76);
      uint64_t v77 = *(void **)(a2 + 2752);
      if (!v77)
      {
LABEL_168:
        unint64_t v47 = prime;
        goto LABEL_169;
      }
      uint64_t v78 = a2 + 2752;
      size_t v79 = v77[1];
      size_t v80 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v81 = v79 & v80;
        *(void *)(*(void *)(a2 + 2728) + 8 * v81) = v78;
        for (uint64_t i = (void *)*v77; *v77; uint64_t i = (void *)*v77)
        {
          size_t v83 = i[1] & v80;
          if (v83 == v81)
          {
            uint64_t v77 = i;
          }
          else
          {
            uint64_t v84 = *(void *)(a2 + 2728);
            if (*(void *)(v84 + 8 * v83))
            {
              *uint64_t v77 = *i;
              uint64_t v85 = 8 * v83;
              void *i = **(void **)(*(void *)(a2 + 2728) + v85);
              **(void **)(*(void *)(a2 + 2728) + v85) = i;
            }
            else
            {
              *(void *)(v84 + 8 * v83) = v77;
              uint64_t v77 = i;
              size_t v81 = v83;
            }
          }
        }
        goto LABEL_168;
      }
      if (v79 >= prime) {
        v79 %= prime;
      }
      *(void *)(*(void *)(a2 + 2728) + 8 * v79) = v78;
      char v89 = (void *)*v77;
      if (!*v77) {
        goto LABEL_168;
      }
      while (1)
      {
        size_t v91 = v89[1];
        if (v91 >= prime) {
          v91 %= prime;
        }
        if (v91 != v79)
        {
          uint64_t v92 = *(void *)(a2 + 2728);
          if (!*(void *)(v92 + 8 * v91))
          {
            *(void *)(v92 + 8 * v91) = v77;
            goto LABEL_173;
          }
          *uint64_t v77 = *v89;
          uint64_t v90 = 8 * v91;
          *char v89 = **(void **)(*(void *)(a2 + 2728) + v90);
          **(void **)(*(void *)(a2 + 2728) + v90) = v89;
          char v89 = v77;
        }
        size_t v91 = v79;
LABEL_173:
        uint64_t v77 = v89;
        char v89 = (void *)*v89;
        size_t v79 = v91;
        if (!v89) {
          goto LABEL_168;
        }
      }
    }
  }
  else
  {
    unint64_t v11 = 0;
    int8x8_t v15 = *(int8x8_t *)(a2 + 2736);
    if (!*(void *)&v15) {
      goto LABEL_63;
    }
  }
  uint8x8_t v16 = (uint8x8_t)vcnt_s8(v15);
  v16.i16[0] = vaddlv_u8(v16);
  if (v16.u32[0] > 1uLL)
  {
    unint64_t v17 = v11;
    if (v11 >= *(void *)&v15) {
      unint64_t v17 = v11 % *(void *)&v15;
    }
  }
  else
  {
    unint64_t v17 = (*(void *)&v15 - 1) & v11;
  }
  unint64_t v18 = *(uint64_t ***)(*(void *)(a2 + 2728) + 8 * v17);
  if (!v18) {
    goto LABEL_63;
  }
  uint64_t v19 = *v18;
  if (!v19) {
    goto LABEL_63;
  }
  uint64_t v20 = *(void *)&v15 - 1;
  if (WORD5(v98))
  {
    uint64_t v21 = (unsigned __int16 *)(v98 + WORD4(v98));
    if (v16.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v22 = v19[1];
        if (v22 == v11)
        {
          if (WORD5(v98) == *((unsigned __int16 *)v19 + 13))
          {
            uint64_t v23 = (_DWORD *)v19[2];
            if (*(_DWORD *)v98 == *v23)
            {
              size_t v24 = (unsigned __int16 *)((char *)v23 + *((unsigned __int16 *)v19 + 12));
              if (*v21 == *v24)
              {
                uint64_t v25 = 1;
                do
                {
                  if (WORD5(v98) == v25) {
                    goto LABEL_34;
                  }
                  unint64_t v26 = v25;
                  if (*(_DWORD *)(v98 + 4 * v25) != v23[v25]) {
                    break;
                  }
                  ++v25;
                }
                while (v21[v26] == v24[v26]);
                if (v26 >= WORD5(v98)) {
                  goto LABEL_34;
                }
              }
            }
          }
        }
        else if ((v22 & v20) != v17)
        {
          goto LABEL_63;
        }
        uint64_t v19 = (uint64_t *)*v19;
        if (!v19) {
          goto LABEL_63;
        }
      }
    }
    while (1)
    {
      unint64_t v28 = v19[1];
      if (v28 == v11)
      {
        if (WORD5(v98) == *((unsigned __int16 *)v19 + 13))
        {
          uint64_t v29 = (_DWORD *)v19[2];
          if (*(_DWORD *)v98 == *v29)
          {
            unint64_t v30 = (unsigned __int16 *)((char *)v29 + *((unsigned __int16 *)v19 + 12));
            if (*v21 == *v30)
            {
              uint64_t v31 = 1;
              do
              {
                if (WORD5(v98) == v31) {
                  goto LABEL_34;
                }
                unint64_t v32 = v31;
                if (*(_DWORD *)(v98 + 4 * v31) != v29[v31]) {
                  break;
                }
                ++v31;
              }
              while (v21[v32] == v30[v32]);
              if (v32 >= WORD5(v98)) {
                goto LABEL_34;
              }
            }
          }
        }
      }
      else
      {
        if (v28 >= *(void *)&v15) {
          v28 %= *(void *)&v15;
        }
        if (v28 != v17) {
          goto LABEL_63;
        }
      }
      uint64_t v19 = (uint64_t *)*v19;
      if (!v19) {
        goto LABEL_63;
      }
    }
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v33 = v19[1];
      if (v33 == v11)
      {
        if (!*((_WORD *)v19 + 13)) {
          goto LABEL_34;
        }
      }
      else if ((v33 & v20) != v17)
      {
        goto LABEL_63;
      }
      uint64_t v19 = (uint64_t *)*v19;
      if (!v19) {
        goto LABEL_63;
      }
    }
  }
  while (1)
  {
    unint64_t v34 = v19[1];
    if (v34 == v11) {
      break;
    }
    if (v34 >= *(void *)&v15) {
      v34 %= *(void *)&v15;
    }
    if (v34 != v17) {
      goto LABEL_63;
    }
LABEL_58:
    uint64_t v19 = (uint64_t *)*v19;
    if (!v19) {
      goto LABEL_63;
    }
  }
  if (*((_WORD *)v19 + 13)) {
    goto LABEL_58;
  }
LABEL_34:
  *a1 = v19[4];
  uint64_t v27 = v19[5];
  a1[1] = v27;
  if (v27) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
  }
LABEL_192:
  size_t v35 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(a2 + 2528));
  if (v35) {
    geo::read_write_lock::logFailure(v35, (uint64_t)"unlock", v95);
  }
LABEL_194:
  if (!BYTE14(v98))
  {
    if ((void)v98)
    {
      uint64_t v96 = gss::Allocator::instance(v35);
      (*(void (**)(uint64_t, void, void))(*(void *)v96 + 40))(v96, v98, WORD6(v98));
    }
  }
}

void sub_1A1816B84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, pthread_rwlock_t *a9, char a10, uint64_t a11, uint64_t a12)
{
  a12 = 0;
  std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,void *>,gss::Allocator>>::operator()[abi:nn180100](v14, v13);
  geo::write_lock_guard::~write_lock_guard(&a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v12);
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)&a10);
  _Unwind_Resume(a1);
}

void gss::StyleMatchingTreeNode<gss::CartoStyle<gss::ScenePropertyID>>::matchAttributes(void *a1, _DWORD *a2, uint64_t a3, _DWORD *a4, uint64_t *a5, uint64_t *a6, void *a7)
{
  unint64_t v11 = a2;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = *a2;
  if (*a2 == 0x7FFFFFFF)
  {
LABEL_2:
    if (gss::MatchingGraphEndChain::matches((uint64_t *)(*a7 + 16 * *((unsigned __int16 *)v11 + 3)), a3))
    {
      uint64_t v14 = *((unsigned __int16 *)v11 + 2);
      uint64_t v15 = *a6;
      uint64_t v16 = *(void *)(*a6 + 16 * v14);
      if (v16)
      {
        *a4 = *(void *)(v16 + 112);
        uint64_t v17 = *(void *)(v15 + 16 * v14 + 8);
        *a1 = v16;
        a1[1] = v17;
        if (v17) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
        }
        return;
      }
      BOOL v50 = GEOGetGeoCSSStyleSheetLog();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        *(void *)&uint8_t buf[4] = "false";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleMatchingTree.hpp";
        __int16 v57 = 1024;
        int v58 = 378;
        _os_log_impl(&dword_1A1780000, v50, OS_LOG_TYPE_ERROR, "endchain with no style: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
      }
    }
LABEL_61:
    *a4 = 0;
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  uint64_t v19 = *a5;
  uint64_t v20 = *(unsigned __int16 *)(a3 + 10);
  uint64_t v21 = *(char **)a3;
  int v22 = *(unsigned __int8 *)(a3 + 15);
  uint64_t v23 = *(void *)a3 + 4 * v20;
  while (1)
  {
    size_t v24 = (unsigned __int16 *)*((void *)v11 + 1);
    unint64_t v25 = *((unsigned __int16 *)v11 + 8);
    unint64_t v26 = (__int16 *)&v24[2 * v25];
    if (!*((_WORD *)v11 + 8)) {
      goto LABEL_17;
    }
    uint64_t v27 = (__int16 *)*((void *)v11 + 1);
    unint64_t v28 = *((unsigned __int16 *)v11 + 8);
    do
    {
      unint64_t v29 = v28 >> 1;
      unint64_t v30 = &v27[2 * (v28 >> 1)];
      int v32 = (unsigned __int16)*v30;
      uint64_t v31 = (unsigned __int16 *)(v30 + 2);
      v28 += ~(v28 >> 1);
      if (v32 == 0xFFFF) {
        unint64_t v28 = v29;
      }
      else {
        uint64_t v27 = (__int16 *)v31;
      }
    }
    while (v28);
    if (v27 != v26 && *v27 == -1)
    {
      unint64_t v11 = (_DWORD *)(v19 + 24 * (unsigned __int16)v27[1]);
      if (!v20) {
        goto LABEL_7;
      }
    }
    else
    {
LABEL_17:
      unint64_t v11 = 0;
      if (!v20) {
        goto LABEL_7;
      }
    }
    uint64_t v33 = 4 * v20;
    unint64_t v34 = *(char **)a3;
    if (v22)
    {
      size_t v35 = *(char **)a3;
      unint64_t v36 = *(unsigned __int16 *)(a3 + 10);
      if (v20 >= 0x1E)
      {
        do
        {
          unint64_t v39 = v36 >> 1;
          char v40 = &v35[4 * (v36 >> 1)];
          unsigned int v42 = *(_DWORD *)v40;
          int v41 = v40 + 4;
          v36 += ~(v36 >> 1);
          if (v42 < v13) {
            size_t v35 = v41;
          }
          else {
            unint64_t v36 = v39;
          }
        }
        while (v36);
        if (v35 == (char *)v23) {
          goto LABEL_7;
        }
        if (*(_DWORD *)v35 != v13) {
          goto LABEL_7;
        }
        unint64_t v43 = (unint64_t)(v35 - v21) >> 2;
        if (v20 == (unsigned __int16)v43) {
          goto LABEL_7;
        }
      }
      else
      {
        uint64_t v37 = 0;
        while (1)
        {
          unsigned int v38 = *(_DWORD *)&v21[4 * v37];
          if (v38 >= v13) {
            break;
          }
          if (v20 == ++v37) {
            goto LABEL_7;
          }
        }
        if (v38 == v13) {
          LOWORD(v43) = v37;
        }
        else {
          LOWORD(v43) = v20;
        }
        if (v20 == (unsigned __int16)v43) {
          goto LABEL_7;
        }
      }
    }
    else
    {
      while (*(_DWORD *)v34 != v13)
      {
        v34 += 4;
        v33 -= 4;
        if (!v33)
        {
          unint64_t v34 = (char *)(*(void *)a3 + 4 * v20);
          break;
        }
      }
      unint64_t v43 = (unint64_t)(v34 - v21) >> 2;
      if (v20 == (unsigned __int16)v43)
      {
LABEL_7:
        if (!v11) {
          goto LABEL_61;
        }
        goto LABEL_8;
      }
    }
    if (!v25) {
      break;
    }
    unsigned int v44 = *(unsigned __int16 *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 8) + 2 * (unsigned __int16)v43);
    do
    {
      unint64_t v45 = v25 >> 1;
      unsigned int v46 = &v24[2 * (v25 >> 1)];
      unsigned int v48 = *v46;
      unint64_t v47 = v46 + 2;
      v25 += ~(v25 >> 1);
      if (v48 < v44) {
        size_t v24 = v47;
      }
      else {
        unint64_t v25 = v45;
      }
    }
    while (v25);
    if (v24 == (unsigned __int16 *)v26 || *v24 != v44) {
      break;
    }
    unint64_t v49 = (_DWORD *)(v19 + 24 * v24[1]);
    if (v11) {
      goto LABEL_55;
    }
LABEL_52:
    unint64_t v11 = v49;
    if (!v49) {
      goto LABEL_61;
    }
LABEL_8:
    unsigned int v13 = *v11;
    if (*v11 == 0x7FFFFFFF) {
      goto LABEL_2;
    }
  }
  unint64_t v49 = 0;
  if (!v11) {
    goto LABEL_52;
  }
LABEL_55:
  if (!v49) {
    goto LABEL_8;
  }
  uint64_t v55 = 0;
  gss::StyleMatchingTreeNode<gss::CartoStyle<gss::ScenePropertyID>>::matchAttributes(buf, v49, a3, (char *)&v55 + 4, a5, a6, a7);
  gss::StyleMatchingTreeNode<gss::CartoStyle<gss::ScenePropertyID>>::matchAttributes(&v54, v11, a3, &v55, a5, a6, a7);
  if (HIDWORD(v55) >= v55)
  {
    long long v51 = *(_OWORD *)buf;
    *(void *)float buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    unint64_t v52 = (std::__shared_weak_count *)*((void *)&v54 + 1);
    *a4 = HIDWORD(v55);
    *(_OWORD *)a1 = v51;
    if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  else
  {
    *a4 = v55;
    *(_OWORD *)a1 = v54;
  }
  uint64_t v53 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
}

void sub_1A1817024(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void gss::StylesheetManager<gss::ScenePropertyID>::targetStyleAttributes(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  std::string __p = 0;
  uint64_t v27 = 0;
  unint64_t v28 = 0;
  uint64_t v10 = a4 - a3;
  unint64_t v11 = v10 + 20;
  if (v10 == -20)
  {
    uint64_t v12 = 0;
  }
  else
  {
    if (v11 >> 61) {
      abort();
    }
    uint64_t v12 = (char *)operator new(8 * v11);
    std::string __p = v12;
    uint64_t v27 = v12;
    unint64_t v28 = &v12[8 * v11];
  }
  std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>,std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>>((unint64_t *)&__p, (uint64_t)v12, a3, a4, v10);
  uint64_t v13 = *(void *)(a2 + 520);
  if (v13)
  {
    uint64_t v29 = v13 + 16;
    uint64_t v14 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(v13 + 16));
    if (v14) {
      geo::read_write_lock::logFailure(v14, (uint64_t)"read lock", v15);
    }
    unsigned int v16 = *(unsigned __int16 *)(v13 + 242);
    uint64_t v30 = v13 + 232;
    int v31 = 0;
    char v32 = 0;
    char v33 = 0;
    if (v16)
    {
      unsigned int v17 = 0;
      uint64_t v18 = 0;
      do
      {
        ++v18;
        unsigned int v19 = v17 + 1;
        if (v17 + 1 < v16) {
          ++v17;
        }
        else {
          unsigned int v17 = v16;
        }
      }
      while (v19 < v16);
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v27, &v30, v13 + 232, v16, v18);
    uint64_t v20 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v13 + 16));
    if (v20) {
      geo::read_write_lock::logFailure(v20, (uint64_t)"unlock", v21);
    }
    unsigned int v22 = *(unsigned __int16 *)(a5 + 10);
    uint64_t v30 = a5;
    int v31 = 0;
    char v32 = 0;
    char v33 = 0;
    if (v22)
    {
      unsigned int v23 = 0;
      uint64_t v24 = 0;
      do
      {
        ++v24;
        unsigned int v25 = v23 + 1;
        if (v23 + 1 < v22) {
          ++v23;
        }
        else {
          unsigned int v23 = v22;
        }
      }
      while (v25 < v22);
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v27, &v30, a5, v22, v24);
  }
  gss::ResolveMultiAttributeVectorToMap((unsigned int **)&__p, a1);
  if (__p)
  {
    uint64_t v27 = __p;
    operator delete(__p);
  }
}

void sub_1A18171E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, pthread_rwlock_t *a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void gss::StylesheetManager<gss::ScenePropertyID>::sourceStyleAttributes(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  std::string __p = 0;
  uint64_t v27 = 0;
  unint64_t v28 = 0;
  uint64_t v10 = a4 - a3;
  unint64_t v11 = v10 + 20;
  if (v10 == -20)
  {
    uint64_t v12 = 0;
  }
  else
  {
    if (v11 >> 61) {
      abort();
    }
    uint64_t v12 = (char *)operator new(8 * v11);
    std::string __p = v12;
    uint64_t v27 = v12;
    unint64_t v28 = &v12[8 * v11];
  }
  std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>,std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>>((unint64_t *)&__p, (uint64_t)v12, a3, a4, v10);
  uint64_t v13 = *(void *)(a2 + 520);
  if (v13)
  {
    uint64_t v29 = v13 + 16;
    uint64_t v14 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(v13 + 16));
    if (v14) {
      geo::read_write_lock::logFailure(v14, (uint64_t)"read lock", v15);
    }
    unsigned int v16 = *(unsigned __int16 *)(v13 + 226);
    uint64_t v30 = v13 + 216;
    int v31 = 0;
    char v32 = 0;
    char v33 = 0;
    if (v16)
    {
      unsigned int v17 = 0;
      uint64_t v18 = 0;
      do
      {
        ++v18;
        unsigned int v19 = v17 + 1;
        if (v17 + 1 < v16) {
          ++v17;
        }
        else {
          unsigned int v17 = v16;
        }
      }
      while (v19 < v16);
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v27, &v30, v13 + 216, v16, v18);
    uint64_t v20 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v13 + 16));
    if (v20) {
      geo::read_write_lock::logFailure(v20, (uint64_t)"unlock", v21);
    }
    unsigned int v22 = *(unsigned __int16 *)(a5 + 10);
    uint64_t v30 = a5;
    int v31 = 0;
    char v32 = 0;
    char v33 = 0;
    if (v22)
    {
      unsigned int v23 = 0;
      uint64_t v24 = 0;
      do
      {
        ++v24;
        unsigned int v25 = v23 + 1;
        if (v23 + 1 < v22) {
          ++v23;
        }
        else {
          unsigned int v23 = v22;
        }
      }
      while (v25 < v22);
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v27, &v30, a5, v22, v24);
  }
  gss::ResolveMultiAttributeVectorToMap((unsigned int **)&__p, a1);
  if (__p)
  {
    uint64_t v27 = __p;
    operator delete(__p);
  }
}

void sub_1A18173BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, pthread_rwlock_t *a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void gss::StylesheetQuery<gss::PropertyID>::resolve(uint64_t a1)
{
  uint64_t v27 = 0;
  unint64_t v28 = 0;
  unint64_t v2 = *(std::__shared_weak_count **)(a1 + 16);
  if (!v2 || (v28 = std::__shared_weak_count::lock(v2)) == 0 || (uint64_t v3 = *(void *)(a1 + 8), (v27 = v3) == 0))
  {
    uint64_t v25 = 0;
    unint64_t v26 = 0;
LABEL_35:
    unsigned int v17 = *(std::__shared_weak_count **)(a1 + 296);
    *(void *)(a1 + 288) = 0;
    *(void *)(a1 + 296) = 0;
    if (v17) {
      std::__shared_weak_count::__release_weak(v17);
    }
    goto LABEL_37;
  }
  uint64_t v5 = *(void *)(v3 + 16);
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 24);
  uint64_t v25 = v5;
  unint64_t v26 = v4;
  if (v4) {
    atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v5) {
    goto LABEL_35;
  }
  gss::StylesheetManager<gss::PropertyID>::sourceStyleAttributes(&v23, v3, *(uint64_t **)(a1 + 240), *(uint64_t **)(a1 + 248), a1 + 272);
  gss::StyleSheet<gss::PropertyID>::styleMatchingAttributes(&v21, v5, (uint64_t)&v23);
  uint64_t v6 = v21;
  uint64_t v7 = v22;
  if (v22) {
    atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
  }
  uint8x8_t v8 = *(std::__shared_weak_count **)(a1 + 296);
  *(void *)(a1 + 288) = v6;
  *(void *)(a1 + 296) = v7;
  if (v8)
  {
    std::__shared_weak_count::__release_weak(v8);
    uint64_t v7 = v22;
  }
  if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
    std::__shared_weak_count::__release_weak(v7);
  }
  if (!BYTE6(v24) && v23)
  {
    uint64_t v9 = gss::Allocator::instance((gss::Allocator *)v8);
    (*(void (**)(uint64_t, uint64_t, void))(*(void *)v9 + 40))(v9, v23, WORD2(v24));
  }
  if (v25)
  {
    uint64_t v10 = *(void *)(v27 + 520);
    unint64_t v11 = *(std::__shared_weak_count **)(v27 + 528);
    uint64_t v23 = v10;
    uint64_t v24 = v11;
    if (v11) {
      atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    BOOL hasTargetStyleAttributes = gss::ClientStyleState<gss::PropertyID>::hasTargetStyleAttributes(v10);
    if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
      std::__shared_weak_count::__release_weak(v11);
    }
    if (hasTargetStyleAttributes)
    {
      gss::StylesheetManager<gss::PropertyID>::targetStyleAttributes(&v23, v27, *(uint64_t **)(a1 + 240), *(uint64_t **)(a1 + 248), a1 + 272);
      gss::StyleSheet<gss::PropertyID>::styleMatchingAttributes(&v21, v25, (uint64_t)&v23);
      uint64_t v13 = v21;
      uint64_t v14 = v22;
      if (v22) {
        atomic_fetch_add_explicit(&v22->__shared_weak_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v15 = *(std::__shared_weak_count **)(a1 + 312);
      *(void *)(a1 + 304) = v13;
      *(void *)(a1 + 312) = v14;
      if (v15)
      {
        std::__shared_weak_count::__release_weak(v15);
        uint64_t v14 = v22;
      }
      if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
      if (!BYTE6(v24) && v23)
      {
        uint64_t v16 = gss::Allocator::instance((gss::Allocator *)v15);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v16 + 40))(v16, v23, WORD2(v24));
      }
      goto LABEL_39;
    }
  }
LABEL_37:
  uint64_t v18 = *(std::__shared_weak_count **)(a1 + 312);
  *(void *)(a1 + 304) = 0;
  *(void *)(a1 + 312) = 0;
  if (v18) {
    std::__shared_weak_count::__release_weak(v18);
  }
LABEL_39:
  unsigned int v19 = v26;
  if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = v28;
  if (v28)
  {
    if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
}

void sub_1A181772C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v7 = va_arg(va2, void);
  uint64_t v9 = va_arg(va2, void);
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  _Unwind_Resume(a1);
}

void gss::StyleSheet<gss::PropertyID>::styleMatchingAttributes(void *a1, uint64_t a2, uint64_t a3)
{
  geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::shrink_to_fit(a3);
  uint64_t v7 = *(void *)(a3 + 8);
  *(void *)&long long v98 = *(void *)a3;
  DWORD2(v98) = v7;
  WORD6(v98) = WORD2(v7);
  HIWORD(v98) = *(_WORD *)(a3 + 14);
  *(void *)(a3 + 7) = 0;
  *(void *)a3 = 0;
  *(unsigned char *)(a3 + 15) = 1;
  uint8x8_t v8 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(a2 + 2528));
  if (v8) {
    geo::read_write_lock::logFailure(v8, (uint64_t)"read lock", v9);
  }
  if (WORD5(v98))
  {
    unint64_t v11 = 0;
    uint64_t v12 = 0;
    unsigned int v13 = 0;
    do
    {
      if (v13 < WORD5(v98))
      {
        uint64_t v12 = (unsigned int *)(v98 + 4 * v13);
        uint64_t v10 = (unsigned __int16 *)(v98 + WORD4(v98) + 2 * v13);
      }
      v11 ^= (*v10
            - 0x61C8864680B583EBLL
            + ((((v11 << 6) - 0x61C8864680B583EBLL + (v11 >> 2) + *v12) ^ v11) << 6)
            + ((((v11 << 6) - 0x61C8864680B583EBLL + (v11 >> 2) + *v12) ^ v11) >> 2)) ^ ((v11 << 6)
                                                                                       - 0x61C8864680B583EBLL
                                                                                       + (v11 >> 2)
                                                                                       + *v12);
      unsigned int v14 = v13 + 1;
      if (v13 + 1 < WORD5(v98)) {
        ++v13;
      }
      else {
        unsigned int v13 = WORD5(v98);
      }
    }
    while (v14 < WORD5(v98));
    int8x8_t v15 = *(int8x8_t *)(a2 + 2736);
    if (!*(void *)&v15)
    {
LABEL_63:
      size_t v35 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(a2 + 2528));
      if (v35) {
        geo::read_write_lock::logFailure(v35, (uint64_t)"unlock", v36);
      }
      unsigned __int8 v37 = atomic_load((unsigned __int8 *)(a2 + 2786));
      if ((v37 & 1) == 0) {
        std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(a2 + 2816));
      }
      unsigned __int8 v38 = atomic_load((unsigned __int8 *)(a2 + 2787));
      if ((v38 & 1) == 0)
      {
        *a1 = 0;
        a1[1] = 0;
        goto LABEL_194;
      }
      gss::StyleMatchingTreeNode<gss::CartoStyle<gss::PropertyID>>::matchAttributes(a1, **(_DWORD ***)(a2 + 160), (uint64_t)&v98, v99, (uint64_t *)(*(void *)(a2 + 160) + 8), (uint64_t *)(a2 + 64), (void *)(*(void *)(a2 + 160) + 24));
      unint64_t v39 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(a2 + 2528));
      if (v39) {
        geo::read_write_lock::logFailure(v39, (uint64_t)"write lock", v40);
      }
      if (WORD5(v98))
      {
        unint64_t v42 = 0;
        unint64_t v43 = 0;
        unsigned int v44 = 0;
        do
        {
          if (v44 < WORD5(v98))
          {
            unint64_t v43 = (unsigned int *)(v98 + 4 * v44);
            int v41 = (unsigned __int16 *)(v98 + WORD4(v98) + 2 * v44);
          }
          unint64_t v45 = ((v42 << 6) - 0x61C8864680B583EBLL + (v42 >> 2) + *v43) ^ v42;
          unint64_t v42 = (*v41 - 0x61C8864680B583EBLL + (v45 << 6) + (v45 >> 2)) ^ v45;
          unsigned int v46 = v44 + 1;
          if (v44 + 1 < WORD5(v98)) {
            ++v44;
          }
          else {
            unsigned int v44 = WORD5(v98);
          }
        }
        while (v46 < WORD5(v98));
        unint64_t v47 = *(void *)(a2 + 2736);
        if (v47)
        {
LABEL_80:
          uint8x8_t v48 = (uint8x8_t)vcnt_s8((int8x8_t)v47);
          v48.i16[0] = vaddlv_u8(v48);
          if (v48.u32[0] > 1uLL)
          {
            unint64_t v3 = v42;
            if (v42 >= v47) {
              unint64_t v3 = v42 % v47;
            }
          }
          else
          {
            unint64_t v3 = (v47 - 1) & v42;
          }
          unint64_t v49 = *(uint64_t ***)(*(void *)(a2 + 2728) + 8 * v3);
          if (v49)
          {
            BOOL v50 = *v49;
            if (v50)
            {
              unint64_t v51 = v47 - 1;
              if (WORD5(v98))
              {
                unint64_t v52 = (unsigned __int16 *)(v98 + WORD4(v98));
                if (v48.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    uint64_t v53 = v50[1];
                    if (v53 == v42)
                    {
                      if (WORD5(v98) == *((unsigned __int16 *)v50 + 13))
                      {
                        long long v54 = (_DWORD *)v50[2];
                        if (*(_DWORD *)v98 == *v54)
                        {
                          uint64_t v55 = (unsigned __int16 *)((char *)v54 + *((unsigned __int16 *)v50 + 12));
                          if (*v52 == *v55)
                          {
                            uint64_t v56 = 1;
                            do
                            {
                              if (WORD5(v98) == v56) {
                                goto LABEL_192;
                              }
                              unint64_t v57 = v56;
                              if (*(_DWORD *)(v98 + 4 * v56) != v54[v56]) {
                                break;
                              }
                              ++v56;
                            }
                            while (v52[v57] == v55[v57]);
                            if (v57 >= WORD5(v98)) {
                              goto LABEL_192;
                            }
                          }
                        }
                      }
                    }
                    else if ((v53 & v51) != v3)
                    {
                      goto LABEL_130;
                    }
                    BOOL v50 = (uint64_t *)*v50;
                    if (!v50) {
                      goto LABEL_130;
                    }
                  }
                }
                while (1)
                {
                  unint64_t v58 = v50[1];
                  if (v58 == v42)
                  {
                    if (WORD5(v98) == *((unsigned __int16 *)v50 + 13))
                    {
                      uint64_t v59 = (_DWORD *)v50[2];
                      if (*(_DWORD *)v98 == *v59)
                      {
                        uint64_t v60 = (unsigned __int16 *)((char *)v59 + *((unsigned __int16 *)v50 + 12));
                        if (*v52 == *v60)
                        {
                          uint64_t v61 = 1;
                          do
                          {
                            if (WORD5(v98) == v61) {
                              goto LABEL_192;
                            }
                            unint64_t v62 = v61;
                            if (*(_DWORD *)(v98 + 4 * v61) != v59[v61]) {
                              break;
                            }
                            ++v61;
                          }
                          while (v52[v62] == v60[v62]);
                          if (v62 >= WORD5(v98)) {
                            goto LABEL_192;
                          }
                        }
                      }
                    }
                  }
                  else
                  {
                    if (v58 >= v47) {
                      v58 %= v47;
                    }
                    if (v58 != v3) {
                      goto LABEL_130;
                    }
                  }
                  BOOL v50 = (uint64_t *)*v50;
                  if (!v50) {
                    goto LABEL_130;
                  }
                }
              }
              if (v48.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v63 = v50[1];
                  if (v63 == v42)
                  {
                    if (!*((_WORD *)v50 + 13)) {
                      goto LABEL_192;
                    }
                  }
                  else if ((v63 & v51) != v3)
                  {
                    goto LABEL_130;
                  }
                  BOOL v50 = (uint64_t *)*v50;
                  if (!v50) {
                    goto LABEL_130;
                  }
                }
              }
              do
              {
                unint64_t v64 = v50[1];
                if (v64 == v42)
                {
                  if (!*((_WORD *)v50 + 13)) {
                    goto LABEL_192;
                  }
                }
                else
                {
                  if (v64 >= v47) {
                    v64 %= v47;
                  }
                  if (v64 != v3) {
                    break;
                  }
                }
                BOOL v50 = (uint64_t *)*v50;
              }
              while (v50);
            }
          }
        }
      }
      else
      {
        unint64_t v42 = 0;
        unint64_t v47 = *(void *)(a2 + 2736);
        if (v47) {
          goto LABEL_80;
        }
      }
LABEL_130:
      uint64_t v65 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 2760) + 16))(*(void *)(a2 + 2760), 48, 8);
      v99[0] = v65;
      v99[1] = a2 + 2760;
      *(void *)uint64_t v65 = 0;
      *(void *)(v65 + 8) = v42;
      uint64_t v66 = *((void *)&v98 + 1);
      *(void *)(v65 + 16) = v98;
      *(_DWORD *)(v65 + 24) = v66;
      *(_WORD *)(v65 + 28) = WORD2(v66);
      *(_WORD *)(v65 + 30) = HIWORD(v98);
      *(void *)&long long v98 = 0;
      *(void *)((char *)&v98 + 7) = 0;
      HIBYTE(v98) = 1;
      *(void *)(v65 + 32) = *a1;
      uint64_t v67 = a1[1];
      *(void *)(v65 + 40) = v67;
      if (v67) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v67 + 8), 1uLL, memory_order_relaxed);
      }
      char v100 = 1;
      float v68 = (float)(unint64_t)(*(void *)(a2 + 2768) + 1);
      float v69 = *(float *)(a2 + 2776);
      if (v47 && (float)(v69 * (float)v47) >= v68)
      {
LABEL_182:
        uint64_t v93 = *(uint64_t **)(*(void *)(a2 + 2728) + 8 * v3);
        if (v93)
        {
          *(void *)uint64_t v65 = *v93;
        }
        else
        {
          *(void *)uint64_t v65 = *(void *)(a2 + 2752);
          *(void *)(a2 + 2752) = v65;
          *(void *)(*(void *)(a2 + 2728) + 8 * v3) = a2 + 2752;
          if (!*(void *)v65)
          {
LABEL_191:
            ++*(void *)(a2 + 2768);
            goto LABEL_192;
          }
          unint64_t v94 = *(void *)(*(void *)v65 + 8);
          if ((v47 & (v47 - 1)) != 0)
          {
            if (v94 >= v47) {
              v94 %= v47;
            }
          }
          else
          {
            v94 &= v47 - 1;
          }
          uint64_t v93 = (uint64_t *)(*(void *)(a2 + 2728) + 8 * v94);
        }
        *uint64_t v93 = v65;
        goto LABEL_191;
      }
      BOOL v70 = v47 < 3 || (v47 & (v47 - 1)) != 0;
      unint64_t v71 = v70 | (2 * v47);
      unint64_t v72 = vcvtps_u32_f32(v68 / v69);
      if (v71 <= v72) {
        size_t prime = v72;
      }
      else {
        size_t prime = v71;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
      }
      unint64_t v47 = *(void *)(a2 + 2736);
      if (prime <= v47)
      {
        if (prime >= v47) {
          goto LABEL_169;
        }
        unint64_t v86 = vcvtps_u32_f32((float)*(unint64_t *)(a2 + 2768) / *(float *)(a2 + 2776));
        if (v47 < 3 || (uint8x8_t v87 = (uint8x8_t)vcnt_s8((int8x8_t)v47), v87.i16[0] = vaddlv_u8(v87), v87.u32[0] > 1uLL))
        {
          unint64_t v86 = std::__next_prime(v86);
        }
        else
        {
          uint64_t v88 = 1 << -(char)__clz(v86 - 1);
          if (v86 >= 2) {
            unint64_t v86 = v88;
          }
        }
        if (prime <= v86) {
          size_t prime = v86;
        }
        if (prime >= v47)
        {
          unint64_t v47 = *(void *)(a2 + 2736);
LABEL_169:
          if ((v47 & (v47 - 1)) != 0)
          {
            if (v42 >= v47) {
              unint64_t v3 = v42 % v47;
            }
            else {
              unint64_t v3 = v42;
            }
          }
          else
          {
            unint64_t v3 = (v47 - 1) & v42;
          }
          goto LABEL_182;
        }
        if (!prime)
        {
          uint64_t v97 = *(void *)(a2 + 2728);
          *(void *)(a2 + 2728) = 0;
          if (v97) {
            (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 2744) + 40))(*(void *)(a2 + 2744), v97, 8 * *(void *)(a2 + 2736));
          }
          unint64_t v47 = 0;
          *(void *)(a2 + 2736) = 0;
          goto LABEL_169;
        }
      }
      uint64_t v74 = (*(uint64_t (**)(void, size_t, uint64_t))(**(void **)(a2 + 2744) + 16))(*(void *)(a2 + 2744), 8 * prime, 8);
      uint64_t v75 = *(void *)(a2 + 2728);
      *(void *)(a2 + 2728) = v74;
      if (v75) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 2744) + 40))(*(void *)(a2 + 2744), v75, 8 * *(void *)(a2 + 2736));
      }
      uint64_t v76 = 0;
      *(void *)(a2 + 2736) = prime;
      do
        *(void *)(*(void *)(a2 + 2728) + 8 * v76++) = 0;
      while (prime != v76);
      uint64_t v77 = *(void **)(a2 + 2752);
      if (!v77)
      {
LABEL_168:
        unint64_t v47 = prime;
        goto LABEL_169;
      }
      uint64_t v78 = a2 + 2752;
      size_t v79 = v77[1];
      size_t v80 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v81 = v79 & v80;
        *(void *)(*(void *)(a2 + 2728) + 8 * v81) = v78;
        for (uint64_t i = (void *)*v77; *v77; uint64_t i = (void *)*v77)
        {
          size_t v83 = i[1] & v80;
          if (v83 == v81)
          {
            uint64_t v77 = i;
          }
          else
          {
            uint64_t v84 = *(void *)(a2 + 2728);
            if (*(void *)(v84 + 8 * v83))
            {
              *uint64_t v77 = *i;
              uint64_t v85 = 8 * v83;
              void *i = **(void **)(*(void *)(a2 + 2728) + v85);
              **(void **)(*(void *)(a2 + 2728) + v85) = i;
            }
            else
            {
              *(void *)(v84 + 8 * v83) = v77;
              uint64_t v77 = i;
              size_t v81 = v83;
            }
          }
        }
        goto LABEL_168;
      }
      if (v79 >= prime) {
        v79 %= prime;
      }
      *(void *)(*(void *)(a2 + 2728) + 8 * v79) = v78;
      char v89 = (void *)*v77;
      if (!*v77) {
        goto LABEL_168;
      }
      while (1)
      {
        size_t v91 = v89[1];
        if (v91 >= prime) {
          v91 %= prime;
        }
        if (v91 != v79)
        {
          uint64_t v92 = *(void *)(a2 + 2728);
          if (!*(void *)(v92 + 8 * v91))
          {
            *(void *)(v92 + 8 * v91) = v77;
            goto LABEL_173;
          }
          *uint64_t v77 = *v89;
          uint64_t v90 = 8 * v91;
          *char v89 = **(void **)(*(void *)(a2 + 2728) + v90);
          **(void **)(*(void *)(a2 + 2728) + v90) = v89;
          char v89 = v77;
        }
        size_t v91 = v79;
LABEL_173:
        uint64_t v77 = v89;
        char v89 = (void *)*v89;
        size_t v79 = v91;
        if (!v89) {
          goto LABEL_168;
        }
      }
    }
  }
  else
  {
    unint64_t v11 = 0;
    int8x8_t v15 = *(int8x8_t *)(a2 + 2736);
    if (!*(void *)&v15) {
      goto LABEL_63;
    }
  }
  uint8x8_t v16 = (uint8x8_t)vcnt_s8(v15);
  v16.i16[0] = vaddlv_u8(v16);
  if (v16.u32[0] > 1uLL)
  {
    unint64_t v17 = v11;
    if (v11 >= *(void *)&v15) {
      unint64_t v17 = v11 % *(void *)&v15;
    }
  }
  else
  {
    unint64_t v17 = (*(void *)&v15 - 1) & v11;
  }
  uint64_t v18 = *(uint64_t ***)(*(void *)(a2 + 2728) + 8 * v17);
  if (!v18) {
    goto LABEL_63;
  }
  unsigned int v19 = *v18;
  if (!v19) {
    goto LABEL_63;
  }
  uint64_t v20 = *(void *)&v15 - 1;
  if (WORD5(v98))
  {
    uint64_t v21 = (unsigned __int16 *)(v98 + WORD4(v98));
    if (v16.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v22 = v19[1];
        if (v22 == v11)
        {
          if (WORD5(v98) == *((unsigned __int16 *)v19 + 13))
          {
            uint64_t v23 = (_DWORD *)v19[2];
            if (*(_DWORD *)v98 == *v23)
            {
              uint64_t v24 = (unsigned __int16 *)((char *)v23 + *((unsigned __int16 *)v19 + 12));
              if (*v21 == *v24)
              {
                uint64_t v25 = 1;
                do
                {
                  if (WORD5(v98) == v25) {
                    goto LABEL_34;
                  }
                  unint64_t v26 = v25;
                  if (*(_DWORD *)(v98 + 4 * v25) != v23[v25]) {
                    break;
                  }
                  ++v25;
                }
                while (v21[v26] == v24[v26]);
                if (v26 >= WORD5(v98)) {
                  goto LABEL_34;
                }
              }
            }
          }
        }
        else if ((v22 & v20) != v17)
        {
          goto LABEL_63;
        }
        unsigned int v19 = (uint64_t *)*v19;
        if (!v19) {
          goto LABEL_63;
        }
      }
    }
    while (1)
    {
      unint64_t v28 = v19[1];
      if (v28 == v11)
      {
        if (WORD5(v98) == *((unsigned __int16 *)v19 + 13))
        {
          uint64_t v29 = (_DWORD *)v19[2];
          if (*(_DWORD *)v98 == *v29)
          {
            uint64_t v30 = (unsigned __int16 *)((char *)v29 + *((unsigned __int16 *)v19 + 12));
            if (*v21 == *v30)
            {
              uint64_t v31 = 1;
              do
              {
                if (WORD5(v98) == v31) {
                  goto LABEL_34;
                }
                unint64_t v32 = v31;
                if (*(_DWORD *)(v98 + 4 * v31) != v29[v31]) {
                  break;
                }
                ++v31;
              }
              while (v21[v32] == v30[v32]);
              if (v32 >= WORD5(v98)) {
                goto LABEL_34;
              }
            }
          }
        }
      }
      else
      {
        if (v28 >= *(void *)&v15) {
          v28 %= *(void *)&v15;
        }
        if (v28 != v17) {
          goto LABEL_63;
        }
      }
      unsigned int v19 = (uint64_t *)*v19;
      if (!v19) {
        goto LABEL_63;
      }
    }
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v33 = v19[1];
      if (v33 == v11)
      {
        if (!*((_WORD *)v19 + 13)) {
          goto LABEL_34;
        }
      }
      else if ((v33 & v20) != v17)
      {
        goto LABEL_63;
      }
      unsigned int v19 = (uint64_t *)*v19;
      if (!v19) {
        goto LABEL_63;
      }
    }
  }
  while (1)
  {
    unint64_t v34 = v19[1];
    if (v34 == v11) {
      break;
    }
    if (v34 >= *(void *)&v15) {
      v34 %= *(void *)&v15;
    }
    if (v34 != v17) {
      goto LABEL_63;
    }
LABEL_58:
    unsigned int v19 = (uint64_t *)*v19;
    if (!v19) {
      goto LABEL_63;
    }
  }
  if (*((_WORD *)v19 + 13)) {
    goto LABEL_58;
  }
LABEL_34:
  *a1 = v19[4];
  uint64_t v27 = v19[5];
  a1[1] = v27;
  if (v27) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
  }
LABEL_192:
  size_t v35 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(a2 + 2528));
  if (v35) {
    geo::read_write_lock::logFailure(v35, (uint64_t)"unlock", v95);
  }
LABEL_194:
  if (!BYTE14(v98))
  {
    if ((void)v98)
    {
      uint64_t v96 = gss::Allocator::instance(v35);
      (*(void (**)(uint64_t, void, void))(*(void *)v96 + 40))(v96, v98, WORD6(v98));
    }
  }
}

void sub_1A18182BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, pthread_rwlock_t *a9, char a10, uint64_t a11, uint64_t a12)
{
  a12 = 0;
  std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<gss::StyleSheetResultCacheKey,std::shared_ptr<gss::CartoStyle<gss::PropertyID>>>,void *>,gss::Allocator>>::operator()[abi:nn180100](v14, v13);
  geo::write_lock_guard::~write_lock_guard(&a9);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v12);
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)&a10);
  _Unwind_Resume(a1);
}

void gss::StyleMatchingTreeNode<gss::CartoStyle<gss::PropertyID>>::matchAttributes(void *a1, _DWORD *a2, uint64_t a3, _DWORD *a4, uint64_t *a5, uint64_t *a6, void *a7)
{
  unint64_t v11 = a2;
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  unsigned int v13 = *a2;
  if (*a2 == 0x7FFFFFFF)
  {
LABEL_2:
    if (gss::MatchingGraphEndChain::matches((uint64_t *)(*a7 + 16 * *((unsigned __int16 *)v11 + 3)), a3))
    {
      uint64_t v14 = *((unsigned __int16 *)v11 + 2);
      uint64_t v15 = *a6;
      uint64_t v16 = *(void *)(*a6 + 16 * v14);
      if (v16)
      {
        *a4 = *(void *)(v16 + 112);
        uint64_t v17 = *(void *)(v15 + 16 * v14 + 8);
        *a1 = v16;
        a1[1] = v17;
        if (v17) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
        }
        return;
      }
      BOOL v50 = GEOGetGeoCSSStyleSheetLog();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        *(void *)&uint8_t buf[4] = "false";
        *(_WORD *)&buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleMatchingTree.hpp";
        __int16 v57 = 1024;
        int v58 = 378;
        _os_log_impl(&dword_1A1780000, v50, OS_LOG_TYPE_ERROR, "endchain with no style: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
      }
    }
LABEL_61:
    *a4 = 0;
    *a1 = 0;
    a1[1] = 0;
    return;
  }
  uint64_t v19 = *a5;
  uint64_t v20 = *(unsigned __int16 *)(a3 + 10);
  uint64_t v21 = *(char **)a3;
  int v22 = *(unsigned __int8 *)(a3 + 15);
  uint64_t v23 = *(void *)a3 + 4 * v20;
  while (1)
  {
    uint64_t v24 = (unsigned __int16 *)*((void *)v11 + 1);
    unint64_t v25 = *((unsigned __int16 *)v11 + 8);
    unint64_t v26 = (__int16 *)&v24[2 * v25];
    if (!*((_WORD *)v11 + 8)) {
      goto LABEL_17;
    }
    uint64_t v27 = (__int16 *)*((void *)v11 + 1);
    unint64_t v28 = *((unsigned __int16 *)v11 + 8);
    do
    {
      unint64_t v29 = v28 >> 1;
      uint64_t v30 = &v27[2 * (v28 >> 1)];
      int v32 = (unsigned __int16)*v30;
      uint64_t v31 = (unsigned __int16 *)(v30 + 2);
      v28 += ~(v28 >> 1);
      if (v32 == 0xFFFF) {
        unint64_t v28 = v29;
      }
      else {
        uint64_t v27 = (__int16 *)v31;
      }
    }
    while (v28);
    if (v27 != v26 && *v27 == -1)
    {
      unint64_t v11 = (_DWORD *)(v19 + 24 * (unsigned __int16)v27[1]);
      if (!v20) {
        goto LABEL_7;
      }
    }
    else
    {
LABEL_17:
      unint64_t v11 = 0;
      if (!v20) {
        goto LABEL_7;
      }
    }
    uint64_t v33 = 4 * v20;
    unint64_t v34 = *(char **)a3;
    if (v22)
    {
      size_t v35 = *(char **)a3;
      unint64_t v36 = *(unsigned __int16 *)(a3 + 10);
      if (v20 >= 0x1E)
      {
        do
        {
          unint64_t v39 = v36 >> 1;
          char v40 = &v35[4 * (v36 >> 1)];
          unsigned int v42 = *(_DWORD *)v40;
          int v41 = v40 + 4;
          v36 += ~(v36 >> 1);
          if (v42 < v13) {
            size_t v35 = v41;
          }
          else {
            unint64_t v36 = v39;
          }
        }
        while (v36);
        if (v35 == (char *)v23) {
          goto LABEL_7;
        }
        if (*(_DWORD *)v35 != v13) {
          goto LABEL_7;
        }
        unint64_t v43 = (unint64_t)(v35 - v21) >> 2;
        if (v20 == (unsigned __int16)v43) {
          goto LABEL_7;
        }
      }
      else
      {
        uint64_t v37 = 0;
        while (1)
        {
          unsigned int v38 = *(_DWORD *)&v21[4 * v37];
          if (v38 >= v13) {
            break;
          }
          if (v20 == ++v37) {
            goto LABEL_7;
          }
        }
        if (v38 == v13) {
          LOWORD(v43) = v37;
        }
        else {
          LOWORD(v43) = v20;
        }
        if (v20 == (unsigned __int16)v43) {
          goto LABEL_7;
        }
      }
    }
    else
    {
      while (*(_DWORD *)v34 != v13)
      {
        v34 += 4;
        v33 -= 4;
        if (!v33)
        {
          unint64_t v34 = (char *)(*(void *)a3 + 4 * v20);
          break;
        }
      }
      unint64_t v43 = (unint64_t)(v34 - v21) >> 2;
      if (v20 == (unsigned __int16)v43)
      {
LABEL_7:
        if (!v11) {
          goto LABEL_61;
        }
        goto LABEL_8;
      }
    }
    if (!v25) {
      break;
    }
    unsigned int v44 = *(unsigned __int16 *)(*(void *)a3 + *(unsigned __int16 *)(a3 + 8) + 2 * (unsigned __int16)v43);
    do
    {
      unint64_t v45 = v25 >> 1;
      unsigned int v46 = &v24[2 * (v25 >> 1)];
      unsigned int v48 = *v46;
      unint64_t v47 = v46 + 2;
      v25 += ~(v25 >> 1);
      if (v48 < v44) {
        uint64_t v24 = v47;
      }
      else {
        unint64_t v25 = v45;
      }
    }
    while (v25);
    if (v24 == (unsigned __int16 *)v26 || *v24 != v44) {
      break;
    }
    unint64_t v49 = (_DWORD *)(v19 + 24 * v24[1]);
    if (v11) {
      goto LABEL_55;
    }
LABEL_52:
    unint64_t v11 = v49;
    if (!v49) {
      goto LABEL_61;
    }
LABEL_8:
    unsigned int v13 = *v11;
    if (*v11 == 0x7FFFFFFF) {
      goto LABEL_2;
    }
  }
  unint64_t v49 = 0;
  if (!v11) {
    goto LABEL_52;
  }
LABEL_55:
  if (!v49) {
    goto LABEL_8;
  }
  uint64_t v55 = 0;
  gss::StyleMatchingTreeNode<gss::CartoStyle<gss::PropertyID>>::matchAttributes(buf, v49, a3, (char *)&v55 + 4, a5, a6, a7);
  gss::StyleMatchingTreeNode<gss::CartoStyle<gss::PropertyID>>::matchAttributes(&v54, v11, a3, &v55, a5, a6, a7);
  if (HIDWORD(v55) >= v55)
  {
    long long v51 = *(_OWORD *)buf;
    *(void *)float buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    unint64_t v52 = (std::__shared_weak_count *)*((void *)&v54 + 1);
    *a4 = HIDWORD(v55);
    *(_OWORD *)a1 = v51;
    if (v52 && !atomic_fetch_add(&v52->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v52->__on_zero_shared)(v52);
      std::__shared_weak_count::__release_weak(v52);
    }
  }
  else
  {
    *a4 = v55;
    *(_OWORD *)a1 = v54;
  }
  uint64_t v53 = *(std::__shared_weak_count **)&buf[8];
  if (*(void *)&buf[8]
    && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
}

void sub_1A181875C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t gss::MatchingGraphEndChain::matches(uint64_t *a1, uint64_t a2)
{
  if (!*((_WORD *)a1 + 4)) {
    return 1;
  }
  uint64_t v4 = (int *)*a1;
  uint64_t v5 = *a1 + 24 * *((unsigned __int16 *)a1 + 4);
  while (1)
  {
    uint64_t v6 = *(unsigned __int16 *)(a2 + 10);
    if (*(_WORD *)(a2 + 10))
    {
      unsigned int v7 = *v4;
      uint8x8_t v8 = *(char **)a2;
      if (*(unsigned char *)(a2 + 15))
      {
        if (v6 >= 0x1E)
        {
          uint64_t v14 = *(char **)a2;
          unint64_t v15 = *(unsigned __int16 *)(a2 + 10);
          do
          {
            unint64_t v16 = v15 >> 1;
            uint64_t v17 = &v14[4 * (v15 >> 1)];
            unsigned int v19 = *(_DWORD *)v17;
            uint64_t v18 = v17 + 4;
            v15 += ~(v15 >> 1);
            if (v19 < v7) {
              uint64_t v14 = v18;
            }
            else {
              unint64_t v15 = v16;
            }
          }
          while (v15);
          if (v14 == &v8[4 * v6] || *(_DWORD *)v14 != v7) {
            return 0;
          }
          unint64_t v11 = (unint64_t)(v14 - v8) >> 2;
        }
        else
        {
          uint64_t v9 = 0;
          while (1)
          {
            unsigned int v10 = *(_DWORD *)&v8[4 * v9];
            if (v10 >= v7) {
              break;
            }
            if (v6 == ++v9) {
              return 0;
            }
          }
          LOWORD(v11) = v10 == v7 ? v9 : *(_WORD *)(a2 + 10);
        }
      }
      else
      {
        uint64_t v12 = 4 * v6;
        unsigned int v13 = *(char **)a2;
        while (*(_DWORD *)v13 != v7)
        {
          v13 += 4;
          v12 -= 4;
          if (!v12)
          {
            unsigned int v13 = &v8[4 * v6];
            break;
          }
        }
        unint64_t v11 = (unint64_t)(v13 - v8) >> 2;
      }
    }
    else
    {
      LOWORD(v11) = 0;
    }
    if (v6 == (unsigned __int16)v11) {
      return 0;
    }
    uint64_t v20 = (__int32 *)*((void *)v4 + 1);
    size_t v21 = *((unsigned __int16 *)v4 + 8);
    int v22 = &v20[v21];
    if (v6 > (unsigned __int16)v11) {
      unint64_t v2 = (unsigned __int16 *)(*(void *)a2 + *(unsigned __int16 *)(a2 + 8) + 2 * (unsigned __int16)v11);
    }
    uint64_t v23 = wmemchr(v20, *v2, v21);
    uint64_t v24 = v23 ? v23 : v22;
    if (v24 == (__int32 *)(*((void *)v4 + 1) + 4 * *((unsigned __int16 *)v4 + 8))) {
      return 0;
    }
    v4 += 6;
    if (v4 == (int *)v5) {
      return 1;
    }
  }
}

void gss::ClientStyleState<gss::PropertyID>::appendSourceClientStyleAttributes(uint64_t a1, unint64_t *a2)
{
  uint64_t v4 = (pthread_rwlock_t *)(a1 + 16);
  uint64_t v5 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  if (v5) {
    geo::read_write_lock::logFailure(v5, (uint64_t)"read lock", v6);
  }
  unsigned int v7 = (void *)a2[1];
  unsigned int v8 = *(unsigned __int16 *)(a1 + 226);
  uint64_t v14 = a1 + 216;
  int v15 = 0;
  char v16 = 0;
  char v17 = 0;
  if (v8)
  {
    unsigned int v9 = 0;
    uint64_t v10 = 0;
    do
    {
      ++v10;
      unsigned int v11 = v9 + 1;
      if (v9 + 1 < v8) {
        ++v9;
      }
      else {
        unsigned int v9 = v8;
      }
    }
    while (v11 < v8);
  }
  else
  {
    uint64_t v10 = 0;
  }
  std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>(a2, v7, &v14, a1 + 216, v8, v10);
  uint64_t v12 = (geo::read_write_lock *)pthread_rwlock_unlock(v4);
  if (v12)
  {
    geo::read_write_lock::logFailure(v12, (uint64_t)"unlock", v13);
  }
}

void sub_1A18189D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, pthread_rwlock_t *a9)
{
}

void gss::StylesheetManager<gss::PropertyID>::targetStyleAttributes(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  std::string __p = 0;
  uint64_t v27 = 0;
  unint64_t v28 = 0;
  uint64_t v10 = a4 - a3;
  unint64_t v11 = v10 + 20;
  if (v10 == -20)
  {
    uint64_t v12 = 0;
  }
  else
  {
    if (v11 >> 61) {
      abort();
    }
    uint64_t v12 = (char *)operator new(8 * v11);
    std::string __p = v12;
    uint64_t v27 = v12;
    unint64_t v28 = &v12[8 * v11];
  }
  std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>,std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>>((unint64_t *)&__p, (uint64_t)v12, a3, a4, v10);
  uint64_t v13 = *(void *)(a2 + 520);
  if (v13)
  {
    uint64_t v29 = v13 + 16;
    uint64_t v14 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(v13 + 16));
    if (v14) {
      geo::read_write_lock::logFailure(v14, (uint64_t)"read lock", v15);
    }
    unsigned int v16 = *(unsigned __int16 *)(v13 + 242);
    uint64_t v30 = v13 + 232;
    int v31 = 0;
    char v32 = 0;
    char v33 = 0;
    if (v16)
    {
      unsigned int v17 = 0;
      uint64_t v18 = 0;
      do
      {
        ++v18;
        unsigned int v19 = v17 + 1;
        if (v17 + 1 < v16) {
          ++v17;
        }
        else {
          unsigned int v17 = v16;
        }
      }
      while (v19 < v16);
    }
    else
    {
      uint64_t v18 = 0;
    }
    std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v27, &v30, v13 + 232, v16, v18);
    uint64_t v20 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v13 + 16));
    if (v20) {
      geo::read_write_lock::logFailure(v20, (uint64_t)"unlock", v21);
    }
    unsigned int v22 = *(unsigned __int16 *)(a5 + 10);
    uint64_t v30 = a5;
    int v31 = 0;
    char v32 = 0;
    char v33 = 0;
    if (v22)
    {
      unsigned int v23 = 0;
      uint64_t v24 = 0;
      do
      {
        ++v24;
        unsigned int v25 = v23 + 1;
        if (v23 + 1 < v22) {
          ++v23;
        }
        else {
          unsigned int v23 = v22;
        }
      }
      while (v25 < v22);
    }
    else
    {
      uint64_t v24 = 0;
    }
    std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v27, &v30, a5, v22, v24);
  }
  gss::ResolveMultiAttributeVectorToMap((unsigned int **)&__p, a1);
  if (__p)
  {
    uint64_t v27 = __p;
    operator delete(__p);
  }
}

void sub_1A1818B8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, pthread_rwlock_t *a13)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(a1);
}

void std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>(unint64_t *a1, void *a2, _DWORD *a3, uint64_t a4, int a5, uint64_t a6)
{
  if (a6 < 1) {
    return;
  }
  unint64_t v13 = *a1;
  unint64_t v12 = a1[1];
  uint64_t v14 = (uint64_t)a2 - *a1;
  uint64_t v15 = v14 >> 3;
  unint64_t v16 = *a1 + (v14 & 0xFFFFFFFFFFFFFFF8);
  unint64_t v17 = a1[2];
  if (a6 > (uint64_t)(v17 - v12) >> 3)
  {
    unint64_t v18 = a6 + ((uint64_t)(v12 - v13) >> 3);
    if (v18 >> 61) {
      abort();
    }
    uint64_t v19 = v17 - v13;
    if (v19 >> 2 > v18) {
      unint64_t v18 = v19 >> 2;
    }
    if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v20 = v18;
    }
    if (v20)
    {
      if (v20 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      size_t v21 = (char *)operator new(8 * v20);
    }
    else
    {
      size_t v21 = 0;
    }
    char v32 = 0;
    char v33 = &v21[8 * v15];
    uint64_t v34 = *(void *)a3;
    unsigned int v35 = a3[2];
    unint64_t v36 = &v33[8 * a6];
    unsigned int v37 = *(unsigned __int16 *)(*(void *)a3 + 10);
    unsigned int v38 = v33;
    do
    {
      if (v35 < v37)
      {
        char v32 = (_DWORD *)(*(void *)v34 + 4 * v35);
        uint64_t v6 = (_WORD *)(*(void *)v34 + *(unsigned __int16 *)(v34 + 8) + 2 * v35);
      }
      *(_DWORD *)unsigned int v38 = *v32;
      *((_WORD *)v38 + 2) = *v6;
      if (v35 + 1 < v37) {
        ++v35;
      }
      else {
        unsigned int v35 = v37;
      }
      v38 += 8;
    }
    while (v38 != v36);
    if ((void *)v13 == a2) {
      goto LABEL_47;
    }
    if ((unint64_t)(v14 - 8) >= 0x68)
    {
      unint64_t v39 = v16;
      if ((v14 & 0xFFFFFFFFFFFFFFF8) + v13 - (unint64_t)&v21[v14 & 0xFFFFFFFFFFFFFFF8] >= 0x20)
      {
        unint64_t v40 = ((unint64_t)(v14 - 8) >> 3) + 1;
        unint64_t v39 = v16 - 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v41 = 8 * v15 - 16;
        unsigned int v42 = (long long *)(v13 + v41);
        unint64_t v43 = &v21[v41];
        uint64_t v44 = v40 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v45 = *v42;
          *((_OWORD *)v43 - 1) = *(v42 - 1);
          *(_OWORD *)unint64_t v43 = v45;
          v42 -= 2;
          v43 -= 32;
          v44 -= 4;
        }
        while (v44);
        v33 -= 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
        if (v40 == (v40 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
    }
    else
    {
      unint64_t v39 = v16;
    }
    do
    {
      uint64_t v46 = *(void *)(v39 - 8);
      v39 -= 8;
      *((void *)v33 - 1) = v46;
      v33 -= 8;
    }
    while (v39 != v13);
LABEL_47:
    unint64_t v47 = &v21[8 * v20];
    unint64_t v48 = a1[1];
    if (v48 != v16)
    {
      unint64_t v49 = (char *)((v14 & 0xFFFFFFFFFFFFFFF8) + v13);
      unint64_t v50 = v48 - (void)v49 - 8;
      if (v50 < 0x68) {
        goto LABEL_114;
      }
      if ((unint64_t)(&v21[8 * a6 + (v14 & 0xFFFFFFFFFFFFFFF8)] - v49) < 0x20) {
        goto LABEL_114;
      }
      uint64_t v51 = (v50 >> 3) + 1;
      uint64_t v52 = 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
      v16 += v52;
      uint64_t v53 = &v21[8 * v15 + 16 + 8 * a6];
      long long v54 = (long long *)(8 * v15 + v13 + 16);
      uint64_t v55 = v51 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v56 = *v54;
        *((_OWORD *)v53 - 1) = *(v54 - 1);
        *(_OWORD *)uint64_t v53 = v56;
        v53 += 32;
        v54 += 2;
        v55 -= 4;
      }
      while (v55);
      v36 += v52;
      if (v51 != (v51 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_114:
        do
        {
          uint64_t v57 = *(void *)v16;
          v16 += 8;
          *(void *)unint64_t v36 = v57;
          v36 += 8;
        }
        while (v16 != v48);
      }
    }
    int v58 = (void *)*a1;
    *a1 = (unint64_t)v33;
    a1[1] = (unint64_t)v36;
    a1[2] = (unint64_t)v47;
    if (v58)
    {
      operator delete(v58);
    }
    return;
  }
  uint64_t v22 = *(void *)a3;
  int v23 = a3[2];
  unsigned int v24 = *(unsigned __int16 *)(*(void *)a3 + 10);
  if (v23 + 1 < v24) {
    unsigned int v25 = v23 + 1;
  }
  else {
    unsigned int v25 = *(unsigned __int16 *)(*(void *)a3 + 10);
  }
  unsigned int v26 = v25;
  if ((unint64_t)a6 >= 2)
  {
    unint64_t v27 = a6 + 1;
    unsigned int v26 = v25;
    do
    {
      if (v26 + 1 < v24) {
        ++v26;
      }
      else {
        unsigned int v26 = *(unsigned __int16 *)(*(void *)a3 + 10);
      }
      --v27;
    }
    while (v27 > 2);
  }
  uint64_t v28 = v12 - v16;
  uint64_t v29 = (uint64_t)(v12 - v16) >> 3;
  if (v29 >= a6)
  {
    unint64_t v31 = a1[1];
    unsigned int v25 = v26;
LABEL_62:
    uint64_t v59 = v16 + 8 * a6;
    uint64_t v60 = (uint64_t)(v31 - v59) >> 3;
    uint64_t v61 = (uint64_t *)(v31 - 8 * a6);
    unint64_t v62 = (void *)v31;
    if ((unint64_t)v61 < v12)
    {
      unint64_t v63 = (v14 & 0xFFFFFFFFFFFFFFF8) + v31 - v59;
      unint64_t v64 = (char *)(v63 + v13);
      unint64_t v65 = v63 + v13 + 8;
      if (v12 > v65) {
        unint64_t v65 = v12;
      }
      unint64_t v66 = v65 + ~v13 - v63;
      unint64_t v67 = v31 - (void)v64;
      BOOL v68 = v66 >= 0x58 && v67 > 0x1F;
      unint64_t v62 = (void *)v31;
      if (!v68) {
        goto LABEL_115;
      }
      uint64_t v69 = (v66 >> 3) + 1;
      uint64_t v70 = 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v61 = (uint64_t *)((char *)v61 + v70);
      unint64_t v71 = (_OWORD *)(v31 + 16);
      unint64_t v72 = (long long *)(8 * v60 + 8 * v15 + v13 + 16);
      uint64_t v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v74 = *v72;
        *(v71 - 1) = *(v72 - 1);
        _OWORD *v71 = v74;
        v71 += 2;
        v72 += 2;
        v73 -= 4;
      }
      while (v73);
      unint64_t v62 = (void *)(v31 + v70);
      if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_115:
        do
        {
          uint64_t v75 = *v61++;
          *v62++ = v75;
        }
        while ((unint64_t)v61 < v12);
      }
    }
    a1[1] = (unint64_t)v62;
    if (v31 != v59)
    {
      uint64_t v76 = (_WORD *)(v31 - 4);
      uint64_t v77 = 8 * v60;
      do
      {
        uint64_t v59 = *(unsigned int *)(v16 + v77 - 8);
        *((_DWORD *)v76 - 1) = v59;
        _WORD *v76 = *(_WORD *)(v16 + v77 - 4);
        v76 -= 4;
        v77 -= 8;
      }
      while (v77);
    }
    uint64_t v78 = *(void *)a3;
    unsigned int v79 = a3[2];
    uint64_t v80 = *(void *)a3 == v22;
    if (*(void *)a3 != v22 || v79 != v25)
    {
      unsigned int v81 = *(unsigned __int16 *)(v78 + 10);
      if ((v80 & 1) == 0)
      {
        uint64_t v85 = 0;
        while (1)
        {
          if (v79 < v81)
          {
            uint64_t v85 = (_DWORD *)(*(void *)v78 + 4 * v79);
            uint64_t v80 = *(void *)v78 + *(unsigned __int16 *)(v78 + 8) + 2 * v79;
          }
          *(_DWORD *)unint64_t v16 = *v85;
          *(_WORD *)(v16 + 4) = *(_WORD *)v80;
          if (v79 + 1 < v81) {
            ++v79;
          }
          else {
            unsigned int v79 = v81;
          }
          v16 += 8;
        }
      }
      int8x8_t v82 = 0;
      do
      {
        if (v79 < v81)
        {
          int8x8_t v82 = (_DWORD *)(*(void *)v78 + 4 * v79);
          uint64_t v59 = *(void *)v78 + *(unsigned __int16 *)(v78 + 8) + 2 * v79;
        }
        *(_DWORD *)unint64_t v16 = *v82;
        *(_WORD *)(v16 + 4) = *(_WORD *)v59;
        if (v79 + 1 < v81) {
          ++v79;
        }
        else {
          unsigned int v79 = v81;
        }
        v16 += 8;
      }
      while (v79 != v25);
    }
    return;
  }
  if (v28 < 1)
  {
    unsigned int v25 = a3[2];
  }
  else if ((unint64_t)v28 >= 9)
  {
    unint64_t v30 = v29 + 1;
    do
    {
      if (v25 + 1 < v24) {
        ++v25;
      }
      else {
        unsigned int v25 = *(unsigned __int16 *)(*(void *)a3 + 10);
      }
      --v30;
    }
    while (v30 > 2);
  }
  if (v22 != a4 || (unint64_t v31 = a1[1], v25 != a5))
  {
    if (v22 != a4)
    {
      unint64_t v86 = 0;
      while (1)
      {
        if (v25 < v24)
        {
          unint64_t v86 = (_DWORD *)(*(void *)v22 + 4 * v25);
          uint64_t v29 = *(void *)v22 + *(unsigned __int16 *)(v22 + 8) + 2 * v25;
        }
        *(_DWORD *)unint64_t v12 = *v86;
        *(_WORD *)(v12 + 4) = *(_WORD *)v29;
        if (v25 + 1 < v24) {
          ++v25;
        }
        else {
          unsigned int v25 = v24;
        }
        v12 += 8;
      }
    }
    size_t v83 = 0;
    unint64_t v31 = a1[1];
    unsigned int v84 = v25;
    do
    {
      if (v84 < v24)
      {
        size_t v83 = (_DWORD *)(*(void *)v22 + 4 * v84);
        unsigned int v7 = (_WORD *)(*(void *)v22 + *(unsigned __int16 *)(v22 + 8) + 2 * v84);
      }
      *(_DWORD *)unint64_t v31 = *v83;
      *(_WORD *)(v31 + 4) = *v7;
      if (v84 + 1 < v24) {
        ++v84;
      }
      else {
        unsigned int v84 = v24;
      }
      v31 += 8;
    }
    while (v84 != a5);
  }
  a1[1] = v31;
  if (v29 >= 1) {
    goto LABEL_62;
  }
}

void gss::StylesheetManager<gss::PropertyID>::sourceStyleAttributes(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  std::string __p = 0;
  uint64_t v19 = 0;
  unint64_t v20 = 0;
  uint64_t v10 = a4 - a3;
  unint64_t v11 = v10 + 20;
  if (v10 == -20)
  {
    unint64_t v12 = 0;
  }
  else
  {
    if (v11 >> 61) {
      abort();
    }
    unint64_t v12 = (char *)operator new(8 * v11);
    std::string __p = v12;
    uint64_t v19 = v12;
    unint64_t v20 = &v12[8 * v11];
  }
  std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>,std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>>((unint64_t *)&__p, (uint64_t)v12, a3, a4, v10);
  uint64_t v13 = *(void *)(a2 + 520);
  if (v13)
  {
    gss::ClientStyleState<gss::PropertyID>::appendSourceClientStyleAttributes(v13, (unint64_t *)&__p);
    unsigned int v14 = *(unsigned __int16 *)(a5 + 10);
    uint64_t v21 = a5;
    int v22 = 0;
    char v23 = 0;
    char v24 = 0;
    if (v14)
    {
      unsigned int v15 = 0;
      uint64_t v16 = 0;
      do
      {
        ++v16;
        unsigned int v17 = v15 + 1;
        if (v15 + 1 < v14) {
          ++v15;
        }
        else {
          unsigned int v15 = v14;
        }
      }
      while (v17 < v14);
    }
    else
    {
      uint64_t v16 = 0;
    }
    std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator,geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::Iterator>((unint64_t *)&__p, v19, &v21, a5, v14, v16);
  }
  gss::ResolveMultiAttributeVectorToMap((unsigned int **)&__p, a1);
  if (__p)
  {
    uint64_t v19 = __p;
    operator delete(__p);
  }
}

void sub_1A181929C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<gss::StyleAttribute,unsigned short>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>,std::__wrap_iter<std::pair<gss::StyleAttribute,unsigned short> const*>>(unint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v5 = a5 - 1;
  if (a5 < 1) {
    return;
  }
  unsigned int v7 = a3;
  unint64_t v10 = *a1;
  unint64_t v9 = a1[1];
  uint64_t v11 = a2 - *a1;
  uint64_t v12 = v11 >> 3;
  unint64_t v13 = *a1 + (v11 & 0xFFFFFFFFFFFFFFF8);
  unint64_t v14 = a1[2];
  if (a5 > (uint64_t)(v14 - v9) >> 3)
  {
    unint64_t v15 = a5 + ((uint64_t)(v9 - v10) >> 3);
    if (v15 >> 61) {
      abort();
    }
    uint64_t v16 = v14 - v10;
    if (v16 >> 2 > v15) {
      unint64_t v15 = v16 >> 2;
    }
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v17 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v17 = v15;
    }
    if (v17)
    {
      if (v17 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v18 = (char *)operator new(8 * v17);
    }
    else
    {
      unint64_t v18 = 0;
    }
    unint64_t v31 = &v18[8 * v12];
    char v32 = &v31[8 * a5];
    uint64_t v33 = v5 & 0x1FFFFFFFFFFFFFFFLL;
    uint64_t v34 = v31;
    if ((v5 & 0x1FFFFFFFFFFFFFFFuLL) >= 7)
    {
      uint64_t v34 = &v18[8 * v12];
      if ((unint64_t)(&v18[v11 & 0xFFFFFFFFFFFFFFF8] - (char *)v7) >= 0x20)
      {
        unint64_t v35 = v10;
        uint64_t v36 = (v33 + 1) & 0x3FFFFFFFFFFFFFFCLL;
        uint64_t v34 = &v31[8 * v36];
        unsigned int v37 = (long long *)(v7 + 2);
        unsigned int v38 = &v18[8 * v12 + 16];
        uint64_t v39 = v36;
        do
        {
          long long v40 = *v37;
          *((_OWORD *)v38 - 1) = *(v37 - 1);
          *(_OWORD *)unsigned int v38 = v40;
          v37 += 2;
          v38 += 32;
          v39 -= 4;
        }
        while (v39);
        if (v33 + 1 == v36) {
          goto LABEL_30;
        }
        v7 += v36;
      }
    }
    do
    {
      uint64_t v41 = *v7++;
      *(void *)uint64_t v34 = v41;
      v34 += 8;
    }
    while (v34 != v32);
    unint64_t v35 = *a1;
LABEL_30:
    if (v35 != v13)
    {
      unsigned int v42 = (char *)((v11 & 0xFFFFFFFFFFFFFFF8) + v10);
      unint64_t v43 = (unint64_t)&v42[-v35 - 8];
      if (v43 < 0x68)
      {
        unint64_t v44 = v13;
        goto LABEL_37;
      }
      unint64_t v44 = v13;
      if ((unint64_t)(v42 - &v18[v11 & 0xFFFFFFFFFFFFFFF8]) < 0x20) {
        goto LABEL_76;
      }
      uint64_t v45 = (v43 >> 3) + 1;
      unint64_t v44 = v13 - 8 * (v45 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v46 = 8 * v12 - 16;
      unint64_t v47 = (long long *)(v10 + v46);
      unint64_t v48 = &v18[v46];
      uint64_t v49 = v45 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v50 = *v47;
        *((_OWORD *)v48 - 1) = *(v47 - 1);
        *(_OWORD *)unint64_t v48 = v50;
        v47 -= 2;
        v48 -= 32;
        v49 -= 4;
      }
      while (v49);
      v31 -= 8 * (v45 & 0x3FFFFFFFFFFFFFFCLL);
      if (v45 != (v45 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_76:
        do
        {
LABEL_37:
          uint64_t v51 = *(void *)(v44 - 8);
          v44 -= 8;
          *((void *)v31 - 1) = v51;
          v31 -= 8;
        }
        while (v44 != v35);
        unint64_t v9 = a1[1];
      }
    }
    uint64_t v52 = &v18[8 * v17];
    if (v9 != v13)
    {
      uint64_t v53 = (char *)((v11 & 0xFFFFFFFFFFFFFFF8) + v10);
      unint64_t v54 = v9 - (void)v53 - 8;
      if (v54 < 0x68) {
        goto LABEL_77;
      }
      if ((unint64_t)(&v18[8 * a5 + (v11 & 0xFFFFFFFFFFFFFFF8)] - v53) < 0x20) {
        goto LABEL_77;
      }
      uint64_t v55 = (v54 >> 3) + 1;
      uint64_t v56 = 8 * (v55 & 0x3FFFFFFFFFFFFFFCLL);
      v13 += v56;
      uint64_t v57 = &v18[8 * v12 + 16 + 8 * a5];
      int v58 = (long long *)(8 * v12 + v10 + 16);
      uint64_t v59 = v55 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v60 = *v58;
        *((_OWORD *)v57 - 1) = *(v58 - 1);
        *(_OWORD *)uint64_t v57 = v60;
        v57 += 32;
        v58 += 2;
        v59 -= 4;
      }
      while (v59);
      v32 += v56;
      if (v55 != (v55 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_77:
        do
        {
          uint64_t v61 = *(void *)v13;
          v13 += 8;
          *(void *)char v32 = v61;
          v32 += 8;
        }
        while (v13 != v9);
      }
    }
    unint64_t v62 = (void *)*a1;
    *a1 = (unint64_t)v31;
    a1[1] = (unint64_t)v32;
    a1[2] = (unint64_t)v52;
    if (v62)
    {
      operator delete(v62);
    }
    return;
  }
  uint64_t v19 = v9 - v13;
  uint64_t v20 = (uint64_t)(v9 - v13) >> 3;
  if (v20 < a5)
  {
    uint64_t v21 = &a3[v20];
    if (v21 == a4)
    {
      char v24 = (char *)a1[1];
      goto LABEL_53;
    }
    unint64_t v22 = (char *)a4 - ((char *)a3 + v19) - 8;
    if (v22 < 0x38)
    {
      char v23 = &a3[v20];
      char v24 = (char *)a1[1];
    }
    else
    {
      char v23 = &a3[v20];
      char v24 = (char *)a1[1];
      if (v13 - (unint64_t)a3 >= 0x20)
      {
        uint64_t v25 = (v22 >> 3) + 1;
        uint64_t v26 = v25 & 0x3FFFFFFFFFFFFFFCLL;
        char v23 = &v21[v26];
        unint64_t v27 = (_OWORD *)(v9 + 16);
        uint64_t v28 = (long long *)&a3[v20 + 2];
        uint64_t v29 = v25 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v30 = *v28;
          *(v27 - 1) = *(v28 - 1);
          _OWORD *v27 = v30;
          v27 += 2;
          v28 += 2;
          v29 -= 4;
        }
        while (v29);
        char v24 = (char *)(v9 + v26 * 8);
        if (v25 == (v25 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_53:
          a1[1] = (unint64_t)v24;
          if (v19 < 1) {
            return;
          }
          goto LABEL_54;
        }
      }
    }
    do
    {
      uint64_t v63 = *v23++;
      *(void *)char v24 = v63;
      v24 += 8;
    }
    while (v23 != a4);
    goto LABEL_53;
  }
  uint64_t v21 = &a3[a5];
  char v24 = (char *)a1[1];
LABEL_54:
  unint64_t v64 = (char *)(v13 + 8 * a5);
  uint64_t v65 = (v24 - v64) >> 3;
  unint64_t v66 = (uint64_t *)&v24[-8 * a5];
  unint64_t v67 = v24;
  if ((unint64_t)v66 < v9)
  {
    unint64_t v68 = (v11 & 0xFFFFFFFFFFFFFFF8) + v24 - v64;
    uint64_t v69 = (char *)(v68 + v10);
    unint64_t v70 = v68 + v10 + 8;
    if (v9 > v70) {
      unint64_t v70 = v9;
    }
    unint64_t v71 = v70 + ~v10 - v68;
    unint64_t v72 = v24 - v69;
    BOOL v73 = v71 >= 0x58 && v72 > 0x1F;
    unint64_t v67 = v24;
    if (!v73) {
      goto LABEL_78;
    }
    uint64_t v74 = (v71 >> 3) + 1;
    uint64_t v75 = 8 * (v74 & 0x3FFFFFFFFFFFFFFCLL);
    unint64_t v66 = (uint64_t *)((char *)v66 + v75);
    uint64_t v76 = v24 + 16;
    uint64_t v77 = (long long *)(8 * v65 + 8 * v12 + v10 + 16);
    uint64_t v78 = v74 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v79 = *v77;
      *(v76 - 1) = *(v77 - 1);
      _OWORD *v76 = v79;
      v76 += 2;
      v77 += 2;
      v78 -= 4;
    }
    while (v78);
    unint64_t v67 = &v24[v75];
    if (v74 != (v74 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_78:
      do
      {
        uint64_t v80 = *v66++;
        *(void *)unint64_t v67 = v80;
        v67 += 8;
      }
      while ((unint64_t)v66 < v9);
    }
  }
  a1[1] = (unint64_t)v67;
  if (v24 != v64)
  {
    unsigned int v81 = v24 - 4;
    uint64_t v82 = 8 * v65;
    do
    {
      *((_DWORD *)v81 - 1) = *(_DWORD *)(v13 + v82 - 8);
      *(_WORD *)unsigned int v81 = *(_WORD *)(v13 + v82 - 4);
      v81 -= 8;
      v82 -= 8;
    }
    while (v82);
  }
  if (v21 != a3)
  {
    do
    {
      *(_DWORD *)unint64_t v13 = *(_DWORD *)v7;
      *(_WORD *)(v13 + 4) = *((_WORD *)v7++ + 2);
      v13 += 8;
    }
    while (v7 != v21);
  }
}

BOOL gss::ClientStyleState<gss::PropertyID>::hasTargetStyleAttributes(uint64_t a1)
{
  unint64_t v2 = (pthread_rwlock_t *)(a1 + 16);
  unint64_t v3 = (geo::read_write_lock *)pthread_rwlock_rdlock((pthread_rwlock_t *)(a1 + 16));
  if (v3) {
    geo::read_write_lock::logFailure(v3, (uint64_t)"read lock", v4);
  }
  unint64_t v5 = *(unsigned __int16 *)(a1 + 242);
  if (v5 != *(unsigned __int16 *)(a1 + 226)) {
    goto LABEL_12;
  }
  if (!*(_WORD *)(a1 + 242))
  {
    BOOL v16 = 0;
    goto LABEL_16;
  }
  uint64_t v6 = *(_DWORD **)(a1 + 232);
  unsigned int v7 = *(_DWORD **)(a1 + 216);
  if (*v6 != *v7
    || (uint64_t v8 = *(unsigned __int16 *)(a1 + 224),
        uint64_t v9 = *(unsigned __int16 *)(a1 + 240),
        *(unsigned __int16 *)((char *)v6 + v9) != *(unsigned __int16 *)((char *)v7 + v8)))
  {
LABEL_12:
    BOOL v16 = 1;
    goto LABEL_16;
  }
  unint64_t v10 = 0;
  uint64_t v11 = v6 + 1;
  uint64_t v12 = v7 + 1;
  uint64_t v13 = (uint64_t)v6 + v9 + 2;
  uint64_t v14 = (uint64_t)v7 + v8 + 2;
  while (v5 - 1 != v10)
  {
    uint64_t v15 = v10++;
    if (v11[v15] != v12[v15]) {
      goto LABEL_15;
    }
    if (*(unsigned __int16 *)(v13 + 2 * v15) != *(unsigned __int16 *)(v14 + 2 * v15))
    {
      unint64_t v10 = v15 + 1;
      goto LABEL_15;
    }
  }
  unint64_t v10 = *(unsigned __int16 *)(a1 + 242);
LABEL_15:
  BOOL v16 = v10 < v5;
LABEL_16:
  unint64_t v17 = (geo::read_write_lock *)pthread_rwlock_unlock(v2);
  if (v17) {
    geo::read_write_lock::logFailure(v17, (uint64_t)"unlock", v18);
  }
  return v16;
}

void gss::StyleSheet<gss::PropertyID>::decodeStyl(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, void *a7)
{
  uint64_t v316 = *MEMORY[0x1E4F143B8];
  int8x16_t v301 = 0;
  int64x2_t v302 = (gss::Allocator *)gss::Allocator::instance((gss::Allocator *)a1);
  uint64_t v303 = 0;
  int8x16_t v300 = &v301;
  uint64_t v305 = 0;
  int8x16_t v306 = (gss::Allocator *)gss::Allocator::instance(v302);
  uint64_t v307 = 0;
  unsigned long long v304 = &v305;
  uint64_t v308 = a2;
  uint64_t v309 = a3;
  unsigned int v291 = 0;
  int64x2_t v292 = (gss::Allocator *)gss::Allocator::instance(v306);
  uint64_t v293 = 0;
  unsigned int v290 = &v291;
  int v296 = 0;
  uint64_t v297 = gss::Allocator::instance(v292);
  uint64_t v298 = 0;
  int v295 = &v296;
  uint64_t v285 = a1;
  if ((gss::StylFile::parseHeader((uint64_t)&v300, a7) & 1) == 0)
  {
    char v24 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 386;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not decode STYL header.";
      _os_log_impl(&dword_1A1780000, v24, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    uint64_t v25 = (void *)std::ostream::operator<<();
    uint64_t v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v25, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v27 = "Could not decode STYL header.";
    uint64_t v28 = 29;
    goto LABEL_107;
  }
  uint64_t v14 = gss::StylFile::chapter(&v300, 1u);
  geo::ibitstream::readVarInt((uint64_t)&v310, v14);
  if (!(_BYTE)v310)
  {
    uint64_t v29 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 414;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read stylesheet version.";
      _os_log_impl(&dword_1A1780000, v29, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    long long v30 = (void *)std::ostream::operator<<();
    unint64_t v31 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v30, (uint64_t)" STYL Parse Error Here: ", 24);
    char v32 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v31, (uint64_t)"Could not read stylesheet version.", 34);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v32, (uint64_t)"\n", 1);
    goto LABEL_104;
  }
  int v286 = v311;
  uint64_t v15 = *((unsigned __int8 *)v14 + 24);
  char v16 = v15 + 1;
  unint64_t v17 = v14[1];
  uint64_t v18 = v14[2];
  unint64_t v19 = v18 + ((unint64_t)(v15 + 1) >> 3);
  unsigned int v20 = (v15 + 1) & 7;
  unint64_t v21 = v18 + 1;
  if (v19 < v18 + 1)
  {
    if (*((unsigned char *)v14 + 24)) {
      unint64_t v22 = v18 + 1;
    }
    else {
      unint64_t v22 = v14[2];
    }
    if (v17 < v22) {
      goto LABEL_22;
    }
    if (*((unsigned char *)v14 + 24))
    {
      if (v17 >= v21)
      {
        unsigned int v23 = (((1 << (8 - v15)) - 1) & *(unsigned __int8 *)(*v14 + v18)) << v15;
        goto LABEL_33;
      }
      goto LABEL_21;
    }
    if (v17 >= v21)
    {
      LOBYTE(v23) = *(unsigned char *)(*v14 + v18);
      goto LABEL_33;
    }
LABEL_21:
    v14[2] = v19;
    *((unsigned char *)v14 + 24) = v20;
LABEL_22:
    uint64_t v34 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 417;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read debug stylesheet flag.";
      _os_log_impl(&dword_1A1780000, v34, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    unint64_t v35 = (void *)std::ostream::operator<<();
    uint64_t v36 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v35, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned int v37 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v36, (uint64_t)"Could not read debug stylesheet flag.", 37);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
    goto LABEL_104;
  }
  if (v15 <= 7) {
    unint64_t v33 = v18 + 1;
  }
  else {
    unint64_t v33 = v18 + 2;
  }
  if (v17 < v33) {
    goto LABEL_21;
  }
  uint64_t v38 = *v14;
  if (*((unsigned char *)v14 + 24))
  {
    int v39 = *(unsigned __int8 *)(v38 + v18);
    if (v21 >= v17) {
      int v40 = 0;
    }
    else {
      int v40 = *(unsigned __int8 *)(v38 + v21);
    }
    unsigned int v23 = ((v40 & (0xFFFF << (8 - v15))) >> (8 - v15)) | ((((1 << (8 - v15)) + 255) & v39) << v15);
    v14[2] = v21;
  }
  else
  {
    LOBYTE(v23) = *(unsigned char *)(v38 + v18);
  }
LABEL_33:
  v14[2] = v19;
  *((unsigned char *)v14 + 24) = v20;
  BOOL v287 = (v23 & 0x80) != 0;
  unint64_t v41 = v19 + 2;
  if (!v20) {
    unint64_t v41 = v19 + 1;
  }
  if (v17 < v41)
  {
    unsigned int v42 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 420;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read number of modes.";
      _os_log_impl(&dword_1A1780000, v42, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    unint64_t v43 = (void *)std::ostream::operator<<();
    unint64_t v44 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v43, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v45 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v44, (uint64_t)"Could not read number of modes.", 31);
LABEL_103:
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v45, (uint64_t)"\n", 1);
    goto LABEL_104;
  }
  unint64_t v46 = v19 + 1;
  uint64_t v47 = *v14;
  unsigned int v48 = *(unsigned __int8 *)(*v14 + v19);
  if (v20)
  {
    if (v46 >= v17) {
      int v49 = 0;
    }
    else {
      int v49 = *(unsigned __int8 *)(v47 + v46);
    }
    unsigned int v48 = (((v49 & (0xFFFF << (8 - v20))) >> (8 - v20)) | ((((1 << (8 - v20)) - 1) & v48) << (v16 & 7)));
  }
  v14[2] = v46;
  if (v48)
  {
    int v50 = 0;
    unint64_t v17 = v14[1];
    while (1)
    {
      unint64_t v51 = v46;
      int v52 = v20;
      v46 += (v20 + 1) >> 3;
      LOBYTE(v20) = (v20 + 1) & 7;
      unint64_t v53 = v51 + 1;
      if (v46 >= v51 + 1)
      {
        if (v17 < v53) {
          goto LABEL_69;
        }
        if (!v52) {
          goto LABEL_61;
        }
        if (v53 >= v17) {
          int v55 = 0;
        }
        else {
          int v55 = *(unsigned __int8 *)(v47 + v53);
        }
        LODWORD(v51) = ((v55 & (0xFFFF << (8 - v52))) >> (8 - v52)) | ((((1 << (8 - v52)) + 255) & *(unsigned __int8 *)(v47 + v51)) << v52);
        v14[2] = v53;
      }
      else
      {
        if (v52) {
          unint64_t v54 = v51 + 1;
        }
        else {
          unint64_t v54 = v51;
        }
        if (v17 < v54) {
          goto LABEL_70;
        }
        if (!v52)
        {
          v14[2] = v51;
          if (v17 < v53)
          {
LABEL_69:
            v14[2] = v46;
            *((unsigned char *)v14 + 24) = v20;
LABEL_70:
            uint64_t v56 = GEOGetGeoCSSStyleSheetLog();
            if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 423;
              __int16 v314 = 2082;
              *(void *)int8x16_t v315 = "Could not read mode support flag.";
              _os_log_impl(&dword_1A1780000, v56, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }

            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
            uint64_t v57 = (void *)std::ostream::operator<<();
            int v58 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v57, (uint64_t)" STYL Parse Error Here: ", 24);
            uint64_t v59 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v58, (uint64_t)"Could not read mode support flag.", 33);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v59, (uint64_t)"\n", 1);
LABEL_104:
            unint64_t v86 = GEOGetGeoCSSStyleSheetLog();
            if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 387;
              __int16 v314 = 2082;
              *(void *)int8x16_t v315 = "Could not decode stylesheet info.";
              _os_log_impl(&dword_1A1780000, v86, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }

            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
            uint8x8_t v87 = (void *)std::ostream::operator<<();
            uint64_t v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v87, (uint64_t)" STYL Parse Error Here: ", 24);
            unint64_t v27 = "Could not decode stylesheet info.";
            uint64_t v28 = 33;
LABEL_107:
            uint64_t v88 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v26, (uint64_t)v27, v28);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v88, (uint64_t)"\n", 1);
            buf[0] = 0;
            uint64_t v89 = *(void *)(a5 + 24);
            if (v89)
            {
              (*(void (**)(uint64_t, unsigned char *))(*(void *)v89 + 48))(v89, buf);
              goto LABEL_109;
            }
            goto LABEL_350;
          }
LABEL_61:
          LOBYTE(v51) = *(unsigned char *)(v47 + v51);
          goto LABEL_64;
        }
        if (v17 < v53) {
          goto LABEL_69;
        }
        LODWORD(v51) = (((1 << (8 - v52)) - 1) & *(unsigned __int8 *)(v47 + v51)) << v52;
      }
LABEL_64:
      v14[2] = v46;
      *((unsigned char *)v14 + 24) = v20;
      if (v50 == 2)
      {
        *(unsigned char *)(a1 + 137) = (v51 & 0x80) != 0;
      }
      else if (v50 == 1)
      {
        *(unsigned char *)(a1 + 138) = (v51 & 0x80) != 0;
      }
      else
      {
        if (v50)
        {
          size_t v83 = GEOGetGeoCSSStyleSheetLog();
          if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 435;
            __int16 v314 = 2082;
            *(void *)int8x16_t v315 = "Support specified for unknown map mode.";
            _os_log_impl(&dword_1A1780000, v83, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }

          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
          unsigned int v84 = (void *)std::ostream::operator<<();
          uint64_t v85 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v84, (uint64_t)" STYL Parse Error Here: ", 24);
          uint64_t v45 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v85, (uint64_t)"Support specified for unknown map mode.", 39);
          goto LABEL_103;
        }
        *(unsigned char *)(a1 + 136) = (v51 & 0x80) != 0;
      }
      if (++v50 >= v48)
      {
        unint64_t v46 = v14[2];
        unsigned int v20 = *((unsigned __int8 *)v14 + 24);
        break;
      }
    }
  }
  unint64_t v60 = v46 + 2;
  unint64_t v61 = v46 + 3;
  if (!v20) {
    unint64_t v61 = v46 + 2;
  }
  if (v17 < v61)
  {
    unint64_t v62 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 441;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read number of attributes.";
      _os_log_impl(&dword_1A1780000, v62, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    uint64_t v63 = (void *)std::ostream::operator<<();
    unint64_t v64 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v63, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v45 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v64, (uint64_t)"Could not read number of attributes.", 36);
    goto LABEL_103;
  }
  uint64_t v65 = *v14;
  if (v20)
  {
    char v66 = 8 - v20;
    int v67 = 0xFFFF << (8 - v20);
    unint64_t v68 = v46 + 1;
    if (v46 + 1 >= v17) {
      int v69 = 0;
    }
    else {
      int v69 = *(unsigned __int8 *)(v65 + v68);
    }
    unsigned int v71 = ((v69 & v67) >> v66) | ((((1 << (8 - v20)) - 1) & *(unsigned char *)(v65 + v46)) << v20);
    v14[2] = v68;
    int v73 = *(unsigned __int8 *)(v65 + v68);
    if (v60 >= v17) {
      int v74 = 0;
    }
    else {
      int v74 = *(unsigned __int8 *)(v65 + v60);
    }
    unsigned int v72 = ((v74 & v67) >> v66) | ((((1 << (8 - v20)) + 255) & v73) << v20);
    unsigned int v70 = v20;
  }
  else
  {
    unsigned int v70 = 0;
    unsigned int v71 = *(unsigned __int16 *)(v65 + v46);
    unsigned int v72 = v71 >> 8;
  }
  v14[2] = v60;
  unint64_t v75 = v60 + ((v70 + 5) >> 3);
  unsigned int v76 = (v70 + 5) & 7;
  unint64_t v77 = v46 + 3;
  if (v75 < v77)
  {
    if (v20)
    {
      if (v17 >= v77)
      {
        unsigned int v78 = (((1 << (8 - v20)) - 1) & *(unsigned __int8 *)(v65 + v60)) << v70;
        goto LABEL_118;
      }
LABEL_112:
      v14[2] = v75;
      *((unsigned char *)v14 + 24) = v76;
      size_t v91 = GEOGetGeoCSSStyleSheetLog();
      if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 444;
        __int16 v314 = 2082;
        *(void *)int8x16_t v315 = "Could not read number of bits for feature attribute.";
        _os_log_impl(&dword_1A1780000, v91, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }

      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
      uint64_t v92 = (void *)std::ostream::operator<<();
      uint64_t v93 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v92, (uint64_t)" STYL Parse Error Here: ", 24);
      unint64_t v94 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v93, (uint64_t)"Could not read number of bits for feature attribute.", 52);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v94, (uint64_t)"\n", 1);
      goto LABEL_104;
    }
    if (v17 < v77) {
      goto LABEL_112;
    }
    goto LABEL_115;
  }
  if (v20 <= 3) {
    unint64_t v79 = v77;
  }
  else {
    unint64_t v79 = v77 + 1;
  }
  if (v17 < v79) {
    goto LABEL_112;
  }
  if (!v20)
  {
LABEL_115:
    LOBYTE(v78) = *(unsigned char *)(v65 + v60);
    goto LABEL_118;
  }
  char v80 = 8 - v20;
  int v81 = *(unsigned __int8 *)(v65 + v60);
  if (v77 >= v17) {
    int v82 = 0;
  }
  else {
    int v82 = *(unsigned __int8 *)(v65 + v77);
  }
  unsigned int v78 = ((v82 & (0xFFFF << v80)) >> v80) | ((((1 << v80) + 255) & v81) << v70);
  v14[2] = v77;
LABEL_118:
  v14[2] = v75;
  *((unsigned char *)v14 + 24) = v76;
  int v95 = ((_BYTE)v70 + 5) & 7;
  unint64_t v96 = v75 + ((v95 + 5) >> 3);
  char v97 = (v95 + 5) & 7;
  unint64_t v98 = v75 + 1;
  uint64_t v281 = a6;
  if (v96 < v75 + 1)
  {
    if (v76) {
      unint64_t v99 = v75 + 1;
    }
    else {
      unint64_t v99 = v75;
    }
    if (v17 < v99) {
      goto LABEL_131;
    }
    if (v76)
    {
      if (v17 >= v98)
      {
        unsigned int v100 = (((1 << (8 - v76)) - 1) & *(unsigned __int8 *)(v65 + v75)) << v95;
        goto LABEL_141;
      }
      goto LABEL_130;
    }
    v14[2] = v75;
    if (v17 >= v98) {
      goto LABEL_138;
    }
LABEL_130:
    v14[2] = v96;
    *((unsigned char *)v14 + 24) = v97;
LABEL_131:
    float v102 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 445;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read number of bits for client attribute.";
      _os_log_impl(&dword_1A1780000, v102, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    BOOL v103 = (void *)std::ostream::operator<<();
    unint64_t v104 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v103, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v105 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v104, (uint64_t)"Could not read number of bits for client attribute.", 51);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v105, (uint64_t)"\n", 1);
    goto LABEL_104;
  }
  if (v76 <= 3) {
    unint64_t v101 = v75 + 1;
  }
  else {
    unint64_t v101 = v75 + 2;
  }
  if (v17 < v101) {
    goto LABEL_130;
  }
  if (!v76)
  {
LABEL_138:
    LOBYTE(v100) = *(unsigned char *)(v65 + v75);
    goto LABEL_141;
  }
  char v106 = 8 - v76;
  int v107 = *(unsigned __int8 *)(v65 + v75);
  if (v98 >= v17) {
    int v108 = 0;
  }
  else {
    int v108 = *(unsigned __int8 *)(v65 + v98);
  }
  unsigned int v100 = ((v108 & (0xFFFF << v106)) >> v106) | ((((1 << v106) + 255) & v107) << v95);
  v14[2] = v98;
LABEL_141:
  unsigned __int16 v109 = v71 | (unsigned __int16)((_WORD)v72 << 8);
  v14[2] = v96;
  *((unsigned char *)v14 + 24) = v97;
  unsigned __int8 v288 = (v78 >> 3) + 1;
  unsigned __int8 v289 = (v100 >> 3) + 1;
  int v273 = a4;
  if (v109)
  {
    int v110 = 0;
    unsigned __int16 v278 = v109;
    while (1)
    {
      int v282 = v110;
      LODWORD(v310) = 0;
      if (!gss::decodeAttributeEncoding(v14, &v310, v288, v289, a7)) {
        break;
      }
      uint64_t v111 = *((unsigned __int8 *)v14 + 24);
      unint64_t v113 = v14[1];
      uint64_t v112 = v14[2];
      unint64_t v114 = v112 + ((unint64_t)(v111 + 5) >> 3);
      char v115 = (v111 + 5) & 7;
      unint64_t v116 = v112 + 1;
      a6 = v281;
      if (v114 >= v112 + 1)
      {
        if (v111 <= 3) {
          unint64_t v119 = v112 + 1;
        }
        else {
          unint64_t v119 = v112 + 2;
        }
        if (v113 < v119)
        {
LABEL_222:
          v14[2] = v114;
          *((unsigned char *)v14 + 24) = v115;
LABEL_223:
          uint64_t v155 = GEOGetGeoCSSStyleSheetLog();
          if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 452;
            __int16 v314 = 2082;
            *(void *)int8x16_t v315 = "Could not read number of bits for attribute value.";
            _os_log_impl(&dword_1A1780000, v155, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }

          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
          std::string::size_type v156 = (void *)std::ostream::operator<<();
          long long v157 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v156, (uint64_t)" STYL Parse Error Here: ", 24);
          unint64_t v158 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v157, (uint64_t)"Could not read number of bits for attribute value.", 50);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v158, (uint64_t)"\n", 1);
          goto LABEL_104;
        }
        uint64_t v120 = *v14;
        if (*((unsigned char *)v14 + 24))
        {
          if (v116 >= v113) {
            int v121 = 0;
          }
          else {
            int v121 = *(unsigned __int8 *)(v120 + v116);
          }
          unsigned int v118 = ((v121 & (0xFFFF << (8 - v111))) >> (8 - v111)) | ((((1 << (8 - v111)) + 255) & *(unsigned __int8 *)(v120 + v112)) << v111);
          v14[2] = v116;
        }
        else
        {
          LOBYTE(v118) = *(unsigned char *)(v120 + v112);
        }
      }
      else
      {
        if (*((unsigned char *)v14 + 24)) {
          unint64_t v117 = v112 + 1;
        }
        else {
          unint64_t v117 = v14[2];
        }
        if (v113 < v117) {
          goto LABEL_223;
        }
        if (*((unsigned char *)v14 + 24))
        {
          if (v113 < v116) {
            goto LABEL_222;
          }
          unsigned int v118 = (((1 << (8 - v111)) - 1) & *(unsigned __int8 *)(*v14 + v112)) << v111;
        }
        else
        {
          if (v113 < v116) {
            goto LABEL_222;
          }
          LOBYTE(v118) = *(unsigned char *)(*v14 + v112);
        }
      }
      v14[2] = v114;
      *((unsigned char *)v14 + 24) = v115;
      int v122 = v291;
      unsigned int v123 = &v291;
      unint64_t v124 = &v291;
      if (v291)
      {
        while (1)
        {
          while (1)
          {
            unint64_t v124 = (uint64_t **)v122;
            unsigned int v125 = *((_DWORD *)v122 + 7);
            if (v310 >= v125) {
              break;
            }
            int v122 = *v124;
            unsigned int v123 = v124;
            if (!*v124) {
              goto LABEL_173;
            }
          }
          if (v125 >= v310) {
            break;
          }
          int v122 = v124[1];
          if (!v122)
          {
            unsigned int v123 = v124 + 1;
            goto LABEL_173;
          }
        }
        uint64_t v126 = (uint64_t)v124;
      }
      else
      {
LABEL_173:
        uint64_t v126 = (*(uint64_t (**)(gss::Allocator *, uint64_t, uint64_t))(*(void *)v292 + 16))(v292, 40, 8);
        *(_DWORD *)(v126 + 28) = v310;
        *(unsigned char *)(v126 + 32) = 0;
        *(void *)uint64_t v126 = 0;
        *(void *)(v126 + 8) = 0;
        *(void *)(v126 + 16) = v124;
        *unsigned int v123 = (uint64_t *)v126;
        int64x2_t v127 = (uint64_t *)v126;
        if (*v290)
        {
          unsigned int v290 = (uint64_t **)*v290;
          int64x2_t v127 = *v123;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v291, v127);
        ++v293;
      }
      *(unsigned char *)(v126 + 32) = (v118 >> 3) + 1;
      int v110 = v282 + 1;
      if ((unsigned __int16)(v282 + 1) >= v278) {
        goto LABEL_176;
      }
    }
    GEOGetGeoCSSStyleSheetLog();
    unint64_t v151 = a6 = v281;
    if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 450;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not decode attribute.";
      _os_log_impl(&dword_1A1780000, v151, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    uint8x8_t v152 = (void *)std::ostream::operator<<();
    char v153 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v152, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v154 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v153, (uint64_t)"Could not decode attribute.", 27);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v154, (uint64_t)"\n", 1);
    goto LABEL_104;
  }
LABEL_176:
  geo::ibitstream::readUIntBits(&v310, v14, 5u);
  if (!(_BYTE)v310)
  {
    GEOGetGeoCSSStyleSheetLog();
    unint64_t v147 = a6 = v281;
    if (os_log_type_enabled(v147, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 457;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read number of bits for property id.";
      _os_log_impl(&dword_1A1780000, v147, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    uint64_t v148 = (void *)std::ostream::operator<<();
    uint64_t v149 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v148, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v150 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v149, (uint64_t)"Could not read number of bits for property id.", 46);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v150, (uint64_t)"\n", 1);
    goto LABEL_104;
  }
  unsigned __int8 v294 = BYTE4(v310) + 1;
  geo::ibitstream::readUIntBits(&v310, v14, (BYTE4(v310) + 1));
  a6 = v281;
  if (!(_BYTE)v310)
  {
    long long v159 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 460;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read number of properties.";
      _os_log_impl(&dword_1A1780000, v159, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    unint64_t v160 = (void *)std::ostream::operator<<();
    unint64_t v161 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v160, (uint64_t)" STYL Parse Error Here: ", 24);
    long long v162 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v161, (uint64_t)"Could not read number of properties.", 36);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v162, (uint64_t)"\n", 1);
    goto LABEL_104;
  }
  int v274 = HIDWORD(v310);
  if (HIDWORD(v310))
  {
    int v128 = 0;
    while (1)
    {
      geo::ibitstream::readUIntBits(&v310, v14, v294);
      if (!(_BYTE)v310) {
        break;
      }
      unsigned int v129 = HIDWORD(v310);
      uint64_t v130 = *((unsigned __int8 *)v14 + 24);
      unint64_t v132 = v14[1];
      uint64_t v131 = v14[2];
      unint64_t v133 = v131 + ((unint64_t)(v130 + 2) >> 3);
      char v134 = (v130 + 2) & 7;
      unint64_t v135 = v131 + 1;
      if (v133 >= v131 + 1)
      {
        if (v130 <= 6) {
          unint64_t v138 = v131 + 1;
        }
        else {
          unint64_t v138 = v131 + 2;
        }
        if (v132 < v138)
        {
LABEL_250:
          v14[2] = v133;
          *((unsigned char *)v14 + 24) = v134;
LABEL_251:
          uint8x8_t v192 = GEOGetGeoCSSStyleSheetLog();
          if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 466;
            __int16 v314 = 2082;
            *(void *)int8x16_t v315 = "Could not read property size.";
            _os_log_impl(&dword_1A1780000, v192, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }

          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
          uint64_t v193 = (void *)std::ostream::operator<<();
          uint64_t v194 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v193, (uint64_t)" STYL Parse Error Here: ", 24);
          uint64_t v195 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v194, (uint64_t)"Could not read property size.", 29);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v195, (uint64_t)"\n", 1);
          goto LABEL_104;
        }
        uint64_t v139 = *v14;
        if (*((unsigned char *)v14 + 24))
        {
          if (v135 >= v132) {
            int v140 = 0;
          }
          else {
            int v140 = *(unsigned __int8 *)(v139 + v135);
          }
          unsigned int v137 = ((v140 & (0xFFFF << (8 - v130))) >> (8 - v130)) | ((((1 << (8 - v130)) + 255) & *(unsigned __int8 *)(v139 + v131)) << v130);
          v14[2] = v135;
        }
        else
        {
          LOBYTE(v137) = *(unsigned char *)(v139 + v131);
        }
      }
      else
      {
        if (*((unsigned char *)v14 + 24)) {
          unint64_t v136 = v131 + 1;
        }
        else {
          unint64_t v136 = v14[2];
        }
        if (v132 < v136) {
          goto LABEL_251;
        }
        if (*((unsigned char *)v14 + 24))
        {
          if (v132 < v135) {
            goto LABEL_250;
          }
          unsigned int v137 = (((1 << (8 - v130)) - 1) & *(unsigned __int8 *)(*v14 + v131)) << v130;
        }
        else
        {
          if (v132 < v135) {
            goto LABEL_250;
          }
          LOBYTE(v137) = *(unsigned char *)(*v14 + v131);
        }
      }
      v14[2] = v133;
      *((unsigned char *)v14 + 24) = v134;
      int v283 = v128;
      if ((v137 & 0x80) == 0)
      {
        geo::ibitstream::readVarInt((uint64_t)&v310, v14);
        if (!(_BYTE)v310)
        {
          float v201 = GEOGetGeoCSSStyleSheetLog();
          if (os_log_type_enabled(v201, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 470;
            __int16 v314 = 2082;
            *(void *)int8x16_t v315 = "Could not read property size.";
            _os_log_impl(&dword_1A1780000, v201, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }

          a6 = v281;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
          int v202 = (void *)std::ostream::operator<<();
          unint64_t v203 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v202, (uint64_t)" STYL Parse Error Here: ", 24);
          int v204 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v203, (uint64_t)"Could not read property size.", 29);
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v204, (uint64_t)"\n", 1);
          goto LABEL_104;
        }
        int v276 = v311;
      }
      unsigned __int8 v279 = v137;
      unint64_t v141 = v296;
      uint64_t v142 = &v296;
      long long v143 = &v296;
      if (v296)
      {
        while (1)
        {
          while (1)
          {
            long long v143 = (uint64_t **)v141;
            unsigned int v144 = *((_DWORD *)v141 + 7);
            if (v129 >= v144) {
              break;
            }
            unint64_t v141 = *v143;
            uint64_t v142 = v143;
            if (!*v143) {
              goto LABEL_213;
            }
          }
          if (v144 >= v129) {
            break;
          }
          unint64_t v141 = v143[1];
          if (!v141)
          {
            uint64_t v142 = v143 + 1;
            goto LABEL_213;
          }
        }
        uint64_t v145 = (uint64_t)v143;
      }
      else
      {
LABEL_213:
        uint64_t v145 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v297 + 16))(v297, 40, 8);
        *(_DWORD *)(v145 + 28) = v129;
        *(void *)(v145 + 32) = 0;
        *(void *)uint64_t v145 = 0;
        *(void *)(v145 + 8) = 0;
        *(void *)(v145 + 16) = v143;
        *uint64_t v142 = (uint64_t *)v145;
        unint64_t v146 = (uint64_t *)v145;
        if (*v295)
        {
          int v295 = (uint64_t **)*v295;
          unint64_t v146 = *v142;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v296, v146);
        ++v298;
      }
      a6 = v281;
      *(unsigned char *)(v145 + 32) = v279 >> 6;
      *(_DWORD *)(v145 + 36) = v276;
      int v128 = v283 + 1;
      if (v283 + 1 == v274) {
        goto LABEL_229;
      }
    }
    uint64_t v188 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 463;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read property id.";
      _os_log_impl(&dword_1A1780000, v188, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    a6 = v281;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    size_t v189 = (void *)std::ostream::operator<<();
    uint64_t v190 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v189, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v191 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v190, (uint64_t)"Could not read property id.", 27);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v191, (uint64_t)"\n", 1);
    goto LABEL_104;
  }
LABEL_229:
  uint64_t v163 = (geo::ibitstream *)gss::StylFile::chapter(&v300, 0xAu);
  uint64_t v164 = (char *)operator new(0x168uLL);
  *((void *)v164 + 1) = 0;
  *((void *)v164 + 2) = 0;
  *(void *)uint64_t v164 = &unk_1EF58A6D0;
  *(_OWORD *)(v164 + 40) = 0u;
  *(_OWORD *)(v164 + 56) = 0u;
  *(_OWORD *)(v164 + 72) = 0u;
  *(_OWORD *)(v164 + 88) = 0u;
  *(_OWORD *)(v164 + 104) = 0u;
  *(_OWORD *)(v164 + 120) = 0u;
  *(_OWORD *)(v164 + 136) = 0u;
  *(_OWORD *)(v164 + 152) = 0u;
  *(_OWORD *)(v164 + 168) = 0u;
  *(_OWORD *)(v164 + 184) = 0u;
  *(_OWORD *)(v164 + 200) = 0u;
  *(_OWORD *)(v164 + 216) = 0u;
  *(_OWORD *)(v164 + 232) = 0u;
  *(_OWORD *)(v164 + 248) = 0u;
  *(_OWORD *)(v164 + 24) = 0u;
  *(_OWORD *)(v164 + 264) = 0u;
  *(_OWORD *)(v164 + 280) = 0u;
  *(_OWORD *)(v164 + 296) = 0u;
  *(_OWORD *)(v164 + 312) = 0u;
  *((_DWORD *)v164 + 29) = 1065353216;
  __asm { FMOV            V0.4S, #1.0 }
  *(void *)(v164 + 108) = _Q0;
  __asm { FMOV            V0.2S, #1.0 }
  *((void *)v164 + 28) = _Q0;
  *(void *)(v164 + 236) = 0xBF8000003F800000;
  *(_OWORD *)(v164 + 284) = xmmword_1A28FE190;
  *(_OWORD *)(v164 + 300) = xmmword_1A28FE1A0;
  *((_DWORD *)v164 + 79) = 1096810496;
  *(_OWORD *)(v164 + 328) = xmmword_1A28FE1B0;
  *(_OWORD *)(v164 + 344) = xmmword_1A28FE1C0;
  long long v170 = *(std::__shared_weak_count **)(a1 + 128);
  *(void *)(a1 + 120) = v164 + 24;
  *(void *)(a1 + 128) = v164;
  if (v170 && !atomic_fetch_add(&v170->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v170->__on_zero_shared)(v170);
    std::__shared_weak_count::__release_weak(v170);
  }
  if ((gss::GlobalProperties::loadFromStylChapterBitstream(*(void *)(a1 + 120), v163, (uint64_t)&v285, a7) & 1) == 0)
  {
    float32x4_t v182 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 488;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not decode global properties.";
      _os_log_impl(&dword_1A1780000, v182, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    uint64_t v183 = (void *)std::ostream::operator<<();
    uint64_t v184 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v183, (uint64_t)" STYL Parse Error Here: ", 24);
    size_t v185 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v184, (uint64_t)"Could not decode global properties.", 35);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v185, (uint64_t)"\n", 1);
    size_t v186 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v186, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 388;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not decode global properties.";
      _os_log_impl(&dword_1A1780000, v186, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    size_t v187 = (void *)std::ostream::operator<<();
    uint64_t v26 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v187, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v27 = "Could not decode global properties.";
    uint64_t v28 = 35;
    goto LABEL_107;
  }
  buf[0] = 1;
  uint64_t v171 = *(void *)(a5 + 24);
  if (!v171) {
    goto LABEL_350;
  }
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v171 + 48))(v171, buf);
  float v172 = gss::StylFile::chapter(&v300, 0x14u);
  int v173 = v172;
  uint64_t v174 = *((unsigned __int8 *)v172 + 24);
  unint64_t v176 = v172[1];
  uint64_t v175 = v172[2];
  unint64_t v177 = v175 + ((unint64_t)(v174 + 5) >> 3);
  char v178 = (v174 + 5) & 7;
  unint64_t v179 = v175 + 1;
  if (v177 < v175 + 1)
  {
    if (*((unsigned char *)v172 + 24)) {
      unint64_t v180 = v175 + 1;
    }
    else {
      unint64_t v180 = v172[2];
    }
    if (v176 < v180) {
      goto LABEL_259;
    }
    if (*((unsigned char *)v172 + 24))
    {
      if (v176 >= v179)
      {
        unsigned int v181 = (((1 << (8 - v174)) - 1) & *(unsigned __int8 *)(*v172 + v175)) << v174;
        goto LABEL_273;
      }
      goto LABEL_258;
    }
    if (v176 >= v179)
    {
      LOBYTE(v181) = *(unsigned char *)(*v172 + v175);
      goto LABEL_273;
    }
LABEL_258:
    v172[2] = v177;
    *((unsigned char *)v172 + 24) = v178;
LABEL_259:
    uint64_t v197 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v197, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 500;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read number of bits for property set index.";
      _os_log_impl(&dword_1A1780000, v197, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    a6 = v281;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    float v198 = (void *)std::ostream::operator<<();
    unint64_t v199 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v198, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v200 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v199, (uint64_t)"Could not read number of bits for property set index.", 53);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v200, (uint64_t)"\n", 1);
    goto LABEL_339;
  }
  if (v174 <= 3) {
    unint64_t v196 = v175 + 1;
  }
  else {
    unint64_t v196 = v175 + 2;
  }
  if (v176 < v196) {
    goto LABEL_258;
  }
  uint64_t v205 = *v172;
  if (*((unsigned char *)v172 + 24))
  {
    int v206 = *(unsigned __int8 *)(v205 + v175);
    if (v179 >= v176) {
      int v207 = 0;
    }
    else {
      int v207 = *(unsigned __int8 *)(v205 + v179);
    }
    unsigned int v181 = ((v207 & (0xFFFF << (8 - v174))) >> (8 - v174)) | ((((1 << (8 - v174)) + 255) & v206) << v174);
    v172[2] = v179;
  }
  else
  {
    LOBYTE(v181) = *(unsigned char *)(v205 + v175);
  }
LABEL_273:
  int v208 = v181 >> 3;
  v172[2] = v177;
  *((unsigned char *)v172 + 24) = v178;
  char v299 = v208 + 1;
  std::string::size_type v209 = (gss::Allocator *)geo::ibitstream::readUIntBits(&v310, v172, v208 + 1);
  if ((_BYTE)v310)
  {
    uint64_t v210 = HIDWORD(v310);
    int64x2_t v275 = (void *)(a1 + 144);
    uint64_t v272 = HIDWORD(v310);
    if (HIWORD(v310) || *(unsigned char *)(a1 + 156) || HIDWORD(v310) <= *(unsigned __int16 *)(a1 + 154))
    {
      if (HIDWORD(v310))
      {
        uint64_t v277 = 0;
        goto LABEL_282;
      }
LABEL_318:
      if (gss::StyleSheet<gss::PropertyID>::decodeStyles(a1, &v300, (uint64_t)&v285, v273, a7))
      {
        gss::StylFile::chapter(&v300, 0x1Eu);
        operator new();
      }
      float v245 = GEOGetGeoCSSStyleSheetLog();
      if (os_log_type_enabled(v245, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 392;
        __int16 v314 = 2082;
        *(void *)int8x16_t v315 = "Could not decode styles.";
        _os_log_impl(&dword_1A1780000, v245, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }

      a6 = v281;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
      uint64_t v246 = (void *)std::ostream::operator<<();
      uint64_t v247 = 24;
      uint64_t v248 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v246, (uint64_t)" STYL Parse Error Here: ", 24);
      long long v249 = "Could not decode styles.";
      goto LABEL_342;
    }
    uint64_t v211 = gss::Allocator::instance(v209);
    std::string::size_type v209 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v211 + 16))(v211, 16 * v210, 8);
    int v212 = v209;
    if (*v275) {
      std::string::size_type v209 = (gss::Allocator *)geo::intern_vector<std::shared_ptr<gss::ConditionalStyle<gss::PropertyID>>,geo::StdAllocator<std::shared_ptr<gss::ConditionalStyle<gss::PropertyID>>,gss::Allocator>>::moveContent((uint64_t)v275, v209);
    }
    *(_WORD *)(a1 + 154) = v272;
    *(void *)(a1 + 144) = v212;
    uint64_t v277 = 0;
    while (1)
    {
LABEL_282:
      uint64_t v213 = gss::Allocator::instance(v209);
      uint64_t v214 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v213 + 16))(v213, 112, 8);
      uint64_t v215 = v214;
      *(void *)uint64_t v214 = &unk_1EF58A708;
      *(void *)(v214 + 8) = 0;
      *(void *)(v214 + 16) = 0;
      *(void *)(v214 + 24) = v213;
      *(void *)(v214 + 32) = 0;
      uint64_t v216 = v214 + 32;
      *(void *)(v214 + 40) = 0;
      *(void *)(v214 + 48) = 0;
      *(unsigned char *)(v214 + 47) = 1;
      *(void *)(v214 + 55) = 0;
      *(unsigned char *)(v214 + 63) = 1;
      *(void *)(v214 + 64) = 0;
      *(void *)(v214 + 71) = 0;
      *(unsigned char *)(v214 + 79) = 1;
      *(void *)(v214 + 80) = 0;
      *(void *)(v214 + 87) = 0;
      *(unsigned char *)(v214 + 95) = 1;
      *(void *)(v214 + 96) = 0;
      *(void *)(v214 + 103) = 0;
      *(unsigned char *)(v214 + 111) = 1;
      *(void *)float buf = v214 + 32;
      *(void *)&uint8_t buf[8] = v214;
      uint64_t v217 = *(unsigned __int16 *)(a1 + 152);
      if (v217 != 0xFFFF && !*(unsigned char *)(a1 + 156) && v217 >= *(unsigned __int16 *)(a1 + 154))
      {
        uint64_t v218 = v217 + 1;
        uint64_t v219 = gss::Allocator::instance((gss::Allocator *)v214);
        unint64_t v220 = (_OWORD *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v219 + 16))(v219, 16 * v218, 8);
        if (*v275) {
          geo::intern_vector<std::shared_ptr<gss::ConditionalStyle<gss::PropertyID>>,geo::StdAllocator<std::shared_ptr<gss::ConditionalStyle<gss::PropertyID>>,gss::Allocator>>::moveContent((uint64_t)v275, v220);
        }
        *(_WORD *)(a1 + 154) = v218;
        *(void *)(a1 + 144) = v220;
        uint64_t v217 = *(unsigned __int16 *)(a1 + 152);
      }
      uint64_t v221 = *(void *)(a1 + 144);
      std::string::size_type v222 = (uint64_t *)(v221 + 16 * v217);
      *std::string::size_type v222 = v216;
      v222[1] = v215;
      *(_WORD *)(a1 + 152) = v217 + 1;
      uint64_t v284 = *(void *)(v221 + 16 * v277);
      geo::ibitstream::readUIntBits(&v310, v173, v294);
      if (!(_BYTE)v310)
      {
        uint64_t v264 = GEOGetGeoCSSStyleSheetLog();
        if (os_log_type_enabled(v264, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 136315650;
          *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 223;
          __int16 v314 = 2082;
          *(void *)int8x16_t v315 = "Could not read number of properties.";
          _os_log_impl(&dword_1A1780000, v264, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
        }

        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp", 86);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
        uint64_t v265 = (void *)std::ostream::operator<<();
        uint64_t v266 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v265, (uint64_t)" STYL Parse Error Here: ", 24);
        int v267 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v266, (uint64_t)"Could not read number of properties.", 36);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v267, (uint64_t)"\n", 1);
        goto LABEL_336;
      }
      int v280 = HIDWORD(v310);
      if (HIDWORD(v310)) {
        break;
      }
LABEL_317:
      std::string::size_type v209 = (gss::Allocator *)gss::StylePropertySet<gss::PropertyID>::intern(v284, v285 + 232);
      if (++v277 == v272) {
        goto LABEL_318;
      }
    }
    int v223 = 0;
    while (1)
    {
      geo::ibitstream::readUIntBits(&v310, v173, v294);
      if (!(_BYTE)v310)
      {
        float v250 = GEOGetGeoCSSStyleSheetLog();
        if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 136315650;
          *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 226;
          __int16 v314 = 2082;
          *(void *)int8x16_t v315 = "Could not read property index.";
          _os_log_impl(&dword_1A1780000, v250, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
        }

        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp", 86);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
        uint64_t v251 = (void *)std::ostream::operator<<();
        uint64_t v252 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v251, (uint64_t)" STYL Parse Error Here: ", 24);
        unsigned __int8 v253 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v252, (uint64_t)"Could not read property index.", 30);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v253, (uint64_t)"\n", 1);
        goto LABEL_336;
      }
      int v224 = v296;
      if (!v296) {
        break;
      }
      unsigned __int16 v225 = WORD2(v310);
      int v226 = &v296;
      do
      {
        unint64_t v227 = v224;
        uint8x8_t v228 = v226;
        unsigned int v229 = *((_DWORD *)v224 + 7);
        uint64_t v230 = (uint64_t **)(v224 + 1);
        if (v229 >= HIDWORD(v310))
        {
          uint64_t v230 = (uint64_t **)v227;
          int v226 = (uint64_t **)v227;
        }
        int v224 = *v230;
      }
      while (v224);
      if (v226 == &v296) {
        break;
      }
      uint64_t v231 = v229 >= HIDWORD(v310) ? v227 : (uint64_t *)v228;
      if (HIDWORD(v310) < *((_DWORD *)v231 + 7)) {
        break;
      }
      if (v229 < HIDWORD(v310)) {
        unint64_t v227 = (uint64_t *)v228;
      }
      uint64_t v232 = *((unsigned int *)v227 + 9);
      switch(*((unsigned char *)v227 + 32))
      {
        case 0:
          goto LABEL_310;
        case 1:
          uint64_t v232 = (8 * v232);
          goto LABEL_310;
        case 2:
          uint64_t v232 = 1;
          goto LABEL_310;
        case 3:
          geo::ibitstream::readVarInt((uint64_t)&v310, v173);
          if (!(_BYTE)v310)
          {
            int v268 = GEOGetGeoCSSStyleSheetLog();
            if (os_log_type_enabled(v268, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 242;
              __int16 v314 = 2082;
              *(void *)int8x16_t v315 = "Could not read size of variable sized property.";
              _os_log_impl(&dword_1A1780000, v268, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }

            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp", 86);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
            unsigned int v269 = (void *)std::ostream::operator<<();
            unint64_t v270 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v269, (uint64_t)" STYL Parse Error Here: ", 24);
            unsigned int v271 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v270, (uint64_t)"Could not read size of variable sized property.", 47);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v271, (uint64_t)"\n", 1);
            goto LABEL_336;
          }
          uint64_t v232 = 8 * v311;
LABEL_310:
          uint64_t v233 = v173[2];
          uint64_t v234 = *((unsigned __int8 *)v173 + 24);
          gss::propertyDecoderForIndex<gss::PropertyID>(v225, buf);
          uint64_t v310 = v232;
          unsigned __int16 v312 = v225;
          if (!*(void *)&v315[4]) {
            goto LABEL_350;
          }
          char v235 = (*(uint64_t (**)(void, uint64_t *, uint64_t, uint64_t *, unsigned __int16 *, uint64_t *, void *))(**(void **)&v315[4] + 48))(*(void *)&v315[4], v173, v284, &v310, &v312, &v285, a7);
          if (*(unsigned char **)&v315[4] == buf)
          {
            (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
          }
          else if (*(void *)&v315[4])
          {
            (*(void (**)(void))(**(void **)&v315[4] + 40))();
          }
          if ((v235 & 1) == 0)
          {
            uint64_t v254 = GEOGetGeoCSSStyleSheetLog();
            if (os_log_type_enabled(v254, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 247;
              __int16 v314 = 2082;
              *(void *)int8x16_t v315 = "Could not decode property";
              _os_log_impl(&dword_1A1780000, v254, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }

            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp", 86);
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
            uint64_t v255 = (void *)std::ostream::operator<<();
            double v256 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v255, (uint64_t)" STYL Parse Error Here: ", 24);
            unint64_t v244 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v256, (uint64_t)"Could not decode property", 25);
            goto LABEL_335;
          }
          unint64_t v236 = 8 * v233 + v232 + v234;
          v173[2] = v236 >> 3;
          *((unsigned char *)v173 + 24) = v236 & 7;
          if (++v223 == v280) {
            goto LABEL_317;
          }
          break;
        default:
          uint64_t v232 = 0;
          goto LABEL_310;
      }
    }
    std::string::size_type v241 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v241, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 228;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not find size for property.";
      _os_log_impl(&dword_1A1780000, v241, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.hpp", 86);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    __int32 v242 = (void *)std::ostream::operator<<();
    int32x2_t v243 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v242, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v244 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v243, (uint64_t)"Could not find size for property.", 33);
LABEL_335:
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v244, (uint64_t)"\n", 1);
LABEL_336:
    double v257 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v257, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 507;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not decode property set.";
      _os_log_impl(&dword_1A1780000, v257, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    a6 = v281;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    double v258 = (void *)std::ostream::operator<<();
    double v259 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v258, (uint64_t)" STYL Parse Error Here: ", 24);
    double v260 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v259, (uint64_t)"Could not decode property set.", 30);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v260, (uint64_t)"\n", 1);
  }
  else
  {
    float v237 = GEOGetGeoCSSStyleSheetLog();
    if (os_log_type_enabled(v237, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 503;
      __int16 v314 = 2082;
      *(void *)int8x16_t v315 = "Could not read number of property sets.";
      _os_log_impl(&dword_1A1780000, v237, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }

    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
    size_t v238 = (void *)std::ostream::operator<<();
    float v239 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v238, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v240 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v239, (uint64_t)"Could not read number of property sets.", 39);
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v240, (uint64_t)"\n", 1);
    a6 = v281;
  }
LABEL_339:
  unint64_t v261 = GEOGetGeoCSSStyleSheetLog();
  if (os_log_type_enabled(v261, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float buf = 136315650;
    *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 391;
    __int16 v314 = 2082;
    *(void *)int8x16_t v315 = "Could not decode property sets.";
    _os_log_impl(&dword_1A1780000, v261, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
  }

  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StyleSheet.hpp", 80);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(a7, (uint64_t)":", 1);
  uint64_t v262 = (void *)std::ostream::operator<<();
  uint64_t v248 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v262, (uint64_t)" STYL Parse Error Here: ", 24);
  long long v249 = "Could not decode property sets.";
  uint64_t v247 = 31;
LABEL_342:
  float v263 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v248, (uint64_t)v249, v247);
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v263, (uint64_t)"\n", 1);
LABEL_109:
  buf[0] = 0;
  uint64_t v90 = *(void *)(a6 + 24);
  if (v90)
  {
    (*(void (**)(uint64_t, unsigned char *))(*(void *)v90 + 48))(v90, buf);
    std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&v295, v296);
    std::__tree<std::__value_type<unsigned int,gss::PropertySize>,std::__map_value_compare<unsigned int,std::__value_type<unsigned int,gss::PropertySize>,std::less<unsigned int>,true>,geo::StdAllocator<std::__value_type<unsigned int,gss::PropertySize>,gss::Allocator>>::destroy((uint64_t)&v290, v291);
    std::__tree<std::__value_type<gss::StylFile::ChapterId,gss::StylChapter>,std::__map_value_compare<gss::StylFile::ChapterId,std::__value_type<gss::StylFile::ChapterId,gss::StylChapter>,std::less<gss::StylFile::ChapterId>,true>,geo::StdAllocator<std::__value_type<gss::StylFile::ChapterId,gss::StylChapter>,gss::Allocator>>::destroy((uint64_t)&v304, v305);
    std::__tree<std::__value_type<gss::StylFile::ChapterId,gss::StylFile::ChapterDescriptor>,std::__map_value_compare<gss::StylFile::ChapterId,std::__value_type<gss::StylFile::ChapterId,gss::StylFile::ChapterDescriptor>,std::less<gss::StylFile::ChapterId>,true>,geo::StdAllocator<std::__value_type<gss::StylFile::ChapterId,gss::StylFile::ChapterDescriptor>,gss::Allocator>>::destroy((uint64_t)&v300, v301);
  }
  else
  {
LABEL_350:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
}

void sub_1A181C754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

uint64_t std::__function::__func<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &),std::allocator<BOOL (*)(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &)>,BOOL ()(geo::ibitstream &,gss::StylePropertySet<gss::PropertyID> &,unsigned long long,gss::StylePropertyIndex,gss::DecodingContext const&,std::ostringstream &)>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, unsigned __int16 *a5, uint64_t a6, uint64_t a7)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t))(a1 + 8))(a2, a3, *a4, *a5, a6, a7);
}

uint64_t gss::propertyDecoderForIndex<gss::PropertyID>@<X0>(uint64_t result@<X0>, void *a2@<X8>)
{
  if (result > 0x1CE) {
    unint64_t v2 = gss::unknownPropertyDecoder<gss::PropertyID>;
  }
  else {
    unint64_t v2 = *(&off_1EF591620 + (__int16)result);
  }
  *a2 = &unk_1EF56BB18;
  a2[1] = v2;
  a2[3] = a2;
  return result;
}

uint64_t gss::floatDecoder<gss::PropertyID>(uint64_t *a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v33 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 32)
  {
    *(_DWORD *)float buf = 0;
    unint64_t v12 = a1[1];
    uint64_t v13 = a1[2];
    char v14 = *((unsigned char *)a1 + 24);
    unint64_t v15 = v13 + 5;
    if (!v14) {
      unint64_t v15 = v13 + 4;
    }
    if (v12 >= v15)
    {
      uint64_t v26 = *a1;
      if (*((unsigned char *)a1 + 24))
      {
        uint64_t v27 = 0;
        uint64_t v28 = v26 + v13;
        uint64_t v29 = v13 + 1;
        do
        {
          if (v29 + v27 >= v12) {
            int v30 = 0;
          }
          else {
            int v30 = *(unsigned __int8 *)(v28 + v27 + 1);
          }
          unsigned int v31 = ((v30 & (0xFFFF << (8 - v14))) >> (8 - v14)) | ((((1 << (8 - v14)) + 255) & *(unsigned __int8 *)(v28 + v27)) << v14);
          a1[2] = v29 + v27;
          buf[v27++] = v31;
        }
        while (v27 != 4);
        int v32 = *(_DWORD *)buf;
      }
      else
      {
        int v32 = *(_DWORD *)(v26 + v13);
        a1[2] = v13 + 4;
      }
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v35);
      *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, &v33) = v32;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    char v16 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      unint64_t v35 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v36 = 1024;
      int v37 = 249;
      __int16 v38 = 2082;
      int v39 = "Could not read float.";
      _os_log_impl(&dword_1A1780000, v16, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)":", 1);
    uint64_t v18 = (void *)std::ostream::operator<<();
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned int v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Could not read float.", 21);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v21 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      unint64_t v35 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v36 = 1024;
      int v37 = 248;
      __int16 v38 = 2082;
      int v39 = "Found float with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)":", 1);
    unsigned int v23 = (void *)std::ostream::operator<<();
    char v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"Found float with strange number of bits.", 40);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::labelInfoDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5, void *a6)
{
  uint64_t v133 = *MEMORY[0x1E4F143B8];
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)v125);
  if (!LOBYTE(v125[0]))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v19 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v129 = 1024;
      int v130 = 948;
      __int16 v131 = 2082;
      unint64_t v132 = "Could not read indication of label height existing.";
      _os_log_impl(&dword_1A1780000, v19, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unsigned int v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)":", 1);
    unint64_t v21 = (void *)std::ostream::operator<<();
    unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned int v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"Could not read indication of label height existing.", 51);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"\n", 1);
    return 0;
  }
  if (v126)
  {
    *(_DWORD *)float buf = 0;
    unint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = *(void *)(a1 + 16);
    char v12 = *(unsigned char *)(a1 + 24);
    unint64_t v13 = v11 + 5;
    if (!v12) {
      unint64_t v13 = v11 + 4;
    }
    if (v10 < v13)
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      char v14 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        __int16 v129 = 1024;
        int v130 = 951;
        __int16 v131 = 2082;
        unint64_t v132 = "Could not read label height.";
        _os_log_impl(&dword_1A1780000, v14, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      unint64_t v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)":", 1);
      char v16 = (void *)std::ostream::operator<<();
      unint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)" STYL Parse Error Here: ", 24);
      uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)"Could not read label height.", 28);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"\n", 1);
      return 0;
    }
    uint64_t v24 = *(void *)a1;
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v25 = 0;
      uint64_t v26 = v24 + v11;
      uint64_t v27 = v11 + 1;
      do
      {
        if (v27 + v25 >= v10) {
          int v28 = 0;
        }
        else {
          int v28 = *(unsigned __int8 *)(v26 + v25 + 1);
        }
        unsigned int v29 = ((v28 & (0xFFFF << (8 - v12))) >> (8 - v12)) | ((((1 << (8 - v12)) + 255) & *(unsigned __int8 *)(v26 + v25)) << v12);
        *(void *)(a1 + 16) = v27 + v25;
        buf[v25++] = v29;
      }
      while (v25 != 4);
      int v30 = *(_DWORD *)buf;
    }
    else
    {
      int v30 = *(_DWORD *)(v24 + v11);
      *(void *)(a1 + 16) = v11 + 4;
    }
    if ((a4 - 171) > 4) {
      unsigned __int16 v31 = 482;
    }
    else {
      unsigned __int16 v31 = word_1A29CD390[(__int16)(a4 - 171)];
    }
    v125[0] = v31;
    *(_WORD *)float buf = v31;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v128);
    *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, v125) = v30;
  }
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)v125);
  if (!LOBYTE(v125[0]))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unsigned __int16 v33 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v129 = 1024;
      int v130 = 956;
      __int16 v131 = 2082;
      unint64_t v132 = "Could not read indication of label height curve existing.";
      _os_log_impl(&dword_1A1780000, v33, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v34 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)":", 1);
    unint64_t v35 = (void *)std::ostream::operator<<();
    __int16 v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)" STYL Parse Error Here: ", 24);
    int v37 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)"Could not read indication of label height curve existing.", 57);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v37, (uint64_t)"\n", 1);
    return 0;
  }
  if (v126)
  {
    geo::ibitstream::readUIntBits(a1, 3u, (uint64_t)v125);
    if (!LOBYTE(v125[0]))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      __int16 v38 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        __int16 v129 = 1024;
        int v130 = 959;
        __int16 v131 = 2082;
        unint64_t v132 = "Could not read label height curve.";
        _os_log_impl(&dword_1A1780000, v38, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      int v39 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)":", 1);
      uint64_t v40 = (void *)std::ostream::operator<<();
      unint64_t v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v40, (uint64_t)" STYL Parse Error Here: ", 24);
      unsigned int v42 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)"Could not read label height curve.", 34);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)"\n", 1);
      return 0;
    }
    if ((a4 - 171) > 4) {
      unsigned __int16 v32 = 482;
    }
    else {
      unsigned __int16 v32 = word_1A29CD39A[(__int16)(a4 - 171)];
    }
    int v43 = v126;
    v125[0] = v32;
    *(_WORD *)float buf = v32;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v128);
    *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, v125) = v43;
  }
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)v125);
  if (!LOBYTE(v125[0]))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v53 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v129 = 1024;
      int v130 = 964;
      __int16 v131 = 2082;
      unint64_t v132 = "Could not read indication of label height curve limit existing.";
      _os_log_impl(&dword_1A1780000, v53, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v54 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v54, (uint64_t)":", 1);
    int v55 = (void *)std::ostream::operator<<();
    uint64_t v56 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)"Could not read indication of label height curve limit existing.", 63);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"\n", 1);
    return 0;
  }
  if (v126)
  {
    *(_DWORD *)float buf = 0;
    unint64_t v44 = *(void *)(a1 + 8);
    uint64_t v45 = *(void *)(a1 + 16);
    char v46 = *(unsigned char *)(a1 + 24);
    unint64_t v47 = v45 + 5;
    if (!v46) {
      unint64_t v47 = v45 + 4;
    }
    if (v44 < v47)
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      unsigned int v48 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        __int16 v129 = 1024;
        int v130 = 967;
        __int16 v131 = 2082;
        unint64_t v132 = "Could not read label height curve limit.";
        _os_log_impl(&dword_1A1780000, v48, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      int v49 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v49, (uint64_t)":", 1);
      int v50 = (void *)std::ostream::operator<<();
      unint64_t v51 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)" STYL Parse Error Here: ", 24);
      int v52 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v51, (uint64_t)"Could not read label height curve limit.", 40);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v52, (uint64_t)"\n", 1);
      return 0;
    }
    uint64_t v58 = *(void *)a1;
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v59 = 0;
      uint64_t v60 = v58 + v45;
      uint64_t v61 = v45 + 1;
      do
      {
        if (v61 + v59 >= v44) {
          int v62 = 0;
        }
        else {
          int v62 = *(unsigned __int8 *)(v60 + v59 + 1);
        }
        unsigned int v63 = ((v62 & (0xFFFF << (8 - v46))) >> (8 - v46)) | ((((1 << (8 - v46)) + 255) & *(unsigned __int8 *)(v60 + v59)) << v46);
        *(void *)(a1 + 16) = v61 + v59;
        buf[v59++] = v63;
      }
      while (v59 != 4);
      int v64 = *(_DWORD *)buf;
    }
    else
    {
      int v64 = *(_DWORD *)(v58 + v45);
      *(void *)(a1 + 16) = v45 + 4;
    }
    if ((a4 - 171) > 4) {
      unsigned __int16 v65 = 482;
    }
    else {
      unsigned __int16 v65 = word_1A29CD3A4[(__int16)(a4 - 171)];
    }
    v125[0] = v65;
    *(_WORD *)float buf = v65;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v128);
    *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, v125) = v64;
  }
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)v125);
  if (!LOBYTE(v125[0]))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v75 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v129 = 1024;
      int v130 = 972;
      __int16 v131 = 2082;
      unint64_t v132 = "Could not read indication of label halo size existing.";
      _os_log_impl(&dword_1A1780000, v75, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unsigned int v76 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v76, (uint64_t)":", 1);
    unint64_t v77 = (void *)std::ostream::operator<<();
    unsigned int v78 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v77, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v79 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v78, (uint64_t)"Could not read indication of label halo size existing.", 54);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v79, (uint64_t)"\n", 1);
    return 0;
  }
  if (v126)
  {
    *(_DWORD *)float buf = 0;
    unint64_t v66 = *(void *)(a1 + 8);
    uint64_t v67 = *(void *)(a1 + 16);
    char v68 = *(unsigned char *)(a1 + 24);
    unint64_t v69 = v67 + 5;
    if (!v68) {
      unint64_t v69 = v67 + 4;
    }
    if (v66 < v69)
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      unsigned int v70 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        __int16 v129 = 1024;
        int v130 = 975;
        __int16 v131 = 2082;
        unint64_t v132 = "Could not read label halo size.";
        _os_log_impl(&dword_1A1780000, v70, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      unsigned int v71 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v71, (uint64_t)":", 1);
      unsigned int v72 = (void *)std::ostream::operator<<();
      int v73 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v72, (uint64_t)" STYL Parse Error Here: ", 24);
      int v74 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)"Could not read label halo size.", 31);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v74, (uint64_t)"\n", 1);
      return 0;
    }
    uint64_t v80 = *(void *)a1;
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v81 = 0;
      uint64_t v82 = v80 + v67;
      uint64_t v83 = v67 + 1;
      do
      {
        if (v83 + v81 >= v66) {
          int v84 = 0;
        }
        else {
          int v84 = *(unsigned __int8 *)(v82 + v81 + 1);
        }
        unsigned int v85 = ((v84 & (0xFFFF << (8 - v68))) >> (8 - v68)) | ((((1 << (8 - v68)) + 255) & *(unsigned __int8 *)(v82 + v81)) << v68);
        *(void *)(a1 + 16) = v83 + v81;
        buf[v81++] = v85;
      }
      while (v81 != 4);
      int v86 = *(_DWORD *)buf;
    }
    else
    {
      int v86 = *(_DWORD *)(v80 + v67);
      *(void *)(a1 + 16) = v67 + 4;
    }
    if ((a4 - 171) > 4) {
      unsigned __int16 v87 = 482;
    }
    else {
      unsigned __int16 v87 = word_1A29CD3AE[(__int16)(a4 - 171)];
    }
    v125[0] = v87;
    *(_WORD *)float buf = v87;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v128);
    *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, v125) = v86;
  }
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)v125);
  if (!LOBYTE(v125[0]))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    uint64_t v89 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v129 = 1024;
      int v130 = 980;
      __int16 v131 = 2082;
      unint64_t v132 = "Could not read indication of label font expansion existing.";
      _os_log_impl(&dword_1A1780000, v89, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v90 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v90, (uint64_t)":", 1);
    size_t v91 = (void *)std::ostream::operator<<();
    uint64_t v92 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v91, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v93 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v92, (uint64_t)"Could not read indication of label font expansion existing.", 59);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v93, (uint64_t)"\n", 1);
    return 0;
  }
  if (v126)
  {
    geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)v125);
    if (!LOBYTE(v125[0]))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      unint64_t v94 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        __int16 v129 = 1024;
        int v130 = 983;
        __int16 v131 = 2082;
        unint64_t v132 = "Could not read label font expansion.";
        _os_log_impl(&dword_1A1780000, v94, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      int v95 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v95, (uint64_t)":", 1);
      unint64_t v96 = (void *)std::ostream::operator<<();
      char v97 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v96, (uint64_t)" STYL Parse Error Here: ", 24);
      unint64_t v98 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v97, (uint64_t)"Could not read label font expansion.", 36);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v98, (uint64_t)"\n", 1);
      return 0;
    }
    if ((a4 - 171) > 4) {
      unsigned __int16 v88 = 482;
    }
    else {
      unsigned __int16 v88 = word_1A29CD3B8[(__int16)(a4 - 171)];
    }
    int v99 = v126;
    v125[0] = v88;
    *(_WORD *)float buf = v88;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v128);
    *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, v125) = v99;
  }
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)v125);
  if (!LOBYTE(v125[0]))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v101 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v129 = 1024;
      int v130 = 988;
      __int16 v131 = 2082;
      unint64_t v132 = "Could not read indication of label spacing existing.";
      _os_log_impl(&dword_1A1780000, v101, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    float v102 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v102, (uint64_t)":", 1);
    BOOL v103 = (void *)std::ostream::operator<<();
    unint64_t v104 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v103, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v105 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v104, (uint64_t)"Could not read indication of label spacing existing.", 52);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v105, (uint64_t)"\n", 1);
    return 0;
  }
  if (v126)
  {
    geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)v125);
    if (!LOBYTE(v125[0]))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      char v106 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        __int16 v129 = 1024;
        int v130 = 991;
        __int16 v131 = 2082;
        unint64_t v132 = "Could not read label spacing.";
        _os_log_impl(&dword_1A1780000, v106, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      int v107 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v107, (uint64_t)":", 1);
      int v108 = (void *)std::ostream::operator<<();
      unsigned __int16 v109 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v108, (uint64_t)" STYL Parse Error Here: ", 24);
      int v110 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v109, (uint64_t)"Could not read label spacing.", 29);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v110, (uint64_t)"\n", 1);
      return 0;
    }
    if ((a4 - 171) > 4) {
      unsigned __int16 v100 = 482;
    }
    else {
      unsigned __int16 v100 = word_1A29CD3C2[(__int16)(a4 - 171)];
    }
    int v111 = v126;
    v125[0] = v100;
    *(_WORD *)float buf = v100;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v128);
    *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, v125) = v111;
  }
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)v125);
  if (!LOBYTE(v125[0]))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v113 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v129 = 1024;
      int v130 = 996;
      __int16 v131 = 2082;
      unint64_t v132 = "Could not read indication of arrow height existing.";
      _os_log_impl(&dword_1A1780000, v113, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v114 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v114, (uint64_t)":", 1);
    char v115 = (void *)std::ostream::operator<<();
    unint64_t v116 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v115, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v117 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v116, (uint64_t)"Could not read indication of arrow height existing.", 51);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v117, (uint64_t)"\n", 1);
    return 0;
  }
  if (v126)
  {
    geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)v125);
    if (!LOBYTE(v125[0]))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      unsigned int v118 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v128 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        __int16 v129 = 1024;
        int v130 = 999;
        __int16 v131 = 2082;
        unint64_t v132 = "Could not read arrow height.";
        _os_log_impl(&dword_1A1780000, v118, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      unint64_t v119 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v119, (uint64_t)":", 1);
      uint64_t v120 = (void *)std::ostream::operator<<();
      int v121 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v120, (uint64_t)" STYL Parse Error Here: ", 24);
      int v122 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v121, (uint64_t)"Could not read arrow height.", 28);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v122, (uint64_t)"\n", 1);
      return 0;
    }
    if ((a4 - 171) > 4) {
      unsigned __int16 v112 = 482;
    }
    else {
      unsigned __int16 v112 = word_1A29CD3CC[(__int16)(a4 - 171)];
    }
    int v124 = v126;
    v125[0] = v112;
    *(_WORD *)float buf = v112;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v128);
    *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, v125) = v124;
  }
  return 1;
}

uint64_t gss::shieldSizeDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 9u, a4, a6);
}

uint64_t gss::labelTextVisibilityDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 3u, a4, a6);
}

uint64_t gss::trafficDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, uint64_t a3, int a4, uint64_t a5, void *a6)
{
  uint64_t v211 = *MEMORY[0x1E4F143B8];
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
  if (!LOBYTE(v201))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v22 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      *(_WORD *)int v208 = 1024;
      *(_DWORD *)&v208[2] = 743;
      __int16 v209 = 2082;
      uint64_t v210 = "Could not read indication of traffic visibility existing.";
      _os_log_impl(&dword_1A1780000, v22, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unsigned int v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)":", 1);
    uint64_t v24 = (void *)std::ostream::operator<<();
    uint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"Could not read indication of traffic visibility existing.", 57);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"\n", 1);
    return 0;
  }
  if (v202.i32[0])
  {
    geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
    if (!LOBYTE(v201))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      unsigned __int16 v32 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        *(_WORD *)int v208 = 1024;
        *(_DWORD *)&v208[2] = 746;
        __int16 v209 = 2082;
        uint64_t v210 = "Could not read traffic visibility.";
        _os_log_impl(&dword_1A1780000, v32, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      unsigned __int16 v33 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v33, (uint64_t)":", 1);
      uint64_t v34 = (void *)std::ostream::operator<<();
      unint64_t v35 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v34, (uint64_t)" STYL Parse Error Here: ", 24);
      __int16 v36 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)"Could not read traffic visibility.", 34);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)"\n", 1);
      return 0;
    }
    __int8 v11 = v202.i8[0];
    if (((a4 - 90) & 0xFFFC) != 0) {
      __int16 v12 = 482;
    }
    else {
      __int16 v12 = 11 * (a4 - 90) + 42;
    }
    LOWORD(v201) = v12;
    *(_WORD *)float buf = v12;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
    *(unsigned char *)geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 16, (unsigned __int16 *)&v201) = v11;
  }
  geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
  if (!LOBYTE(v201))
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    uint64_t v27 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      *(_WORD *)int v208 = 1024;
      *(_DWORD *)&v208[2] = 751;
      __int16 v209 = 2082;
      uint64_t v210 = "Could not read indication of traffic fill color existing.";
      _os_log_impl(&dword_1A1780000, v27, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    int v28 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v28, (uint64_t)":", 1);
    unsigned int v29 = (void *)std::ostream::operator<<();
    int v30 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v29, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned __int16 v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v30, (uint64_t)"Could not read indication of traffic fill color existing.", 57);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v31, (uint64_t)"\n", 1);
    return 0;
  }
  if (!v202.i32[0])
  {
LABEL_45:
    geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
    if (!LOBYTE(v201))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      uint64_t v59 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        *(_WORD *)int v208 = 1024;
        *(_DWORD *)&v208[2] = 762;
        __int16 v209 = 2082;
        uint64_t v210 = "Could not read indication of traffic secondary color existing.";
        _os_log_impl(&dword_1A1780000, v59, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      uint64_t v60 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v60, (uint64_t)":", 1);
      uint64_t v61 = (void *)std::ostream::operator<<();
      int v62 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v61, (uint64_t)" STYL Parse Error Here: ", 24);
      unsigned int v63 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v62, (uint64_t)"Could not read indication of traffic secondary color existing.", 62);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v63, (uint64_t)"\n", 1);
      return 0;
    }
    if (v202.i32[0])
    {
      *(_DWORD *)float buf = 0;
      unint64_t v50 = *(void *)(a1 + 8);
      uint64_t v51 = *(void *)(a1 + 16);
      char v52 = *(unsigned char *)(a1 + 24);
      unint64_t v53 = v51 + 5;
      if (!v52) {
        unint64_t v53 = v51 + 4;
      }
      if (v50 < v53)
      {
        if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
          dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
        }
        unint64_t v54 = GEOGetGeoCSSStyleSheetLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 136315650;
          int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
          *(_WORD *)int v208 = 1024;
          *(_DWORD *)&v208[2] = 765;
          __int16 v209 = 2082;
          uint64_t v210 = "Could not read traffic secondary color.";
          _os_log_impl(&dword_1A1780000, v54, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
        }
        int v55 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v55, (uint64_t)":", 1);
        uint64_t v56 = (void *)std::ostream::operator<<();
        uint64_t v57 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v56, (uint64_t)" STYL Parse Error Here: ", 24);
        uint64_t v58 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v57, (uint64_t)"Could not read traffic secondary color.", 39);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v58, (uint64_t)"\n", 1);
        return 0;
      }
      uint64_t v64 = *(void *)a1;
      if (*(unsigned char *)(a1 + 24))
      {
        uint64_t v65 = 0;
        uint64_t v66 = v64 + v51;
        uint64_t v67 = v51 + 1;
        do
        {
          if (v67 + v65 >= v50) {
            int v68 = 0;
          }
          else {
            int v68 = *(unsigned __int8 *)(v66 + v65 + 1);
          }
          unsigned int v69 = ((v68 & (0xFFFF << (8 - v52))) >> (8 - v52)) | ((((1 << (8 - v52)) + 255) & *(unsigned __int8 *)(v66 + v65)) << v52);
          *(void *)(a1 + 16) = v67 + v65;
          buf[v65++] = v69;
        }
        while (v65 != 4);
        unsigned int v70 = *(_DWORD *)buf;
      }
      else
      {
        unsigned int v70 = *(_DWORD *)(v64 + v51);
        *(void *)(a1 + 16) = v51 + 4;
      }
      if (((a4 - 90) & 0xFFFC) != 0) {
        unsigned __int16 v71 = 482;
      }
      else {
        unsigned __int16 v71 = 11 * (a4 - 90) + 44;
      }
      unsigned __int16 v204 = v71;
      *(_WORD *)float buf = v71;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
      unsigned int v72 = bswap32(v70);
      float v201 = (float)v72 / 255.0;
      float32x2_t v202 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v72), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL)), (float32x2_t)vdup_n_s32(0x437F0000u));
      float v203 = (float)HIBYTE(v72) / 255.0;
      *(_DWORD *)float buf = geo::colorTransform<geo::ReverseGammaCorrection>(geo::reverseSRGBGammaCorrection, &v201);
      int v207 = (const char *)__PAIR64__(v74, v73);
      *(_DWORD *)int v208 = v75;
      geo::_wordColor<float,4,(geo::ColorSpace)0>((float32x4_t *)buf, &v205);
      int16x4_t v76 = v205;
      *(int16x4_t *)geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 48, &v204) = v76;
    }
    geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
    if (!LOBYTE(v201))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      int v86 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        *(_WORD *)int v208 = 1024;
        *(_DWORD *)&v208[2] = 773;
        __int16 v209 = 2082;
        uint64_t v210 = "Could not read indication of traffic pill middle length existing.";
        _os_log_impl(&dword_1A1780000, v86, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      unsigned __int16 v87 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v87, (uint64_t)":", 1);
      unsigned __int16 v88 = (void *)std::ostream::operator<<();
      uint64_t v89 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v88, (uint64_t)" STYL Parse Error Here: ", 24);
      uint64_t v90 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v89, (uint64_t)"Could not read indication of traffic pill middle length existing.", 65);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v90, (uint64_t)"\n", 1);
      return 0;
    }
    if (v202.i32[0])
    {
      *(_DWORD *)float buf = 0;
      unint64_t v77 = *(void *)(a1 + 8);
      uint64_t v78 = *(void *)(a1 + 16);
      char v79 = *(unsigned char *)(a1 + 24);
      unint64_t v80 = v78 + 5;
      if (!v79) {
        unint64_t v80 = v78 + 4;
      }
      if (v77 < v80)
      {
        if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
          dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
        }
        uint64_t v81 = GEOGetGeoCSSStyleSheetLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 136315650;
          int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
          *(_WORD *)int v208 = 1024;
          *(_DWORD *)&v208[2] = 776;
          __int16 v209 = 2082;
          uint64_t v210 = "Could not read traffic pill middle length.";
          _os_log_impl(&dword_1A1780000, v81, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
        }
        uint64_t v82 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v82, (uint64_t)":", 1);
        uint64_t v83 = (void *)std::ostream::operator<<();
        int v84 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v83, (uint64_t)" STYL Parse Error Here: ", 24);
        unsigned int v85 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v84, (uint64_t)"Could not read traffic pill middle length.", 42);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v85, (uint64_t)"\n", 1);
        return 0;
      }
      uint64_t v91 = *(void *)a1;
      if (*(unsigned char *)(a1 + 24))
      {
        uint64_t v92 = 0;
        uint64_t v93 = v91 + v78;
        uint64_t v94 = v78 + 1;
        do
        {
          if (v94 + v92 >= v77) {
            int v95 = 0;
          }
          else {
            int v95 = *(unsigned __int8 *)(v93 + v92 + 1);
          }
          unsigned int v96 = ((v95 & (0xFFFF << (8 - v79))) >> (8 - v79)) | ((((1 << (8 - v79)) + 255) & *(unsigned __int8 *)(v93 + v92)) << v79);
          *(void *)(a1 + 16) = v94 + v92;
          buf[v92++] = v96;
        }
        while (v92 != 4);
        int v97 = *(_DWORD *)buf;
      }
      else
      {
        int v97 = *(_DWORD *)(v91 + v78);
        *(void *)(a1 + 16) = v78 + 4;
      }
      if (((a4 - 90) & 0xFFFC) != 0) {
        __int16 v98 = 482;
      }
      else {
        __int16 v98 = 11 * (a4 - 90) + 45;
      }
      LOWORD(v201) = v98;
      *(_WORD *)float buf = v98;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
      *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, (unsigned __int16 *)&v201) = v97;
    }
    geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
    if (!LOBYTE(v201))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      int v121 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        *(_WORD *)int v208 = 1024;
        *(_DWORD *)&v208[2] = 781;
        __int16 v209 = 2082;
        uint64_t v210 = "Could not read indication of traffic pill spacing existing.";
        _os_log_impl(&dword_1A1780000, v121, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      int v122 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v122, (uint64_t)":", 1);
      unsigned int v123 = (void *)std::ostream::operator<<();
      int v124 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v123, (uint64_t)" STYL Parse Error Here: ", 24);
      unsigned int v125 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v124, (uint64_t)"Could not read indication of traffic pill spacing existing.", 59);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v125, (uint64_t)"\n", 1);
      return 0;
    }
    if (v202.i32[0])
    {
      geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)&v201);
      if (!LOBYTE(v201))
      {
        if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
          dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
        }
        __int16 v131 = GEOGetGeoCSSStyleSheetLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 136315650;
          int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
          *(_WORD *)int v208 = 1024;
          *(_DWORD *)&v208[2] = 784;
          __int16 v209 = 2082;
          uint64_t v210 = "Could not read traffic pill spacing.";
          _os_log_impl(&dword_1A1780000, v131, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
        }
        unint64_t v132 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v132, (uint64_t)":", 1);
        uint64_t v133 = (void *)std::ostream::operator<<();
        char v134 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v133, (uint64_t)" STYL Parse Error Here: ", 24);
        unint64_t v135 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v134, (uint64_t)"Could not read traffic pill spacing.", 36);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v135, (uint64_t)"\n", 1);
        return 0;
      }
      __int32 v99 = v202.i32[0];
      if (((a4 - 90) & 0xFFFC) != 0) {
        __int16 v100 = 482;
      }
      else {
        __int16 v100 = 11 * (a4 - 90) + 46;
      }
      LOWORD(v201) = v100;
      *(_WORD *)float buf = v100;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
      *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, (unsigned __int16 *)&v201) = v99;
    }
    geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
    if (!LOBYTE(v201))
    {
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      int v126 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        *(_WORD *)int v208 = 1024;
        *(_DWORD *)&v208[2] = 789;
        __int16 v209 = 2082;
        uint64_t v210 = "Could not read indication of traffic secondary width existing.";
        _os_log_impl(&dword_1A1780000, v126, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      int64x2_t v127 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v127, (uint64_t)":", 1);
      int v128 = (void *)std::ostream::operator<<();
      __int16 v129 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v128, (uint64_t)" STYL Parse Error Here: ", 24);
      int v130 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v129, (uint64_t)"Could not read indication of traffic secondary width existing.", 62);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v130, (uint64_t)"\n", 1);
      return 0;
    }
    if (v202.i32[0])
    {
      geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)&v201);
      if (!LOBYTE(v201))
      {
        if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
          dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
        }
        unint64_t v136 = GEOGetGeoCSSStyleSheetLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 136315650;
          int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
          *(_WORD *)int v208 = 1024;
          *(_DWORD *)&v208[2] = 792;
          __int16 v209 = 2082;
          uint64_t v210 = "Could not read traffic secondary width.";
          _os_log_impl(&dword_1A1780000, v136, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
        }
        unsigned int v137 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v137, (uint64_t)":", 1);
        unint64_t v138 = (void *)std::ostream::operator<<();
        uint64_t v139 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v138, (uint64_t)" STYL Parse Error Here: ", 24);
        int v140 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v139, (uint64_t)"Could not read traffic secondary width.", 39);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v140, (uint64_t)"\n", 1);
        return 0;
      }
      __int32 v101 = v202.i32[0];
      if (((a4 - 90) & 0xFFFC) != 0) {
        __int16 v102 = 482;
      }
      else {
        __int16 v102 = 11 * (a4 - 90) + 47;
      }
      LOWORD(v201) = v102;
      *(_WORD *)float buf = v102;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
      *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, (unsigned __int16 *)&v201) = v101;
    }
    if (*(_DWORD *)(a5 + 8) >= 2u)
    {
      geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
      if (!LOBYTE(v201))
      {
        if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
          dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
        }
        unint64_t v141 = GEOGetGeoCSSStyleSheetLog_log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)float buf = 136315650;
          int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
          *(_WORD *)int v208 = 1024;
          *(_DWORD *)&v208[2] = 798;
          __int16 v209 = 2082;
          uint64_t v210 = "Could not read indication of traffic width existing.";
          _os_log_impl(&dword_1A1780000, v141, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
        }
        uint64_t v142 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v142, (uint64_t)":", 1);
        long long v143 = (void *)std::ostream::operator<<();
        unsigned int v144 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v143, (uint64_t)" STYL Parse Error Here: ", 24);
        uint64_t v145 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v144, (uint64_t)"Could not read indication of traffic width existing.", 52);
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v145, (uint64_t)"\n", 1);
        return 0;
      }
      if (v202.i32[0])
      {
        geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)&v201);
        if (!LOBYTE(v201))
        {
          if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
            dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
          }
          unint64_t v146 = GEOGetGeoCSSStyleSheetLog_log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
            *(_WORD *)int v208 = 1024;
            *(_DWORD *)&v208[2] = 801;
            __int16 v209 = 2082;
            uint64_t v210 = "Could not read traffic width.";
            _os_log_impl(&dword_1A1780000, v146, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }
          unint64_t v147 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v147, (uint64_t)":", 1);
          uint64_t v148 = (void *)std::ostream::operator<<();
          uint64_t v149 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v148, (uint64_t)" STYL Parse Error Here: ", 24);
          uint64_t v150 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v149, (uint64_t)"Could not read traffic width.", 29);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v150, (uint64_t)"\n", 1);
          return 0;
        }
        __int32 v103 = v202.i32[0];
        if (((a4 - 90) & 0xFFFC) != 0) {
          __int16 v104 = 482;
        }
        else {
          __int16 v104 = 11 * (a4 - 90) + 48;
        }
        LOWORD(v201) = v104;
        *(_WORD *)float buf = v104;
        buf[2] = 0;
        geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
        *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, (unsigned __int16 *)&v201) = v103;
      }
      if (*(_DWORD *)(a5 + 8) >= 3u)
      {
        geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
        if (!LOBYTE(v201))
        {
          if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
            dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
          }
          unint64_t v151 = GEOGetGeoCSSStyleSheetLog_log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
            *(_WORD *)int v208 = 1024;
            *(_DWORD *)&v208[2] = 808;
            __int16 v209 = 2082;
            uint64_t v210 = "Could not read indication of traffic min width existing.";
            _os_log_impl(&dword_1A1780000, v151, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }
          uint8x8_t v152 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v152, (uint64_t)":", 1);
          char v153 = (void *)std::ostream::operator<<();
          unint64_t v154 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v153, (uint64_t)" STYL Parse Error Here: ", 24);
          uint64_t v155 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v154, (uint64_t)"Could not read indication of traffic min width existing.", 56);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v155, (uint64_t)"\n", 1);
          return 0;
        }
        if (v202.i32[0])
        {
          geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)&v201);
          if (!LOBYTE(v201))
          {
            if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
              dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
            }
            unint64_t v161 = GEOGetGeoCSSStyleSheetLog_log;
            if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
              *(_WORD *)int v208 = 1024;
              *(_DWORD *)&v208[2] = 811;
              __int16 v209 = 2082;
              uint64_t v210 = "Could not read traffic min width.";
              _os_log_impl(&dword_1A1780000, v161, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }
            long long v162 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v162, (uint64_t)":", 1);
            uint64_t v163 = (void *)std::ostream::operator<<();
            uint64_t v164 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v163, (uint64_t)" STYL Parse Error Here: ", 24);
            char v165 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v164, (uint64_t)"Could not read traffic min width.", 33);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v165, (uint64_t)"\n", 1);
            return 0;
          }
          __int32 v105 = v202.i32[0];
          if (((a4 - 90) & 0xFFFC) != 0) {
            __int16 v106 = 482;
          }
          else {
            __int16 v106 = 11 * (a4 - 90) + 49;
          }
          LOWORD(v201) = v106;
          *(_WORD *)float buf = v106;
          buf[2] = 0;
          geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
          *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, (unsigned __int16 *)&v201) = v105;
        }
        geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
        if (!LOBYTE(v201))
        {
          if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
            dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
          }
          std::string::size_type v156 = GEOGetGeoCSSStyleSheetLog_log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
            *(_WORD *)int v208 = 1024;
            *(_DWORD *)&v208[2] = 816;
            __int16 v209 = 2082;
            uint64_t v210 = "Could not read indication of traffic secondary min width existing.";
            _os_log_impl(&dword_1A1780000, v156, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }
          long long v157 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v157, (uint64_t)":", 1);
          unint64_t v158 = (void *)std::ostream::operator<<();
          long long v159 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v158, (uint64_t)" STYL Parse Error Here: ", 24);
          unint64_t v160 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v159, (uint64_t)"Could not read indication of traffic secondary min width existing.", 66);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v160, (uint64_t)"\n", 1);
          return 0;
        }
        if (v202.i32[0])
        {
          geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)&v201);
          if (!LOBYTE(v201))
          {
            if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
              dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
            }
            uint64_t v171 = GEOGetGeoCSSStyleSheetLog_log;
            if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
              *(_WORD *)int v208 = 1024;
              *(_DWORD *)&v208[2] = 819;
              __int16 v209 = 2082;
              uint64_t v210 = "Could not read traffic secondary min width.";
              _os_log_impl(&dword_1A1780000, v171, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }
            float v172 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v172, (uint64_t)":", 1);
            int v173 = (void *)std::ostream::operator<<();
            uint64_t v174 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v173, (uint64_t)" STYL Parse Error Here: ", 24);
            uint64_t v175 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v174, (uint64_t)"Could not read traffic secondary min width.", 43);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v175, (uint64_t)"\n", 1);
            return 0;
          }
          __int32 v107 = v202.i32[0];
          if (((a4 - 90) & 0xFFFC) != 0) {
            __int16 v108 = 482;
          }
          else {
            __int16 v108 = 11 * (a4 - 90) + 50;
          }
          LOWORD(v201) = v108;
          *(_WORD *)float buf = v108;
          buf[2] = 0;
          geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
          *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, (unsigned __int16 *)&v201) = v107;
        }
        geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
        if (!LOBYTE(v201))
        {
          if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
            dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
          }
          int v166 = GEOGetGeoCSSStyleSheetLog_log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
            *(_WORD *)int v208 = 1024;
            *(_DWORD *)&v208[2] = 824;
            __int16 v209 = 2082;
            uint64_t v210 = "Could not read indication of traffic max width existing.";
            _os_log_impl(&dword_1A1780000, v166, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }
          uint64_t v167 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v167, (uint64_t)":", 1);
          unint64_t v168 = (void *)std::ostream::operator<<();
          unint64_t v169 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v168, (uint64_t)" STYL Parse Error Here: ", 24);
          long long v170 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v169, (uint64_t)"Could not read indication of traffic max width existing.", 56);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v170, (uint64_t)"\n", 1);
          return 0;
        }
        if (v202.i32[0])
        {
          geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)&v201);
          if (!LOBYTE(v201))
          {
            if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
              dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
            }
            unsigned int v181 = GEOGetGeoCSSStyleSheetLog_log;
            if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
              *(_WORD *)int v208 = 1024;
              *(_DWORD *)&v208[2] = 827;
              __int16 v209 = 2082;
              uint64_t v210 = "Could not read traffic max width.";
              _os_log_impl(&dword_1A1780000, v181, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }
            float32x4_t v182 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v182, (uint64_t)":", 1);
            uint64_t v183 = (void *)std::ostream::operator<<();
            uint64_t v184 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v183, (uint64_t)" STYL Parse Error Here: ", 24);
            size_t v185 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v184, (uint64_t)"Could not read traffic max width.", 33);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v185, (uint64_t)"\n", 1);
            return 0;
          }
          __int32 v109 = v202.i32[0];
          if (((a4 - 90) & 0xFFFC) != 0) {
            __int16 v110 = 482;
          }
          else {
            __int16 v110 = 11 * (a4 - 90) + 51;
          }
          LOWORD(v201) = v110;
          *(_WORD *)float buf = v110;
          buf[2] = 0;
          geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
          *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, (unsigned __int16 *)&v201) = v109;
        }
        geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
        if (!LOBYTE(v201))
        {
          if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
            dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
          }
          unint64_t v176 = GEOGetGeoCSSStyleSheetLog_log;
          if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)float buf = 136315650;
            int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
            *(_WORD *)int v208 = 1024;
            *(_DWORD *)&v208[2] = 832;
            __int16 v209 = 2082;
            uint64_t v210 = "Could not read indication of traffic secondary max width existing.";
            _os_log_impl(&dword_1A1780000, v176, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
          }
          unint64_t v177 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v177, (uint64_t)":", 1);
          char v178 = (void *)std::ostream::operator<<();
          unint64_t v179 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v178, (uint64_t)" STYL Parse Error Here: ", 24);
          unint64_t v180 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v179, (uint64_t)"Could not read indication of traffic secondary max width existing.", 66);
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v180, (uint64_t)"\n", 1);
          return 0;
        }
        if (v202.i32[0])
        {
          geo::ibitstream::readFloat((uint64_t *)a1, (uint64_t)&v201);
          if (!LOBYTE(v201))
          {
            if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
              dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
            }
            size_t v186 = GEOGetGeoCSSStyleSheetLog_log;
            if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
              *(_WORD *)int v208 = 1024;
              *(_DWORD *)&v208[2] = 835;
              __int16 v209 = 2082;
              uint64_t v210 = "Could not read traffic secondary max width.";
              _os_log_impl(&dword_1A1780000, v186, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }
            size_t v187 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v187, (uint64_t)":", 1);
            uint64_t v188 = (void *)std::ostream::operator<<();
            size_t v189 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v188, (uint64_t)" STYL Parse Error Here: ", 24);
            uint64_t v190 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v189, (uint64_t)"Could not read traffic secondary max width.", 43);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v190, (uint64_t)"\n", 1);
            return 0;
          }
          __int32 v111 = v202.i32[0];
          if (((a4 - 90) & 0xFFFC) != 0) {
            __int16 v112 = 482;
          }
          else {
            __int16 v112 = 11 * (a4 - 90) + 52;
          }
          LOWORD(v201) = v112;
          *(_WORD *)float buf = v112;
          buf[2] = 0;
          geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
          *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, (unsigned __int16 *)&v201) = v111;
        }
        if (*(_DWORD *)(a5 + 8) >= 0xDu)
        {
          geo::ibitstream::readUIntBits(a1, 1u, (uint64_t)&v201);
          if (!LOBYTE(v201))
          {
            if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
              dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
            }
            unint64_t v191 = GEOGetGeoCSSStyleSheetLog_log;
            if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)float buf = 136315650;
              int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
              *(_WORD *)int v208 = 1024;
              *(_DWORD *)&v208[2] = 842;
              __int16 v209 = 2082;
              uint64_t v210 = "Could not read indication of traffic gradient mask color existing.";
              _os_log_impl(&dword_1A1780000, v191, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
            }
            uint8x8_t v192 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v192, (uint64_t)":", 1);
            uint64_t v193 = (void *)std::ostream::operator<<();
            uint64_t v194 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v193, (uint64_t)" STYL Parse Error Here: ", 24);
            uint64_t v195 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v194, (uint64_t)"Could not read indication of traffic gradient mask color existing.", 66);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v195, (uint64_t)"\n", 1);
            return 0;
          }
          if (v202.i32[0])
          {
            geo::ibitstream::readUInt32((uint64_t *)a1, (uint64_t)&v201);
            if (!LOBYTE(v201))
            {
              if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
                dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
              }
              unint64_t v196 = GEOGetGeoCSSStyleSheetLog_log;
              if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)float buf = 136315650;
                int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
                *(_WORD *)int v208 = 1024;
                *(_DWORD *)&v208[2] = 845;
                __int16 v209 = 2082;
                uint64_t v210 = "Could not read gradient mask color.";
                _os_log_impl(&dword_1A1780000, v196, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
              }
              uint64_t v197 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v197, (uint64_t)":", 1);
              float v198 = (void *)std::ostream::operator<<();
              unint64_t v199 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v198, (uint64_t)" STYL Parse Error Here: ", 24);
              uint64_t v200 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v199, (uint64_t)"Could not read gradient mask color.", 35);
              std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v200, (uint64_t)"\n", 1);
              return 0;
            }
            unsigned int v113 = v202.i32[0];
            if ((((_WORD)a4 - 90) & 0xFFFC) != 0) {
              unsigned __int16 v114 = 482;
            }
            else {
              unsigned __int16 v114 = a4 + 338;
            }
            unsigned __int16 v204 = v114;
            *(_WORD *)float buf = v114;
            buf[2] = 0;
            geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
            unsigned int v115 = bswap32(v113);
            float v201 = (float)v115 / 255.0;
            float32x2_t v202 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v115), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL)), (float32x2_t)vdup_n_s32(0x437F0000u));
            float v203 = (float)HIBYTE(v115) / 255.0;
            *(_DWORD *)float buf = geo::colorTransform<geo::ReverseGammaCorrection>(geo::reverseSRGBGammaCorrection, &v201);
            int v207 = (const char *)__PAIR64__(v117, v116);
            *(_DWORD *)int v208 = v118;
            geo::_wordColor<float,4,(geo::ColorSpace)0>((float32x4_t *)buf, &v205);
            int16x4_t v119 = v205;
            *(int16x4_t *)geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 48, &v204) = v119;
          }
        }
      }
    }
    return 1;
  }
  *(_DWORD *)float buf = 0;
  unint64_t v13 = *(void *)(a1 + 8);
  uint64_t v14 = *(void *)(a1 + 16);
  char v15 = *(unsigned char *)(a1 + 24);
  unint64_t v16 = v14 + 5;
  if (!v15) {
    unint64_t v16 = v14 + 4;
  }
  if (v13 >= v16)
  {
    uint64_t v37 = *(void *)a1;
    if (*(unsigned char *)(a1 + 24))
    {
      uint64_t v38 = 0;
      uint64_t v39 = v37 + v14;
      uint64_t v40 = v14 + 1;
      do
      {
        if (v40 + v38 >= v13) {
          int v41 = 0;
        }
        else {
          int v41 = *(unsigned __int8 *)(v39 + v38 + 1);
        }
        unsigned int v42 = ((v41 & (0xFFFF << (8 - v15))) >> (8 - v15)) | ((((1 << (8 - v15)) + 255) & *(unsigned __int8 *)(v39 + v38)) << v15);
        *(void *)(a1 + 16) = v40 + v38;
        buf[v38++] = v42;
      }
      while (v38 != 4);
      unsigned int v43 = *(_DWORD *)buf;
    }
    else
    {
      unsigned int v43 = *(_DWORD *)(v37 + v14);
      *(void *)(a1 + 16) = v14 + 4;
    }
    if (((a4 - 90) & 0xFFFC) != 0) {
      unsigned __int16 v44 = 482;
    }
    else {
      unsigned __int16 v44 = 11 * (a4 - 90) + 43;
    }
    unsigned __int16 v204 = v44;
    *(_WORD *)float buf = v44;
    buf[2] = 0;
    geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v207);
    unsigned int v45 = bswap32(v43);
    float v201 = (float)v45 / 255.0;
    float32x2_t v202 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v45), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL)), (float32x2_t)vdup_n_s32(0x437F0000u));
    float v203 = (float)HIBYTE(v45) / 255.0;
    *(_DWORD *)float buf = geo::colorTransform<geo::ReverseGammaCorrection>(geo::reverseSRGBGammaCorrection, &v201);
    int v207 = (const char *)__PAIR64__(v47, v46);
    *(_DWORD *)int v208 = v48;
    geo::_wordColor<float,4,(geo::ColorSpace)0>((float32x4_t *)buf, &v205);
    int16x4_t v49 = v205;
    *(int16x4_t *)geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 48, &v204) = v49;
    goto LABEL_45;
  }
  if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
    dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
  }
  unint64_t v17 = GEOGetGeoCSSStyleSheetLog_log;
  if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float buf = 136315650;
    int v207 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
    *(_WORD *)int v208 = 1024;
    *(_DWORD *)&v208[2] = 754;
    __int16 v209 = 2082;
    uint64_t v210 = "Could not read traffic fill color.";
    _os_log_impl(&dword_1A1780000, v17, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)":", 1);
  unint64_t v19 = (void *)std::ostream::operator<<();
  unsigned int v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" STYL Parse Error Here: ", 24);
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"Could not read traffic fill color.", 34);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"\n", 1);
  return 0;
}

uint64_t gss::labelPositionDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 0x1FFu, a4, a6);
}

uint64_t gss::dashPatternDecoder<gss::PropertyID>(gss::Allocator *a1, unint64_t a2, uint64_t a3, int a4, uint64_t *a5, void *a6)
{
  uint64_t v100 = *MEMORY[0x1E4F143B8];
  uint64_t v94 = 0;
  int v95 = 0;
  unsigned int v96 = 0;
  uint64_t v97 = gss::Allocator::instance(a1);
  __int16 v12 = (gss::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v97 + 16))(v97, 8, 2);
  unint64_t v13 = v12;
  uint64_t v94 = v12;
  unsigned int v96 = (char *)v12 + 8;
  if (v12) {
    *(_DWORD *)__int16 v12 = 19661079;
  }
  uint64_t v14 = 0;
  *((_DWORD *)v12 + 1) = 19726616;
  int v95 = (gss::Allocator *)((char *)v12 + 8);
  while (*(unsigned __int16 *)((char *)v12 + v14) != a4)
  {
    v14 += 4;
    if (v14 == 8)
    {
      uint64_t v15 = 1;
      goto LABEL_82;
    }
  }
  uint64_t v15 = 1;
  if (!a3) {
    goto LABEL_83;
  }
  uint64_t v89 = 0;
  uint64_t v90 = 0;
  uint64_t v91 = 0;
  uint64_t v16 = gss::Allocator::instance(v12);
  uint64_t v17 = v16;
  uint64_t v92 = v16;
  if ((a3 & 0xF) != 0)
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    uint64_t v18 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 584;
      *(_WORD *)&unsigned char buf[18] = 2082;
      *(void *)&buf[20] = "Dash pattern had strange number of bits.";
      _os_log_impl(&dword_1A1780000, v18, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)":", 1);
    unsigned int v20 = (void *)std::ostream::operator<<();
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"Dash pattern had strange number of bits.", 40);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)"\n", 1);
    uint64_t v15 = 0;
  }
  else
  {
    if (a3 >= 0x10)
    {
      uint64_t v25 = a3 >> 4;
      uint64_t v26 = 4 * v25;
      uint64_t v27 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 16))(v16, 4 * v25, 4);
      uint64_t v23 = v27;
      uint64_t v28 = 0;
      uint64_t v87 = v27 + 4 * v25;
      do
      {
        if (v27 + v28) {
          *(_DWORD *)(v27 + v28) = 0;
        }
        v28 += 4;
      }
      while (v26 != v28);
      uint64_t v29 = 0;
      uint64_t v89 = v27;
      uint64_t v90 = v27 + 4 * v25;
      uint64_t v91 = v90;
      int v30 = *((unsigned __int8 *)a1 + 24);
      BOOL v31 = *((unsigned char *)a1 + 24) != 0;
      uint64_t v33 = *(void *)a1;
      unint64_t v32 = *((void *)a1 + 1);
      uint64_t v34 = *((void *)a1 + 2);
      if (v25 <= 1) {
        uint64_t v35 = 1;
      }
      else {
        uint64_t v35 = v25;
      }
      while (1)
      {
        *(_WORD *)float buf = 0;
        uint64_t v36 = v34 + 2;
        if (v32 < v34 + 2 + v31) {
          break;
        }
        if (v30)
        {
          char v37 = 0;
          uint64_t v38 = 0;
          do
          {
            char v39 = v37;
            uint64_t v36 = v34 + 1;
            if (v34 + 1 >= v32) {
              int v40 = 0;
            }
            else {
              int v40 = *(unsigned __int8 *)(v33 + v34 + 1);
            }
            char v41 = ((v40 & (0xFFFF << (8 - v30))) >> (8 - v30)) | ((((1 << (8 - v30)) + 255) & *(unsigned __int8 *)(v33 + v34)) << v30);
            *((void *)a1 + 2) = v36;
            buf[v38] = v41;
            char v37 = 1;
            uint64_t v34 = v36;
            uint64_t v38 = 1;
          }
          while ((v39 & 1) == 0);
          unsigned int v42 = *(unsigned __int16 *)buf;
        }
        else
        {
          unsigned int v42 = *(unsigned __int16 *)(v33 + v34);
          *((void *)a1 + 2) = v36;
        }
        *(float *)(v23 + 4 * v29++) = (float)v42 * 0.25;
        uint64_t v34 = v36;
        if (v29 == v35)
        {
          uint64_t v43 = 0;
          float v24 = 0.0;
          do
          {
            float v24 = v24 + *(float *)(v23 + v43);
            v43 += 4;
          }
          while (v26 != v43);
          goto LABEL_35;
        }
      }
      if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
        dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
      }
      unsigned int v72 = GEOGetGeoCSSStyleSheetLog_log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 590;
        *(_WORD *)&unsigned char buf[18] = 2082;
        *(void *)&buf[20] = "Could not read dash gap.";
        _os_log_impl(&dword_1A1780000, v72, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
      }
      unsigned int v73 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v73, (uint64_t)":", 1);
      unsigned int v74 = (void *)std::ostream::operator<<();
      int v75 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v74, (uint64_t)" STYL Parse Error Here: ", 24);
      int16x4_t v76 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v75, (uint64_t)"Could not read dash gap.", 24);
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v76, (uint64_t)"\n", 1);
      uint64_t v15 = 0;
    }
    else
    {
      uint64_t v87 = 0;
      uint64_t v23 = 0;
      float v24 = 0.0;
LABEL_35:
      float v93 = v24;
      unsigned __int16 v88 = *(_WORD *)((char *)v13 + v14 + 2);
      *(_WORD *)float buf = v88;
      buf[2] = 0;
      unsigned __int16 v44 = (gss::Allocator *)geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&buf[4]);
      uint64_t v45 = *a5;
      uint64_t v46 = *(void *)(*a5 + 392);
      if (*(void *)(*a5 + 384) == v46
        || (unsigned int v47 = *(uint64_t **)(v46 - 16),
            unint64_t v48 = v47[1],
            0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v48 - *v47) >> 3) == *(_DWORD *)(v45 + 408)))
      {
        uint64_t v49 = gss::Allocator::instance(v44);
        unint64_t v50 = (atomic_ullong *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v49 + 16))(v49, 64, 8);
        atomic_ullong *v50 = (atomic_ullong)&unk_1EF58B268;
        v50[1] = 0;
        v50[2] = 0;
        v50[3] = v49;
        v50[4] = 0;
        uint64_t v51 = v50 + 4;
        v50[5] = 0;
        v50[6] = 0;
        uint64_t v52 = gss::Allocator::instance((gss::Allocator *)v50);
        v50[7] = v52;
        unint64_t v53 = *(unsigned int *)(v45 + 408);
        atomic_ullong v54 = v50[4];
        if (0xCCCCCCCCCCCCCCCDLL * ((v50[6] - v54) >> 3) < v53)
        {
          atomic_ullong v55 = v50[5];
          __int32 v99 = v50 + 7;
          *(void *)float buf = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v52 + 16))(v52, 40 * v53, 8);
          *(void *)&uint8_t buf[8] = *(void *)buf + v55 - v54;
          *(void *)&buf[16] = *(void *)&buf[8];
          *(void *)&unsigned char buf[24] = *(void *)buf + 40 * v53;
          std::vector<gss::DashPattern,geo::StdAllocator<gss::DashPattern,gss::Allocator>>::__swap_out_circular_buffer(v51, buf);
          std::__split_buffer<gss::DashPattern,geo::StdAllocator<gss::DashPattern,gss::Allocator> &>::~__split_buffer((uint64_t)buf);
        }
        uint64_t v56 = *(uint64_t ***)(v45 + 392);
        unint64_t v57 = *(void *)(v45 + 400);
        if ((unint64_t)v56 >= v57)
        {
          uint64_t v59 = *(void *)(v45 + 384);
          uint64_t v60 = ((uint64_t)v56 - v59) >> 4;
          unint64_t v61 = v60 + 1;
          if ((unint64_t)(v60 + 1) >> 60) {
            std::vector<double>::__throw_length_error[abi:ne180100]();
          }
          uint64_t v62 = v57 - v59;
          if (v62 >> 3 > v61) {
            unint64_t v61 = v62 >> 3;
          }
          if ((unint64_t)v62 >= 0x7FFFFFFFFFFFFFF0) {
            unint64_t v63 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v63 = v61;
          }
          if (v63 >> 60) {
            std::__throw_bad_array_new_length[abi:ne180100]();
          }
          uint64_t v64 = (char *)operator new(16 * v63);
          uint64_t v65 = (uint64_t **)&v64[16 * v60];
          uint64_t v66 = &v64[16 * v63];
          *uint64_t v65 = v51;
          v65[1] = v50;
          atomic_fetch_add_explicit(v50 + 1, 1uLL, memory_order_relaxed);
          uint64_t v67 = *(void **)(v45 + 384);
          int v68 = *(void **)(v45 + 392);
          uint64_t v58 = v65 + 2;
          if (v68 == v67)
          {
            *(void *)(v45 + 384) = v65;
            *(void *)(v45 + 392) = v58;
            *(void *)(v45 + 400) = v66;
          }
          else
          {
            do
            {
              long long v69 = *((_OWORD *)v68 - 1);
              v68 -= 2;
              *((_OWORD *)v65 - 1) = v69;
              v65 -= 2;
              *int v68 = 0;
              v68[1] = 0;
            }
            while (v68 != v67);
            int v68 = *(void **)(v45 + 384);
            unsigned int v70 = *(void **)(v45 + 392);
            *(void *)(v45 + 384) = v65;
            *(void *)(v45 + 392) = v58;
            *(void *)(v45 + 400) = v66;
            while (v70 != v68)
            {
              unsigned __int16 v71 = (std::__shared_weak_count *)*(v70 - 1);
              if (v71) {
                std::__shared_weak_count::__release_shared[abi:ne180100](v71);
              }
              v70 -= 2;
            }
          }
          if (v68) {
            operator delete(v68);
          }
        }
        else
        {
          void *v56 = v51;
          v56[1] = v50;
          atomic_fetch_add_explicit(v50 + 1, 1uLL, memory_order_relaxed);
          uint64_t v58 = v56 + 2;
        }
        *(void *)(v45 + 392) = v58;
        std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v50);
        unsigned int v47 = *(uint64_t **)(*(void *)(v45 + 392) - 16);
        unint64_t v48 = v47[1];
      }
      unint64_t v77 = v47[2];
      if (v48 >= v77)
      {
        unint64_t v79 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v48 - *v47) >> 3);
        unint64_t v80 = v79 + 1;
        if (v79 + 1 > 0x666666666666666) {
          std::vector<double>::__throw_length_error[abi:ne180100]();
        }
        unint64_t v81 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v77 - *v47) >> 3);
        if (2 * v81 > v80) {
          unint64_t v80 = 2 * v81;
        }
        if (v81 >= 0x333333333333333) {
          uint64_t v82 = 0x666666666666666;
        }
        else {
          uint64_t v82 = v80;
        }
        __int32 v99 = v47 + 3;
        if (v82)
        {
          uint64_t v83 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v47[3] + 16))(v47[3], 40 * v82, 8);
          uint64_t v84 = v83 + 40 * v79;
          *(void *)float buf = v83;
          *(void *)&uint8_t buf[8] = v84;
          *(void *)&unsigned char buf[24] = v83 + 40 * v82;
          if (v83)
          {
            *(void *)uint64_t v84 = v23;
            *(void *)(v84 + 8) = v87;
            *(void *)(v84 + 16) = v87;
            *(void *)(v84 + 24) = v17;
            uint64_t v89 = 0;
            uint64_t v90 = 0;
            uint64_t v91 = 0;
            *(float *)(v83 + 40 * v79 + 32) = v24;
            uint64_t v87 = 0;
            uint64_t v23 = 0;
          }
        }
        else
        {
          uint64_t v84 = 40 * v79;
          *(void *)float buf = 0;
          *(void *)&uint8_t buf[8] = 40 * v79;
          *(void *)&unsigned char buf[24] = 0;
        }
        *(void *)&buf[16] = v84 + 40;
        std::vector<gss::DashPattern,geo::StdAllocator<gss::DashPattern,gss::Allocator>>::__swap_out_circular_buffer(v47, buf);
        uint64_t v78 = v47[1];
        std::__split_buffer<gss::DashPattern,geo::StdAllocator<gss::DashPattern,gss::Allocator> &>::~__split_buffer((uint64_t)buf);
      }
      else
      {
        if (v48)
        {
          *(void *)unint64_t v48 = v23;
          *(void *)(v48 + 8) = v87;
          *(void *)(v48 + 16) = v87;
          *(void *)(v48 + 24) = v17;
          uint64_t v89 = 0;
          uint64_t v90 = 0;
          uint64_t v91 = 0;
          *(float *)(v48 + 32) = v24;
          uint64_t v87 = 0;
          uint64_t v23 = 0;
        }
        uint64_t v78 = v48 + 40;
      }
      v47[1] = v78;
      uint64_t v85 = geo::intern_linear_map<gss::PropertyID,gss::StylePropertySetInternObject,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 64, &v88);
      *(unsigned char *)uint64_t v85 = 2;
      *(void *)(v85 + 8) = v78 - 40;
      uint64_t v15 = 1;
    }
    if (v23)
    {
      uint64_t v90 = v23;
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v17 + 40))(v17, v23, v87 - v23);
      unint64_t v13 = v94;
    }
  }
LABEL_82:
  if (!v13) {
    return v15;
  }
LABEL_83:
  int v95 = v13;
  (*(void (**)(uint64_t, gss::Allocator *, int64_t))(*(void *)v97 + 40))(v97, v13, v96 - (char *)v13);
  return v15;
}

void sub_1A1820BD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  gss::DashPattern::~DashPattern((gss::DashPattern *)va);
  geo::linear_map<gss::StylePropertyIndex,gss::PropertyID,std::equal_to<gss::StylePropertyIndex>,geo::StdAllocator<std::pair<gss::StylePropertyIndex,gss::PropertyID>,gss::Allocator>,std::vector<std::pair<gss::StylePropertyIndex,gss::PropertyID>,geo::StdAllocator<std::pair<gss::StylePropertyIndex,gss::PropertyID>,gss::Allocator>>>::~linear_map((uint64_t *)va1);
  _Unwind_Resume(a1);
}

uint64_t gss::uint64Decoder<gss::PropertyID>(uint64_t *a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v33 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 64)
  {
    *(void *)float buf = 0;
    unint64_t v12 = a1[1];
    uint64_t v13 = a1[2];
    char v14 = *((unsigned char *)a1 + 24);
    unint64_t v15 = v13 + 9;
    if (!v14) {
      unint64_t v15 = v13 + 8;
    }
    if (v12 >= v15)
    {
      uint64_t v26 = *a1;
      if (*((unsigned char *)a1 + 24))
      {
        uint64_t v27 = 0;
        uint64_t v28 = v26 + v13;
        uint64_t v29 = v13 + 1;
        do
        {
          if (v29 + v27 >= v12) {
            int v30 = 0;
          }
          else {
            int v30 = *(unsigned __int8 *)(v28 + v27 + 1);
          }
          unsigned int v31 = ((v30 & (0xFFFF << (8 - v14))) >> (8 - v14)) | ((((1 << (8 - v14)) + 255) & *(unsigned __int8 *)(v28 + v27)) << v14);
          a1[2] = v29 + v27;
          buf[v27++] = v31;
        }
        while (v27 != 8);
        uint64_t v32 = *(void *)buf;
      }
      else
      {
        uint64_t v32 = *(void *)(v26 + v13);
        a1[2] = v13 + 8;
      }
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&buf[4]);
      *(void *)geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 48, &v33) = v32;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    uint64_t v16 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v35 = 1024;
      int v36 = 514;
      __int16 v37 = 2082;
      uint64_t v38 = "Could not read uint64 property";
      _os_log_impl(&dword_1A1780000, v16, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)":", 1);
    uint64_t v18 = (void *)std::ostream::operator<<();
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned int v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Could not read uint64 property", 30);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v21 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      *(void *)&uint8_t buf[4] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v35 = 1024;
      int v36 = 513;
      __int16 v37 = 2082;
      uint64_t v38 = "Found uint64 property with a strange number of bits.";
      _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)":", 1);
    uint64_t v23 = (void *)std::ostream::operator<<();
    float v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"Found uint64 property with a strange number of bits.", 52);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::labelLayoutStyleDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 0x13u, a4, a6);
}

uint64_t gss::fixedPoint6_2Decoder<gss::PropertyID>(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v28 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 8)
  {
    unint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = *(void *)(a1 + 16);
    unint64_t v14 = v13 + 2;
    if (!*(unsigned char *)(a1 + 24)) {
      unint64_t v14 = v13 + 1;
    }
    if (v12 >= v14)
    {
      unint64_t v25 = v13 + 1;
      unsigned int v26 = *(unsigned __int8 *)(*(void *)a1 + v13);
      if (*(unsigned char *)(a1 + 24))
      {
        if (v25 >= v12) {
          int v27 = 0;
        }
        else {
          int v27 = *(unsigned __int8 *)(*(void *)a1 + v25);
        }
        unsigned int v26 = ((v27 & (0xFFFF << (8 - *(unsigned char *)(a1 + 24)))) >> (8 - *(unsigned char *)(a1 + 24))) | ((((1 << (8 - *(unsigned char *)(a1 + 24))) - 1) & v26) << *(unsigned char *)(a1 + 24));
      }
      *(void *)(a1 + 16) = v25;
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v30);
      *(float *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, &v28) = (float)v26 * 0.25;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v15 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 380;
      __int16 v33 = 2082;
      uint64_t v34 = "Could not read fixed point 6.2.";
      _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)":", 1);
    uint64_t v17 = (void *)std::ostream::operator<<();
    uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"Could not read fixed point 6.2.", 31);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unsigned int v20 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 379;
      __int16 v33 = 2082;
      uint64_t v34 = "Found fixed point 6.2 property with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v20, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)":", 1);
    unint64_t v22 = (void *)std::ostream::operator<<();
    uint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" STYL Parse Error Here: ", 24);
    float v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"Found fixed point 6.2 property with strange number of bits.", 59);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::fixedPoint12_4Decoder<gss::PropertyID>(uint64_t *a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v34 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 16)
  {
    *(_WORD *)float buf = 0;
    unint64_t v12 = a1[1];
    uint64_t v13 = a1[2];
    char v14 = *((unsigned char *)a1 + 24);
    unint64_t v15 = v13 + 3;
    if (!v14) {
      unint64_t v15 = v13 + 2;
    }
    if (v12 >= v15)
    {
      uint64_t v26 = *a1;
      if (*((unsigned char *)a1 + 24))
      {
        char v27 = 0;
        uint64_t v28 = 0;
        do
        {
          char v29 = v27;
          uint64_t v30 = v13 + 1;
          if (v13 + 1 >= v12) {
            int v31 = 0;
          }
          else {
            int v31 = *(unsigned __int8 *)(v26 + v13 + 1);
          }
          uint8_t v32 = ((v31 & (0xFFFF << (8 - v14))) >> (8 - v14)) | ((((1 << (8 - v14)) + 255) & *(unsigned __int8 *)(v26 + v13)) << v14);
          a1[2] = v30;
          buf[v28] = v32;
          char v27 = 1;
          uint64_t v13 = v30;
          uint64_t v28 = 1;
        }
        while ((v29 & 1) == 0);
        unsigned int v33 = *(unsigned __int16 *)buf;
      }
      else
      {
        unsigned int v33 = *(unsigned __int16 *)(v26 + v13);
        a1[2] = v13 + 2;
      }
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v36);
      *(float *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, &v34) = (float)v33 * 0.0625;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    uint64_t v16 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v36 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v37 = 1024;
      int v38 = 424;
      __int16 v39 = 2082;
      int v40 = "Could not read fixed point 12.4.";
      _os_log_impl(&dword_1A1780000, v16, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)":", 1);
    uint64_t v18 = (void *)std::ostream::operator<<();
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned int v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Could not read fixed point 12.4.", 32);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v21 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v36 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v37 = 1024;
      int v38 = 423;
      __int16 v39 = 2082;
      int v40 = "Found fixed point 12.4 property with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)":", 1);
    uint64_t v23 = (void *)std::ostream::operator<<();
    float v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"Found fixed point 12.4 property with strange number of bits.", 60);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::labelIconStyleDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 0xBu, a4, a6);
}

uint64_t gss::labelMeshPositioningModeDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 7u, a4, a6);
}

uint64_t gss::int32Decoder<gss::PropertyID>(uint64_t *a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v33 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 32)
  {
    *(_DWORD *)float buf = 0;
    unint64_t v12 = a1[1];
    uint64_t v13 = a1[2];
    char v14 = *((unsigned char *)a1 + 24);
    unint64_t v15 = v13 + 5;
    if (!v14) {
      unint64_t v15 = v13 + 4;
    }
    if (v12 >= v15)
    {
      uint64_t v26 = *a1;
      if (*((unsigned char *)a1 + 24))
      {
        uint64_t v27 = 0;
        uint64_t v28 = v26 + v13;
        uint64_t v29 = v13 + 1;
        do
        {
          if (v29 + v27 >= v12) {
            int v30 = 0;
          }
          else {
            int v30 = *(unsigned __int8 *)(v28 + v27 + 1);
          }
          unsigned int v31 = ((v30 & (0xFFFF << (8 - v14))) >> (8 - v14)) | ((((1 << (8 - v14)) + 255) & *(unsigned __int8 *)(v28 + v27)) << v14);
          a1[2] = v29 + v27;
          buf[v27++] = v31;
        }
        while (v27 != 4);
        int v32 = *(_DWORD *)buf;
      }
      else
      {
        int v32 = *(_DWORD *)(v26 + v13);
        a1[2] = v13 + 4;
      }
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v35);
      *(_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, &v33) = v32;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    uint64_t v16 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      uint64_t v35 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v36 = 1024;
      int v37 = 121;
      __int16 v38 = 2082;
      __int16 v39 = "Could not read int32.";
      _os_log_impl(&dword_1A1780000, v16, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)":", 1);
    uint64_t v18 = (void *)std::ostream::operator<<();
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned int v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Could not read int32.", 21);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v21 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      uint64_t v35 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v36 = 1024;
      int v37 = 120;
      __int16 v38 = 2082;
      __int16 v39 = "Found int32 property with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)":", 1);
    uint64_t v23 = (void *)std::ostream::operator<<();
    float v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"Found int32 property with strange number of bits.", 49);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::labelColorSourceDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 6u, a4, a6);
}

uint64_t gss::labelOccludedAppearanceDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 4u, a4, a6);
}

uint64_t gss::fixedPoint0to2_55Decoder<gss::PropertyID>(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v28 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 8)
  {
    unint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = *(void *)(a1 + 16);
    unint64_t v14 = v13 + 2;
    if (!*(unsigned char *)(a1 + 24)) {
      unint64_t v14 = v13 + 1;
    }
    if (v12 >= v14)
    {
      unint64_t v25 = v13 + 1;
      unsigned int v26 = *(unsigned __int8 *)(*(void *)a1 + v13);
      if (*(unsigned char *)(a1 + 24))
      {
        if (v25 >= v12) {
          int v27 = 0;
        }
        else {
          int v27 = *(unsigned __int8 *)(*(void *)a1 + v25);
        }
        unsigned int v26 = ((v27 & (0xFFFF << (8 - *(unsigned char *)(a1 + 24)))) >> (8 - *(unsigned char *)(a1 + 24))) | ((((1 << (8 - *(unsigned char *)(a1 + 24))) - 1) & v26) << *(unsigned char *)(a1 + 24));
      }
      *(void *)(a1 + 16) = v25;
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v30);
      *(float *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, &v28) = (float)v26 / 100.0;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v15 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 358;
      __int16 v33 = 2082;
      unsigned __int16 v34 = "Could not read fixed point 0 to 2.55.";
      _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)":", 1);
    uint64_t v17 = (void *)std::ostream::operator<<();
    uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"Could not read fixed point 0 to 2.55.", 37);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unsigned int v20 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 357;
      __int16 v33 = 2082;
      unsigned __int16 v34 = "Found fixed point 0 to 2.55 property with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v20, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)":", 1);
    unint64_t v22 = (void *)std::ostream::operator<<();
    uint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" STYL Parse Error Here: ", 24);
    float v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"Found fixed point 0 to 2.55 property with strange number of bits.", 65);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::fixedPoint5_3Decoder<gss::PropertyID>(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v28 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 8)
  {
    unint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = *(void *)(a1 + 16);
    unint64_t v14 = v13 + 2;
    if (!*(unsigned char *)(a1 + 24)) {
      unint64_t v14 = v13 + 1;
    }
    if (v12 >= v14)
    {
      unint64_t v25 = v13 + 1;
      unsigned int v26 = *(unsigned __int8 *)(*(void *)a1 + v13);
      if (*(unsigned char *)(a1 + 24))
      {
        if (v25 >= v12) {
          int v27 = 0;
        }
        else {
          int v27 = *(unsigned __int8 *)(*(void *)a1 + v25);
        }
        unsigned int v26 = ((v27 & (0xFFFF << (8 - *(unsigned char *)(a1 + 24)))) >> (8 - *(unsigned char *)(a1 + 24))) | ((((1 << (8 - *(unsigned char *)(a1 + 24))) - 1) & v26) << *(unsigned char *)(a1 + 24));
      }
      *(void *)(a1 + 16) = v25;
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v30);
      *(float *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, &v28) = (float)v26 * 0.125;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v15 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 270;
      __int16 v33 = 2082;
      unsigned __int16 v34 = "Could not read fixed point 5.3.";
      _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)":", 1);
    uint64_t v17 = (void *)std::ostream::operator<<();
    uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"Could not read fixed point 5.3.", 31);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unsigned int v20 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 269;
      __int16 v33 = 2082;
      unsigned __int16 v34 = "Found fixed point 5.3 property with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v20, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)":", 1);
    unint64_t v22 = (void *)std::ostream::operator<<();
    uint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" STYL Parse Error Here: ", 24);
    float v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"Found fixed point 5.3 property with strange number of bits.", 59);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::labelTextSourceDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 0xBu, a4, a6);
}

uint64_t gss::strokePositionDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 2u, a4, a6);
}

uint64_t gss::floatPairDecoder<gss::PropertyID>(uint64_t *a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v49 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 != 64)
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v22 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      uint64_t v51 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v52 = 1024;
      int v53 = 444;
      __int16 v54 = 2082;
      atomic_ullong v55 = "Found float pair property with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v22, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)":", 1);
    float v24 = (void *)std::ostream::operator<<();
    unint64_t v25 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned int v26 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v25, (uint64_t)"Found float pair property with strange number of bits.", 54);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v26, (uint64_t)"\n", 1);
    return 0;
  }
  *(_DWORD *)float buf = 0;
  unint64_t v12 = a1[1];
  uint64_t v13 = a1[2];
  uint64_t v14 = v13 + 4;
  char v15 = *((unsigned char *)a1 + 24);
  unint64_t v16 = v13 + 5;
  if (!v15) {
    unint64_t v16 = v13 + 4;
  }
  if (v12 >= v16)
  {
    uint64_t v27 = *a1;
    if (*((unsigned char *)a1 + 24))
    {
      uint64_t v28 = 0;
      char v29 = 8 - v15;
      int v30 = 0xFFFF << (8 - v15);
      uint64_t v31 = v27 + v13;
      do
      {
        unint64_t v32 = v13 + v28 + 1;
        if (v32 >= v12) {
          int v33 = 0;
        }
        else {
          int v33 = *(unsigned __int8 *)(v31 + v28 + 1);
        }
        unsigned int v34 = ((v33 & v30) >> v29) | ((((1 << (8 - v15)) - 1) & *(unsigned char *)(v31 + v28)) << v15);
        a1[2] = v32;
        buf[v28++] = v34;
      }
      while (v28 != 4);
      int v35 = *(_DWORD *)buf;
      *(_DWORD *)float buf = 0;
      uint64_t v36 = v13 + 4;
      if (v12 >= v36 + 5)
      {
        uint64_t v37 = 0;
        uint64_t v38 = v36 + v27;
        do
        {
          unint64_t v39 = v36 + v37 + 1;
          if (v39 >= v12) {
            int v40 = 0;
          }
          else {
            int v40 = *(unsigned __int8 *)(v38 + v37 + 1);
          }
          unsigned int v41 = ((v40 & v30) >> v29) | ((((1 << (8 - v15)) - 1) & *(unsigned char *)(v38 + v37)) << v15);
          a1[2] = v39;
          buf[v37++] = v41;
        }
        while (v37 != 4);
        int v42 = *(_DWORD *)buf;
        goto LABEL_38;
      }
    }
    else
    {
      int v35 = *(_DWORD *)(v27 + v13);
      a1[2] = v14;
      if (v12 >= v13 + 8 + (unint64_t)(v15 != 0))
      {
        int v42 = *(_DWORD *)(v27 + v14);
        a1[2] = v13 + 8;
LABEL_38:
        *(_WORD *)float buf = v10;
        buf[2] = 0;
        geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v51);
        unint64_t v48 = (_DWORD *)geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 48, &v49);
        _DWORD *v48 = v35;
        v48[1] = v42;
        return 1;
      }
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    uint64_t v43 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      uint64_t v51 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v52 = 1024;
      int v53 = 446;
      __int16 v54 = 2082;
      atomic_ullong v55 = "Could not read second half of float pair.";
      _os_log_impl(&dword_1A1780000, v43, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unsigned __int16 v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)":", 1);
    uint64_t v45 = (void *)std::ostream::operator<<();
    uint64_t v46 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned int v47 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v46, (uint64_t)"Could not read second half of float pair.", 41);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v47, (uint64_t)"\n", 1);
    return 0;
  }
  if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
    dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
  }
  uint64_t v17 = GEOGetGeoCSSStyleSheetLog_log;
  if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)float buf = 136315650;
    uint64_t v51 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
    __int16 v52 = 1024;
    int v53 = 445;
    __int16 v54 = 2082;
    atomic_ullong v55 = "Could not read first half of float pair.";
    _os_log_impl(&dword_1A1780000, v17, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
  }
  uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)":", 1);
  unint64_t v19 = (void *)std::ostream::operator<<();
  unsigned int v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" STYL Parse Error Here: ", 24);
  unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"Could not read first half of float pair.", 40);
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"\n", 1);
  return 0;
}

uint64_t gss::polygonPlacementDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 2u, a4, a6);
}

uint64_t gss::externalFeatureCategoryDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 3u, a4, a6);
}

uint64_t gss::grlVariantDEPRECATEDDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 0xBu, a4, a6);
}

uint64_t gss::labelShieldVariantDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 2u, a4, a6);
}

uint64_t gss::balloonBehaviorDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 2u, a4, a6);
}

uint64_t gss::labelCollisionOverlayGroupDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 4u, a4, a6);
}

uint64_t gss::iconGradientDecoder<gss::PropertyID>(uint64_t *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (a3 != 64)
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    uint64_t v17 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      uint64_t v62 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      *(_WORD *)unint64_t v63 = 1024;
      *(_DWORD *)&v63[2] = 461;
      __int16 v64 = 2082;
      uint64_t v65 = "Found color gradient with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v17, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)":", 1);
    unint64_t v19 = (void *)std::ostream::operator<<();
    unsigned int v20 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v20, (uint64_t)"Found color gradient with strange number of bits.", 49);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)"\n", 1);
    return 0;
  }
  *(_DWORD *)float buf = 0;
  unint64_t v7 = a1[1];
  uint64_t v8 = a1[2];
  uint64_t v9 = v8 + 4;
  char v10 = *((unsigned char *)a1 + 24);
  unint64_t v11 = v8 + 5;
  if (!v10) {
    unint64_t v11 = v8 + 4;
  }
  if (v7 < v11)
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unint64_t v12 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      uint64_t v62 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      *(_WORD *)unint64_t v63 = 1024;
      *(_DWORD *)&v63[2] = 462;
      __int16 v64 = 2082;
      uint64_t v65 = "Could not read first half of color gradient.";
      _os_log_impl(&dword_1A1780000, v12, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    uint64_t v13 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v13, (uint64_t)":", 1);
    uint64_t v14 = (void *)std::ostream::operator<<();
    char v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v14, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)"Could not read first half of color gradient.", 44);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)"\n", 1);
    return 0;
  }
  uint64_t v24 = *a1;
  if (*((unsigned char *)a1 + 24))
  {
    uint64_t v25 = 0;
    char v26 = 8 - v10;
    int v27 = 0xFFFF << (8 - v10);
    uint64_t v28 = v24 + v8;
    do
    {
      unint64_t v29 = v8 + v25 + 1;
      if (v29 >= v7) {
        int v30 = 0;
      }
      else {
        int v30 = *(unsigned __int8 *)(v28 + v25 + 1);
      }
      unsigned int v31 = ((v30 & v27) >> v26) | ((((1 << (8 - v10)) - 1) & *(unsigned char *)(v28 + v25)) << v10);
      a1[2] = v29;
      buf[v25++] = v31;
    }
    while (v25 != 4);
    unsigned int v32 = *(_DWORD *)buf;
    *(_DWORD *)float buf = 0;
    uint64_t v33 = v8 + 4;
    if (v7 >= v33 + 5)
    {
      uint64_t v34 = 0;
      uint64_t v35 = v33 + v24;
      do
      {
        unint64_t v36 = v33 + v34 + 1;
        if (v36 >= v7) {
          int v37 = 0;
        }
        else {
          int v37 = *(unsigned __int8 *)(v35 + v34 + 1);
        }
        unsigned int v38 = ((v37 & v27) >> v26) | ((((1 << (8 - v10)) - 1) & *(unsigned char *)(v35 + v34)) << v10);
        a1[2] = v36;
        buf[v34++] = v38;
      }
      while (v34 != 4);
      unsigned int v39 = *(_DWORD *)buf;
      goto LABEL_36;
    }
LABEL_30:
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    int v40 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      uint64_t v62 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      *(_WORD *)unint64_t v63 = 1024;
      *(_DWORD *)&v63[2] = 463;
      __int16 v64 = 2082;
      uint64_t v65 = "Could not read second half of color gradient.";
      _os_log_impl(&dword_1A1780000, v40, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unsigned int v41 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)":", 1);
    int v42 = (void *)std::ostream::operator<<();
    uint64_t v43 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)" STYL Parse Error Here: ", 24);
    unsigned __int16 v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v43, (uint64_t)"Could not read second half of color gradient.", 45);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)"\n", 1);
    return 0;
  }
  unsigned int v32 = *(_DWORD *)(v24 + v8);
  a1[2] = v9;
  if (v7 < v8 + 8 + (unint64_t)(v10 != 0)) {
    goto LABEL_30;
  }
  unsigned int v39 = *(_DWORD *)(v24 + v9);
  a1[2] = v8 + 8;
LABEL_36:
  *(_WORD *)float buf = 4;
  buf[2] = 0;
  geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v62);
  *(_WORD *)float buf = 5;
  buf[2] = 0;
  geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v62);
  unsigned int v45 = bswap32(v32);
  float v57 = (float)v45 / 255.0;
  float32x2_t v58 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v45), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL)), (float32x2_t)vdup_n_s32(0x437F0000u));
  float v59 = (float)HIBYTE(v45) / 255.0;
  *(_DWORD *)float buf = geo::colorTransform<geo::ReverseGammaCorrection>(geo::reverseSRGBGammaCorrection, &v57);
  uint64_t v62 = (const char *)__PAIR64__(v47, v46);
  *(_DWORD *)unint64_t v63 = v48;
  geo::_wordColor<float,4,(geo::ColorSpace)0>((float32x4_t *)buf, &v60);
  int16x4_t v49 = v60;
  unint64_t v50 = a2 + 48;
  *(_WORD *)float buf = 4;
  uint64_t v51 = (void *)geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 48, (unsigned __int16 *)buf);
  unsigned int v52 = bswap32(v39);
  void *v51 = v49;
  float v57 = (float)v52 / 255.0;
  float32x2_t v58 = vdiv_f32(vcvt_f32_u32((uint32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(v52), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL)), (float32x2_t)vdup_n_s32(0x437F0000u));
  float v59 = (float)HIBYTE(v52) / 255.0;
  *(_DWORD *)float buf = geo::colorTransform<geo::ReverseGammaCorrection>(geo::reverseSRGBGammaCorrection, &v57);
  uint64_t v62 = (const char *)__PAIR64__(v54, v53);
  *(_DWORD *)unint64_t v63 = v55;
  geo::_wordColor<float,4,(geo::ColorSpace)0>((float32x4_t *)buf, &v60);
  int16x4_t v56 = v60;
  *(_WORD *)float buf = 5;
  *(int16x4_t *)geo::intern_linear_map<gss::PropertyID,unsigned long long,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](v50, (unsigned __int16 *)buf) = v56;
  return 1;
}

uint64_t gss::uint8Decoder<gss::PropertyID>(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v28 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 8)
  {
    unint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = *(void *)(a1 + 16);
    unint64_t v14 = v13 + 2;
    if (!*(unsigned char *)(a1 + 24)) {
      unint64_t v14 = v13 + 1;
    }
    if (v12 >= v14)
    {
      unint64_t v25 = v13 + 1;
      unsigned int v26 = *(unsigned __int8 *)(*(void *)a1 + v13);
      if (*(unsigned char *)(a1 + 24))
      {
        if (v25 >= v12) {
          int v27 = 0;
        }
        else {
          int v27 = *(unsigned __int8 *)(*(void *)a1 + v25);
        }
        unsigned int v26 = ((v27 & (0xFFFF << (8 - *(unsigned char *)(a1 + 24)))) >> (8 - *(unsigned char *)(a1 + 24))) | ((((1 << (8 - *(unsigned char *)(a1 + 24))) - 1) & v26) << *(unsigned char *)(a1 + 24));
      }
      *(void *)(a1 + 16) = v25;
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v30);
      *(unsigned char *)geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 16, &v28) = v26;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    char v15 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 141;
      __int16 v33 = 2082;
      uint64_t v34 = "Could not read uint8.";
      _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)":", 1);
    uint64_t v17 = (void *)std::ostream::operator<<();
    uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"Could not read uint8.", 21);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unsigned int v20 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 140;
      __int16 v33 = 2082;
      uint64_t v34 = "Found uint8 property with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v20, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)":", 1);
    unint64_t v22 = (void *)std::ostream::operator<<();
    uint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"Found uint8 property with strange number of bits.", 49);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::labelTextPlacementSourceDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 1u, a4, a6);
}

uint64_t gss::labelPositionAnchorDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 2u, a4, a6);
}

uint64_t gss::labelIconGlyphStyleDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 3u, a4, a6);
}

uint64_t gss::labelPerspectiveScalingModeDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 3u, a4, a6);
}

uint64_t *std::vector<gss::DashPattern,geo::StdAllocator<gss::DashPattern,gss::Allocator>>::__swap_out_circular_buffer(uint64_t *result, void *a2)
{
  uint64_t v3 = *result;
  uint64_t v2 = result[1];
  uint64_t v4 = a2[1];
  if (v2 != *result)
  {
    uint64_t v5 = 0;
    do
    {
      uint64_t v6 = v4 + v5;
      uint64_t v7 = v2 + v5;
      *(void *)(v6 - 40) = 0;
      *(void *)(v6 - 32) = 0;
      *(void *)(v6 - 24) = 0;
      *(void *)(v6 - 16) = *(void *)(v2 + v5 - 16);
      *(_OWORD *)(v6 - 40) = *(_OWORD *)(v2 + v5 - 40);
      *(void *)(v6 - 24) = *(void *)(v2 + v5 - 24);
      *(void *)(v7 - 40) = 0;
      *(void *)(v7 - 32) = 0;
      *(void *)(v7 - 24) = 0;
      *(_DWORD *)(v6 - 8) = *(_DWORD *)(v2 + v5 - 8);
      v5 -= 40;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  uint64_t v8 = *result;
  uint64_t *result = v4;
  a2[1] = v8;
  uint64_t v9 = result[1];
  result[1] = a2[2];
  a2[2] = v9;
  uint64_t v10 = result[2];
  result[2] = a2[3];
  a2[3] = v10;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<gss::DashPattern,geo::StdAllocator<gss::DashPattern,gss::Allocator> &>::~__split_buffer(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  while (v2 != v3)
  {
    uint64_t v4 = *(void *)(v2 - 40);
    *(void *)(a1 + 16) = v2 - 40;
    if (v4)
    {
      *(void *)(v2 - 32) = v4;
      std::allocator_traits<geo::StdAllocator<float,gss::Allocator>>::deallocate[abi:ne180100]((void *)(v2 - 16), v4, (*(void *)(v2 - 24) - v4) >> 2);
      uint64_t v2 = *(void *)(a1 + 16);
    }
    else
    {
      v2 -= 40;
    }
  }
  if (*(void *)a1) {
    (*(void (**)(void, void, void))(***(void ***)(a1 + 32) + 40))(**(void **)(a1 + 32), *(void *)a1, *(void *)(a1 + 24) - *(void *)a1);
  }
  return a1;
}

uint64_t gss::labelAnnotationLayoutDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 6u, a4, a6);
}

uint64_t gss::labelPositioningModeDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 5u, a4, a6);
}

uint64_t gss::labelOrientationDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 0x20u, a4, a6);
}

uint64_t gss::fixedPoint8_0Decoder<gss::PropertyID>(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, void *a6)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  int v10 = gss::idForIndex<gss::PropertyID>(a4);
  unsigned __int16 v28 = v10;
  if (v10 == 482) {
    return 1;
  }
  if (a3 == 8)
  {
    unint64_t v12 = *(void *)(a1 + 8);
    uint64_t v13 = *(void *)(a1 + 16);
    unint64_t v14 = v13 + 2;
    if (!*(unsigned char *)(a1 + 24)) {
      unint64_t v14 = v13 + 1;
    }
    if (v12 >= v14)
    {
      unint64_t v25 = v13 + 1;
      unsigned int v26 = *(unsigned __int8 *)(*(void *)a1 + v13);
      if (*(unsigned char *)(a1 + 24))
      {
        if (v25 >= v12) {
          int v27 = 0;
        }
        else {
          int v27 = *(unsigned __int8 *)(*(void *)a1 + v25);
        }
        unsigned int v26 = ((v27 & (0xFFFF << (8 - *(unsigned char *)(a1 + 24)))) >> (8 - *(unsigned char *)(a1 + 24))) | ((((1 << (8 - *(unsigned char *)(a1 + 24))) - 1) & v26) << *(unsigned char *)(a1 + 24));
      }
      *(void *)(a1 + 16) = v25;
      *(_WORD *)float buf = v10;
      buf[2] = 0;
      geo::intern_linear_map<gss::PropertyID,unsigned char,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::insert<std::pair<gss::PropertyID const,unsigned char> const*>(a2, (uint64_t)buf, (uint64_t)&v30);
      *(float *)geo::intern_linear_map<gss::PropertyID,unsigned int,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[](a2 + 32, &v28) = (float)v26;
      return 1;
    }
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    char v15 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 292;
      __int16 v33 = 2082;
      uint64_t v34 = "Could not read fixed point 8.0.";
      _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v16 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v16, (uint64_t)":", 1);
    uint64_t v17 = (void *)std::ostream::operator<<();
    uint64_t v18 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)" STYL Parse Error Here: ", 24);
    unint64_t v19 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v18, (uint64_t)"Could not read fixed point 8.0.", 31);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"\n", 1);
  }
  else
  {
    if (GEOGetGeoCSSStyleSheetLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoCSSStyleSheetLog_onceToken, &__block_literal_global);
    }
    unsigned int v20 = GEOGetGeoCSSStyleSheetLog_log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoCSSStyleSheetLog_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 136315650;
      int v30 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp";
      __int16 v31 = 1024;
      int v32 = 291;
      __int16 v33 = 2082;
      uint64_t v34 = "Found fixed point 8.0 property with strange number of bits.";
      _os_log_impl(&dword_1A1780000, v20, OS_LOG_TYPE_ERROR, "%s:%d STYL Parse Error Here: %{public}s", buf, 0x1Cu);
    }
    unint64_t v21 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoCSS/GeoCSS/StylePropertySet.cpp", 86);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v21, (uint64_t)":", 1);
    unint64_t v22 = (void *)std::ostream::operator<<();
    uint64_t v23 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v22, (uint64_t)" STYL Parse Error Here: ", 24);
    uint64_t v24 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v23, (uint64_t)"Found fixed point 8.0 property with strange number of bits.", 59);
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v24, (uint64_t)"\n", 1);
  }
  return 0;
}

uint64_t gss::occlusionVisibilityDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 1u, a4, a6);
}

uint64_t gss::maneuverDisplayModeDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 2u, a4, a6);
}

uint64_t gss::occlusionBehaviorDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 2u, a4, a6);
}

void std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#1},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#1}>,void ()(BOOL)>::operator()(uint64_t a1, unsigned __int8 *a2)
{
}

void std::__function::__func<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#2},std::allocator<gss::StyleSheet<gss::PropertyID>::construct(unsigned char const*,unsigned long,std::string const&,float,gss::TargetDisplay,BOOL,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,std::shared_ptr<std::unordered_map<std::string,int,std::hash<std::string>,std::equal_to<std::string>,geo::StdAllocator<std::pair<std::string const,int>,gss::Allocator>>> const&,BOOL,BOOL,std::function<void ()(BOOL)>)::{lambda(void)#1}::operator() const(void)::{lambda(BOOL)#2}>,void ()(BOOL)>::operator()(void *a1, unsigned __int8 *a2)
{
}

uint64_t gss::genericShieldStyleDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 5u, a4, a6);
}

uint64_t gss::labelImageSourceDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 7u, a4, a6);
}

uint64_t gss::linePlacementDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 1u, a4, a6);
}

uint64_t gss::fillPositionDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 1u, a4, a6);
}

uint64_t gss::buildingRoofDecoder<gss::PropertyID>(uint64_t a1, unint64_t a2, unsigned __int8 a3, unsigned int a4, uint64_t a5, void *a6)
{
  return gss::enumDecoder<gss::PropertyID>(a1, a2, a3, 1u, a4, a6);
}

void md::OverlaysLogic::reset(md::OverlaysLogic *this)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 93);
  if (v2)
  {
    v21[0] = &unk_1EF570458;
    unint64_t v22 = v21;
    geo::TaskQueue::barrierSync(v2, v21);
    if (v22 == v21)
    {
      (*(void (**)(void *))(v21[0] + 32))(v21);
    }
    else if (v22)
    {
      (*(void (**)(void))(*v22 + 40))();
    }
  }
  v19[0] = &unk_1EF5704A0;
  v19[1] = this;
  unsigned int v20 = v19;
  md::OverlaysLogic::_forEachOverlayLevelAndFallback((uint64_t)v19);
  if (v20 == v19)
  {
    (*(void (**)(void *))(v19[0] + 32))(v19);
    if (!*((void *)this + 87)) {
      goto LABEL_10;
    }
  }
  else
  {
    if (v20) {
      (*(void (**)(void))(*v20 + 40))();
    }
    if (!*((void *)this + 87))
    {
LABEL_10:
      if (!*((void *)this + 78)) {
        goto LABEL_29;
      }
      goto LABEL_19;
    }
  }
  uint64_t v3 = (char *)*((void *)this + 86);
  if (v3)
  {
    do
    {
      uint64_t v4 = *(char **)v3;
      v18[0] = (void **)(v3 + 24);
      std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100](v18);
      operator delete(v3);
      uint64_t v3 = v4;
    }
    while (v4);
  }
  *((void *)this + 86) = 0;
  uint64_t v5 = *((void *)this + 85);
  if (v5)
  {
    for (uint64_t i = 0; i != v5; ++i)
      *(void *)(*((void *)this + 84) + 8 * i) = 0;
  }
  *((void *)this + 87) = 0;
  if (*((void *)this + 78))
  {
LABEL_19:
    uint64_t v7 = (void *)*((void *)this + 77);
    while (v7)
    {
      uint64_t v8 = v7;
      uint64_t v7 = (void *)*v7;
      uint64_t v9 = (std::__shared_weak_count *)v8[4];
      if (v9 && !atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
        std::__shared_weak_count::__release_weak(v9);
      }
      operator delete(v8);
    }
    *((void *)this + 77) = 0;
    uint64_t v10 = *((void *)this + 76);
    if (v10)
    {
      for (uint64_t j = 0; j != v10; ++j)
        *(void *)(*((void *)this + 75) + 8 * j) = 0;
    }
    *((void *)this + 78) = 0;
  }
LABEL_29:
  *((_DWORD *)this + 182) = 0;
  unint64_t v12 = +[VKDebugSettings sharedSettings];
  *((unsigned char *)this + 922) = [v12 daVinciUseCollisionMesh];

  uint64_t v13 = *((void *)this + 94);
  uint64_t v14 = *(void *)(v13 + 32);
  uint64_t v15 = *(void *)(v13 + 40);
  if (v14 != v15)
  {
    while (*(_WORD *)v14 != 6)
    {
      v14 += 16;
      if (v14 == v15) {
        goto LABEL_36;
      }
    }
  }
  if (v14 == v15)
  {
LABEL_36:
    LOBYTE(v18[0]) = 0;
  }
  else
  {
    (*(void (**)(void ***__return_ptr))(**(void **)(v14 + 8) + 64))(v18);
    if (LOBYTE(v18[0])) {
      *((unsigned char *)this + 924) = BYTE4(v18[0]);
    }
  }
  uint64_t v17 = (void *)*((void *)this + 21);
  unint64_t v16 = (void *)((char *)this + 168);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v17);
  *(v16 - 1) = v16;
  *unint64_t v16 = 0;
  v16[1] = 0;
}

void sub_1A1823814(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A1823828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A18238C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1823930(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1823A60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1823B84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1823C08(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1823DF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1823FF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A18240CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1824284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *md::TileSelectionLogic::configurationDidChange(md::TileSelectionLogic *this)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  int v32 = -1;
  *(void *)&long long v2 = -1;
  *((void *)&v2 + 1) = -1;
  long long v30 = v2;
  long long v31 = v2;
  uint64_t v3 = *(void *)(*((void *)this + 15) + 24);
  v28[0] = &unk_1EF574040;
  v28[1] = &v30;
  v28[2] = this;
  unint64_t v29 = v28;
  uint64_t v4 = *(__int16 **)(v3 + 8);
  uint64_t v5 = *(__int16 **)(v3 + 16);
  if (v4 == v5) {
    goto LABEL_7;
  }
  do
  {
    uint64_t v6 = *((void *)v4 + 1);
    uint64_t v7 = *((void *)v4 + 2);
    __int16 v25 = *v4;
    *(void *)float buf = v6;
    uint64_t v24 = v7;
    if (!v29) {
LABEL_58:
    }
      std::__throw_bad_function_call[abi:nn180100]();
    (*(void (**)(void *, __int16 *, uint8_t *, uint64_t *))(*v29 + 48))(v29, &v25, buf, &v24);
    v4 += 12;
  }
  while (v4 != v5);
  if (v29 == v28)
  {
LABEL_7:
    (*(void (**)(void *))(v28[0] + 32))(v28);
  }
  else if (v29)
  {
    (*(void (**)(void *))(*v29 + 40))(v29);
  }
  if (v30 == -1)
  {
    LODWORD(v30) = 256;
  }
  else
  {
    uint64_t v8 = *((void *)this + 16);
    if (v8) {
      *(_DWORD *)(v8 + 8) = v30;
    }
  }
  if (DWORD1(v30) == -1)
  {
    DWORD1(v30) = 256;
  }
  else
  {
    uint64_t v9 = *((void *)this + 17);
    if (v9) {
      *(_DWORD *)(v9 + 8) = DWORD1(v30);
    }
  }
  if (DWORD2(v30) == -1)
  {
    DWORD2(v30) = 256;
  }
  else
  {
    uint64_t v10 = *((void *)this + 18);
    if (v10) {
      *(_DWORD *)(v10 + 8) = DWORD2(v30);
    }
  }
  if (HIDWORD(v30) == -1)
  {
    HIDWORD(v30) = 256;
  }
  else
  {
    uint64_t v11 = *((void *)this + 19);
    if (v11) {
      *(_DWORD *)(v11 + 8) = HIDWORD(v30);
    }
  }
  if (v31 == -1)
  {
    LODWORD(v31) = 256;
  }
  else
  {
    uint64_t v12 = *((void *)this + 20);
    if (v12) {
      *(_DWORD *)(v12 + 8) = v31;
    }
  }
  if (DWORD1(v31) == -1)
  {
    DWORD1(v31) = 256;
  }
  else
  {
    uint64_t v13 = *((void *)this + 21);
    if (v13) {
      *(_DWORD *)(v13 + 8) = DWORD1(v31);
    }
  }
  if (DWORD2(v31) == -1)
  {
    DWORD2(v31) = 256;
  }
  else
  {
    uint64_t v14 = *((void *)this + 22);
    if (v14) {
      *(_DWORD *)(v14 + 8) = DWORD2(v31);
    }
  }
  if (HIDWORD(v31) == -1)
  {
    HIDWORD(v31) = 256;
  }
  else
  {
    uint64_t v15 = *((void *)this + 23);
    if (v15) {
      *(_DWORD *)(v15 + 8) = HIDWORD(v31);
    }
  }
  if (v32 == -1)
  {
    int v32 = 256;
  }
  else
  {
    uint64_t v16 = *((void *)this + 24);
    if (v16) {
      *(_DWORD *)(v16 + 8) = v32;
    }
  }
  *((_DWORD *)this + 78) = -1;
  v26[0] = &unk_1EF574088;
  v26[1] = this;
  v26[2] = &v30;
  int v27 = v26;
  uint64_t v18 = *(__int16 **)(v3 + 8);
  uint64_t v17 = *(__int16 **)(v3 + 16);
  if (v18 == v17) {
    goto LABEL_50;
  }
  do
  {
    uint64_t v19 = *((void *)v18 + 1);
    uint64_t v20 = *((void *)v18 + 2);
    __int16 v25 = *v18;
    *(void *)float buf = v19;
    uint64_t v24 = v20;
    if (!v27) {
      goto LABEL_58;
    }
    (*(void (**)(void *, __int16 *, uint8_t *, uint64_t *))(*v27 + 48))(v27, &v25, buf, &v24);
    v18 += 12;
  }
  while (v18 != v17);
  if (v27 == v26)
  {
LABEL_50:
    (*(void (**)(void *))(v26[0] + 32))(v26);
  }
  else if (v27)
  {
    (*(void (**)(void *))(*v27 + 40))(v27);
  }
  if (*((_DWORD *)this + 78) == -1) {
    *((_DWORD *)this + 78) = 1;
  }
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  unint64_t v21 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
  {
    int v22 = *((_DWORD *)this + 78);
    *(_DWORD *)float buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = v22;
    _os_log_impl(&dword_1A1780000, v21, OS_LOG_TYPE_DEBUG, "Min visible zoom: %d", buf, 8u);
  }

  gdc::GlobeTileSelector::purgeCache(*((void **)this + 17));
  gdc::GlobeTileSelector::purgeCache(*((void **)this + 23));
  return gdc::GlobeTileSelector::purgeCache(*((void **)this + 24));
}

void std::__function::__func<md::TileSelectionLogic::configurationDidChange(void)::$_1,std::allocator<md::TileSelectionLogic::configurationDidChange(void)::$_1>,void ()(unsigned short,gdc::LayerDataSource *,gdc::DataKeyRequester *)>::operator()(uint64_t a1, unsigned __int16 *a2, uint64_t a3, void *a4)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a2;
  uint64_t v6 = *a4;
  uint64_t v7 = *(void *)(a1 + 8);
  (*(void (**)(uint64_t *__return_ptr, void))(*(void *)*a4 + 64))(&v43, *a4);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 48))(&v41, v6);
  uint64_t v8 = *(int8x8_t **)(v7 + 120);
  int8x8_t v9 = v8[17];
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v11 = v5;
      if (*(void *)&v9 <= v5) {
        unint64_t v11 = v5 % *(void *)&v9;
      }
    }
    else
    {
      unint64_t v11 = (v9.i32[0] - 1) & v5;
    }
    uint64_t v12 = *(uint64_t ***)(*(void *)&v8[16] + 8 * v11);
    if (v12)
    {
      uint64_t v13 = *v12;
      if (v13)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v13[1];
            if (v15 == v5)
            {
              if (*((unsigned __int16 *)v13 + 8) == v5) {
                goto LABEL_68;
              }
            }
            else if ((v15 & (*(void *)&v9 - 1)) != v11)
            {
              goto LABEL_21;
            }
            uint64_t v13 = (uint64_t *)*v13;
            if (!v13) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v14 = v13[1];
          if (v14 == v5)
          {
            if (*((unsigned __int16 *)v13 + 8) == v5)
            {
LABEL_68:
              BOOL v16 = *((unsigned char *)v13 + 18) == 0;
              if (!(_BYTE)v43) {
                goto LABEL_69;
              }
              goto LABEL_22;
            }
          }
          else
          {
            if (v14 >= *(void *)&v9) {
              v14 %= *(void *)&v9;
            }
            if (v14 != v11) {
              break;
            }
          }
          uint64_t v13 = (uint64_t *)*v13;
        }
        while (v13);
      }
    }
  }
LABEL_21:
  BOOL v16 = 0;
  if (!(_BYTE)v43)
  {
LABEL_69:
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v35 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      if (v5 > 0x51) {
        unint64_t v36 = "<Invalid>";
      }
      else {
        unint64_t v36 = off_1E5A95780[v5];
      }
      int v37 = "n";
      if (v16) {
        int v37 = "y";
      }
      *(_DWORD *)float buf = 136315394;
      unsigned int v45 = v36;
      __int16 v46 = 2080;
      double v47 = *(double *)&v37;
      _os_log_impl(&dword_1A1780000, v35, OS_LOG_TYPE_DEBUG, "Skipping Layer: %s, isRequired: %s", buf, 0x16u);
    }

    return;
  }
LABEL_22:
  if ((_BYTE)v41) {
    BOOL v17 = v16;
  }
  else {
    BOOL v17 = 0;
  }
  if (!v17) {
    goto LABEL_69;
  }
  if (!*(void *)&v9) {
    goto LABEL_47;
  }
  uint8x8_t v18 = (uint8x8_t)vcnt_s8(v9);
  v18.i16[0] = vaddlv_u8(v18);
  if (v18.u32[0] > 1uLL)
  {
    unint64_t v19 = v5;
    if (*(void *)&v9 <= v5) {
      unint64_t v19 = v5 % *(void *)&v9;
    }
  }
  else
  {
    unint64_t v19 = (v9.i32[0] - 1) & v5;
  }
  uint64_t v20 = *(uint64_t ****)(*(void *)&v8[16] + 8 * v19);
  if (!v20 || (unint64_t v21 = *v20) == 0)
  {
LABEL_46:
    int8x8_t v9 = 0;
    goto LABEL_47;
  }
  if (v18.u32[0] < 2uLL)
  {
    uint64_t v22 = *(void *)&v9 - 1;
    while (1)
    {
      uint64_t v24 = v21[1];
      if (v24 == (uint64_t *)v5)
      {
        if (*((unsigned __int16 *)v21 + 8) == v5) {
          goto LABEL_79;
        }
      }
      else if (((unint64_t)v24 & v22) != v19)
      {
        goto LABEL_46;
      }
      unint64_t v21 = (uint64_t **)*v21;
      if (!v21) {
        goto LABEL_46;
      }
    }
  }
  while (1)
  {
    unint64_t v23 = (unint64_t)v21[1];
    if (v23 == v5) {
      break;
    }
    if (v23 >= *(void *)&v9) {
      v23 %= *(void *)&v9;
    }
    if (v23 != v19) {
      goto LABEL_46;
    }
LABEL_36:
    unint64_t v21 = (uint64_t **)*v21;
    if (!v21) {
      goto LABEL_46;
    }
  }
  if (*((unsigned __int16 *)v21 + 8) != v5) {
    goto LABEL_36;
  }
LABEL_79:
  int8x8_t v9 = (int8x8_t)*((unsigned __int16 *)v21 + 10);
LABEL_47:
  unsigned int v25 = HIDWORD(v43);
  unsigned int v26 = *(_DWORD *)(*(void *)(a1 + 16) + 4 * *(void *)&v9);
  (*(void (**)(uint64_t *__return_ptr, uint64_t))(*(void *)v6 + 40))(&v38, v6);
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  int v27 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    double v28 = log2((double)(v25 / v26));
    if (v5 > 0x51) {
      unint64_t v29 = "<Invalid>";
    }
    else {
      unint64_t v29 = off_1E5A95780[v5];
    }
    if ((_BYTE)v38) {
      int v30 = HIDWORD(v38);
    }
    else {
      int v30 = -1;
    }
    if (v39) {
      int v31 = v40;
    }
    else {
      int v31 = -1;
    }
    *(_DWORD *)float buf = 136316418;
    unsigned int v45 = v29;
    __int16 v46 = 2048;
    double v47 = v28;
    __int16 v48 = 1024;
    int v49 = HIDWORD(v41);
    __int16 v50 = 1024;
    int v51 = v42;
    __int16 v52 = 1024;
    int v53 = v30;
    __int16 v54 = 1024;
    int v55 = v31;
    _os_log_impl(&dword_1A1780000, v27, OS_LOG_TYPE_DEBUG, "Layer: %s Tile Adjust: %f, Download: %d, %d, Visible: %d, %d", buf, 0x2Eu);
  }

  unsigned int v32 = *(_DWORD *)(v7 + 312);
  unsigned int v33 = HIDWORD(v41);
  if ((_BYTE)v38) {
    unsigned int v34 = HIDWORD(v38);
  }
  else {
    unsigned int v34 = HIDWORD(v41);
  }
  if (HIDWORD(v41) >= v34) {
    unsigned int v33 = v34;
  }
  if (v33 < v32) {
    unsigned int v32 = v33;
  }
  *(_DWORD *)(v7 + 312) = v32;
}

void md::SingleGEOResourceDataRequester::minRequiredTileSizeForTileSet(md::SingleGEOResourceDataRequester *this@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 32))(&v11);
  if ((_BYTE)v11
    && ((*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 24))(&v10), (_BYTE)v10))
  {
    if (*((_WORD *)this + 11) == 13)
    {
      uint64_t v4 = (char *)&v10 + 4;
    }
    else if (*((unsigned char *)this + 28))
    {
      uint64_t v4 = (char *)this + 32;
    }
    else
    {
      uint64_t v4 = (char *)&v10 + 4;
    }
    unsigned int v5 = *(_DWORD *)v4;
    unsigned int v6 = HIDWORD(v11);
    BOOL v7 = HIDWORD(v10) >= v5;
    unsigned int v8 = HIDWORD(v10) - v5;
    if (v8 != 0 && v7)
    {
      double v9 = (double)HIDWORD(v11);
      unsigned int v6 = (exp2(-(double)v8) * v9);
    }
    *(unsigned char *)a2 = 1;
    *(_DWORD *)(a2 + 4) = v6;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
}

void md::SingleGEOResourceDataRequester::requestDataKeys(md::SingleGEOResourceDataRequester *this, const gdc::SelectionContext *a2, char a3)
{
  uint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    unsigned int v8 = (gdc::LayerDataCollector *)*((void *)a2 + 1);
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v5 + 32))(&v48);
    if ((_BYTE)v48)
    {
      (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 24))(&v46);
      if ((_BYTE)v46)
      {
        double v9 = (char *)&v46 + 4;
        if (*((unsigned char *)this + 28)) {
          double v9 = (char *)this + 32;
        }
        uint64_t v10 = (unsigned int *)&v47;
        if (*((unsigned char *)this + 36)) {
          uint64_t v10 = (unsigned int *)((char *)this + 40);
        }
        uint64_t v11 = (unsigned int *)*((void *)a2 + 8);
        unint64_t v12 = *v11;
        unint64_t v13 = HIDWORD(v48);
        if (v12) {
          BOOL v14 = HIDWORD(v48) == 0;
        }
        else {
          BOOL v14 = 1;
        }
        if (v14)
        {
          int v15 = 0;
        }
        else
        {
          if (HIDWORD(v48) >= v12)
          {
            int v15 = 0;
          }
          else
          {
            int v15 = 0;
            do
            {
              ++v15;
              v13 *= 2;
            }
            while (v13 < v12);
          }
          while (v13 > v12)
          {
            --v15;
            v12 *= 2;
          }
        }
        unsigned int v16 = *(_DWORD *)v9;
        unsigned int v30 = *v10;
        uint64_t v43 = 0;
        unsigned __int16 v44 = 0;
        uint64_t v45 = 0;
        BOOL v17 = (uint64_t *)*((void *)v11 + 3);
        if (v17)
        {
          int v29 = -v15 & ~(-v15 >> 31);
          do
          {
            uint64_t v18 = *((unsigned __int8 *)v17 + 17);
            int v19 = 1 << v18;
            int v20 = *((_DWORD *)v17 + 6);
            int v21 = (*((_DWORD *)v17 + 5) % v19 + v19) % v19;
            v40[0] = *((unsigned char *)v17 + 16);
            v40[1] = v18;
            int v41 = v21;
            int v42 = (v20 % v19 + v19) % v19;
            if (v18)
            {
              unsigned __int8 v22 = v18 - 1;
              if (v29 < (int)v18 - 1) {
                unsigned __int8 v22 = v29;
              }
              BOOL v23 = v18 >= v22;
              LOBYTE(v18) = v18 - v22;
              if (!v23) {
                LOBYTE(v18) = 0;
              }
            }
            if (v16 <= v18 && v30 >= v18)
            {
              unsigned __int16 v44 = v43;
              unsigned int v24 = **((_DWORD **)a2 + 8);
              (*(void (**)(void **__return_ptr))(**((void **)this + 1) + 32))(v35);
              unint64_t v3 = v3 & 0xFFFFFFFFFF000000 | *((unsigned __int16 *)this + 22) | ((unint64_t)*((unsigned __int8 *)this + 46) << 16);
              md::TileAdjustmentHelpers::adjustTileForSizeAndResourceType(v24, HIDWORD(v35[0]), *((unsigned __int16 *)this + 12), *((void *)this + 1), v40, v3, (unint64_t *)&v43);
              unsigned int v25 = v43;
              unsigned int v26 = v44;
              while (v25 != v26)
              {
                (*(void (**)(void *__return_ptr, md::SingleGEOResourceDataRequester *, char *))(*(void *)this + 80))(v39, this, v25);
                if (a3) {
                  int v27 = 1;
                }
                else {
                  int v27 = *((_DWORD *)this + 4);
                }
                gdc::Tiled::mapDataKeyFromTile((unsigned __int8 *)v35, 0, (unsigned __int8 *)v39, *((_WORD *)this + 11), v27);
                gdc::LayerDataCollector::addDataKey(v8, (const gdc::LayerDataRequestKey *)v35, (const QuadTile *)(v17 + 2));
                if (*((unsigned char *)this + 20))
                {
                  if (a3) {
                    int v28 = 1;
                  }
                  else {
                    int v28 = *((_DWORD *)this + 4);
                  }
                  gdc::Tiled::mapDataKeyFromTile(v31, 1u, (unsigned __int8 *)v39, *((_WORD *)this + 11), v28);
                  gdc::LayerDataCollector::addDataKey(v8, (const gdc::LayerDataRequestKey *)v31, (const QuadTile *)(v17 + 2));
                  if (v34) {
                    char v34 = 0;
                  }
                  if (v32 != v33) {
                    free(v32);
                  }
                }
                if (v38) {
                  char v38 = 0;
                }
                if (v36 != v37) {
                  free(v36);
                }
                v25 += 24;
              }
            }
            BOOL v17 = (uint64_t *)*v17;
          }
          while (v17);
          if (v43)
          {
            unsigned __int16 v44 = v43;
            operator delete(v43);
          }
        }
      }
    }
  }
}

void sub_1A1825060(_Unwind_Exception *exception_object)
{
  unint64_t v3 = *(void **)(v1 - 136);
  if (v3)
  {
    *(void *)(v1 - 128) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t gdc::ResourceManager::tileSize@<X0>(uint64_t this@<X0>, int a2@<W1>, unsigned char *a3@<X8>)
{
  unint64_t v3 = *(unsigned __int16 **)(this + 32);
  uint64_t v4 = *(unsigned __int16 **)(this + 40);
  if (v3 != v4)
  {
    while (*v3 != a2)
    {
      v3 += 8;
      if (v3 == v4) {
        goto LABEL_7;
      }
    }
  }
  if (v3 != v4) {
    return (*(uint64_t (**)(void))(**((void **)v3 + 1) + 72))();
  }
LABEL_7:
  *a3 = 0;
  return this;
}

void *md::TiledGEOResourceFetcher::tileSize@<X0>(md::TiledGEOResourceFetcher *this@<X0>, uint64_t a2@<X8>)
{
  BOOL result = (void *)*((void *)this + 76);
  if (result)
  {
    unsigned int v5 = 1;
    if ([result scale] == 2)
    {
      if (*((float *)this + 2) > 1.0) {
        unsigned int v5 = 2;
      }
      else {
        unsigned int v5 = 1;
      }
    }
    BOOL result = (void *)[*((id *)this + 76) size];
    unint64_t v6 = 0x20001000080uLL >> (16 * result);
    if (result >= 3) {
      LOWORD(v6) = 0;
    }
    *(unsigned char *)a2 = 1;
    *(_DWORD *)(a2 + 4) = (v6 & 0x380) / v5;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
  return result;
}

double md::SingleGEOResourceDataRequester::resolveTile@<D0>(const QuadTile *a1@<X1>, uint64_t a2@<X8>)
{
  *(_WORD *)a2 = *(_WORD *)&a1->_type;
  double result = *(double *)&a1->_yIdx;
  *(double *)(a2 + 4) = result;
  return result;
}

void md::TileAdjustmentHelpers::adjustTileForSizeAndResourceType(unsigned int a1, unsigned int a2, uint64_t a3, uint64_t a4, unsigned __int8 *a5, int a6, unint64_t *a7)
{
  __int16 v11 = a3;
  int v12 = 0;
  if (a1 && a2)
  {
    unint64_t v13 = a1;
    unint64_t v14 = a2;
    if (a2 >= a1)
    {
      int v12 = 0;
    }
    else
    {
      int v12 = 0;
      do
      {
        ++v12;
        v14 *= 2;
      }
      while (v14 < a1);
    }
    while (v14 > v13)
    {
      --v12;
      v13 *= 2;
    }
  }
  int v15 = a5[1];
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t))(*(void *)a4 + 24))(&v20, a4, a3);
  if ((_BYTE)v20)
  {
    signed int v16 = v12 + v15;
    int v17 = a6 & 0xFFFFFF;
    if ((*(void *)&a6 & 0xFF0000) != 0)
    {
      signed int v18 = a6;
      if (HIDWORD(v20) < a6) {
        signed int v18 = HIDWORD(v20);
      }
      signed int v19 = BYTE1(v17);
      if (BYTE1(v17) <= v21) {
        signed int v19 = v21;
      }
    }
    else
    {
      signed int v18 = HIDWORD(v20);
      signed int v19 = v21;
    }
    if (v18 > v16) {
      signed int v16 = v18;
    }
    if (v19 < v16) {
      signed int v16 = v19;
    }
    md::TileAdjustmentHelpers::enumerateResourceTilesWithZAdjustment(a5[1] - v16, v11, a4, a5, v17, a7);
  }
}

uint64_t gdc::ResourceManager::downloadZoomRange@<X0>(uint64_t this@<X0>, int a2@<W1>, unsigned char *a3@<X8>)
{
  unint64_t v3 = *(unsigned __int16 **)(this + 32);
  uint64_t v4 = *(unsigned __int16 **)(this + 40);
  if (v3 != v4)
  {
    while (*v3 != a2)
    {
      v3 += 8;
      if (v3 == v4) {
        goto LABEL_7;
      }
    }
  }
  if (v3 != v4) {
    return (*(uint64_t (**)(void))(**((void **)v3 + 1) + 64))();
  }
LABEL_7:
  *a3 = 0;
  return this;
}

uint64_t md::TiledGEOResourceFetcher::downloadZoomRange@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(this + 592))
  {
    *(void *)(a2 + 4) = *(void *)(this + 596);
    *(unsigned char *)a2 = 1;
  }
  return this;
}

void md::TileAdjustmentHelpers::enumerateResourceTilesWithZAdjustment(int a1, __int16 a2, uint64_t a3, unsigned __int8 *a4, int a5, unint64_t *a6)
{
  char v7 = a1;
  __int16 v50 = a5;
  char v51 = BYTE2(a5);
  uint64_t v46 = a3;
  __int16 v47 = a2;
  uint64_t v48 = &v50;
  int v49 = a6;
  if (a1 < 0)
  {
    unsigned int v11 = -(char)a1;
    int v12 = a4[1];
    int v13 = *((_DWORD *)a4 + 1);
    int v14 = *a4;
    char v15 = v12 - a1;
    int v16 = v13 << v11;
    int v42 = *((_DWORD *)a4 + 2);
    int v17 = v42 << v11;
    if (v11 <= 0x1E) {
      char v18 = *a4;
    }
    else {
      char v18 = -1;
    }
    if (v11 <= 0x1E) {
      char v19 = v12 - a1;
    }
    else {
      char v19 = 0;
    }
    if (v11 <= 0x1E) {
      unsigned int v20 = v13 << v11;
    }
    else {
      unsigned int v20 = 0;
    }
    if (v11 <= 0x1E) {
      unsigned int v21 = v42 << v11;
    }
    else {
      unsigned int v21 = 0;
    }
    unint64_t v22 = 1 << v11;
    uint64_t v41 = v22 << v11;
    if (v22 << v11)
    {
      char v43 = v18;
      char v44 = v19;
      unint64_t v45 = __PAIR64__(v21, v20);
      md::TileAdjustmentHelpers::enumerateResourceTilesWithZAdjustment(int,unsigned short,gdc::ResourceManifestInformer const*,geo::QuadTile const&,std::optional<gm::Range<unsigned char>>,std::vector<geo::QuadTile> &)::$_0::operator()(&v46, &v43);
      if (v14 != *a4 || v12 != a4[1] || v13 != *((_DWORD *)a4 + 1) || v42 != *((_DWORD *)a4 + 2) || v41 != 1)
      {
        int v23 = v7 != 0;
        LODWORD(v24) = v7 == 0;
        uint64_t v25 = 1;
        uint64_t v26 = 2;
        do
        {
          do
          {
            unint64_t v27 = v26;
            char v43 = v14;
            char v44 = v15;
            LODWORD(v45) = v16 + v24;
            HIDWORD(v45) = v17 + v23;
            md::TileAdjustmentHelpers::enumerateResourceTilesWithZAdjustment(int,unsigned short,gdc::ResourceManifestInformer const*,geo::QuadTile const&,std::optional<gm::Range<unsigned char>>,std::vector<geo::QuadTile> &)::$_0::operator()(&v46, &v43);
            ++v25;
            unint64_t v24 = v27 / v22;
            int v23 = v25 - v27 / v22 * v22;
            uint64_t v26 = v27 + 1;
          }
          while (v14 != *a4);
        }
        while (v12 != a4[1] || v13 != *((_DWORD *)a4 + 1) || v42 != *((_DWORD *)a4 + 2) || v41 != v27);
      }
    }
  }
  else
  {
    unsigned int v8 = a4[1];
    if (a4[1])
    {
      unsigned int v9 = a1;
      if (v8 < a1) {
        unsigned int v9 = a4[1];
      }
      LOBYTE(v8) = v8 - v9;
      int32x2_t v10 = vshl_s32(*(int32x2_t *)(a4 + 4), vneg_s32(vdup_n_s32(v9)));
    }
    else
    {
      int32x2_t v10 = *(int32x2_t *)(a4 + 4);
    }
    char v43 = *a4;
    char v44 = v8;
    unint64_t v45 = (unint64_t)v10;
    md::TileAdjustmentHelpers::enumerateResourceTilesWithZAdjustment(int,unsigned short,gdc::ResourceManifestInformer const*,geo::QuadTile const&,std::optional<gm::Range<unsigned char>>,std::vector<geo::QuadTile> &)::$_0::operator()(&v46, &v43);
  }
  unint64_t v28 = a6[1];
  unint64_t v29 = 126 - 2 * __clz(0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28 - *a6) >> 3));
  if (v28 == *a6) {
    uint64_t v30 = 0;
  }
  else {
    uint64_t v30 = v29;
  }
  std::__introsort<std::_ClassicAlgPolicy,QuadTileCompare &,geo::QuadTile *,false>(*a6, v28, v30, 1);
  unsigned int v32 = (unsigned __int8 *)*a6;
  int v31 = (unsigned __int8 *)a6[1];
  if ((unsigned __int8 *)*a6 != v31)
  {
    unsigned int v33 = v32 + 24;
    if (v32 + 24 != v31)
    {
      unsigned int v34 = *v32;
      while (1)
      {
        unsigned int v35 = v34;
        unint64_t v36 = v33 - 24;
        unsigned int v34 = *v33;
        if (__PAIR64__(*(v33 - 23), v35) == __PAIR64__(v33[1], v34)
          && *((_DWORD *)v33 - 5) == *((_DWORD *)v33 + 1)
          && *((_DWORD *)v33 - 4) == *((_DWORD *)v33 + 2))
        {
          break;
        }
        v33 += 24;
        if (v33 == v31) {
          return;
        }
      }
      if (v36 != v31)
      {
        int v37 = v33 + 24;
        if (v36 + 48 != v31)
        {
          do
          {
            if (*v36 != *v37
              || v36[1] != v37[1]
              || *((_DWORD *)v36 + 1) != *((_DWORD *)v37 + 1)
              || *((_DWORD *)v36 + 2) != *((_DWORD *)v37 + 2))
            {
              long long v38 = *(_OWORD *)v37;
              *((void *)v36 + 5) = *((void *)v37 + 2);
              *(_OWORD *)(v36 + 24) = v38;
              v36 += 24;
            }
            v37 += 24;
          }
          while (v37 != v31);
          int v31 = (unsigned __int8 *)a6[1];
        }
        char v39 = v36 + 24;
        if (v39 != v31) {
          a6[1] = (unint64_t)v39;
        }
      }
    }
  }
}

void std::__introsort<std::_ClassicAlgPolicy,QuadTileCompare &,geo::QuadTile *,false>(unint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
void md::TileAdjustmentHelpers::enumerateResourceTilesWithZAdjustment(int,unsigned short,gdc::ResourceManifestInformer const*,geo::QuadTile const&,std::optional<gm::Range<unsigned char>>,std::vector<geo::QuadTile> &)::$_0::operator()(void *a1, char *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 16))(&v44);
  if ((_BYTE)v44)
  {
    BOOL v4 = (unsigned __int16 *)a1[2];
    BOOL v5 = (char **)a1[3];
    unsigned int v6 = *v4;
    int v7 = v6 | (*((unsigned __int8 *)v4 + 2) << 16);
    unsigned int v8 = a2[1];
    unsigned int v9 = v6 >> 8;
    BOOL v10 = (v7 & 0xFF0000) != 0;
    BOOL v11 = v8 >= v7;
    if (v9 >= v8) {
      unsigned int v9 = a2[1];
    }
    int v12 = v10 && v11;
    if (v12) {
      unsigned int v13 = v9;
    }
    else {
      unsigned int v13 = 0;
    }
    char v14 = v46;
    if (v12 == 1 && v13 > v46)
    {
      if (a2[1])
      {
        unsigned int v19 = (v8 - v13);
        if (v8 < v19) {
          unsigned int v19 = a2[1];
        }
        char v20 = v8 - v19;
        int32x2_t v21 = vshl_s32(*(int32x2_t *)(a2 + 4), vneg_s32(vdup_n_s32(v19)));
      }
      else
      {
        char v20 = 0;
        int32x2_t v21 = *(int32x2_t *)(a2 + 4);
      }
      char v32 = *a2;
      int v34 = v5[1];
      unint64_t v33 = (unint64_t)v5[2];
      if ((unint64_t)v34 < v33)
      {
        *int v34 = v32;
        v34[1] = v20;
        uint64_t i = v34 + 24;
        *(int32x2_t *)(v34 + 4) = v21;
        goto LABEL_42;
      }
      unsigned int v22 = *v5;
      unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((v34 - *v5) >> 3);
      unint64_t v36 = v35 + 1;
      if (v35 + 1 <= 0xAAAAAAAAAAAAAAALL)
      {
        unint64_t v37 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v33 - (void)v22) >> 3);
        if (2 * v37 > v36) {
          unint64_t v36 = 2 * v37;
        }
        if (v37 >= 0x555555555555555) {
          unint64_t v38 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v38 = v36;
        }
        if (v38 <= 0xAAAAAAAAAAAAAAALL)
        {
          uint64_t v39 = 24 * v38;
          unint64_t v40 = (char *)operator new(24 * v38);
          __int16 v41 = &v40[24 * v35];
          char *v41 = v32;
          uint64_t v42 = &v40[v39];
          v41[1] = v20;
          *(int32x2_t *)(v41 + 4) = v21;
          for (uint64_t i = v41 + 24; v34 != v22; *(void *)(v41 + 4) = *(void *)(v34 + 4))
          {
            __int16 v43 = *((_WORD *)v34 - 12);
            v34 -= 24;
            *((_WORD *)v41 - 12) = v43;
            v41 -= 24;
          }
          __int16 *v5 = v41;
          v5[1] = i;
          v5[2] = v42;
          if (!v22) {
            goto LABEL_42;
          }
LABEL_41:
          operator delete(v22);
          goto LABEL_42;
        }
LABEL_45:
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
    }
    else
    {
      int v17 = v5[1];
      unint64_t v16 = (unint64_t)v5[2];
      if ((unint64_t)v17 < v16)
      {
        *int v17 = v45;
        v17[1] = v14;
        *(void *)(v17 + 4) = v47;
        uint64_t i = v17 + 24;
LABEL_42:
        v5[1] = i;
        return;
      }
      unsigned int v22 = *v5;
      unint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v17 - *v5) >> 3);
      unint64_t v24 = v23 + 1;
      if (v23 + 1 <= 0xAAAAAAAAAAAAAAALL)
      {
        unint64_t v25 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v16 - (void)v22) >> 3);
        if (2 * v25 > v24) {
          unint64_t v24 = 2 * v25;
        }
        if (v25 >= 0x555555555555555) {
          unint64_t v26 = 0xAAAAAAAAAAAAAAALL;
        }
        else {
          unint64_t v26 = v24;
        }
        if (v26 <= 0xAAAAAAAAAAAAAAALL)
        {
          uint64_t v27 = 24 * v26;
          unsigned int v28 = (char *)operator new(24 * v26);
          int v29 = &v28[24 * v23];
          BOOL v30 = &v28[v27];
          *int v29 = v45;
          v29[1] = v14;
          *(void *)(v29 + 4) = v47;
          for (uint64_t i = v29 + 24; v17 != v22; *(void *)(v29 + 4) = *(void *)(v17 + 4))
          {
            __int16 v31 = *((_WORD *)v17 - 12);
            v17 -= 24;
            *((_WORD *)v29 - 12) = v31;
            v29 -= 24;
          }
          __int16 *v5 = v29;
          v5[1] = i;
          v5[2] = v30;
          if (!v22) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
        goto LABEL_45;
      }
    }
    abort();
  }
}

void md::DaVinciGroundMetaData::queryMetaTileFromTile(md::DaVinciGroundMetaData *this, const QuadTile *a2)
{
  (*(void (**)(uint64_t *__return_ptr))(**(void **)&a2->_type + 16))(&v10);
  if ((_BYTE)v10)
  {
    gdc::Tiled::mapDataKeyFromTile(v6, 0, v11, 51, *(_DWORD *)(a2->_hash + 16));
    gdc::LayerDataStore::get((gdc::LayerDataStore *)v5, *(const gdc::LayerDataRequestKey **)&a2->_xIdx, v6);
    BOOL v4 = (std::__shared_weak_count *)v5[1];
    *(void *)this = v5[0];
    *((void *)this + 1) = v4;
    if (v4)
    {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
    if (v9) {
      char v9 = 0;
    }
    if (v7 != v8) {
      free(v7);
    }
  }
  else
  {
    *(void *)this = 0;
    *((void *)this + 1) = 0;
  }
}

uint64_t gdc::ResourceManager::resourceTileForTile@<X0>(uint64_t this@<X0>, const QuadTile *a2@<X2>, int a3@<W1>, unsigned char *a4@<X8>)
{
  BOOL v4 = *(unsigned __int16 **)(this + 32);
  BOOL v5 = *(unsigned __int16 **)(this + 40);
  if (v4 != v5)
  {
    while (*v4 != a3)
    {
      v4 += 8;
      if (v4 == v5) {
        goto LABEL_7;
      }
    }
  }
  if (v4 != v5) {
    return (*(uint64_t (**)(void, const QuadTile *))(**((void **)v4 + 1) + 56))(*((void *)v4 + 1), a2);
  }
LABEL_7:
  *a4 = 0;
  return this;
}

uint64_t md::TiledGEOResourceFetcher::resourceTileForTile@<X0>(uint64_t this@<X0>, const QuadTile *a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(void *)(this + 608) || !*(unsigned char *)(this + 592)) {
    goto LABEL_33;
  }
  unsigned int level = a2->_level;
  int yIdx = a2->_yIdx;
  int xIdx = a2->_xIdx;
  unsigned __int8 type = a2->_type;
  if ((int)(level - *(_DWORD *)(this + 600)) >= 1)
  {
    if (!a2->_level) {
      goto LABEL_33;
    }
    unsigned int v7 = (level - *(unsigned char *)(this + 600));
    if (level < v7) {
      LOBYTE(v7) = a2->_level;
    }
    LOBYTE(level) = level - v7;
    yIdx >>= v7;
    xIdx >>= v7;
  }
  if ((_BYTE)level)
  {
    while (*(_DWORD *)(this + 596) <= level)
    {
      unsigned int v8 = *(unsigned int **)(this + 568);
      char v9 = *(unsigned int **)(this + 576);
      if (v8 != v9)
      {
        uint64_t v10 = v8 + 2;
        while (1)
        {
          unsigned int v11 = *(v10 - 2);
          int v12 = v10 - 2;
          if (v11 <= level && *(v10 - 1) >= level)
          {
            unsigned int v14 = (level - v11);
            if (level < v14) {
              LOBYTE(v14) = level;
            }
            unsigned int v15 = xIdx >> v14;
            unsigned int v16 = yIdx >> v14;
            BOOL v17 = v15 < *v10 || v15 > v10[2];
            BOOL v18 = !v17 && v16 >= v10[1];
            if (v18 && v16 <= v10[3]) {
              break;
            }
          }
          v10 += 6;
          if (v12 + 6 == v9) {
            goto LABEL_10;
          }
        }
        *(unsigned char *)a3 = 1;
        *(unsigned char *)(a3 + 8) = type;
        *(unsigned char *)(a3 + 9) = level;
        *(_DWORD *)(a3 + 12) = yIdx;
        *(_DWORD *)(a3 + 16) = xIdx;
        return this;
      }
LABEL_10:
      LOBYTE(level) = level - 1;
      yIdx >>= 1;
      xIdx >>= 1;
      if (!(_BYTE)level) {
        break;
      }
    }
  }
LABEL_33:
  *(unsigned char *)a3 = 0;
  return this;
}

uint64_t md::DaVinciGroundTileResourceFetcher::downloadZoomRange@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  if (*(unsigned char *)(this + 618))
  {
    if (*(unsigned char *)(this + 592))
    {
      LODWORD(v2) = *(_DWORD *)(this + 600);
      if (v2 >= 0xB) {
        uint64_t v2 = 11;
      }
      else {
        uint64_t v2 = v2;
      }
      uint64_t v3 = *(unsigned int *)(this + 596) | (unint64_t)(v2 << 32);
    }
    else
    {
      uint64_t v3 = 0xB00000000;
    }
    *(unsigned char *)a2 = 1;
    *(void *)(a2 + 4) = v3;
  }
  else
  {
    *(unsigned char *)a2 = 0;
    if (*(unsigned char *)(this + 592))
    {
      *(void *)(a2 + 4) = *(void *)(this + 596);
      *(unsigned char *)a2 = 1;
    }
  }
  return this;
}

uint64_t md::SingleGEOResourceDataRequester::downloadZoomRange(md::SingleGEOResourceDataRequester *this)
{
  return (*(uint64_t (**)(void, void))(**((void **)this + 1) + 24))(*((void *)this + 1), *((unsigned __int16 *)this + 12));
}

void std::__function::__func<md::TileSelectionLogic::configurationDidChange(void)::$_0,std::allocator<md::TileSelectionLogic::configurationDidChange(void)::$_0>,void ()(unsigned short,gdc::LayerDataSource *,gdc::DataKeyRequester *)>::operator()(uint64_t a1, unsigned __int16 *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  unint64_t v5 = *a2;
  uint64_t v6 = *(void *)(a1 + 16);
  (*(void (**)(uint64_t *__return_ptr))(**(void **)a4 + 64))(&v24);
  if (!(_BYTE)v24) {
    return;
  }
  unsigned int v7 = *(int8x8_t **)(v6 + 120);
  int8x8_t v8 = v7[17];
  if (!*(void *)&v8) {
    goto LABEL_22;
  }
  uint8x8_t v9 = (uint8x8_t)vcnt_s8(v8);
  v9.i16[0] = vaddlv_u8(v9);
  if (v9.u32[0] > 1uLL)
  {
    unint64_t v10 = v5;
    if (*(void *)&v8 <= v5) {
      unint64_t v10 = v5 % *(void *)&v8;
    }
  }
  else
  {
    unint64_t v10 = (v8.i32[0] - 1) & v5;
  }
  unsigned int v11 = *(uint64_t ****)(*(void *)&v7[16] + 8 * v10);
  if (!v11 || (int v12 = *v11) == 0)
  {
LABEL_22:
    unsigned int v16 = 0;
    goto LABEL_23;
  }
  if (v9.u32[0] < 2uLL)
  {
    uint64_t v13 = *(void *)&v8 - 1;
    while (1)
    {
      unsigned int v15 = v12[1];
      if (v15 == (uint64_t *)v5)
      {
        if (*((unsigned __int16 *)v12 + 8) == v5) {
          goto LABEL_47;
        }
      }
      else if (((unint64_t)v15 & v13) != v10)
      {
        goto LABEL_22;
      }
      int v12 = (uint64_t **)*v12;
      if (!v12) {
        goto LABEL_22;
      }
    }
  }
  while (1)
  {
    unint64_t v14 = (unint64_t)v12[1];
    if (v14 == v5) {
      break;
    }
    if (v14 >= *(void *)&v8) {
      v14 %= *(void *)&v8;
    }
    if (v14 != v10) {
      goto LABEL_22;
    }
LABEL_12:
    int v12 = (uint64_t **)*v12;
    if (!v12) {
      goto LABEL_22;
    }
  }
  if (*((unsigned __int16 *)v12 + 8) != v5) {
    goto LABEL_12;
  }
LABEL_47:
  unsigned int v16 = *((unsigned __int16 *)v12 + 10);
LABEL_23:
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  BOOL v17 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    if (v5 > 0x51) {
      BOOL v18 = "<Invalid>";
    }
    else {
      BOOL v18 = off_1E5A95780[v5];
    }
    if (v16 > 8) {
      unsigned int v19 = "<Invalid>";
    }
    else {
      unsigned int v19 = off_1E5A95718[v16];
    }
    *(_DWORD *)float buf = 136315650;
    unint64_t v26 = v18;
    __int16 v27 = 1024;
    int v28 = HIDWORD(v24);
    __int16 v29 = 2080;
    BOOL v30 = v19;
    _os_log_impl(&dword_1A1780000, v17, OS_LOG_TYPE_DEBUG, "Layer %s wants grid size %d for tile selection set: %s", buf, 0x1Cu);
  }

  unsigned int v20 = HIDWORD(v24);
  uint64_t v21 = *(void *)(a1 + 8);
  if (HIDWORD(v24) < *(_DWORD *)(v21 + 4 * v16))
  {
    if (HIDWORD(v24) <= 0x7F)
    {
      if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
      }
      unsigned int v22 = (id)GEOGetVectorKitVKDefaultLog_log;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        if (v5 > 0x51) {
          unint64_t v23 = "<Invalid>";
        }
        else {
          unint64_t v23 = off_1E5A95780[v5];
        }
        *(_DWORD *)float buf = 136315394;
        unint64_t v26 = v23;
        __int16 v27 = 1024;
        int v28 = HIDWORD(v24);
        _os_log_impl(&dword_1A1780000, v22, OS_LOG_TYPE_DEBUG, "Layer %s wants grid size %d. This is probably a bug!", buf, 0x12u);
      }

      unsigned int v20 = HIDWORD(v24);
      uint64_t v21 = *(void *)(a1 + 8);
    }
    if (v20 <= 0x80) {
      unsigned int v20 = 128;
    }
    *(_DWORD *)(v21 + 4 * v16) = v20;
  }
}

void md::RegionalResourceSetFetcher::tileSize(uint64_t a1@<X8>)
{
  *(unsigned char *)a1 = 1;
  *(_DWORD *)(a1 + 4) = 512;
}

void gdc::DataKeyRequester::minRequiredTileSizeForTileSet(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

double md::RegionalResourceSetFetcher::resourceTileForTile@<D0>(const QuadTile *a1@<X1>, uint64_t a2@<X8>)
{
  __int16 v3 = *(_WORD *)&a1->_type;
  *(unsigned char *)a2 = 1;
  *(_WORD *)(a2 + 8) = v3;
  double result = *(double *)&a1->_yIdx;
  *(double *)(a2 + 12) = result;
  return result;
}

void gdc::DataKeyRequester::downloadZoomRange(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t md::SingleGEOResourceDataRequester::visibleZoomRange@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(this + 28))
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 32);
    *(unsigned char *)a2 = 1;
  }
  *(unsigned char *)(a2 + 8) = 0;
  if (*(unsigned char *)(this + 36))
  {
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(this + 40);
    *(unsigned char *)(a2 + 8) = 1;
  }
  return this;
}

void *gdc::GlobeTileSelector::purgeCache(void *this)
{
  uint64_t v1 = this;
  if (this[29])
  {
    this = (void *)this[28];
    if (this)
    {
      do
      {
        uint64_t v2 = (void *)*this;
        operator delete(this);
        this = v2;
      }
      while (v2);
    }
    v1[28] = 0;
    uint64_t v3 = v1[27];
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(v1[26] + 8 * i) = 0;
    }
    v1[29] = 0;
  }
  if (v1[33])
  {
    uint64_t v5 = v1[31];
    this = (void *)v1[32];
    uint64_t v6 = *this;
    *(void *)(v6 + 8) = *(void *)(v5 + 8);
    **(void **)(v5 + 8) = v6;
    v1[33] = 0;
    if (this != v1 + 31)
    {
      do
      {
        unsigned int v7 = (void *)this[1];
        operator delete(this);
        this = v7;
      }
      while (v7 != v1 + 31);
    }
  }
  if (v1[11])
  {
    this = (void *)v1[10];
    if (this)
    {
      do
      {
        int8x8_t v8 = (void *)*this;
        operator delete(this);
        this = v8;
      }
      while (v8);
    }
    v1[10] = 0;
    uint64_t v9 = v1[9];
    if (v9)
    {
      for (uint64_t j = 0; j != v9; ++j)
        *(void *)(v1[8] + 8 * j) = 0;
    }
    v1[11] = 0;
  }
  if (v1[15])
  {
    uint64_t v11 = v1[13];
    this = (void *)v1[14];
    uint64_t v12 = *this;
    *(void *)(v12 + 8) = *(void *)(v11 + 8);
    **(void **)(v11 + 8) = v12;
    v1[15] = 0;
    if (this != v1 + 13)
    {
      do
      {
        uint64_t v13 = (void *)this[1];
        operator delete(this);
        this = v13;
      }
      while (v13 != v1 + 13);
    }
  }
  if (v1[20])
  {
    this = (void *)v1[19];
    if (this)
    {
      do
      {
        unint64_t v14 = (void *)*this;
        operator delete(this);
        this = v14;
      }
      while (v14);
    }
    v1[19] = 0;
    uint64_t v15 = v1[18];
    if (v15)
    {
      for (uint64_t k = 0; k != v15; ++k)
        *(void *)(v1[17] + 8 * k) = 0;
    }
    v1[20] = 0;
  }
  if (v1[24])
  {
    BOOL v17 = v1 + 22;
    uint64_t v18 = v1[22];
    this = (void *)v1[23];
    uint64_t v19 = *this;
    *(void *)(v19 + 8) = *(void *)(v18 + 8);
    **(void **)(v18 + 8) = v19;
    v1[24] = 0;
    if (this != v1 + 22)
    {
      do
      {
        unsigned int v20 = (void *)this[1];
        operator delete(this);
        this = v20;
      }
      while (v20 != v17);
    }
  }
  return this;
}

void md::S2ResourceDataRequester::minRequiredTileSizeForTileSet(md::S2ResourceDataRequester *this@<X0>, uint64_t a2@<X8>)
{
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 32))(&v8);
  if ((_BYTE)v8)
  {
    (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 24))(&v7);
    char v5 = v7;
    if ((_BYTE)v7)
    {
      if (*((unsigned char *)this + 28)) {
        uint64_t v6 = (char *)this + 32;
      }
      else {
        uint64_t v6 = (char *)&v7 + 4;
      }
      LODWORD(v4) = HIDWORD(v8);
      *(_DWORD *)(a2 + 4) = (exp2(-(double)(HIDWORD(v7) - *(_DWORD *)v6)) * (double)v4);
      char v5 = 1;
    }
    *(unsigned char *)a2 = v5;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
}

uint64_t md::S2ResourceDataRequester::downloadZoomRange(md::S2ResourceDataRequester *this)
{
  return (*(uint64_t (**)(void, void))(**((void **)this + 1) + 24))(*((void *)this + 1), *((unsigned __int16 *)this + 12));
}

void md::SequentialGEOResourceDataRequester::minRequiredTileSizeForTileSet(md::SequentialGEOResourceDataRequester *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = *((void *)this + 1);
  if (v4)
  {
    (*(void (**)(uint64_t *__return_ptr))(*(void *)v4 + 32))(&v13);
    if (!(_BYTE)v13)
    {
      uint64_t v5 = *((void *)this + 6);
      for (uint64_t i = *((void *)this + 7); v5 != i; v5 += 2)
      {
        (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 32))(&v13);
        if ((_BYTE)v13) {
          break;
        }
      }
    }
  }
  (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 32))(&v14);
  if ((_BYTE)v14
    && ((*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 24))(&v13), (_BYTE)v13))
  {
    if (*((_WORD *)this + 11) == 13)
    {
      uint64_t v7 = (char *)&v13 + 4;
    }
    else if (*((unsigned char *)this + 28))
    {
      uint64_t v7 = (char *)this + 32;
    }
    else
    {
      uint64_t v7 = (char *)&v13 + 4;
    }
    unsigned int v8 = *(_DWORD *)v7;
    unsigned int v9 = HIDWORD(v14);
    BOOL v10 = HIDWORD(v13) >= v8;
    unsigned int v11 = HIDWORD(v13) - v8;
    if (v11 != 0 && v10)
    {
      double v12 = (double)HIDWORD(v14);
      unsigned int v9 = (exp2(-(double)v11) * v12);
    }
    *(unsigned char *)a2 = 1;
    *(_DWORD *)(a2 + 4) = v9;
  }
  else
  {
    *(unsigned char *)a2 = 0;
  }
}

uint64_t md::SequentialGEOResourceDataRequester::downloadZoomRange(md::SequentialGEOResourceDataRequester *this)
{
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    (*(void (**)(uint64_t *__return_ptr, void, void))(*(void *)v2 + 32))(&v7, *((void *)this + 1), *((unsigned __int16 *)this + 12));
    if ((_BYTE)v7
      || (uint64_t v5 = (unsigned __int16 *)*((void *)this + 6), v6 = (unsigned __int16 *)*((void *)this + 7), v5 == v6))
    {
LABEL_3:
      uint64_t v3 = *((unsigned __int16 *)this + 12);
    }
    else
    {
      while (1)
      {
        uint64_t v3 = *v5;
        (*(void (**)(uint64_t *__return_ptr))(**((void **)this + 1) + 32))(&v7);
        if ((_BYTE)v7) {
          break;
        }
        if (++v5 == v6) {
          goto LABEL_3;
        }
      }
    }
  }
  else
  {
    uint64_t v3 = *((unsigned __int16 *)this + 12);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 24))(v2, v3);
}

uint64_t md::S2ResourceDataRequester::visibleZoomRange@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  *(unsigned char *)a2 = 0;
  if (*(unsigned char *)(this + 28))
  {
    *(_DWORD *)(a2 + 4) = *(_DWORD *)(this + 32);
    *(unsigned char *)a2 = 1;
  }
  *(unsigned char *)(a2 + 8) = 0;
  if (*(unsigned char *)(this + 36))
  {
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(this + 40);
    *(unsigned char *)(a2 + 8) = 1;
  }
  return this;
}

void sub_1A18274A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A1827518(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::TextDataStringInfo::generateLineBreakInfo(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v53 = a2;
  unint64_t v7 = [v53 length];
  if (!v7) {
    goto LABEL_84;
  }
  {
    operator new();
  }
  if ((v7 & 0x8000000000000000) != 0) {
    abort();
  }
  uint64_t v8 = mdm::Allocator::instance(void)::alloc;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                     + 16))(mdm::Allocator::instance(void)::alloc, 2 * v7, 2);
  BOOL v10 = (unsigned __int16 *)v9;
  uint64_t v11 = 0;
  do
  {
    if (v9 + v11) {
      *(_WORD *)(v9 + v11) = 0;
    }
    v11 += 2;
  }
  while (2 * v7 != v11);
  objc_msgSend(v53, "getCharacters:range:", v9, 0, v7);
  int v12 = *(unsigned __int8 *)(a1 + 128);
  switch(v12)
  {
    case 3:
      if (md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::onceToken != -1) {
        dispatch_once(&md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::onceToken, &__block_literal_global_14_18310);
      }
      uint64_t v13 = &md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeLeadingCharacterSet;
      uint64_t v14 = md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeFollowingCharacterSet;
      if (!md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeFollowingCharacterSet) {
        goto LABEL_82;
      }
      break;
    case 2:
      if (md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::onceToken != -1) {
        dispatch_once(&md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::onceToken, &__block_literal_global_16_18311);
      }
      uint64_t v13 = &md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeLeadingCharacterSet;
      uint64_t v14 = md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeFollowingCharacterSet;
      if (!md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeFollowingCharacterSet) {
        goto LABEL_82;
      }
      break;
    case 1:
      if (md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::onceToken != -1) {
        dispatch_once(&md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::onceToken, &__block_literal_global_18309);
      }
      uint64_t v13 = &md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeLeadingCharacterSet;
      uint64_t v14 = md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeFollowingCharacterSet;
      if (!md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeFollowingCharacterSet) {
        goto LABEL_82;
      }
      break;
    default:
      if (md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::onceToken[0] != -1) {
        dispatch_once(md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::onceToken, &__block_literal_global_18_18312);
      }
      uint64_t v13 = &md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeLeadingCharacterSet;
      uint64_t v14 = md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeFollowingCharacterSet;
      if (!md::TextDataStringInfo::getBreakingCharacterSets(std::set<unsigned short> const*&,std::set<unsigned short> const*&)const::localeFollowingCharacterSet) {
        goto LABEL_82;
      }
      break;
  }
  uint64_t v15 = *v13;
  if (!*v13) {
    goto LABEL_82;
  }
  {
    operator new();
  }
  if (v7 >> 62) {
    abort();
  }
  uint64_t v52 = mdm::Allocator::instance(void)::alloc;
  uint64_t v16 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                      + 16))(mdm::Allocator::instance(void)::alloc, 4 * v7, 4);
  uint64_t v17 = v16;
  uint64_t v18 = 0;
  do
  {
    if (v16 + v18) {
      *(_DWORD *)(v16 + v18) = 0;
    }
    v18 += 4;
  }
  while (4 * v7 != v18);
  if (*(void *)(a1 + 104) - *(void *)(a1 + 96) >= 2uLL)
  {
    int v19 = 0;
    if (v7 <= 1) {
      uint64_t v20 = 1;
    }
    else {
      uint64_t v20 = v7;
    }
    uint64_t v21 = v10;
    unsigned int v22 = (_DWORD *)v16;
    do
    {
      int v23 = *v21++;
      if (v23 == 30) {
        ++v19;
      }
      *v22++ = v19;
      --v20;
    }
    while (v20);
  }
  uint64_t v24 = a4[1];
  uint64_t v25 = v24 - *a4;
  if (v24 == *a4) {
    goto LABEL_80;
  }
  uint64_t v26 = 0;
  uint64_t v27 = 0;
  char v28 = 0;
  unint64_t v29 = v25 / 24;
  if (v29 <= 1) {
    unint64_t v29 = 1;
  }
  while (2)
  {
    unint64_t v35 = *(void *)(*a3 + 8 * v26);
    if (v35 >= v7) {
      goto LABEL_56;
    }
    uint64_t v36 = *a4 + 24 * v26;
    uint64_t v37 = *(unsigned int *)(v17 + 4 * v35);
    unsigned int v40 = *(unsigned __int8 *)(v36 + 20);
    uint64_t v39 = (unsigned char *)(v36 + 20);
    unsigned int v38 = v40;
    if (v37 != v27)
    {
      unsigned int v38 = v38 & 0xFFFFFFEF | (16 * (*(unsigned char *)(*(void *)(a1 + 96) + v37) & 1));
      *uint64_t v39 = v38;
      uint64_t v27 = v37;
    }
    unsigned int v41 = v10[v35];
    if (v41 - 0x2000 < 0xC || v41 == 32) {
      int v43 = 8;
    }
    else {
      int v43 = 0;
    }
    unsigned int v44 = v43 | v38 & 0xFFFFFFF7;
    *uint64_t v39 = v44;
    unsigned int v45 = v44 & 0xFFFFFFDF | (32 * ((*(unsigned __int8 *)(*(void *)(a1 + 96) + v27) >> 1) & 1));
    *uint64_t v39 = v45;
    for (uint64_t i = *(uint64_t ***)(v14 + 8); i; uint64_t i = (uint64_t **)*i)
    {
      unsigned int v48 = *((unsigned __int16 *)i + 13);
      if (v41 >= v48)
      {
        if (v48 >= v41)
        {
          char v47 = 0;
          goto LABEL_73;
        }
        ++i;
      }
    }
    char v47 = 2;
LABEL_73:
    char v49 = v47 | v45 & 0xFD;
    *uint64_t v39 = v49;
    uint64_t v50 = *(uint64_t ***)(v15 + 8);
    if (!v50)
    {
LABEL_45:
      char v30 = 1;
      goto LABEL_46;
    }
    while (1)
    {
      unsigned int v51 = *((unsigned __int16 *)v50 + 13);
      if (v41 >= v51) {
        break;
      }
LABEL_75:
      uint64_t v50 = (uint64_t **)*v50;
      if (!v50) {
        goto LABEL_45;
      }
    }
    if (v51 < v41)
    {
      ++v50;
      goto LABEL_75;
    }
    char v30 = 0;
LABEL_46:
    char v31 = v49 & 0xFE | v30;
    *uint64_t v39 = v31;
    if (*(unsigned char *)(a1 + 128)) {
      BOOL v32 = v41 > 0x7F;
    }
    else {
      BOOL v32 = 0;
    }
    char v33 = v32;
    if ((v28 | v33)) {
      char v34 = 4;
    }
    else {
      char v34 = 0;
    }
    *uint64_t v39 = v34 | v31 & 0xFB;
    char v28 = v33;
LABEL_56:
    if (++v26 != v29) {
      continue;
    }
    break;
  }
LABEL_80:
  if (v17) {
    (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)v52 + 40))(v52, v17, 4 * v7);
  }
LABEL_82:
  if (v10) {
    (*(void (**)(uint64_t, unsigned __int16 *, unint64_t))(*(void *)v8 + 40))(v8, v10, 2 * v7);
  }
LABEL_84:
}

void sub_1A1827AC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  if (v13) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a11 + 40))(a11, v13, v12);
  }

  _Unwind_Resume(a1);
}

void ___ZN2md21DaVinciGroundSettings13_readSettingsEP12NSDictionary_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  id v6 = a3;
  unint64_t v7 = *(void **)(a1 + 40);
  if (v20[0]) {
    goto LABEL_33;
  }
  uint64_t v8 = v5;
  id v9 = v6;
  uint64_t v21 = 0;
  if ((md::DaVinciGroundSettings::_parsePropertyKeyAndType(v8, (int *)&v21 + 1, &v21) & 1) == 0)
  {

    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    uint64_t v13 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)float buf = 138412546;
      *(void *)&uint8_t buf[4] = v8;
      *(_WORD *)&uint8_t buf[12] = 2112;
      *(void *)&buf[14] = v9;
      _os_log_impl(&dword_1A1780000, v13, OS_LOG_TYPE_ERROR, "DaVinciGroundSettings: unexpected key/value %@=%@", buf, 0x16u);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    goto LABEL_33;
  }
  unint64_t v10 = v7[1];
  if (!v10) {
    goto LABEL_32;
  }
  uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
  v11.i16[0] = vaddlv_u8(v11);
  if (v11.u32[0] > 1uLL)
  {
    unint64_t v12 = SHIDWORD(v21);
    if (v10 <= SHIDWORD(v21)) {
      unint64_t v12 = SHIDWORD(v21) % v10;
    }
  }
  else
  {
    unint64_t v12 = (v10 - 1) & SHIDWORD(v21);
  }
  uint64_t v14 = *(uint64_t ***)(*v7 + 8 * v12);
  if (!v14 || (uint64_t v15 = *v14) == 0)
  {
LABEL_32:

LABEL_33:
    return;
  }
  if (v11.u32[0] < 2uLL)
  {
    unint64_t v16 = v10 - 1;
    while (1)
    {
      uint64_t v18 = v15[1];
      if (v18 == SHIDWORD(v21))
      {
        if (*((_DWORD *)v15 + 4) == HIDWORD(v21)) {
          goto LABEL_30;
        }
      }
      else if ((v18 & v16) != v12)
      {
        goto LABEL_32;
      }
      uint64_t v15 = (uint64_t *)*v15;
      if (!v15) {
        goto LABEL_32;
      }
    }
  }
  while (1)
  {
    unint64_t v17 = v15[1];
    if (v17 == SHIDWORD(v21)) {
      break;
    }
    if (v17 >= v10) {
      v17 %= v10;
    }
    if (v17 != v12) {
      goto LABEL_32;
    }
LABEL_18:
    uint64_t v15 = (uint64_t *)*v15;
    if (!v15) {
      goto LABEL_32;
    }
  }
  if (*((_DWORD *)v15 + 4) != HIDWORD(v21)) {
    goto LABEL_18;
  }
LABEL_30:
  *(void *)float buf = v9;
  *(void *)&uint8_t buf[8] = v8;
  uint64_t v19 = *((unsigned int *)v15 + 8);
  if (v19 != -1)
  {
    unsigned int v22 = buf;
    ((void (*)(unsigned char **, uint64_t *))off_1EF58FC08[v19])(&v22, v15 + 3);

    goto LABEL_32;
  }
  std::__throw_bad_variant_access[abi:nn180100]();
  __break(1u);
}

void sub_1A1827DBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void md::RegionalResourceLayerDataSource::createLayerData(uint64_t a1@<X1>, uint64_t *a2@<X2>, uint64_t *a3@<X8>)
{
  uint64_t v4 = *(int **)(a1 + 16);
  int v5 = *((unsigned __int8 *)v4 + 8);
  double v6 = 1.0 / (double)(1 << v5);
  double v7 = v6 * (double)*v4;
  double v8 = v6 * (double)((1 << v5) + ~v4[1]);
  double v9 = v7 + v6;
  double v10 = v8 + v6;
  uint8x8_t v11 = (char *)operator new(0x70uLL);
  *((void *)v11 + 1) = 0;
  *((void *)v11 + 2) = 0;
  *(void *)uint8x8_t v11 = &unk_1EF57F9C8;
  *(_OWORD *)(v11 + 40) = 0u;
  *(_OWORD *)(v11 + 56) = 0u;
  *((_DWORD *)v11 + 18) = v5;
  *((double *)v11 + 10) = v7;
  *((double *)v11 + 11) = v8;
  *((double *)v11 + 12) = v9;
  *((double *)v11 + 13) = v10;
  *(_OWORD *)(v11 + 24) = 0u;
  unsigned int v56 = (md::ResourceInfo *)(v11 + 24);
  int v57 = (std::__shared_weak_count *)v11;
  uint64_t v12 = *a2;
  uint64_t v13 = a2[1];
  uint64_t v14 = *a2;
  if (*a2 != v13)
  {
    uint64_t v14 = *a2;
    while (*(_WORD *)v14 != 18)
    {
      v14 += 48;
      if (v14 == v13) {
        goto LABEL_18;
      }
    }
  }
  if (v14 != v13)
  {
    uint64_t v15 = *(void **)(v14 + 24);
    if (v15)
    {
      do
      {
        uint64_t v16 = v15[14];
        unint64_t v17 = (std::__shared_weak_count *)v15[15];
        uint64_t v59 = v16;
        int16x4_t v60 = v17;
        if (v17) {
          atomic_fetch_add_explicit(&v17->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v18 = (NSArray *)*(id *)(v16 + 144);
        md::ResourceInfo::setResourceNames(v56, v18);

        if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
        uint64_t v15 = (void *)*v15;
      }
      while (v15);
      uint64_t v12 = *a2;
      uint64_t v13 = a2[1];
    }
  }
  while (1)
  {
LABEL_18:
    if (v12 == v13) {
      goto LABEL_19;
    }
    if (*(_WORD *)v12 == 19) {
      break;
    }
    v12 += 48;
  }
  if (v12 != v13)
  {
    uint64_t v21 = *(void **)(v12 + 24);
    if (v21)
    {
      while (1)
      {
        uint64_t v22 = v21[14];
        int v23 = (std::__shared_weak_count *)v21[15];
        int v54 = v21;
        uint64_t v59 = v22;
        int16x4_t v60 = v23;
        if (v23) {
          atomic_fetch_add_explicit(&v23->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        id v53 = v23;
        uint64_t v24 = *(void *)(v22 + 144);
        uint64_t v25 = *(void *)(v22 + 152);
        if (v24 != v25) {
          break;
        }
LABEL_59:
        if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
          std::__shared_weak_count::__release_weak(v53);
        }
        uint64_t v21 = (void *)*v54;
        if (!*v54) {
          goto LABEL_19;
        }
      }
      uint64_t v55 = *(void *)(v22 + 152);
      while (1)
      {
        id v28 = *(id *)(v24 + 8);
        unint64_t v29 = v28;
        char v31 = (void *)*((void *)v56 + 4);
        unint64_t v30 = *((void *)v56 + 5);
        if ((unint64_t)v31 < v30)
        {
          id v26 = v28;
          *char v31 = &unk_1EF559558;
          v31[1] = v26;
          uint64_t v27 = v31 + 3;
        }
        else
        {
          uint64_t v32 = *((void *)v56 + 3);
          unint64_t v33 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v31 - v32) >> 3);
          unint64_t v34 = v33 + 1;
          if (v33 + 1 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          unint64_t v35 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v30 - v32) >> 3);
          if (2 * v35 > v34) {
            unint64_t v34 = 2 * v35;
          }
          if (v35 >= 0x555555555555555) {
            unint64_t v36 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v36 = v34;
          }
          if (v36)
          {
            if (v36 > 0xAAAAAAAAAAAAAAALL) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            uint64_t v37 = (char *)operator new(24 * v36);
          }
          else
          {
            uint64_t v37 = 0;
          }
          unsigned int v38 = &v37[24 * v33];
          uint64_t v39 = &v37[24 * v36];
          id v40 = v29;
          *(void *)unsigned int v38 = &unk_1EF559558;
          *((void *)v38 + 1) = v40;
          uint64_t v27 = v38 + 24;
          uint64_t v42 = (id *)*((void *)v56 + 3);
          unsigned int v41 = (id *)*((void *)v56 + 4);
          if (v41 == v42)
          {
            *((void *)v56 + 3) = v38;
            *((void *)v56 + 4) = v27;
            *((void *)v56 + 5) = v39;
          }
          else
          {
            uint64_t v43 = (uint64_t)&v37[24 * v33 - 24];
            do
            {
              *((void *)v38 - 3) = &unk_1EF559558;
              v38 -= 24;
              *((void *)v38 + 1) = 0;
              objc_storeStrong((id *)v38 + 1, *(v41 - 2));
              unsigned int v44 = *(v41 - 2);
              *(v41 - 2) = 0;

              v43 -= 24;
              v41 -= 3;
            }
            while (v41 != v42);
            unsigned int v41 = (id *)*((void *)v56 + 3);
            unsigned int v45 = (id *)*((void *)v56 + 4);
            *((void *)v56 + 3) = v38;
            *((void *)v56 + 4) = v27;
            *((void *)v56 + 5) = v39;
            if (v45 != v41)
            {
              unsigned __int8 v46 = v45 - 3;
              char v47 = v45 - 3;
              unsigned int v48 = v45 - 3;
              do
              {
                char v49 = (void (**)(id *))*v48;
                v48 -= 3;
                (*v49)(v47);
                v46 -= 3;
                BOOL v50 = v47 == v41;
                char v47 = v48;
              }
              while (!v50);
              uint64_t v25 = v55;
              if (!v41) {
                goto LABEL_35;
              }
LABEL_58:
              operator delete(v41);
              goto LABEL_35;
            }
          }
          uint64_t v25 = v55;
          if (v41) {
            goto LABEL_58;
          }
        }
LABEL_35:
        *((void *)v56 + 4) = v27;

        v24 += 24;
        if (v24 == v25) {
          goto LABEL_59;
        }
      }
    }
  }
LABEL_19:
  uint64_t v19 = operator new(0x2F8uLL);
  v19[1] = 0;
  v19[2] = 0;
  void *v19 = &unk_1EF581C20;
  uint64_t v59 = 0;
  int16x4_t v60 = 0;
  uint64_t v61 = 0;
  v58[0] = 0;
  v58[1] = 0;
  uint64_t v20 = md::MapTileData::MapTileData((uint64_t)(v19 + 3), a1, (uint64_t)&v59, v58, 1);
  void v19[3] = &unk_1EF545738;
  v19[82] = &unk_1EF545778;
  v19[93] = v56;
  v19[94] = v57;
  if (v57)
  {
    atomic_fetch_add_explicit(&v57->__shared_owners_, 1uLL, memory_order_relaxed);
    *a3 = v20;
    a3[1] = (uint64_t)v19;
    if (!atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
      std::__shared_weak_count::__release_weak(v57);
    }
  }
  else
  {
    *a3 = v20;
    a3[1] = (uint64_t)v19;
  }
}

void sub_1A18283A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  std::__shared_weak_count::~__shared_weak_count(v18);
  operator delete(v20);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a14);
  _Unwind_Resume(a1);
}

void md::ResourceInfo::setResourceNames(md::ResourceInfo *this, NSArray *a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v43 = a2;
  unint64_t v3 = [(NSArray *)v43 count];
  unint64_t v4 = v3;
  int v5 = *(void ***)this;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)this + 2) - *(void *)this) >> 3) < v3)
  {
    if (v3 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    double v6 = (void **)*((void *)this + 1);
    double v7 = (char *)operator new(24 * v3);
    double v8 = &v7[24 * v4];
    double v9 = &v7[24 * (((char *)v6 - (char *)v5) / 24)];
    if (v6 == v5)
    {
      *(void *)this = v9;
      *((void *)this + 1) = v9;
      *((void *)this + 2) = v8;
    }
    else
    {
      double v10 = &v7[24 * (((char *)v6 - (char *)v5) / 24)];
      do
      {
        long long v11 = *(_OWORD *)(v6 - 3);
        *((void *)v10 - 1) = *(v6 - 1);
        *(_OWORD *)(v10 - 24) = v11;
        v10 -= 24;
        *(v6 - 2) = 0;
        *(v6 - 1) = 0;
        *(v6 - 3) = 0;
        v6 -= 3;
      }
      while (v6 != v5);
      int v5 = *(void ***)this;
      uint64_t v12 = (void **)*((void *)this + 1);
      *(void *)this = v10;
      *((void *)this + 1) = v9;
      *((void *)this + 2) = v8;
      while (v12 != v5)
      {
        if (*((char *)v12 - 1) < 0) {
          operator delete(*(v12 - 3));
        }
        v12 -= 3;
      }
    }
    if (v5) {
      operator delete(v5);
    }
  }
  long long v46 = 0u;
  long long v47 = 0u;
  long long v44 = 0u;
  long long v45 = 0u;
  uint64_t v13 = v43;
  uint64_t v14 = [(NSArray *)v13 countByEnumeratingWithState:&v44 objects:v53 count:16];
  if (v14)
  {
    uint64_t v15 = *(void *)v45;
    do
    {
      for (uint64_t i = 0; i != v14; ++i)
      {
        if (*(void *)v45 != v15) {
          objc_enumerationMutation(v13);
        }
        unint64_t v17 = (const char *)[*(id *)(*((void *)&v44 + 1) + 8 * i) UTF8String];
        uint64_t v18 = v17;
        if (v17 && *v17)
        {
          uint64_t v20 = (void *)*((void *)this + 1);
          unint64_t v19 = *((void *)this + 2);
          if ((unint64_t)v20 < v19)
          {
            size_t v21 = strlen(v17);
            if (v21 > 0x7FFFFFFFFFFFFFF7) {
              abort();
            }
            size_t v22 = v21;
            if (v21 >= 0x17)
            {
              uint64_t v29 = (v21 & 0xFFFFFFFFFFFFFFF8) + 8;
              if ((v21 | 7) != 0x17) {
                uint64_t v29 = v21 | 7;
              }
              uint64_t v30 = v29 + 1;
              int v23 = operator new(v29 + 1);
              v20[1] = v22;
              v20[2] = v30 | 0x8000000000000000;
              void *v20 = v23;
            }
            else
            {
              *((unsigned char *)v20 + 23) = v21;
              int v23 = v20;
              if (!v21) {
                goto LABEL_41;
              }
            }
            memmove(v23, v18, v22);
LABEL_41:
            *((unsigned char *)v23 + v22) = 0;
            *((void *)this + 1) = v20 + 3;
            *((void *)this + 1) = v20 + 3;
            continue;
          }
          unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v20 - *(void *)this) >> 3);
          unint64_t v25 = v24 + 1;
          if (v24 + 1 > 0xAAAAAAAAAAAAAAALL) {
            abort();
          }
          unint64_t v26 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v19 - *(void *)this) >> 3);
          if (2 * v26 > v25) {
            unint64_t v25 = 2 * v26;
          }
          if (v26 >= 0x555555555555555) {
            unint64_t v27 = 0xAAAAAAAAAAAAAAALL;
          }
          else {
            unint64_t v27 = v25;
          }
          uint64_t v52 = (char *)this + 16;
          if (v27)
          {
            if (v27 > 0xAAAAAAAAAAAAAAALL) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            id v28 = (char *)operator new(24 * v27);
          }
          else
          {
            id v28 = 0;
          }
          char v31 = &v28[24 * v24];
          unsigned int v48 = v28;
          char v49 = v31;
          BOOL v50 = v31;
          unsigned int v51 = &v28[24 * v27];
          size_t v32 = strlen(v18);
          if (v32 > 0x7FFFFFFFFFFFFFF7) {
            abort();
          }
          size_t v33 = v32;
          if (v32 >= 0x17)
          {
            uint64_t v34 = (v32 & 0xFFFFFFFFFFFFFFF8) + 8;
            if ((v32 | 7) != 0x17) {
              uint64_t v34 = v32 | 7;
            }
            uint64_t v35 = v34 + 1;
            unint64_t v36 = (char *)operator new(v34 + 1);
            *((void *)v31 + 1) = v33;
            *((void *)v31 + 2) = v35 | 0x8000000000000000;
            *(void *)char v31 = v36;
            char v31 = v36;
          }
          else
          {
            v31[23] = v32;
            if (!v32) {
              goto LABEL_51;
            }
          }
          memmove(v31, v18, v33);
LABEL_51:
          v31[v33] = 0;
          uint64_t v37 = v49;
          unsigned int v38 = v50 + 24;
          uint64_t v39 = *(char **)this;
          id v40 = (char *)*((void *)this + 1);
          if (v40 == *(char **)this)
          {
            *(void *)this = v49;
            *((void *)this + 1) = v38;
            *((void *)this + 2) = v51;
          }
          else
          {
            do
            {
              long long v41 = *(_OWORD *)(v40 - 24);
              *((void *)v37 - 1) = *((void *)v40 - 1);
              *(_OWORD *)(v37 - 24) = v41;
              v37 -= 24;
              *((void *)v40 - 2) = 0;
              *((void *)v40 - 1) = 0;
              *((void *)v40 - 3) = 0;
              v40 -= 24;
            }
            while (v40 != v39);
            id v40 = *(char **)this;
            uint64_t v42 = (void **)*((void *)this + 1);
            *(void *)this = v37;
            *((void *)this + 1) = v38;
            *((void *)this + 2) = v51;
            while (v42 != (void **)v40)
            {
              if (*((char *)v42 - 1) < 0) {
                operator delete(*(v42 - 3));
              }
              v42 -= 3;
            }
          }
          if (v40) {
            operator delete(v40);
          }
          *((void *)this + 1) = v38;
          continue;
        }
      }
      uint64_t v14 = [(NSArray *)v13 countByEnumeratingWithState:&v44 objects:v53 count:16];
    }
    while (v14);
  }
}

void sub_1A182887C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, std::__split_buffer<std::string> *a12)
{
  _Unwind_Resume(a1);
}

void md::anonymous namespace'::_parseZoomRange(md::_anonymous_namespace_ *this, NSString *a2)
{
  uint64_t v13 = a2;
  unint64_t v3 = [(NSString *)v13 componentsSeparatedByString:@"-"];
  if ([v3 count] == 2)
  {
    unint64_t v4 = [v3 objectAtIndexedSubscript:0];
    int v5 = [v4 intValue];

    if (v5 >= 1)
    {
      double v6 = [v3 objectAtIndexedSubscript:0];
      unsigned __int8 v7 = [v6 intValue];

      double v8 = [v3 objectAtIndexedSubscript:1];
      int v9 = [v8 intValue];

      if (v9 >= 1)
      {
        double v10 = [v3 objectAtIndexedSubscript:1];
        __int16 v11 = [v10 intValue];

        *(unsigned char *)this = 1;
        *(_WORD *)((char *)this + 1) = v7 | (unsigned __int16)(v11 << 8);
        goto LABEL_9;
      }
    }
  }
  else if ([v3 count] == 1)
  {
    int v12 = [(NSString *)v13 intValue];
    if (v12 >= 1)
    {
      *(unsigned char *)this = 1;
      *(_WORD *)((char *)this + 1) = (v12 | (unsigned __int16)((_WORD)v12 << 8)) + 256;
      goto LABEL_9;
    }
  }
  *(unsigned char *)this = 0;
LABEL_9:
}

void sub_1A1828A30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void md::GeoResourceProvider::resourceNames(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v82 = *MEMORY[0x1E4F143B8];
  long long v65 = (std::mutex *)(a1 + 112);
  std::mutex::lock((std::mutex *)(a1 + 112));
  uint64_t v5 = *(void *)(a1 + 320);
  uint64_t v6 = *(void *)(a1 + 328);
  __int16 v63 = (void *)a1;
  if (v5 == v6)
  {
    uint64_t v7 = a2;
  }
  else
  {
    uint64_t v7 = a2;
    while (((*(_DWORD *)v5 ^ a2) & 3) != 0)
    {
      v5 += 24;
      if (v5 == v6) {
        goto LABEL_10;
      }
    }
  }
  if (v5 == v6)
  {
LABEL_10:
    long long v75 = 0uLL;
    unint64_t v76 = 0;
    uint64_t v77 = grl::Allocator::instance(v4);
    if ((v7 & 1) == 0) {
      goto LABEL_36;
    }
    int v9 = [MEMORY[0x1E4F64908] sharedManager];
    double v10 = [v9 allResourceNames];

    if (!v10 || ![v10 count])
    {
      if (GEOGetVectorKitVKGeoResourceProviderLog(void)::onceToken != -1) {
        dispatch_once(&GEOGetVectorKitVKGeoResourceProviderLog(void)::onceToken, &__block_literal_global_85);
      }
      long long v47 = GEOGetVectorKitVKGeoResourceProviderLog(void)::log;
      if (os_log_type_enabled((os_log_t)GEOGetVectorKitVKGeoResourceProviderLog(void)::log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)float buf = 136315650;
        *(void *)&uint8_t buf[4] = "false";
        *(_WORD *)&uint8_t buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/GeoResourceProvider.mm";
        *(_WORD *)&unsigned char buf[22] = 1024;
        int v81 = 125;
        _os_log_impl(&dword_1A1780000, v47, OS_LOG_TYPE_ERROR, "A non-empty set of resource name of global resources is expected: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
      }
      *a3 = 0;
      a3[1] = 0;

      goto LABEL_100;
    }
    std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::reserve((uint64_t *)&v75, [v10 count]);
    long long v73 = 0u;
    long long v74 = 0u;
    long long v71 = 0u;
    long long v72 = 0u;
    id v11 = v10;
    uint64_t v12 = [v11 countByEnumeratingWithState:&v71 objects:v79 count:16];
    if (!v12) {
      goto LABEL_35;
    }
    uint64_t v13 = *(void *)v72;
LABEL_15:
    uint64_t v14 = 0;
    while (1)
    {
      if (*(void *)v72 != v13) {
        objc_enumerationMutation(v11);
      }
      uint64_t v16 = (const char *)[*(id *)(*((void *)&v71 + 1) + 8 * v14) UTF8String];
      unint64_t v17 = v16;
      *(void *)float buf = v16;
      if (!v16) {
        goto LABEL_18;
      }
      uint64_t v18 = (char *)*((void *)&v75 + 1);
      if (*((void *)&v75 + 1) < v76) {
        break;
      }
      uint64_t v15 = std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__emplace_back_slow_path<char const*&>((uint64_t *)&v75, (const char **)buf);
LABEL_17:
      *((void *)&v75 + 1) = v15;
LABEL_18:
      if (v12 == ++v14)
      {
        uint64_t v12 = [v11 countByEnumeratingWithState:&v71 objects:v79 count:16];
        if (!v12)
        {
LABEL_35:

LABEL_36:
          if ((v7 & 2) != 0)
          {
            unint64_t v24 = [MEMORY[0x1E4F64918] modernManager];
            unint64_t v25 = [v24 allRegionalResourceNames];

            if (v25)
            {
              unint64_t v26 = v25;
              uint64_t v7 = a2;
              if ([v25 count])
              {
                std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::reserve((uint64_t *)&v75, [v25 count] - 0x5555555555555555 * ((uint64_t)(*((void *)&v75 + 1) - v75) >> 3));
                long long v69 = 0u;
                long long v70 = 0u;
                long long v67 = 0u;
                long long v68 = 0u;
                id v27 = v25;
                uint64_t v28 = [v27 countByEnumeratingWithState:&v67 objects:v78 count:16];
                uint64_t v7 = a2;
                if (!v28) {
                  goto LABEL_61;
                }
                uint64_t v29 = *(void *)v68;
                while (1)
                {
                  for (uint64_t i = 0; i != v28; ++i)
                  {
                    if (*(void *)v68 != v29) {
                      objc_enumerationMutation(v27);
                    }
                    size_t v32 = (const char *)[*(id *)(*((void *)&v67 + 1) + 8 * i) UTF8String];
                    size_t v33 = v32;
                    *(void *)float buf = v32;
                    if (v32)
                    {
                      uint64_t v34 = (char *)*((void *)&v75 + 1);
                      if (*((void *)&v75 + 1) < v76)
                      {
                        if (!*((void *)&v75 + 1)) {
                          goto LABEL_59;
                        }
                        size_t v35 = strlen(v32);
                        if (v35 > 0x7FFFFFFFFFFFFFF7) {
                          abort();
                        }
                        size_t v36 = v35;
                        if (v35 >= 0x17)
                        {
                          uint64_t v38 = (v35 & 0xFFFFFFFFFFFFFFF8) + 8;
                          if ((v35 | 7) != 0x17) {
                            uint64_t v38 = v35 | 7;
                          }
                          uint64_t v39 = v38 + 1;
                          uint64_t v37 = operator new(v38 + 1);
                          *((void *)v34 + 1) = v36;
                          *((void *)v34 + 2) = v39 | 0x8000000000000000;
                          *(void *)uint64_t v34 = v37;
                          uint64_t v7 = a2;
                        }
                        else
                        {
                          *(unsigned char *)(*((void *)&v75 + 1) + 23) = v35;
                          uint64_t v37 = v34;
                          if (!v35)
                          {
LABEL_58:
                            v37[v36] = 0;
                            unint64_t v25 = v26;
LABEL_59:
                            char v31 = v34 + 24;
LABEL_43:
                            *((void *)&v75 + 1) = v31;
                            continue;
                          }
                        }
                        memmove(v37, v33, v36);
                        goto LABEL_58;
                      }
                      char v31 = std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__emplace_back_slow_path<char const*&>((uint64_t *)&v75, (const char **)buf);
                      goto LABEL_43;
                    }
                  }
                  uint64_t v28 = [v27 countByEnumeratingWithState:&v67 objects:v78 count:16];
                  if (!v28)
                  {
LABEL_61:

                    break;
                  }
                }
              }
            }
          }
          id v40 = (char *)operator new(0x38uLL);
          long long v41 = (std::__shared_weak_count *)v40;
          *((void *)v40 + 1) = 0;
          *((void *)v40 + 2) = 0;
          *(void *)id v40 = &unk_1EF58B2A0;
          *(_OWORD *)(v40 + 24) = v75;
          uint64_t v42 = v77;
          *((void *)v40 + 5) = v76;
          *((void *)v40 + 6) = v42;
          long long v75 = 0uLL;
          unint64_t v76 = 0;
          *(void *)float buf = v7;
          *(void *)&uint8_t buf[8] = v40 + 24;
          *(void *)&buf[16] = v40;
          long long v44 = (char *)v63[40];
          uint64_t v43 = (char *)v63[41];
          long long v45 = v44;
          if (v44 != v43)
          {
            long long v45 = (char *)v63[40];
            while (((*(_DWORD *)v45 ^ a2) & 3) != 0)
            {
              v45 += 24;
              if (v45 == v43) {
                goto LABEL_69;
              }
            }
          }
          if (v45 == v43)
          {
LABEL_69:
            unint64_t v46 = v63[42];
            if ((unint64_t)v43 < v46)
            {
              *(void *)uint64_t v43 = a2;
              *((void *)v43 + 1) = v40 + 24;
              *((void *)v43 + 2) = v40;
              *(void *)&uint8_t buf[8] = 0;
              *(void *)&buf[16] = 0;
              long long v45 = v43;
              v63[41] = v43 + 24;
              goto LABEL_98;
            }
            unint64_t v48 = 0xAAAAAAAAAAAAAAABLL * ((v43 - v44) >> 3) + 1;
            if (v48 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            unint64_t v49 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v46 - (void)v44) >> 3);
            if (2 * v49 > v48) {
              unint64_t v48 = 2 * v49;
            }
            if (v49 >= 0x555555555555555) {
              unint64_t v50 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              unint64_t v50 = v48;
            }
            if (v50 > 0xAAAAAAAAAAAAAAALL) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            unsigned int v51 = (char *)operator new(24 * v50);
            uint64_t v52 = &v51[8 * ((v43 - v44) >> 3)];
            *(void *)uint64_t v52 = a2;
            *(_OWORD *)(v52 + 8) = *(_OWORD *)&buf[8];
            id v53 = &v51[24 * v50];
            *(void *)&uint8_t buf[8] = 0;
            *(void *)&buf[16] = 0;
            uint64_t v54 = v52 + 24;
            if (v44 == v43)
            {
              v63[40] = v52;
              v63[41] = v54;
              BOOL v58 = v63;
              v63[42] = v53;
              if (v44) {
                goto LABEL_94;
              }
            }
            else
            {
              do
              {
                uint64_t v55 = *((void *)v43 - 3);
                v43 -= 24;
                *((void *)v52 - 3) = v55;
                v52 -= 24;
                *(_OWORD *)(v52 + 8) = *(_OWORD *)(v43 + 8);
                *((void *)v43 + 1) = 0;
                *((void *)v43 + 2) = 0;
              }
              while (v43 != v44);
              long long v44 = (char *)v63[40];
              unsigned int v56 = (char *)v63[41];
              v63[40] = v52;
              v63[41] = v54;
              v63[42] = v53;
              if (v56 == v44)
              {
                BOOL v58 = v63;
                if (v44) {
                  goto LABEL_94;
                }
              }
              else
              {
                do
                {
                  int v57 = (std::__shared_weak_count *)*((void *)v56 - 1);
                  if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
                    std::__shared_weak_count::__release_weak(v57);
                  }
                  v56 -= 24;
                }
                while (v56 != v44);
                BOOL v58 = v63;
                if (!v44) {
                  goto LABEL_95;
                }
LABEL_94:
                operator delete(v44);
                BOOL v58 = v63;
              }
            }
LABEL_95:
            long long v41 = *(std::__shared_weak_count **)&buf[16];
            v58[41] = v54;
            long long v45 = v54 - 24;
            if (!v41) {
              goto LABEL_98;
            }
          }
          if (!atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
            std::__shared_weak_count::__release_weak(v41);
          }
LABEL_98:
          *a3 = *((void *)v45 + 1);
          uint64_t v59 = *((void *)v45 + 2);
          a3[1] = v59;
          if (v59) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v59 + 8), 1uLL, memory_order_relaxed);
          }
LABEL_100:
          uint64_t v60 = v75;
          if ((void)v75)
          {
            uint64_t v61 = *((void *)&v75 + 1);
            uint64_t v62 = v75;
            if (*((void *)&v75 + 1) != (void)v75)
            {
              do
              {
                if (*(char *)(v61 - 1) < 0) {
                  operator delete(*(void **)(v61 - 24));
                }
                v61 -= 24;
              }
              while (v61 != v60);
              uint64_t v62 = v75;
            }
            *((void *)&v75 + 1) = v60;
            (*(void (**)(uint64_t, uint64_t, unint64_t))(*(void *)v77 + 40))(v77, v62, v76 - v62);
          }
          goto LABEL_108;
        }
        goto LABEL_15;
      }
    }
    if (!*((void *)&v75 + 1))
    {
LABEL_33:
      uint64_t v15 = v18 + 24;
      goto LABEL_17;
    }
    size_t v19 = strlen(v16);
    if (v19 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    size_t v20 = v19;
    if (v19 >= 0x17)
    {
      uint64_t v22 = (v19 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v19 | 7) != 0x17) {
        uint64_t v22 = v19 | 7;
      }
      uint64_t v23 = v22 + 1;
      size_t v21 = operator new(v22 + 1);
      *((void *)v18 + 1) = v20;
      *((void *)v18 + 2) = v23 | 0x8000000000000000;
      *(void *)uint64_t v18 = v21;
      uint64_t v7 = a2;
    }
    else
    {
      *(unsigned char *)(*((void *)&v75 + 1) + 23) = v19;
      size_t v21 = v18;
      if (!v19) {
        goto LABEL_32;
      }
    }
    memmove(v21, v17, v20);
LABEL_32:
    *((unsigned char *)v21 + v20) = 0;
    goto LABEL_33;
  }
  *a3 = *(void *)(v5 + 8);
  uint64_t v8 = *(void *)(v5 + 16);
  a3[1] = v8;
  if (v8) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v8 + 8), 1uLL, memory_order_relaxed);
  }
LABEL_108:
  std::mutex::unlock(v65);
}

void sub_1A18292F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::mutex *a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34)
{
  std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::~vector[abi:nn180100](&a33);
  std::mutex::unlock(a13);
  _Unwind_Resume(a1);
}

void sub_1A18294A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A18295C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t md::LabelExternalFeature::addTextForZoom(int64x2_t *a1, char a2, char a3, const char *a4, const char *a5)
{
  uint64_t v6 = (char *)a1[3].i64[1];
  if ((unint64_t)v6 >= a1[4].i64[0])
  {
    uint64_t result = std::vector<md::LabelExternalTextElement>::__emplace_back_slow_path<unsigned char &,char const*&,char const*&,char const*&,char const*&,md::LabelExternalTextType &>(a1 + 3, a2, a4, a5, 0, 0, a3);
  }
  else
  {
    char *v6 = a2;
    v6[1] = a3;
    md::StringWithLocaleImp<std::string>::StringWithLocaleImp((uint64_t)(v6 + 8), a4, a5);
    md::StringWithLocaleImp<std::string>::StringWithLocaleImp((uint64_t)(v6 + 56), 0, 0);
    uint64_t result = (uint64_t)(v6 + 104);
    a1[3].i64[1] = (uint64_t)(v6 + 104);
  }
  a1[3].i64[1] = result;
  return result;
}

void sub_1A1829668(_Unwind_Exception *exception_object)
{
  if (*(char *)(v3 + 55) < 0) {
    operator delete(*(void **)(v3 + 32));
  }
  if (*(char *)(v3 + 31) < 0) {
    operator delete(*v2);
  }
  *(void *)(v1 + 56) = v3;
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<md::LabelExternalTextElement>::__emplace_back_slow_path<unsigned char &,char const*&,char const*&,char const*&,char const*&,md::LabelExternalTextType &>(int64x2_t *a1, char a2, const char *a3, const char *a4, const char *a5, const char *a6, char a7)
{
  uint64_t v7 = 0x4EC4EC4EC4EC4EC5 * ((a1->i64[1] - a1->i64[0]) >> 3);
  unint64_t v8 = v7 + 1;
  if ((unint64_t)(v7 + 1) > 0x276276276276276) {
    abort();
  }
  if (0x9D89D89D89D89D8ALL * ((a1[1].i64[0] - a1->i64[0]) >> 3) > v8) {
    unint64_t v8 = 0x9D89D89D89D89D8ALL * ((a1[1].i64[0] - a1->i64[0]) >> 3);
  }
  if ((unint64_t)(0x4EC4EC4EC4EC4EC5 * ((a1[1].i64[0] - a1->i64[0]) >> 3)) >= 0x13B13B13B13B13BLL) {
    unint64_t v13 = 0x276276276276276;
  }
  else {
    unint64_t v13 = v8;
  }
  uint64_t v34 = a1 + 1;
  if (v13)
  {
    if (v13 > 0x276276276276276) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v14 = a4;
    uint64_t v15 = a5;
    uint64_t v16 = a6;
    unint64_t v17 = (char *)operator new(104 * v13);
    a4 = v14;
  }
  else
  {
    uint64_t v15 = a5;
    uint64_t v16 = a6;
    unint64_t v17 = 0;
  }
  uint64_t v18 = &v17[104 * v7];
  char v31 = v17;
  v32.i64[0] = (uint64_t)v18;
  v32.i64[1] = (uint64_t)v18;
  size_t v33 = &v17[104 * v13];
  char *v18 = a2;
  v18[1] = a7;
  md::StringWithLocaleImp<std::string>::StringWithLocaleImp((uint64_t)(v18 + 8), a3, a4);
  md::StringWithLocaleImp<std::string>::StringWithLocaleImp((uint64_t)(v18 + 56), v15, v16);
  uint64_t v19 = v32.i64[0];
  uint64_t v20 = v32.i64[1] + 104;
  v32.i64[1] += 104;
  uint64_t v22 = a1->i64[0];
  unint64_t v21 = a1->u64[1];
  if (v21 == a1->i64[0])
  {
    int64x2_t v28 = vdupq_n_s64(v21);
  }
  else
  {
    do
    {
      __int16 v23 = *(_WORD *)(v21 - 104);
      v21 -= 104;
      *(_WORD *)(v19 - 104) = v23;
      v19 -= 104;
      long long v24 = *(_OWORD *)(v21 + 8);
      *(void *)(v19 + 24) = *(void *)(v21 + 24);
      *(_OWORD *)(v19 + 8) = v24;
      *(void *)(v21 + 16) = 0;
      *(void *)(v21 + 24) = 0;
      *(void *)(v21 + 8) = 0;
      long long v25 = *(_OWORD *)(v21 + 32);
      *(void *)(v19 + 48) = *(void *)(v21 + 48);
      *(_OWORD *)(v19 + 32) = v25;
      *(void *)(v21 + 40) = 0;
      *(void *)(v21 + 48) = 0;
      *(void *)(v21 + 32) = 0;
      long long v26 = *(_OWORD *)(v21 + 56);
      *(void *)(v19 + 72) = *(void *)(v21 + 72);
      *(_OWORD *)(v19 + 56) = v26;
      *(void *)(v21 + 64) = 0;
      *(void *)(v21 + 72) = 0;
      *(void *)(v21 + 56) = 0;
      long long v27 = *(_OWORD *)(v21 + 80);
      *(void *)(v19 + 96) = *(void *)(v21 + 96);
      *(_OWORD *)(v19 + 80) = v27;
      *(void *)(v21 + 80) = 0;
      *(void *)(v21 + 88) = 0;
      *(void *)(v21 + 96) = 0;
    }
    while (v21 != v22);
    int64x2_t v28 = *a1;
    uint64_t v20 = v32.i64[1];
  }
  a1->i64[0] = v19;
  a1->i64[1] = v20;
  int64x2_t v32 = v28;
  uint64_t v29 = (char *)a1[1].i64[0];
  a1[1].i64[0] = (uint64_t)v33;
  size_t v33 = v29;
  char v31 = (char *)v28.i64[0];
  std::__split_buffer<md::LabelExternalTextElement>::~__split_buffer((uint64_t)&v31);
  return v20;
}

void sub_1A18298B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  if (*(char *)(v5 + 55) < 0) {
    operator delete(*(void **)(v3 + 104 * v4 + 32));
  }
  if (*(char *)(v5 + 31) < 0) {
    operator delete(*v2);
  }
  std::__split_buffer<md::LabelExternalTextElement>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t md::StringWithLocaleImp<std::string>::StringWithLocaleImp(uint64_t a1, const char *a2, const char *a3)
{
  if (a2) {
    uint64_t v5 = a2;
  }
  else {
    uint64_t v5 = "";
  }
  size_t v6 = strlen(v5);
  if (v6 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  size_t v7 = v6;
  if (v6 >= 0x17)
  {
    uint64_t v9 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v6 | 7) != 0x17) {
      uint64_t v9 = v6 | 7;
    }
    uint64_t v10 = v9 + 1;
    unint64_t v8 = operator new(v9 + 1);
    *(void *)(a1 + 8) = v7;
    *(void *)(a1 + 16) = v10 | 0x8000000000000000;
    *(void *)a1 = v8;
    goto LABEL_11;
  }
  *(unsigned char *)(a1 + 23) = v6;
  unint64_t v8 = (void *)a1;
  if (v6) {
LABEL_11:
  }
    memmove(v8, v5, v7);
  *((unsigned char *)v8 + v7) = 0;
  if (a3) {
    id v11 = a3;
  }
  else {
    id v11 = "";
  }
  size_t v12 = strlen(v11);
  if (v12 > 0x7FFFFFFFFFFFFFF7) {
    abort();
  }
  size_t v13 = v12;
  if (v12 >= 0x17)
  {
    uint64_t v15 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v15 = v12 | 7;
    }
    uint64_t v16 = v15 + 1;
    uint64_t v14 = operator new(v15 + 1);
    *(void *)(a1 + 32) = v13;
    *(void *)(a1 + 40) = v16 | 0x8000000000000000;
    *(void *)(a1 + 24) = v14;
  }
  else
  {
    uint64_t v14 = (void *)(a1 + 24);
    *(unsigned char *)(a1 + 47) = v12;
    if (!v12) {
      goto LABEL_23;
    }
  }
  memmove(v14, v11, v13);
LABEL_23:
  *((unsigned char *)v14 + v13) = 0;
  return a1;
}

void sub_1A1829A48(_Unwind_Exception *exception_object)
{
  if (*(char *)(v1 + 23) < 0) {
    operator delete(*(void **)v1);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__split_buffer<md::LabelExternalTextElement>::~__split_buffer(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  for (uint64_t i = *(void *)(a1 + 16); i != v2; uint64_t i = *(void *)(a1 + 16))
  {
    *(void *)(a1 + 16) = i - 104;
    if (*(char *)(i - 1) < 0)
    {
      operator delete(*(void **)(i - 24));
      if ((*(char *)(i - 25) & 0x80000000) == 0)
      {
LABEL_6:
        if (*(char *)(i - 49) < 0) {
          goto LABEL_11;
        }
        goto LABEL_7;
      }
    }
    else if ((*(char *)(i - 25) & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(*(void **)(i - 48));
    if (*(char *)(i - 49) < 0)
    {
LABEL_11:
      operator delete(*(void **)(i - 72));
      if ((*(char *)(i - 73) & 0x80000000) == 0) {
        continue;
      }
      goto LABEL_12;
    }
LABEL_7:
    if ((*(char *)(i - 73) & 0x80000000) == 0) {
      continue;
    }
LABEL_12:
    operator delete(*(void **)(i - 96));
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

void ___ZN2md16StylesheetVendor15localizationMapEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 32);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      unint64_t v8 = (const char *)[v5 UTF8String];
      size_t v9 = strlen(v8);
      if (v9 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      std::string::size_type v10 = v9;
      if (v9 >= 0x17)
      {
        uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v9 | 7) != 0x17) {
          uint64_t v12 = v9 | 7;
        }
        uint64_t v13 = v12 + 1;
        p_dst = (std::string *)operator new(v12 + 1);
        __dst.__r_.__value_.__l.__size_ = v10;
        __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v9;
        p_dst = &__dst;
        if (!v9)
        {
LABEL_11:
          p_dst->__r_.__value_.__s.__data_[v10] = 0;
          uint64_t v14 = *(float **)(v7 + 96);
          int v15 = [v6 intValue];
          int v16 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else {
            std::string __p = __dst;
          }
          int v18 = v15;
          std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,geo::StdAllocator<std::__hash_value_type<std::string,int>,gss::Allocator>>::__emplace_unique_key_args<std::string,std::pair<std::string const,int>>(v14, (uint64_t)&__p, (long long *)&__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
            if ((v16 & 0x80000000) == 0) {
              goto LABEL_16;
            }
          }
          else if ((v16 & 0x80000000) == 0)
          {
            goto LABEL_16;
          }
          operator delete(__dst.__r_.__value_.__l.__data_);
          goto LABEL_16;
        }
      }
      memmove(p_dst, v8, v10);
      goto LABEL_11;
    }
  }
LABEL_16:
}

void sub_1A1829CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v24 < 0) {
    operator delete(a17);
  }

  _Unwind_Resume(a1);
}

void ___ZN2md16StylesheetVendor11currencyMapEv_block_invoke(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(a1 + 32);
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      unint64_t v8 = (const char *)[v5 UTF8String];
      size_t v9 = strlen(v8);
      if (v9 >= 0x7FFFFFFFFFFFFFF8) {
        abort();
      }
      std::string::size_type v10 = v9;
      if (v9 >= 0x17)
      {
        uint64_t v12 = (v9 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v9 | 7) != 0x17) {
          uint64_t v12 = v9 | 7;
        }
        uint64_t v13 = v12 + 1;
        p_dst = (std::string *)operator new(v12 + 1);
        __dst.__r_.__value_.__l.__size_ = v10;
        __dst.__r_.__value_.__r.__words[2] = v13 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v9;
        p_dst = &__dst;
        if (!v9)
        {
LABEL_11:
          p_dst->__r_.__value_.__s.__data_[v10] = 0;
          uint64_t v14 = *(float **)(v7 + 120);
          int v15 = [v6 intValue];
          int v16 = SHIBYTE(__dst.__r_.__value_.__r.__words[2]);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
            std::string::__init_copy_ctor_external(&__p, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
          }
          else {
            std::string __p = __dst;
          }
          int v18 = v15;
          std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,geo::StdAllocator<std::__hash_value_type<std::string,int>,gss::Allocator>>::__emplace_unique_key_args<std::string,std::pair<std::string const,int>>(v14, (uint64_t)&__p, (long long *)&__p);
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            operator delete(__p.__r_.__value_.__l.__data_);
            if ((v16 & 0x80000000) == 0) {
              goto LABEL_16;
            }
          }
          else if ((v16 & 0x80000000) == 0)
          {
            goto LABEL_16;
          }
          operator delete(__dst.__r_.__value_.__l.__data_);
          goto LABEL_16;
        }
      }
      memmove(p_dst, v8, v10);
      goto LABEL_11;
    }
  }
LABEL_16:
}

void sub_1A1829E80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, int a19, __int16 a20,char a21,char a22)
{
  if (a14 < 0) {
    operator delete(__p);
  }
  if (v24 < 0) {
    operator delete(a17);
  }

  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<std::string,int>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,int>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,int>,std::equal_to<std::string>,std::hash<std::string>,true>,geo::StdAllocator<std::__hash_value_type<std::string,int>,gss::Allocator>>::__emplace_unique_key_args<std::string,std::pair<std::string const,int>>(float *a1, uint64_t a2, long long *a3)
{
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    uint64_t v7 = (uint64_t *)a2;
  }
  else {
    uint64_t v7 = *(uint64_t **)a2;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a2 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *((void *)a1 + 1);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    uint64_t v13 = *(uint64_t ***)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      uint64_t v14 = *v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v20 = v14[1];
            if (v20 == v10)
            {
              uint64_t v21 = *((unsigned __int8 *)v14 + 39);
              if ((v21 & 0x80u) == 0) {
                uint64_t v22 = *((unsigned __int8 *)v14 + 39);
              }
              else {
                uint64_t v22 = v14[3];
              }
              if (v22 == v8)
              {
                __int16 v23 = (const void **)(v14 + 2);
                if ((v21 & 0x80) != 0)
                {
                  if (!memcmp(*v23, v7, v14[3])) {
                    return;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v14 + 39)) {
                    return;
                  }
                  for (uint64_t i = v7; *(unsigned __int8 *)v23 == *(unsigned __int8 *)i; uint64_t i = (uint64_t *)((char *)i + 1))
                  {
                    __int16 v23 = (const void **)((char *)v23 + 1);
                    if (!--v21) {
                      return;
                    }
                  }
                }
              }
            }
            else if ((v20 & (v11 - 1)) != v3)
            {
              goto LABEL_49;
            }
            uint64_t v14 = (uint64_t *)*v14;
            if (!v14) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            uint64_t v16 = *((unsigned __int8 *)v14 + 39);
            if ((v16 & 0x80u) == 0) {
              uint64_t v17 = *((unsigned __int8 *)v14 + 39);
            }
            else {
              uint64_t v17 = v14[3];
            }
            if (v17 == v8)
            {
              int v18 = (const void **)(v14 + 2);
              if ((v16 & 0x80) != 0)
              {
                if (!memcmp(*v18, v7, v14[3])) {
                  return;
                }
              }
              else
              {
                if (!*((unsigned char *)v14 + 39)) {
                  return;
                }
                for (uint64_t j = v7; *(unsigned __int8 *)v18 == *(unsigned __int8 *)j; uint64_t j = (uint64_t *)((char *)j + 1))
                {
                  int v18 = (const void **)((char *)v18 + 1);
                  if (!--v16) {
                    return;
                  }
                }
              }
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v3) {
              break;
            }
          }
          uint64_t v14 = (uint64_t *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_49:
  uint64_t v25 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 4) + 16))(*((void *)a1 + 4), 48, 8);
  *(void *)uint64_t v25 = 0;
  *(void *)(v25 + 8) = v10;
  long long v26 = (std::string *)(v25 + 16);
  if (*((char *)a3 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v26, *(const std::string::value_type **)a3, *((void *)a3 + 1));
  }
  else
  {
    long long v27 = *a3;
    *(void *)(v25 + 32) = *((void *)a3 + 2);
    *(_OWORD *)&v26->__r_.__value_.__l.__data_ = v27;
  }
  *(_DWORD *)(v25 + 40) = *((_DWORD *)a3 + 6);
  float v28 = (float)(unint64_t)(*((void *)a1 + 5) + 1);
  float v29 = a1[12];
  if (!v11 || (float)(v29 * (float)v11) < v28)
  {
    BOOL v30 = 1;
    if (v11 >= 3) {
      BOOL v30 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v31 = v30 | (2 * v11);
    unint64_t v32 = vcvtps_u32_f32(v28 / v29);
    if (v31 <= v32) {
      size_t prime = v32;
    }
    else {
      size_t prime = v31;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v11 = *((void *)a1 + 1);
    if (prime <= v11)
    {
      if (prime >= v11) {
        goto LABEL_88;
      }
      unint64_t v45 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 5) / a1[12]);
      if (v11 < 3 || (uint8x8_t v46 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v46.i16[0] = vaddlv_u8(v46), v46.u32[0] > 1uLL))
      {
        unint64_t v45 = std::__next_prime(v45);
      }
      else
      {
        uint64_t v47 = 1 << -(char)__clz(v45 - 1);
        if (v45 >= 2) {
          unint64_t v45 = v47;
        }
      }
      if (prime <= v45) {
        size_t prime = v45;
      }
      if (prime >= v11)
      {
        unint64_t v11 = *((void *)a1 + 1);
LABEL_88:
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v3 = v10 % v11;
          }
          else {
            unint64_t v3 = v10;
          }
        }
        else
        {
          unint64_t v3 = (v11 - 1) & v10;
        }
        goto LABEL_101;
      }
      if (!prime)
      {
        uint64_t v53 = *(void *)a1;
        *(void *)a1 = 0;
        if (v53) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v53, 8 * *((void *)a1 + 1));
        }
        unint64_t v11 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_88;
      }
    }
    uint64_t v34 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(**((void **)a1 + 2) + 16))(*((void *)a1 + 2), 8 * prime, 8);
    uint64_t v35 = *(void *)a1;
    *(void *)a1 = v34;
    if (v35) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v35, 8 * *((void *)a1 + 1));
    }
    uint64_t v36 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v36++) = 0;
    while (prime != v36);
    uint64_t v38 = (uint64_t *)(a1 + 6);
    uint64_t v37 = (void *)*((void *)a1 + 3);
    if (!v37)
    {
LABEL_87:
      unint64_t v11 = prime;
      goto LABEL_88;
    }
    size_t v39 = v37[1];
    size_t v40 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v41 = v39 & v40;
      *(void *)(*(void *)a1 + 8 * v41) = v38;
      for (uint64_t k = (void *)*v37; *v37; uint64_t k = (void *)*v37)
      {
        size_t v43 = k[1] & v40;
        if (v43 == v41)
        {
          uint64_t v37 = k;
        }
        else if (*(void *)(*(void *)a1 + 8 * v43))
        {
          void *v37 = *k;
          uint64_t v44 = 8 * v43;
          *uint64_t k = **(void **)(*(void *)a1 + v44);
          **(void **)(*(void *)a1 + v44) = k;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v43) = v37;
          uint64_t v37 = k;
          size_t v41 = v43;
        }
      }
      goto LABEL_87;
    }
    if (v39 >= prime) {
      v39 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v39) = v38;
    unint64_t v48 = (void *)*v37;
    if (!*v37) {
      goto LABEL_87;
    }
    while (1)
    {
      size_t v50 = v48[1];
      if (v50 >= prime) {
        v50 %= prime;
      }
      if (v50 != v39)
      {
        if (!*(void *)(*(void *)a1 + 8 * v50))
        {
          *(void *)(*(void *)a1 + 8 * v50) = v37;
          goto LABEL_92;
        }
        void *v37 = *v48;
        uint64_t v49 = 8 * v50;
        void *v48 = **(void **)(*(void *)a1 + v49);
        **(void **)(*(void *)a1 + v49) = v48;
        unint64_t v48 = v37;
      }
      size_t v50 = v39;
LABEL_92:
      uint64_t v37 = v48;
      unint64_t v48 = (void *)*v48;
      size_t v39 = v50;
      if (!v48) {
        goto LABEL_87;
      }
    }
  }
LABEL_101:
  unsigned int v51 = *(uint64_t **)(*(void *)a1 + 8 * v3);
  if (v51)
  {
    *(void *)uint64_t v25 = *v51;
    uint64_t *v51 = v25;
  }
  else
  {
    *(void *)uint64_t v25 = *((void *)a1 + 3);
    *((void *)a1 + 3) = v25;
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 6;
    if (*(void *)v25)
    {
      unint64_t v52 = *(void *)(*(void *)v25 + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v52 >= v11) {
          v52 %= v11;
        }
      }
      else
      {
        v52 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v52) = v25;
    }
  }
  ++*((void *)a1 + 5);
}

void sub_1A182A4DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,int>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<std::string,int>,void *>,gss::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

void std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::reserve(uint64_t *a1, unint64_t a2)
{
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 3) < a2)
  {
    if (a2 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v3 = (a1[1] - *a1) / 24;
    uint64_t v4 = 24 * a2;
    uint64_t v5 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 24 * a2, 8);
    uint64_t v6 = v5 + 24 * v3;
    uint64_t v7 = v5 + v4;
    uint64_t v8 = *a1;
    uint64_t v9 = a1[1];
    if (v9 == *a1)
    {
      *a1 = v6;
      a1[1] = v6;
      a1[2] = v7;
    }
    else
    {
      uint64_t v10 = v5 + 24 * v3;
      do
      {
        long long v11 = *(_OWORD *)(v9 - 24);
        *(void *)(v10 - 8) = *(void *)(v9 - 8);
        *(_OWORD *)(v10 - 24) = v11;
        v10 -= 24;
        *(void *)(v9 - 16) = 0;
        *(void *)(v9 - 8) = 0;
        *(void *)(v9 - 24) = 0;
        v9 -= 24;
      }
      while (v9 != v8);
      uint64_t v9 = *a1;
      uint64_t v12 = a1[1];
      *a1 = v10;
      a1[1] = v6;
      a1[2] = v7;
      while (v12 != v9)
      {
        if (*(char *)(v12 - 1) < 0) {
          operator delete(*(void **)(v12 - 24));
        }
        v12 -= 24;
      }
    }
    if (v9)
    {
      uint64_t v13 = *(void (**)(void))(*(void *)a1[3] + 40);
      v13();
    }
  }
}