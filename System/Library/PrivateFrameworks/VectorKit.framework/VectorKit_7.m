void sub_1A1A677A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

unint64_t *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorAO>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorAO>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  v3 = *(int8x8_t **)(a2 + 8);
  v4 = (void *)gdc::Registry::storage<md::ls::StyleGroundOcclusionConstantDataHandle>(v3);
  v5 = (void *)gdc::Registry::storage<md::ls::FunctionConstants>(v3);
  v6 = v5;
  v7 = v5 + 4;
  if (v4[8] - v4[7] >= v5[8] - v5[7]) {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v45, v8, v5, v4, *(void *)(v8 + 24));
  if (v4[8] - v4[7] >= v6[8] - v6[7]) {
    uint64_t v9 = (uint64_t)v7;
  }
  else {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v43, v9, v6, v4, *(void *)(v9 + 32));
  if (v44 == v48)
  {
    result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  }
  else
  {
    result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    do
    {
      unint64_t *result = *v11;
      unint64_t v12 = *v11;
      uint64_t v13 = v6[4];
      if (v12 >> 39 < (v6[5] - v13) >> 3
        && (uint64_t v14 = *(void *)(v13 + 8 * (v12 >> 39))) != 0
        && (unint64_t v15 = *(unsigned __int16 *)(v14 + 2 * (HIDWORD(v12) & 0x7F)),
            uint64_t v17 = v6[7],
            uint64_t v16 = v6[8],
            v15 < (v16 - v17) >> 3)
        && ((unint64_t v18 = HIDWORD(v12), v19 = v17 + 8 * v15, v19 != v16)
          ? (BOOL v20 = *(_DWORD *)(v19 + 4) == v18)
          : (BOOL v20 = 0),
            v20))
      {
        uint64_t v21 = v6[11];
        uint64_t v22 = v6[10] + 33 * v15;
      }
      else
      {
        uint64_t v21 = v6[11];
        uint64_t v22 = v21;
      }
      if (v22 == v21) {
        uint64_t v23 = 0;
      }
      else {
        uint64_t v23 = v22;
      }
      *(unsigned char *)(v23 + 16) = 1;
      v24 = v48;
      v11 = *(unint64_t **)(v45 + 32);
      if (++v48 != v11)
      {
        uint64_t v25 = v46[4];
        unint64_t v26 = (v46[5] - v25) >> 3;
        v27 = v24 + 2;
        while (1)
        {
          unint64_t v28 = *((unsigned int *)v27 - 1);
          unint64_t v29 = v28 >> 7;
          if (v28 >> 7 < v26)
          {
            uint64_t v30 = *(void *)(v25 + 8 * v29);
            if (v30)
            {
              unint64_t v31 = *(unsigned __int16 *)(v30 + 2 * (v28 & 0x7F));
              uint64_t v33 = v46[7];
              uint64_t v32 = v46[8];
              if (v31 < (v32 - v33) >> 3)
              {
                uint64_t v34 = v33 + 8 * v31;
                if (v34 != v32 && *(_DWORD *)(v34 + 4) == v28)
                {
                  uint64_t v36 = v47[4];
                  if (v29 < (v47[5] - v36) >> 3)
                  {
                    uint64_t v37 = *(void *)(v36 + 8 * v29);
                    if (v37)
                    {
                      unint64_t v38 = *(unsigned __int16 *)(v37 + 2 * (v28 & 0x7F));
                      uint64_t v39 = v47[7];
                      uint64_t v40 = v47[8];
                      if (v38 < (v40 - v39) >> 3)
                      {
                        uint64_t v41 = v39 + 8 * v38;
                        if (v41 != v40 && *(_DWORD *)(v41 + 4) == v28) {
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          v48 = v27;
          BOOL v20 = v27++ == v11;
          if (v20) {
            goto LABEL_9;
          }
        }
        v11 = v27 - 1;
      }
LABEL_9:
      ;
    }
    while (v44 != v11);
  }
  unint64_t *result = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0;
  return result;
}

uint64_t gdc::Registry::storageTuple<md::ls::PositionScaleInfoConstantDataHandle,md::ls::StyleRouteLineMaskConstantDataHandle,md::ls::StyleConstantHandle,md::ls::LandCoverSettingsConstantDataHandle,md::ls::StyleGroundOcclusionConstantDataHandle,md::ls::ColorRampDataHandle,md::ls::NormalsHandle,md::ls::UVsHandle,md::ls::ElevationHandle,md::ls::InstanceTransformHandle,md::ls::UniqueStyleEmissiveDataKeyHandle,md::ls::NeedsClimateTint>(uint64_t *a1, int8x8_t *a2)
{
  uint64_t v4 = gdc::Registry::storage<md::ls::PositionScaleInfoConstantDataHandle>(a2);
  uint64_t v33 = 0x6E0342375BBCD967;
  v5 = a2 + 15;
  int8x8_t v6 = a2[16];
  if (!*(void *)&v6) {
    goto LABEL_21;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v8 = 0x6E0342375BBCD967;
    if (*(void *)&v6 <= 0x6E0342375BBCD967uLL) {
      uint64_t v8 = 0x6E0342375BBCD967uLL % *(void *)&v6;
    }
  }
  else
  {
    uint64_t v8 = (*(void *)&v6 - 1) & 0x6E0342375BBCD967;
  }
  uint64_t v9 = *(void **)(*(void *)v5 + 8 * v8);
  if (!v9 || (v10 = (void *)*v9) == 0) {
LABEL_21:
  }
    operator new();
  if (v7.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v12 = v10[1];
      if (v12 == 0x6E0342375BBCD967)
      {
        if (v10[2] == 0x6E0342375BBCD967) {
          goto LABEL_43;
        }
      }
      else if ((v12 & (*(void *)&v6 - 1)) != v8)
      {
        goto LABEL_21;
      }
      v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v11 = v10[1];
    if (v11 == 0x6E0342375BBCD967) {
      break;
    }
    if (v11 >= *(void *)&v6) {
      v11 %= *(void *)&v6;
    }
    if (v11 != v8) {
      goto LABEL_21;
    }
LABEL_11:
    v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_21;
    }
  }
  if (v10[2] != 0x6E0342375BBCD967) {
    goto LABEL_11;
  }
LABEL_43:
  uint64_t v28 = v10[3];
  uint64_t v33 = 0x7DD7F5B95CA3FF88;
  uint64_t v31 = v4;
  uint64_t v32 = a1;
  uint8x8_t v13 = (uint8x8_t)vcnt_s8(v6);
  v13.i16[0] = vaddlv_u8(v13);
  if (v13.u32[0] > 1uLL)
  {
    uint64_t v14 = 0x7DD7F5B95CA3FF88;
    if (*(void *)&v6 <= 0x7DD7F5B95CA3FF88uLL) {
      uint64_t v14 = 0x7DD7F5B95CA3FF88uLL % *(void *)&v6;
    }
  }
  else
  {
    uint64_t v14 = (*(void *)&v6 - 1) & 0x7DD7F5B95CA3FF88;
  }
  unint64_t v15 = *(void **)(*(void *)v5 + 8 * v14);
  if (!v15 || (uint64_t v16 = (void *)*v15) == 0) {
LABEL_42:
  }
    operator new();
  if (v13.u32[0] < 2uLL)
  {
    uint64_t v17 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v19 = v16[1];
      if (v19 == 0x7DD7F5B95CA3FF88)
      {
        if (v16[2] == 0x7DD7F5B95CA3FF88) {
          goto LABEL_44;
        }
      }
      else if ((v19 & v17) != v14)
      {
        goto LABEL_42;
      }
      uint64_t v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_42;
      }
    }
  }
  while (2)
  {
    unint64_t v18 = v16[1];
    if (v18 != 0x7DD7F5B95CA3FF88)
    {
      if (v18 >= *(void *)&v6) {
        v18 %= *(void *)&v6;
      }
      if (v18 != v14) {
        goto LABEL_42;
      }
      goto LABEL_32;
    }
    if (v16[2] != 0x7DD7F5B95CA3FF88)
    {
LABEL_32:
      uint64_t v16 = (void *)*v16;
      if (!v16) {
        goto LABEL_42;
      }
      continue;
    }
    break;
  }
LABEL_44:
  uint64_t v29 = v16[3];
  uint64_t v30 = gdc::Registry::storage<md::ls::LandCoverSettingsConstantDataHandle>(a2);
  uint64_t v20 = gdc::Registry::storage<md::ls::StyleGroundOcclusionConstantDataHandle>(a2);
  uint64_t v21 = gdc::Registry::storage<md::ls::ColorRampDataHandle>(a2);
  uint64_t v22 = gdc::Registry::storage<md::ls::NormalsHandle>(a2);
  uint64_t v23 = gdc::Registry::storage<md::ls::UVsHandle>(a2);
  uint64_t v24 = gdc::Registry::storage<md::ls::ElevationHandle>(a2);
  uint64_t v25 = gdc::Registry::storage<md::ls::InstanceTransformHandle>(a2);
  uint64_t v26 = gdc::Registry::storage<md::ls::UniqueStyleEmissiveDataKeyHandle>(a2);
  uint64_t result = gdc::Registry::storage<md::ls::NeedsClimateTint>(a2);
  *uint64_t v32 = v31;
  v32[1] = v28;
  v32[2] = v29;
  v32[3] = v30;
  v32[4] = v20;
  v32[5] = v21;
  v32[6] = v22;
  v32[7] = v23;
  v32[8] = v24;
  v32[9] = v25;
  v32[10] = v26;
  v32[11] = result;
  return result;
}

void sub_1A1A67EFC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::StyleGroundOcclusionConstantDataHandle>(int8x8_t *a1)
{
  unint64_t v10 = 0xD5AD9B8C3FE62EE8;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xD5AD9B8C3FE62EE8;
    if (*(void *)&v1 <= 0xD5AD9B8C3FE62EE8) {
      unint64_t v3 = 0xD5AD9B8C3FE62EE8 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xD5AD9B8C3FE62EE8;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xD5AD9B8C3FE62EE8)
      {
        if (v5[2] == 0xD5AD9B8C3FE62EE8) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xD5AD9B8C3FE62EE8) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xD5AD9B8C3FE62EE8) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A68170(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::NeedsClimateTint>(int8x8_t *a1)
{
  uint64_t v10 = 0x11BB47B172EB0B40;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x11BB47B172EB0B40;
    if (*(void *)&v1 <= 0x11BB47B172EB0B40uLL) {
      uint64_t v3 = 0x11BB47B172EB0B40uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x11BB47B172EB0B40;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x11BB47B172EB0B40)
      {
        if (v5[2] == 0x11BB47B172EB0B40) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x11BB47B172EB0B40) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x11BB47B172EB0B40) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A683E0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::LandCoverSettingsConstantDataHandle>(int8x8_t *a1)
{
  unint64_t v10 = 0xDC98991DB7473274;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xDC98991DB7473274;
    if (*(void *)&v1 <= 0xDC98991DB7473274) {
      unint64_t v3 = 0xDC98991DB7473274 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xDC98991DB7473274;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xDC98991DB7473274)
      {
        if (v5[2] == 0xDC98991DB7473274) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xDC98991DB7473274) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xDC98991DB7473274) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A68650(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfMaterialRequiresEmissiveColor>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfMaterialRequiresEmissiveColor>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  unint64_t v3 = *(int8x8_t **)(a2 + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::MaterialPendingProcessing>(v3);
  v5 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialData>(v3);
  uint64_t v6 = (void *)gdc::Registry::storage<md::ls::UniqueStyleEmissiveDataKeyHandle>(v3);
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v7 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v7 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v93, v7, v4, v5, *(void *)(v7 + 24));
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v91, v8, v4, v5, *(void *)(v8 + 32));
  if (v92 != v96)
  {
    unint64_t v10 = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    v90 = v10;
    while (1)
    {
      unint64_t *v10 = *v9;
      unint64_t v11 = *v9;
      unint64_t v12 = HIDWORD(*v9);
      unint64_t v13 = v11 >> 39;
      uint64_t v14 = v6[4];
      if (v11 >> 39 < (v6[5] - v14) >> 3
        && (uint64_t v15 = *(void *)(v14 + 8 * v13)) != 0
        && (unint64_t v16 = *(unsigned __int16 *)(v15 + 2 * (HIDWORD(v11) & 0x7F)),
            uint64_t v18 = v6[7],
            uint64_t v17 = v6[8],
            v16 < (v17 - v18) >> 3)
        && ((uint64_t v19 = v18 + 8 * v16, v19 != v17) ? (v20 = *(_DWORD *)(v19 + 4) == v12) : (v20 = 0), v20))
      {
        uint64_t v21 = v6[11];
        uint64_t v22 = v6[10] + 8 * v16;
      }
      else
      {
        uint64_t v21 = v6[11];
        uint64_t v22 = v21;
      }
      if (v22 == v21) {
        uint64_t v23 = 0;
      }
      else {
        uint64_t v23 = (unint64_t *)v22;
      }
      uint64_t v24 = v5[4];
      if (v13 < (v5[5] - v24) >> 3
        && (uint64_t v25 = *(void *)(v24 + 8 * v13)) != 0
        && (unint64_t v26 = *(unsigned __int16 *)(v25 + 2 * (HIDWORD(v11) & 0x7F)),
            uint64_t v28 = v5[7],
            uint64_t v27 = v5[8],
            v26 < (v27 - v28) >> 3)
        && ((uint64_t v29 = v28 + 8 * v26, v29 != v27) ? (v30 = *(_DWORD *)(v29 + 4) == v12) : (v30 = 0), v30))
      {
        uint64_t v31 = v5[11];
        uint64_t v32 = v5[10] + 24 * v26;
      }
      else
      {
        uint64_t v31 = v5[11];
        uint64_t v32 = v31;
      }
      if (v32 == v31) {
        uint64_t v33 = 0;
      }
      else {
        uint64_t v33 = (unint64_t *)v32;
      }
      uint64_t v34 = **(void **)(a1 + 8);
      v35 = *(void **)v34;
      uint64_t v36 = *(void **)(v34 + 8);
      if (v35 != v36)
      {
        while (*v35 != 0x41D4E9297E100630)
        {
          v35 += 5;
          if (v35 == v36) {
            goto LABEL_40;
          }
        }
      }
      if (v35 == v36)
      {
LABEL_40:
        uint64_t v37 = 0;
      }
      else
      {
        uint64_t v37 = (int8x8_t *)v35[3];
        unint64_t v38 = (std::__shared_weak_count *)v35[4];
        if (v38)
        {
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
            std::__shared_weak_count::__release_weak(v38);
          }
        }
      }
      uint64_t v39 = **(void **)(a1 + 8);
      uint64_t v40 = *(void **)v39;
      uint64_t v41 = *(void **)(v39 + 8);
      if (v40 != v41)
      {
        while (*v40 != 0x4EDAD23DFB014132)
        {
          v40 += 5;
          if (v40 == v41) {
            goto LABEL_49;
          }
        }
      }
      if (v40 == v41)
      {
LABEL_49:
        uint64_t v43 = 0;
      }
      else
      {
        uint64_t v43 = v40[3];
        v42 = (std::__shared_weak_count *)v40[4];
        if (v42)
        {
          atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
        }
      }
      unint64_t v44 = *v33;
      v100 = (void (**)(void **))v44;
      uint64_t v45 = *(void *)(v43 + 120);
      if (v44 >= (unint64_t)((*(void *)(v43 + 128) - v45) >> 3)) {
        goto LABEL_58;
      }
      v46 = *(void (***)(void **))(v45 + 8 * v44);
      if (!v46) {
        goto LABEL_59;
      }
      if (HIDWORD(v44) != HIDWORD(v46)
        || ((uint64_t v47 = *(void *)(v43 + 144), v48 = (void **)(v47 + 8 * v46), v48 != *(void ***)(v43 + 152))
          ? (BOOL v49 = v47 == 0)
          : (BOOL v49 = 1),
            v49))
      {
LABEL_58:
        v46 = 0;
      }
      else
      {
        v89 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>(v43 + 56, v44, &v100);
        ++v89[3];
        v46 = (void (**)(void **))*v48;
      }
LABEL_59:
      v50 = *(int8x8_t **)v43;
      v103 = v46;
      *(void *)&long long v104 = 0;
      gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(&v97, v50, (uint64_t *)&v103, 0);
      uint64_t v51 = v97;
      int v52 = (*(uint64_t (**)(uint64_t))(*(void *)v97 + 984))(v97);
      int v53 = (*(uint64_t (**)(uint64_t))(*(void *)v51 + 176))(v51);
      if (((v52 | v53) & 1) == 0)
      {
        unint64_t v10 = v90;
        if (v23)
        {
          unint64_t v60 = *v90;
          v61 = *(void **)(a1 + 8);
          v100 = (void (**)(void **))&unk_1EF526B10;
          *(void *)&long long v101 = v60;
          v102 = (void **)&v100;
          v105 = (void **)&v103;
          v103 = (void (**)(void **))&unk_1EF526B10;
          *(void *)&long long v104 = v60;
          int v106 = 1;
          ecs2::Runtime::queueCommand(v61, (uint64_t)&v103);
          if (v106 != -1) {
            ((void (*)(char *, void (***)(void **)))off_1EF590540[v106])(&v99, &v103);
          }
          int v106 = -1;
          if (v102 == (void **)&v100)
          {
            v100[4]((void **)&v100);
          }
          else if (v102)
          {
            (*((void (**)(void))*v102 + 5))();
          }
          md::VKMRenderResourcesStore::disconnect<geo::handle<md::CachedKey<md::StyleEmissiveColorCacheKey>>>(v37, *v23);
        }
LABEL_92:
        v69 = v98;
        if (v98) {
          goto LABEL_93;
        }
        goto LABEL_95;
      }
      if (v52)
      {
        float v54 = **(float **)(v51 + 48);
        v55 = *(void **)(v51 + 16);
        unint64_t v10 = v90;
        if (!v55
          || ((unsigned __int8 v56 = gms::_Material<ggl::Texture2D>::zoomable(v55, 0x1Cu), v54 < 1.0)
            ? (unsigned __int8 v57 = v56)
            : (unsigned __int8 v57 = 0),
              (v57 & 1) == 0))
        {
          v58 = *(void **)(v51 + 32);
          if (v58)
          {
            unsigned int v59 = 28;
LABEL_82:
            gms::_Material<ggl::Texture2D>::zoomable(v58, v59);
          }
        }
      }
      else
      {
        unint64_t v10 = v90;
        if (v53)
        {
          float v62 = **(float **)(v51 + 48);
          v63 = *(void **)(v51 + 16);
          if (!v63
            || ((unsigned __int8 v64 = gms::_Material<ggl::Texture2D>::zoomable(v63, 7u), v62 < 1.0)
              ? (unsigned __int8 v65 = v64)
              : (unsigned __int8 v65 = 0),
                (v65 & 1) == 0))
          {
            v58 = *(void **)(v51 + 32);
            if (v58)
            {
              unsigned int v59 = 7;
              goto LABEL_82;
            }
          }
        }
      }
      if (v23) {
        goto LABEL_92;
      }
      v103 = (void (**)(void **))v33[1];
      v100 = v103;
      unint64_t v66 = md::VKMRenderResourcesStore::addKey<md::StyleEmissiveColorCacheKey>((uint64_t)v37, (uint64_t *)&v103, (unint64_t)&v100);
      unint64_t v67 = *v10;
      v68 = *(void **)(a1 + 8);
      v100 = (void (**)(void **))&unk_1EF525C70;
      *(void *)&long long v101 = v66;
      *((void *)&v101 + 1) = v67;
      v102 = (void **)&v100;
      v105 = (void **)&v103;
      v103 = (void (**)(void **))&unk_1EF525C70;
      long long v104 = v101;
      int v106 = 0;
      ecs2::Runtime::queueCommand(v68, (uint64_t)&v103);
      if (v106 != -1) {
        ((void (*)(char *, void (***)(void **)))off_1EF590540[v106])(&v99, &v103);
      }
      int v106 = -1;
      if (v102 != (void **)&v100)
      {
        if (v102)
        {
          (*((void (**)(void))*v102 + 5))();
          v69 = v98;
          if (v98) {
            goto LABEL_93;
          }
          goto LABEL_95;
        }
        goto LABEL_92;
      }
      v100[4]((void **)&v100);
      v69 = v98;
      if (v98)
      {
LABEL_93:
        if (!atomic_fetch_add(&v69->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v69->__on_zero_shared)(v69);
          std::__shared_weak_count::__release_weak(v69);
        }
      }
LABEL_95:
      v70 = v96;
      uint64_t v9 = *(unint64_t **)(v93 + 32);
      if (++v96 != v9)
      {
        uint64_t v71 = v94[4];
        unint64_t v72 = (v94[5] - v71) >> 3;
        v73 = v70 + 2;
        while (1)
        {
          unint64_t v74 = *((unsigned int *)v73 - 1);
          unint64_t v75 = v74 >> 7;
          if (v74 >> 7 < v72)
          {
            uint64_t v76 = *(void *)(v71 + 8 * v75);
            if (v76)
            {
              unint64_t v77 = *(unsigned __int16 *)(v76 + 2 * (v74 & 0x7F));
              uint64_t v79 = v94[7];
              uint64_t v78 = v94[8];
              if (v77 < (v78 - v79) >> 3)
              {
                uint64_t v80 = v79 + 8 * v77;
                if (v80 != v78 && *(_DWORD *)(v80 + 4) == v74)
                {
                  uint64_t v82 = v95[4];
                  if (v75 < (v95[5] - v82) >> 3)
                  {
                    uint64_t v83 = *(void *)(v82 + 8 * v75);
                    if (v83)
                    {
                      unint64_t v84 = *(unsigned __int16 *)(v83 + 2 * (v74 & 0x7F));
                      uint64_t v86 = v95[7];
                      uint64_t v85 = v95[8];
                      if (v84 < (v85 - v86) >> 3)
                      {
                        uint64_t v87 = v86 + 8 * v84;
                        if (v87 != v85 && *(_DWORD *)(v87 + 4) == v74) {
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          v96 = v73;
          BOOL v20 = v73++ == v9;
          if (v20) {
            goto LABEL_9;
          }
        }
        uint64_t v9 = v73 - 1;
      }
LABEL_9:
      if (v92 == v9) {
        goto LABEL_120;
      }
    }
  }
  unint64_t v10 = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
LABEL_120:
  unint64_t *v10 = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0;
}

void sub_1A1A68ED8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,std::__shared_weak_count *a24)
{
  if (a24)
  {
    if (!atomic_fetch_add(&a24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a24->__on_zero_shared)(a24);
      std::__shared_weak_count::__release_weak(a24);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t gdc::Registry::storage<md::ls::UniqueStyleEmissiveDataKeyHandle>(int8x8_t *a1)
{
  unint64_t v10 = 0xEBDB618C34E97A19;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xEBDB618C34E97A19;
    if (*(void *)&v1 <= 0xEBDB618C34E97A19) {
      unint64_t v3 = 0xEBDB618C34E97A19 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xEBDB618C34E97A19;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xEBDB618C34E97A19)
      {
        if (v5[2] == 0xEBDB618C34E97A19) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xEBDB618C34E97A19) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xEBDB618C34E97A19) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A69174(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::MaterialPendingProcessing>(int8x8_t *a1)
{
  unint64_t v10 = 0xCE1B2B8E676E76D8;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xCE1B2B8E676E76D8;
    if (*(void *)&v1 <= 0xCE1B2B8E676E76D8) {
      unint64_t v3 = 0xCE1B2B8E676E76D8 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xCE1B2B8E676E76D8;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xCE1B2B8E676E76D8)
      {
        if (v5[2] == 0xCE1B2B8E676E76D8) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xCE1B2B8E676E76D8) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xCE1B2B8E676E76D8) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A693E4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::LandCoverSettings>>>(int8x8_t *a1)
{
  uint64_t v10 = 0x6635AEA306F3CF3ELL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x6635AEA306F3CF3ELL;
    if (*(void *)&v1 <= 0x6635AEA306F3CF3EuLL) {
      uint64_t v3 = 0x6635AEA306F3CF3EuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x6635AEA306F3CF3ELL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x6635AEA306F3CF3ELL)
      {
        if (v5[2] == 0x6635AEA306F3CF3ELL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x6635AEA306F3CF3ELL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x6635AEA306F3CF3ELL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A69654(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareMeshRenderableBounds>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareMeshRenderableBounds>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A69BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v15)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::BoundZScale const&,md::ls::BoundZAdjust const&,md::ls::MeshRenderableBounds const&,md::BoundData &>>::~Model()
{
}

void ecs2::Query<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::GeocentricBounds const&,md::ls::SliceAssignmentT<(md::SliceType)0> const&,md::ls::MeshRenderableTransformConstantDataHandle const&,md::ls::MeshRenderableBounds const&,md::BoundData &>>::~Model()
{
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorFog>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorFog>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A6A050(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants &,md::ls::IsMaterial const&,md::ls::MainPassItem const&>>::~Model()
{
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::AssignFlyoverNightTextureIndex>,std::allocator<ecs2::ForwardToExecute<md::ita::AssignFlyoverNightTextureIndex>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  *(void *)(a1 + 8) = a2;
  uint64_t v3 = *(int8x8_t **)(a2 + 8);
  uint64_t v4 = gdc::Registry::storage<md::ls::RequiresShaderTextureID<Flyover::NightTexture>>(v3);
  v5 = (void *)gdc::Registry::storage<md::ls::TextureHandleForType<Flyover::NightTexture>>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::FlyoverInstance>(v3);
  uint64_t v7 = gdc::Registry::storage<md::ls::PipelineSetup>(v3);
  uint64_t v8 = (void *)v7;
  uint64_t v9 = (void *)(v4 + 32);
  if (v5[8] - v5[7] < *(void *)(v4 + 64) - *(void *)(v4 + 56)) {
    uint64_t v9 = v5 + 4;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) < v9[4] - v9[3]) {
    uint64_t v9 = (void *)(v6 + 32);
  }
  if (*(void *)(v7 + 64) - *(void *)(v7 + 56) < v9[4] - v9[3]) {
    uint64_t v9 = (void *)(v7 + 32);
  }
  v156 = v9;
  v157 = (void *)v4;
  v158 = v5;
  v159 = (void *)v6;
  unint64_t v11 = (void *)v9[3];
  uint64_t v10 = (void *)v9[4];
  v160 = (void *)v7;
  v161 = v11;
  v155 = v10;
  if (v10 != v11
    && !gdc::RegistryQueryView<gdc::All<md::ls::RequiresShaderTextureID<Flyover::NightTexture> const,md::ls::TextureHandleForType<Flyover::NightTexture> const,md::ls::FlyoverInstance const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v156))
  {
    unint64_t v12 = v11 + 1;
    do
    {
      unint64_t v11 = v12;
      v161 = v12;
      if (v12 == v155) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RequiresShaderTextureID<Flyover::NightTexture> const,md::ls::TextureHandleForType<Flyover::NightTexture> const,md::ls::FlyoverInstance const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v156);
      unint64_t v12 = v11 + 1;
    }
    while (!isValid);
  }
  v154 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  if (v155 != v11)
  {
    uint64_t v152 = v2;
    v153 = v5;
    do
    {
      void *v154 = *v11;
      unint64_t v14 = *v11;
      uint64_t v15 = HIDWORD(*v11);
      unint64_t v16 = *v11 >> 39;
      uint64_t v17 = v5[4];
      if (v16 < (v5[5] - v17) >> 3
        && (uint64_t v18 = *(void *)(v17 + 8 * v16)) != 0
        && (unint64_t v19 = *(unsigned __int16 *)(v18 + 2 * (HIDWORD(v14) & 0x7F)),
            uint64_t v21 = v5[7],
            uint64_t v20 = v5[8],
            v19 < (v20 - v21) >> 3)
        && ((uint64_t v22 = v21 + 8 * v19, v22 != v20) ? (v23 = *(_DWORD *)(v22 + 4) == v15) : (v23 = 0), v23))
      {
        uint64_t v24 = (unint64_t *)(v5[10] + 8 * v19);
      }
      else
      {
        uint64_t v24 = (unint64_t *)v5[11];
      }
      uint64_t v25 = v8[4];
      if (v16 < (v8[5] - v25) >> 3
        && (uint64_t v26 = *(void *)(v25 + 8 * v16)) != 0
        && (unint64_t v27 = *(unsigned __int16 *)(v26 + 2 * (HIDWORD(v14) & 0x7F)),
            uint64_t v29 = v8[7],
            uint64_t v28 = v8[8],
            v27 < (v28 - v29) >> 3)
        && ((uint64_t v30 = v29 + 8 * v27, v30 != v28) ? (v31 = *(_DWORD *)(v30 + 4) == v15) : (v31 = 0), v31))
      {
        uint64_t v32 = v8[11];
        uint64_t v33 = v8[10] + 8 * v27;
      }
      else
      {
        uint64_t v32 = v8[11];
        uint64_t v33 = v32;
      }
      if (v33 == v32) {
        uint64_t v34 = 0;
      }
      else {
        uint64_t v34 = (unint64_t *)v33;
      }
      uint64_t v35 = **(void **)(v2 + 8);
      uint64_t v36 = *(void **)v35;
      uint64_t v37 = *(void **)(v35 + 8);
      if (v36 != v37)
      {
        while (*v36 != 0x41D4E9297E100630)
        {
          v36 += 5;
          if (v36 == v37) {
            goto LABEL_43;
          }
        }
      }
      if (v36 == v37)
      {
LABEL_43:
        uint64_t v39 = 0;
      }
      else
      {
        uint64_t v39 = (void *)v36[3];
        unint64_t v38 = (std::__shared_weak_count *)v36[4];
        if (v38)
        {
          atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
            std::__shared_weak_count::__release_weak(v38);
          }
        }
      }
      uint64_t v40 = **(void **)(v2 + 8);
      uint64_t v41 = *(void **)v40;
      v42 = *(void **)(v40 + 8);
      if (v41 != v42)
      {
        while (*v41 != 0x348A0B0E758C07C2)
        {
          v41 += 5;
          if (v41 == v42) {
            goto LABEL_52;
          }
        }
      }
      if (v41 == v42)
      {
LABEL_52:
        uint64_t v43 = 0;
      }
      else
      {
        uint64_t v43 = v41[3];
        unint64_t v44 = (std::__shared_weak_count *)v41[4];
        if (v44)
        {
          atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
            std::__shared_weak_count::__release_weak(v44);
          }
        }
      }
      uint64_t v45 = (uint64_t)(v39 + 37);
      unint64_t v46 = *v34;
      unint64_t v47 = *v34;
      uint64_t v48 = v39[50];
      unint64_t v49 = (v39[51] - v48) >> 3;
      if (v47 < v49
        && (uint64_t v50 = *(void *)(v48 + 8 * v47)) != 0
        && HIDWORD(v46) == HIDWORD(v50)
        && ((uint64_t v51 = v39[53], v51 + 16 * v50 != v39[54]) ? (v52 = v51 == 0) : (v52 = 1), !v52))
      {
        uint64_t v61 = *(void *)(v48 + 8 * v47);
        float v62 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v39 + 37), v46, v34);
        ++v62[3];
        uint64_t v63 = v51 + 16 * v61;
        uint64_t v2 = v152;
        int v53 = *(void **)(v63 + 8);
        unint64_t v46 = *v34;
        uint64_t v48 = v39[50];
        unint64_t v47 = *v34;
        if (v47 >= (v39[51] - v48) >> 3) {
          goto LABEL_72;
        }
      }
      else
      {
        int v53 = 0;
        if (v47 >= v49) {
          goto LABEL_72;
        }
      }
      uint64_t v54 = *(void *)(v48 + 8 * v47);
      if (!v54
        || HIDWORD(v46) != HIDWORD(v54)
        || ((v55 = v39[53], unsigned __int8 v56 = (uint64_t *)v39[54], v57 = (uint64_t *)(v55 + 16 * v54), v57 != v56)
          ? (BOOL v58 = v55 == 0)
          : (BOOL v58 = 1),
            v58))
      {
LABEL_72:
        uint64_t v60 = 0;
        goto LABEL_73;
      }
      unsigned int v59 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>(v45, v46, v34);
      ++v59[3];
      uint64_t v60 = *v57;
LABEL_73:
      unint64_t v64 = *v24;
      unint64_t v162 = v64;
      std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v43 + 104));
      uint64_t v65 = *(void *)(v43 + 504);
      if (v64 < (unint64_t)((*(void *)(v43 + 512) - v65) >> 3)
        && ((uint64_t v66 = *(void *)(v65 + 8 * v64)) != 0 ? (v67 = HIDWORD(v64) == HIDWORD(v66)) : (v67 = 0),
            v67))
      {
        v69 = (uint64_t *)(*(void *)(v43 + 528) + 40 * v66);
        v68 = *(uint64_t **)(v43 + 536);
      }
      else
      {
        v68 = *(uint64_t **)(v43 + 536);
        v69 = v68;
      }
      std::__shared_mutex_base::unlock_shared((std::__shared_mutex_base *)(v43 + 104));
      v70 = std::__hash_table<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::__unordered_map_hasher<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::hash<geo::handle<mre::Texture>>,std::equal_to<geo::handle<mre::Texture>>,true>,std::__unordered_map_equal<geo::handle<mre::Texture>,std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>,std::equal_to<geo::handle<mre::Texture>>,std::hash<geo::handle<mre::Texture>>,true>,std::allocator<std::__hash_value_type<geo::handle<mre::Texture>,mre::GGLResourceStore::Counter>>>::__emplace_unique_key_args<geo::handle<mre::Texture>,std::piecewise_construct_t const&,std::tuple<geo::handle<mre::Texture> const&>,std::tuple<>>((float *)(v43 + 440), v162, &v162);
      uint64_t v71 = 0;
      ++v70[3];
      if (v69 != v68 && v69) {
        uint64_t v71 = *v69;
      }
      {
        gdc::typeIndex<Flyover::NightTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
      }
      unint64_t v72 = v53[1];
      if (!v72) {
        goto LABEL_154;
      }
      unint64_t v73 = gdc::typeIndex<Flyover::NightTexture>(void)::index;
      uint8x8_t v74 = (uint8x8_t)vcnt_s8((int8x8_t)v72);
      v74.i16[0] = vaddlv_u8(v74);
      if (v74.u32[0] > 1uLL)
      {
        uint64_t v75 = gdc::typeIndex<Flyover::NightTexture>(void)::index;
        if (gdc::typeIndex<Flyover::NightTexture>(void)::index >= v72) {
          uint64_t v75 = gdc::typeIndex<Flyover::NightTexture>(void)::index % v72;
        }
      }
      else
      {
        uint64_t v75 = (v72 - 1) & gdc::typeIndex<Flyover::NightTexture>(void)::index;
      }
      uint64_t v76 = *(void **)(*v53 + 8 * v75);
      if (!v76) {
        goto LABEL_154;
      }
      unint64_t v77 = (void *)*v76;
      if (!v77) {
        goto LABEL_154;
      }
      if (v74.u32[0] < 2uLL)
      {
        unint64_t v78 = v72 - 1;
        while (1)
        {
          uint64_t v80 = v77[1];
          if (gdc::typeIndex<Flyover::NightTexture>(void)::index == v80)
          {
            if (v77[2] == gdc::typeIndex<Flyover::NightTexture>(void)::index) {
              goto LABEL_105;
            }
          }
          else if ((v80 & v78) != v75)
          {
            goto LABEL_154;
          }
          unint64_t v77 = (void *)*v77;
          if (!v77) {
            goto LABEL_154;
          }
        }
      }
      while (1)
      {
        unint64_t v79 = v77[1];
        if (gdc::typeIndex<Flyover::NightTexture>(void)::index == v79) {
          break;
        }
        if (v79 >= v72) {
          v79 %= v72;
        }
        if (v79 != v75) {
          goto LABEL_154;
        }
LABEL_93:
        unint64_t v77 = (void *)*v77;
        if (!v77) {
          goto LABEL_154;
        }
      }
      if (v77[2] != gdc::typeIndex<Flyover::NightTexture>(void)::index) {
        goto LABEL_93;
      }
LABEL_105:
      {
        if (v151)
        {
          md::typeToIntMap(v151);
          uint64_t v2 = v152;
        }
      }
      if (!qword_1E957F030) {
        goto LABEL_196;
      }
      uint8x8_t v81 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
      v81.i16[0] = vaddlv_u8(v81);
      if (v81.u32[0] > 1uLL)
      {
        unint64_t v82 = v73;
        if (v73 >= qword_1E957F030) {
          unint64_t v82 = v73 % qword_1E957F030;
        }
      }
      else
      {
        unint64_t v82 = (qword_1E957F030 - 1) & v73;
      }
      uint64_t v83 = *(uint64_t ****)(md::typeToIntMap(void)::typeToIntMap + 8 * v82);
      if (!v83 || (unint64_t v84 = *v83) == 0) {
LABEL_196:
      }
        abort();
      if (v81.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v86 = v84[1];
          if ((uint64_t *)v73 == v86)
          {
            if (v84[2] == (uint64_t *)v73) {
              goto LABEL_126;
            }
          }
          else if (((unint64_t)v86 & (qword_1E957F030 - 1)) != v82)
          {
            goto LABEL_196;
          }
          unint64_t v84 = (uint64_t **)*v84;
          if (!v84) {
            goto LABEL_196;
          }
        }
      }
      while (2)
      {
        unint64_t v85 = (unint64_t)v84[1];
        if (v73 != v85)
        {
          if (v85 >= qword_1E957F030) {
            v85 %= (unint64_t)qword_1E957F030;
          }
          if (v85 != v82) {
            goto LABEL_196;
          }
LABEL_116:
          unint64_t v84 = (uint64_t **)*v84;
          if (!v84) {
            goto LABEL_196;
          }
          continue;
        }
        break;
      }
      if (v84[2] != (uint64_t *)v73) {
        goto LABEL_116;
      }
LABEL_126:
      uint64_t v88 = *((int *)v84 + 6);
      uint64_t v87 = *((int *)v84 + 7);
      if (v88 != -1)
      {
        uint64_t v89 = *(void *)(v60 + 16);
        if (v89)
        {
          uint64_t v90 = *(void *)(*(void *)(v89 + 48) + 72);
          uint64_t v91 = *(void *)(v90 + 8);
          uint64_t v92 = *(void *)(v91 + 72);
          if (v92)
          {
            uint64_t v93 = 0;
            uint64_t v94 = *(void *)(v91 + 64);
            v95 = (unsigned __int8 *)(v94 + 1);
            while (1)
            {
              int v96 = *v95;
              v95 += 2;
              if (v96 == v88) {
                break;
              }
              if (v92 == ++v93) {
                goto LABEL_132;
              }
            }
            v103 = (unsigned __int8 *)(v94 + 2 * v93);
LABEL_139:
            *(void *)(*(void *)(v60 + 96) + 8 * *v103) = v71;
          }
          else
          {
LABEL_132:
            uint64_t v97 = *(void *)(v90 + 24);
            uint64_t v98 = *(void *)(v97 + 72);
            if (v98)
            {
              uint64_t v99 = 0;
              uint64_t v100 = *(void *)(v97 + 64);
              long long v101 = (unsigned __int8 *)(v100 + 1);
              while (1)
              {
                int v102 = *v101;
                v101 += 2;
                if (v102 == v88) {
                  break;
                }
                if (v98 == ++v99) {
                  goto LABEL_140;
                }
              }
              v103 = (unsigned __int8 *)(v100 + 2 * v99);
              goto LABEL_139;
            }
          }
        }
      }
LABEL_140:
      if (v87 != -1)
      {
        uint64_t v104 = *(void *)(v60 + 16);
        if (v104)
        {
          uint64_t v105 = *(void *)(*(void *)(v104 + 48) + 72);
          uint64_t v106 = *(void *)(v105 + 8);
          uint64_t v107 = *(void *)(v106 + 72);
          if (v107)
          {
            uint64_t v108 = 0;
            uint64_t v109 = *(void *)(v106 + 64);
            v110 = (unsigned __int8 *)(v109 + 1);
            while (1)
            {
              int v111 = *v110;
              v110 += 2;
              if (v111 == v87) {
                break;
              }
              if (v107 == ++v108) {
                goto LABEL_146;
              }
            }
            v118 = (unsigned __int8 *)(v109 + 2 * v108);
LABEL_153:
            *(void *)(*(void *)(v60 + 96) + 8 * *v118) = v71;
          }
          else
          {
LABEL_146:
            uint64_t v112 = *(void *)(v105 + 24);
            uint64_t v113 = *(void *)(v112 + 72);
            if (v113)
            {
              uint64_t v114 = 0;
              uint64_t v115 = *(void *)(v112 + 64);
              v116 = (unsigned __int8 *)(v115 + 1);
              while (1)
              {
                int v117 = *v116;
                v116 += 2;
                if (v117 == v87) {
                  break;
                }
                if (v113 == ++v114) {
                  goto LABEL_154;
                }
              }
              v118 = (unsigned __int8 *)(v115 + 2 * v114);
              goto LABEL_153;
            }
          }
        }
      }
LABEL_154:
      unint64_t v11 = (void *)v156[4];
      v119 = v161 + 1;
      v161 = v119;
      if (v119 == v11)
      {
        v5 = v153;
      }
      else
      {
        uint64_t v120 = v157[4];
        v5 = v153;
        do
        {
          unint64_t v121 = *((unsigned int *)v119 + 1);
          unint64_t v122 = v121 >> 7;
          if (v121 >> 7 < (v157[5] - v120) >> 3)
          {
            uint64_t v123 = *(void *)(v120 + 8 * v122);
            if (v123)
            {
              uint64_t v124 = v121 & 0x7F;
              unint64_t v125 = *(unsigned __int16 *)(v123 + 2 * v124);
              uint64_t v127 = v157[7];
              uint64_t v126 = v157[8];
              if (v125 < (v126 - v127) >> 3)
              {
                uint64_t v128 = v127 + 8 * v125;
                if (v128 != v126 && *(_DWORD *)(v128 + 4) == v121)
                {
                  uint64_t v130 = v158[4];
                  if (v122 < (v158[5] - v130) >> 3)
                  {
                    uint64_t v131 = *(void *)(v130 + 8 * v122);
                    if (v131)
                    {
                      unint64_t v132 = *(unsigned __int16 *)(v131 + 2 * v124);
                      uint64_t v134 = v158[7];
                      uint64_t v133 = v158[8];
                      if (v132 < (v133 - v134) >> 3)
                      {
                        uint64_t v135 = v134 + 8 * v132;
                        if (v135 != v133 && *(_DWORD *)(v135 + 4) == v121)
                        {
                          uint64_t v137 = v159[4];
                          if (v122 < (v159[5] - v137) >> 3)
                          {
                            uint64_t v138 = *(void *)(v137 + 8 * v122);
                            if (v138)
                            {
                              unint64_t v139 = *(unsigned __int16 *)(v138 + 2 * v124);
                              uint64_t v141 = v159[7];
                              uint64_t v140 = v159[8];
                              if (v139 < (v140 - v141) >> 3)
                              {
                                uint64_t v142 = v141 + 8 * v139;
                                if (v142 != v140 && *(_DWORD *)(v142 + 4) == v121)
                                {
                                  uint64_t v144 = v160[4];
                                  if (v122 < (v160[5] - v144) >> 3)
                                  {
                                    uint64_t v145 = *(void *)(v144 + 8 * v122);
                                    if (v145)
                                    {
                                      unint64_t v146 = *(unsigned __int16 *)(v145 + 2 * v124);
                                      uint64_t v147 = v160[7];
                                      uint64_t v148 = v160[8];
                                      if (v146 < (v148 - v147) >> 3)
                                      {
                                        uint64_t v149 = v147 + 8 * v146;
                                        if (*(_DWORD *)(v149 + 4) == v121 && v149 != v148)
                                        {
                                          unint64_t v11 = v119;
                                          goto LABEL_190;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          ++v119;
        }
        while (v119 != v11);
        v119 = v11;
LABEL_190:
        v161 = v119;
      }
    }
    while (v155 != v11);
  }
  void *v154 = 0xFFFFFFFF00000000;
  *(void *)(v2 + 8) = 0;
}

void sub_1A1A6AA68(_Unwind_Exception *a1)
{
}

uint64_t gdc::Registry::access<gdc::ecs::Access<gdc::Read<md::ls::PendingDeletion const>,gdc::Write<md::ls::RenderableAlbedoTexture,md::ls::TextureHandleForType<Flyover::NightTexture>,md::ls::TextureHandleForType<Flyover::DiffuseTexture>,md::ls::UniqueMaterialAlbedoTexture,md::ls::UniqueMaterialEmissiveTexture,md::ls::UniqueMaterialDiffuseTexture>>>(uint64_t *a1, int8x8_t *a2)
{
  uint64_t v4 = gdc::Registry::storage<md::ls::PendingDeletion>(a2);
  uint64_t v5 = gdc::Registry::storage<md::ls::RenderableAlbedoTexture>(a2);
  uint64_t v6 = gdc::Registry::storage<md::ls::TextureHandleForType<Flyover::NightTexture>>(a2);
  uint64_t v7 = gdc::Registry::storage<md::ls::TextureHandleForType<Flyover::DiffuseTexture>>(a2);
  uint64_t v8 = gdc::Registry::storage<md::ls::UniqueMaterialAlbedoTexture>(a2);
  uint64_t v9 = gdc::Registry::storage<md::ls::UniqueMaterialEmissiveTexture>(a2);
  uint64_t result = gdc::Registry::storage<md::ls::UniqueMaterialDiffuseTexture>(a2);
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  a1[4] = v8;
  a1[5] = v9;
  a1[6] = result;
  return result;
}

void sub_1A1A6AB30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t gdc::Registry::storage<md::ls::TextureHandleForType<Flyover::NightTexture>>(int8x8_t *a1)
{
  unint64_t v10 = 0xD49B968135FE1A73;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xD49B968135FE1A73;
    if (*(void *)&v1 <= 0xD49B968135FE1A73) {
      unint64_t v3 = 0xD49B968135FE1A73 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xD49B968135FE1A73;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xD49B968135FE1A73)
      {
        if (v5[2] == 0xD49B968135FE1A73) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xD49B968135FE1A73) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xD49B968135FE1A73) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A6AD80(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::TextureHandleForType<Flyover::DiffuseTexture>>(int8x8_t *a1)
{
  unint64_t v10 = 0xBAA35DF429A7267FLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xBAA35DF429A7267FLL;
    if (*(void *)&v1 <= 0xBAA35DF429A7267FLL) {
      unint64_t v3 = 0xBAA35DF429A7267FLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xBAA35DF429A7267FLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xBAA35DF429A7267FLL)
      {
        if (v5[2] == 0xBAA35DF429A7267FLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xBAA35DF429A7267FLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xBAA35DF429A7267FLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A6AFF0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::RequiresShaderTextureID<Flyover::NightTexture>>(int8x8_t *a1)
{
  uint64_t v10 = 0xF9931FC5DA4F362;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0xF9931FC5DA4F362;
    if (*(void *)&v1 <= 0xF9931FC5DA4F362uLL) {
      uint64_t v3 = 0xF9931FC5DA4F362uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0xF9931FC5DA4F362;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xF9931FC5DA4F362)
      {
        if (v5[2] == 0xF9931FC5DA4F362) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xF9931FC5DA4F362) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xF9931FC5DA4F362) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A6B260(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::ResolveMaterialEmissiveTexture>,std::allocator<ecs2::ForwardToExecute<md::ita::ResolveMaterialEmissiveTexture>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A6B848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17 == v19)
  {
    (*(void (**)(uint64_t *))(a14 + 32))(&a14);
  }
  else if (a17)
  {
    (*(void (**)(void))(*(void *)a17 + 40))();
  }
  (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>::Model<ecs2::RuntimeQuery<md::ls::SharedMaterialEmissiveTexture &,md::ls::TextureHandleForType<DaVinci::EmissiveTexture> &>>::~Model()
{
}

void ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialEmissiveTexture &>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialData>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialEmissiveTexture>(v3);
  uint64_t v6 = v5;
  unint64_t v7 = v5 + 4;
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v58, v8, v4, v5, *(void *)(v8 + 24));
  if (v6[8] - v6[7] >= v4[8] - v4[7]) {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v9 = (uint64_t)v7;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v56, v9, v4, v6, *(void *)(v9 + 32));
  uint64_t v10 = (uint64_t (**)(void))&ecs2::Runtime::_localEntity;
  if (v57 == v61) {
    goto LABEL_55;
  }
  unint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *unint64_t v12 = *v11;
    unint64_t v13 = *v11;
    unint64_t v14 = HIDWORD(*v11);
    unint64_t v15 = v13 >> 39;
    uint64_t v16 = v4[4];
    if (v13 >> 39 >= (v4[5] - v16) >> 3) {
      goto LABEL_17;
    }
    uint64_t v17 = *(void *)(v16 + 8 * v15);
    if (!v17) {
      goto LABEL_17;
    }
    unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v13) & 0x7F));
    uint64_t v20 = v4[7];
    uint64_t v19 = v4[8];
    if (v18 >= (v19 - v20) >> 3) {
      goto LABEL_17;
    }
    uint64_t v21 = v20 + 8 * v18;
    BOOL v22 = v21 != v19 && *(_DWORD *)(v21 + 4) == v14;
    if (v22)
    {
      uint64_t v23 = v4[11];
      uint64_t v24 = v4[10] + 24 * v18;
    }
    else
    {
LABEL_17:
      uint64_t v23 = v4[11];
      uint64_t v24 = v23;
    }
    uint64_t v25 = v24 == v23 ? 0 : v24;
    uint64_t v26 = v6[4];
    if (v15 < (v6[5] - v26) >> 3)
    {
      uint64_t v27 = *(void *)(v26 + 8 * v15);
      if (v27)
      {
        unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v13) & 0x7F));
        uint64_t v30 = v6[7];
        uint64_t v29 = v6[8];
        if (v28 < (v29 - v30) >> 3)
        {
          uint64_t v31 = v30 + 8 * v28;
          if (v31 != v29 && *(_DWORD *)(v31 + 4) == v14) {
            break;
          }
        }
      }
    }
    uint64_t v33 = v6[11];
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a2 + 24);
    if (!v35) {
      goto LABEL_54;
    }
LABEL_29:
    if (v34 == v33) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v25, v36);
    unint64_t v38 = v61;
    unint64_t v11 = *(unint64_t **)(v58 + 32);
    if (++v61 != v11)
    {
      uint64_t v39 = v59[4];
      unint64_t v40 = (v59[5] - v39) >> 3;
      uint64_t v41 = v38 + 2;
      while (1)
      {
        unint64_t v42 = *((unsigned int *)v41 - 1);
        unint64_t v43 = v42 >> 7;
        if (v42 >> 7 < v40)
        {
          uint64_t v44 = *(void *)(v39 + 8 * v43);
          if (v44)
          {
            unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
            uint64_t v46 = v59[7];
            uint64_t result = v59[8];
            if (v45 < (result - v46) >> 3)
            {
              uint64_t v47 = v46 + 8 * v45;
              if (v47 != result && *(_DWORD *)(v47 + 4) == v42)
              {
                uint64_t v49 = v60[4];
                uint64_t result = v60[5] - v49;
                if (v43 < result >> 3)
                {
                  uint64_t v50 = *(void *)(v49 + 8 * v43);
                  if (v50)
                  {
                    unint64_t v51 = *(unsigned __int16 *)(v50 + 2 * (v42 & 0x7F));
                    uint64_t v53 = v60[7];
                    uint64_t v52 = v60[8];
                    uint64_t result = v52 - v53;
                    if (v51 < (v52 - v53) >> 3)
                    {
                      uint64_t v54 = v53 + 8 * v51;
                      if (v54 != v52 && *(_DWORD *)(v54 + 4) == v42) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v61 = v41;
        BOOL v22 = v41++ == v11;
        if (v22) {
          goto LABEL_9;
        }
      }
      unint64_t v11 = v41 - 1;
    }
LABEL_9:
    if (v57 == v11) {
      goto LABEL_56;
    }
  }
  uint64_t v33 = v6[11];
  uint64_t v34 = v6[10] + 8 * v28;
  uint64_t v35 = *(void *)(a2 + 24);
  if (v35) {
    goto LABEL_29;
  }
LABEL_54:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_55:
  uint64_t result = (*v10)();
  unint64_t v12 = (void *)result;
LABEL_56:
  *unint64_t v12 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::UniqueMaterialEmissiveTexture>(int8x8_t *a1)
{
  uint64_t v10 = 0x1202E9D2D9704CABLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x1202E9D2D9704CABLL;
    if (*(void *)&v1 <= 0x1202E9D2D9704CABuLL) {
      uint64_t v3 = 0x1202E9D2D9704CABuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x1202E9D2D9704CABLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x1202E9D2D9704CABLL)
      {
        if (v5[2] == 0x1202E9D2D9704CABLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x1202E9D2D9704CABLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x1202E9D2D9704CABLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A6BE60(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::ResolveMaterialDiffuseTexture>,std::allocator<ecs2::ForwardToExecute<md::ita::ResolveMaterialDiffuseTexture>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A6C448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17 == v19)
  {
    (*(void (**)(uint64_t *))(a14 + 32))(&a14);
  }
  else if (a17)
  {
    (*(void (**)(void))(*(void *)a17 + 40))();
  }
  (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>::Model<ecs2::RuntimeQuery<md::ls::SharedMaterialDiffuseTexture &,md::ls::TextureHandleForType<DaVinci::DiffuseTexture> &>>::~Model()
{
}

void ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialDiffuseTexture &>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialData>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialDiffuseTexture>(v3);
  uint64_t v6 = v5;
  unint64_t v7 = v5 + 4;
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v58, v8, v4, v5, *(void *)(v8 + 24));
  if (v6[8] - v6[7] >= v4[8] - v4[7]) {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v9 = (uint64_t)v7;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v56, v9, v4, v6, *(void *)(v9 + 32));
  uint64_t v10 = (uint64_t (**)(void))&ecs2::Runtime::_localEntity;
  if (v57 == v61) {
    goto LABEL_55;
  }
  unint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *unint64_t v12 = *v11;
    unint64_t v13 = *v11;
    unint64_t v14 = HIDWORD(*v11);
    unint64_t v15 = v13 >> 39;
    uint64_t v16 = v4[4];
    if (v13 >> 39 >= (v4[5] - v16) >> 3) {
      goto LABEL_17;
    }
    uint64_t v17 = *(void *)(v16 + 8 * v15);
    if (!v17) {
      goto LABEL_17;
    }
    unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v13) & 0x7F));
    uint64_t v20 = v4[7];
    uint64_t v19 = v4[8];
    if (v18 >= (v19 - v20) >> 3) {
      goto LABEL_17;
    }
    uint64_t v21 = v20 + 8 * v18;
    BOOL v22 = v21 != v19 && *(_DWORD *)(v21 + 4) == v14;
    if (v22)
    {
      uint64_t v23 = v4[11];
      uint64_t v24 = v4[10] + 24 * v18;
    }
    else
    {
LABEL_17:
      uint64_t v23 = v4[11];
      uint64_t v24 = v23;
    }
    uint64_t v25 = v24 == v23 ? 0 : v24;
    uint64_t v26 = v6[4];
    if (v15 < (v6[5] - v26) >> 3)
    {
      uint64_t v27 = *(void *)(v26 + 8 * v15);
      if (v27)
      {
        unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v13) & 0x7F));
        uint64_t v30 = v6[7];
        uint64_t v29 = v6[8];
        if (v28 < (v29 - v30) >> 3)
        {
          uint64_t v31 = v30 + 8 * v28;
          if (v31 != v29 && *(_DWORD *)(v31 + 4) == v14) {
            break;
          }
        }
      }
    }
    uint64_t v33 = v6[11];
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a2 + 24);
    if (!v35) {
      goto LABEL_54;
    }
LABEL_29:
    if (v34 == v33) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v25, v36);
    unint64_t v38 = v61;
    unint64_t v11 = *(unint64_t **)(v58 + 32);
    if (++v61 != v11)
    {
      uint64_t v39 = v59[4];
      unint64_t v40 = (v59[5] - v39) >> 3;
      uint64_t v41 = v38 + 2;
      while (1)
      {
        unint64_t v42 = *((unsigned int *)v41 - 1);
        unint64_t v43 = v42 >> 7;
        if (v42 >> 7 < v40)
        {
          uint64_t v44 = *(void *)(v39 + 8 * v43);
          if (v44)
          {
            unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
            uint64_t v46 = v59[7];
            uint64_t result = v59[8];
            if (v45 < (result - v46) >> 3)
            {
              uint64_t v47 = v46 + 8 * v45;
              if (v47 != result && *(_DWORD *)(v47 + 4) == v42)
              {
                uint64_t v49 = v60[4];
                uint64_t result = v60[5] - v49;
                if (v43 < result >> 3)
                {
                  uint64_t v50 = *(void *)(v49 + 8 * v43);
                  if (v50)
                  {
                    unint64_t v51 = *(unsigned __int16 *)(v50 + 2 * (v42 & 0x7F));
                    uint64_t v53 = v60[7];
                    uint64_t v52 = v60[8];
                    uint64_t result = v52 - v53;
                    if (v51 < (v52 - v53) >> 3)
                    {
                      uint64_t v54 = v53 + 8 * v51;
                      if (v54 != v52 && *(_DWORD *)(v54 + 4) == v42) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v61 = v41;
        BOOL v22 = v41++ == v11;
        if (v22) {
          goto LABEL_9;
        }
      }
      unint64_t v11 = v41 - 1;
    }
LABEL_9:
    if (v57 == v11) {
      goto LABEL_56;
    }
  }
  uint64_t v33 = v6[11];
  uint64_t v34 = v6[10] + 8 * v28;
  uint64_t v35 = *(void *)(a2 + 24);
  if (v35) {
    goto LABEL_29;
  }
LABEL_54:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_55:
  uint64_t result = (*v10)();
  unint64_t v12 = (void *)result;
LABEL_56:
  *unint64_t v12 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::UniqueMaterialDiffuseTexture>(int8x8_t *a1)
{
  unint64_t v10 = 0xCF2EB3C843EAD89ALL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xCF2EB3C843EAD89ALL;
    if (*(void *)&v1 <= 0xCF2EB3C843EAD89ALL) {
      unint64_t v3 = 0xCF2EB3C843EAD89ALL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xCF2EB3C843EAD89ALL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xCF2EB3C843EAD89ALL)
      {
        if (v5[2] == 0xCF2EB3C843EAD89ALL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xCF2EB3C843EAD89ALL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xCF2EB3C843EAD89ALL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A6CA60(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::ResolveMaterialAlbedoTexture>,std::allocator<ecs2::ForwardToExecute<md::ita::ResolveMaterialAlbedoTexture>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A6D298(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17 == v21)
  {
    (*(void (**)(uint64_t *))(a14 + 32))(&a14);
  }
  else if (a17)
  {
    (*(void (**)(void))(*(void *)a17 + 40))();
  }
  (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::SharedMaterialAlbedoTexture &,md::ls::TextureHandleForType<DaVinci::TexTexture> &>::Model<ecs2::RuntimeQuery<md::ls::SharedMaterialAlbedoTexture &,md::ls::TextureHandleForType<DaVinci::TexTexture> &>>::~Model()
{
}

void ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialAlbedoTexture &>>::~Model()
{
}

void ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::SharedMaterialAlbedoTexture const&>>::each(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::MeshRenderableID>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::SharedMaterialAlbedoTexture>(v3);
  uint64_t v6 = v5;
  unint64_t v7 = v5 + 4;
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v58, v8, v4, v5, *(void *)(v8 + 24));
  if (v6[8] - v6[7] >= v4[8] - v4[7]) {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v9 = (uint64_t)v7;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v56, v9, v4, v6, *(void *)(v9 + 32));
  unint64_t v10 = (uint64_t (**)(void))&ecs2::Runtime::_localEntity;
  if (v57 == v61) {
    goto LABEL_55;
  }
  unint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *unint64_t v12 = *v11;
    unint64_t v13 = *v11;
    unint64_t v14 = HIDWORD(*v11);
    unint64_t v15 = v13 >> 39;
    uint64_t v16 = v4[4];
    if (v13 >> 39 >= (v4[5] - v16) >> 3) {
      goto LABEL_17;
    }
    uint64_t v17 = *(void *)(v16 + 8 * v15);
    if (!v17) {
      goto LABEL_17;
    }
    unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v13) & 0x7F));
    uint64_t v20 = v4[7];
    uint64_t v19 = v4[8];
    if (v18 >= (v19 - v20) >> 3) {
      goto LABEL_17;
    }
    uint64_t v21 = v20 + 8 * v18;
    BOOL v22 = v21 != v19 && *(_DWORD *)(v21 + 4) == v14;
    if (v22)
    {
      uint64_t v23 = v4[11];
      uint64_t v24 = v4[10] + 8 * v18;
    }
    else
    {
LABEL_17:
      uint64_t v23 = v4[11];
      uint64_t v24 = v23;
    }
    uint64_t v25 = v24 == v23 ? 0 : v24;
    uint64_t v26 = v6[4];
    if (v15 < (v6[5] - v26) >> 3)
    {
      uint64_t v27 = *(void *)(v26 + 8 * v15);
      if (v27)
      {
        unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v13) & 0x7F));
        uint64_t v30 = v6[7];
        uint64_t v29 = v6[8];
        if (v28 < (v29 - v30) >> 3)
        {
          uint64_t v31 = v30 + 8 * v28;
          if (v31 != v29 && *(_DWORD *)(v31 + 4) == v14) {
            break;
          }
        }
      }
    }
    uint64_t v33 = v6[11];
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a2 + 24);
    if (!v35) {
      goto LABEL_54;
    }
LABEL_29:
    if (v34 == v33) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v25, v36);
    unint64_t v38 = v61;
    unint64_t v11 = *(unint64_t **)(v58 + 32);
    if (++v61 != v11)
    {
      uint64_t v39 = v59[4];
      unint64_t v40 = (v59[5] - v39) >> 3;
      uint64_t v41 = v38 + 2;
      while (1)
      {
        unint64_t v42 = *((unsigned int *)v41 - 1);
        unint64_t v43 = v42 >> 7;
        if (v42 >> 7 < v40)
        {
          uint64_t v44 = *(void *)(v39 + 8 * v43);
          if (v44)
          {
            unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
            uint64_t v46 = v59[7];
            uint64_t result = v59[8];
            if (v45 < (result - v46) >> 3)
            {
              uint64_t v47 = v46 + 8 * v45;
              if (v47 != result && *(_DWORD *)(v47 + 4) == v42)
              {
                uint64_t v49 = v60[4];
                uint64_t result = v60[5] - v49;
                if (v43 < result >> 3)
                {
                  uint64_t v50 = *(void *)(v49 + 8 * v43);
                  if (v50)
                  {
                    unint64_t v51 = *(unsigned __int16 *)(v50 + 2 * (v42 & 0x7F));
                    uint64_t v53 = v60[7];
                    uint64_t v52 = v60[8];
                    uint64_t result = v52 - v53;
                    if (v51 < (v52 - v53) >> 3)
                    {
                      uint64_t v54 = v53 + 8 * v51;
                      if (v54 != v52 && *(_DWORD *)(v54 + 4) == v42) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v61 = v41;
        BOOL v22 = v41++ == v11;
        if (v22) {
          goto LABEL_9;
        }
      }
      unint64_t v11 = v41 - 1;
    }
LABEL_9:
    if (v57 == v11) {
      goto LABEL_56;
    }
  }
  uint64_t v33 = v6[11];
  uint64_t v34 = v6[10] + 8 * v28;
  uint64_t v35 = *(void *)(a2 + 24);
  if (v35) {
    goto LABEL_29;
  }
LABEL_54:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_55:
  uint64_t result = (*v10)();
  unint64_t v12 = (void *)result;
LABEL_56:
  *unint64_t v12 = 0xFFFFFFFF00000000;
  return result;
}

void ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::RenderableAlbedoTexture const&>>::each(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::MeshRenderableID>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::RenderableAlbedoTexture>(v3);
  uint64_t v6 = v5;
  unint64_t v7 = v5 + 4;
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v58, v8, v4, v5, *(void *)(v8 + 24));
  if (v6[8] - v6[7] >= v4[8] - v4[7]) {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v9 = (uint64_t)v7;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v56, v9, v4, v6, *(void *)(v9 + 32));
  unint64_t v10 = (uint64_t (**)(void))&ecs2::Runtime::_localEntity;
  if (v57 == v61) {
    goto LABEL_55;
  }
  unint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *unint64_t v12 = *v11;
    unint64_t v13 = *v11;
    unint64_t v14 = HIDWORD(*v11);
    unint64_t v15 = v13 >> 39;
    uint64_t v16 = v4[4];
    if (v13 >> 39 >= (v4[5] - v16) >> 3) {
      goto LABEL_17;
    }
    uint64_t v17 = *(void *)(v16 + 8 * v15);
    if (!v17) {
      goto LABEL_17;
    }
    unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v13) & 0x7F));
    uint64_t v20 = v4[7];
    uint64_t v19 = v4[8];
    if (v18 >= (v19 - v20) >> 3) {
      goto LABEL_17;
    }
    uint64_t v21 = v20 + 8 * v18;
    BOOL v22 = v21 != v19 && *(_DWORD *)(v21 + 4) == v14;
    if (v22)
    {
      uint64_t v23 = v4[11];
      uint64_t v24 = v4[10] + 8 * v18;
    }
    else
    {
LABEL_17:
      uint64_t v23 = v4[11];
      uint64_t v24 = v23;
    }
    uint64_t v25 = v24 == v23 ? 0 : v24;
    uint64_t v26 = v6[4];
    if (v15 < (v6[5] - v26) >> 3)
    {
      uint64_t v27 = *(void *)(v26 + 8 * v15);
      if (v27)
      {
        unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v13) & 0x7F));
        uint64_t v30 = v6[7];
        uint64_t v29 = v6[8];
        if (v28 < (v29 - v30) >> 3)
        {
          uint64_t v31 = v30 + 8 * v28;
          if (v31 != v29 && *(_DWORD *)(v31 + 4) == v14) {
            break;
          }
        }
      }
    }
    uint64_t v33 = v6[11];
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a2 + 24);
    if (!v35) {
      goto LABEL_54;
    }
LABEL_29:
    if (v34 == v33) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v25, v36);
    unint64_t v38 = v61;
    unint64_t v11 = *(unint64_t **)(v58 + 32);
    if (++v61 != v11)
    {
      uint64_t v39 = v59[4];
      unint64_t v40 = (v59[5] - v39) >> 3;
      uint64_t v41 = v38 + 2;
      while (1)
      {
        unint64_t v42 = *((unsigned int *)v41 - 1);
        unint64_t v43 = v42 >> 7;
        if (v42 >> 7 < v40)
        {
          uint64_t v44 = *(void *)(v39 + 8 * v43);
          if (v44)
          {
            unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
            uint64_t v46 = v59[7];
            uint64_t result = v59[8];
            if (v45 < (result - v46) >> 3)
            {
              uint64_t v47 = v46 + 8 * v45;
              if (v47 != result && *(_DWORD *)(v47 + 4) == v42)
              {
                uint64_t v49 = v60[4];
                uint64_t result = v60[5] - v49;
                if (v43 < result >> 3)
                {
                  uint64_t v50 = *(void *)(v49 + 8 * v43);
                  if (v50)
                  {
                    unint64_t v51 = *(unsigned __int16 *)(v50 + 2 * (v42 & 0x7F));
                    uint64_t v53 = v60[7];
                    uint64_t v52 = v60[8];
                    uint64_t result = v52 - v53;
                    if (v51 < (v52 - v53) >> 3)
                    {
                      uint64_t v54 = v53 + 8 * v51;
                      if (v54 != v52 && *(_DWORD *)(v54 + 4) == v42) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v61 = v41;
        BOOL v22 = v41++ == v11;
        if (v22) {
          goto LABEL_9;
        }
      }
      unint64_t v11 = v41 - 1;
    }
LABEL_9:
    if (v57 == v11) {
      goto LABEL_56;
    }
  }
  uint64_t v33 = v6[11];
  uint64_t v34 = v6[10] + 24 * v28;
  uint64_t v35 = *(void *)(a2 + 24);
  if (v35) {
    goto LABEL_29;
  }
LABEL_54:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_55:
  uint64_t result = (*v10)();
  unint64_t v12 = (void *)result;
LABEL_56:
  *unint64_t v12 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::RenderableAlbedoTexture>(int8x8_t *a1)
{
  uint64_t v10 = 0x28D6AB85FDB5A2BLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x28D6AB85FDB5A2BLL;
    if (*(void *)&v1 <= 0x28D6AB85FDB5A2BuLL) {
      uint64_t v3 = 0x28D6AB85FDB5A2BuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x28D6AB85FDB5A2BLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x28D6AB85FDB5A2BLL)
      {
        if (v5[2] == 0x28D6AB85FDB5A2BLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x28D6AB85FDB5A2BLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x28D6AB85FDB5A2BLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A6DCF4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::SharedMaterialAlbedoTexture>(int8x8_t *a1)
{
  unint64_t v10 = 0x9AAE33FEB51FAC5BLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0x9AAE33FEB51FAC5BLL;
    if (*(void *)&v1 <= 0x9AAE33FEB51FAC5BLL) {
      unint64_t v3 = 0x9AAE33FEB51FAC5BLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0x9AAE33FEB51FAC5BLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x9AAE33FEB51FAC5BLL)
      {
        if (v5[2] == 0x9AAE33FEB51FAC5BLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x9AAE33FEB51FAC5BLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x9AAE33FEB51FAC5BLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A6DF64(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_ea8_40c27_ZTSNSt3__18functionIFvvEEE(uint64_t a1, uint64_t a2)
{
  uint64_t result = *(void *)(a2 + 64);
  if (result)
  {
    if (result == a2 + 40)
    {
      *(void *)(a1 + 64) = a1 + 40;
      uint64_t v4 = *(uint64_t (**)(void))(**(void **)(a2 + 64) + 24);
      return v4();
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 16))(result);
      *(void *)(a1 + 64) = result;
    }
  }
  else
  {
    *(void *)(a1 + 64) = 0;
  }
  return result;
}

uint64_t ggl::MetalResourceAccessor::load(ggl::MetalResourceAccessor *this, ggl::Texture2DLoadItem *a2)
{
  uint8x8_t v2 = *(ggl::MetalResourceManager **)(*((void *)this + 1) + 80);
  v4[0] = 0;
  v4[1] = 0;
  return ggl::MetalResourceManager::upload(v2, (uint64_t)a2, v4);
}

void sub_1A1A6E080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void ggl::MetalRenderer::frame(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, uint64_t a6)
{
  uint64_t v246 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v10 = atomic_load((unsigned __int8 *)(a1 + 417));
  if (v10)
  {
    if (GEOGetGeoGLDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoGLDefaultLog_onceToken, &__block_literal_global_53364);
    }
    unint64_t v11 = (id)GEOGetGeoGLDefaultLog_log;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      unsigned int v12 = atomic_load((unsigned int *)(a1 + 420));
      int v13 = *(_DWORD *)(a1 + 428);
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)&buf[4] = v12;
      *(_WORD *)&buf[8] = 1024;
      *(_DWORD *)&buf[10] = v13;
      _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_INFO, "Attempting to reset command queue, attempt %d of %d", buf, 0xEu);
    }

    uint64_t v14 = *(void *)(a1 + 136);
    uint64_t v15 = [*(id *)(v14 + 104) newCommandQueue];
    uint64_t v16 = *(void **)(v14 + 112);
    v14 += 112;
    *(void *)uint64_t v14 = v15;

    uint64_t v17 = *(void **)v14;
    unint64_t v18 = [NSString stringWithUTF8String:"com.apple.MapKit"];
    [v17 setLabel:v18];

    atomic_fetch_add((atomic_uint *volatile)(a1 + 420), 1u);
    atomic_store(0, (unsigned __int8 *)(a1 + 417));
  }
  uint64_t v19 = &qword_1EB32C000;
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v20 = *(void *)(a1 + 144);
    if (v20)
    {
      uint64_t v21 = (unsigned int *)a2[42];
      if (v21)
      {
        float v22 = *(float *)(a1 + 44);
        unsigned int v23 = (float)((float)v21[9] / v22);
        LODWORD(v21) = v21[10];
        goto LABEL_39;
      }
      uint64_t v26 = a2[11];
      if (v26)
      {
        uint64_t v27 = a2 + 12;
      }
      else
      {
        uint64_t v26 = a2[35];
        if (!v26) {
          goto LABEL_28;
        }
        uint64_t v27 = a2 + 36;
      }
      uint64_t v28 = 80;
      if (*(_DWORD *)(v26 + 56) == 3) {
        uint64_t v28 = 196;
      }
      unsigned int v29 = *(_DWORD *)(v26 + v28);
      unsigned int v30 = v29 >> *v27;
      if (v30 <= 1) {
        unsigned int v30 = 1;
      }
      if (v29) {
        LODWORD(v26) = v30;
      }
      else {
        LODWORD(v26) = 0;
      }
LABEL_28:
      float v22 = *(float *)(a1 + 44);
      unsigned int v23 = (float)((float)v26 / v22);
      uint64_t v21 = (unsigned int *)a2[11];
      if (v21)
      {
        uint64_t v31 = a2 + 12;
      }
      else
      {
        uint64_t v21 = (unsigned int *)a2[35];
        if (!v21) {
          goto LABEL_39;
        }
        uint64_t v31 = a2 + 36;
      }
      uint64_t v32 = 21;
      if (v21[14] == 3) {
        uint64_t v32 = 49;
      }
      unsigned int v33 = v21[v32];
      unsigned int v34 = v33 >> *v31;
      if (v34 <= 1) {
        unsigned int v34 = 1;
      }
      if (v33) {
        LODWORD(v21) = v34;
      }
      else {
        LODWORD(v21) = 0;
      }
LABEL_39:
      float v35 = (float)v23;
      float v36 = *(double *)(v20 + 24);
      int v37 = *(unsigned __int8 *)(v20 + 32);
      *(float *)buf = 2.0 / v35;
      *(_OWORD *)&buf[4] = 0uLL;
      *(float *)&buf[20] = -2.0 / truncf((float)v21 / v22);
      float v38 = v36 + -1.0;
      if (!v37) {
        float v38 = 1.0 - v36;
      }
      uint64_t v224 = 0;
      __dst = 0;
      v226 = (char *)LODWORD(v38);
      *(float *)&v227 = (float)-v35 / v35;
      HIDWORD(v227) = 1065353216;
      uint64_t v228 = LODWORD(v36) | 0x3F80000000000000;
      if (*(void *)v20)
      {
        uint64_t v39 = *(void *)v20;
        unint64_t v40 = *(std::__shared_weak_count **)(v20 + 8);
        if (v40)
        {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
          ggl::DebugConsole::setProjection(v39, buf);
          uint64_t v19 = &qword_1EB32C000;
          if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
            std::__shared_weak_count::__release_weak(v40);
          }
        }
        else
        {
          ggl::DebugConsole::setProjection(v39, buf);
        }
        uint64_t v43 = *(void *)(a1 + 144);
        if (v19[261] != -1) {
          dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
        }
        uint64_t v44 = (ggl::Performance::Counters *)ggl::Performance::Counters::instance(void)::counters;
        if (*(void *)v43)
        {
          unint64_t v45 = *(ggl::DebugConsole **)v43;
          uint64_t v46 = *(void *)(v43 + 8);
          if (v46)
          {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v46 + 8), 1uLL, memory_order_relaxed);
            ggl::Performance::Counters::draw(v44, v45);
          }
          ggl::Performance::Counters::draw((ggl::Performance::Counters *)ggl::Performance::Counters::instance(void)::counters, v45);
        }
        uint64_t v47 = *(const ggl::CommonLibrary **)(v43 + 16);
        uint64_t v48 = operator new(0xB0uLL);
        v48[1] = 0;
        v48[2] = 0;
        void *v48 = &unk_1EF5836D0;
        ggl::DebugConsole::DebugConsole((ggl::DebugConsole *)(v48 + 3), v47);
      }
      uint64_t v41 = *(const ggl::CommonLibrary **)(v20 + 16);
      unint64_t v42 = operator new(0xB0uLL);
      v42[1] = 0;
      v42[2] = 0;
      void *v42 = &unk_1EF5836D0;
      ggl::DebugConsole::DebugConsole((ggl::DebugConsole *)(v42 + 3), v41);
    }
  }
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  uint64_t v24 = ggl::Performance::Counters::instance(void)::counters;
  if (*(_DWORD *)(ggl::Performance::Counters::instance(void)::counters + 40))
  {
    unint64_t v25 = 0;
    do
      atomic_store(0, (unint64_t *)(*(void *)(v24 + 32) + 8 * v25++));
    while (v25 < *(unsigned int *)(v24 + 40));
  }
  uint64_t v49 = MEMORY[0x1A6239C40]();
  __int16 v219 = 0;
  v220 = 0;
  v221 = 0;
  char v222 = *(unsigned char *)(a1 + 416);
  uint64_t v50 = *(uint64_t **)(a3 + 136);
  unint64_t v51 = *(std::__shared_weak_count **)(a3 + 144);
  context = (void *)v49;
  uint64_t v210 = a4;
  if (v51)
  {
    atomic_fetch_add_explicit(&v51->__shared_owners_, 1uLL, memory_order_relaxed);
    v220 = v50;
    v221 = v51;
    uint64_t v50 = *(uint64_t **)(a3 + 136);
  }
  else
  {
    v220 = *(uint64_t **)(a3 + 136);
  }
  *(void *)(a1 + 16) = *v50;
  __p = 0;
  v217 = 0;
  uint64_t v218 = 0;
  *(void *)&long long v214 = a2;
  *((void *)&v214 + 1) = a3;
  uint64_t v213 = a3;
  char v215 = 0;
  uint64_t v52 = v217;
  v212 = __p;
  if (__p != v217)
  {
    uint64_t v53 = __p;
    while (1)
    {
      while (1)
      {
        uint64_t v54 = (void *)v53[1];
        uint64_t v55 = v54[13];
        uint64_t v56 = v54[14];
        uint64_t v57 = v56 - v55;
        if (v56 != v55) {
          break;
        }
        v53 += 3;
        if (v53 == v52) {
          goto LABEL_93;
        }
      }
      if (v57 < 0) {
        abort();
      }
      uint64_t v58 = v54[16];
      uint64_t v59 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v58 + 16))(v58, v56 - v55, 8);
      uint64_t v60 = 0;
      do
      {
        if (v59 + v60) {
          *(void *)(v59 + v60) = *(void *)(v55 + v60);
        }
        v60 += 8;
      }
      while (v55 + v60 != v56);
      uint64_t v61 = (uint64_t *)(v59 + v60);
      if (v61 != (uint64_t *)v59) {
        break;
      }
LABEL_86:
      char v64 = 1;
LABEL_87:
      if (v59) {
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v58 + 40))(v58, v59, v57);
      }
      v53 += 3;
      if (v53 == v52) {
        char v69 = 0;
      }
      else {
        char v69 = v64;
      }
      if ((v69 & 1) == 0) {
        goto LABEL_93;
      }
    }
    float v62 = (uint64_t *)v59;
    while (1)
    {
      if ((_BYTE)v219) {
        BOOL v63 = HIBYTE(v219) == 0;
      }
      else {
        BOOL v63 = 1;
      }
      char v64 = v63;
      if (!v63) {
        goto LABEL_87;
      }
      uint64_t v65 = *v62;
      if (*v62) {
        break;
      }
LABEL_68:
      if (++v62 == v61) {
        goto LABEL_86;
      }
    }
    uint64_t v66 = *(void *)(v65 + 168);
    uint64_t v67 = *(void *)(v65 + 176);
    while (1)
    {
      if (v66 == v67) {
        goto LABEL_68;
      }
      if (!*(unsigned char *)(v66 + 1)) {
        break;
      }
      if (*(unsigned char *)(v66 + 1) == 1)
      {
        v68 = (__int16 *)((char *)&v219 + 1);
        goto LABEL_80;
      }
LABEL_81:
      v66 += 152;
    }
    v68 = &v219;
LABEL_80:
    *(unsigned char *)v68 = 1;
    goto LABEL_81;
  }
LABEL_93:
  ggl::MetalDeviceContext::beginFrame(*(void *)(a1 + 432));
  ggl::MetalBindingManager::resetBindingCache(*(ggl::MetalBindingManager **)(*(void *)(a1 + 432) + 8));
  uint64_t v70 = v213;
  if (v212 != v52)
  {
    uint64_t v71 = v212;
    do
    {
      ggl::MetalDeviceContext::beginPass(*(void *)(a1 + 432));
      unint64_t v72 = (void *)v71[1];
      unint64_t v73 = (const Texture **)v72[31];
      uint8x8_t v74 = (const Texture **)v72[32];
      if (v73 != v74)
      {
        do
          ggl::MetalDeviceContext::optimizeForCPUAccess(*(ggl::MetalDeviceContext **)(a1 + 432), *v73++);
        while (v73 != v74);
        unint64_t v72 = (void *)v71[1];
      }
      uint64_t v75 = (const Texture **)v72[27];
      uint64_t v76 = (const Texture **)v72[28];
      if (v75 != v76)
      {
        do
          ggl::MetalDeviceContext::optimizeForGPUAccess(*(ggl::MetalDeviceContext **)(a1 + 432), *v75++);
        while (v75 != v76);
        unint64_t v72 = (void *)v71[1];
        uint64_t v75 = (const Texture **)v72[27];
      }
      v72[32] = v72[31];
      v72[28] = v75;
      uint64_t v77 = v72[13];
      uint64_t v78 = v72[14];
      uint64_t v79 = v78 - v77;
      if (v78 != v77)
      {
        if (v79 < 0) {
          abort();
        }
        uint64_t v80 = v72[16];
        uint64_t v81 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80 + 16))(v80, v78 - v77, 8);
        uint64_t v82 = v81;
        uint64_t v83 = 0;
        do
        {
          if (v81 + v83) {
            *(void *)(v81 + v83) = *(void *)(v77 + v83);
          }
          v83 += 8;
        }
        while (v77 + v83 != v78);
        if (v83)
        {
          uint64_t v84 = 8 * (v83 >> 3);
          unint64_t v85 = (ggl::CommandBuffer **)v81;
          do
          {
            if (*v85) {
              ggl::MetalDeviceContext::processBuffer(*(ggl::MetalDeviceContext **)(a1 + 432), *v85);
            }
            ++v85;
            v84 -= 8;
          }
          while (v84);
        }
        if (v82) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80 + 40))(v80, v82, v79);
        }
      }
      uint64_t v86 = *(void *)(a1 + 432);
      uint64_t v87 = *(ggl::MetalDeviceContextPass **)(v86 + 48);
      if (v87)
      {
        *(void *)(v86 + 48) = 0;
        ggl::MetalDeviceContextPass::~MetalDeviceContextPass(v87);
        MEMORY[0x1A6239270]();
      }
      v71 += 3;
    }
    while (v71 != v52);
  }
  if (*(void *)(a1 + 56) != *(void *)(a1 + 64)) {
    operator new();
  }
  gettimeofday((timeval *)buf, 0);
  double v88 = (double)*(uint64_t *)buf + (double)*(int *)&buf[8] * 0.000001;
  double v89 = fmin(fmax(v88 - *(double *)(a1 + 160), 0.001), 100.0);
  uint64_t v90 = a1 + 8 * (*(void *)(a1 + 16) % 0x1EuLL);
  double v91 = v89 + *(double *)(a1 + 168) - *(double *)(v90 + 176);
  *(double *)(a1 + 160) = v88;
  *(double *)(a1 + 168) = v91;
  *(double *)(a1 + 152) = 30.0 / v91;
  *(double *)(v90 + 176) = v89;
  unint64_t v92 = atomic_load((unsigned int *)(*(void *)(*(void *)(a1 + 136) + 80) + 312));
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  atomic_store(v92, (unint64_t *)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 64));
  memset(buf, 0, sizeof(buf));
  uint64_t v93 = a5;
  {
    uint64_t v93 = a5;
    if (v203) {
      operator new();
    }
  }
  uint64_t v224 = ggl::Allocator::instance(void)::alloc;
  __dst = 0;
  v226 = 0;
  v227 = 0;
  {
    uint64_t v93 = a5;
    if (v204) {
      operator new();
    }
  }
  uint64_t v228 = ggl::Allocator::instance(void)::alloc;
  uint64_t v229 = 0;
  v230 = 0;
  v231 = 0;
  {
    uint64_t v93 = a5;
    if (v205) {
      operator new();
    }
  }
  uint64_t v232 = ggl::Allocator::instance(void)::alloc;
  uint64_t v233 = 0;
  v234 = 0;
  v235 = 0;
  {
    uint64_t v93 = a5;
    if (v206) {
      operator new();
    }
  }
  uint64_t v236 = ggl::Allocator::instance(void)::alloc;
  v237 = 0;
  v238 = 0;
  unint64_t v239 = 0;
  {
    uint64_t v93 = a5;
    if (v207) {
      operator new();
    }
  }
  uint64_t v240 = ggl::Allocator::instance(void)::alloc;
  uint64_t v94 = (void *)v93[3];
  if (v94)
  {
    if (v94 == v93)
    {
      v244 = &v241;
      (*(void (**)(void *, uint64_t *))(*v93 + 24))(v93, &v241);
    }
    else
    {
      v244 = (uint64_t *)(*(uint64_t (**)(void *))(*v94 + 16))(v94);
    }
    v95 = v238;
    if ((unint64_t)v238 >= v239)
    {
      uint64_t v97 = (v238 - v237) >> 5;
      if ((unint64_t)(v97 + 1) >> 59) {
        abort();
      }
      unint64_t v98 = (uint64_t)(v239 - (void)v237) >> 4;
      if (v98 <= v97 + 1) {
        unint64_t v98 = v97 + 1;
      }
      if (v239 - (unint64_t)v237 >= 0x7FFFFFFFFFFFFFE0) {
        uint64_t v99 = 0x7FFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v99 = v98;
      }
      if (v99) {
        uint64_t v100 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v240 + 16))(v240, 32 * v99, 8);
      }
      else {
        uint64_t v100 = 0;
      }
      long long v101 = (char *)(v100 + 32 * v97);
      std::allocator_traits<geo::StdAllocator<std::function<void ()(NSError *)>,ggl::Allocator>>::construct[abi:nn180100]<std::function<void ()(NSError *)>,ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0,void>(v101, &v241);
      unint64_t v102 = v100 + 32 * v99;
      int v96 = v101 + 32;
      v103 = v237;
      uint64_t v104 = v238;
      if (v238 == v237)
      {
        v237 = v101;
        v238 = v101 + 32;
        unint64_t v105 = v239;
        unint64_t v239 = v102;
      }
      else
      {
        do
        {
          uint64_t v106 = v101;
          v101 -= 32;
          uint64_t v107 = v104 - 32;
          uint64_t v108 = (char *)*((void *)v104 - 1);
          if (v108)
          {
            if (v107 == v108)
            {
              *((void *)v106 - 1) = v101;
              (*(void (**)(void, char *))(**((void **)v104 - 1) + 24))(*((void *)v104 - 1), v101);
            }
            else
            {
              *((void *)v106 - 1) = v108;
              *((void *)v104 - 1) = 0;
            }
          }
          else
          {
            *((void *)v106 - 1) = 0;
          }
          v104 -= 32;
        }
        while (v107 != v103);
        uint64_t v104 = v237;
        uint64_t v109 = v238;
        v237 = v101;
        v238 = v96;
        unint64_t v105 = v239;
        unint64_t v239 = v102;
        if (v109 != v104)
        {
          v110 = v109 - 32;
          int v111 = v109 - 32;
          do
          {
            uint64_t v112 = (char *)*((void *)v111 + 3);
            if (v111 == v112)
            {
              (*(void (**)(char *))(*(void *)v111 + 32))(v111);
            }
            else if (v112)
            {
              (*(void (**)(char *))(*(void *)v112 + 40))(v112);
            }
            v110 -= 32;
            BOOL v63 = v111 == v104;
            v111 -= 32;
          }
          while (!v63);
        }
      }
      if (v104) {
        (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v240 + 40))(v240, v104, v105 - (void)v104);
      }
    }
    else
    {
      std::allocator_traits<geo::StdAllocator<std::function<void ()(NSError *)>,ggl::Allocator>>::construct[abi:nn180100]<std::function<void ()(NSError *)>,ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0,void>(v238, &v241);
      int v96 = v95 + 32;
    }
    v238 = v96;
    uint64_t v70 = v213;
    if (v244 == &v241)
    {
      (*(void (**)(uint64_t *))(v241 + 32))(&v241);
    }
    else if (v244)
    {
      (*(void (**)(void))(*v244 + 40))();
    }
  }
  uint64_t v113 = v238;
  if ((unint64_t)v238 >= v239)
  {
    uint64_t v115 = (v238 - v237) >> 5;
    unint64_t v116 = v115 + 1;
    if ((unint64_t)(v115 + 1) >> 59) {
      abort();
    }
    uint64_t v117 = v239 - (void)v237;
    if ((uint64_t)(v239 - (void)v237) >> 4 > v116) {
      unint64_t v116 = v117 >> 4;
    }
    if ((unint64_t)v117 >= 0x7FFFFFFFFFFFFFE0) {
      uint64_t v118 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v118 = v116;
    }
    if (v118)
    {
      uint64_t v119 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v240 + 16))(v240, 32 * v118, 8);
      uint64_t v120 = (char *)(v119 + 32 * v115);
      unint64_t v121 = v119 + 32 * v118;
      if (v119)
      {
        *(void *)uint64_t v120 = &unk_1EF57AB78;
        *((void *)v120 + 1) = a1;
        *((void *)v120 + 3) = v120;
      }
    }
    else
    {
      unint64_t v121 = 0;
      uint64_t v120 = (char *)(32 * v115);
    }
    uint64_t v114 = v120 + 32;
    unint64_t v122 = v237;
    uint64_t v123 = v238;
    if (v238 == v237)
    {
      v237 = v120;
      v238 = v120 + 32;
      unint64_t v124 = v239;
      unint64_t v239 = v121;
    }
    else
    {
      do
      {
        unint64_t v125 = v120;
        v120 -= 32;
        uint64_t v126 = v123 - 32;
        uint64_t v127 = (char *)*((void *)v123 - 1);
        if (v127)
        {
          if (v126 == v127)
          {
            *((void *)v125 - 1) = v120;
            (*(void (**)(void, char *))(**((void **)v123 - 1) + 24))(*((void *)v123 - 1), v120);
          }
          else
          {
            *((void *)v125 - 1) = v127;
            *((void *)v123 - 1) = 0;
          }
        }
        else
        {
          *((void *)v125 - 1) = 0;
        }
        v123 -= 32;
      }
      while (v126 != v122);
      uint64_t v123 = v237;
      uint64_t v128 = v238;
      v237 = v120;
      v238 = v114;
      unint64_t v124 = v239;
      unint64_t v239 = v121;
      if (v128 != v123)
      {
        v129 = v128 - 32;
        uint64_t v130 = v128 - 32;
        do
        {
          uint64_t v131 = (char *)*((void *)v130 + 3);
          if (v130 == v131)
          {
            (*(void (**)(char *))(*(void *)v130 + 32))(v130);
          }
          else if (v131)
          {
            (*(void (**)(char *))(*(void *)v131 + 40))(v131);
          }
          v129 -= 32;
          BOOL v63 = v130 == v123;
          v130 -= 32;
        }
        while (!v63);
      }
    }
    if (v123) {
      (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v240 + 40))(v240, v123, v124 - (void)v123);
    }
    uint64_t v70 = v213;
  }
  else
  {
    if (v238)
    {
      *(void *)v238 = &unk_1EF57AB78;
      *((void *)v113 + 1) = a1;
      *((void *)v113 + 3) = v113;
    }
    uint64_t v114 = v113 + 32;
  }
  v238 = v114;
  uint64_t v132 = *(void *)(a6 + 24);
  if (v132)
  {
    uint64_t v133 = v230;
    if (v230 < v231)
    {
      if (v230)
      {
        if (v132 == a6)
        {
          v230[3] = (uint64_t)v230;
          (*(void (**)(void, uint64_t *))(**(void **)(a6 + 24) + 24))(*(void *)(a6 + 24), v133);
        }
        else
        {
          v133[3] = (*(uint64_t (**)(uint64_t))(*(void *)v132 + 16))(v132);
        }
      }
      v230 = v133 + 4;
      uint64_t v70 = v213;
      goto LABEL_234;
    }
    uint64_t v134 = ((uint64_t)v230 - v229) >> 5;
    if ((unint64_t)(v134 + 1) >> 59) {
      goto LABEL_349;
    }
    unint64_t v135 = ((uint64_t)v231 - v229) >> 4;
    if (v135 <= v134 + 1) {
      unint64_t v135 = v134 + 1;
    }
    if ((unint64_t)v231 - v229 >= 0x7FFFFFFFFFFFFFE0) {
      uint64_t v136 = 0x7FFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v136 = v135;
    }
    v245 = &v232;
    if (v136)
    {
      uint64_t v137 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v232 + 16))(v232, 32 * v136, 8);
      uint64_t v138 = v137 + 32 * v134;
      uint64_t v241 = v137;
      uint64_t v242 = v138;
      unint64_t v139 = (uint64_t *)(v137 + 32 * v136);
      uint64_t v243 = v138;
      v244 = v139;
      if (v137)
      {
        uint64_t v140 = *(void *)(a6 + 24);
        if (v140)
        {
          if (v140 == a6)
          {
            *(void *)(v138 + 24) = v138;
            (*(void (**)(void, uint64_t))(**(void **)(a6 + 24) + 24))(*(void *)(a6 + 24), v138);
          }
          else
          {
            *(void *)(v138 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v140 + 16))(v140);
          }
        }
        else
        {
          *(void *)(v138 + 24) = 0;
        }
      }
    }
    else
    {
      unint64_t v139 = 0;
      uint64_t v138 = 32 * v134;
      uint64_t v243 = 32 * v134;
      v244 = 0;
    }
    uint64_t v141 = v138 + 32;
    uint64_t v243 = v138 + 32;
    uint64_t v143 = v229;
    uint64_t v142 = (uint64_t)v230;
    if (v230 == (uint64_t *)v229)
    {
      uint64_t v144 = (char *)v230;
    }
    else
    {
      do
      {
        uint64_t v145 = v138;
        v138 -= 32;
        uint64_t v146 = v142 - 32;
        uint64_t v147 = *(void *)(v142 - 8);
        if (v147)
        {
          if (v146 == v147)
          {
            *(void *)(v145 - 8) = v138;
            (*(void (**)(void, uint64_t))(**(void **)(v142 - 8) + 24))(*(void *)(v142 - 8), v138);
          }
          else
          {
            *(void *)(v145 - 8) = v147;
            *(void *)(v142 - 8) = 0;
          }
        }
        else
        {
          *(void *)(v145 - 8) = 0;
        }
        uint64_t v142 = v146;
      }
      while (v146 != v143);
      uint64_t v144 = (char *)v229;
      uint64_t v142 = (uint64_t)v230;
      uint64_t v141 = v243;
      unint64_t v139 = v244;
    }
    uint64_t v229 = v138;
    v230 = (uint64_t *)v141;
    uint64_t v242 = (uint64_t)v144;
    uint64_t v243 = v142;
    uint64_t v148 = (char *)v231;
    v231 = v139;
    if ((char *)v142 == v144)
    {
      uint64_t v144 = (char *)v142;
      uint64_t v70 = v213;
      if (!v142) {
        goto LABEL_233;
      }
    }
    else
    {
      uint64_t v149 = v142 - 32;
      v150 = (char *)(v142 - 32);
      do
      {
        v151 = (char *)*((void *)v150 + 3);
        if (v150 == v151)
        {
          (*(void (**)(char *))(*(void *)v150 + 32))(v150);
        }
        else if (v151)
        {
          (*(void (**)(char *))(*(void *)v151 + 40))(v151);
        }
        v149 -= 32;
        BOOL v63 = v150 == v144;
        v150 -= 32;
      }
      while (!v63);
      uint64_t v243 = (uint64_t)v144;
      uint64_t v70 = v213;
      if (!v144) {
        goto LABEL_233;
      }
    }
    (*(void (**)(uint64_t, char *, int64_t))(*(void *)*v245 + 40))(*v245, v144, v148 - v144);
LABEL_233:
    v230 = (uint64_t *)v141;
  }
LABEL_234:
  uint64_t v152 = *(void *)(v210 + 24);
  if (!v152) {
    goto LABEL_276;
  }
  v153 = v234;
  if (v234 < v235)
  {
    if (v234)
    {
      if (v152 == v210)
      {
        v234[3] = (uint64_t)v234;
        (*(void (**)(void, uint64_t *))(**(void **)(v210 + 24) + 24))(*(void *)(v210 + 24), v153);
      }
      else
      {
        v153[3] = (*(uint64_t (**)(uint64_t))(*(void *)v152 + 16))(v152);
      }
    }
    uint64_t v161 = (uint64_t)(v153 + 4);
    goto LABEL_275;
  }
  uint64_t v154 = ((uint64_t)v234 - v233) >> 5;
  if ((unint64_t)(v154 + 1) >> 59) {
    goto LABEL_349;
  }
  unint64_t v155 = ((uint64_t)v235 - v233) >> 4;
  if (v155 <= v154 + 1) {
    unint64_t v155 = v154 + 1;
  }
  if ((unint64_t)v235 - v233 >= 0x7FFFFFFFFFFFFFE0) {
    uint64_t v156 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    uint64_t v156 = v155;
  }
  v245 = &v236;
  if (v156)
  {
    uint64_t v157 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v236 + 16))(v236, 32 * v156, 8);
    uint64_t v158 = v157 + 32 * v154;
    uint64_t v241 = v157;
    uint64_t v242 = v158;
    v159 = (uint64_t *)(v157 + 32 * v156);
    uint64_t v243 = v158;
    v244 = v159;
    if (v157)
    {
      uint64_t v160 = *(void *)(v210 + 24);
      if (v160)
      {
        if (v160 == v210)
        {
          *(void *)(v158 + 24) = v158;
          (*(void (**)(void, uint64_t))(**(void **)(v210 + 24) + 24))(*(void *)(v210 + 24), v158);
        }
        else
        {
          *(void *)(v158 + 24) = (*(uint64_t (**)(uint64_t))(*(void *)v160 + 16))(v160);
        }
      }
      else
      {
        *(void *)(v158 + 24) = 0;
      }
    }
  }
  else
  {
    v159 = 0;
    uint64_t v158 = 32 * v154;
    uint64_t v243 = 32 * v154;
    v244 = 0;
  }
  uint64_t v161 = v158 + 32;
  uint64_t v243 = v158 + 32;
  uint64_t v163 = v233;
  uint64_t v162 = (uint64_t)v234;
  if (v234 == (uint64_t *)v233)
  {
    v164 = (char *)v234;
  }
  else
  {
    do
    {
      uint64_t v165 = v158;
      v158 -= 32;
      uint64_t v166 = v162 - 32;
      uint64_t v167 = *(void *)(v162 - 8);
      if (v167)
      {
        if (v166 == v167)
        {
          *(void *)(v165 - 8) = v158;
          (*(void (**)(void, uint64_t))(**(void **)(v162 - 8) + 24))(*(void *)(v162 - 8), v158);
        }
        else
        {
          *(void *)(v165 - 8) = v167;
          *(void *)(v162 - 8) = 0;
        }
      }
      else
      {
        *(void *)(v165 - 8) = 0;
      }
      uint64_t v162 = v166;
    }
    while (v166 != v163);
    v164 = (char *)v233;
    uint64_t v162 = (uint64_t)v234;
    uint64_t v161 = v243;
    v159 = v244;
  }
  uint64_t v233 = v158;
  v234 = (uint64_t *)v161;
  uint64_t v242 = (uint64_t)v164;
  uint64_t v243 = v162;
  v168 = (char *)v235;
  v235 = v159;
  if ((char *)v162 == v164)
  {
    v164 = (char *)v162;
    uint64_t v70 = v213;
    if (!v162) {
      goto LABEL_275;
    }
  }
  else
  {
    uint64_t v169 = v162 - 32;
    v170 = (char *)(v162 - 32);
    uint64_t v70 = v213;
    do
    {
      v171 = (char *)*((void *)v170 + 3);
      if (v170 == v171)
      {
        (*(void (**)(char *))(*(void *)v170 + 32))(v170);
      }
      else if (v171)
      {
        (*(void (**)(char *))(*(void *)v171 + 40))(v171);
      }
      v169 -= 32;
      BOOL v63 = v170 == v164;
      v170 -= 32;
    }
    while (!v63);
    uint64_t v243 = (uint64_t)v164;
    if (!v164) {
      goto LABEL_275;
    }
  }
  (*(void (**)(uint64_t, char *, int64_t))(*(void *)*v245 + 40))(*v245, v164, v168 - v164);
LABEL_275:
  v234 = (uint64_t *)v161;
LABEL_276:
  if (&__dst == (void **)(v70 + 152)) {
    goto LABEL_302;
  }
  v173 = *(char **)(v70 + 152);
  v172 = *(char **)(v70 + 160);
  int64_t v174 = v172 - v173;
  unint64_t v175 = (v172 - v173) >> 3;
  uint64_t v176 = (uint64_t)v227;
  v177 = (char *)__dst;
  if (v175 <= (v227 - (unsigned char *)__dst) >> 3)
  {
    unint64_t v182 = (v226 - (unsigned char *)__dst) >> 3;
    if (v182 >= v175)
    {
      if (v172 != v173) {
        memmove(__dst, v173, v172 - v173);
      }
      goto LABEL_301;
    }
    v183 = &v173[8 * v182];
    if (v226 != __dst)
    {
      memmove(__dst, v173, v226 - (unsigned char *)__dst);
      v177 = v226;
    }
    v181 = v177;
    if (v183 != v172)
    {
      v181 = v177;
      do
      {
        if (v181) {
          *(void *)v181 = *(void *)v183;
        }
        v183 += 8;
        v181 += 8;
      }
      while (v183 != v172);
    }
  }
  else
  {
    if (__dst)
    {
      v226 = (char *)__dst;
      (*(void (**)(uint64_t, void *))(*(void *)v228 + 40))(v228, __dst);
      uint64_t v176 = 0;
      __dst = 0;
      v226 = 0;
      v227 = 0;
    }
    if (v174 < 0) {
      goto LABEL_349;
    }
    uint64_t v178 = v176 >> 2;
    if (v176 >> 2 <= v175) {
      uint64_t v178 = (v172 - v173) >> 3;
    }
    unint64_t v179 = (unint64_t)v176 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v178;
    if (v179 >> 61) {
      goto LABEL_349;
    }
    v180 = (char *)(*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v228 + 16))(v228, 8 * v179, 8);
    v177 = v180;
    __dst = v180;
    v226 = v180;
    v227 = &v180[8 * v179];
    v181 = v180;
    if (v173 != v172)
    {
      v181 = v180;
      do
      {
        if (v181) {
          *(void *)v181 = *(void *)v173;
        }
        v173 += 8;
        v181 += 8;
      }
      while (v173 != v172);
    }
  }
  int64_t v174 = v181 - v177;
LABEL_301:
  v226 = &v177[v174];
  uint64_t v70 = v213;
LABEL_302:
  v184 = (char **)(v70 + 184);
  v185 = *(char **)(v70 + 184);
  if (buf != (unsigned char *)(v70 + 184))
  {
    v186 = *(char **)(v70 + 192);
    int64_t v187 = v186 - v185;
    unint64_t v188 = (v186 - v185) >> 3;
    uint64_t v189 = *(void *)&buf[16];
    uint64_t v190 = *(void *)buf;
    if (v188 <= (uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3)
    {
      unint64_t v195 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
      if (v195 >= v188)
      {
        if (v186 != v185) {
          memmove(*(void **)buf, v185, v186 - v185);
        }
        goto LABEL_327;
      }
      v196 = &v185[8 * v195];
      if (*(void *)&buf[8] != *(void *)buf)
      {
        memmove(*(void **)buf, v185, *(void *)&buf[8] - *(void *)buf);
        uint64_t v190 = *(void *)&buf[8];
      }
      v194 = (char *)v190;
      if (v196 != v186)
      {
        v194 = (char *)v190;
        do
        {
          if (v194) {
            *(void *)v194 = *(void *)v196;
          }
          v196 += 8;
          v194 += 8;
        }
        while (v196 != v186);
      }
LABEL_326:
      int64_t v187 = (int64_t)&v194[-v190];
LABEL_327:
      *(void *)&buf[8] = v190 + v187;
      v185 = *v184;
      uint64_t v70 = v213;
      goto LABEL_328;
    }
    if (*(void *)buf)
    {
      *(void *)&buf[8] = *(void *)buf;
      (*(void (**)(uint64_t, void))(*(void *)v224 + 40))(v224, *(void *)buf);
      uint64_t v189 = 0;
      memset(buf, 0, sizeof(buf));
    }
    if ((v187 & 0x8000000000000000) == 0)
    {
      uint64_t v191 = v189 >> 2;
      if (v189 >> 2 <= v188) {
        uint64_t v191 = (v186 - v185) >> 3;
      }
      unint64_t v192 = (unint64_t)v189 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v191;
      if (!(v192 >> 61))
      {
        uint64_t v193 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v224 + 16))(v224, 8 * v192, 8);
        uint64_t v190 = v193;
        *(void *)buf = v193;
        *(void *)&buf[8] = v193;
        *(void *)&buf[16] = v193 + 8 * v192;
        v194 = (char *)v193;
        if (v185 != v186)
        {
          v194 = (char *)v193;
          do
          {
            if (v194) {
              *(void *)v194 = *(void *)v185;
            }
            v185 += 8;
            v194 += 8;
          }
          while (v185 != v186);
        }
        goto LABEL_326;
      }
    }
LABEL_349:
    abort();
  }
LABEL_328:
  *(void *)(v70 + 160) = *(void *)(v70 + 152);
  *(void *)(v70 + 192) = v185;
  ggl::MetalDeviceContext::endFrame(*(ggl::MetalDeviceContext **)(a1 + 432), (const ggl::EndFrameParams *)buf);
  uint64_t v197 = *v220;
  v198 = (std::__shared_weak_count *)operator new(0x78uLL);
  v198->__shared_owners_ = 0;
  p_shared_owners = &v198->__shared_owners_;
  v198->__shared_weak_owners_ = 0;
  v198->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587BB8;
  v198[1].__vftable = (std::__shared_weak_count_vtbl *)(v197 + 1);
  LODWORD(v198[1].__shared_owners_) = 0;
  v198[3].__shared_owners_ = 0;
  v198[4].__shared_weak_owners_ = 0;
  v200 = (std::__shared_weak_count_vtbl *)operator new(0x28uLL);
  v200->~__shared_weak_count_0 = 0;
  v200->__on_zero_shared = 0;
  v200->~__shared_weak_count = (void (__cdecl *)(std::__shared_weak_count *__hidden))&unk_1EF5834D8;
  v200->__on_zero_shared_weak = 0;
  v198[1].__shared_weak_owners_ = (uint64_t)&v200->__get_deleter;
  v198[2].__vftable = v200;
  atomic_fetch_add_explicit(&v198->__shared_owners_, 1uLL, memory_order_relaxed);
  atomic_fetch_add_explicit(&v198->__shared_owners_, 1uLL, memory_order_relaxed);
  v201 = *(std::__shared_weak_count **)(v70 + 144);
  *(void *)(v70 + 136) = v198 + 1;
  *(void *)(v70 + 144) = v198;
  if (v201 && !atomic_fetch_add(&v201->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v201->__on_zero_shared)(v201);
    std::__shared_weak_count::__release_weak(v201);
  }
  if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
  {
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_333;
    }
  }
  else
  {
    ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
    std::__shared_weak_count::__release_weak(v198);
    if (atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL)) {
      goto LABEL_333;
    }
  }
  ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
  std::__shared_weak_count::__release_weak(v198);
LABEL_333:
  ggl::EndFrameParams::~EndFrameParams((ggl::EndFrameParams *)buf);
  if (__p) {
    operator delete(__p);
  }
  v202 = v221;
  if (v221 && !atomic_fetch_add(&v221->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v202->__on_zero_shared)(v202);
    std::__shared_weak_count::__release_weak(v202);
  }
}

void sub_1A1A70098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  std::__split_buffer<std::function<void ()(void)>,geo::StdAllocator<std::function<void ()(void)>,ggl::Allocator> &>::~__split_buffer(v48 - 136);
  ggl::EndFrameParams::~EndFrameParams((ggl::EndFrameParams *)&a29);
  if (__p) {
    operator delete(__p);
  }
  md::components::Material::~Material((md::components::Material *)&a25);
  _Unwind_Resume(a1);
}

void ggl::MetalBindingManager::resetBindingCache(ggl::MetalBindingManager *this)
{
  uint8x8_t v2 = (char *)*((void *)this + 1);
  unint64_t v3 = (char *)*((void *)this + 2);
  uint64_t v4 = v3 - v2;
  if (v3 != v2)
  {
    *((_OWORD *)v2 + 14) = 0u;
    *((_OWORD *)v2 + 15) = 0u;
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)uint8x8_t v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    goto LABEL_33;
  }
  uint64_t v43 = 0;
  if ((unint64_t)v4 > 0xFF)
  {
    if (v4 == 256) {
      goto LABEL_33;
    }
    uint64_t v20 = v3 + 256;
    goto LABEL_32;
  }
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = 32 - (v4 >> 3);
  uint64_t v7 = *((void *)this + 3);
  if (v6 <= (v7 - (uint64_t)v3) >> 3)
  {
    uint64_t v20 = &v3[8 * v6];
    unint64_t v21 = (31 - v5) & 0x1FFFFFFFFFFFFFFFLL;
    if (v21 >= 0xF && (v3 >= (char *)&v44 || v20 <= (char *)&v43))
    {
      unint64_t v22 = v21 + 1;
      unsigned int v23 = v3;
      uint64_t v24 = v22 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        *(_OWORD *)unsigned int v23 = 0uLL;
        *((_OWORD *)v23 + 1) = 0uLL;
        v23 += 32;
        v24 -= 4;
      }
      while (v24);
      if (v22 == (v22 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_32;
      }
      v3 += 8 * (v22 & 0x3FFFFFFFFFFFFFFCLL);
    }
    do
    {
      *(void *)unint64_t v3 = 0;
      v3 += 8;
    }
    while (v3 != v20);
LABEL_32:
    *((void *)this + 2) = v20;
    goto LABEL_33;
  }
  uint64_t v8 = v7 - (void)v2;
  uint64_t v9 = v8 >> 2;
  if ((unint64_t)(v8 >> 2) <= 0x20) {
    uint64_t v9 = 32;
  }
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v9;
  }
  if (v10 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v11 = (char *)operator new(8 * v10);
  unsigned int v12 = &v11[8 * v5];
  int v13 = v11 + 256;
  unint64_t v14 = (31 - v5) & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v15 = v12;
  if (v14 < 0x13) {
    goto LABEL_18;
  }
  if (v12 < (char *)&v44)
  {
    uint64_t v15 = &v11[8 * v5];
    if (&v11[8 * v6 + v4] > (char *)&v43) {
      goto LABEL_18;
    }
  }
  uint64_t v16 = (v14 + 1) & 0x3FFFFFFFFFFFFFFCLL;
  uint64_t v17 = &v11[8 * v5];
  uint64_t v18 = v16;
  do
  {
    *(_OWORD *)uint64_t v17 = 0uLL;
    *((_OWORD *)v17 + 1) = 0uLL;
    v17 += 32;
    v18 -= 4;
  }
  while (v18);
  if (v14 + 1 != v16)
  {
    uint64_t v15 = &v12[8 * v16];
LABEL_18:
    uint64_t v19 = v43;
    do
    {
      *(void *)uint64_t v15 = v19;
      v15 += 8;
    }
    while (v15 != v13);
  }
  *((void *)this + 1) = v12;
  *((void *)this + 2) = v13;
  *((void *)this + 3) = &v11[8 * v10];
  if (v3) {
    operator delete(v3);
  }
LABEL_33:
  unint64_t v25 = (char *)*((void *)this + 20);
  uint64_t v26 = (char *)*((void *)this + 21);
  uint64_t v27 = v26 - v25;
  if (v26 == v25)
  {
    uint64_t v43 = 0;
    if ((unint64_t)v27 > 0xFF)
    {
      if (v27 != 256) {
        *((void *)this + 21) = v26 + 256;
      }
    }
    else
    {
      std::vector<__CVBuffer *>::__append((unint64_t *)this + 20, 32 - (v27 >> 3), (const double *)&v43);
    }
  }
  else
  {
    *((_OWORD *)v25 + 14) = 0u;
    *((_OWORD *)v25 + 15) = 0u;
    *((_OWORD *)v25 + 12) = 0u;
    *((_OWORD *)v25 + 13) = 0u;
    *((_OWORD *)v25 + 10) = 0u;
    *((_OWORD *)v25 + 11) = 0u;
    *((_OWORD *)v25 + 8) = 0u;
    *((_OWORD *)v25 + 9) = 0u;
    *((_OWORD *)v25 + 6) = 0u;
    *((_OWORD *)v25 + 7) = 0u;
    *((_OWORD *)v25 + 4) = 0u;
    *((_OWORD *)v25 + 5) = 0u;
    *((_OWORD *)v25 + 2) = 0u;
    *((_OWORD *)v25 + 3) = 0u;
    *(_OWORD *)unint64_t v25 = 0u;
    *((_OWORD *)v25 + 1) = 0u;
  }
  uint64_t v28 = (char *)*((void *)this + 23);
  unsigned int v29 = (char *)*((void *)this + 24);
  uint64_t v30 = v29 - v28;
  if (v29 == v28)
  {
    uint64_t v43 = 0;
    if ((unint64_t)v30 > 0xFF)
    {
      if (v30 != 256) {
        *((void *)this + 24) = v29 + 256;
      }
    }
    else
    {
      std::vector<__CVBuffer *>::__append((unint64_t *)this + 23, 32 - (v30 >> 3), (const double *)&v43);
    }
  }
  else
  {
    *((_OWORD *)v28 + 14) = 0u;
    *((_OWORD *)v28 + 15) = 0u;
    *((_OWORD *)v28 + 12) = 0u;
    *((_OWORD *)v28 + 13) = 0u;
    *((_OWORD *)v28 + 10) = 0u;
    *((_OWORD *)v28 + 11) = 0u;
    *((_OWORD *)v28 + 8) = 0u;
    *((_OWORD *)v28 + 9) = 0u;
    *((_OWORD *)v28 + 6) = 0u;
    *((_OWORD *)v28 + 7) = 0u;
    *((_OWORD *)v28 + 4) = 0u;
    *((_OWORD *)v28 + 5) = 0u;
    *((_OWORD *)v28 + 2) = 0u;
    *((_OWORD *)v28 + 3) = 0u;
    *(_OWORD *)uint64_t v28 = 0u;
    *((_OWORD *)v28 + 1) = 0u;
  }
  uint64_t v32 = (char *)*((void *)this + 26);
  uint64_t v31 = (char *)*((void *)this + 27);
  uint64_t v33 = v31 - v32;
  if (v31 == v32)
  {
    uint64_t v43 = 0;
    if ((unint64_t)v33 > 0x6F)
    {
      if (v33 != 112) {
        *((void *)this + 27) = v31 + 112;
      }
    }
    else
    {
      std::vector<__CVBuffer *>::__append((unint64_t *)this + 26, 14 - (v33 >> 3), (const double *)&v43);
    }
  }
  else
  {
    *((_OWORD *)v32 + 5) = 0u;
    *((_OWORD *)v32 + 6) = 0u;
    *((_OWORD *)v32 + 3) = 0u;
    *((_OWORD *)v32 + 4) = 0u;
    *((_OWORD *)v32 + 1) = 0u;
    *((_OWORD *)v32 + 2) = 0u;
    *(_OWORD *)uint64_t v32 = 0u;
  }
  float v35 = (char *)*((void *)this + 32);
  unsigned int v34 = (char *)*((void *)this + 33);
  uint64_t v36 = v34 - v35;
  if (v34 == v35)
  {
    uint64_t v43 = 0;
    if ((unint64_t)v36 > 0x6F)
    {
      if (v36 != 112) {
        *((void *)this + 33) = v34 + 112;
      }
    }
    else
    {
      std::vector<__CVBuffer *>::__append((unint64_t *)this + 32, 14 - (v36 >> 3), (const double *)&v43);
    }
  }
  else
  {
    *((_OWORD *)v35 + 5) = 0u;
    *((_OWORD *)v35 + 6) = 0u;
    *((_OWORD *)v35 + 3) = 0u;
    *((_OWORD *)v35 + 4) = 0u;
    *((_OWORD *)v35 + 1) = 0u;
    *((_OWORD *)v35 + 2) = 0u;
    *(_OWORD *)float v35 = 0u;
  }
  float v38 = (char *)*((void *)this + 29);
  int v37 = (char *)*((void *)this + 30);
  uint64_t v39 = v37 - v38;
  if (v37 == v38)
  {
    uint64_t v43 = 0;
    if ((unint64_t)v39 > 0x6F)
    {
      if (v39 != 112) {
        *((void *)this + 30) = v37 + 112;
      }
    }
    else
    {
      std::vector<__CVBuffer *>::__append((unint64_t *)this + 29, 14 - (v39 >> 3), (const double *)&v43);
    }
  }
  else
  {
    *((_OWORD *)v38 + 5) = 0u;
    *((_OWORD *)v38 + 6) = 0u;
    *((_OWORD *)v38 + 3) = 0u;
    *((_OWORD *)v38 + 4) = 0u;
    *((_OWORD *)v38 + 1) = 0u;
    *((_OWORD *)v38 + 2) = 0u;
    *(_OWORD *)float v38 = 0u;
  }
  uint64_t v41 = (char *)*((void *)this + 35);
  unint64_t v40 = (char *)*((void *)this + 36);
  uint64_t v42 = v40 - v41;
  if (v40 == v41)
  {
    uint64_t v43 = 0;
    if ((unint64_t)v42 > 0x6F)
    {
      if (v42 != 112) {
        *((void *)this + 36) = v40 + 112;
      }
    }
    else
    {
      std::vector<__CVBuffer *>::__append((unint64_t *)this + 35, 14 - (v42 >> 3), (const double *)&v43);
    }
  }
  else
  {
    *((_OWORD *)v41 + 5) = 0u;
    *((_OWORD *)v41 + 6) = 0u;
    *((_OWORD *)v41 + 3) = 0u;
    *((_OWORD *)v41 + 4) = 0u;
    *((_OWORD *)v41 + 1) = 0u;
    *((_OWORD *)v41 + 2) = 0u;
    *(_OWORD *)uint64_t v41 = 0u;
  }
}

void anonymous namespace'::extractPasses(long long *a1, char **a2)
{
  uint64_t v4 = *((void *)a1 + 1);
  uint64_t v5 = *(long long **)(v4 + 72);
  for (i = *(long long **)(v4 + 80); v5 != i; uint64_t v5 = (long long *)((char *)v5 + 24))
  {
    long long v19 = *v5;
    uint64_t v20 = *((void *)v5 + 2);
  }
  uint64_t v8 = a2[1];
  unint64_t v7 = (unint64_t)a2[2];
  if ((unint64_t)v8 >= v7)
  {
    unint64_t v11 = *a2;
    unint64_t v12 = 0xAAAAAAAAAAAAAAABLL * ((v8 - *a2) >> 3);
    unint64_t v13 = v12 + 1;
    if (v12 + 1 > 0xAAAAAAAAAAAAAAALL) {
      abort();
    }
    unint64_t v14 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v7 - (void)v11) >> 3);
    if (2 * v14 > v13) {
      unint64_t v13 = 2 * v14;
    }
    if (v14 >= 0x555555555555555) {
      unint64_t v15 = 0xAAAAAAAAAAAAAAALL;
    }
    else {
      unint64_t v15 = v13;
    }
    if (v15)
    {
      if (v15 > 0xAAAAAAAAAAAAAAALL) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      uint64_t v16 = (char *)operator new(24 * v15);
    }
    else
    {
      uint64_t v16 = 0;
    }
    uint64_t v17 = &v16[24 * v12];
    *(_OWORD *)uint64_t v17 = *a1;
    *((void *)v17 + 2) = *((void *)a1 + 2);
    unint64_t v10 = v17 + 24;
    if (v8 != v11)
    {
      do
      {
        long long v18 = *(_OWORD *)(v8 - 24);
        *(v17 - 8) = *(v8 - 8);
        *(_OWORD *)(v17 - 24) = v18;
        v17 -= 24;
        v8 -= 24;
      }
      while (v8 != v11);
      uint64_t v8 = *a2;
    }
    *a2 = v17;
    a2[1] = v10;
    a2[2] = &v16[24 * v15];
    if (v8) {
      operator delete(v8);
    }
  }
  else
  {
    long long v9 = *a1;
    *((void *)v8 + 2) = *((void *)a1 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    unint64_t v10 = v8 + 24;
  }
  a2[1] = v10;
  *(void *)(*((void *)a1 + 1) + 80) = *(void *)(*((void *)a1 + 1) + 72);
}

uint64_t ggl::MetalDeviceContext::beginPass(uint64_t result)
{
  if (!*(void *)(result + 48)) {
    operator new();
  }
  return result;
}

void ggl::MetalDeviceContextPass::~MetalDeviceContextPass(ggl::MetalDeviceContextPass *this)
{
  uint8x8_t v2 = (void *)*((void *)this + 13);
  if (v2)
  {
    [v2 updateFence:*((void *)this + 11)];
    [*((id *)this + 13) endEncoding];
    unint64_t v3 = (void *)*((void *)this + 13);
    *((void *)this + 13) = 0;
  }
  uint64_t v4 = (void *)*((void *)this + 12);
  if (v4)
  {
    [v4 updateFence:*((void *)this + 11) afterStages:2];
    [*((id *)this + 12) endEncoding];
    uint64_t v5 = (void *)*((void *)this + 12);
    *((void *)this + 12) = 0;
  }
  if (*((unsigned char *)this + 64)) {
    *((unsigned char *)this + 64) = 0;
  }
}

void sub_1A1A70A14(_Unwind_Exception *a1)
{
  if (*(unsigned char *)(v1 + 64)) {
    *(unsigned char *)(v1 + 64) = 0;
  }
  _Unwind_Resume(a1);
}

void ggl::MetalDeviceContext::endFrame(ggl::MetalDeviceContext *this, const ggl::EndFrameParams *a2)
{
  uint64_t v103 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v5 = (id *)operator new(0x18uLL);
    double v91 = v5;
    unint64_t v92 = v5;
    uint64_t v93 = v5 + 3;
    uint64_t v6 = (uint64_t)*(id *)(v2 + 144);
    id v70 = *(id *)(*((void *)this + 5) + 152);
    uint64_t v67 = (void *)v6;
    if (v6)
    {
      id *v5 = *(id *)(*((void *)this + 5) + 128);
      unint64_t v92 = v5 + 1;
      objc_msgSend((id)v6, "endEncoding", v6);
      uint64_t v6 = 1;
    }
    uint64_t v7 = *((void *)this + 5);
    if (*(unsigned char *)(v7 + 50))
    {
      v5[v6++] = *(id *)(v7 + 120);
      unint64_t v92 = &v5[v6];
    }
    uint64_t v8 = &v5[v6];
    if (v70)
    {
      *v8++ = *(id *)(*((void *)this + 5) + 136);
      unint64_t v92 = v8;
      [v70 endEncoding];
    }
    uint64_t v9 = *((void *)a2 + 8);
    for (uint64_t i = *((void *)a2 + 9); v9 != i; v9 += 32)
    {
      uint64_t v11 = *((void *)this + 5);
      *(_OWORD *)buf = *(_OWORD *)(v11 + 24);
      if (*(unsigned char *)(v11 + 50))
      {
        id v12 = *(id *)(v11 + 120);
        *(void *)&buf[16] = v12;
      }
      else
      {
        id v12 = 0;
        *(void *)&buf[16] = 0;
      }

      uint64_t v13 = *(void *)(v9 + 24);
      if (v13)
      {
        v81[0] = buf;
        (*(void (**)(uint64_t, void *))(*(void *)v13 + 48))(v13, v81);
      }
    }
    uint64_t v14 = *((void *)this + 5);
    unint64_t v15 = *(uint64_t **)(v14 + 8);
    uint64_t v16 = *(std::__shared_weak_count **)(v14 + 16);
    double v89 = v15;
    uint64_t v90 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    unint64_t v17 = atomic_load((unsigned int *)(*(void *)(*((void *)this + 2) + 80) + 312));
    if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
      dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
    }
    atomic_store(v17, (unint64_t *)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 64));
    ggl::RenderResourceFences::update(*((_DWORD **)this + 4), v15 + 2);
    if (v91 == v8)
    {
      id v18 = 0;
      long long v19 = 0;
    }
    else
    {
      id v18 = *v91;
      long long v19 = *(v8 - 1);
    }
    unint64_t v72 = v18;
    id v21 = v19;
    v87[0] = 0;
    v87[1] = v87;
    v87[2] = 0x2020000000;
    id v71 = v21;
    BOOL v88 = v18 == v21;
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x4012000000;
    unint64_t v98 = __Block_byref_object_copy__53326;
    uint64_t v99 = __Block_byref_object_dispose__53327;
    uint64_t v100 = "";
    unint64_t v22 = (std::__shared_weak_count *)operator new(0x20uLL);
    v22->__shared_owners_ = 0;
    v22->__shared_weak_owners_ = 0;
    v22->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B1F8;
    v22[1].__vftable = 0;
    long long v101 = &v22[1].__vftable;
    unint64_t v102 = v22;
    uint64_t v83 = 0;
    uint64_t v84 = &v83;
    uint64_t v85 = 0x2020000000;
    uint64_t v86 = *(void *)(*((void *)this + 5) + 40);
    v81[0] = 0;
    v81[1] = v81;
    v81[2] = 0x4012000000;
    v81[3] = __Block_byref_object_copy__2;
    v81[4] = __Block_byref_object_dispose__3;
    v81[5] = "";
    uint64_t v24 = (std::__shared_weak_count *)operator new(0x38uLL);
    v24->__shared_owners_ = 0;
    v24->__shared_weak_owners_ = 0;
    v24->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B310;
    v24[1].__vftable = 0;
    v24[1].__shared_owners_ = 0;
    v24[1].__shared_weak_owners_ = 0;
    unint64_t v25 = (std::__shared_weak_count_vtbl *)*((void *)a2 + 19);
    v24[2].__vftable = v25;
    uint64_t v27 = *((void *)a2 + 16);
    uint64_t v26 = *((void *)a2 + 17);
    uint64_t v28 = v26 - v27;
    if (v26 != v27)
    {
      if (v28 < 0) {
        abort();
      }
      v68 = a2;
      uint64_t v29 = (*((uint64_t (**)(std::__shared_weak_count_vtbl *, uint64_t, uint64_t))v25->~__shared_weak_count + 2))(v25, v26 - v27, 8);
      uint64_t v30 = 0;
      v24[1].__vftable = (std::__shared_weak_count_vtbl *)v29;
      v24[1].__shared_owners_ = v29;
      v24[1].__shared_weak_owners_ = v29 + 32 * (v28 >> 5);
      while (1)
      {
        uint64_t v23 = v29 + v30;
        if (v29 + v30)
        {
          uint64_t v32 = v27 + v30;
          uint64_t v31 = *(void *)(v27 + v30 + 24);
          if (v31)
          {
            if (v32 == v31)
            {
              *(void *)(v29 + v30 + 24) = v23;
              (*(void (**)(void))(**(void **)(v32 + 24) + 24))(*(void *)(v32 + 24));
              goto LABEL_31;
            }
            uint64_t v31 = (*(uint64_t (**)(uint64_t))(*(void *)v31 + 16))(v31);
          }
          *(void *)(v29 + v30 + 24) = v31;
        }
LABEL_31:
        v30 += 32;
        if (v27 + v30 == v26)
        {
          v24[1].__shared_owners_ = v29 + v30;
          a2 = v68;
          break;
        }
      }
    }
    v81[6] = v24 + 1;
    uint64_t v82 = v24;
    v80[0] = MEMORY[0x1E4F143A8];
    v80[1] = 3221225472;
    v80[2] = ___ZN3ggl18MetalDeviceContext8endFrameERKNS_14EndFrameParamsE_block_invoke;
    v80[3] = &unk_1E5A997E0;
    v80[4] = buf;
    char v69 = (void *)MEMORY[0x1A6239EB0](v80, v23);
    v79[0] = MEMORY[0x1E4F143A8];
    v79[1] = 3221225472;
    v79[2] = ___ZN3ggl18MetalDeviceContext8endFrameERKNS_14EndFrameParamsE_block_invoke_2;
    v79[3] = &unk_1E5A997E0;
    v79[4] = &v83;
    uint64_t v33 = (void *)MEMORY[0x1A6239EB0](v79);
    v77[0] = MEMORY[0x1E4F143A8];
    v77[1] = 3321888768;
    v77[2] = ___ZN3ggl18MetalDeviceContext8endFrameERKNS_14EndFrameParamsE_block_invoke_6;
    v77[3] = &unk_1EF58E7F8;
    v77[6] = this;
    v77[7] = v15;
    uint64_t v78 = v16;
    if (v16) {
      atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    v77[4] = &v83;
    v77[5] = v81;
    unsigned int v34 = (void *)MEMORY[0x1A6239EB0](v77);
    v73[0] = MEMORY[0x1E4F143A8];
    v73[1] = 3221225472;
    v73[2] = ___ZN3ggl18MetalDeviceContext8endFrameERKNS_14EndFrameParamsE_block_invoke_8;
    v73[3] = &unk_1E5A99808;
    uint64_t v75 = v87;
    uint64_t v76 = buf;
    id v35 = v34;
    id v74 = v35;
    uint64_t v36 = (void *)MEMORY[0x1A6239EB0](v73);
    if (v18)
    {
      [v18 addScheduledHandler:v33];
      if (v18 != v71) {
        [v18 addCompletedHandler:v69];
      }
      objc_msgSend(v71, "addCompletedHandler:", v36, v67);
    }
    else
    {
      (*((void (**)(id, void, void, double))v35 + 2))(v35, 0, 0, 0.0);
    }
    int v37 = (id *)*((void *)this + 5);
    *((void *)this + 5) = 0;
    if (v37)
    {
      ggl::MetalDeviceContextFrame::~MetalDeviceContextFrame(v37);
      MEMORY[0x1A6239270]();
    }
    atomic_store(1u, (unsigned int *)v15 + 2);
    unsigned int v38 = atomic_load((unsigned int *)v15 + 2);
    if (v38 == 2 && (uint64_t v39 = v15[7]) != 0)
    {
      uint64_t v40 = *v15;
      uint64_t v95 = 0;
      *(void *)int v96 = v40;
      int v94 = 0;
      (*(void (**)(uint64_t, uint8_t *, uint64_t *, int *))(*(void *)v39 + 48))(v39, v96, &v95, &v94);
    }
    else
    {
      unsigned int v41 = atomic_load((unsigned int *)v15 + 2);
      if (v41 == 1)
      {
        uint64_t v42 = v15[11];
        if (v42) {
          (*(void (**)(uint64_t))(*(void *)v42 + 48))(v42);
        }
      }
    }
    uint64_t v43 = v91;
    uint64_t v44 = v92;
    if (v91 != v92)
    {
      unint64_t v45 = v91;
      do
      {
        id v46 = *v45;
        [v46 commit];

        ++v45;
      }
      while (v45 != v44);
    }
    uint64_t v47 = *((void *)a2 + 12);
    uint64_t v48 = *((void *)a2 + 13);
    while (v47 != v48)
    {
      uint64_t v49 = *(void *)(v47 + 24);
      if (v49) {
        (*(void (**)(uint64_t))(*(void *)v49 + 48))(v49);
      }
      v47 += 32;
    }
    if (GEOGetGeoGLPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoGLPerformanceLog_onceToken, &__block_literal_global_5_53372);
    }
    uint64_t v50 = (id)GEOGetGeoGLPerformanceLog_log;
    unint64_t v51 = v50;
    os_signpost_id_t v52 = v84[3];
    if (v52 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v50))
    {
      *(_WORD *)int v96 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v51, OS_SIGNPOST_INTERVAL_BEGIN, v52, "GPUFrameScheduled", "", v96, 2u);
    }

    if (GEOGetGeoGLPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoGLPerformanceLog_onceToken, &__block_literal_global_5_53372);
    }
    uint64_t v53 = (id)GEOGetGeoGLPerformanceLog_log;
    uint64_t v54 = v53;
    os_signpost_id_t v55 = v84[3];
    if (v55 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v53))
    {
      *(_WORD *)int v96 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v54, OS_SIGNPOST_INTERVAL_BEGIN, v55, "WaitUntilScheduled", "", v96, 2u);
    }

    for (; v43 != v44; ++v43)
    {
      id v56 = *v43;
      [v56 waitUntilScheduled];
    }
    if (GEOGetGeoGLPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetGeoGLPerformanceLog_onceToken, &__block_literal_global_5_53372);
    }
    uint64_t v57 = (id)GEOGetGeoGLPerformanceLog_log;
    uint64_t v58 = v57;
    os_signpost_id_t v59 = v84[3];
    if (v59 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v57))
    {
      *(_WORD *)int v96 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v58, OS_SIGNPOST_INTERVAL_END, v59, "WaitUntilScheduled", "", v96, 2u);
    }

    uint64_t v60 = v78;
    if (v78 && !atomic_fetch_add(&v78->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v60->__on_zero_shared)(v60);
      std::__shared_weak_count::__release_weak(v60);
    }

    _Block_object_dispose(v81, 8);
    uint64_t v61 = v82;
    if (v82 && !atomic_fetch_add(&v82->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v61->__on_zero_shared)(v61);
      std::__shared_weak_count::__release_weak(v61);
    }
    _Block_object_dispose(&v83, 8);
    _Block_object_dispose(buf, 8);
    float v62 = v102;
    if (v102 && !atomic_fetch_add(&v102->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v62->__on_zero_shared)(v62);
      std::__shared_weak_count::__release_weak(v62);
    }
    _Block_object_dispose(v87, 8);

    BOOL v63 = v90;
    if (v90 && !atomic_fetch_add(&v90->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v63->__on_zero_shared)(v63);
      std::__shared_weak_count::__release_weak(v63);
    }

    char v64 = v91;
    if (v91)
    {
      for (j = v92; j != v64; --j)
      {
        uint64_t v66 = *(j - 1);
      }
      operator delete(v64);
    }
  }
  else
  {
    if (GEOGetGeoGLMetalDeviceContextLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetGeoGLMetalDeviceContextLog(void)::onceToken, &__block_literal_global_53322);
    }
    uint64_t v20 = GEOGetGeoGLMetalDeviceContextLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoGLMetalDeviceContextLog(void)::log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&buf[4] = "false";
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalDeviceContext.mm";
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v98) = 169;
      _os_log_impl(&dword_1A1780000, v20, OS_LOG_TYPE_FAULT, "No active frame to end: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
    }
  }
}

void sub_1A1A71608(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a28);
  _Block_object_dispose(&a40, 8);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a46);
  _Block_object_dispose(&a48, 8);
  _Block_object_dispose((const void *)(v59 - 192), 8);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v59 - 144);
  _Block_object_dispose(&a52, 8);

  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&a56);
  std::vector<VKTransitLineMarker * {__strong}>::~vector[abi:nn180100]((void **)(v59 - 248));
  _Unwind_Resume(a1);
}

uint64_t ggl::MetalResourceManager::upload(ggl::MetalResourceManager *a1, uint64_t a2, id a3)
{
  uint64_t v5 = *(unsigned int **)a2;
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(uint64_t **)(v6 + 24);
  if (!v7)
  {
    uint64_t v7 = ggl::MetalResourceManager::newTexture(a1, *(const Texture **)(a2 + 8));
    if (v5) {
      goto LABEL_3;
    }
LABEL_10:
    uint64_t result = *(void *)(a2 + 72);
    if (!result) {
      return result;
    }
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, a2);
  }
  if (!v5) {
    goto LABEL_10;
  }
LABEL_3:
  int32x2_t v8 = *(int32x2_t *)(a2 + 36);
  int32x2_t v9 = *(int32x2_t *)(a2 + 28);
  if (*(void *)a3 && *((unsigned char *)v7 + 120) == 1) {
    ggl::RenderResourceFences::update((_DWORD *)v7 + 16, (uint64_t *)(*(void *)a3 + 16));
  }
  if (*((unsigned char *)v7 + 120) == 1)
  {
    unint64_t v10 = (id *)(v7[4] + 8 * *((unsigned int *)v7 + 16));
  }
  else
  {
    if (*((unsigned char *)v7 + 120)) {
      goto LABEL_15;
    }
    unint64_t v10 = (id *)v7[4];
  }
  a3 = *v10;
LABEL_15:
  if (v5[2])
  {
    unint64_t v12 = 0;
    uint32x2_t v13 = (uint32x2_t)vsub_s32(v8, v9);
    do
    {
      if ((*(uint64_t (**)(unsigned int *, unint64_t))(*(void *)v5 + 16))(v5, v12))
      {
        uint32x2_t v18 = (uint32x2_t)vneg_s32(vdup_n_s32(v12));
        uint32x2_t v19 = vmax_u32(vshl_u32(v13, v18), (uint32x2_t)0x100000001);
        *(void *)&long long v20 = v19.u32[0];
        *((void *)&v20 + 1) = v19.u32[1];
        long long v21 = v20;
        unsigned int v22 = *(unsigned __int8 *)(a2 + 16);
        if (*(unsigned char *)(a2 + 16))
        {
          if (*(unsigned __int8 *)(a2 + 17) - 1 <= 4) {
            unsigned int v22 = (*(unsigned char *)(a2 + 17) - 1) + 1;
          }
          else {
            unsigned int v22 = 0;
          }
        }
        uint32x2_t v14 = vshl_u32(*(uint32x2_t *)(a2 + 28), v18);
        *(void *)&long long v15 = v14.u32[0];
        *((void *)&v15 + 1) = v14.u32[1];
        long long v16 = v15;
        if (*(unsigned char *)(a2 + 20)) {
          uint64_t v17 = *(unsigned int *)(a2 + 24);
        }
        else {
          uint64_t v17 = v22;
        }
        long long v23 = v16;
        uint64_t v24 = 0;
        long long v25 = v21;
        uint64_t v26 = 1;
        objc_msgSend(a3, "replaceRegion:mipmapLevel:slice:withBytes:bytesPerRow:bytesPerImage:", &v23, v12, v17);
      }
      ++v12;
    }
    while (v12 < v5[2]);
  }
  if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
    dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
  }
  atomic_fetch_add((atomic_ullong *volatile)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 40), 1uLL);

  uint64_t result = *(void *)(a2 + 72);
  if (result) {
    return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)result + 48))(result, a2);
  }
  return result;
}

void sub_1A1A71A5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ggl::RenderResourceFences::update(_DWORD *a1, uint64_t *a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *a2;
  if (*a2 == *(void *)&a1[4 * v2 + 2]) {
    return;
  }
  uint64_t v4 = ((int)v2 + 1) % 3u;
  *a1 = v4;
  uint64_t v5 = &a1[4 * v4];
  int32x2_t v8 = (unsigned __int8 *)*((void *)v5 + 1);
  uint64_t v6 = v5 + 2;
  uint64_t v7 = v8;
  if (v8)
  {
    atomic_load(v7);
    int32x2_t v9 = &a1[4 * *a1];
    uint64_t v11 = *a2;
    uint64_t v10 = a2[1];
    if (v10) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
    }
    *((void *)v9 + 1) = v11;
    unint64_t v12 = (std::__shared_weak_count *)*((void *)v9 + 2);
    *((void *)v9 + 2) = v10;
    if (!v12) {
      return;
    }
LABEL_10:
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
    return;
  }
  uint64_t v13 = a2[1];
  if (v13) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
  }
  void *v6 = v3;
  uint32x2_t v14 = &a1[4 * v4];
  unint64_t v12 = (std::__shared_weak_count *)*((void *)v14 + 2);
  *((void *)v14 + 2) = v13;
  if (v12) {
    goto LABEL_10;
  }
}

uint64_t std::__function::__func<md::LabelRenderer::prepareDeviceBuffer(md::LabelRenderDeviceBuffer &,unsigned int)::$_0,std::allocator<md::LabelRenderer::prepareDeviceBuffer(md::LabelRenderDeviceBuffer &,unsigned int)::$_0>,void ()(ggl::Texture2DLoadItem const&)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (*a2) {
    return (*(uint64_t (**)(void))(*(void *)result + 8))();
  }
  return result;
}

uint64_t ggl::TextureData2DNoCopy::mipData(ggl::TextureData2DNoCopy *this, unsigned int a2)
{
  return *(void *)(*((void *)this + 4) + 8 * a2);
}

void ggl::TextureData2DNoCopy::~TextureData2DNoCopy(ggl::TextureData2DNoCopy *this)
{
  *(void *)this = &unk_1EF55F580;
  uint64_t v1 = *((void *)this + 4);
  if (v1)
  {
    *((void *)this + 5) = v1;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 7) + 40))(*((void *)this + 7), v1, *((void *)this + 6) - v1);
  }
  JUMPOUT(0x1A6239270);
}

{
  uint64_t v1;

  *(void *)this = &unk_1EF55F580;
  uint64_t v1 = *((void *)this + 4);
  if (v1)
  {
    *((void *)this + 5) = v1;
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 7) + 40))(*((void *)this + 7), v1, *((void *)this + 6) - v1);
  }
}

uint64_t std::__shared_ptr_pointer<ggl::RenderTransaction *,std::shared_ptr<ggl::RenderTransaction>::__shared_ptr_default_delete<ggl::RenderTransaction,ggl::RenderTransaction>,std::allocator<ggl::RenderTransaction>>::__on_zero_shared(uint64_t result)
{
  uint64_t v1 = *(void **)(result + 24);
  if (v1)
  {
    uint64_t v2 = (void *)v1[11];
    if (v2 == v1 + 8)
    {
      (*(void (**)(void *))(v1[8] + 32))(v1 + 8);
    }
    else if (v2)
    {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    uint64_t v3 = (void *)v1[7];
    if (v3 == v1 + 4)
    {
      (*(void (**)(void *))(v1[4] + 32))(v1 + 4);
      uint64_t v4 = (std::__shared_weak_count *)v1[3];
      if (!v4) {
        goto LABEL_15;
      }
    }
    else
    {
      if (v3) {
        (*(void (**)(void *))(*v3 + 40))(v3);
      }
      uint64_t v4 = (std::__shared_weak_count *)v1[3];
      if (!v4)
      {
LABEL_15:
        JUMPOUT(0x1A6239270);
      }
    }
    if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    goto LABEL_15;
  }
  return result;
}

void *std::allocator_traits<geo::StdAllocator<std::function<void ()(NSError *)>,ggl::Allocator>>::construct[abi:nn180100]<std::function<void ()(NSError *)>,ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0,void>(void *result, void *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (result)
  {
    uint64_t v2 = result;
    uint64_t v3 = (void *)a2[3];
    if (v3)
    {
      if (v3 == a2)
      {
        uint64_t v6 = v5;
        (*(void (**)(void *, void *))(*a2 + 24))(a2, v5);
      }
      else
      {
        uint64_t v6 = (void *)a2[3];
        a2[3] = 0;
      }
    }
    else
    {
      uint64_t v6 = 0;
    }
    v2[3] = 0;
    uint64_t result = operator new(0x28uLL);
    uint64_t v4 = result;
    unint64_t *result = &unk_1EF57AB30;
    if (!v6)
    {
      result[4] = 0;
      goto LABEL_11;
    }
    if (v6 != v5)
    {
      result[4] = v6;
LABEL_11:
      v2[3] = result;
      return result;
    }
    result[4] = result + 1;
    (*(void (**)(void *))(v5[0] + 24))(v5);
    uint64_t result = v6;
    v2[3] = v4;
    if (result == v5)
    {
      return (void *)(*(uint64_t (**)(void *))(v5[0] + 32))(v5);
    }
    else if (result)
    {
      return (void *)(*(uint64_t (**)(void *))(*result + 40))(result);
    }
  }
  return result;
}

void sub_1A1A71F78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13)
{
  if (a13 == &a10)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
    _Unwind_Resume(exception_object);
  }
  if (a13) {
    (*(void (**)(void))(*a13 + 40))();
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::__function::__func<md::erq::EncodeRenderQueue::operator()(md::erq::RenderQueueToSubmit const&,md::erq::RenderTargetToSubmit const&,md::erq::GPUWorkCallbacks const&)::$_1,std::allocator<md::erq::EncodeRenderQueue::operator()(md::erq::RenderQueueToSubmit const&,md::erq::RenderTargetToSubmit const&,md::erq::GPUWorkCallbacks const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  os_signpost_id_t v2 = *(void *)(a1 + 8);
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL)
  {
    uint64_t v3 = GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled((os_log_t)GEOGetVectorKitPerformanceLog_log))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v2, "SubmitCommands", "", v5, 2u);
    }
  }
  return (*(uint64_t (**)(void, void))(**(void **)(a1 + 24) + 56))(*(void *)(a1 + 24), *(void *)(a1 + 16));
}

void *std::__function::__func<ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0,std::allocator<ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_0>,void ()(NSError *)>::__clone(uint64_t a1)
{
  os_signpost_id_t v2 = operator new(0x28uLL);
  *os_signpost_id_t v2 = &unk_1EF57AB30;
  uint64_t v3 = v2 + 1;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    if (v4 == a1 + 8)
    {
      v2[4] = v3;
      (*(void (**)(uint64_t))(*(void *)v4 + 24))(v4);
      return v2;
    }
    uint64_t v4 = (*(uint64_t (**)(uint64_t, void *))(*(void *)v4 + 16))(v4, v3);
  }
  v2[4] = v4;
  return v2;
}

void sub_1A1A7217C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void ggl::MetalDeviceContextFrame::~MetalDeviceContextFrame(id *this)
{
  os_signpost_id_t v2 = (char *)this[11];
  if (!v2) {
    goto LABEL_16;
  }
  uint64_t v3 = (char *)this[12];
  uint64_t v4 = this[11];
  if (v3 == v2) {
    goto LABEL_15;
  }
  uint64_t v5 = v3 - 32;
  uint64_t v6 = v3 - 32;
  do
  {
    int32x2_t v8 = (char *)*((void *)v6 + 3);
    if (v6 == v8)
    {
      (*(void (**)(char *, unsigned char *))(*(void *)v6 + 32))(v6, v4);
      if (*(v6 - 28)) {
        goto LABEL_9;
      }
    }
    else
    {
      if (v8) {
        (*(void (**)(char *, unsigned char *))(*(void *)v8 + 40))(v8, v4);
      }
      if (*(v6 - 28)) {
LABEL_9:
      }
        *(v6 - 28) = 0;
    }
    if (*(v6 - 32)) {
      *(v6 - 32) = 0;
    }
    uint64_t v7 = v6 - 48;
    v6 -= 80;
    v5 -= 80;
  }
  while (v7 != v2);
  uint64_t v4 = this[11];
LABEL_15:
  this[12] = v2;
  (*(void (**)(id, unsigned char *, int64_t))(*(void *)this[14] + 40))(this[14], v4, (unsigned char *)this[13] - v4);
LABEL_16:
  int32x2_t v9 = (char *)this[7];
  if (v9)
  {
    uint64_t v10 = (char *)this[8];
    uint64_t v11 = this[7];
    if (v10 != v9)
    {
      unint64_t v12 = v10 - 32;
      uint64_t v13 = v10 - 32;
      do
      {
        long long v15 = (char *)*((void *)v13 + 3);
        if (v13 == v15)
        {
          (*(void (**)(char *))(*(void *)v13 + 32))(v13);
        }
        else if (v15)
        {
          (*(void (**)(char *, unsigned char *))(*(void *)v15 + 40))(v15, v11);
        }
        uint32x2_t v14 = v13 - 32;
        v13 -= 64;
        v12 -= 64;
      }
      while (v14 != v9);
      uint64_t v11 = this[7];
    }
    this[8] = v9;
    (*(void (**)(id, unsigned char *, int64_t))(*(void *)this[10] + 40))(this[10], v11, (unsigned char *)this[9] - v11);
  }
  long long v16 = (std::__shared_weak_count *)this[2];
  if (v16)
  {
    if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
}

uint64_t std::__function::__func<ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_1,std::allocator<ggl::MetalRenderer::frame(ggl::RenderTarget *,ggl::RenderQueue *,std::function<void ()(void)>,std::function<void ()(void)>,std::function<void ()(ggl::WillSubmitFrameInfo const*)>)::$_1>,void ()(NSError *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF57AB78;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<std::__bind<void (ggl::Texture2D::*)(ggl::Texture2DLoadItem const&),ggl::Texture2D*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::Texture2D::*)(ggl::Texture2DLoadItem const&),ggl::Texture2D*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::operator()(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  uint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

void ggl::Texture2D::onImplicitLoadComplete(uint64_t a1)
{
  *(unsigned char *)(a1 + 129) = 0;
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 120);
  *(void *)(a1 + 112) = 0;
  *(void *)(a1 + 120) = 0;
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

void std::vector<__CVBuffer *>::__append(unint64_t *a1, unint64_t a2, const double *a3)
{
  unint64_t v7 = a1[1];
  unint64_t v6 = a1[2];
  int32x2_t v8 = (void *)v7;
  if (a2 <= (uint64_t)(v6 - v7) >> 3)
  {
    if (!a2)
    {
LABEL_21:
      a1[1] = (unint64_t)v8;
      return;
    }
    unint64_t v16 = (a2 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v16 >= 0xF && (v7 >= (unint64_t)(a3 + 1) || v7 + 8 * a2 <= (unint64_t)a3))
    {
      unint64_t v17 = v16 + 1;
      float64x2_t v18 = vld1q_dup_f64(a3);
      uint32x2_t v19 = (float64x2_t *)(v7 + 16);
      uint64_t v20 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v19[-1] = v18;
        *uint32x2_t v19 = v18;
        v19 += 2;
        v20 -= 4;
      }
      while (v20);
      if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_20;
      }
      int32x2_t v8 = (void *)(v7 + 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL));
    }
    do
      *v8++ = *(void *)a3;
    while (v8 != (void *)(v7 + 8 * a2));
LABEL_20:
    int32x2_t v8 = (void *)(v7 + 8 * a2);
    goto LABEL_21;
  }
  int32x2_t v9 = (void *)*a1;
  uint64_t v10 = v7 - *a1;
  uint64_t v11 = v10 >> 3;
  unint64_t v12 = (v10 >> 3) + a2;
  if (v12 >> 61) {
    abort();
  }
  uint64_t v13 = v6 - (void)v9;
  if (v13 >> 2 > v12) {
    unint64_t v12 = v13 >> 2;
  }
  if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v14 = v12;
  }
  if (v14)
  {
    if (v14 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    long long v15 = (char *)operator new(8 * v14);
  }
  else
  {
    long long v15 = 0;
  }
  unint64_t v21 = (unint64_t)&v15[8 * v11];
  unsigned int v22 = (char *)(v21 + 8 * a2);
  unint64_t v23 = (a2 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  uint64_t v24 = (char *)v21;
  if (v23 < 0x13) {
    goto LABEL_30;
  }
  if (v21 < (unint64_t)(a3 + 1))
  {
    uint64_t v24 = &v15[8 * v11];
    if (&v15[8 * a2 + v10] > (char *)a3) {
      goto LABEL_30;
    }
  }
  unint64_t v25 = v23 + 1;
  float64x2_t v26 = vld1q_dup_f64(a3);
  uint64_t v27 = (float64x2_t *)&v15[8 * v11 + 16];
  uint64_t v28 = v25 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    v27[-1] = v26;
    float64x2_t *v27 = v26;
    v27 += 2;
    v28 -= 4;
  }
  while (v28);
  if (v25 != (v25 & 0x3FFFFFFFFFFFFFFCLL))
  {
    uint64_t v24 = (char *)(v21 + 8 * (v25 & 0x3FFFFFFFFFFFFFFCLL));
    do
    {
LABEL_30:
      *(double *)uint64_t v24 = *a3;
      v24 += 8;
    }
    while (v24 != v22);
    int32x2_t v9 = (void *)*a1;
  }
  if ((void *)v7 != v9)
  {
    unint64_t v29 = v7 - (void)v9 - 8;
    if (v29 < 0x58) {
      goto LABEL_50;
    }
    if (v7 - (unint64_t)&v15[v10] < 0x20) {
      goto LABEL_50;
    }
    uint64_t v30 = (v29 >> 3) + 1;
    int32x2_t v8 = (void *)(v7 - 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL));
    uint64_t v31 = &v15[8 * v11 - 16];
    uint64_t v32 = (long long *)(v7 - 16);
    uint64_t v33 = v30 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v34 = *v32;
      *((_OWORD *)v31 - 1) = *(v32 - 1);
      *(_OWORD *)uint64_t v31 = v34;
      v31 -= 32;
      v32 -= 2;
      v33 -= 4;
    }
    while (v33);
    v21 -= 8 * (v30 & 0x3FFFFFFFFFFFFFFCLL);
    if (v30 == (v30 & 0x3FFFFFFFFFFFFFFCLL))
    {
      int32x2_t v8 = v9;
    }
    else
    {
LABEL_50:
      do
      {
        uint64_t v35 = *--v8;
        *(void *)(v21 - 8) = v35;
        v21 -= 8;
      }
      while (v8 != v9);
      int32x2_t v8 = (void *)*a1;
    }
  }
  *a1 = v21;
  a1[1] = (unint64_t)v22;
  a1[2] = (unint64_t)&v15[8 * v14];
  if (v8)
  {
    operator delete(v8);
  }
}

uint64_t std::__function::__func<std::__bind<void (ggl::TextureCube::*)(ggl::Texture2DLoadItem const&),ggl::TextureCube*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::TextureCube::*)(ggl::Texture2DLoadItem const&),ggl::TextureCube*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::operator()(void *a1)
{
  uint64_t v1 = a1[2];
  uint64_t v2 = (uint64_t (*)(void *))a1[1];
  uint64_t v3 = (void *)(a1[3] + (v1 >> 1));
  if (v1) {
    return (*(uint64_t (**)(void))(*v3 + v2))();
  }
  else {
    return v2(v3);
  }
}

void ggl::TextureCube::onImplicitLoadComplete(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(unsigned __int8 *)(a2 + 17);
  *(unsigned char *)(a1 + 193) = 0;
  uint64_t v3 = a1 + 16 * v2;
  uint64_t v4 = *(std::__shared_weak_count **)(v3 + 104);
  *(void *)(v3 + 96) = 0;
  *(void *)(v3 + 104) = 0;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorRoutelineMask>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A72B54(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants &,md::ls::StyleRouteLineMaskDataKeyHandle const&>>::~Model()
{
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::ProcessRenderableForStyleRouteLineMask>,std::allocator<ecs2::ForwardToExecute<md::ita::ProcessRenderableForStyleRouteLineMask>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A72EC8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>::Model<ecs2::RuntimeQuery<md::ls::InView const&,md::ls::MeshRenderableID const&,md::ls::GradientMaskColorFactors const&,md::ls::StyleRouteLineMaskDataKeyHandle *>>::~Model()
{
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteRenderable>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfShouldDeleteRenderable>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A732A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::AssociationHandle const&>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::MeshRenderableID>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::AssociationHandle>(v3);
  unint64_t v6 = v5;
  unint64_t v7 = v5 + 4;
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v58, v8, v4, v5, *(void *)(v8 + 24));
  if (v6[8] - v6[7] >= v4[8] - v4[7]) {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v9 = (uint64_t)v7;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v56, v9, v4, v6, *(void *)(v9 + 32));
  uint64_t v10 = (uint64_t (**)(void))&ecs2::Runtime::_localEntity;
  if (v57 == v61) {
    goto LABEL_55;
  }
  unint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *unint64_t v12 = *v11;
    unint64_t v13 = *v11;
    unint64_t v14 = HIDWORD(*v11);
    unint64_t v15 = v13 >> 39;
    uint64_t v16 = v4[4];
    if (v13 >> 39 >= (v4[5] - v16) >> 3) {
      goto LABEL_17;
    }
    uint64_t v17 = *(void *)(v16 + 8 * v15);
    if (!v17) {
      goto LABEL_17;
    }
    unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v13) & 0x7F));
    uint64_t v20 = v4[7];
    uint64_t v19 = v4[8];
    if (v18 >= (v19 - v20) >> 3) {
      goto LABEL_17;
    }
    uint64_t v21 = v20 + 8 * v18;
    BOOL v22 = v21 != v19 && *(_DWORD *)(v21 + 4) == v14;
    if (v22)
    {
      uint64_t v23 = v4[11];
      uint64_t v24 = v4[10] + 8 * v18;
    }
    else
    {
LABEL_17:
      uint64_t v23 = v4[11];
      uint64_t v24 = v23;
    }
    uint64_t v25 = v24 == v23 ? 0 : v24;
    uint64_t v26 = v6[4];
    if (v15 < (v6[5] - v26) >> 3)
    {
      uint64_t v27 = *(void *)(v26 + 8 * v15);
      if (v27)
      {
        unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v13) & 0x7F));
        uint64_t v30 = v6[7];
        uint64_t v29 = v6[8];
        if (v28 < (v29 - v30) >> 3)
        {
          uint64_t v31 = v30 + 8 * v28;
          if (v31 != v29 && *(_DWORD *)(v31 + 4) == v14) {
            break;
          }
        }
      }
    }
    uint64_t v33 = v6[11];
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a2 + 24);
    if (!v35) {
      goto LABEL_54;
    }
LABEL_29:
    if (v34 == v33) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v25, v36);
    unsigned int v38 = v61;
    uint64_t v11 = *(unint64_t **)(v58 + 32);
    if (++v61 != v11)
    {
      uint64_t v39 = v59[4];
      unint64_t v40 = (v59[5] - v39) >> 3;
      unsigned int v41 = v38 + 2;
      while (1)
      {
        unint64_t v42 = *((unsigned int *)v41 - 1);
        unint64_t v43 = v42 >> 7;
        if (v42 >> 7 < v40)
        {
          uint64_t v44 = *(void *)(v39 + 8 * v43);
          if (v44)
          {
            unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
            uint64_t v46 = v59[7];
            uint64_t result = v59[8];
            if (v45 < (result - v46) >> 3)
            {
              uint64_t v47 = v46 + 8 * v45;
              if (v47 != result && *(_DWORD *)(v47 + 4) == v42)
              {
                uint64_t v49 = v60[4];
                uint64_t result = v60[5] - v49;
                if (v43 < result >> 3)
                {
                  uint64_t v50 = *(void *)(v49 + 8 * v43);
                  if (v50)
                  {
                    unint64_t v51 = *(unsigned __int16 *)(v50 + 2 * (v42 & 0x7F));
                    uint64_t v53 = v60[7];
                    uint64_t v52 = v60[8];
                    uint64_t result = v52 - v53;
                    if (v51 < (v52 - v53) >> 3)
                    {
                      uint64_t v54 = v53 + 8 * v51;
                      if (v54 != v52 && *(_DWORD *)(v54 + 4) == v42) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v61 = v41;
        BOOL v22 = v41++ == v11;
        if (v22) {
          goto LABEL_9;
        }
      }
      uint64_t v11 = v41 - 1;
    }
LABEL_9:
    if (v57 == v11) {
      goto LABEL_56;
    }
  }
  uint64_t v33 = v6[11];
  uint64_t v34 = v6[10] + 16 * v28;
  uint64_t v35 = *(void *)(a2 + 24);
  if (v35) {
    goto LABEL_29;
  }
LABEL_54:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_55:
  uint64_t result = (*v10)();
  unint64_t v12 = (void *)result;
LABEL_56:
  *unint64_t v12 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t md::Logic<md::RouteLineLogic,md::RouteLineContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x8E4587A431F9C696)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      unint64_t v6 = *(uint64_t **)(a2 + 8);
      uint64_t v7 = *v6;
      unint64_t v8 = v6[1];
      md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildRequiredTuple<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>(v14, *v6, v8);
      uint64_t v9 = md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildOptionalTuple<md::PuckContext,md::RouteOverlayContext>(v7, v8);
      v11[0] = v14[0];
      v11[1] = v14[1];
      uint64_t v12 = v9;
      uint64_t v13 = v10;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)v5 + 144))(v5, a2, v11, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::RouteLineLogic,md::RouteLineContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x8E4587A431F9C696)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      unint64_t v6 = *(uint64_t **)(a2 + 8);
      uint64_t v7 = *v6;
      unint64_t v8 = v6[1];
      md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildRequiredTuple<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>(v14, *v6, v8);
      uint64_t v9 = md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildOptionalTuple<md::PuckContext,md::RouteOverlayContext>(v7, v8);
      v11[0] = v14[0];
      v11[1] = v14[1];
      uint64_t v12 = v9;
      uint64_t v13 = v10;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)v5 + 152))(v5, a2, v11, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::RouteLineLogic,md::RouteLineContext,md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x8E4587A431F9C696)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      unint64_t v6 = *(uint64_t **)(a2 + 8);
      uint64_t v7 = *v6;
      unint64_t v8 = v6[1];
      md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildRequiredTuple<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>(v14, *v6, v8);
      uint64_t v9 = md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildOptionalTuple<md::PuckContext,md::RouteOverlayContext>(v7, v8);
      v11[0] = v14[0];
      v11[1] = v14[1];
      uint64_t v12 = v9;
      uint64_t v13 = v10;
      return (*(uint64_t (**)(uint64_t, uint64_t, _OWORD *, uint64_t))(*(void *)v5 + 136))(v5, a2, v11, v3);
    }
  }
  return result;
}

void *md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildRequiredTuple<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>(void *result, uint64_t a2, unint64_t a3)
{
  if (!a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    goto LABEL_94;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v4 = 0x1B8B241A8D896A1DLL;
    if (a3 <= 0x1B8B241A8D896A1DLL) {
      uint64_t v4 = 0x1B8B241A8D896A1DLL % a3;
    }
  }
  else
  {
    uint64_t v4 = (a3 - 1) & 0x1B8B241A8D896A1DLL;
  }
  unint64_t v8 = *(void **)(a2 + 8 * v4);
  if (!v8) {
    goto LABEL_25;
  }
  uint64_t v9 = (void *)*v8;
  if (!v9) {
    goto LABEL_25;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v11 = v9[1];
      if (v11 == 0x1B8B241A8D896A1DLL)
      {
        if (v9[2] == 0x1B8B241A8D896A1DLL) {
          goto LABEL_23;
        }
      }
      else if ((v11 & (a3 - 1)) != v4)
      {
        goto LABEL_25;
      }
      uint64_t v9 = (void *)*v9;
      if (!v9) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v10 = v9[1];
    if (v10 == 0x1B8B241A8D896A1DLL) {
      break;
    }
    if (v10 >= a3) {
      v10 %= a3;
    }
    if (v10 != v4) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v9 = (void *)*v9;
    if (!v9) {
      goto LABEL_25;
    }
  }
  if (v9[2] != 0x1B8B241A8D896A1DLL) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v12 = v9[5];
  if (*(void *)(v12 + 8) == 0x1B8B241A8D896A1DLL)
  {
    uint64_t v6 = *(void *)(v12 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v6 = 0;
LABEL_26:
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v13 = 0x8BD499FBD96FBB9ELL;
    if (a3 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v13 = 0x8BD499FBD96FBB9ELL % a3;
    }
  }
  else
  {
    unint64_t v13 = (a3 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  unint64_t v14 = *(void **)(a2 + 8 * v13);
  if (!v14) {
    goto LABEL_48;
  }
  unint64_t v15 = (void *)*v14;
  if (!v15) {
    goto LABEL_48;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v17 = v15[1];
      if (v17 == 0x8BD499FBD96FBB9ELL)
      {
        if (v15[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_46;
        }
      }
      else if ((v17 & (a3 - 1)) != v13)
      {
        goto LABEL_48;
      }
      unint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v16 = v15[1];
    if (v16 != 0x8BD499FBD96FBB9ELL)
    {
      if (v16 >= a3) {
        v16 %= a3;
      }
      if (v16 != v13) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v15[2] != 0x8BD499FBD96FBB9ELL)
    {
LABEL_35:
      unint64_t v15 = (void *)*v15;
      if (!v15) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v18 = v15[5];
  if (*(void *)(v18 + 8) == 0x8BD499FBD96FBB9ELL)
  {
    uint64_t v7 = *(void *)(v18 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v7 = 0;
LABEL_49:
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v19 = 0x1AF456233693CD46;
    if (a3 <= 0x1AF456233693CD46) {
      uint64_t v19 = 0x1AF456233693CD46 % a3;
    }
  }
  else
  {
    uint64_t v19 = (a3 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v20 = *(void **)(a2 + 8 * v19);
  if (!v20) {
    goto LABEL_71;
  }
  uint64_t v21 = (void *)*v20;
  if (!v21) {
    goto LABEL_71;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v23 = v21[1];
      if (v23 == 0x1AF456233693CD46)
      {
        if (v21[2] == 0x1AF456233693CD46) {
          goto LABEL_69;
        }
      }
      else if ((v23 & (a3 - 1)) != v19)
      {
        goto LABEL_71;
      }
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_71;
      }
    }
  }
  while (2)
  {
    unint64_t v22 = v21[1];
    if (v22 != 0x1AF456233693CD46)
    {
      if (v22 >= a3) {
        v22 %= a3;
      }
      if (v22 != v19) {
        goto LABEL_71;
      }
      goto LABEL_58;
    }
    if (v21[2] != 0x1AF456233693CD46)
    {
LABEL_58:
      uint64_t v21 = (void *)*v21;
      if (!v21) {
        goto LABEL_71;
      }
      continue;
    }
    break;
  }
LABEL_69:
  uint64_t v24 = v21[5];
  if (*(void *)(v24 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v5 = *(void *)(v24 + 32);
    goto LABEL_72;
  }
LABEL_71:
  uint64_t v5 = 0;
LABEL_72:
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v25 = 0x99BED48DEFBBD82BLL;
    if (a3 <= 0x99BED48DEFBBD82BLL) {
      unint64_t v25 = 0x99BED48DEFBBD82BLL % a3;
    }
  }
  else
  {
    unint64_t v25 = (a3 - 1) & 0x99BED48DEFBBD82BLL;
  }
  uint64_t v26 = *(void **)(a2 + 8 * v25);
  if (!v26) {
    goto LABEL_94;
  }
  uint64_t v27 = (void *)*v26;
  if (!v27) {
    goto LABEL_94;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v29 = v27[1];
      if (v29 == 0x99BED48DEFBBD82BLL)
      {
        if (v27[2] == 0x99BED48DEFBBD82BLL) {
          goto LABEL_92;
        }
      }
      else if ((v29 & (a3 - 1)) != v25)
      {
        goto LABEL_94;
      }
      uint64_t v27 = (void *)*v27;
      if (!v27) {
        goto LABEL_94;
      }
    }
  }
  while (1)
  {
    unint64_t v28 = v27[1];
    if (v28 == 0x99BED48DEFBBD82BLL) {
      break;
    }
    if (v28 >= a3) {
      v28 %= a3;
    }
    if (v28 != v25) {
      goto LABEL_94;
    }
LABEL_81:
    uint64_t v27 = (void *)*v27;
    if (!v27) {
      goto LABEL_94;
    }
  }
  if (v27[2] != 0x99BED48DEFBBD82BLL) {
    goto LABEL_81;
  }
LABEL_92:
  uint64_t v30 = v27[5];
  if (*(void *)(v30 + 8) != 0x99BED48DEFBBD82BLL)
  {
LABEL_94:
    uint64_t v31 = 0;
    goto LABEL_95;
  }
  uint64_t v31 = *(void *)(v30 + 32);
LABEL_95:
  unint64_t *result = v6;
  result[1] = v7;
  result[2] = v5;
  result[3] = v31;
  return result;
}

uint64_t md::LogicDependencies<gdc::TypeList<md::NavigationContext,md::ElevationContext,md::CameraContext,md::SceneContext>,gdc::TypeList<md::PuckContext,md::RouteOverlayContext>>::buildOptionalTuple<md::PuckContext,md::RouteOverlayContext>(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0x9AEE7E062376E454;
    if (a2 <= 0x9AEE7E062376E454) {
      unint64_t v3 = 0x9AEE7E062376E454 % a2;
    }
  }
  else
  {
    unint64_t v3 = (a2 - 1) & 0x9AEE7E062376E454;
  }
  uint64_t v5 = *(void **)(a1 + 8 * v3);
  if (!v5) {
    goto LABEL_25;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    goto LABEL_25;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v8 = v6[1];
      if (v8 == 0x9AEE7E062376E454)
      {
        if (v6[2] == 0x9AEE7E062376E454) {
          goto LABEL_23;
        }
      }
      else if ((v8 & (a2 - 1)) != v3)
      {
        goto LABEL_25;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v6[1];
    if (v7 == 0x9AEE7E062376E454) {
      break;
    }
    if (v7 >= a2) {
      v7 %= a2;
    }
    if (v7 != v3) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_25;
    }
  }
  if (v6[2] != 0x9AEE7E062376E454) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v9 = v6[5];
  if (*(void *)(v9 + 8) == 0x9AEE7E062376E454)
  {
    uint64_t v10 = *(void *)(v9 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v10 = 0;
LABEL_26:
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v11 = 0x13043386C0978CC2;
    if (a2 <= 0x13043386C0978CC2) {
      uint64_t v11 = 0x13043386C0978CC2 % a2;
    }
  }
  else
  {
    uint64_t v11 = (a2 - 1) & 0x13043386C0978CC2;
  }
  uint64_t v12 = *(void **)(a1 + 8 * v11);
  if (!v12) {
    return v10;
  }
  unint64_t v13 = (void *)*v12;
  if (!v13) {
    return v10;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v15 = v13[1];
      if (v15 == 0x13043386C0978CC2)
      {
        if (v13[2] == 0x13043386C0978CC2) {
          goto LABEL_46;
        }
      }
      else if ((v15 & (a2 - 1)) != v11)
      {
        return v10;
      }
      unint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
    }
  }
  while (2)
  {
    unint64_t v14 = v13[1];
    if (v14 != 0x13043386C0978CC2)
    {
      if (v14 >= a2) {
        v14 %= a2;
      }
      if (v14 != v11) {
        return v10;
      }
      goto LABEL_35;
    }
    if (v13[2] != 0x13043386C0978CC2)
    {
LABEL_35:
      unint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
      continue;
    }
    break;
  }
LABEL_46:
  if (*(void *)(v13[5] + 8) == 0x13043386C0978CC2) {
    return v10;
  }
  return v10;
}

void md::RouteLineLogic::runBeforeLayout(uint64_t a1, id *a2, uint64_t a3, float *a4)
{
  uint64_t v6 = *(unsigned char **)a3;
  unint64_t v7 = *(uint64_t **)(a3 + 24);
  if (!*(void *)(*(void *)a3 + 40)) {
    goto LABEL_30;
  }
  uint64_t v9 = *(void *)(a3 + 16);
  unsigned int v10 = *(unsigned __int8 *)(v9 + 3776) - 1;
  BOOL v11 = v10 >= 3 && **(unsigned char **)(a3 + 8) == 0;
  if (!v11)
  {
    uint64_t v12 = *(double **)(a3 + 32);
    double v13 = *(double *)(v9 + 16);
    double v14 = *(double *)(v9 + 24);
    long double v15 = tan(*(double *)(v9 + 8) * 0.5 + 0.785398163);
    double v16 = v13 * 0.159154943 + 0.5;
    double v17 = log(v15) * 0.159154943 + 0.5;
    long double v18 = exp(v17 * 6.28318531 + -3.14159265);
    double v19 = atan(v18) * 2.0 + -1.57079633;
    long double v20 = fmod(v16 * 6.28318531, 6.28318531);
    double v21 = fmod(v20 + 6.28318531, 6.28318531) + -3.14159265;
    __double2 v22 = __sincos_stret(v19);
    __double2 v23 = __sincos_stret(v21);
    if (v12
      && (v10 >= 3 ? (uint64_t v24 = v12 + 1) : (uint64_t v24 = v12 + 4),
          geo::Intersect::encloses<double>((double *)(v9 + 984), v24) && v6[168]))
    {
      if (*v6)
      {
        double v25 = *(double *)(v9 + 496);
        double v26 = *(double *)(v9 + 504);
        double v27 = *(double *)(v9 + 512);
        if (v10 > 2) {
          double v28 = sqrt((v25 - v12[1]) * (v25 - v12[1]) + (v26 - v12[2]) * (v26 - v12[2]) + (v27 - v12[3]) * (v27 - v12[3]));
        }
        else {
          double v28 = sqrt((v25 - v12[4]) * (v25 - v12[4]) + (v26 - v12[5]) * (v26 - v12[5]) + (v27 - v12[6]) * (v27 - v12[6]))
        }
              * 0.0000000249532021;
        goto LABEL_23;
      }
      double v29 = 1.0;
    }
    else
    {
      double v29 = 1.0;
      if (*v6 && *(unsigned char *)(a1 + 216)) {
        double v29 = *(double *)(a1 + 208);
      }
    }
    double v31 = *(double *)(v9 + 496);
    double v30 = *(double *)(v9 + 504);
    double v32 = *(double *)(v9 + 512);
    if (v10 > 2)
    {
      double v28 = sqrt((v31 - v16) * (v31 - v16)+ (v30 - v17) * (v30 - v17)+ (v32 + v14 * -0.0000000249532021) * (v32 + v14 * -0.0000000249532021))* v29;
    }
    else
    {
      double v33 = 6378137.0 / sqrt(v22.__sinval * v22.__sinval * -0.00669437999 + 1.0);
      double v28 = v29
          * 0.0000000249532021
          * sqrt((v31 - (v33 + v14) * v22.__cosval * v23.__cosval) * (v31 - (v33 + v14) * v22.__cosval * v23.__cosval)+ (v30 - (v33 + v14) * v22.__cosval * v23.__sinval) * (v30 - (v33 + v14) * v22.__cosval * v23.__sinval)+ (v32 - (v14 + v33 * 0.99330562) * v22.__sinval) * (v32 - (v14 + v33 * 0.99330562) * v22.__sinval));
    }
    goto LABEL_23;
  }
  double v28 = -*(double *)(v9 + 512) / fmin(*(double *)(v9 + 3104), -0.000001);
LABEL_23:
  double v35 = *(double *)(v9 + 368);
  double v34 = *(double *)(v9 + 376);
  if (v34 >= v35)
  {
    double v41 = *(double *)(v9 + 456);
  }
  else
  {
    double v36 = v34 * v35;
    double v37 = v34 / v35;
    if (v36 <= 0.0) {
      double v38 = 1.0;
    }
    else {
      double v38 = v37;
    }
    long double v39 = tan(*(double *)(v9 + 456) * 0.5);
    long double v40 = atan(v38 * v39);
    double v41 = v40 + v40;
  }
  [*a2 size];
  float v43 = v41 / v42;
  float v44 = v28 * v43;
  a4[19] = v44;
LABEL_30:
  *((unsigned char *)a4 + 72) = 0;
  uint64_t v45 = *v7;
  uint64_t v46 = *(_WORD **)(v45 + 48);
  uint64_t v47 = *(_WORD **)(v45 + 56);
  if (v46 != v47)
  {
    while (*v46 != 77)
    {
      v46 += 16;
      if (v46 == v47) {
        goto LABEL_41;
      }
    }
  }
  if (v46 == v47)
  {
LABEL_41:
    uint64_t v52 = *(void *)a4;
    if (*(void *)a4 != *(void *)(a1 + 136))
    {
      gdc::ServiceLocator::associate<md::RouteElevationSource,md::StandardRouteElevationSource>(*(void **)(a1 + 120));
      if (*(void *)(a1 + 168))
      {
        uint64_t v53 = *(void **)(a1 + 160);
        while (v53)
        {
          uint64_t v54 = v53;
          uint64_t v53 = (void *)*v53;
          os_signpost_id_t v55 = (std::__shared_weak_count *)v54[6];
          if (v55 && !atomic_fetch_add(&v55->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
            std::__shared_weak_count::__release_weak(v55);
          }
          operator delete(v54);
        }
        *(void *)(a1 + 160) = 0;
        uint64_t v56 = *(void *)(a1 + 152);
        if (v56)
        {
          for (uint64_t i = 0; i != v56; ++i)
            *(void *)(*(void *)(a1 + 144) + 8 * i) = 0;
        }
        *(void *)(a1 + 168) = 0;
      }
      uint64_t v59 = *(void **)(a1 + 192);
      uint64_t v58 = (void *)(a1 + 192);
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v59);
      *(v58 - 1) = v58;
      void *v58 = 0;
      v58[1] = 0;
      uint64_t v52 = *(v58 - 7);
    }
    *(void *)a4 = v52;
    return;
  }
  *(_OWORD *)unint64_t v155 = 0u;
  *(_OWORD *)uint64_t v156 = 0u;
  int v157 = 1065353216;
  __p = 0;
  v153 = 0;
  uint64_t v154 = 0;
  {
    qword_1EB3176C0 = 0;
    qword_1EB3176B8 = 0;
    md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
    __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
  }
  uint64_t v48 = *(_WORD **)(v45 + 48);
  uint64_t v49 = *(_WORD **)(v45 + 56);
  v150 = a4;
  uint64_t v50 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
  if (v48 != v49)
  {
    unint64_t v51 = v48;
    while (*v51 != 77)
    {
      v51 += 16;
      if (v51 == v49) {
        goto LABEL_61;
      }
    }
    if (v51 == v49)
    {
      uint64_t v50 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    }
    else
    {
      while (*v48 != 77)
      {
        v48 += 16;
        if (v48 == v49)
        {
          uint64_t v48 = v49;
          break;
        }
      }
      uint64_t v50 = (uint64_t *)(v48 + 4);
    }
  }
LABEL_61:
  float v62 = (uint64_t *)*v50;
  uint64_t v60 = v50 + 1;
  uint64_t v61 = v62;
  if (v62 != v60)
  {
    do
    {
      uint64_t v63 = v61[4];
      uint64_t v64 = v61[5];
      *(void *)&long long v158 = v63;
      *((void *)&v158 + 1) = v64;
      if (v64) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v64 + 8), 1uLL, memory_order_relaxed);
      }
      std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__emplace_unique_key_args<geo::QuadTile,geo::QuadTile const&>((uint64_t)v155, (unsigned __int8 *)(v63 + 168), v63 + 168);
      uint64_t v65 = v153;
      if (v153 >= v154)
      {
        uint64_t v67 = __p;
        uint64_t v68 = (v153 - __p) >> 4;
        unint64_t v69 = v68 + 1;
        if ((unint64_t)(v68 + 1) >> 60) {
          abort();
        }
        uint64_t v70 = v154 - __p;
        if ((v154 - __p) >> 3 > v69) {
          unint64_t v69 = v70 >> 3;
        }
        if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v71 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v71 = v69;
        }
        if (v71 >> 60) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v72 = (char *)operator new(16 * v71);
        unint64_t v73 = &v72[16 * v68];
        uint64_t v74 = *((void *)&v158 + 1);
        *(_OWORD *)unint64_t v73 = v158;
        if (v74)
        {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v74 + 8), 1uLL, memory_order_relaxed);
          uint64_t v65 = v153;
        }
        uint64_t v66 = v73 + 16;
        if (v65 == __p)
        {
          __p = v73;
          uint64_t v154 = &v72[16 * v71];
        }
        else
        {
          uint64_t v75 = v65;
          do
          {
            long long v76 = *((_OWORD *)v75 - 1);
            v75 -= 16;
            *((_OWORD *)v73 - 1) = v76;
            v73 -= 16;
            *(void *)uint64_t v75 = 0;
            *((void *)v75 + 1) = 0;
          }
          while (v75 != __p);
          __p = v73;
          uint64_t v154 = &v72[16 * v71];
          do
          {
            uint64_t v77 = (std::__shared_weak_count *)*((void *)v65 - 1);
            if (v77 && !atomic_fetch_add(&v77->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v77->__on_zero_shared)(v77);
              std::__shared_weak_count::__release_weak(v77);
            }
            v65 -= 16;
          }
          while (v65 != v67);
        }
        if (v67) {
          operator delete(v67);
        }
      }
      else
      {
        *(void *)v153 = v158;
        *((void *)v153 + 1) = v64;
        if (v64) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v64 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v66 = v153 + 16;
      }
      v153 = v66;
      uint64_t v78 = (std::__shared_weak_count *)*((void *)&v158 + 1);
      if (*((void *)&v158 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v158 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v78->__on_zero_shared)(v78);
        std::__shared_weak_count::__release_weak(v78);
        uint64_t v79 = (uint64_t *)v61[1];
        if (!v79)
        {
          do
          {
LABEL_96:
            uint64_t v80 = (uint64_t *)v61[2];
            BOOL v11 = *v80 == (void)v61;
            uint64_t v61 = v80;
          }
          while (!v11);
          goto LABEL_63;
        }
      }
      else
      {
        uint64_t v79 = (uint64_t *)v61[1];
        if (!v79) {
          goto LABEL_96;
        }
      }
      do
      {
        uint64_t v80 = v79;
        uint64_t v79 = (uint64_t *)*v79;
      }
      while (v79);
LABEL_63:
      uint64_t v61 = v80;
    }
    while (v80 != v60);
  }
  uint64_t v81 = (uint64_t)v156[0];
  uint64_t v82 = *(void *)(a1 + 160);
  v151 = (uint64_t *)(a1 + 160);
  if (v156[0]) {
    BOOL v83 = v82 == 0;
  }
  else {
    BOOL v83 = 1;
  }
  if (!v83)
  {
    while (1)
    {
      int v87 = *(unsigned __int8 *)(v81 + 17);
      int v88 = *(_DWORD *)(v81 + 20);
      int v89 = *(_DWORD *)(v81 + 24);
      int v90 = *(unsigned __int8 *)(v81 + 16);
      int v91 = *(unsigned __int8 *)(v82 + 17);
      int v92 = *(_DWORD *)(v82 + 20);
      int v93 = *(_DWORD *)(v82 + 24);
      int v94 = *(unsigned __int8 *)(v82 + 16);
      uint64_t v95 = *(std::__shared_weak_count **)(v82 + 48);
      if (v95) {
        atomic_fetch_add_explicit(&v95->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      BOOL v99 = v90 == v94 && v87 == v91 && v88 == v92 && v89 == v93;
      if (v95 && !atomic_fetch_add(&v95->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v95->__on_zero_shared)(v95);
        std::__shared_weak_count::__release_weak(v95);
      }
      if (!v99) {
        break;
      }
      uint64_t v81 = *(void *)v81;
      uint64_t v82 = *(void *)v82;
      if (!v81 || !v82) {
        goto LABEL_104;
      }
    }
LABEL_105:
    *((unsigned char *)a4 + 72) = 1;
    uint64_t v84 = (uint64_t *)(a1 + 144);
    if (*(void *)(a1 + 168))
    {
      uint64_t v81 = *v151;
      while (v81)
      {
        uint64_t v85 = (void *)v81;
        uint64_t v81 = *(void *)v81;
        uint64_t v86 = (std::__shared_weak_count *)v85[6];
        if (v86 && !atomic_fetch_add(&v86->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
          std::__shared_weak_count::__release_weak(v86);
        }
        operator delete(v85);
      }
      *(void *)(a1 + 160) = 0;
      uint64_t v100 = *(void *)(a1 + 152);
      if (v100)
      {
        for (uint64_t j = 0; j != v100; ++j)
          *(void *)(*v84 + 8 * j) = 0;
      }
      *(void *)(a1 + 168) = 0;
    }
    unint64_t v102 = (uint64_t *)(a1 + 192);
    std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(a1 + 192));
    *(void *)(a1 + 184) = a1 + 192;
    *(void *)(a1 + 192) = 0;
    *(void *)(a1 + 200) = 0;
    uint64_t v103 = __p;
    if (__p != v153)
    {
      while (1)
      {
        uint64_t v104 = *(void *)v103;
        uint64_t v105 = *(unsigned __int8 *)(*(void *)v103 + 168);
        uint64_t v106 = *(unsigned __int8 *)(*(void *)v103 + 169);
        unint64_t v107 = (v106
              - 0x61C8864680B583EBLL
              + ((v105 - 0x61C8864680B583EBLL) << 6)
              + ((unint64_t)(v105 - 0x61C8864680B583EBLL) >> 2)) ^ (v105 - 0x61C8864680B583EBLL);
        uint64_t v108 = *(int *)(*(void *)v103 + 172);
        uint64_t v109 = *(int *)(*(void *)v103 + 176);
        unint64_t v110 = (v108 - 0x61C8864680B583EBLL + (v107 << 6) + (v107 >> 2)) ^ v107;
        unint64_t v111 = (v109 - 0x61C8864680B583EBLL + (v110 << 6) + (v110 >> 2)) ^ v110;
        unint64_t v112 = *(void *)(a1 + 152);
        if (v112)
        {
          uint8x8_t v113 = (uint8x8_t)vcnt_s8((int8x8_t)v112);
          v113.i16[0] = vaddlv_u8(v113);
          if (v113.u32[0] > 1uLL)
          {
            uint64_t v81 = (v109 - 0x61C8864680B583EBLL + (v110 << 6) + (v110 >> 2)) ^ v110;
            if (v111 >= v112) {
              uint64_t v81 = v111 % v112;
            }
          }
          else
          {
            uint64_t v81 = v111 & (v112 - 1);
          }
          uint64_t v114 = *(uint64_t ***)(*v84 + 8 * v81);
          if (v114)
          {
            uint64_t v115 = *v114;
            if (v115)
            {
              if (v113.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v117 = v115[1];
                  if (v117 == v111)
                  {
                    if (__PAIR64__(*((unsigned __int8 *)v115 + 17), *((unsigned __int8 *)v115 + 16)) == __PAIR64__(v106, v105)
                      && *(uint64_t *)((char *)v115 + 20) == __PAIR64__(v109, v108))
                    {
                      goto LABEL_204;
                    }
                  }
                  else if ((v117 & (v112 - 1)) != v81)
                  {
                    goto LABEL_164;
                  }
                  uint64_t v115 = (uint64_t *)*v115;
                  if (!v115) {
                    goto LABEL_164;
                  }
                }
              }
              do
              {
                unint64_t v116 = v115[1];
                if (v116 == v111)
                {
                  if (__PAIR64__(*((unsigned __int8 *)v115 + 17), *((unsigned __int8 *)v115 + 16)) == __PAIR64__(v106, v105)
                    && *(uint64_t *)((char *)v115 + 20) == __PAIR64__(v109, v108))
                  {
                    goto LABEL_204;
                  }
                }
                else
                {
                  if (v116 >= v112) {
                    v116 %= v112;
                  }
                  if (v116 != v81) {
                    break;
                  }
                }
                uint64_t v115 = (uint64_t *)*v115;
              }
              while (v115);
            }
          }
        }
LABEL_164:
        uint64_t v118 = operator new(0x38uLL);
        *(void *)&long long v158 = v118;
        *((void *)&v158 + 1) = a1 + 160;
        void *v118 = 0;
        v118[1] = v111;
        *((_WORD *)v118 + 8) = *(_WORD *)(v104 + 168);
        *(void *)((char *)v118 + 20) = *(void *)(v104 + 172);
        v118[5] = *(void *)v103;
        uint64_t v119 = *((void *)v103 + 1);
        v118[6] = v119;
        if (v119) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v119 + 8), 1uLL, memory_order_relaxed);
        }
        LOBYTE(v159) = 1;
        float v120 = (float)(unint64_t)(*(void *)(a1 + 168) + 1);
        float v121 = *(float *)(a1 + 176);
        if (!v112 || (float)(v121 * (float)v112) < v120)
        {
          BOOL v122 = (v112 & (v112 - 1)) != 0;
          if (v112 < 3) {
            BOOL v122 = 1;
          }
          unint64_t v123 = v122 | (2 * v112);
          unint64_t v124 = vcvtps_u32_f32(v120 / v121);
          if (v123 <= v124) {
            size_t prime = v124;
          }
          else {
            size_t prime = v123;
          }
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
          }
          int8x8_t v126 = *(int8x8_t *)(a1 + 152);
          if (prime > *(void *)&v126) {
            goto LABEL_178;
          }
          if (prime < *(void *)&v126)
          {
            unint64_t v127 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 168) / *(float *)(a1 + 176));
            if (*(void *)&v126 < 3uLL
              || (uint8x8_t v128 = (uint8x8_t)vcnt_s8(v126), v128.i16[0] = vaddlv_u8(v128), v128.u32[0] > 1uLL))
            {
              unint64_t v127 = std::__next_prime(v127);
            }
            else
            {
              uint64_t v129 = 1 << -(char)__clz(v127 - 1);
              if (v127 >= 2) {
                unint64_t v127 = v129;
              }
            }
            if (prime <= v127) {
              size_t prime = v127;
            }
            if (prime < *(void *)&v126) {
LABEL_178:
            }
              std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1 + 144, prime);
          }
          unint64_t v112 = *(void *)(a1 + 152);
          if ((v112 & (v112 - 1)) != 0)
          {
            if (v111 >= v112) {
              uint64_t v81 = v111 % v112;
            }
            else {
              uint64_t v81 = v111;
            }
          }
          else
          {
            uint64_t v81 = (v112 - 1) & v111;
          }
        }
        uint64_t v130 = *v84;
        uint64_t v131 = *(void **)(*v84 + 8 * v81);
        if (v131)
        {
          void *v118 = *v131;
        }
        else
        {
          void *v118 = *v151;
          uint64_t *v151 = (uint64_t)v118;
          *(void *)(v130 + 8 * v81) = v151;
          if (!*v118) {
            goto LABEL_203;
          }
          unint64_t v132 = *(void *)(*v118 + 8);
          if ((v112 & (v112 - 1)) != 0)
          {
            if (v132 >= v112) {
              v132 %= v112;
            }
          }
          else
          {
            v132 &= v112 - 1;
          }
          uint64_t v131 = (void *)(*v84 + 8 * v132);
        }
        *uint64_t v131 = v118;
LABEL_203:
        ++*(void *)(a1 + 168);
        LODWORD(v106) = *(unsigned __int8 *)(*(void *)v103 + 169);
LABEL_204:
        uint64_t v133 = *v102;
        uint64_t v134 = (void *)(a1 + 192);
        uint64_t v81 = a1 + 192;
        if (*v102)
        {
          while (1)
          {
            while (1)
            {
              uint64_t v81 = v133;
              unsigned int v135 = *(unsigned __int8 *)(v133 + 25);
              if (v106 <= v135) {
                break;
              }
              uint64_t v133 = *(void *)v81;
              uint64_t v134 = (void *)v81;
              if (!*(void *)v81) {
                goto LABEL_211;
              }
            }
            if (v135 <= v106) {
              break;
            }
            uint64_t v133 = *(void *)(v81 + 8);
            if (!v133)
            {
              uint64_t v134 = (void *)(v81 + 8);
              goto LABEL_211;
            }
          }
        }
        else
        {
LABEL_211:
          uint64_t v136 = operator new(0x20uLL);
          v136[25] = v106;
          *(void *)uint64_t v136 = 0;
          *((void *)v136 + 1) = 0;
          *((void *)v136 + 2) = v81;
          *uint64_t v134 = v136;
          uint64_t v137 = **(void **)(a1 + 184);
          if (v137)
          {
            *(void *)(a1 + 184) = v137;
            uint64_t v136 = (unsigned char *)*v134;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 192), (uint64_t *)v136);
          ++*(void *)(a1 + 200);
        }
        v103 += 16;
        if (v103 == v153) {
          goto LABEL_213;
        }
      }
    }
    goto LABEL_213;
  }
LABEL_104:
  if (v81 | v82) {
    goto LABEL_105;
  }
LABEL_213:
  uint64_t v138 = *(void *)(a1 + 128);
  if (*(void *)v150 == v138)
  {
    uint64_t v138 = *(void *)v150;
  }
  else
  {
    unint64_t v139 = *(void **)(a1 + 120);
    uint64_t v140 = (void *)*v139;
    uint64_t v141 = (void *)v139[1];
    if ((void *)*v139 != v141)
    {
      while (*v140 != 0xD91D59D9773C991ALL)
      {
        v140 += 5;
        if (v140 == v141) {
          goto LABEL_226;
        }
      }
    }
    if (v140 != v141)
    {
      *(void *)&long long v158 = 0xAB4154EC82453679;
      *((void *)&v158 + 1) = "md::RouteElevationSource]";
      uint64_t v142 = v140[3];
      uint64_t v143 = (std::__shared_weak_count *)v140[4];
      uint64_t v159 = 24;
      uint64_t v160 = v142;
      uint64_t v161 = v143;
      if (v143) {
        atomic_fetch_add_explicit(&v143->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      geo::linear_map<gdc::TypeInfo,std::shared_ptr<void>,std::equal_to<gdc::TypeInfo>,std::allocator<std::pair<gdc::TypeInfo,std::shared_ptr<void>>>,std::vector<std::pair<gdc::TypeInfo,std::shared_ptr<void>>>>::insert_or_assign((uint64_t)v139, &v158);
      if (v143 && !atomic_fetch_add(&v143->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v143->__on_zero_shared)(v143);
        std::__shared_weak_count::__release_weak(v143);
      }
      uint64_t v138 = *(void *)(a1 + 128);
    }
  }
LABEL_226:
  *(void *)v150 = v138;
  if (v150 + 2 != (float *)(a1 + 144))
  {
    v150[10] = *(float *)(a1 + 176);
    std::__hash_table<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,std::allocator<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<std::__hash_value_type<geo::QuadTile,std::shared_ptr<md::FlyoverDsmTileData>>,void *> *>>((void *)v150 + 1, *(uint64_t **)(a1 + 160));
    std::__tree<unsigned char,std::greater<unsigned char>,std::allocator<unsigned char>>::__assign_multi<std::__tree_const_iterator<unsigned char,std::__tree_node<unsigned char,void *> *,long>>((uint64_t **)v150 + 6, *(void **)(a1 + 184), (void *)(a1 + 192));
  }
  uint64_t v144 = __p;
  if (__p)
  {
    uint64_t v145 = v153;
    if (v153 != __p)
    {
      do
      {
        uint64_t v146 = (std::__shared_weak_count *)*((void *)v145 - 1);
        if (v146 && !atomic_fetch_add(&v146->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v146->__on_zero_shared)(v146);
          std::__shared_weak_count::__release_weak(v146);
        }
        v145 -= 16;
      }
      while (v145 != __p);
      uint64_t v144 = __p;
    }
    operator delete(v144);
  }
  uint64_t v147 = v156[0];
  if (v156[0])
  {
    do
    {
      uint64_t v148 = (void *)*v147;
      operator delete(v147);
      uint64_t v147 = v148;
    }
    while (v148);
  }
  uint64_t v149 = v155[0];
  v155[0] = 0;
  if (v149) {
    operator delete(v149);
  }
}

void sub_1A1A74CE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v9 = va_arg(va2, void);
  uint64_t v11 = va_arg(va2, void);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v13 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  geo::MarkedLRUCache<md::GeometryContext::SplineKey,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,md::GeometryContext::SplineKeyHash,std::equal_to<md::GeometryContext::SplineKey>>::CacheEntry::~CacheEntry((uint64_t)va2);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)va);
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100]((uint64_t)va1);
  _Unwind_Resume(a1);
}

void gdc::ServiceLocator::associate<md::RouteElevationSource,md::StandardRouteElevationSource>(void *a1)
{
  uint64_t v1 = (void *)*a1;
  uint8x8_t v2 = (void *)a1[1];
  if ((void *)*a1 != v2)
  {
    while (*v1 != 0xA89E774940B82160)
    {
      v1 += 5;
      if (v1 == v2) {
        return;
      }
    }
  }
  if (v1 != v2)
  {
    v5[0] = 0xAB4154EC82453679;
    v5[1] = "md::RouteElevationSource]";
    uint64_t v3 = v1[3];
    uint64_t v4 = (std::__shared_weak_count *)v1[4];
    v5[2] = 24;
    void v5[3] = v3;
    v5[4] = v4;
    if (v4) {
      atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    geo::linear_map<gdc::TypeInfo,std::shared_ptr<void>,std::equal_to<gdc::TypeInfo>,std::allocator<std::pair<gdc::TypeInfo,std::shared_ptr<void>>>,std::vector<std::pair<gdc::TypeInfo,std::shared_ptr<void>>>>::insert_or_assign((uint64_t)a1, v5);
    if (v4)
    {
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void sub_1A1A74E20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  geo::MarkedLRUCache<md::GeometryContext::SplineKey,std::shared_ptr<ggl::ConstantDataTyped<ggl::Tile::Transform>>,md::GeometryContext::SplineKeyHash,std::equal_to<md::GeometryContext::SplineKey>>::CacheEntry::~CacheEntry((uint64_t)va);
  _Unwind_Resume(a1);
}

void geo::linear_map<gdc::TypeInfo,std::shared_ptr<void>,std::equal_to<gdc::TypeInfo>,std::allocator<std::pair<gdc::TypeInfo,std::shared_ptr<void>>>,std::vector<std::pair<gdc::TypeInfo,std::shared_ptr<void>>>>::insert_or_assign(uint64_t a1, void *a2)
{
  uint64_t v3 = *(char **)a1;
  unint64_t v2 = *(void *)(a1 + 8);
  if (*(void *)a1 != v2)
  {
    while (*a2 != *(void *)v3)
    {
      v3 += 40;
      if (v3 == (char *)v2) {
        goto LABEL_13;
      }
    }
  }
  if (v3 == (char *)v2)
  {
LABEL_13:
    if (v2 >= *(void *)(a1 + 16))
    {
      *(void *)(a1 + 8) = std::vector<std::pair<gdc::TypeInfo,std::shared_ptr<void>>>::__push_back_slow_path<std::pair<gdc::TypeInfo,std::shared_ptr<void>> const&>((char **)a1, (uint64_t)a2);
    }
    else
    {
      long long v8 = *(_OWORD *)a2;
      *(void *)(v2 + 16) = a2[2];
      *(_OWORD *)unint64_t v2 = v8;
      uint64_t v9 = a2[4];
      *(void *)(v2 + 24) = a2[3];
      *(void *)(v2 + 32) = v9;
      if (v9) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v9 + 8), 1uLL, memory_order_relaxed);
      }
      *(void *)(a1 + 8) = v2 + 40;
    }
  }
  else
  {
    long long v4 = *(_OWORD *)a2;
    *((void *)v3 + 2) = a2[2];
    *(_OWORD *)uint64_t v3 = v4;
    uint64_t v6 = a2[3];
    uint64_t v5 = a2[4];
    if (v5) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v5 + 8), 1uLL, memory_order_relaxed);
    }
    uint64_t v7 = (std::__shared_weak_count *)*((void *)v3 + 4);
    *((void *)v3 + 3) = v6;
    *((void *)v3 + 4) = v5;
    if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
}

void md::DaVinciHikingRenderLayer::DaVinciHikingRenderLayer(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  if (a2 == 37)
  {
    if (GEOConfigGetBOOL()) {
      GEOConfigGetDouble();
    }
    if (GEOConfigGetBOOL()) {
      GEOConfigGetDouble();
    }
  }
  md::DaVinciCenterLineRoadsRenderLayer::DaVinciCenterLineRoadsRenderLayer(a1, a2, a3, v7);
}

void sub_1A1A75138(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v3, 0x1020C40455D1DCFLL);
  uint64_t v5 = (uint64_t *)*((void *)v2 + 54);
  *((void *)v2 + 54) = 0;
  if (v5)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy((void *)v5[15]);
    uint64_t v6 = (std::__shared_weak_count *)v5[2];
    if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
    uint64_t v7 = *v5;
    uint64_t *v5 = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
    MEMORY[0x1A6239270](v5, 0x1020C40455D1DCFLL);
  }
  md::DaVinciCenterLineRoadsRenderLayer::~DaVinciCenterLineRoadsRenderLayer(v2);

  _Unwind_Resume(a1);
}

void md::DaVinciCenterLineRoadsRenderLayer::DaVinciCenterLineRoadsRenderLayer(uint64_t a1, int a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  __int16 v8 = a201[(a2 - 33)];
  [*(id *)(a3 + 104) format];
  if (v7)
  {
    [v7 standardCommandBufferSelector];
    uint64_t v9 = v18;
  }
  else
  {
    uint64_t v9 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
  }
  commandBufferLocationsForRenderLayerType(&v16, a2, v9);
  v7;
  unsigned int v10 = operator new(2uLL);
  _WORD *v10 = v8;
  *(void *)a1 = &unk_1EF530C60;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  uint64_t v11 = v16;
  int64_t v12 = v17 - v16;
  if (v17 != v16)
  {
    if (v12 < 0) {
      abort();
    }
    uint64_t v13 = (char *)operator new(v17 - v16);
    *(void *)(a1 + 8) = v13;
    *(void *)(a1 + 16) = v13;
    uint64_t v14 = &v13[2 * (v12 >> 1)];
    *(void *)(a1 + 24) = v14;
    memcpy(v13, v11, v12);
    *(void *)(a1 + 16) = v14;
  }
  *(void *)&long long v15 = v10;
  *((void *)&v15 + 1) = v10 + 1;
  *(_WORD *)(a1 + 32) = 0;
  *(unsigned char *)(a1 + 34) = a2;
  *(void *)(a1 + 40) = a3;
  *(_WORD *)(a1 + 48) = 0;
  *(_DWORD *)(a1 + 52) = 1;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(void *)(a1 + 112) = 0;
  *(_DWORD *)(a1 + 120) = 1065353216;
  *(void *)(a1 + 136) = 0;
  *(void *)(a1 + 160) = 0;
  *(void *)(a1 + 128) = a1 + 136;
  *(void *)(a1 + 144) = 0;
  *(void *)(a1 + 152) = a1 + 160;
  *(void *)(a1 + 184) = 0;
  *(void *)(a1 + 168) = 0;
  *(void *)(a1 + 176) = a1 + 184;
  *(void *)(a1 + 216) = 0;
  *(void *)(a1 + 208) = 0;
  *(void *)(a1 + 192) = 0;
  *(void *)(a1 + 200) = a1 + 208;
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 232) = 0;
  *(void *)(a1 + 224) = a1 + 232;
  *(_OWORD *)(a1 + 248) = xmmword_1A28FD220;
  *(void *)(a1 + 312) = 0;
  *(_OWORD *)(a1 + 264) = 0u;
  *(_OWORD *)(a1 + 280) = 0u;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 320) = v15;
  *(void *)(a1 + 336) = v10 + 1;
  *(_DWORD *)(a1 + 344) = 2;
  *(void *)a1 = &unk_1EF54EA28;
  *(void *)(a1 + 352) = 0;
  operator new();
}

void sub_1A1A75844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  uint64_t v14 = *v12;
  if (*v12)
  {
    *(void *)(v10 + 416) = v14;
    operator delete(v14);
  }
  std::unique_ptr<md::RoadStyling>::~unique_ptr[abi:nn180100]((void ***)(v10 + 400));
  md::DaVinciCenterLineRoadsRenderResources::~DaVinciCenterLineRoadsRenderResources(v11);
  md::CartographicTiledVectorRenderLayer<md::DaVinciRoadTileDataRenderable>::~CartographicTiledVectorRenderLayer((void *)v10);

  _Unwind_Resume(a1);
}

void md::CartographicTiledRenderResources::CartographicTiledRenderResources(md::CartographicTiledRenderResources *this, VKSharedResources *a2, const RenderTargetFormat *a3)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  long long v4 = a2;
  *((void *)this + 16) = 0;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 32;
  uint64_t v5 = malloc_type_malloc(0xF10uLL, 0xB644C221uLL);
  void *v5 = 0;
  v5[1] = 0;
  *((void *)this + 16) = v5;
  *((void *)this + 17) = v5;
  operator new();
}

void sub_1A1A76728(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  std::function<void ()(ggl::PolygonSolidFill::MeshPipelineSetup *)>::~function(&a26);
  std::function<ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::~function((void *)(v31 - 136));
  MEMORY[0x1A6239270](v30, 0x10A0C40D234DDC7);
  md::RenderItemPool::~RenderItemPool(v29);
  std::unique_ptr<ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>>::~unique_ptr[abi:nn180100](v28);
  double v33 = (void *)v26[10];
  if (v33)
  {
    v26[11] = (uint64_t)v33;
    operator delete(v33);
  }
  double v34 = (void *)v26[7];
  if (v34)
  {
    v26[8] = (uint64_t)v34;
    operator delete(v34);
  }
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v26 + 5));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v26 + 3));
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)(v26 + 1));
  uint64_t v35 = *v26;
  *double v26 = 0;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }

  _Unwind_Resume(a1);
}

uint64_t md::GeometryLogic::createUnitTransformConstantData(md::GeometryLogic *this)
{
  unint64_t v2 = operator new(0xE8uLL);
  v2[1] = 0;
  v2[2] = 0;
  *unint64_t v2 = &unk_1EF586E28;
  uint64_t result = ggl::BufferData::BufferData((uint64_t)(v2 + 3), qword_1E95523C8, 2, 1, 6, 1);
  v2[28] = ggl::Tile::Transform::reflection(void)::reflection;
  v2[3] = &unk_1EF55E298;
  *(void *)this = result;
  *((void *)this + 1) = v2;
  unint64_t v4 = v2[4];
  unint64_t v6 = v2[11];
  uint64_t v5 = v2[12];
  *(_OWORD *)(v5 + 32) = xmmword_1A28FCDD0;
  *(_OWORD *)(v5 + 48) = xmmword_1A28FD2E0;
  *(_OWORD *)(v5 + 64) = xmmword_1A28FD2F0;
  *(_OWORD *)(v5 + 80) = xmmword_1A28FD290;
  *(_OWORD *)(v5 + 96) = xmmword_1A28FD300;
  *(_OWORD *)(v5 + 112) = xmmword_1A28FD310;
  *(_OWORD *)(v5 + 128) = xmmword_1A28FD320;
  *(_OWORD *)(v5 + 144) = xmmword_1A28FD330;
  *(_OWORD *)(v5 + 160) = xmmword_1A28FD340;
  *(_OWORD *)(v5 + 176) = xmmword_1A28FD350;
  *(_OWORD *)(v5 + 192) = xmmword_1A28FD360;
  *(_OWORD *)(v5 + 208) = xmmword_1A28FD370;
  *(_OWORD *)(v5 + 224) = xmmword_1A28FC6C0;
  *(_OWORD *)(v5 + 240) = xmmword_1A28FD380;
  *(_OWORD *)(v5 + 256) = xmmword_1A28FD390;
  *(_OWORD *)(v5 + 272) = xmmword_1A28FD270;
  *(_OWORD *)uint64_t v5 = xmmword_1A28FD2A0;
  *(void *)(v5 + 16) = 1065353216;
  *(_DWORD *)(v5 + 24) = 0;
  *(_DWORD *)(v5 + 348) = 1065353216;
  __asm { FMOV            V0.4S, #1.0 }
  *(void *)(v5 + 340) = _Q0;
  *(_OWORD *)(v5 + 288) = xmmword_1A28FD3A0;
  if (v6 > v4) {
    unint64_t v4 = v6;
  }
  v2[10] = 0;
  v2[11] = v4;
  return result;
}

uint64_t ggl::PolygonSolidFill::MeshPipelineState::MeshPipelineState(uint64_t a1, void *a2, uint64_t a3, _OWORD *a4, char a5)
{
  {
    uint64_t v84 = a4;
    uint64_t v86 = a2;
    uint64_t v87 = a3;
    a2 = v86;
    a3 = v87;
    a4 = v84;
    if (v85)
    {
      {
        if (v85)
        {
          {
            {
              ggl::MeshTyped<ggl::PolygonBase::DefaultVbo>::attributesReflection(void)::r = (uint64_t)&ggl::PolygonBase::defaultVboReflection;
            }
            ggl::MeshTyped<ggl::PolygonBase::DefaultVbo>::typedReflection(void)::r = (uint64_t)&ggl::MeshTyped<ggl::PolygonBase::DefaultVbo>::attributesReflection(void)::r;
            *(void *)algn_1EB32B470 = 1;
          }
          ggl::PolygonSolidFill::MeshPipelineSetup::typedReflection(void)::ref = (uint64_t)&ggl::MeshTyped<ggl::PolygonBase::DefaultVbo>::typedReflection(void)::r;
          *(void *)algn_1E9583A28 = &ggl::PolygonSolidFill::pipelineDataMeshPipelineDeviceStructs(void)::ref;
          qword_1E9583A30 = 0;
          {
            ggl::PolygonSolidFill::pipelineDataMeshPipelineConstantStructs(void)::ref = (uint64_t)ggl::Tile::View::reflection(void)::reflection;
            unk_1E9583B20 = ggl::Tile::Transform::reflection(void)::reflection;
            qword_1E9583B28 = (uint64_t)ggl::PolygonSolidFill::SolidFill::reflection(void)::reflection;
          }
          qword_1E9583A38 = (uint64_t)&ggl::PolygonSolidFill::pipelineDataMeshPipelineConstantStructs(void)::ref;
          unk_1E9583A40 = xmmword_1A28FCD30;
        }
      }
      ggl::PolygonSolidFill::MeshPipelineState::typedReflection(void)::ref = (uint64_t)&ggl::PolygonSolidFill::MeshPipelineSetup::typedReflection(void)::ref;
      ggl::PolygonSolidFillShader::typedReflection(v85);
      qword_1EB318D60 = (uint64_t)&ggl::PolygonSolidFillShader::typedReflection(void)::ref;
      {
        ggl::PolygonSolidFill::pipelineStateMeshPipelineAttributeStructBinding(void)::attr = 0;
        unk_1E9583BF0 = 0;
        qword_1E9583BF8 = (uint64_t)"";
        dword_1E9583C00 = 0;
        qword_1E9583C08 = (uint64_t)&ggl::PolygonSolidFill::pipelineStateMeshPipelineAttributeBinding_0(void)::attr;
        unk_1E9583C10 = 1;
      }
      qword_1EB318D68 = (uint64_t)&ggl::PolygonSolidFill::pipelineStateMeshPipelineAttributeStructBinding(void)::attr;
      unk_1EB318D70 = 1;
      qword_1EB318D78 = 0;
      unk_1EB318D80 = 0;
      qword_1EB318D88 = (uint64_t)&ggl::PolygonSolidFill::pipelineStateMeshPipelineDeviceStructBinding(void)::ref;
      unk_1EB318D90 = 0;
      {
        ggl::PolygonSolidFill::pipelineStateMeshPipelineConstantStructBinding(void)::ref = 0;
        unk_1E9583B60 = 0;
        qword_1E9583B68 = (uint64_t)"view";
        dword_1E9583B70 = 3;
        qword_1E9583B78 = (uint64_t)&ggl::PolygonSolidFill::pipelineStateMeshPipelineConstantViewBinding(void)::reflection;
        unk_1E9583B80 = xmmword_1A28FCEB0;
        qword_1E9583B90 = 1;
        unk_1E9583B98 = "transform";
        dword_1E9583BA0 = 3;
        qword_1E9583BA8 = (uint64_t)&ggl::PolygonSolidFill::pipelineStateMeshPipelineConstantTransformBinding(void)::reflection;
        *(_OWORD *)algn_1E9583BB0 = xmmword_1A28FCF70;
        qword_1E9583BC0 = 2;
        unk_1E9583BC8 = "solidFill";
        dword_1E9583BD0 = 3;
        qword_1E9583BD8 = (uint64_t)&ggl::PolygonSolidFill::pipelineStateMeshPipelineConstantSolidFillBinding(void)::reflection;
        unk_1E9583BE0 = 5;
      }
      qword_1EB318D98 = (uint64_t)&ggl::PolygonSolidFill::pipelineStateMeshPipelineConstantStructBinding(void)::ref;
      unk_1EB318DA0 = 3;
      a4 = v84;
      a2 = v86;
      a3 = v87;
    }
  }
  uint64_t v7 = *a2;
  __int16 v8 = (std::__shared_weak_count *)a2[1];
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(_OWORD *)int v90 = *(_OWORD *)a3;
  *(_OWORD *)&v90[12] = *(_OWORD *)(a3 + 12);
  long long v9 = *(_OWORD *)(a3 + 28);
  char v10 = *(unsigned char *)(a3 + 44);
  long long v88 = *a4;
  long long v89 = a4[1];
  *(_DWORD *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)a1 = &unk_1EF55B208;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 40) = &ggl::PolygonSolidFill::MeshPipelineState::typedReflection(void)::ref;
  *(void *)(a1 + 48) = v7;
  *(void *)(a1 + 56) = v8;
  if (v8) {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  *(unsigned char *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 116) = xmmword_1A28FC970;
  *(void *)(a1 + 132) = 0;
  *(void *)(a1 + 148) = 0;
  *(void *)(a1 + 140) = 0;
  *(unsigned char *)(a1 + 160) = 0;
  *(_OWORD *)(a1 + 164) = xmmword_1A28FC970;
  *(void *)(a1 + 180) = 0;
  *(void *)(a1 + 196) = 0;
  *(void *)(a1 + 188) = 0;
  *(unsigned char *)(a1 + 208) = 0;
  *(_OWORD *)(a1 + 212) = xmmword_1A28FC970;
  *(void *)(a1 + 228) = 0;
  *(void *)(a1 + 244) = 0;
  *(void *)(a1 + 236) = 0;
  *(_OWORD *)(a1 + 256) = v88;
  *(_OWORD *)(a1 + 272) = v89;
  *(unsigned char *)(a1 + 288) = 0;
  *(_OWORD *)(a1 + 296) = 0u;
  *(_OWORD *)(a1 + 312) = 0u;
  *(_OWORD *)(a1 + 328) = 0u;
  *(_OWORD *)(a1 + 344) = 0u;
  *(void *)(a1 + 360) = 0;
  *(void *)(a1 + 368) = 0x100000001;
  *(unsigned char *)(a1 + 376) = 0;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v90;
  *(_OWORD *)(a1 + 76) = *(_OWORD *)&v90[12];
  *(_OWORD *)(a1 + 92) = v9;
  *(unsigned char *)(a1 + 108) = v10;
  if (v8 && !atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
    std::__shared_weak_count::__release_weak(v8);
  }
  *(unsigned char *)(a1 + 305) = a5;
  int8x16_t v11 = *(int8x16_t *)(a1 + 320);
  int8x16_t v12 = vceqzq_s8(*(int8x16_t *)(a1 + 304));
  int16x8_t v13 = vmovl_high_s8(v12);
  int32x4_t v14 = vmovl_s16(*(int16x4_t *)v13.i8);
  v15.i64[0] = v14.u32[0];
  v15.i64[1] = v14.u32[1];
  int8x16_t v16 = v15;
  int16x8_t v17 = vmovl_s8(*(int8x8_t *)v12.i8);
  int32x4_t v18 = vmovl_s16(*(int16x4_t *)v17.i8);
  *(void *)a1 = &unk_1EF55D3F8;
  v15.i64[0] = v18.u32[0];
  v15.i64[1] = v18.u32[1];
  int8x16_t v19 = v15;
  int32x4_t v20 = vmovl_high_s16(v13);
  v15.i64[0] = v20.u32[0];
  v15.i64[1] = v20.u32[1];
  int8x16_t v21 = v15;
  int32x4_t v22 = vmovl_high_s16(v17);
  v15.i64[0] = v22.u32[0];
  v15.i64[1] = v22.u32[1];
  int8x16_t v23 = v15;
  v15.i64[0] = v14.u32[2];
  v15.i64[1] = v14.u32[3];
  int8x16_t v24 = v15;
  v15.i64[0] = v18.u32[2];
  v15.i64[1] = v18.u32[3];
  int8x16_t v25 = v15;
  v15.i64[0] = v20.u32[2];
  v15.i64[1] = v20.u32[3];
  int8x16_t v26 = v15;
  v15.i64[0] = v22.u32[2];
  v15.i64[1] = v22.u32[3];
  int8x16_t v27 = vbicq_s8((int8x16_t)xmmword_1A28FC980, v15);
  int8x16_t v28 = vbicq_s8((int8x16_t)xmmword_1A28FC990, v26);
  int8x16_t v29 = vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v25);
  int8x16_t v30 = vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v21);
  int8x16_t v31 = vceqzq_s8(v11);
  int16x8_t v32 = vmovl_high_s8(v31);
  int32x4_t v33 = vmovl_s16(*(int16x4_t *)v32.i8);
  v15.i64[0] = v33.u32[0];
  v15.i64[1] = v33.u32[1];
  int8x16_t v34 = v15;
  int16x8_t v35 = vmovl_s8(*(int8x8_t *)v31.i8);
  int32x4_t v36 = vmovl_s16(*(int16x4_t *)v35.i8);
  v15.i64[0] = v36.u32[0];
  v15.i64[1] = v36.u32[1];
  int8x16_t v37 = v15;
  int32x4_t v38 = vmovl_high_s16(v32);
  v15.i64[0] = v38.u32[0];
  v15.i64[1] = v38.u32[1];
  int8x16_t v39 = v15;
  int32x4_t v40 = vmovl_high_s16(v35);
  v15.i64[0] = v40.u32[0];
  v15.i64[1] = v40.u32[1];
  int8x16_t v41 = v15;
  v15.i64[0] = v33.u32[2];
  v15.i64[1] = v33.u32[3];
  int8x16_t v42 = v15;
  v15.i64[0] = v36.u32[2];
  v15.i64[1] = v36.u32[3];
  int8x16_t v43 = v15;
  v15.i64[0] = v38.u32[2];
  v15.i64[1] = v38.u32[3];
  int8x16_t v44 = v15;
  v15.i64[0] = v40.u32[2];
  v15.i64[1] = v40.u32[3];
  int8x16_t v45 = vbicq_s8((int8x16_t)xmmword_1A28FCA00, v44);
  int8x16_t v46 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA60, v34), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v16));
  int8x16_t v47 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA50, v37), vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v19));
  int8x16_t v48 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA40, v39), v30);
  int8x16_t v49 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA30, v41), vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v23));
  int8x16_t v50 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA20, v42), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v24));
  int8x16_t v51 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCA10, v43), v29);
  int8x16_t v52 = vorrq_s8(v45, v28);
  int8x16_t v53 = vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9F0, v15), v27);
  int8x16_t v54 = vceqzq_s8(*(int8x16_t *)(a1 + 336));
  int16x8_t v55 = vmovl_s8(*(int8x8_t *)v54.i8);
  int32x4_t v56 = vmovl_high_s16(v55);
  v15.i64[0] = v56.i32[2];
  v15.i64[1] = v56.i32[3];
  int8x16_t v57 = v15;
  int16x8_t v58 = vmovl_high_s8(v54);
  int32x4_t v59 = vmovl_high_s16(v58);
  v15.i64[0] = v59.i32[2];
  v15.i64[1] = v59.i32[3];
  int8x16_t v60 = v15;
  int32x4_t v61 = vmovl_s16(*(int16x4_t *)v55.i8);
  v15.i64[0] = v61.i32[2];
  v15.i64[1] = v61.i32[3];
  int8x16_t v62 = v15;
  int32x4_t v63 = vmovl_s16(*(int16x4_t *)v58.i8);
  v15.i64[0] = v63.i32[2];
  v15.i64[1] = v63.i32[3];
  int8x16_t v64 = v15;
  v15.i64[0] = v56.i32[0];
  v15.i64[1] = v56.i32[1];
  int8x16_t v65 = v15;
  v15.i64[0] = v59.i32[0];
  v15.i64[1] = v59.i32[1];
  int8x16_t v66 = v15;
  v15.i64[0] = v61.i32[0];
  v15.i64[1] = v61.i32[1];
  int8x16_t v67 = v15;
  v15.i64[0] = v63.i32[0];
  v15.i64[1] = v63.i32[1];
  int8x16_t v68 = vbicq_s8((int8x16_t)xmmword_1A28FCA70, v15);
  int8x16_t v69 = vceqzq_s8(*(int8x16_t *)(a1 + 352));
  int16x8_t v70 = vmovl_high_s8(v69);
  int32x4_t v71 = vmovl_s16(*(int16x4_t *)v70.i8);
  v15.i64[0] = v71.i32[0];
  v15.i64[1] = v71.i32[1];
  int8x16_t v72 = v15;
  int16x8_t v73 = vmovl_s8(*(int8x8_t *)v69.i8);
  int32x4_t v74 = vmovl_s16(*(int16x4_t *)v73.i8);
  v15.i64[0] = v74.i32[0];
  v15.i64[1] = v74.i32[1];
  int8x16_t v75 = v15;
  int32x4_t v76 = vmovl_high_s16(v70);
  v15.i64[0] = v76.i32[0];
  v15.i64[1] = v76.i32[1];
  int8x16_t v77 = v15;
  int32x4_t v78 = vmovl_high_s16(v73);
  v15.i64[0] = v78.i32[0];
  v15.i64[1] = v78.i32[1];
  int8x16_t v79 = v15;
  v15.i64[0] = v71.i32[2];
  v15.i64[1] = v71.i32[3];
  int8x16_t v80 = v15;
  v15.i64[0] = v74.i32[2];
  v15.i64[1] = v74.i32[3];
  int8x16_t v81 = v15;
  v15.i64[0] = v76.i32[2];
  v15.i64[1] = v76.i32[3];
  int8x16_t v82 = v15;
  v15.i64[0] = v78.i32[2];
  v15.i64[1] = v78.i32[3];
  *(void *)(a1 + 296) = vaddvq_s64(vaddq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB50, v75), vbicq_s8((int8x16_t)xmmword_1A28FCA80, v67)), v47), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB60, v72), v68), v46)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB30, v79), vbicq_s8((int8x16_t)xmmword_1A28FCAA0, v65)), v49), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB40, v77), vbicq_s8((int8x16_t)xmmword_1A28FCA90, v66)),
                                               v48))),
                              (int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB10, v81), vbicq_s8((int8x16_t)xmmword_1A28FCAC0, v62)), v51), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCB20, v80), vbicq_s8((int8x16_t)xmmword_1A28FCAB0, v64)), v50)), vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FCAF0, v15), vbicq_s8((int8x16_t)xmmword_1A28FCAE0, v57)), v53), vorrq_s8(vorrq_s8(
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCB00, v82),
                                                 vbicq_s8((int8x16_t)xmmword_1A28FCAD0, v60)),
                                               v52)))));
  *(unsigned char *)(a1 + 288) = 1;
  return a1;
}

unint64_t *ggl::FragmentedPool<ggl::PolygonSolidFill::MeshPipelineSetup>::FragmentedPool(unint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  {
    operator new();
  }
  uint64_t v10 = ggl::Allocator::instance(void)::alloc;
  a1[4] = 0;
  a1[3] = v10;
  a1[5] = 0;
  a1[6] = 0;
  {
    operator new();
  }
  a1[7] = ggl::Allocator::instance(void)::alloc;
  uint64_t v11 = *(void *)(a2 + 24);
  if (!v11) {
    goto LABEL_6;
  }
  if (v11 != a2)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
LABEL_6:
    a1[11] = v11;
    goto LABEL_8;
  }
  a1[11] = (unint64_t)(a1 + 8);
  (*(void (**)(void, unint64_t *))(**(void **)(a2 + 24) + 24))(*(void *)(a2 + 24), a1 + 8);
LABEL_8:
  uint64_t v12 = *(void *)(a3 + 24);
  if (!v12)
  {
LABEL_11:
    a1[15] = v12;
    goto LABEL_13;
  }
  if (v12 != a3)
  {
    uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
    goto LABEL_11;
  }
  a1[15] = (unint64_t)(a1 + 12);
  (*(void (**)(void, unint64_t *))(**(void **)(a3 + 24) + 24))(*(void *)(a3 + 24), a1 + 12);
LABEL_13:
  a1[16] = a5;
  unint64_t v13 = *a1;
  if (a4 <= (uint64_t)(a1[2] - *a1) >> 3) {
    goto LABEL_26;
  }
  unint64_t v14 = a1[1];
  uint64_t v15 = (*(uint64_t (**)(unint64_t, unint64_t, uint64_t))(*(void *)a1[3] + 16))(a1[3], 8 * a4, 8);
  uint64_t v16 = v14 - v13;
  unint64_t v17 = v15 + ((v14 - v13) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v19 = *a1;
  unint64_t v18 = a1[1];
  unint64_t v20 = v18 - *a1;
  if (v18 == *a1)
  {
    unint64_t v22 = v15 + ((v14 - v13) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_24;
  }
  unint64_t v21 = v20 - 8;
  if (v20 - 8 >= 0x58)
  {
    unint64_t v22 = v15 + ((v14 - v13) & 0xFFFFFFFFFFFFFFF8);
    if (v18 - (v16 & 0xFFFFFFFFFFFFFFF8) - v15 >= 0x20)
    {
      uint64_t v23 = v16 >> 3;
      uint64_t v24 = (v21 >> 3) + 1;
      int8x16_t v25 = (_OWORD *)(v15 + 8 * v23 - 16);
      int8x16_t v26 = (long long *)(v18 - 16);
      uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v28 = *v26;
        *(v25 - 1) = *(v26 - 1);
        *int8x16_t v25 = v28;
        v25 -= 2;
        v26 -= 2;
        v27 -= 4;
      }
      while (v27);
      unint64_t v22 = v17 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      v18 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
      if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_23;
      }
    }
  }
  else
  {
    unint64_t v22 = v15 + ((v14 - v13) & 0xFFFFFFFFFFFFFFF8);
  }
  do
  {
    uint64_t v29 = *(void *)(v18 - 8);
    v18 -= 8;
    *(void *)(v22 - 8) = v29;
    v22 -= 8;
  }
  while (v18 != v19);
LABEL_23:
  unint64_t v18 = *a1;
LABEL_24:
  *a1 = v22;
  a1[1] = v17;
  unint64_t v30 = a1[2];
  a1[2] = v15 + 8 * a4;
  if (v18) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)a1[3] + 40))(a1[3], v18, v30 - v18);
  }
LABEL_26:
  unint64_t v31 = a1[4];
  if (a4 <= (uint64_t)(a1[6] - v31) >> 3) {
    return a1;
  }
  unint64_t v32 = a1[5];
  uint64_t v33 = (*(uint64_t (**)(unint64_t, unint64_t, uint64_t))(*(void *)a1[7] + 16))(a1[7], 8 * a4, 8);
  uint64_t v34 = v32 - v31;
  unint64_t v35 = v33 + ((v32 - v31) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v37 = a1[4];
  unint64_t v36 = a1[5];
  unint64_t v38 = v36 - v37;
  if (v36 == v37)
  {
    unint64_t v40 = v33 + ((v32 - v31) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_37;
  }
  unint64_t v39 = v38 - 8;
  if (v38 - 8 >= 0x58)
  {
    unint64_t v40 = v33 + ((v32 - v31) & 0xFFFFFFFFFFFFFFF8);
    if (v36 - ((v34 & 0xFFFFFFFFFFFFFFF8) + v33) >= 0x20)
    {
      uint64_t v41 = v34 >> 3;
      uint64_t v42 = (v39 >> 3) + 1;
      int8x16_t v43 = (_OWORD *)(v33 + 8 * v41 - 16);
      int8x16_t v44 = (long long *)(v36 - 16);
      uint64_t v45 = v42 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v46 = *v44;
        *(v43 - 1) = *(v44 - 1);
        *int8x16_t v43 = v46;
        v43 -= 2;
        v44 -= 2;
        v45 -= 4;
      }
      while (v45);
      unint64_t v40 = v35 - 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
      v36 -= 8 * (v42 & 0x3FFFFFFFFFFFFFFCLL);
      if (v42 == (v42 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_36;
      }
    }
  }
  else
  {
    unint64_t v40 = v33 + ((v32 - v31) & 0xFFFFFFFFFFFFFFF8);
  }
  do
  {
    uint64_t v47 = *(void *)(v36 - 8);
    v36 -= 8;
    *(void *)(v40 - 8) = v47;
    v40 -= 8;
  }
  while (v36 != v37);
LABEL_36:
  unint64_t v36 = a1[4];
LABEL_37:
  a1[4] = v40;
  a1[5] = v35;
  unint64_t v48 = a1[6];
  a1[6] = v33 + 8 * a4;
  if (v36) {
    (*(void (**)(unint64_t, unint64_t, unint64_t))(*(void *)a1[7] + 40))(a1[7], v36, v48 - v36);
  }
  return a1;
}

void sub_1A1A775F8(_Unwind_Exception *a1)
{
  std::function<ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::~function(v3);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v2);
  gss::FeatureAttributeSet::~FeatureAttributeSet(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::CartographicTiledRenderResources::CartographicTiledRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::CartographicTiledRenderResources::CartographicTiledRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_1>,void ()(ggl::PolygonSolidFill::MeshPipelineSetup *)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF51F2F8;
}

uint64_t std::__function::__func<md::CartographicTiledRenderResources::CartographicTiledRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::CartographicTiledRenderResources::CartographicTiledRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_0>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51F2B0;
  a2[1] = v2;
  return result;
}

_WORD *commandBufferLocationsForRenderLayerType(void *a1, int a2, uint64_t a3)
{
  switch(a2)
  {
    case '!':
      __int16 v4 = *(_WORD *)(*(void *)(a3 + 8) + 98);
      goto LABEL_12;
    case '""':
      uint64_t v5 = *(_WORD **)(a3 + 8);
      __int16 v6 = v5[53];
      __int16 v7 = v5[30];
      __int16 v8 = v5[75];
      goto LABEL_6;
    case '#':
      long long v9 = *(_WORD **)(a3 + 8);
      __int16 v6 = v9[54];
      __int16 v7 = v9[31];
      __int16 v8 = v9[76];
LABEL_6:
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      uint64_t result = operator new(6uLL);
      a1[1] = result + 3;
      a1[2] = result + 3;
      _WORD *result = v6;
      result[1] = v7;
      result[2] = v8;
      *a1 = result;
      return result;
    case '$':
      uint64_t v11 = *(void *)(a3 + 8);
      int v12 = *(unsigned __int16 *)(v11 + 104);
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      int v13 = *(unsigned __int16 *)(v11 + 110);
      goto LABEL_10;
    case '%':
      __int16 v4 = *(_WORD *)(*(void *)(a3 + 8) + 100);
      goto LABEL_12;
    case '&':
      uint64_t v14 = *(void *)(a3 + 8);
      int v12 = *(unsigned __int16 *)(v14 + 112);
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      int v13 = *(unsigned __int16 *)(v14 + 116);
LABEL_10:
      uint64_t v15 = operator new(4uLL);
      *a1 = v15;
      *uint64_t v15 = v12 | (v13 << 16);
      uint64_t result = v15 + 1;
      goto LABEL_13;
    case '\'':
      __int16 v4 = *(_WORD *)(*(void *)(a3 + 8) + 114);
      goto LABEL_12;
    default:
      __int16 v4 = *(_WORD *)(*(void *)(a3 + 8) + 106);
LABEL_12:
      a1[1] = 0;
      a1[2] = 0;
      *a1 = 0;
      uint64_t v16 = operator new(2uLL);
      *a1 = v16;
      *uint64_t v16 = v4;
      uint64_t result = v16 + 1;
LABEL_13:
      a1[1] = result;
      a1[2] = result;
      return result;
  }
}

void md::PatternedSharedResources::PatternedSharedResources(md::PatternedSharedResources *this, const StandardLibrary *a2, const RenderTargetFormat *a3, char a4, int a5)
{
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  if ((a4 & 1) == 0 && !a5) {
    operator new();
  }
  operator new();
}

void sub_1A1A78950(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v5);
  std::unique_ptr<md::PolylinePipelineStateManager<md::Ribbons::GradientPolylineOverlayRibbonDescriptor,ggl::GradientPolylineOverlayRibbon::FillPipelineState,std::shared_ptr<ggl::GradientPolylineOverlayFillShader>>>::~unique_ptr[abi:nn180100](v4);
  uint64_t v7 = v3[3];
  v3[3] = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = v3[2];
  v3[2] = 0;
  if (v8) {
    (*(void (**)(uint64_t))(*(void *)v8 + 8))(v8);
  }
  uint64_t v9 = v3[1];
  v3[1] = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  uint64_t v10 = *v3;
  uint64_t *v3 = 0;
  if (v10) {
    (*(void (**)(uint64_t))(*(void *)v10 + 8))(v10);
  }
  _Unwind_Resume(a1);
}

void md::TrailJunctionRenderable::SharedResources::SharedResources(md::TrailJunctionRenderable::SharedResources *this, const StandardLibrary *a2, const RenderTargetFormat *a3, long long *a4)
{
  *(void *)this = 0;
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  if (a3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)&a3->colorFormats[2], 1uLL, memory_order_relaxed);
  }
  long long v4 = *a4;
  long long v5 = a4[1];
  *((void *)this + 15) = 0;
  *(_OWORD *)((char *)this + 24) = v4;
  *(_OWORD *)((char *)this + 40) = v5;
  *((unsigned char *)this + 56) = 1;
  *(void *)((char *)this + 60) = 0x700000006;
  *(void *)((char *)this + 68) = 0x100000000;
  *((_DWORD *)this + 19) = 7;
  *((void *)this + 10) = 0;
  *((void *)this + 11) = 0;
  *((_DWORD *)this + 24) = 0;
  *((unsigned char *)this + 100) = 15;
  *((unsigned char *)this + 104) = 0;
  *((void *)this + 16) = 0;
  *((void *)this + 14) = (char *)this + 120;
  operator new();
}

void sub_1A1A78BAC(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy((void *)v1[15]);
  uint64_t v3 = (std::__shared_weak_count *)v1[2];
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  uint64_t v4 = *v1;
  *uint64_t v1 = 0;
  if (v4) {
    (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  }
  _Unwind_Resume(a1);
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_16PolygonSolidFill17MeshPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57B118;
}

uint64_t std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_6,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_6>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51EB18;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4,std::allocator<md::COverlayRenderResources::COverlayRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&,BOOL)::$_4>,ggl::PolygonSolidFill::MeshPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF51EA88;
  a2[1] = v2;
  return result;
}

void ggl::PolygonSolidFillShader::typedReflection(ggl::PolygonSolidFillShader *this)
{
  {
    if (v1)
    {
      ggl::PolygonSolidFillShader::typedReflection(void)::ref = (uint64_t)"PolygonSolidFillShader";
      ggl::polygonSolidFillShaderVertexFunctionDescriptor(v1);
      qword_1EB322110 = (uint64_t)&ggl::polygonSolidFillShaderVertexFunctionDescriptor(void)::ref;
      uint64_t v2 = (ggl *)ggl::crc32::compute<29ul>("PolygonSolidFillShaderVertex");
      dword_1EB322118 = (int)v2;
      ggl::polygonSolidFillShaderFragmentFunctionDescriptor(v2);
      qword_1EB322120 = (uint64_t)&ggl::polygonSolidFillShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB322128 = ggl::crc32::compute<31ul>("PolygonSolidFillShaderFragment");
      qword_1EB322130 = (uint64_t)ggl::polygonSolidFillShaderShaderConstants(void)::ref;
      unk_1EB322138 = 3;
      qword_1EB322140 = (uint64_t)&ggl::polygonSolidFillShaderShaderTextures(void)::ref;
      unk_1EB322148 = 0;
      qword_1EB322150 = (uint64_t)&ggl::polygonSolidFillShaderShaderSamplers(void)::ref;
      unk_1EB322158 = 0;
    }
  }
}

void ggl::PolygonSolidFillS2Shader::typedReflection(ggl::PolygonSolidFillS2Shader *this)
{
  {
    if (v1)
    {
      ggl::PolygonSolidFillS2Shader::typedReflection(void)::ref = (uint64_t)"PolygonSolidFillS2Shader";
      ggl::polygonSolidFillS2ShaderVertexFunctionDescriptor(v1);
      qword_1EB31A320 = (uint64_t)&ggl::polygonSolidFillS2ShaderVertexFunctionDescriptor(void)::ref;
      uint64_t v2 = (ggl *)ggl::crc32::compute<31ul>("PolygonSolidFillS2ShaderVertex");
      dword_1EB31A328 = (int)v2;
      ggl::polygonSolidFillS2ShaderFragmentFunctionDescriptor(v2);
      qword_1EB31A330 = (uint64_t)&ggl::polygonSolidFillS2ShaderFragmentFunctionDescriptor(void)::ref;
      dword_1EB31A338 = ggl::crc32::compute<33ul>("PolygonSolidFillS2ShaderFragment");
      qword_1EB31A340 = (uint64_t)ggl::polygonSolidFillS2ShaderShaderConstants(void)::ref;
      unk_1EB31A348 = 3;
      qword_1EB31A350 = (uint64_t)&ggl::polygonSolidFillS2ShaderShaderTextures(void)::ref;
      unk_1EB31A358 = 0;
      qword_1EB31A360 = (uint64_t)&ggl::polygonSolidFillS2ShaderShaderSamplers(void)::ref;
      unk_1EB31A368 = 0;
    }
  }
}

void ggl::polygonSolidFillS2ShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::polygonSolidFillS2ShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<33ul>("PolygonSolidFillS2ShaderFragment");
    *(_DWORD *)algn_1EB31ABD4 = 1;
    qword_1EB31ABD8 = (uint64_t)"PolygonSolidFillS2Shader";
    unk_1EB31ABE0 = 0;
    qword_1EB31ABE8 = 0;
    unk_1EB31ABF0 = &ggl::polygonSolidFillS2ShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB31ABF8 = 1;
    unk_1EB31AC00 = &ggl::polygonSolidFillS2ShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB31AC08 = 0;
    unk_1EB31AC10 = &ggl::polygonSolidFillS2ShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB31AC18 = 0;
    unk_1EB31AC20 = &ggl::polygonSolidFillS2ShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB31AC30 = 0;
    unk_1EB31AC38 = 0;
    qword_1EB31AC28 = 0;
  }
}

void ggl::polygonSolidFillShaderFragmentFunctionDescriptor(ggl *this)
{
  {
    ggl::polygonSolidFillShaderFragmentFunctionDescriptor(void)::ref = ggl::crc32::compute<31ul>("PolygonSolidFillShaderFragment");
    *(_DWORD *)algn_1EB3281A4 = 1;
    qword_1EB3281A8 = (uint64_t)"PolygonSolidFillShader";
    unk_1EB3281B0 = 0;
    qword_1EB3281B8 = 0;
    unk_1EB3281C0 = &ggl::polygonSolidFillShaderFragShaderFunctionConstantMapping(void)::ref;
    qword_1EB3281C8 = 1;
    unk_1EB3281D0 = &ggl::polygonSolidFillShaderFragShaderFunctionBufferMapping(void)::ref;
    qword_1EB3281D8 = 0;
    unk_1EB3281E0 = &ggl::polygonSolidFillShaderFragShaderFunctionTextureMapping(void)::ref;
    qword_1EB3281E8 = 0;
    unk_1EB3281F0 = &ggl::polygonSolidFillShaderFragShaderFunctionSamplerMapping(void)::ref;
    qword_1EB328200 = 0;
    unk_1EB328208 = 0;
    qword_1EB3281F8 = 0;
  }
}

void ggl::polygonSolidFillS2ShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::polygonSolidFillS2ShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<31ul>("PolygonSolidFillS2ShaderVertex");
    *(_DWORD *)algn_1EB31AA0C = 0;
    qword_1EB31AA10 = (uint64_t)"PolygonSolidFillS2Shader";
    unk_1EB31AA18 = ggl::polygonSolidFillS2ShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB31AA20 = 1;
    unk_1EB31AA28 = &ggl::polygonSolidFillS2ShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB31AA30 = 3;
    unk_1EB31AA38 = &ggl::polygonSolidFillS2ShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB31AA40 = 0;
    unk_1EB31AA48 = &ggl::polygonSolidFillS2ShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB31AA50 = 0;
    unk_1EB31AA58 = &ggl::polygonSolidFillS2ShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB31AA68 = 0;
    unk_1EB31AA70 = 0;
    qword_1EB31AA60 = 0;
  }
}

void ggl::polygonSolidFillShaderVertexFunctionDescriptor(ggl *this)
{
  {
    ggl::polygonSolidFillShaderVertexFunctionDescriptor(void)::ref = ggl::crc32::compute<29ul>("PolygonSolidFillShaderVertex");
    *(_DWORD *)algn_1EB32736C = 0;
    qword_1EB327370 = (uint64_t)"PolygonSolidFillShader";
    unk_1EB327378 = ggl::polygonSolidFillShaderVertShaderFunctionAttributes(void)::ref;
    qword_1EB327380 = 1;
    unk_1EB327388 = &ggl::polygonSolidFillShaderVertShaderFunctionConstantMapping(void)::ref;
    qword_1EB327390 = 3;
    unk_1EB327398 = &ggl::polygonSolidFillShaderVertShaderFunctionBufferMapping(void)::ref;
    qword_1EB3273A0 = 0;
    unk_1EB3273A8 = &ggl::polygonSolidFillShaderVertShaderFunctionTextureMapping(void)::ref;
    qword_1EB3273B0 = 0;
    unk_1EB3273B8 = &ggl::polygonSolidFillShaderVertShaderFunctionSamplerMapping(void)::ref;
    qword_1EB3273C8 = 0;
    unk_1EB3273D0 = 0;
    qword_1EB3273C0 = 0;
  }
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CheckIfReadyToProcess>,std::allocator<ecs2::ForwardToExecute<md::ita::CheckIfReadyToProcess>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A79994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
  std::function<void ()(md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*)>::~function(&a16);
  if (__p) {
    operator delete(__p);
  }
  (*(void (**)(uint64_t))(*(void *)v20 + 8))(v20);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>::Model<ecs2::RuntimeQuery<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>>::~Model()
{
}

unint64_t *ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>::Model<ecs2::RuntimeQuery<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::RegisterHandle>(v2);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::MapDataTypeV>(v2);
  long long v5 = (void *)gdc::Registry::storage<md::ls::CheckIfReadyToProcess>(v2);
  __int16 v6 = (void *)gdc::Registry::storage<md::ls::FlyoverOctileKey>(v2);
  uint64_t v7 = (void *)gdc::Registry::storage<md::ls::BaseMapTileHandle>(v2);
  uint64_t v8 = (void *)gdc::Registry::storage<md::ls::WillEnterView>(v2);
  uint64_t v9 = (void *)gdc::Registry::storage<md::ls::RenderablesCount>(v2);
  v127[0] = (uint64_t)v3;
  v127[1] = (uint64_t)v4;
  v127[2] = (uint64_t)v5;
  v127[3] = (uint64_t)v6;
  v127[4] = (uint64_t)v7;
  v127[5] = (uint64_t)v8;
  v127[6] = (uint64_t)v9;
  gdc::RegistryQueryView<gdc::All<md::ls::RegisterHandle const,md::ls::RenderablesCount,md::ls::MapDataTypeV const,md::ls::CheckIfReadyToProcess const>,gdc::Any<md::ls::FlyoverOctileKey const,md::ls::BaseMapTileHandle const,md::ls::WillEnterView const>,gdc::None<>>::begin(v125, v127);
  uint64_t v10 = v3 + 4;
  if (v9[8] - v9[7] < v3[8] - v3[7]) {
    uint64_t v10 = v9 + 4;
  }
  if (v4[8] - v4[7] < v10[4] - v10[3]) {
    uint64_t v10 = v4 + 4;
  }
  if (v5[8] - v5[7] < v10[4] - v10[3]) {
    uint64_t v10 = v5 + 4;
  }
  uint64_t v11 = v126;
  unint64_t v123 = (unint64_t *)v10[4];
  if (v123 == v126)
  {
    uint64_t result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
LABEL_130:
    unint64_t *result = 0xFFFFFFFF00000000;
  }
  else
  {
    uint64_t result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    int v13 = (void *)v125[1];
    uint64_t v14 = (void *)v125[2];
    float v120 = (void *)v125[3];
    uint64_t v121 = v125[0];
    uint64_t v119 = (void *)v125[4];
    BOOL v122 = result;
    while (1)
    {
      unint64_t *result = *v11;
      unint64_t v15 = *v11;
      unint64_t v16 = HIDWORD(*v11);
      unint64_t v17 = *v11 >> 39;
      uint64_t v18 = v3[4];
      if (v17 < (v3[5] - v18) >> 3
        && (uint64_t v19 = *(void *)(v18 + 8 * v17)) != 0
        && (unint64_t v20 = *(unsigned __int16 *)(v19 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v22 = v3[7],
            uint64_t v21 = v3[8],
            v20 < (v21 - v22) >> 3)
        && ((uint64_t v23 = v22 + 8 * v20, v23 != v21) ? (v24 = *(_DWORD *)(v23 + 4) == v16) : (v24 = 0), v24))
      {
        uint64_t v25 = v3[11];
        uint64_t v26 = v3[10] + 8 * v20;
      }
      else
      {
        uint64_t v25 = v3[11];
        uint64_t v26 = v25;
      }
      if (v26 == v25) {
        uint64_t v27 = 0;
      }
      else {
        uint64_t v27 = v26;
      }
      uint64_t v28 = v9[4];
      if (v17 < (v9[5] - v28) >> 3
        && (uint64_t v29 = *(void *)(v28 + 8 * v17)) != 0
        && (unint64_t v30 = *(unsigned __int16 *)(v29 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v32 = v9[7],
            uint64_t v31 = v9[8],
            v30 < (v31 - v32) >> 3)
        && ((uint64_t v33 = v32 + 8 * v30, v33 != v31) ? (v34 = *(_DWORD *)(v33 + 4) == v16) : (v34 = 0), v34))
      {
        uint64_t v35 = v9[11];
        uint64_t v36 = v9[10] + 32 * v30;
      }
      else
      {
        uint64_t v35 = v9[11];
        uint64_t v36 = v35;
      }
      if (v36 == v35) {
        uint64_t v37 = 0;
      }
      else {
        uint64_t v37 = v36;
      }
      uint64_t v38 = v4[4];
      if (v17 < (v4[5] - v38) >> 3
        && (uint64_t v39 = *(void *)(v38 + 8 * v17)) != 0
        && (unint64_t v40 = *(unsigned __int16 *)(v39 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v42 = v4[7],
            uint64_t v41 = v4[8],
            v40 < (v41 - v42) >> 3)
        && ((uint64_t v43 = v42 + 8 * v40, v43 != v41) ? (v44 = *(_DWORD *)(v43 + 4) == v16) : (v44 = 0), v44))
      {
        uint64_t v45 = v4[11];
        uint64_t v46 = v4[10] + 2 * v40;
      }
      else
      {
        uint64_t v45 = v4[11];
        uint64_t v46 = v45;
      }
      if (v46 == v45) {
        uint64_t v47 = 0;
      }
      else {
        uint64_t v47 = v46;
      }
      uint64_t v48 = v5[4];
      if (v17 < (v5[5] - v48) >> 3
        && (uint64_t v49 = *(void *)(v48 + 8 * v17)) != 0
        && (unint64_t v50 = *(unsigned __int16 *)(v49 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v52 = v5[7],
            uint64_t v51 = v5[8],
            v50 < (v51 - v52) >> 3)
        && ((uint64_t v53 = v52 + 8 * v50, v53 != v51) ? (v54 = *(_DWORD *)(v53 + 4) == v16) : (v54 = 0), v54))
      {
        uint64_t v55 = v5[11];
        uint64_t v56 = v5[10] + 8 * v50;
      }
      else
      {
        uint64_t v55 = v5[11];
        uint64_t v56 = v55;
      }
      if (v56 == v55) {
        uint64_t v57 = 0;
      }
      else {
        uint64_t v57 = v56;
      }
      uint64_t v58 = v6[4];
      if (v17 < (v6[5] - v58) >> 3
        && (uint64_t v59 = *(void *)(v58 + 8 * v17)) != 0
        && (unint64_t v60 = *(unsigned __int16 *)(v59 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v62 = v6[7],
            uint64_t v61 = v6[8],
            v60 < (v61 - v62) >> 3)
        && ((v63 = v62 + 8 * v60, v63 != v61) ? (BOOL v64 = *(_DWORD *)(v63 + 4) == v16) : (BOOL v64 = 0), v64))
      {
        uint64_t v65 = v6[11];
        uint64_t v66 = v6[10] + 40 * v60;
      }
      else
      {
        uint64_t v65 = v6[11];
        uint64_t v66 = v65;
      }
      if (v66 == v65) {
        uint64_t v66 = 0;
      }
      if ((uint64_t v67 = v7[4], v17 < (v7[5] - v67) >> 3)
        && (uint64_t v68 = *(void *)(v67 + 8 * v17)) != 0
        && (unint64_t v69 = *(unsigned __int16 *)(v68 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v71 = v7[7],
            uint64_t v70 = v7[8],
            v69 < (v70 - v71) >> 3)
        && ((uint64_t v72 = v71 + 8 * v69, v72 != v70) ? (v73 = *(_DWORD *)(v72 + 4) == v16) : (v73 = 0), v73))
      {
        uint64_t v74 = v7[11];
        uint64_t v75 = v7[10] + 8 * v69;
      }
      else
      {
        uint64_t v74 = v7[11];
        uint64_t v75 = v74;
      }
      if (v75 == v74) {
        uint64_t v75 = 0;
      }
      uint64_t v76 = v8[4];
      if (v17 < (v8[5] - v76) >> 3
        && (uint64_t v77 = *(void *)(v76 + 8 * v17)) != 0
        && (unint64_t v78 = *(unsigned __int16 *)(v77 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v80 = v8[7],
            uint64_t v79 = v8[8],
            v78 < (v79 - v80) >> 3)
        && (uint64_t v81 = v80 + 8 * v78, v81 != v79)
        && *(_DWORD *)(v81 + 4) == v16)
      {
        unint64_t v82 = v8[11];
        unint64_t v83 = v8[10] + v78;
      }
      else
      {
        unint64_t v82 = v8[11];
        unint64_t v83 = v82;
      }
      unint64_t v84 = v83 == v82 ? 0 : v83;
      uint64_t v129 = v75;
      uint64_t v130 = v66;
      unint64_t v128 = v84;
      uint64_t v85 = *(void *)(a2 + 24);
      if (!v85) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t *, unint64_t *))(*(void *)v85 + 48))(v85, v27, v37, v47, v57, &v130, &v129, &v128);
      uint64_t v86 = *(unint64_t **)(v121 + 32);
      uint64_t v87 = v11 + 1;
      int8x8_t v126 = v11 + 1;
      if (v11 + 1 == v86)
      {
        uint64_t result = v122;
      }
      else
      {
        uint64_t v88 = v13[4];
        uint64_t result = v122;
        do
        {
          unint64_t v89 = *((unsigned int *)v87 + 1);
          unint64_t v90 = v89 >> 7;
          if (v89 >> 7 < (v13[5] - v88) >> 3)
          {
            uint64_t v91 = *(void *)(v88 + 8 * v90);
            if (v91)
            {
              uint64_t v92 = v89 & 0x7F;
              unint64_t v93 = *(unsigned __int16 *)(v91 + 2 * v92);
              uint64_t v95 = v13[7];
              uint64_t v94 = v13[8];
              if (v93 < (v94 - v95) >> 3)
              {
                uint64_t v96 = v95 + 8 * v93;
                if (v96 != v94 && *(_DWORD *)(v96 + 4) == v89)
                {
                  uint64_t v98 = v14[4];
                  if (v90 < (v14[5] - v98) >> 3)
                  {
                    uint64_t v99 = *(void *)(v98 + 8 * v90);
                    if (v99)
                    {
                      unint64_t v100 = *(unsigned __int16 *)(v99 + 2 * v92);
                      uint64_t v102 = v14[7];
                      uint64_t v101 = v14[8];
                      if (v100 < (v101 - v102) >> 3)
                      {
                        uint64_t v103 = v102 + 8 * v100;
                        if (v103 != v101 && *(_DWORD *)(v103 + 4) == v89)
                        {
                          uint64_t v105 = v120[4];
                          if (v90 < (v120[5] - v105) >> 3)
                          {
                            uint64_t v106 = *(void *)(v105 + 8 * v90);
                            if (v106)
                            {
                              unint64_t v107 = *(unsigned __int16 *)(v106 + 2 * v92);
                              uint64_t v109 = v120[7];
                              uint64_t v108 = v120[8];
                              if (v107 < (v108 - v109) >> 3)
                              {
                                uint64_t v110 = v109 + 8 * v107;
                                if (v110 != v108 && *(_DWORD *)(v110 + 4) == v89)
                                {
                                  uint64_t v112 = v119[4];
                                  if (v90 < (v119[5] - v112) >> 3)
                                  {
                                    uint64_t v113 = *(void *)(v112 + 8 * v90);
                                    if (v113)
                                    {
                                      unint64_t v114 = *(unsigned __int16 *)(v113 + 2 * v92);
                                      uint64_t v116 = v119[7];
                                      uint64_t v115 = v119[8];
                                      if (v114 < (v115 - v116) >> 3)
                                      {
                                        uint64_t v117 = v116 + 8 * v114;
                                        if (*(_DWORD *)(v117 + 4) == v89 && v117 != v115)
                                        {
                                          uint64_t v86 = v87;
                                          goto LABEL_122;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          ++v87;
        }
        while (v87 != v86);
        uint64_t v87 = v86;
LABEL_122:
        int8x8_t v126 = v87;
      }
      uint64_t v11 = v86;
      if (v123 == v86) {
        goto LABEL_130;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return (unint64_t *)std::__function::__func<ecs2::ForwardToExecute<md::ita::CreateTileClearRenderItemsForShadowPass>,std::allocator<ecs2::ForwardToExecute<md::ita::CreateTileClearRenderItemsForShadowPass>>,void ()(ecs2::Runtime &)>::operator()();
  }
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CreateTileClearRenderItemsForShadowPass>,std::allocator<ecs2::ForwardToExecute<md::ita::CreateTileClearRenderItemsForShadowPass>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A7A36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::function<void ()(md::ls::EnteringView const&,md::ls::SupportsShadows const&,md::ls::AssociationTileHandle const&,md::ls::BaseMapTileHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle const&)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::EnteringView const&,md::ls::SupportsShadows const&,md::ls::AssociationTileHandle const&,md::ls::BaseMapTileHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle const&>::Model<ecs2::RuntimeQuery<md::ls::EnteringView const&,md::ls::SupportsShadows const&,md::ls::AssociationTileHandle const&,md::ls::BaseMapTileHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle const&>>::~Model()
{
}

unint64_t *ecs2::Query<md::ls::EnteringView const&,md::ls::SupportsShadows const&,md::ls::AssociationTileHandle const&,md::ls::BaseMapTileHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle const&>::Model<ecs2::RuntimeQuery<md::ls::EnteringView const&,md::ls::SupportsShadows const&,md::ls::AssociationTileHandle const&,md::ls::BaseMapTileHandle const&,md::ls::TileViewConstantDataHandle const&,md::ls::TileTransformConstantDataHandle const&,md::ls::TileMatrix const&,md::ls::TileShadowConstantDataHandle const&>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v3 = gdc::Registry::storage<md::ls::EnteringView>(v2);
  uint64_t v4 = gdc::Registry::storage<md::ls::SupportsShadows>(v2);
  uint64_t v5 = gdc::Registry::storage<md::ls::AssociationTileHandle>(v2);
  uint64_t v6 = gdc::Registry::storage<md::ls::BaseMapTileHandle>(v2);
  uint64_t v7 = gdc::Registry::storage<md::ls::TileViewConstantDataHandle>(v2);
  uint64_t v8 = gdc::Registry::storage<md::ls::TileTransformConstantDataHandle>(v2);
  uint64_t v9 = gdc::Registry::storage<md::ls::TileMatrix>(v2);
  uint64_t v10 = gdc::Registry::storage<md::ls::TileShadowConstantDataHandle>(v2);
  uint64_t v113 = (void *)v3;
  unint64_t v114 = (void *)v4;
  uint64_t v115 = (void *)v5;
  uint64_t v116 = (void *)v6;
  uint64_t v117 = (void *)v7;
  uint64_t v118 = (void *)v8;
  uint64_t v119 = (void *)v9;
  float v120 = (void *)v10;
  gdc::RegistryQueryView<gdc::All<md::ls::EnteringView const,md::ls::SupportsShadows const,md::ls::AssociationTileHandle const,md::ls::BaseMapTileHandle const,md::ls::TileViewConstantDataHandle const,md::ls::TileTransformConstantDataHandle const,md::ls::TileMatrix const,md::ls::TileShadowConstantDataHandle const>,gdc::Any<>,gdc::None<>>::begin(v111, (uint64_t *)&v113);
  if (*(void *)(v4 + 64) - *(void *)(v4 + 56) >= *(void *)(v3 + 64) - *(void *)(v3 + 56)) {
    uint64_t v11 = v3;
  }
  else {
    uint64_t v11 = v4;
  }
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) < *(void *)(v11 + 64) - *(void *)(v11 + 56)) {
    uint64_t v11 = v5;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) < *(void *)(v11 + 64) - *(void *)(v11 + 56)) {
    uint64_t v11 = v6;
  }
  if (*(void *)(v7 + 64) - *(void *)(v7 + 56) < *(void *)(v11 + 64) - *(void *)(v11 + 56)) {
    uint64_t v11 = v7;
  }
  if (*(void *)(v8 + 64) - *(void *)(v8 + 56) < *(void *)(v11 + 64) - *(void *)(v11 + 56)) {
    uint64_t v11 = v8;
  }
  if (*(void *)(v9 + 64) - *(void *)(v9 + 56) < *(void *)(v11 + 64) - *(void *)(v11 + 56)) {
    uint64_t v11 = v9;
  }
  if (*(void *)(v10 + 64) - *(void *)(v10 + 56) < *(void *)(v11 + 64) - *(void *)(v11 + 56)) {
    uint64_t v11 = v10;
  }
  int v12 = v112;
  uint64_t v109 = *(unint64_t **)(v11 + 64);
  if (v109 == v112)
  {
    uint64_t result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
LABEL_118:
    unint64_t *result = 0xFFFFFFFF00000000;
  }
  else
  {
    uint64_t result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v14 = v113;
    unint64_t v15 = v114;
    unint64_t v16 = v115;
    unint64_t v17 = v116;
    uint64_t v18 = v117;
    uint64_t v19 = v118;
    unint64_t v20 = v119;
    uint64_t v21 = v120;
    uint64_t v107 = v111[0];
    uint64_t v108 = result;
    while (1)
    {
      unint64_t *result = *v12;
      unint64_t v22 = *v12;
      unint64_t v23 = HIDWORD(*v12);
      unint64_t v24 = *v12 >> 39;
      uint64_t v25 = v14[4];
      if (v24 >= (v14[5] - v25) >> 3) {
        goto LABEL_27;
      }
      uint64_t v26 = *(void *)(v25 + 8 * v24);
      if (!v26) {
        goto LABEL_27;
      }
      unint64_t v27 = *(unsigned __int16 *)(v26 + 2 * (HIDWORD(v22) & 0x7F));
      uint64_t v29 = v14[7];
      uint64_t v28 = v14[8];
      if (v27 >= (v28 - v29) >> 3) {
        goto LABEL_27;
      }
      uint64_t v30 = v29 + 8 * v27;
      if (v30 != v28 && *(_DWORD *)(v30 + 4) == v23)
      {
        unint64_t v32 = v14[11];
        unint64_t v33 = v14[10] + v27;
      }
      else
      {
LABEL_27:
        unint64_t v32 = v14[11];
        unint64_t v33 = v32;
      }
      unint64_t v34 = v33 == v32 ? 0 : v33;
      if ((uint64_t v35 = v15[4], v24 < (v15[5] - v35) >> 3)
        && (uint64_t v36 = *(void *)(v35 + 8 * v24)) != 0
        && (unint64_t v37 = *(unsigned __int16 *)(v36 + 2 * (HIDWORD(v22) & 0x7F)),
            uint64_t v39 = v15[7],
            uint64_t v38 = v15[8],
            v37 < (v38 - v39) >> 3)
        && ((uint64_t v40 = v39 + 8 * v37, v40 != v38) ? (v41 = *(_DWORD *)(v40 + 4) == v23) : (v41 = 0), v41))
      {
        unint64_t v42 = v15[11];
        unint64_t v43 = v15[10] + v37;
      }
      else
      {
        unint64_t v42 = v15[11];
        unint64_t v43 = v42;
      }
      unint64_t v44 = v43 == v42 ? 0 : v43;
      if ((uint64_t v45 = v16[4], v24 < (v16[5] - v45) >> 3)
        && (uint64_t v46 = *(void *)(v45 + 8 * v24)) != 0
        && (unint64_t v47 = *(unsigned __int16 *)(v46 + 2 * (HIDWORD(v22) & 0x7F)),
            uint64_t v49 = v16[7],
            uint64_t v48 = v16[8],
            v47 < (v48 - v49) >> 3)
        && ((v50 = v49 + 8 * v47, v50 != v48) ? (BOOL v51 = *(_DWORD *)(v50 + 4) == v23) : (BOOL v51 = 0), v51))
      {
        uint64_t v52 = v16[11];
        uint64_t v53 = v16[10] + 8 * v47;
      }
      else
      {
        uint64_t v52 = v16[11];
        uint64_t v53 = v52;
      }
      uint64_t v54 = v53 == v52 ? 0 : v53;
      if ((uint64_t v55 = v17[4], v24 < (v17[5] - v55) >> 3)
        && (uint64_t v56 = *(void *)(v55 + 8 * v24)) != 0
        && (unint64_t v57 = *(unsigned __int16 *)(v56 + 2 * (HIDWORD(v22) & 0x7F)),
            uint64_t v59 = v17[7],
            uint64_t v58 = v17[8],
            v57 < (v58 - v59) >> 3)
        && ((uint64_t v60 = v59 + 8 * v57, v60 != v58) ? (v61 = *(_DWORD *)(v60 + 4) == v23) : (v61 = 0), v61))
      {
        uint64_t v62 = v17[11];
        uint64_t v63 = v17[10] + 8 * v57;
      }
      else
      {
        uint64_t v62 = v17[11];
        uint64_t v63 = v62;
      }
      uint64_t v64 = v63 == v62 ? 0 : v63;
      if ((uint64_t v65 = v18[4], v24 < (v18[5] - v65) >> 3)
        && (uint64_t v66 = *(void *)(v65 + 8 * v24)) != 0
        && (unint64_t v67 = *(unsigned __int16 *)(v66 + 2 * (HIDWORD(v22) & 0x7F)),
            uint64_t v69 = v18[7],
            uint64_t v68 = v18[8],
            v67 < (v68 - v69) >> 3)
        && ((v70 = v69 + 8 * v67, v70 != v68) ? (BOOL v71 = *(_DWORD *)(v70 + 4) == v23) : (BOOL v71 = 0), v71))
      {
        uint64_t v72 = v18[11];
        uint64_t v73 = v18[10] + 8 * v67;
      }
      else
      {
        uint64_t v72 = v18[11];
        uint64_t v73 = v72;
      }
      uint64_t v74 = v73 == v72 ? 0 : v73;
      if ((uint64_t v75 = v19[4], v24 < (v19[5] - v75) >> 3)
        && (uint64_t v76 = *(void *)(v75 + 8 * v24)) != 0
        && (unint64_t v77 = *(unsigned __int16 *)(v76 + 2 * (HIDWORD(v22) & 0x7F)),
            uint64_t v79 = v19[7],
            uint64_t v78 = v19[8],
            v77 < (v78 - v79) >> 3)
        && ((uint64_t v80 = v79 + 8 * v77, v80 != v78) ? (v81 = *(_DWORD *)(v80 + 4) == v23) : (v81 = 0), v81))
      {
        uint64_t v82 = v19[11];
        uint64_t v83 = v19[10] + 8 * v77;
      }
      else
      {
        uint64_t v82 = v19[11];
        uint64_t v83 = v82;
      }
      uint64_t v84 = v83 == v82 ? 0 : v83;
      uint64_t v85 = v20[4];
      if (v24 < (v20[5] - v85) >> 3
        && (uint64_t v86 = *(void *)(v85 + 8 * v24)) != 0
        && (unint64_t v87 = *(unsigned __int16 *)(v86 + 2 * (HIDWORD(v22) & 0x7F)),
            uint64_t v89 = v20[7],
            uint64_t v88 = v20[8],
            v87 < (v88 - v89) >> 3)
        && (uint64_t v90 = v89 + 8 * v87, v90 != v88)
        && *(_DWORD *)(v90 + 4) == v23)
      {
        uint64_t v91 = v20[11];
        uint64_t v92 = v20[10] + 8 * v87;
      }
      else
      {
        uint64_t v91 = v20[11];
        uint64_t v92 = v91;
      }
      uint64_t v93 = v92 == v91 ? 0 : v92;
      uint64_t v94 = v21[4];
      if (v24 < (v21[5] - v94) >> 3
        && (uint64_t v95 = *(void *)(v94 + 8 * v24)) != 0
        && (unint64_t v96 = *(unsigned __int16 *)(v95 + 2 * (HIDWORD(v22) & 0x7F)),
            uint64_t v98 = v21[7],
            uint64_t v97 = v21[8],
            v96 < (v97 - v98) >> 3)
        && (uint64_t v99 = v98 + 8 * v96, v99 != v97)
        && *(_DWORD *)(v99 + 4) == v23)
      {
        uint64_t v100 = v21[11];
        uint64_t v101 = v21[10] + 8 * v96;
      }
      else
      {
        uint64_t v100 = v21[11];
        uint64_t v101 = v100;
      }
      uint64_t v102 = *(void *)(a2 + 24);
      if (!v102) {
        break;
      }
      if (v101 == v100) {
        uint64_t v103 = 0;
      }
      else {
        uint64_t v103 = v101;
      }
      (*(void (**)(uint64_t, unint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v102 + 48))(v102, v34, v44, v54, v64, v74, v84, v93, v103);
      uint64_t v104 = *(unint64_t **)(v107 + 32);
      while (1)
      {
        uint64_t v112 = ++v12;
        if (v12 == v104) {
          break;
        }
        if (gdc::RegistryQueryView<gdc::All<md::ls::EnteringView const,md::ls::SupportsShadows const,md::ls::AssociationTileHandle const,md::ls::BaseMapTileHandle const,md::ls::TileViewConstantDataHandle const,md::ls::TileTransformConstantDataHandle const,md::ls::TileMatrix const,md::ls::TileShadowConstantDataHandle const>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v111)) {
          goto LABEL_19;
        }
      }
      int v12 = v104;
LABEL_19:
      uint64_t result = v108;
      if (v109 == v12) {
        goto LABEL_118;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return (unint64_t *)gdc::RegistryQueryView<gdc::All<md::ls::EnteringView const,md::ls::SupportsShadows const,md::ls::AssociationTileHandle const,md::ls::BaseMapTileHandle const,md::ls::TileViewConstantDataHandle const,md::ls::TileTransformConstantDataHandle const,md::ls::TileMatrix const,md::ls::TileShadowConstantDataHandle const>,gdc::Any<>,gdc::None<>>::begin(v105, v106);
  }
  return result;
}

unint64_t gdc::RegistryQueryView<gdc::All<md::ls::EnteringView const,md::ls::SupportsShadows const,md::ls::AssociationTileHandle const,md::ls::BaseMapTileHandle const,md::ls::TileViewConstantDataHandle const,md::ls::TileTransformConstantDataHandle const,md::ls::TileMatrix const,md::ls::TileShadowConstantDataHandle const>,gdc::Any<>,gdc::None<>>::begin(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = a2[3];
  uint64_t v7 = a2[4];
  uint64_t v8 = a2[5];
  uint64_t v9 = a2[6];
  uint64_t v10 = a2[7];
  uint64_t v11 = *a2 + 32;
  if (!*a2) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = v4 + 32;
  if (!v4) {
    uint64_t v12 = 0;
  }
  uint64_t v13 = v5 + 32;
  if (!v5) {
    uint64_t v13 = 0;
  }
  uint64_t v14 = v6 + 32;
  if (!v6) {
    uint64_t v14 = 0;
  }
  uint64_t v15 = v7 + 32;
  if (!v7) {
    uint64_t v15 = 0;
  }
  uint64_t v16 = v8 + 32;
  if (!v8) {
    uint64_t v16 = 0;
  }
  uint64_t v17 = v9 + 32;
  if (!v9) {
    uint64_t v17 = 0;
  }
  uint64_t v18 = v10 + 32;
  if (!v10) {
    uint64_t v18 = 0;
  }
  if (*(void *)(v12 + 32) - *(void *)(v12 + 24) < *(void *)(v11 + 32) - *(void *)(v11 + 24)) {
    uint64_t v11 = v12;
  }
  if (*(void *)(v13 + 32) - *(void *)(v13 + 24) < *(void *)(v11 + 32) - *(void *)(v11 + 24)) {
    uint64_t v11 = v13;
  }
  if (*(void *)(v14 + 32) - *(void *)(v14 + 24) < *(void *)(v11 + 32) - *(void *)(v11 + 24)) {
    uint64_t v11 = v14;
  }
  if (*(void *)(v15 + 32) - *(void *)(v15 + 24) < *(void *)(v11 + 32) - *(void *)(v11 + 24)) {
    uint64_t v11 = v15;
  }
  if (*(void *)(v16 + 32) - *(void *)(v16 + 24) < *(void *)(v11 + 32) - *(void *)(v11 + 24)) {
    uint64_t v11 = v16;
  }
  if (*(void *)(v17 + 32) - *(void *)(v17 + 24) < *(void *)(v11 + 32) - *(void *)(v11 + 24)) {
    uint64_t v11 = v17;
  }
  unint64_t result = *(void *)(v11 + 32) - *(void *)(v11 + 24);
  if (*(void *)(v18 + 32) - *(void *)(v18 + 24) < result) {
    uint64_t v11 = v18;
  }
  *a1 = v11;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  a1[4] = v6;
  a1[5] = v7;
  a1[6] = v8;
  a1[7] = v9;
  a1[8] = v10;
  uint64_t v21 = *(void *)(v11 + 24);
  uint64_t v20 = *(void *)(v11 + 32);
  a1[10] = v21;
  if (v20 != v21)
  {
    unint64_t result = gdc::RegistryQueryView<gdc::All<md::ls::EnteringView const,md::ls::SupportsShadows const,md::ls::AssociationTileHandle const,md::ls::BaseMapTileHandle const,md::ls::TileViewConstantDataHandle const,md::ls::TileTransformConstantDataHandle const,md::ls::TileMatrix const,md::ls::TileShadowConstantDataHandle const>,gdc::Any<>,gdc::None<>>::Iterator::isValid(a1);
    if ((result & 1) == 0)
    {
      uint64_t v22 = v21 + 8;
      do
      {
        a1[10] = v22;
        if (v22 == v20) {
          break;
        }
        unint64_t result = gdc::RegistryQueryView<gdc::All<md::ls::EnteringView const,md::ls::SupportsShadows const,md::ls::AssociationTileHandle const,md::ls::BaseMapTileHandle const,md::ls::TileViewConstantDataHandle const,md::ls::TileTransformConstantDataHandle const,md::ls::TileMatrix const,md::ls::TileShadowConstantDataHandle const>,gdc::Any<>,gdc::None<>>::Iterator::isValid(a1);
        v22 += 8;
      }
      while (!result);
    }
  }
  return result;
}

uint64_t gdc::Registry::storage<md::ls::SupportsShadows>(int8x8_t *a1)
{
  unint64_t v10 = 0xE690FF1B9655D152;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xE690FF1B9655D152;
    if (*(void *)&v1 <= 0xE690FF1B9655D152) {
      unint64_t v3 = 0xE690FF1B9655D152 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xE690FF1B9655D152;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xE690FF1B9655D152)
      {
        if (v5[2] == 0xE690FF1B9655D152) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xE690FF1B9655D152) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xE690FF1B9655D152) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A7ACE4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareFlyoverS2TransformConstantDataHandle>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareFlyoverS2TransformConstantDataHandle>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A7B1C8(_Unwind_Exception *a1)
{
  std::function<void ()(md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&)>::~function((void *)(v2 - 184));
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>::Model<ecs2::RuntimeQuery<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>::Model<ecs2::RuntimeQuery<md::ls::FlyoverCommonS2TransformHandle &,md::ls::BaseMapTileHandle const&>>::each(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::BaseMapTileHandle>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::FlyoverCommonS2TransformHandle>(v3);
  uint64_t v6 = v5;
  unint64_t v7 = v5 + 4;
  if (v4[8] - v4[7] >= v5[8] - v5[7]) {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v58, v8, v5, v4, *(void *)(v8 + 24));
  if (v4[8] - v4[7] >= v6[8] - v6[7]) {
    uint64_t v9 = (uint64_t)v7;
  }
  else {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v56, v9, v6, v4, *(void *)(v9 + 32));
  unint64_t v10 = (uint64_t (**)(void))&ecs2::Runtime::_localEntity;
  if (v57 == v61) {
    goto LABEL_55;
  }
  uint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *uint64_t v12 = *v11;
    unint64_t v13 = *v11;
    unint64_t v14 = HIDWORD(*v11);
    unint64_t v15 = v13 >> 39;
    uint64_t v16 = v6[4];
    if (v13 >> 39 >= (v6[5] - v16) >> 3) {
      goto LABEL_17;
    }
    uint64_t v17 = *(void *)(v16 + 8 * v15);
    if (!v17) {
      goto LABEL_17;
    }
    unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v13) & 0x7F));
    uint64_t v20 = v6[7];
    uint64_t v19 = v6[8];
    if (v18 >= (v19 - v20) >> 3) {
      goto LABEL_17;
    }
    uint64_t v21 = v20 + 8 * v18;
    BOOL v22 = v21 != v19 && *(_DWORD *)(v21 + 4) == v14;
    if (v22)
    {
      uint64_t v23 = v6[11];
      uint64_t v24 = v6[10] + 8 * v18;
    }
    else
    {
LABEL_17:
      uint64_t v23 = v6[11];
      uint64_t v24 = v23;
    }
    uint64_t v25 = v24 == v23 ? 0 : v24;
    uint64_t v26 = v4[4];
    if (v15 < (v4[5] - v26) >> 3)
    {
      uint64_t v27 = *(void *)(v26 + 8 * v15);
      if (v27)
      {
        unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v13) & 0x7F));
        uint64_t v30 = v4[7];
        uint64_t v29 = v4[8];
        if (v28 < (v29 - v30) >> 3)
        {
          uint64_t v31 = v30 + 8 * v28;
          if (v31 != v29 && *(_DWORD *)(v31 + 4) == v14) {
            break;
          }
        }
      }
    }
    uint64_t v33 = v4[11];
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a2 + 24);
    if (!v35) {
      goto LABEL_54;
    }
LABEL_29:
    if (v34 == v33) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v25, v36);
    uint64_t v38 = v61;
    uint64_t v11 = *(unint64_t **)(v58 + 32);
    if (++v61 != v11)
    {
      uint64_t v39 = v59[4];
      unint64_t v40 = (v59[5] - v39) >> 3;
      BOOL v41 = v38 + 2;
      while (1)
      {
        unint64_t v42 = *((unsigned int *)v41 - 1);
        unint64_t v43 = v42 >> 7;
        if (v42 >> 7 < v40)
        {
          uint64_t v44 = *(void *)(v39 + 8 * v43);
          if (v44)
          {
            unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
            uint64_t v46 = v59[7];
            uint64_t result = v59[8];
            if (v45 < (result - v46) >> 3)
            {
              uint64_t v47 = v46 + 8 * v45;
              if (v47 != result && *(_DWORD *)(v47 + 4) == v42)
              {
                uint64_t v49 = v60[4];
                uint64_t result = v60[5] - v49;
                if (v43 < result >> 3)
                {
                  uint64_t v50 = *(void *)(v49 + 8 * v43);
                  if (v50)
                  {
                    unint64_t v51 = *(unsigned __int16 *)(v50 + 2 * (v42 & 0x7F));
                    uint64_t v53 = v60[7];
                    uint64_t v52 = v60[8];
                    uint64_t result = v52 - v53;
                    if (v51 < (v52 - v53) >> 3)
                    {
                      uint64_t v54 = v53 + 8 * v51;
                      if (v54 != v52 && *(_DWORD *)(v54 + 4) == v42) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        BOOL v61 = v41;
        BOOL v22 = v41++ == v11;
        if (v22) {
          goto LABEL_9;
        }
      }
      uint64_t v11 = v41 - 1;
    }
LABEL_9:
    if (v57 == v11) {
      goto LABEL_56;
    }
  }
  uint64_t v33 = v4[11];
  uint64_t v34 = v4[10] + 8 * v28;
  uint64_t v35 = *(void *)(a2 + 24);
  if (v35) {
    goto LABEL_29;
  }
LABEL_54:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_55:
  uint64_t result = (*v10)();
  uint64_t v12 = (void *)result;
LABEL_56:
  *uint64_t v12 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::FlyoverCommonS2TransformHandle>(int8x8_t *a1)
{
  uint64_t v10 = 0x81BF69EEE736436;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x81BF69EEE736436;
    if (*(void *)&v1 <= 0x81BF69EEE736436uLL) {
      uint64_t v3 = 0x81BF69EEE736436uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x81BF69EEE736436;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x81BF69EEE736436)
      {
        if (v5[2] == 0x81BF69EEE736436) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x81BF69EEE736436) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x81BF69EEE736436) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A7B73C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t ecs2::Query<md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::DaVinciGroundRenderable> const&,md::ls::TileRenderableDataHandle const&>::Model<ecs2::RuntimeQuery<md::ls::BaseMapTileHandle const&,md::ls::TileRenderableTypeT<md::DaVinciGroundRenderable> const&,md::ls::TileRenderableDataHandle const&>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::BaseMapTileHandle>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::TileRenderableTypeT<md::DaVinciGroundRenderable>>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::TileRenderableDataHandle>(v3);
  uint64_t v10 = (void *)v6;
  uint64_t v11 = v4 + 4;
  if (v5[8] - v5[7] < v4[8] - v4[7]) {
    uint64_t v11 = v5 + 4;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) >= v11[4] - v11[3]) {
    uint64_t v12 = (uint64_t)v11;
  }
  else {
    uint64_t v12 = v6 + 32;
  }
  v82[0] = v12;
  v82[1] = v4;
  v82[2] = v5;
  v82[3] = v6;
  unint64_t v14 = *(void **)(v12 + 24);
  unint64_t v13 = *(void **)(v12 + 32);
  uint64_t v83 = v14;
  if (v13 != v14
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v82))
  {
    unint64_t v15 = v14 + 1;
    do
    {
      unint64_t v14 = v15;
      uint64_t v83 = v15;
      if (v15 == v13) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v82);
      unint64_t v15 = v14 + 1;
    }
    while (!isValid);
  }
  uint64_t v17 = &ecs2::Runtime::_localEntity;
  unint64_t v18 = ecs2::Runtime::_localEntity;
  if (v13 == v14) {
    goto LABEL_82;
  }
  uint64_t v19 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *uint64_t v19 = *v14;
    unint64_t v21 = *v14;
    uint64_t v22 = HIDWORD(*v14);
    unint64_t v23 = *v14 >> 39;
    uint64_t v24 = v4[4];
    if (v23 >= (v4[5] - v24) >> 3) {
      goto LABEL_23;
    }
    uint64_t v25 = *(void *)(v24 + 8 * v23);
    if (!v25) {
      goto LABEL_23;
    }
    unint64_t v26 = *(unsigned __int16 *)(v25 + 2 * (HIDWORD(v21) & 0x7F));
    uint64_t v28 = v4[7];
    uint64_t v27 = v4[8];
    if (v26 >= (v27 - v28) >> 3) {
      goto LABEL_23;
    }
    uint64_t v29 = v28 + 8 * v26;
    if (v29 != v27 && *(_DWORD *)(v29 + 4) == v22)
    {
      uint64_t v31 = v4[11];
      uint64_t v32 = v4[10] + 8 * v26;
    }
    else
    {
LABEL_23:
      uint64_t v31 = v4[11];
      uint64_t v32 = v31;
    }
    uint64_t v33 = v32 == v31 ? 0 : v32;
    if ((uint64_t v34 = v5[4], v23 < (v5[5] - v34) >> 3)
      && (uint64_t v35 = *(void *)(v34 + 8 * v23)) != 0
      && (unint64_t v36 = *(unsigned __int16 *)(v35 + 2 * (HIDWORD(v21) & 0x7F)), v38 = v5[7], v37 = v5[8], v36 < (v37 - v38) >> 3)
      && ((uint64_t v39 = v38 + 8 * v36, v39 != v37) ? (v40 = *(_DWORD *)(v39 + 4) == v22) : (v40 = 0), v40))
    {
      unint64_t v41 = v5[11];
      unint64_t v42 = v5[10] + v36;
    }
    else
    {
      unint64_t v41 = v5[11];
      unint64_t v42 = v41;
    }
    unint64_t v43 = v42 == v41 ? 0 : v42;
    uint64_t v44 = v10[4];
    if (v23 < (v10[5] - v44) >> 3)
    {
      uint64_t v45 = *(void *)(v44 + 8 * v23);
      if (v45)
      {
        unint64_t v46 = *(unsigned __int16 *)(v45 + 2 * (HIDWORD(v21) & 0x7F));
        uint64_t v48 = v10[7];
        uint64_t v47 = v10[8];
        if (v46 < (v47 - v48) >> 3)
        {
          uint64_t v49 = v48 + 8 * v46;
          if (v49 != v47 && *(_DWORD *)(v49 + 4) == v22) {
            break;
          }
        }
      }
    }
    uint64_t v51 = v10[11];
    uint64_t v52 = v51;
    uint64_t v53 = *(void *)(a2 + 24);
    if (!v53) {
      goto LABEL_81;
    }
LABEL_46:
    if (v52 == v51) {
      uint64_t v54 = 0;
    }
    else {
      uint64_t v54 = v52;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(*(void *)v53 + 48))(v53, v33, v43, v54);
    uint64_t v56 = *(void **)(v12 + 32);
    uint64_t v20 = v14 + 1;
    uint64_t v83 = v14 + 1;
    if (v14 + 1 != v56)
    {
      uint64_t v57 = v4[4];
      uint64_t v59 = v4[7];
      uint64_t v58 = v4[8];
      uint64_t v60 = v5[4];
      uint64_t result = v5[7];
      uint64_t v61 = v5[8];
      uint64_t v62 = v10[4];
      uint64_t v64 = v10[7];
      uint64_t v63 = v10[8];
      while (1)
      {
        unint64_t v65 = *((unsigned int *)v20 + 1);
        unint64_t v66 = v65 >> 7;
        if (v65 >> 7 < (v4[5] - v57) >> 3)
        {
          uint64_t v67 = *(void *)(v57 + 8 * v66);
          if (v67)
          {
            uint64_t v68 = v65 & 0x7F;
            unint64_t v69 = *(unsigned __int16 *)(v67 + 2 * v68);
            if ((v58 - v59) >> 3 > v69)
            {
              uint64_t v70 = v59 + 8 * v69;
              BOOL v71 = v70 != v58 && *(_DWORD *)(v70 + 4) == v65;
              if (v71 && v66 < (v5[5] - v60) >> 3)
              {
                uint64_t v73 = *(void *)(v60 + 8 * v66);
                if (v73)
                {
                  unint64_t v74 = *(unsigned __int16 *)(v73 + 2 * v68);
                  if ((v61 - result) >> 3 > v74)
                  {
                    unint64_t v75 = result + 8 * v74;
                    BOOL v76 = v75 != v61 && *(_DWORD *)(v75 + 4) == v65;
                    if (v76 && v66 < (v10[5] - v62) >> 3)
                    {
                      uint64_t v78 = *(void *)(v62 + 8 * v66);
                      if (v78)
                      {
                        unint64_t v79 = *(unsigned __int16 *)(v78 + 2 * v68);
                        if ((v63 - v64) >> 3 > v79)
                        {
                          uint64_t v80 = v64 + 8 * v79;
                          if (*(_DWORD *)(v80 + 4) == v65 && v80 != v63) {
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (++v20 == v56)
        {
          uint64_t v20 = v56;
          goto LABEL_14;
        }
      }
      uint64_t v56 = v20;
LABEL_14:
      uint64_t v83 = v20;
    }
    unint64_t v14 = v56;
    if (v13 == v56) {
      goto LABEL_83;
    }
  }
  uint64_t v51 = v10[11];
  uint64_t v52 = v10[10] + 8 * v46;
  uint64_t v53 = *(void *)(a2 + 24);
  if (v53) {
    goto LABEL_46;
  }
LABEL_81:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_82:
  uint64_t result = ((uint64_t (*)(uint64_t (**)(void), uint64_t, uint64_t, uint64_t))v18)(v17, v7, v8, v9);
  uint64_t v19 = (void *)result;
LABEL_83:
  *uint64_t v19 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::BaseMapTileHandle>(int8x8_t *a1)
{
  uint64_t v10 = 0x695C99F828CA9E84;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x695C99F828CA9E84;
    if (*(void *)&v1 <= 0x695C99F828CA9E84uLL) {
      uint64_t v3 = 0x695C99F828CA9E84uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x695C99F828CA9E84;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x695C99F828CA9E84)
      {
        if (v5[2] == 0x695C99F828CA9E84) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x695C99F828CA9E84) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x695C99F828CA9E84) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A7BD58(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::RegistryQueryView<gdc::All<md::ls::RegisterHandle const,md::ls::RenderablesCount,md::ls::MapDataTypeV const,md::ls::CheckIfReadyToProcess const>,gdc::Any<md::ls::FlyoverOctileKey const,md::ls::BaseMapTileHandle const,md::ls::WillEnterView const>,gdc::None<>>::begin(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = a2[6];
  uint64_t v4 = *a2;
  uint64_t v5 = a2[1];
  uint64_t v6 = a2[2];
  uint64_t v7 = *a2 + 32;
  if (!*a2) {
    uint64_t v7 = 0;
  }
  uint64_t v8 = v3 + 32;
  if (!v3) {
    uint64_t v8 = 0;
  }
  uint64_t v9 = v5 + 32;
  if (!v5) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = v6 + 32;
  if (!v6) {
    uint64_t v10 = 0;
  }
  uint64_t result = *(void *)(v7 + 24);
  if (*(void *)(v8 + 32) - *(void *)(v8 + 24) < (unint64_t)(*(void *)(v7 + 32) - result)) {
    uint64_t v7 = v8;
  }
  if (*(void *)(v9 + 32) - *(void *)(v9 + 24) < *(void *)(v7 + 32) - *(void *)(v7 + 24)) {
    uint64_t v7 = v9;
  }
  if (*(void *)(v10 + 32) - *(void *)(v10 + 24) < *(void *)(v7 + 32) - *(void *)(v7 + 24)) {
    uint64_t v7 = v10;
  }
  *a1 = v7;
  a1[1] = v4;
  a1[2] = v3;
  a1[3] = v5;
  a1[4] = v6;
  uint64_t v13 = *(void *)(v7 + 24);
  uint64_t v12 = *(void *)(v7 + 32);
  a1[6] = v13;
  if (v12 != v13)
  {
    uint64_t result = gdc::RegistryQueryView<gdc::All<md::ls::RequiresShaderTextureID<Flyover::NightTexture> const,md::ls::TextureHandleForType<Flyover::NightTexture> const,md::ls::FlyoverInstance const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(a1);
    if ((result & 1) == 0)
    {
      uint64_t v14 = v13 + 8;
      do
      {
        a1[6] = v14;
        if (v14 == v12) {
          break;
        }
        uint64_t result = gdc::RegistryQueryView<gdc::All<md::ls::RequiresShaderTextureID<Flyover::NightTexture> const,md::ls::TextureHandleForType<Flyover::NightTexture> const,md::ls::FlyoverInstance const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(a1);
        v14 += 8;
      }
      while (!result);
    }
  }
  return result;
}

uint64_t gdc::Registry::storage<md::ls::CheckIfReadyToProcess>(int8x8_t *a1)
{
  unint64_t v10 = 0xD14836FBCB6E3943;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xD14836FBCB6E3943;
    if (*(void *)&v1 <= 0xD14836FBCB6E3943) {
      unint64_t v3 = 0xD14836FBCB6E3943 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xD14836FBCB6E3943;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xD14836FBCB6E3943)
      {
        if (v5[2] == 0xD14836FBCB6E3943) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xD14836FBCB6E3943) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xD14836FBCB6E3943) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A7C0BC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::FlyoverOctileKey>(int8x8_t *a1)
{
  uint64_t v10 = 0x53EA4A91D91C8985;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x53EA4A91D91C8985;
    if (*(void *)&v1 <= 0x53EA4A91D91C8985uLL) {
      uint64_t v3 = 0x53EA4A91D91C8985uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x53EA4A91D91C8985;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x53EA4A91D91C8985)
      {
        if (v5[2] == 0x53EA4A91D91C8985) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x53EA4A91D91C8985) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x53EA4A91D91C8985) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A7C32C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::WillEnterView>(int8x8_t *a1)
{
  unint64_t v10 = 0xF3801DCCD1DDBED8;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xF3801DCCD1DDBED8;
    if (*(void *)&v1 <= 0xF3801DCCD1DDBED8) {
      unint64_t v3 = 0xF3801DCCD1DDBED8 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xF3801DCCD1DDBED8;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xF3801DCCD1DDBED8)
      {
        if (v5[2] == 0xF3801DCCD1DDBED8) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xF3801DCCD1DDBED8) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xF3801DCCD1DDBED8) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A7C59C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_0,std::allocator<md::ita::CheckIfReadyToProcess::operator()(ecs2::Query<md::ls::RegisterHandle const&,md::ls::RenderablesCount &,md::ls::MapDataTypeV const&,md::ls::CheckIfReadyToProcess const&,md::ls::FlyoverOctileKey const*,md::ls::BaseMapTileHandle const*,md::ls::WillEnterView const*>)::$_0>,void ()(md::StyleManagerEvent)>::operator()(uint64_t result, unsigned __int8 *a2)
{
  if (*a2 <= 5u) {
    **(unsigned char **)(result + 8) = 1;
  }
  return result;
}

void gdc::EnteringCollector<md::components::MeshInstance>::~EnteringCollector(gdc::EntityCollector *a1)
{
  *(void *)a1 = &unk_1EF558E40;
  gdc::RegistrySignalCollector<md::components::MeshInstance>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E40;
  gdc::RegistrySignalCollector<md::components::MeshInstance>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

void sub_1A1A7C654(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void gdc::EnteringCollector<md::components::MeshInstance>::observe(int8x8_t **a1, int8x8_t *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1[7] != a2) {
    ((void (*)(int8x8_t **))(*a1)[3])(a1);
  }
  a1[7] = a2;
  uint64_t v4 = gdc::Registry::storage<md::components::MeshInstance>(a2);
  uint64_t v13 = (void (**)(void **))&unk_1EF521398;
  uint64_t v14 = a1;
  unint64_t v15 = (void **)&v13;
  uint64_t v5 = gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect(v4 + 152, &v13);
  if (v15 == (void **)&v13)
  {
    v13[4]((void **)&v13);
  }
  else if (v15)
  {
    (*((void (**)(void))*v15 + 5))();
  }
  if (v5 != -1)
  {
    uint64_t v6 = a1 + 12;
    {
      uint64_t v6 = a1 + 12;
      if (v10)
      {
        uint64_t v11 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::Counter::nextId(void)::counter++;
        gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId = v11;
        uint64_t v6 = a1 + 12;
      }
    }
    v6[gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId] = (int8x8_t *)v5;
  }
  uint64_t v7 = gdc::Registry::storage<md::components::MeshInstance>(a1[7]);
  uint64_t v13 = (void (**)(void **))&unk_1EF521350;
  uint64_t v14 = a1;
  unint64_t v15 = (void **)&v13;
  uint64_t v8 = gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect(v7 + 200, &v13);
  if (v15 == (void **)&v13)
  {
    v13[4]((void **)&v13);
    if (v8 == -1) {
      return;
    }
    goto LABEL_16;
  }
  if (v15) {
    (*((void (**)(void))*v15 + 5))();
  }
  if (v8 != -1)
  {
LABEL_16:
    uint64_t v9 = a1 + 14;
    {
      {
        uint64_t v12 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::Counter::nextId(void)::counter++;
        gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId = v12;
      }
    }
    v9[gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId] = (int8x8_t *)v8;
  }
}

void sub_1A1A7C908(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 != v13)
  {
    if (a13) {
      (*(void (**)(void))(*(void *)a13 + 40))();
    }
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  _Unwind_Resume(exception_object);
}

void gdc::RegistrySignalCollector<md::components::MeshInstance>::unobserve(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    {
      uint64_t v8 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::Counter::nextId(void)::counter++;
      gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId = v8;
    }
    unint64_t v2 = *(void *)(a1
                   + 96
                   + 8
                   * gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId);
    if (v2 != -1)
    {
      uint64_t v3 = gdc::Registry::storage<md::components::MeshInstance>(*(int8x8_t **)(a1 + 56));
      std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__erase_unique<unsigned long>((uint64_t *)(v3 + 160), v2);
    }
    {
      uint64_t v9 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::Counter::nextId(void)::counter++;
      gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId = v9;
    }
    unint64_t v4 = *(void *)(a1
                   + 104
                   + 8
                   * gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId);
    if (v4 != -1)
    {
      uint64_t v5 = gdc::Registry::storage<md::components::MeshInstance>(*(int8x8_t **)(a1 + 56));
      std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__erase_unique<unsigned long>((uint64_t *)(v5 + 112), v4);
    }
    {
      uint64_t v10 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::Counter::nextId(void)::counter++;
      gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId = v10;
    }
    unint64_t v6 = *(void *)(a1
                   + 112
                   + 8
                   * gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::MeshInstance>,unsigned long long>::getId<md::components::MeshInstance>(void)::localId);
    if (v6 != -1)
    {
      uint64_t v7 = gdc::Registry::storage<md::components::MeshInstance>(*(int8x8_t **)(a1 + 56));
      std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__erase_unique<unsigned long>((uint64_t *)(v7 + 208), v6);
    }
  }
  *(void *)(a1 + 40) = *(void *)(a1 + 32);
  *(void *)(a1 + 56) = 0;
}

void gdc::UpdateCollector<md::components::Visibility>::~UpdateCollector(gdc::EntityCollector *a1)
{
  *(void *)a1 = &unk_1EF558E10;
  gdc::RegistrySignalCollector<md::components::Visibility>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E10;
  gdc::RegistrySignalCollector<md::components::Visibility>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

void sub_1A1A7CB68(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void gdc::UpdateCollector<md::components::Visibility>::observe(int8x8_t **a1, int8x8_t *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1[7] != a2) {
    ((void (*)(int8x8_t **))(*a1)[3])(a1);
  }
  a1[7] = a2;
  uint64_t v4 = gdc::Registry::storage<md::components::Visibility>(a2);
  uint64_t v13 = (void (**)(void **))&unk_1EF521278;
  uint64_t v14 = a1;
  unint64_t v15 = (void **)&v13;
  uint64_t v5 = gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect(v4 + 104, &v13);
  if (v15 == (void **)&v13)
  {
    v13[4]((void **)&v13);
  }
  else if (v15)
  {
    (*((void (**)(void))*v15 + 5))();
  }
  if (v5 != -1)
  {
    unint64_t v6 = a1 + 13;
    {
      unint64_t v6 = a1 + 13;
      if (v10)
      {
        uint64_t v11 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::Counter::nextId(void)::counter++;
        gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId = v11;
        unint64_t v6 = a1 + 13;
      }
    }
    v6[gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId] = (int8x8_t *)v5;
  }
  uint64_t v7 = gdc::Registry::storage<md::components::Visibility>(a1[7]);
  uint64_t v13 = (void (**)(void **))&unk_1EF521230;
  uint64_t v14 = a1;
  unint64_t v15 = (void **)&v13;
  uint64_t v8 = gdc::Signal<gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>>::connect(v7 + 200, &v13);
  if (v15 == (void **)&v13)
  {
    v13[4]((void **)&v13);
    if (v8 == -1) {
      return;
    }
    goto LABEL_16;
  }
  if (v15) {
    (*((void (**)(void))*v15 + 5))();
  }
  if (v8 != -1)
  {
LABEL_16:
    uint64_t v9 = a1 + 14;
    {
      {
        uint64_t v12 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::Counter::nextId(void)::counter++;
        gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId = v12;
      }
    }
    v9[gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId] = (int8x8_t *)v8;
  }
}

void sub_1A1A7CE1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 != v13)
  {
    if (a13) {
      (*(void (**)(void))(*(void *)a13 + 40))();
    }
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  _Unwind_Resume(exception_object);
}

uint64_t gdc::Registry::storage<md::components::Visibility>(int8x8_t *a1)
{
  unint64_t v10 = 0xF44C196EC679B51CLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xF44C196EC679B51CLL;
    if (*(void *)&v1 <= 0xF44C196EC679B51CLL) {
      unint64_t v3 = 0xF44C196EC679B51CLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xF44C196EC679B51CLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xF44C196EC679B51CLL)
      {
        if (v5[2] == 0xF44C196EC679B51CLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xF44C196EC679B51CLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xF44C196EC679B51CLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A7D0DC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void gdc::RegistrySignalCollector<md::components::Visibility>::unobserve(uint64_t a1)
{
  if (*(void *)(a1 + 56))
  {
    {
      uint64_t v8 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::Counter::nextId(void)::counter++;
      gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId = v8;
    }
    unint64_t v2 = *(void *)(a1
                   + 96
                   + 8
                   * gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId);
    if (v2 != -1)
    {
      uint64_t v3 = gdc::Registry::storage<md::components::Visibility>(*(int8x8_t **)(a1 + 56));
      std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__erase_unique<unsigned long>((uint64_t *)(v3 + 160), v2);
    }
    {
      uint64_t v9 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::Counter::nextId(void)::counter++;
      gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId = v9;
    }
    unint64_t v4 = *(void *)(a1
                   + 104
                   + 8
                   * gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId);
    if (v4 != -1)
    {
      uint64_t v5 = gdc::Registry::storage<md::components::Visibility>(*(int8x8_t **)(a1 + 56));
      std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__erase_unique<unsigned long>((uint64_t *)(v5 + 112), v4);
    }
    {
      uint64_t v10 = gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::Counter::nextId(void)::counter++;
      gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId = v10;
    }
    unint64_t v6 = *(void *)(a1
                   + 112
                   + 8
                   * gdc::FamilyInfo<gdc::RegistrySignalCollector<md::components::Visibility>,unsigned long long>::getId<md::components::Visibility>(void)::localId);
    if (v6 != -1)
    {
      uint64_t v7 = gdc::Registry::storage<md::components::Visibility>(*(int8x8_t **)(a1 + 56));
      std::__hash_table<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::__unordered_map_hasher<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::hash<unsigned long>,std::equal_to<unsigned long>,true>,std::__unordered_map_equal<unsigned long,std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>,std::equal_to<unsigned long>,std::hash<unsigned long>,true>,std::allocator<std::__hash_value_type<unsigned long,std::function<void ()(gdc::Registry *,std::span<gdc::Entity,18446744073709551615ul>)>>>>::__erase_unique<unsigned long>((uint64_t *)(v7 + 208), v6);
    }
  }
  *(void *)(a1 + 40) = *(void *)(a1 + 32);
  *(void *)(a1 + 56) = 0;
}

void gdc::UpdateCollector<md::components::Material>::~UpdateCollector(gdc::EntityCollector *a1)
{
  *(void *)a1 = &unk_1EF558E70;
  gdc::RegistrySignalCollector<md::components::Material>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
  JUMPOUT(0x1A6239270);
}

{
  uint64_t vars8;

  *(void *)a1 = &unk_1EF558E70;
  gdc::RegistrySignalCollector<md::components::Material>::unobserve((uint64_t)a1);
  gdc::EntityCollector::~EntityCollector(a1);
}

void sub_1A1A7D2EC(_Unwind_Exception *a1)
{
  gdc::EntityCollector::~EntityCollector(v1);
  _Unwind_Resume(a1);
}

void gdc::EntityCollector::~EntityCollector(gdc::EntityCollector *this)
{
  *(void *)this = &unk_1EF554F30;
  *((void *)this + 5) = *((void *)this + 4);
  *((void *)this + 7) = 0;
  unint64_t v2 = (char *)this + 64;
  uint64_t v3 = (char *)*((void *)this + 11);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    unint64_t v4 = (void *)*((void *)this + 4);
    if (v4)
    {
LABEL_5:
      *((void *)this + 5) = v4;
      operator delete(v4);
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    unint64_t v4 = (void *)*((void *)this + 4);
    if (v4) {
      goto LABEL_5;
    }
  }
  uint64_t v5 = (void *)*((void *)this + 1);
  if (v5)
  {
    unint64_t v6 = (void *)*((void *)this + 2);
    uint64_t v7 = (void *)*((void *)this + 1);
    if (v6 != v5)
    {
      do
      {
        uint64_t v9 = *--v6;
        uint64_t v8 = v9;
        void *v6 = 0;
        if (v9) {
          MEMORY[0x1A6239270](v8, 0x1000C40104B78CFLL);
        }
      }
      while (v6 != v5);
      uint64_t v7 = (void *)*((void *)this + 1);
    }
    *((void *)this + 2) = v5;
    operator delete(v7);
  }
}

{
  uint64_t vars8;

  gdc::EntityCollector::~EntityCollector(this);
  JUMPOUT(0x1A6239270);
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::operator()()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A1A7D6C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, uint64_t *);
  std::function<BOOL ()(gdc::Registry const*,gdc::Entity)>::~function((uint64_t *)va1);
  gdc::RegistrySignalCollector<md::components::Visibility>::~RegistrySignalCollector(v2);
  if (v8 == (uint64_t *)va)
  {
    (*(void (**)(uint64_t *))(v4 + 32))((uint64_t *)va);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  MEMORY[0x1A6239270](v2, 0x10A1C4026EC0EDELL);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_2,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_2>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::operator()()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A1A7D9F4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, uint64_t *);
  std::function<BOOL ()(gdc::Registry const*,gdc::Entity)>::~function((uint64_t *)va1);
  gdc::RegistrySignalCollector<md::components::Material>::~RegistrySignalCollector(v2);
  if (v8 == (uint64_t *)va)
  {
    (*(void (**)(uint64_t *))(v4 + 32))((uint64_t *)va);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  MEMORY[0x1A6239270](v2, 0x10A1C4026EC0EDELL);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_3,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_3>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::operator()()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A1A7DD28(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, uint64_t *);
  std::function<BOOL ()(gdc::Registry const*,gdc::Entity)>::~function((uint64_t *)va1);
  gdc::RegistrySignalCollector<md::components::MeshInstance>::~RegistrySignalCollector(v2);
  if (v8 == (uint64_t *)va)
  {
    (*(void (**)(uint64_t *))(v4 + 32))((uint64_t *)va);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  MEMORY[0x1A6239270](v2, 0x10A1C4026EC0EDELL);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_4,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_4>,std::unique_ptr<gdc::EntityCollector> ()(gdc::Registry *)>::operator()()
{
  uint64_t v0 = *MEMORY[0x1E4F143B8];
  operator new();
}

void sub_1A1A7E05C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, uint64_t *);
  std::function<BOOL ()(gdc::Registry const*,gdc::Entity)>::~function((uint64_t *)va1);
  gdc::RegistrySignalCollector<md::components::Material>::~RegistrySignalCollector(v2);
  if (v8 == (uint64_t *)va)
  {
    (*(void (**)(uint64_t *))(v4 + 32))((uint64_t *)va);
  }
  else if (v8)
  {
    (*(void (**)(void))(*v8 + 40))();
  }
  MEMORY[0x1A6239270](v2, 0x10A1C4026EC0EDELL);
  _Unwind_Resume(a1);
}

void *std::__function::__value_func<BOOL ()(gdc::Registry const*,gdc::Entity)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    uint64_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      uint64_t result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void std::__function::__func<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_0,std::allocator<md::MeshRenderableLogic::MeshRenderableLogic(std::shared_ptr<md::RegistryManager> const&,std::shared_ptr<md::RunLoopController> const&,geo::TaskQueue *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_0>,BOOL ()(gdc::Registry const*,gdc::Entity)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF574C10;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareCulledDepthPrePassSlice>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareCulledDepthPrePassSlice>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A7E868(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v15)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>::Model<ecs2::RuntimeQuery<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)8> const&>>::~Model()
{
}

void ecs2::Query<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>::Model<ecs2::RuntimeQuery<md::ls::VisibilityGroupID const&,md::ls::SliceAssignmentT<(md::SliceType)1> const&>>::~Model()
{
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareCulledShadowSlice>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareCulledShadowSlice>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A7EE04(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

char *std::__hash_table<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned long>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,std::unordered_set<unsigned long>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,std::unordered_set<unsigned long>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t *a1, unsigned int a2, _DWORD *a3)
{
  unint64_t v6 = a2;
  unint64_t v7 = a1[1];
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    uint64_t v9 = *(void ***)(*a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = (char *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = *((void *)v10 + 1);
            if (v12 == a2)
            {
              if (*((_DWORD *)v10 + 4) == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_23;
            }
            uint64_t v10 = *(char **)v10;
            if (!v10) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v11 = *((void *)v10 + 1);
          if (v11 == a2)
          {
            if (*((_DWORD *)v10 + 4) == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = *(char **)v10;
        }
        while (v10);
      }
    }
  }
LABEL_23:
  uint64_t v13 = a1 + 2;
  uint64_t v10 = (char *)operator new(0x40uLL);
  *(void *)uint64_t v10 = 0;
  *((void *)v10 + 1) = v6;
  *((_DWORD *)v10 + 4) = *a3;
  *(_OWORD *)(v10 + 24) = 0u;
  *(_OWORD *)(v10 + 40) = 0u;
  *((_DWORD *)v10 + 14) = 1065353216;
  float v14 = (float)(unint64_t)(a1[3] + 1);
  float v15 = *((float *)a1 + 8);
  if (v7 && (float)(v15 * (float)v7) >= v14)
  {
    unint64_t v6 = v3;
    goto LABEL_73;
  }
  BOOL v16 = 1;
  if (v7 >= 3) {
    BOOL v16 = (v7 & (v7 - 1)) != 0;
  }
  unint64_t v17 = v16 | (2 * v7);
  unint64_t v18 = vcvtps_u32_f32(v14 / v15);
  if (v17 <= v18) {
    size_t prime = v18;
  }
  else {
    size_t prime = v17;
  }
  if (prime == 1)
  {
    size_t prime = 2;
  }
  else if ((prime & (prime - 1)) != 0)
  {
    size_t prime = std::__next_prime(prime);
    unint64_t v7 = a1[1];
  }
  if (prime > v7)
  {
LABEL_36:
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v20 = operator new(8 * prime);
    unint64_t v21 = (void *)*a1;
    *a1 = (uint64_t)v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v22++) = 0;
    while (prime != v22);
    unint64_t v23 = (void *)*v13;
    if (!*v13) {
      goto LABEL_60;
    }
    size_t v24 = v23[1];
    size_t v25 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v26 = v24 & v25;
      *(void *)(*a1 + 8 * v26) = v13;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v28 = i[1] & v25;
        if (v28 == v26)
        {
          unint64_t v23 = i;
        }
        else if (*(void *)(*a1 + 8 * v28))
        {
          *unint64_t v23 = *i;
          uint64_t v29 = 8 * v28;
          void *i = **(void **)(*a1 + v29);
          **(void **)(*a1 + v29) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v28) = v23;
          unint64_t v23 = i;
          size_t v26 = v28;
        }
      }
LABEL_60:
      unint64_t v7 = prime;
      goto LABEL_61;
    }
    if (v24 >= prime) {
      v24 %= prime;
    }
    *(void *)(*a1 + 8 * v24) = v13;
    uint64_t v33 = (void *)*v23;
    if (!*v23) {
      goto LABEL_60;
    }
    while (1)
    {
      size_t v35 = v33[1];
      if (v35 >= prime) {
        v35 %= prime;
      }
      if (v35 != v24)
      {
        if (!*(void *)(*a1 + 8 * v35))
        {
          *(void *)(*a1 + 8 * v35) = v23;
          goto LABEL_65;
        }
        *unint64_t v23 = *v33;
        uint64_t v34 = 8 * v35;
        *uint64_t v33 = **(void **)(*a1 + v34);
        **(void **)(*a1 + v34) = v33;
        uint64_t v33 = v23;
      }
      size_t v35 = v24;
LABEL_65:
      unint64_t v23 = v33;
      uint64_t v33 = (void *)*v33;
      size_t v24 = v35;
      if (!v33) {
        goto LABEL_60;
      }
    }
  }
  if (prime >= v7) {
    goto LABEL_61;
  }
  unint64_t v30 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
  if (v7 < 3 || (uint8x8_t v31 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v31.i16[0] = vaddlv_u8(v31), v31.u32[0] > 1uLL))
  {
    unint64_t v30 = std::__next_prime(v30);
  }
  else
  {
    uint64_t v32 = 1 << -(char)__clz(v30 - 1);
    if (v30 >= 2) {
      unint64_t v30 = v32;
    }
  }
  if (prime <= v30) {
    size_t prime = v30;
  }
  if (prime < v7)
  {
    if (!prime)
    {
      BOOL v40 = (void *)*a1;
      *a1 = 0;
      if (v40) {
        operator delete(v40);
      }
      unint64_t v7 = 0;
      a1[1] = 0;
      goto LABEL_61;
    }
    goto LABEL_36;
  }
  unint64_t v7 = a1[1];
LABEL_61:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v6) {
      v6 %= v7;
    }
  }
  else
  {
    unint64_t v6 = (v7 - 1) & v6;
  }
LABEL_73:
  uint64_t v36 = *a1;
  uint64_t v37 = *(void **)(*a1 + 8 * v6);
  if (v37)
  {
    *(void *)uint64_t v10 = *v37;
LABEL_81:
    *uint64_t v37 = v10;
    goto LABEL_82;
  }
  *(void *)uint64_t v10 = *v13;
  *uint64_t v13 = v10;
  *(void *)(v36 + 8 * v6) = v13;
  if (*(void *)v10)
  {
    unint64_t v38 = *(void *)(*(void *)v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    uint64_t v37 = (void *)(*a1 + 8 * v38);
    goto LABEL_81;
  }
LABEL_82:
  ++a1[3];
  return v10;
}

void sub_1A1A7F2D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::Registry *,std::unordered_map<gdc::Entity,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *,std::hash<gdc::Entity>,std::equal_to<gdc::Entity>,std::allocator<std::pair<gdc::Entity const,gdc::components::RegistryBridgeMap<gdc::Entity>::RemoteBridgeNode *>>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>>::~Model()
{
}

unint64_t *ecs2::Query<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::SliceAssignmentT<(md::SliceType)3> const&,md::ls::VisibilityGroupID const&,md::ls::SharedRenderableDataHandle const&,md::ls::AppliedWantsDynamicShadowBounds const*,md::BoundData const&,md::ls::BoundZScale const*,md::ls::BoundZAdjust const*>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  unint64_t v3 = (void *)gdc::Registry::storage<md::ls::MeshRenderableID>(v2);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)3>>(v2);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::VisibilityGroupID>(v2);
  unint64_t v6 = (void *)gdc::Registry::storage<md::ls::SharedRenderableDataHandle>(v2);
  unint64_t v7 = (void *)gdc::Registry::storage<md::BoundData>(v2);
  uint64_t v8 = gdc::Registry::storage<md::ls::AppliedWantsDynamicShadowBounds>(v2);
  uint64_t v9 = (void *)gdc::Registry::storage<md::ls::BoundZScale>(v2);
  uint64_t v10 = (void *)gdc::Registry::storage<md::ls::BoundZAdjust>(v2);
  v145[0] = (uint64_t)v3;
  v145[1] = (uint64_t)v4;
  v145[2] = (uint64_t)v5;
  v145[3] = (uint64_t)v6;
  v145[4] = (uint64_t)v7;
  v145[5] = v8;
  uint64_t v142 = (void *)v8;
  v145[6] = (uint64_t)v9;
  v145[7] = (uint64_t)v10;
  gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::RenderItemUpdate const,md::ls::DataIDSetToUse const,md::ls::RequiredPipelinePoolID const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::begin(v143, v145);
  unint64_t v11 = v3 + 4;
  if (v4[8] - v4[7] < v3[8] - v3[7]) {
    unint64_t v11 = v4 + 4;
  }
  if (v5[8] - v5[7] < v11[4] - v11[3]) {
    unint64_t v11 = v5 + 4;
  }
  if (v6[8] - v6[7] < v11[4] - v11[3]) {
    unint64_t v11 = v6 + 4;
  }
  if (v7[8] - v7[7] < v11[4] - v11[3]) {
    unint64_t v11 = v7 + 4;
  }
  uint64_t v12 = v144;
  uint64_t v140 = (unint64_t *)v11[4];
  if (v140 == v144)
  {
    uint64_t result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
LABEL_145:
    unint64_t *result = 0xFFFFFFFF00000000;
  }
  else
  {
    uint64_t result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    float v14 = (void *)v143[1];
    uint64_t v138 = result;
    uint64_t v139 = v143[0];
    float v15 = (void *)v143[2];
    uint64_t v136 = (void *)v143[4];
    uint64_t v137 = (void *)v143[3];
    unsigned int v135 = (void *)v143[5];
    BOOL v16 = v142;
    while (1)
    {
      unint64_t *result = *v12;
      unint64_t v17 = *v12;
      unint64_t v18 = HIDWORD(*v12);
      unint64_t v19 = *v12 >> 39;
      uint64_t v20 = v3[4];
      if (v19 < (v3[5] - v20) >> 3
        && (uint64_t v21 = *(void *)(v20 + 8 * v19)) != 0
        && (unint64_t v22 = *(unsigned __int16 *)(v21 + 2 * (HIDWORD(v17) & 0x7F)),
            uint64_t v24 = v3[7],
            uint64_t v23 = v3[8],
            v22 < (v23 - v24) >> 3)
        && ((uint64_t v25 = v24 + 8 * v22, v25 != v23) ? (v26 = *(_DWORD *)(v25 + 4) == v18) : (v26 = 0), v26))
      {
        uint64_t v27 = v3[11];
        uint64_t v28 = v3[10] + 8 * v22;
      }
      else
      {
        uint64_t v27 = v3[11];
        uint64_t v28 = v27;
      }
      if (v28 == v27) {
        uint64_t v29 = 0;
      }
      else {
        uint64_t v29 = v28;
      }
      uint64_t v30 = v4[4];
      if (v19 < (v4[5] - v30) >> 3
        && (uint64_t v31 = *(void *)(v30 + 8 * v19)) != 0
        && (unint64_t v32 = *(unsigned __int16 *)(v31 + 2 * (HIDWORD(v17) & 0x7F)),
            uint64_t v34 = v4[7],
            uint64_t v33 = v4[8],
            v32 < (v33 - v34) >> 3)
        && ((v35 = v34 + 8 * v32, v35 != v33) ? (BOOL v36 = *(_DWORD *)(v35 + 4) == v18) : (BOOL v36 = 0), v36))
      {
        uint64_t v37 = v4[11];
        uint64_t v38 = v4[10] + 4 * v32;
      }
      else
      {
        uint64_t v37 = v4[11];
        uint64_t v38 = v37;
      }
      if (v38 == v37) {
        uint64_t v39 = 0;
      }
      else {
        uint64_t v39 = v38;
      }
      uint64_t v40 = v5[4];
      if (v19 < (v5[5] - v40) >> 3
        && (uint64_t v41 = *(void *)(v40 + 8 * v19)) != 0
        && (unint64_t v42 = *(unsigned __int16 *)(v41 + 2 * (HIDWORD(v17) & 0x7F)),
            uint64_t v44 = v5[7],
            uint64_t v43 = v5[8],
            v42 < (v43 - v44) >> 3)
        && ((uint64_t v45 = v44 + 8 * v42, v45 != v43) ? (v46 = *(_DWORD *)(v45 + 4) == v18) : (v46 = 0), v46))
      {
        uint64_t v47 = v5[11];
        uint64_t v48 = v5[10] + 8 * v42;
      }
      else
      {
        uint64_t v47 = v5[11];
        uint64_t v48 = v47;
      }
      if (v48 == v47) {
        uint64_t v49 = 0;
      }
      else {
        uint64_t v49 = v48;
      }
      uint64_t v50 = v6[4];
      if (v19 < (v6[5] - v50) >> 3
        && (uint64_t v51 = *(void *)(v50 + 8 * v19)) != 0
        && (unint64_t v52 = *(unsigned __int16 *)(v51 + 2 * (HIDWORD(v17) & 0x7F)),
            uint64_t v54 = v6[7],
            uint64_t v53 = v6[8],
            v52 < (v53 - v54) >> 3)
        && ((v55 = v54 + 8 * v52, v55 != v53) ? (BOOL v56 = *(_DWORD *)(v55 + 4) == v18) : (BOOL v56 = 0), v56))
      {
        uint64_t v57 = v6[11];
        uint64_t v58 = v6[10] + 8 * v52;
      }
      else
      {
        uint64_t v57 = v6[11];
        uint64_t v58 = v57;
      }
      if (v58 == v57) {
        uint64_t v59 = 0;
      }
      else {
        uint64_t v59 = v58;
      }
      uint64_t v60 = v16[4];
      if (v19 < (v16[5] - v60) >> 3
        && (uint64_t v61 = *(void *)(v60 + 8 * v19)) != 0
        && (unint64_t v62 = *(unsigned __int16 *)(v61 + 2 * (HIDWORD(v17) & 0x7F)),
            uint64_t v64 = v16[7],
            uint64_t v63 = v16[8],
            v62 < (v63 - v64) >> 3)
        && ((uint64_t v65 = v64 + 8 * v62, v65 != v63) ? (v66 = *(_DWORD *)(v65 + 4) == v18) : (v66 = 0), v66))
      {
        unint64_t v67 = v16[11];
        unint64_t v68 = v16[10] + v62;
      }
      else
      {
        unint64_t v67 = v16[11];
        unint64_t v68 = v67;
      }
      if (v68 == v67) {
        unint64_t v68 = 0;
      }
      if ((uint64_t v69 = v7[4], v19 < (v7[5] - v69) >> 3)
        && (uint64_t v70 = *(void *)(v69 + 8 * v19)) != 0
        && (unint64_t v71 = *(unsigned __int16 *)(v70 + 2 * (HIDWORD(v17) & 0x7F)),
            uint64_t v73 = v7[7],
            uint64_t v72 = v7[8],
            v71 < (v72 - v73) >> 3)
        && ((uint64_t v74 = v73 + 8 * v71, v74 != v72) ? (v75 = *(_DWORD *)(v74 + 4) == v18) : (v75 = 0), v75))
      {
        uint64_t v76 = v7[11];
        uint64_t v77 = v7[10] + 24 * v71;
      }
      else
      {
        uint64_t v76 = v7[11];
        uint64_t v77 = v76;
      }
      if (v77 == v76) {
        uint64_t v78 = 0;
      }
      else {
        uint64_t v78 = v77;
      }
      uint64_t v79 = v9[4];
      if (v19 < (v9[5] - v79) >> 3
        && (uint64_t v80 = *(void *)(v79 + 8 * v19)) != 0
        && (unint64_t v81 = *(unsigned __int16 *)(v80 + 2 * (HIDWORD(v17) & 0x7F)),
            uint64_t v83 = v9[7],
            uint64_t v82 = v9[8],
            v81 < (v82 - v83) >> 3)
        && (uint64_t v84 = v83 + 8 * v81, v84 != v82)
        && *(_DWORD *)(v84 + 4) == v18)
      {
        uint64_t v85 = v9[11];
        uint64_t v86 = v9[10] + 4 * v81;
      }
      else
      {
        uint64_t v85 = v9[11];
        uint64_t v86 = v85;
      }
      if (v86 == v85) {
        uint64_t v86 = 0;
      }
      uint64_t v87 = v10[4];
      if (v19 < (v10[5] - v87) >> 3
        && (uint64_t v88 = *(void *)(v87 + 8 * v19)) != 0
        && (unint64_t v89 = *(unsigned __int16 *)(v88 + 2 * (HIDWORD(v17) & 0x7F)),
            uint64_t v91 = v10[7],
            uint64_t v90 = v10[8],
            v89 < (v90 - v91) >> 3)
        && (uint64_t v92 = v91 + 8 * v89, v92 != v90)
        && *(_DWORD *)(v92 + 4) == v18)
      {
        uint64_t v93 = v10[11];
        uint64_t v94 = v10[10] + 4 * v89;
      }
      else
      {
        uint64_t v93 = v10[11];
        uint64_t v94 = v93;
      }
      uint64_t v95 = v94 == v93 ? 0 : v94;
      uint64_t v147 = v86;
      unint64_t v148 = v68;
      uint64_t v146 = v95;
      uint64_t v96 = *(void *)(a2 + 24);
      if (!v96) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t, uint64_t *, uint64_t *))(*(void *)v96 + 48))(v96, v29, v39, v49, v59, &v148, v78, &v147, &v146);
      uint64_t v97 = *(unint64_t **)(v139 + 32);
      uint64_t v98 = v12 + 1;
      uint64_t v144 = v12 + 1;
      if (v12 + 1 == v97)
      {
        BOOL v16 = v142;
        uint64_t result = v138;
      }
      else
      {
        uint64_t v99 = v14[4];
        BOOL v16 = v142;
        do
        {
          unint64_t v100 = *((unsigned int *)v98 + 1);
          unint64_t v101 = v100 >> 7;
          if (v100 >> 7 < (v14[5] - v99) >> 3)
          {
            uint64_t v102 = *(void *)(v99 + 8 * v101);
            if (v102)
            {
              uint64_t v103 = v100 & 0x7F;
              unint64_t v104 = *(unsigned __int16 *)(v102 + 2 * v103);
              uint64_t v106 = v14[7];
              uint64_t v105 = v14[8];
              if (v104 < (v105 - v106) >> 3)
              {
                uint64_t v107 = v106 + 8 * v104;
                if (v107 != v105 && *(_DWORD *)(v107 + 4) == v100)
                {
                  uint64_t v109 = v15[4];
                  if (v101 < (v15[5] - v109) >> 3)
                  {
                    uint64_t v110 = *(void *)(v109 + 8 * v101);
                    if (v110)
                    {
                      unint64_t v111 = *(unsigned __int16 *)(v110 + 2 * v103);
                      uint64_t v113 = v15[7];
                      uint64_t v112 = v15[8];
                      if (v111 < (v112 - v113) >> 3)
                      {
                        uint64_t v114 = v113 + 8 * v111;
                        if (v114 != v112 && *(_DWORD *)(v114 + 4) == v100)
                        {
                          uint64_t v116 = v137[4];
                          if (v101 < (v137[5] - v116) >> 3)
                          {
                            uint64_t v117 = *(void *)(v116 + 8 * v101);
                            if (v117)
                            {
                              unint64_t v118 = *(unsigned __int16 *)(v117 + 2 * v103);
                              uint64_t v120 = v137[7];
                              uint64_t v119 = v137[8];
                              if (v118 < (v119 - v120) >> 3)
                              {
                                uint64_t v121 = v120 + 8 * v118;
                                if (v121 != v119 && *(_DWORD *)(v121 + 4) == v100)
                                {
                                  uint64_t v123 = v136[4];
                                  if (v101 < (v136[5] - v123) >> 3)
                                  {
                                    uint64_t v124 = *(void *)(v123 + 8 * v101);
                                    if (v124)
                                    {
                                      unint64_t v125 = *(unsigned __int16 *)(v124 + 2 * v103);
                                      uint64_t v127 = v136[7];
                                      uint64_t v126 = v136[8];
                                      if (v125 < (v126 - v127) >> 3)
                                      {
                                        uint64_t v128 = v127 + 8 * v125;
                                        if (v128 != v126 && *(_DWORD *)(v128 + 4) == v100)
                                        {
                                          uint64_t v129 = v135[4];
                                          if (v101 < (v135[5] - v129) >> 3)
                                          {
                                            uint64_t v130 = *(void *)(v129 + 8 * v101);
                                            if (v130)
                                            {
                                              unint64_t v131 = *(unsigned __int16 *)(v130 + 2 * v103);
                                              uint64_t v133 = v135[7];
                                              uint64_t v132 = v135[8];
                                              if (v131 < (v132 - v133) >> 3)
                                              {
                                                uint64_t v134 = v133 + 8 * v131;
                                                if (*(_DWORD *)(v134 + 4) == v100 && v134 != v132)
                                                {
                                                  uint64_t v97 = v98;
                                                  goto LABEL_137;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          ++v98;
        }
        while (v98 != v97);
        uint64_t v98 = v97;
LABEL_137:
        uint64_t result = v138;
        uint64_t v144 = v98;
      }
      uint64_t v12 = v97;
      if (v140 == v97) {
        goto LABEL_145;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return (unint64_t *)std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)3>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)3>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()();
  }
  return result;
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)3>>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::SliceAssignmentT<(md::SliceType)3>>(std::type_identity<md::ls::SliceAssignmentT<(md::SliceType)3>>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  uint64_t result = (void *)gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)3>>(a2);
  unint64_t v3 = result;
  if (result[29] && (uint64_t v4 = (void *)result[28]) != 0)
  {
    uint64_t v5 = result[31];
    uint64_t v6 = result[7];
    uint64_t v7 = (result[8] - v6) >> 3;
    while (1)
    {
      v11[0] = v6;
      v11[1] = v7;
      uint64_t v10 = v5;
      uint64_t v8 = v4[6];
      if (!v8) {
        break;
      }
      uint64_t result = (void *)(*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v8 + 48))(v8, &v10, v11);
      uint64_t v4 = (void *)*v4;
      if (!v4) {
        goto LABEL_6;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return (void *)gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)3>>(v9);
  }
  else
  {
LABEL_6:
    v3[8] = v3[7];
    v3[11] = v3[10];
  }
  return result;
}

uint64_t gdc::Registry::storage<md::ls::SliceAssignmentT<(md::SliceType)3>>(int8x8_t *a1)
{
  unint64_t v10 = 0xCEB05E103001C9FELL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xCEB05E103001C9FELL;
    if (*(void *)&v1 <= 0xCEB05E103001C9FELL) {
      unint64_t v3 = 0xCEB05E103001C9FELL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xCEB05E103001C9FELL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xCEB05E103001C9FELL)
      {
        if (v5[2] == 0xCEB05E103001C9FELL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xCEB05E103001C9FELL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xCEB05E103001C9FELL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A7FCC8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::MarkPipelineDataRequirements>,std::allocator<ecs2::ForwardToExecute<md::ita::MarkPipelineDataRequirements>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A7FF24(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v2 + 8))(v2);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>::Model<ecs2::RuntimeQuery<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>::Model<ecs2::RuntimeQuery<md::ls::RenderItemID const&,md::ls::RenderItemUpdate const&,md::ls::DataIDSetToUse const&,md::ls::RequiredPipelinePoolID const&,md::ls::PipelineSetup &>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  unint64_t v3 = (void *)gdc::Registry::storage<md::ls::RenderItemID>(v2);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::RenderItemUpdate>(v2);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::DataIDSetToUse>(v2);
  uint64_t v6 = (void *)gdc::Registry::storage<md::ls::RequiredPipelinePoolID>(v2);
  unint64_t v7 = (void *)gdc::Registry::storage<md::ls::PipelineSetup>(v2);
  v115[0] = (uint64_t)v3;
  v115[1] = (uint64_t)v4;
  v115[2] = (uint64_t)v5;
  v115[3] = (uint64_t)v6;
  v115[4] = (uint64_t)v7;
  gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::RenderItemUpdate const,md::ls::DataIDSetToUse const,md::ls::RequiredPipelinePoolID const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::begin(v113, v115);
  uint64_t v8 = v3 + 4;
  if (v4[8] - v4[7] < v3[8] - v3[7]) {
    uint64_t v8 = v4 + 4;
  }
  if (v5[8] - v5[7] < v8[4] - v8[3]) {
    uint64_t v8 = v5 + 4;
  }
  if (v6[8] - v6[7] < v8[4] - v8[3]) {
    uint64_t v8 = v6 + 4;
  }
  if (v7[8] - v7[7] < v8[4] - v8[3]) {
    uint64_t v8 = v7 + 4;
  }
  uint64_t v9 = (unint64_t *)v8[4];
  unint64_t v10 = v114;
  if (v9 == v114)
  {
    uint64_t result = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    unint64_t v11 = (void *)result;
LABEL_114:
    void *v11 = 0xFFFFFFFF00000000;
  }
  else
  {
    unint64_t v11 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v12 = (void *)v113[1];
    uint64_t v13 = (void *)v113[2];
    uint64_t v110 = (void *)v113[3];
    uint64_t v111 = v113[0];
    uint64_t v108 = (void *)v113[5];
    uint64_t v109 = (void *)v113[4];
    while (1)
    {
      void *v11 = *v10;
      unint64_t v15 = *v10;
      unint64_t v16 = HIDWORD(*v10);
      unint64_t v17 = *v10 >> 39;
      uint64_t v18 = v3[4];
      if (v17 >= (v3[5] - v18) >> 3) {
        goto LABEL_21;
      }
      uint64_t v19 = *(void *)(v18 + 8 * v17);
      if (!v19) {
        goto LABEL_21;
      }
      unint64_t v20 = *(unsigned __int16 *)(v19 + 2 * (HIDWORD(v15) & 0x7F));
      uint64_t v22 = v3[7];
      uint64_t v21 = v3[8];
      if (v20 >= (v21 - v22) >> 3) {
        goto LABEL_21;
      }
      uint64_t v23 = v22 + 8 * v20;
      if (v23 != v21 && *(_DWORD *)(v23 + 4) == v16)
      {
        uint64_t v25 = v3[11];
        uint64_t v26 = v3[10] + 24 * v20;
      }
      else
      {
LABEL_21:
        uint64_t v25 = v3[11];
        uint64_t v26 = v25;
      }
      uint64_t v27 = v26 == v25 ? 0 : v26;
      if ((uint64_t v28 = v4[4], v17 < (v4[5] - v28) >> 3)
        && (uint64_t v29 = *(void *)(v28 + 8 * v17)) != 0
        && (unint64_t v30 = *(unsigned __int16 *)(v29 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v32 = v4[7],
            uint64_t v31 = v4[8],
            v30 < (v31 - v32) >> 3)
        && ((uint64_t v33 = v32 + 8 * v30, v33 != v31) ? (v34 = *(_DWORD *)(v33 + 4) == v16) : (v34 = 0), v34))
      {
        uint64_t v35 = v4[11];
        uint64_t v36 = v4[10] + 8 * v30;
      }
      else
      {
        uint64_t v35 = v4[11];
        uint64_t v36 = v35;
      }
      uint64_t v37 = v36 == v35 ? 0 : v36;
      if ((uint64_t v38 = v5[4], v17 < (v5[5] - v38) >> 3)
        && (uint64_t v39 = *(void *)(v38 + 8 * v17)) != 0
        && (unint64_t v40 = *(unsigned __int16 *)(v39 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v42 = v5[7],
            uint64_t v41 = v5[8],
            v40 < (v41 - v42) >> 3)
        && ((uint64_t v43 = v42 + 8 * v40, v43 != v41) ? (v44 = *(_DWORD *)(v43 + 4) == v16) : (v44 = 0), v44))
      {
        uint64_t v45 = v5[11];
        uint64_t v46 = v5[10] + 8 * v40;
      }
      else
      {
        uint64_t v45 = v5[11];
        uint64_t v46 = v45;
      }
      uint64_t v47 = v46 == v45 ? 0 : v46;
      if ((uint64_t v48 = v6[4], v17 < (v6[5] - v48) >> 3)
        && (uint64_t v49 = *(void *)(v48 + 8 * v17)) != 0
        && (unint64_t v50 = *(unsigned __int16 *)(v49 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v52 = v6[7],
            uint64_t v51 = v6[8],
            v50 < (v51 - v52) >> 3)
        && ((uint64_t v53 = v52 + 8 * v50, v53 != v51) ? (v54 = *(_DWORD *)(v53 + 4) == v16) : (v54 = 0), v54))
      {
        unint64_t v55 = v6[11];
        unint64_t v56 = v6[10] + v50;
      }
      else
      {
        unint64_t v55 = v6[11];
        unint64_t v56 = v55;
      }
      unint64_t v57 = v56 == v55 ? 0 : v56;
      if ((uint64_t v58 = v7[4], v17 < (v7[5] - v58) >> 3)
        && (uint64_t v59 = *(void *)(v58 + 8 * v17)) != 0
        && (unint64_t v60 = *(unsigned __int16 *)(v59 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v62 = v7[7],
            uint64_t v61 = v7[8],
            v60 < (v61 - v62) >> 3)
        && ((v63 = v62 + 8 * v60, v63 != v61) ? (BOOL v64 = *(_DWORD *)(v63 + 4) == v16) : (BOOL v64 = 0), v64))
      {
        uint64_t v65 = v7[11];
        uint64_t v66 = v7[10] + 8 * v60;
      }
      else
      {
        uint64_t v65 = v7[11];
        uint64_t v66 = v65;
      }
      uint64_t v67 = *(void *)(a2 + 24);
      if (!v67) {
        break;
      }
      if (v66 == v65) {
        uint64_t v68 = 0;
      }
      else {
        uint64_t v68 = v66;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, uint64_t))(*(void *)v67 + 48))(v67, v27, v37, v47, v57, v68);
      uint64_t v70 = *(unint64_t **)(v111 + 32);
      float v14 = v10 + 1;
      uint64_t v114 = v10 + 1;
      if (v10 + 1 != v70)
      {
        uint64_t v71 = v12[4];
        while (1)
        {
          unint64_t v72 = *((unsigned int *)v14 + 1);
          unint64_t v73 = v72 >> 7;
          if (v72 >> 7 < (v12[5] - v71) >> 3)
          {
            uint64_t v74 = *(void *)(v71 + 8 * v73);
            if (v74)
            {
              uint64_t v75 = v72 & 0x7F;
              unint64_t v76 = *(unsigned __int16 *)(v74 + 2 * v75);
              uint64_t v78 = v12[7];
              uint64_t v77 = v12[8];
              uint64_t result = v77 - v78;
              if (v76 < (v77 - v78) >> 3)
              {
                uint64_t v79 = v78 + 8 * v76;
                if (v79 != v77 && *(_DWORD *)(v79 + 4) == v72)
                {
                  uint64_t v81 = v13[4];
                  if (v73 < (v13[5] - v81) >> 3)
                  {
                    uint64_t v82 = *(void *)(v81 + 8 * v73);
                    if (v82)
                    {
                      unint64_t v83 = *(unsigned __int16 *)(v82 + 2 * v75);
                      uint64_t v85 = v13[7];
                      uint64_t v84 = v13[8];
                      uint64_t result = v84 - v85;
                      if (v83 < (v84 - v85) >> 3)
                      {
                        uint64_t v86 = v85 + 8 * v83;
                        if (v86 != v84 && *(_DWORD *)(v86 + 4) == v72)
                        {
                          uint64_t v88 = v110[4];
                          if (v73 < (v110[5] - v88) >> 3)
                          {
                            uint64_t v89 = *(void *)(v88 + 8 * v73);
                            if (v89)
                            {
                              unint64_t v90 = *(unsigned __int16 *)(v89 + 2 * v75);
                              uint64_t v92 = v110[7];
                              uint64_t v91 = v110[8];
                              uint64_t result = v91 - v92;
                              if (v90 < (v91 - v92) >> 3)
                              {
                                uint64_t v93 = v92 + 8 * v90;
                                if (v93 != v91 && *(_DWORD *)(v93 + 4) == v72)
                                {
                                  uint64_t v95 = v109[4];
                                  if (v73 < (v109[5] - v95) >> 3)
                                  {
                                    uint64_t v96 = *(void *)(v95 + 8 * v73);
                                    if (v96)
                                    {
                                      unint64_t v97 = *(unsigned __int16 *)(v96 + 2 * v75);
                                      uint64_t v99 = v109[7];
                                      uint64_t v98 = v109[8];
                                      uint64_t result = v98 - v99;
                                      if (v97 < (v98 - v99) >> 3)
                                      {
                                        uint64_t v100 = v99 + 8 * v97;
                                        if (v100 != v98 && *(_DWORD *)(v100 + 4) == v72)
                                        {
                                          uint64_t v101 = v108[4];
                                          if (v73 < (v108[5] - v101) >> 3)
                                          {
                                            uint64_t v102 = *(void *)(v101 + 8 * v73);
                                            if (v102)
                                            {
                                              unint64_t v103 = *(unsigned __int16 *)(v102 + 2 * v75);
                                              uint64_t v105 = v108[7];
                                              uint64_t v104 = v108[8];
                                              if (v103 < (v104 - v105) >> 3)
                                              {
                                                uint64_t v106 = v105 + 8 * v103;
                                                if (*(_DWORD *)(v106 + 4) == v72 && v106 != v104) {
                                                  break;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (++v14 == v70)
          {
            float v14 = v70;
            goto LABEL_12;
          }
        }
        uint64_t v70 = v14;
LABEL_12:
        uint64_t v114 = v14;
      }
      unint64_t v10 = v70;
      if (v9 == v70) {
        goto LABEL_114;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return gdc::Registry::storage<md::ls::RenderItemUpdate>(v107);
  }
  return result;
}

uint64_t gdc::Registry::storage<md::ls::RenderItemUpdate>(int8x8_t *a1)
{
  uint64_t v10 = 0x78C3BD332555ACA7;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x78C3BD332555ACA7;
    if (*(void *)&v1 <= 0x78C3BD332555ACA7uLL) {
      uint64_t v3 = 0x78C3BD332555ACA7uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x78C3BD332555ACA7;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x78C3BD332555ACA7)
      {
        if (v5[2] == 0x78C3BD332555ACA7) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x78C3BD332555ACA7) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x78C3BD332555ACA7) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A806FC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::RenderItemUpdate const,md::ls::DataIDSetToUse const,md::ls::RequiredPipelinePoolID const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::begin(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v4 = a2[1];
  uint64_t v5 = a2[2];
  uint64_t v6 = a2[3];
  uint64_t v7 = a2[4];
  uint64_t v8 = *a2 + 32;
  if (!*a2) {
    uint64_t v8 = 0;
  }
  uint64_t v9 = v4 + 32;
  if (!v4) {
    uint64_t v9 = 0;
  }
  uint64_t v10 = v5 + 32;
  if (!v5) {
    uint64_t v10 = 0;
  }
  uint64_t v11 = v6 + 32;
  if (!v6) {
    uint64_t v11 = 0;
  }
  uint64_t v12 = v7 + 32;
  if (!v7) {
    uint64_t v12 = 0;
  }
  if (*(void *)(v9 + 32) - *(void *)(v9 + 24) < *(void *)(v8 + 32) - *(void *)(v8 + 24)) {
    uint64_t v8 = v9;
  }
  if (*(void *)(v10 + 32) - *(void *)(v10 + 24) < *(void *)(v8 + 32) - *(void *)(v8 + 24)) {
    uint64_t v8 = v10;
  }
  uint64_t result = *(void *)(v8 + 24);
  if (*(void *)(v11 + 32) - *(void *)(v11 + 24) < (unint64_t)(*(void *)(v8 + 32) - result)) {
    uint64_t v8 = v11;
  }
  if (*(void *)(v12 + 32) - *(void *)(v12 + 24) < *(void *)(v8 + 32) - *(void *)(v8 + 24)) {
    uint64_t v8 = v12;
  }
  *a1 = v8;
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  a1[4] = v6;
  a1[5] = v7;
  uint64_t v15 = *(void *)(v8 + 24);
  uint64_t v14 = *(void *)(v8 + 32);
  a1[7] = v15;
  if (v14 != v15)
  {
    uint64_t result = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::RenderItemUpdate const,md::ls::DataIDSetToUse const,md::ls::RequiredPipelinePoolID const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(a1);
    if ((result & 1) == 0)
    {
      uint64_t v16 = v15 + 8;
      do
      {
        a1[7] = v16;
        if (v16 == v14) {
          break;
        }
        uint64_t result = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::RenderItemUpdate const,md::ls::DataIDSetToUse const,md::ls::RequiredPipelinePoolID const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(a1);
        v16 += 8;
      }
      while (!result);
    }
  }
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::TransferPipelines>,std::allocator<ecs2::ForwardToExecute<md::ita::TransferPipelines>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A80B90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v15)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>::Model<ecs2::RuntimeQuery<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>>::~Model()
{
}

void ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>::Model<ecs2::RuntimeQuery<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>::Model<ecs2::RuntimeQuery<md::ls::PipelineSetupToApply const&,md::ls::RenderState const&,md::ls::DataIDSetToUse const&,md::ls::RenderItemID const&>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v3 = (void *)gdc::Registry::storage<md::ls::PipelineSetupToApply>(v2);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::RenderState>(v2);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::DataIDSetToUse>(v2);
  uint64_t v6 = (void *)gdc::Registry::storage<md::ls::RenderItemID>(v2);
  v98[0] = (uint64_t)v3;
  v98[1] = (uint64_t)v4;
  v98[2] = (uint64_t)v5;
  v98[3] = (uint64_t)v6;
  gdc::RegistryQueryView<gdc::All<md::ls::PipelineSetupToApply const,md::ls::RenderState const,md::ls::DataIDSetToUse const,md::ls::RenderItemID const>,gdc::Any<>,gdc::None<>>::begin(v96, v98);
  uint64_t v7 = v3 + 4;
  if (v4[8] - v4[7] < v3[8] - v3[7]) {
    uint64_t v7 = v4 + 4;
  }
  if (v5[8] - v5[7] < v7[4] - v7[3]) {
    uint64_t v7 = v5 + 4;
  }
  if (v6[8] - v6[7] < v7[4] - v7[3]) {
    uint64_t v7 = v6 + 4;
  }
  uint64_t v8 = (unint64_t *)v7[4];
  uint64_t v9 = v97;
  if (v8 == v97)
  {
    uint64_t result = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v10 = (void *)result;
LABEL_97:
    void *v10 = 0xFFFFFFFF00000000;
  }
  else
  {
    uint64_t v10 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v11 = v96[0];
    uint64_t v12 = (void *)v96[1];
    uint64_t v13 = (void *)v96[2];
    uint64_t v93 = (void *)v96[4];
    uint64_t v94 = (void *)v96[3];
    while (1)
    {
      void *v10 = *v9;
      unint64_t v15 = *v9;
      unint64_t v16 = HIDWORD(*v9);
      unint64_t v17 = *v9 >> 39;
      uint64_t v18 = v3[4];
      if (v17 >= (v3[5] - v18) >> 3) {
        goto LABEL_19;
      }
      uint64_t v19 = *(void *)(v18 + 8 * v17);
      if (!v19) {
        goto LABEL_19;
      }
      unint64_t v20 = *(unsigned __int16 *)(v19 + 2 * (HIDWORD(v15) & 0x7F));
      uint64_t v22 = v3[7];
      uint64_t v21 = v3[8];
      if (v20 >= (v21 - v22) >> 3) {
        goto LABEL_19;
      }
      uint64_t v23 = v22 + 8 * v20;
      if (v23 != v21 && *(_DWORD *)(v23 + 4) == v16)
      {
        uint64_t v25 = v3[11];
        uint64_t v26 = v3[10] + 8 * v20;
      }
      else
      {
LABEL_19:
        uint64_t v25 = v3[11];
        uint64_t v26 = v25;
      }
      uint64_t v27 = v26 == v25 ? 0 : v26;
      if ((uint64_t v28 = v4[4], v17 < (v4[5] - v28) >> 3)
        && (uint64_t v29 = *(void *)(v28 + 8 * v17)) != 0
        && (unint64_t v30 = *(unsigned __int16 *)(v29 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v32 = v4[7],
            uint64_t v31 = v4[8],
            v30 < (v31 - v32) >> 3)
        && ((uint64_t v33 = v32 + 8 * v30, v33 != v31) ? (v34 = *(_DWORD *)(v33 + 4) == v16) : (v34 = 0), v34))
      {
        uint64_t v35 = v4[11];
        uint64_t v36 = v4[10] + 8 * v30;
      }
      else
      {
        uint64_t v35 = v4[11];
        uint64_t v36 = v35;
      }
      uint64_t v37 = v36 == v35 ? 0 : v36;
      if ((uint64_t v38 = v5[4], v17 < (v5[5] - v38) >> 3)
        && (uint64_t v39 = *(void *)(v38 + 8 * v17)) != 0
        && (unint64_t v40 = *(unsigned __int16 *)(v39 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v42 = v5[7],
            uint64_t v41 = v5[8],
            v40 < (v41 - v42) >> 3)
        && ((uint64_t v43 = v42 + 8 * v40, v43 != v41) ? (v44 = *(_DWORD *)(v43 + 4) == v16) : (v44 = 0), v44))
      {
        uint64_t v45 = v5[11];
        uint64_t v46 = v5[10] + 8 * v40;
      }
      else
      {
        uint64_t v45 = v5[11];
        uint64_t v46 = v45;
      }
      uint64_t v47 = v46 == v45 ? 0 : v46;
      if ((uint64_t v48 = v6[4], v17 < (v6[5] - v48) >> 3)
        && (uint64_t v49 = *(void *)(v48 + 8 * v17)) != 0
        && (unint64_t v50 = *(unsigned __int16 *)(v49 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v52 = v6[7],
            uint64_t v51 = v6[8],
            v50 < (v51 - v52) >> 3)
        && ((uint64_t v53 = v52 + 8 * v50, v53 != v51) ? (v54 = *(_DWORD *)(v53 + 4) == v16) : (v54 = 0), v54))
      {
        uint64_t v55 = v6[11];
        uint64_t v56 = v6[10] + 24 * v50;
      }
      else
      {
        uint64_t v55 = v6[11];
        uint64_t v56 = v55;
      }
      uint64_t v57 = *(void *)(a2 + 24);
      if (!v57) {
        break;
      }
      if (v56 == v55) {
        uint64_t v58 = 0;
      }
      else {
        uint64_t v58 = v56;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v57 + 48))(v57, v27, v37, v47, v58);
      unint64_t v60 = *(unint64_t **)(v11 + 32);
      uint64_t v14 = v9 + 1;
      unint64_t v97 = v9 + 1;
      if (v9 + 1 != v60)
      {
        uint64_t v61 = v12[4];
        while (1)
        {
          unint64_t v62 = *((unsigned int *)v14 + 1);
          unint64_t v63 = v62 >> 7;
          if (v62 >> 7 < (v12[5] - v61) >> 3)
          {
            uint64_t v64 = *(void *)(v61 + 8 * v63);
            if (v64)
            {
              uint64_t v65 = v62 & 0x7F;
              unint64_t v66 = *(unsigned __int16 *)(v64 + 2 * v65);
              uint64_t v68 = v12[7];
              uint64_t v67 = v12[8];
              uint64_t result = v67 - v68;
              if (v66 < (v67 - v68) >> 3)
              {
                uint64_t v69 = v68 + 8 * v66;
                if (v69 != v67 && *(_DWORD *)(v69 + 4) == v62)
                {
                  uint64_t v71 = v13[4];
                  if (v63 < (v13[5] - v71) >> 3)
                  {
                    uint64_t v72 = *(void *)(v71 + 8 * v63);
                    if (v72)
                    {
                      unint64_t v73 = *(unsigned __int16 *)(v72 + 2 * v65);
                      uint64_t v75 = v13[7];
                      uint64_t v74 = v13[8];
                      uint64_t result = v74 - v75;
                      if (v73 < (v74 - v75) >> 3)
                      {
                        uint64_t v76 = v75 + 8 * v73;
                        if (v76 != v74 && *(_DWORD *)(v76 + 4) == v62)
                        {
                          uint64_t v78 = v94[4];
                          if (v63 < (v94[5] - v78) >> 3)
                          {
                            uint64_t v79 = *(void *)(v78 + 8 * v63);
                            if (v79)
                            {
                              unint64_t v80 = *(unsigned __int16 *)(v79 + 2 * v65);
                              uint64_t v82 = v94[7];
                              uint64_t v81 = v94[8];
                              uint64_t result = v81 - v82;
                              if (v80 < (v81 - v82) >> 3)
                              {
                                uint64_t v83 = v82 + 8 * v80;
                                if (v83 != v81 && *(_DWORD *)(v83 + 4) == v62)
                                {
                                  uint64_t v85 = v93[4];
                                  if (v63 < (v93[5] - v85) >> 3)
                                  {
                                    uint64_t v86 = *(void *)(v85 + 8 * v63);
                                    if (v86)
                                    {
                                      unint64_t v87 = *(unsigned __int16 *)(v86 + 2 * v65);
                                      uint64_t v89 = v93[7];
                                      uint64_t v88 = v93[8];
                                      if (v87 < (v88 - v89) >> 3)
                                      {
                                        uint64_t v90 = v89 + 8 * v87;
                                        if (*(_DWORD *)(v90 + 4) == v62 && v90 != v88) {
                                          break;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (++v14 == v60)
          {
            uint64_t v14 = v60;
            goto LABEL_10;
          }
        }
        unint64_t v60 = v14;
LABEL_10:
        unint64_t v97 = v14;
      }
      uint64_t v9 = v60;
      if (v8 == v60) {
        goto LABEL_97;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return gdc::Registry::storage<md::ls::RenderState>(v92);
  }
  return result;
}

uint64_t gdc::Registry::storage<md::ls::RenderState>(int8x8_t *a1)
{
  uint64_t v10 = 0x52AC71251090DBDELL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x52AC71251090DBDELL;
    if (*(void *)&v1 <= 0x52AC71251090DBDEuLL) {
      uint64_t v3 = 0x52AC71251090DBDEuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x52AC71251090DBDELL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x52AC71251090DBDELL)
      {
        if (v5[2] == 0x52AC71251090DBDELL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x52AC71251090DBDELL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x52AC71251090DBDELL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A81390(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t ecs2::Query<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>::Model<ecs2::RuntimeQuery<md::ls::PipelineSetupToApply const&,md::ls::DataIDSetToUse const&,md::ls::PipelineState const&>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::PipelineSetupToApply>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::DataIDSetToUse>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::PipelineState>(v3);
  uint64_t v10 = (void *)v6;
  uint64_t v11 = v4 + 4;
  if (v5[8] - v5[7] < v4[8] - v4[7]) {
    uint64_t v11 = v5 + 4;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) >= v11[4] - v11[3]) {
    uint64_t v12 = (uint64_t)v11;
  }
  else {
    uint64_t v12 = v6 + 32;
  }
  v82[0] = v12;
  v82[1] = v4;
  v82[2] = v5;
  v82[3] = v6;
  uint64_t v14 = *(void **)(v12 + 24);
  uint64_t v13 = *(void **)(v12 + 32);
  uint64_t v83 = v14;
  if (v13 != v14
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v82))
  {
    unint64_t v15 = v14 + 1;
    do
    {
      uint64_t v14 = v15;
      uint64_t v83 = v15;
      if (v15 == v13) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v82);
      unint64_t v15 = v14 + 1;
    }
    while (!isValid);
  }
  unint64_t v17 = &ecs2::Runtime::_localEntity;
  uint64_t v18 = ecs2::Runtime::_localEntity;
  if (v13 == v14) {
    goto LABEL_82;
  }
  uint64_t v19 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *uint64_t v19 = *v14;
    unint64_t v21 = *v14;
    uint64_t v22 = HIDWORD(*v14);
    unint64_t v23 = *v14 >> 39;
    uint64_t v24 = v4[4];
    if (v23 >= (v4[5] - v24) >> 3) {
      goto LABEL_23;
    }
    uint64_t v25 = *(void *)(v24 + 8 * v23);
    if (!v25) {
      goto LABEL_23;
    }
    unint64_t v26 = *(unsigned __int16 *)(v25 + 2 * (HIDWORD(v21) & 0x7F));
    uint64_t v28 = v4[7];
    uint64_t v27 = v4[8];
    if (v26 >= (v27 - v28) >> 3) {
      goto LABEL_23;
    }
    uint64_t v29 = v28 + 8 * v26;
    if (v29 != v27 && *(_DWORD *)(v29 + 4) == v22)
    {
      uint64_t v31 = v4[11];
      uint64_t v32 = v4[10] + 8 * v26;
    }
    else
    {
LABEL_23:
      uint64_t v31 = v4[11];
      uint64_t v32 = v31;
    }
    uint64_t v33 = v32 == v31 ? 0 : v32;
    if ((uint64_t v34 = v5[4], v23 < (v5[5] - v34) >> 3)
      && (uint64_t v35 = *(void *)(v34 + 8 * v23)) != 0
      && (unint64_t v36 = *(unsigned __int16 *)(v35 + 2 * (HIDWORD(v21) & 0x7F)), v38 = v5[7], v37 = v5[8], v36 < (v37 - v38) >> 3)
      && ((uint64_t v39 = v38 + 8 * v36, v39 != v37) ? (v40 = *(_DWORD *)(v39 + 4) == v22) : (v40 = 0), v40))
    {
      uint64_t v41 = v5[11];
      uint64_t v42 = v5[10] + 8 * v36;
    }
    else
    {
      uint64_t v41 = v5[11];
      uint64_t v42 = v41;
    }
    uint64_t v43 = v42 == v41 ? 0 : v42;
    uint64_t v44 = v10[4];
    if (v23 < (v10[5] - v44) >> 3)
    {
      uint64_t v45 = *(void *)(v44 + 8 * v23);
      if (v45)
      {
        unint64_t v46 = *(unsigned __int16 *)(v45 + 2 * (HIDWORD(v21) & 0x7F));
        uint64_t v48 = v10[7];
        uint64_t v47 = v10[8];
        if (v46 < (v47 - v48) >> 3)
        {
          uint64_t v49 = v48 + 8 * v46;
          if (v49 != v47 && *(_DWORD *)(v49 + 4) == v22) {
            break;
          }
        }
      }
    }
    uint64_t v51 = v10[11];
    uint64_t v52 = v51;
    uint64_t v53 = *(void *)(a2 + 24);
    if (!v53) {
      goto LABEL_81;
    }
LABEL_46:
    if (v52 == v51) {
      uint64_t v54 = 0;
    }
    else {
      uint64_t v54 = v52;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)v53 + 48))(v53, v33, v43, v54);
    uint64_t v56 = *(void **)(v12 + 32);
    unint64_t v20 = v14 + 1;
    uint64_t v83 = v14 + 1;
    if (v14 + 1 != v56)
    {
      uint64_t v57 = v4[4];
      uint64_t v59 = v4[7];
      uint64_t v58 = v4[8];
      uint64_t v60 = v5[4];
      uint64_t result = v5[7];
      uint64_t v61 = v5[8];
      uint64_t v62 = v10[4];
      uint64_t v64 = v10[7];
      uint64_t v63 = v10[8];
      while (1)
      {
        unint64_t v65 = *((unsigned int *)v20 + 1);
        unint64_t v66 = v65 >> 7;
        if (v65 >> 7 < (v4[5] - v57) >> 3)
        {
          uint64_t v67 = *(void *)(v57 + 8 * v66);
          if (v67)
          {
            uint64_t v68 = v65 & 0x7F;
            unint64_t v69 = *(unsigned __int16 *)(v67 + 2 * v68);
            if ((v58 - v59) >> 3 > v69)
            {
              uint64_t v70 = v59 + 8 * v69;
              BOOL v71 = v70 != v58 && *(_DWORD *)(v70 + 4) == v65;
              if (v71 && v66 < (v5[5] - v60) >> 3)
              {
                uint64_t v73 = *(void *)(v60 + 8 * v66);
                if (v73)
                {
                  unint64_t v74 = *(unsigned __int16 *)(v73 + 2 * v68);
                  if ((v61 - result) >> 3 > v74)
                  {
                    unint64_t v75 = result + 8 * v74;
                    BOOL v76 = v75 != v61 && *(_DWORD *)(v75 + 4) == v65;
                    if (v76 && v66 < (v10[5] - v62) >> 3)
                    {
                      uint64_t v78 = *(void *)(v62 + 8 * v66);
                      if (v78)
                      {
                        unint64_t v79 = *(unsigned __int16 *)(v78 + 2 * v68);
                        if ((v63 - v64) >> 3 > v79)
                        {
                          uint64_t v80 = v64 + 8 * v79;
                          if (*(_DWORD *)(v80 + 4) == v65 && v80 != v63) {
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (++v20 == v56)
        {
          unint64_t v20 = v56;
          goto LABEL_14;
        }
      }
      uint64_t v56 = v20;
LABEL_14:
      uint64_t v83 = v20;
    }
    uint64_t v14 = v56;
    if (v13 == v56) {
      goto LABEL_83;
    }
  }
  uint64_t v51 = v10[11];
  uint64_t v52 = v10[10] + 8 * v46;
  uint64_t v53 = *(void *)(a2 + 24);
  if (v53) {
    goto LABEL_46;
  }
LABEL_81:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_82:
  uint64_t result = ((uint64_t (*)(uint64_t (**)(void), uint64_t, uint64_t, uint64_t))v18)(v17, v7, v8, v9);
  uint64_t v19 = (void *)result;
LABEL_83:
  *uint64_t v19 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::DataIDSetToUse>(int8x8_t *a1)
{
  unint64_t v10 = 0xB3837544666C5A60;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xB3837544666C5A60;
    if (*(void *)&v1 <= 0xB3837544666C5A60) {
      unint64_t v3 = 0xB3837544666C5A60 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xB3837544666C5A60;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xB3837544666C5A60)
      {
        if (v5[2] == 0xB3837544666C5A60) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xB3837544666C5A60) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xB3837544666C5A60) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A819AC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::PipelineSetupToApply>(int8x8_t *a1)
{
  unint64_t v10 = 0xBBB17A4464CB2E03;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xBBB17A4464CB2E03;
    if (*(void *)&v1 <= 0xBBB17A4464CB2E03) {
      unint64_t v3 = 0xBBB17A4464CB2E03 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xBBB17A4464CB2E03;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xBBB17A4464CB2E03)
      {
        if (v5[2] == 0xBBB17A4464CB2E03) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xBBB17A4464CB2E03) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xBBB17A4464CB2E03) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A81C1C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::PipelineState>(int8x8_t *a1)
{
  unint64_t v10 = 0xB160D04D0F4A35A4;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xB160D04D0F4A35A4;
    if (*(void *)&v1 <= 0xB160D04D0F4A35A4) {
      unint64_t v3 = 0xB160D04D0F4A35A4 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xB160D04D0F4A35A4;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xB160D04D0F4A35A4)
      {
        if (v5[2] == 0xB160D04D0F4A35A4) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xB160D04D0F4A35A4) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xB160D04D0F4A35A4) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A81E8C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::ProcessMaterialsForUpdatedStyle>,std::allocator<ecs2::ForwardToExecute<md::ita::ProcessMaterialsForUpdatedStyle>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A82388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (a15 == v17)
  {
    (*(void (**)(uint64_t *))(a12 + 32))(&a12);
  }
  else if (a15)
  {
    (*(void (**)(void))(*(void *)a15 + 40))();
  }
  (*(void (**)(uint64_t))(*(void *)v16 + 8))(v16);
  (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialVisibilityOptionsHandle &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialVisibilityOptionsHandle &>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialVisibilityOptionsHandle &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialVisibilityOptionsHandle &>>::each(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialData>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialVisibilityOptionsHandle>(v3);
  uint64_t v6 = v5;
  unint64_t v7 = v5 + 4;
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v58, v8, v4, v5, *(void *)(v8 + 24));
  if (v6[8] - v6[7] >= v4[8] - v4[7]) {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v9 = (uint64_t)v7;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v56, v9, v4, v6, *(void *)(v9 + 32));
  unint64_t v10 = (uint64_t (**)(void))&ecs2::Runtime::_localEntity;
  if (v57 == v61) {
    goto LABEL_55;
  }
  uint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *uint64_t v12 = *v11;
    unint64_t v13 = *v11;
    unint64_t v14 = HIDWORD(*v11);
    unint64_t v15 = v13 >> 39;
    uint64_t v16 = v4[4];
    if (v13 >> 39 >= (v4[5] - v16) >> 3) {
      goto LABEL_17;
    }
    uint64_t v17 = *(void *)(v16 + 8 * v15);
    if (!v17) {
      goto LABEL_17;
    }
    unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v13) & 0x7F));
    uint64_t v20 = v4[7];
    uint64_t v19 = v4[8];
    if (v18 >= (v19 - v20) >> 3) {
      goto LABEL_17;
    }
    uint64_t v21 = v20 + 8 * v18;
    BOOL v22 = v21 != v19 && *(_DWORD *)(v21 + 4) == v14;
    if (v22)
    {
      uint64_t v23 = v4[11];
      uint64_t v24 = v4[10] + 24 * v18;
    }
    else
    {
LABEL_17:
      uint64_t v23 = v4[11];
      uint64_t v24 = v23;
    }
    uint64_t v25 = v24 == v23 ? 0 : v24;
    uint64_t v26 = v6[4];
    if (v15 < (v6[5] - v26) >> 3)
    {
      uint64_t v27 = *(void *)(v26 + 8 * v15);
      if (v27)
      {
        unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v13) & 0x7F));
        uint64_t v30 = v6[7];
        uint64_t v29 = v6[8];
        if (v28 < (v29 - v30) >> 3)
        {
          uint64_t v31 = v30 + 8 * v28;
          if (v31 != v29 && *(_DWORD *)(v31 + 4) == v14) {
            break;
          }
        }
      }
    }
    uint64_t v33 = v6[11];
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a2 + 24);
    if (!v35) {
      goto LABEL_54;
    }
LABEL_29:
    if (v34 == v33) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v25, v36);
    uint64_t v38 = v61;
    uint64_t v11 = *(unint64_t **)(v58 + 32);
    if (++v61 != v11)
    {
      uint64_t v39 = v59[4];
      unint64_t v40 = (v59[5] - v39) >> 3;
      uint64_t v41 = v38 + 2;
      while (1)
      {
        unint64_t v42 = *((unsigned int *)v41 - 1);
        unint64_t v43 = v42 >> 7;
        if (v42 >> 7 < v40)
        {
          uint64_t v44 = *(void *)(v39 + 8 * v43);
          if (v44)
          {
            unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
            uint64_t v46 = v59[7];
            uint64_t result = v59[8];
            if (v45 < (result - v46) >> 3)
            {
              uint64_t v47 = v46 + 8 * v45;
              if (v47 != result && *(_DWORD *)(v47 + 4) == v42)
              {
                uint64_t v49 = v60[4];
                uint64_t result = v60[5] - v49;
                if (v43 < result >> 3)
                {
                  uint64_t v50 = *(void *)(v49 + 8 * v43);
                  if (v50)
                  {
                    unint64_t v51 = *(unsigned __int16 *)(v50 + 2 * (v42 & 0x7F));
                    uint64_t v53 = v60[7];
                    uint64_t v52 = v60[8];
                    uint64_t result = v52 - v53;
                    if (v51 < (v52 - v53) >> 3)
                    {
                      uint64_t v54 = v53 + 8 * v51;
                      if (v54 != v52 && *(_DWORD *)(v54 + 4) == v42) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v61 = v41;
        BOOL v22 = v41++ == v11;
        if (v22) {
          goto LABEL_9;
        }
      }
      uint64_t v11 = v41 - 1;
    }
LABEL_9:
    if (v57 == v11) {
      goto LABEL_56;
    }
  }
  uint64_t v33 = v6[11];
  uint64_t v34 = v6[10] + 16 * v28;
  uint64_t v35 = *(void *)(a2 + 24);
  if (v35) {
    goto LABEL_29;
  }
LABEL_54:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_55:
  uint64_t result = (*v10)();
  uint64_t v12 = (void *)result;
LABEL_56:
  *uint64_t v12 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::UniqueMaterialVisibilityOptionsHandle>(int8x8_t *a1)
{
  unint64_t v10 = 0x849CB194B84BB63DLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0x849CB194B84BB63DLL;
    if (*(void *)&v1 <= 0x849CB194B84BB63DLL) {
      unint64_t v3 = 0x849CB194B84BB63DLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0x849CB194B84BB63DLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x849CB194B84BB63DLL)
      {
        if (v5[2] == 0x849CB194B84BB63DLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x849CB194B84BB63DLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x849CB194B84BB63DLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A829FC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialZIndexHandle &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialZIndexHandle &>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialZIndexHandle &>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialData const&,md::ls::UniqueMaterialZIndexHandle &>>::each(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialData>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialZIndexHandle>(v3);
  uint64_t v6 = v5;
  unint64_t v7 = v5 + 4;
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v58, v8, v4, v5, *(void *)(v8 + 24));
  if (v6[8] - v6[7] >= v4[8] - v4[7]) {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v9 = (uint64_t)v7;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v56, v9, v4, v6, *(void *)(v9 + 32));
  unint64_t v10 = (uint64_t (**)(void))&ecs2::Runtime::_localEntity;
  if (v57 == v61) {
    goto LABEL_55;
  }
  uint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *uint64_t v12 = *v11;
    unint64_t v13 = *v11;
    unint64_t v14 = HIDWORD(*v11);
    unint64_t v15 = v13 >> 39;
    uint64_t v16 = v4[4];
    if (v13 >> 39 >= (v4[5] - v16) >> 3) {
      goto LABEL_17;
    }
    uint64_t v17 = *(void *)(v16 + 8 * v15);
    if (!v17) {
      goto LABEL_17;
    }
    unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v13) & 0x7F));
    uint64_t v20 = v4[7];
    uint64_t v19 = v4[8];
    if (v18 >= (v19 - v20) >> 3) {
      goto LABEL_17;
    }
    uint64_t v21 = v20 + 8 * v18;
    BOOL v22 = v21 != v19 && *(_DWORD *)(v21 + 4) == v14;
    if (v22)
    {
      uint64_t v23 = v4[11];
      uint64_t v24 = v4[10] + 24 * v18;
    }
    else
    {
LABEL_17:
      uint64_t v23 = v4[11];
      uint64_t v24 = v23;
    }
    uint64_t v25 = v24 == v23 ? 0 : v24;
    uint64_t v26 = v6[4];
    if (v15 < (v6[5] - v26) >> 3)
    {
      uint64_t v27 = *(void *)(v26 + 8 * v15);
      if (v27)
      {
        unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v13) & 0x7F));
        uint64_t v30 = v6[7];
        uint64_t v29 = v6[8];
        if (v28 < (v29 - v30) >> 3)
        {
          uint64_t v31 = v30 + 8 * v28;
          if (v31 != v29 && *(_DWORD *)(v31 + 4) == v14) {
            break;
          }
        }
      }
    }
    uint64_t v33 = v6[11];
    uint64_t v34 = v33;
    uint64_t v35 = *(void *)(a2 + 24);
    if (!v35) {
      goto LABEL_54;
    }
LABEL_29:
    if (v34 == v33) {
      uint64_t v36 = 0;
    }
    else {
      uint64_t v36 = v34;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v35 + 48))(v35, v25, v36);
    uint64_t v38 = v61;
    uint64_t v11 = *(unint64_t **)(v58 + 32);
    if (++v61 != v11)
    {
      uint64_t v39 = v59[4];
      unint64_t v40 = (v59[5] - v39) >> 3;
      uint64_t v41 = v38 + 2;
      while (1)
      {
        unint64_t v42 = *((unsigned int *)v41 - 1);
        unint64_t v43 = v42 >> 7;
        if (v42 >> 7 < v40)
        {
          uint64_t v44 = *(void *)(v39 + 8 * v43);
          if (v44)
          {
            unint64_t v45 = *(unsigned __int16 *)(v44 + 2 * (v42 & 0x7F));
            uint64_t v46 = v59[7];
            uint64_t result = v59[8];
            if (v45 < (result - v46) >> 3)
            {
              uint64_t v47 = v46 + 8 * v45;
              if (v47 != result && *(_DWORD *)(v47 + 4) == v42)
              {
                uint64_t v49 = v60[4];
                uint64_t result = v60[5] - v49;
                if (v43 < result >> 3)
                {
                  uint64_t v50 = *(void *)(v49 + 8 * v43);
                  if (v50)
                  {
                    unint64_t v51 = *(unsigned __int16 *)(v50 + 2 * (v42 & 0x7F));
                    uint64_t v53 = v60[7];
                    uint64_t v52 = v60[8];
                    uint64_t result = v52 - v53;
                    if (v51 < (v52 - v53) >> 3)
                    {
                      uint64_t v54 = v53 + 8 * v51;
                      if (v54 != v52 && *(_DWORD *)(v54 + 4) == v42) {
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v61 = v41;
        BOOL v22 = v41++ == v11;
        if (v22) {
          goto LABEL_9;
        }
      }
      uint64_t v11 = v41 - 1;
    }
LABEL_9:
    if (v57 == v11) {
      goto LABEL_56;
    }
  }
  uint64_t v33 = v6[11];
  uint64_t v34 = v6[10] + 24 * v28;
  uint64_t v35 = *(void *)(a2 + 24);
  if (v35) {
    goto LABEL_29;
  }
LABEL_54:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_55:
  uint64_t result = (*v10)();
  uint64_t v12 = (void *)result;
LABEL_56:
  *uint64_t v12 = 0xFFFFFFFF00000000;
  return result;
}

void *ecs2::Query<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>::Model<ecs2::RuntimeQuery<md::ls::PendingDeletion const&,md::ls::RenderableMaterialData *,md::ls::RampMaterialData *,md::ls::ColorDataHandle *,md::ls::UniqueMaterialVisibilityOptionsHandle *,md::ls::UniqueMaterialZIndexHandle *,md::ls::UniqueColorDataHandle *>>::each(uint64_t a1, uint64_t a2)
{
  uint8x8_t v2 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  unint64_t v3 = (void *)gdc::Registry::storage<md::ls::PendingDeletion>(v2);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::RenderableMaterialData>(v2);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::RampMaterialData>(v2);
  uint64_t v6 = (void *)gdc::Registry::storage<md::ls::ColorDataHandle>(v2);
  unint64_t v7 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialVisibilityOptionsHandle>(v2);
  uint64_t v8 = (void *)gdc::Registry::storage<md::ls::UniqueMaterialZIndexHandle>(v2);
  uint64_t v9 = (void *)gdc::Registry::storage<md::ls::UniqueColorDataHandle>(v2);
  unint64_t v10 = (unint64_t *)v3[7];
  uint64_t v11 = (uint64_t *)v3[8];
  uint64_t v12 = (char *)v11 - (char *)v10;
  if (v11 != (uint64_t *)v10)
  {
    if ((unint64_t v13 = *((unsigned int *)v10 + 1), v14 = v3[4], v15 = (v3[5] - v14) >> 3, v13 >> 7 >= v15)
      || (uint64_t v16 = *(void *)(v14 + 8 * (v13 >> 7))) == 0
      || (unint64_t v17 = *(unsigned __int16 *)(v16 + 2 * (v13 & 0x7F)), v17 >= v12 >> 3)
      || ((unint64_t v18 = (uint64_t *)&v10[v17], v18 != v11) ? (v19 = *((_DWORD *)v18 + 1) == v13) : (v19 = 0), !v19))
    {
      unint64_t v20 = v12 >> 3;
      uint64_t v21 = (uint64_t *)(v10 + 1);
      while (v21 != v11)
      {
        unint64_t v22 = *((unsigned int *)v21 + 1);
        uint64_t v23 = (uint64_t *)v3[8];
        if (v22 >> 7 < v15)
        {
          uint64_t v24 = *(void *)(v14 + 8 * (v22 >> 7));
          uint64_t v23 = (uint64_t *)v3[8];
          if (v24)
          {
            unint64_t v25 = *(unsigned __int16 *)(v24 + 2 * (v22 & 0x7F));
            uint64_t v23 = (uint64_t *)v3[8];
            if (v20 > v25)
            {
              uint64_t v23 = (uint64_t *)&v10[v25];
              if (*((_DWORD *)v23 + 1) != v22) {
                uint64_t v23 = (uint64_t *)v3[8];
              }
            }
          }
        }
        ++v21;
        if (v23 != v11)
        {
          unint64_t v10 = (unint64_t *)(v21 - 1);
          goto LABEL_19;
        }
      }
      goto LABEL_110;
    }
  }
LABEL_19:
  if (v11 == (uint64_t *)v10)
  {
LABEL_110:
    uint64_t result = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    void *result = 0xFFFFFFFF00000000;
    return result;
  }
  uint64_t v26 = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *uint64_t v26 = *v10;
    unint64_t v28 = *v10;
    unint64_t v29 = HIDWORD(*v10);
    unint64_t v30 = *v10 >> 39;
    uint64_t v31 = v3[4];
    if (v30 < (v3[5] - v31) >> 3
      && (uint64_t v32 = *(void *)(v31 + 8 * v30)) != 0
      && (unint64_t v33 = *(unsigned __int16 *)(v32 + 2 * (HIDWORD(v28) & 0x7F)), v35 = v3[7], v34 = v3[8], v33 < (v34 - v35) >> 3)
      && ((uint64_t v36 = v35 + 8 * v33, v36 != v34) ? (v37 = *(_DWORD *)(v36 + 4) == v29) : (v37 = 0), v37))
    {
      unint64_t v38 = v3[11];
      unint64_t v39 = v3[10] + v33;
    }
    else
    {
      unint64_t v38 = v3[11];
      unint64_t v39 = v38;
    }
    if (v39 == v38) {
      unint64_t v40 = 0;
    }
    else {
      unint64_t v40 = v39;
    }
    uint64_t v41 = v4[4];
    if (v30 < (v4[5] - v41) >> 3
      && (uint64_t v42 = *(void *)(v41 + 8 * v30)) != 0
      && (v43 = *(unsigned __int16 *)(v42 + 2 * (HIDWORD(v28) & 0x7F)), uint64_t v45 = v4[7], v44 = v4[8], v43 < (v44 - v45) >> 3)
      && ((v46 = v45 + 8 * v43, v46 != v44) ? (BOOL v47 = *(_DWORD *)(v46 + 4) == v29) : (BOOL v47 = 0), v47))
    {
      uint64_t v48 = v4[11];
      uint64_t v49 = v4[10] + 32 * v43;
    }
    else
    {
      uint64_t v48 = v4[11];
      uint64_t v49 = v48;
    }
    if (v49 == v48) {
      uint64_t v49 = 0;
    }
    uint64_t v50 = v5[4];
    if (v30 < (v5[5] - v50) >> 3
      && (uint64_t v51 = *(void *)(v50 + 8 * v30)) != 0
      && (unint64_t v52 = *(unsigned __int16 *)(v51 + 2 * (HIDWORD(v28) & 0x7F)), v54 = v5[7], v53 = v5[8], v52 < (v53 - v54) >> 3)
      && ((v55 = v54 + 8 * v52, v55 != v53) ? (BOOL v56 = *(_DWORD *)(v55 + 4) == v29) : (BOOL v56 = 0), v56))
    {
      uint64_t v57 = v5[11];
      uint64_t v58 = v5[10] + 32 * v52;
    }
    else
    {
      uint64_t v57 = v5[11];
      uint64_t v58 = v57;
    }
    if (v58 == v57) {
      uint64_t v58 = 0;
    }
    uint64_t v59 = v6[4];
    if (v30 < (v6[5] - v59) >> 3
      && (uint64_t v60 = *(void *)(v59 + 8 * v30)) != 0
      && (v61 = *(unsigned __int16 *)(v60 + 2 * (HIDWORD(v28) & 0x7F)), v63 = v6[7], uint64_t v62 = v6[8], v61 < (v62 - v63) >> 3)
      && ((uint64_t v64 = v63 + 8 * v61, v64 != v62) ? (v65 = *(_DWORD *)(v64 + 4) == v29) : (v65 = 0), v65))
    {
      uint64_t v66 = v6[11];
      uint64_t v67 = v6[10] + 8 * v61;
    }
    else
    {
      uint64_t v66 = v6[11];
      uint64_t v67 = v66;
    }
    if (v67 == v66) {
      uint64_t v67 = 0;
    }
    uint64_t v68 = v7[4];
    if (v30 < (v7[5] - v68) >> 3
      && (uint64_t v69 = *(void *)(v68 + 8 * v30)) != 0
      && (v70 = *(unsigned __int16 *)(v69 + 2 * (HIDWORD(v28) & 0x7F)), v72 = v7[7], uint64_t v71 = v7[8], v70 < (v71 - v72) >> 3)
      && ((v73 = v72 + 8 * v70, v73 != v71) ? (BOOL v74 = *(_DWORD *)(v73 + 4) == v29) : (BOOL v74 = 0), v74))
    {
      uint64_t v75 = v7[11];
      uint64_t v76 = v7[10] + 16 * v70;
    }
    else
    {
      uint64_t v75 = v7[11];
      uint64_t v76 = v75;
    }
    if (v76 == v75) {
      uint64_t v76 = 0;
    }
    if ((uint64_t v77 = v8[4], v30 < (v8[5] - v77) >> 3)
      && (uint64_t v78 = *(void *)(v77 + 8 * v30)) != 0
      && (unint64_t v79 = *(unsigned __int16 *)(v78 + 2 * (HIDWORD(v28) & 0x7F)), v81 = v8[7], v80 = v8[8], v79 < (v80 - v81) >> 3)
      && ((uint64_t v82 = v81 + 8 * v79, v82 != v80) ? (v83 = *(_DWORD *)(v82 + 4) == v29) : (v83 = 0), v83))
    {
      uint64_t v84 = v8[11];
      uint64_t v85 = v8[10] + 24 * v79;
    }
    else
    {
      uint64_t v84 = v8[11];
      uint64_t v85 = v84;
    }
    if (v85 == v84) {
      uint64_t v85 = 0;
    }
    uint64_t v86 = v9[4];
    if (v30 < (v9[5] - v86) >> 3
      && (uint64_t v87 = *(void *)(v86 + 8 * v30)) != 0
      && (unint64_t v88 = *(unsigned __int16 *)(v87 + 2 * (HIDWORD(v28) & 0x7F)), v90 = v9[7], v89 = v9[8], v88 < (v89 - v90) >> 3)
      && (uint64_t v91 = v90 + 8 * v88, v91 != v89)
      && *(_DWORD *)(v91 + 4) == v29)
    {
      uint64_t v92 = v9[11];
      uint64_t v93 = v9[10] + 8 * v88;
    }
    else
    {
      uint64_t v92 = v9[11];
      uint64_t v93 = v92;
    }
    uint64_t v94 = v93 == v92 ? 0 : v93;
    uint64_t v110 = v58;
    uint64_t v111 = v49;
    uint64_t v108 = v76;
    uint64_t v109 = v67;
    uint64_t v106 = v94;
    uint64_t v107 = v85;
    uint64_t v95 = *(void *)(a2 + 24);
    if (!v95) {
      break;
    }
    (*(void (**)(uint64_t, unint64_t, uint64_t *, uint64_t *, uint64_t *, uint64_t *, uint64_t *, uint64_t *))(*(void *)v95 + 48))(v95, v40, &v111, &v110, &v109, &v108, &v107, &v106);
    uint64_t v96 = v3[4];
    uint64_t v97 = v3[7];
    uint64_t v27 = (uint64_t *)v3[8];
    uint64_t v98 = (uint64_t *)(v10 + 1);
    while (v98 != v27)
    {
      unint64_t v99 = *((unsigned int *)v98 + 1);
      uint64_t v100 = v3[8];
      if (v99 >> 7 < (v3[5] - v96) >> 3)
      {
        uint64_t v101 = *(void *)(v96 + 8 * (v99 >> 7));
        uint64_t v100 = v3[8];
        if (v101)
        {
          unint64_t v102 = *(unsigned __int16 *)(v101 + 2 * (v99 & 0x7F));
          uint64_t v100 = v3[8];
          if (((uint64_t)v27 - v97) >> 3 > v102)
          {
            uint64_t v100 = v97 + 8 * v102;
            if (*(_DWORD *)(v100 + 4) != v99) {
              uint64_t v100 = v3[8];
            }
          }
        }
      }
      ++v98;
      if ((uint64_t *)v100 != v27)
      {
        uint64_t v27 = v98 - 1;
        break;
      }
    }
    unint64_t v10 = (unint64_t *)v27;
    if (v11 == v27) {
      goto LABEL_110;
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return (void *)gdc::Registry::storage<md::ls::UniqueMaterialZIndexHandle>(v104);
}

uint64_t gdc::Registry::storage<md::ls::UniqueMaterialZIndexHandle>(int8x8_t *a1)
{
  unint64_t v10 = 0xE515B39146CD9FB7;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xE515B39146CD9FB7;
    if (*(void *)&v1 <= 0xE515B39146CD9FB7) {
      unint64_t v3 = 0xE515B39146CD9FB7 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xE515B39146CD9FB7;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xE515B39146CD9FB7)
      {
        if (v5[2] == 0xE515B39146CD9FB7) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xE515B39146CD9FB7) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xE515B39146CD9FB7) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A8349C(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::ApplyAlbedoTint>,std::allocator<ecs2::ForwardToExecute<md::ita::ApplyAlbedoTint>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  uint8x8_t v2 = *(int8x8_t **)(a2 + 8);
  uint64_t v3 = gdc::Registry::storage<md::ls::InView>(v2);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::SharedColorDataHandle>(v2);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::AlbedoTintColor>(v2);
  gdc::Registry::storage<md::ls::UniqueColorDataHandle>(v2);
  uint64_t v6 = gdc::Registry::storage<md::ls::ColorDataHandle>(v2);
  unint64_t v7 = (void *)v6;
  uint64_t v8 = (void *)(v3 + 32);
  if (v4[8] - v4[7] < *(void *)(v3 + 64) - *(void *)(v3 + 56)) {
    uint64_t v8 = v4 + 4;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) < v8[4] - v8[3]) {
    uint64_t v8 = (void *)(v6 + 32);
  }
  if (v5[8] - v5[7] < v8[4] - v8[3]) {
    uint64_t v8 = v5 + 4;
  }
  uint64_t v97 = v8;
  uint64_t v98 = (void *)v3;
  unint64_t v99 = v4;
  uint64_t v100 = (void *)v6;
  uint64_t v9 = (void *)v8[3];
  unint64_t v10 = (void *)v8[4];
  uint64_t v101 = v5;
  unint64_t v102 = v9;
  if (v10 != v9
    && !gdc::RegistryQueryView<gdc::All<md::ls::RequiresShaderTextureID<Flyover::NightTexture> const,md::ls::TextureHandleForType<Flyover::NightTexture> const,md::ls::FlyoverInstance const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v97))
  {
    uint64_t v11 = v9 + 1;
    do
    {
      uint64_t v9 = v11;
      unint64_t v102 = v11;
      if (v11 == v10) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RequiresShaderTextureID<Flyover::NightTexture> const,md::ls::TextureHandleForType<Flyover::NightTexture> const,md::ls::FlyoverInstance const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v97);
      uint64_t v11 = v9 + 1;
    }
    while (!isValid);
  }
  uint64_t v95 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (v10 != v9)
  {
    void *v95 = *v9;
    unint64_t v14 = *v9;
    uint64_t v15 = HIDWORD(*v9);
    unint64_t v16 = *v9 >> 39;
    uint64_t v17 = v4[4];
    if (v16 < (v4[5] - v17) >> 3
      && (uint64_t v18 = *(void *)(v17 + 8 * v16)) != 0
      && (unint64_t v19 = *(unsigned __int16 *)(v18 + 2 * (HIDWORD(v14) & 0x7F)), v21 = v4[7], v20 = v4[8], v19 < (v20 - v21) >> 3)
      && ((uint64_t v22 = v21 + 8 * v19, v22 != v20) ? (v23 = *(_DWORD *)(v22 + 4) == v15) : (v23 = 0), v23))
    {
      uint64_t v24 = (unint64_t *)(v4[10] + 8 * v19);
    }
    else
    {
      uint64_t v24 = (unint64_t *)v4[11];
    }
    uint64_t v25 = v7[4];
    if (v16 < (v7[5] - v25) >> 3
      && (uint64_t v26 = *(void *)(v25 + 8 * v16)) != 0
      && (v27 = *(unsigned __int16 *)(v26 + 2 * (HIDWORD(v14) & 0x7F)), v29 = v7[7], uint64_t v28 = v7[8], v27 < (v28 - v29) >> 3)
      && ((uint64_t v30 = v29 + 8 * v27, v30 != v28) ? (v31 = *(_DWORD *)(v30 + 4) == v15) : (v31 = 0), v31))
    {
      uint64_t v32 = (unint64_t *)(v7[10] + 8 * v27);
    }
    else
    {
      uint64_t v32 = (unint64_t *)v7[11];
    }
    uint64_t v33 = v5[4];
    if (v16 < (v5[5] - v33) >> 3
      && (uint64_t v34 = *(void *)(v33 + 8 * v16)) != 0
      && (v35 = *(unsigned __int16 *)(v34 + 2 * (HIDWORD(v14) & 0x7F)), v37 = v5[7], uint64_t v36 = v5[8], v35 < (v36 - v37) >> 3)
      && ((uint64_t v38 = v37 + 8 * v35, v38 != v36) ? (v39 = *(_DWORD *)(v38 + 4) == v15) : (v39 = 0), v39))
    {
      uint64_t v40 = v5[11];
      uint64_t v41 = v5[10] + 16 * v35;
    }
    else
    {
      uint64_t v40 = v5[11];
      uint64_t v41 = v40;
    }
    if (v41 == v40) {
      uint64_t v42 = 0;
    }
    else {
      uint64_t v42 = (float *)v41;
    }
    uint64_t v43 = **(void **)(a1 + 8);
    uint64_t v44 = *(void **)v43;
    uint64_t v45 = *(void **)(v43 + 8);
    if (v44 != v45)
    {
      while (*v44 != 0x4EDAD23DFB014132)
      {
        v44 += 5;
        if (v44 == v45) {
          goto LABEL_52;
        }
      }
    }
    if (v44 == v45)
    {
LABEL_52:
      uint64_t v46 = 0;
    }
    else
    {
      uint64_t v46 = (void *)v44[3];
      BOOL v47 = (std::__shared_weak_count *)v44[4];
      if (v47)
      {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
      }
    }
    unint64_t v48 = *v24;
    unint64_t v103 = v48;
    uint64_t v49 = v46[126];
    unint64_t v50 = (v46[127] - v49) >> 3;
    if (v48 < v50
      && ((uint64_t v51 = *(void *)(v49 + 8 * v48)) != 0 ? (v52 = HIDWORD(v48) == HIDWORD(v51)) : (v52 = 0), v52))
    {
      uint64_t v54 = v46[129] + 20 * v51;
      uint64_t v53 = v46[130];
    }
    else
    {
      uint64_t v53 = v46[130];
      uint64_t v54 = v53;
    }
    if (v54 == v53) {
      uint64_t v55 = 0;
    }
    else {
      uint64_t v55 = (float *)v54;
    }
    if (v55)
    {
      BOOL v56 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>((uint64_t)(v46 + 118), v48, &v103);
      ++v56[3];
      uint64_t v49 = v46[126];
      unint64_t v50 = (v46[127] - v49) >> 3;
    }
    unint64_t v57 = *v32;
    unint64_t v103 = v57;
    if (v57 < v50
      && ((v58 = *(void *)(v49 + 8 * v57)) != 0 ? (BOOL v59 = HIDWORD(v57) == HIDWORD(v58)) : (BOOL v59 = 0), v59))
    {
      uint64_t v61 = v46[129] + 20 * v58;
      uint64_t v60 = v46[130];
    }
    else
    {
      uint64_t v60 = v46[130];
      uint64_t v61 = v60;
    }
    if (v61 == v60) {
      uint64_t v62 = 0;
    }
    else {
      uint64_t v62 = (float *)v61;
    }
    if (v62)
    {
      uint64_t v63 = std::__hash_table<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::hash<geo::handle<md::MaterialIDStorage>>,std::equal_to<geo::handle<md::MaterialIDStorage>>,true>,std::__unordered_map_equal<geo::handle<md::MaterialIDStorage>,std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>,std::equal_to<geo::handle<md::MaterialIDStorage>>,std::hash<geo::handle<md::MaterialIDStorage>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::MaterialIDStorage>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::MaterialIDStorage>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::MaterialIDStorage> const&>,std::tuple<>>((uint64_t)(v46 + 118), v57, &v103);
      ++v63[3];
    }
    *uint64_t v62 = *v55 + (float)((float)(*v42 - *v55) * v42[3]);
    v62[1] = v55[1] + (float)((float)(v42[1] - v55[1]) * v42[3]);
    v62[2] = v55[2] + (float)((float)(v42[2] - v55[2]) * v42[3]);
    uint64_t v9 = (void *)v97[4];
    unint64_t v13 = v102 + 1;
    unint64_t v102 = v13;
    if (v13 != v9)
    {
      uint64_t v64 = v98[4];
      while (1)
      {
        unint64_t v65 = *((unsigned int *)v13 + 1);
        unint64_t v66 = v65 >> 7;
        if (v65 >> 7 < (v98[5] - v64) >> 3)
        {
          uint64_t v67 = *(void *)(v64 + 8 * v66);
          if (v67)
          {
            uint64_t v68 = v65 & 0x7F;
            unint64_t v69 = *(unsigned __int16 *)(v67 + 2 * v68);
            uint64_t v71 = v98[7];
            uint64_t v70 = v98[8];
            if (v69 < (v70 - v71) >> 3)
            {
              uint64_t v72 = v71 + 8 * v69;
              if (v72 != v70 && *(_DWORD *)(v72 + 4) == v65)
              {
                uint64_t v74 = v99[4];
                if (v66 < (v99[5] - v74) >> 3)
                {
                  uint64_t v75 = *(void *)(v74 + 8 * v66);
                  if (v75)
                  {
                    unint64_t v76 = *(unsigned __int16 *)(v75 + 2 * v68);
                    uint64_t v78 = v99[7];
                    uint64_t v77 = v99[8];
                    if (v76 < (v77 - v78) >> 3)
                    {
                      uint64_t v79 = v78 + 8 * v76;
                      if (v79 != v77 && *(_DWORD *)(v79 + 4) == v65)
                      {
                        uint64_t v81 = v100[4];
                        if (v66 < (v100[5] - v81) >> 3)
                        {
                          uint64_t v82 = *(void *)(v81 + 8 * v66);
                          if (v82)
                          {
                            unint64_t v83 = *(unsigned __int16 *)(v82 + 2 * v68);
                            uint64_t v85 = v100[7];
                            uint64_t v84 = v100[8];
                            if (v83 < (v84 - v85) >> 3)
                            {
                              uint64_t v86 = v85 + 8 * v83;
                              if (v86 != v84 && *(_DWORD *)(v86 + 4) == v65)
                              {
                                uint64_t v88 = v101[4];
                                if (v66 < (v101[5] - v88) >> 3)
                                {
                                  uint64_t v89 = *(void *)(v88 + 8 * v66);
                                  if (v89)
                                  {
                                    unint64_t v90 = *(unsigned __int16 *)(v89 + 2 * v68);
                                    uint64_t v91 = v101[7];
                                    uint64_t v92 = v101[8];
                                    if (v90 < (v92 - v91) >> 3)
                                    {
                                      uint64_t v93 = v91 + 8 * v90;
                                      if (*(_DWORD *)(v93 + 4) == v65 && v93 != v92) {
                                        break;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (++v13 == v9)
        {
          unint64_t v13 = v9;
          goto LABEL_15;
        }
      }
      uint64_t v9 = v13;
LABEL_15:
      unint64_t v102 = v13;
    }
  }
  void *v95 = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0;
}

uint64_t gdc::Registry::storage<md::ls::UniqueColorDataHandle>(int8x8_t *a1)
{
  uint64_t v10 = 0x60915CB292001F47;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x60915CB292001F47;
    if (*(void *)&v1 <= 0x60915CB292001F47uLL) {
      uint64_t v3 = 0x60915CB292001F47uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x60915CB292001F47;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x60915CB292001F47)
      {
        if (v5[2] == 0x60915CB292001F47) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x60915CB292001F47) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x60915CB292001F47) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A83CD0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::SharedColorDataHandle>(int8x8_t *a1)
{
  unint64_t v10 = 0xC893C1C4D3D90FF5;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xC893C1C4D3D90FF5;
    if (*(void *)&v1 <= 0xC893C1C4D3D90FF5) {
      unint64_t v3 = 0xC893C1C4D3D90FF5 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xC893C1C4D3D90FF5;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xC893C1C4D3D90FF5)
      {
        if (v5[2] == 0xC893C1C4D3D90FF5) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xC893C1C4D3D90FF5) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xC893C1C4D3D90FF5) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A83F40(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::AlbedoTintColor>(int8x8_t *a1)
{
  uint64_t v10 = 0x2906BE24995F2F60;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x2906BE24995F2F60;
    if (*(void *)&v1 <= 0x2906BE24995F2F60uLL) {
      uint64_t v3 = 0x2906BE24995F2F60uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x2906BE24995F2F60;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x2906BE24995F2F60)
      {
        if (v5[2] == 0x2906BE24995F2F60) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x2906BE24995F2F60) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x2906BE24995F2F60) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A841B0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1A1A8441C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1A1A84434(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);

  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::~vector[abi:nn180100]((void **)va);
  _Unwind_Resume(a1);
}

void md::OverlaysLogic::runBeforeLayout(uint64_t a1, const md::LayoutContext *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v263 = *MEMORY[0x1E4F143B8];
  v259[0] = &unk_1EF570020;
  v259[1] = a2;
  v257[0] = &unk_1EF570068;
  v257[1] = a2;
  v258 = v257;
  v262 = v261;
  v260 = v259;
  v261[0] = &unk_1EF570068;
  v261[1] = a2;
  _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__1NS_9allocatorISM_EEFvvEEclEv((uint64_t)v259);
  if (v258 == v257)
  {
    (*(void (**)(void *))(v257[0] + 32))(v257);
    uint64_t v7 = a4;
  }
  else
  {
    uint64_t v7 = a4;
    if (v258) {
      (*(void (**)(void *))(*v258 + 40))(v258);
    }
  }
  if (v260 == v259)
  {
    (*(void (**)(void *))(v259[0] + 32))(v259);
  }
  else if (v260)
  {
    (*(void (**)(void *))(*v260 + 40))(v260);
  }
  md::OverlayContainer::flushCommandQueue(*(md::OverlayContainer **)(a1 + 712));
  uint64_t v8 = *(void *)(a1 + 712);
  *(void *)(v7 + 160) = v8;
  *(void *)(v7 + 168) = *(void *)(a1 + 152);
  if (*(unsigned char *)(v8 + 345))
  {
    v255[0] = &unk_1EF5700B0;
    v255[1] = a1;
    v256 = v255;
    md::OverlaysLogic::_forEachOverlayLevelAndFallback((uint64_t)v255);
    if (v256 == v255)
    {
      (*(void (**)(void *))(v255[0] + 32))(v255);
      if (!*(void *)(a1 + 696))
      {
LABEL_22:
        uint64_t v8 = *(void *)(a1 + 712);
        *(unsigned char *)(v8 + 345) = 0;
        goto LABEL_23;
      }
    }
    else
    {
      if (v256) {
        (*(void (**)(void *))(*v256 + 40))(v256);
      }
      if (!*(void *)(a1 + 696)) {
        goto LABEL_22;
      }
    }
    uint64_t v9 = *(void **)(a1 + 688);
    if (v9)
    {
      do
      {
        uint64_t v10 = (void *)*v9;
        buf[0] = (int8x8_t)(v9 + 3);
        std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
        operator delete(v9);
        uint64_t v9 = v10;
      }
      while (v10);
    }
    *(void *)(a1 + 688) = 0;
    uint64_t v11 = *(void *)(a1 + 680);
    if (v11)
    {
      for (uint64_t i = 0; i != v11; ++i)
        *(void *)(*(void *)(a1 + 672) + 8 * i) = 0;
    }
    *(void *)(a1 + 696) = 0;
    uint64_t v7 = a4;
    goto LABEL_22;
  }
LABEL_23:
  unint64_t v13 = *(unsigned char **)(a3 + 8);
  uint64_t v14 = *(void *)(a3 + 16);
  int v15 = v13[1];
  *(unsigned char *)(a1 + 921) = v15;
  double v16 = fabs(*(double *)(v14 + 40));
  BOOL v17 = *(void *)(v8 + 320) != 0;
  *(unsigned char *)(a1 + 920) = v16 > 0.0001;
  *(unsigned char *)(v7 + 209) = v17;
  BOOL v18 = v16 > 0.0001 && v15 == 0;
  v20 = !v18 || !*v13 || (unint64_t v19 = *(void **)(v7 + 160), v19[21] != v19[20]) || v19[24] != v19[23];
  *(unsigned char *)(v7 + 177) = v20;
  v253[0] = &unk_1EF5700F8;
  v253[1] = a1;
  v253[2] = v7;
  v254 = v253;
  md::OverlaysLogic::_forEachOverlayLevelAndFallback((uint64_t)v253);
  if (v254 == v253)
  {
    (*(void (**)(void *))(v253[0] + 32))(v253);
    if (*(void *)(v7 + 152)) {
      goto LABEL_35;
    }
    goto LABEL_43;
  }
  if (v254) {
    (*(void (**)(void))(*v254 + 40))();
  }
  if (!*(void *)(v7 + 152)) {
LABEL_43:
  }
    *(void *)(v7 + 152) = *(void *)(a1 + 744);
LABEL_35:
  uint64_t v21 = *(void *)(a1 + 712);
  std::mutex::lock((std::mutex *)(v21 + 232));
  int v22 = *(_DWORD *)(v21 + 348);
  std::mutex::unlock((std::mutex *)(v21 + 232));
  if (v22 == *(_DWORD *)(a1 + 728)) {
    goto LABEL_189;
  }
  memset(buf, 0, sizeof(buf));
  float v252 = 1.0;
  long long v240 = 0u;
  long long v241 = 0u;
  float v242 = 1.0;
  *(_OWORD *)__p = 0u;
  long long v238 = 0u;
  int v239 = 1065353216;
  uint64_t v23 = *(void *)(a1 + 712);
  std::mutex::lock((std::mutex *)(v23 + 232));
  int v222 = v22;
  v234 = 0;
  v235 = 0;
  uint64_t v236 = 0;
  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v234, *(void *)(v23 + 160), *(void *)(v23 + 168), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v23 + 168) - *(void *)(v23 + 160)) >> 3));
  std::mutex::unlock((std::mutex *)(v23 + 232));
  uint64_t v25 = v234;
  uint64_t v24 = v235;
  if (v234)
  {
    if (v235 == v234)
    {
      uint64_t v30 = v235;
    }
    else
    {
      uint64_t v26 = v235 - 24;
      unint64_t v27 = v235 - 24;
      uint64_t v28 = v235 - 24;
      do
      {
        uint64_t v29 = *(void (***)(char *))v28;
        v28 -= 24;
        (*v29)(v27);
        v26 -= 24;
        BOOL v18 = v27 == v25;
        unint64_t v27 = v28;
      }
      while (!v18);
      uint64_t v30 = v234;
    }
    operator delete(v30);
  }
  uint64_t v225 = v14;
  if (v24 != v25)
  {
    uint64_t v31 = *(void *)(a1 + 712);
    std::mutex::lock((std::mutex *)(v31 + 232));
    v234 = 0;
    v235 = 0;
    uint64_t v236 = 0;
    std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v234, *(void *)(v31 + 160), *(void *)(v31 + 168), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v31 + 168) - *(void *)(v31 + 160)) >> 3));
    std::mutex::unlock((std::mutex *)(v31 + 232));
    uint64_t v32 = v234;
    uint64_t v33 = v235;
    unint64_t prime = vcvtps_u32_f32((float)(0xAAAAAAAAAAAAAAABLL * ((v235 - v234) >> 3)) / v252);
    if (prime == 1)
    {
      unint64_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      unint64_t prime = std::__next_prime(prime);
    }
    int8x8_t v35 = buf[1];
    if (prime > *(void *)&buf[1]) {
      goto LABEL_53;
    }
    if (prime < *(void *)&buf[1])
    {
      unint64_t v36 = vcvtps_u32_f32((float)(unint64_t)buf[3] / v252);
      if (*(void *)&buf[1] < 3uLL
        || (uint8x8_t v37 = (uint8x8_t)vcnt_s8(buf[1]), v37.i16[0] = vaddlv_u8(v37), v37.u32[0] > 1uLL))
      {
        unint64_t v36 = std::__next_prime(v36);
      }
      else
      {
        uint64_t v38 = 1 << -(char)__clz(v36 - 1);
        if (v36 >= 2) {
          unint64_t v36 = v38;
        }
      }
      if (prime <= v36) {
        unint64_t prime = v36;
      }
      if (prime < *(void *)&v35) {
LABEL_53:
      }
        std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)buf, prime);
    }
    if (v32)
    {
      if (v33 != v32)
      {
        BOOL v39 = v33 - 24;
        uint64_t v40 = v39;
        uint64_t v41 = v39;
        do
        {
          uint64_t v42 = *(void (***)(char *))v41;
          v41 -= 24;
          (*v42)(v40);
          v39 -= 24;
          BOOL v18 = v40 == v32;
          uint64_t v40 = v41;
        }
        while (!v18);
        uint64_t v33 = v234;
      }
      operator delete(v33);
    }
    uint64_t v43 = *(void *)(a1 + 712);
    std::mutex::lock((std::mutex *)(v43 + 232));
    v234 = 0;
    v235 = 0;
    uint64_t v236 = 0;
    std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v234, *(void *)(v43 + 160), *(void *)(v43 + 168), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v43 + 168) - *(void *)(v43 + 160)) >> 3));
    std::mutex::unlock((std::mutex *)(v43 + 232));
    uint64_t v45 = (id *)v234;
    uint64_t v44 = (id *)v235;
    if (v234 == v235)
    {
      if (!v234) {
        goto LABEL_85;
      }
      goto LABEL_84;
    }
    uint64_t v46 = (id *)v234;
    do
    {
      uint64_t v232 = &unk_1EF559F78;
      id v233 = 0;
      id v233 = v46[1];
      id v47 = v233;
      unsigned int v48 = [v47 identifier];
      std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,unsigned int,unsigned int>((uint64_t)buf, v48, v48, buf[3].i32[0]);

      id v49 = v233;
      unint64_t v50 = [v49 rasterTileProvider];

      if (v50 && [v50 keyframesCount] >= 2)
      {
        id v51 = v233;
        unsigned int v52 = [v51 identifier];
        id v53 = v50;
        __int16 v228 = [v53 keyframesCount];
        [v53 duration];
        uint64_t v229 = v54;
        char v230 = [v53 crossfadeKeyframes];
        char v231 = 0;

        std::__hash_table<std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>>>::__emplace_unique_key_args<unsigned int,unsigned int,md::OverlaysContext::KeyframeAnimationParameters>((float *)__p, v52, v52, (uint64_t)&v228);
      }

      uint64_t v232 = &unk_1EF559F78;
      v46 += 3;
    }
    while (v46 != v44);
    uint64_t v14 = v225;
    if (v45)
    {
      if (v45 != v44)
      {
        uint64_t v55 = (char *)(v44 - 3);
        BOOL v56 = v55;
        unint64_t v57 = v55;
        do
        {
          uint64_t v58 = *(void (***)(char *))v57;
          v57 -= 24;
          (*v58)(v56);
          v55 -= 24;
          BOOL v18 = v56 == (char *)v45;
          BOOL v56 = v57;
        }
        while (!v18);
        uint64_t v45 = (id *)v234;
      }
LABEL_84:
      operator delete(v45);
    }
  }
LABEL_85:
  uint64_t v59 = *(void *)(a1 + 712);
  std::mutex::lock((std::mutex *)(v59 + 232));
  v234 = 0;
  v235 = 0;
  uint64_t v236 = 0;
  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v234, *(void *)(v59 + 184), *(void *)(v59 + 192), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v59 + 192) - *(void *)(v59 + 184)) >> 3));
  std::mutex::unlock((std::mutex *)(v59 + 232));
  uint64_t v61 = v234;
  uint64_t v60 = v235;
  if (v234)
  {
    if (v235 == v234)
    {
      unint64_t v66 = v235;
    }
    else
    {
      uint64_t v62 = v235 - 24;
      uint64_t v63 = v235 - 24;
      uint64_t v64 = v235 - 24;
      do
      {
        unint64_t v65 = *(void (***)(char *))v64;
        v64 -= 24;
        (*v65)(v63);
        v62 -= 24;
        BOOL v18 = v63 == v61;
        uint64_t v63 = v64;
      }
      while (!v18);
      unint64_t v66 = v234;
    }
    operator delete(v66);
  }
  if (v60 == v61) {
    goto LABEL_131;
  }
  uint64_t v67 = *(void *)(a1 + 712);
  std::mutex::lock((std::mutex *)(v67 + 232));
  v234 = 0;
  v235 = 0;
  uint64_t v236 = 0;
  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v234, *(void *)(v67 + 184), *(void *)(v67 + 192), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v67 + 192) - *(void *)(v67 + 184)) >> 3));
  std::mutex::unlock((std::mutex *)(v67 + 232));
  uint64_t v68 = v234;
  unint64_t v69 = v235;
  unint64_t v70 = vcvtps_u32_f32((float)(0xAAAAAAAAAAAAAAABLL * ((v235 - v234) >> 3)) / v242);
  if (v70 == 1)
  {
    unint64_t v70 = 2;
  }
  else if ((v70 & (v70 - 1)) != 0)
  {
    unint64_t v70 = std::__next_prime(v70);
  }
  unint64_t v71 = *((void *)&v240 + 1);
  if (v70 > *((void *)&v240 + 1)) {
    goto LABEL_99;
  }
  if (v70 < *((void *)&v240 + 1))
  {
    unint64_t v72 = vcvtps_u32_f32((float)*((unint64_t *)&v241 + 1) / v242);
    if (*((void *)&v240 + 1) < 3uLL
      || (uint8x8_t v73 = (uint8x8_t)vcnt_s8(*(int8x8_t *)((char *)&v240 + 8)), v73.i16[0] = vaddlv_u8(v73), v73.u32[0] > 1uLL))
    {
      unint64_t v72 = std::__next_prime(v72);
    }
    else
    {
      uint64_t v74 = 1 << -(char)__clz(v72 - 1);
      if (v72 >= 2) {
        unint64_t v72 = v74;
      }
    }
    if (v70 <= v72) {
      unint64_t v70 = v72;
    }
    if (v70 < v71) {
LABEL_99:
    }
      std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)&v240, v70);
  }
  if (v68)
  {
    if (v69 != v68)
    {
      uint64_t v75 = v69 - 24;
      unint64_t v76 = v75;
      uint64_t v77 = v75;
      do
      {
        uint64_t v78 = *(void (***)(char *))v77;
        v77 -= 24;
        (*v78)(v76);
        v75 -= 24;
        BOOL v18 = v76 == v68;
        unint64_t v76 = v77;
      }
      while (!v18);
      unint64_t v69 = v234;
    }
    operator delete(v69);
  }
  uint64_t v79 = *(void *)(a1 + 712);
  std::mutex::lock((std::mutex *)(v79 + 232));
  v234 = 0;
  v235 = 0;
  uint64_t v236 = 0;
  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(&v234, *(void *)(v79 + 184), *(void *)(v79 + 192), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v79 + 192) - *(void *)(v79 + 184)) >> 3));
  std::mutex::unlock((std::mutex *)(v79 + 232));
  uint64_t v81 = (id *)v234;
  uint64_t v80 = (id *)v235;
  if (v234 != v235)
  {
    uint64_t v82 = (id *)v234;
    do
    {
      uint64_t v232 = &unk_1EF559F78;
      id v233 = 0;
      id v233 = v82[1];
      id v83 = v233;
      unsigned int v84 = [v83 identifier];
      std::__hash_table<std::__hash_value_type<unsigned int,unsigned int>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,unsigned int>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,unsigned int>>>::__emplace_unique_key_args<unsigned int,unsigned int,unsigned int>((uint64_t)&v240, v84, v84, SDWORD2(v241));

      id v85 = v233;
      uint64_t v86 = [v85 rasterTileProvider];

      if (v86 && [v86 keyframesCount] >= 2)
      {
        id v87 = v233;
        unsigned int v88 = [v87 identifier];
        id v89 = v86;
        __int16 v228 = [v89 keyframesCount];
        [v89 duration];
        uint64_t v229 = v90;
        char v230 = [v89 crossfadeKeyframes];
        char v231 = 0;

        std::__hash_table<std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,md::OverlaysContext::KeyframeAnimationParameters>>>::__emplace_unique_key_args<unsigned int,unsigned int,md::OverlaysContext::KeyframeAnimationParameters>((float *)__p, v88, v88, (uint64_t)&v228);
      }

      uint64_t v232 = &unk_1EF559F78;
      v82 += 3;
    }
    while (v82 != v80);
    uint64_t v14 = v225;
    if (!v81) {
      goto LABEL_131;
    }
    if (v81 != v80)
    {
      uint64_t v91 = (char *)(v80 - 3);
      uint64_t v92 = v91;
      uint64_t v93 = v91;
      do
      {
        uint64_t v94 = *(void (***)(char *))v93;
        v93 -= 24;
        (*v94)(v92);
        v91 -= 24;
        BOOL v18 = v92 == (char *)v81;
        uint64_t v92 = v93;
      }
      while (!v18);
      uint64_t v81 = (id *)v234;
    }
    goto LABEL_130;
  }
  uint64_t v14 = v225;
  if (v234) {
LABEL_130:
  }
    operator delete(v81);
LABEL_131:
  *(_DWORD *)(a1 + 728) = v222;
  if (*(void *)(a4 + 24))
  {
    uint64_t v95 = *(void **)(a4 + 16);
    if (v95)
    {
      do
      {
        uint64_t v96 = (void *)*v95;
        operator delete(v95);
        uint64_t v95 = v96;
      }
      while (v96);
    }
    *(void *)(a4 + 16) = 0;
    uint64_t v97 = *(void *)(a4 + 8);
    if (v97)
    {
      for (uint64_t j = 0; j != v97; ++j)
        *(void *)(*(void *)a4 + 8 * j) = 0;
    }
    *(void *)(a4 + 24) = 0;
  }
  int8x8_t v99 = buf[0];
  buf[0] = 0;
  uint64_t v100 = *(void **)a4;
  *(int8x8_t *)a4 = v99;
  if (v100) {
    operator delete(v100);
  }
  int8x8_t v101 = buf[1];
  int8x8_t v102 = buf[2];
  *(int8x8_t *)(a4 + 16) = buf[2];
  *(int8x8_t *)(a4 + 8) = v101;
  buf[1] = 0;
  int8x8_t v103 = buf[3];
  *(int8x8_t *)(a4 + 24) = buf[3];
  *(float *)(a4 + 32) = v252;
  if (v103)
  {
    unint64_t v104 = *(void *)(*(void *)&v102 + 8);
    if ((*(void *)&v101 & (*(void *)&v101 - 1)) != 0)
    {
      if (v104 >= *(void *)&v101) {
        v104 %= *(void *)&v101;
      }
    }
    else
    {
      v104 &= *(void *)&v101 - 1;
    }
    *(void *)(*(void *)a4 + 8 * v104) = a4 + 16;
    buf[2] = 0;
    buf[3] = 0;
  }
  if (*(void *)(a4 + 64))
  {
    uint64_t v105 = *(void **)(a4 + 56);
    if (v105)
    {
      do
      {
        uint64_t v106 = (void *)*v105;
        operator delete(v105);
        uint64_t v105 = v106;
      }
      while (v106);
    }
    *(void *)(a4 + 56) = 0;
    uint64_t v107 = *(void *)(a4 + 48);
    if (v107)
    {
      for (uint64_t k = 0; k != v107; ++k)
        *(void *)(*(void *)(a4 + 40) + 8 * k) = 0;
    }
    *(void *)(a4 + 64) = 0;
  }
  uint64_t v109 = v240;
  *(void *)&long long v240 = 0;
  uint64_t v110 = *(void **)(a4 + 40);
  *(void *)(a4 + 40) = v109;
  if (v110) {
    operator delete(v110);
  }
  unint64_t v111 = *((void *)&v240 + 1);
  uint64_t v112 = v241;
  *(void *)(a4 + 56) = v241;
  *(void *)(a4 + 48) = v111;
  *((void *)&v240 + 1) = 0;
  uint64_t v113 = *((void *)&v241 + 1);
  *(void *)(a4 + 64) = *((void *)&v241 + 1);
  *(float *)(a4 + 72) = v242;
  if (v113)
  {
    unint64_t v114 = *(void *)(v112 + 8);
    if ((v111 & (v111 - 1)) != 0)
    {
      if (v114 >= v111) {
        v114 %= v111;
      }
    }
    else
    {
      v114 &= v111 - 1;
    }
    *(void *)(*(void *)(a4 + 40) + 8 * v114) = a4 + 56;
    long long v241 = 0uLL;
  }
  if (*(void *)(a4 + 136))
  {
    uint64_t v115 = *(void **)(a4 + 128);
    if (v115)
    {
      do
      {
        uint64_t v116 = (void *)*v115;
        operator delete(v115);
        uint64_t v115 = v116;
      }
      while (v116);
    }
    *(void *)(a4 + 128) = 0;
    uint64_t v117 = *(void *)(a4 + 120);
    if (v117)
    {
      for (uint64_t m = 0; m != v117; ++m)
        *(void *)(*(void *)(a4 + 112) + 8 * m) = 0;
    }
    *(void *)(a4 + 136) = 0;
  }
  uint64_t v119 = __p[0];
  __p[0] = 0;
  uint64_t v120 = *(void **)(a4 + 112);
  *(void *)(a4 + 112) = v119;
  if (v120) {
    operator delete(v120);
  }
  unint64_t v122 = (unint64_t)__p[1];
  uint64_t v121 = (void *)v238;
  *(void *)(a4 + 128) = v238;
  *(void *)(a4 + 120) = v122;
  __p[1] = 0;
  uint64_t v123 = *((void *)&v238 + 1);
  *(void *)(a4 + 136) = *((void *)&v238 + 1);
  *(_DWORD *)(a4 + 144) = v239;
  if (v123)
  {
    unint64_t v124 = v121[1];
    if ((v122 & (v122 - 1)) != 0)
    {
      if (v124 >= v122) {
        v124 %= v122;
      }
    }
    else
    {
      v124 &= v122 - 1;
    }
    *(void *)(*(void *)(a4 + 112) + 8 * v124) = a4 + 128;
    long long v238 = 0uLL;
  }
  else if (v121)
  {
    do
    {
      unint64_t v125 = (void *)*v121;
      operator delete(v121);
      uint64_t v121 = v125;
    }
    while (v125);
  }
  uint64_t v126 = __p[0];
  __p[0] = 0;
  if (v126) {
    operator delete(v126);
  }
  uint64_t v127 = (void *)v241;
  if ((void)v241)
  {
    do
    {
      uint64_t v128 = (void *)*v127;
      operator delete(v127);
      uint64_t v127 = v128;
    }
    while (v128);
  }
  uint64_t v129 = (void *)v240;
  *(void *)&long long v240 = 0;
  if (v129) {
    operator delete(v129);
  }
  uint64_t v130 = (void *)buf[2];
  if (buf[2])
  {
    do
    {
      unint64_t v131 = (void *)*v130;
      operator delete(v130);
      uint64_t v130 = v131;
    }
    while (v131);
  }
  uint64_t v132 = (void *)buf[0];
  buf[0] = 0;
  if (v132) {
    operator delete(v132);
  }
LABEL_189:
  uint64_t v133 = *(void *)(a1 + 712);
  std::mutex::lock((std::mutex *)(v133 + 232));
  memset(buf, 0, 24);
  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(buf, *(void *)(v133 + 160), *(void *)(v133 + 168), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v133 + 168) - *(void *)(v133 + 160)) >> 3));
  std::mutex::unlock((std::mutex *)(v133 + 232));
  uint64_t v134 = (void (***)(void))buf[0];
  int8x8_t v135 = buf[1];
  md::OverlaysLogic::updateKeyframeAnimationOverrides(*(void *)buf, *(void *)&buf[1], a4);
  if (v134)
  {
    if (*(void (****)(void))&v135 != v134)
    {
      uint64_t v136 = (void (***)(void))(*(void *)&v135 - 24);
      uint64_t v137 = v136;
      uint64_t v138 = v136;
      do
      {
        uint64_t v139 = *v138;
        v138 -= 3;
        (*v139)(v137);
        v136 -= 3;
        BOOL v18 = v137 == v134;
        uint64_t v137 = v138;
      }
      while (!v18);
      uint64_t v134 = (void (***)(void))buf[0];
    }
    operator delete(v134);
  }
  uint64_t v140 = *(void *)(a1 + 712);
  std::mutex::lock((std::mutex *)(v140 + 232));
  memset(buf, 0, 24);
  std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(buf, *(void *)(v140 + 184), *(void *)(v140 + 192), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(v140 + 192) - *(void *)(v140 + 184)) >> 3));
  std::mutex::unlock((std::mutex *)(v140 + 232));
  uint64_t v141 = (void (***)(void))buf[0];
  int8x8_t v142 = buf[1];
  md::OverlaysLogic::updateKeyframeAnimationOverrides(*(void *)buf, *(void *)&buf[1], a4);
  if (v141)
  {
    if (*(void (****)(void))&v142 != v141)
    {
      uint64_t v143 = (void (***)(void))(*(void *)&v142 - 24);
      uint64_t v144 = v143;
      uint64_t v145 = v143;
      do
      {
        uint64_t v146 = *v145;
        v145 -= 3;
        (*v146)(v144);
        v143 -= 3;
        BOOL v18 = v144 == v141;
        uint64_t v144 = v145;
      }
      while (!v18);
      uint64_t v141 = (void (***)(void))buf[0];
    }
    operator delete(v141);
  }
  md::OverlaysLogic::updateOverlays((md::OverlaysLogic *)a1, a2);
  if (*(unsigned char *)(a1 + 923))
  {
    v248 = (void (**)(void **))&unk_1EF570140;
    uint64_t v249 = a1;
    v250 = (void **)&v248;
    std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::clear(*(void **)(a1 + 640));
    if (*(void *)(a1 + 696))
    {
      uint64_t v147 = *(void **)(a1 + 688);
      if (v147)
      {
        do
        {
          unint64_t v148 = (void *)*v147;
          buf[0] = (int8x8_t)(v147 + 3);
          std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
          operator delete(v147);
          uint64_t v147 = v148;
        }
        while (v148);
      }
      *(void *)(a1 + 688) = 0;
      uint64_t v149 = *(void *)(a1 + 680);
      if (v149)
      {
        for (uint64_t n = 0; n != v149; ++n)
          *(void *)(*(void *)(a1 + 672) + 8 * n) = 0;
      }
      *(void *)(a1 + 696) = 0;
    }
    if (v250 == (void **)&v248)
    {
      v248[4]((void **)&v248);
    }
    else if (v250)
    {
      (*((void (**)(void))*v250 + 5))();
    }
    v248 = (void (**)(void **))&unk_1EF570140;
    uint64_t v249 = a1;
    v250 = (void **)&v248;
    std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::clear(*(void **)(a1 + 648));
    if (*(void *)(a1 + 696))
    {
      v151 = *(void **)(a1 + 688);
      if (v151)
      {
        do
        {
          uint64_t v152 = (void *)*v151;
          buf[0] = (int8x8_t)(v151 + 3);
          std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
          operator delete(v151);
          v151 = v152;
        }
        while (v152);
      }
      *(void *)(a1 + 688) = 0;
      uint64_t v153 = *(void *)(a1 + 680);
      if (v153)
      {
        for (iuint64_t i = 0; ii != v153; ++ii)
          *(void *)(*(void *)(a1 + 672) + 8 * ii) = 0;
      }
      *(void *)(a1 + 696) = 0;
    }
    if (v250 == (void **)&v248)
    {
      v248[4]((void **)&v248);
    }
    else if (v250)
    {
      (*((void (**)(void))*v250 + 5))();
    }
    v248 = (void (**)(void **))&unk_1EF570140;
    uint64_t v249 = a1;
    v250 = (void **)&v248;
    std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::clear(*(void **)(a1 + 656));
    if (*(void *)(a1 + 696))
    {
      unint64_t v155 = *(void **)(a1 + 688);
      if (v155)
      {
        do
        {
          uint64_t v156 = (void *)*v155;
          buf[0] = (int8x8_t)(v155 + 3);
          std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
          operator delete(v155);
          unint64_t v155 = v156;
        }
        while (v156);
      }
      *(void *)(a1 + 688) = 0;
      uint64_t v157 = *(void *)(a1 + 680);
      if (v157)
      {
        for (juint64_t j = 0; jj != v157; ++jj)
          *(void *)(*(void *)(a1 + 672) + 8 * jj) = 0;
      }
      *(void *)(a1 + 696) = 0;
    }
    if (v250 == (void **)&v248)
    {
      v248[4]((void **)&v248);
    }
    else if (v250)
    {
      (*((void (**)(void))*v250 + 5))();
    }
    v248 = (void (**)(void **))&unk_1EF570140;
    uint64_t v249 = a1;
    v250 = (void **)&v248;
    std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::clear(*(void **)(a1 + 664));
    if (*(void *)(a1 + 696))
    {
      uint64_t v159 = *(void **)(a1 + 688);
      if (v159)
      {
        do
        {
          uint64_t v160 = (void *)*v159;
          buf[0] = (int8x8_t)(v159 + 3);
          std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>::__destroy_vector::operator()[abi:nn180100]((void ***)buf);
          operator delete(v159);
          uint64_t v159 = v160;
        }
        while (v160);
      }
      *(void *)(a1 + 688) = 0;
      uint64_t v161 = *(void *)(a1 + 680);
      if (v161)
      {
        for (kuint64_t k = 0; kk != v161; ++kk)
          *(void *)(*(void *)(a1 + 672) + 8 * kk) = 0;
      }
      *(void *)(a1 + 696) = 0;
    }
    if (v250 == (void **)&v248)
    {
      v248[4]((void **)&v248);
    }
    else if (v250)
    {
      (*((void (**)(void))*v250 + 5))();
      *(unsigned char *)(a1 + 923) = 0;
      goto LABEL_265;
    }
    *(unsigned char *)(a1 + 923) = 0;
  }
  else
  {
    v245 = (void (**)(void **))&unk_1EF570188;
    uint64_t v246 = a1;
    v247 = (void **)&v245;
    _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__6NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEEclES1E_S1N_((uint64_t)&v245, (int8x8_t **)(a1 + 640), (void *)(a1 + 344));
    if (v247 == (void **)&v245)
    {
      v245[4]((void **)&v245);
    }
    else if (v247)
    {
      (*((void (**)(void))*v247 + 5))();
    }
    v245 = (void (**)(void **))&unk_1EF570188;
    uint64_t v246 = a1;
    v247 = (void **)&v245;
    _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__6NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEEclES1E_S1N_((uint64_t)&v245, (int8x8_t **)(a1 + 648), (void *)(a1 + 384));
    if (v247 == (void **)&v245)
    {
      v245[4]((void **)&v245);
    }
    else if (v247)
    {
      (*((void (**)(void))*v247 + 5))();
    }
    v245 = (void (**)(void **))&unk_1EF570188;
    uint64_t v246 = a1;
    v247 = (void **)&v245;
    _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__6NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEEclES1E_S1N_((uint64_t)&v245, (int8x8_t **)(a1 + 656), (void *)(a1 + 424));
    if (v247 == (void **)&v245)
    {
      v245[4]((void **)&v245);
    }
    else if (v247)
    {
      (*((void (**)(void))*v247 + 5))();
    }
    v245 = (void (**)(void **))&unk_1EF570188;
    uint64_t v246 = a1;
    v247 = (void **)&v245;
    _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__6NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEEclES1E_S1N_((uint64_t)&v245, (int8x8_t **)(a1 + 664), (void *)(a1 + 464));
    if (v247 == (void **)&v245)
    {
      v245[4]((void **)&v245);
    }
    else if (v247)
    {
      (*((void (**)(void))*v247 + 5))();
    }
  }
LABEL_265:
  uint64_t v163 = *(void *)(md::LayoutContext::frameState(a2) + 88);
  uint64_t v164 = *((void *)a2 + 10);
  v165.n128_f32[0] = *(float *)(v14 + 3080) + *(float *)(v14 + 3076);
  float v166 = fmaxf(v165.n128_f32[0], 1.0);
  uint64_t v167 = *(void **)(a1 + 712);
  uint64_t v168 = v167[20];
  uint64_t v169 = v167[21];
  if (v168 == v169)
  {
LABEL_268:
    uint64_t v173 = v167[23];
    uint64_t v174 = v167[24];
    if (v173 == v174) {
      goto LABEL_282;
    }
    uint64_t v175 = v173 + 24;
    do
    {
      id v176 = *(id *)(v175 - 16);
      v177 = [v176 customTileProvider];

      BOOL v178 = v175 == v174 || v177 != 0;
      v175 += 24;
    }
    while (!v178);
    if (!v177) {
      goto LABEL_282;
    }
  }
  else
  {
    while (1)
    {
      id v170 = *(id *)(v168 + 8);
      v171 = [v170 customTileProvider];
      BOOL v172 = v171 == 0;

      if (!v172) {
        break;
      }
      v168 += 24;
      if (v168 == v169) {
        goto LABEL_268;
      }
    }
  }
  uint64_t v179 = *(void *)(a1 + 744);
  v244 = 0;
  v180 = (float *)operator new(0x28uLL);
  *(void *)v180 = &unk_1EF56FFD8;
  *((void *)v180 + 1) = a1;
  *((void *)v180 + 2) = v163;
  *((void *)v180 + 3) = v164;
  v180[8] = v166;
  v244 = v180;
  geo::TaskQueue::async(&v226, v179, v243);
  v181 = v227;
  if (v227 && !atomic_fetch_add(&v227->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v181->__on_zero_shared)(v181);
    std::__shared_weak_count::__release_weak(v181);
  }
  if (v244 == (float *)v243)
  {
    __n128 v165 = ((__n128 (*)(void *))*(void *)(v243[0] + 32))(v243);
  }
  else if (v244)
  {
    (*(void (**)(void))(*(void *)v244 + 40))();
  }
LABEL_282:
  v165.n128_u8[0] = *(unsigned char *)(a1 + 924);
  *(unsigned char *)(a4 + 176) = v166 >= (float)v165.n128_u32[0];
  unint64_t v182 = *(void **)(a4 + 184);
  *(void *)(a4 + 192) = v182;
  unint64_t v183 = *(void *)(a1 + 176);
  if (v183 > (uint64_t)(*(void *)(a4 + 200) - (void)v182) >> 5)
  {
    if (v183 >> 59) {
      abort();
    }
    v184 = (char *)operator new(32 * v183);
    *(void *)(a4 + 184) = v184;
    *(void *)(a4 + 192) = v184;
    *(void *)(a4 + 200) = &v184[32 * v183];
    if (v182) {
      operator delete(v182);
    }
  }
  v185 = *(void **)(a1 + 160);
  if (v185 != (void *)(a1 + 168))
  {
    do
    {
      v186 = (void *)v185[5];
      int8x8_t v187 = (int8x8_t)v186[1];
      if (!*(void *)&v187) {
        goto LABEL_314;
      }
      uint8x8_t v188 = (uint8x8_t)vcnt_s8(v187);
      v188.i16[0] = vaddlv_u8(v188);
      if (v188.u32[0] > 1uLL)
      {
        uint64_t v189 = 0x64A448A5CD5D38DBLL;
        if (*(void *)&v187 <= 0x64A448A5CD5D38DBuLL) {
          uint64_t v189 = 0x64A448A5CD5D38DBuLL % *(void *)&v187;
        }
      }
      else
      {
        uint64_t v189 = (*(void *)&v187 - 1) & 0x64A448A5CD5D38DBLL;
      }
      uint64_t v190 = *(void **)(*v186 + 8 * v189);
      if (!v190 || (uint64_t v191 = (void *)*v190) == 0)
      {
LABEL_314:
        if (GEOGetVectorKitOverlaysLogicLog(void)::onceToken != -1) {
          dispatch_once(&GEOGetVectorKitOverlaysLogicLog(void)::onceToken, &__block_literal_global_31);
        }
        int v204 = (id)GEOGetVectorKitOverlaysLogicLog(void)::log;
        if (os_log_type_enabled(v204, OS_LOG_TYPE_ERROR))
        {
          buf[0].i32[0] = 136315650;
          *(int8x8_t *)((char *)buf + 4) = (int8x8_t)"transformData";
          buf[1].i16[2] = 2080;
          *(int8x8_t *)((char *)&buf[1] + 6) = (int8x8_t)"/Library/Caches/com.apple.xbs/Sources/VectorKit/src/Overlays/OverlaysLogic.mm";
          buf[2].i16[3] = 1024;
          buf[3].i32[0] = 743;
          _os_log_impl(&dword_1A1780000, v204, OS_LOG_TYPE_ERROR, "Invalid SharedTransformData.: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)buf, 0x1Cu);
        }

        int v205 = (void *)v185[1];
        if (!v205) {
          goto LABEL_335;
        }
        do
        {
LABEL_319:
          int v206 = v205;
          int v205 = (void *)*v205;
        }
        while (v205);
        goto LABEL_288;
      }
      if (v188.u32[0] < 2uLL)
      {
        uint64_t v192 = *(void *)&v187 - 1;
        while (1)
        {
          uint64_t v194 = v191[1];
          if (v194 == 0x64A448A5CD5D38DBLL)
          {
            if (v191[2] == 0x64A448A5CD5D38DBLL) {
              goto LABEL_310;
            }
          }
          else if ((v194 & v192) != v189)
          {
            goto LABEL_314;
          }
          uint64_t v191 = (void *)*v191;
          if (!v191) {
            goto LABEL_314;
          }
        }
      }
      while (1)
      {
        unint64_t v193 = v191[1];
        if (v193 == 0x64A448A5CD5D38DBLL) {
          break;
        }
        if (v193 >= *(void *)&v187) {
          v193 %= *(void *)&v187;
        }
        if (v193 != v189) {
          goto LABEL_314;
        }
LABEL_299:
        uint64_t v191 = (void *)*v191;
        if (!v191) {
          goto LABEL_314;
        }
      }
      if (v191[2] != 0x64A448A5CD5D38DBLL) {
        goto LABEL_299;
      }
LABEL_310:
      uint64_t v195 = v191[5];
      if (*(void *)(v195 + 8) != 0x64A448A5CD5D38DBLL) {
        goto LABEL_314;
      }
      v196 = *(char **)(v195 + 32);
      if (!v196) {
        goto LABEL_314;
      }
      char v197 = v196[1];
      int v199 = *((_DWORD *)v196 + 1);
      int v198 = *((_DWORD *)v196 + 2);
      char v200 = *v196;
      v202 = *(unsigned char **)(a4 + 192);
      unint64_t v201 = *(void *)(a4 + 200);
      if ((unint64_t)v202 >= v201)
      {
        int v207 = *(unsigned char **)(a4 + 184);
        uint64_t v208 = (v202 - v207) >> 5;
        unint64_t v209 = v208 + 1;
        if ((unint64_t)(v208 + 1) >> 59) {
          abort();
        }
        char v219 = v200;
        char v220 = v197;
        int v221 = v199;
        int v223 = v198;
        uint64_t v210 = v201 - (void)v207;
        if (v210 >> 4 > v209) {
          unint64_t v209 = v210 >> 4;
        }
        if ((unint64_t)v210 >= 0x7FFFFFFFFFFFFFE0) {
          unint64_t v209 = 0x7FFFFFFFFFFFFFFLL;
        }
        if (v209 >> 59) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        unint64_t v218 = v209;
        v211 = (char *)operator new(32 * v209);
        v212 = &v211[32 * v208];
        char *v212 = v219;
        v212[1] = v220;
        *((_DWORD *)v212 + 1) = v221;
        *((_DWORD *)v212 + 2) = v223;
        *((void *)v212 + 3) = v186;
        if (v202 == v207)
        {
          char v215 = &v211[32 * v208];
        }
        else
        {
          uint64_t v213 = 0;
          do
          {
            long long v214 = &v212[v213];
            *((_WORD *)v214 - 16) = *(_WORD *)&v202[v213 - 32];
            *(void *)(v214 - 28) = *(void *)&v202[v213 - 28];
            *((void *)v214 - 1) = *(void *)&v202[v213 - 8];
            v213 -= 32;
          }
          while (&v202[v213] != v207);
          char v215 = &v212[v213];
        }
        int v203 = v212 + 32;
        *(void *)(a4 + 184) = v215;
        *(void *)(a4 + 192) = v212 + 32;
        *(void *)(a4 + 200) = &v211[32 * v218];
        if (v207) {
          operator delete(v207);
        }
      }
      else
      {
        unsigned char *v202 = v200;
        v202[1] = v197;
        *((_DWORD *)v202 + 1) = v199;
        *((_DWORD *)v202 + 2) = v198;
        int v203 = v202 + 32;
        *((void *)v202 + 3) = v186;
      }
      *(void *)(a4 + 192) = v203;
      int v205 = (void *)v185[1];
      if (v205) {
        goto LABEL_319;
      }
      do
      {
LABEL_335:
        int v206 = (void *)v185[2];
        BOOL v18 = *v206 == (void)v185;
        v185 = v206;
      }
      while (!v18);
LABEL_288:
      v185 = v206;
    }
    while (v206 != (void *)(a1 + 168));
  }
  *(unsigned char *)(a4 + 208) = *(unsigned char *)(a1 + 922);
  if (*(unsigned char *)(a1 + 856))
  {
    v216 = (char *)operator new(4uLL);
    *(_DWORD *)v216 = 3735610;
    v217 = v216 + 4;
  }
  else
  {
    v216 = (char *)operator new(2uLL);
    *(_WORD *)v216 = 58;
    v217 = v216 + 2;
  }
  std::vector<md::MapDataType>::__assign_with_size[abi:nn180100]<md::MapDataType*,md::MapDataType*>((void *)(a4 + 216), v216, v217, (v217 - v216) >> 1);
  operator delete(v216);
  if (v262)
  {
    (*(void (**)(void *))(*v262 + 48))(v262);
    if (v262 == v261)
    {
      (*(void (**)(void *))(v261[0] + 32))(v261);
    }
    else if (v262)
    {
      (*(void (**)(void))(*v262 + 40))();
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
}

void sub_1A1A86098(_Unwind_Exception *a1)
{
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v1 - 152));
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__6NS_9allocatorISM_EEFvRNS_10unique_ptrINS_13unordered_mapINS2_10SurfaceKeyENSQ_ImNS_10shared_ptrIN3ggl16IOSurfaceTextureEEENS_4hashImEENS_8equal_toImEENSN_INS_4pairIKmSV_EEEEEENS2_14SurfaceKeyHashENS2_15SurfaceKeyEqualENSN_INS10_IKSR_S14_EEEEEENS_14default_deleteIS1A_EEEERKNS_13unordered_setIN3geo8QuadTileENS1G_12QuadTileHashENSY_IS1H_EENSN_IS1H_EEEEEEclES1E_S1N_(uint64_t a1, int8x8_t **a2, void *a3)
{
  uint64_t v3 = (int8x8_t *)(*a2)[2];
  if (v3)
  {
    uint64_t v6 = (uint64_t *)(*(void *)(a1 + 8) + 672);
    do
    {
      while (!std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::find<geo::QuadTile>(a3, (unsigned __int8 *)&v3[2]))
      {
        uint64_t v3 = (int8x8_t *)*v3;
        if (!v3) {
          return;
        }
      }
      for (uint64_t i = (void *)v3[8]; i; uint64_t i = (void *)*i)
      {
        uint64_t v8 = *(void *)(i[3] + 136);
        uint64_t v9 = std::__hash_table<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int const&>,std::tuple<>>(v6, v3[5].u32[0], &v3[5]);
        uint64_t v10 = geo::linear_map<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>,std::equal_to<unsigned char>,std::allocator<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>,std::vector<std::pair<unsigned char,std::list<std::shared_ptr<ggl::IOSurfaceTexture>>>>>::operator[](v9 + 3, *(_DWORD *)(v8 + 44));
        uint64_t v11 = operator new(0x20uLL);
        v11[1] = *(_OWORD *)(i + 3);
        i[3] = 0;
        i[4] = 0;
        uint64_t v12 = *(void *)v10;
        *(void *)uint64_t v11 = *(void *)v10;
        *((void *)v11 + 1) = v10;
        *(void *)(v12 + 8) = v11;
        *(void *)uint64_t v10 = v11;
        ++*((void *)v10 + 2);
      }
      unint64_t v13 = *a2;
      int8x8_t v14 = (*a2)[1];
      double v16 = (int8x8_t *)*v3;
      unint64_t v15 = (unint64_t)v3[1];
      uint8x8_t v17 = (uint8x8_t)vcnt_s8(v14);
      v17.i16[0] = vaddlv_u8(v17);
      if (v17.u32[0] > 1uLL)
      {
        if (v15 >= *(void *)&v14) {
          v15 %= *(void *)&v14;
        }
      }
      else
      {
        v15 &= *(void *)&v14 - 1;
      }
      BOOL v18 = *(int8x8_t **)(*(void *)v13 + 8 * v15);
      do
      {
        unint64_t v19 = v18;
        BOOL v18 = (int8x8_t *)*v18;
      }
      while (v18 != v3);
      if (v19 == &v13[2]) {
        goto LABEL_44;
      }
      unint64_t v20 = (unint64_t)v19[1];
      if (v17.u32[0] > 1uLL)
      {
        if (v20 >= *(void *)&v14) {
          v20 %= *(void *)&v14;
        }
      }
      else
      {
        v20 &= *(void *)&v14 - 1;
      }
      int8x8_t v21 = *v3;
      if (v20 != v15)
      {
LABEL_44:
        if (v16)
        {
          unint64_t v22 = (unint64_t)v16[1];
          if (v17.u32[0] > 1uLL)
          {
            if (v22 >= *(void *)&v14) {
              v22 %= *(void *)&v14;
            }
          }
          else
          {
            v22 &= *(void *)&v14 - 1;
          }
          int8x8_t v21 = *v3;
          if (v22 == v15)
          {
LABEL_27:
            unint64_t v23 = *(void *)(*(void *)&v21 + 8);
            if (v17.u32[0] > 1uLL)
            {
              if (v23 >= *(void *)&v14) {
                v23 %= *(void *)&v14;
              }
            }
            else
            {
              v23 &= *(void *)&v14 - 1;
            }
            if (v23 != v15)
            {
              *(void *)(*(void *)v13 + 8 * v23) = v19;
              int8x8_t v21 = *v3;
            }
            goto LABEL_33;
          }
        }
        *(void *)(*(void *)v13 + 8 * v15) = 0;
        int8x8_t v21 = *v3;
      }
      if (v21) {
        goto LABEL_27;
      }
LABEL_33:
      *unint64_t v19 = v21;
      int8x8_t *v3 = 0;
      --*(void *)&v13[3];
      uint64_t v24 = (void *)v3[8];
      while (v24)
      {
        uint64_t v26 = v24;
        uint64_t v24 = (void *)*v24;
        unint64_t v27 = (std::__shared_weak_count *)v26[4];
        if (v27 && !atomic_fetch_add(&v27->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v27->__on_zero_shared)(v27);
          std::__shared_weak_count::__release_weak(v27);
        }
        operator delete(v26);
      }
      uint64_t v25 = (void *)v3[6];
      v3[6] = 0;
      if (v25) {
        operator delete(v25);
      }
      operator delete(v3);
      uint64_t v3 = v16;
    }
    while (v16);
  }
}

uint64_t md::OverlaysLogic::_forEachOverlayLevelAndFallback(uint64_t a1)
{
  uint64_t v10 = 0;
  uint64_t v11 = 0;
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v2 + 48))(v2, &v11, &v10);
    uint64_t v10 = 1;
    uint64_t v11 = 0;
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48))(v3, &v11, &v10);
      uint64_t v10 = 0;
      uint64_t v11 = 1;
      uint64_t v4 = *(void *)(a1 + 24);
      if (v4)
      {
        (*(void (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v4 + 48))(v4, &v11, &v10);
        uint64_t v10 = 1;
        uint64_t v11 = 1;
        uint64_t v5 = *(void *)(a1 + 24);
        if (v5) {
          return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v5 + 48))(v5, &v11, &v10);
        }
      }
    }
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__4NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEEclEOSP_OSQ_(v7, v8, v9);
}

uint64_t _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__4NS_9allocatorISM_EEFv14VKOverlayLevel33VKOverlayResourceFallbackableModeEEclEOSP_OSQ_(uint64_t result, void *a2, void *a3)
{
  uint64_t v3 = *(void *)(result + 16) + 16 * *a2 + 80;
  if (!*(void *)(v3 + 8 * *a3)) {
    *(void *)(v3 + 8 * *a3) = *(void *)(*(void *)(result + 8) + 16 * *a2 + 8 * *a3 + 640);
  }
  return result;
}

void std::__function::__func<md::OverlaysLogic::updateVisibleTiles(md::LayoutContext const&)::$_1,std::allocator<md::OverlaysLogic::updateVisibleTiles(md::LayoutContext const&)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::operator()(uint64_t a1, int8x8_t **a2, uint64_t **a3)
{
  uint64_t v142 = *(void *)(a1 + 8);
  uint64_t v3 = *a2;
  uint64_t v4 = *a3;
  if (*a3) {
    int v5 = 71;
  }
  else {
    int v5 = 11;
  }
  if (*a3) {
    int v6 = 72;
  }
  else {
    int v6 = 12;
  }
  if (v3) {
    LODWORD(v7) = v6;
  }
  else {
    LODWORD(v7) = v5;
  }
  uint64_t v8 = **(void **)(a1 + 16);
  while (1)
  {
    uint64_t v9 = *(unsigned __int16 **)(v8 + 48);
    uint64_t v10 = *(unsigned __int16 **)(v8 + 56);
    uint64_t v11 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    if (v9 != v10)
    {
      uint64_t v12 = v9;
      while (*v12 != v7)
      {
        v12 += 16;
        if (v12 == v10) {
          goto LABEL_22;
        }
      }
      if (v12 == v10)
      {
        uint64_t v11 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
      }
      else
      {
        while (*v9 != v7)
        {
          v9 += 16;
          if (v9 == v10)
          {
            uint64_t v9 = v10;
            break;
          }
        }
        uint64_t v11 = (uint64_t *)(v9 + 4);
      }
    }
LABEL_22:
    uint64_t v13 = v142 + 80 * (void)v3 + 40 * (void)v4;
    int8x8_t v14 = (void *)(v13 + 344);
    uint64_t v144 = (unsigned __int8 **)(v142 + 48 * (void)v3 + 24 * (void)v4 + 504);
    uint64_t v140 = v13;
    if (*(void *)(v13 + 368))
    {
      unint64_t v15 = *(void **)(v13 + 360);
      if (v15)
      {
        do
        {
          double v16 = (void *)*v15;
          operator delete(v15);
          unint64_t v15 = v16;
        }
        while (v16);
      }
      _OWORD v14[2] = 0;
      uint64_t v17 = v14[1];
      if (v17)
      {
        for (uint64_t i = 0; i != v17; ++i)
          *(void *)(*v14 + 8 * i) = 0;
      }
      v14[3] = 0;
    }
    uint64_t v141 = (uint64_t)v14;
    v144[1] = *v144;
    *(_OWORD *)__p = 0u;
    *(_OWORD *)v151 = 0u;
    float v152 = 1.0;
    unint64_t v19 = (uint64_t *)*v11;
    uint64_t v143 = v11 + 1;
    if ((uint64_t *)*v11 == v11 + 1) {
      break;
    }
    uint64_t v4 = &v153;
    while (1)
    {
      uint64_t v20 = v19[4];
      unint64_t v21 = *(void *)(v20 + 848);
      uint64_t v22 = *(void *)(v20 + 856);
      uint64_t v23 = v20;
      if (v21 != v22) {
        break;
      }
LABEL_62:
      uint64_t v41 = *(unsigned __int8 *)(v20 + 169);
      uint64_t v149 = *(void *)(v20 + 172);
      uint64_t v42 = *(unsigned __int8 *)(v20 + 168);
      uint64_t v43 = v19;
      uint64_t v44 = v19[5];
      if (v44) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v44 + 8), 1uLL, memory_order_relaxed);
      }
      *(void *)&long long v45 = v23;
      *((void *)&v45 + 1) = v44;
      long long v146 = v45;
      unint64_t v46 = (v41
           - 0x61C8864680B583EBLL
           + ((v42 - 0x61C8864680B583EBLL) << 6)
           + ((unint64_t)(v42 - 0x61C8864680B583EBLL) >> 2)) ^ (v42 - 0x61C8864680B583EBLL);
      unint64_t v47 = ((int)v149 - 0x61C8864680B583EBLL + (v46 << 6) + (v46 >> 2)) ^ v46;
      unint64_t v48 = (SHIDWORD(v149) - 0x61C8864680B583EBLL + (v47 << 6) + (v47 >> 2)) ^ v47;
      unint64_t v49 = (unint64_t)__p[1];
      if (!__p[1]) {
        goto LABEL_90;
      }
      uint8x8_t v50 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
      v50.i16[0] = vaddlv_u8(v50);
      if (v50.u32[0] > 1uLL)
      {
        unint64_t v21 = (SHIDWORD(v149) - 0x61C8864680B583EBLL + (v47 << 6) + (v47 >> 2)) ^ v47;
        if ((void *)v48 >= __p[1]) {
          unint64_t v21 = v48 % (unint64_t)__p[1];
        }
      }
      else
      {
        unint64_t v21 = v48 & ((unint64_t)__p[1] - 1);
      }
      id v51 = (uint64_t **)*((void *)__p[0] + v21);
      if (!v51 || (unsigned int v52 = *v51) == 0)
      {
LABEL_90:
        BOOL v56 = (char *)operator new(0x38uLL);
        *(void *)BOOL v56 = 0;
        *((void *)v56 + 1) = v48;
        v56[16] = v42;
        v56[17] = v41;
        *(void *)(v56 + 20) = v149;
        *(_OWORD *)(v56 + 40) = v146;
        float v57 = (float)((unint64_t)v151[1] + 1);
        if (!v49 || (float)(v152 * (float)v49) < v57)
        {
          BOOL v58 = (v49 & (v49 - 1)) != 0;
          if (v49 < 3) {
            BOOL v58 = 1;
          }
          unint64_t v59 = v58 | (2 * v49);
          unint64_t v60 = vcvtps_u32_f32(v57 / v152);
          if (v59 <= v60) {
            size_t prime = v60;
          }
          else {
            size_t prime = v59;
          }
          if (prime == 1)
          {
            size_t prime = 2;
          }
          else if ((prime & (prime - 1)) != 0)
          {
            size_t prime = std::__next_prime(prime);
            unint64_t v49 = (unint64_t)__p[1];
          }
          if (prime > v49)
          {
LABEL_102:
            if (prime >> 61) {
LABEL_274:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            uint64_t v62 = operator new(8 * prime);
            uint64_t v63 = __p[0];
            __p[0] = v62;
            if (v63) {
              operator delete(v63);
            }
            uint64_t v64 = 0;
            __p[1] = (void *)prime;
            do
              *((void *)__p[0] + v64++) = 0;
            while (prime != v64);
            unint64_t v65 = (void **)v151[0];
            if (!v151[0]) {
              goto LABEL_126;
            }
            size_t v66 = *((void *)v151[0] + 1);
            size_t v67 = prime - 1;
            if ((prime & (prime - 1)) == 0)
            {
              size_t v68 = v66 & v67;
              *((void *)__p[0] + v68) = v151;
              for (uint64_t j = *v65; *v65; uint64_t j = *v65)
              {
                size_t v70 = j[1] & v67;
                if (v70 == v68)
                {
                  unint64_t v65 = (void **)j;
                }
                else if (*((void *)__p[0] + v70))
                {
                  *unint64_t v65 = (void *)*j;
                  uint64_t v71 = 8 * v70;
                  void *j = **(void **)((char *)__p[0] + v71);
                  **(void **)((char *)__p[0] + v71) = j;
                }
                else
                {
                  *((void *)__p[0] + v70) = v65;
                  unint64_t v65 = (void **)j;
                  size_t v68 = v70;
                }
              }
              goto LABEL_126;
            }
            if (v66 >= prime) {
              v66 %= prime;
            }
            *((void *)__p[0] + v66) = v151;
            uint64_t v75 = *v65;
            if (!*v65)
            {
LABEL_126:
              unint64_t v49 = prime;
              goto LABEL_127;
            }
            while (2)
            {
              size_t v77 = v75[1];
              if (v77 >= prime) {
                v77 %= prime;
              }
              if (v77 != v66)
              {
                if (!*((void *)__p[0] + v77))
                {
                  *((void *)__p[0] + v77) = v65;
LABEL_131:
                  unint64_t v65 = (void **)v75;
                  uint64_t v75 = (void *)*v75;
                  size_t v66 = v77;
                  if (!v75) {
                    goto LABEL_126;
                  }
                  continue;
                }
                *unint64_t v65 = (void *)*v75;
                uint64_t v76 = 8 * v77;
                *uint64_t v75 = **(void **)((char *)__p[0] + v76);
                **(void **)((char *)__p[0] + v76) = v75;
                uint64_t v75 = v65;
              }
              break;
            }
            size_t v77 = v66;
            goto LABEL_131;
          }
          if (prime < v49)
          {
            unint64_t v72 = vcvtps_u32_f32((float)(unint64_t)v151[1] / v152);
            if (v49 < 3 || (uint8x8_t v73 = (uint8x8_t)vcnt_s8((int8x8_t)v49), v73.i16[0] = vaddlv_u8(v73), v73.u32[0] > 1uLL))
            {
              unint64_t v72 = std::__next_prime(v72);
            }
            else
            {
              uint64_t v74 = 1 << -(char)__clz(v72 - 1);
              if (v72 >= 2) {
                unint64_t v72 = v74;
              }
            }
            if (prime <= v72) {
              size_t prime = v72;
            }
            if (prime >= v49)
            {
              unint64_t v49 = (unint64_t)__p[1];
            }
            else
            {
              if (prime) {
                goto LABEL_102;
              }
              id v83 = __p[0];
              __p[0] = 0;
              if (v83) {
                operator delete(v83);
              }
              unint64_t v49 = 0;
              __p[1] = 0;
            }
          }
LABEL_127:
          if ((v49 & (v49 - 1)) != 0)
          {
            if (v48 >= v49) {
              unint64_t v21 = v48 % v49;
            }
            else {
              unint64_t v21 = v48;
            }
          }
          else
          {
            unint64_t v21 = (v49 - 1) & v48;
          }
        }
        uint64_t v78 = __p[0];
        uint64_t v79 = (void *)*((void *)__p[0] + v21);
        uint64_t v55 = v43;
        if (v79)
        {
          *(void *)BOOL v56 = *v79;
          goto LABEL_148;
        }
        *(void **)BOOL v56 = v151[0];
        v151[0] = v56;
        v78[v21] = v151;
        if (*(void *)v56)
        {
          unint64_t v80 = *(void *)(*(void *)v56 + 8);
          if ((v49 & (v49 - 1)) != 0)
          {
            if (v80 >= v49) {
              v80 %= v49;
            }
          }
          else
          {
            v80 &= v49 - 1;
          }
          uint64_t v79 = (char *)__p[0] + 8 * v80;
LABEL_148:
          *uint64_t v79 = v56;
        }
        ++v151[1];
        goto LABEL_151;
      }
      if (v50.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v54 = v52[1];
          if (v54 == v48)
          {
            if (*((unsigned __int8 *)v52 + 16) == v42
              && *((unsigned __int8 *)v52 + 17) == v41
              && *(uint64_t *)((char *)v52 + 20) == v149)
            {
              goto LABEL_88;
            }
          }
          else if ((v54 & ((uint64_t)__p[1] - 1)) != v21)
          {
            goto LABEL_90;
          }
          unsigned int v52 = (uint64_t *)*v52;
          if (!v52) {
            goto LABEL_90;
          }
        }
      }
      while (1)
      {
        unint64_t v53 = v52[1];
        if (v53 == v48) {
          break;
        }
        if ((void *)v53 >= __p[1]) {
          v53 %= (unint64_t)__p[1];
        }
        if (v53 != v21) {
          goto LABEL_90;
        }
LABEL_74:
        unsigned int v52 = (uint64_t *)*v52;
        if (!v52) {
          goto LABEL_90;
        }
      }
      if (*((unsigned __int8 *)v52 + 16) != v42
        || *((unsigned __int8 *)v52 + 17) != v41
        || *(uint64_t *)((char *)v52 + 20) != v149)
      {
        goto LABEL_74;
      }
LABEL_88:
      uint64_t v55 = v43;
      if (*((void *)&v146 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v146 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        (*(void (**)(void))(**((void **)&v146 + 1) + 16))(*((void *)&v146 + 1));
        std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v146 + 1));
        uint64_t v81 = (uint64_t *)v43[1];
        if (v81) {
          goto LABEL_152;
        }
      }
      else
      {
LABEL_151:
        uint64_t v81 = (uint64_t *)v55[1];
        if (v81)
        {
          do
          {
LABEL_152:
            uint64_t v82 = v81;
            uint64_t v81 = (uint64_t *)*v81;
          }
          while (v81);
          goto LABEL_31;
        }
      }
      do
      {
        uint64_t v82 = (uint64_t *)v55[2];
        BOOL v115 = *v82 == (void)v55;
        uint64_t v55 = v82;
      }
      while (!v115);
LABEL_31:
      unint64_t v19 = v82;
      if (v82 == v143) {
        goto LABEL_167;
      }
    }
    uint64_t v145 = v19[4];
    unint64_t v148 = v19;
    uint64_t v3 = *(int8x8_t **)(v142 + 152);
    while (1)
    {
      uint64_t v24 = *(void *)v21;
      uint64_t v25 = (void *)gdc::Registry::storage<md::overlayComponents::TileIsInView>(v3);
      uint64_t v153 = v24;
      uint64_t v26 = geo::sparse_set<gdc::Entity,unsigned short,256ul>::insert(v25 + 4, (uint64_t)&v153);
      if (v27)
      {
        uint64_t v30 = (unsigned char *)v25[11];
        unint64_t v29 = v25[12];
        if ((unint64_t)v30 >= v29)
        {
          uint64_t v32 = (char *)v25[10];
          uint64_t v33 = v30 - v32;
          uint64_t v34 = v30 - v32 + 1;
          if (v34 < 0) {
            abort();
          }
          unint64_t v35 = v29 - (void)v32;
          if (2 * v35 > v34) {
            uint64_t v34 = 2 * v35;
          }
          if (v35 >= 0x3FFFFFFFFFFFFFFFLL) {
            size_t v36 = 0x7FFFFFFFFFFFFFFFLL;
          }
          else {
            size_t v36 = v34;
          }
          if (v36) {
            uint8x8_t v37 = (char *)operator new(v36);
          }
          else {
            uint8x8_t v37 = 0;
          }
          uint64_t v38 = &v37[v36];
          uint64_t v31 = (uint64_t)&v37[v33 + 1];
          BOOL v39 = (char *)(v32 - v30);
          if (v32 == v30) {
            BOOL v39 = 0;
          }
          v25[10] = &v37[v33 + (void)v39];
          v25[11] = v31;
          v25[12] = v38;
          if (v32) {
            operator delete(v32);
          }
        }
        else
        {
          uint64_t v31 = (uint64_t)(v30 + 1);
        }
        v25[11] = v31;
        uint64_t v8 = v25[31];
      }
      else
      {
        uint64_t v8 = v25[31];
        if (v25[10] + (((uint64_t)v26 - v25[7]) >> 3) != v25[11])
        {
          uint64_t v7 = (void *)v25[16];
          if (v7)
          {
            while (1)
            {
              unint64_t v155 = &v153;
              uint64_t v156 = 1;
              uint64_t v154 = v8;
              uint64_t v28 = v7[6];
              if (!v28) {
                goto LABEL_272;
              }
              (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v28 + 48))(v28, &v154, &v155);
              uint64_t v7 = (void *)*v7;
              if (!v7) {
                goto LABEL_34;
              }
            }
          }
          goto LABEL_34;
        }
      }
      uint64_t v7 = (void *)v25[22];
      if (v7) {
        break;
      }
LABEL_34:
      v21 += 8;
      if (v21 == v22)
      {
        unint64_t v19 = v148;
        uint64_t v23 = v148[4];
        uint64_t v20 = v145;
        goto LABEL_62;
      }
    }
    while (1)
    {
      unint64_t v155 = &v153;
      uint64_t v156 = 1;
      uint64_t v154 = v8;
      uint64_t v40 = v7[6];
      if (!v40) {
        break;
      }
      (*(void (**)(uint64_t, uint64_t *, uint64_t **))(*(void *)v40 + 48))(v40, &v154, &v155);
      uint64_t v7 = (void *)*v7;
      if (!v7) {
        goto LABEL_34;
      }
    }
LABEL_272:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
LABEL_276:
    {
      qword_1EB3176C0 = 0;
      qword_1EB3176B8 = 0;
      md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
      __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
    }
  }
LABEL_167:
  uint64_t v84 = v140 + 184;
  for (uint64_t k = *(unsigned __int8 **)(v140 + 200); k; uint64_t k = *(unsigned __int8 **)k)
  {
    if (!std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::find<geo::QuadTile>(__p, k + 16))std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::__emplace_unique_key_args<geo::QuadTile,geo::QuadTile const&>(v141, k + 16, (uint64_t)(k + 16)); {
  }
    }
  uint64_t v147 = (void *)(v140 + 200);
  uint64_t v86 = (unsigned __int8 *)v151[0];
  if (v151[0])
  {
    LOBYTE(v87) = 25;
    while (1)
    {
      if (!std::__hash_table<geo::QuadTile,geo::QuadTileHash,std::equal_to<geo::QuadTile>,std::allocator<geo::QuadTile>>::find<geo::QuadTile>((void *)v84, v86 + 16))
      {
        int v89 = v86[17];
        int v91 = *((_DWORD *)v86 + 5);
        int v90 = *((_DWORD *)v86 + 6);
        int v92 = v86[16];
        uint64_t v93 = *v144;
        uint64_t v94 = v144[1];
        uint64_t v95 = *v144;
        if (*v144 != v94)
        {
          uint64_t v95 = *v144;
          while (v92 != *v95 || v89 != v95[1] || v91 != *((_DWORD *)v95 + 1) || v90 != *((_DWORD *)v95 + 2))
          {
            v95 += 32;
            if (v95 == v94) {
              goto LABEL_188;
            }
          }
        }
        if (v95 == v94)
        {
LABEL_188:
          uint64_t v96 = v144[2];
          if (v94 < v96)
          {
            unsigned __int8 *v94 = v92;
            v94[1] = v89;
            *((_DWORD *)v94 + 1) = v91;
            *((_DWORD *)v94 + 2) = v90;
            unsigned int v88 = (char *)(v94 + 32);
            v94[24] = 0;
          }
          else
          {
            uint64_t v97 = (v94 - v93) >> 5;
            unint64_t v98 = v97 + 1;
            if ((unint64_t)(v97 + 1) >> 59) {
              abort();
            }
            uint64_t v99 = v96 - v93;
            if (v99 >> 4 > v98) {
              unint64_t v98 = v99 >> 4;
            }
            if ((unint64_t)v99 >= 0x7FFFFFFFFFFFFFE0) {
              unint64_t v100 = 0x7FFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v100 = v98;
            }
            if (v100 >> 59) {
              goto LABEL_274;
            }
            int8x8_t v101 = (char *)operator new(32 * v100);
            int8x8_t v102 = &v101[32 * v97];
            *int8x8_t v102 = v92;
            v102[1] = v89;
            *((_DWORD *)v102 + 1) = v91;
            *((_DWORD *)v102 + 2) = v90;
            v102[24] = 0;
            if (v93 == v94)
            {
              uint64_t v105 = &v101[32 * v97];
            }
            else
            {
              uint64_t v103 = 0;
              do
              {
                unint64_t v104 = &v102[v103];
                *((_WORD *)v104 - 16) = *(_WORD *)&v94[v103 - 32];
                *(void *)(v104 - 28) = *(void *)&v94[v103 - 28];
                *(v104 - 8) = v94[v103 - 8];
                v103 -= 32;
              }
              while (&v94[v103] != v93);
              uint64_t v105 = &v102[v103];
            }
            unsigned int v88 = v102 + 32;
            *uint64_t v144 = (unsigned __int8 *)v105;
            v144[1] = (unsigned __int8 *)(v102 + 32);
            v144[2] = (unsigned __int8 *)&v101[32 * v100];
            if (v93) {
              operator delete(v93);
            }
            uint64_t v84 = v140 + 184;
          }
          v144[1] = (unsigned __int8 *)v88;
        }
      }
      if (v86[17] >= v87) {
        unsigned int v87 = v87;
      }
      else {
        unsigned int v87 = v86[17];
      }
      uint64_t v86 = *(unsigned __int8 **)v86;
      if (!v86) {
        goto LABEL_205;
      }
    }
  }
  unsigned int v87 = 25;
LABEL_205:
  uint64_t v106 = (int *)*v144;
  uint64_t v107 = v144[1];
  if (*v144 != v107)
  {
    uint64_t v109 = __p[0];
    unint64_t v108 = (unint64_t)__p[1];
    uint8x8_t v110 = (uint8x8_t)vcnt_s8((int8x8_t)__p[1]);
    v110.i16[0] = vaddlv_u8(v110);
    unint64_t v111 = (unint64_t)__p[1] - 1;
    do
    {
      LOBYTE(v112) = *((unsigned char *)v106 + 1);
      if ((_BYTE)v112)
      {
        LOBYTE(v112) = v112 - 1;
        int v113 = v106[1] >> 1;
        int v114 = v106[2] >> 1;
      }
      else
      {
        int v113 = v106[1];
        int v114 = v106[2];
      }
      BOOL v115 = v87 > v112 || v108 == 0;
      if (!v115)
      {
        uint64_t v116 = *(unsigned __int8 *)v106;
        do
        {
          unint64_t v117 = ((v116 - 0x61C8864680B583EBLL) << 6)
               - 0x61C8864680B583EBLL
               + ((unint64_t)(v116 - 0x61C8864680B583EBLL) >> 2);
          unint64_t v119 = (v113
                - 0x61C8864680B583EBLL
                + (((v117 + v112) ^ (v116 - 0x61C8864680B583EBLL)) << 6)
                + (((v117 + v112) ^ (v116 - 0x61C8864680B583EBLL)) >> 2)) ^ (v117
                                                                                            + v112) ^ (v116 - 0x61C8864680B583EBLL);
          unint64_t v120 = (v114 - 0x61C8864680B583EBLL + (v119 << 6) + (v119 >> 2)) ^ v119;
          if (v110.u32[0] > 1uLL)
          {
            unint64_t v121 = v120;
            if (v120 >= v108) {
              unint64_t v121 = v120 % v108;
            }
          }
          else
          {
            unint64_t v121 = v111 & v120;
          }
          unint64_t v122 = (uint64_t **)v109[v121];
          if (v122)
          {
            uint64_t v123 = *v122;
            if (v123)
            {
              if (v110.u32[0] < 2uLL)
              {
                while (1)
                {
                  uint64_t v124 = v123[1];
                  if (v120 == v124)
                  {
                    if (__PAIR64__(*((unsigned __int8 *)v123 + 17), *((unsigned __int8 *)v123 + 16)) == __PAIR64__(v112, v116)
                      && *((_DWORD *)v123 + 5) == v113
                      && *((_DWORD *)v123 + 6) == v114)
                    {
                      goto LABEL_207;
                    }
                  }
                  else if ((v124 & v111) != v121)
                  {
                    goto LABEL_217;
                  }
                  uint64_t v123 = (uint64_t *)*v123;
                  if (!v123) {
                    goto LABEL_217;
                  }
                }
              }
              do
              {
                unint64_t v125 = v123[1];
                if (v120 == v125)
                {
                  if (__PAIR64__(*((unsigned __int8 *)v123 + 17), *((unsigned __int8 *)v123 + 16)) == __PAIR64__(v112, v116)
                    && *((_DWORD *)v123 + 5) == v113
                    && *((_DWORD *)v123 + 6) == v114)
                  {
LABEL_207:
                    *((unsigned char *)v106 + 24) = 1;
                    goto LABEL_208;
                  }
                }
                else
                {
                  if (v125 >= v108) {
                    v125 %= v108;
                  }
                  if (v125 != v121) {
                    break;
                  }
                }
                uint64_t v123 = (uint64_t *)*v123;
              }
              while (v123);
            }
          }
LABEL_217:
          char v118 = v112 != 0;
          unsigned int v112 = v112 - 1;
          if (!v118) {
            unsigned int v112 = 0;
          }
          v113 >>= v118;
          v114 >>= v118;
        }
        while (v112 >= v87);
      }
LABEL_208:
      v106 += 8;
    }
    while (v106 != (int *)v107);
  }
  if (*(void *)(v84 + 24))
  {
    uint64_t v126 = (void *)*v147;
    if (*v147)
    {
      do
      {
        uint64_t v127 = v126;
        uint64_t v126 = (void *)*v126;
        uint64_t v128 = (std::__shared_weak_count *)v127[6];
        if (v128 && !atomic_fetch_add(&v128->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
          std::__shared_weak_count::__release_weak(v128);
        }
        operator delete(v127);
      }
      while (v126);
    }
    *(void *)(v84 + 16) = 0;
    uint64_t v129 = *(void *)(v84 + 8);
    if (v129)
    {
      for (uint64_t m = 0; m != v129; ++m)
        *(void *)(*(void *)v84 + 8 * m) = 0;
    }
    *(void *)(v84 + 24) = 0;
  }
  unint64_t v131 = __p[0];
  __p[0] = 0;
  uint64_t v132 = *(void **)v84;
  *(void *)uint64_t v84 = v131;
  if (v132) {
    operator delete(v132);
  }
  unint64_t v133 = (unint64_t)__p[1];
  *(void **)(v84 + 8) = __p[1];
  __p[1] = 0;
  uint64_t v134 = v151[1];
  *(void **)(v84 + 24) = v151[1];
  *(float *)(v84 + 32) = v152;
  int8x8_t v135 = v151[0];
  *(void **)(v84 + 16) = v151[0];
  if (v134)
  {
    unint64_t v136 = v135[1];
    if ((v133 & (v133 - 1)) != 0)
    {
      if (v136 >= v133) {
        v136 %= v133;
      }
    }
    else
    {
      v136 &= v133 - 1;
    }
    *(void *)(*(void *)v84 + 8 * v136) = v147;
    v151[0] = 0;
    v151[1] = 0;
  }
  else
  {
    while (v135)
    {
      uint64_t v137 = v135;
      int8x8_t v135 = (void *)*v135;
      uint64_t v138 = (std::__shared_weak_count *)v137[6];
      if (v138 && !atomic_fetch_add(&v138->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
        std::__shared_weak_count::__release_weak(v138);
      }
      operator delete(v137);
    }
  }
  uint64_t v139 = __p[0];
  __p[0] = 0;
  if (v139) {
    operator delete(v139);
  }
}

void sub_1A1A87634(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, long long a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, void *a20)
{
  unint64_t v21 = a20;
  while (v21)
  {
    uint64_t v22 = v21;
    unint64_t v21 = (void *)*v21;
    uint64_t v23 = (std::__shared_weak_count *)v22[6];
    if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
    operator delete(v22);
  }
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::OverlaysLogic::updateOverlaysResources(void)::$_0,std::allocator<md::OverlaysLogic::updateOverlaysResources(void)::$_0>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::operator()(uint64_t a1, void *a2, void *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  for (uint64_t i = *(void **)(v3 + 80 * *a2 + 40 * *a3 + 200); i; uint64_t i = (void *)*i)
  {
    uint64_t v5 = i[5];
    uint64_t v26 = (char *)&v26;
    char v27 = &v26;
    uint64_t v28 = 0;
    int v6 = (geo::read_write_lock *)pthread_rwlock_wrlock((pthread_rwlock_t *)(v5 + 872));
    if (v6) {
      geo::read_write_lock::logFailure(v6, (uint64_t)"write lock", v7);
    }
    uint64_t v8 = (void *)(v5 + 752);
    uint64_t v9 = *(void **)(v5 + 760);
    if (v9 != (void *)(v5 + 752))
    {
      do
      {
        while (1)
        {
          unsigned __int8 v17 = atomic_load((unsigned __int8 *)v9 + 153);
          if (v17) {
            break;
          }
          uint64_t v9 = (void *)v9[1];
          if (v9 == v8) {
            goto LABEL_7;
          }
        }
        BOOL v18 = v9 + 2;
        uint64_t v30 = 0;
        memset(v29, 0, 138);
        if (v9[13] || v9[14])
        {
          md::OverlayTileData::OverlayTileResource::moveNonTileVectorResources((uint64_t)v29, (uint64_t)(v9 + 2));
          uint64_t v19 = *v18;
          *BOOL v18 = 0;
          uint64_t v20 = *(void **)&v29[0];
          *(void *)&v29[0] = v19;
          if (v20) {
            std::default_delete<md::OverlayTileData::OverlayTileResource::Texture>::operator()[abi:nn180100](v20);
          }
          atomic_store(0, (unsigned __int8 *)v9 + 153);
          uint64_t v9 = (void *)v9[1];
        }
        else
        {
          md::OverlayTileData::OverlayTileResource::operator=((uint64_t)v29, (uint64_t)(v9 + 2));
          uint64_t v23 = *v9;
          uint64_t v24 = (void *)v9[1];
          *(void *)(v23 + 8) = v24;
          *(void *)v9[1] = v23;
          --*(void *)(v5 + 768);
          md::OverlayTileData::OverlayTileResource::~OverlayTileResource((md::OverlayTileData::OverlayTileResource *)(v9 + 2));
          operator delete(v9);
          uint64_t v9 = v24;
        }
        unint64_t v21 = (char *)operator new(0xA8uLL);
        *((void *)v21 + 20) = 0;
        *(_OWORD *)unint64_t v21 = 0u;
        *((_OWORD *)v21 + 2) = 0u;
        *((_OWORD *)v21 + 3) = 0u;
        *((_OWORD *)v21 + 4) = 0u;
        *((_OWORD *)v21 + 5) = 0u;
        *((_OWORD *)v21 + 6) = 0u;
        *((_OWORD *)v21 + 7) = 0u;
        *((_OWORD *)v21 + 8) = 0u;
        *(_OWORD *)(v21 + 138) = 0u;
        *((_OWORD *)v21 + 1) = 0u;
        md::OverlayTileData::OverlayTileResource::operator=((uint64_t)(v21 + 16), (uint64_t)v29);
        uint64_t v22 = v26;
        *(void *)unint64_t v21 = v26;
        *((void *)v21 + 1) = &v26;
        *((void *)v22 + 1) = v21;
        uint64_t v26 = v21;
        ++v28;
        md::OverlayTileData::OverlayTileResource::~OverlayTileResource((md::OverlayTileData::OverlayTileResource *)v29);
      }
      while (v9 != v8);
    }
LABEL_7:
    if (*(void *)(v5 + 792)) {
      md::OverlayTileData::updateNonTileOverlays(v5, (void *)(v5 + 776));
    }
    if (*(void *)(v5 + 816)) {
      md::OverlayTileData::updateNonTileOverlays(v5, (void *)(v5 + 800));
    }
    uint64_t v10 = (geo::read_write_lock *)pthread_rwlock_unlock((pthread_rwlock_t *)(v5 + 872));
    if (v10) {
      geo::read_write_lock::logFailure(v10, (uint64_t)"unlock", v11);
    }
    uint64_t v12 = v28;
    **(unsigned char **)(a1 + 16) |= v28 != 0;
    if (v12)
    {
      int8x8_t v14 = v26;
      uint64_t v13 = v27;
      unint64_t v15 = *v27;
      *((void *)v15 + 1) = *((void *)v26 + 1);
      **((void **)v14 + 1) = v15;
      uint64_t v16 = *(void *)(v3 + 944);
      *(void *)(v16 + 8) = v13;
      *uint64_t v13 = (char *)v16;
      *(void *)(v3 + 944) = v14;
      *((void *)v14 + 1) = v3 + 944;
      *(void *)(v3 + 960) += v12;
    }
  }
}

void sub_1A1A87A10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t *a13, uint64_t a14, char a15)
{
  if (a14)
  {
    uint64_t v16 = a12;
    unsigned __int8 v17 = a13;
    uint64_t v18 = *a13;
    *(void *)(v18 + 8) = *(void *)(a12 + 8);
    **(void **)(v16 + 8) = v18;
    a14 = 0;
    if (v17 != &a12)
    {
      do
      {
        uint64_t v19 = (uint64_t *)v17[1];
        md::OverlayTileData::OverlayTileResource::~OverlayTileResource((md::OverlayTileData::OverlayTileResource *)(v17 + 2));
        operator delete(v17);
        unsigned __int8 v17 = v19;
      }
      while (v19 != &a12);
    }
  }
  _Unwind_Resume(exception_object);
}

void std::vector<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__init_with_size[abi:nn180100]<geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*,geo::_retain_ptr<VKOverlay * {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>*>(void *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    if (a4 >= 0xAAAAAAAAAAAAAABLL) {
      abort();
    }
    uint64_t v7 = 3 * a4;
    uint64_t v8 = operator new(24 * a4);
    uint64_t v9 = v8;
    *a1 = v8;
    a1[1] = v8;
    a1[2] = &v8[v7];
    if (a2 != a3)
    {
      uint64_t v10 = v8;
      do
      {
        *uint64_t v9 = &unk_1EF559F78;
        v9[1] = 0;
        id v11 = *(id *)(a2 + 8);
        uint64_t v12 = (void *)v9[1];
        v9[1] = v11;

        a2 += 24;
        v9 += 3;
        v10 += 3;
      }
      while (a2 != a3);
    }
    a1[1] = v9;
  }
}

void md::OverlaysLogic::updateKeyframeAnimationOverrides(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return;
  }
  uint64_t v5 = a1;
  while (2)
  {
    id v19 = *(id *)(v5 + 8);
    id v6 = v19;
    uint64_t v7 = [v6 rasterTileProvider];

    if (!v7 || [v7 keyframesCount] < 2) {
      goto LABEL_4;
    }
    id v8 = v19;
    unsigned int v9 = [v8 identifier];
    unint64_t v10 = *(void *)(a3 + 120);
    if (!v10) {
      goto LABEL_33;
    }
    uint8x8_t v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      unint64_t v12 = v9;
      if (v10 <= v9) {
        unint64_t v12 = v9 % v10;
      }
    }
    else
    {
      unint64_t v12 = (v10 - 1) & v9;
    }
    uint64_t v13 = *(uint64_t ***)(*(void *)(a3 + 112) + 8 * v12);
    if (!v13 || (int8x8_t v14 = *v13) == 0) {
LABEL_33:
    }
      abort();
    if (v11.u32[0] < 2uLL)
    {
      unint64_t v15 = v10 - 1;
      while (1)
      {
        uint64_t v17 = v14[1];
        if (v17 == v9)
        {
          if (*((_DWORD *)v14 + 4) == v9) {
            goto LABEL_27;
          }
        }
        else if ((v17 & v15) != v12)
        {
          goto LABEL_33;
        }
        int8x8_t v14 = (uint64_t *)*v14;
        if (!v14) {
          goto LABEL_33;
        }
      }
    }
    while (1)
    {
      unint64_t v16 = v14[1];
      if (v16 == v9) {
        break;
      }
      if (v16 >= v10) {
        v16 %= v10;
      }
      if (v16 != v12) {
        goto LABEL_33;
      }
LABEL_17:
      int8x8_t v14 = (uint64_t *)*v14;
      if (!v14) {
        goto LABEL_33;
      }
    }
    if (*((_DWORD *)v14 + 4) != v9) {
      goto LABEL_17;
    }
LABEL_27:

    int v18 = [v7 keyframeIndexOverride];
    if (v18 < 0)
    {
      if (*((unsigned char *)v14 + 42)) {
        *((unsigned char *)v14 + 42) = 0;
      }
    }
    else
    {
      if (!*((unsigned char *)v14 + 42)) {
        *((unsigned char *)v14 + 42) = 1;
      }
      *((_WORD *)v14 + 22) = v18;
    }
LABEL_4:

    v5 += 24;
    if (v5 != a2) {
      continue;
    }
    break;
  }
}

void sub_1A1A87D5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  _Unwind_Resume(a1);
}

void *std::vector<md::MapDataType>::__assign_with_size[abi:nn180100]<md::MapDataType*,md::MapDataType*>(void *result, char *__src, char *a3, size_t __sz)
{
  id v6 = __src;
  uint64_t v7 = result;
  size_t v8 = result[2];
  unsigned int v9 = (char *)*result;
  if (__sz > (uint64_t)(v8 - *result) >> 1)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      size_t v8 = 0;
      void *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((__sz & 0x8000000000000000) != 0) {
      goto LABEL_23;
    }
    if (v8 <= __sz) {
      size_t v10 = __sz;
    }
    else {
      size_t v10 = v8;
    }
    BOOL v11 = v8 >= 0x7FFFFFFFFFFFFFFELL;
    uint64_t v12 = 0x7FFFFFFFFFFFFFFFLL;
    if (!v11) {
      uint64_t v12 = v10;
    }
    if (v12 < 0) {
LABEL_23:
    }
      abort();
    uint64_t v13 = 2 * v12;
    uint64_t result = operator new(2 * v12);
    unsigned int v9 = (char *)result;
    void *v7 = result;
    v7[1] = result;
    v7[2] = (char *)result + v13;
    size_t v14 = a3 - v6;
    if (v14) {
      uint64_t result = memcpy(result, v6, v14);
    }
    unint64_t v15 = (void **)(v7 + 1);
    goto LABEL_22;
  }
  unint64_t v15 = (void **)(result + 1);
  unint64_t v16 = (unsigned char *)result[1];
  unint64_t v17 = (v16 - v9) >> 1;
  if (v17 >= __sz)
  {
    size_t v14 = a3 - __src;
    if (a3 == __src) {
      goto LABEL_22;
    }
    id v19 = (void *)*result;
LABEL_21:
    uint64_t result = memmove(v19, __src, v14);
    goto LABEL_22;
  }
  int v18 = &__src[2 * v17];
  if (v16 != v9)
  {
    uint64_t result = memmove((void *)*result, __src, v16 - v9);
    unsigned int v9 = (char *)*v15;
  }
  size_t v14 = a3 - v18;
  if (v14)
  {
    id v19 = v9;
    __src = v18;
    goto LABEL_21;
  }
LABEL_22:
  *unint64_t v15 = &v9[v14];
  return result;
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__2NS_9allocatorISM_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "OverlaysLogic", "", v5, 2u);
  }
}

void _ZNSt3__110__function6__funcIZN2md13OverlaysLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_19PendingSceneContextENS2_16ElevationContextENS2_13CameraContextENS2_22PendingRegistryContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_15OverlaysContextEE3__1NS_9allocatorISM_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "OverlaysLogic", "", v5, 2u);
  }
}

void md::OverlayContainer::flushCommandQueue(md::OverlayContainer *this)
{
  uint64_t v2 = (std::mutex *)((char *)this + 48);
  std::mutex::lock((std::mutex *)((char *)this + 48));
  long long v3 = *((_OWORD *)this + 7);
  *((_OWORD *)this + 7) = *(_OWORD *)((char *)this + 136);
  *(_OWORD *)((char *)this + 136) = v3;
  uint64_t v4 = *((void *)this + 16);
  *((void *)this + 16) = *((void *)this + 19);
  *((void *)this + 19) = v4;
  std::mutex::unlock(v2);
  id v6 = (void *)*((void *)this + 17);
  uint64_t v5 = (void *)*((void *)this + 18);
  if (v6 != v5)
  {
    do
    {
      uint64_t v7 = v6[4];
      if (!v7)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::clear();
        return;
      }
      (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
      v6 += 5;
    }
    while (v6 != v5);
    id v6 = (void *)*((void *)this + 17);
    size_t v8 = (void *)*((void *)this + 18);
    if (v8 == v6)
    {
      id v6 = (void *)*((void *)this + 18);
    }
    else
    {
      unsigned int v9 = v8 - 4;
      size_t v10 = v8 - 4;
      do
      {
        uint64_t v12 = (void *)v10[3];
        if (v10 == v12)
        {
          (*(void (**)(void *))(*v10 + 32))(v10);
        }
        else if (v12)
        {
          (*(void (**)(void *))(*v12 + 40))(v12);
        }
        BOOL v11 = v10 - 1;
        v10 -= 5;
        v9 -= 5;
      }
      while (v11 != v6);
    }
  }
  *((void *)this + 18) = v6;
}

void std::__hash_table<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,std::__unordered_map_hasher<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyHash,md::SurfaceKeyEqual,true>,std::__unordered_map_equal<md::SurfaceKey,std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>,md::SurfaceKeyEqual,md::SurfaceKeyHash,true>,std::allocator<std::__hash_value_type<md::SurfaceKey,std::unordered_map<unsigned long,std::shared_ptr<ggl::IOSurfaceTexture>>>>>::clear(void *a1)
{
  if (a1[3])
  {
    uint64_t v2 = (void *)a1[2];
    if (v2)
    {
      do
      {
        long long v3 = (void *)*v2;
        uint64_t v4 = (void *)v2[8];
        while (v4)
        {
          id v6 = v4;
          uint64_t v4 = (void *)*v4;
          uint64_t v7 = (std::__shared_weak_count *)v6[4];
          if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
          operator delete(v6);
        }
        uint64_t v5 = (void *)v2[6];
        v2[6] = 0;
        if (v5) {
          operator delete(v5);
        }
        operator delete(v2);
        uint64_t v2 = v3;
      }
      while (v3);
    }
    a1[2] = 0;
    uint64_t v8 = a1[1];
    if (v8)
    {
      for (uint64_t i = 0; i != v8; ++i)
        *(void *)(*a1 + 8 * i) = 0;
    }
    a1[3] = 0;
  }
}

void std::__function::__func<md::OverlaysLogic::reset(void)::$_1,std::allocator<md::OverlaysLogic::reset(void)::$_1>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::operator()(uint64_t a1, void *a2, void *a3)
{
}

void std::__function::__func<md::OverlaysLogic::OverlaysLogic(std::shared_ptr<md::RegistryManager> const&,geo::TaskQueue *,gdc::ResourceManager *,NSObject  {objcproto17OS_dispatch_queue}*,std::shared_ptr<md::RunLoopController> const&)::$_0,std::allocator<md::OverlaysLogic::OverlaysLogic(std::shared_ptr<md::RegistryManager> const&,geo::TaskQueue *,gdc::ResourceManager *,NSObject  {objcproto17OS_dispatch_queue}*,std::shared_ptr<md::RunLoopController> const&)::$_0>,void ()(VKOverlayLevel,VKOverlayResourceFallbackableMode)>::operator()()
{
}

unsigned char *md::LabelMapTile::updateLabels(unsigned char *this, md::LabelManager *a2, md::LabelPool *a3, int a4, int a5)
{
  uint64_t v5 = a2;
  uint64_t v6 = (uint64_t)this;
  uint64_t v1039 = *MEMORY[0x1E4F143B8];
  v1030 = a2;
  if ((char)this[492] == a4 && !this[122] && !this[124] && !this[123] && !this[128] && !a5) {
    return this;
  }
  uint64_t v7 = *((void *)a2 + 54);
  this[492] = a4;
  {
    operator new();
  }
  unsigned int v9 = (void *)mdm::Allocator::instance(void)::alloc;
  size_t v10 = *(void **)(v6 + 416);
  v1028 = *(void ***)(v6 + 408);
  v1029[0] = v10;
  BOOL v11 = *(void **)(v6 + 432);
  *(void *)(v6 + 432) = 0;
  v1029[1] = v9;
  v1029[2] = v11;
  *(void *)(v6 + 408) = v6 + 416;
  *(void *)(v6 + 416) = 0;
  v1021 = (uint64_t **)(v6 + 416);
  uint64_t v12 = v10 + 2;
  if (!v11) {
    uint64_t v12 = &v1028;
  }
  *uint64_t v12 = v1029;
  uint64_t v973 = v7;
  if (*(float *)(v7 + 424) <= 0.0)
  {
    int v13 = a4;
  }
  else
  {
    int v13 = a4;
    if (*(unsigned char *)(v7 + 27))
    {
      *(_OWORD *)buf = xmmword_1A28FCDD0;
      *(void *)&buf[16] = 0;
      LOBYTE(v1033) = 0;
      __asm { FMOV            V2.2D, #0.5 }
      float64x2_t v1026 = vmlaq_f64(*(float64x2_t *)(v6 + 40), _Q2, vsubq_f64(*(float64x2_t *)(v6 + 56), *(float64x2_t *)(v6 + 40)));
      v1027.__r_.__value_.__r.__words[0] = (*(double (**)(uint64_t, float64x2_t *))(*(void *)v6 + 16))(v6, &v1026);
      v1027.__r_.__value_.__l.__size_ = v17;
      v1027.__r_.__value_.__r.__words[2] = v18;
      __p.__r_.__value_.__s.__data_[0] = 0;
      __p.__r_.__value_.__s.__data_[12] = 0;
      md::LabelLayoutContext::evaluateWorldPoint(v7, (uint64_t)&v1027, (uint64_t)&__p, 1u, 0, (uint64_t)buf, 1.0);
      if (!(_BYTE)v1033)
      {
        int v19 = (int)*(float *)buf & ~((int)*(float *)buf >> 31);
        if (v19 >= a4) {
          int v19 = a4;
        }
        if (v19 >= 23) {
          int v13 = 23;
        }
        else {
          int v13 = v19;
        }
      }
      uint64_t v5 = v1030;
    }
  }
  uint64_t v20 = (void *)(*(uint64_t (**)(void))(**(void **)(*((void *)v5 + 21) + 64) + 8))(*(void *)(*((void *)v5 + 21) + 64));
  if (v20)
  {
    BOOL v21 = v20[16] != v20[17] || v20[30] != v20[31];
    *(_DWORD *)v996 = v21;
  }
  else
  {
    *(_DWORD *)v996 = 0;
  }
  v993 = v20;
  if (*(unsigned char *)(*((void *)v1030 + 29) + 28)) {
    BOOL v976 = *((unsigned char *)v1030 + 3389) != 0;
  }
  else {
    BOOL v976 = 0;
  }
  uint64_t v972 = (*(uint64_t (**)(void))(**(void **)(*((void *)v1030 + 21) + 32) + 80))(*(void *)(*((void *)v1030 + 21) + 32));
  v974 = (void *)(v6 + 440);
  v975 = *(int8x8_t **)(v7 + 1232);
  *(_DWORD *)(v6 + 96) = 0;
  uint64_t v22 = (const QuadTile **)(v6 + 168);
  v985 = (const QuadTile **)(v6 + 328);
  v998 = (QuadTile *)(v6 + 8);
  v1015 = (double *)(v6 + 40);
  *(void *)(v6 + 88) = 0;
  v1017 = (md::LabelMapTile *)v6;
  int v1001 = v13;
  do
  {
    uint64_t v23 = *v22;
    if (!*v22) {
      goto LABEL_28;
    }
    v988 = v22;
    uint64_t v24 = (unsigned int *)*((void *)v1030 + 37);
    unsigned int hash = v23[11]._hash;
    unsigned int v26 = v24[3];
    v1005 = *v22;
    if (hash != v26)
    {
      LODWORD(v23[11]._hash) = v26;
      BOOL v27 = hash <= v26 && hash > v24[4];
      uint64_t v28 = v23;
      unsigned int v29 = !v27;
      memset(buf, 0, sizeof(buf));
      {
        operator new();
      }
      uint64_t v1032 = mdm::Allocator::instance(void)::alloc;
      unint64_t v30 = v28[2]._hash + *(void *)&v28[9]._xIdx;
      if (v30)
      {
        if (v30 > 0xAAAAAAAAAAAAAAALL) {
          abort();
        }
        uint64_t v31 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                            + 16))(mdm::Allocator::instance(void)::alloc, 24 * v30, 8);
        uint64_t v33 = *(void *)buf;
        uint64_t v32 = *(void *)&buf[8];
        uint64_t v34 = v31;
        if (*(void *)&buf[8] != *(void *)buf)
        {
          do
          {
            long long v35 = *(_OWORD *)(v32 - 24);
            *(void *)(v34 - 8) = *(void *)(v32 - 8);
            *(_OWORD *)(v34 - 24) = v35;
            v34 -= 24;
            v32 -= 24;
          }
          while (v32 != v33);
          uint64_t v32 = v33;
        }
        *(void *)buf = v34;
        *(void *)&buf[8] = v31;
        uint64_t v36 = *(void *)&buf[16];
        *(void *)&buf[16] = v31 + 24 * v30;
        if (v32) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 40))(v1032, v32, v36 - v32);
        }
      }
      uint64_t v37 = atomic_load((unsigned __int8 *)(*(void *)v24 + 3394));
      uint64_t v38 = *(unint64_t **)&v1005[8]._xIdx;
      if (v38 == &v1005[8]._hash)
      {
LABEL_46:
        BOOL v39 = (const QuadTile *)v1005[1]._hash;
        uint64_t v6 = (uint64_t)v1017;
        if (v39 == &v1005[2])
        {
LABEL_47:
          uint64_t v40 = (const QuadTile *)v1005[5]._hash;
          if (v40 == &v1005[6])
          {
LABEL_48:
            uint64_t v41 = (const QuadTile *)v1005[9]._hash;
            if (v41 == &v1005[10])
            {
LABEL_49:
              uint64_t v42 = *(unint64_t **)&v1005[4]._xIdx;
              if (v42 == &v1005[4]._hash)
              {
LABEL_50:
                uint64_t v43 = *(int **)&v1005[7]._type;
                if (v43 == &v1005[7]._xIdx)
                {
LABEL_51:
                  md::LabelFeatureStyler::styleLabelFeatures(v24, (char **)buf, v29, 0, *(void *)(*(void *)(*(void *)v24 + 152) + 64));
                  int v13 = v1001;
                  uint64_t v23 = v1005;
                  if (*(void *)buf)
                  {
                    *(void *)&buf[8] = *(void *)buf;
                    (*(void (**)(uint64_t, void, void))(*(void *)v1032 + 40))(v1032, *(void *)buf, *(void *)&buf[16] - *(void *)buf);
                  }
                  goto LABEL_53;
                }
                while (1)
                {
                  int v207 = (std::__shared_weak_count *)*((void *)v43 + 5);
                  if (!v207) {
                    goto LABEL_376;
                  }
                  uint64_t v208 = std::__shared_weak_count::lock(v207);
                  v1027.__r_.__value_.__l.__size_ = (std::string::size_type)v208;
                  if (!v208) {
                    goto LABEL_376;
                  }
                  unint64_t v209 = v208;
                  std::string::size_type v210 = *((void *)v43 + 4);
                  v1027.__r_.__value_.__r.__words[0] = v210;
                  if (v210 && *(_DWORD *)(v210 + 128) != v24[3])
                  {
                    v211 = *(std::string::size_type **)&buf[8];
                    if (*(void *)&buf[8] >= *(void *)&buf[16])
                    {
                      unint64_t v213 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
                      unint64_t v214 = v213 + 1;
                      if (v213 + 1 > 0xAAAAAAAAAAAAAAALL) {
                        abort();
                      }
                      if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v214) {
                        unint64_t v214 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
                      }
                      if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
                        uint64_t v215 = 0xAAAAAAAAAAAAAAALL;
                      }
                      else {
                        uint64_t v215 = v214;
                      }
                      if (v215)
                      {
                        uint64_t v216 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 16))(v1032, 24 * v215, 8);
                        v217 = (std::string::size_type *)(v216 + 24 * v213);
                        uint64_t v218 = v216 + 24 * v215;
                        if (v216)
                        {
                          std::string::size_type *v217 = v210;
                          unint64_t v219 = v216 + 24 * v213;
                          *(void *)(v219 + 8) = 0;
                          *(void *)(v219 + 16) = 0;
                        }
                      }
                      else
                      {
                        uint64_t v218 = 0;
                        v217 = (std::string::size_type *)(8 * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
                      }
                      uint64_t v6 = (uint64_t)v1017;
                      uint64_t v221 = *(void *)buf;
                      uint64_t v220 = *(void *)&buf[8];
                      int v222 = v217;
                      if (*(void *)&buf[8] != *(void *)buf)
                      {
                        do
                        {
                          long long v223 = *(_OWORD *)(v220 - 24);
                          *(v222 - 1) = *(void *)(v220 - 8);
                          *(_OWORD *)(v222 - 3) = v223;
                          v222 -= 3;
                          v220 -= 24;
                        }
                        while (v220 != v221);
                        uint64_t v220 = v221;
                      }
                      v212 = v217 + 3;
                      uint64_t v224 = *(void *)&buf[16];
                      *(void *)buf = v222;
                      *(void *)&buf[16] = v218;
                      if (v220) {
                        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 40))(v1032, v220, v224 - v220);
                      }
                    }
                    else
                    {
                      if (*(void *)&buf[8])
                      {
                        *(void *)(*(void *)&buf[8] + 8) = 0;
                        v211[2] = 0;
                        std::string::size_type *v211 = v210;
                      }
                      v212 = v211 + 3;
                    }
                    *(void *)&buf[8] = v212;
                  }
                  if (!atomic_fetch_add(&v209->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v209->__on_zero_shared)(v209);
                    std::__shared_weak_count::__release_weak(v209);
                    uint64_t v225 = (int *)*((void *)v43 + 1);
                    if (!v225)
                    {
                      do
                      {
LABEL_380:
                        v226 = (int *)*((void *)v43 + 2);
                        _ZF = *(void *)v226 == (void)v43;
                        uint64_t v43 = v226;
                      }
                      while (!_ZF);
                      goto LABEL_350;
                    }
                  }
                  else
                  {
LABEL_376:
                    uint64_t v225 = (int *)*((void *)v43 + 1);
                    if (!v225) {
                      goto LABEL_380;
                    }
                  }
                  do
                  {
                    v226 = v225;
                    uint64_t v225 = *(int **)v225;
                  }
                  while (v225);
LABEL_350:
                  uint64_t v43 = v226;
                  if (v226 == &v1005[7]._xIdx) {
                    goto LABEL_51;
                  }
                }
              }
              while (1)
              {
                int8x8_t v187 = (std::__shared_weak_count *)v42[5];
                if (!v187) {
                  goto LABEL_343;
                }
                uint8x8_t v188 = std::__shared_weak_count::lock(v187);
                v1027.__r_.__value_.__l.__size_ = (std::string::size_type)v188;
                if (!v188) {
                  goto LABEL_343;
                }
                uint64_t v189 = v188;
                std::string::size_type v190 = v42[4];
                v1027.__r_.__value_.__r.__words[0] = v190;
                if (v190 && *(_DWORD *)(v190 + 128) != v24[3])
                {
                  uint64_t v191 = *(std::string::size_type **)&buf[8];
                  if (*(void *)&buf[8] >= *(void *)&buf[16])
                  {
                    unint64_t v193 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
                    unint64_t v194 = v193 + 1;
                    if (v193 + 1 > 0xAAAAAAAAAAAAAAALL) {
                      abort();
                    }
                    if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v194) {
                      unint64_t v194 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
                    }
                    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
                      uint64_t v195 = 0xAAAAAAAAAAAAAAALL;
                    }
                    else {
                      uint64_t v195 = v194;
                    }
                    if (v195)
                    {
                      uint64_t v196 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 16))(v1032, 24 * v195, 8);
                      char v197 = (std::string::size_type *)(v196 + 24 * v193);
                      uint64_t v198 = v196 + 24 * v195;
                      if (v196)
                      {
                        *char v197 = v190;
                        unint64_t v199 = v196 + 24 * v193;
                        *(void *)(v199 + 8) = 0;
                        *(void *)(v199 + 16) = 0;
                      }
                    }
                    else
                    {
                      uint64_t v198 = 0;
                      char v197 = (std::string::size_type *)(8 * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
                    }
                    uint64_t v6 = (uint64_t)v1017;
                    uint64_t v201 = *(void *)buf;
                    uint64_t v200 = *(void *)&buf[8];
                    v202 = v197;
                    if (*(void *)&buf[8] != *(void *)buf)
                    {
                      do
                      {
                        long long v203 = *(_OWORD *)(v200 - 24);
                        *(v202 - 1) = *(void *)(v200 - 8);
                        *(_OWORD *)(v202 - 3) = v203;
                        v202 -= 3;
                        v200 -= 24;
                      }
                      while (v200 != v201);
                      uint64_t v200 = v201;
                    }
                    uint64_t v192 = v197 + 3;
                    uint64_t v204 = *(void *)&buf[16];
                    *(void *)buf = v202;
                    *(void *)&buf[16] = v198;
                    if (v200) {
                      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 40))(v1032, v200, v204 - v200);
                    }
                  }
                  else
                  {
                    if (*(void *)&buf[8])
                    {
                      *(void *)(*(void *)&buf[8] + 8) = 0;
                      v191[2] = 0;
                      *uint64_t v191 = v190;
                    }
                    uint64_t v192 = v191 + 3;
                  }
                  *(void *)&buf[8] = v192;
                }
                if (!atomic_fetch_add(&v189->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v189->__on_zero_shared)(v189);
                  std::__shared_weak_count::__release_weak(v189);
                  int v205 = (unint64_t *)v42[1];
                  if (!v205)
                  {
                    do
                    {
LABEL_347:
                      int v206 = (unint64_t *)v42[2];
                      _ZF = *v206 == (void)v42;
                      uint64_t v42 = v206;
                    }
                    while (!_ZF);
                    goto LABEL_317;
                  }
                }
                else
                {
LABEL_343:
                  int v205 = (unint64_t *)v42[1];
                  if (!v205) {
                    goto LABEL_347;
                  }
                }
                do
                {
                  int v206 = v205;
                  int v205 = (unint64_t *)*v205;
                }
                while (v205);
LABEL_317:
                uint64_t v42 = v206;
                if (v206 == &v1005[4]._hash) {
                  goto LABEL_50;
                }
              }
            }
            while (1)
            {
              uint64_t v167 = (std::__shared_weak_count *)v41[1]._hash;
              if (!v167) {
                goto LABEL_310;
              }
              uint64_t v168 = std::__shared_weak_count::lock(v167);
              v1027.__r_.__value_.__l.__size_ = (std::string::size_type)v168;
              if (!v168) {
                goto LABEL_310;
              }
              uint64_t v169 = v168;
              std::string::size_type v170 = *(void *)&v41[1]._xIdx;
              v1027.__r_.__value_.__r.__words[0] = v170;
              if (v170 && *(_DWORD *)(v170 + 128) != v24[3])
              {
                v171 = *(std::string::size_type **)&buf[8];
                if (*(void *)&buf[8] >= *(void *)&buf[16])
                {
                  unint64_t v173 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
                  unint64_t v174 = v173 + 1;
                  if (v173 + 1 > 0xAAAAAAAAAAAAAAALL) {
                    abort();
                  }
                  if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v174) {
                    unint64_t v174 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
                  }
                  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
                    uint64_t v175 = 0xAAAAAAAAAAAAAAALL;
                  }
                  else {
                    uint64_t v175 = v174;
                  }
                  if (v175)
                  {
                    uint64_t v176 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 16))(v1032, 24 * v175, 8);
                    v177 = (std::string::size_type *)(v176 + 24 * v173);
                    uint64_t v178 = v176 + 24 * v175;
                    if (v176)
                    {
                      std::string::size_type *v177 = v170;
                      unint64_t v179 = v176 + 24 * v173;
                      *(void *)(v179 + 8) = 0;
                      *(void *)(v179 + 16) = 0;
                    }
                  }
                  else
                  {
                    uint64_t v178 = 0;
                    v177 = (std::string::size_type *)(8 * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
                  }
                  uint64_t v6 = (uint64_t)v1017;
                  uint64_t v181 = *(void *)buf;
                  uint64_t v180 = *(void *)&buf[8];
                  unint64_t v182 = v177;
                  if (*(void *)&buf[8] != *(void *)buf)
                  {
                    do
                    {
                      long long v183 = *(_OWORD *)(v180 - 24);
                      *(v182 - 1) = *(void *)(v180 - 8);
                      *(_OWORD *)(v182 - 3) = v183;
                      v182 -= 3;
                      v180 -= 24;
                    }
                    while (v180 != v181);
                    uint64_t v180 = v181;
                  }
                  BOOL v172 = v177 + 3;
                  uint64_t v184 = *(void *)&buf[16];
                  *(void *)buf = v182;
                  *(void *)&buf[16] = v178;
                  if (v180) {
                    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 40))(v1032, v180, v184 - v180);
                  }
                }
                else
                {
                  if (*(void *)&buf[8])
                  {
                    *(void *)(*(void *)&buf[8] + 8) = 0;
                    v171[2] = 0;
                    std::string::size_type *v171 = v170;
                  }
                  BOOL v172 = v171 + 3;
                }
                *(void *)&buf[8] = v172;
              }
              if (!atomic_fetch_add(&v169->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v169->__on_zero_shared)(v169);
                std::__shared_weak_count::__release_weak(v169);
                v185 = *(const QuadTile **)&v41->_xIdx;
                if (!v185)
                {
                  do
                  {
LABEL_314:
                    v186 = (const QuadTile *)v41->_hash;
                    _ZF = *(void *)&v186->_type == (void)v41;
                    uint64_t v41 = v186;
                  }
                  while (!_ZF);
                  goto LABEL_284;
                }
              }
              else
              {
LABEL_310:
                v185 = *(const QuadTile **)&v41->_xIdx;
                if (!v185) {
                  goto LABEL_314;
                }
              }
              do
              {
                v186 = v185;
                v185 = *(const QuadTile **)&v185->_type;
              }
              while (v185);
LABEL_284:
              uint64_t v41 = v186;
              if (v186 == &v1005[10]) {
                goto LABEL_49;
              }
            }
          }
          while (1)
          {
            uint64_t v147 = (std::__shared_weak_count *)v40[1]._hash;
            if (!v147) {
              goto LABEL_277;
            }
            unint64_t v148 = std::__shared_weak_count::lock(v147);
            v1027.__r_.__value_.__l.__size_ = (std::string::size_type)v148;
            if (!v148) {
              goto LABEL_277;
            }
            uint64_t v149 = v148;
            std::string::size_type v150 = *(void *)&v40[1]._xIdx;
            v1027.__r_.__value_.__r.__words[0] = v150;
            if (v150 && *(_DWORD *)(v150 + 128) != v24[3])
            {
              v151 = *(std::string::size_type **)&buf[8];
              if (*(void *)&buf[8] >= *(void *)&buf[16])
              {
                unint64_t v153 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
                unint64_t v154 = v153 + 1;
                if (v153 + 1 > 0xAAAAAAAAAAAAAAALL) {
                  abort();
                }
                if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v154) {
                  unint64_t v154 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
                }
                if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
                  uint64_t v155 = 0xAAAAAAAAAAAAAAALL;
                }
                else {
                  uint64_t v155 = v154;
                }
                if (v155)
                {
                  uint64_t v156 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 16))(v1032, 24 * v155, 8);
                  uint64_t v157 = (std::string::size_type *)(v156 + 24 * v153);
                  uint64_t v158 = v156 + 24 * v155;
                  if (v156)
                  {
                    std::string::size_type *v157 = v150;
                    unint64_t v159 = v156 + 24 * v153;
                    *(void *)(v159 + 8) = 0;
                    *(void *)(v159 + 16) = 0;
                  }
                }
                else
                {
                  uint64_t v158 = 0;
                  uint64_t v157 = (std::string::size_type *)(8 * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
                }
                uint64_t v6 = (uint64_t)v1017;
                uint64_t v161 = *(void *)buf;
                uint64_t v160 = *(void *)&buf[8];
                uint64_t v162 = v157;
                if (*(void *)&buf[8] != *(void *)buf)
                {
                  do
                  {
                    long long v163 = *(_OWORD *)(v160 - 24);
                    *(v162 - 1) = *(void *)(v160 - 8);
                    *(_OWORD *)(v162 - 3) = v163;
                    v162 -= 3;
                    v160 -= 24;
                  }
                  while (v160 != v161);
                  uint64_t v160 = v161;
                }
                float v152 = v157 + 3;
                uint64_t v164 = *(void *)&buf[16];
                *(void *)buf = v162;
                *(void *)&buf[16] = v158;
                if (v160) {
                  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 40))(v1032, v160, v164 - v160);
                }
              }
              else
              {
                if (*(void *)&buf[8])
                {
                  *(void *)(*(void *)&buf[8] + 8) = 0;
                  v151[2] = 0;
                  std::string::size_type *v151 = v150;
                }
                float v152 = v151 + 3;
              }
              *(void *)&buf[8] = v152;
            }
            if (!atomic_fetch_add(&v149->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v149->__on_zero_shared)(v149);
              std::__shared_weak_count::__release_weak(v149);
              __n128 v165 = *(const QuadTile **)&v40->_xIdx;
              if (!v165)
              {
                do
                {
LABEL_281:
                  float v166 = (const QuadTile *)v40->_hash;
                  _ZF = *(void *)&v166->_type == (void)v40;
                  uint64_t v40 = v166;
                }
                while (!_ZF);
                goto LABEL_251;
              }
            }
            else
            {
LABEL_277:
              __n128 v165 = *(const QuadTile **)&v40->_xIdx;
              if (!v165) {
                goto LABEL_281;
              }
            }
            do
            {
              float v166 = v165;
              __n128 v165 = *(const QuadTile **)&v165->_type;
            }
            while (v165);
LABEL_251:
            uint64_t v40 = v166;
            if (v166 == &v1005[6]) {
              goto LABEL_48;
            }
          }
        }
        while (1)
        {
          uint64_t v127 = (std::__shared_weak_count *)v39[1]._hash;
          if (!v127) {
            goto LABEL_244;
          }
          uint64_t v128 = std::__shared_weak_count::lock(v127);
          v1027.__r_.__value_.__l.__size_ = (std::string::size_type)v128;
          if (!v128) {
            goto LABEL_244;
          }
          uint64_t v129 = v128;
          std::string::size_type v130 = *(void *)&v39[1]._xIdx;
          v1027.__r_.__value_.__r.__words[0] = v130;
          if (v130 && *(_DWORD *)(v130 + 128) != v24[3])
          {
            unint64_t v131 = *(std::string::size_type **)&buf[8];
            if (*(void *)&buf[8] >= *(void *)&buf[16])
            {
              unint64_t v133 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
              unint64_t v134 = v133 + 1;
              if (v133 + 1 > 0xAAAAAAAAAAAAAAALL) {
                abort();
              }
              if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v134) {
                unint64_t v134 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
              }
              if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
                uint64_t v135 = 0xAAAAAAAAAAAAAAALL;
              }
              else {
                uint64_t v135 = v134;
              }
              if (v135)
              {
                uint64_t v136 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 16))(v1032, 24 * v135, 8);
                uint64_t v137 = (std::string::size_type *)(v136 + 24 * v133);
                uint64_t v138 = v136 + 24 * v135;
                if (v136)
                {
                  *uint64_t v137 = v130;
                  unint64_t v139 = v136 + 24 * v133;
                  *(void *)(v139 + 8) = 0;
                  *(void *)(v139 + 16) = 0;
                }
              }
              else
              {
                uint64_t v138 = 0;
                uint64_t v137 = (std::string::size_type *)(8 * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
              }
              uint64_t v6 = (uint64_t)v1017;
              uint64_t v141 = *(void *)buf;
              uint64_t v140 = *(void *)&buf[8];
              uint64_t v142 = v137;
              if (*(void *)&buf[8] != *(void *)buf)
              {
                do
                {
                  long long v143 = *(_OWORD *)(v140 - 24);
                  *(v142 - 1) = *(void *)(v140 - 8);
                  *(_OWORD *)(v142 - 3) = v143;
                  v142 -= 3;
                  v140 -= 24;
                }
                while (v140 != v141);
                uint64_t v140 = v141;
              }
              uint64_t v132 = v137 + 3;
              uint64_t v144 = *(void *)&buf[16];
              *(void *)buf = v142;
              *(void *)&buf[16] = v138;
              if (v140) {
                (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 40))(v1032, v140, v144 - v140);
              }
            }
            else
            {
              if (*(void *)&buf[8])
              {
                *(void *)(*(void *)&buf[8] + 8) = 0;
                v131[2] = 0;
                *unint64_t v131 = v130;
              }
              uint64_t v132 = v131 + 3;
            }
            *(void *)&buf[8] = v132;
          }
          if (!atomic_fetch_add(&v129->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v129->__on_zero_shared)(v129);
            std::__shared_weak_count::__release_weak(v129);
            uint64_t v145 = *(const QuadTile **)&v39->_xIdx;
            if (!v145)
            {
              do
              {
LABEL_248:
                long long v146 = (const QuadTile *)v39->_hash;
                _ZF = *(void *)&v146->_type == (void)v39;
                BOOL v39 = v146;
              }
              while (!_ZF);
              goto LABEL_218;
            }
          }
          else
          {
LABEL_244:
            uint64_t v145 = *(const QuadTile **)&v39->_xIdx;
            if (!v145) {
              goto LABEL_248;
            }
          }
          do
          {
            long long v146 = v145;
            uint64_t v145 = *(const QuadTile **)&v145->_type;
          }
          while (v145);
LABEL_218:
          BOOL v39 = v146;
          if (v146 == &v1005[2]) {
            goto LABEL_47;
          }
        }
      }
      while (1)
      {
        uint64_t v107 = (std::__shared_weak_count *)v38[5];
        if (!v107) {
          goto LABEL_211;
        }
        unint64_t v108 = std::__shared_weak_count::lock(v107);
        v1027.__r_.__value_.__l.__size_ = (std::string::size_type)v108;
        if (!v108) {
          goto LABEL_211;
        }
        uint64_t v109 = v108;
        uint8x8_t v110 = (_DWORD *)v38[4];
        v1027.__r_.__value_.__r.__words[0] = (std::string::size_type)v110;
        if (v110 && v110[32] != v24[3])
        {
          unint64_t v111 = *(void **)&buf[8];
          if (*(void *)&buf[8] >= *(void *)&buf[16])
          {
            unint64_t v113 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3);
            unint64_t v114 = v113 + 1;
            if (v113 + 1 > 0xAAAAAAAAAAAAAAALL) {
              abort();
            }
            if (0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) > v114) {
              unint64_t v114 = 0x5555555555555556 * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3);
            }
            if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)&buf[16] - *(void *)buf) >> 3) >= 0x555555555555555) {
              uint64_t v115 = 0xAAAAAAAAAAAAAAALL;
            }
            else {
              uint64_t v115 = v114;
            }
            if (v115)
            {
              uint64_t v116 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 16))(v1032, 24 * v115, 8);
              unint64_t v117 = (void *)(v116 + 24 * v113);
              uint64_t v118 = v116 + 24 * v115;
              if (v116)
              {
                *unint64_t v117 = v110;
                unint64_t v119 = v116 + 24 * v113;
                *(void *)(v119 + 8) = 0;
                *(void *)(v119 + 16) = 0;
              }
            }
            else
            {
              uint64_t v118 = 0;
              unint64_t v117 = (void *)(8 * ((uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3));
            }
            uint64_t v121 = *(void *)buf;
            uint64_t v120 = *(void *)&buf[8];
            unint64_t v122 = v117;
            if (*(void *)&buf[8] != *(void *)buf)
            {
              do
              {
                long long v123 = *(_OWORD *)(v120 - 24);
                *(v122 - 1) = *(void *)(v120 - 8);
                *(_OWORD *)(v122 - 3) = v123;
                v122 -= 3;
                v120 -= 24;
              }
              while (v120 != v121);
              uint64_t v120 = v121;
            }
            unsigned int v112 = v117 + 3;
            uint64_t v124 = *(void *)&buf[16];
            *(void *)buf = v122;
            *(void *)&buf[16] = v118;
            if (v120) {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v1032 + 40))(v1032, v120, v124 - v120);
            }
          }
          else
          {
            if (*(void *)&buf[8])
            {
              *(void *)(*(void *)&buf[8] + 8) = 0;
              v111[2] = 0;
              *unint64_t v111 = v110;
            }
            unsigned int v112 = v111 + 3;
          }
          *(void *)&buf[8] = v112;
          (*(void (**)(_DWORD *, uint64_t))(*(void *)v110 + 528))(v110, v37);
        }
        if (!atomic_fetch_add(&v109->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v109->__on_zero_shared)(v109);
          std::__shared_weak_count::__release_weak(v109);
          unint64_t v125 = (unint64_t *)v38[1];
          if (!v125)
          {
            do
            {
LABEL_215:
              uint64_t v126 = (unint64_t *)v38[2];
              _ZF = *v126 == (void)v38;
              uint64_t v38 = v126;
            }
            while (!_ZF);
            goto LABEL_185;
          }
        }
        else
        {
LABEL_211:
          unint64_t v125 = (unint64_t *)v38[1];
          if (!v125) {
            goto LABEL_215;
          }
        }
        do
        {
          uint64_t v126 = v125;
          unint64_t v125 = (unint64_t *)*v125;
        }
        while (v125);
LABEL_185:
        uint64_t v38 = v126;
        if (v126 == &v1005[8]._hash) {
          goto LABEL_46;
        }
      }
    }
LABEL_53:
    uint64_t v44 = *(double **)&v23[1]._type;
    float64_t v46 = *v44;
    float64_t v45 = v44[1];
    v1026.f64[0] = v46;
    v1026.f64[1] = v45;
    if (v45 != 0.0) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v45 + 8), 1uLL, memory_order_relaxed);
    }
    unint64_t v47 = v23;
    unint64_t v48 = *(unint64_t **)&v23[8]._xIdx;
    p_unsigned int hash = &v47[8]._hash;
    if (v48 != &v47[8]._hash)
    {
      v1009 = &v47[8]._hash;
      while (1)
      {
        long long v1025 = 0uLL;
        uint8x8_t v50 = (std::__shared_weak_count *)v48[5];
        if (!v50) {
          break;
        }
        id v51 = std::__shared_weak_count::lock(v50);
        *((void *)&v1025 + 1) = v51;
        if (!v51) {
          goto LABEL_66;
        }
        unint64_t v52 = v48[4];
        *(void *)&long long v1025 = v52;
        if (!v52) {
          goto LABEL_66;
        }
        if (v996[0])
        {
          unint64_t v53 = (*(uint64_t (**)(unint64_t))(*(void *)v52 + 160))(v52);
          int8x8_t v54 = (int8x8_t)v993[21];
          if (v54)
          {
            uint8x8_t v55 = (uint8x8_t)vcnt_s8(v54);
            v55.i16[0] = vaddlv_u8(v55);
            if (v55.u32[0] > 1uLL)
            {
              unint64_t v56 = v53;
              if (*(void *)&v54 <= v53) {
                unint64_t v56 = v53 % *(void *)&v54;
              }
            }
            else
            {
              unint64_t v56 = (*(void *)&v54 - 1) & v53;
            }
            size_t v68 = *(void **)(v993[20] + 8 * v56);
            if (v68)
            {
              unint64_t v69 = (void *)*v68;
              if (v69)
              {
                if (v55.u32[0] < 2uLL)
                {
                  uint64_t v70 = *(void *)&v54 - 1;
                  while (1)
                  {
                    uint64_t v72 = v69[1];
                    if (v72 == v53)
                    {
                      if (v69[2] == v53) {
                        goto LABEL_98;
                      }
                    }
                    else if ((v72 & v70) != v56)
                    {
                      goto LABEL_76;
                    }
                    unint64_t v69 = (void *)*v69;
                    if (!v69) {
                      goto LABEL_76;
                    }
                  }
                }
                do
                {
                  unint64_t v71 = v69[1];
                  if (v71 == v53)
                  {
                    if (v69[2] == v53) {
                      goto LABEL_98;
                    }
                  }
                  else
                  {
                    if (v71 >= *(void *)&v54) {
                      v71 %= *(void *)&v54;
                    }
                    if (v71 != v56) {
                      break;
                    }
                  }
                  unint64_t v69 = (void *)*v69;
                }
                while (v69);
              }
            }
          }
        }
LABEL_76:
        if (!*(void *)(*(uint64_t (**)(unint64_t, void, void, void, void))(*(void *)v52 + 552))(v52, 0, 0, 0, 0))
        {
          ++*(_DWORD *)(v6 + 92);
          int v13 = v1001;
          goto LABEL_67;
        }
        if (*(unsigned char *)(v52 + 140) || v1001 >= *(unsigned __int8 *)(v52 + 136))
        {
          md::PointLabelFeature::updatePositions((md::PointLabelFeature *)v52);
          uint64_t v59 = (*(uint64_t (**)(unint64_t))(*(void *)v52 + 160))(v52);
          if (md::DebugStreamingPOIFeatureID && md::DebugStreamingPOIFeatureID == v59)
          {
            if (GEOGetVectorKitStreamingPOILog_onceToken != -1) {
              dispatch_once(&GEOGetVectorKitStreamingPOILog_onceToken, &__block_literal_global_61);
            }
            unint64_t v60 = (id)GEOGetVectorKitStreamingPOILog_log;
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              md::HighlightHelper::debugTileToString(&v1027, v998);
              int v61 = SHIBYTE(v1027.__r_.__value_.__r.__words[2]);
              std::string::size_type v62 = v1027.__r_.__value_.__r.__words[0];
              md::HighlightHelper::debugTileToString(&__p, v1005 + 12);
              uint64_t v63 = &v1027;
              if (v61 < 0) {
                uint64_t v63 = (std::string *)v62;
              }
              p_p = &__p;
              if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
              }
              uint64_t v66 = *(void *)(v52 + 432);
              uint64_t v65 = *(void *)(v52 + 440);
              *(_DWORD *)buf = 136316418;
              *(void *)&int8x8_t buf[4] = v63;
              *(_WORD *)&buf[12] = 2080;
              *(void *)&buf[14] = p_p;
              *(_WORD *)&buf[22] = 2048;
              uint64_t v1032 = (uint64_t)v1005;
              __int16 v1033 = 2048;
              float64_t v1034 = v1026.f64[0];
              __int16 v1035 = 2048;
              uint64_t v1036 = v65;
              __int16 v1037 = 2048;
              uint64_t v1038 = v66;
              _os_log_impl(&dword_1A1780000, v60, OS_LOG_TYPE_DEBUG, "Add MapTileFeature, mapTile=(%s), labelTile=(%s)[%p] geoTile[%p] removeVersion=%llu, updateVersion=%llu", buf, 0x3Eu);
              if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(__p.__r_.__value_.__l.__data_);
              }
              p_unsigned int hash = v1009;
              if (SHIBYTE(v1027.__r_.__value_.__r.__words[2]) < 0) {
                operator delete(v1027.__r_.__value_.__l.__data_);
              }
            }
          }
          if (*(void *)(v52 + 440) > *(void *)(v52 + 432)) {
            goto LABEL_98;
          }
          BOOL v67 = v976;
          if (!*(unsigned char *)(v52 + 647)) {
            BOOL v67 = 0;
          }
          if (v67
            || v975
            && (*(uint64_t (**)(unint64_t))(*(void *)v52 + 368))(v52)
            && (*(uint64_t (**)(unint64_t))(*(void *)v52 + 384))(v52)
            && (uint64_t v73 = (*(uint64_t (**)(unint64_t))(*(void *)v52 + 376))(v52),
                int v74 = md::VenueLogicContext::displayedFloorOrdinalForVenueBuildingId(v975, v73),
                v74 != (*(unsigned int (**)(unint64_t))(*(void *)v52 + 400))(v52)))
          {
LABEL_98:
            int v13 = v1001;
            goto LABEL_67;
          }
          uint64_t v75 = *(unsigned int **)(v52 + 456);
          uint64_t v76 = (unsigned int *)(v52 + 464);
          int v13 = v1001;
          if (v75 == v76) {
            goto LABEL_67;
          }
          while (2)
          {
            uint64_t v78 = *((void *)v75 + 5);
            uint64_t v77 = *((void *)v75 + 6);
            float64x2_t v79 = v1026;
            if (*(void *)&v1026.f64[1]) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v1026.f64[1] + 8), 1uLL, memory_order_relaxed);
            }
            if (v78 == v77)
            {
              BOOL v84 = 0;
              if (!*(void *)&v79.f64[1]) {
                goto LABEL_141;
              }
            }
            else
            {
              uint64_t v80 = v78 + 8;
              do
              {
                uint64_t v81 = *(void *)(v80 - 8);
                if (v81) {
                  uint64_t v82 = v81 + 8;
                }
                else {
                  uint64_t v82 = 0;
                }
                uint64_t v83 = *(void *)(v82 + 8);
                BOOL v84 = v83 == *(void *)&v79.f64[0];
                _ZF = v83 == *(void *)&v79.f64[0] || v80 == v77;
                v80 += 8;
              }
              while (!_ZF);
              if (!*(void *)&v79.f64[1])
              {
LABEL_141:
                if (v84) {
                  goto LABEL_142;
                }
LABEL_177:
                uint64_t v105 = (unsigned int *)*((void *)v75 + 1);
                if (v105)
                {
                  do
                  {
LABEL_178:
                    uint64_t v106 = v105;
                    uint64_t v105 = *(unsigned int **)v105;
                  }
                  while (v105);
                  goto LABEL_124;
                }
                do
                {
LABEL_181:
                  uint64_t v106 = (unsigned int *)*((void *)v75 + 2);
                  _ZF = *(void *)v106 == (void)v75;
                  uint64_t v75 = v106;
                }
                while (!_ZF);
LABEL_124:
                uint64_t v75 = v106;
                if (v106 == v76)
                {
                  id v51 = (std::__shared_weak_count *)*((void *)&v1025 + 1);
                  goto LABEL_67;
                }
                continue;
              }
            }
            break;
          }
          if (atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v79.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL)) {
            goto LABEL_141;
          }
          (*(void (**)(void))(**(void **)&v79.f64[1] + 16))(*(void *)&v79.f64[1]);
          std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v79.f64[1]);
          if (!v84) {
            goto LABEL_177;
          }
LABEL_142:
          std::string::size_type v86 = v1025;
          if (v998->_type == 255)
          {
            int8x8_t v101 = (md::LabelPoint *)(*(uint64_t (**)(void, void *))(*(void *)v1025 + 112))(v1025, (void *)v75 + 4);
            int8x8_t v102 = (double *)md::LabelPoint::mercatorPoint(v101);
            if (*v102 < *v1015) {
              goto LABEL_177;
            }
            if (*v102 > *(double *)(v6 + 56)) {
              goto LABEL_177;
            }
            double v103 = v102[1];
            if (v103 < *(double *)(v6 + 48) || v103 > *(double *)(v6 + 64)) {
              goto LABEL_177;
            }
            std::string::size_type v86 = v1025;
          }
          unsigned int v87 = v1030;
          unsigned int v88 = (std::__shared_weak_count *)*((void *)&v1025 + 1);
          v1027.__r_.__value_.__r.__words[0] = v86;
          v1027.__r_.__value_.__l.__size_ = *((void *)&v1025 + 1);
          if (*((void *)&v1025 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v1025 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v87, &v1027, v75 + 8, 1);
          if (v88 && !atomic_fetch_add(&v88->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
            std::__shared_weak_count::__release_weak(v88);
            unint64_t v89 = *(void *)buf;
            if (*(void *)buf) {
              goto LABEL_148;
            }
          }
          else
          {
            unint64_t v89 = *(void *)buf;
            if (*(void *)buf)
            {
LABEL_148:
              int v90 = v1021;
              while (1)
              {
                int v91 = *v90;
                int v92 = v90;
                if (!*v90) {
                  break;
                }
                while (1)
                {
                  int v90 = (uint64_t **)v91;
                  unint64_t v93 = v91[4];
                  if (v89 < v93) {
                    break;
                  }
                  if (v93 >= v89) {
                    goto LABEL_162;
                  }
                  int v91 = v90[1];
                  if (!v91)
                  {
                    int v92 = v90 + 1;
                    goto LABEL_154;
                  }
                }
              }
LABEL_154:
              uint64_t v94 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 424) + 16))(*(void *)(v6 + 424), 48, 8);
              uint64_t v95 = v94;
              uint64_t v96 = *(void *)&buf[8];
              v94[4] = *(void *)buf;
              v94[5] = v96;
              if (v96) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v96 + 8), 1uLL, memory_order_relaxed);
              }
              uint64_t *v94 = 0;
              v94[1] = 0;
              v94[2] = (uint64_t)v90;
              char *v92 = v94;
              uint64_t v97 = **(void **)(v6 + 408);
              if (v97)
              {
                *(void *)(v6 + 408) = v97;
                uint64_t v95 = *v92;
              }
              std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v6 + 416), v95);
              ++*(void *)(v6 + 432);
              uint64_t v98 = *(void *)buf;
              if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v98 + 820))
              {
                *(unsigned char *)(v98 + 1214) = -1;
                md::Label::updateStateMachineForStaging(v98, 0, 37);
              }
              *(unsigned char *)(v98 + 1261) = 0;
              *(void *)(v98 + 1224) = 0;
              unint64_t v89 = *(void *)buf;
LABEL_162:
              uint64_t v99 = v1030;
              unint64_t v100 = (std::__shared_weak_count *)*((void *)&v1025 + 1);
              *(_OWORD *)&v1027.__r_.__value_.__l.__data_ = v1025;
              p_unsigned int hash = v1009;
              if (*((void *)&v1025 + 1)) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v1025 + 1) + 8), 1uLL, memory_order_relaxed);
              }
              md::Label::update(v89, (uint64_t)v99, v6);
              if (v100 && !atomic_fetch_add(&v100->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v100->__on_zero_shared)(v100);
                std::__shared_weak_count::__release_weak(v100);
              }
            }
          }
          unint64_t v104 = *(std::__shared_weak_count **)&buf[8];
          if (!*(void *)&buf[8]
            || atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            goto LABEL_177;
          }
          ((void (*)(std::__shared_weak_count *))v104->__on_zero_shared)(v104);
          std::__shared_weak_count::__release_weak(v104);
          uint64_t v105 = (unsigned int *)*((void *)v75 + 1);
          if (v105) {
            goto LABEL_178;
          }
          goto LABEL_181;
        }
        ++*(_DWORD *)(v6 + 96);
        int v13 = v1001;
LABEL_67:
        if (v51 && !atomic_fetch_add(&v51->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
          std::__shared_weak_count::__release_weak(v51);
          float v57 = (unint64_t *)v48[1];
          if (!v57)
          {
            do
            {
LABEL_73:
              BOOL v58 = (unint64_t *)v48[2];
              _ZF = *v58 == (void)v48;
              unint64_t v48 = v58;
            }
            while (!_ZF);
            goto LABEL_57;
          }
        }
        else
        {
          float v57 = (unint64_t *)v48[1];
          if (!v57) {
            goto LABEL_73;
          }
        }
        do
        {
          BOOL v58 = v57;
          float v57 = (unint64_t *)*v57;
        }
        while (v57);
LABEL_57:
        unint64_t v48 = v58;
        if (v58 == p_hash) {
          goto LABEL_383;
        }
      }
      id v51 = 0;
LABEL_66:
      ++*(_DWORD *)(v6 + 88);
      goto LABEL_67;
    }
LABEL_383:
    v227 = (const QuadTile *)v1005[1]._hash;
    if (v227 != &v1005[2])
    {
      v1010 = 0;
      while (1)
      {
        *(_OWORD *)&v1027.__r_.__value_.__l.__data_ = 0uLL;
        __int16 v228 = (std::__shared_weak_count *)v227[1]._hash;
        if (!v228
          || (v1027.__r_.__value_.__l.__size_ = (std::string::size_type)std::__shared_weak_count::lock(v228)) == 0
          || (uint64_t v229 = *(unsigned __int8 **)&v227[1]._xIdx,
              (v1027.__r_.__value_.__r.__words[0] = (std::string::size_type)v229) == 0))
        {
          ++*(_DWORD *)(v6 + 88);
          goto LABEL_394;
        }
        if (!*(void *)(*(uint64_t (**)(unsigned __int8 *, void, void, void, void))(*(void *)v229 + 552))(v229, 0, 0, 0, 0))
        {
          ++*(_DWORD *)(v6 + 92);
          goto LABEL_394;
        }
        if (!v229[140] && v13 < v229[136])
        {
          ++*(_DWORD *)(v6 + 96);
          goto LABEL_394;
        }
        md::LineLabelFeature::updatePositions((md::LineLabelFeature *)v229, v1030, v13, (md::LabelMapTile *)v6);
        md::LineLabelPlacer::placementsForRect((char **)buf, (uint64_t)(v229 + 192), v1015, v13);
        if (v1010) {
          operator delete(v1010);
        }
        id v233 = *(unsigned int **)&buf[8];
        v1010 = *(void **)buf;
        v234 = *(unsigned int **)buf;
        if (*(void *)buf != *(void *)&buf[8]) {
          break;
        }
LABEL_394:
        size = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        if (v1027.__r_.__value_.__l.__size_
          && !atomic_fetch_add((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
          std::__shared_weak_count::__release_weak(size);
          char v231 = *(const QuadTile **)&v227->_xIdx;
          if (!v231)
          {
            do
            {
LABEL_400:
              uint64_t v232 = (const QuadTile *)v227->_hash;
              _ZF = *(void *)&v232->_type == (void)v227;
              v227 = v232;
            }
            while (!_ZF);
            goto LABEL_385;
          }
        }
        else
        {
          char v231 = *(const QuadTile **)&v227->_xIdx;
          if (!v231) {
            goto LABEL_400;
          }
        }
        do
        {
          uint64_t v232 = v231;
          char v231 = *(const QuadTile **)&v231->_type;
        }
        while (v231);
LABEL_385:
        v227 = v232;
        if (v232 == &v1005[2]) {
          goto LABEL_468;
        }
      }
      while (1)
      {
        v235 = v1030;
        uint64_t v236 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
        if (v1027.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v235, &__p, v234, 1);
        if (v236 && !atomic_fetch_add(&v236->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v236->__on_zero_shared)(v236);
          std::__shared_weak_count::__release_weak(v236);
          unint64_t v237 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_461;
          }
        }
        else
        {
          unint64_t v237 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_461;
          }
        }
        long long v238 = (uint64_t *)v1021;
        while (1)
        {
          int v239 = (uint64_t *)*v238;
          long long v240 = v238;
          if (!*v238) {
            break;
          }
          while (1)
          {
            long long v238 = v239;
            unint64_t v241 = v239[4];
            if (v237 < v241) {
              break;
            }
            if (v241 >= v237) {
              goto LABEL_457;
            }
            int v239 = (uint64_t *)v238[1];
            if (!v239)
            {
              long long v240 = v238 + 1;
              goto LABEL_419;
            }
          }
        }
LABEL_419:
        uint64_t v242 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 424) + 16))(*(void *)(v6 + 424), 48, 8);
        uint64_t v243 = *(void *)&buf[8];
        *(void *)(v242 + 32) = *(void *)buf;
        *(void *)(v242 + 40) = v243;
        if (v243) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v243 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)uint64_t v242 = 0;
        *(void *)(v242 + 8) = 0;
        *(void *)(v242 + 16) = v238;
        *long long v240 = v242;
        uint64_t v244 = **(void **)(v6 + 408);
        if (v244)
        {
          *(void *)(v6 + 408) = v244;
          uint64_t v242 = *v240;
        }
        v245 = *v1021;
        _ZF = v242 == (void)*v1021;
        *(unsigned char *)(v242 + 24) = _ZF;
        if (!_ZF)
        {
          do
          {
            uint64_t v246 = *(uint64_t **)(v242 + 16);
            if (*((unsigned char *)v246 + 24)) {
              break;
            }
            uint64_t v247 = v246[2];
            v248 = *(uint64_t **)v247;
            if (*(uint64_t **)v247 == v246)
            {
              uint64_t v251 = *(void *)(v247 + 8);
              if (!v251 || (v252 = *(unsigned __int8 *)(v251 + 24), uint64_t v249 = (unsigned char *)(v251 + 24), v252))
              {
                if (*v246 == v242)
                {
                  v253 = *(uint64_t ***)(v242 + 16);
                }
                else
                {
                  v253 = (uint64_t **)v246[1];
                  v254 = *v253;
                  v246[1] = (uint64_t)*v253;
                  if (v254)
                  {
                    v254[2] = (uint64_t)v246;
                    uint64_t v247 = v246[2];
                  }
                  v253[2] = (uint64_t *)v247;
                  *(void *)(v246[2] + 8 * (*(void *)v246[2] != (void)v246)) = v253;
                  *v253 = v246;
                  v246[2] = (uint64_t)v253;
                  uint64_t v247 = (uint64_t)v253[2];
                  uint64_t v246 = *(uint64_t **)v247;
                }
                *((unsigned char *)v253 + 24) = 1;
                *(unsigned char *)(v247 + 24) = 0;
                uint64_t v257 = v246[1];
                *(void *)uint64_t v247 = v257;
                if (v257) {
                  *(void *)(v257 + 16) = v247;
                }
                v246[2] = *(void *)(v247 + 16);
                *(void *)(*(void *)(v247 + 16) + 8 * (**(void **)(v247 + 16) != v247)) = v246;
                v246[1] = v247;
                goto LABEL_452;
              }
            }
            else if (!v248 || (v250 = *((unsigned __int8 *)v248 + 24), uint64_t v249 = v248 + 3, v250))
            {
              if (*v246 == v242)
              {
                uint64_t v255 = *(void *)(v242 + 8);
                *uint64_t v246 = v255;
                if (v255)
                {
                  *(void *)(v255 + 16) = v246;
                  uint64_t v247 = v246[2];
                }
                *(void *)(v242 + 16) = v247;
                *(void *)(v246[2] + 8 * (*(void *)v246[2] != (void)v246)) = v242;
                *(void *)(v242 + 8) = v246;
                v246[2] = v242;
                uint64_t v247 = *(void *)(v242 + 16);
              }
              else
              {
                uint64_t v242 = *(void *)(v242 + 16);
              }
              *(unsigned char *)(v242 + 24) = 1;
              *(unsigned char *)(v247 + 24) = 0;
              uint64_t v246 = *(uint64_t **)(v247 + 8);
              uint64_t v256 = *v246;
              *(void *)(v247 + 8) = *v246;
              if (v256) {
                *(void *)(v256 + 16) = v247;
              }
              v246[2] = *(void *)(v247 + 16);
              *(void *)(*(void *)(v247 + 16) + 8 * (**(void **)(v247 + 16) != v247)) = v246;
              *uint64_t v246 = v247;
LABEL_452:
              *(void *)(v247 + 16) = v246;
              break;
            }
            *((unsigned char *)v246 + 24) = 1;
            uint64_t v242 = v247;
            *(unsigned char *)(v247 + 24) = v247 == (void)v245;
            *uint64_t v249 = 1;
          }
          while ((uint64_t *)v247 != v245);
        }
        ++*(void *)(v6 + 432);
        uint64_t v258 = *(void *)buf;
        if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v258 + 820))
        {
          *(unsigned char *)(v258 + 1214) = -1;
          md::Label::updateStateMachineForStaging(v258, 0, 37);
        }
        *(unsigned char *)(v258 + 1261) = 0;
        *(void *)(v258 + 1224) = 0;
        unint64_t v237 = *(void *)buf;
LABEL_457:
        v259 = v1030;
        v260 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
        if (v1027.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        md::Label::update(v237, (uint64_t)v259, v6);
        if (!v260 || atomic_fetch_add(&v260->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
LABEL_461:
          v261 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8]) {
            goto LABEL_462;
          }
          goto LABEL_407;
        }
        ((void (*)(std::__shared_weak_count *))v260->__on_zero_shared)(v260);
        std::__shared_weak_count::__release_weak(v260);
        v261 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8])
        {
LABEL_462:
          if (!atomic_fetch_add(&v261->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v261->__on_zero_shared)(v261);
            std::__shared_weak_count::__release_weak(v261);
          }
        }
LABEL_407:
        if (++v234 == v233) {
          goto LABEL_394;
        }
      }
    }
    v1010 = 0;
LABEL_468:
    v262 = (const QuadTile *)v1005[5]._hash;
    if (v262 != &v1005[6])
    {
      while (1)
      {
        *(_OWORD *)&v1027.__r_.__value_.__l.__data_ = 0uLL;
        v268 = (std::__shared_weak_count *)v262[1]._hash;
        if (!v268
          || (v1027.__r_.__value_.__l.__size_ = (std::string::size_type)std::__shared_weak_count::lock(v268)) == 0
          || (v269 = *(unsigned __int8 **)&v262[1]._xIdx,
              (v1027.__r_.__value_.__r.__words[0] = (std::string::size_type)v269) == 0))
        {
          ++*(_DWORD *)(v6 + 88);
          goto LABEL_487;
        }
        if (!*(void *)(*(uint64_t (**)(unsigned __int8 *, void, void, void, void))(*(void *)v269 + 552))(v269, 0, 0, 0, 0))
        {
          ++*(_DWORD *)(v6 + 92);
          goto LABEL_487;
        }
        if (!v269[140] && v13 < v269[136])
        {
          ++*(_DWORD *)(v6 + 96);
          goto LABEL_487;
        }
        md::LineLabelFeature::updatePositions((md::LineLabelFeature *)v269, v1030, v13, (md::LabelMapTile *)v6);
        md::LineLabelPlacer::placementsForRect((char **)buf, (uint64_t)(v269 + 192), v1015, v13);
        if (v1010) {
          operator delete(v1010);
        }
        v273 = *(unsigned int **)&buf[8];
        v1010 = *(void **)buf;
        v274 = *(unsigned int **)buf;
        if (*(void *)buf != *(void *)&buf[8]) {
          break;
        }
LABEL_487:
        v270 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        if (v1027.__r_.__value_.__l.__size_
          && !atomic_fetch_add((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v270->__on_zero_shared)(v270);
          std::__shared_weak_count::__release_weak(v270);
          v271 = *(const QuadTile **)&v262->_xIdx;
          if (!v271)
          {
            do
            {
LABEL_493:
              v272 = (const QuadTile *)v262->_hash;
              _ZF = *(void *)&v272->_type == (void)v262;
              v262 = v272;
            }
            while (!_ZF);
            goto LABEL_478;
          }
        }
        else
        {
          v271 = *(const QuadTile **)&v262->_xIdx;
          if (!v271) {
            goto LABEL_493;
          }
        }
        do
        {
          v272 = v271;
          v271 = *(const QuadTile **)&v271->_type;
        }
        while (v271);
LABEL_478:
        v262 = v272;
        if (v272 == &v1005[6]) {
          goto LABEL_469;
        }
      }
      while (1)
      {
        v275 = v1030;
        v276 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
        if (v1027.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v275, &__p, v274, 1);
        if (v276 && !atomic_fetch_add(&v276->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v276->__on_zero_shared)(v276);
          std::__shared_weak_count::__release_weak(v276);
          unint64_t v277 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_554;
          }
        }
        else
        {
          unint64_t v277 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_554;
          }
        }
        v278 = (uint64_t *)v1021;
        while (1)
        {
          v279 = (uint64_t *)*v278;
          v280 = v278;
          if (!*v278) {
            break;
          }
          while (1)
          {
            v278 = v279;
            unint64_t v281 = v279[4];
            if (v277 < v281) {
              break;
            }
            if (v281 >= v277) {
              goto LABEL_550;
            }
            v279 = (uint64_t *)v278[1];
            if (!v279)
            {
              v280 = v278 + 1;
              goto LABEL_512;
            }
          }
        }
LABEL_512:
        uint64_t v282 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 424) + 16))(*(void *)(v6 + 424), 48, 8);
        uint64_t v283 = *(void *)&buf[8];
        *(void *)(v282 + 32) = *(void *)buf;
        *(void *)(v282 + 40) = v283;
        if (v283) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v283 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)uint64_t v282 = 0;
        *(void *)(v282 + 8) = 0;
        *(void *)(v282 + 16) = v278;
        uint64_t *v280 = v282;
        uint64_t v284 = **(void **)(v6 + 408);
        if (v284)
        {
          *(void *)(v6 + 408) = v284;
          uint64_t v282 = *v280;
        }
        v285 = *v1021;
        _ZF = v282 == (void)*v1021;
        *(unsigned char *)(v282 + 24) = _ZF;
        if (!_ZF)
        {
          do
          {
            v286 = *(uint64_t **)(v282 + 16);
            if (*((unsigned char *)v286 + 24)) {
              break;
            }
            uint64_t v287 = v286[2];
            v288 = *(uint64_t **)v287;
            if (*(uint64_t **)v287 == v286)
            {
              uint64_t v291 = *(void *)(v287 + 8);
              if (!v291 || (int v292 = *(unsigned __int8 *)(v291 + 24), v289 = (unsigned char *)(v291 + 24), v292))
              {
                if (*v286 == v282)
                {
                  v293 = *(uint64_t ***)(v282 + 16);
                }
                else
                {
                  v293 = (uint64_t **)v286[1];
                  v294 = *v293;
                  v286[1] = (uint64_t)*v293;
                  if (v294)
                  {
                    v294[2] = (uint64_t)v286;
                    uint64_t v287 = v286[2];
                  }
                  v293[2] = (uint64_t *)v287;
                  *(void *)(v286[2] + 8 * (*(void *)v286[2] != (void)v286)) = v293;
                  *v293 = v286;
                  v286[2] = (uint64_t)v293;
                  uint64_t v287 = (uint64_t)v293[2];
                  v286 = *(uint64_t **)v287;
                }
                *((unsigned char *)v293 + 24) = 1;
                *(unsigned char *)(v287 + 24) = 0;
                uint64_t v297 = v286[1];
                *(void *)uint64_t v287 = v297;
                if (v297) {
                  *(void *)(v297 + 16) = v287;
                }
                v286[2] = *(void *)(v287 + 16);
                *(void *)(*(void *)(v287 + 16) + 8 * (**(void **)(v287 + 16) != v287)) = v286;
                v286[1] = v287;
                goto LABEL_545;
              }
            }
            else if (!v288 || (int v290 = *((unsigned __int8 *)v288 + 24), v289 = v288 + 3, v290))
            {
              if (*v286 == v282)
              {
                uint64_t v295 = *(void *)(v282 + 8);
                uint64_t *v286 = v295;
                if (v295)
                {
                  *(void *)(v295 + 16) = v286;
                  uint64_t v287 = v286[2];
                }
                *(void *)(v282 + 16) = v287;
                *(void *)(v286[2] + 8 * (*(void *)v286[2] != (void)v286)) = v282;
                *(void *)(v282 + 8) = v286;
                v286[2] = v282;
                uint64_t v287 = *(void *)(v282 + 16);
              }
              else
              {
                uint64_t v282 = *(void *)(v282 + 16);
              }
              *(unsigned char *)(v282 + 24) = 1;
              *(unsigned char *)(v287 + 24) = 0;
              v286 = *(uint64_t **)(v287 + 8);
              uint64_t v296 = *v286;
              *(void *)(v287 + 8) = *v286;
              if (v296) {
                *(void *)(v296 + 16) = v287;
              }
              v286[2] = *(void *)(v287 + 16);
              *(void *)(*(void *)(v287 + 16) + 8 * (**(void **)(v287 + 16) != v287)) = v286;
              uint64_t *v286 = v287;
LABEL_545:
              *(void *)(v287 + 16) = v286;
              break;
            }
            *((unsigned char *)v286 + 24) = 1;
            uint64_t v282 = v287;
            *(unsigned char *)(v287 + 24) = v287 == (void)v285;
            unsigned char *v289 = 1;
          }
          while ((uint64_t *)v287 != v285);
        }
        ++*(void *)(v6 + 432);
        uint64_t v298 = *(void *)buf;
        if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v298 + 820))
        {
          *(unsigned char *)(v298 + 1214) = -1;
          md::Label::updateStateMachineForStaging(v298, 0, 37);
        }
        *(unsigned char *)(v298 + 1261) = 0;
        *(void *)(v298 + 1224) = 0;
        unint64_t v277 = *(void *)buf;
LABEL_550:
        v299 = v1030;
        v300 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
        if (v1027.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        md::Label::update(v277, (uint64_t)v299, v6);
        if (!v300 || atomic_fetch_add(&v300->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
LABEL_554:
          v301 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8]) {
            goto LABEL_555;
          }
          goto LABEL_500;
        }
        ((void (*)(std::__shared_weak_count *))v300->__on_zero_shared)(v300);
        std::__shared_weak_count::__release_weak(v300);
        v301 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8])
        {
LABEL_555:
          if (!atomic_fetch_add(&v301->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v301->__on_zero_shared)(v301);
            std::__shared_weak_count::__release_weak(v301);
          }
        }
LABEL_500:
        if (++v274 == v273) {
          goto LABEL_487;
        }
      }
    }
LABEL_469:
    uint64_t v263 = (const QuadTile *)v1005[9]._hash;
    if (v263 != &v1005[10])
    {
      while (1)
      {
        *(_OWORD *)&v1027.__r_.__value_.__l.__data_ = 0uLL;
        v302 = (std::__shared_weak_count *)v263[1]._hash;
        if (!v302
          || (v1027.__r_.__value_.__l.__size_ = (std::string::size_type)std::__shared_weak_count::lock(v302)) == 0
          || (v303 = *(unsigned __int8 **)&v263[1]._xIdx,
              (v1027.__r_.__value_.__r.__words[0] = (std::string::size_type)v303) == 0))
        {
          ++*(_DWORD *)(v6 + 88);
          goto LABEL_569;
        }
        if (!*(void *)(*(uint64_t (**)(unsigned __int8 *, void, void, void, void))(*(void *)v303 + 552))(v303, 0, 0, 0, 0))
        {
          ++*(_DWORD *)(v6 + 92);
          goto LABEL_569;
        }
        if (!v303[140] && v13 < v303[136])
        {
          ++*(_DWORD *)(v6 + 96);
          goto LABEL_569;
        }
        md::LineLabelFeature::updatePositions((md::LineLabelFeature *)v303, v1030, v13, (md::LabelMapTile *)v6);
        md::LineLabelPlacer::placementsForRect((char **)buf, (uint64_t)(v303 + 192), v1015, v13);
        if (v1010) {
          operator delete(v1010);
        }
        v307 = *(unsigned int **)&buf[8];
        v1010 = *(void **)buf;
        v308 = *(unsigned int **)buf;
        if (*(void *)buf != *(void *)&buf[8]) {
          break;
        }
LABEL_569:
        v304 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        if (v1027.__r_.__value_.__l.__size_
          && !atomic_fetch_add((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v304->__on_zero_shared)(v304);
          std::__shared_weak_count::__release_weak(v304);
          v305 = *(const QuadTile **)&v263->_xIdx;
          if (!v305)
          {
            do
            {
LABEL_575:
              v306 = (const QuadTile *)v263->_hash;
              _ZF = *(void *)&v306->_type == (void)v263;
              uint64_t v263 = v306;
            }
            while (!_ZF);
            goto LABEL_560;
          }
        }
        else
        {
          v305 = *(const QuadTile **)&v263->_xIdx;
          if (!v305) {
            goto LABEL_575;
          }
        }
        do
        {
          v306 = v305;
          v305 = *(const QuadTile **)&v305->_type;
        }
        while (v305);
LABEL_560:
        uint64_t v263 = v306;
        if (v306 == &v1005[10]) {
          goto LABEL_470;
        }
      }
      while (1)
      {
        v309 = v1030;
        v310 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
        if (v1027.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v309, &__p, v308, 1);
        if (v310 && !atomic_fetch_add(&v310->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v310->__on_zero_shared)(v310);
          std::__shared_weak_count::__release_weak(v310);
          unint64_t v311 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_636;
          }
        }
        else
        {
          unint64_t v311 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_636;
          }
        }
        v312 = (uint64_t *)v1021;
        while (1)
        {
          v313 = (uint64_t *)*v312;
          v314 = v312;
          if (!*v312) {
            break;
          }
          while (1)
          {
            v312 = v313;
            unint64_t v315 = v313[4];
            if (v311 < v315) {
              break;
            }
            if (v315 >= v311) {
              goto LABEL_632;
            }
            v313 = (uint64_t *)v312[1];
            if (!v313)
            {
              v314 = v312 + 1;
              goto LABEL_594;
            }
          }
        }
LABEL_594:
        uint64_t v316 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 424) + 16))(*(void *)(v6 + 424), 48, 8);
        uint64_t v317 = *(void *)&buf[8];
        *(void *)(v316 + 32) = *(void *)buf;
        *(void *)(v316 + 40) = v317;
        if (v317) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v317 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)uint64_t v316 = 0;
        *(void *)(v316 + 8) = 0;
        *(void *)(v316 + 16) = v312;
        uint64_t *v314 = v316;
        uint64_t v318 = **(void **)(v6 + 408);
        if (v318)
        {
          *(void *)(v6 + 408) = v318;
          uint64_t v316 = *v314;
        }
        v319 = *v1021;
        _ZF = v316 == (void)*v1021;
        *(unsigned char *)(v316 + 24) = _ZF;
        if (!_ZF)
        {
          do
          {
            v320 = *(uint64_t **)(v316 + 16);
            if (*((unsigned char *)v320 + 24)) {
              break;
            }
            uint64_t v321 = v320[2];
            v322 = *(uint64_t **)v321;
            if (*(uint64_t **)v321 == v320)
            {
              uint64_t v325 = *(void *)(v321 + 8);
              if (!v325 || (int v326 = *(unsigned __int8 *)(v325 + 24), v323 = (unsigned char *)(v325 + 24), v326))
              {
                if (*v320 == v316)
                {
                  v327 = *(uint64_t ***)(v316 + 16);
                }
                else
                {
                  v327 = (uint64_t **)v320[1];
                  v328 = *v327;
                  v320[1] = (uint64_t)*v327;
                  if (v328)
                  {
                    v328[2] = (uint64_t)v320;
                    uint64_t v321 = v320[2];
                  }
                  v327[2] = (uint64_t *)v321;
                  *(void *)(v320[2] + 8 * (*(void *)v320[2] != (void)v320)) = v327;
                  *v327 = v320;
                  v320[2] = (uint64_t)v327;
                  uint64_t v321 = (uint64_t)v327[2];
                  v320 = *(uint64_t **)v321;
                }
                *((unsigned char *)v327 + 24) = 1;
                *(unsigned char *)(v321 + 24) = 0;
                uint64_t v331 = v320[1];
                *(void *)uint64_t v321 = v331;
                if (v331) {
                  *(void *)(v331 + 16) = v321;
                }
                v320[2] = *(void *)(v321 + 16);
                *(void *)(*(void *)(v321 + 16) + 8 * (**(void **)(v321 + 16) != v321)) = v320;
                v320[1] = v321;
                goto LABEL_627;
              }
            }
            else if (!v322 || (int v324 = *((unsigned __int8 *)v322 + 24), v323 = v322 + 3, v324))
            {
              if (*v320 == v316)
              {
                uint64_t v329 = *(void *)(v316 + 8);
                uint64_t *v320 = v329;
                if (v329)
                {
                  *(void *)(v329 + 16) = v320;
                  uint64_t v321 = v320[2];
                }
                *(void *)(v316 + 16) = v321;
                *(void *)(v320[2] + 8 * (*(void *)v320[2] != (void)v320)) = v316;
                *(void *)(v316 + 8) = v320;
                v320[2] = v316;
                uint64_t v321 = *(void *)(v316 + 16);
              }
              else
              {
                uint64_t v316 = *(void *)(v316 + 16);
              }
              *(unsigned char *)(v316 + 24) = 1;
              *(unsigned char *)(v321 + 24) = 0;
              v320 = *(uint64_t **)(v321 + 8);
              uint64_t v330 = *v320;
              *(void *)(v321 + 8) = *v320;
              if (v330) {
                *(void *)(v330 + 16) = v321;
              }
              v320[2] = *(void *)(v321 + 16);
              *(void *)(*(void *)(v321 + 16) + 8 * (**(void **)(v321 + 16) != v321)) = v320;
              uint64_t *v320 = v321;
LABEL_627:
              *(void *)(v321 + 16) = v320;
              break;
            }
            *((unsigned char *)v320 + 24) = 1;
            uint64_t v316 = v321;
            *(unsigned char *)(v321 + 24) = v321 == (void)v319;
            unsigned char *v323 = 1;
          }
          while ((uint64_t *)v321 != v319);
        }
        ++*(void *)(v6 + 432);
        uint64_t v332 = *(void *)buf;
        if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v332 + 820))
        {
          *(unsigned char *)(v332 + 1214) = -1;
          md::Label::updateStateMachineForStaging(v332, 0, 37);
        }
        *(unsigned char *)(v332 + 1261) = 0;
        *(void *)(v332 + 1224) = 0;
        unint64_t v311 = *(void *)buf;
LABEL_632:
        v333 = v1030;
        v334 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
        if (v1027.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        md::Label::update(v311, (uint64_t)v333, v6);
        if (!v334 || atomic_fetch_add(&v334->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
LABEL_636:
          v335 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8]) {
            goto LABEL_637;
          }
          goto LABEL_582;
        }
        ((void (*)(std::__shared_weak_count *))v334->__on_zero_shared)(v334);
        std::__shared_weak_count::__release_weak(v334);
        v335 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8])
        {
LABEL_637:
          if (!atomic_fetch_add(&v335->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v335->__on_zero_shared)(v335);
            std::__shared_weak_count::__release_weak(v335);
          }
        }
LABEL_582:
        if (++v308 == v307) {
          goto LABEL_569;
        }
      }
    }
LABEL_470:
    v264 = *(unint64_t **)&v1005[4]._xIdx;
    if (v264 != &v1005[4]._hash)
    {
      while (1)
      {
        *(_OWORD *)&v1027.__r_.__value_.__l.__data_ = 0uLL;
        v336 = (std::__shared_weak_count *)v264[5];
        if (!v336
          || (v1027.__r_.__value_.__l.__size_ = (std::string::size_type)std::__shared_weak_count::lock(v336)) == 0
          || (v337 = (unsigned __int8 *)v264[4], (v1027.__r_.__value_.__r.__words[0] = (std::string::size_type)v337) == 0))
        {
          ++*(_DWORD *)(v6 + 88);
          goto LABEL_651;
        }
        if (!*(void *)(*(uint64_t (**)(unsigned __int8 *, void, void, void, void))(*(void *)v337 + 552))(v337, 0, 0, 0, 0))
        {
          ++*(_DWORD *)(v6 + 92);
          goto LABEL_651;
        }
        if (!v337[140] && v13 < v337[136])
        {
          ++*(_DWORD *)(v6 + 96);
          goto LABEL_651;
        }
        md::LineLabelFeature::updatePositions((md::LineLabelFeature *)v337, v1030, v13, (md::LabelMapTile *)v6);
        md::LineLabelPlacer::placementsForRect((char **)buf, (uint64_t)(v337 + 192), v1015, v13);
        if (v1010) {
          operator delete(v1010);
        }
        v341 = *(unsigned int **)&buf[8];
        v1010 = *(void **)buf;
        v342 = *(unsigned int **)buf;
        if (*(void *)buf != *(void *)&buf[8]) {
          break;
        }
LABEL_651:
        v338 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        if (v1027.__r_.__value_.__l.__size_
          && !atomic_fetch_add((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v338->__on_zero_shared)(v338);
          std::__shared_weak_count::__release_weak(v338);
          v339 = (unint64_t *)v264[1];
          if (!v339)
          {
            do
            {
LABEL_657:
              v340 = (unint64_t *)v264[2];
              _ZF = *v340 == (void)v264;
              v264 = v340;
            }
            while (!_ZF);
            goto LABEL_642;
          }
        }
        else
        {
          v339 = (unint64_t *)v264[1];
          if (!v339) {
            goto LABEL_657;
          }
        }
        do
        {
          v340 = v339;
          v339 = (unint64_t *)*v339;
        }
        while (v339);
LABEL_642:
        v264 = v340;
        if (v340 == &v1005[4]._hash) {
          goto LABEL_471;
        }
      }
      while (1)
      {
        v343 = v1030;
        v344 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
        if (v1027.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v343, &__p, v342, 1);
        if (v344 && !atomic_fetch_add(&v344->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v344->__on_zero_shared)(v344);
          std::__shared_weak_count::__release_weak(v344);
          unint64_t v345 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_718;
          }
        }
        else
        {
          unint64_t v345 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_718;
          }
        }
        v346 = (uint64_t *)v1021;
        while (1)
        {
          v347 = (uint64_t *)*v346;
          v348 = v346;
          if (!*v346) {
            break;
          }
          while (1)
          {
            v346 = v347;
            unint64_t v349 = v347[4];
            if (v345 < v349) {
              break;
            }
            if (v349 >= v345) {
              goto LABEL_714;
            }
            v347 = (uint64_t *)v346[1];
            if (!v347)
            {
              v348 = v346 + 1;
              goto LABEL_676;
            }
          }
        }
LABEL_676:
        uint64_t v350 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 424) + 16))(*(void *)(v6 + 424), 48, 8);
        uint64_t v351 = *(void *)&buf[8];
        *(void *)(v350 + 32) = *(void *)buf;
        *(void *)(v350 + 40) = v351;
        if (v351) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v351 + 8), 1uLL, memory_order_relaxed);
        }
        *(void *)uint64_t v350 = 0;
        *(void *)(v350 + 8) = 0;
        *(void *)(v350 + 16) = v346;
        uint64_t *v348 = v350;
        uint64_t v352 = **(void **)(v6 + 408);
        if (v352)
        {
          *(void *)(v6 + 408) = v352;
          uint64_t v350 = *v348;
        }
        v353 = *v1021;
        _ZF = v350 == (void)*v1021;
        *(unsigned char *)(v350 + 24) = _ZF;
        if (!_ZF)
        {
          do
          {
            v354 = *(uint64_t **)(v350 + 16);
            if (*((unsigned char *)v354 + 24)) {
              break;
            }
            uint64_t v355 = v354[2];
            v356 = *(uint64_t **)v355;
            if (*(uint64_t **)v355 == v354)
            {
              uint64_t v359 = *(void *)(v355 + 8);
              if (!v359 || (int v360 = *(unsigned __int8 *)(v359 + 24), v357 = (unsigned char *)(v359 + 24), v360))
              {
                if (*v354 == v350)
                {
                  v361 = *(uint64_t ***)(v350 + 16);
                }
                else
                {
                  v361 = (uint64_t **)v354[1];
                  v362 = *v361;
                  v354[1] = (uint64_t)*v361;
                  if (v362)
                  {
                    v362[2] = (uint64_t)v354;
                    uint64_t v355 = v354[2];
                  }
                  v361[2] = (uint64_t *)v355;
                  *(void *)(v354[2] + 8 * (*(void *)v354[2] != (void)v354)) = v361;
                  *v361 = v354;
                  v354[2] = (uint64_t)v361;
                  uint64_t v355 = (uint64_t)v361[2];
                  v354 = *(uint64_t **)v355;
                }
                *((unsigned char *)v361 + 24) = 1;
                *(unsigned char *)(v355 + 24) = 0;
                uint64_t v365 = v354[1];
                *(void *)uint64_t v355 = v365;
                if (v365) {
                  *(void *)(v365 + 16) = v355;
                }
                v354[2] = *(void *)(v355 + 16);
                *(void *)(*(void *)(v355 + 16) + 8 * (**(void **)(v355 + 16) != v355)) = v354;
                v354[1] = v355;
                goto LABEL_709;
              }
            }
            else if (!v356 || (int v358 = *((unsigned __int8 *)v356 + 24), v357 = v356 + 3, v358))
            {
              if (*v354 == v350)
              {
                uint64_t v363 = *(void *)(v350 + 8);
                uint64_t *v354 = v363;
                if (v363)
                {
                  *(void *)(v363 + 16) = v354;
                  uint64_t v355 = v354[2];
                }
                *(void *)(v350 + 16) = v355;
                *(void *)(v354[2] + 8 * (*(void *)v354[2] != (void)v354)) = v350;
                *(void *)(v350 + 8) = v354;
                v354[2] = v350;
                uint64_t v355 = *(void *)(v350 + 16);
              }
              else
              {
                uint64_t v350 = *(void *)(v350 + 16);
              }
              *(unsigned char *)(v350 + 24) = 1;
              *(unsigned char *)(v355 + 24) = 0;
              v354 = *(uint64_t **)(v355 + 8);
              uint64_t v364 = *v354;
              *(void *)(v355 + 8) = *v354;
              if (v364) {
                *(void *)(v364 + 16) = v355;
              }
              v354[2] = *(void *)(v355 + 16);
              *(void *)(*(void *)(v355 + 16) + 8 * (**(void **)(v355 + 16) != v355)) = v354;
              uint64_t *v354 = v355;
LABEL_709:
              *(void *)(v355 + 16) = v354;
              break;
            }
            *((unsigned char *)v354 + 24) = 1;
            uint64_t v350 = v355;
            *(unsigned char *)(v355 + 24) = v355 == (void)v353;
            unsigned char *v357 = 1;
          }
          while ((uint64_t *)v355 != v353);
        }
        ++*(void *)(v6 + 432);
        uint64_t v366 = *(void *)buf;
        if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v366 + 820))
        {
          *(unsigned char *)(v366 + 1214) = -1;
          md::Label::updateStateMachineForStaging(v366, 0, 37);
        }
        *(unsigned char *)(v366 + 1261) = 0;
        *(void *)(v366 + 1224) = 0;
        unint64_t v345 = *(void *)buf;
LABEL_714:
        v367 = v1030;
        v368 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
        if (v1027.__r_.__value_.__l.__size_) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
        }
        md::Label::update(v345, (uint64_t)v367, v6);
        if (!v368 || atomic_fetch_add(&v368->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
LABEL_718:
          v369 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8]) {
            goto LABEL_719;
          }
          goto LABEL_664;
        }
        ((void (*)(std::__shared_weak_count *))v368->__on_zero_shared)(v368);
        std::__shared_weak_count::__release_weak(v368);
        v369 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8])
        {
LABEL_719:
          if (!atomic_fetch_add(&v369->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v369->__on_zero_shared)(v369);
            std::__shared_weak_count::__release_weak(v369);
          }
        }
LABEL_664:
        if (++v342 == v341) {
          goto LABEL_651;
        }
      }
    }
LABEL_471:
    v265 = *(int **)&v1005[7]._type;
    p_xIdx = &v1005[7]._xIdx;
    _ZF = v265 == &v1005[7]._xIdx;
    v1006 = &v1005[7]._xIdx;
    if (!_ZF)
    {
      while (1)
      {
        *(_OWORD *)&v1027.__r_.__value_.__l.__data_ = 0uLL;
        v370 = (std::__shared_weak_count *)*((void *)v265 + 5);
        if (!v370
          || (v1027.__r_.__value_.__l.__size_ = (std::string::size_type)std::__shared_weak_count::lock(v370)) == 0
          || (v371 = (unsigned __int8 *)*((void *)v265 + 4),
              (v1027.__r_.__value_.__r.__words[0] = (std::string::size_type)v371) == 0))
        {
          ++*(_DWORD *)(v6 + 88);
          goto LABEL_733;
        }
        if (!*(void *)(*(uint64_t (**)(unsigned __int8 *, void, void, void, void))(*(void *)v371 + 552))(v371, 0, 0, 0, 0))
        {
          ++*(_DWORD *)(v6 + 92);
          goto LABEL_733;
        }
        if (v371[140] || v13 >= v371[136]) {
          break;
        }
        ++*(_DWORD *)(v6 + 96);
LABEL_733:
        v372 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
        if (v1027.__r_.__value_.__l.__size_
          && !atomic_fetch_add((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v372->__on_zero_shared)(v372);
          std::__shared_weak_count::__release_weak(v372);
          v373 = (int *)*((void *)v265 + 1);
          if (!v373)
          {
            do
            {
LABEL_739:
              v374 = (int *)*((void *)v265 + 2);
              _ZF = *(void *)v374 == (void)v265;
              v265 = v374;
            }
            while (!_ZF);
            goto LABEL_724;
          }
        }
        else
        {
          v373 = (int *)*((void *)v265 + 1);
          if (!v373) {
            goto LABEL_739;
          }
        }
        do
        {
          v374 = v373;
          v373 = *(int **)v373;
        }
        while (v373);
LABEL_724:
        v265 = v374;
        if (v374 == p_xIdx) {
          goto LABEL_473;
        }
      }
      md::LineLabelFeature::updatePositions((md::LineLabelFeature *)v371, v1030, v13, (md::LabelMapTile *)v6);
      unsigned __int8 v375 = atomic_load(v371 + 672);
      if ((v375 & 1) == 0) {
        goto LABEL_816;
      }
      {
        operator new();
      }
      uint64_t v376 = mdm::Allocator::instance(void)::alloc;
      std::mutex::lock((std::mutex *)(v371 + 608));
      v377 = (unsigned __int8 *)*((void *)v371 + 85);
      v378 = (unsigned __int8 *)*((void *)v371 + 86);
      *(_OWORD *)(v371 + 680) = 0u;
      v379 = (void *)*((void *)v371 + 87);
      *((void *)v371 + 87) = 0;
      atomic_store(0, v371 + 672);
      std::mutex::unlock((std::mutex *)(v371 + 608));
      if (v377 == v378)
      {
        if (!v377) {
          goto LABEL_816;
        }
        goto LABEL_815;
      }
      v978 = v379;
      v980 = v377;
      uint64_t v982 = v376;
      v380 = (uint64_t **)(v371 + 576);
      v381 = v377;
      while (1)
      {
        int v382 = *v381;
        if (v382 != 2)
        {
          if (v382 == 1) {
            md::TransitLineLabelFeature::addTransitLink((uint64_t *)v371, *((void *)v381 + 1));
          }
          goto LABEL_746;
        }
        v383 = (void *)*((void *)v371 + 63);
        if (v383 != *((void **)v371 + 64)) {
          break;
        }
LABEL_746:
        v381 += 32;
        if (v381 == v378)
        {
          uint64_t v6 = (uint64_t)v1017;
          int v13 = v1001;
          v377 = v980;
          uint64_t v376 = v982;
          v379 = v978;
          if (!v980)
          {
LABEL_816:
            md::LineLabelPlacer::placementsForRect((char **)buf, (uint64_t)(v371 + 192), v1015, v13);
            if (v1010) {
              operator delete(v1010);
            }
            v411 = *(unsigned int **)&buf[8];
            v1010 = *(void **)buf;
            v412 = *(unsigned int **)buf;
            if (*(void *)buf == *(void *)&buf[8])
            {
LABEL_819:
              p_xIdx = v1006;
              goto LABEL_733;
            }
            while (1)
            {
              v413 = v1030;
              v414 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
              if (v1027.__r_.__value_.__l.__size_) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
              }
              md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v413, &__p, v412, 1);
              if (v414 && !atomic_fetch_add(&v414->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v414->__on_zero_shared)(v414);
                std::__shared_weak_count::__release_weak(v414);
                unint64_t v415 = *(void *)buf;
                if (!*(void *)buf) {
                  goto LABEL_874;
                }
              }
              else
              {
                unint64_t v415 = *(void *)buf;
                if (!*(void *)buf) {
                  goto LABEL_874;
                }
              }
              v416 = (uint64_t *)v1021;
              while (1)
              {
                v417 = (uint64_t *)*v416;
                v418 = v416;
                if (!*v416) {
                  break;
                }
                while (1)
                {
                  v416 = v417;
                  unint64_t v419 = v417[4];
                  if (v415 < v419) {
                    break;
                  }
                  if (v419 >= v415) {
                    goto LABEL_870;
                  }
                  v417 = (uint64_t *)v416[1];
                  if (!v417)
                  {
                    v418 = v416 + 1;
                    goto LABEL_832;
                  }
                }
              }
LABEL_832:
              uint64_t v420 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v6 + 424) + 16))(*(void *)(v6 + 424), 48, 8);
              uint64_t v421 = *(void *)&buf[8];
              *(void *)(v420 + 32) = *(void *)buf;
              *(void *)(v420 + 40) = v421;
              if (v421) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v421 + 8), 1uLL, memory_order_relaxed);
              }
              *(void *)uint64_t v420 = 0;
              *(void *)(v420 + 8) = 0;
              *(void *)(v420 + 16) = v416;
              uint64_t *v418 = v420;
              uint64_t v422 = **(void **)(v6 + 408);
              if (v422)
              {
                *(void *)(v6 + 408) = v422;
                uint64_t v420 = *v418;
              }
              v423 = *v1021;
              _ZF = v420 == (void)*v1021;
              *(unsigned char *)(v420 + 24) = _ZF;
              if (!_ZF)
              {
                do
                {
                  v424 = *(uint64_t **)(v420 + 16);
                  if (*((unsigned char *)v424 + 24)) {
                    break;
                  }
                  uint64_t v425 = v424[2];
                  v426 = *(uint64_t **)v425;
                  if (*(uint64_t **)v425 == v424)
                  {
                    uint64_t v429 = *(void *)(v425 + 8);
                    if (!v429 || (int v430 = *(unsigned __int8 *)(v429 + 24), v427 = (unsigned char *)(v429 + 24), v430))
                    {
                      if (*v424 == v420)
                      {
                        v431 = *(uint64_t ***)(v420 + 16);
                      }
                      else
                      {
                        v431 = (uint64_t **)v424[1];
                        v432 = *v431;
                        v424[1] = (uint64_t)*v431;
                        if (v432)
                        {
                          v432[2] = (uint64_t)v424;
                          uint64_t v425 = v424[2];
                        }
                        v431[2] = (uint64_t *)v425;
                        *(void *)(v424[2] + 8 * (*(void *)v424[2] != (void)v424)) = v431;
                        *v431 = v424;
                        v424[2] = (uint64_t)v431;
                        uint64_t v425 = (uint64_t)v431[2];
                        v424 = *(uint64_t **)v425;
                      }
                      *((unsigned char *)v431 + 24) = 1;
                      *(unsigned char *)(v425 + 24) = 0;
                      uint64_t v435 = v424[1];
                      *(void *)uint64_t v425 = v435;
                      if (v435) {
                        *(void *)(v435 + 16) = v425;
                      }
                      v424[2] = *(void *)(v425 + 16);
                      *(void *)(*(void *)(v425 + 16) + 8 * (**(void **)(v425 + 16) != v425)) = v424;
                      v424[1] = v425;
                      goto LABEL_865;
                    }
                  }
                  else if (!v426 || (int v428 = *((unsigned __int8 *)v426 + 24), v427 = v426 + 3, v428))
                  {
                    if (*v424 == v420)
                    {
                      uint64_t v433 = *(void *)(v420 + 8);
                      uint64_t *v424 = v433;
                      if (v433)
                      {
                        *(void *)(v433 + 16) = v424;
                        uint64_t v425 = v424[2];
                      }
                      *(void *)(v420 + 16) = v425;
                      *(void *)(v424[2] + 8 * (*(void *)v424[2] != (void)v424)) = v420;
                      *(void *)(v420 + 8) = v424;
                      v424[2] = v420;
                      uint64_t v425 = *(void *)(v420 + 16);
                    }
                    else
                    {
                      uint64_t v420 = *(void *)(v420 + 16);
                    }
                    *(unsigned char *)(v420 + 24) = 1;
                    *(unsigned char *)(v425 + 24) = 0;
                    v424 = *(uint64_t **)(v425 + 8);
                    uint64_t v434 = *v424;
                    *(void *)(v425 + 8) = *v424;
                    if (v434) {
                      *(void *)(v434 + 16) = v425;
                    }
                    v424[2] = *(void *)(v425 + 16);
                    *(void *)(*(void *)(v425 + 16) + 8 * (**(void **)(v425 + 16) != v425)) = v424;
                    uint64_t *v424 = v425;
LABEL_865:
                    *(void *)(v425 + 16) = v424;
                    break;
                  }
                  *((unsigned char *)v424 + 24) = 1;
                  uint64_t v420 = v425;
                  *(unsigned char *)(v425 + 24) = v425 == (void)v423;
                  unsigned char *v427 = 1;
                }
                while ((uint64_t *)v425 != v423);
              }
              ++*(void *)(v6 + 432);
              uint64_t v436 = *(void *)buf;
              if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v436 + 820))
              {
                *(unsigned char *)(v436 + 1214) = -1;
                md::Label::updateStateMachineForStaging(v436, 0, 37);
              }
              *(unsigned char *)(v436 + 1261) = 0;
              *(void *)(v436 + 1224) = 0;
              unint64_t v415 = *(void *)buf;
LABEL_870:
              v437 = v1030;
              v438 = (std::__shared_weak_count *)v1027.__r_.__value_.__l.__size_;
              *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(_OWORD *)&v1027.__r_.__value_.__l.__data_;
              if (v1027.__r_.__value_.__l.__size_) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v1027.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
              }
              md::Label::update(v415, (uint64_t)v437, v6);
              if (!v438 || atomic_fetch_add(&v438->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
LABEL_874:
                v439 = *(std::__shared_weak_count **)&buf[8];
                if (*(void *)&buf[8]) {
                  goto LABEL_875;
                }
                goto LABEL_820;
              }
              ((void (*)(std::__shared_weak_count *))v438->__on_zero_shared)(v438);
              std::__shared_weak_count::__release_weak(v438);
              v439 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8])
              {
LABEL_875:
                if (!atomic_fetch_add(&v439->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v439->__on_zero_shared)(v439);
                  std::__shared_weak_count::__release_weak(v439);
                }
              }
LABEL_820:
              if (++v412 == v411) {
                goto LABEL_819;
              }
            }
          }
          do
          {
            v410 = (std::__shared_weak_count *)*((void *)v378 - 1);
            if (v410 && !atomic_fetch_add(&v410->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v410->__on_zero_shared)(v410);
              std::__shared_weak_count::__release_weak(v410);
            }
            v378 -= 32;
          }
          while (v378 != v980);
LABEL_815:
          (*(void (**)(uint64_t, unsigned __int8 *, int64_t))(*(void *)v376 + 40))(v376, v377, (unsigned char *)v379 - v377);
          goto LABEL_816;
        }
      }
      while (1)
      {
        while (1)
        {
          v384 = *(uint64_t **)(*v383 + 8);
          v385 = (std::__shared_weak_count *)v384[1];
          if (v385) {
            break;
          }
          uint64_t v387 = *((void *)v381 + 2);
LABEL_760:
          if (!v387) {
            goto LABEL_761;
          }
LABEL_753:
          if (++v383 == *((void **)v371 + 64)) {
            goto LABEL_746;
          }
        }
        v386 = std::__shared_weak_count::lock(v385);
        uint64_t v387 = *((void *)v381 + 2);
        if (!v386) {
          goto LABEL_760;
        }
        v388 = v386;
        uint64_t v389 = *v384;
        if (!atomic_fetch_add(&v386->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v386->__on_zero_shared)(v386);
          std::__shared_weak_count::__release_weak(v388);
          if (v389 == v387) {
            goto LABEL_761;
          }
          goto LABEL_753;
        }
        if (v389 != v387) {
          goto LABEL_753;
        }
LABEL_761:
        v390 = *v380;
        if (*v380)
        {
          unint64_t v391 = *(void *)(*v383 + 8);
          v392 = (uint64_t *)(v371 + 576);
          v393 = *v380;
          do
          {
            unint64_t v394 = v393[4];
            _CF = v394 >= v391;
            if (v394 >= v391) {
              v396 = (uint64_t **)v393;
            }
            else {
              v396 = (uint64_t **)(v393 + 1);
            }
            if (_CF) {
              v392 = v393;
            }
            v393 = *v396;
          }
          while (*v396);
          if (v392 != (uint64_t *)v380 && v391 >= v392[4])
          {
            v397 = (uint64_t *)v392[1];
            v398 = v392;
            if (v397)
            {
              do
              {
                v399 = v397;
                v397 = (uint64_t *)*v397;
              }
              while (v397);
            }
            else
            {
              do
              {
                v399 = (uint64_t *)v398[2];
                _ZF = *v399 == (void)v398;
                v398 = v399;
              }
              while (!_ZF);
            }
            if (*((uint64_t **)v371 + 71) == v392) {
              *((void *)v371 + 71) = v399;
            }
            --*((void *)v371 + 74);
            std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(v390, v392);
            (*(void (**)(void, uint64_t *, uint64_t))(**((void **)v371 + 73) + 40))(*((void *)v371 + 73), v392, 48);
          }
        }
        v400 = v383 + 1;
        v401 = (void *)*((void *)v371 + 64);
        v402 = v383;
        if (v383 + 1 != v401)
        {
          do
          {
            v403 = v402;
            uint64_t v404 = *v402;
            if (*v402)
            {
              _ZF = (*(void *)v404)-- == 1;
              if (_ZF)
              {
                uint64_t v405 = *(void *)(v404 + 16);
                if (v405)
                {
                  *(void *)(v404 + 24) = v405;
                  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v404 + 40) + 40))(*(void *)(v404 + 40), v405, *(void *)(v404 + 32) - v405);
                }
                {
                  operator new();
                }
                (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 40))(mdm::Allocator::instance(void)::alloc, *v402, 56);
              }
            }
            ++v402;
            void *v403 = v403[1];
            v403[1] = 0;
          }
          while (v403 + 2 != v401);
          v400 = (void *)*((void *)v371 + 64);
          if (v400 == v402) {
            goto LABEL_805;
          }
LABEL_794:
          v406 = v400;
          do
          {
            uint64_t v408 = *--v406;
            uint64_t v407 = v408;
            if (v408)
            {
              _ZF = (*(void *)v407)-- == 1;
              if (_ZF)
              {
                uint64_t v409 = *(void *)(v407 + 16);
                if (v409)
                {
                  *(void *)(v407 + 24) = v409;
                  (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v407 + 40) + 40))(*(void *)(v407 + 40), v409, *(void *)(v407 + 32) - v409);
                }
                {
                  operator new();
                }
                (*(void (**)(uint64_t, void, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                 + 40))(mdm::Allocator::instance(void)::alloc, *(v400 - 1), 56);
                *(v400 - 1) = 0;
              }
            }
            v400 = v406;
          }
          while (v406 != v402);
          goto LABEL_805;
        }
        if (v400 != v383) {
          goto LABEL_794;
        }
LABEL_805:
        *((void *)v371 + 64) = v402;
        if (v383 == v402) {
          goto LABEL_746;
        }
      }
    }
LABEL_473:
    if (v1010) {
      operator delete(v1010);
    }
    v267 = *(std::__shared_weak_count **)&v1026.f64[1];
    uint64_t v22 = v988;
    if (*(void *)&v1026.f64[1]
      && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v1026.f64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v267->__on_zero_shared)(v267);
      std::__shared_weak_count::__release_weak(v267);
    }
LABEL_28:
    v22 += 2;
  }
  while (v22 != v985);
  v1027.__r_.__value_.__r.__words[0] = v6;
  v1027.__r_.__value_.__l.__size_ = (std::string::size_type)&v1030;
  v1027.__r_.__value_.__r.__words[2] = (std::string::size_type)a3;
  uint64_t v440 = *(void *)(v6 + 328);
  if (v440)
  {
    if (*((unsigned char *)v1030 + 3029))
    {
      v442 = *(void **)(v440 + 200);
      for (uint64_t i = *(void **)(v440 + 208); v442 != i; v442 += 2)
        md::LabelMapTile::updateLabels(md::LabelManager *,md::LabelPool &,int,BOOL)::$_0::operator()((uint64_t)&v1027, v442);
    }
    else if (*((unsigned char *)v1030 + 3030))
    {
      v697 = *(void **)(v440 + 200);
      v696 = *(void **)(v440 + 208);
      while (v697 != v696)
      {
        if (*(unsigned char *)(*v697 + 353)) {
          md::LabelMapTile::updateLabels(md::LabelManager *,md::LabelPool &,int,BOOL)::$_0::operator()((uint64_t)&v1027, v697);
        }
        v697 += 2;
      }
    }
  }
  if ((*(uint64_t (**)(void))(**(void **)(*((void *)v1030 + 21) + 48) + 24))(*(void *)(*((void *)v1030 + 21) + 48)))
  {
    uint64_t v443 = (*(uint64_t (**)(void))(**(void **)(*((void *)v1030 + 21) + 48) + 24))(*(void *)(*((void *)v1030 + 21) + 48));
    v445 = *(void **)v443;
    v444 = *(void **)(v443 + 8);
    if (*(void **)v443 != v444)
    {
      do
      {
        md::LabelMapTile::updateLabels(md::LabelManager *,md::LabelPool &,int,BOOL)::$_0::operator()((uint64_t)&v1027, v445);
        v445 += 2;
      }
      while (v445 != v444);
    }
  }
  v446 = v1030;
  uint64_t v447 = (*(uint64_t (**)(void))(**(void **)(*((void *)v1030 + 21) + 40) + 16))(*(void *)(*((void *)v1030 + 21) + 40));
  if (v447)
  {
    v448 = *(md::PointLabelFeature ***)v447;
    v449 = *(md::PointLabelFeature ***)(v447 + 8);
    if (*(md::PointLabelFeature ***)v447 != v449)
    {
      __asm { FMOV            V0.2D, #0.5 }
      float64x2_t v986 = _Q0;
      float64x2_t v989 = (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL);
      while (!*(void *)(*(uint64_t (**)(md::PointLabelFeature *, void, void, void, void))(*(void *)*v448 + 552))(*v448, 0, 0, 0, 0))
      {
        ++*((_DWORD *)v1017 + 23);
LABEL_894:
        v448 += 2;
        if (v448 == v449) {
          goto LABEL_945;
        }
      }
      v451 = *v448;
      if (!*((void *)*v448 + 9))
      {
        *((void *)v451 + 9) = atomic_fetch_add((atomic_ullong *volatile)(*((void *)v446 + 36) + 680), 1uLL) + 1;
        v451 = *v448;
      }
      md::PointLabelFeature::updatePositions(v451);
      v452 = (unsigned int *)*((void *)*v448 + 57);
      uint64_t v453 = (uint64_t)*v448 + 464;
      if (v452 == (unsigned int *)v453) {
        goto LABEL_894;
      }
      while (1)
      {
        uint64_t v454 = (*(uint64_t (**)(md::PointLabelFeature *, void *))(*(void *)*v448 + 112))(*v448, (void *)v452 + 4);
        uint64_t v455 = v454;
        if (*(unsigned char *)(v454 + 45)) {
          BOOL v456 = 1;
        }
        else {
          BOOL v456 = *(unsigned char *)(v454 + 46) == 0;
        }
        if (v456)
        {
          v467.f64[0] = *(float64_t *)(v454 + 24);
        }
        else
        {
          long double v457 = *(double *)v454;
          long double v458 = *(double *)(v454 + 8);
          long double v459 = *(double *)(v454 + 16);
          double v460 = sqrt(v457 * v457 + v458 * v458);
          double v461 = atan2(v459, v460 * 0.996647189);
          long double v1011 = atan2(v458, v457);
          __double2 v462 = __sincos_stret(v461);
          long double v463 = atan2(v459 + v462.__sinval * v462.__sinval * 42841.3115 * v462.__sinval, v460 + v462.__cosval * v462.__cosval * -42697.6727 * v462.__cosval);
          long double v464 = tan(v463 * 0.5 + 0.785398163);
          long double v465 = log(v464);
          v466.f64[0] = v1011;
          v466.f64[1] = v465;
          float64x2_t v467 = vmlaq_f64(v986, v989, v466);
          *(float64x2_t *)(v455 + 24) = v467;
          *(unsigned char *)(v455 + 45) = 1;
        }
        if (v467.f64[0] < *v1015
          || v467.f64[0] > *((double *)v1017 + 7)
          || (double v468 = *(double *)(v455 + 32), v468 < *((double *)v1017 + 6))
          || v468 > *((double *)v1017 + 8))
        {
LABEL_938:
          v482 = (unsigned int *)*((void *)v452 + 1);
          if (!v482) {
            goto LABEL_942;
          }
          goto LABEL_939;
        }
        v469 = (std::__shared_weak_count *)v448[1];
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)*v448;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v469;
        if (v469) {
          atomic_fetch_add_explicit(&v469->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v446, &__p, v452 + 8, 1);
        if (v469 && !atomic_fetch_add(&v469->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v469->__on_zero_shared)(v469);
          std::__shared_weak_count::__release_weak(v469);
          unint64_t v470 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_936;
          }
        }
        else
        {
          unint64_t v470 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_936;
          }
        }
        v471 = v1021;
        while (1)
        {
          v472 = *v471;
          v473 = v471;
          if (!*v471) {
            break;
          }
          while (1)
          {
            v471 = (uint64_t **)v472;
            unint64_t v474 = v472[4];
            if (v470 < v474) {
              break;
            }
            if (v474 >= v470) {
              goto LABEL_930;
            }
            v472 = v471[1];
            if (!v472)
            {
              v473 = v471 + 1;
              goto LABEL_922;
            }
          }
        }
LABEL_922:
        v475 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1017 + 53) + 16))(*((void *)v1017 + 53), 48, 8);
        v476 = v475;
        uint64_t v477 = *(void *)&buf[8];
        v475[4] = *(void *)buf;
        v475[5] = v477;
        if (v477) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v477 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t *v475 = 0;
        v475[1] = 0;
        v475[2] = (uint64_t)v471;
        *v473 = v475;
        uint64_t v478 = **((void **)v1017 + 51);
        if (v478)
        {
          *((void *)v1017 + 51) = v478;
          v476 = *v473;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v1017 + 52), v476);
        ++*((void *)v1017 + 54);
        uint64_t v479 = *(void *)buf;
        if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v479 + 820))
        {
          *(unsigned char *)(v479 + 1214) = -1;
          md::Label::updateStateMachineForStaging(v479, 0, 37);
        }
        *(unsigned char *)(v479 + 1261) = 0;
        *(void *)(v479 + 1224) = 0;
        unint64_t v470 = *(void *)buf;
LABEL_930:
        v480 = (std::__shared_weak_count *)v448[1];
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)*v448;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v480;
        if (v480) {
          atomic_fetch_add_explicit(&v480->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        md::Label::update(v470, (uint64_t)v446, (uint64_t)v1017);
        if (v480 && !atomic_fetch_add(&v480->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v480->__on_zero_shared)(v480);
          std::__shared_weak_count::__release_weak(v480);
        }
LABEL_936:
        v481 = *(std::__shared_weak_count **)&buf[8];
        if (!*(void *)&buf[8]
          || atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          goto LABEL_938;
        }
        ((void (*)(std::__shared_weak_count *))v481->__on_zero_shared)(v481);
        std::__shared_weak_count::__release_weak(v481);
        v482 = (unsigned int *)*((void *)v452 + 1);
        if (!v482)
        {
          do
          {
LABEL_942:
            v483 = (unsigned int *)*((void *)v452 + 2);
            _ZF = *(void *)v483 == (void)v452;
            v452 = v483;
          }
          while (!_ZF);
          goto LABEL_900;
        }
        do
        {
LABEL_939:
          v483 = v482;
          v482 = *(unsigned int **)v482;
        }
        while (v482);
LABEL_900:
        v452 = v483;
        if (v483 == (unsigned int *)v453) {
          goto LABEL_894;
        }
      }
    }
  }
LABEL_945:
  uint64_t v484 = (*(uint64_t (**)(void))(**(void **)(*((void *)v446 + 21) + 40) + 24))(*(void *)(*((void *)v446 + 21) + 40));
  uint64_t v485 = (uint64_t)v1017;
  uint64_t v1012 = (uint64_t)v446;
  if (v484)
  {
    v487 = *(void **)v484;
    v486 = *(void **)(v484 + 8);
    if (*(void **)v484 != v486)
    {
      v1007 = 0;
      v488 = 0;
      v990 = *(void **)(v484 + 8);
      while (1)
      {
        if (!*(void *)(*(uint64_t (**)(void, void, void, void, void))(*(void *)*v487 + 552))(*v487, 0, 0, 0, 0))
        {
          ++*(_DWORD *)(v485 + 92);
          goto LABEL_949;
        }
        v489 = (void *)*v487;
        if (!*(void *)(*v487 + 72))
        {
          v489[9] = atomic_fetch_add((atomic_ullong *volatile)(*((void *)v446 + 36) + 680), 1uLL) + 1;
          v489 = (void *)*v487;
        }
        v490 = (void *)v489[41];
        v491 = v489 + 42;
        if (v490 == v489 + 42)
        {
          v446 = (md::LabelManager *)v1012;
          goto LABEL_949;
        }
        v492 = v1007;
        do
        {
          v493 = (double *)md::LabelPoint::mercatorPoint((md::LabelPoint *)(v490[5] + 48));
          if (*v493 < *(double *)(v485 + 40) || *v493 > *(double *)(v485 + 56)) {
            goto LABEL_968;
          }
          double v495 = v493[1];
          if (v495 < *(double *)(v485 + 48) || v495 > *(double *)(v485 + 64)) {
            goto LABEL_968;
          }
          if (v492 < v488)
          {
            *(_DWORD *)v492 = *((_DWORD *)v490 + 8);
            v492 += 4;
LABEL_968:
            v497 = (void *)v490[1];
            if (v497) {
              goto LABEL_969;
            }
            goto LABEL_989;
          }
          uint64_t v499 = (v492 - v1007) >> 2;
          unint64_t v500 = v499 + 1;
          if ((unint64_t)(v499 + 1) >> 62) {
            abort();
          }
          if ((v488 - v1007) >> 1 > v500) {
            unint64_t v500 = (v488 - v1007) >> 1;
          }
          if ((unint64_t)(v488 - v1007) >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v501 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v501 = v500;
          }
          if (v501)
          {
            if (v501 >> 62) {
              goto LABEL_1799;
            }
            v502 = operator new(4 * v501);
          }
          else
          {
            v502 = 0;
          }
          v503 = &v502[4 * v499];
          *(_DWORD *)v503 = *((_DWORD *)v490 + 8);
          v504 = v503 + 4;
          if (v492 != v1007)
          {
            unint64_t v505 = v492 - 4 - v1007;
            if (v505 < 0x2C || (unint64_t)(v1007 - v502) < 0x20)
            {
              v506 = v492;
              goto LABEL_985;
            }
            uint64_t v508 = (v505 >> 2) + 1;
            v506 = &v492[-4 * (v508 & 0x7FFFFFFFFFFFFFF8)];
            v509 = &v502[4 * v499 - 16];
            v510 = v492 - 16;
            uint64_t v511 = v508 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v512 = *(_OWORD *)v510;
              *(v509 - 1) = *((_OWORD *)v510 - 1);
              _OWORD *v509 = v512;
              v509 -= 2;
              v510 -= 32;
              v511 -= 8;
            }
            while (v511);
            v503 -= 4 * (v508 & 0x7FFFFFFFFFFFFFF8);
            if (v508 != (v508 & 0x7FFFFFFFFFFFFFF8))
            {
              do
              {
LABEL_985:
                int v507 = *((_DWORD *)v506 - 1);
                v506 -= 4;
                *((_DWORD *)v503 - 1) = v507;
                v503 -= 4;
              }
              while (v506 != v1007);
            }
            v488 = &v502[4 * v501];
            if (!v1007) {
              goto LABEL_988;
            }
LABEL_987:
            operator delete(v1007);
            goto LABEL_988;
          }
          v488 = &v502[4 * v501];
          if (v1007) {
            goto LABEL_987;
          }
LABEL_988:
          v1007 = v503;
          v492 = v504;
          uint64_t v485 = (uint64_t)v1017;
          v497 = (void *)v490[1];
          if (v497)
          {
            do
            {
LABEL_969:
              v498 = v497;
              v497 = (void *)*v497;
            }
            while (v497);
            goto LABEL_955;
          }
          do
          {
LABEL_989:
            v498 = (void *)v490[2];
            _ZF = *v498 == (void)v490;
            v490 = v498;
          }
          while (!_ZF);
LABEL_955:
          v490 = v498;
        }
        while (v498 != v491);
        v513 = v488;
        v514 = (unsigned int *)v1007;
        if (v1007 != v492)
        {
          v446 = (md::LabelManager *)v1012;
          while (1)
          {
            v515 = (std::__shared_weak_count *)v487[1];
            __p.__r_.__value_.__r.__words[0] = *v487;
            __p.__r_.__value_.__l.__size_ = (std::string::size_type)v515;
            if (v515) {
              atomic_fetch_add_explicit(&v515->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, v1012, &__p, v514, 1);
            if (v515 && !atomic_fetch_add(&v515->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v515->__on_zero_shared)(v515);
              std::__shared_weak_count::__release_weak(v515);
              unint64_t v516 = *(void *)buf;
              if (!*(void *)buf) {
                goto LABEL_1054;
              }
            }
            else
            {
              unint64_t v516 = *(void *)buf;
              if (!*(void *)buf) {
                goto LABEL_1054;
              }
            }
            v517 = (uint64_t *)v1021;
            while (1)
            {
              v518 = (uint64_t *)*v517;
              v519 = v517;
              if (!*v517) {
                break;
              }
              while (1)
              {
                v517 = v518;
                unint64_t v520 = v518[4];
                if (v516 < v520) {
                  break;
                }
                if (v520 >= v516) {
                  goto LABEL_1050;
                }
                v518 = (uint64_t *)v517[1];
                if (!v518)
                {
                  v519 = v517 + 1;
                  goto LABEL_1012;
                }
              }
            }
LABEL_1012:
            uint64_t v521 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v485 + 424) + 16))(*(void *)(v485 + 424), 48, 8);
            uint64_t v522 = *(void *)&buf[8];
            *(void *)(v521 + 32) = *(void *)buf;
            *(void *)(v521 + 40) = v522;
            if (v522) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v522 + 8), 1uLL, memory_order_relaxed);
            }
            *(void *)uint64_t v521 = 0;
            *(void *)(v521 + 8) = 0;
            *(void *)(v521 + 16) = v517;
            uint64_t *v519 = v521;
            uint64_t v523 = **(void **)(v485 + 408);
            if (v523)
            {
              *(void *)(v485 + 408) = v523;
              uint64_t v521 = *v519;
            }
            v524 = *v1021;
            _ZF = v521 == (void)*v1021;
            *(unsigned char *)(v521 + 24) = _ZF;
            if (!_ZF)
            {
              do
              {
                v525 = *(uint64_t **)(v521 + 16);
                if (*((unsigned char *)v525 + 24)) {
                  break;
                }
                uint64_t v526 = v525[2];
                v527 = *(uint64_t **)v526;
                if (*(uint64_t **)v526 == v525)
                {
                  uint64_t v530 = *(void *)(v526 + 8);
                  if (!v530 || (int v531 = *(unsigned __int8 *)(v530 + 24), v528 = (unsigned char *)(v530 + 24), v531))
                  {
                    if (*v525 == v521)
                    {
                      v532 = *(uint64_t ***)(v521 + 16);
                    }
                    else
                    {
                      v532 = (uint64_t **)v525[1];
                      v533 = *v532;
                      v525[1] = (uint64_t)*v532;
                      if (v533)
                      {
                        v533[2] = (uint64_t)v525;
                        uint64_t v526 = v525[2];
                      }
                      v532[2] = (uint64_t *)v526;
                      *(void *)(v525[2] + 8 * (*(void *)v525[2] != (void)v525)) = v532;
                      *v532 = v525;
                      v525[2] = (uint64_t)v532;
                      uint64_t v526 = (uint64_t)v532[2];
                      v525 = *(uint64_t **)v526;
                    }
                    *((unsigned char *)v532 + 24) = 1;
                    *(unsigned char *)(v526 + 24) = 0;
                    uint64_t v536 = v525[1];
                    *(void *)uint64_t v526 = v536;
                    if (v536) {
                      *(void *)(v536 + 16) = v526;
                    }
                    v525[2] = *(void *)(v526 + 16);
                    *(void *)(*(void *)(v526 + 16) + 8 * (**(void **)(v526 + 16) != v526)) = v525;
                    v525[1] = v526;
                    goto LABEL_1045;
                  }
                }
                else if (!v527 || (int v529 = *((unsigned __int8 *)v527 + 24), v528 = v527 + 3, v529))
                {
                  if (*v525 == v521)
                  {
                    uint64_t v534 = *(void *)(v521 + 8);
                    uint64_t *v525 = v534;
                    if (v534)
                    {
                      *(void *)(v534 + 16) = v525;
                      uint64_t v526 = v525[2];
                    }
                    *(void *)(v521 + 16) = v526;
                    *(void *)(v525[2] + 8 * (*(void *)v525[2] != (void)v525)) = v521;
                    *(void *)(v521 + 8) = v525;
                    v525[2] = v521;
                    uint64_t v526 = *(void *)(v521 + 16);
                  }
                  else
                  {
                    uint64_t v521 = *(void *)(v521 + 16);
                  }
                  *(unsigned char *)(v521 + 24) = 1;
                  *(unsigned char *)(v526 + 24) = 0;
                  v525 = *(uint64_t **)(v526 + 8);
                  uint64_t v535 = *v525;
                  *(void *)(v526 + 8) = *v525;
                  if (v535) {
                    *(void *)(v535 + 16) = v526;
                  }
                  v525[2] = *(void *)(v526 + 16);
                  *(void *)(*(void *)(v526 + 16) + 8 * (**(void **)(v526 + 16) != v526)) = v525;
                  uint64_t *v525 = v526;
LABEL_1045:
                  *(void *)(v526 + 16) = v525;
                  break;
                }
                *((unsigned char *)v525 + 24) = 1;
                uint64_t v521 = v526;
                *(unsigned char *)(v526 + 24) = v526 == (void)v524;
                unsigned char *v528 = 1;
              }
              while ((uint64_t *)v526 != v524);
            }
            ++*(void *)(v485 + 432);
            uint64_t v537 = *(void *)buf;
            if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v537 + 820))
            {
              *(unsigned char *)(v537 + 1214) = -1;
              md::Label::updateStateMachineForStaging(v537, 0, 37);
            }
            *(unsigned char *)(v537 + 1261) = 0;
            *(void *)(v537 + 1224) = 0;
            unint64_t v516 = *(void *)buf;
LABEL_1050:
            v538 = (std::__shared_weak_count *)v487[1];
            __p.__r_.__value_.__r.__words[0] = *v487;
            __p.__r_.__value_.__l.__size_ = (std::string::size_type)v538;
            if (v538) {
              atomic_fetch_add_explicit(&v538->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            md::Label::update(v516, v1012, v485);
            if (!v538 || atomic_fetch_add(&v538->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
LABEL_1054:
              v539 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8]) {
                goto LABEL_1055;
              }
              goto LABEL_1000;
            }
            ((void (*)(std::__shared_weak_count *))v538->__on_zero_shared)(v538);
            std::__shared_weak_count::__release_weak(v538);
            v539 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)&buf[8])
            {
LABEL_1055:
              if (!atomic_fetch_add(&v539->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v539->__on_zero_shared)(v539);
                std::__shared_weak_count::__release_weak(v539);
              }
            }
LABEL_1000:
            if (++v514 == (unsigned int *)v492) {
              goto LABEL_1061;
            }
          }
        }
        v446 = (md::LabelManager *)v1012;
LABEL_1061:
        v488 = v513;
        v486 = v990;
LABEL_949:
        v487 += 2;
        if (v487 == v486) {
          goto LABEL_1063;
        }
      }
    }
  }
  v1007 = 0;
  v488 = 0;
LABEL_1063:
  uint64_t v540 = (*(uint64_t (**)(void))(**(void **)(*((void *)v446 + 21) + 40) + 32))(*(void *)(*((void *)v446 + 21) + 40));
  if (v540)
  {
    v542 = *(void **)v540;
    v541 = *(void **)(v540 + 8);
    if (*(void **)v540 != v541)
    {
      v991 = *(void **)(v540 + 8);
      do
      {
        if (!*(void *)(*(uint64_t (**)(void, void, void, void, void))(*(void *)*v542 + 552))(*v542, 0, 0, 0, 0))
        {
          ++*(_DWORD *)(v485 + 92);
          goto LABEL_1067;
        }
        v543 = (void *)*v542;
        if (!*(void *)(*v542 + 72))
        {
          v543[9] = atomic_fetch_add((atomic_ullong *volatile)(*((void *)v446 + 36) + 680), 1uLL) + 1;
          v543 = (void *)*v542;
        }
        v544 = (_DWORD *)v543[33];
        v545 = (_DWORD *)v543[34];
        if (v544 == v545)
        {
          v446 = (md::LabelManager *)v1012;
          goto LABEL_1067;
        }
        v546 = v1007;
        do
        {
          v547 = (double *)md::LabelPoint::mercatorPoint((md::LabelPoint *)(v544 + 2));
          if (*v547 < *(double *)(v485 + 40) || *v547 > *(double *)(v485 + 56)) {
            goto LABEL_1074;
          }
          double v549 = v547[1];
          if (v549 < *(double *)(v485 + 48) || v549 > *(double *)(v485 + 64)) {
            goto LABEL_1074;
          }
          if (v546 < v488)
          {
            *(_DWORD *)v546 = *v544;
            v546 += 4;
            goto LABEL_1074;
          }
          uint64_t v551 = (v546 - v1007) >> 2;
          unint64_t v552 = v551 + 1;
          if ((unint64_t)(v551 + 1) >> 62) {
            abort();
          }
          if ((v488 - v1007) >> 1 > v552) {
            unint64_t v552 = (v488 - v1007) >> 1;
          }
          if ((unint64_t)(v488 - v1007) >= 0x7FFFFFFFFFFFFFFCLL) {
            unint64_t v553 = 0x3FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v553 = v552;
          }
          if (v553)
          {
            if (v553 >> 62) {
              goto LABEL_1799;
            }
            v554 = operator new(4 * v553);
          }
          else
          {
            v554 = 0;
          }
          v555 = &v554[4 * v551];
          *(_DWORD *)v555 = *v544;
          v556 = v555 + 4;
          v557 = v1007;
          if (v546 != v1007)
          {
            unint64_t v558 = v546 - 4 - v1007;
            if (v558 >= 0x2C && (unint64_t)(v1007 - v554) >= 0x20)
            {
              uint64_t v561 = (v558 >> 2) + 1;
              v559 = &v546[-4 * (v561 & 0x7FFFFFFFFFFFFFF8)];
              v562 = &v554[4 * v551 - 16];
              v563 = v546 - 16;
              uint64_t v564 = v561 & 0x7FFFFFFFFFFFFFF8;
              v557 = v1007;
              do
              {
                long long v565 = *(_OWORD *)v563;
                *(v562 - 1) = *((_OWORD *)v563 - 1);
                _OWORD *v562 = v565;
                v562 -= 2;
                v563 -= 32;
                v564 -= 8;
              }
              while (v564);
              v555 -= 4 * (v561 & 0x7FFFFFFFFFFFFFF8);
              if (v561 == (v561 & 0x7FFFFFFFFFFFFFF8)) {
                goto LABEL_1101;
              }
            }
            else
            {
              v559 = v546;
              v557 = v1007;
            }
            do
            {
              int v560 = *((_DWORD *)v559 - 1);
              v559 -= 4;
              *((_DWORD *)v555 - 1) = v560;
              v555 -= 4;
            }
            while (v559 != v557);
          }
LABEL_1101:
          v488 = &v554[4 * v553];
          if (v557) {
            operator delete(v557);
          }
          v1007 = v555;
          v546 = v556;
          uint64_t v485 = (uint64_t)v1017;
LABEL_1074:
          v544 += 40;
        }
        while (v544 != v545);
        v566 = v488;
        v567 = (unsigned int *)v1007;
        if (v1007 != v546)
        {
          v446 = (md::LabelManager *)v1012;
          while (1)
          {
            v568 = (std::__shared_weak_count *)v542[1];
            __p.__r_.__value_.__r.__words[0] = *v542;
            __p.__r_.__value_.__l.__size_ = (std::string::size_type)v568;
            if (v568) {
              atomic_fetch_add_explicit(&v568->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, v1012, &__p, v567, 1);
            if (v568 && !atomic_fetch_add(&v568->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v568->__on_zero_shared)(v568);
              std::__shared_weak_count::__release_weak(v568);
              unint64_t v569 = *(void *)buf;
              if (!*(void *)buf) {
                goto LABEL_1164;
              }
            }
            else
            {
              unint64_t v569 = *(void *)buf;
              if (!*(void *)buf) {
                goto LABEL_1164;
              }
            }
            v570 = (uint64_t *)v1021;
            while (1)
            {
              v571 = (uint64_t *)*v570;
              v572 = v570;
              if (!*v570) {
                break;
              }
              while (1)
              {
                v570 = v571;
                unint64_t v573 = v571[4];
                if (v569 < v573) {
                  break;
                }
                if (v573 >= v569) {
                  goto LABEL_1160;
                }
                v571 = (uint64_t *)v570[1];
                if (!v571)
                {
                  v572 = v570 + 1;
                  goto LABEL_1122;
                }
              }
            }
LABEL_1122:
            uint64_t v574 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v485 + 424) + 16))(*(void *)(v485 + 424), 48, 8);
            uint64_t v575 = *(void *)&buf[8];
            *(void *)(v574 + 32) = *(void *)buf;
            *(void *)(v574 + 40) = v575;
            if (v575) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v575 + 8), 1uLL, memory_order_relaxed);
            }
            *(void *)uint64_t v574 = 0;
            *(void *)(v574 + 8) = 0;
            *(void *)(v574 + 16) = v570;
            uint64_t *v572 = v574;
            uint64_t v576 = **(void **)(v485 + 408);
            if (v576)
            {
              *(void *)(v485 + 408) = v576;
              uint64_t v574 = *v572;
            }
            v577 = *v1021;
            _ZF = v574 == (void)*v1021;
            *(unsigned char *)(v574 + 24) = _ZF;
            if (!_ZF)
            {
              do
              {
                v578 = *(uint64_t **)(v574 + 16);
                if (*((unsigned char *)v578 + 24)) {
                  break;
                }
                uint64_t v579 = v578[2];
                v580 = *(uint64_t **)v579;
                if (*(uint64_t **)v579 == v578)
                {
                  uint64_t v583 = *(void *)(v579 + 8);
                  if (!v583 || (int v584 = *(unsigned __int8 *)(v583 + 24), v581 = (unsigned char *)(v583 + 24), v584))
                  {
                    if (*v578 == v574)
                    {
                      v585 = *(uint64_t ***)(v574 + 16);
                    }
                    else
                    {
                      v585 = (uint64_t **)v578[1];
                      v586 = *v585;
                      v578[1] = (uint64_t)*v585;
                      if (v586)
                      {
                        v586[2] = (uint64_t)v578;
                        uint64_t v579 = v578[2];
                      }
                      v585[2] = (uint64_t *)v579;
                      *(void *)(v578[2] + 8 * (*(void *)v578[2] != (void)v578)) = v585;
                      *v585 = v578;
                      v578[2] = (uint64_t)v585;
                      uint64_t v579 = (uint64_t)v585[2];
                      v578 = *(uint64_t **)v579;
                    }
                    *((unsigned char *)v585 + 24) = 1;
                    *(unsigned char *)(v579 + 24) = 0;
                    uint64_t v589 = v578[1];
                    *(void *)uint64_t v579 = v589;
                    if (v589) {
                      *(void *)(v589 + 16) = v579;
                    }
                    v578[2] = *(void *)(v579 + 16);
                    *(void *)(*(void *)(v579 + 16) + 8 * (**(void **)(v579 + 16) != v579)) = v578;
                    v578[1] = v579;
                    goto LABEL_1155;
                  }
                }
                else if (!v580 || (int v582 = *((unsigned __int8 *)v580 + 24), v581 = v580 + 3, v582))
                {
                  if (*v578 == v574)
                  {
                    uint64_t v587 = *(void *)(v574 + 8);
                    uint64_t *v578 = v587;
                    if (v587)
                    {
                      *(void *)(v587 + 16) = v578;
                      uint64_t v579 = v578[2];
                    }
                    *(void *)(v574 + 16) = v579;
                    *(void *)(v578[2] + 8 * (*(void *)v578[2] != (void)v578)) = v574;
                    *(void *)(v574 + 8) = v578;
                    v578[2] = v574;
                    uint64_t v579 = *(void *)(v574 + 16);
                  }
                  else
                  {
                    uint64_t v574 = *(void *)(v574 + 16);
                  }
                  *(unsigned char *)(v574 + 24) = 1;
                  *(unsigned char *)(v579 + 24) = 0;
                  v578 = *(uint64_t **)(v579 + 8);
                  uint64_t v588 = *v578;
                  *(void *)(v579 + 8) = *v578;
                  if (v588) {
                    *(void *)(v588 + 16) = v579;
                  }
                  v578[2] = *(void *)(v579 + 16);
                  *(void *)(*(void *)(v579 + 16) + 8 * (**(void **)(v579 + 16) != v579)) = v578;
                  uint64_t *v578 = v579;
LABEL_1155:
                  *(void *)(v579 + 16) = v578;
                  break;
                }
                *((unsigned char *)v578 + 24) = 1;
                uint64_t v574 = v579;
                *(unsigned char *)(v579 + 24) = v579 == (void)v577;
                unsigned char *v581 = 1;
              }
              while ((uint64_t *)v579 != v577);
            }
            ++*(void *)(v485 + 432);
            uint64_t v590 = *(void *)buf;
            if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v590 + 820))
            {
              *(unsigned char *)(v590 + 1214) = -1;
              md::Label::updateStateMachineForStaging(v590, 0, 37);
            }
            *(unsigned char *)(v590 + 1261) = 0;
            *(void *)(v590 + 1224) = 0;
            unint64_t v569 = *(void *)buf;
LABEL_1160:
            v591 = (std::__shared_weak_count *)v542[1];
            __p.__r_.__value_.__r.__words[0] = *v542;
            __p.__r_.__value_.__l.__size_ = (std::string::size_type)v591;
            if (v591) {
              atomic_fetch_add_explicit(&v591->__shared_owners_, 1uLL, memory_order_relaxed);
            }
            md::Label::update(v569, v1012, v485);
            if (!v591 || atomic_fetch_add(&v591->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
LABEL_1164:
              v592 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8]) {
                goto LABEL_1165;
              }
              goto LABEL_1110;
            }
            ((void (*)(std::__shared_weak_count *))v591->__on_zero_shared)(v591);
            std::__shared_weak_count::__release_weak(v591);
            v592 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)&buf[8])
            {
LABEL_1165:
              if (!atomic_fetch_add(&v592->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v592->__on_zero_shared)(v592);
                std::__shared_weak_count::__release_weak(v592);
              }
            }
LABEL_1110:
            if (++v567 == (unsigned int *)v546) {
              goto LABEL_1171;
            }
          }
        }
        v446 = (md::LabelManager *)v1012;
LABEL_1171:
        v488 = v566;
        v541 = v991;
LABEL_1067:
        v542 += 2;
      }
      while (v542 != v541);
    }
  }
  uint64_t v593 = (*(uint64_t (**)(void))(**(void **)(*((void *)v446 + 21) + 40) + 40))(*(void *)(*((void *)v446 + 21) + 40));
  v594 = a3;
  if (v593)
  {
    v596 = *(md::PointLabelFeature ***)v593;
    v595 = *(md::PointLabelFeature ***)(v593 + 8);
    if (*(md::PointLabelFeature ***)v593 != v595)
    {
      __asm { FMOV            V0.2D, #0.5 }
      *(_OWORD *)v983 = _Q0;
      float64x2_t v987 = (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL);
      while (!*(void *)(*(uint64_t (**)(md::PointLabelFeature *, void, void, void, void))(*(void *)*v596 + 552))(*v596, 0, 0, 0, 0))
      {
        ++*((_DWORD *)v1017 + 23);
LABEL_1176:
        v596 += 2;
        v594 = a3;
        if (v596 == v595) {
          goto LABEL_1227;
        }
      }
      v598 = *v596;
      if (!*((void *)*v596 + 9))
      {
        *((void *)v598 + 9) = atomic_fetch_add((atomic_ullong *volatile)(*((void *)v446 + 36) + 680), 1uLL) + 1;
        v598 = *v596;
      }
      md::PointLabelFeature::updatePositions(v598);
      v599 = (unsigned int *)*((void *)*v596 + 57);
      uint64_t v600 = (uint64_t)*v596 + 464;
      if (v599 == (unsigned int *)v600) {
        goto LABEL_1176;
      }
      while (1)
      {
        uint64_t v601 = (*(uint64_t (**)(md::PointLabelFeature *, void *))(*(void *)*v596 + 112))(*v596, (void *)v599 + 4);
        uint64_t v602 = v601;
        if (*(unsigned char *)(v601 + 45)) {
          BOOL v603 = 1;
        }
        else {
          BOOL v603 = *(unsigned char *)(v601 + 46) == 0;
        }
        if (v603)
        {
          v614.f64[0] = *(float64_t *)(v601 + 24);
        }
        else
        {
          long double v604 = *(double *)v601;
          long double v605 = *(double *)(v601 + 8);
          long double v606 = *(double *)(v601 + 16);
          double v607 = sqrt(v604 * v604 + v605 * v605);
          double v608 = atan2(v606, v607 * 0.996647189);
          long double v1013 = atan2(v605, v604);
          __double2 v609 = __sincos_stret(v608);
          long double v610 = atan2(v606 + v609.__sinval * v609.__sinval * 42841.3115 * v609.__sinval, v607 + v609.__cosval * v609.__cosval * -42697.6727 * v609.__cosval);
          long double v611 = tan(v610 * 0.5 + 0.785398163);
          long double v612 = log(v611);
          v613.f64[0] = v1013;
          v613.f64[1] = v612;
          float64x2_t v614 = vmlaq_f64(*(float64x2_t *)v983, v987, v613);
          *(float64x2_t *)(v602 + 24) = v614;
          *(unsigned char *)(v602 + 45) = 1;
        }
        if (v614.f64[0] < *v1015
          || v614.f64[0] > *((double *)v1017 + 7)
          || (double v615 = *(double *)(v602 + 32), v615 < *((double *)v1017 + 6))
          || v615 > *((double *)v1017 + 8))
        {
LABEL_1220:
          v630 = (unsigned int *)*((void *)v599 + 1);
          if (!v630) {
            goto LABEL_1224;
          }
          goto LABEL_1221;
        }
        v616 = (std::__shared_weak_count *)v596[1];
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)*v596;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v616;
        if (v616) {
          atomic_fetch_add_explicit(&v616->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v446, &__p, v599 + 8, 1);
        if (v616 && !atomic_fetch_add(&v616->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v616->__on_zero_shared)(v616);
          std::__shared_weak_count::__release_weak(v616);
          unint64_t v617 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_1218;
          }
        }
        else
        {
          unint64_t v617 = *(void *)buf;
          if (!*(void *)buf) {
            goto LABEL_1218;
          }
        }
        v618 = v595;
        v619 = v1021;
        while (1)
        {
          v620 = *v619;
          v621 = v619;
          if (!*v619) {
            break;
          }
          while (1)
          {
            v619 = (uint64_t **)v620;
            unint64_t v622 = v620[4];
            if (v617 < v622) {
              break;
            }
            if (v622 >= v617) {
              goto LABEL_1212;
            }
            v620 = v619[1];
            if (!v620)
            {
              v621 = v619 + 1;
              goto LABEL_1204;
            }
          }
        }
LABEL_1204:
        v623 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1017 + 53) + 16))(*((void *)v1017 + 53), 48, 8);
        v624 = v623;
        uint64_t v625 = *(void *)&buf[8];
        v623[4] = *(void *)buf;
        v623[5] = v625;
        if (v625) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v625 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t *v623 = 0;
        v623[1] = 0;
        v623[2] = (uint64_t)v619;
        *v621 = v623;
        uint64_t v626 = **((void **)v1017 + 51);
        if (v626)
        {
          *((void *)v1017 + 51) = v626;
          v624 = *v621;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v1017 + 52), v624);
        ++*((void *)v1017 + 54);
        uint64_t v627 = *(void *)buf;
        if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v627 + 820))
        {
          *(unsigned char *)(v627 + 1214) = -1;
          md::Label::updateStateMachineForStaging(v627, 0, 37);
        }
        *(unsigned char *)(v627 + 1261) = 0;
        *(void *)(v627 + 1224) = 0;
        unint64_t v617 = *(void *)buf;
LABEL_1212:
        v628 = (std::__shared_weak_count *)v596[1];
        __p.__r_.__value_.__r.__words[0] = (std::string::size_type)*v596;
        __p.__r_.__value_.__l.__size_ = (std::string::size_type)v628;
        v595 = v618;
        if (v628) {
          atomic_fetch_add_explicit(&v628->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        md::Label::update(v617, (uint64_t)v446, (uint64_t)v1017);
        if (v628 && !atomic_fetch_add(&v628->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v628->__on_zero_shared)(v628);
          std::__shared_weak_count::__release_weak(v628);
        }
LABEL_1218:
        v629 = *(std::__shared_weak_count **)&buf[8];
        if (!*(void *)&buf[8]
          || atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          goto LABEL_1220;
        }
        ((void (*)(std::__shared_weak_count *))v629->__on_zero_shared)(v629);
        std::__shared_weak_count::__release_weak(v629);
        v630 = (unsigned int *)*((void *)v599 + 1);
        if (!v630)
        {
          do
          {
LABEL_1224:
            v631 = (unsigned int *)*((void *)v599 + 2);
            _ZF = *(void *)v631 == (void)v599;
            v599 = v631;
          }
          while (!_ZF);
          goto LABEL_1182;
        }
        do
        {
LABEL_1221:
          v631 = v630;
          v630 = *(unsigned int **)v630;
        }
        while (v630);
LABEL_1182:
        v599 = v631;
        if (v631 == (unsigned int *)v600) {
          goto LABEL_1176;
        }
      }
    }
  }
LABEL_1227:
  if (v1007) {
    operator delete(v1007);
  }
  v632 = v1030;
  uint64_t v633 = (*(uint64_t (**)(void))(**(void **)(*((void *)v1030 + 21) + 32) + 200))(*(void *)(*((void *)v1030 + 21) + 32));
  if (v633)
  {
    v634 = *(std::string::size_type **)v633;
    v635 = *(std::string::size_type **)(v633 + 8);
    if (*(std::string::size_type **)v633 != v635)
    {
      while (1)
      {
        std::string::size_type v636 = *v634;
        *(_DWORD *)buf = 1;
        v637 = (md::LabelPoint *)(*(uint64_t (**)(std::string::size_type, uint8_t *))(*(void *)v636 + 112))(v636, buf);
        v638 = (double *)md::LabelPoint::mercatorPoint(v637);
        if (*v638 >= *v1015 && *v638 <= *((double *)v1017 + 7))
        {
          double v639 = v638[1];
          if (v639 >= *((double *)v1017 + 6) && v639 <= *((double *)v1017 + 8)) {
            break;
          }
        }
LABEL_1232:
        v634 += 2;
        if (v634 == v635) {
          goto LABEL_1267;
        }
      }
      v640 = (std::__shared_weak_count *)v634[1];
      __p.__r_.__value_.__r.__words[0] = *v634;
      __p.__r_.__value_.__l.__size_ = (std::string::size_type)v640;
      if (v640) {
        atomic_fetch_add_explicit(&v640->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      LODWORD(v1026.f64[0]) = 1;
      md::LabelPool::labelForFeature((md::LabelBase **)buf, v594, (uint64_t)v632, &__p, (unsigned int *)&v1026, 1);
      if (v640 && !atomic_fetch_add(&v640->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v640->__on_zero_shared)(v640);
        std::__shared_weak_count::__release_weak(v640);
        unint64_t v641 = *(void *)buf;
        if (*(void *)buf)
        {
LABEL_1242:
          v642 = v1021;
          while (1)
          {
            v643 = *v642;
            v644 = v642;
            if (!*v642) {
              break;
            }
            while (1)
            {
              v642 = (uint64_t **)v643;
              unint64_t v645 = v643[4];
              if (v641 < v645) {
                break;
              }
              if (v645 >= v641) {
                goto LABEL_1256;
              }
              v643 = v642[1];
              if (!v643)
              {
                v644 = v642 + 1;
                goto LABEL_1248;
              }
            }
          }
LABEL_1248:
          v646 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1017 + 53) + 16))(*((void *)v1017 + 53), 48, 8);
          v647 = v646;
          uint64_t v648 = *(void *)&buf[8];
          v646[4] = *(void *)buf;
          v646[5] = v648;
          if (v648) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v648 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t *v646 = 0;
          v646[1] = 0;
          v646[2] = (uint64_t)v642;
          *v644 = v646;
          uint64_t v649 = **((void **)v1017 + 51);
          if (v649)
          {
            *((void *)v1017 + 51) = v649;
            v647 = *v644;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v1017 + 52), v647);
          ++*((void *)v1017 + 54);
          uint64_t v650 = *(void *)buf;
          if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v650 + 820))
          {
            *(unsigned char *)(v650 + 1214) = -1;
            md::Label::updateStateMachineForStaging(v650, 0, 37);
          }
          *(unsigned char *)(v650 + 1261) = 0;
          *(void *)(v650 + 1224) = 0;
          unint64_t v641 = *(void *)buf;
LABEL_1256:
          v651 = (std::__shared_weak_count *)v634[1];
          __p.__r_.__value_.__r.__words[0] = *v634;
          __p.__r_.__value_.__l.__size_ = (std::string::size_type)v651;
          if (v651) {
            atomic_fetch_add_explicit(&v651->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          md::Label::update(v641, (uint64_t)v632, (uint64_t)v1017);
          if (v651 && !atomic_fetch_add(&v651->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v651->__on_zero_shared)(v651);
            std::__shared_weak_count::__release_weak(v651);
          }
        }
      }
      else
      {
        unint64_t v641 = *(void *)buf;
        if (*(void *)buf) {
          goto LABEL_1242;
        }
      }
      if (!*(void *)(*(uint64_t (**)(std::string::size_type, void, void, void, void))(*(void *)*v634 + 552))(*v634, 0, 0, 0, 0))++*((_DWORD *)v1017 + 23); {
      v652 = *(std::__shared_weak_count **)&buf[8];
      }
      if (*(void *)&buf[8]
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v652->__on_zero_shared)(v652);
        std::__shared_weak_count::__release_weak(v652);
      }
      goto LABEL_1232;
    }
  }
LABEL_1267:
  v653 = v1030;
  uint64_t v654 = (*(uint64_t (**)(void))(**(void **)(*((void *)v1030 + 21) + 32) + 192))(*(void *)(*((void *)v1030 + 21) + 32));
  if (v654)
  {
    v655 = *(void **)v654;
    v656 = *(void **)(v654 + 8);
    if (*(void **)v654 != v656)
    {
      do
      {
        v657 = (void *)*v655;
        *(_DWORD *)buf = 1;
        v658 = (md::LabelPoint *)(*(uint64_t (**)(void *, uint8_t *))(*v657 + 112))(v657, buf);
        v659 = (double *)md::LabelPoint::mercatorPoint(v658);
        if (*v659 >= *v1015 && *v659 <= *((double *)v1017 + 7))
        {
          double v660 = v659[1];
          if (v660 >= *((double *)v1017 + 6) && v660 <= *((double *)v1017 + 8))
          {
            v661 = (void *)*v655;
            if (!*(void *)(*v655 + 72))
            {
              v661[9] = atomic_fetch_add((atomic_ullong *volatile)(*((void *)v653 + 36) + 680), 1uLL) + 1;
              v661 = (void *)*v655;
            }
            if (*(void *)(*(uint64_t (**)(void *, void, void, void, void))(*v661 + 552))(v661, 0, 0, 0, 0))
            {
              v662 = (std::__shared_weak_count *)v655[1];
              __p.__r_.__value_.__r.__words[0] = *v655;
              __p.__r_.__value_.__l.__size_ = (std::string::size_type)v662;
              if (v662) {
                atomic_fetch_add_explicit(&v662->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              LODWORD(v1026.f64[0]) = 1;
              md::LabelPool::labelForFeature((md::LabelBase **)buf, v594, (uint64_t)v653, &__p, (unsigned int *)&v1026, 1);
              if (v662 && !atomic_fetch_add(&v662->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v662->__on_zero_shared)(v662);
                std::__shared_weak_count::__release_weak(v662);
                unint64_t v663 = *(void *)buf;
                if (*(void *)buf) {
                  goto LABEL_1284;
                }
              }
              else
              {
                unint64_t v663 = *(void *)buf;
                if (*(void *)buf)
                {
LABEL_1284:
                  v664 = v1021;
                  while (1)
                  {
                    v665 = *v664;
                    v666 = v664;
                    if (!*v664) {
                      break;
                    }
                    while (1)
                    {
                      v664 = (uint64_t **)v665;
                      unint64_t v667 = v665[4];
                      if (v663 < v667) {
                        break;
                      }
                      if (v667 >= v663) {
                        goto LABEL_1298;
                      }
                      v665 = v664[1];
                      if (!v665)
                      {
                        v666 = v664 + 1;
                        goto LABEL_1290;
                      }
                    }
                  }
LABEL_1290:
                  v668 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1017 + 53)
                                                                                        + 16))(*((void *)v1017 + 53), 48, 8);
                  v669 = v668;
                  uint64_t v670 = *(void *)&buf[8];
                  v668[4] = *(void *)buf;
                  v668[5] = v670;
                  if (v670) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v670 + 8), 1uLL, memory_order_relaxed);
                  }
                  uint64_t *v668 = 0;
                  v668[1] = 0;
                  v668[2] = (uint64_t)v664;
                  *v666 = v668;
                  uint64_t v671 = **((void **)v1017 + 51);
                  if (v671)
                  {
                    *((void *)v1017 + 51) = v671;
                    v669 = *v666;
                  }
                  std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v1017 + 52), v669);
                  ++*((void *)v1017 + 54);
                  uint64_t v672 = *(void *)buf;
                  if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u)
                    && !*(unsigned char *)(v672 + 820))
                  {
                    *(unsigned char *)(v672 + 1214) = -1;
                    md::Label::updateStateMachineForStaging(v672, 0, 37);
                  }
                  *(unsigned char *)(v672 + 1261) = 0;
                  *(void *)(v672 + 1224) = 0;
                  unint64_t v663 = *(void *)buf;
LABEL_1298:
                  v673 = (std::__shared_weak_count *)v655[1];
                  __p.__r_.__value_.__r.__words[0] = *v655;
                  __p.__r_.__value_.__l.__size_ = (std::string::size_type)v673;
                  if (v673) {
                    atomic_fetch_add_explicit(&v673->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  md::Label::update(v663, (uint64_t)v653, (uint64_t)v1017);
                  if (v673 && !atomic_fetch_add(&v673->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v673->__on_zero_shared)(v673);
                    std::__shared_weak_count::__release_weak(v673);
                  }
                }
              }
              v674 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8]
                && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v674->__on_zero_shared)(v674);
                std::__shared_weak_count::__release_weak(v674);
              }
              goto LABEL_1271;
            }
            ++*((_DWORD *)v1017 + 23);
          }
        }
LABEL_1271:
        v655 += 2;
      }
      while (v655 != v656);
    }
  }
  v675 = v1030;
  uint64_t v676 = (*(uint64_t (**)(void))(**(void **)(*((void *)v1030 + 21) + 32) + 208))(*(void *)(*((void *)v1030 + 21) + 32));
  if (v676)
  {
    v678 = *(unsigned __int8 ***)v676;
    v677 = *(unsigned __int8 ***)(v676 + 8);
    if (*(unsigned __int8 ***)v676 != v677)
    {
      v679 = 0;
      do
      {
        v680 = *v678;
        if (*(void *)(*(uint64_t (**)(unsigned __int8 *, void, void, void, void))(*(void *)*v678 + 552))(*v678, 0, 0, 0, 0))
        {
          if (v680[140] || v1001 >= v680[136])
          {
            md::LineLabelFeature::updatePositions((md::LineLabelFeature *)v680, v675, v1001, v1017);
            md::LineLabelPlacer::placementsForRect((char **)buf, (uint64_t)(v680 + 192), v1015, v1001);
            if (v679) {
              operator delete(v679);
            }
            v679 = *(void **)buf;
            v681 = *(unsigned int **)&buf[8];
            for (uint64_t j = *(unsigned int **)buf; j != v681; ++j)
            {
              md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v675, v678, j, 1);
              uint64_t v683 = *(void *)buf;
              if (*(void *)buf)
              {
                v684 = v1021;
                while (1)
                {
                  v685 = *v684;
                  v686 = v684;
                  if (!*v684) {
                    break;
                  }
                  while (1)
                  {
                    v684 = (uint64_t **)v685;
                    unint64_t v687 = v685[4];
                    if (*(void *)buf < v687) {
                      break;
                    }
                    if (v687 >= *(void *)buf) {
                      goto LABEL_1336;
                    }
                    v685 = v684[1];
                    if (!v685)
                    {
                      v686 = v684 + 1;
                      goto LABEL_1328;
                    }
                  }
                }
LABEL_1328:
                v688 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1017 + 53) + 16))(*((void *)v1017 + 53), 48, 8);
                v689 = v688;
                uint64_t v690 = *(void *)&buf[8];
                v688[4] = *(void *)buf;
                v688[5] = v690;
                if (v690) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v690 + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t *v688 = 0;
                v688[1] = 0;
                v688[2] = (uint64_t)v684;
                *v686 = v688;
                uint64_t v691 = **((void **)v1017 + 51);
                if (v691)
                {
                  *((void *)v1017 + 51) = v691;
                  v689 = *v686;
                }
                std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v1017 + 52), v689);
                ++*((void *)v1017 + 54);
                uint64_t v692 = *(void *)buf;
                if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v692 + 820))
                {
                  *(unsigned char *)(v692 + 1214) = -1;
                  md::Label::updateStateMachineForStaging(v692, 0, 37);
                }
                *(unsigned char *)(v692 + 1261) = 0;
                *(void *)(v692 + 1224) = 0;
                uint64_t v683 = *(void *)buf;
LABEL_1336:
                md::Label::update(v683, (uint64_t)v675, (uint64_t)v1017);
              }
              v693 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8]
                && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v693->__on_zero_shared)(v693);
                std::__shared_weak_count::__release_weak(v693);
              }
            }
            v594 = a3;
          }
          else
          {
            ++*((_DWORD *)v1017 + 24);
          }
        }
        else
        {
          ++*((_DWORD *)v1017 + 23);
        }
        v678 += 2;
      }
      while (v678 != v677);
      if (v679) {
        operator delete(v679);
      }
    }
  }
  if (*(_DWORD *)v996)
  {
    v694 = (void *)v993[16];
    for (uint64_t k = (void *)v993[17]; v694 != k; v694 += 2)
    {
      uint64_t v698 = *v694;
      *(_DWORD *)buf = 1;
      v699 = (md::LabelPoint *)(*(uint64_t (**)(uint64_t, uint8_t *))(*(void *)v698 + 112))(v698, buf);
      v700 = (double *)md::LabelPoint::mercatorPoint(v699);
      if (*v700 >= *v1015 && *v700 <= *((double *)v1017 + 7))
      {
        double v701 = v700[1];
        if (v701 >= *((double *)v1017 + 6) && v701 <= *((double *)v1017 + 8))
        {
          if (*(void *)(*(uint64_t (**)(void, void, void, void, void))(*(void *)*v694 + 552))(*v694, 0, 0, 0, 0))
          {
            LODWORD(__p.__r_.__value_.__l.__data_) = 1;
            md::LabelPool::labelForFeature((md::LabelBase **)buf, v594, (uint64_t)v1030, v694, (unsigned int *)&__p, 1);
            uint64_t v702 = *(void *)buf;
            if (*(void *)buf)
            {
              v703 = v1021;
              while (1)
              {
                v704 = *v703;
                v705 = v703;
                if (!*v703) {
                  break;
                }
                while (1)
                {
                  v703 = (uint64_t **)v704;
                  unint64_t v706 = v704[4];
                  if (*(void *)buf < v706) {
                    break;
                  }
                  if (v706 >= *(void *)buf) {
                    goto LABEL_1373;
                  }
                  v704 = v703[1];
                  if (!v704)
                  {
                    v705 = v703 + 1;
                    goto LABEL_1365;
                  }
                }
              }
LABEL_1365:
              v707 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1017 + 53) + 16))(*((void *)v1017 + 53), 48, 8);
              v708 = v707;
              uint64_t v709 = *(void *)&buf[8];
              v707[4] = *(void *)buf;
              v707[5] = v709;
              if (v709) {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v709 + 8), 1uLL, memory_order_relaxed);
              }
              uint64_t *v707 = 0;
              v707[1] = 0;
              v707[2] = (uint64_t)v703;
              *v705 = v707;
              uint64_t v710 = **((void **)v1017 + 51);
              if (v710)
              {
                *((void *)v1017 + 51) = v710;
                v708 = *v705;
              }
              std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v1017 + 52), v708);
              ++*((void *)v1017 + 54);
              uint64_t v711 = *(void *)buf;
              if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v711 + 820))
              {
                *(unsigned char *)(v711 + 1214) = -1;
                md::Label::updateStateMachineForStaging(v711, 0, 37);
              }
              *(unsigned char *)(v711 + 1261) = 0;
              *(void *)(v711 + 1224) = 0;
              uint64_t v702 = *(void *)buf;
LABEL_1373:
              md::Label::update(v702, (uint64_t)v1030, (uint64_t)v1017);
            }
            v712 = *(std::__shared_weak_count **)&buf[8];
            if (*(void *)&buf[8]
              && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v712->__on_zero_shared)(v712);
              std::__shared_weak_count::__release_weak(v712);
            }
          }
          else
          {
            ++*((_DWORD *)v1017 + 23);
          }
        }
      }
    }
    v714 = (md::LineLabelFeature **)v993[30];
    v713 = (md::LineLabelFeature **)v993[31];
    if (v714 != v713)
    {
      v715 = 0;
      do
      {
        v716 = *v714;
        md::LineLabelFeature::updatePositions(*v714, v1030, v1001, v1017);
        md::LineLabelPlacer::placementsForRect((char **)buf, (uint64_t)v716 + 192, v1015, v1001);
        if (v715) {
          operator delete(v715);
        }
        v715 = *(void **)buf;
        v717 = *(unsigned int **)&buf[8];
        for (uint64_t m = *(unsigned int **)buf; m != v717; ++m)
        {
          md::LabelPool::labelForFeature((md::LabelBase **)buf, a3, (uint64_t)v1030, v714, m, 1);
          uint64_t v719 = *(void *)buf;
          if (*(void *)buf)
          {
            v720 = (uint64_t *)v1021;
            while (1)
            {
              v721 = (uint64_t *)*v720;
              v722 = v720;
              if (!*v720) {
                break;
              }
              while (1)
              {
                v720 = v721;
                unint64_t v723 = v721[4];
                if (*(void *)buf < v723) {
                  break;
                }
                if (v723 >= *(void *)buf) {
                  goto LABEL_1428;
                }
                v721 = (uint64_t *)v720[1];
                if (!v721)
                {
                  v722 = v720 + 1;
                  goto LABEL_1392;
                }
              }
            }
LABEL_1392:
            uint64_t v724 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1017 + 53) + 16))(*((void *)v1017 + 53), 48, 8);
            uint64_t v725 = *(void *)&buf[8];
            *(void *)(v724 + 32) = *(void *)buf;
            *(void *)(v724 + 40) = v725;
            if (v725) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v725 + 8), 1uLL, memory_order_relaxed);
            }
            *(void *)uint64_t v724 = 0;
            *(void *)(v724 + 8) = 0;
            *(void *)(v724 + 16) = v720;
            uint64_t *v722 = v724;
            uint64_t v726 = **((void **)v1017 + 51);
            if (v726)
            {
              *((void *)v1017 + 51) = v726;
              uint64_t v724 = *v722;
            }
            v727 = *v1021;
            _ZF = v724 == (void)*v1021;
            *(unsigned char *)(v724 + 24) = _ZF;
            if (!_ZF)
            {
              do
              {
                v728 = *(uint64_t **)(v724 + 16);
                if (*((unsigned char *)v728 + 24)) {
                  break;
                }
                uint64_t v729 = v728[2];
                v730 = *(uint64_t **)v729;
                if (*(uint64_t **)v729 == v728)
                {
                  uint64_t v733 = *(void *)(v729 + 8);
                  if (!v733 || (int v734 = *(unsigned __int8 *)(v733 + 24), v731 = (unsigned char *)(v733 + 24), v734))
                  {
                    if (*v728 == v724)
                    {
                      v735 = *(uint64_t ***)(v724 + 16);
                    }
                    else
                    {
                      v735 = (uint64_t **)v728[1];
                      v736 = *v735;
                      v728[1] = (uint64_t)*v735;
                      if (v736)
                      {
                        v736[2] = (uint64_t)v728;
                        uint64_t v729 = v728[2];
                      }
                      v735[2] = (uint64_t *)v729;
                      *(void *)(v728[2] + 8 * (*(void *)v728[2] != (void)v728)) = v735;
                      *v735 = v728;
                      v728[2] = (uint64_t)v735;
                      uint64_t v729 = (uint64_t)v735[2];
                      v728 = *(uint64_t **)v729;
                    }
                    *((unsigned char *)v735 + 24) = 1;
                    *(unsigned char *)(v729 + 24) = 0;
                    uint64_t v739 = v728[1];
                    *(void *)uint64_t v729 = v739;
                    if (v739) {
                      *(void *)(v739 + 16) = v729;
                    }
                    v728[2] = *(void *)(v729 + 16);
                    *(void *)(*(void *)(v729 + 16) + 8 * (**(void **)(v729 + 16) != v729)) = v728;
                    v728[1] = v729;
                    goto LABEL_1423;
                  }
                }
                else if (!v730 || (int v732 = *((unsigned __int8 *)v730 + 24), v731 = v730 + 3, v732))
                {
                  if (*v728 == v724)
                  {
                    uint64_t v737 = *(void *)(v724 + 8);
                    uint64_t *v728 = v737;
                    if (v737)
                    {
                      *(void *)(v737 + 16) = v728;
                      uint64_t v729 = v728[2];
                    }
                    *(void *)(v724 + 16) = v729;
                    *(void *)(v728[2] + 8 * (*(void *)v728[2] != (void)v728)) = v724;
                    *(void *)(v724 + 8) = v728;
                    v728[2] = v724;
                    uint64_t v729 = *(void *)(v724 + 16);
                  }
                  else
                  {
                    uint64_t v724 = *(void *)(v724 + 16);
                  }
                  *(unsigned char *)(v724 + 24) = 1;
                  *(unsigned char *)(v729 + 24) = 0;
                  v728 = *(uint64_t **)(v729 + 8);
                  uint64_t v738 = *v728;
                  *(void *)(v729 + 8) = *v728;
                  if (v738) {
                    *(void *)(v738 + 16) = v729;
                  }
                  v728[2] = *(void *)(v729 + 16);
                  *(void *)(*(void *)(v729 + 16) + 8 * (**(void **)(v729 + 16) != v729)) = v728;
                  uint64_t *v728 = v729;
LABEL_1423:
                  *(void *)(v729 + 16) = v728;
                  break;
                }
                *((unsigned char *)v728 + 24) = 1;
                uint64_t v724 = v729;
                *(unsigned char *)(v729 + 24) = v729 == (void)v727;
                unsigned char *v731 = 1;
              }
              while ((uint64_t *)v729 != v727);
            }
            ++*((void *)v1017 + 54);
            uint64_t v740 = *(void *)buf;
            if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v740 + 820))
            {
              *(unsigned char *)(v740 + 1214) = -1;
              md::Label::updateStateMachineForStaging(v740, 0, 37);
            }
            *(unsigned char *)(v740 + 1261) = 0;
            *(void *)(v740 + 1224) = 0;
            uint64_t v719 = *(void *)buf;
LABEL_1428:
            md::Label::update(v719, (uint64_t)v1030, (uint64_t)v1017);
          }
          v741 = *(std::__shared_weak_count **)&buf[8];
          if (*(void *)&buf[8]
            && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v741->__on_zero_shared)(v741);
            std::__shared_weak_count::__release_weak(v741);
          }
        }
        v714 += 2;
      }
      while (v714 != v713);
      v594 = a3;
      if (v715) {
        operator delete(v715);
      }
    }
  }
  v742 = (unsigned __int8 **)*((void *)v1017 + 43);
  for (uint64_t n = (unsigned __int8 **)*((void *)v1017 + 44); v742 != n; v742 += 2)
  {
    v744 = *v742;
    *(_DWORD *)buf = 1;
    v745 = (md::LabelPoint *)(*(uint64_t (**)(unsigned __int8 *, uint8_t *))(*(void *)v744 + 112))(v744, buf);
    v746 = (double *)md::LabelPoint::mercatorPoint(v745);
    if (*v746 >= *v1015 && *v746 <= *((double *)v1017 + 7))
    {
      double v747 = v746[1];
      if (v747 >= *((double *)v1017 + 6) && v747 <= *((double *)v1017 + 8))
      {
        if (*(void *)(*(uint64_t (**)(unsigned __int8 *, void, void, void, void))(*(void *)*v742 + 552))(*v742, 0, 0, 0, 0))
        {
          v748 = *v742;
          if ((*v742)[140] || v1001 >= v748[136])
          {
            if (!v975
              || !*(void *)&v975[34]
              || !(*(uint64_t (**)(unsigned __int8 *))(*(void *)v748 + 368))(v748)
              || !(*(uint64_t (**)(unsigned __int8 *))(*(void *)*v742 + 384))(*v742)
              || (uint64_t v749 = (*(uint64_t (**)(unsigned __int8 *))(*(void *)*v742 + 376))(*v742),
                  int v750 = md::VenueLogicContext::displayedFloorOrdinalForVenueBuildingId(v975, v749),
                  v750 == (*(unsigned int (**)(unsigned __int8 *))(*(void *)*v742 + 400))(*v742)))
            {
              LODWORD(__p.__r_.__value_.__l.__data_) = 1;
              md::LabelPool::labelForCustomFeature(buf, (uint64_t)v594, (uint64_t)v1030, v742, (unsigned int *)&__p, 1);
              uint64_t v751 = *(void *)buf;
              if (*(void *)buf)
              {
                v752 = v1021;
                while (1)
                {
                  v753 = *v752;
                  v754 = v752;
                  if (!*v752) {
                    break;
                  }
                  while (1)
                  {
                    v752 = (uint64_t **)v753;
                    unint64_t v755 = v753[4];
                    if (*(void *)buf < v755) {
                      break;
                    }
                    if (v755 >= *(void *)buf) {
                      goto LABEL_1466;
                    }
                    v753 = v752[1];
                    if (!v753)
                    {
                      v754 = v752 + 1;
                      goto LABEL_1458;
                    }
                  }
                }
LABEL_1458:
                v756 = (uint64_t *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)v1017 + 53) + 16))(*((void *)v1017 + 53), 48, 8);
                v757 = v756;
                uint64_t v758 = *(void *)&buf[8];
                v756[4] = *(void *)buf;
                v756[5] = v758;
                if (v758) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v758 + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t *v756 = 0;
                v756[1] = 0;
                v756[2] = (uint64_t)v752;
                *v754 = v756;
                uint64_t v759 = **((void **)v1017 + 51);
                if (v759)
                {
                  *((void *)v1017 + 51) = v759;
                  v757 = *v754;
                }
                std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)v1017 + 52), v757);
                ++*((void *)v1017 + 54);
                uint64_t v760 = *(void *)buf;
                if (!atomic_fetch_add((atomic_uchar *volatile)(*(void *)buf + 1296), 1u) && !*(unsigned char *)(v760 + 820))
                {
                  *(unsigned char *)(v760 + 1214) = -1;
                  md::Label::updateStateMachineForStaging(v760, 0, 37);
                }
                *(unsigned char *)(v760 + 1261) = 0;
                *(void *)(v760 + 1224) = 0;
                uint64_t v751 = *(void *)buf;
LABEL_1466:
                md::Label::update(v751, (uint64_t)v1030, (uint64_t)v1017);
              }
              v761 = *(std::__shared_weak_count **)&buf[8];
              if (*(void *)&buf[8]
                && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v761->__on_zero_shared)(v761);
                std::__shared_weak_count::__release_weak(v761);
              }
            }
          }
          else
          {
            ++*((_DWORD *)v1017 + 24);
          }
        }
        else
        {
          ++*((_DWORD *)v1017 + 23);
        }
      }
    }
  }
  if (*((unsigned char *)v1017 + 125))
  {
    v762 = v1028;
    if (v1028 != v1029)
    {
      do
      {
        uint64_t v763 = v762[4];
        if (atomic_fetch_add((atomic_uchar *volatile)(v763 + 1296), 0xFFu) == 1)
        {
          if (*(unsigned char *)(v763 + 1264))
          {
            *(unsigned char *)(v763 + 1261) = 1;
            *(void *)(v763 + 1224) = 0;
          }
          else
          {
            md::Label::updateStateMachineForStaging(v763, 1, 37);
          }
        }
        v764 = (void *)v762[1];
        if (v764)
        {
          do
          {
            v765 = (void **)v764;
            v764 = (void *)*v764;
          }
          while (v764);
        }
        else
        {
          do
          {
            v765 = (void **)v762[2];
            _ZF = *v765 == v762;
            v762 = v765;
          }
          while (!_ZF);
        }
        v762 = v765;
      }
      while (v765 != v1029);
    }
  }
  *((unsigned char *)v1017 + 125) = 1;
  v766 = v993;
  if (*((unsigned char *)v1017 + 126))
  {
    v767 = (std::__shared_weak_count *)*((void *)v1017 + 56);
    void *v974 = 0;
    v974[1] = 0;
    if (v767 && !atomic_fetch_add(&v767->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v767->__on_zero_shared)(v767);
      std::__shared_weak_count::__release_weak(v767);
      v766 = v993;
      if (!*((void *)v1017 + 27)) {
        goto LABEL_1500;
      }
    }
    else if (!*((void *)v1017 + 27))
    {
      goto LABEL_1500;
    }
    unsigned __int8 v768 = atomic_load((unsigned __int8 *)v1030 + 3391);
    if (v768)
    {
      uint64_t v769 = *((void *)v1017 + 27);
      *(void *)buf = 0;
      *(void *)&buf[8] = 0;
      v770 = *(std::__shared_weak_count **)(v769 + 272);
      if (v770)
      {
        *(void *)&buf[8] = std::__shared_weak_count::lock(v770);
        if (*(void *)&buf[8])
        {
          uint64_t v771 = *(void *)(v769 + 264);
          *(void *)buf = v771;
          if (v771)
          {
            int v772 = *(unsigned __int8 *)(*((void *)v1030 + 29) + 17);
            v773 = operator new(0xF0uLL);
            v773[1] = 0;
            v773[2] = 0;
            void *v773 = &unk_1EF581D00;
            uint64_t v774 = md::LabelMapTileCollisionInfo::LabelMapTileCollisionInfo((uint64_t)(v773 + 3), v772 == 0, v1015, v771, 3);
            v775 = (std::__shared_weak_count *)*((void *)v1017 + 56);
            *((void *)v1017 + 55) = v774;
            *((void *)v1017 + 56) = v773;
            if (v775)
            {
              if (!atomic_fetch_add(&v775->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v775->__on_zero_shared)(v775);
                std::__shared_weak_count::__release_weak(v775);
              }
            }
          }
        }
      }
      v776 = *(std::__shared_weak_count **)&buf[8];
      if (*(void *)&buf[8]
        && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v776->__on_zero_shared)(v776);
        std::__shared_weak_count::__release_weak(v776);
      }
      v766 = v993;
    }
  }
LABEL_1500:
  *((unsigned char *)v1017 + 126) = 0;
  if (*((unsigned char *)v1017 + 127))
  {
    v777 = (std::__shared_weak_count *)*((void *)v1017 + 58);
    v974[2] = 0;
    v974[3] = 0;
    if (v777 && !atomic_fetch_add(&v777->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v777->__on_zero_shared)(v777);
      std::__shared_weak_count::__release_weak(v777);
      v766 = v993;
      uint64_t v778 = *((void *)v1017 + 35);
      if (v778)
      {
LABEL_1504:
        *(void *)buf = 0;
        *(void *)&buf[8] = 0;
        v779 = *(std::__shared_weak_count **)(v778 + 272);
        if (v779)
        {
          *(void *)&buf[8] = std::__shared_weak_count::lock(v779);
          if (*(void *)&buf[8])
          {
            uint64_t v780 = *(void *)(v778 + 264);
            *(void *)buf = v780;
            if (v780)
            {
              int v781 = *(unsigned __int8 *)(*((void *)v1030 + 29) + 17);
              v782 = operator new(0xF0uLL);
              v782[1] = 0;
              v782[2] = 0;
              void *v782 = &unk_1EF581D00;
              uint64_t v783 = md::LabelMapTileCollisionInfo::LabelMapTileCollisionInfo((uint64_t)(v782 + 3), v781 == 0, v1015, v780, 2);
              v784 = (std::__shared_weak_count *)*((void *)v1017 + 58);
              *((void *)v1017 + 57) = v783;
              *((void *)v1017 + 58) = v782;
              if (v784)
              {
                if (!atomic_fetch_add(&v784->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v784->__on_zero_shared)(v784);
                  std::__shared_weak_count::__release_weak(v784);
                }
              }
            }
          }
        }
        v785 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8]
          && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&buf[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v785->__on_zero_shared)(v785);
          std::__shared_weak_count::__release_weak(v785);
        }
        v766 = v993;
      }
    }
    else
    {
      uint64_t v778 = *((void *)v1017 + 35);
      if (v778) {
        goto LABEL_1504;
      }
    }
    *((unsigned char *)v1017 + 127) = 0;
  }
  if (v766)
  {
    v786 = v1030;
    if (*((unsigned char *)v1030 + 201) == 1)
    {
      uint64_t v787 = v766[41];
      if (v787)
      {
        int v788 = *(_DWORD *)(v787 + 48);
        if (*((_DWORD *)v1017 + 122) == v788) {
          goto LABEL_1534;
        }
        *((_DWORD *)v1017 + 122) = v788;
        v789 = *(md::LabelRouteCollisionInfo **)(v787 + 304);
        if (v789)
        {
          v790 = (uint64_t **)md::LabelRouteCollisionInfo::tileCollisionInfo(v789, *((unsigned __int8 *)v1017 + 9), v1015);
          if (v790) {
            goto LABEL_1528;
          }
        }
LABEL_1531:
        v796 = (std::__shared_weak_count *)*((void *)v1017 + 60);
        v974[4] = 0;
        v974[5] = 0;
        if (!v796) {
          goto LABEL_1534;
        }
LABEL_1532:
        if (!atomic_fetch_add(&v796->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v796->__on_zero_shared)(v796);
          std::__shared_weak_count::__release_weak(v796);
        }
        goto LABEL_1534;
      }
LABEL_1530:
      *((_DWORD *)v1017 + 122) = 0;
      goto LABEL_1531;
    }
  }
  if (!v972) {
    goto LABEL_1530;
  }
  v786 = v1030;
  if (*((unsigned char *)v1030 + 201) != 2) {
    goto LABEL_1530;
  }
  if (!*(unsigned char *)(md::LabelSettingsStyleCache::styleCaps(*(md::LabelSettingsStyleCache **)(*((void *)v1030 + 42)
                                                                                          + 200))
                 + 1))
    goto LABEL_1530;
  uint64_t v791 = *(void *)(v972 + 200);
  if (!v791) {
    goto LABEL_1530;
  }
  int v792 = *(unsigned __int8 *)(v791 + 24);
  if (*((_DWORD *)v1017 + 122) == v792) {
    goto LABEL_1534;
  }
  *((_DWORD *)v1017 + 122) = v792;
  v790 = (uint64_t **)md::LabelRouteCollisionInfo::tileCollisionInfo(*(md::LabelRouteCollisionInfo **)(v791 + 96), *((unsigned __int8 *)v1017 + 9), v1015);
  if (!v790) {
    goto LABEL_1531;
  }
LABEL_1528:
  int v793 = *(unsigned __int8 *)(*((void *)v786 + 29) + 17);
  v794 = operator new(0xF0uLL);
  v794[1] = 0;
  v794[2] = 0;
  void *v794 = &unk_1EF581D00;
  uint64_t v795 = md::LabelMapTileCollisionInfo::LabelMapTileCollisionInfo((uint64_t)(v794 + 3), v793 == 0, v1015, v790);
  v796 = (std::__shared_weak_count *)*((void *)v1017 + 60);
  *((void *)v1017 + 59) = v795;
  *((void *)v1017 + 60) = v794;
  if (v796) {
    goto LABEL_1532;
  }
LABEL_1534:
  v797 = v1030;
  int type = v998->_type;
  uint64_t v799 = (*(uint64_t (**)(void))(**(void **)(*((void *)v1030 + 21) + 32) + 80))(*(void *)(*((void *)v1030 + 21) + 32));
  if (type != 255
    || !v799
    || (uint64_t v800 = *(void *)(v799 + 200)) == 0
    || *(void *)(v973 + 1208) == *(void *)(v973 + 1216))
  {
    v842 = (uint64_t **)*((void *)v1017 + 51);
    if (v842 != v1021)
    {
      do
      {
        v843 = v842[4];
        if (*((unsigned char *)v843 + 1279))
        {
          *((_WORD *)v843 + 640) = 0;
          *((unsigned char *)v843 + 1282) = 0;
          if ((*(unsigned int (**)(uint64_t, uint64_t))(*(void *)v843[1] + 520))(v843[1], 0xFFFFFFFFLL)) {
            md::LabelFeatureStyler::restyleFeature(*((md::LabelFeatureStyler **)v797 + 37), (md::LabelFeature *)v842[4][1]);
          }
        }
        v844 = v842[1];
        if (v844)
        {
          do
          {
            v845 = (uint64_t **)v844;
            v844 = (uint64_t *)*v844;
          }
          while (v844);
        }
        else
        {
          do
          {
            v845 = (uint64_t **)v842[2];
            _ZF = *v845 == (uint64_t *)v842;
            v842 = v845;
          }
          while (!_ZF);
        }
        v842 = v845;
      }
      while (v845 != v1021);
    }
    goto LABEL_1797;
  }
  if (*((unsigned __int8 *)v1017 + 9) >= 0xFu) {
    int v801 = 15;
  }
  else {
    int v801 = *((unsigned __int8 *)v1017 + 9);
  }
  v802 = (uint64_t **)*((void *)v1017 + 51);
  if (v802 == v1021) {
    goto LABEL_1797;
  }
  unsigned int v997 = v801;
  v981 = v797;
  v803 = 0;
  v804 = 0;
  v805 = 0;
  v1016 = 0;
  v806 = 0;
  v807 = 0;
  int v1014 = *(unsigned __int8 *)(v973 + 1197);
  v1002 = *(md::LabelRouteCollisionInfo ***)(v799 + 200);
  int v1008 = *(unsigned __int8 *)(v800 + 24);
  double v808 = 1.79769313e308;
  double v809 = -1.79769313e308;
  double v810 = -1.79769313e308;
  double v811 = 1.79769313e308;
  do
  {
    v1019 = v805;
    v812 = v802[4];
    if (!*((unsigned char *)v812 + 1279))
    {
      v805 = v1019;
      v813 = v802[1];
      if (v813) {
        goto LABEL_1591;
      }
      goto LABEL_1601;
    }
    if (*((unsigned __int8 *)v812 + 1281) == v1014
      && *((unsigned __int8 *)v812 + 1280) == v1008
      && *((unsigned __int8 *)v812 + 1282) >= v997)
    {
      v805 = v1019;
      v813 = v802[1];
      if (v813) {
        goto LABEL_1591;
      }
      goto LABEL_1601;
    }
    if (v806 < v807)
    {
      *(void *)v806 = v812;
      v806 += 8;
      v805 = v1019;
      goto LABEL_1569;
    }
    uint64_t v814 = (v806 - v1016) >> 3;
    unint64_t v815 = v814 + 1;
    if ((unint64_t)(v814 + 1) >> 61) {
      abort();
    }
    if ((v807 - v1016) >> 2 > v815) {
      unint64_t v815 = (v807 - v1016) >> 2;
    }
    if ((unint64_t)(v807 - v1016) >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v816 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v816 = v815;
    }
    if (v816)
    {
      if (v816 >> 61) {
        goto LABEL_1799;
      }
      v817 = operator new(8 * v816);
    }
    else
    {
      v817 = 0;
    }
    v818 = &v817[8 * v814];
    *(void *)v818 = v812;
    v819 = v818 + 8;
    v820 = v1016;
    if (v806 == v1016)
    {
      v805 = v1019;
      v807 = &v817[8 * v816];
      if (!v1016) {
        goto LABEL_1568;
      }
LABEL_1567:
      operator delete(v820);
      goto LABEL_1568;
    }
    unint64_t v821 = v806 - 8 - v1016;
    v805 = v1019;
    if (v821 < 0x168
      || &v817[v806 - v1016 - 8 - (v821 & 0xFFFFFFFFFFFFFFF8)] > &v817[v806 - v1016 - 8]
      || &v806[-(v821 & 0xFFFFFFFFFFFFFFF8) - 8] > v806 - 8
      || (unint64_t)(v1016 - v817) < 0x20)
    {
      v822 = v806;
      v820 = v1016;
      do
      {
LABEL_1565:
        uint64_t v823 = *((void *)v822 - 1);
        v822 -= 8;
        *((void *)v818 - 1) = v823;
        v818 -= 8;
      }
      while (v822 != v820);
      goto LABEL_1566;
    }
    uint64_t v837 = (v821 >> 3) + 1;
    v822 = &v806[-8 * (v837 & 0x3FFFFFFFFFFFFFFCLL)];
    v838 = &v817[8 * v814 - 16];
    v839 = v806 - 16;
    uint64_t v840 = v837 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v841 = *(_OWORD *)v839;
      *(v838 - 1) = *((_OWORD *)v839 - 1);
      _OWORD *v838 = v841;
      v838 -= 2;
      v839 -= 32;
      v840 -= 4;
    }
    while (v840);
    v818 -= 8 * (v837 & 0x3FFFFFFFFFFFFFFCLL);
    v820 = v1016;
    if (v837 != (v837 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_1565;
    }
LABEL_1566:
    v807 = &v817[8 * v816];
    if (v820) {
      goto LABEL_1567;
    }
LABEL_1568:
    v1016 = v818;
    v806 = v819;
LABEL_1569:
    v824 = (md::LabelPoint *)(*(uint64_t (**)(uint64_t, uint64_t *))(*(void *)v802[4][1] + 112))(v802[4][1], v802[4] + 6);
    v825 = (_OWORD *)md::LabelPoint::mercatorPoint(v824);
    v826 = v825;
    if (v804 >= v803)
    {
      uint64_t v828 = (v804 - (char *)v805) >> 4;
      unint64_t v829 = v828 + 1;
      if ((unint64_t)(v828 + 1) >> 60) {
        abort();
      }
      if ((v803 - (char *)v805) >> 3 > v829) {
        unint64_t v829 = (v803 - (char *)v805) >> 3;
      }
      if ((unint64_t)(v803 - (char *)v805) >= 0x7FFFFFFFFFFFFFF0) {
        unint64_t v830 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v830 = v829;
      }
      if (v830)
      {
        if (v830 >> 60) {
          goto LABEL_1799;
        }
        v831 = (char *)operator new(16 * v830);
      }
      else
      {
        v831 = 0;
      }
      v832 = &v831[16 * v828];
      *(_OWORD *)v832 = *v826;
      if (v804 == (char *)v805)
      {
        v805 = (md::LabelPool *)&v831[16 * v828];
      }
      else
      {
        v833 = &v831[16 * v828];
        do
        {
          *((_OWORD *)v833 - 1) = *((_OWORD *)v804 - 1);
          v833 -= 16;
          v804 -= 16;
        }
        while (v804 != (char *)v805);
        v804 = (char *)v805;
        v805 = (md::LabelPool *)v833;
      }
      v803 = &v831[16 * v830];
      v827 = (double *)(v832 + 16);
      if (v804) {
        operator delete(v804);
      }
    }
    else
    {
      *(_OWORD *)v804 = *v825;
      v827 = (double *)(v804 + 16);
    }
    double v834 = *(v827 - 2);
    double v835 = *(v827 - 1);
    double v808 = fmin(v834, v808);
    double v810 = fmax(v810, v834);
    double v811 = fmin(v835, v811);
    double v809 = fmax(v809, v835);
    v804 = (char *)v827;
    v813 = v802[1];
    if (v813)
    {
      do
      {
LABEL_1591:
        v836 = (uint64_t **)v813;
        v813 = (uint64_t *)*v813;
      }
      while (v813);
      goto LABEL_1543;
    }
    do
    {
LABEL_1601:
      v836 = (uint64_t **)v802[2];
      _ZF = *v836 == (uint64_t *)v802;
      v802 = v836;
    }
    while (!_ZF);
LABEL_1543:
    v802 = v836;
  }
  while (v836 != v1021);
  if (v1016 != v806)
  {
    if (v810 >= v808 && v809 >= v811)
    {
      double v846 = *(double *)(v973 + 1200);
      double v847 = -(v846 * *((double *)v1017 + 13));
      double v808 = v808 - v846 * *((double *)v1017 + 13);
      double v810 = v810 - v847;
      double v811 = v811 - v846 * *((double *)v1017 + 13);
      double v809 = v809 - v847;
    }
    memset(buf, 0, sizeof(buf));
    uint64_t v848 = v806 - v1016;
    v1020 = v805;
    if (v806 - v1016 < 0) {
      abort();
    }
    size_t v849 = v848 >> 3;
    v850 = operator new(v848 >> 3);
    memset(v850, 255, v849);
    v979 = v850;
    uint64_t v851 = md::LabelRouteCollisionInfo::collisionInfoForZoom(v1002[12], v997);
    v852 = (int8x8_t *)v851;
    double v853 = 1.0 / *(double *)(v851 + 16);
    int v854 = (int)(v808 * v853) & ~((int)(v808 * v853) >> 31);
    int v999 = (int)(v810 * v853);
    v984 = (int8x8_t *)v851;
    unint64_t v977 = v849;
    if (v854 > v999
      || ((int v855 = (int)(v809 * v853),
           uint64_t v994 = (int)(v811 * v853) & ~((int)(v811 * v853) >> 31),
           (int)v994 <= v855)
        ? (BOOL v856 = *(void *)(v851 + 32) == 0)
        : (BOOL v856 = 1),
          v856))
    {
      v857 = 0;
      v860 = 0;
      goto LABEL_1690;
    }
    v858 = 0;
    v859 = 0;
    v860 = 0;
    v861 = 0;
    uint64_t v862 = (v855 + 1);
LABEL_1634:
    int v863 = v854 << 16;
    uint64_t v864 = v994;
    while (2)
    {
      int8x8_t v865 = v852[4];
      if (!*(void *)&v865) {
        goto LABEL_1636;
      }
      unint64_t v866 = (v863 + v864);
      uint8x8_t v867 = (uint8x8_t)vcnt_s8(v865);
      v867.i16[0] = vaddlv_u8(v867);
      if (v867.u32[0] > 1uLL)
      {
        unint64_t v868 = (v863 + v864);
        if (*(void *)&v865 <= v866) {
          unint64_t v868 = v866 % *(void *)&v865;
        }
      }
      else
      {
        unint64_t v868 = (v865.i32[0] - 1) & v866;
      }
      v869 = *(uint64_t ***)(*(void *)&v852[3] + 8 * v868);
      if (!v869) {
        goto LABEL_1636;
      }
      v870 = *v869;
      if (!v870) {
        goto LABEL_1636;
      }
      if (v867.u32[0] < 2uLL)
      {
        uint64_t v871 = *(void *)&v865 - 1;
        while (1)
        {
          uint64_t v873 = v870[1];
          if (v873 == v866)
          {
            if (*((_DWORD *)v870 + 4) == v866) {
              goto LABEL_1658;
            }
          }
          else if ((v873 & v871) != v868)
          {
            goto LABEL_1636;
          }
          v870 = (uint64_t *)*v870;
          if (!v870) {
            goto LABEL_1636;
          }
        }
      }
      while (2)
      {
        unint64_t v872 = v870[1];
        if (v872 != v866)
        {
          if (v872 >= *(void *)&v865) {
            v872 %= *(void *)&v865;
          }
          if (v872 != v868) {
            goto LABEL_1636;
          }
          goto LABEL_1647;
        }
        if (*((_DWORD *)v870 + 4) != v866)
        {
LABEL_1647:
          v870 = (uint64_t *)*v870;
          if (!v870) {
            goto LABEL_1636;
          }
          continue;
        }
        break;
      }
LABEL_1658:
      uint64_t v874 = v870[3];
      if (v874) {
        uint64_t v875 = v874 + 8;
      }
      else {
        uint64_t v875 = 0;
      }
      if (v861 < v858)
      {
        *(void *)v861 = v875;
        v861 += 8;
        v859 = v861;
      }
      else
      {
        int64_t v876 = v861 - v860;
        uint64_t v877 = (v861 - v860) >> 3;
        unint64_t v878 = v877 + 1;
        v1003 = v860;
        if ((unint64_t)(v877 + 1) >> 61) {
          abort();
        }
        if ((v858 - v860) >> 2 > v878) {
          unint64_t v878 = (v858 - v860) >> 2;
        }
        if ((unint64_t)(v858 - v860) >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v879 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v879 = v878;
        }
        int v1022 = v854;
        if (v879)
        {
          if (!(v879 >> 61))
          {
            v880 = operator new(8 * v879);
            goto LABEL_1672;
          }
LABEL_1799:
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        v880 = 0;
LABEL_1672:
        v860 = &v880[8 * v877];
        *(void *)v860 = v875;
        v859 = v860 + 8;
        v881 = v1003;
        if (v861 != v1003)
        {
          unint64_t v882 = v861 - 8 - v1003;
          if (v882 < 0x168
            || &v880[v876 - 8 - (v882 & 0xFFFFFFFFFFFFFFF8)] > &v880[v876 - 8]
            || &v861[-(v882 & 0xFFFFFFFFFFFFFFF8) - 8] > v861 - 8
            || (unint64_t)(v861 - &v880[v876]) < 0x20)
          {
            v883 = v861;
            v881 = v1003;
            v852 = v984;
          }
          else
          {
            uint64_t v885 = (v882 >> 3) + 1;
            v883 = &v861[-8 * (v885 & 0x3FFFFFFFFFFFFFFCLL)];
            v886 = &v880[8 * v877 - 16];
            v887 = v861 - 16;
            uint64_t v888 = v885 & 0x3FFFFFFFFFFFFFFCLL;
            v881 = v1003;
            v852 = v984;
            do
            {
              long long v889 = *(_OWORD *)v887;
              *(v886 - 1) = *((_OWORD *)v887 - 1);
              _OWORD *v886 = v889;
              v886 -= 2;
              v887 -= 32;
              v888 -= 4;
            }
            while (v888);
            v860 -= 8 * (v885 & 0x3FFFFFFFFFFFFFFCLL);
            if (v885 == (v885 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_1676:
              v858 = &v880[8 * v879];
              if (v881) {
                goto LABEL_1677;
              }
              goto LABEL_1678;
            }
          }
          do
          {
            uint64_t v884 = *((void *)v883 - 1);
            v883 -= 8;
            *((void *)v860 - 1) = v884;
            v860 -= 8;
          }
          while (v883 != v881);
          goto LABEL_1676;
        }
        v852 = v984;
        v858 = &v880[8 * v879];
        if (v1003) {
LABEL_1677:
        }
          operator delete(v881);
LABEL_1678:
        v861 = v859;
        int v854 = v1022;
      }
LABEL_1636:
      if (++v864 != v862) {
        continue;
      }
      break;
    }
    while (v854 != v999)
    {
      ++v854;
      if (v852[4]) {
        goto LABEL_1634;
      }
    }
    v857 = v859;
LABEL_1690:
    {
      operator new();
    }
    uint64_t v995 = mdm::Allocator::instance(void)::alloc;
    v1004 = v860;
    if (v860 != v857)
    {
      uint64_t v1023 = 0;
      v890 = 0;
      v891 = 0;
      v892 = v860;
      while (1)
      {
        v896 = *(char **)(*(void *)v892 + 40);
        v895 = *(char **)(*(void *)v892 + 48);
        uint64_t v897 = v895 - v896;
        if (v895 - v896 < 1)
        {
          v893 = v890;
          v894 = v891;
          goto LABEL_1694;
        }
        uint64_t v898 = v897 >> 3;
        uint64_t v899 = v890 - v891;
        v900 = &v891[(v890 - v891) & 0xFFFFFFFFFFFFFFF8];
        if (v897 >> 3 <= (v1023 - (uint64_t)v890) >> 3)
        {
          v908 = v857;
          uint64_t v909 = (v890 - v900) >> 3;
          if (v909 < v898)
          {
            v910 = &v896[8 * v909];
            if (v910 == v895)
            {
              v912 = v890;
            }
            else
            {
              v911 = &v896[8 * v909];
              v912 = v890;
              do
              {
                if (v912) {
                  *(void *)v912 = *(void *)v911;
                }
                v911 += 8;
                v912 += 8;
              }
              while (v911 != v895);
            }
            if (v890 - v900 < 1)
            {
              v893 = v912;
            }
            else
            {
LABEL_1735:
              uint64_t v933 = 8 * v898;
              v934 = &v912[-8 * v898];
              v893 = v912;
              while (v934 < v890)
              {
                if (v893) {
                  *(void *)v893 = *(void *)v934;
                }
                v934 += 8;
                v893 += 8;
              }
              v935 = &v900[v933];
              if (v912 != v935) {
                memmove(&v912[-8 * ((v912 - v935) >> 3)], &v891[(v890 - v891) & 0xFFFFFFFFFFFFFFF8], v912 - v935);
              }
              if (v910 != v896) {
                memmove(&v891[(v890 - v891) & 0xFFFFFFFFFFFFFFF8], v896, v910 - v896);
              }
            }
            v894 = v891;
            v857 = v908;
            goto LABEL_1694;
          }
          v910 = &v896[8 * v898];
          v912 = v890;
          goto LABEL_1735;
        }
        uint64_t v901 = v899 >> 3;
        unint64_t v902 = (v899 >> 3) + v898;
        if (v902 >> 61) {
          abort();
        }
        unint64_t v903 = v1023 - (void)v891;
        if ((v1023 - (uint64_t)v891) >> 2 > v902) {
          unint64_t v902 = (v1023 - (uint64_t)v891) >> 2;
        }
        if (v903 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v902 = 0x1FFFFFFFFFFFFFFFLL;
        }
        unint64_t v1000 = v902;
        if (v902)
        {
          v992 = v892;
          uint64_t v904 = v895 - v896;
          v905 = v857;
          uint64_t v906 = v899 >> 3;
          uint64_t v907 = (*(uint64_t (**)(uint64_t, unint64_t, uint64_t))(*(void *)v995 + 16))(v995, 8 * v902, 4);
          unint64_t v903 = v1023 - (void)v891;
          uint64_t v901 = v906;
          v857 = v905;
          uint64_t v897 = v904;
          v892 = v992;
          uint64_t v899 = v890 - v891;
        }
        else
        {
          uint64_t v907 = 0;
        }
        v894 = (char *)(v907 + 8 * v901);
        uint64_t v913 = 8 * v898;
        v893 = &v894[8 * v898];
        uint64_t v914 = v913;
        v915 = v894;
        do
        {
          if (v915) {
            *(void *)v915 = *(void *)v896;
          }
          v915 += 8;
          v896 += 8;
          v914 -= 8;
        }
        while (v914);
        if ((unint64_t)v899 >= 8)
        {
          unint64_t v916 = (v899 & 0xFFFFFFFFFFFFFFF8) - 8;
          if (v916 >= 0x68)
          {
            v917 = &v891[(v890 - v891) & 0xFFFFFFFFFFFFFFF8];
            if ((unint64_t)&v891[-v907] >= 0x20)
            {
              uint64_t v918 = (v916 >> 3) + 1;
              v917 = &v900[-8 * (v918 & 0x3FFFFFFFFFFFFFFCLL)];
              v919 = (long long *)&v891[8 * v901 - 16];
              v920 = (_OWORD *)(v907 + 8 * v901 - 16);
              uint64_t v921 = v918 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v922 = *v919;
                *(v920 - 1) = *(v919 - 1);
                _OWORD *v920 = v922;
                v919 -= 2;
                v920 -= 2;
                v921 -= 4;
              }
              while (v921);
              v894 -= 8 * (v918 & 0x3FFFFFFFFFFFFFFCLL);
              if (v918 == (v918 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_1724;
              }
            }
          }
          else
          {
            v917 = &v891[(v890 - v891) & 0xFFFFFFFFFFFFFFF8];
          }
          do
          {
            uint64_t v923 = *((void *)v917 - 1);
            v917 -= 8;
            *((void *)v894 - 1) = v923;
            v894 -= 8;
          }
          while (v917 != v891);
        }
LABEL_1724:
        uint64_t v1023 = v907 + 8 * v1000;
        if (v890 != v900)
        {
          v924 = &v891[v899 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v925 = v890 - v924 - 8;
          if (v925 >= 0x68 && (v899 & 0xFFFFFFFFFFFFFFF8) + v907 + v897 - (unint64_t)v924 >= 0x20)
          {
            uint64_t v926 = (v925 >> 3) + 1;
            uint64_t v927 = 8 * (v926 & 0x3FFFFFFFFFFFFFFCLL);
            v900 += v927;
            v928 = (_OWORD *)(v907 + v913 + 8 * v901 + 16);
            v929 = (long long *)&v891[8 * v901 + 16];
            uint64_t v930 = v926 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v931 = *v929;
              *(v928 - 1) = *(v929 - 1);
              _OWORD *v928 = v931;
              v928 += 2;
              v929 += 2;
              v930 -= 4;
            }
            while (v930);
            v893 += v927;
            if (v926 == (v926 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_1732:
              (*(void (**)(uint64_t, char *, unint64_t))(*(void *)v995 + 40))(v995, v891, v903);
              goto LABEL_1694;
            }
          }
          do
          {
            uint64_t v932 = *(void *)v900;
            v900 += 8;
            *(void *)v893 = v932;
            v893 += 8;
          }
          while (v900 != v890);
        }
        if (v891) {
          goto LABEL_1732;
        }
LABEL_1694:
        v892 += 8;
        v890 = v893;
        v891 = v894;
        if (v892 == v857) {
          goto LABEL_1747;
        }
      }
    }
    uint64_t v1023 = 0;
    v893 = 0;
    v894 = 0;
LABEL_1747:
    v936 = *(uint64_t **)(*(void *)v984 + 32);
    unint64_t v937 = (v804 - (char *)v1020) >> 4;
    unint64_t v938 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
    if (v937 <= v938)
    {
      if (v937 < v938) {
        *(void *)&buf[8] = *(void *)buf + 8 * v937;
      }
    }
    else
    {
      std::vector<double>::__append((uint64_t)buf, v937 - v938);
    }
    if (v804 != (char *)v1020)
    {
      uint64_t v939 = *(void *)buf;
      if (v937 <= 1) {
        uint64_t v940 = 1;
      }
      else {
        uint64_t v940 = (v804 - (char *)v1020) >> 4;
      }
      if (v894 == v893)
      {
        memset_pattern16(*(void **)buf, &unk_1A28FFCE0, 8 * v940);
      }
      else
      {
        uint64_t v941 = 0;
        do
        {
          v942 = (double *)((char *)v1020 + 16 * v941);
          int8x8_t v943 = v984[10];
          double v944 = 1.79769313e308;
          v945 = v894;
          do
          {
            uint64_t v946 = *((unsigned int *)v945 + 1);
            if (v946 >= 2)
            {
              unsigned int v947 = *(_DWORD *)v945;
              uint64_t v948 = *v936;
              uint64_t v949 = v946 - 1;
              double v950 = *v942;
              double v951 = v942[1];
              do
              {
                unsigned int v952 = v947 + 1;
                v953 = (double *)(v948 + 16 * *(int *)(*(void *)&v943 + 4 * v947));
                v954 = (double *)(v948 + 16 * *(int *)(*(void *)&v943 + 4 * v952));
                double v956 = *v953;
                double v955 = v953[1];
                double v957 = *v954 - *v953;
                double v958 = v954[1] - v955;
                double v959 = v957 * v957 + v958 * v958;
                double v960 = 0.0;
                if (v959 > 1.0e-15) {
                  double v960 = fmin(fmax(((v950 - v956) * v957 + (v951 - v955) * v958) / v959, 0.0), 1.0);
                }
                double v944 = fmin((v950 - (v956 + v960 * v957)) * (v950 - (v956 + v960 * v957))+ (v951 - (v955 + v960 * v958)) * (v951 - (v955 + v960 * v958)), v944);
                unsigned int v947 = v952;
                --v949;
              }
              while (v949);
            }
            v945 += 8;
          }
          while (v945 != v893);
          *(double *)(v939 + 8 * v941++) = v944;
        }
        while (v941 != v940);
      }
    }
    if (v894) {
      (*(void (**)(uint64_t, char *, uint64_t))(*(void *)v995 + 40))(v995, v894, v1023 - (void)v894);
    }
    if (v1004) {
      operator delete(v1004);
    }
    v961 = *(double **)buf;
    if (*(void *)&buf[8] != *(void *)buf)
    {
      uint64_t v962 = 0;
      unint64_t v963 = (uint64_t)(*(void *)&buf[8] - *(void *)buf) >> 3;
      if (v963 <= 1) {
        unint64_t v963 = 1;
      }
      do
      {
        double v965 = v961[v962];
        double v966 = 1.79769313e308;
        if (v965 != 1.79769313e308) {
          double v966 = *((double *)v1017 + 14) * v965;
        }
        v967 = *(double **)(v973 + 1208);
        v968 = *(char **)(v973 + 1216);
        if (v967 == (double *)v968)
        {
LABEL_1774:
          char v964 = 0;
        }
        else
        {
          while (v967[1] < v966)
          {
            v967 += 2;
            if (v967 == (double *)v968) {
              goto LABEL_1774;
            }
          }
          char v964 = *(unsigned char *)v967;
        }
        v979[v962++] = v964;
      }
      while (v962 != v963);
    }
    uint64_t v969 = 0;
    if (v977 <= 1) {
      uint64_t v970 = 1;
    }
    else {
      uint64_t v970 = v977;
    }
    do
    {
      uint64_t v971 = *(void *)&v1016[8 * v969];
      if (*(unsigned char *)(v971 + 1279))
      {
        *(unsigned char *)(v971 + 1280) = v1008;
        *(unsigned char *)(v971 + 1281) = v1014;
        *(unsigned char *)(v971 + 1282) = v997;
        if ((*(unsigned int (**)(void))(**(void **)(v971 + 8) + 520))()) {
          md::LabelFeatureStyler::restyleFeature(*((md::LabelFeatureStyler **)v981 + 37), *(md::LabelFeature **)(*(void *)&v1016[8 * v969] + 8));
        }
      }
      ++v969;
    }
    while (v970 != v969);
    operator delete(v979);
    if (v961) {
      operator delete(v961);
    }
    v805 = v1020;
  }
  if (v805) {
    operator delete(v805);
  }
  if (v1016) {
    operator delete(v1016);
  }
LABEL_1797:
  *((_WORD *)v1017 + 61) = 0;
  *((unsigned char *)v1017 + 124) = 0;
  *((unsigned char *)v1017 + 128) = 0;
  return (unsigned char *)std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy((uint64_t)&v1028, v1029[0]);
}

void sub_1A1A8FEF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,void *a32,void *a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,void *a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,char a53,void *a54)
{
  std::__shared_weak_count::~__shared_weak_count(v54);
  operator delete(v56);
  std::__tree<std::shared_ptr<md::MuninRoadLabel>,std::less<std::shared_ptr<md::MuninRoadLabel>>,geo::StdAllocator<std::shared_ptr<md::MuninRoadLabel>,mdm::Allocator>>::destroy((uint64_t)&a53, a54);
  _Unwind_Resume(a1);
}

void md::LineLabelPlacer::placementsForRect(char **a1, uint64_t a2, double *a3, char a4)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  uint64_t v4 = *(void **)(a2 + 32);
  uint64_t v5 = (void *)(a2 + 40);
  if (v4 != (void *)(a2 + 40))
  {
    uint64_t v6 = a3;
    uint64_t v7 = a2;
    unsigned int v9 = 0;
    size_t v10 = 0;
    BOOL v11 = (char *)(1 << a4);
    uint64_t v48 = 1 << a4;
    while (1)
    {
      uint64_t v12 = (_DWORD *)v4[5];
      if ((v11 & v12[4]) != 0) {
        break;
      }
LABEL_46:
      uint64_t v32 = (void *)v4[1];
      if (v32)
      {
        do
        {
          uint64_t v33 = v32;
          uint64_t v32 = (void *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          uint64_t v33 = (void *)v4[2];
          BOOL v34 = *v33 == (void)v4;
          uint64_t v4 = v33;
        }
        while (!v34);
      }
      uint64_t v4 = v33;
      if (v33 == v5) {
        return;
      }
    }
    if (*(unsigned char *)(*(void *)v7 + 290))
    {
      unint64_t v13 = (unint64_t)a1[2];
      if ((unint64_t)v9 < v13)
      {
LABEL_7:
        *(_DWORD *)unsigned int v9 = *((_DWORD *)v4 + 8);
        size_t v14 = v9 + 4;
LABEL_45:
        a1[1] = v14;
        unsigned int v9 = v14;
        goto LABEL_46;
      }
      uint64_t v26 = (v9 - v10) >> 2;
      unint64_t v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 62) {
        abort();
      }
      uint64_t v28 = v13 - (void)v10;
      if (v28 >> 1 > v27) {
        unint64_t v27 = v28 >> 1;
      }
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v27;
      }
      if (v24)
      {
        if (v24 >> 62) {
LABEL_80:
        }
          std::__throw_bad_array_new_length[abi:nn180100]();
        uint64_t v25 = operator new(4 * v24);
      }
      else
      {
        uint64_t v25 = 0;
      }
      BOOL v11 = &v25[4 * v26];
      *(_DWORD *)BOOL v11 = *((_DWORD *)v4 + 8);
      size_t v14 = v11 + 4;
      if (v9 != v10)
      {
        unint64_t v29 = v9 - 4 - v10;
        if (v29 >= 0xBC)
        {
          if (&v25[v9 - v10 - 4 - (v29 & 0xFFFFFFFFFFFFFFFCLL)] > &v25[v9 - v10 - 4])
          {
            unint64_t v30 = v9;
          }
          else if (&v9[-(v29 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v9 - 4)
          {
            unint64_t v30 = v9;
          }
          else if ((unint64_t)(v10 - v25) >= 0x20)
          {
            uint64_t v35 = (v29 >> 2) + 1;
            unint64_t v30 = &v9[-4 * (v35 & 0x7FFFFFFFFFFFFFF8)];
            uint64_t v36 = &v25[4 * v26 - 16];
            uint64_t v37 = v9 - 16;
            uint64_t v38 = v35 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v39 = *(_OWORD *)v37;
              *(v36 - 1) = *((_OWORD *)v37 - 1);
              *uint64_t v36 = v39;
              v36 -= 2;
              v37 -= 32;
              v38 -= 8;
            }
            while (v38);
            v11 -= 4 * (v35 & 0x7FFFFFFFFFFFFFF8);
            if (v35 == (v35 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_42;
            }
          }
          else
          {
            unint64_t v30 = v9;
          }
        }
        else
        {
          unint64_t v30 = v9;
        }
        do
        {
          int v31 = *((_DWORD *)v30 - 1);
          v30 -= 4;
          *((_DWORD *)v11 - 1) = v31;
          v11 -= 4;
        }
        while (v30 != v10);
      }
    }
    else
    {
      unint64_t v15 = (md::LabelPoint *)(*(uint64_t (**)(_DWORD *))(*(void *)v12 + 56))(v12);
      unint64_t v16 = (double *)md::LabelPoint::mercatorPoint(v15);
      if (*v16 < *v6 || *v16 > v6[2]) {
        goto LABEL_46;
      }
      double v18 = v16[1];
      if (v18 < v6[1] || v18 > v6[3]) {
        goto LABEL_46;
      }
      unint64_t v20 = (unint64_t)a1[2];
      if ((unint64_t)v9 < v20) {
        goto LABEL_7;
      }
      uint64_t v21 = (v9 - v10) >> 2;
      unint64_t v22 = v21 + 1;
      if ((unint64_t)(v21 + 1) >> 62) {
        abort();
      }
      uint64_t v23 = v20 - (void)v10;
      if (v23 >> 1 > v22) {
        unint64_t v22 = v23 >> 1;
      }
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v24 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v24 = v22;
      }
      if (v24)
      {
        if (v24 >> 62) {
          goto LABEL_80;
        }
        uint64_t v25 = operator new(4 * v24);
      }
      else
      {
        uint64_t v25 = 0;
      }
      BOOL v11 = &v25[4 * v21];
      *(_DWORD *)BOOL v11 = *((_DWORD *)v4 + 8);
      size_t v14 = v11 + 4;
      if (v9 != v10)
      {
        unint64_t v40 = v9 - 4 - v10;
        if (v40 >= 0xBC)
        {
          if (&v25[v9 - v10 - 4 - (v40 & 0xFFFFFFFFFFFFFFFCLL)] > &v25[v9 - v10 - 4])
          {
            uint64_t v41 = v9;
          }
          else if (&v9[-(v40 & 0xFFFFFFFFFFFFFFFCLL) - 4] > v9 - 4)
          {
            uint64_t v41 = v9;
          }
          else if ((unint64_t)(v10 - v25) >= 0x20)
          {
            uint64_t v43 = (v40 >> 2) + 1;
            uint64_t v41 = &v9[-4 * (v43 & 0x7FFFFFFFFFFFFFF8)];
            uint64_t v44 = &v25[4 * v21 - 16];
            float64_t v45 = v9 - 16;
            uint64_t v46 = v43 & 0x7FFFFFFFFFFFFFF8;
            do
            {
              long long v47 = *(_OWORD *)v45;
              *(v44 - 1) = *((_OWORD *)v45 - 1);
              _OWORD *v44 = v47;
              v44 -= 2;
              v45 -= 32;
              v46 -= 8;
            }
            while (v46);
            v11 -= 4 * (v43 & 0x7FFFFFFFFFFFFFF8);
            if (v43 == (v43 & 0x7FFFFFFFFFFFFFF8)) {
              goto LABEL_42;
            }
          }
          else
          {
            uint64_t v41 = v9;
          }
        }
        else
        {
          uint64_t v41 = v9;
        }
        do
        {
          int v42 = *((_DWORD *)v41 - 1);
          v41 -= 4;
          *((_DWORD *)v11 - 1) = v42;
          v11 -= 4;
        }
        while (v41 != v10);
      }
    }
LABEL_42:
    *a1 = v11;
    a1[1] = v14;
    a1[2] = &v25[4 * v24];
    if (v10) {
      operator delete(v10);
    }
    size_t v10 = v11;
    uint64_t v7 = a2;
    uint64_t v6 = a3;
    LODWORD(v11) = v48;
    goto LABEL_45;
  }
}

void sub_1A1A908F4(_Unwind_Exception *exception_object)
{
  long long v3 = *(void **)v1;
  if (*(void *)v1)
  {
    *(void *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void md::PointLabelFeature::updatePositions(md::PointLabelFeature *this)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 312);
  if ((v1 & 1) == 0) {
    return;
  }
  uint64_t v4 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
  {
    operator new();
  }
  uint64_t v67 = mdm::Allocator::instance(void)::alloc;
  std::mutex::lock((std::mutex *)((char *)this + 248));
  uint64_t v5 = (unsigned __int8 *)*((void *)this + 40);
  long long v63 = *(_OWORD *)((char *)this + 328);
  uint64_t v65 = v5;
  *((_OWORD *)this + 20) = 0uLL;
  long long v66 = v63;
  *((void *)this + 42) = 0;
  atomic_store(0, (unsigned __int8 *)this + 312);
  std::mutex::unlock((std::mutex *)((char *)this + 248));
  uint64_t v6 = v5;
  int v61 = (unsigned __int8 *)v63;
  if (v5 != (unsigned __int8 *)v63)
  {
    std::string::size_type v62 = (uint64_t *)((char *)this + 464);
    uint64_t v7 = v5;
    while (1)
    {
      uint64_t v64 = v7;
      int v8 = *v7;
      if (v8 == 2)
      {
        uint64_t v9 = *((void *)v7 + 5);
        uint64_t v10 = (*(uint64_t (**)(md::PointLabelFeature *))(*(void *)this + 160))(this);
        if (md::DebugStreamingPOIFeatureID) {
          BOOL v11 = md::DebugStreamingPOIFeatureID == v10;
        }
        else {
          BOOL v11 = 0;
        }
        if (v11)
        {
          if (GEOGetVectorKitStreamingPOILog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitStreamingPOILog_onceToken, &__block_literal_global_61);
          }
          uint64_t v12 = (id)GEOGetVectorKitStreamingPOILog_log;
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v13 = *((void *)this + 55);
            *(_DWORD *)buf = 134218240;
            *(void *)&int8x8_t buf[4] = v13;
            __int16 v69 = 2048;
            uint64_t v70 = v9;
            _os_log_impl(&dword_1A1780000, v12, OS_LOG_TYPE_DEBUG, "PointLabelFeature::setPoiRemoveVersion, oldVersion=%llu, newVersion=%llu", buf, 0x16u);
          }
        }
        *((void *)this + 55) = v9;
        goto LABEL_7;
      }
      if (v8 == 1) {
        break;
      }
      if (!*v7) {
        (*(void (**)(md::PointLabelFeature *, unsigned __int8 *, void))(*(void *)this + 760))(this, v7 + 8, v7[32]);
      }
LABEL_7:
      uint64_t v7 = v64 + 48;
      if (v64 + 48 == v61)
      {
        uint64_t v6 = v65;
        goto LABEL_149;
      }
    }
    uint64_t v14 = (*(uint64_t (**)(md::PointLabelFeature *))(*(void *)this + 160))(this);
    if (md::DebugStreamingPOIFeatureID) {
      BOOL v15 = md::DebugStreamingPOIFeatureID == v14;
    }
    else {
      BOOL v15 = 0;
    }
    if (v15)
    {
      if (GEOGetVectorKitStreamingPOILog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitStreamingPOILog_onceToken, &__block_literal_global_61);
      }
      unint64_t v16 = (id)GEOGetVectorKitStreamingPOILog_log;
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v17 = *((void *)v64 + 2);
        *(_DWORD *)buf = 134217984;
        *(void *)&int8x8_t buf[4] = v17;
        _os_log_impl(&dword_1A1780000, v16, OS_LOG_TYPE_DEBUG, "PointLabelFeature::removeTileElements, geoTile=%p", buf, 0xCu);
      }
    }
    double v18 = (uint64_t *)*((void *)this + 57);
    if (v18 == v62) {
      goto LABEL_7;
    }
    while (1)
    {
      int v19 = v4;
      unint64_t v20 = v3;
      uint64_t v21 = (uint64_t *)v18[5];
      unint64_t v22 = (uint64_t *)v18[6];
      uint64_t v23 = *((void *)v64 + 2);
      unint64_t v24 = (std::__shared_weak_count *)*((void *)v64 + 3);
      if (v24) {
        atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v21 != v22)
      {
        while (1)
        {
          uint64_t v25 = *v21 ? *v21 + 8 : 0;
          if (*(void *)(v25 + 8) == v23) {
            break;
          }
          if (++v21 == v22)
          {
            uint64_t v21 = v22;
            goto LABEL_62;
          }
        }
        if (v21 != v22)
        {
          for (uint64_t i = v21 + 1; i != v22; ++i)
          {
            uint64_t v27 = *i;
            uint64_t v28 = *i + 8;
            if (!*i) {
              uint64_t v28 = 0;
            }
            if (*(void *)(v28 + 8) != v23)
            {
              unint64_t v29 = (void *)*v21;
              if (*v21)
              {
                BOOL v11 = (*v29)-- == 1;
                if (v11)
                {
                  unint64_t v30 = (std::__shared_weak_count *)v29[3];
                  if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
                    std::__shared_weak_count::__release_weak(v30);
                  }
                  if ((atomic_load_explicit(v20, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire((__guard *)v20)) {
                    operator new();
                  }
                  (*(void (**)(void, uint64_t, uint64_t))(**((void **)v19 + 91) + 40))(*((void *)v19 + 91), *v21, 152);
                  *uint64_t v21 = 0;
                  uint64_t v27 = *i;
                }
              }
              *v21++ = v27;
              uint64_t *i = 0;
            }
          }
        }
      }
LABEL_62:
      if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
        std::__shared_weak_count::__release_weak(v24);
      }
      int v31 = (uint64_t *)v18[6];
      long long v3 = v20;
      if (v21 == v31)
      {
        uint64_t v32 = (uint64_t *)v18[5];
        uint64_t v4 = v19;
        if (v32 != v21) {
          goto LABEL_83;
        }
      }
      else
      {
        uint64_t v4 = v19;
        if (v31 != v21)
        {
          uint64_t v33 = (uint64_t *)v18[6];
          do
          {
            uint64_t v35 = (void *)*--v33;
            BOOL v34 = v35;
            if (v35)
            {
              BOOL v11 = (*v34)-- == 1;
              if (v11)
              {
                uint64_t v36 = (std::__shared_weak_count *)v34[3];
                if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
                  std::__shared_weak_count::__release_weak(v36);
                }
                if ((atomic_load_explicit(v3, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire((__guard *)v3)) {
                  operator new();
                }
                (*(void (**)(void, void, uint64_t))(**((void **)v19 + 91) + 40))(*((void *)v19 + 91), *(v31 - 1), 152);
                *(v31 - 1) = 0;
              }
            }
            int v31 = v33;
          }
          while (v33 != v21);
        }
        v18[6] = (uint64_t)v21;
        uint64_t v32 = (uint64_t *)v18[5];
        if (v32 != v21)
        {
LABEL_83:
          if (*v32) {
            uint64_t v37 = *v32 + 8;
          }
          else {
            uint64_t v37 = 0;
          }
          if (*(void *)(v37 + 72) != *((void *)this + 54))
          {
            uint64_t v44 = (*(uint64_t (**)(md::PointLabelFeature *))(*(void *)this + 160))(this);
            if (md::DebugStreamingPOIFeatureID && md::DebugStreamingPOIFeatureID == v44)
            {
              if (GEOGetVectorKitStreamingPOILog_onceToken != -1) {
                dispatch_once(&GEOGetVectorKitStreamingPOILog_onceToken, &__block_literal_global_61);
              }
              float64_t v45 = (id)GEOGetVectorKitStreamingPOILog_log;
              if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v46 = *((void *)this + 54);
                if (*v32) {
                  uint64_t v47 = *v32 + 8;
                }
                else {
                  uint64_t v47 = 0;
                }
                uint64_t v48 = *(void *)(v47 + 72);
                *(_DWORD *)buf = 134218240;
                *(void *)&int8x8_t buf[4] = v46;
                __int16 v69 = 2048;
                uint64_t v70 = v48;
                _os_log_impl(&dword_1A1780000, v45, OS_LOG_TYPE_DEBUG, "PointLabelFeature::removeTile, unexpire elements oldVersion=%llu -> updateVersion=%llu", buf, 0x16u);
              }
            }
            if (*v32) {
              uint64_t v49 = *v32 + 8;
            }
            else {
              uint64_t v49 = 0;
            }
            *((void *)this + 54) = *(void *)(v49 + 72);
            uint8x8_t v50 = (void **)v18[5];
            id v51 = (void **)v18[6];
            while (v50 != v51)
            {
              unint64_t v52 = *v50;
              *(void *)buf = v52;
              if (v52)
              {
                uint64_t v53 = (*v52)++;
                if (v52[10] != *((void *)this + 54))
                {
                  *unint64_t v52 = v53;
                  if (!v53)
                  {
                    float v57 = (std::__shared_weak_count *)v52[3];
                    if (v57 && !atomic_fetch_add(&v57->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
                      std::__shared_weak_count::__release_weak(v57);
                    }
                    if ((atomic_load_explicit(v3, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire((__guard *)v3)) {
                      operator new();
                    }
                    (*(void (**)(void, void, uint64_t))(**((void **)v4 + 91) + 40))(*((void *)v4 + 91), *(void *)buf, 152);
                  }
                  break;
                }
                unint64_t v54 = (unint64_t)(v52 + 1);
              }
              else
              {
                if (MEMORY[0x48] != *((void *)this + 54)) {
                  break;
                }
                unint64_t v54 = 0;
              }
              md::PointLabelFeatureElement::updateText(v54, this, *((unsigned __int8 *)this + 649));
              if (v52) {
                uint8x8_t v55 = (md::PointLabelFeatureElement *)(v52 + 1);
              }
              else {
                uint8x8_t v55 = 0;
              }
              md::PointLabelFeatureElement::updateLabelPlacements(v55, this);
              if (v52)
              {
                BOOL v11 = (*v52)-- == 1;
                if (v11)
                {
                  unint64_t v56 = (std::__shared_weak_count *)v52[3];
                  if (v56 && !atomic_fetch_add(&v56->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v56->__on_zero_shared)(v56);
                    std::__shared_weak_count::__release_weak(v56);
                  }
                  if ((atomic_load_explicit(v3, memory_order_acquire) & 1) == 0 && __cxa_guard_acquire((__guard *)v3)) {
                    operator new();
                  }
                  (*(void (**)(void, void, uint64_t))(**((void **)v4 + 91) + 40))(*((void *)v4 + 91), *(void *)buf, 152);
                }
              }
              ++v50;
            }
          }
        }
      }
      uint64_t v38 = (uint64_t *)v18[1];
      if (v18[5] == v18[6])
      {
        unint64_t v40 = (uint64_t *)v18[1];
        uint64_t v41 = v18;
        if (v38)
        {
          do
          {
            long long v39 = v40;
            unint64_t v40 = (uint64_t *)*v40;
          }
          while (v40);
        }
        else
        {
          do
          {
            long long v39 = (uint64_t *)v41[2];
            BOOL v11 = *v39 == (void)v41;
            uint64_t v41 = v39;
          }
          while (!v11);
        }
        int v42 = v18;
        if (v38)
        {
          do
          {
            uint64_t v43 = v38;
            uint64_t v38 = (uint64_t *)*v38;
          }
          while (v38);
        }
        else
        {
          do
          {
            uint64_t v43 = (uint64_t *)v42[2];
            BOOL v11 = *v43 == (void)v42;
            int v42 = v43;
          }
          while (!v11);
        }
        if (*((uint64_t **)this + 57) == v18) {
          *((void *)this + 57) = v43;
        }
        --*((void *)this + 60);
        std::__tree_remove[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 58), v18);
        *(void *)buf = v18 + 5;
        std::vector<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>,geo::StdAllocator<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>,mdm::Allocator>>::__destroy_vector::operator()[abi:nn180100]((uint64_t **)buf);
        (*(void (**)(void, uint64_t *, uint64_t))(**((void **)this + 59) + 40))(*((void *)this + 59), v18, 128);
      }
      else if (v38)
      {
        do
        {
          long long v39 = v38;
          uint64_t v38 = (uint64_t *)*v38;
        }
        while (v38);
      }
      else
      {
        do
        {
          long long v39 = (uint64_t *)v18[2];
          BOOL v11 = *v39 == (void)v18;
          double v18 = v39;
        }
        while (!v11);
      }
      double v18 = v39;
      if (v39 == v62) {
        goto LABEL_7;
      }
    }
  }
LABEL_149:
  if (v6)
  {
    uint64_t v58 = v66;
    uint64_t v59 = v6;
    if ((unsigned __int8 *)v66 != v6)
    {
      do
      {
        v58 -= 48;
        unint64_t v60 = v6;
        geo::StdAllocator<md::PointLabelFeature::WorkUnit,mdm::Allocator>::destroy(v58);
        uint64_t v6 = v60;
      }
      while ((unsigned __int8 *)v58 != v60);
      uint64_t v59 = v65;
    }
    (*(void (**)(uint64_t, unsigned __int8 *, uint64_t))(*(void *)v67 + 40))(v67, v59, *((void *)&v66 + 1) - (void)v59);
  }
}

void sub_1A1A915B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  std::vector<md::PointLabelFeature::WorkUnit,geo::StdAllocator<md::PointLabelFeature::WorkUnit,mdm::Allocator>>::~vector[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t md::PointLabelFeature::venueID(md::PointLabelFeature *this)
{
  return *((void *)this + 76);
}

BOOL md::PointLabelFeatureBase::setFlexZone(md::PointLabelFeatureBase *this, unsigned __int8 a2)
{
  int v2 = *((unsigned __int8 *)this + 244);
  if (v2 != a2) {
    *((unsigned char *)this + 244) = a2;
  }
  return v2 != a2;
}

void md::LabelPool::labelForFeature(md::LabelBase **a1, md::LabelPool *this, uint64_t a3, void *a4, unsigned int *a5, int a6)
{
  if (*((void *)this + 27) > *((void *)this + 76))
  {
    md::LabelPool::pruneCachedLabels((uint64_t)this);
    *((void *)this + 76) = *(void *)this + *((void *)this + 27);
  }
  *a1 = 0;
  a1[1] = 0;
  unint64_t v12 = *(void *)(*a4 + 72);
  unsigned int v13 = *a5;
  BOOL v15 = (uint64_t **)((char *)this + 232);
  uint64_t v14 = (char *)*((void *)this + 29);
  if (!v14) {
    goto LABEL_18;
  }
  unint64_t v16 = (uint64_t **)((char *)this + 232);
  do
  {
    unint64_t v17 = *((void *)v14 + 4);
    BOOL v19 = v17 == v12;
    BOOL v18 = v17 < v12;
    if (v19) {
      BOOL v18 = *((_DWORD *)v14 + 10) < v13;
    }
    BOOL v19 = !v18;
    if (v18) {
      unint64_t v20 = (char **)(v14 + 8);
    }
    else {
      unint64_t v20 = (char **)v14;
    }
    if (v19) {
      unint64_t v16 = (uint64_t **)v14;
    }
    uint64_t v14 = *v20;
  }
  while (*v20);
  if (v16 == v15) {
    goto LABEL_18;
  }
  uint64_t v21 = v16[4];
  BOOL v19 = v12 == (void)v21;
  BOOL v22 = v12 < (unint64_t)v21;
  if (v19) {
    BOOL v22 = v13 < *((_DWORD *)v16 + 10);
  }
  if (v22)
  {
LABEL_18:
    if (!a6) {
      return;
    }
    uint64_t v23 = (char *)*((void *)this + 25);
    if (!v23) {
      goto LABEL_38;
    }
    unint64_t v24 = (char *)this + 200;
    do
    {
      unint64_t v25 = *((void *)v23 + 4);
      BOOL v19 = v25 == v12;
      BOOL v26 = v25 < v12;
      if (v19) {
        BOOL v26 = *((_DWORD *)v23 + 10) < v13;
      }
      BOOL v27 = !v26;
      if (v26) {
        uint64_t v28 = (char **)(v23 + 8);
      }
      else {
        uint64_t v28 = (char **)v23;
      }
      if (v27) {
        unint64_t v24 = v23;
      }
      uint64_t v23 = *v28;
    }
    while (*v28);
    if (v24 == (char *)this + 200) {
      goto LABEL_38;
    }
    unint64_t v29 = *((void *)v24 + 4);
    BOOL v19 = v12 == v29;
    BOOL v30 = v12 < v29;
    if (v19) {
      BOOL v30 = v13 < *((_DWORD *)v24 + 10);
    }
    if (v30 || (int v31 = (std::__shared_weak_count *)*((void *)v24 + 7)) == 0 || v31->__shared_owners_ == -1)
    {
LABEL_38:
      BOOL v34 = operator new(0x538uLL);
      v34[1] = 0;
      v34[2] = 0;
      *BOOL v34 = &unk_1EF5829B0;
      md::Label::Label((uint64_t)(v34 + 3), a3, a4, a5);
    }
    uint64_t v32 = std::__shared_weak_count::lock(v31);
    if (v32) {
      uint64_t v33 = (md::LabelBase *)*((void *)v24 + 6);
    }
    else {
      uint64_t v33 = 0;
    }
    *a1 = v33;
    a1[1] = (md::LabelBase *)v32;
    uint64_t v37 = *v15;
    uint64_t v38 = (uint64_t *)((char *)this + 232);
    if (*v15)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v38 = v37;
          unint64_t v39 = v37[4];
          unsigned int v40 = *((_DWORD *)v38 + 10);
          BOOL v41 = v13 < v40;
          if (v12 != v39) {
            BOOL v41 = v12 < v39;
          }
          if (!v41) {
            break;
          }
          uint64_t v37 = (uint64_t *)*v38;
          BOOL v15 = (uint64_t **)v38;
          if (!*v38) {
            goto LABEL_54;
          }
        }
        BOOL v42 = v40 < v13;
        int v43 = v12 == v39 ? v42 : v39 < v12;
        if (v43 != 1) {
          break;
        }
        uint64_t v37 = (uint64_t *)v38[1];
        if (!v37)
        {
          BOOL v15 = (uint64_t **)(v38 + 1);
          goto LABEL_54;
        }
      }
      uint64_t v44 = (uint64_t)v38;
      uint64_t v48 = *a1;
      uint64_t v47 = a1[1];
      if (v47) {
        goto LABEL_57;
      }
    }
    else
    {
LABEL_54:
      uint64_t v44 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 30) + 16))(*((void *)this + 30), 64, 8);
      *(void *)(v44 + 32) = v12;
      *(_DWORD *)(v44 + 40) = v13;
      *(void *)(v44 + 48) = 0;
      *(void *)(v44 + 56) = 0;
      *(void *)uint64_t v44 = 0;
      *(void *)(v44 + 8) = 0;
      *(void *)(v44 + 16) = v38;
      *BOOL v15 = (uint64_t *)v44;
      uint64_t v45 = **((void **)this + 28);
      uint64_t v46 = (uint64_t *)v44;
      if (v45)
      {
        *((void *)this + 28) = v45;
        uint64_t v46 = *v15;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*((uint64_t **)this + 29), v46);
      ++*((void *)this + 31);
      uint64_t v48 = *a1;
      uint64_t v47 = a1[1];
      if (v47) {
LABEL_57:
      }
        atomic_fetch_add_explicit((atomic_ullong *volatile)v47 + 1, 1uLL, memory_order_relaxed);
    }
    uint64_t v49 = *(std::__shared_weak_count **)(v44 + 56);
    *(void *)(v44 + 48) = v48;
    *(void *)(v44 + 56) = v47;
    if (v49 && !atomic_fetch_add(&v49->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v49->__on_zero_shared)(v49);
      std::__shared_weak_count::__release_weak(v49);
    }
    uint8x8_t v50 = *a1;
    if (!*((unsigned char *)*a1 + 1253)) {
      *((unsigned char *)v50 + 1253) = 1;
    }
    if (*(unsigned char *)(*((void *)this + 1) + 3613)) {
      goto LABEL_64;
    }
    (*(void (**)(md::LabelDedupingGroup **__return_ptr))(**((void **)v50 + 1) + 288))(v139);
    unint64_t v52 = v139[0];
    id v51 = (std::__shared_weak_count *)v139[1];
    if (v139[1] && !atomic_fetch_add((atomic_ullong *volatile)v139[1] + 1, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
      std::__shared_weak_count::__release_weak(v51);
    }
    if (v52)
    {
      uint64_t v53 = *a1;
      (*(void (**)(long long *__return_ptr))(**((void **)*a1 + 1) + 288))(&v138);
      unint64_t v54 = (md::LabelDedupingGroup *)v138;
      unint64_t v55 = 0x9DDFEA08EB382D69 * (((8 * v138) + 8) ^ DWORD1(v138));
      unint64_t v56 = 0x9DDFEA08EB382D69 * (DWORD1(v138) ^ (v55 >> 47) ^ v55);
      unint64_t v57 = v56 ^ (v56 >> 47);
      unint64_t v58 = 0x9DDFEA08EB382D69 * v57;
      unint64_t v59 = *((void *)this + 40);
      if (v59)
      {
        uint8x8_t v60 = (uint8x8_t)vcnt_s8((int8x8_t)v59);
        v60.i16[0] = vaddlv_u8(v60);
        if (v60.u32[0] > 1uLL)
        {
          a3 = 0x9DDFEA08EB382D69 * v57;
          if (v58 >= v59) {
            a3 = v58 % v59;
          }
        }
        else
        {
          a3 = v58 & (v59 - 1);
        }
        size_t v68 = *(void **)(*((void *)this + 39) + 8 * a3);
        if (v68)
        {
          __int16 v69 = (void *)*v68;
          if (v69)
          {
            if (v60.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v71 = v69[1];
                if (v71 == v58)
                {
                  if (v69[2] == (void)v138) {
                    goto LABEL_170;
                  }
                }
                else if ((v71 & (v59 - 1)) != a3)
                {
                  goto LABEL_99;
                }
                __int16 v69 = (void *)*v69;
                if (!v69) {
                  goto LABEL_99;
                }
              }
            }
            do
            {
              unint64_t v70 = v69[1];
              if (v70 == v58)
              {
                if (v69[2] == (void)v138) {
                  goto LABEL_170;
                }
              }
              else
              {
                if (v70 >= v59) {
                  v70 %= v59;
                }
                if (v70 != a3) {
                  break;
                }
              }
              __int16 v69 = (void *)*v69;
            }
            while (v69);
          }
        }
      }
LABEL_99:
      uint64_t v72 = (md::LabelDedupingGroup *)(*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 43)
                                                                                          + 16))(*((void *)this + 43), 32, 8);
      v139[0] = v72;
      v139[1] = (md::LabelPool *)((char *)this + 344);
      *(void *)uint64_t v72 = 0;
      *((void *)v72 + 1) = v58;
      uint64_t v73 = *((void *)&v138 + 1);
      *((void *)v72 + 2) = v138;
      *((void *)v72 + 3) = v73;
      if (v73) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v73 + 8), 1uLL, memory_order_relaxed);
      }
      char v140 = 1;
      float v74 = (float)(unint64_t)(*((void *)this + 44) + 1);
      float v75 = *((float *)this + 90);
      if (v59 && (float)(v75 * (float)v59) >= v74)
      {
LABEL_160:
        uint64_t v106 = *(md::LabelDedupingGroup ***)(*((void *)this + 39) + 8 * a3);
        if (v106)
        {
          *(void *)uint64_t v72 = *v106;
        }
        else
        {
          *(void *)uint64_t v72 = *((void *)this + 42);
          *((void *)this + 42) = v72;
          *(void *)(*((void *)this + 39) + 8 * a3) = (char *)this + 336;
          if (!*(void *)v72)
          {
LABEL_169:
            ++*((void *)this + 44);
            unint64_t v54 = (md::LabelDedupingGroup *)v138;
LABEL_170:
            md::LabelBase::setDedupingGroup(v53, v54);
            unint64_t v108 = (std::__shared_weak_count *)*((void *)&v138 + 1);
            if (!*((void *)&v138 + 1)) {
              goto LABEL_64;
            }
            goto LABEL_171;
          }
          unint64_t v107 = *(void *)(*(void *)v72 + 8);
          if ((v59 & (v59 - 1)) != 0)
          {
            if (v107 >= v59) {
              v107 %= v59;
            }
          }
          else
          {
            v107 &= v59 - 1;
          }
          uint64_t v106 = (md::LabelDedupingGroup **)(*((void *)this + 39) + 8 * v107);
        }
        *uint64_t v106 = v72;
        goto LABEL_169;
      }
      BOOL v76 = 1;
      if (v59 >= 3) {
        BOOL v76 = (v59 & (v59 - 1)) != 0;
      }
      unint64_t v77 = v76 | (2 * v59);
      unint64_t v78 = vcvtps_u32_f32(v74 / v75);
      if (v77 <= v78) {
        size_t prime = v78;
      }
      else {
        size_t prime = v77;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
      }
      unint64_t v59 = *((void *)this + 40);
      if (prime <= v59)
      {
        if (prime >= v59) {
          goto LABEL_147;
        }
        unint64_t v92 = vcvtps_u32_f32((float)*((unint64_t *)this + 44) / *((float *)this + 90));
        if (v59 < 3 || (uint8x8_t v93 = (uint8x8_t)vcnt_s8((int8x8_t)v59), v93.i16[0] = vaddlv_u8(v93), v93.u32[0] > 1uLL))
        {
          unint64_t v92 = std::__next_prime(v92);
        }
        else
        {
          uint64_t v94 = 1 << -(char)__clz(v92 - 1);
          if (v92 >= 2) {
            unint64_t v92 = v94;
          }
        }
        if (prime <= v92) {
          size_t prime = v92;
        }
        if (prime >= v59)
        {
          unint64_t v59 = *((void *)this + 40);
LABEL_147:
          if ((v59 & (v59 - 1)) != 0)
          {
            if (v58 >= v59) {
              a3 = v58 % v59;
            }
            else {
              a3 = v58;
            }
          }
          else
          {
            a3 = (v59 - 1) & v58;
          }
          goto LABEL_160;
        }
        if (!prime)
        {
          uint64_t v109 = *((void *)this + 39);
          *((void *)this + 39) = 0;
          if (v109) {
            (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 41) + 40))(*((void *)this + 41), v109, 8 * *((void *)this + 40));
          }
          unint64_t v59 = 0;
          *((void *)this + 40) = 0;
          goto LABEL_147;
        }
      }
      uint64_t v80 = (*(uint64_t (**)(void, size_t, uint64_t))(**((void **)this + 41) + 16))(*((void *)this + 41), 8 * prime, 8);
      uint64_t v81 = *((void *)this + 39);
      *((void *)this + 39) = v80;
      if (v81) {
        (*(void (**)(void, uint64_t, uint64_t))(**((void **)this + 41) + 40))(*((void *)this + 41), v81, 8 * *((void *)this + 40));
      }
      uint64_t v82 = 0;
      *((void *)this + 40) = prime;
      do
        *(void *)(*((void *)this + 39) + 8 * v82++) = 0;
      while (prime != v82);
      uint64_t v83 = (void *)*((void *)this + 42);
      if (!v83)
      {
LABEL_146:
        unint64_t v59 = prime;
        goto LABEL_147;
      }
      BOOL v84 = (char *)this + 336;
      size_t v85 = v83[1];
      size_t v86 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v87 = v85 & v86;
        *(void *)(*((void *)this + 39) + 8 * v87) = v84;
        for (uint64_t i = (void *)*v83; *v83; uint64_t i = (void *)*v83)
        {
          size_t v89 = i[1] & v86;
          if (v89 == v87)
          {
            uint64_t v83 = i;
          }
          else
          {
            uint64_t v90 = *((void *)this + 39);
            if (*(void *)(v90 + 8 * v89))
            {
              *uint64_t v83 = *i;
              uint64_t v91 = 8 * v89;
              void *i = **(void **)(*((void *)this + 39) + v91);
              **(void **)(*((void *)this + 39) + v91) = i;
            }
            else
            {
              *(void *)(v90 + 8 * v89) = v83;
              uint64_t v83 = i;
              size_t v87 = v89;
            }
          }
        }
        goto LABEL_146;
      }
      if (v85 >= prime) {
        v85 %= prime;
      }
      *(void *)(*((void *)this + 39) + 8 * v85) = v84;
      int8x8_t v102 = (void *)*v83;
      if (!*v83) {
        goto LABEL_146;
      }
      while (1)
      {
        size_t v104 = v102[1];
        if (v104 >= prime) {
          v104 %= prime;
        }
        if (v104 != v85)
        {
          uint64_t v105 = *((void *)this + 39);
          if (!*(void *)(v105 + 8 * v104))
          {
            *(void *)(v105 + 8 * v104) = v83;
            goto LABEL_151;
          }
          *uint64_t v83 = *v102;
          uint64_t v103 = 8 * v104;
          *int8x8_t v102 = **(void **)(*((void *)this + 39) + v103);
          **(void **)(*((void *)this + 39) + v103) = v102;
          int8x8_t v102 = v83;
        }
        size_t v104 = v85;
LABEL_151:
        uint64_t v83 = v102;
        int8x8_t v102 = (void *)*v102;
        size_t v85 = v104;
        if (!v102) {
          goto LABEL_146;
        }
      }
    }
    int v61 = *a1;
    int v62 = *((unsigned __int8 *)*a1 + 38);
    if (v62 == 1)
    {
      unint64_t v95 = *(void *)(*((void *)v61 + 1) + 72);
      unint64_t v137 = v95;
      if (v95)
      {
        v139[0] = 0;
        v139[1] = 0;
        int8x8_t v96 = *(int8x8_t *)((char *)this + 432);
        if (v96)
        {
          uint8x8_t v97 = (uint8x8_t)vcnt_s8(v96);
          v97.i16[0] = vaddlv_u8(v97);
          if (v97.u32[0] > 1uLL)
          {
            unint64_t v98 = v95;
            if (v95 >= *(void *)&v96) {
              unint64_t v98 = v95 % *(void *)&v96;
            }
          }
          else
          {
            unint64_t v98 = (*(void *)&v96 - 1) & v95;
          }
          uint8x8_t v110 = *(void **)(*((void *)this + 53) + 8 * v98);
          if (v110)
          {
            unint64_t v111 = (void *)*v110;
            if (v111)
            {
              if (v97.u32[0] < 2uLL)
              {
                uint64_t v112 = *(void *)&v96 - 1;
                while (1)
                {
                  uint64_t v114 = v111[1];
                  if (v114 == v95)
                  {
                    if (v111[2] == v95) {
                      goto LABEL_235;
                    }
                  }
                  else if ((v114 & v112) != v98)
                  {
                    goto LABEL_199;
                  }
                  unint64_t v111 = (void *)*v111;
                  if (!v111) {
                    goto LABEL_199;
                  }
                }
              }
              do
              {
                unint64_t v113 = v111[1];
                if (v113 == v95)
                {
                  if (v111[2] == v95)
                  {
LABEL_235:
                    std::shared_ptr<ggl::VertexData>::operator=[abi:nn180100]<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4UV>,void>(v139, v111[3], v111[4]);
                    goto LABEL_240;
                  }
                }
                else
                {
                  if (v113 >= *(void *)&v96) {
                    v113 %= *(void *)&v96;
                  }
                  if (v113 != v98) {
                    break;
                  }
                }
                unint64_t v111 = (void *)*v111;
              }
              while (v111);
            }
          }
        }
LABEL_199:
        uint64_t v115 = operator new(0x80uLL);
        v115[1] = 0;
        v115[2] = 0;
        *uint64_t v115 = &unk_1EF581D38;
        uint64_t v116 = md::LabelDedupingGroup::LabelDedupingGroup((md::LabelDedupingGroup *)(v115 + 3));
        v115[3] = &unk_1EF5467B0;
        v115[13] = *((void *)v61 + 1);
        uint64_t v117 = *((void *)v61 + 2);
        v115[14] = v117;
        if (v117) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v117 + 16), 1uLL, memory_order_relaxed);
        }
        *((_DWORD *)v115 + 30) = 0;
        *(void *)&long long v118 = v116;
        *((void *)&v118 + 1) = v115;
        unint64_t v119 = (std::__shared_weak_count *)v139[1];
        *(_OWORD *)unint64_t v139 = v118;
        if (v119 && !atomic_fetch_add(&v119->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v119->__on_zero_shared)(v119);
          std::__shared_weak_count::__release_weak(v119);
        }
        *(void *)&long long v138 = &v137;
        uint64_t v120 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,geo::StdAllocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((float *)this + 106, v137, (uint64_t **)&v138);
        unint64_t v122 = v139[0];
        uint64_t v121 = v139[1];
        if (v139[1]) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)v139[1] + 1, 1uLL, memory_order_relaxed);
        }
        long long v123 = (std::__shared_weak_count *)v120[4];
        v120[3] = v122;
        v120[4] = v121;
        if (v123 && !atomic_fetch_add(&v123->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
LABEL_228:
          ((void (*)(std::__shared_weak_count *))v123->__on_zero_shared)(v123);
          std::__shared_weak_count::__release_weak(v123);
        }
LABEL_240:
        md::LabelBase::setDedupingGroup(*a1, v139[0]);
        unint64_t v108 = (std::__shared_weak_count *)v139[1];
        if (v139[1])
        {
LABEL_171:
          if (!atomic_fetch_add(&v108->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
            std::__shared_weak_count::__release_weak(v108);
          }
        }
      }
    }
    else
    {
      if (v62 != 2)
      {
        if (*((unsigned char *)v61 + 1216))
        {
          uint64_t v99 = (*(uint64_t (**)(void, void))(**((void **)v61 + 1) + 472))(*((void *)v61 + 1), 0);
          uint64_t v100 = v99;
          if (v99)
          {
            if (*(char *)(v99 + 23) < 0 ? *(void *)(v99 + 8) : *(unsigned __int8 *)(v99 + 23))
            {
              v139[0] = 0;
              v139[1] = 0;
              unint64_t v131 = std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::find<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>((void *)this + 32, v99);
              if (v131)
              {
                uint64_t v132 = (md::LabelDedupingGroup *)v131[6];
                unint64_t v133 = (md::LabelDedupingGroup *)v131[7];
                unint64_t v134 = v139;
              }
              else
              {
                _ZNSt3__111make_sharedB8nn180100IN2md23NamedLabelDedupingGroupEJEvEENS_10shared_ptrIT_EEDpOT0_((md::LabelDedupingGroup **)&v138);
                std::shared_ptr<md::LabelFeature>::operator=[abi:nn180100]((uint64_t)v139, &v138);
                std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)&v138);
                *(void *)&long long v138 = v100;
                unint64_t v134 = (md::LabelDedupingGroup **)(std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> const&>,std::tuple<>>((float *)this + 64, v100, (long long **)&v138)+ 6);
                uint64_t v132 = v139[0];
                unint64_t v133 = v139[1];
              }
              std::shared_ptr<ggl::VertexData>::operator=[abi:nn180100]<ggl::VertexDataTyped<ggl::CommonMesh::BufferPos4UV>,void>(v134, (uint64_t)v132, (uint64_t)v133);
              md::LabelBase::setDedupingGroup(v61, v139[0]);
              std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)v139);
            }
          }
        }
        goto LABEL_64;
      }
      unint64_t v63 = (*(uint64_t (**)(void))(**((void **)v61 + 1) + 160))(*((void *)v61 + 1));
      unint64_t v64 = v63;
      unint64_t v137 = v63;
      if (v63)
      {
        v139[0] = 0;
        v139[1] = 0;
        int8x8_t v65 = *(int8x8_t *)((char *)this + 376);
        if (v65)
        {
          uint8x8_t v66 = (uint8x8_t)vcnt_s8(v65);
          v66.i16[0] = vaddlv_u8(v66);
          if (v66.u32[0] > 1uLL)
          {
            unint64_t v67 = v63;
            if (v63 >= *(void *)&v65) {
              unint64_t v67 = v63 % *(void *)&v65;
            }
          }
          else
          {
            unint64_t v67 = (*(void *)&v65 - 1) & v63;
          }
          uint64_t v124 = *(void **)(*((void *)this + 46) + 8 * v67);
          if (v124)
          {
            unint64_t v125 = (void *)*v124;
            if (v125)
            {
              if (v66.u32[0] < 2uLL)
              {
                uint64_t v126 = *(void *)&v65 - 1;
                while (1)
                {
                  uint64_t v128 = v125[1];
                  if (v128 == v63)
                  {
                    if (v125[2] == v63) {
                      goto LABEL_237;
                    }
                  }
                  else if ((v128 & v126) != v67)
                  {
                    goto LABEL_226;
                  }
                  unint64_t v125 = (void *)*v125;
                  if (!v125) {
                    goto LABEL_226;
                  }
                }
              }
              do
              {
                unint64_t v127 = v125[1];
                if (v127 == v63)
                {
                  if (v125[2] == v63)
                  {
LABEL_237:
                    uint64_t v136 = (md::LabelDedupingGroup *)v125[3];
                    uint64_t v135 = (atomic_ullong *)v125[4];
                    if (v135) {
                      atomic_fetch_add_explicit(v135 + 1, 1uLL, memory_order_relaxed);
                    }
                    v139[0] = v136;
                    v139[1] = (md::LabelDedupingGroup *)v135;
                    goto LABEL_240;
                  }
                }
                else
                {
                  if (v127 >= *(void *)&v65) {
                    v127 %= *(void *)&v65;
                  }
                  if (v127 != v67) {
                    break;
                  }
                }
                unint64_t v125 = (void *)*v125;
              }
              while (v125);
            }
          }
        }
LABEL_226:
        uint64_t v129 = (char *)operator new(0x68uLL);
        *((void *)v129 + 1) = 0;
        *((void *)v129 + 2) = 0;
        *(void *)uint64_t v129 = &unk_1EF5823C8;
        *(_OWORD *)(v129 + 24) = 0u;
        *(_OWORD *)(v129 + 40) = 0u;
        *(_OWORD *)(v129 + 56) = 0u;
        *(_OWORD *)(v129 + 72) = 0u;
        *(_OWORD *)(v129 + 88) = 0u;
        md::LabelDedupingGroup::LabelDedupingGroup((md::LabelDedupingGroup *)(v129 + 24));
        *((void *)v129 + 3) = &unk_1EF54A470;
        v139[0] = (md::LabelDedupingGroup *)(v129 + 24);
        v139[1] = (md::LabelDedupingGroup *)v129;
        *(void *)&long long v138 = &v137;
        std::string::size_type v130 = std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,geo::StdAllocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((float *)this + 92, v64, (uint64_t **)&v138);
        atomic_fetch_add_explicit((atomic_ullong *volatile)v129 + 1, 1uLL, memory_order_relaxed);
        long long v123 = (std::__shared_weak_count *)v130[4];
        v130[3] = v129 + 24;
        v130[4] = v129;
        if (!v123 || atomic_fetch_add(&v123->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
          goto LABEL_240;
        }
        goto LABEL_228;
      }
    }
LABEL_64:
    *((unsigned char *)this + 758) = 1;
    return;
  }
  uint64_t v36 = (md::LabelBase *)v16[6];
  uint64_t v35 = v16[7];
  if (v35) {
    atomic_fetch_add_explicit(v35 + 1, 1uLL, memory_order_relaxed);
  }
  *a1 = v36;
  a1[1] = (md::LabelBase *)v35;
}

void sub_1A1A9264C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v5);
  _Unwind_Resume(a1);
}

void md::LabelPool::labelForCustomFeature(void *a1, uint64_t a2, uint64_t a3, void *a4, unsigned int *a5, int a6)
{
  *a1 = 0;
  a1[1] = 0;
  unint64_t v11 = *(void *)(*a4 + 72);
  unsigned int v12 = *a5;
  unsigned int v13 = (std::mutex *)(a2 + 480);
  std::mutex::lock((std::mutex *)(a2 + 480));
  uint64_t v14 = *(void *)(a2 + 552);
  if (!v14) {
    goto LABEL_16;
  }
  uint64_t v15 = a2 + 552;
  do
  {
    unint64_t v16 = *(void *)(v14 + 32);
    BOOL v18 = v16 == v11;
    BOOL v17 = v16 < v11;
    if (v18) {
      BOOL v17 = *(_DWORD *)(v14 + 40) < v12;
    }
    BOOL v18 = !v17;
    if (v17) {
      BOOL v19 = (uint64_t *)(v14 + 8);
    }
    else {
      BOOL v19 = (uint64_t *)v14;
    }
    if (v18) {
      uint64_t v15 = v14;
    }
    uint64_t v14 = *v19;
  }
  while (*v19);
  if (v15 == a2 + 552) {
    goto LABEL_16;
  }
  unint64_t v20 = *(void *)(v15 + 32);
  BOOL v18 = v11 == v20;
  BOOL v21 = v11 < v20;
  if (v18) {
    BOOL v21 = v12 < *(_DWORD *)(v15 + 40);
  }
  if (v21)
  {
LABEL_16:
    BOOL v22 = operator new(0x538uLL);
    v22[1] = 0;
    v22[2] = 0;
    *BOOL v22 = &unk_1EF5829B0;
    md::Label::Label((uint64_t)(v22 + 3), a3, a4, a5);
  }
  uint64_t v24 = *(void *)(v15 + 48);
  uint64_t v23 = *(void *)(v15 + 56);
  if (v23) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v23 + 8), 1uLL, memory_order_relaxed);
  }
  *a1 = v24;
  a1[1] = v23;
  std::mutex::unlock(v13);
  if (a6)
  {
    BOOL v26 = (uint64_t *)(a2 + 232);
    uint64_t v25 = *(void *)(a2 + 232);
    if (v25)
    {
      uint64_t v27 = a2 + 232;
      uint64_t v28 = *(void *)(a2 + 232);
      do
      {
        unint64_t v29 = *(void *)(v28 + 32);
        BOOL v18 = v29 == v11;
        BOOL v30 = v29 < v11;
        if (v18) {
          BOOL v30 = *(_DWORD *)(v28 + 40) < v12;
        }
        BOOL v31 = !v30;
        if (v30) {
          uint64_t v32 = (uint64_t *)(v28 + 8);
        }
        else {
          uint64_t v32 = (uint64_t *)v28;
        }
        if (v31) {
          uint64_t v27 = v28;
        }
        uint64_t v28 = *v32;
      }
      while (*v32);
      if ((uint64_t *)v27 != v26)
      {
        unint64_t v33 = *(void *)(v27 + 32);
        BOOL v34 = v12 < *(_DWORD *)(v27 + 40);
        BOOL v18 = v11 == v33;
        BOOL v35 = v11 < v33;
        if (!v18) {
          BOOL v34 = v35;
        }
        if (!v34) {
          return;
        }
      }
      while (1)
      {
        while (1)
        {
          uint64_t v36 = v25;
          unint64_t v37 = *(void *)(v25 + 32);
          unsigned int v38 = *(_DWORD *)(v36 + 40);
          BOOL v39 = v12 < v38;
          if (v11 != v37) {
            BOOL v39 = v11 < v37;
          }
          if (!v39) {
            break;
          }
          uint64_t v25 = *(void *)v36;
          BOOL v26 = (uint64_t *)v36;
          if (!*(void *)v36) {
            goto LABEL_47;
          }
        }
        BOOL v40 = v38 < v12;
        int v41 = v11 == v37 ? v40 : v37 < v11;
        if (v41 != 1) {
          break;
        }
        uint64_t v25 = *(void *)(v36 + 8);
        if (!v25)
        {
          BOOL v26 = (uint64_t *)(v36 + 8);
          goto LABEL_47;
        }
      }
      uint64_t v42 = v36;
      uint64_t v46 = *a1;
      uint64_t v45 = a1[1];
      if (!v45)
      {
LABEL_51:
        uint64_t v47 = *(std::__shared_weak_count **)(v42 + 56);
        *(void *)(v42 + 48) = v46;
        *(void *)(v42 + 56) = v45;
        if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
          std::__shared_weak_count::__release_weak(v47);
        }
        if (!*(unsigned char *)(*a1 + 1253)) {
          *(unsigned char *)(*a1 + 1253) = 1;
        }
        *(unsigned char *)(a2 + 758) = 1;
        return;
      }
    }
    else
    {
      uint64_t v36 = a2 + 232;
LABEL_47:
      uint64_t v42 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 240) + 16))(*(void *)(a2 + 240), 64, 8);
      *(void *)(v42 + 32) = v11;
      *(_DWORD *)(v42 + 40) = v12;
      *(void *)(v42 + 48) = 0;
      *(void *)(v42 + 56) = 0;
      *(void *)uint64_t v42 = 0;
      *(void *)(v42 + 8) = 0;
      *(void *)(v42 + 16) = v36;
      *BOOL v26 = v42;
      uint64_t v43 = **(void **)(a2 + 224);
      uint64_t v44 = (uint64_t *)v42;
      if (v43)
      {
        *(void *)(a2 + 224) = v43;
        uint64_t v44 = (uint64_t *)*v26;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a2 + 232), v44);
      ++*(void *)(a2 + 248);
      uint64_t v46 = *a1;
      uint64_t v45 = a1[1];
      if (!v45) {
        goto LABEL_51;
      }
    }
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 8), 1uLL, memory_order_relaxed);
    goto LABEL_51;
  }
}

void sub_1A1A92B6C(_Unwind_Exception *a1)
{
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void md::LabelFeature::dedupingGroup(void *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
}

uint64_t md::LabelBase::setDedupingGroup(md::LabelBase *this, md::LabelDedupingGroup *a2)
{
  *((void *)this + 3) = a2;
  uint64_t v4 = (void *)*((void *)a2 + 2);
  unint64_t v5 = *((void *)a2 + 3);
  if ((unint64_t)v4 < v5)
  {
    if (v4) {
      void *v4 = this;
    }
    uint64_t v6 = v4 + 1;
    goto LABEL_27;
  }
  uint64_t v7 = *((void *)a2 + 1);
  uint64_t v8 = ((uint64_t)v4 - v7) >> 3;
  unint64_t v9 = v8 + 1;
  if ((unint64_t)(v8 + 1) >> 61) {
    abort();
  }
  uint64_t v10 = v5 - v7;
  if (v10 >> 2 > v9) {
    unint64_t v9 = v10 >> 2;
  }
  if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v9 = 0x1FFFFFFFFFFFFFFFLL;
  }
  if (v9)
  {
    uint64_t v11 = 8 * v9;
    uint64_t v12 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**((void **)a2 + 4) + 16))(*((void *)a2 + 4), 8 * v9, 8);
    unsigned int v13 = (void *)(v12 + 8 * v8);
    unint64_t v9 = v12 + v11;
    if (v12) {
      *unsigned int v13 = this;
    }
  }
  else
  {
    unsigned int v13 = (void *)(8 * v8);
  }
  uint64_t v6 = v13 + 1;
  uint64_t v15 = *((void *)a2 + 1);
  uint64_t v14 = *((void *)a2 + 2);
  if (v14 != v15)
  {
    unint64_t v16 = v14 - v15 - 8;
    if (v16 < 0x38)
    {
      uint64_t v18 = *((void *)a2 + 2);
    }
    else if ((unint64_t)(v14 - (void)v13) < 0x20)
    {
      uint64_t v18 = *((void *)a2 + 2);
    }
    else
    {
      uint64_t v17 = (v16 >> 3) + 1;
      uint64_t v18 = v14 - 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
      BOOL v19 = v13 - 2;
      unint64_t v20 = (long long *)(v14 - 16);
      uint64_t v21 = v17 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v22 = *v20;
        *(v19 - 1) = *(v20 - 1);
        *BOOL v19 = v22;
        v19 -= 2;
        v20 -= 2;
        v21 -= 4;
      }
      while (v21);
      v13 -= v17 & 0x3FFFFFFFFFFFFFFCLL;
      if (v17 == (v17 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_24;
      }
    }
    do
    {
      uint64_t v23 = *(void *)(v18 - 8);
      v18 -= 8;
      *--unsigned int v13 = v23;
    }
    while (v18 != v15);
LABEL_24:
    uint64_t v14 = *((void *)a2 + 1);
  }
  *((void *)a2 + 1) = v13;
  *((void *)a2 + 2) = v6;
  uint64_t v24 = *((void *)a2 + 3);
  *((void *)a2 + 3) = v9;
  if (v14) {
    (*(void (**)(void, uint64_t, uint64_t))(**((void **)a2 + 4) + 40))(*((void *)a2 + 4), v14, v24 - v14);
  }
LABEL_27:
  *((void *)a2 + 2) = v6;
  uint64_t v25 = *(uint64_t (**)(md::LabelDedupingGroup *, md::LabelBase *))(*(void *)a2 + 40);
  return v25(a2, this);
}

void *std::__hash_table<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,geo::StdAllocator<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(float *a1, unint64_t a2, uint64_t **a3)
{
  unint64_t v7 = *((void *)a1 + 1);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = a2;
      if (v7 <= a2) {
        unint64_t v3 = a2 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & a2;
    }
    unint64_t v9 = *(void ***)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      uint64_t v10 = *v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == a2)
            {
              if (v10[2] == a2) {
                return v10;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_22;
            }
            uint64_t v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == a2)
          {
            if (v10[2] == a2) {
              return v10;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          uint64_t v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_22:
  uint64_t v10 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 4) + 16))(*((void *)a1 + 4), 40, 8);
  void *v10 = 0;
  v10[1] = a2;
  uint64_t v13 = **a3;
  v10[3] = 0;
  v10[4] = 0;
  v10[2] = v13;
  float v14 = (float)(unint64_t)(*((void *)a1 + 5) + 1);
  float v15 = a1[12];
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v7 = *((void *)a1 + 1);
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_58;
      }
      unint64_t v31 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 5) / a1[12]);
      if (v7 < 3 || (uint8x8_t v32 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v32.i16[0] = vaddlv_u8(v32), v32.u32[0] > 1uLL))
      {
        unint64_t v31 = std::__next_prime(v31);
      }
      else
      {
        uint64_t v33 = 1 << -(char)__clz(v31 - 1);
        if (v31 >= 2) {
          unint64_t v31 = v33;
        }
      }
      if (prime <= v31) {
        size_t prime = v31;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *((void *)a1 + 1);
LABEL_58:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v7 <= a2) {
            unint64_t v3 = a2 % v7;
          }
          else {
            unint64_t v3 = a2;
          }
        }
        else
        {
          unint64_t v3 = (v7 - 1) & a2;
        }
        goto LABEL_71;
      }
      if (!prime)
      {
        uint64_t v40 = *(void *)a1;
        *(void *)a1 = 0;
        if (v40) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v40, 8 * *((void *)a1 + 1));
        }
        unint64_t v7 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_58;
      }
    }
    uint64_t v20 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(**((void **)a1 + 2) + 16))(*((void *)a1 + 2), 8 * prime, 8);
    uint64_t v21 = *(void *)a1;
    *(void *)a1 = v20;
    if (v21) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v21, 8 * *((void *)a1 + 1));
    }
    uint64_t v22 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v22++) = 0;
    while (prime != v22);
    uint64_t v24 = (uint64_t *)(a1 + 6);
    uint64_t v23 = (void *)*((void *)a1 + 3);
    if (!v23)
    {
LABEL_57:
      unint64_t v7 = prime;
      goto LABEL_58;
    }
    size_t v25 = v23[1];
    size_t v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v27 = v25 & v26;
      *(void *)(*(void *)a1 + 8 * v27) = v24;
      for (uint64_t i = (void *)*v23; *v23; uint64_t i = (void *)*v23)
      {
        size_t v29 = i[1] & v26;
        if (v29 == v27)
        {
          uint64_t v23 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v29))
        {
          *uint64_t v23 = *i;
          uint64_t v30 = 8 * v29;
          void *i = **(void **)(*(void *)a1 + v30);
          **(void **)(*(void *)a1 + v30) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v29) = v23;
          uint64_t v23 = i;
          size_t v27 = v29;
        }
      }
      goto LABEL_57;
    }
    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v25) = v24;
    BOOL v34 = (void *)*v23;
    if (!*v23) {
      goto LABEL_57;
    }
    while (1)
    {
      size_t v36 = v34[1];
      if (v36 >= prime) {
        v36 %= prime;
      }
      if (v36 != v25)
      {
        if (!*(void *)(*(void *)a1 + 8 * v36))
        {
          *(void *)(*(void *)a1 + 8 * v36) = v23;
          goto LABEL_62;
        }
        *uint64_t v23 = *v34;
        uint64_t v35 = 8 * v36;
        *BOOL v34 = **(void **)(*(void *)a1 + v35);
        **(void **)(*(void *)a1 + v35) = v34;
        BOOL v34 = v23;
      }
      size_t v36 = v25;
LABEL_62:
      uint64_t v23 = v34;
      BOOL v34 = (void *)*v34;
      size_t v25 = v36;
      if (!v34) {
        goto LABEL_57;
      }
    }
  }
LABEL_71:
  unint64_t v37 = *(void **)(*(void *)a1 + 8 * v3);
  if (v37)
  {
    void *v10 = *v37;
LABEL_79:
    *unint64_t v37 = v10;
    goto LABEL_80;
  }
  void *v10 = *((void *)a1 + 3);
  *((void *)a1 + 3) = v10;
  *(void *)(*(void *)a1 + 8 * v3) = a1 + 6;
  if (*v10)
  {
    unint64_t v38 = *(void *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v38 >= v7) {
        v38 %= v7;
      }
    }
    else
    {
      v38 &= v7 - 1;
    }
    unint64_t v37 = (void *)(*(void *)a1 + 8 * v38);
    goto LABEL_79;
  }
LABEL_80:
  ++*((void *)a1 + 5);
  return v10;
}

void sub_1A1A932A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::shared_ptr<md::LabelDedupingGroup>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t md::LabelNavTrafficSupport::externalTrafficIncidentFeatures(md::LabelNavTrafficSupport *this)
{
  return (uint64_t)this + 72;
}

uint64_t non-virtual thunk to'md::MapStandardLabeler::transitSupport(md::MapStandardLabeler *this)
{
  return *((void *)this + 47);
}

uint64_t non-virtual thunk to'md::MapNavLabeler::externalRouteWaypointFeatures(md::MapNavLabeler *this)
{
  return *((void *)this + 7) + 88;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::routeAnnotationFeatures(md::MapNavLabeler *this)
{
  return *((void *)this + 8) + 112;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::externalRouteFeatures(md::MapNavLabeler *this)
{
  return *((void *)this + 7) + 288;
}

uint64_t md::NullARWalkingLabelsStateDelegate::arWalkingStorefrontFeatures(md::NullARWalkingLabelsStateDelegate *this)
{
  return 0;
}

uint64_t md::NullARWalkingLabelsStateDelegate::arWalkingManeuverFeatures(md::NullARWalkingLabelsStateDelegate *this)
{
  return 0;
}

uint64_t md::NullARWalkingLabelsStateDelegate::arWalkingContinueFeatures(md::NullARWalkingLabelsStateDelegate *this)
{
  return 0;
}

uint64_t md::NullARWalkingLabelsStateDelegate::arWalkingArrivalFeatures(md::NullARWalkingLabelsStateDelegate *this)
{
  return 0;
}

void *std::__hash_table<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::__unordered_map_hasher<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,std::__unordered_map_equal<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,std::equal_to<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,std::hash<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>>,true>,geo::StdAllocator<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,mdm::Allocator>>::__emplace_unique_key_args<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::piecewise_construct_t const&,std::tuple<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>> const&>,std::tuple<>>(float *a1, uint64_t a2, long long **a3)
{
  int v6 = *(char *)(a2 + 23);
  if (v6 >= 0) {
    unint64_t v7 = (uint64_t *)a2;
  }
  else {
    unint64_t v7 = *(uint64_t **)a2;
  }
  if (v6 >= 0) {
    unint64_t v8 = *(unsigned __int8 *)(a2 + 23);
  }
  else {
    unint64_t v8 = *(void *)(a2 + 8);
  }
  unint64_t v9 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:nn180100](v7, v8);
  unint64_t v10 = v9;
  unint64_t v11 = *((void *)a1 + 1);
  if (v11)
  {
    uint8x8_t v12 = (uint8x8_t)vcnt_s8((int8x8_t)v11);
    v12.i16[0] = vaddlv_u8(v12);
    if (v12.u32[0] > 1uLL)
    {
      unint64_t v3 = v9;
      if (v9 >= v11) {
        unint64_t v3 = v9 % v11;
      }
    }
    else
    {
      unint64_t v3 = (v11 - 1) & v9;
    }
    uint64_t v13 = *(void **)(*(void *)a1 + 8 * v3);
    if (v13)
    {
      float v14 = (void *)*v13;
      if (*v13)
      {
        if (v12.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v19 = v14[1];
            if (v19 == v10)
            {
              uint64_t v20 = *((unsigned __int8 *)v14 + 39);
              if ((v20 & 0x80u) == 0) {
                uint64_t v21 = *((unsigned __int8 *)v14 + 39);
              }
              else {
                uint64_t v21 = v14[3];
              }
              if (v21 == v8)
              {
                if ((v20 & 0x80) != 0)
                {
                  if (!memcmp((const void *)v14[2], v7, v14[3])) {
                    return v14;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v14 + 39)) {
                    return v14;
                  }
                  uint64_t v22 = 0;
                  while (*((unsigned __int8 *)v14 + v22 + 16) == *((unsigned __int8 *)v7 + v22))
                  {
                    if (v20 == ++v22) {
                      return v14;
                    }
                  }
                }
              }
            }
            else if ((v19 & (v11 - 1)) != v3)
            {
              goto LABEL_49;
            }
            float v14 = (void *)*v14;
            if (!v14) {
              goto LABEL_49;
            }
          }
        }
        do
        {
          unint64_t v15 = v14[1];
          if (v15 == v10)
          {
            uint64_t v16 = *((unsigned __int8 *)v14 + 39);
            if ((v16 & 0x80u) == 0) {
              uint64_t v17 = *((unsigned __int8 *)v14 + 39);
            }
            else {
              uint64_t v17 = v14[3];
            }
            if (v17 == v8)
            {
              if ((v16 & 0x80) != 0)
              {
                if (!memcmp((const void *)v14[2], v7, v14[3])) {
                  return v14;
                }
              }
              else
              {
                if (!*((unsigned char *)v14 + 39)) {
                  return v14;
                }
                uint64_t v18 = 0;
                while (*((unsigned __int8 *)v14 + v18 + 16) == *((unsigned __int8 *)v7 + v18))
                {
                  if (v16 == ++v18) {
                    return v14;
                  }
                }
              }
            }
          }
          else
          {
            if (v15 >= v11) {
              v15 %= v11;
            }
            if (v15 != v3) {
              break;
            }
          }
          float v14 = (void *)*v14;
        }
        while (v14);
      }
    }
  }
LABEL_49:
  uint64_t v23 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 4) + 16))(*((void *)a1 + 4), 64, 8);
  *uint64_t v23 = 0;
  v23[1] = v10;
  uint64_t v24 = (void **)(v23 + 2);
  size_t v25 = *a3;
  v23[5] = *((void *)*a3 + 3);
  if (*((char *)v25 + 23) < 0)
  {
    std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>::__init_copy_ctor_external(v24, *(void **)v25, *((void *)v25 + 1));
  }
  else
  {
    long long v26 = *v25;
    v23[4] = *((void *)v25 + 2);
    *(_OWORD *)uint64_t v24 = v26;
  }
  v23[6] = 0;
  v23[7] = 0;
  float v27 = (float)(unint64_t)(*((void *)a1 + 5) + 1);
  float v28 = a1[12];
  if (!v11 || (float)(v28 * (float)v11) < v27)
  {
    BOOL v29 = 1;
    if (v11 >= 3) {
      BOOL v29 = (v11 & (v11 - 1)) != 0;
    }
    unint64_t v30 = v29 | (2 * v11);
    unint64_t v31 = vcvtps_u32_f32(v27 / v28);
    if (v30 <= v31) {
      size_t prime = v31;
    }
    else {
      size_t prime = v30;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    unint64_t v11 = *((void *)a1 + 1);
    if (prime <= v11)
    {
      if (prime >= v11) {
        goto LABEL_88;
      }
      unint64_t v44 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 5) / a1[12]);
      if (v11 < 3 || (uint8x8_t v45 = (uint8x8_t)vcnt_s8((int8x8_t)v11), v45.i16[0] = vaddlv_u8(v45), v45.u32[0] > 1uLL))
      {
        unint64_t v44 = std::__next_prime(v44);
      }
      else
      {
        uint64_t v46 = 1 << -(char)__clz(v44 - 1);
        if (v44 >= 2) {
          unint64_t v44 = v46;
        }
      }
      if (prime <= v44) {
        size_t prime = v44;
      }
      if (prime >= v11)
      {
        unint64_t v11 = *((void *)a1 + 1);
LABEL_88:
        if ((v11 & (v11 - 1)) != 0)
        {
          if (v10 >= v11) {
            unint64_t v3 = v10 % v11;
          }
          else {
            unint64_t v3 = v10;
          }
        }
        else
        {
          unint64_t v3 = (v11 - 1) & v10;
        }
        goto LABEL_101;
      }
      if (!prime)
      {
        uint64_t v53 = *(void *)a1;
        *(void *)a1 = 0;
        if (v53) {
          (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v53, 8 * *((void *)a1 + 1));
        }
        unint64_t v11 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_88;
      }
    }
    uint64_t v33 = (*(uint64_t (**)(uint64_t, size_t, uint64_t))(**((void **)a1 + 2) + 16))(*((void *)a1 + 2), 8 * prime, 8);
    uint64_t v34 = *(void *)a1;
    *(void *)a1 = v33;
    if (v34) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(**((void **)a1 + 2) + 40))(*((void *)a1 + 2), v34, 8 * *((void *)a1 + 1));
    }
    uint64_t v35 = 0;
    *((void *)a1 + 1) = prime;
    do
      *(void *)(*(void *)a1 + 8 * v35++) = 0;
    while (prime != v35);
    unint64_t v37 = (uint64_t *)(a1 + 6);
    size_t v36 = (void *)*((void *)a1 + 3);
    if (!v36)
    {
LABEL_87:
      unint64_t v11 = prime;
      goto LABEL_88;
    }
    size_t v38 = v36[1];
    size_t v39 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v40 = v38 & v39;
      *(void *)(*(void *)a1 + 8 * v40) = v37;
      for (uint64_t i = (void *)*v36; *v36; uint64_t i = (void *)*v36)
      {
        size_t v42 = i[1] & v39;
        if (v42 == v40)
        {
          size_t v36 = i;
        }
        else if (*(void *)(*(void *)a1 + 8 * v42))
        {
          *size_t v36 = *i;
          uint64_t v43 = 8 * v42;
          void *i = **(void **)(*(void *)a1 + v43);
          **(void **)(*(void *)a1 + v43) = i;
        }
        else
        {
          *(void *)(*(void *)a1 + 8 * v42) = v36;
          size_t v36 = i;
          size_t v40 = v42;
        }
      }
      goto LABEL_87;
    }
    if (v38 >= prime) {
      v38 %= prime;
    }
    *(void *)(*(void *)a1 + 8 * v38) = v37;
    uint64_t v47 = (void *)*v36;
    if (!*v36) {
      goto LABEL_87;
    }
    while (1)
    {
      size_t v49 = v47[1];
      if (v49 >= prime) {
        v49 %= prime;
      }
      if (v49 != v38)
      {
        if (!*(void *)(*(void *)a1 + 8 * v49))
        {
          *(void *)(*(void *)a1 + 8 * v49) = v36;
          goto LABEL_92;
        }
        *size_t v36 = *v47;
        uint64_t v48 = 8 * v49;
        void *v47 = **(void **)(*(void *)a1 + v48);
        **(void **)(*(void *)a1 + v48) = v47;
        uint64_t v47 = v36;
      }
      size_t v49 = v38;
LABEL_92:
      size_t v36 = v47;
      uint64_t v47 = (void *)*v47;
      size_t v38 = v49;
      if (!v47) {
        goto LABEL_87;
      }
    }
  }
LABEL_101:
  uint8x8_t v50 = *(void **)(*(void *)a1 + 8 * v3);
  if (v50)
  {
    *uint64_t v23 = *v50;
    void *v50 = v23;
  }
  else
  {
    *uint64_t v23 = *((void *)a1 + 3);
    *((void *)a1 + 3) = v23;
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 6;
    if (*v23)
    {
      unint64_t v51 = *(void *)(*v23 + 8);
      if ((v11 & (v11 - 1)) != 0)
      {
        if (v51 >= v11) {
          v51 %= v11;
        }
      }
      else
      {
        v51 &= v11 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v51) = v23;
    }
  }
  float v14 = v23;
  ++*((void *)a1 + 5);
  return v14;
}

void sub_1A1A93928(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,void *>,std::__hash_node_destructor<geo::StdAllocator<std::__hash_node<std::__hash_value_type<std::basic_string<char,std::char_traits<char>,geo::StdAllocator<char,mdm::Allocator>>,std::shared_ptr<md::LabelDedupingGroup>>,void *>,mdm::Allocator>>>::~unique_ptr[abi:nn180100]((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<md::LabelFeature>::operator=[abi:nn180100](uint64_t a1, long long *a2)
{
  long long v3 = *a2;
  *(void *)a2 = 0;
  *((void *)a2 + 1) = 0;
  uint64_t v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  return a1;
}

uint64_t std::__function::__func<ggl::AlphaAtlas::AlphaAtlas(unsigned int,BOOL,float,float,ggl::Device *)::$_0,std::allocator<ggl::AlphaAtlas::AlphaAtlas(unsigned int,BOOL,float,float,ggl::Device *)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)v4, *(void *)(*(void *)(a1 + 8) + 24));
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 24))(v2, v4);
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  if (v6) {
    return (*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

uint64_t std::__function::__func<ggl::IsoAlphaAtlas::IsoAlphaAtlas(unsigned int,float,float,ggl::Device *)::$_0,std::allocator<ggl::IsoAlphaAtlas::IsoAlphaAtlas(unsigned int,float,float,ggl::Device *)::$_0>,void ()(ggl::ResourceAccessor *)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a2;
  ggl::Texture2D::vendImplicitLoadItem((ggl::Texture2D *)v4, *(void *)(*(void *)(a1 + 8) + 16));
  (*(void (**)(uint64_t, unsigned char *))(*(void *)v2 + 24))(v2, v4);
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  if (v6) {
    return (*(uint64_t (**)(void))(*v6 + 40))();
  }
  return result;
}

uint64_t ggl::Texture2D::vendImplicitLoadItem(ggl::Texture2D *this, uint64_t a2)
{
  uint64_t v4 = *(void *)(a2 + 112);
  uint64_t v5 = *(void *)(a2 + 80);
  int v6 = operator new(0x20uLL);
  void *v6 = &unk_1EF56B920;
  v6[1] = ggl::Texture2D::onImplicitLoadComplete;
  v6[2] = 0;
  v6[3] = a2;
  *(void *)this = v4;
  *((void *)this + 1) = a2;
  *((unsigned char *)this + 16) = 0;
  *((unsigned char *)this + 20) = 0;
  *(void *)((char *)this + 28) = 0;
  *(void *)((char *)this + 36) = v5;
  __n128 v7 = std::__function::__func<std::__bind<void (ggl::Texture2D::*)(ggl::Texture2DLoadItem const&),ggl::Texture2D*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::Texture2D::*)(ggl::Texture2DLoadItem const&),ggl::Texture2D*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::__clone((uint64_t)v6);
  *((void *)this + 9) = v8;
  return (*(uint64_t (**)(void *, __n128))(*v6 + 40))(v6, v7);
}

__n128 std::__function::__func<std::__bind<void (ggl::Texture2D::*)(ggl::Texture2DLoadItem const&),ggl::Texture2D*,std::placeholders::__ph<1> const&>,std::allocator<std::__bind<void (ggl::Texture2D::*)(ggl::Texture2DLoadItem const&),ggl::Texture2D*,std::placeholders::__ph<1> const&>>,void ()(ggl::Texture2DLoadItem const&)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF56B920;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareSlices>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareSlices>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1A9436C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  if (a17 == v20)
  {
    (*(void (**)(uint64_t *))(a14 + 32))(&a14);
  }
  else if (a17)
  {
    (*(void (**)(void))(*(void *)a17 + 40))();
  }

  (*(void (**)(uint64_t))(*(void *)v18 + 8))(v18);
  (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::UniqueMaterialVisibilityOptionsHandle const&>::Model<ecs2::RuntimeQuery<md::ls::UniqueMaterialVisibilityOptionsHandle const&>>::~Model()
{
}

void ecs2::Query<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>::Model<ecs2::RuntimeQuery<md::ls::MeshRenderableID const&,md::ls::PrimitiveType const&,md::ls::SharedMaterialVisibilityOptionsHandle const*,md::ls::RenderableVisibilityOptions const*,md::ls::MarketMask const*>>::~Model()
{
}

uint64_t md::LabelRenderer::renderLayers(uint64_t result, uint64_t *a2, uint64_t *a3, uint64_t a4, void *a5)
{
  uint64_t v24 = 0;
  int v25 = 0;
  uint64_t v22 = 0;
  int v23 = 0;
  if (a2 != a3)
  {
    __n128 v7 = a3;
    uint64_t v8 = a2;
    uint64_t v9 = result;
    do
    {
      unint64_t v10 = v8;
      if (v8 != v7)
      {
        unint64_t v16 = v7 - v8;
        int v17 = *(char *)(*v8 + 2);
        do
        {
          unint64_t v18 = v16 >> 1;
          uint64_t v19 = &v8[v16 >> 1];
          int v20 = *(char *)(*v19 + 2);
          if (v17 >= v20 && (v17 != v20 || *(float *)(*v10 + 24) <= *(float *)(*v19 + 24)))
          {
            uint64_t v8 = v19 + 1;
            unint64_t v18 = v16 + ~v18;
          }
          unint64_t v16 = v18;
        }
        while (v18);
      }
      uint64_t v24 = 0;
      int v25 = 0;
      uint64_t v22 = 0;
      int v23 = 0;
      if (v10 != v8)
      {
        int v11 = 0;
        uint64_t v12 = 0;
        int v13 = 0;
        uint64_t v14 = 0;
        do
        {
          uint64_t v15 = *v10;
          if (v11
            && (*(unsigned __int8 *)(v12 + 8) != *(unsigned __int8 *)(v15 + 8)
             || *(unsigned __int8 *)(v12 + 4) != *(unsigned __int8 *)(v15 + 4)
             || *(void *)(v12 + 16) != *(void *)(v15 + 16)
             || *(unsigned __int8 *)(v12 + 9) != *(unsigned __int8 *)(v15 + 9)
             || *(unsigned char *)(v12 + 29) != 1
             || *(unsigned char *)(v15 + 29) != 1
             || !*(unsigned char *)(v15 + 10)))
          {
            __n128 result = md::LabelRenderer::addGlyphRenderItem(v9, (unsigned int *)&v24, a4, a5, 1);
            uint64_t v12 = 0;
            int v11 = 0;
            uint64_t v24 = 0;
            int v25 = 0;
          }
          if (v13
            && (*(unsigned __int8 *)(v14 + 8) != *(unsigned __int8 *)(v15 + 8)
             || *(unsigned __int8 *)(v14 + 4) != *(unsigned __int8 *)(v15 + 4)
             || *(void *)(v14 + 16) != *(void *)(v15 + 16)
             || *(unsigned __int8 *)(v14 + 9) != *(unsigned __int8 *)(v15 + 9)
             || *(unsigned char *)(v14 + 29) != 1
             || *(unsigned char *)(v15 + 29) != 1))
          {
            if (*(unsigned char *)(v14 + 28) == 1) {
              __n128 result = md::LabelRenderer::addGlyphRenderItem(v9, (unsigned int *)&v22, a4, a5, 0);
            }
            else {
              __n128 result = md::LabelRenderer::addIconRenderItem(v9, (unsigned int *)&v22, a4, a5);
            }
            uint64_t v14 = 0;
            int v13 = 0;
          }
          if (*(unsigned char *)(v15 + 28) == 1 && *(unsigned char *)(v15 + 10))
          {
            if (!v12) {
              uint64_t v12 = v15;
            }
            uint64_t v24 = v12;
            v11 += *(unsigned __int16 *)(v15 + 32);
            int v25 = v11;
          }
          if (!v14) {
            uint64_t v14 = v15;
          }
          uint64_t v22 = v14;
          v13 += *(unsigned __int16 *)(v15 + 32);
          int v23 = v13;
          ++v10;
        }
        while (v10 != v8);
        if (v11) {
          __n128 result = md::LabelRenderer::addGlyphRenderItem(v9, (unsigned int *)&v24, a4, a5, 1);
        }
        __n128 v7 = a3;
        if (v13)
        {
          if (*(unsigned char *)(v14 + 28) == 1) {
            __n128 result = md::LabelRenderer::addGlyphRenderItem(v9, (unsigned int *)&v22, a4, a5, 0);
          }
          else {
            __n128 result = md::LabelRenderer::addIconRenderItem(v9, (unsigned int *)&v22, a4, a5);
          }
        }
      }
    }
    while (v8 != v7);
  }
  return result;
}

uint64_t md::LabelRenderer::addIconRenderItem(uint64_t a1, unsigned int *a2, uint64_t a3, void *a4)
{
  uint64_t v4 = a2;
  uint64_t v6 = *(void *)(a1 + 16 * *(unsigned int *)(a1 + 1540) + 1552);
  if (!v6) {
    uint64_t v6 = *(void *)(a1 + 1872);
  }
  uint64_t v364 = v6;
  int v7 = *(unsigned __int8 *)(*(void *)a2 + 9);
  uint64_t v8 = a1 + 1456;
  uint64_t v9 = 1456;
  if (!*(unsigned char *)(a3 + 24))
  {
    uint64_t v9 = 1440;
    uint64_t v8 = a1 + 1440;
  }
  if (*(unsigned char *)(*(void *)a2 + 9)) {
    uint64_t v10 = 1424;
  }
  else {
    uint64_t v10 = v9;
  }
  if (*(unsigned char *)(*(void *)a2 + 9)) {
    uint64_t v11 = a1 + 1424;
  }
  else {
    uint64_t v11 = v8;
  }
  uint64_t v12 = *(void *)(a1 + 16);
  uint64_t v13 = *(void *)(*(void *)a2 + 16);
  uint64_t v14 = (std::__shared_mutex_base *)(v12 + 104);
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(v12 + 104));
  uint64_t v15 = *(void *)(v12 + 600);
  if (v13 < (unint64_t)((*(void *)(v12 + 608) - v15) >> 3)
    && ((uint64_t v16 = *(void *)(v15 + 8 * v13)) != 0 ? (v17 = HIDWORD(v13) == HIDWORD(v16)) : (v17 = 0), v17))
  {
    uint64_t v19 = (uint64_t *)(*(void *)(v12 + 624) + 40 * v16);
    unint64_t v18 = *(uint64_t **)(v12 + 632);
  }
  else
  {
    unint64_t v18 = *(uint64_t **)(v12 + 632);
    uint64_t v19 = v18;
  }
  std::__shared_mutex_base::unlock_shared(v14);
  if (v19 == v18 || v19 == 0) {
    uint64_t v21 = 0;
  }
  else {
    uint64_t v21 = *v19;
  }
  int v22 = *(unsigned __int8 *)(*(void *)v4 + 4);
  if (!*(unsigned char *)(*(void *)v4 + 4))
  {
    uint64_t v37 = *(void *)(a1 + 16 * *(unsigned int *)(a1 + 1684) + 1696);
    if (!v37) {
      uint64_t v37 = *(void *)(a1 + 1888);
    }
    int v38 = *(unsigned __int8 *)(a3 + 24);
    uint64_t v39 = *(void *)(a1 + 432);
    uint64_t v40 = *(void *)(v39 + 8);
    if (v40 == *(void *)v39)
    {
      uint64_t v79 = *(void *)(v39 + 88);
      if (!v79) {
        goto LABEL_428;
      }
      long long v26 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v79 + 48))(v79);
      int v41 = *(void **)(v39 + 40);
      unint64_t v80 = *(void *)(v39 + 48);
      if ((unint64_t)v41 >= v80)
      {
        uint64_t v94 = *(void *)(v39 + 32);
        uint64_t v95 = ((uint64_t)v41 - v94) >> 3;
        unint64_t v45 = v95 + 1;
        if ((unint64_t)(v95 + 1) >> 61) {
          goto LABEL_429;
        }
        uint64_t v96 = v80 - v94;
        if (v96 >> 2 > v45) {
          unint64_t v45 = v96 >> 2;
        }
        if ((unint64_t)v96 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v45)
        {
          uint64_t v97 = 8 * v45;
          uint64_t v98 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v39 + 56) + 16))(*(void *)(v39 + 56), 8 * v45, 8);
          size_t v49 = (void *)(v98 + 8 * v95);
          unint64_t v45 = v98 + v97;
          if (v98) {
            *size_t v49 = v26;
          }
        }
        else
        {
          size_t v49 = (void *)(8 * v95);
        }
        uint64_t v81 = v49 + 1;
        uint64_t v154 = *(void *)(v39 + 32);
        uint64_t v119 = *(void *)(v39 + 40);
        if (v119 == v154) {
          goto LABEL_283;
        }
        unint64_t v155 = v119 - v154 - 8;
        if (v155 < 0x38)
        {
          uint64_t v157 = *(void *)(v39 + 40);
        }
        else if ((unint64_t)(v119 - (void)v49) < 0x20)
        {
          uint64_t v157 = *(void *)(v39 + 40);
        }
        else
        {
          uint64_t v156 = (v155 >> 3) + 1;
          uint64_t v157 = v119 - 8 * (v156 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v158 = v49 - 2;
          unint64_t v159 = (long long *)(v119 - 16);
          uint64_t v160 = v156 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v161 = *v159;
            *(v158 - 1) = *(v159 - 1);
            _OWORD *v158 = v161;
            v158 -= 2;
            v159 -= 2;
            v160 -= 4;
          }
          while (v160);
          v49 -= v156 & 0x3FFFFFFFFFFFFFFCLL;
          if (v156 == (v156 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_282;
          }
        }
        do
        {
          uint64_t v237 = *(void *)(v157 - 8);
          v157 -= 8;
          *--size_t v49 = v237;
        }
        while (v157 != v154);
        goto LABEL_282;
      }
    }
    else
    {
      long long v26 = *(void **)(v40 - 8);
      *(void *)(v39 + 8) = v40 - 8;
      int v41 = *(void **)(v39 + 40);
      unint64_t v42 = *(void *)(v39 + 48);
      if ((unint64_t)v41 >= v42)
      {
        uint64_t v43 = *(void *)(v39 + 32);
        uint64_t v44 = ((uint64_t)v41 - v43) >> 3;
        unint64_t v45 = v44 + 1;
        if ((unint64_t)(v44 + 1) >> 61) {
          goto LABEL_429;
        }
        uint64_t v46 = v42 - v43;
        if (v46 >> 2 > v45) {
          unint64_t v45 = v46 >> 2;
        }
        if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v45 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v45)
        {
          uint64_t v47 = 8 * v45;
          uint64_t v48 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v39 + 56) + 16))(*(void *)(v39 + 56), 8 * v45, 8);
          size_t v49 = (void *)(v48 + 8 * v44);
          unint64_t v45 = v48 + v47;
          if (v48) {
            *size_t v49 = v26;
          }
        }
        else
        {
          size_t v49 = (void *)(8 * v44);
        }
        uint64_t v81 = v49 + 1;
        uint64_t v120 = *(void *)(v39 + 32);
        uint64_t v119 = *(void *)(v39 + 40);
        if (v119 == v120) {
          goto LABEL_283;
        }
        unint64_t v121 = v119 - v120 - 8;
        if (v121 < 0x38)
        {
          uint64_t v123 = *(void *)(v39 + 40);
        }
        else if ((unint64_t)(v119 - (void)v49) < 0x20)
        {
          uint64_t v123 = *(void *)(v39 + 40);
        }
        else
        {
          uint64_t v122 = (v121 >> 3) + 1;
          uint64_t v123 = v119 - 8 * (v122 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v124 = v49 - 2;
          unint64_t v125 = (long long *)(v119 - 16);
          uint64_t v126 = v122 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v127 = *v125;
            *(v124 - 1) = *(v125 - 1);
            *uint64_t v124 = v127;
            v124 -= 2;
            v125 -= 2;
            v126 -= 4;
          }
          while (v126);
          v49 -= v122 & 0x3FFFFFFFFFFFFFFCLL;
          if (v122 == (v122 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_282;
          }
        }
        do
        {
          uint64_t v179 = *(void *)(v123 - 8);
          v123 -= 8;
          *--size_t v49 = v179;
        }
        while (v123 != v120);
LABEL_282:
        uint64_t v119 = *(void *)(v39 + 32);
LABEL_283:
        *(void *)(v39 + 32) = v49;
        *(void *)(v39 + 40) = v81;
        uint64_t v238 = *(void *)(v39 + 48);
        *(void *)(v39 + 48) = v45;
        if (v119) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v39 + 56) + 40))(*(void *)(v39 + 56), v119, v238 - v119);
        }
        goto LABEL_285;
      }
    }
    if (v41) {
      *int v41 = v26;
    }
    uint64_t v81 = v41 + 1;
LABEL_285:
    *(void *)(v39 + 40) = v81;
    uint64_t v360 = v37;
    *(void *)&long long v370 = v26;
    uint64_t v239 = *(void *)(v39 + 120);
    if (!v239) {
      goto LABEL_428;
    }
    (*(void (**)(uint64_t, long long *))(*(void *)v239 + 48))(v239, &v370);
    LOWORD(v240) = 1;
    WORD1(v240) = v38 ^ 1;
    int v362 = v7;
    BYTE4(v240) = v7;
    BYTE5(v240) = 1;
    HIWORD(v240) = 1;
    int8x16_t v241 = vceqzq_s8((int8x16_t)v240);
    int16x8_t v242 = vmovl_s8(*(int8x8_t *)v241.i8);
    int32x4_t v243 = vmovl_high_s16(v242);
    v244.i64[0] = v243.u32[2];
    v244.i64[1] = v243.u32[3];
    int8x16_t v245 = v244;
    int16x8_t v246 = vmovl_high_s8(v241);
    int32x4_t v247 = vmovl_high_s16(v246);
    v244.i64[0] = v247.u32[2];
    v244.i64[1] = v247.u32[3];
    int8x16_t v248 = v244;
    int32x4_t v249 = vmovl_s16(*(int16x4_t *)v242.i8);
    v244.i64[0] = v249.u32[2];
    v244.i64[1] = v249.u32[3];
    int8x16_t v250 = v244;
    int32x4_t v251 = vmovl_s16(*(int16x4_t *)v246.i8);
    v244.i64[0] = v251.u32[2];
    v244.i64[1] = v251.u32[3];
    int8x16_t v252 = v244;
    v244.i64[0] = v243.u32[0];
    v244.i64[1] = v243.u32[1];
    int8x16_t v253 = v244;
    v244.i64[0] = v247.u32[0];
    v244.i64[1] = v247.u32[1];
    int8x16_t v254 = v244;
    v244.i64[0] = v249.u32[0];
    v244.i64[1] = v249.u32[1];
    int8x16_t v255 = v244;
    v244.i64[0] = v251.u32[0];
    v244.i64[1] = v251.u32[1];
    unint64_t v256 = vaddvq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v255), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v244)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v253), vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v254))), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v250), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v252)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC980, v245), vbicq_s8((int8x16_t)xmmword_1A28FC990, v248)))));
    unint64_t v257 = v256;
    uint64_t v258 = (uint64_t **)(a1 + 816);
    v259 = *(void **)(a1 + 816);
    if (v259)
    {
      v260 = (uint64_t **)(a1 + 816);
      do
      {
        unint64_t v261 = v259[4];
        BOOL v262 = v261 >= v256;
        if (v261 >= v256) {
          uint64_t v263 = v259;
        }
        else {
          uint64_t v263 = v259 + 1;
        }
        if (v262) {
          v260 = (uint64_t **)v259;
        }
        v259 = (void *)*v263;
      }
      while (*v263);
      if (v260 != v258 && v256 >= (unint64_t)v260[4])
      {
        v271 = (std::__shared_weak_count *)v260[5];
        v272 = (std::__shared_weak_count *)v260[6];
        v369 = v272;
        if (!v272)
        {
          BOOL v273 = 1;
          int v274 = v362;
          if (!v271) {
            goto LABEL_313;
          }
          goto LABEL_312;
        }
        atomic_fetch_add_explicit(&v272->__shared_owners_, 1uLL, memory_order_relaxed);
        BOOL v273 = 0;
        int v274 = v362;
LABEL_310:
        atomic_fetch_add_explicit(&v272->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_311:
        if (!v271) {
          goto LABEL_313;
        }
LABEL_312:
        if (*(void *)v271[1].__shared_weak_owners_ == v26[1])
        {
          v276 = (std::__shared_weak_count *)v26[2];
          if (v276 && v276 != v271) {
            ggl::PipelineSetup::resetData((uint64_t)v26);
          }
          if (!v273) {
            atomic_fetch_add_explicit(&v272->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          v275 = (std::__shared_weak_count *)v26[3];
          v26[2] = v271;
          v26[3] = v272;
          if (!v275) {
            goto LABEL_322;
          }
          goto LABEL_321;
        }
LABEL_313:
        v275 = (std::__shared_weak_count *)v26[3];
        v26[2] = 0;
        v26[3] = 0;
        if (!v275) {
          goto LABEL_322;
        }
LABEL_321:
        if (!atomic_fetch_add(&v275->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          uint64_t v277 = v360;
          ((void (*)(std::__shared_weak_count *))v275->__on_zero_shared)(v275);
          std::__shared_weak_count::__release_weak(v275);
          if (v273) {
            goto LABEL_327;
          }
          goto LABEL_325;
        }
LABEL_322:
        uint64_t v277 = v360;
        if (v273) {
          goto LABEL_327;
        }
LABEL_325:
        if (!atomic_fetch_add(&v272->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v272->__on_zero_shared)(v272);
          std::__shared_weak_count::__release_weak(v272);
        }
LABEL_327:
        if (v369 && !atomic_fetch_add(&v369->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v369->__on_zero_shared)(v369);
          std::__shared_weak_count::__release_weak(v369);
        }
        uint64_t v278 = v26[8];
        *(void *)(v278 + 56) = 0;
        uint64_t v279 = *(void *)(a1 + 1408);
        *(void *)(v278 + 48) = v279;
        uint64_t v280 = v26[20];
        uint64_t v281 = *(void *)(a1 + 1416);
        if (v281) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v281 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v282 = *(std::__shared_weak_count **)(v280 + 56);
        *(void *)(v280 + 48) = v279;
        *(void *)(v280 + 56) = v281;
        if (v282 && !atomic_fetch_add(&v282->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v282->__on_zero_shared)(v282);
          std::__shared_weak_count::__release_weak(v282);
        }
        if (v274)
        {
          uint64_t v283 = (void *)v26[8];
          v283[1] = 0;
          uint64_t v284 = *(void *)(a1 + 1392);
          *uint64_t v283 = v284;
          v285 = (void *)v26[20];
          uint64_t v286 = *(void *)(a1 + 1400);
          if (v286) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v286 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v287 = (std::__shared_weak_count *)v285[1];
          void *v285 = v284;
          v285[1] = v286;
          if (v287 && !atomic_fetch_add(&v287->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v287->__on_zero_shared)(v287);
            std::__shared_weak_count::__release_weak(v287);
          }
        }
        uint64_t v288 = v26[8];
        *(void *)(v288 + 40) = 0;
        uint64_t v289 = *(void *)(a1 + 1496);
        *(void *)(v288 + 32) = v289;
        uint64_t v290 = v26[20];
        uint64_t v291 = *(void *)(a1 + 1504);
        if (v291) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v291 + 8), 1uLL, memory_order_relaxed);
        }
        int v292 = *(std::__shared_weak_count **)(v290 + 40);
        *(void *)(v290 + 32) = v289;
        *(void *)(v290 + 40) = v291;
        if (v292 && !atomic_fetch_add(&v292->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v292->__on_zero_shared)(v292);
          std::__shared_weak_count::__release_weak(v292);
        }
        *(void *)(v26[12] + 8) = v364;
        *(void *)v26[12] = v277;
        uint64_t v293 = v26[8];
        *(void *)(v293 + 24) = 0;
        uint64_t v294 = *(void *)(a1 + 1640);
        *(void *)(v293 + 16) = v294;
        uint64_t v295 = v26[20];
        uint64_t v296 = *(void *)(a1 + 1648);
        if (v296) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v296 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v232 = *(std::__shared_weak_count **)(v295 + 24);
        *(void *)(v295 + 16) = v294;
        *(void *)(v295 + 24) = v296;
        if (v232) {
          goto LABEL_413;
        }
        goto LABEL_415;
      }
    }
    v264 = (std::__shared_weak_count *)operator new(0x198uLL);
    v264->__shared_owners_ = 0;
    v264->__shared_weak_owners_ = 0;
    v264->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF52E450;
    long long v265 = *(_OWORD *)(a1 + 744);
    long long v370 = *(_OWORD *)(a1 + 728);
    long long v371 = v265;
    ggl::Icon::ShadowPipelineState::ShadowPipelineState((uint64_t)&v264[1], (void *)(a1 + 712), a1 + 760, &v370, 1, v38 != 1, 0, v362 != 0, 1, 1);
    v367 = v264 + 1;
    v369 = v264;
    *(void *)&long long v370 = v257;
    *((void *)&v370 + 1) = v264 + 1;
    *(void *)&long long v371 = v264;
    atomic_fetch_add_explicit(&v264->__shared_owners_, 1uLL, memory_order_relaxed);
    v266 = *(uint64_t **)(a1 + 816);
    v267 = (uint64_t **)(a1 + 816);
    if (v266)
    {
      while (1)
      {
        while (1)
        {
          v267 = (uint64_t **)v266;
          unint64_t v268 = v266[4];
          if (v257 >= v268) {
            break;
          }
          v266 = *v267;
          uint64_t v258 = v267;
          if (!*v267) {
            goto LABEL_304;
          }
        }
        if (v268 >= v257) {
          break;
        }
        v266 = v267[1];
        if (!v266)
        {
          uint64_t v258 = v267 + 1;
          goto LABEL_304;
        }
      }
    }
    else
    {
LABEL_304:
      v269 = (uint64_t *)operator new(0x38uLL);
      v269[4] = v257;
      v269[5] = (uint64_t)&v264[1];
      v269[6] = (uint64_t)v264;
      *((void *)&v370 + 1) = 0;
      *(void *)&long long v371 = 0;
      uint64_t *v269 = 0;
      v269[1] = 0;
      v269[2] = (uint64_t)v267;
      void *v258 = v269;
      uint64_t v270 = **(void **)(a1 + 808);
      if (v270)
      {
        *(void *)(a1 + 808) = v270;
        v269 = *v258;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 816), v269);
      ++*(void *)(a1 + 824);
      v264 = (std::__shared_weak_count *)v371;
      if (!(void)v371)
      {
LABEL_309:
        v271 = v367;
        v272 = v369;
        BOOL v273 = v369 == 0;
        int v274 = v362;
        if (!v369) {
          goto LABEL_311;
        }
        goto LABEL_310;
      }
    }
    if (!atomic_fetch_add(&v264->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v264->__on_zero_shared)(v264);
      std::__shared_weak_count::__release_weak(v264);
    }
    goto LABEL_309;
  }
  if (v22 == 9)
  {
    uint64_t v359 = v4;
    uint64_t v50 = *(void *)(a1 + 16 * *(unsigned int *)(a1 + 1684) + 1696);
    if (!v50) {
      uint64_t v50 = *(void *)(a1 + 1888);
    }
    uint64_t v51 = *(void *)(a1 + 440);
    uint64_t v52 = *(void *)(v51 + 8);
    if (v52 == *(void *)v51)
    {
      uint64_t v82 = *(void *)(v51 + 88);
      if (!v82) {
        goto LABEL_428;
      }
      long long v26 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v82 + 48))(v82);
      uint64_t v53 = *(void **)(v51 + 40);
      unint64_t v83 = *(void *)(v51 + 48);
      if ((unint64_t)v53 >= v83)
      {
        uint64_t v99 = *(void *)(v51 + 32);
        uint64_t v100 = ((uint64_t)v53 - v99) >> 3;
        unint64_t v57 = v100 + 1;
        if ((unint64_t)(v100 + 1) >> 61) {
          goto LABEL_429;
        }
        uint64_t v101 = v83 - v99;
        if (v101 >> 2 > v57) {
          unint64_t v57 = v101 >> 2;
        }
        if ((unint64_t)v101 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v57)
        {
          uint64_t v102 = v21;
          uint64_t v103 = 8 * v57;
          uint64_t v104 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v51 + 56) + 16))(*(void *)(v51 + 56), 8 * v57, 8);
          int v62 = (void *)(v104 + 8 * v100);
          unint64_t v57 = v104 + v103;
          if (v104) {
            *int v62 = v26;
          }
          uint64_t v21 = v102;
        }
        else
        {
          int v62 = (void *)(8 * v100);
        }
        BOOL v84 = v62 + 1;
        uint64_t v162 = *(void *)(v51 + 32);
        uint64_t v128 = *(void *)(v51 + 40);
        if (v128 == v162) {
          goto LABEL_358;
        }
        unint64_t v163 = v128 - v162 - 8;
        if (v163 < 0x38)
        {
          uint64_t v165 = *(void *)(v51 + 40);
        }
        else if ((unint64_t)(v128 - (void)v62) < 0x20)
        {
          uint64_t v165 = *(void *)(v51 + 40);
        }
        else
        {
          uint64_t v164 = (v163 >> 3) + 1;
          uint64_t v165 = v128 - 8 * (v164 & 0x3FFFFFFFFFFFFFFCLL);
          float v166 = v62 - 2;
          uint64_t v167 = (long long *)(v128 - 16);
          uint64_t v168 = v164 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v169 = *v167;
            *(v166 - 1) = *(v167 - 1);
            *float v166 = v169;
            v166 -= 2;
            v167 -= 2;
            v168 -= 4;
          }
          while (v168);
          v62 -= v164 & 0x3FFFFFFFFFFFFFFCLL;
          if (v164 == (v164 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_357;
          }
        }
        do
        {
          uint64_t v297 = *(void *)(v165 - 8);
          v165 -= 8;
          *--int v62 = v297;
        }
        while (v165 != v162);
        goto LABEL_357;
      }
    }
    else
    {
      long long v26 = *(void **)(v52 - 8);
      *(void *)(v51 + 8) = v52 - 8;
      uint64_t v53 = *(void **)(v51 + 40);
      unint64_t v54 = *(void *)(v51 + 48);
      if ((unint64_t)v53 >= v54)
      {
        uint64_t v55 = *(void *)(v51 + 32);
        uint64_t v56 = ((uint64_t)v53 - v55) >> 3;
        unint64_t v57 = v56 + 1;
        if ((unint64_t)(v56 + 1) >> 61) {
          goto LABEL_429;
        }
        uint64_t v58 = v54 - v55;
        if (v58 >> 2 > v57) {
          unint64_t v57 = v58 >> 2;
        }
        if ((unint64_t)v58 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v57 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v57)
        {
          uint64_t v59 = v21;
          uint64_t v60 = 8 * v57;
          uint64_t v61 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v51 + 56) + 16))(*(void *)(v51 + 56), 8 * v57, 8);
          int v62 = (void *)(v61 + 8 * v56);
          unint64_t v57 = v61 + v60;
          if (v61) {
            *int v62 = v26;
          }
          uint64_t v21 = v59;
        }
        else
        {
          int v62 = (void *)(8 * v56);
        }
        BOOL v84 = v62 + 1;
        uint64_t v129 = *(void *)(v51 + 32);
        uint64_t v128 = *(void *)(v51 + 40);
        if (v128 == v129) {
          goto LABEL_358;
        }
        unint64_t v130 = v128 - v129 - 8;
        if (v130 < 0x38)
        {
          uint64_t v132 = *(void *)(v51 + 40);
        }
        else if ((unint64_t)(v128 - (void)v62) < 0x20)
        {
          uint64_t v132 = *(void *)(v51 + 40);
        }
        else
        {
          uint64_t v131 = (v130 >> 3) + 1;
          uint64_t v132 = v128 - 8 * (v131 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v133 = v62 - 2;
          unint64_t v134 = (long long *)(v128 - 16);
          uint64_t v135 = v131 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v136 = *v134;
            *(v133 - 1) = *(v134 - 1);
            *unint64_t v133 = v136;
            v133 -= 2;
            v134 -= 2;
            v135 -= 4;
          }
          while (v135);
          v62 -= v131 & 0x3FFFFFFFFFFFFFFCLL;
          if (v131 == (v131 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_357;
          }
        }
        do
        {
          uint64_t v180 = *(void *)(v132 - 8);
          v132 -= 8;
          *--int v62 = v180;
        }
        while (v132 != v129);
LABEL_357:
        uint64_t v128 = *(void *)(v51 + 32);
LABEL_358:
        *(void *)(v51 + 32) = v62;
        *(void *)(v51 + 40) = v84;
        uint64_t v298 = *(void *)(v51 + 48);
        *(void *)(v51 + 48) = v57;
        if (v128) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v51 + 56) + 40))(*(void *)(v51 + 56), v128, v298 - v128);
        }
LABEL_360:
        *(void *)(v51 + 40) = v84;
        *(void *)&long long v370 = v26;
        uint64_t v299 = *(void *)(v51 + 120);
        if (!v299) {
          goto LABEL_428;
        }
        (*(void (**)(uint64_t, long long *))(*(void *)v299 + 48))(v299, &v370);
        *(void *)v26[12] = v21;
        uint64_t v300 = v26[8];
        *(void *)(v300 + 72) = 0;
        uint64_t v301 = *(void *)(a1 + 1408);
        *(void *)(v300 + 64) = v301;
        uint64_t v302 = v26[20];
        uint64_t v303 = *(void *)(a1 + 1416);
        uint64_t v4 = v359;
        if (v303) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v303 + 8), 1uLL, memory_order_relaxed);
        }
        v304 = *(std::__shared_weak_count **)(v302 + 72);
        *(void *)(v302 + 64) = v301;
        *(void *)(v302 + 72) = v303;
        if (v304 && !atomic_fetch_add(&v304->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v304->__on_zero_shared)(v304);
          std::__shared_weak_count::__release_weak(v304);
        }
        v305 = (void *)v26[8];
        v305[1] = 0;
        uint64_t v306 = *(void *)(a1 + 1376);
        void *v305 = v306;
        v307 = (void *)v26[20];
        uint64_t v308 = *(void *)(a1 + 1384);
        if (v308) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v308 + 8), 1uLL, memory_order_relaxed);
        }
        v309 = (std::__shared_weak_count *)v307[1];
        void *v307 = v306;
        v307[1] = v308;
        if (v309 && !atomic_fetch_add(&v309->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v309->__on_zero_shared)(v309);
          std::__shared_weak_count::__release_weak(v309);
        }
        uint64_t v310 = v26[8];
        *(void *)(v310 + 24) = 0;
        uint64_t v311 = *(void *)(a1 + v10);
        *(void *)(v310 + 16) = v311;
        uint64_t v312 = v26[20];
        uint64_t v313 = *(void *)(v11 + 8);
        if (v313) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v313 + 8), 1uLL, memory_order_relaxed);
        }
        v314 = *(std::__shared_weak_count **)(v312 + 24);
        *(void *)(v312 + 16) = v311;
        *(void *)(v312 + 24) = v313;
        if (v314 && !atomic_fetch_add(&v314->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v314->__on_zero_shared)(v314);
          std::__shared_weak_count::__release_weak(v314);
        }
        uint64_t v315 = v26[8];
        *(void *)(v315 + 56) = 0;
        uint64_t v316 = *(void *)(a1 + 1496);
        *(void *)(v315 + 48) = v316;
        uint64_t v317 = v26[20];
        uint64_t v318 = *(void *)(a1 + 1504);
        if (v318) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v318 + 8), 1uLL, memory_order_relaxed);
        }
        v319 = *(std::__shared_weak_count **)(v317 + 56);
        *(void *)(v317 + 48) = v316;
        *(void *)(v317 + 56) = v318;
        if (v319 && !atomic_fetch_add(&v319->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v319->__on_zero_shared)(v319);
          std::__shared_weak_count::__release_weak(v319);
        }
        *(void *)(v26[12] + 16) = v364;
        *(void *)(v26[12] + 8) = v50;
LABEL_410:
        uint64_t v343 = v26[8];
        *(void *)(v343 + 40) = 0;
        uint64_t v344 = *(void *)(a1 + 1640);
        *(void *)(v343 + 32) = v344;
        uint64_t v345 = v26[20];
        uint64_t v346 = *(void *)(a1 + 1648);
        if (v346) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v346 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v232 = *(std::__shared_weak_count **)(v345 + 40);
        *(void *)(v345 + 32) = v344;
        *(void *)(v345 + 40) = v346;
        if (v232) {
          goto LABEL_413;
        }
        goto LABEL_415;
      }
    }
    if (v53) {
      *uint64_t v53 = v26;
    }
    BOOL v84 = v53 + 1;
    goto LABEL_360;
  }
  if (v22 != 7)
  {
    unint64_t v63 = v4;
    uint64_t v64 = *(void *)(a1 + 16 * *(unsigned int *)(a1 + 1684) + 1696);
    if (!v64) {
      uint64_t v64 = *(void *)(a1 + 1888);
    }
    uint64_t v65 = *(void *)(a1 + 448);
    uint64_t v66 = *(void *)(v65 + 8);
    if (v66 == *(void *)v65)
    {
      uint64_t v85 = *(void *)(v65 + 88);
      if (!v85) {
        goto LABEL_428;
      }
      long long v26 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v85 + 48))(v85);
      unint64_t v67 = *(void **)(v65 + 40);
      unint64_t v86 = *(void *)(v65 + 48);
      if ((unint64_t)v67 >= v86)
      {
        uint64_t v105 = *(void *)(v65 + 32);
        uint64_t v106 = ((uint64_t)v67 - v105) >> 3;
        unint64_t v71 = v106 + 1;
        if ((unint64_t)(v106 + 1) >> 61) {
          goto LABEL_429;
        }
        uint64_t v107 = v86 - v105;
        if (v107 >> 2 > v71) {
          unint64_t v71 = v107 >> 2;
        }
        if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v71 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v71)
        {
          uint64_t v108 = 8 * v71;
          uint64_t v109 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v65 + 56) + 16))(*(void *)(v65 + 56), 8 * v71, 8);
          float v75 = (void *)(v109 + 8 * v106);
          unint64_t v71 = v109 + v108;
          if (v109) {
            *float v75 = v26;
          }
        }
        else
        {
          float v75 = (void *)(8 * v106);
        }
        size_t v87 = v75 + 1;
        uint64_t v170 = *(void *)(v65 + 32);
        uint64_t v137 = *(void *)(v65 + 40);
        if (v137 == v170) {
          goto LABEL_386;
        }
        unint64_t v171 = v137 - v170 - 8;
        if (v171 < 0x38)
        {
          uint64_t v173 = *(void *)(v65 + 40);
        }
        else if ((unint64_t)(v137 - (void)v75) < 0x20)
        {
          uint64_t v173 = *(void *)(v65 + 40);
        }
        else
        {
          uint64_t v172 = (v171 >> 3) + 1;
          uint64_t v173 = v137 - 8 * (v172 & 0x3FFFFFFFFFFFFFFCLL);
          unint64_t v174 = v75 - 2;
          uint64_t v175 = (long long *)(v137 - 16);
          uint64_t v176 = v172 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v177 = *v175;
            *(v174 - 1) = *(v175 - 1);
            *unint64_t v174 = v177;
            v174 -= 2;
            v175 -= 2;
            v176 -= 4;
          }
          while (v176);
          v75 -= v172 & 0x3FFFFFFFFFFFFFFCLL;
          if (v172 == (v172 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_385;
          }
        }
        do
        {
          uint64_t v320 = *(void *)(v173 - 8);
          v173 -= 8;
          *--float v75 = v320;
        }
        while (v173 != v170);
        goto LABEL_385;
      }
    }
    else
    {
      long long v26 = *(void **)(v66 - 8);
      *(void *)(v65 + 8) = v66 - 8;
      unint64_t v67 = *(void **)(v65 + 40);
      unint64_t v68 = *(void *)(v65 + 48);
      if ((unint64_t)v67 >= v68)
      {
        uint64_t v69 = *(void *)(v65 + 32);
        uint64_t v70 = ((uint64_t)v67 - v69) >> 3;
        unint64_t v71 = v70 + 1;
        if ((unint64_t)(v70 + 1) >> 61) {
          goto LABEL_429;
        }
        uint64_t v72 = v68 - v69;
        if (v72 >> 2 > v71) {
          unint64_t v71 = v72 >> 2;
        }
        if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v71 = 0x1FFFFFFFFFFFFFFFLL;
        }
        if (v71)
        {
          uint64_t v73 = 8 * v71;
          uint64_t v74 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v65 + 56) + 16))(*(void *)(v65 + 56), 8 * v71, 8);
          float v75 = (void *)(v74 + 8 * v70);
          unint64_t v71 = v74 + v73;
          if (v74) {
            *float v75 = v26;
          }
        }
        else
        {
          float v75 = (void *)(8 * v70);
        }
        size_t v87 = v75 + 1;
        uint64_t v138 = *(void *)(v65 + 32);
        uint64_t v137 = *(void *)(v65 + 40);
        if (v137 == v138) {
          goto LABEL_386;
        }
        unint64_t v139 = v137 - v138 - 8;
        if (v139 < 0x38)
        {
          uint64_t v141 = *(void *)(v65 + 40);
        }
        else if ((unint64_t)(v137 - (void)v75) < 0x20)
        {
          uint64_t v141 = *(void *)(v65 + 40);
        }
        else
        {
          uint64_t v140 = (v139 >> 3) + 1;
          uint64_t v141 = v137 - 8 * (v140 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v142 = v75 - 2;
          long long v143 = (long long *)(v137 - 16);
          uint64_t v144 = v140 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v145 = *v143;
            *(v142 - 1) = *(v143 - 1);
            *uint64_t v142 = v145;
            v142 -= 2;
            v143 -= 2;
            v144 -= 4;
          }
          while (v144);
          v75 -= v140 & 0x3FFFFFFFFFFFFFFCLL;
          if (v140 == (v140 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_385;
          }
        }
        do
        {
          uint64_t v181 = *(void *)(v141 - 8);
          v141 -= 8;
          *--float v75 = v181;
        }
        while (v141 != v138);
LABEL_385:
        uint64_t v137 = *(void *)(v65 + 32);
LABEL_386:
        *(void *)(v65 + 32) = v75;
        *(void *)(v65 + 40) = v87;
        uint64_t v321 = *(void *)(v65 + 48);
        *(void *)(v65 + 48) = v71;
        if (v137) {
          (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v65 + 56) + 40))(*(void *)(v65 + 56), v137, v321 - v137);
        }
LABEL_388:
        *(void *)(v65 + 40) = v87;
        *(void *)&long long v370 = v26;
        uint64_t v322 = *(void *)(v65 + 120);
        if (!v322) {
          goto LABEL_428;
        }
        (*(void (**)(uint64_t, long long *))(*(void *)v322 + 48))(v322, &v370);
        uint64_t v323 = v26[8];
        *(void *)(v323 + 72) = 0;
        uint64_t v324 = *(void *)(a1 + 1408);
        *(void *)(v323 + 64) = v324;
        uint64_t v325 = v26[20];
        uint64_t v326 = *(void *)(a1 + 1416);
        uint64_t v4 = v63;
        if (v326) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v326 + 8), 1uLL, memory_order_relaxed);
        }
        v327 = *(std::__shared_weak_count **)(v325 + 72);
        *(void *)(v325 + 64) = v324;
        *(void *)(v325 + 72) = v326;
        if (v327 && !atomic_fetch_add(&v327->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v327->__on_zero_shared)(v327);
          std::__shared_weak_count::__release_weak(v327);
        }
        v328 = (void *)v26[8];
        v328[1] = 0;
        uint64_t v329 = *(void *)(a1 + 1376);
        void *v328 = v329;
        uint64_t v330 = (void *)v26[20];
        uint64_t v331 = *(void *)(a1 + 1384);
        if (v331) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v331 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v332 = (std::__shared_weak_count *)v330[1];
        *uint64_t v330 = v329;
        v330[1] = v331;
        if (v332 && !atomic_fetch_add(&v332->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v332->__on_zero_shared)(v332);
          std::__shared_weak_count::__release_weak(v332);
        }
        uint64_t v333 = v26[8];
        *(void *)(v333 + 24) = 0;
        uint64_t v334 = *(void *)(a1 + v10);
        *(void *)(v333 + 16) = v334;
        uint64_t v335 = v26[20];
        uint64_t v336 = *(void *)(v11 + 8);
        if (v336) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v336 + 8), 1uLL, memory_order_relaxed);
        }
        v337 = *(std::__shared_weak_count **)(v335 + 24);
        *(void *)(v335 + 16) = v334;
        *(void *)(v335 + 24) = v336;
        if (v337 && !atomic_fetch_add(&v337->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v337->__on_zero_shared)(v337);
          std::__shared_weak_count::__release_weak(v337);
        }
        uint64_t v338 = v26[8];
        *(void *)(v338 + 56) = 0;
        uint64_t v339 = *(void *)(a1 + 1496);
        *(void *)(v338 + 48) = v339;
        uint64_t v340 = v26[20];
        uint64_t v341 = *(void *)(a1 + 1504);
        if (v341) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v341 + 8), 1uLL, memory_order_relaxed);
        }
        v342 = *(std::__shared_weak_count **)(v340 + 56);
        *(void *)(v340 + 48) = v339;
        *(void *)(v340 + 56) = v341;
        if (v342 && !atomic_fetch_add(&v342->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v342->__on_zero_shared)(v342);
          std::__shared_weak_count::__release_weak(v342);
        }
        *(void *)(v26[12] + 8) = v364;
        *(void *)v26[12] = v64;
        goto LABEL_410;
      }
    }
    if (v67) {
      *unint64_t v67 = v26;
    }
    size_t v87 = v67 + 1;
    goto LABEL_388;
  }
  int v23 = *(unsigned __int8 *)(a3 + 24);
  uint64_t v24 = *(void *)(a1 + 424);
  uint64_t v25 = *(void *)(v24 + 8);
  if (v25 != *(void *)v24)
  {
    long long v26 = *(void **)(v25 - 8);
    *(void *)(v24 + 8) = v25 - 8;
    float v27 = *(void **)(v24 + 40);
    unint64_t v28 = *(void *)(v24 + 48);
    if ((unint64_t)v27 >= v28)
    {
      uint64_t v29 = *(void *)(v24 + 32);
      uint64_t v30 = ((uint64_t)v27 - v29) >> 3;
      unint64_t v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 61) {
        goto LABEL_429;
      }
      uint64_t v32 = v28 - v29;
      if (v32 >> 2 > v31) {
        unint64_t v31 = v32 >> 2;
      }
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v31)
      {
        uint64_t v33 = v21;
        uint64_t v34 = 8 * v31;
        uint64_t v35 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v24 + 56) + 16))(*(void *)(v24 + 56), 8 * v31, 8);
        size_t v36 = (void *)(v35 + 8 * v30);
        unint64_t v31 = v35 + v34;
        if (v35) {
          *size_t v36 = v26;
        }
        uint64_t v21 = v33;
      }
      else
      {
        size_t v36 = (void *)(8 * v30);
      }
      unint64_t v78 = v36 + 1;
      uint64_t v111 = *(void *)(v24 + 32);
      uint64_t v110 = *(void *)(v24 + 40);
      if (v110 == v111) {
        goto LABEL_213;
      }
      unint64_t v112 = v110 - v111 - 8;
      if (v112 < 0x38)
      {
        uint64_t v114 = *(void *)(v24 + 40);
      }
      else if ((unint64_t)(v110 - (void)v36) < 0x20)
      {
        uint64_t v114 = *(void *)(v24 + 40);
      }
      else
      {
        uint64_t v113 = (v112 >> 3) + 1;
        uint64_t v114 = v110 - 8 * (v113 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v115 = v36 - 2;
        uint64_t v116 = (long long *)(v110 - 16);
        uint64_t v117 = v113 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v118 = *v116;
          *(v115 - 1) = *(v116 - 1);
          *uint64_t v115 = v118;
          v115 -= 2;
          v116 -= 2;
          v117 -= 4;
        }
        while (v117);
        v36 -= v113 & 0x3FFFFFFFFFFFFFFCLL;
        if (v113 == (v113 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_212;
        }
      }
      do
      {
        uint64_t v178 = *(void *)(v114 - 8);
        v114 -= 8;
        *--size_t v36 = v178;
      }
      while (v114 != v111);
LABEL_212:
      uint64_t v110 = *(void *)(v24 + 32);
LABEL_213:
      *(void *)(v24 + 32) = v36;
      *(void *)(v24 + 40) = v78;
      uint64_t v183 = *(void *)(v24 + 48);
      *(void *)(v24 + 48) = v31;
      if (v110) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v24 + 56) + 40))(*(void *)(v24 + 56), v110, v183 - v110);
      }
      goto LABEL_215;
    }
    goto LABEL_77;
  }
  uint64_t v76 = *(void *)(v24 + 88);
  if (!v76)
  {
LABEL_428:
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_429:
    abort();
  }
  long long v26 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v76 + 48))(v76);
  float v27 = *(void **)(v24 + 40);
  unint64_t v77 = *(void *)(v24 + 48);
  if ((unint64_t)v27 >= v77)
  {
    uint64_t v88 = *(void *)(v24 + 32);
    uint64_t v89 = ((uint64_t)v27 - v88) >> 3;
    unint64_t v31 = v89 + 1;
    if ((unint64_t)(v89 + 1) >> 61) {
      goto LABEL_429;
    }
    uint64_t v90 = v77 - v88;
    if (v90 >> 2 > v31) {
      unint64_t v31 = v90 >> 2;
    }
    if ((unint64_t)v90 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
    }
    if (v31)
    {
      uint64_t v91 = v21;
      uint64_t v92 = 8 * v31;
      uint64_t v93 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v24 + 56) + 16))(*(void *)(v24 + 56), 8 * v31, 8);
      size_t v36 = (void *)(v93 + 8 * v89);
      unint64_t v31 = v93 + v92;
      if (v93) {
        *size_t v36 = v26;
      }
      uint64_t v21 = v91;
    }
    else
    {
      size_t v36 = (void *)(8 * v89);
    }
    unint64_t v78 = v36 + 1;
    uint64_t v146 = *(void *)(v24 + 32);
    uint64_t v110 = *(void *)(v24 + 40);
    if (v110 == v146) {
      goto LABEL_213;
    }
    unint64_t v147 = v110 - v146 - 8;
    if (v147 < 0x38)
    {
      uint64_t v149 = *(void *)(v24 + 40);
    }
    else if ((unint64_t)(v110 - (void)v36) < 0x20)
    {
      uint64_t v149 = *(void *)(v24 + 40);
    }
    else
    {
      uint64_t v148 = (v147 >> 3) + 1;
      uint64_t v149 = v110 - 8 * (v148 & 0x3FFFFFFFFFFFFFFCLL);
      std::string::size_type v150 = v36 - 2;
      v151 = (long long *)(v110 - 16);
      uint64_t v152 = v148 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v153 = *v151;
        *(v150 - 1) = *(v151 - 1);
        _OWORD *v150 = v153;
        v150 -= 2;
        v151 -= 2;
        v152 -= 4;
      }
      while (v152);
      v36 -= v148 & 0x3FFFFFFFFFFFFFFCLL;
      if (v148 == (v148 & 0x3FFFFFFFFFFFFFFCLL)) {
        goto LABEL_212;
      }
    }
    do
    {
      uint64_t v182 = *(void *)(v149 - 8);
      v149 -= 8;
      *--size_t v36 = v182;
    }
    while (v149 != v146);
    goto LABEL_212;
  }
LABEL_77:
  if (v27) {
    void *v27 = v26;
  }
  unint64_t v78 = v27 + 1;
LABEL_215:
  *(void *)(v24 + 40) = v78;
  *(void *)&long long v370 = v26;
  uint64_t v184 = *(void *)(v24 + 120);
  if (!v184) {
    goto LABEL_428;
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v184 + 48))(v184, &v370);
  int v185 = v7 ^ 1;
  LOWORD(v186) = v7 ^ 1;
  WORD1(v186) = v23 ^ 1;
  int v361 = v7;
  WORD2(v186) = v7;
  HIWORD(v186) = 1;
  int8x16_t v187 = vceqzq_s8((int8x16_t)v186);
  int16x8_t v188 = vmovl_s8(*(int8x8_t *)v187.i8);
  int32x4_t v189 = vmovl_high_s16(v188);
  v190.i64[0] = v189.u32[2];
  v190.i64[1] = v189.u32[3];
  int8x16_t v191 = v190;
  int16x8_t v192 = vmovl_high_s8(v187);
  int32x4_t v193 = vmovl_high_s16(v192);
  v190.i64[0] = v193.u32[2];
  v190.i64[1] = v193.u32[3];
  int8x16_t v194 = v190;
  int32x4_t v195 = vmovl_s16(*(int16x4_t *)v188.i8);
  v190.i64[0] = v195.u32[2];
  v190.i64[1] = v195.u32[3];
  int8x16_t v196 = v190;
  int32x4_t v197 = vmovl_s16(*(int16x4_t *)v192.i8);
  v190.i64[0] = v197.u32[2];
  v190.i64[1] = v197.u32[3];
  int8x16_t v198 = v190;
  v190.i64[0] = v189.u32[0];
  v190.i64[1] = v189.u32[1];
  int8x16_t v199 = v190;
  v190.i64[0] = v193.u32[0];
  v190.i64[1] = v193.u32[1];
  int8x16_t v200 = v190;
  v190.i64[0] = v195.u32[0];
  v190.i64[1] = v195.u32[1];
  int8x16_t v201 = v190;
  v190.i64[0] = v197.u32[0];
  v190.i64[1] = v197.u32[1];
  unint64_t v202 = vaddvq_s64((int64x2_t)vorrq_s8(vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC6E0, v201), vbicq_s8((int8x16_t)xmmword_1A28FC9E0, v190)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9C0, v199), vbicq_s8((int8x16_t)xmmword_1A28FC9D0, v200))), vorrq_s8(vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC9A0, v196), vbicq_s8((int8x16_t)xmmword_1A28FC9B0, v198)), vorrq_s8(vbicq_s8((int8x16_t)xmmword_1A28FC980, v191), vbicq_s8((int8x16_t)xmmword_1A28FC990, v194)))));
  unint64_t v203 = v202;
  uint64_t v204 = (uint64_t **)(a1 + 696);
  int v205 = *(void **)(a1 + 696);
  uint64_t v358 = v21;
  if (!v205) {
    goto LABEL_227;
  }
  int v206 = (uint64_t **)(a1 + 696);
  do
  {
    unint64_t v207 = v205[4];
    BOOL v208 = v207 >= v202;
    if (v207 >= v202) {
      unint64_t v209 = v205;
    }
    else {
      unint64_t v209 = v205 + 1;
    }
    if (v208) {
      int v206 = (uint64_t **)v205;
    }
    int v205 = (void *)*v209;
  }
  while (*v209);
  if (v206 == v204 || v202 < (unint64_t)v206[4])
  {
LABEL_227:
    std::string::size_type v210 = (std::__shared_weak_count *)operator new(0x198uLL);
    v210->__shared_weak_owners_ = 0;
    v210->__shared_owners_ = 0;
    v210->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF588E88;
    long long v211 = *(_OWORD *)(a1 + 624);
    long long v370 = *(_OWORD *)(a1 + 608);
    long long v371 = v211;
    ggl::Icon::IconPipelineState::IconPipelineState((uint64_t)&v210[1], (void *)(a1 + 592), a1 + 640, &v370, v185 != 0, v23 != 1, 0, v361 != 0, 0, 1);
    uint64_t v366 = v210 + 1;
    v368 = v210;
    *(void *)&long long v370 = v203;
    *((void *)&v370 + 1) = v210 + 1;
    *(void *)&long long v371 = v210;
    atomic_fetch_add_explicit(&v210->__shared_owners_, 1uLL, memory_order_relaxed);
    v212 = *(uint64_t **)(a1 + 696);
    unint64_t v213 = (uint64_t **)(a1 + 696);
    if (v212)
    {
      while (1)
      {
        while (1)
        {
          unint64_t v213 = (uint64_t **)v212;
          unint64_t v214 = v212[4];
          if (v203 >= v214) {
            break;
          }
          v212 = *v213;
          uint64_t v204 = v213;
          if (!*v213) {
            goto LABEL_234;
          }
        }
        if (v214 >= v203) {
          break;
        }
        v212 = v213[1];
        if (!v212)
        {
          uint64_t v204 = v213 + 1;
          goto LABEL_234;
        }
      }
    }
    else
    {
LABEL_234:
      uint64_t v215 = (uint64_t *)operator new(0x38uLL);
      v215[4] = v203;
      v215[5] = (uint64_t)&v210[1];
      v215[6] = (uint64_t)v210;
      *((void *)&v370 + 1) = 0;
      *(void *)&long long v371 = 0;
      *uint64_t v215 = 0;
      v215[1] = 0;
      v215[2] = (uint64_t)v213;
      *uint64_t v204 = v215;
      uint64_t v216 = **(void **)(a1 + 688);
      if (v216)
      {
        *(void *)(a1 + 688) = v216;
        uint64_t v215 = *v204;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 696), v215);
      ++*(void *)(a1 + 704);
      std::string::size_type v210 = (std::__shared_weak_count *)v371;
      if (!(void)v371)
      {
LABEL_239:
        v217 = v366;
        uint64_t v218 = v368;
        BOOL v219 = v368 == 0;
        int v220 = v361;
        if (!v368) {
          goto LABEL_241;
        }
        goto LABEL_240;
      }
    }
    if (!atomic_fetch_add(&v210->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v210->__on_zero_shared)(v210);
      std::__shared_weak_count::__release_weak(v210);
    }
    goto LABEL_239;
  }
  v217 = (std::__shared_weak_count *)v206[5];
  uint64_t v218 = (std::__shared_weak_count *)v206[6];
  v368 = v218;
  if (!v218)
  {
    BOOL v219 = 1;
    int v220 = v361;
    if (!v217) {
      goto LABEL_243;
    }
    goto LABEL_242;
  }
  atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v219 = 0;
  int v220 = v361;
LABEL_240:
  atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_241:
  if (!v217) {
    goto LABEL_243;
  }
LABEL_242:
  if (*(void *)v217[1].__shared_weak_owners_ == v26[1])
  {
    int v222 = (std::__shared_weak_count *)v26[2];
    if (v222 && v222 != v217) {
      ggl::PipelineSetup::resetData((uint64_t)v26);
    }
    if (!v219) {
      atomic_fetch_add_explicit(&v218->__shared_owners_, 1uLL, memory_order_relaxed);
    }
    uint64_t v221 = (std::__shared_weak_count *)v26[3];
    v26[2] = v217;
    v26[3] = v218;
    if (!v221) {
      goto LABEL_253;
    }
    goto LABEL_251;
  }
LABEL_243:
  uint64_t v221 = (std::__shared_weak_count *)v26[3];
  v26[2] = 0;
  v26[3] = 0;
  if (v221)
  {
LABEL_251:
    if (!atomic_fetch_add(&v221->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v221->__on_zero_shared)(v221);
      std::__shared_weak_count::__release_weak(v221);
    }
  }
LABEL_253:
  if (!v219 && !atomic_fetch_add(&v218->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v218->__on_zero_shared)(v218);
    std::__shared_weak_count::__release_weak(v218);
  }
  if (v368 && !atomic_fetch_add(&v368->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v368->__on_zero_shared)(v368);
    std::__shared_weak_count::__release_weak(v368);
  }
  *(void *)v26[12] = v358;
  uint64_t v223 = v26[8];
  *(void *)(v223 + 40) = 0;
  uint64_t v224 = *(void *)(a1 + 1408);
  *(void *)(v223 + 32) = v224;
  uint64_t v225 = v26[20];
  uint64_t v226 = *(void *)(a1 + 1416);
  if (v226) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v226 + 8), 1uLL, memory_order_relaxed);
  }
  v227 = *(std::__shared_weak_count **)(v225 + 40);
  *(void *)(v225 + 32) = v224;
  *(void *)(v225 + 40) = v226;
  if (v227 && !atomic_fetch_add(&v227->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v227->__on_zero_shared)(v227);
    std::__shared_weak_count::__release_weak(v227);
    __int16 v228 = (void *)v26[8];
    if (v220)
    {
LABEL_264:
      v228[1] = 0;
      uint64_t v229 = *(void *)(a1 + 1392);
      *__int16 v228 = v229;
      char v230 = (void *)v26[20];
      uint64_t v231 = *(void *)(a1 + 1400);
      if (v231) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v231 + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v232 = (std::__shared_weak_count *)v230[1];
      void *v230 = v229;
      v230[1] = v231;
      if (!v232) {
        goto LABEL_415;
      }
LABEL_413:
      if (!atomic_fetch_add(&v232->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v232->__on_zero_shared)(v232);
        std::__shared_weak_count::__release_weak(v232);
      }
      goto LABEL_415;
    }
  }
  else
  {
    __int16 v228 = (void *)v26[8];
    if (v220) {
      goto LABEL_264;
    }
  }
  v228[3] = 0;
  uint64_t v233 = *(void *)(a1 + 1496);
  v228[2] = v233;
  uint64_t v234 = v26[20];
  uint64_t v235 = *(void *)(a1 + 1504);
  if (v235) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v235 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v236 = *(std::__shared_weak_count **)(v234 + 24);
  *(void *)(v234 + 16) = v233;
  *(void *)(v234 + 24) = v235;
  if (v236 && !atomic_fetch_add(&v236->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v236->__on_zero_shared)(v236);
    std::__shared_weak_count::__release_weak(v236);
  }
  *(void *)(v26[12] + 8) = v364;
LABEL_415:
  v347 = (void *)ggl::FragmentedPool<ggl::RenderItem>::pop(*(void *)(a1 + 336));
  uint64_t v348 = *(void *)v4;
  int v349 = *(unsigned __int8 *)(*(void *)v4 + 8);
  if (v349 == 2)
  {
    int v351 = *(unsigned __int8 *)(a3 + 8);
    uint64_t v352 = a4 + 2;
    v353 = a4 + 3;
    goto LABEL_421;
  }
  if (v349 == 1)
  {
    int v351 = *(unsigned __int8 *)(a3 + 8);
    v353 = a4;
    uint64_t v352 = a4 + 1;
LABEL_421:
    if (v351) {
      uint64_t v350 = v352;
    }
    else {
      uint64_t v350 = v353;
    }
    goto LABEL_424;
  }
  if (*(unsigned char *)(*(void *)v4 + 8)) {
    goto LABEL_425;
  }
  uint64_t v350 = a4;
LABEL_424:
  v347[3] = *v350;
LABEL_425:
  v347[4] = v26;
  v347[8] = a1 + 1232;
  uint64_t v354 = *(unsigned __int16 *)(v348 + 38);
  if (*(unsigned char *)(a3 + 25)) {
    v354 += *(unsigned __int16 *)(v348 + 32);
  }
  uint64_t v355 = 6 * v354;
  uint64_t v356 = 6 * (v354 + v4[2]);
  v347[9] = v355;
  v347[10] = v356;
  v347[11] = 0;
  v347[12] = 1;
  uint64_t result = ggl::CommandBuffer::pushRenderItem(*(void *)(a3 + 16), (uint64_t)v347);
  ++*(_DWORD *)(a1 + 1816);
  return result;
}

void sub_1A1A96650(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  md::components::Material::~Material((md::components::Material *)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A1A9666C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  md::components::Material::~Material((md::components::Material *)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::RenderItem>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v17);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v34 = v12 - 2;
        uint64_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)uint64_t v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--uint64_t v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        uint64_t v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *uint64_t v12 = v3;
        }
      }
      else
      {
        uint64_t v12 = (uint64_t *)(8 * v7);
      }
      uint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        long long v26 = v12 - 2;
        float v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)long long v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--uint64_t v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  uint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

uint64_t std::__function::__func<ecs2::ForwardToExecute<md::ita::SetupPredefinedRenderState>,std::allocator<ecs2::ForwardToExecute<md::ita::SetupPredefinedRenderState>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  uint64_t v3 = *(int8x8_t **)(a2 + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::PredefinedRenderState>(v3);
  uint64_t v5 = gdc::Registry::storage<md::ls::RenderItemID>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::NeedsRenderState>(v3);
  gdc::Registry::storage<md::ls::FlyoverInstance>(v3);
  uint64_t v7 = v4 + 4;
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) < v4[8] - v4[7]) {
    uint64_t v7 = (void *)(v5 + 32);
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) < v7[4] - v7[3]) {
    uint64_t v7 = (void *)(v6 + 32);
  }
  uint64_t v66 = v7;
  unint64_t v67 = v4;
  unint64_t v68 = (void *)v5;
  uint64_t v69 = (void *)v6;
  unint64_t v8 = (void *)v7[3];
  uint64_t v9 = (void *)v7[4];
  uint64_t v70 = v8;
  if (v9 != v8
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v66))
  {
    uint64_t v10 = v8 + 1;
    do
    {
      unint64_t v8 = v10;
      uint64_t v70 = v10;
      if (v10 == v9) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v66);
      uint64_t v10 = v8 + 1;
    }
    while (!isValid);
  }
  if (v9 == v8)
  {
    uint64_t result = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v12 = (void *)result;
  }
  else
  {
    uint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    do
    {
      *uint64_t v12 = *v8;
      unint64_t v14 = *v8;
      unint64_t v15 = *v8 >> 39;
      uint64_t v16 = v4[4];
      if (v15 < (v4[5] - v16) >> 3
        && (uint64_t v17 = *(void *)(v16 + 8 * v15)) != 0
        && (unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v14) & 0x7F)),
            uint64_t v20 = v4[7],
            uint64_t v19 = v4[8],
            v18 < (v19 - v20) >> 3)
        && ((unint64_t v21 = HIDWORD(v14), v22 = v20 + 8 * v18, v22 != v19)
          ? (BOOL v23 = *(_DWORD *)(v22 + 4) == v21)
          : (BOOL v23 = 0),
            v23))
      {
        uint64_t v24 = (unsigned __int8 *)(v4[10] + v18);
      }
      else
      {
        uint64_t v24 = (unsigned __int8 *)v4[11];
      }
      uint64_t v25 = **(void **)(v2 + 8);
      long long v26 = *(void **)v25;
      float v27 = *(void **)(v25 + 8);
      if (v26 != v27)
      {
        while (*v26 != 0x41D4E9297E100630)
        {
          v26 += 5;
          if (v26 == v27) {
            goto LABEL_31;
          }
        }
      }
      if (v26 == v27)
      {
LABEL_31:
        uint64_t v29 = 0;
      }
      else
      {
        uint64_t v29 = v26[3];
        uint64_t v28 = (std::__shared_weak_count *)v26[4];
        if (v28)
        {
          atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
      }
      uint64_t v30 = v29 + 8 * *v24;
      unint64_t v31 = *(void *)(v30 + 10520);
      if (!v31)
      {
        uint64_t v32 = v4;
        uint64_t v33 = v12;
        uint64_t v34 = v2;
        uint64_t v35 = v9;
        if (*v24 >= 4u) {
          int v36 = 0;
        }
        else {
          int v36 = *v24;
        }
        long long v37 = *(uint64_t (***)())(v29 + 10504);
        uint64_t v38 = +[VKDebugSettings sharedSettings];
        int v39 = [v38 flyoverSkipTileRendering];

        if (v39)
        {
          uint64_t v40 = v37 + 111;
        }
        else
        {
          switch(v36)
          {
            case 1:
              uint64_t v40 = v37 + 30;
              break;
            case 3:
              uint64_t v40 = v37 + 84;
              break;
            case 2:
              uint64_t v40 = v37 + 57;
              break;
            default:
              uint64_t v40 = v37 + 3;
              break;
          }
        }
        uint64_t v72 = v40;
        unint64_t v31 = geo::packed_array<md::RenderStateStorage,geo::handle<md::RenderStateItem>>::push_back((void *)(v29 + 728), &v72);
        *(int64x2_t *)float v75 = vdupq_n_s64(1uLL);
        v75[16] = 1;
        std::__hash_table<std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::RenderStateItem>,std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::hash<geo::handle<md::RenderStateItem>>,std::equal_to<geo::handle<md::RenderStateItem>>,true>,std::__unordered_map_equal<geo::handle<md::RenderStateItem>,std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::equal_to<geo::handle<md::RenderStateItem>>,std::hash<geo::handle<md::RenderStateItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::RenderStateItem>,geo::handle<md::RenderStateItem> const&,md::Counter>(v29 + 688, v31, v31, (uint64_t)v75);
        *(void *)(v30 + 10520) = v31;
        uint64_t v9 = v35;
        uint64_t v2 = v34;
        uint64_t v12 = v33;
        uint64_t v4 = v32;
      }
      uint64_t v41 = *(void **)(v2 + 8);
      uint64_t v42 = *v12;
      uint64_t v72 = &off_1EF521B30;
      *(void *)&long long v73 = v31;
      *((void *)&v73 + 1) = v42;
      uint64_t v74 = &v72;
      uint64_t v76 = v75;
      *(void *)float v75 = &off_1EF521B30;
      *(_OWORD *)&v75[8] = v73;
      int v77 = 0;
      ecs2::Runtime::queueCommand(v41, (uint64_t)v75);
      if (v77 != -1) {
        ((void (*)(char *, unsigned char *))off_1EF58FE68[v77])(&v71, v75);
      }
      int v77 = -1;
      uint64_t result = (uint64_t)v74;
      if (v74 == &v72)
      {
        uint64_t result = ((uint64_t (*)(uint64_t (***)()))v72[4])(&v72);
      }
      else if (v74)
      {
        uint64_t result = (*v74)[5]();
      }
      unint64_t v8 = (void *)v66[4];
      uint64_t v13 = v70 + 1;
      uint64_t v70 = v13;
      if (v13 != v8)
      {
        uint64_t v44 = v67[4];
        while (1)
        {
          unint64_t v45 = *((unsigned int *)v13 + 1);
          unint64_t v46 = v45 >> 7;
          if (v45 >> 7 < (v67[5] - v44) >> 3)
          {
            uint64_t v47 = *(void *)(v44 + 8 * v46);
            if (v47)
            {
              uint64_t v48 = v45 & 0x7F;
              unint64_t v49 = *(unsigned __int16 *)(v47 + 2 * v48);
              uint64_t v50 = v67[7];
              uint64_t result = v67[8];
              if (v49 < (result - v50) >> 3)
              {
                uint64_t v51 = v50 + 8 * v49;
                if (v51 != result && *(_DWORD *)(v51 + 4) == v45)
                {
                  uint64_t v53 = v68[4];
                  uint64_t result = v68[5] - v53;
                  if (v46 < result >> 3)
                  {
                    uint64_t v54 = *(void *)(v53 + 8 * v46);
                    if (v54)
                    {
                      unint64_t v55 = *(unsigned __int16 *)(v54 + 2 * v48);
                      uint64_t v56 = v68[7];
                      uint64_t result = v68[8];
                      if (v55 < (result - v56) >> 3)
                      {
                        uint64_t v57 = v56 + 8 * v55;
                        if (v57 != result && *(_DWORD *)(v57 + 4) == v45)
                        {
                          uint64_t v59 = v69[4];
                          uint64_t result = v69[5] - v59;
                          if (v46 < result >> 3)
                          {
                            uint64_t v60 = *(void *)(v59 + 8 * v46);
                            if (v60)
                            {
                              unint64_t v61 = *(unsigned __int16 *)(v60 + 2 * v48);
                              uint64_t v63 = v69[7];
                              uint64_t v62 = v69[8];
                              uint64_t result = v62 - v63;
                              if (v61 < (v62 - v63) >> 3)
                              {
                                uint64_t v64 = v63 + 8 * v61;
                                if (*(_DWORD *)(v64 + 4) == v45 && v64 != v62) {
                                  break;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (++v13 == v8)
          {
            uint64_t v13 = v8;
            goto LABEL_13;
          }
        }
        unint64_t v8 = v13;
LABEL_13:
        uint64_t v70 = v13;
      }
    }
    while (v9 != v8);
  }
  *uint64_t v12 = 0xFFFFFFFF00000000;
  *(void *)(v2 + 8) = 0;
  return result;
}

void sub_1A1A96F68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::PredefinedRenderState>(int8x8_t *a1)
{
  unint64_t v10 = 0xCB8AA7FBA6BCD25CLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xCB8AA7FBA6BCD25CLL;
    if (*(void *)&v1 <= 0xCB8AA7FBA6BCD25CLL) {
      unint64_t v3 = 0xCB8AA7FBA6BCD25CLL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xCB8AA7FBA6BCD25CLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xCB8AA7FBA6BCD25CLL)
      {
        if (v5[2] == 0xCB8AA7FBA6BCD25CLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xCB8AA7FBA6BCD25CLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xCB8AA7FBA6BCD25CLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A971BC(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

unint64_t std::__function::__func<ecs2::ForwardToExecute<md::ita::SetupRenderStatesForSeeThrough>,std::allocator<ecs2::ForwardToExecute<md::ita::SetupRenderStatesForSeeThrough>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  unint64_t v3 = *(int8x8_t **)(a2 + 8);
  uint64_t v4 = gdc::Registry::storage<md::ls::IntendedSceneLayerType<(md::SceneLayer)3>>(v3);
  uint64_t v5 = gdc::Registry::storage<md::ls::MainPassItem>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::IsTransparent>(v3);
  uint64_t v7 = gdc::Registry::storage<md::ls::NeedsRenderState>(v3);
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) >= *(void *)(v4 + 64) - *(void *)(v4 + 56)) {
    uint64_t v8 = v4;
  }
  else {
    uint64_t v8 = v5;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) < *(void *)(v8 + 64) - *(void *)(v8 + 56)) {
    uint64_t v8 = v6;
  }
  if (*(void *)(v7 + 64) - *(void *)(v7 + 56) < *(void *)(v8 + 64) - *(void *)(v8 + 56)) {
    uint64_t v8 = v7;
  }
  uint64_t v42 = v8 + 32;
  uint64_t v43 = (void *)v4;
  uint64_t v44 = (void *)v5;
  unint64_t v45 = (void *)v6;
  uint64_t v9 = *(void **)(v8 + 56);
  unint64_t v10 = *(void **)(v8 + 64);
  unint64_t v46 = (void *)v7;
  uint64_t v47 = v9;
  if (v10 != v9
    && !gdc::RegistryQueryView<gdc::All<md::ls::RequiresShaderTextureID<Flyover::NightTexture> const,md::ls::TextureHandleForType<Flyover::NightTexture> const,md::ls::FlyoverInstance const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v42))
  {
    uint64_t v11 = v9 + 1;
    do
    {
      uint64_t v9 = v11;
      uint64_t v47 = v11;
      if (v11 == v10) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RequiresShaderTextureID<Flyover::NightTexture> const,md::ls::TextureHandleForType<Flyover::NightTexture> const,md::ls::FlyoverInstance const,md::ls::PipelineSetup>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v42);
      uint64_t v11 = v9 + 1;
    }
    while (!isValid);
  }
  unint64_t result = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  unint64_t v14 = (uint64_t *)result;
  while (v10 != v9)
  {
    *unint64_t v14 = *v9;
    uint64_t v16 = **(void **)(a1 + 8);
    uint64_t v17 = *(void **)v16;
    unint64_t v18 = *(void **)(v16 + 8);
    if (v17 != v18)
    {
      while (*v17 != 0x41D4E9297E100630)
      {
        v17 += 5;
        if (v17 == v18) {
          goto LABEL_27;
        }
      }
    }
    if (v17 == v18)
    {
LABEL_27:
      uint64_t v20 = 0;
      unint64_t v21 = MEMORY[0x2938];
      if (!MEMORY[0x2938]) {
        goto LABEL_28;
      }
    }
    else
    {
      uint64_t v20 = (void *)v17[3];
      uint64_t v19 = (std::__shared_weak_count *)v17[4];
      if (v19)
      {
        atomic_fetch_add_explicit(&v19->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
          std::__shared_weak_count::__release_weak(v19);
          unint64_t v21 = v20[1319];
          if (v21) {
            goto LABEL_29;
          }
LABEL_28:
          unint64_t v49 = (uint64_t (**)())(v20[1312] + 2208);
          unint64_t v21 = geo::packed_array<md::RenderStateStorage,geo::handle<md::RenderStateItem>>::push_back(v20 + 91, &v49);
          *(int64x2_t *)uint64_t v52 = vdupq_n_s64(1uLL);
          v52[16] = 1;
          std::__hash_table<std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::RenderStateItem>,std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::hash<geo::handle<md::RenderStateItem>>,std::equal_to<geo::handle<md::RenderStateItem>>,true>,std::__unordered_map_equal<geo::handle<md::RenderStateItem>,std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::equal_to<geo::handle<md::RenderStateItem>>,std::hash<geo::handle<md::RenderStateItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::RenderStateItem>,geo::handle<md::RenderStateItem> const&,md::Counter>((uint64_t)(v20 + 86), v21, v21, (uint64_t)v52);
          v20[1319] = v21;
          goto LABEL_29;
        }
      }
      unint64_t v21 = v20[1319];
      if (!v21) {
        goto LABEL_28;
      }
    }
LABEL_29:
    uint64_t v22 = *(void **)(a1 + 8);
    uint64_t v23 = *v14;
    unint64_t v49 = &off_1EF521B30;
    *(void *)&long long v50 = v21;
    *((void *)&v50 + 1) = v23;
    uint64_t v51 = &v49;
    uint64_t v53 = v52;
    *(void *)uint64_t v52 = &off_1EF521B30;
    *(_OWORD *)&v52[8] = v50;
    int v54 = 0;
    ecs2::Runtime::queueCommand(v22, (uint64_t)v52);
    if (v54 != -1) {
      ((void (*)(char *, unsigned char *))off_1EF58FE68[v54])(&v48, v52);
    }
    int v54 = -1;
    unint64_t result = (unint64_t)v51;
    if (v51 == &v49)
    {
      unint64_t result = ((uint64_t (*)(uint64_t (***)()))v49[4])(&v49);
    }
    else if (v51)
    {
      unint64_t result = (*v51)[5]();
    }
    uint64_t v9 = *(void **)(v42 + 32);
    unint64_t v15 = v47 + 1;
    uint64_t v47 = v15;
    if (v15 != v9)
    {
      uint64_t v24 = v43[4];
      while (1)
      {
        unint64_t v25 = *((unsigned int *)v15 + 1);
        unint64_t v26 = v25 >> 7;
        if (v25 >> 7 < (v43[5] - v24) >> 3)
        {
          unint64_t result = *(void *)(v24 + 8 * v26);
          if (result)
          {
            uint64_t v27 = v25 & 0x7F;
            unint64_t result = *(unsigned __int16 *)(result + 2 * v27);
            uint64_t v29 = v43[7];
            uint64_t v28 = v43[8];
            if (result < (v28 - v29) >> 3)
            {
              unint64_t result = v29 + 8 * result;
              if (result != v28 && *(_DWORD *)(result + 4) == v25)
              {
                unint64_t result = v44[4];
                if (v26 < (uint64_t)(v44[5] - result) >> 3)
                {
                  unint64_t result = *(void *)(result + 8 * v26);
                  if (result)
                  {
                    unint64_t result = *(unsigned __int16 *)(result + 2 * v27);
                    uint64_t v32 = v44[7];
                    uint64_t v31 = v44[8];
                    if (result < (v31 - v32) >> 3)
                    {
                      unint64_t result = v32 + 8 * result;
                      if (result != v31 && *(_DWORD *)(result + 4) == v25)
                      {
                        unint64_t result = v45[4];
                        if (v26 < (uint64_t)(v45[5] - result) >> 3)
                        {
                          unint64_t result = *(void *)(result + 8 * v26);
                          if (result)
                          {
                            unint64_t result = *(unsigned __int16 *)(result + 2 * v27);
                            uint64_t v35 = v45[7];
                            uint64_t v34 = v45[8];
                            if (result < (v34 - v35) >> 3)
                            {
                              unint64_t result = v35 + 8 * result;
                              if (result != v34 && *(_DWORD *)(result + 4) == v25)
                              {
                                unint64_t result = v46[4];
                                if (v26 < (uint64_t)(v46[5] - result) >> 3)
                                {
                                  uint64_t v37 = *(void *)(result + 8 * v26);
                                  if (v37)
                                  {
                                    unint64_t v38 = *(unsigned __int16 *)(v37 + 2 * v27);
                                    unint64_t result = v46[7];
                                    uint64_t v39 = v46[8];
                                    if (v38 < (uint64_t)(v39 - result) >> 3)
                                    {
                                      unint64_t v40 = result + 8 * v38;
                                      unint64_t result = *(unsigned int *)(v40 + 4);
                                      if (result == v25 && v40 != v39) {
                                        break;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (++v15 == v9)
        {
          unint64_t v15 = v9;
          goto LABEL_16;
        }
      }
      uint64_t v9 = v15;
LABEL_16:
      uint64_t v47 = v15;
    }
  }
  *unint64_t v14 = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::MainPassItem>(int8x8_t *a1)
{
  unint64_t v10 = 0xDB4F0ABC43345F6ALL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xDB4F0ABC43345F6ALL;
    if (*(void *)&v1 <= 0xDB4F0ABC43345F6ALL) {
      unint64_t v3 = 0xDB4F0ABC43345F6ALL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xDB4F0ABC43345F6ALL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xDB4F0ABC43345F6ALL)
      {
        if (v5[2] == 0xDB4F0ABC43345F6ALL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xDB4F0ABC43345F6ALL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xDB4F0ABC43345F6ALL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A97904(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<ecs2::ForwardToExecute<md::ita::SetupCustomRenderState>,std::allocator<ecs2::ForwardToExecute<md::ita::SetupCustomRenderState>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  unint64_t v3 = *(int8x8_t **)(a2 + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::CustomRenderState>(v3);
  uint64_t v5 = gdc::Registry::storage<md::ls::IntendedSceneLayerType<(md::SceneLayer)4>>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::NeedsRenderState>(v3);
  unint64_t v7 = v4 + 4;
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) < v4[8] - v4[7]) {
    unint64_t v7 = (void *)(v5 + 32);
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) < v7[4] - v7[3]) {
    unint64_t v7 = (void *)(v6 + 32);
  }
  uint64_t v59 = v7;
  uint64_t v60 = v4;
  unint64_t v61 = (void *)v5;
  uint64_t v62 = (void *)v6;
  uint64_t v8 = (void *)v7[3];
  uint64_t v9 = (void *)v7[4];
  uint64_t v63 = v8;
  if (v9 != v8
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v59))
  {
    unint64_t v10 = v8 + 1;
    do
    {
      uint64_t v8 = v10;
      uint64_t v63 = v10;
      if (v10 == v9) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v59);
      unint64_t v10 = v8 + 1;
    }
    while (!isValid);
  }
  if (v9 == v8)
  {
    uint64_t result = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v12 = (uint64_t *)result;
  }
  else
  {
    uint64_t v12 = (uint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    do
    {
      *uint64_t v12 = *v8;
      unint64_t v14 = *v8;
      unint64_t v15 = *v8 >> 39;
      uint64_t v16 = v4[4];
      if (v15 < (v4[5] - v16) >> 3
        && (uint64_t v17 = *(void *)(v16 + 8 * v15)) != 0
        && (unint64_t v18 = *(unsigned __int16 *)(v17 + 2 * (HIDWORD(v14) & 0x7F)),
            uint64_t v20 = v4[7],
            uint64_t v19 = v4[8],
            v18 < (v19 - v20) >> 3)
        && ((unint64_t v21 = HIDWORD(v14), v22 = v20 + 8 * v18, v22 != v19)
          ? (BOOL v23 = *(_DWORD *)(v22 + 4) == v21)
          : (BOOL v23 = 0),
            v23))
      {
        uint64_t v24 = v4[11];
        uint64_t v25 = v4[10] + 24 * v18;
      }
      else
      {
        uint64_t v24 = v4[11];
        uint64_t v25 = v24;
      }
      if (v25 == v24) {
        uint64_t v26 = 0;
      }
      else {
        uint64_t v26 = v25;
      }
      uint64_t v27 = **(void **)(a1 + 8);
      uint64_t v28 = *(void **)v27;
      uint64_t v29 = *(void **)(v27 + 8);
      if (v28 != v29)
      {
        while (*v28 != 0x41D4E9297E100630)
        {
          v28 += 5;
          if (v28 == v29) {
            goto LABEL_34;
          }
        }
      }
      if (v28 == v29)
      {
LABEL_34:
        uint64_t v30 = 0;
      }
      else
      {
        uint64_t v30 = v28[3];
        uint64_t v31 = (std::__shared_weak_count *)v28[4];
        if (v31)
        {
          atomic_fetch_add_explicit(&v31->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v31->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v31->__on_zero_shared)(v31);
            std::__shared_weak_count::__release_weak(v31);
          }
        }
      }
      uint64_t v32 = *(void *)v26;
      if (*(unsigned char *)(v26 + 17)) {
        *(unsigned char *)(v32 + 208) = 1;
      }
      uint64_t v65 = (uint64_t (**)())v32;
      unint64_t v33 = geo::packed_array<md::RenderStateStorage,geo::handle<md::RenderStateItem>>::push_back((void *)(v30 + 728), &v65);
      *(int64x2_t *)unint64_t v68 = vdupq_n_s64(1uLL);
      v68[16] = 1;
      std::__hash_table<std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::RenderStateItem>,std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::hash<geo::handle<md::RenderStateItem>>,std::equal_to<geo::handle<md::RenderStateItem>>,true>,std::__unordered_map_equal<geo::handle<md::RenderStateItem>,std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>,std::equal_to<geo::handle<md::RenderStateItem>>,std::hash<geo::handle<md::RenderStateItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::RenderStateItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::RenderStateItem>,geo::handle<md::RenderStateItem> const&,md::Counter>(v30 + 688, v33, v33, (uint64_t)v68);
      uint64_t v34 = *(void **)(a1 + 8);
      uint64_t v35 = *v12;
      uint64_t v65 = &off_1EF521B30;
      *(void *)&long long v66 = v33;
      *((void *)&v66 + 1) = v35;
      unint64_t v67 = &v65;
      uint64_t v69 = v68;
      *(void *)unint64_t v68 = &off_1EF521B30;
      *(_OWORD *)&v68[8] = v66;
      int v70 = 0;
      ecs2::Runtime::queueCommand(v34, (uint64_t)v68);
      if (v70 != -1) {
        ((void (*)(char *, unsigned char *))off_1EF58FE68[v70])(&v64, v68);
      }
      int v70 = -1;
      uint64_t result = (uint64_t)v67;
      if (v67 == &v65)
      {
        uint64_t result = ((uint64_t (*)(uint64_t (***)()))v65[4])(&v65);
      }
      else if (v67)
      {
        uint64_t result = (*v67)[5]();
      }
      uint64_t v8 = (void *)v59[4];
      uint64_t v13 = v63 + 1;
      uint64_t v63 = v13;
      if (v13 != v8)
      {
        uint64_t v37 = v60[4];
        while (1)
        {
          unint64_t v38 = *((unsigned int *)v13 + 1);
          unint64_t v39 = v38 >> 7;
          if (v38 >> 7 < (v60[5] - v37) >> 3)
          {
            uint64_t v40 = *(void *)(v37 + 8 * v39);
            if (v40)
            {
              uint64_t v41 = v38 & 0x7F;
              unint64_t v42 = *(unsigned __int16 *)(v40 + 2 * v41);
              uint64_t v43 = v60[7];
              uint64_t result = v60[8];
              if (v42 < (result - v43) >> 3)
              {
                uint64_t v44 = v43 + 8 * v42;
                if (v44 != result && *(_DWORD *)(v44 + 4) == v38)
                {
                  uint64_t v46 = v61[4];
                  uint64_t result = v61[5] - v46;
                  if (v39 < result >> 3)
                  {
                    uint64_t v47 = *(void *)(v46 + 8 * v39);
                    if (v47)
                    {
                      unint64_t v48 = *(unsigned __int16 *)(v47 + 2 * v41);
                      uint64_t v49 = v61[7];
                      uint64_t result = v61[8];
                      if (v48 < (result - v49) >> 3)
                      {
                        uint64_t v50 = v49 + 8 * v48;
                        if (v50 != result && *(_DWORD *)(v50 + 4) == v38)
                        {
                          uint64_t v52 = v62[4];
                          uint64_t result = v62[5] - v52;
                          if (v39 < result >> 3)
                          {
                            uint64_t v53 = *(void *)(v52 + 8 * v39);
                            if (v53)
                            {
                              unint64_t v54 = *(unsigned __int16 *)(v53 + 2 * v41);
                              uint64_t v56 = v62[7];
                              uint64_t v55 = v62[8];
                              uint64_t result = v55 - v56;
                              if (v54 < (v55 - v56) >> 3)
                              {
                                uint64_t v57 = v56 + 8 * v54;
                                if (*(_DWORD *)(v57 + 4) == v38 && v57 != v55) {
                                  break;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (++v13 == v8)
          {
            uint64_t v13 = v8;
            goto LABEL_13;
          }
        }
        uint64_t v8 = v13;
LABEL_13:
        uint64_t v63 = v13;
      }
    }
    while (v9 != v8);
  }
  *uint64_t v12 = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::NeedsRenderState>(int8x8_t *a1)
{
  uint64_t v10 = 0x1E85A99FD528C623;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x1E85A99FD528C623;
    if (*(void *)&v1 <= 0x1E85A99FD528C623uLL) {
      uint64_t v3 = 0x1E85A99FD528C623uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x1E85A99FD528C623;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x1E85A99FD528C623)
      {
        if (v5[2] == 0x1E85A99FD528C623) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x1E85A99FD528C623) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x1E85A99FD528C623) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A98048(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::IntendedSceneLayerType<(md::SceneLayer)4>>(int8x8_t *a1)
{
  uint64_t v10 = 0x5DA2A39FD10CA33BLL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x5DA2A39FD10CA33BLL;
    if (*(void *)&v1 <= 0x5DA2A39FD10CA33BuLL) {
      uint64_t v3 = 0x5DA2A39FD10CA33BuLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x5DA2A39FD10CA33BLL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x5DA2A39FD10CA33BLL)
      {
        if (v5[2] == 0x5DA2A39FD10CA33BLL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x5DA2A39FD10CA33BLL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x5DA2A39FD10CA33BLL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A982B8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::IntendedSceneLayerType<(md::SceneLayer)3>>(int8x8_t *a1)
{
  uint64_t v10 = 0x40FCAF57579CC039;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x40FCAF57579CC039;
    if (*(void *)&v1 <= 0x40FCAF57579CC039uLL) {
      uint64_t v3 = 0x40FCAF57579CC039uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x40FCAF57579CC039;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x40FCAF57579CC039)
      {
        if (v5[2] == 0x40FCAF57579CC039) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x40FCAF57579CC039) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x40FCAF57579CC039) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1A98528(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void sub_1A1A986AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1A987D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, char a11)
{
  _Unwind_Resume(a1);
}

uint64_t ggl::DisplayLink::onTimerFired(ggl::DisplayLink *this, double a2)
{
  double v4 = a2;
  uint64_t v2 = *((void *)this + 4);
  if (v2) {
    return (*(uint64_t (**)(uint64_t, double *))(*(void *)v2 + 48))(v2, &v4);
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return std::__function::__func<md::MapEngine::MapEngineDisplayLinkCaller,std::allocator<md::MapEngine::MapEngineDisplayLinkCaller>,void ()(double)>::operator()();
}

uint64_t std::__function::__func<md::MapEngine::MapEngineDisplayLinkCaller,std::allocator<md::MapEngine::MapEngineDisplayLinkCaller>,void ()(double)>::operator()(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(md::MapEngine **)(a1 + 8);
  if (md::MapEngine::canRenderAsync(v1))
  {
    uint64_t v2 = *((void *)v1 + 566);
    int v8 = 0;
    uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)v2 + 16))(v2, v6);
    if (v8 != -1) {
      return ((uint64_t (*)(char *, void *))off_1EF590668[v8])(&v5, v6);
    }
  }
  else
  {
    double v4 = CACurrentMediaTime();
    v6[0] = &unk_1EF520DB0;
    unint64_t v7 = v6;
    md::MapEngine::onRenderTimerFired((uint64_t)v1, v6, v4);
    uint64_t result = (uint64_t)v7;
    if (v7 == v6)
    {
      return (*(uint64_t (**)(void *))(v6[0] + 32))(v6);
    }
    else if (v7)
    {
      return (*(uint64_t (**)(void))(*v7 + 40))();
    }
  }
  return result;
}

void sub_1A1A98990(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, __int16 a10, char a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18)
{
  if (a16 == v18)
  {
    (*(void (**)(uint64_t *))(a13 + 32))(&a13);
    _Unwind_Resume(exception_object);
  }
  if (a16)
  {
    (*(void (**)(void))(*(void *)a16 + 40))();
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void md::MapEngine::onRenderTimerFired(uint64_t a1, void *a2, double a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  int v6 = *(unsigned __int8 *)(a1 + 98);
  *(unsigned char *)(a1 + 96) = v6 != (*(unsigned int (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
  *(unsigned char *)(a1 + 98) = (*(uint64_t (**)(void))(**(void **)(a1 + 88) + 24))(*(void *)(a1 + 88));
  if (*(void *)(a1 + 824))
  {
    if (ggl::Performance::Counters::instance(void)::onceToken[0] != -1) {
      dispatch_once(ggl::Performance::Counters::instance(void)::onceToken, &__block_literal_global_53878);
    }
    unint64_t v7 = atomic_load((unint64_t *)(*(void *)(ggl::Performance::Counters::instance(void)::counters + 32) + 64));
    unint64_t v8 = *(void *)(a1 + 1296);
    if (v7 <= v8)
    {
      *(void *)(*(void *)(a1 + 896) + 384) = 0x3FF0000000000000;
      *(void *)(a1 + 1328) = 0;
    }
    else
    {
      float v9 = fmaxf((float)((float)v7 - (float)v8) / (float)*(unint64_t *)(a1 + 1304), 0.0);
      if (v9 <= 1.0) {
        float v10 = (float)(v9 * 10.0) + -10.0;
      }
      else {
        float v10 = 0.0;
      }
      float v11 = exp2f(v10);
      if (v11 == 1.0)
      {
        float v12 = 0.05;
      }
      else
      {
        float v13 = (float)(v11 * -0.95) + 1.0;
        float v14 = fmaxf(v13, 0.05);
        float v15 = fminf(v13, 0.05);
        if (v11 > 1.0) {
          float v12 = v15;
        }
        else {
          float v12 = v14;
        }
      }
      double v16 = *(double *)(a1 + 1312);
      if (v16 > 0.0500000007) {
        float v12 = v16;
      }
      double v17 = v12;
      *(double *)(*(void *)(a1 + 896) + 384) = v12;
      if (vabdd_f64(*(double *)(a1 + 1328), v12) > 0.200000003 || *(unsigned char *)(a1 + 1320))
      {
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        uint64_t v18 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
        {
          uint64_t v19 = *(void *)(a1 + 1296);
          *(_DWORD *)buf = 134218496;
          *(void *)&int8x8_t buf[4] = v19;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v7;
          __int16 v49 = 2048;
          double v50 = v17;
          _os_log_impl(&dword_1A1780000, v18, OS_LOG_TYPE_INFO, "Exceeded Metal Buffer threshold of %llu with a count of %llu resources. Starting scaling cache down with the new cache size factor of %f", buf, 0x20u);
        }

        *(double *)(a1 + 1328) = v17;
      }
    }
    if (v7 <= *(void *)(a1 + 1288))
    {
      *(_DWORD *)(a1 + 1352) = -1;
      if (*(double *)(a1 + 1344) != 5.0)
      {
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        uint64_t v30 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134217984;
          *(void *)&int8x8_t buf[4] = v7;
          _os_log_impl(&dword_1A1780000, v30, OS_LOG_TYPE_INFO, "Metal Buffer threshold no longer exceeded with current count of %llu buffer resources", buf, 0xCu);
        }
      }
      *(void *)(a1 + 1344) = 0x4014000000000000;
    }
    else
    {
      double v20 = a3 - (double)*(uint64_t *)(a1 + 1336);
      double v21 = *(double *)(a1 + 1344);
      if (v20 <= v21)
      {
        double v31 = v21 - v20;
        unsigned int v32 = ((v21 - v20) * 0.1);
        if (*(_DWORD *)(a1 + 1352) != v32)
        {
          if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
            dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
          }
          unint64_t v33 = (id)GEOGetVectorKitVKDefaultLog_log;
          if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
          {
            uint64_t v34 = *(void *)(a1 + 1288);
            *(_DWORD *)buf = 134218752;
            *(void *)&int8x8_t buf[4] = v34;
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v7;
            __int16 v49 = 2048;
            double v50 = v31;
            __int16 v51 = 2048;
            uint64_t v52 = *(const char **)&v20;
            _os_log_impl(&dword_1A1780000, v33, OS_LOG_TYPE_INFO, "Exceeded Metal Buffer threshold of %llu with a count of %llu resources. Waiting %f seconds to prune resources. (Time since last prune:%f)", buf, 0x2Au);
          }

          *(_DWORD *)(a1 + 1352) = v32;
        }
      }
      else
      {
        *(double *)(a1 + 1344) = fmin(fmax(v21 + v21, 5.0), 900.0);
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        uint64_t v22 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          uint64_t v23 = *(void *)(a1 + 1288);
          *(_DWORD *)buf = 134219266;
          *(void *)&int8x8_t buf[4] = v23;
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v7;
          __int16 v49 = 2048;
          double v50 = v20;
          __int16 v51 = 2080;
          uint64_t v52 = "false";
          __int16 v53 = 2080;
          unint64_t v54 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/MDMapEngine.mm";
          __int16 v55 = 1024;
          int v56 = 2213;
          _os_log_impl(&dword_1A1780000, v22, OS_LOG_TYPE_ERROR, "Exceeded Metal Buffer threshold of %llu with a count of %llu resources, pruning resources now (Time since last prune:%f): Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x3Au);
        }

        uint64_t v24 = **(uint64_t ***)(a1 + 4512);
        if (v24 != *(uint64_t **)(*(void *)(a1 + 4512) + 8) && *v24 != 0x4BCD00F88A8100BELL)
        {
          uint64_t v25 = v24 + 5;
          do
          {
            uint64_t v26 = *v25;
            v25 += 5;
          }
          while (v26 != 0x4BCD00F88A8100BELL);
          uint64_t v24 = v25 - 5;
        }
        uint64_t v27 = (void (***)(void, uint64_t, const char *))v24[3];
        uint64_t v28 = (std::__shared_weak_count *)v24[4];
        if (v28)
        {
          atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
        (**v27)(v27, 2, "");
        uint64_t v29 = *(void *)(*(void *)(a1 + 8) + 8);
        *(void *)buf = &unk_1EF579530;
        *(void *)&buf[8] = a1;
        double v50 = COERCE_DOUBLE(buf);
        geo::TaskQueue::barrierSync(v29, buf);
        if (*(unsigned char **)&v50 == buf)
        {
          (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
        }
        else if (v50 != 0.0)
        {
          (*(void (**)(void))(**(void **)&v50 + 40))();
        }
        *(void *)(a1 + 1336) = (uint64_t)a3;
        *(_DWORD *)(a1 + 1352) = -1;
      }
    }
  }
  md::MapEngine::updateRunLoopStatus((md::MapEngine *)a1);
  uint64_t v35 = *(void *)(a1 + 88);
  if (v35 && (*(unsigned int (**)(uint64_t))(*(void *)v35 + 24))(v35))
  {
    if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
    }
    int v36 = (id)GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled(v36))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v36, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "DisplayLinkSkip", "", buf, 2u);
    }

    uint64_t v37 = a2[3];
    if (v37)
    {
      (*(void (**)(uint64_t))(*(void *)v37 + 48))(v37);
    }
    else
    {
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
    }
    return;
  }
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  unint64_t v38 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v39 = v38;
  os_signpost_id_t v40 = *(void *)(a1 + 1216);
  if (v40 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v38))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v39, OS_SIGNPOST_INTERVAL_BEGIN, v40, "Frame", "", buf, 2u);
  }

  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = std::chrono::steady_clock::now().__d_.__rep_;
  unint64_t v42 = operator new(0x18uLL);
  void *v42 = &unk_1EF5796E0;
  v42[1] = a1;
  v42[2] = rep;
  uint64_t v47 = v42;
  uint64_t v43 = a2[3];
  if (v43)
  {
    if ((void *)v43 == a2)
    {
      unint64_t v45 = v44;
      (*(void (**)(void *, void *))(*a2 + 24))(a2, v44);
      goto LABEL_73;
    }
    uint64_t v43 = (*(uint64_t (**)(uint64_t))(*(void *)v43 + 16))(v43);
  }
  unint64_t v45 = (void *)v43;
LABEL_73:
  md::MapEngine::renderScene(a1, v46, v44, a3);
  if (v45 == v44)
  {
    (*(void (**)(void *))(v44[0] + 32))(v44);
  }
  else if (v45)
  {
    (*(void (**)(void))(*v45 + 40))();
  }
  if (v47 == v46)
  {
    (*(void (**)(void *))(v46[0] + 32))(v46);
  }
  else if (v47)
  {
    (*(void (**)(void))(*v47 + 40))();
  }
}

void sub_1A1A993C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void md::MapEngine::renderScene(uint64_t a1, void *a2, void *a3, double a4)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (md::MapEngine::canRenderAsync((md::MapEngine *)a1))
  {
    unint64_t v8 = (void *)a2[3];
    if (v8)
    {
      if (v8 == a2)
      {
        uint64_t v37 = v36;
        (*(void (**)(void *, void *))(*a2 + 24))(a2, v36);
      }
      else
      {
        uint64_t v37 = (void *)(*(uint64_t (**)(void *))(*v8 + 16))(v8);
      }
    }
    else
    {
      uint64_t v37 = 0;
    }
    uint64_t v12 = a3[3];
    if (v12)
    {
      if ((void *)v12 == a3)
      {
        uint64_t v35 = v34;
        (*(void (**)(void *, void *))(*a3 + 24))(a3, v34);
        goto LABEL_18;
      }
      uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)v12 + 16))(v12);
    }
    uint64_t v35 = (void *)v12;
LABEL_18:
    [*(id *)(a1 + 840) size];
    double v14 = v13;
    double v16 = v15;
    char v17 = *(unsigned char *)(a1 + 1177);
    if (v17) {
      char v17 = *(unsigned char *)(a1 + 1178) == 0;
    }
    if ((v17 & 1) == 0
      && !*(unsigned char *)(a1 + 1176)
      && (([*(id *)(a1 + 840) hasRenderTarget] & 1) != 0 || *(void *)(a1 + 1200) == 1)
      && v16 * v14 > 0.0)
    {
      unsigned __int8 v18 = atomic_load((unsigned __int8 *)(a1 + 1181));
      if ((v18 & 1) == 0)
      {
        md::MapEngine::runUpdatePhase((md::MapEngine *)a1, a4, 0);
        uint64_t v19 = *(void *)(a1 + 4536);
        __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(v19 + 176);
        __lk.__owns_ = 1;
        std::mutex::lock((std::mutex *)(v19 + 176));
        while (*(unsigned char *)(v19 + 292))
          std::condition_variable::wait((std::condition_variable *)(v19 + 240), &__lk);
        if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
        }
        double v20 = (id)GEOGetVectorKitPerformanceLog_log;
        double v21 = v20;
        os_signpost_id_t v22 = *(void *)(v19 + 296);
        if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v20))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_1A1780000, v21, OS_SIGNPOST_INTERVAL_BEGIN, v22, "HomeQueueReservation", "", buf, 2u);
        }

        uint64_t v23 = (md::HomeQueueScheduler::waitForReservation(void)::reservationKey + 1);
        md::HomeQueueScheduler::waitForReservation(void)::reservationKey = v23;
        *(_DWORD *)(v19 + 288) = v23;
        *(unsigned char *)(v19 + 292) = 1;
        if (__lk.__owns_) {
          std::mutex::unlock(__lk.__m_);
        }
        uint64_t v24 = (uint64_t)v37;
        if (v37)
        {
          if (v37 == v36)
          {
            uint64_t v44 = buf;
            (*(void (**)(void *, uint8_t *))(v36[0] + 24))(v36, buf);
            goto LABEL_51;
          }
          uint64_t v24 = (*(uint64_t (**)(void))(*v37 + 16))();
        }
        uint64_t v44 = (uint8_t *)v24;
LABEL_51:
        uint64_t v25 = md::MapEngine::buildFrameRequest(a1, v23 | 0x100000000, (uint64_t)buf);
        if (v44 == buf)
        {
          (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
        }
        else if (v44)
        {
          (*(void (**)(void))(*(void *)v44 + 40))();
        }
        uint64_t v26 = *(void *)(a1 + 4512);
        uint64_t v27 = *(void **)v26;
        uint64_t v28 = *(void **)(v26 + 8);
        if (v27 != v28)
        {
          while (*v27 != 0x8C3843AC816FCBCLL)
          {
            v27 += 5;
            if (v27 == v28) {
              goto LABEL_63;
            }
          }
        }
        if (v27 == v28)
        {
LABEL_63:
          uint64_t v29 = 0;
        }
        else
        {
          uint64_t v29 = v27[3];
          uint64_t v30 = (std::__shared_weak_count *)v27[4];
          if (v30)
          {
            atomic_fetch_add_explicit(&v30->__shared_owners_, 1uLL, memory_order_relaxed);
            if (!atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
              std::__shared_weak_count::__release_weak(v30);
            }
          }
        }
        __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)a1;
        *(_DWORD *)&__lk.__owns_ = v23;
        if (v35)
        {
          if (v35 == v34)
          {
            os_signpost_id_t v40 = v39;
            (*(void (**)(void *, void *))(v34[0] + 24))(v34, v39);
          }
          else
          {
            os_signpost_id_t v40 = v35;
            uint64_t v35 = 0;
          }
        }
        else
        {
          os_signpost_id_t v40 = 0;
        }
        unint64_t v42 = 0;
        double v31 = operator new(0x38uLL);
        unsigned int v32 = v31;
        uint64_t m = __lk.__m_;
        *double v31 = &unk_1EF520D20;
        v31[1] = m;
        *((_DWORD *)v31 + 4) = *(_DWORD *)&__lk.__owns_;
        if (v40)
        {
          if (v40 == v39)
          {
            v31[6] = v31 + 3;
            (*(void (**)(void *))(v39[0] + 24))(v39);
          }
          else
          {
            v31[6] = v40;
            os_signpost_id_t v40 = 0;
          }
        }
        else
        {
          v31[6] = 0;
        }
        unint64_t v42 = v32;
        (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v29 + 24))(v29, v25, v41);
        if (v42 == v41)
        {
          (*(void (**)(void *))(v41[0] + 32))(v41);
        }
        else if (v42)
        {
          (*(void (**)(void))(*v42 + 40))();
        }
        if (v40 == v39)
        {
          (*(void (**)(void *))(v39[0] + 32))(v39);
        }
        else if (v40)
        {
          (*(void (**)(void))(*v40 + 40))();
        }
        goto LABEL_41;
      }
    }
    if (v35)
    {
      (*(void (**)(void *))(*v35 + 48))(v35);
LABEL_41:
      if (v35 == v34)
      {
        (*(void (**)(void *))(v34[0] + 32))(v34);
      }
      else if (v35)
      {
        (*(void (**)(void))(*v35 + 40))();
      }
      if (v37 == v36)
      {
        (*(void (**)(void *))(v36[0] + 32))(v36);
      }
      else if (v37)
      {
        (*(void (**)(void))(*v37 + 40))();
      }
      return;
    }
LABEL_83:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
    return;
  }
  md::MapEngine::renderSceneSync((md::MapEngine *)a1, a4);
  uint64_t v9 = a2[3];
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 48))(v9);
  }
  uint64_t v10 = a3[3];
  if (!v10)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    goto LABEL_83;
  }
  float v11 = *(void (**)(void))(*(void *)v10 + 48);
  v11();
}

void sub_1A1A99BF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
}

unsigned __int8 *md::MapEngine::canRenderAsync(md::MapEngine *this)
{
  uint64_t v2 = (uint64_t *)*((void *)this + 141);
  uint64_t v3 = *v2;
  uint64_t v4 = v2[1];
  uint64_t v5 = v3;
  if (v3 != v4)
  {
    uint64_t v5 = v3;
    while (*(unsigned char *)v5 != 20)
    {
      v5 += 16;
      if (v5 == v4) {
        goto LABEL_9;
      }
    }
  }
  if (v5 == v4)
  {
LABEL_9:
    unsigned int v6 = 0;
    if (v3 != v4)
    {
LABEL_10:
      while (*(unsigned char *)v3 != 22)
      {
        v3 += 16;
        if (v3 == v4) {
          goto LABEL_15;
        }
      }
    }
  }
  else
  {
    unsigned int v6 = *(_DWORD *)(v5 + 8);
    if (v3 != v4) {
      goto LABEL_10;
    }
  }
  if (v3 == v4) {
LABEL_15:
  }
    BOOL v7 = 1;
  else {
    BOOL v7 = *(void *)(v3 + 8) == 0;
  }
  if (*((unsigned char *)this + 1241)) {
    BOOL v8 = v6 > 0xA;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 && (((1 << v6) & 0x418) != 0 || ((1 << v6) & 6) != 0 && !v7))
  {
    *(unsigned char *)(*((void *)this + 112) + 377) = 1;
    int v13 = 3;
    uint64_t result = (unsigned __int8 *)*((void *)this + 148);
    if (!result) {
      return result;
    }
    goto LABEL_40;
  }
  *(unsigned char *)(*((void *)this + 112) + 377) = 0;
  int v9 = 1 << v6;
  if (v7) {
    int v10 = 0;
  }
  else {
    int v10 = 3;
  }
  if (v6 == 11) {
    int v11 = 2;
  }
  else {
    int v11 = 4;
  }
  if ((v9 & 0x418) != 0) {
    int v12 = 1;
  }
  else {
    int v12 = v11;
  }
  if ((v9 & 0x1E7) == 0) {
    int v10 = v12;
  }
  if (v6 <= 0xB) {
    int v13 = v10;
  }
  else {
    int v13 = 4;
  }
  uint64_t result = (unsigned __int8 *)*((void *)this + 148);
  if (result)
  {
LABEL_40:
    if (v13 == result[8])
    {
      uint64_t result = (unsigned __int8 *)(*(uint64_t (**)(unsigned __int8 *))(*(void *)result + 16))(result);
      if (result) {
        return (unsigned __int8 *)(*((unsigned char *)this + 4440) != 0);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t md::MapEngineConfiguration::supportsAsyncRender(md::MapEngineConfiguration *this)
{
  return 1;
}

uint64_t md::MapEngine::renderSceneSync(md::MapEngine *this, double a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  [*((id *)this + 105) size];
  char v6 = *((unsigned char *)this + 1177);
  if (v6) {
    char v6 = *((unsigned char *)this + 1178) == 0;
  }
  uint64_t result = 0;
  if ((v6 & 1) == 0 && !*((unsigned char *)this + 1176))
  {
    double v8 = v5 * v4;
    if ([*((id *)this + 105) hasRenderTarget])
    {
      if (v8 <= 0.0) {
        return 0;
      }
    }
    else
    {
      uint64_t result = 0;
      if (*((void *)this + 150) != 1 || v8 <= 0.0) {
        return result;
      }
    }
    unsigned __int8 v9 = atomic_load((unsigned __int8 *)this + 1181);
    if (v9) {
      return 0;
    }
    if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
    }
    int v10 = (id)GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled(v10))
    {
      unsigned int v11 = md::MapEngine::canRenderAsync(this);

      if (v11)
      {
        if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
        }
        int v12 = (id)GEOGetVectorKitPerformanceLog_log;
        if (os_signpost_enabled(v12))
        {
          *(_WORD *)uint64_t v19 = 0;
          _os_signpost_emit_with_name_impl(&dword_1A1780000, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ForceSyncRender", "", v19, 2u);
        }
      }
    }
    else
    {
    }
    md::HomeQueueScheduler::waitForSynchronization(*((md::HomeQueueScheduler **)this + 567), "BOOL md::MapEngine::renderSceneSync(double)");
    md::MapEngine::runUpdatePhase(this, a2, 0);
    uint64_t v23 = 0;
    uint64_t v13 = md::MapEngine::buildFrameRequest((uint64_t)this, 0, (uint64_t)v22);
    if (v23 == v22)
    {
      (*(void (**)(void *))(v22[0] + 32))(v22);
    }
    else if (v23)
    {
      (*(void (**)(void))(*v23 + 40))();
    }
    double v14 = (uint64_t *)**((void **)this + 564);
    if (v14 != *(uint64_t **)(*((void *)this + 564) + 8) && *v14 != 0x8C3843AC816FCBCLL)
    {
      double v15 = v14 + 5;
      do
      {
        uint64_t v16 = *v15;
        v15 += 5;
      }
      while (v16 != 0x8C3843AC816FCBCLL);
      double v14 = v15 - 5;
    }
    uint64_t v17 = v14[3];
    unsigned __int8 v18 = (std::__shared_weak_count *)v14[4];
    if (v18)
    {
      atomic_fetch_add_explicit(&v18->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
        std::__shared_weak_count::__release_weak(v18);
      }
    }
    double v21 = 0;
    (*(void (**)(uint64_t, uint64_t, void *))(*(void *)v17 + 32))(v17, v13, v20);
    if (v21 == v20)
    {
      (*(void (**)(void *))(v20[0] + 32))(v20);
    }
    else if (v21)
    {
      (*(void (**)(void))(*v21 + 40))();
    }
    return 1;
  }
  return result;
}

void sub_1A1A9A180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1A9A190(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function(va);
  _Unwind_Resume(a1);
}

void md::HomeQueueScheduler::waitForSynchronization(md::HomeQueueScheduler *this, const char *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  os_signpost_id_t v22 = a2;
  uint64_t v3 = (std::mutex *)((char *)this + 176);
  double v20 = (std::mutex *)((char *)this + 176);
  char v21 = 1;
  std::mutex::lock((std::mutex *)((char *)this + 176));
  if (!*((unsigned char *)this + 292)) {
    goto LABEL_69;
  }
  std::mutex::lock((std::mutex *)((char *)this + 8));
  int v4 = *(unsigned __int8 *)this;
  std::mutex::unlock((std::mutex *)((char *)this + 8));
  if (!v4) {
    goto LABEL_67;
  }
  v29[0] = &unk_1EF5738A8;
  v29[1] = this;
  uint64_t v30 = &v22;
  double v31 = v29;
  uint64_t v26 = (void (**)(void **))&unk_1EF5738F0;
  *(void *)&long long v27 = this;
  *((void *)&v27 + 1) = &v22;
  uint64_t v28 = (void **)&v26;
  uint64_t v34 = (void **)&v32;
  unsigned int v32 = (void (**)(void **))&unk_1EF5738F0;
  long long v33 = v27;
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  double v5 = (id)GEOGetVectorKitPerformanceLog_log;
  char v6 = v5;
  os_signpost_id_t v7 = *((void *)this + 37);
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    double v8 = *v30;
    if (!*v30) {
      double v8 = "";
    }
    *(_DWORD *)buf = 136315138;
    *(void *)&int8x8_t buf[4] = v8;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v6, OS_SIGNPOST_INTERVAL_BEGIN, v7, "WaitForSynchronization", "SyncPoint:%s", buf, 0xCu);
  }

  if (v28 == (void **)&v26)
  {
    v26[4]((void **)&v26);
  }
  else if (v28)
  {
    (*((void (**)(void))*v28 + 5))();
  }
  if (v31 == v29)
  {
    (*(void (**)(void *))(v29[0] + 32))(v29);
  }
  else if (v31)
  {
    (*(void (**)(void))(*v31 + 40))();
  }
  v9.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  v24[0] = &unk_1EF573938;
  v24[1] = &v20;
  uint64_t v25 = v24;
  std::mutex::lock((std::mutex *)((char *)this + 8));
  int v10 = *(unsigned __int8 *)this;
  std::mutex::unlock((std::mutex *)((char *)this + 8));
  if (v10)
  {
    std::mutex::lock((std::mutex *)((char *)this + 8));
    *(unsigned char *)this = 0;
    std::mutex::unlock((std::mutex *)((char *)this + 8));
    if (v25) {
      (*(void (**)(void *))(*v25 + 48))(v25);
    }
    for (uint64_t i = 0; ; (*(void (**)(void))(*i + 48))())
    {
      __lk.__m_ = (std::unique_lock<std::mutex>::mutex_type *)((char *)this + 8);
      __lk.__owns_ = 1;
      std::mutex::lock((std::mutex *)((char *)this + 8));
      if (*(unsigned char *)this)
      {
        int v11 = 3;
LABEL_47:
        std::mutex::unlock(__lk.__m_);
        goto LABEL_48;
      }
      while (!*((void *)this + 20))
      {
        if (*(unsigned char *)this)
        {
          int v11 = 1;
          if (__lk.__owns_) {
            goto LABEL_47;
          }
          goto LABEL_48;
        }
        std::condition_variable::wait((std::condition_variable *)((char *)this + 72), &__lk);
      }
      int v12 = (void *)(*(void *)(*((void *)this + 16) + ((*((void *)this + 19) >> 4) & 0xFFFFFFFFFFFFFF8))
                     + 32 * (*((void *)this + 19) & 0x7FLL));
      uint64_t v13 = (void *)v12[3];
      if (!v13) {
        break;
      }
      if (v13 != v12)
      {
        uint64_t v14 = (*(uint64_t (**)(void))(*v13 + 16))(v12[3]);
LABEL_33:
        os_signpost_id_t v40 = (unsigned char *)v14;
        goto LABEL_35;
      }
      os_signpost_id_t v40 = buf;
      (*(void (**)(void *, unsigned char *))(*v12 + 24))(v12, buf);
LABEL_35:
      std::__function::__value_func<void ()(void)>::swap[abi:nn180100](buf, v35);
      if (v40 == buf)
      {
        (*(void (**)(unsigned char *))(*(void *)buf + 32))(buf);
      }
      else if (v40)
      {
        (*(void (**)(unsigned char *))(*(void *)v40 + 40))(v40);
      }
      double v15 = (void *)(*(void *)(*((void *)this + 16) + ((*((void *)this + 19) >> 4) & 0xFFFFFFFFFFFFFF8))
                     + 32 * (*((void *)this + 19) & 0x7FLL));
      uint64_t v16 = (void *)v15[3];
      if (v16 == v15)
      {
        (*(void (**)(uint64_t))(*v15 + 32))(*(void *)(*((void *)this + 16) + ((*((void *)this + 19) >> 4) & 0xFFFFFFFFFFFFFF8))+ 32 * (*((void *)this + 19) & 0x7FLL));
      }
      else if (v16)
      {
        (*(void (**)(void *))(*v16 + 40))(v16);
      }
      int64x2_t v17 = vaddq_s64(*(int64x2_t *)((char *)this + 152), (int64x2_t)xmmword_1A28FE7B0);
      *(int64x2_t *)((char *)this + 152) = v17;
      if (v17.i64[0] >= 0x100uLL)
      {
        operator delete(**((void ***)this + 16));
        int v11 = 0;
        *((void *)this + 16) += 8;
        *((void *)this + 19) -= 128;
        if (!__lk.__owns_) {
          goto LABEL_48;
        }
        goto LABEL_47;
      }
      int v11 = 0;
      if (__lk.__owns_) {
        goto LABEL_47;
      }
LABEL_48:
      if (v11)
      {
        if (i == v35)
        {
          (*(void (**)(void *))(v35[0] + 32))(v35);
        }
        else if (i)
        {
          (*(void (**)(void))(*i + 40))();
        }
        goto LABEL_55;
      }
      if (!i) {
        goto LABEL_73;
      }
    }
    uint64_t v14 = 0;
    goto LABEL_33;
  }
LABEL_55:
  if (v25 == v24)
  {
    (*(void (**)(void *))(v24[0] + 32))(v24);
  }
  else if (v25)
  {
    (*(void (**)(void))(*v25 + 40))();
  }
  v18.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  uint64_t v19 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    *(void *)&int8x8_t buf[4] = v22;
    __int16 v38 = 2048;
    double v39 = (double)(v18.__d_.__rep_ - v9.__d_.__rep_) * 0.000001;
    _os_log_impl(&dword_1A1780000, v19, OS_LOG_TYPE_INFO, "Waited for synchronization with background (reason:%s, %f ms)", buf, 0x16u);
  }

  if (!v34)
  {
LABEL_73:
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
    return;
  }
  (*((void (**)(void **))*v34 + 6))(v34);
  if (v34 != (void **)&v32)
  {
    if (v34) {
      (*((void (**)(void))*v34 + 5))();
    }
LABEL_67:
    if (!v21) {
      return;
    }
    goto LABEL_68;
  }
  v32[4]((void **)&v32);
  if (v21)
  {
LABEL_68:
    uint64_t v3 = v20;
LABEL_69:
    std::mutex::unlock(v3);
  }
}

void sub_1A1A9A984(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::mutex *a12, char a13, uint64_t a14, std::mutex *a15, char a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  if (!a13) {
    _Unwind_Resume(exception_object);
  }
  std::mutex::unlock(a12);
  _Unwind_Resume(exception_object);
}

uint64_t md::MapEngine::buildFrameRequest(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(void *)(a1 + 4512);
  os_signpost_id_t v7 = *(void **)v6;
  double v8 = *(void **)(v6 + 8);
  if (v7 != v8)
  {
    while (*v7 != 0x8C3843AC816FCBCLL)
    {
      v7 += 5;
      if (v7 == v8) {
        goto LABEL_9;
      }
    }
  }
  if (v7 == v8)
  {
LABEL_9:
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = v7[3];
    int v10 = (std::__shared_weak_count *)v7[4];
    if (v10)
    {
      atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
        std::__shared_weak_count::__release_weak(v10);
      }
    }
  }
  LOBYTE(v15) = *(void *)(a1 + 1200) == 1;
  HIDWORD(v15) = a2;
  LOBYTE(v16) = BYTE4(a2);
  CFTimeInterval v17 = CACurrentMediaTime();
  int v11 = [*(id *)(a1 + 840) renderSource];
  LOBYTE(v18) = [v11 isDelayedRenderQueueConsumptionSupported] ^ 1;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, void (***)(void **)))(*(void *)v9 + 16))(v9, &v15);

  if (*(void *)(a3 + 24)) {
    (*(void (**)(uint64_t, uint64_t, void, uint64_t))(*(void *)v9 + 64))(v9, v12, 0, a3);
  }
  uint64_t v14 = v12;
  [*(id *)(a1 + 840) prepareRenderTask:&v14];
  if (!*(void *)(a1 + 1200))
  {
    double v15 = (void (**)(void **))&unk_1EF520D68;
    uint64_t v16 = a1;
    std::chrono::steady_clock::time_point v18 = (void **)&v15;
    (*(void (**)(uint64_t, uint64_t, uint64_t, void (***)(void **)))(*(void *)v9 + 64))(v9, v12, 2, &v15);
    if (v18 == (void **)&v15)
    {
      v15[4]((void **)&v15);
    }
    else if (v18)
    {
      (*((void (**)(void))*v18 + 5))();
    }
  }
  return v12;
}

void sub_1A1A9AD00(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void sub_1A1A9AD14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *md::MapEngineFrameService::addTask(void *result, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4 = result[11];
  if (a2 < (unint64_t)((result[12] - v4) >> 3))
  {
    uint64_t v5 = *(void *)(v4 + 8 * a2);
    if (v5 && HIDWORD(a2) == HIDWORD(v5))
    {
      uint64_t v7 = result[14] + 8 * v5;
      if (v7 != result[15])
      {
        uint64_t v10 = *(void *)v7;
        ++*(void *)(*(void *)v7 + 120);
        uint64_t v11 = result[1];
        uint64_t v12 = *(void **)v11;
        uint64_t v13 = *(void **)(v11 + 8);
        if (v12 != v13)
        {
          while (*v12 != 0xCFC5133F599B8248)
          {
            v12 += 5;
            if (v12 == v13) {
              goto LABEL_16;
            }
          }
        }
        if (v12 == v13)
        {
LABEL_16:
          uint64_t v14 = 0;
        }
        else
        {
          uint64_t v14 = v12[3];
          double v15 = (std::__shared_weak_count *)v12[4];
          if (v15)
          {
            atomic_fetch_add_explicit(&v15->__shared_owners_, 1uLL, memory_order_relaxed);
            if (!atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
              std::__shared_weak_count::__release_weak(v15);
            }
          }
        }
        uint64_t v16 = *(char **)(v10 + 96);
        CFTimeInterval v17 = *(char **)(v10 + 104);
        uint64_t v18 = v10 + 96;
        if (v16 != v17)
        {
          while (*v16 != a3)
          {
            v16 += 16;
            if (v16 == v17) {
              goto LABEL_22;
            }
          }
        }
        if (v16 == v17)
        {
LABEL_22:
          v21[0] = a3;
          uint64_t v22 = 0;
          uint64_t v16 = geo::linear_map<md::FrameCallback,geo::handle<gdc::tf::Taskflow>,std::equal_to<md::FrameCallback>,std::allocator<std::pair<md::FrameCallback,geo::handle<gdc::tf::Taskflow>>>,std::vector<std::pair<md::FrameCallback,geo::handle<gdc::tf::Taskflow>>>>::insert(v18, v21);
        }
        uint64_t v19 = *((void *)v16 + 1);
        double v20 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v14 + 48);
        return (void *)v20(v14, v19, a4);
      }
    }
  }
  return result;
}

unint64_t md::MapEngineFrameService::requestFrame(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = **(uint64_t ***)(a1 + 8);
  if (v4 != *(uint64_t **)(*(void *)(a1 + 8) + 8) && *v4 != 0xCFC5133F599B8248)
  {
    uint64_t v5 = v4 + 5;
    do
    {
      uint64_t v6 = *v5;
      v5 += 5;
    }
    while (v6 != 0xCFC5133F599B8248);
    uint64_t v4 = v5 - 5;
  }
  uint64_t v7 = v4[3];
  double v8 = (std::__shared_weak_count *)v4[4];
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  *(_OWORD *)uint64_t v96 = *(_OWORD *)a2;
  *(_OWORD *)&v96[9] = *(_OWORD *)(a2 + 9);
  LODWORD(v97) = *(_DWORD *)(a2 + 4);
  BYTE4(v97) = *(unsigned char *)(a2 + 8);
  *((void *)&v97 + 1) = 0;
  *(_WORD *)uint64_t v98 = 0;
  memset(&v98[8], 0, 32);
  *(void *)&long long v99 = 0;
  char v95 = 0;
  uint64_t v9 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 16))(v7, &v95);
  char v94 = 0;
  uint64_t v10 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 16))(v7, &v94);
  char v93 = 0;
  uint64_t v11 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 16))(v7, &v93);
  char v92 = 0;
  uint64_t v12 = (*(uint64_t (**)(uint64_t, char *))(*(void *)v7 + 16))(v7, &v92);
  *((void *)&v99 + 1) = 0;
  uint64_t v100 = 0;
  uint64_t v101 = 0;
  uint64_t v13 = operator new(0x40uLL);
  *(unsigned char *)uint64_t v13 = 3;
  v13[1] = v9;
  *((unsigned char *)v13 + 16) = 1;
  v13[3] = v10;
  *((unsigned char *)v13 + 32) = 0;
  v13[5] = v11;
  *((unsigned char *)v13 + 48) = 2;
  v13[7] = v12;
  *((void *)&v99 + 1) = v13;
  uint64_t v100 = (char *)(v13 + 8);
  uint64_t v101 = (char *)(v13 + 8);
  uint64_t v102 = 0;
  uint64_t v14 = *(char **)(a1 + 56);
  if (!v14)
  {
    double v15 = (char *)malloc_type_malloc(*(void *)(a1 + 48), 0x160B39uLL);
    uint64_t v16 = v15;
    uint64_t v18 = (uint64_t **)(a1 + 24);
    CFTimeInterval v17 = *(uint64_t **)(a1 + 24);
    if (v17)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v19 = (uint64_t **)v17;
          unint64_t v20 = v17[4];
          if ((unint64_t)v15 >= v20) {
            break;
          }
          CFTimeInterval v17 = *v19;
          uint64_t v18 = v19;
          if (!*v19) {
            goto LABEL_17;
          }
        }
        if (v20 >= (unint64_t)v15) {
          break;
        }
        CFTimeInterval v17 = v19[1];
        if (!v17)
        {
          uint64_t v18 = v19 + 1;
          goto LABEL_17;
        }
      }
    }
    else
    {
      uint64_t v19 = (uint64_t **)(a1 + 24);
LABEL_17:
      char v21 = (uint64_t *)operator new(0x28uLL);
      v21[4] = (uint64_t)v16;
      *char v21 = 0;
      v21[1] = 0;
      v21[2] = (uint64_t)v19;
      *uint64_t v18 = v21;
      uint64_t v22 = **(void **)(a1 + 16);
      if (v22)
      {
        *(void *)(a1 + 16) = v22;
        char v21 = *v18;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 24), v21);
      ++*(void *)(a1 + 32);
    }
    uint64_t v14 = *(char **)(a1 + 56);
    uint64_t v23 = (*(void *)(a1 + 40) << 7) - 128;
    if (v23 >= 0)
    {
      uint64_t v24 = &v16[v23];
      uint64_t v25 = &v16[v23];
      do
      {
        *(void *)uint64_t v25 = v14;
        v25 -= 128;
        uint64_t v14 = v24;
        uint64_t v24 = v25;
      }
      while (v25 >= v16);
      uint64_t v14 = v25 + 128;
    }
    *(void *)(a1 + 56) = v14;
  }
  *(void *)(a1 + 56) = *(void *)v14;
  *(_OWORD *)uint64_t v14 = *(_OWORD *)v96;
  long long v26 = *(_OWORD *)&v96[16];
  long long v27 = v97;
  long long v28 = *(_OWORD *)&v98[16];
  *((_OWORD *)v14 + 3) = *(_OWORD *)v98;
  *((_OWORD *)v14 + 4) = v28;
  *((_OWORD *)v14 + 1) = v26;
  *((_OWORD *)v14 + 2) = v27;
  uint64_t v29 = *(void *)&v98[32];
  *(void *)&v98[32] = 0;
  *((void *)v14 + 10) = v29;
  *((void *)v14 + 13) = 0;
  *((void *)v14 + 14) = 0;
  *((void *)v14 + 12) = 0;
  long long v30 = v99;
  *(void *)&long long v99 = 0;
  *(_OWORD *)(v14 + 88) = v30;
  uint64_t v31 = v99;
  *((void *)v14 + 13) = v100;
  *((void *)v14 + 14) = v101;
  *((void *)&v99 + 1) = 0;
  uint64_t v100 = 0;
  uint64_t v101 = 0;
  *((void *)v14 + 15) = v102;
  *(void *)&long long v99 = 0;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  unsigned int v32 = *(ggl::RenderQueue **)&v98[32];
  *(void *)&v98[32] = 0;
  if (v32)
  {
    ggl::RenderQueue::~RenderQueue(v32);
    MEMORY[0x1A6239270]();
  }
  uint64_t v33 = *(void *)(a1 + 72);
  if (*(void *)(a1 + 64) == v33)
  {
    uint64_t v36 = ((*(void *)(a1 + 120) - *(void *)(a1 + 112)) >> 3) | 0x100000000;
    __int16 v38 = *(uint64_t **)(a1 + 96);
    unint64_t v37 = *(void *)(a1 + 104);
    if ((unint64_t)v38 >= v37)
    {
      os_signpost_id_t v40 = *(uint64_t **)(a1 + 88);
      uint64_t v41 = v38 - v40;
      unint64_t v42 = v41 + 1;
      if ((unint64_t)(v41 + 1) >> 61) {
        goto LABEL_100;
      }
      uint64_t v43 = v37 - (void)v40;
      if (v43 >> 2 > v42) {
        unint64_t v42 = v43 >> 2;
      }
      if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v44 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v44 = v42;
      }
      if (v44)
      {
        if (v44 >> 61) {
          goto LABEL_101;
        }
        uint64_t v45 = operator new(8 * v44);
      }
      else
      {
        uint64_t v45 = 0;
      }
      uint64_t v46 = (uint64_t *)&v45[8 * v41];
      uint64_t v47 = &v45[8 * v44];
      uint64_t *v46 = v36;
      double v39 = v46 + 1;
      if (v38 == v40)
      {
        os_signpost_id_t v40 = v38;
      }
      else
      {
        unint64_t v48 = (char *)v38 - (char *)v40 - 8;
        if (v48 < 0x58) {
          goto LABEL_104;
        }
        if ((unint64_t)((char *)v40 - v45) < 0x20) {
          goto LABEL_104;
        }
        uint64_t v49 = (v48 >> 3) + 1;
        double v50 = &v45[8 * v41 - 16];
        __int16 v51 = v38 - 2;
        uint64_t v52 = v49 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v53 = *(_OWORD *)v51;
          *(v50 - 1) = *((_OWORD *)v51 - 1);
          _OWORD *v50 = v53;
          v50 -= 2;
          v51 -= 4;
          v52 -= 4;
        }
        while (v52);
        v46 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
        v38 -= v49 & 0x3FFFFFFFFFFFFFFCLL;
        if (v49 != (v49 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_104:
          do
          {
            uint64_t v54 = *--v38;
            *--uint64_t v46 = v54;
          }
          while (v38 != v40);
          os_signpost_id_t v40 = *(uint64_t **)(a1 + 88);
        }
      }
      *(void *)(a1 + 88) = v46;
      *(void *)(a1 + 96) = v39;
      *(void *)(a1 + 104) = v47;
      if (v40) {
        operator delete(v40);
      }
    }
    else
    {
      *__int16 v38 = v36;
      double v39 = v38 + 1;
    }
    *(void *)(a1 + 96) = v39;
    unint64_t v35 = *(v39 - 1);
  }
  else
  {
    uint64_t v34 = *(void *)(v33 - 8);
    *(void *)(a1 + 72) = v33 - 8;
    *(_DWORD *)(*(void *)(a1 + 88) + 8 * v34) = (*(void *)(a1 + 120) - *(void *)(a1 + 112)) >> 3;
    *(_DWORD *)(*(void *)(a1 + 88) + 8 * v34 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 88)
                                                                                          + 8 * v34
                                                                                          + 4) << 32)
                                                     + 0x100000000) >> 32;
    unint64_t v35 = v34 | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 88) + 8 * v34 + 4) << 32);
  }
  int v56 = *(char **)(a1 + 120);
  unint64_t v55 = *(void *)(a1 + 128);
  if ((unint64_t)v56 >= v55)
  {
    uint64_t v58 = *(char **)(a1 + 112);
    uint64_t v59 = (v56 - v58) >> 3;
    unint64_t v60 = v59 + 1;
    if ((unint64_t)(v59 + 1) >> 61) {
      goto LABEL_100;
    }
    uint64_t v61 = v55 - (void)v58;
    if (v61 >> 2 > v60) {
      unint64_t v60 = v61 >> 2;
    }
    if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v62 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v62 = v60;
    }
    if (v62)
    {
      if (v62 >> 61) {
        goto LABEL_101;
      }
      uint64_t v63 = operator new(8 * v62);
    }
    else
    {
      uint64_t v63 = 0;
    }
    char v64 = (char **)&v63[8 * v59];
    uint64_t v65 = &v63[8 * v62];
    *char v64 = v14;
    uint64_t v57 = v64 + 1;
    if (v56 == v58)
    {
      uint64_t v58 = v56;
    }
    else
    {
      unint64_t v66 = v56 - v58 - 8;
      if (v66 < 0x58) {
        goto LABEL_105;
      }
      if ((unint64_t)(v58 - v63) < 0x20) {
        goto LABEL_105;
      }
      uint64_t v67 = (v66 >> 3) + 1;
      unint64_t v68 = &v63[8 * v59 - 16];
      uint64_t v69 = v56 - 16;
      uint64_t v70 = v67 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v71 = *(_OWORD *)v69;
        *(v68 - 1) = *((_OWORD *)v69 - 1);
        _OWORD *v68 = v71;
        v68 -= 2;
        v69 -= 32;
        v70 -= 4;
      }
      while (v70);
      v64 -= v67 & 0x3FFFFFFFFFFFFFFCLL;
      v56 -= 8 * (v67 & 0x3FFFFFFFFFFFFFFCLL);
      if (v67 != (v67 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_105:
        do
        {
          uint64_t v72 = (char *)*((void *)v56 - 1);
          v56 -= 8;
          *--char v64 = v72;
        }
        while (v56 != v58);
        uint64_t v58 = *(char **)(a1 + 112);
      }
    }
    *(void *)(a1 + 112) = v64;
    *(void *)(a1 + 120) = v57;
    *(void *)(a1 + 128) = v65;
    if (v58) {
      operator delete(v58);
    }
  }
  else
  {
    *(void *)int v56 = v14;
    uint64_t v57 = v56 + 8;
  }
  *(void *)(a1 + 120) = v57;
  uint64_t v74 = *(char **)(a1 + 144);
  unint64_t v73 = *(void *)(a1 + 152);
  if ((unint64_t)v74 < v73)
  {
    *(void *)uint64_t v74 = v35;
    float v75 = v74 + 8;
    goto LABEL_99;
  }
  uint64_t v76 = *(char **)(a1 + 136);
  uint64_t v77 = (v74 - v76) >> 3;
  unint64_t v78 = v77 + 1;
  if ((unint64_t)(v77 + 1) >> 61) {
LABEL_100:
  }
    abort();
  uint64_t v79 = v73 - (void)v76;
  if (v79 >> 2 > v78) {
    unint64_t v78 = v79 >> 2;
  }
  if ((unint64_t)v79 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v80 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v80 = v78;
  }
  if (v80)
  {
    if (!(v80 >> 61))
    {
      uint64_t v81 = operator new(8 * v80);
      goto LABEL_90;
    }
LABEL_101:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  uint64_t v81 = 0;
LABEL_90:
  uint64_t v82 = &v81[8 * v77];
  unint64_t v83 = &v81[8 * v80];
  *uint64_t v82 = v35;
  float v75 = v82 + 1;
  if (v74 != v76)
  {
    unint64_t v84 = v74 - v76 - 8;
    if (v84 < 0x58) {
      goto LABEL_106;
    }
    if ((unint64_t)(v76 - v81) < 0x20) {
      goto LABEL_106;
    }
    uint64_t v85 = (v84 >> 3) + 1;
    unint64_t v86 = &v81[8 * v77 - 16];
    size_t v87 = v74 - 16;
    uint64_t v88 = v85 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v89 = *(_OWORD *)v87;
      *(v86 - 1) = *((_OWORD *)v87 - 1);
      *unint64_t v86 = v89;
      v86 -= 2;
      v87 -= 32;
      v88 -= 4;
    }
    while (v88);
    v82 -= v85 & 0x3FFFFFFFFFFFFFFCLL;
    v74 -= 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
    if (v85 != (v85 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_106:
      do
      {
        uint64_t v90 = *((void *)v74 - 1);
        v74 -= 8;
        *--uint64_t v82 = v90;
      }
      while (v74 != v76);
    }
  }
  *(void *)(a1 + 136) = v82;
  *(void *)(a1 + 144) = v75;
  *(void *)(a1 + 152) = v83;
  if (v76) {
    operator delete(v76);
  }
LABEL_99:
  *(void *)(a1 + 144) = v75;
  return v35;
}

void sub_1A1A9B690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  md::MapEngineFrameService::Data::~Data((md::MapEngineFrameService::Data *)va);
  _Unwind_Resume(a1);
}

void sub_1A1A9B6A4(_Unwind_Exception *a1)
{
  md::MapEngineFrameService::Data::{unnamed type#2}::~Data(v1 + 80);
  _Unwind_Resume(a1);
}

void md::MapEngineCallbackGraphService::create(uint64_t a1)
{
  std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 8));
  uint64_t v2 = *(char **)(a1 + 216);
  if (!v2)
  {
    uint64_t v3 = (char *)malloc_type_malloc(*(void *)(a1 + 208), 0x160B39uLL);
    uint64_t v4 = v3;
    uint64_t v6 = (uint64_t **)(a1 + 184);
    uint64_t v5 = *(uint64_t **)(a1 + 184);
    if (v5)
    {
      do
      {
        while (1)
        {
          uint64_t v7 = (uint64_t **)v5;
          unint64_t v8 = v5[4];
          if ((unint64_t)v3 >= v8) {
            break;
          }
          uint64_t v5 = *v7;
          uint64_t v6 = v7;
          if (!*v7) {
            goto LABEL_9;
          }
        }
        if (v8 >= (unint64_t)v3) {
          goto LABEL_12;
        }
        uint64_t v5 = v7[1];
      }
      while (v5);
      uint64_t v6 = v7 + 1;
    }
    else
    {
      uint64_t v7 = (uint64_t **)(a1 + 184);
    }
LABEL_9:
    uint64_t v9 = (uint64_t *)operator new(0x28uLL);
    v9[4] = (uint64_t)v4;
    *uint64_t v9 = 0;
    v9[1] = 0;
    v9[2] = (uint64_t)v7;
    NSObject *v6 = v9;
    uint64_t v10 = **(void **)(a1 + 176);
    if (v10)
    {
      *(void *)(a1 + 176) = v10;
      uint64_t v9 = *v6;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 184), v9);
    ++*(void *)(a1 + 192);
LABEL_12:
    uint64_t v2 = *(char **)(a1 + 216);
    uint64_t v11 = 88 * *(void *)(a1 + 200) - 88;
    if ((v11 & 0x8000000000000000) == 0)
    {
      uint64_t v12 = &v4[v11];
      uint64_t v13 = &v4[v11];
      do
      {
        *(void *)uint64_t v13 = v2;
        v13 -= 88;
        uint64_t v2 = v12;
        uint64_t v12 = v13;
      }
      while (v13 >= v4);
      uint64_t v2 = v13 + 88;
    }
    *(void *)(a1 + 216) = v2;
  }
  *(void *)(a1 + 216) = *(void *)v2;
  *((_OWORD *)v2 + 1) = 0u;
  *((void *)v2 + 7) = 0;
  *(void *)uint64_t v2 = v2 + 16;
  *((void *)v2 + 1) = v2 + 56;
  *((_OWORD *)v2 + 2) = 0u;
  *((_DWORD *)v2 + 12) = 1065353216;
  *((void *)v2 + 8) = 0;
  *((void *)v2 + 9) = 0;
  operator new();
}

void sub_1A1A9BD10(_Unwind_Exception *a1)
{
  MEMORY[0x1A6239270](v2, 0x1020C40EDED9539);
  std::__shared_mutex_base::unlock(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<md::MapEngine::onDisplayLinkFired(double)::$_0,std::allocator<md::MapEngine::onDisplayLinkFired(double)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF520DB0;
}

void md::RouteOverlayContainer::addOverlay(uint64_t a1, void *a2, uint64_t a3)
{
  id v22 = a2;
  uint64_t v5 = (std::mutex *)(a1 + 96);
  std::mutex::lock((std::mutex *)(a1 + 96));
  if (a3) {
    uint64_t v6 = 48;
  }
  else {
    uint64_t v6 = 24;
  }
  if (a3) {
    uint64_t v7 = a1 + 48;
  }
  else {
    uint64_t v7 = a1 + 24;
  }
  uint64_t v9 = (uint64_t **)(v7 + 8);
  unint64_t v8 = *(uint64_t **)(v7 + 8);
  if (v8)
  {
    while (1)
    {
      while (1)
      {
        uint64_t v10 = (uint64_t **)v8;
        unint64_t v11 = v8[4];
        if (v11 <= (unint64_t)v22) {
          break;
        }
        unint64_t v8 = *v10;
        uint64_t v9 = v10;
        if (!*v10) {
          goto LABEL_15;
        }
      }
      if (v11 >= (unint64_t)v22) {
        break;
      }
      unint64_t v8 = v10[1];
      if (!v8)
      {
        uint64_t v9 = v10 + 1;
        goto LABEL_15;
      }
    }
  }
  else
  {
    uint64_t v10 = (uint64_t **)(v7 + 8);
LABEL_15:
    uint64_t v12 = (uint64_t *)operator new(0x28uLL);
    v12[4] = (uint64_t)v22;
    *uint64_t v12 = 0;
    v12[1] = 0;
    v12[2] = (uint64_t)v10;
    *uint64_t v9 = v12;
    uint64_t v13 = **(void **)(a1 + v6);
    if (v13)
    {
      *(void *)(a1 + v6) = v13;
      uint64_t v12 = *v9;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v7 + 8), v12);
    ++*(void *)(v7 + 16);
    uint64_t v14 = *(void **)(a1 + 8);
    if ((unint64_t)v14 >= *(void *)(a1 + 16))
    {
      uint64_t v16 = std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__emplace_back_slow_path<objc_object  {objcproto14VKRouteOverlay}*&,geo::memory_management_mode const&>((void **)a1, v22);
    }
    else
    {
      id v15 = v22;
      *uint64_t v14 = &unk_1EF559F98;
      v14[1] = v15;
      uint64_t v16 = (char *)(v14 + 3);
    }
    *(void *)(a1 + 8) = v16;
    CFTimeInterval v17 = *(void **)(a1 + 72);
    uint64_t v18 = (void *)(a1 + 80);
    if (v17 != v18)
    {
      do
      {
        (**(void (***)(void, id, uint64_t))v17[4])(v17[4], v22, a3);
        uint64_t v19 = (void *)v17[1];
        if (v19)
        {
          do
          {
            unint64_t v20 = v19;
            uint64_t v19 = (void *)*v19;
          }
          while (v19);
        }
        else
        {
          do
          {
            unint64_t v20 = (void *)v17[2];
            BOOL v21 = *v20 == (void)v17;
            CFTimeInterval v17 = v20;
          }
          while (!v21);
        }
        CFTimeInterval v17 = v20;
      }
      while (v20 != v18);
    }
  }
  std::mutex::unlock(v5);
}

void sub_1A1A9C098(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  std::mutex::unlock(v10);

  _Unwind_Resume(a1);
}

uint64_t non-virtual thunk to'md::RouteLineLayerDataSource::onOverlayAdded(uint64_t result)
{
  uint64_t v1 = *(void *)(result - 568);
  for (uint64_t i = *(void *)(v1 + 8); i != v1; uint64_t i = *(void *)(i + 8))
    *(void *)(*(void *)(i + 128) + 152) = 1;
  return result;
}

void *std::string::__assign_no_alias<true>(void *__dst, void *__src, size_t __len)
{
  if (__len > 0x16)
  {
    if (__len - 0x7FFFFFFFFFFFFFF7 <= 0x800000000000001ELL) {
      abort();
    }
    size_t v7 = 44;
    if (__len > 0x2C) {
      size_t v7 = __len;
    }
    size_t v8 = (v7 | 7) + 1;
    uint64_t v6 = operator new(v8);
    memcpy(v6, __src, __len);
    __dst[1] = __len;
    __dst[2] = v8 | 0x8000000000000000;
    void *__dst = v6;
  }
  else
  {
    *((unsigned char *)__dst + 23) = __len;
    uint64_t v6 = __dst;
    if (__len)
    {
      memmove(__dst, __src, __len);
      uint64_t v6 = __dst;
    }
  }
  *((unsigned char *)v6 + __len) = 0;
  return __dst;
}

void md::GeometryLogic::calculateGeocentricBounds(float32_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8 = *(void *)(a2 + 8);
  if ((*(unsigned char *)(a2 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    *(void *)uint64_t v54 = &v77;
    unint64_t v78 = v54;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v78, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  if (v8) {
    uint64_t v9 = *(void *)(a2 + 72);
  }
  else {
    uint64_t v9 = 0;
  }
  int v10 = *(_DWORD *)(v9 + 32);
  *(void *)&long long v11 = *(void *)(v9 + 36);
  int v12 = *(_DWORD *)(v9 + 56);
  *((void *)&v11 + 1) = *(void *)(v9 + 48);
  *(_OWORD *)&v54[4] = v11;
  LODWORD(v11) = *(_DWORD *)(v9 + 64);
  *(void *)&long long v13 = *(void *)(v9 + 68);
  int v55 = v12;
  int v56 = v11;
  *((void *)&v13 + 1) = *(void *)(v9 + 80);
  LODWORD(v11) = *(_DWORD *)(v9 + 88);
  long long v57 = v13;
  LODWORD(v13) = *(_DWORD *)(v9 + 96);
  *(void *)&long long v14 = *(void *)(v9 + 100);
  int v58 = v11;
  int v59 = v13;
  LODWORD(v13) = *(_DWORD *)(v9 + 120);
  *((void *)&v14 + 1) = *(void *)(v9 + 112);
  long long v60 = v14;
  LODWORD(v11) = *(_DWORD *)(v9 + 128);
  *(void *)&long long v14 = *(void *)(v9 + 132);
  int v61 = v13;
  int v62 = v11;
  *((void *)&v14 + 1) = *(void *)(v9 + 144);
  LODWORD(v11) = *(_DWORD *)(v9 + 152);
  long long v63 = v14;
  LODWORD(v13) = *(_DWORD *)(v9 + 160);
  *(void *)&long long v14 = *(void *)(v9 + 164);
  int v64 = v11;
  int v65 = v13;
  LODWORD(v13) = *(_DWORD *)(v9 + 184);
  *((void *)&v14 + 1) = *(void *)(v9 + 176);
  long long v66 = v14;
  LODWORD(v11) = *(_DWORD *)(v9 + 192);
  *(void *)&long long v14 = *(void *)(v9 + 196);
  int v67 = v13;
  int v68 = v11;
  *((void *)&v14 + 1) = *(void *)(v9 + 208);
  LODWORD(v11) = *(_DWORD *)(v9 + 216);
  long long v69 = v14;
  LODWORD(v13) = *(_DWORD *)(v9 + 224);
  *(void *)&long long v14 = *(void *)(v9 + 228);
  int v70 = v11;
  int v71 = v13;
  LODWORD(v13) = *(_DWORD *)(v9 + 248);
  *((void *)&v14 + 1) = *(void *)(v9 + 240);
  long long v72 = v14;
  LODWORD(v11) = *(_DWORD *)(v9 + 256);
  *(void *)&long long v14 = *(void *)(v9 + 260);
  int v73 = v13;
  int v74 = v11;
  *((void *)&v14 + 1) = *(void *)(v9 + 272);
  LODWORD(v11) = *(_DWORD *)(v9 + 280);
  long long v75 = v14;
  int v76 = v11;
  float v15 = *(float *)(v9 + 288);
  float v16 = *(float *)(v9 + 292);
  float v17 = *(float *)(v9 + 296);
  *(_DWORD *)(a4 + 8) = 0;
  *(void *)a4 = 0;
  *(_OWORD *)a3 = xmmword_1A28FC710;
  *(void *)(a3 + 16) = 0x80000000800000;
  *(float32_t *)&long long v11 = *a1;
  *(float32_t *)&long long v13 = a1[1];
  *(float *)&long long v14 = *(float *)(v9 + 8) + (float)(*(float *)(v9 + 12) * *(float *)&v13);
  *(_DWORD *)uint64_t v54 = v10;
  float v18 = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>((uint64_t)v54, *(float32_t *)&v11, *(float *)v9+ (float)((float)(*(float *)(v9 + 4) + (float)(*(float *)&v14 * *(float *)&v13)) * *(float *)&v13), *(double *)&v13);
  *(float *)a3 = v18;
  *(float *)(a3 + 4) = v19;
  *(float *)(a3 + 8) = v20;
  float v21 = v18 - v15;
  float v22 = v19 - v16;
  float v23 = v20 - v17;
  float v24 = 1.0 / sqrtf((float)((float)(v21 * v21) + (float)(v22 * v22)) + (float)(v23 * v23));
  *(float *)a4 = v24 * v21;
  *(float *)(a4 + 4) = v24 * v22;
  *(float *)(a4 + 8) = v24 * v23;
  float v25 = a1[4];
  *(float *)&double v26 = *(float *)(v9 + 4) + (float)((float)(*(float *)(v9 + 8) + (float)(*(float *)(v9 + 12) * v25)) * v25);
  *(float *)(a3 + 12) = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>((uint64_t)v54, a1[3], *(float *)v9 + (float)(*(float *)&v26 * v25), v26);
  *(_DWORD *)(a3 + 16) = v27;
  *(_DWORD *)(a3 + 20) = LODWORD(v30);
  float v28 = a1[1];
  float v29 = a1[3] - *a1;
  *(float *)&double v30 = a1[4] - v28;
  if (v29 >= 0.5 || *(float *)&v30 >= 0.5)
  {
    float v31 = v28 + (float)(*(float *)&v30 * 0.5);
    *(float *)&double v30 = *(float *)(v9 + 4)
                   + (float)((float)(*(float *)(v9 + 8) + (float)(*(float *)(v9 + 12) * v31)) * v31);
    float v32 = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>((uint64_t)v54, *a1 + (float)(v29 * 0.5), *(float *)v9 + (float)(*(float *)&v30 * v31), v30);
    v33.i32[3] = HIDWORD(*(_OWORD *)a3);
    v33.i64[0] = __PAIR64__(v34.u32[0], LODWORD(v32));
    v33.i32[2] = v35;
    float32x4_t v36 = *(float32x4_t *)a3;
    v36.f32[3] = v32;
    int8x16_t v37 = (int8x16_t)vcgtq_f32(v36, v33);
    v33.f32[3] = v32;
    int8x16_t v52 = vbslq_s8(v37, (int8x16_t)v33, *(int8x16_t *)a3);
    *(int8x16_t *)a3 = v52;
    v34.i32[1] = v35;
    float32x2_t v38 = vmaxnm_f32(*(float32x2_t *)(a3 + 16), v34);
    *(float32x2_t *)(a3 + 16) = v38;
    v34.f32[0] = a1[4];
    *(float *)&double v39 = *(float *)(v9 + 4)
                   + (float)((float)(*(float *)(v9 + 8) + (float)(*(float *)(v9 + 12) * v34.f32[0])) * v34.f32[0]);
    v40.i32[0] = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>((uint64_t)v54, *a1, *(float *)v9 + (float)(*(float *)&v39 * v34.f32[0]), v39);
    v40.i32[1] = v41.i32[0];
    v40.i64[1] = __PAIR64__(v52.u32[3], v42);
    float32x4_t v43 = (float32x4_t)v52;
    v43.i32[3] = v40.i32[0];
    int8x16_t v44 = (int8x16_t)vcgtq_f32(v43, v40);
    v40.i32[3] = v40.i32[0];
    int8x16_t v53 = vbslq_s8(v44, (int8x16_t)v40, v52);
    v41.i32[1] = v42;
    *(int8x16_t *)a3 = v53;
    float32x2_t v45 = vmaxnm_f32(v38, v41);
    *(float32x2_t *)(a3 + 16) = v45;
    v41.f32[0] = a1[1];
    *(float *)&double v46 = *(float *)(v9 + 4)
                   + (float)((float)(*(float *)(v9 + 8) + (float)(*(float *)(v9 + 12) * v41.f32[0])) * v41.f32[0]);
    v47.i32[0] = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>((uint64_t)v54, a1[3], *(float *)v9 + (float)(*(float *)&v46 * v41.f32[0]), v46);
    v47.i32[1] = v48.i32[0];
    v47.i64[1] = __PAIR64__(v53.u32[3], v49);
    float32x4_t v50 = (float32x4_t)v53;
    v50.i32[3] = v47.i32[0];
    int8x16_t v51 = (int8x16_t)vcgtq_f32(v50, v47);
    v47.i32[3] = v47.i32[0];
    *(int8x16_t *)a3 = vbslq_s8(v51, (int8x16_t)v47, v53);
    v48.i32[1] = v49;
    *(float32x2_t *)(a3 + 16) = vmaxnm_f32(v45, v48);
  }
}

float gdc::GlobeTileUtils::createSplinePatchFromMercatorRect(uint64_t a1, double *a2, double a3, double a4)
{
  gdc::GlobeTileUtils::boundsFromMercatorRect((uint64_t)&v208, a2, a3, a4);
  double v5 = v212;
  double v6 = v213;
  double v7 = v214;
  double v8 = v211;
  double v160 = v209;
  double v167 = v210;
  double v156 = v208;
  double v158 = -(v210 * v212 - v209 * v213) - (v210 * v212 - v209 * v213);
  double v169 = -(v209 * v211 - v208 * v212) - (v209 * v211 - v208 * v212);
  double v170 = -(v208 * v213 - v210 * v211) - (v208 * v213 - v210 * v211);
  double v165 = -(v208 * v213 - v210 * v211) * -2.0;
  double v166 = -(v210 * v212 - v209 * v213) * -2.0;
  double v164 = -(v209 * v211 - v208 * v212) * -2.0;
  double v152 = *a2;
  double v168 = a2[1];
  double v9 = a2[3];
  double v162 = v9;
  long double v10 = exp(v168 * 6.28318531 + -3.14159265);
  long double v155 = atan(v10) * 2.0 + -1.57079633;
  long double v11 = exp(v9 * 6.28318531 + -3.14159265);
  long double v12 = atan(v11);
  float v13 = v155;
  *(float *)&long double v12 = v12 * 2.0 + -1.57079633;
  *(float *)&long double v12 = *(float *)&v12 - v13;
  float v14 = v13 + (float)(*(float *)&v12 * 0.66667);
  long double v15 = tan((float)(v13 + (float)(*(float *)&v12 * 0.33333)) * 0.5 + 0.785398163);
  double v16 = log(v15);
  long double v17 = tan(v14 * 0.5 + 0.785398163);
  long double v18 = log(v17);
  unint64_t v19 = 0;
  uint64_t v20 = 0;
  float v21 = (0.5 - v168 + v16 * 0.159154943) / (v162 - v168);
  double v163 = v162 - v168;
  *(float *)&long double v18 = (0.5 - v168 + v18 * 0.159154943) / v163;
  v207[0] = 0;
  *(float *)&v207[1] = v21;
  v207[2] = LODWORD(v18);
  v207[3] = 1065353216;
  double v151 = a2[2] - v152;
  BOOL v22 = v218 < v215;
  if (v219 < v216) {
    BOOL v22 = 1;
  }
  double v157 = v156 + v215;
  double v23 = -(v160 - v158 * v6);
  double v159 = v217;
  double v161 = v216;
  char v24 = v220 < v217 || v22;
  double v153 = 1.0 / (v218 - v215);
  double v154 = v23;
  double v25 = 1.0 / (v219 - v216);
  double v26 = 1.0 / (v220 - v217);
  do
  {
    long double v27 = fmod((v152 + (double)v19 * 0.333333333 * v151) * 6.28318531, 6.28318531);
    long double v28 = fmod(v27 + 6.28318531, 6.28318531);
    __double2 v29 = __sincos_stret(v28 + -3.14159265);
    uint64_t v30 = 0;
    float v31 = (float *)&v175 + 3 * v20;
    do
    {
      if (v24)
      {
        memset_pattern16(&__b, &unk_1A28FFCE0, 0x18uLL);
        double v34 = *((double *)&__b + 1);
        v33.i64[0] = __b;
        double v35 = *(double *)&v238;
      }
      else
      {
        long double v39 = exp((v168 + v163 * *(float *)&v207[v30]) * 6.28318531 + -3.14159265);
        long double v40 = atan(v39);
        __double2 v41 = __sincos_stret(v40 * 2.0 + -1.57079633);
        double v42 = 6378137.0 / sqrt(v41.__sinval * v41.__sinval * -0.00669437999 + 1.0);
        double v43 = v42 * v41.__cosval * v29.__cosval;
        double v44 = v42 * v41.__cosval * v29.__sinval;
        double v45 = v41.__sinval * 0.99330562 * v42;
        double v46 = -(v45 * v5 - v44 * v6) - (v45 * v5 - v44 * v6);
        double v47 = -(v43 * v6 - v45 * v8) - (v43 * v6 - v45 * v8);
        double v48 = -(v44 * v8 - v43 * v5) - (v44 * v8 - v43 * v5);
        *(float *)v33.i32 = (v43 - v157 + (v47 + v165) * v6 + (v46 + v166) * v7 + (v169 - v48) * v5) * v153;
        *(double *)v33.i64 = *(float *)v33.i32;
        *(float *)&double v44 = (v154 + v44 + v47 * v7 + v48 * v8 - (v161 + v169 * v8 + v170 * v7 + v46 * v6)) * v25;
        double v34 = *(float *)&v44;
        *(float *)&double v45 = (v45 - v167 + (v48 + v164) * v7 + (v46 + v166) * v5 - v159 + (v170 - v47) * v8) * v26;
        double v35 = *(float *)&v45;
      }
      float v36 = *(double *)v33.i64;
      float v37 = v34;
      float v38 = v35;
      *(v31 - 1) = v36;
      *float v31 = v37;
      v31[1] = v38;
      ++v30;
      v31 += 3;
    }
    while (v30 != 4);
    v20 += 4;
    ++v19;
  }
  while (v19 != 4);
  float v49 = v174;
  *(float *)a1 = v174;
  float v50 = v180;
  v33.i64[0] = v202;
  v51.i64[1] = __PAIR64__(v33.u32[3], v203);
  *(_DWORD *)(a1 + 152) = v203;
  *(void *)(a1 + 144) = v33.i64[0];
  float v52 = *(float *)v206;
  *(void *)(a1 + 180) = *(void *)v206;
  *(_DWORD *)(a1 + 188) = *(_DWORD *)&v206[8];
  float32x2_t v53 = (float32x2_t)vdup_n_s32(0xBE97B424);
  float v54 = v49 * -0.2963;
  float v55 = v49 * -0.037037;
  *(int32x2_t *)v32.i8 = vdup_n_s32(0xBD17B427);
  float32_t v56 = (float)((float)(v49 * -0.2963) + (float)(v50 * -0.037037)) + v176;
  float32x2_t v57 = (float32x2_t)vdup_n_s32(0xBE97B427);
  float32_t v58 = (float)((float)(v49 * -0.037037) + (float)(v50 * -0.2963)) + v178;
  _D18 = (float32x2_t)vdup_n_s32(0x3EE38E39u);
  float32x4_t v60 = (float32x4_t)vdupq_n_s32(0x40D80003u);
  *(float *)(a1 + 12) = (float)((float)(v58 * -0.22222) + (float)(v56 * 0.44444)) * 6.75;
  float32x2_t v61 = v175;
  *(float32x2_t *)(a1 + 4) = v175;
  float32x2_t v62 = v181;
  *(float32x2_t *)(a1 + 40) = v181;
  float32x2_t v63 = vmul_f32(v61, v53);
  float32x2_t v64 = vmul_f32(v61, (float32x2_t)vdup_n_s32(0xBD17B424));
  _D19 = vmla_f32(vadd_f32(v179, v64), v57, v62);
  float32x2_t v66 = vmla_f32(vadd_f32(v177, v63), *(float32x2_t *)v32.i8, v62);
  float32x2_t v67 = (float32x2_t)vdup_n_s32(0x3E638E37u);
  float32x2_t v68 = (float32x2_t)vdup_lane_s32((int32x2_t)_D19, 0);
  v68.f32[0] = v58;
  float32x2_t v69 = (float32x2_t)vdup_n_s32(0x3EE38E37u);
  _S28 = 1055100471;
  __asm { FMLA            S12, S28, V19.S[1] }
  float32x2_t v76 = vmul_f32(vmla_f32(vneg_f32(vmul_f32(_D19, v67)), _D18, v66), *(float32x2_t *)v60.f32);
  _D11 = (float32x2_t)vdup_lane_s32((int32x2_t)v66, 0);
  _D11.f32[0] = v56;
  float32x2_t v78 = (float32x2_t)vdup_n_s32(0x3E638E39u);
  *(float32x2_t *)(a1 + 16) = v76;
  *(float32x2_t *)(a1 + 24) = vmul_f32(vmla_f32(vneg_f32(vmul_f32(_D11, v78)), v69, v68), *(float32x2_t *)v60.f32);
  *(float *)(a1 + 32) = _S12 * 6.75;
  *(float *)(a1 + 36) = v50;
  float32_t v79 = vmlas_n_f32(v54, -0.037037, *(float *)v33.i32) + v182;
  float32_t v80 = vmlas_n_f32(v55, -0.2963, *(float *)v33.i32) + v192;
  *(float *)(a1 + 48) = (float)((float)(v80 * -0.22222) + (float)(v79 * 0.44444)) * 6.75;
  *((void *)&v81 + 1) = v51.i64[1];
  *(void *)&long long v81 = v33.i64[0];
  v51.i64[0] = v81 >> 32;
  _D30 = vmla_f32(vadd_f32(v193, v64), v57, *(float32x2_t *)v51.i8);
  float32x2_t v83 = vmla_f32(vadd_f32(v183, v63), *(float32x2_t *)v32.i8, *(float32x2_t *)v51.i8);
  __asm { FMLA            S11, S28, V30.S[1] }
  *(float32x2_t *)(a1 + 52) = vmul_f32(vmla_f32(vneg_f32(vmul_f32(_D30, v67)), _D18, v83), *(float32x2_t *)v60.f32);
  float32x2_t v84 = (float32x2_t)vdup_lane_s32((int32x2_t)_D30, 0);
  v84.f32[0] = v80;
  float32x2_t v85 = (float32x2_t)vdup_lane_s32((int32x2_t)v83, 0);
  v85.f32[0] = v79;
  *(float *)(a1 + 104) = _D11.f32[0] * 6.75;
  float32_t v86 = (float)((float)(-0.037037 * v52) + (float)(v50 * -0.2963)) + v190;
  float32_t v87 = (float)((float)(-0.2963 * v52) + (float)(v50 * -0.037037)) + v200;
  *(float *)(a1 + 84) = (float)((float)(v87 * -0.22222) + (float)(v86 * 0.44444)) * 6.75;
  *(float32x2_t *)v32.i8 = vmul_f32(*(float32x2_t *)&v206[4], *(float32x2_t *)v32.i8);
  float32x2_t v88 = (float32x2_t)vdup_n_s32(0x3D17B424u);
  float32x2_t v89 = vmul_f32(*(float32x2_t *)&v206[4], v57);
  _D22 = vadd_f32(v89, vmls_f32(v201, v88, v62));
  float32x2_t v91 = vadd_f32(*(float32x2_t *)v32.i8, vmla_f32(v191, v53, v62));
  float32x2_t v92 = vmul_f32(vmla_f32(vneg_f32(vmul_f32(_D22, v67)), _D18, v91), *(float32x2_t *)v60.f32);
  __asm { FMLA            S18, S28, V22.S[1] }
  *(float32x2_t *)(a1 + 88) = v92;
  *(float32x2_t *)(a1 + 96) = vmul_f32(vmla_f32(vneg_f32(vmul_f32(v85, v78)), v69, v84), *(float32x2_t *)v60.f32);
  float32x2_t v93 = (float32x2_t)vdup_lane_s32((int32x2_t)_D22, 0);
  v93.f32[0] = v87;
  float32x2_t v94 = (float32x2_t)vdup_lane_s32((int32x2_t)v91, 0);
  v94.f32[0] = v86;
  *(float32x2_t *)(a1 + 132) = vmul_f32(vmla_f32(vneg_f32(vmul_f32(v94, v78)), v69, v93), *(float32x2_t *)v60.f32);
  *(float *)(a1 + 140) = _D18.f32[0] * 6.75;
  float32x4_t v95 = (float32x4_t)vextq_s8(v33, v51, 0xCuLL);
  v95.i32[0] = v33.i32[0];
  v95.i32[3] = v33.i32[0];
  float32x4_t v96 = (float32x4_t)vextq_s8((int8x16_t)xmmword_1A28FD3B0, v32, 0xCuLL);
  v96.f32[0] = -0.037037 * v52;
  v96.f32[3] = -0.2963 * v52;
  float32x4_t v97 = vaddq_f32(vmlaq_f32(v96, (float32x4_t)xmmword_1A28FD3B0, v95), v204);
  float32x4_t v98 = (float32x4_t)vextq_s8((int8x16_t)v97, vextq_s8((int8x16_t)v97, (int8x16_t)v97, 8uLL), 0xCuLL);
  *(float32x2_t *)&v98.i32[1] = vadd_f32(vmls_f32(v89, v88, *(float32x2_t *)v51.i8), v205);
  *(float32x4_t *)(a1 + 156) = vmulq_f32(vmlaq_f32(vmulq_f32(v98, (float32x4_t)xmmword_1A28FD3D0), (float32x4_t)xmmword_1A28FD3C0, v97), v60);
  *(float32x2_t *)(a1 + 172) = vmul_f32(vmla_f32(vneg_f32(vmul_f32((float32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v97, (int8x16_t)v97, 4uLL), v78)), v69, *(float32x2_t *)&v98.i32[1]), *(float32x2_t *)v60.f32);
  long long __b = xmmword_1A28FD3E0;
  long long v238 = xmmword_1A28FD3F0;
  long long v239 = xmmword_1A28FD400;
  long long v240 = xmmword_1A28FD410;
  gm::Matrix<float,4,4>::inverted<int,void>(&v221, (float *)&__b);
  *(void *)(a1 + 68) = 0;
  *(void *)(a1 + 60) = 0;
  *(void *)(a1 + 76) = 0;
  *(void *)(a1 + 108) = 0;
  *(void *)(a1 + 124) = 0;
  *(void *)(a1 + 116) = 0;
  float v100 = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>(a1, 0.33333, 0.33333, v99);
  float v102 = v101;
  float v173 = *(float *)&v103;
  v76.i32[0] = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>(a1, 0.33333, 0.66667, v103);
  float v105 = v104;
  float v172 = *(float *)&v106;
  float v107 = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>(a1, 0.66667, 0.33333, v106);
  v68.i32[0] = v108;
  float v171 = *(float *)&v109;
  float v110 = gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>(a1, 0.66667, 0.66667, v109);
  float v111 = v221;
  float v112 = v222;
  float v113 = v225;
  float v114 = v226;
  float v115 = v229;
  float v116 = v230;
  float v117 = v233;
  float v118 = v234;
  float v119 = v223;
  float v120 = v224;
  float v121 = v227;
  float v122 = v228;
  float v123 = v184 - v100;
  float v124 = v186;
  float v125 = v196;
  float v126 = v197 - v110;
  float v127 = v231;
  *(float *)v51.i32 = v232;
  float v128 = (float)((float)((float)(v221 * (float)(v184 - v100)) + (float)(v225 * (float)(v187 - v76.f32[0])))
               + (float)(v229 * (float)(v194 - v107)))
       + (float)(v233 * v126);
  float v129 = (float)((float)((float)(v222 * (float)(v184 - v100)) + (float)(v226 * (float)(v187 - v76.f32[0])))
               + (float)(v230 * (float)(v194 - v107)))
       + (float)(v234 * v126);
  float v130 = (float)((float)(v223 * (float)(v184 - v100)) + (float)(v227 * (float)(v187 - v76.f32[0])))
       + (float)(v231 * (float)(v194 - v107));
  float v131 = (float)((float)(v224 * v123) + (float)(v228 * (float)(v187 - v76.f32[0])))
       + (float)(v232 * (float)(v194 - v107));
  float v132 = v235;
  v76.f32[0] = v236;
  float v133 = v130 + (float)(v235 * v126);
  float v134 = v131 + (float)(v236 * v126);
  float v135 = v185 - v102;
  float v136 = v189;
  float v137 = v188 - v105;
  float v138 = v195 - v68.f32[0];
  v68.i32[0] = v199;
  float v140 = v198 - v139;
  float v141 = (float)(v221 * v135) + (float)(v225 * (float)(v188 - v105));
  float v142 = (float)(v222 * v135) + (float)(v226 * v137);
  _D11.f32[0] = (float)((float)(v223 * v135) + (float)(v227 * v137)) + (float)(v231 * v138);
  float v143 = (float)((float)(v224 * v135) + (float)(v228 * v137)) + (float)(v232 * v138);
  float v144 = (float)(v141 + (float)(v229 * v138)) + (float)(v233 * v140);
  float v145 = (float)(v142 + (float)(v230 * v138)) + (float)(v234 * v140);
  _D11.f32[0] = _D11.f32[0] + (float)(v235 * v140);
  float v146 = v143 + (float)(v236 * v140);
  *(float *)(a1 + 60) = v128;
  *(float *)(a1 + 64) = v144;
  *(float *)(a1 + 108) = v133;
  *(_DWORD *)(a1 + 112) = _D11.i32[0];
  float v148 = v68.f32[0] - v147;
  *(float *)(a1 + 68) = (float)((float)((float)(v111 * (float)(v124 - v173)) + (float)(v113 * (float)(v136 - v172)))
                              + (float)(v115 * (float)(v125 - v171)))
                      + (float)(v117 * v148);
  *(float *)(a1 + 72) = v129;
  *(float *)(a1 + 76) = v145;
  *(float *)(a1 + 80) = (float)((float)((float)(v112 * (float)(v124 - v173)) + (float)(v114 * (float)(v136 - v172)))
                              + (float)(v116 * (float)(v125 - v171)))
                      + (float)(v118 * v148);
  *(float *)(a1 + 116) = (float)((float)((float)(v119 * (float)(v124 - v173)) + (float)(v121 * (float)(v136 - v172)))
                               + (float)(v127 * (float)(v125 - v171)))
                       + (float)(v132 * v148);
  *(float *)(a1 + 120) = v134;
  float result = (float)((float)((float)(v120 * (float)(v124 - v173)) + (float)(v122 * (float)(v136 - v172)))
                 + (float)(*(float *)v51.i32 * (float)(v125 - v171)))
         + (float)(v76.f32[0] * v148);
  *(float *)(a1 + 124) = v146;
  *(float *)(a1 + 128) = result;
  return result;
}

float geo::Frustum<float>::calculateCorners(float *a1, float *a2)
{
  gm::Matrix<float,4,4>::inverted<int,void>(&v40, a2);
  float v3 = v40;
  float v4 = v41;
  float v6 = v44;
  float v5 = v45;
  float v7 = v44 + v40;
  float v8 = v52;
  float v9 = v53;
  float v10 = v45 + v41;
  float v11 = v48;
  float v12 = v49;
  float v13 = v42;
  float v14 = v43;
  float v15 = v46;
  float v16 = v47;
  float v17 = v46 + v42;
  float v18 = v54;
  float v19 = v55;
  float v20 = v47 + v43;
  float v21 = v50;
  float v22 = v51;
  float v23 = 1.0 / (float)(v55 - (float)(v47 + v43));
  float v24 = v23 * (float)(v53 - (float)(v45 + v41));
  float v25 = v23 * (float)(v54 - (float)(v46 + v42));
  a1[24] = v23 * (float)(v52 - (float)(v44 + v40));
  a1[25] = v24;
  float v26 = v8 + v11;
  float v27 = v19 + v22;
  float v28 = 1.0 / (float)((float)(v19 + v22) - v20);
  a1[26] = v25;
  a1[27] = v28 * (float)((float)(v8 + v11) - v7);
  a1[28] = v28 * (float)((float)(v9 + v12) - v10);
  a1[29] = v28 * (float)((float)(v18 + v21) - v17);
  float v29 = 1.0 / (float)(v19 + (float)(v16 - v14));
  a1[30] = v29 * (float)(v8 + (float)(v6 - v3));
  a1[31] = v29 * (float)(v9 + (float)(v5 - v4));
  float v30 = 1.0 / (float)(v27 + (float)(v16 - v14));
  a1[32] = v29 * (float)(v18 + (float)(v15 - v13));
  a1[33] = v30 * (float)((float)(v8 + v11) + (float)(v6 - v3));
  a1[34] = v30 * (float)((float)(v9 + v12) + (float)(v5 - v4));
  a1[35] = v30 * (float)((float)(v18 + v21) + (float)(v15 - v13));
  float v31 = v3 - v6;
  float v32 = v4 - v5;
  float v33 = v13 - v15;
  float v34 = v14 - v16;
  float v35 = 1.0 / (float)(v19 + v34);
  a1[36] = v35 * (float)(v8 + v31);
  a1[37] = v35 * (float)(v9 + v32);
  float v36 = 1.0 / (float)(v27 + v34);
  a1[38] = v35 * (float)(v18 + v33);
  a1[39] = v36 * (float)((float)(v8 + v11) + v31);
  a1[40] = v36 * (float)((float)(v9 + v12) + v32);
  a1[41] = v36 * (float)((float)(v18 + v21) + v33);
  float v37 = 1.0 / (float)(v19 + v20);
  a1[42] = v37 * (float)(v8 + v7);
  a1[43] = v37 * (float)(v9 + v10);
  float v38 = 1.0 / (float)(v27 + v20);
  a1[44] = v37 * (float)(v18 + v17);
  a1[45] = v38 * (float)(v26 + v7);
  float result = v38 * (float)((float)(v18 + v21) + v17);
  a1[46] = v38 * (float)((float)(v9 + v12) + v10);
  a1[47] = result;
  return result;
}

float gm::Matrix<float,4,4>::inverted<int,void>(float *a1, float *a2)
{
  float v2 = a2[12];
  float v3 = a2[13];
  float v5 = a2[8];
  float v4 = a2[9];
  float v6 = a2[7];
  float v7 = a2[11];
  float v8 = v2;
  float v10 = a2[5];
  float v9 = a2[6];
  float v11 = a2[4];
  float v12 = a2[14];
  float v13 = a2[15];
  float v14 = a2[10];
  float v16 = a2[3];
  float v15 = v11;
  float v18 = a2[1];
  float v17 = a2[2];
  float v19 = *a2;
  float v20 = 1.0
      / (float)((float)((float)((float)((float)((float)((float)((float)((float)((float)(v4 * v2) - (float)(v3 * v5)) * v9)
                                                              + (float)((float)((float)(v10 * v5) - (float)(v11 * v4))
                                                                      * v12))
                                                      + (float)((float)((float)(v11 * v3) - (float)(v10 * v2)) * v14))
                                              * v16)
                                      + (float)((float)((float)((float)((float)(v18 * v11) * v12)
                                                              + (float)(v17 * (float)(v10 * v2)))
                                                      + (float)((float)(*a2 * v3) * v9))
                                              * v7))
                              + (float)((float)((float)((float)(v17 * (float)(v11 * v4))
                                                      + (float)((float)(v18 * v5) * v9))
                                              + (float)((float)(*a2 * v10) * v14))
                                      * v13))
                      + (float)((float)((float)((float)(v17 * (float)(v3 * v5)) + (float)((float)(v18 * v2) * v14))
                                      + (float)((float)(*a2 * v4) * v12))
                              * v6))
              - (float)((float)((float)((float)((float)((float)((float)(v13 * v17) * (float)(v10 * v5))
                                                      + (float)((float)(v6 * v17) * (float)(v4 * v2)))
                                              + (float)((float)(v7 * v12) * (float)(*a2 * v10)))
                                      + (float)((float)((float)(v17 * (float)(v11 * v3))
                                                      + (float)((float)(v18 * v2) * v9))
                                              * v7))
                              + (float)((float)((float)((float)(v18 * v5) * v12) + (float)((float)(*a2 * v3) * v14)) * v6))
                      + (float)((float)((float)((float)(v18 * v11) * v14) + (float)((float)(*a2 * v4) * v9)) * v13)));
  *a1 = (float)((float)((float)((float)((float)(v9 * v3) * v7)
                              + (float)((float)((float)(v12 * v4) - (float)(v14 * v3)) * v6))
                      + (float)((float)(v10 * v14) * v13))
              - (float)((float)(v13 * (float)(v9 * v4)) + (float)((float)(v10 * v12) * v7)))
      * v20;
  a1[1] = (float)((float)((float)((float)(v16 * (float)((float)(v14 * v3) - (float)(v12 * v4)))
                                + (float)((float)(v17 * v4) * v13))
                        + (float)((float)(v18 * v12) * v7))
                - (float)((float)((float)(v17 * v3) * v7) + (float)((float)(v18 * v14) * v13)))
        * v20;
  a1[2] = (float)((float)((float)((float)(v16 * (float)((float)(v10 * v12) - (float)(v9 * v3)))
                                + (float)((float)(v17 * v3) * v6))
                        + (float)((float)(v18 * v9) * v13))
                - (float)((float)((float)(v17 * v10) * v13) + (float)((float)(v18 * v12) * v6)))
        * v20;
  a1[3] = (float)((float)((float)((float)(v16 * (float)((float)(v9 * v4) - (float)(v10 * v14)))
                                + (float)((float)(v17 * v10) * v7))
                        + (float)((float)(v18 * v14) * v6))
                - (float)((float)((float)(v17 * v4) * v6) + (float)((float)(v18 * v9) * v7)))
        * v20;
  a1[4] = (float)((float)((float)((float)((float)(v8 * v14) - (float)(v5 * v12)) * v6)
                        + (float)((float)((float)(v5 * v9) - (float)(v11 * v14)) * v13))
                + (float)((float)((float)(v11 * v12) - (float)(v8 * v9)) * v7))
        * v20;
  a1[5] = (float)((float)((float)((float)((float)(v8 * v17) * v7)
                                + (float)((float)((float)(v5 * v12) - (float)(v8 * v14)) * v16))
                        + (float)((float)(v19 * v14) * v13))
                - (float)((float)((float)(v5 * v17) * v13) + (float)((float)(v19 * v12) * v7)))
        * v20;
  a1[6] = (float)((float)((float)((float)((float)(v8 * v9) - (float)(v11 * v12)) * v16)
                        + (float)((float)((float)(v11 * v17) - (float)(v19 * v9)) * v13))
                + (float)((float)((float)(v19 * v12) - (float)(v8 * v17)) * v6))
        * v20;
  a1[7] = (float)((float)((float)((float)((float)(v5 * v17) * v6)
                                + (float)((float)((float)(v11 * v14) - (float)(v5 * v9)) * v16))
                        + (float)((float)(v19 * v9) * v7))
                - (float)((float)((float)(v11 * v17) * v7) + (float)((float)(v19 * v14) * v6)))
        * v20;
  float v21 = (float)(v5 * v3) - (float)(v8 * v4);
  float v22 = v8 * v10;
  float v23 = v11 * v3;
  float v24 = v5 * v10;
  float v25 = v11 * v4;
  float v26 = (float)((float)((float)((float)((float)(v8 * v10) * v7) + (float)(v21 * v6)) + (float)((float)(v15 * v4) * v13))
              - (float)((float)((float)(v5 * v10) * v13) + (float)((float)(v15 * v3) * v7)))
      * v20;
  float v27 = (float)(v8 * v4) - (float)(v5 * v3);
  float v28 = v8 * v18;
  float v29 = v19 * v3;
  float v30 = v5 * v18;
  float v31 = v19 * v4;
  a1[8] = v26;
  a1[9] = (float)((float)((float)(v27 * v16) + (float)((float)(v30 - v31) * v13)) + (float)((float)(v29 - v28) * v7))
        * v20;
  float v32 = v15 * v18;
  float v33 = v19 * v10;
  a1[10] = (float)((float)((float)((float)(v28 * v6) + (float)((float)(v23 - v22) * v16)) + (float)(v33 * v13))
                 - (float)((float)(v32 * v13) + (float)(v29 * v6)))
         * v20;
  a1[11] = (float)((float)((float)((float)(v24 - v25) * v16) + (float)((float)(v32 - v33) * v7))
                 + (float)((float)(v31 - v30) * v6))
         * v20;
  a1[12] = (float)((float)((float)(v27 * v9) + (float)((float)(v24 - v25) * v12)) + (float)((float)(v23 - v22) * v14))
         * v20;
  a1[13] = (float)((float)((float)((float)(v28 * v14) + (float)(v21 * v17)) + (float)(v31 * v12))
                 - (float)((float)(v30 * v12) + (float)(v29 * v14)))
         * v20;
  float result = (float)((float)((float)((float)(v30 * v9) + (float)((float)(v25 - v24) * v17)) + (float)(v33 * v14))
                 - (float)((float)(v32 * v14) + (float)(v31 * v9)))
         * v20;
  a1[14] = (float)((float)((float)((float)(v22 - v23) * v17) + (float)((float)(v32 - v33) * v12))
                 + (float)((float)(v29 - v28) * v9))
         * v20;
  a1[15] = result;
  return result;
}

float gm::cubicBezierPatch<gm::Matrix<float,3,1>,float>(uint64_t a1, float32_t a2, float32_t a3, double a4)
{
  v4.f32[0] = 1.0 - a3;
  float32_t v5 = (float)(1.0 - a3) * 3.0;
  float v6 = v5 * (float)(a3 * a3);
  float v7 = (float)(a3 * a3) * a3;
  _D17 = *(float32x2_t *)a1;
  float32x2_t v9 = *(float32x2_t *)(a1 + 12);
  _S6 = *(_DWORD *)(a1 + 20);
  _D22.i32[0] = vdup_lane_s32((int32x2_t)v4, 0).u32[0];
  _D22.f32[1] = a3;
  float32x2_t v12 = vmul_n_f32(_D22, 1.0 - a3);
  v4.f32[1] = v5;
  _D22.i32[0] = *(void *)(a1 + 48);
  _D22.i32[1] = v9.i32[1];
  _D19 = vmul_f32(v12, v4);
  v9.i32[1] = HIDWORD(*(void *)(a1 + 48));
  float32x2_t v14 = (float32x2_t)vrev64_s32((int32x2_t)_D19);
  float32x2_t v15 = vmul_f32(v9, v14);
  v9.i32[0] = *(void *)(a1 + 60);
  v9.i32[1] = HIDWORD(*(void *)a1);
  float32x2_t v16 = vmul_f32(v9, v14);
  _D17.i32[1] = HIDWORD(*(void *)(a1 + 60));
  float32x2_t v17 = vmla_lane_f32(vmul_n_f32(*(float32x2_t *)(a1 + 144), _D19.f32[0]), *(float32x2_t *)(a1 + 156), _D19, 1);
  float32x2_t v18 = vmla_lane_f32(vmul_n_f32(*(float32x2_t *)(a1 + 96), _D19.f32[0]), *(float32x2_t *)(a1 + 108), _D19, 1);
  float32x2_t v19 = vmla_f32(v15, _D19, _D17);
  float32x2_t v20 = vmla_f32(v16, _D19, _D22);
  _D22.i32[0] = *(_DWORD *)(a1 + 164);
  __asm { FMLA            S17, S22, V19.S[1] }
  _D22.i32[0] = *(_DWORD *)(a1 + 116);
  __asm { FMLA            S23, S22, V19.S[1] }
  _D22.i32[0] = *(_DWORD *)(a1 + 68);
  __asm { FMLA            S16, S22, V19.S[1] }
  float32x2_t v27 = *(float32x2_t *)(a1 + 24);
  __asm { FMLA            S7, S6, V19.S[1] }
  _D19.i32[0] = *(void *)(a1 + 72);
  _D19.i32[1] = v27.i32[1];
  v27.i32[1] = HIDWORD(*(void *)(a1 + 72));
  _D1 = vmla_n_f32(v19, v27, v6);
  float32x2_t v30 = *(float32x2_t *)(a1 + 36);
  v31.i32[0] = *(void *)(a1 + 84);
  v31.i32[1] = v30.i32[1];
  v30.i32[1] = HIDWORD(*(void *)(a1 + 84));
  *(float *)&a4 = 1.0 - a2;
  float32x2_t v32 = vmla_n_f32(vmla_n_f32(v20, _D19, v6), v31, v7);
  _D19.i32[0] = vdup_lane_s32(*(int32x2_t *)&a4, 0).u32[0];
  _S16 = (float)(_S16 + (float)(*(float *)(a1 + 80) * v6)) + (float)(*(float *)(a1 + 92) * v7);
  _D19.f32[1] = a2;
  *((float *)&a4 + 1) = (float)(1.0 - a2) * 3.0;
  _D2 = vmul_f32(vmul_n_f32(_D19, 1.0 - a2), *(float32x2_t *)&a4);
  float32x2_t v35 = vmla_f32(vmul_f32(v32, (float32x2_t)vrev64_s32((int32x2_t)_D2)), _D2, vmla_n_f32(_D1, v30, v7));
  __asm { FMLA            S1, S16, V2.S[1] }
  LODWORD(result) = vmla_n_f32(vmla_n_f32(v35, vmla_n_f32(vmla_n_f32(v18, *(float32x2_t *)(a1 + 120), v6), *(float32x2_t *)(a1 + 132), v7), (float)((float)(1.0 - a2) * 3.0) * (float)(a2 * a2)), vmla_n_f32(vmla_n_f32(v17, *(float32x2_t *)(a1 + 168), v6), *(float32x2_t *)(a1 + 180), v7), (float)(a2 * a2) * a2).u32[0];
  return result;
}

uint64_t md::Logic<md::ResolvedSceneLogic,md::SceneContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x99BED48DEFBBD82BLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>::resolveDependencies(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ResolvedSceneLogic,md::SceneContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x99BED48DEFBBD82BLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>::resolveDependencies(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::ResolvedSceneLogic,md::SceneContext,md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>>::_runAfterLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x99BED48DEFBBD82BLL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>::resolveDependencies(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 136))(v5, a2, v6, v3);
    }
  }
  return result;
}

void *md::LogicDependencies<gdc::TypeList<md::PendingSceneContext>,gdc::TypeList<md::DrapingContext,md::FlyoverCompleteTileDataContext>>::resolveDependencies(void *result, uint64_t a2, unint64_t a3)
{
  if (!a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    goto LABEL_71;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v4 = 0x9F2276D081C2CB20;
    if (a3 <= 0x9F2276D081C2CB20) {
      unint64_t v4 = 0x9F2276D081C2CB20 % a3;
    }
  }
  else
  {
    unint64_t v4 = (a3 - 1) & 0x9F2276D081C2CB20;
  }
  float v7 = *(void **)(a2 + 8 * v4);
  if (!v7) {
    goto LABEL_25;
  }
  float v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_25;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v10 = v8[1];
      if (v10 == 0x9F2276D081C2CB20)
      {
        if (v8[2] == 0x9F2276D081C2CB20) {
          goto LABEL_23;
        }
      }
      else if ((v10 & (a3 - 1)) != v4)
      {
        goto LABEL_25;
      }
      float v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v8[1];
    if (v9 == 0x9F2276D081C2CB20) {
      break;
    }
    if (v9 >= a3) {
      v9 %= a3;
    }
    if (v9 != v4) {
      goto LABEL_25;
    }
LABEL_12:
    float v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_25;
    }
  }
  if (v8[2] != 0x9F2276D081C2CB20) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v11 = v8[5];
  if (*(void *)(v11 + 8) == 0x9F2276D081C2CB20)
  {
    uint64_t v5 = *(void *)(v11 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v5 = 0;
LABEL_26:
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v12 = 0x1B9039CBDAB12E5CLL;
    if (a3 <= 0x1B9039CBDAB12E5CLL) {
      uint64_t v12 = 0x1B9039CBDAB12E5CLL % a3;
    }
  }
  else
  {
    uint64_t v12 = (a3 - 1) & 0x1B9039CBDAB12E5CLL;
  }
  float v13 = *(void **)(a2 + 8 * v12);
  if (!v13) {
    goto LABEL_48;
  }
  float32x2_t v14 = (void *)*v13;
  if (!v14) {
    goto LABEL_48;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v16 = v14[1];
      if (v16 == 0x1B9039CBDAB12E5CLL)
      {
        if (v14[2] == 0x1B9039CBDAB12E5CLL) {
          goto LABEL_46;
        }
      }
      else if ((v16 & (a3 - 1)) != v12)
      {
        goto LABEL_48;
      }
      float32x2_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v15 = v14[1];
    if (v15 != 0x1B9039CBDAB12E5CLL)
    {
      if (v15 >= a3) {
        v15 %= a3;
      }
      if (v15 != v12) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v14[2] != 0x1B9039CBDAB12E5CLL)
    {
LABEL_35:
      float32x2_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v17 = v14[5];
  if (*(void *)(v17 + 8) == 0x1B9039CBDAB12E5CLL)
  {
    uint64_t v6 = *(void *)(v17 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v6 = 0;
LABEL_49:
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v18 = 0xD3D7935EF848FCE7;
    if (a3 <= 0xD3D7935EF848FCE7) {
      unint64_t v18 = 0xD3D7935EF848FCE7 % a3;
    }
  }
  else
  {
    unint64_t v18 = (a3 - 1) & 0xD3D7935EF848FCE7;
  }
  float32x2_t v19 = *(void **)(a2 + 8 * v18);
  if (!v19) {
    goto LABEL_71;
  }
  float32x2_t v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_71;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v22 = v20[1];
      if (v22 == 0xD3D7935EF848FCE7)
      {
        if (v20[2] == 0xD3D7935EF848FCE7) {
          goto LABEL_69;
        }
      }
      else if ((v22 & (a3 - 1)) != v18)
      {
        goto LABEL_71;
      }
      float32x2_t v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_71;
      }
    }
  }
  while (1)
  {
    unint64_t v21 = v20[1];
    if (v21 == 0xD3D7935EF848FCE7) {
      break;
    }
    if (v21 >= a3) {
      v21 %= a3;
    }
    if (v21 != v18) {
      goto LABEL_71;
    }
LABEL_58:
    float32x2_t v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_71;
    }
  }
  if (v20[2] != 0xD3D7935EF848FCE7) {
    goto LABEL_58;
  }
LABEL_69:
  uint64_t v23 = v20[5];
  if (*(void *)(v23 + 8) != 0xD3D7935EF848FCE7)
  {
LABEL_71:
    uint64_t v24 = 0;
    goto LABEL_72;
  }
  uint64_t v24 = *(void *)(v23 + 32);
LABEL_72:
  unsigned __int8 *result = v5;
  result[1] = v6;
  result[2] = v24;
  return result;
}

void md::ResolvedSceneLogic::runBeforeLayoutAtVariableRate(uint64_t a1, uint64_t a2, md::SceneStateManager ***a3, md::SceneStateManager **a4)
{
  float v7 = **a3;
  uint64_t v6 = (std::__shared_weak_count *)(*a3)[1];
  float v115 = *a3;
  if (!v6
    || (atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed),
        atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)))
  {
    if (v7) {
      goto LABEL_4;
    }
LABEL_248:
    if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
    }
    float v114 = (id)GEOGetVectorKitVKDefaultLog_log;
    if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1A1780000, v114, OS_LOG_TYPE_ERROR, "PendingSceneContext sceneStateManager is null in ResolvedSceneLogic", buf, 2u);
    }

    return;
  }
  ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
  std::__shared_weak_count::__release_weak(v6);
  if (!v7) {
    goto LABEL_248;
  }
LABEL_4:
  md::SceneStateManager::updateTileSets(*v115);
  unint64_t v9 = *v115;
  float v8 = (atomic_ullong *)v115[1];
  if (v8) {
    atomic_fetch_add_explicit(v8 + 1, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = (std::__shared_weak_count *)a4[1];
  *a4 = v9;
  a4[1] = (md::SceneStateManager *)v8;
  if (v10 && !atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
  }
  *(void *)(a1 + 120) = a4;
  if (*(unsigned char *)(a1 + 128))
  {
    uint64_t v154 = 0;
    float v125 = (void *)(a1 + 152);
    uint64_t v11 = &md::TileSelectionTileSetTypeList;
    do
    {
      uint64_t v12 = (unsigned __int16 *)*((void *)*v115 + 14);
      float v13 = (unsigned __int16 *)*((void *)*v115 + 15);
      float v116 = v11;
      if (v12 != v13)
      {
        while (*v12 != (unsigned __int16)*v11)
        {
          v12 += 56;
          if (v12 == v13)
          {
            uint64_t v12 = (unsigned __int16 *)*((void *)*v115 + 15);
            break;
          }
        }
      }
      float v124 = (unsigned __int8 **)*((void *)v12 + 13);
      float32x2_t v14 = *v124;
      unint64_t v15 = *v124;
      float v117 = v124[1];
      if (*v124 != v117)
      {
        uint64_t v16 = v14 + 144;
        uint64_t v17 = *v124;
        while (1)
        {
          unint64_t v15 = v16;
          if (v16 == v117) {
            break;
          }
          v17 += 144;
          if (v16[112] != v14[112] || v16[113] != v14[113] || *((_DWORD *)v16 + 29) != *((_DWORD *)v14 + 29))
          {
            unint64_t v15 = v17;
            goto LABEL_26;
          }
          v16 += 144;
          if (*((_DWORD *)v15 + 30) != *((_DWORD *)v14 + 30)) {
            goto LABEL_26;
          }
        }
        unint64_t v15 = v124[1];
      }
LABEL_26:
      unint64_t v18 = v124[1];
      while (1)
      {
        float v123 = v15;
        if (v14 == v18) {
          break;
        }
        while (v14 != v15)
        {
          int8x8_t v20 = *(int8x8_t *)(a1 + 144);
          if (v20)
          {
            unint64_t v21 = *((void *)v14 + 13);
            uint8x8_t v22 = (uint8x8_t)vcnt_s8(v20);
            v22.i16[0] = vaddlv_u8(v22);
            if (v22.u32[0] > 1uLL)
            {
              unint64_t v23 = *((void *)v14 + 13);
              if (v21 >= *(void *)&v20) {
                unint64_t v23 = v21 % *(void *)&v20;
              }
            }
            else
            {
              unint64_t v23 = (*(void *)&v20 - 1) & v21;
            }
            uint64_t v24 = *(uint64_t ****)(*(void *)(a1 + 136) + 8 * v23);
            if (v24)
            {
              float v25 = *v24;
              if (*v24)
              {
                if (v22.u32[0] < 2uLL)
                {
                  uint64_t v26 = *(void *)&v20 - 1;
                  while (1)
                  {
                    float32x2_t v31 = v25[1];
                    if ((uint64_t *)v21 == v31)
                    {
                      if (*((unsigned __int8 *)v25 + 16) == *v14
                        && *((unsigned __int16 *)v25 + 12) == *((unsigned __int16 *)v14 + 4)
                        && v25[12] == *((uint64_t **)v14 + 10))
                      {
                        float32x2_t v32 = v25[4];
                        size_t v33 = (char *)v25[5] - (char *)v32;
                        float v34 = (const void *)*((void *)v14 + 2);
                        if (v33 == *((void *)v14 + 3) - (void)v34 && !memcmp(v32, v34, v33)) {
                          goto LABEL_31;
                        }
                      }
                    }
                    else if (((unint64_t)v31 & v26) != v23)
                    {
                      goto LABEL_62;
                    }
                    float v25 = (uint64_t **)*v25;
                    if (!v25) {
                      goto LABEL_62;
                    }
                  }
                }
                do
                {
                  unint64_t v27 = (unint64_t)v25[1];
                  if (v21 == v27)
                  {
                    if (*((unsigned __int8 *)v25 + 16) == *v14
                      && *((unsigned __int16 *)v25 + 12) == *((unsigned __int16 *)v14 + 4)
                      && v25[12] == *((uint64_t **)v14 + 10))
                    {
                      float v28 = v25[4];
                      size_t v29 = (char *)v25[5] - (char *)v28;
                      float32x2_t v30 = (const void *)*((void *)v14 + 2);
                      if (v29 == *((void *)v14 + 3) - (void)v30 && !memcmp(v28, v30, v29)) {
                        goto LABEL_31;
                      }
                    }
                  }
                  else
                  {
                    if (v27 >= *(void *)&v20) {
                      v27 %= *(void *)&v20;
                    }
                    if (v27 != v23) {
                      break;
                    }
                  }
                  float v25 = (uint64_t **)*v25;
                }
                while (v25);
              }
            }
          }
LABEL_62:
          float32x2_t v35 = (unsigned __int16 *)v124[3];
          float v36 = (unsigned __int16 *)v124[4];
          if (v35 != v36)
          {
            while (*v35 != *((unsigned __int16 *)v14 + 4))
            {
              v35 += 16;
              if (v35 == v36)
              {
                float32x2_t v35 = (unsigned __int16 *)v124[4];
                break;
              }
            }
          }
          unint64_t v37 = *((void *)v14 + 17);
          long double v39 = v35 + 4;
          uint64_t v38 = *((void *)v35 + 1);
          if (0x8E38E38E38E38E39 * ((*((void *)v39 + 1) - v38) >> 4) <= v37) {
            abort();
          }
          uint64_t v40 = v38 + 144 * v37;
          uint64_t v41 = *(void *)(v40 + 112);
          uint64_t v152 = v41;
          float v42 = *(std::__shared_weak_count **)(v40 + 120);
          double v153 = v42;
          if (v42) {
            atomic_fetch_add_explicit(&v42->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          if (!v41) {
            goto LABEL_222;
          }
          (*(void (**)(void **__return_ptr))(*(void *)v41 + 24))(v127);
          float v126 = v42;
          buf[0] = *v14;
          gdc::LayerDataKey::LayerDataKey((uint64_t)&v136, (uint64_t)(v14 + 8));
          char v141 = 0;
          if (v14[96])
          {
            int v142 = *((_DWORD *)v14 + 25);
            char v141 = 1;
          }
          unint64_t v43 = *((void *)v14 + 13);
          unint64_t v143 = v43;
          long long v144 = *(_OWORD *)v127;
          uint64_t v145 = v128;
          v127[0] = 0;
          v127[1] = 0;
          uint64_t v128 = 0;
          long long v146 = v129;
          uint64_t v147 = v130;
          long long v129 = 0uLL;
          uint64_t v130 = 0;
          long long v148 = v131;
          uint64_t v44 = v132;
          long long v131 = 0uLL;
          uint64_t v132 = 0;
          float v45 = (void **)v133[0];
          long long __p = *(_OWORD *)v133;
          uint64_t v149 = v44;
          uint64_t v151 = v134;
          v133[0] = 0;
          v133[1] = 0;
          uint64_t v134 = 0;
          unint64_t v46 = *(void *)(a1 + 144);
          if (v46)
          {
            uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v46);
            v47.i16[0] = vaddlv_u8(v47);
            if (v47.u32[0] > 1uLL)
            {
              float v42 = (std::__shared_weak_count *)v43;
              if (v43 >= v46) {
                float v42 = (std::__shared_weak_count *)(v43 % v46);
              }
            }
            else
            {
              float v42 = (std::__shared_weak_count *)((v46 - 1) & v43);
            }
            float v48 = *(uint64_t ****)(*(void *)(a1 + 136) + 8 * (void)v42);
            if (v48)
            {
              float v49 = *v48;
              if (*v48)
              {
                float v50 = v45;
                int v51 = buf[0];
                int v52 = v136;
                float v53 = v140;
                float v54 = v137;
                size_t v55 = v138 - (void)v137;
                if (v47.u32[0] < 2uLL)
                {
                  while (1)
                  {
                    float32x4_t v60 = v49[1];
                    if (v60 == (uint64_t *)v43)
                    {
                      if (*((unsigned __int8 *)v49 + 16) == v51
                        && *((unsigned __int16 *)v49 + 12) == v52
                        && v49[12] == v53)
                      {
                        float32x2_t v61 = v49[4];
                        if ((char *)v49[5] - (char *)v61 == v55)
                        {
                          float v120 = v53;
                          float v122 = v54;
                          size_t v118 = v55;
                          int v62 = memcmp(v61, v54, v55);
                          size_t v55 = v118;
                          float v53 = v120;
                          float v54 = v122;
                          if (!v62) {
                            goto LABEL_100;
                          }
                        }
                      }
                    }
                    else if ((std::__shared_weak_count *)((unint64_t)v60 & (v46 - 1)) != v42)
                    {
                      goto LABEL_102;
                    }
                    float v49 = (uint64_t **)*v49;
                    if (!v49) {
                      goto LABEL_102;
                    }
                  }
                }
                do
                {
                  unint64_t v56 = (unint64_t)v49[1];
                  if (v56 == v43)
                  {
                    if (*((unsigned __int8 *)v49 + 16) == v51
                      && *((unsigned __int16 *)v49 + 12) == v52
                      && v49[12] == v53)
                    {
                      float32x2_t v57 = v49[4];
                      if ((char *)v49[5] - (char *)v57 == v55)
                      {
                        float v119 = v53;
                        float v121 = v54;
                        size_t v58 = v55;
                        int v59 = memcmp(v57, v54, v55);
                        size_t v55 = v58;
                        float v53 = v119;
                        float v54 = v121;
                        if (!v59)
                        {
LABEL_100:
                          unint64_t v15 = v123;
                          if (!v50) {
                            goto LABEL_188;
                          }
                          goto LABEL_165;
                        }
                      }
                    }
                  }
                  else
                  {
                    if (v56 >= v46) {
                      v56 %= v46;
                    }
                    if ((std::__shared_weak_count *)v56 != v42) {
                      break;
                    }
                  }
                  float v49 = (uint64_t **)*v49;
                }
                while (v49);
              }
            }
          }
LABEL_102:
          float32x2_t v63 = (char *)operator new(0xE0uLL);
          long double v155 = v63;
          uint64_t v156 = a1 + 152;
          *(void *)float32x2_t v63 = 0;
          *((void *)v63 + 1) = v43;
          v63[16] = buf[0];
          gdc::LayerDataKey::LayerDataKey((uint64_t)(v63 + 24), (uint64_t)&v136);
          v63[112] = 0;
          if (v141)
          {
            *((_DWORD *)v63 + 29) = v142;
            v63[112] = 1;
          }
          *((void *)v63 + 15) = v143;
          *((void *)v63 + 18) = v145;
          *((void *)v63 + 21) = v147;
          uint64_t v64 = v151;
          *((void *)v63 + 24) = v149;
          *((_OWORD *)v63 + 8) = v144;
          long long v144 = 0uLL;
          uint64_t v145 = 0;
          *(_OWORD *)(v63 + 152) = v146;
          long long v146 = 0uLL;
          uint64_t v147 = 0;
          *((_OWORD *)v63 + 11) = v148;
          long long v148 = 0uLL;
          uint64_t v149 = 0;
          *(_OWORD *)(v63 + 200) = __p;
          *((void *)v63 + 27) = v64;
          long long __p = 0uLL;
          uint64_t v151 = 0;
          char v157 = 1;
          float v65 = (float)(unint64_t)(*(void *)(a1 + 160) + 1);
          float v66 = *(float *)(a1 + 168);
          if (!v46 || (float)(v66 * (float)v46) < v65)
          {
            BOOL v67 = v46 < 3 || (v46 & (v46 - 1)) != 0;
            unint64_t v68 = v67 | (2 * v46);
            unint64_t v69 = vcvtps_u32_f32(v65 / v66);
            if (v68 <= v69) {
              size_t prime = v69;
            }
            else {
              size_t prime = v68;
            }
            if (prime == 1)
            {
              size_t prime = 2;
            }
            else if ((prime & (prime - 1)) != 0)
            {
              size_t prime = std::__next_prime(prime);
            }
            unint64_t v46 = *(void *)(a1 + 144);
            if (prime <= v46)
            {
              if (prime < v46)
              {
                unint64_t v82 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 160) / *(float *)(a1 + 168));
                if (v46 < 3
                  || (uint8x8_t v83 = (uint8x8_t)vcnt_s8((int8x8_t)v46), v83.i16[0] = vaddlv_u8(v83), v83.u32[0] > 1uLL))
                {
                  unint64_t v82 = std::__next_prime(v82);
                }
                else
                {
                  uint64_t v84 = 1 << -(char)__clz(v82 - 1);
                  if (v82 >= 2) {
                    unint64_t v82 = v84;
                  }
                }
                if (prime <= v82) {
                  size_t prime = v82;
                }
                if (prime >= v46)
                {
                  unint64_t v46 = *(void *)(a1 + 144);
                }
                else
                {
                  if (prime) {
                    goto LABEL_117;
                  }
                  float v111 = *(void **)(a1 + 136);
                  *(void *)(a1 + 136) = 0;
                  if (v111) {
                    operator delete(v111);
                  }
                  unint64_t v46 = 0;
                  *(void *)(a1 + 144) = 0;
                }
              }
LABEL_142:
              if ((v46 & (v46 - 1)) != 0)
              {
                if (v43 >= v46) {
                  float v42 = (std::__shared_weak_count *)(v43 % v46);
                }
                else {
                  float v42 = (std::__shared_weak_count *)v43;
                }
              }
              else
              {
                float v42 = (std::__shared_weak_count *)((v46 - 1) & v43);
              }
              goto LABEL_155;
            }
LABEL_117:
            if (prime >> 61) {
              std::__throw_bad_array_new_length[abi:nn180100]();
            }
            int v71 = operator new(8 * prime);
            long long v72 = *(void **)(a1 + 136);
            *(void *)(a1 + 136) = v71;
            if (v72) {
              operator delete(v72);
            }
            uint64_t v73 = 0;
            *(void *)(a1 + 144) = prime;
            do
              *(void *)(*(void *)(a1 + 136) + 8 * v73++) = 0;
            while (prime != v73);
            int v74 = (void *)*v125;
            if (!*v125) {
              goto LABEL_141;
            }
            size_t v75 = v74[1];
            size_t v76 = prime - 1;
            if ((prime & (prime - 1)) == 0)
            {
              size_t v77 = v75 & v76;
              *(void *)(*(void *)(a1 + 136) + 8 * v77) = v125;
              for (uint64_t i = (void *)*v74; *v74; uint64_t i = (void *)*v74)
              {
                size_t v79 = i[1] & v76;
                if (v79 == v77)
                {
                  int v74 = i;
                }
                else
                {
                  uint64_t v80 = *(void *)(a1 + 136);
                  if (*(void *)(v80 + 8 * v79))
                  {
                    *int v74 = *i;
                    uint64_t v81 = 8 * v79;
                    void *i = **(void **)(*(void *)(a1 + 136) + v81);
                    **(void **)(*(void *)(a1 + 136) + v81) = i;
                  }
                  else
                  {
                    *(void *)(v80 + 8 * v79) = v74;
                    int v74 = i;
                    size_t v77 = v79;
                  }
                }
              }
              goto LABEL_141;
            }
            if (v75 >= prime) {
              v75 %= prime;
            }
            *(void *)(*(void *)(a1 + 136) + 8 * v75) = v125;
            float32x2_t v85 = (void *)*v74;
            if (!*v74)
            {
LABEL_141:
              unint64_t v46 = prime;
              goto LABEL_142;
            }
            while (2)
            {
              size_t v87 = v85[1];
              if (v87 >= prime) {
                v87 %= prime;
              }
              if (v87 != v75)
              {
                uint64_t v88 = *(void *)(a1 + 136);
                if (!*(void *)(v88 + 8 * v87))
                {
                  *(void *)(v88 + 8 * v87) = v74;
LABEL_146:
                  int v74 = v85;
                  float32x2_t v85 = (void *)*v85;
                  size_t v75 = v87;
                  if (!v85) {
                    goto LABEL_141;
                  }
                  continue;
                }
                *int v74 = *v85;
                uint64_t v86 = 8 * v87;
                *float32x2_t v85 = **(void **)(*(void *)(a1 + 136) + v86);
                **(void **)(*(void *)(a1 + 136) + v86) = v85;
                float32x2_t v85 = v74;
              }
              break;
            }
            size_t v87 = v75;
            goto LABEL_146;
          }
LABEL_155:
          float32x2_t v89 = *(void **)(*(void *)(a1 + 136) + 8 * (void)v42);
          uint64_t v90 = v155;
          if (v89)
          {
            void *v155 = *v89;
            unint64_t v15 = v123;
          }
          else
          {
            void *v155 = *(void *)(a1 + 152);
            *(void *)(a1 + 152) = v90;
            *(void *)(*(void *)(a1 + 136) + 8 * (void)v42) = v125;
            unint64_t v15 = v123;
            if (!*v90) {
              goto LABEL_164;
            }
            unint64_t v91 = *(void *)(*v90 + 8);
            if ((v46 & (v46 - 1)) != 0)
            {
              if (v91 >= v46) {
                v91 %= v46;
              }
            }
            else
            {
              v91 &= v46 - 1;
            }
            float32x2_t v89 = (void *)(*(void *)(a1 + 136) + 8 * v91);
          }
          void *v89 = v90;
LABEL_164:
          ++*(void *)(a1 + 160);
          float v50 = (void **)__p;
          if (!(void)__p) {
            goto LABEL_188;
          }
LABEL_165:
          uint64_t v92 = *((void *)&__p + 1);
          float32x2_t v93 = v50;
          if (*((void ***)&__p + 1) != v50)
          {
            do
            {
              uint64_t v94 = *(void *)(v92 - 24);
              if (v94)
              {
                uint64_t v95 = *(void *)(v92 - 16);
                float32x4_t v96 = *(void **)(v92 - 24);
                if (v95 != v94)
                {
                  do
                  {
                    if (*(char *)(v95 - 1) < 0) {
                      operator delete(*(void **)(v95 - 24));
                    }
                    v95 -= 24;
                  }
                  while (v95 != v94);
                  float32x4_t v96 = *(void **)(v92 - 24);
                }
                *(void *)(v92 - 16) = v94;
                operator delete(v96);
              }
              uint64_t v97 = *(void *)(v92 - 48);
              if (v97)
              {
                uint64_t v98 = *(void *)(v92 - 40);
                double v99 = *(void **)(v92 - 48);
                if (v98 != v97)
                {
                  do
                  {
                    if (*(char *)(v98 - 9) < 0) {
                      operator delete(*(void **)(v98 - 32));
                    }
                    v98 -= 64;
                  }
                  while (v98 != v97);
                  double v99 = *(void **)(v92 - 48);
                }
                *(void *)(v92 - 40) = v97;
                operator delete(v99);
              }
              float v100 = (void **)(v92 - 80);
              if (*(char *)(v92 - 57) < 0) {
                operator delete(*v100);
              }
              v92 -= 80;
            }
            while (v100 != v50);
            float32x2_t v93 = (void **)__p;
          }
          *((void *)&__p + 1) = v50;
          operator delete(v93);
LABEL_188:
          std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&v148);
          if (SHIBYTE(v147) < 0) {
            operator delete((void *)v146);
          }
          if ((SHIBYTE(v145) & 0x80000000) == 0)
          {
            if (!v141) {
              goto LABEL_193;
            }
LABEL_192:
            char v141 = 0;
            goto LABEL_193;
          }
          operator delete((void *)v144);
          if (v141) {
            goto LABEL_192;
          }
LABEL_193:
          if (v137 != v139) {
            free(v137);
          }
          float v101 = (void **)v133[0];
          if (v133[0])
          {
            float v102 = (char *)v133[1];
            double v103 = v133[0];
            if (v133[1] != v133[0])
            {
              do
              {
                uint64_t v104 = *((void *)v102 - 3);
                if (v104)
                {
                  uint64_t v105 = *((void *)v102 - 2);
                  double v106 = (void *)*((void *)v102 - 3);
                  if (v105 != v104)
                  {
                    do
                    {
                      if (*(char *)(v105 - 1) < 0) {
                        operator delete(*(void **)(v105 - 24));
                      }
                      v105 -= 24;
                    }
                    while (v105 != v104);
                    double v106 = (void *)*((void *)v102 - 3);
                  }
                  *((void *)v102 - 2) = v104;
                  operator delete(v106);
                }
                uint64_t v107 = *((void *)v102 - 6);
                if (v107)
                {
                  uint64_t v108 = *((void *)v102 - 5);
                  double v109 = (void *)*((void *)v102 - 6);
                  if (v108 != v107)
                  {
                    do
                    {
                      if (*(char *)(v108 - 9) < 0) {
                        operator delete(*(void **)(v108 - 32));
                      }
                      v108 -= 64;
                    }
                    while (v108 != v107);
                    double v109 = (void *)*((void *)v102 - 6);
                  }
                  *((void *)v102 - 5) = v107;
                  operator delete(v109);
                }
                float v110 = (void **)(v102 - 80);
                if (*(v102 - 57) < 0) {
                  operator delete(*v110);
                }
                v102 -= 80;
              }
              while (v110 != v101);
              double v103 = v133[0];
            }
            v133[1] = v101;
            operator delete(v103);
          }
          std::vector<gdc::DebugTreeNode>::~vector[abi:nn180100]((void ***)&v131);
          if (SHIBYTE(v130) < 0) {
            operator delete((void *)v129);
          }
          float v42 = v126;
          if (SHIBYTE(v128) < 0)
          {
            operator delete(v127[0]);
            if (!v126) {
              goto LABEL_31;
            }
            goto LABEL_223;
          }
LABEL_222:
          if (!v42) {
            goto LABEL_31;
          }
LABEL_223:
          if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
            std::__shared_weak_count::__release_weak(v42);
          }
LABEL_31:
          v14 += 144;
        }
        float32x2_t v19 = v117;
        if (v117 != v15)
        {
          float v112 = v15 + 144;
          float32x2_t v19 = v15;
          while (1)
          {
            if (v112 == v117)
            {
              float32x2_t v19 = v117;
              goto LABEL_28;
            }
            if (v112[112] != v15[112]) {
              break;
            }
            v19 += 144;
            if (v112[113] == v15[113] && *((_DWORD *)v112 + 29) == *((_DWORD *)v15 + 29))
            {
              int v113 = *((_DWORD *)v112 + 30);
              v112 += 144;
              if (v113 == *((_DWORD *)v15 + 30)) {
                continue;
              }
            }
            goto LABEL_28;
          }
          float32x2_t v19 = v112;
        }
LABEL_28:
        unint64_t v18 = v124[1];
        float32x2_t v14 = v15;
        unint64_t v15 = v19;
      }
      uint64_t v11 = v116 + 1;
    }
    while (v116 + 1 != (__int16 *)&ggl::specularBuildingShaderVertShaderFunctionConstantMapping(void)::ref);
  }
}

void sub_1A1A9EA70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  std::unique_ptr<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,gdc::DebugTreeNode>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<gdc::LayerDataRequestKey,gdc::DebugTreeNode>,void *>>>>::~unique_ptr[abi:nn180100](v39 - 120);
  std::pair<gdc::LayerDataRequestKey,gdc::DebugTreeNode>::~pair((uint64_t)&a39);
  gdc::DebugTreeNode::~DebugTreeNode((gdc::DebugTreeNode *)&a27);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](v39 - 144);
  _Unwind_Resume(a1);
}

void md::DaVinciGroundRenderLayer::setupStyleColorConstantData<ggl::DaVinci::GroundPipelineSetup,ggl::DaVinci::GroundPipelineState>(uint64_t a1, uint64_t a2, float32x4_t *a3)
{
  float32x4_t v14 = *a3;
  char v15 = 1;
  uint64_t v6 = (float *)(a1 + 448);
  uint64_t v7 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::find<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>((void *)(a1 + 448), v14.f32);
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 + 40);
  }
  else
  {
    uint64_t v9 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::pop(*(void *)(a1 + 1960));
    uint64_t v8 = v9;
    unint64_t v10 = *(void *)(v9 + 8);
    **(float16x4_t **)(v9 + 72) = vcvt_f16_f32(*a3);
    if (*(void *)(v9 + 64) > v10) {
      unint64_t v10 = *(void *)(v9 + 64);
    }
    *(void *)(v9 + 56) = 0;
    *(void *)(v9 + 64) = v10;
    std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *&>(v6, (unsigned int *)&v14, (uint64_t)&v14, v9);
  }
  uint64_t v11 = *(void *)(a2 + 64);
  *(void *)(v11 + 448) = v8;
  *(void *)(v11 + 456) = 0;
  uint64_t v12 = *(void *)(a2 + 160);
  float v13 = *(std::__shared_weak_count **)(v12 + 456);
  *(void *)(v12 + 448) = 0;
  *(void *)(v12 + 456) = 0;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
}

uint64_t std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::find<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>(void *a1, float *a2)
{
  if (*((unsigned char *)a2 + 16))
  {
    float v2 = a2[1];
    if (*a2 == 0.0) {
      unint64_t v3 = 0x9E3779B97F4A7C15;
    }
    else {
      unint64_t v3 = *(unsigned int *)a2 - 0x61C8864680B583EBLL;
    }
    if (v2 == 0.0) {
      uint64_t v4 = 0x9E3779B97F4A7C15;
    }
    else {
      uint64_t v4 = LODWORD(v2) - 0x61C8864680B583EBLL;
    }
    float v5 = a2[2];
    float v6 = a2[3];
    if (v5 == 0.0) {
      uint64_t v7 = 0x9E3779B97F4A7C15;
    }
    else {
      uint64_t v7 = LODWORD(v5) - 0x61C8864680B583EBLL;
    }
    if (v6 == 0.0) {
      uint64_t v8 = 0x9E3779B97F4A7C15;
    }
    else {
      uint64_t v8 = LODWORD(v6) - 0x61C8864680B583EBLL;
    }
    int8x8_t v9 = (int8x8_t)a1[1];
    if (!*(void *)&v9) {
      return 0;
    }
    unint64_t v10 = (v7 + ((((v3 >> 2) + (v3 << 6) + v4) ^ v3) << 6) + ((((v3 >> 2) + (v3 << 6) + v4) ^ v3) >> 2)) ^ ((v3 >> 2) + (v3 << 6) + v4) ^ v3;
    unint64_t v11 = (v8 + (v10 << 6) + (v10 >> 2)) ^ v10;
    unint64_t v12 = (((v11 << 6) + (v11 >> 2) - 0x61C8864680B583EBLL) ^ v11) - 0x61C8864680B583EBLL;
    uint8x8_t v13 = (uint8x8_t)vcnt_s8(v9);
    v13.i16[0] = vaddlv_u8(v13);
    if (v13.u32[0] > 1uLL)
    {
      uint64_t v14 = (((v11 << 6) + (v11 >> 2) - 0x61C8864680B583EBLL) ^ v11) - 0x61C8864680B583EBLL;
      if (v12 >= *(void *)&v9) {
        uint64_t v14 = v12 % *(void *)&v9;
      }
    }
    else
    {
      uint64_t v14 = v12 & (*(void *)&v9 - 1);
    }
    char v15 = *(uint64_t **)(*a1 + 8 * v14);
    if (v15)
    {
      uint64_t result = *v15;
      if (*v15)
      {
        if (v13.u32[0] < 2uLL)
        {
          uint64_t v17 = *(void *)&v9 - 1;
          while (1)
          {
            uint64_t v20 = *(void *)(result + 8);
            if (v20 == v12)
            {
              if (*(unsigned char *)(result + 32))
              {
                if (*(void *)(result + 16) == *(void *)a2 && *(void *)(result + 24) == *((void *)a2 + 1)) {
                  return result;
                }
              }
            }
            else if ((v20 & v17) != v14)
            {
              return 0;
            }
            uint64_t result = *(void *)result;
            if (!result) {
              return result;
            }
          }
        }
        do
        {
          unint64_t v18 = *(void *)(result + 8);
          if (v18 == v12)
          {
            if (*(unsigned char *)(result + 32))
            {
              if (*(void *)(result + 16) == *(void *)a2 && *(void *)(result + 24) == *((void *)a2 + 1)) {
                return result;
              }
            }
          }
          else
          {
            if (v18 >= *(void *)&v9) {
              v18 %= *(void *)&v9;
            }
            if (v18 != v14) {
              return 0;
            }
          }
          uint64_t result = *(void *)result;
        }
        while (result);
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v22 = std::__throw_bad_optional_access[abi:nn180100]();
    return std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *&>(v22);
  }
  return result;
}

void std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *&>(float *a1, unsigned int *a2, uint64_t a3, uint64_t a4)
{
  if (!*((unsigned char *)a2 + 16))
  {
    std::__throw_bad_optional_access[abi:nn180100]();
    goto LABEL_114;
  }
  float v8 = *((float *)a2 + 1);
  unint64_t v9 = *a2 - 0x61C8864680B583EBLL;
  if (*(float *)a2 == 0.0) {
    unint64_t v9 = 0x9E3779B97F4A7C15;
  }
  uint64_t v10 = LODWORD(v8) - 0x61C8864680B583EBLL;
  if (v8 == 0.0) {
    uint64_t v10 = 0x9E3779B97F4A7C15;
  }
  float v11 = *((float *)a2 + 2);
  float v12 = *((float *)a2 + 3);
  unint64_t v13 = ((v9 >> 2) + (v9 << 6) + v10) ^ v9;
  uint64_t v14 = LODWORD(v11) - 0x61C8864680B583EBLL;
  if (v11 == 0.0) {
    uint64_t v14 = 0x9E3779B97F4A7C15;
  }
  unint64_t v15 = (v14 + (v13 << 6) + (v13 >> 2)) ^ v13;
  uint64_t v16 = LODWORD(v12) - 0x61C8864680B583EBLL;
  if (v12 == 0.0) {
    uint64_t v16 = 0x9E3779B97F4A7C15;
  }
  unint64_t v17 = (v16 + (v15 << 6) + (v15 >> 2)) ^ v15;
  unint64_t v18 = (((v17 << 6) + (v17 >> 2) - 0x61C8864680B583EBLL) ^ v17) - 0x61C8864680B583EBLL;
  unint64_t v19 = *((void *)a1 + 1);
  if (v19)
  {
    uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v19);
    v20.i16[0] = vaddlv_u8(v20);
    if (v20.u32[0] > 1uLL)
    {
      uint64_t v4 = (((v17 << 6) + (v17 >> 2) - 0x61C8864680B583EBLL) ^ v17) - 0x61C8864680B583EBLL;
      if (v18 >= v19) {
        uint64_t v4 = v18 % v19;
      }
    }
    else
    {
      uint64_t v4 = v18 & (v19 - 1);
    }
    unint64_t v21 = *(uint64_t ***)(*(void *)a1 + 8 * v4);
    if (v21)
    {
      uint64_t v22 = *v21;
      if (v22)
      {
        if (v20.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v25 = v22[1];
            if (v25 == v18)
            {
              if (*((unsigned char *)v22 + 32))
              {
                if (v22[2] == *(void *)a2 && v22[3] == *((void *)a2 + 1)) {
                  return;
                }
              }
            }
            else if ((v25 & (v19 - 1)) != v4)
            {
              goto LABEL_42;
            }
            uint64_t v22 = (uint64_t *)*v22;
            if (!v22) {
              goto LABEL_42;
            }
          }
        }
        do
        {
          unint64_t v23 = v22[1];
          if (v23 == v18)
          {
            if (*((unsigned char *)v22 + 32))
            {
              if (v22[2] == *(void *)a2 && v22[3] == *((void *)a2 + 1)) {
                return;
              }
            }
          }
          else
          {
            if (v23 >= v19) {
              v23 %= v19;
            }
            if (v23 != v4) {
              break;
            }
          }
          uint64_t v22 = (uint64_t *)*v22;
        }
        while (v22);
      }
    }
  }
LABEL_42:
  unint64_t v27 = operator new(0x30uLL);
  float v28 = v27;
  void *v27 = 0;
  v27[1] = v18;
  *((unsigned char *)v27 + 16) = 0;
  *((unsigned char *)v27 + 32) = 0;
  if (*(unsigned char *)(a3 + 16))
  {
    *((_OWORD *)v27 + 1) = *(_OWORD *)a3;
    *((unsigned char *)v27 + 32) = 1;
  }
  v27[5] = a4;
  float v29 = (float)(unint64_t)(*((void *)a1 + 3) + 1);
  float v30 = a1[8];
  if (!v19 || (float)(v30 * (float)v19) < v29)
  {
    BOOL v31 = 1;
    if (v19 >= 3) {
      BOOL v31 = (v19 & (v19 - 1)) != 0;
    }
    unint64_t v32 = v31 | (2 * v19);
    unint64_t v33 = vcvtps_u32_f32(v29 / v30);
    if (v32 <= v33) {
      size_t prime = v33;
    }
    else {
      size_t prime = v32;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v19 = *((void *)a1 + 1);
    }
    if (prime <= v19)
    {
      if (prime >= v19) {
        goto LABEL_81;
      }
      unint64_t v46 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
      if (v19 < 3 || (uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v19), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
      {
        unint64_t v46 = std::__next_prime(v46);
      }
      else
      {
        uint64_t v48 = 1 << -(char)__clz(v46 - 1);
        if (v46 >= 2) {
          unint64_t v46 = v48;
        }
      }
      if (prime <= v46) {
        size_t prime = v46;
      }
      if (prime >= v19)
      {
        unint64_t v19 = *((void *)a1 + 1);
LABEL_81:
        if ((v19 & (v19 - 1)) != 0)
        {
          if (v18 >= v19) {
            uint64_t v4 = v18 % v19;
          }
          else {
            uint64_t v4 = v18;
          }
        }
        else
        {
          uint64_t v4 = (v19 - 1) & v18;
        }
        goto LABEL_94;
      }
      if (!prime)
      {
        size_t v55 = *(void **)a1;
        *(void *)a1 = 0;
        if (v55) {
          operator delete(v55);
        }
        unint64_t v19 = 0;
        *((void *)a1 + 1) = 0;
        goto LABEL_81;
      }
    }
    if (!(prime >> 61))
    {
      float32x2_t v35 = operator new(8 * prime);
      float v36 = *(void **)a1;
      *(void *)a1 = v35;
      if (v36) {
        operator delete(v36);
      }
      uint64_t v37 = 0;
      *((void *)a1 + 1) = prime;
      do
        *(void *)(*(void *)a1 + 8 * v37++) = 0;
      while (prime != v37);
      uint64_t v39 = (uint64_t *)(a1 + 4);
      uint64_t v38 = (void *)*((void *)a1 + 2);
      if (!v38) {
        goto LABEL_80;
      }
      size_t v40 = v38[1];
      size_t v41 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v42 = v40 & v41;
        *(void *)(*(void *)a1 + 8 * v42) = v39;
        for (uint64_t i = (void *)*v38; *v38; uint64_t i = (void *)*v38)
        {
          size_t v44 = i[1] & v41;
          if (v44 == v42)
          {
            uint64_t v38 = i;
          }
          else if (*(void *)(*(void *)a1 + 8 * v44))
          {
            *uint64_t v38 = *i;
            uint64_t v45 = 8 * v44;
            void *i = **(void **)(*(void *)a1 + v45);
            **(void **)(*(void *)a1 + v45) = i;
          }
          else
          {
            *(void *)(*(void *)a1 + 8 * v44) = v38;
            uint64_t v38 = i;
            size_t v42 = v44;
          }
        }
LABEL_80:
        unint64_t v19 = prime;
        goto LABEL_81;
      }
      if (v40 >= prime) {
        v40 %= prime;
      }
      *(void *)(*(void *)a1 + 8 * v40) = v39;
      float v49 = (void *)*v38;
      if (!*v38) {
        goto LABEL_80;
      }
      while (1)
      {
        size_t v51 = v49[1];
        if (v51 >= prime) {
          v51 %= prime;
        }
        if (v51 != v40)
        {
          if (!*(void *)(*(void *)a1 + 8 * v51))
          {
            *(void *)(*(void *)a1 + 8 * v51) = v38;
            goto LABEL_85;
          }
          *uint64_t v38 = *v49;
          uint64_t v50 = 8 * v51;
          *float v49 = **(void **)(*(void *)a1 + v50);
          **(void **)(*(void *)a1 + v50) = v49;
          float v49 = v38;
        }
        size_t v51 = v40;
LABEL_85:
        uint64_t v38 = v49;
        float v49 = (void *)*v49;
        size_t v40 = v51;
        if (!v49) {
          goto LABEL_80;
        }
      }
    }
LABEL_114:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
LABEL_94:
  int v52 = *(void **)a1;
  float v53 = *(void **)(*(void *)a1 + 8 * v4);
  if (v53)
  {
    *float v28 = *v53;
LABEL_102:
    *float v53 = v28;
    goto LABEL_103;
  }
  *float v28 = *((void *)a1 + 2);
  *((void *)a1 + 2) = v28;
  v52[v4] = a1 + 4;
  if (*v28)
  {
    unint64_t v54 = *(void *)(*v28 + 8);
    if ((v19 & (v19 - 1)) != 0)
    {
      if (v54 >= v19) {
        v54 %= v19;
      }
    }
    else
    {
      v54 &= v19 - 1;
    }
    float v53 = (void *)(*(void *)a1 + 8 * v54);
    goto LABEL_102;
  }
LABEL_103:
  ++*((void *)a1 + 3);
}

void sub_1A1A9F2B8(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::pop(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  if (v2 == *(void *)a1)
  {
    uint64_t v13 = *(void *)(a1 + 88);
    if (!v13)
    {
LABEL_52:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
      abort();
    }
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v13 + 48))(v13);
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v14 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      uint64_t v17 = ((uint64_t)v4 - v16) >> 3;
      unint64_t v8 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v18 = v14 - v16;
      if (v18 >> 2 > v8) {
        unint64_t v8 = v18 >> 2;
      }
      if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v19 = 8 * v8;
        uint64_t v20 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v20 + 8 * v17);
        unint64_t v8 = v20 + v19;
        if (v20) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v17);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v30 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v30) {
        goto LABEL_48;
      }
      unint64_t v31 = v21 - v30 - 8;
      if (v31 < 0x38)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v33 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v32 = (v31 >> 3) + 1;
        uint64_t v33 = v21 - 8 * (v32 & 0x3FFFFFFFFFFFFFFCLL);
        float v34 = v12 - 2;
        float32x2_t v35 = (long long *)(v21 - 16);
        uint64_t v36 = v32 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v37 = *v35;
          *((_OWORD *)v34 - 1) = *(v35 - 1);
          *(_OWORD *)float v34 = v37;
          v34 -= 4;
          v35 -= 2;
          v36 -= 4;
        }
        while (v36);
        v12 -= v32 & 0x3FFFFFFFFFFFFFFCLL;
        if (v32 == (v32 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v39 = *(void *)(v33 - 8);
        v33 -= 8;
        *--float v12 = v39;
      }
      while (v33 != v30);
      goto LABEL_47;
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 - 8);
    *(void *)(a1 + 8) = v2 - 8;
    uint64_t v4 = *(uint64_t **)(a1 + 40);
    unint64_t v5 = *(void *)(a1 + 48);
    if ((unint64_t)v4 >= v5)
    {
      uint64_t v6 = *(void *)(a1 + 32);
      uint64_t v7 = ((uint64_t)v4 - v6) >> 3;
      unint64_t v8 = v7 + 1;
      if ((unint64_t)(v7 + 1) >> 61) {
        goto LABEL_53;
      }
      uint64_t v9 = v5 - v6;
      if (v9 >> 2 > v8) {
        unint64_t v8 = v9 >> 2;
      }
      if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v8)
      {
        uint64_t v10 = 8 * v8;
        uint64_t v11 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(a1 + 56) + 16))(*(void *)(a1 + 56), 8 * v8, 8);
        float v12 = (uint64_t *)(v11 + 8 * v7);
        unint64_t v8 = v11 + v10;
        if (v11) {
          *float v12 = v3;
        }
      }
      else
      {
        float v12 = (uint64_t *)(8 * v7);
      }
      unint64_t v15 = v12 + 1;
      uint64_t v22 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21 == v22) {
        goto LABEL_48;
      }
      unint64_t v23 = v21 - v22 - 8;
      if (v23 < 0x38)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else if ((unint64_t)(v21 - (void)v12) < 0x20)
      {
        uint64_t v25 = *(void *)(a1 + 40);
      }
      else
      {
        uint64_t v24 = (v23 >> 3) + 1;
        uint64_t v25 = v21 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v26 = v12 - 2;
        unint64_t v27 = (long long *)(v21 - 16);
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v27;
          *((_OWORD *)v26 - 1) = *(v27 - 1);
          *(_OWORD *)uint64_t v26 = v29;
          v26 -= 4;
          v27 -= 2;
          v28 -= 4;
        }
        while (v28);
        v12 -= v24 & 0x3FFFFFFFFFFFFFFCLL;
        if (v24 == (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_47;
        }
      }
      do
      {
        uint64_t v38 = *(void *)(v25 - 8);
        v25 -= 8;
        *--float v12 = v38;
      }
      while (v25 != v22);
LABEL_47:
      uint64_t v21 = *(void *)(a1 + 32);
LABEL_48:
      *(void *)(a1 + 32) = v12;
      *(void *)(a1 + 40) = v15;
      uint64_t v40 = *(void *)(a1 + 48);
      *(void *)(a1 + 48) = v8;
      if (v21) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 56) + 40))(*(void *)(a1 + 56), v21, v40 - v21);
      }
      goto LABEL_50;
    }
  }
  if (v4) {
    uint64_t *v4 = v3;
  }
  unint64_t v15 = v4 + 1;
LABEL_50:
  *(void *)(a1 + 40) = v15;
  uint64_t v43 = v3;
  uint64_t v41 = *(void *)(a1 + 120);
  if (!v41) {
    goto LABEL_52;
  }
  (*(void (**)(uint64_t, uint64_t *))(*(void *)v41 + 48))(v41, &v43);
  return v3;
}

double std::__introsort<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *,false>(uint64_t *a1, unsigned __int8 *a2, uint64_t a3, char a4)
{
double std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *>(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int8 *a3, unsigned __int8 *a4)
{
  double result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,gdc::ResourceKeyLessThan &,gdc::ResourceKey *>(a1, a2, a3);
  unsigned int v9 = *((unsigned __int16 *)a4 + 1);
  unsigned int v10 = *((unsigned __int16 *)a3 + 1);
  BOOL v11 = v9 >= v10;
  if (v9 == v10 && (unsigned int v12 = *a4, v13 = *a3, v11 = v12 >= v13, v12 == v13))
  {
    if (!gdc::GenericKey::operator<(*((void *)a4 + 1), *((void *)a4 + 2), *((void *)a3 + 1), *((void *)a3 + 2))) {
      return result;
    }
  }
  else if (v11)
  {
    return result;
  }
  double result = std::swap[abi:nn180100]<gdc::ResourceKey>((uint64_t *)a3, (uint64_t *)a4);
  unsigned int v14 = *((unsigned __int16 *)a3 + 1);
  unsigned int v15 = *((unsigned __int16 *)a2 + 1);
  BOOL v16 = v14 >= v15;
  if (v14 == v15 && (v17 = *a3, v18 = *a2, BOOL v16 = v17 >= v18, v17 == v18))
  {
    if (!gdc::GenericKey::operator<(*((void *)a3 + 1), *((void *)a3 + 2), *((void *)a2 + 1), *((void *)a2 + 2))) {
      return result;
    }
  }
  else if (v16)
  {
    return result;
  }
  double result = std::swap[abi:nn180100]<gdc::ResourceKey>((uint64_t *)a2, (uint64_t *)a3);
  unsigned int v19 = *((unsigned __int16 *)a2 + 1);
  unsigned int v20 = *((unsigned __int16 *)a1 + 1);
  BOOL v21 = v19 >= v20;
  if (v19 == v20 && (v22 = *a2, v23 = *a1, BOOL v21 = v22 >= v23, v22 == v23))
  {
    if (!gdc::GenericKey::operator<(*((void *)a2 + 1), *((void *)a2 + 2), *((void *)a1 + 1), *((void *)a1 + 2))) {
      return result;
    }
  }
  else if (v21)
  {
    return result;
  }
  return std::swap[abi:nn180100]<gdc::ResourceKey>((uint64_t *)a1, (uint64_t *)a2);
}

double std::swap[abi:nn180100]<gdc::ResourceKey>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3 = (char *)a1[1];
  BOOL v4 = v65;
  uint64_t v62 = *a1;
  *(void *)&long long v63 = v65;
  uint64_t v6 = (char *)a1[3];
  uint64_t v5 = a1[4];
  *(void *)&long long v64 = v65;
  *((void *)&v64 + 1) = v5;
  if (v3 != v6)
  {
    uint64_t v7 = a1[2];
    *(void *)&long long v63 = v3;
    *((void *)&v63 + 1) = v7;
    *(_OWORD *)(a1 + 1) = 0u;
    *(_OWORD *)(a1 + 3) = 0u;
    goto LABEL_18;
  }
  unint64_t v8 = (char *)a1[2];
  unint64_t v9 = v8 - v3;
  *((void *)&v63 + 1) = &v65[v8 - v3];
  if (v8 != v3)
  {
    if (v9 < 8 || (unint64_t)((char *)&v62 - v3 + 40) < 0x20) {
      goto LABEL_17;
    }
    if (v9 >= 0x20)
    {
      unint64_t v10 = v9 & 0xFFFFFFFFFFFFFFE0;
      BOOL v11 = (long long *)(v3 + 16);
      unsigned int v12 = &v66;
      unint64_t v13 = v9 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v14 = *v11;
        *((_OWORD *)v12 - 1) = *(v11 - 1);
        *(_OWORD *)unsigned int v12 = v14;
        v11 += 2;
        v12 += 4;
        v13 -= 32;
      }
      while (v13);
      if (v9 == v10) {
        goto LABEL_18;
      }
      if ((v9 & 0x18) == 0)
      {
        v3 += v10;
        BOOL v4 = &v65[v10];
        do
        {
LABEL_17:
          char v20 = *v3++;
          *v4++ = v20;
        }
        while (v3 != v8);
        goto LABEL_18;
      }
    }
    else
    {
      unint64_t v10 = 0;
    }
    unint64_t v15 = v9 & 0xFFFFFFFFFFFFFFF8;
    BOOL v4 = &v65[v9 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v16 = v10 - (v9 & 0xFFFFFFFFFFFFFFF8);
    unsigned int v17 = (uint64_t *)&v3[v10];
    unsigned int v18 = &v65[v10];
    do
    {
      uint64_t v19 = *v17++;
      *v18++ = v19;
      v16 += 8;
    }
    while (v16);
    if (v9 != v15)
    {
      v3 += v15;
      goto LABEL_17;
    }
  }
LABEL_18:
  uint64_t v21 = a1[9];
  uint64_t v67 = v21;
  long long v68 = *((_OWORD *)a1 + 5);
  *a1 = *a2;
  if (a1 == a2) {
    goto LABEL_37;
  }
  unsigned int v22 = a1 + 5;
  uint64_t v23 = a2[1];
  a1[3] = (uint64_t)(a1 + 5);
  if (v23 == a2[3])
  {
    a1[1] = (uint64_t)v22;
    uint64_t v24 = (char *)a2[1];
    a1[2] = (uint64_t)&v22[a2[2] - (void)v24];
    uint64_t v25 = (char *)a2[2];
    if (v24 == v25) {
      goto LABEL_36;
    }
    unint64_t v26 = v25 - v24;
    if ((unint64_t)(v25 - v24) >= 8 && (unint64_t)((char *)a1 - v24 + 40) >= 0x20)
    {
      if (v26 < 0x20)
      {
        uint64_t v27 = 0;
LABEL_30:
        unint64_t v32 = v26 & 0xFFFFFFFFFFFFFFF8;
        v22 += v26 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v33 = v27 - (v26 & 0xFFFFFFFFFFFFFFF8);
        long long v34 = (uint64_t *)&v24[v27];
        unint64_t v35 = (uint64_t *)((char *)a1 + v27 + 40);
        do
        {
          uint64_t v36 = *v34++;
          *v35++ = v36;
          v33 += 8;
        }
        while (v33);
        if (v26 == v32) {
          goto LABEL_36;
        }
        v24 += v32;
        goto LABEL_35;
      }
      uint64_t v27 = v26 & 0xFFFFFFFFFFFFFFE0;
      unint64_t v28 = (long long *)(v24 + 16);
      long long v29 = a1 + 7;
      unint64_t v30 = v26 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v31 = *v28;
        *(v29 - 1) = *(v28 - 1);
        *long long v29 = v31;
        v28 += 2;
        v29 += 2;
        v30 -= 32;
      }
      while (v30);
      if (v26 == v27) {
        goto LABEL_36;
      }
      if ((v26 & 0x18) != 0) {
        goto LABEL_30;
      }
      v24 += v27;
      v22 += v27;
    }
    do
    {
LABEL_35:
      char v37 = *v24++;
      *v22++ = v37;
    }
    while (v24 != v25);
    goto LABEL_36;
  }
  a1[1] = v23;
  a1[2] = a2[2];
  *(_OWORD *)(a2 + 1) = 0u;
  *(_OWORD *)(a2 + 3) = 0u;
LABEL_36:
  a1[4] = a2[4];
LABEL_37:
  a1[9] = a2[9];
  uint64_t v38 = a2 + 10;
  *((_OWORD *)a1 + 5) = *((_OWORD *)a2 + 5);
  *a2 = v62;
  if (&v62 != a2)
  {
    uint64_t v39 = a2 + 5;
    char v40 = (void *)a2[1];
    if (v40 != (void *)a2[3]) {
      free(v40);
    }
    a2[3] = (uint64_t)v39;
    unsigned int v41 = (char *)v63;
    if ((void)v63 != (void)v64)
    {
      uint64_t v42 = *((void *)&v63 + 1);
      a2[1] = v63;
      a2[2] = v42;
      long long v63 = 0u;
      long long v64 = 0u;
LABEL_59:
      uint64_t v61 = v67;
      a2[4] = *((void *)&v64 + 1);
      a2[9] = v61;
      double result = *(double *)&v68;
      *uint64_t v38 = v68;
      return result;
    }
    BOOL v46 = (char *)*((void *)&v63 + 1);
    unint64_t v48 = *((void *)&v63 + 1) - v63;
    BOOL v47 = *((void *)&v63 + 1) == (void)v63;
    BOOL v49 = &v39[*((void *)&v63 + 1) - v63];
    a2[1] = (uint64_t)v39;
    a2[2] = (uint64_t)v49;
    if (v47) {
      goto LABEL_59;
    }
    if (v48 >= 8 && (unint64_t)((char *)a2 - v41 + 40) >= 0x20)
    {
      if (v48 < 0x20)
      {
        uint64_t v50 = 0;
LABEL_53:
        unint64_t v55 = v48 & 0xFFFFFFFFFFFFFFF8;
        v39 += v48 & 0xFFFFFFFFFFFFFFF8;
        uint64_t v56 = v50 - (v48 & 0xFFFFFFFFFFFFFFF8);
        long long v57 = (uint64_t *)&v41[v50];
        unsigned int v58 = (uint64_t *)((char *)a2 + v50 + 40);
        do
        {
          uint64_t v59 = *v57++;
          *v58++ = v59;
          v56 += 8;
        }
        while (v56);
        if (v48 == v55) {
          goto LABEL_59;
        }
        v41 += v55;
        goto LABEL_58;
      }
      uint64_t v50 = v48 & 0xFFFFFFFFFFFFFFE0;
      unsigned int v51 = (long long *)(v41 + 16);
      BOOL v52 = a2 + 7;
      unint64_t v53 = v48 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v54 = *v51;
        *(v52 - 1) = *(v51 - 1);
        *BOOL v52 = v54;
        v51 += 2;
        v52 += 2;
        v53 -= 32;
      }
      while (v53);
      if (v48 == v50) {
        goto LABEL_59;
      }
      if ((v48 & 0x18) != 0) {
        goto LABEL_53;
      }
      v41 += v50;
      v39 += v50;
    }
    do
    {
LABEL_58:
      char v60 = *v41++;
      *v39++ = v60;
    }
    while (v41 != v46);
    goto LABEL_59;
  }
  long long v43 = (void *)v63;
  size_t v44 = (void *)v64;
  a2[9] = v21;
  double result = *(double *)&v68;
  *uint64_t v38 = v68;
  if (v43 != v44) {
    free(v43);
  }
  return result;
}

void md::DaVinciGroundRenderLayer::layout(md::DaVinciGroundRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v820 = *MEMORY[0x1E4F143B8];
  switch(*((unsigned char *)this + 3560))
  {
    case 0:
    case 1:
    case 4:
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      BOOL v4 = (id)GEOGetVectorKitPerformanceLog_log;
      uint64_t v5 = v4;
      os_signpost_id_t v6 = *((void *)a2 + 10);
      if (v6 - 1 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled(v4)) {
        goto LABEL_18;
      }
      *(_WORD *)buf = 0;
      uint64_t v7 = "DaVinciGroundLayout";
      break;
    case 2:
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      unint64_t v9 = (id)GEOGetVectorKitPerformanceLog_log;
      uint64_t v5 = v9;
      os_signpost_id_t v6 = *((void *)a2 + 10);
      if (v6 - 1 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled(v9)) {
        goto LABEL_18;
      }
      *(_WORD *)buf = 0;
      uint64_t v7 = "DaVinciBuildingsLayout";
      break;
    case 3:
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      unint64_t v8 = (id)GEOGetVectorKitPerformanceLog_log;
      uint64_t v5 = v8;
      os_signpost_id_t v6 = *((void *)a2 + 10);
      if (v6 - 1 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled(v8)) {
        goto LABEL_18;
      }
      *(_WORD *)buf = 0;
      uint64_t v7 = "DaVinciNonTiledLayout";
      break;
    default:
      goto LABEL_19;
  }
  _os_signpost_emit_with_name_impl(&dword_1A1780000, v5, OS_SIGNPOST_INTERVAL_BEGIN, v6, v7, "", buf, 2u);
LABEL_18:

LABEL_19:
  md::DaVinciGroundRenderResources::resetPools((md::DaVinciGroundRenderLayer *)((char *)this + 568));
  unint64_t v10 = this;
  v728 = this;
  if (*((void *)this + 433))
  {
    BOOL v11 = (void *)*((void *)this + 432);
    if (v11)
    {
      do
      {
        unsigned int v12 = (void *)*v11;
        operator delete(v11);
        BOOL v11 = v12;
      }
      while (v12);
    }
    unint64_t v10 = this;
    *((void *)this + 432) = 0;
    uint64_t v13 = *((void *)this + 431);
    if (v13)
    {
      for (uint64_t i = 0; i != v13; ++i)
        *(void *)(*((void *)this + 430) + 8 * i) = 0;
    }
    *((void *)this + 433) = 0;
  }
  uint64_t v691 = (void *)((char *)v10 + 3480);
  if (*((void *)v10 + 438))
  {
    unint64_t v15 = (void *)*((void *)v10 + 437);
    if (v15)
    {
      do
      {
        unint64_t v16 = (void *)*v15;
        operator delete(v15);
        unint64_t v15 = v16;
      }
      while (v16);
    }
    *((void *)this + 437) = 0;
    uint64_t v17 = *((void *)this + 436);
    if (v17)
    {
      for (uint64_t j = 0; j != v17; ++j)
        *(void *)(*v691 + 8 * j) = 0;
    }
    unint64_t v10 = this;
    *((void *)this + 438) = 0;
  }
  uint64_t v711 = (void *)((char *)v10 + 3520);
  if (*((void *)v10 + 443))
  {
    uint64_t v19 = (void *)*((void *)v10 + 442);
    if (v19)
    {
      do
      {
        char v20 = (void *)*v19;
        operator delete(v19);
        uint64_t v19 = v20;
      }
      while (v20);
    }
    *((void *)this + 442) = 0;
    uint64_t v21 = *((void *)this + 441);
    if (v21)
    {
      for (uint64_t k = 0; k != v21; ++k)
        *(void *)(*v711 + 8 * k) = 0;
    }
    unint64_t v10 = this;
    *((void *)this + 443) = 0;
  }
  if (*((void *)v10 + 69))
  {
    uint64_t v23 = (void *)*((void *)v10 + 68);
    if (v23)
    {
      do
      {
        uint64_t v24 = (void *)*v23;
        operator delete(v23);
        uint64_t v23 = v24;
      }
      while (v24);
    }
    unint64_t v10 = this;
    *((void *)this + 68) = 0;
    uint64_t v25 = *((void *)this + 67);
    if (v25)
    {
      for (uint64_t m = 0; m != v25; ++m)
        *(void *)(*((void *)this + 66) + 8 * m) = 0;
    }
    *((void *)this + 69) = 0;
  }
  if (*((void *)v10 + 59))
  {
    uint64_t v27 = (void *)*((void *)v10 + 58);
    if (v27)
    {
      do
      {
        unint64_t v28 = (void *)*v27;
        operator delete(v27);
        uint64_t v27 = v28;
      }
      while (v28);
    }
    unint64_t v10 = this;
    *((void *)this + 58) = 0;
    uint64_t v29 = *((void *)this + 57);
    if (v29)
    {
      for (uint64_t n = 0; n != v29; ++n)
        *(void *)(*((void *)this + 56) + 8 * n) = 0;
    }
    *((void *)this + 59) = 0;
  }
  if (*((void *)v10 + 54))
  {
    long long v31 = (void *)*((void *)v10 + 53);
    if (v31)
    {
      do
      {
        unint64_t v32 = (void *)*v31;
        operator delete(v31);
        long long v31 = v32;
      }
      while (v32);
    }
    unint64_t v10 = this;
    *((void *)this + 53) = 0;
    uint64_t v33 = *((void *)this + 52);
    if (v33)
    {
      for (iuint64_t i = 0; ii != v33; ++ii)
        *(void *)(*((void *)this + 51) + 8 * ii) = 0;
    }
    *((void *)this + 54) = 0;
  }
  if (*((void *)v10 + 64))
  {
    unint64_t v35 = (void *)*((void *)v10 + 63);
    if (v35)
    {
      do
      {
        uint64_t v36 = (void *)*v35;
        operator delete(v35);
        unint64_t v35 = v36;
      }
      while (v36);
    }
    unint64_t v10 = this;
    *((void *)this + 63) = 0;
    uint64_t v37 = *((void *)this + 62);
    if (v37)
    {
      for (juint64_t j = 0; jj != v37; ++jj)
        *(void *)(*((void *)this + 61) + 8 * jj) = 0;
    }
    *((void *)this + 64) = 0;
  }
  if (*((void *)v10 + 49))
  {
    uint64_t v39 = (void *)*((void *)v10 + 48);
    if (v39)
    {
      do
      {
        char v40 = (void *)*v39;
        operator delete(v39);
        uint64_t v39 = v40;
      }
      while (v40);
    }
    unint64_t v10 = this;
    *((void *)this + 48) = 0;
    uint64_t v41 = *((void *)this + 47);
    if (v41)
    {
      for (kuint64_t k = 0; kk != v41; ++kk)
        *(void *)(*((void *)this + 46) + 8 * kk) = 0;
    }
    *((void *)this + 49) = 0;
  }
  long long v43 = (uint64_t *)(*(uint64_t (**)(md::DaVinciGroundRenderLayer *, const md::LayoutContext *))(*(void *)v10 + 96))(v10, a2);
  uint64_t v44 = (uint64_t)v10;
  unsigned int v45 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v46 = (int8x8_t)v45[1];
  if (!*(void *)&v46)
  {
    uint64_t v49 = 0;
    goto LABEL_122;
  }
  uint8x8_t v47 = (uint8x8_t)vcnt_s8(v46);
  v47.i16[0] = vaddlv_u8(v47);
  if (v47.u32[0] > 1uLL)
  {
    unint64_t v48 = 0x99BED48DEFBBD82BLL;
    if (*(void *)&v46 <= 0x99BED48DEFBBD82BLL) {
      unint64_t v48 = 0x99BED48DEFBBD82BLL % *(void *)&v46;
    }
  }
  else
  {
    unint64_t v48 = (*(void *)&v46 - 1) & 0x99BED48DEFBBD82BLL;
  }
  uint64_t v50 = *v45;
  unsigned int v51 = *(void **)(v50 + 8 * v48);
  if (!v51) {
    goto LABEL_103;
  }
  BOOL v52 = (void *)*v51;
  if (!v52) {
    goto LABEL_103;
  }
  if (v47.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v54 = v52[1];
      if (v54 == 0x99BED48DEFBBD82BLL)
      {
        if (v52[2] == 0x99BED48DEFBBD82BLL) {
          goto LABEL_97;
        }
      }
      else if ((v54 & (*(void *)&v46 - 1)) != v48)
      {
        goto LABEL_103;
      }
      BOOL v52 = (void *)*v52;
      if (!v52) {
        goto LABEL_103;
      }
    }
  }
  while (1)
  {
    unint64_t v53 = v52[1];
    if (v53 == 0x99BED48DEFBBD82BLL) {
      break;
    }
    if (v53 >= *(void *)&v46) {
      v53 %= *(void *)&v46;
    }
    if (v53 != v48) {
      goto LABEL_103;
    }
LABEL_86:
    BOOL v52 = (void *)*v52;
    if (!v52) {
      goto LABEL_103;
    }
  }
  if (v52[2] != 0x99BED48DEFBBD82BLL) {
    goto LABEL_86;
  }
LABEL_97:
  uint64_t v55 = v52[5];
  if (*(void *)(v55 + 8) != 0x99BED48DEFBBD82BLL)
  {
LABEL_103:
    uint64_t v49 = 0;
    if (v47.u32[0] > 1uLL) {
      goto LABEL_99;
    }
    goto LABEL_104;
  }
  uint64_t v49 = *(void *)(v55 + 32);
  if (v47.u32[0] > 1uLL)
  {
LABEL_99:
    unint64_t v56 = 0xF014CCE28176CA44;
    if (*(void *)&v46 <= 0xF014CCE28176CA44) {
      unint64_t v56 = 0xF014CCE28176CA44 % *(void *)&v46;
    }
    long long v57 = *(void **)(v50 + 8 * v56);
    if (!v57) {
      goto LABEL_122;
    }
    goto LABEL_105;
  }
LABEL_104:
  unint64_t v56 = (*(void *)&v46 - 1) & 0xF014CCE28176CA44;
  long long v57 = *(void **)(v50 + 8 * v56);
  if (!v57) {
    goto LABEL_122;
  }
LABEL_105:
  unsigned int v58 = (void *)*v57;
  if (!v58) {
    goto LABEL_122;
  }
  if (v47.u32[0] < 2uLL)
  {
    uint64_t v59 = *(void *)&v46 - 1;
    while (1)
    {
      uint64_t v61 = v58[1];
      if (v61 == 0xF014CCE28176CA44)
      {
        if (v58[2] == 0xF014CCE28176CA44) {
          goto LABEL_120;
        }
      }
      else if ((v61 & v59) != v56)
      {
        goto LABEL_122;
      }
      unsigned int v58 = (void *)*v58;
      if (!v58) {
        goto LABEL_122;
      }
    }
  }
  while (2)
  {
    unint64_t v60 = v58[1];
    if (v60 != 0xF014CCE28176CA44)
    {
      if (v60 >= *(void *)&v46) {
        v60 %= *(void *)&v46;
      }
      if (v60 != v56) {
        goto LABEL_122;
      }
      goto LABEL_109;
    }
    if (v58[2] != 0xF014CCE28176CA44)
    {
LABEL_109:
      unsigned int v58 = (void *)*v58;
      if (!v58) {
        goto LABEL_122;
      }
      continue;
    }
    break;
  }
LABEL_120:
  uint64_t v62 = v58[5];
  if (*(void *)(v62 + 8) == 0xF014CCE28176CA44)
  {
    long long v63 = *(int8x8_t **)(v62 + 32);
    goto LABEL_123;
  }
LABEL_122:
  long long v63 = 0;
LABEL_123:
  v64.__d_.__rep_ = std::chrono::steady_clock::now().__d_.__rep_;
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep rep = v64.__d_.__rep_;
  if (*(unsigned char *)(v44 + 3608))
  {
    uint64_t v66 = (unsigned char *)(v44 + 3616);
    if (*(unsigned char *)(v44 + 3616) && v64.__d_.__rep_ - *(void *)(v44 + 3600) < 10000000000) {
      goto LABEL_247;
    }
  }
  else
  {
    uint64_t v66 = (unsigned char *)(v44 + 3616);
  }
  if (*(unsigned char *)(v44 + 3560) != 1) {
    goto LABEL_247;
  }
  uint64_t v67 = *(void **)v49;
  long long v68 = *(unsigned __int16 **)(*(void *)v49 + 184);
  unint64_t v69 = *(unsigned __int16 **)(*(void *)v49 + 192);
  if (v68 != v69)
  {
    unint64_t v70 = (unsigned __int16 *)v67[15];
    int v71 = *(unsigned __int16 **)(*(void *)v49 + 184);
    do
    {
      long long v72 = (unsigned __int16 *)v67[14];
      if (v72 != v70)
      {
        long long v72 = (unsigned __int16 *)v67[14];
        while (*v72 != *v71)
        {
          v72 += 56;
          if (v72 == v70)
          {
            long long v72 = (unsigned __int16 *)v67[15];
            break;
          }
        }
      }
      if (!*((unsigned char *)v72 + 8)) {
        goto LABEL_247;
      }
      ++v71;
    }
    while (v71 != v69);
  }
  unint64_t v73 = (unsigned __int16 *)v67[26];
  long long v74 = (unsigned __int16 *)v67[27];
  if (v73 != v74)
  {
    unint64_t v75 = (unsigned __int16 *)v67[15];
    unint64_t v76 = (unsigned __int16 *)v67[26];
    do
    {
      uint64_t v79 = (unsigned __int16 *)v67[14];
      if (v79 != v75)
      {
        uint64_t v79 = (unsigned __int16 *)v67[14];
        while (*v79 != *v76)
        {
          v79 += 56;
          if (v79 == v75)
          {
            uint64_t v79 = (unsigned __int16 *)v67[15];
            break;
          }
        }
      }
      int v77 = *((unsigned __int8 *)v79 + 8);
      ++v76;
      if (v77) {
        _ZF = v76 == v74;
      }
      else {
        _ZF = 1;
      }
    }
    while (!_ZF);
    if (!v77) {
      goto LABEL_247;
    }
  }
  if (v68 == v69)
  {
LABEL_159:
    if (v73 == v74) {
      goto LABEL_171;
    }
    uint8x8_t v83 = (unsigned __int16 *)v67[14];
    char v82 = (unsigned __int16 *)v67[15];
    do
    {
      uint64_t v86 = v83;
      if (v83 != v82)
      {
        uint64_t v86 = v83;
        while (*v86 != *v73)
        {
          v86 += 56;
          if (v86 == v82)
          {
            uint64_t v86 = v82;
            break;
          }
        }
      }
      int v84 = *((unsigned __int8 *)v86 + 8);
      ++v73;
      if (v84) {
        BOOL v85 = v73 == v74;
      }
      else {
        BOOL v85 = 1;
      }
    }
    while (!v85);
    if (v84)
    {
LABEL_171:
      if (v43[1] == *v43)
      {
        if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
        }
        unint64_t v87 = (id)GEOGetVectorKitVKDefaultLog_log;
        if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1A1780000, v87, OS_LOG_TYPE_ERROR, "Missing DaVinciGroundRenderables for ground mesh layer", buf, 2u);
        }
      }
    }
  }
  else
  {
    uint64_t v80 = (unsigned __int16 *)v67[15];
    while (1)
    {
      unint64_t v81 = (unsigned __int16 *)v67[14];
      if (v81 != v80)
      {
        unint64_t v81 = (unsigned __int16 *)v67[14];
        while (*v81 != *v68)
        {
          v81 += 56;
          if (v81 == v80)
          {
            unint64_t v81 = (unsigned __int16 *)v67[15];
            break;
          }
        }
      }
      if (!*((unsigned char *)v81 + 8)) {
        break;
      }
      if (++v68 == v69) {
        goto LABEL_159;
      }
    }
  }
  std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)buf);
  std::chrono::duration<long long, std::ratio<1, 1000000000>>::rep v729 = rep;
  uint64_t v88 = *v43;
  uint64_t v89 = v43[1];
  if (*v43 == v89) {
    goto LABEL_852;
  }
  uint64_t v724 = v66;
  uint64_t v90 = 0;
  int8x16_t v731 = (int8x16_t)vdupq_n_s64(1uLL);
  while (2)
  {
    uint64_t v91 = *(void *)(*(void *)v88 + 384);
    long long v92 = md::MeshRenderableContext::renderablesForRegistry(v63, *(const gdc::Registry **)(v91 + 1320));
    if (*(unsigned char *)(v44 + 3560) == 1 && v92[1] == *v92)
    {
      unint64_t v93 = (void *)gdc::Registry::storage<md::components::Visibility>(*(int8x8_t **)(v91 + 1320));
      uint64_t v94 = v93[7];
      uint64_t v95 = v93[8];
      if (v94 == v95) {
        goto LABEL_200;
      }
      float32x4_t v96 = (int8x16_t *)v93[10];
      unint64_t v97 = v95 - v94 - 8;
      if (v97 >= 0x38)
      {
        uint64_t v99 = (v97 >> 3) + 1;
        if (v97 >= 0xF8)
        {
          int64x2_t v101 = 0uLL;
          uint64_t v100 = v99 & 0x3FFFFFFFFFFFFFE0;
          int64x2_t v102 = 0uLL;
          double v103 = v96 + 1;
          int64x2_t v104 = 0uLL;
          uint64_t v105 = v99 & 0x3FFFFFFFFFFFFFE0;
          int64x2_t v106 = 0uLL;
          int64x2_t v107 = 0uLL;
          int64x2_t v108 = 0uLL;
          int64x2_t v109 = 0uLL;
          int64x2_t v110 = 0uLL;
          int64x2_t v111 = 0uLL;
          int64x2_t v112 = 0uLL;
          int64x2_t v113 = 0uLL;
          int64x2_t v114 = 0uLL;
          int64x2_t v115 = 0uLL;
          int64x2_t v116 = 0uLL;
          int64x2_t v117 = 0uLL;
          int64x2_t v118 = 0uLL;
          do
          {
            uint8x16_t v119 = (uint8x16_t)vceqzq_s8(v103[-1]);
            uint16x8_t v120 = vmovl_u8(*(uint8x8_t *)v119.i8);
            uint32x4_t v121 = vmovl_u16(*(uint16x4_t *)v120.i8);
            v122.i64[0] = v121.u32[0];
            v122.i64[1] = v121.u32[1];
            int8x16_t v123 = (int8x16_t)vdupq_n_s64(1uLL);
            int64x2_t v734 = (int64x2_t)vandq_s8(v122, v123);
            v122.i64[0] = v121.u32[2];
            v122.i64[1] = v121.u32[3];
            int64x2_t v124 = (int64x2_t)vandq_s8(v122, v123);
            uint32x4_t v125 = vmovl_high_u16(v120);
            v122.i64[0] = v125.u32[0];
            v122.i64[1] = v125.u32[1];
            int64x2_t v126 = (int64x2_t)vandq_s8(v122, v123);
            uint16x8_t v127 = vmovl_high_u8(v119);
            uint32x4_t v128 = vmovl_u16(*(uint16x4_t *)v127.i8);
            v122.i64[0] = v128.u32[0];
            v122.i64[1] = v128.u32[1];
            int64x2_t v129 = (int64x2_t)vandq_s8(v122, v123);
            v122.i64[0] = v125.u32[2];
            v122.i64[1] = v125.u32[3];
            int64x2_t v130 = (int64x2_t)vandq_s8(v122, v123);
            v122.i64[0] = v128.u32[2];
            v122.i64[1] = v128.u32[3];
            int64x2_t v131 = (int64x2_t)vandq_s8(v122, v123);
            uint32x4_t v132 = vmovl_high_u16(v127);
            v122.i64[0] = v132.u32[0];
            v122.i64[1] = v132.u32[1];
            int64x2_t v133 = (int64x2_t)vandq_s8(v122, v123);
            v122.i64[0] = v132.u32[2];
            v122.i64[1] = v132.u32[3];
            int64x2_t v134 = (int64x2_t)vandq_s8(v122, v123);
            uint8x16_t v135 = (uint8x16_t)vceqzq_s8(*v103);
            uint16x8_t v136 = vmovl_u8(*(uint8x8_t *)v135.i8);
            uint32x4_t v137 = vmovl_u16(*(uint16x4_t *)v136.i8);
            v122.i64[0] = v137.u32[0];
            v122.i64[1] = v137.u32[1];
            int64x2_t v138 = (int64x2_t)vandq_s8(v122, v123);
            v122.i64[0] = v137.u32[2];
            v122.i64[1] = v137.u32[3];
            int64x2_t v139 = (int64x2_t)vandq_s8(v122, v123);
            uint32x4_t v140 = vmovl_high_u16(v136);
            v122.i64[0] = v140.u32[0];
            v122.i64[1] = v140.u32[1];
            int64x2_t v141 = (int64x2_t)vandq_s8(v122, v123);
            uint16x8_t v142 = vmovl_high_u8(v135);
            uint32x4_t v143 = vmovl_u16(*(uint16x4_t *)v142.i8);
            v122.i64[0] = v143.u32[0];
            v122.i64[1] = v143.u32[1];
            int64x2_t v144 = (int64x2_t)vandq_s8(v122, v123);
            v122.i64[0] = v140.u32[2];
            v122.i64[1] = v140.u32[3];
            int64x2_t v145 = (int64x2_t)vandq_s8(v122, v123);
            v122.i64[0] = v143.u32[2];
            v122.i64[1] = v143.u32[3];
            int64x2_t v146 = (int64x2_t)vandq_s8(v122, v123);
            uint32x4_t v147 = vmovl_high_u16(v142);
            v122.i64[0] = v147.u32[0];
            v122.i64[1] = v147.u32[1];
            int64x2_t v148 = (int64x2_t)vandq_s8(v122, v123);
            v122.i64[0] = v147.u32[2];
            v122.i64[1] = v147.u32[3];
            int64x2_t v110 = vaddq_s64(v110, v134);
            int64x2_t v109 = vaddq_s64(v109, v133);
            int64x2_t v108 = vaddq_s64(v108, v131);
            int64x2_t v106 = vaddq_s64(v106, v130);
            int64x2_t v107 = vaddq_s64(v107, v129);
            int64x2_t v104 = vaddq_s64(v104, v126);
            int64x2_t v102 = vaddq_s64(v102, v124);
            int64x2_t v101 = vaddq_s64(v101, v734);
            int64x2_t v118 = vaddq_s64(v118, (int64x2_t)vandq_s8(v122, v123));
            int64x2_t v117 = vaddq_s64(v117, v148);
            int64x2_t v116 = vaddq_s64(v116, v146);
            int64x2_t v114 = vaddq_s64(v114, v145);
            int64x2_t v115 = vaddq_s64(v115, v144);
            int64x2_t v113 = vaddq_s64(v113, v141);
            int64x2_t v112 = vaddq_s64(v112, v139);
            int64x2_t v111 = vaddq_s64(v111, v138);
            v103 += 2;
            v105 -= 32;
          }
          while (v105);
          uint64_t v98 = vaddvq_s64(vaddq_s64(vaddq_s64(vaddq_s64(vaddq_s64(v111, v101), vaddq_s64(v115, v107)), vaddq_s64(vaddq_s64(v113, v104), vaddq_s64(v117, v109))), vaddq_s64(vaddq_s64(vaddq_s64(v112, v102), vaddq_s64(v116, v108)), vaddq_s64(vaddq_s64(v114, v106), vaddq_s64(v118, v110)))));
          if (v99 == v100) {
            goto LABEL_200;
          }
          if ((v99 & 0x18) == 0)
          {
            v94 += 8 * v100;
            float32x4_t v96 = (int8x16_t *)((char *)v96 + v100);
            goto LABEL_197;
          }
        }
        else
        {
          uint64_t v98 = 0;
          uint64_t v100 = 0;
        }
        uint64_t v149 = v99 & 0x3FFFFFFFFFFFFFF8;
        int64x2_t v150 = 0uLL;
        int64x2_t v151 = (int64x2_t)(unint64_t)v98;
        uint64_t v152 = v100 - (v99 & 0x3FFFFFFFFFFFFFF8);
        double v153 = (int8x8_t *)&v96->i8[v100];
        int64x2_t v154 = 0uLL;
        int64x2_t v155 = 0uLL;
        do
        {
          int8x8_t v156 = *v153++;
          uint16x8_t v157 = vmovl_u8((uint8x8_t)vceqz_s8(v156));
          uint32x4_t v158 = vmovl_u16(*(uint16x4_t *)v157.i8);
          v159.i64[0] = v158.u32[0];
          v159.i64[1] = v158.u32[1];
          int64x2_t v160 = (int64x2_t)vandq_s8(v159, v731);
          v159.i64[0] = v158.u32[2];
          v159.i64[1] = v158.u32[3];
          int64x2_t v161 = (int64x2_t)vandq_s8(v159, v731);
          uint32x4_t v162 = vmovl_high_u16(v157);
          v159.i64[0] = v162.u32[0];
          v159.i64[1] = v162.u32[1];
          int64x2_t v163 = (int64x2_t)vandq_s8(v159, v731);
          v159.i64[0] = v162.u32[2];
          v159.i64[1] = v162.u32[3];
          int64x2_t v155 = vaddq_s64(v155, (int64x2_t)vandq_s8(v159, v731));
          int64x2_t v154 = vaddq_s64(v154, v163);
          int64x2_t v150 = vaddq_s64(v150, v161);
          int64x2_t v151 = vaddq_s64(v151, v160);
          v152 += 8;
        }
        while (v152);
        uint64_t v98 = vaddvq_s64(vaddq_s64(vaddq_s64(v151, v154), vaddq_s64(v150, v155)));
        if (v99 != v149)
        {
          float32x4_t v96 = (int8x16_t *)((char *)v96 + v149);
          v94 += 8 * (v99 & 0x3FFFFFFFFFFFFFF8);
          goto LABEL_197;
        }
      }
      else
      {
        uint64_t v98 = 0;
        do
        {
LABEL_197:
          int v164 = v96->u8[0];
          float32x4_t v96 = (int8x16_t *)((char *)v96 + 1);
          if (!v164) {
            ++v98;
          }
          v94 += 8;
        }
        while (v94 != v95);
      }
LABEL_200:
      if (v90) {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(buf, (uint64_t)" | ", 3);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(buf, (uint64_t)"Key: ", 5);
      gdc::LayerDataRequestKey::keysInt32Str((std::string *)__p, (unsigned __int16 *)(v91 + 16));
      if (__p[23] >= 0) {
        unint64_t v165 = __p;
      }
      else {
        unint64_t v165 = *(unsigned char **)__p;
      }
      if (__p[23] >= 0) {
        uint64_t v166 = __p[23];
      }
      else {
        uint64_t v166 = *(void *)&__p[8];
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(buf, (uint64_t)v165, v166);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(buf, (uint64_t)", ", 2);
      if ((__p[23] & 0x80000000) != 0) {
        operator delete(*(void **)__p);
      }
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(buf, (uint64_t)"Has mesh errors: ", 17);
      unint64_t v167 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v167, (uint64_t)", ", 2);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(buf, (uint64_t)"MeshInstance count: ", 20);
      gdc::Registry::storage<md::components::MeshInstance>(*(int8x8_t **)(v91 + 1320));
      unint64_t v168 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v168, (uint64_t)", ", 2);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(buf, (uint64_t)"PendingMaterial count: ", 23);
      gdc::Registry::storage<md::components::PendingMaterial>(*(int8x8_t **)(v91 + 1320));
      double v169 = (void *)std::ostream::operator<<();
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v169, (uint64_t)", ", 2);
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(buf, (uint64_t)"Invisible MeshInstances count: ", 31);
      std::ostream::operator<<();
      ++v90;
    }
    v88 += 8;
    if (v88 != v89) {
      continue;
    }
    break;
  }
  uint64_t v66 = v724;
  if (!v90)
  {
LABEL_852:
    if (*v66)
    {
      if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
      }
      BOOL v175 = (id)GEOGetVectorKitVKDefaultLog_log;
      if (os_log_type_enabled(v175, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long __p = 0;
        _os_log_impl(&dword_1A1780000, v175, OS_LOG_TYPE_INFO, "No longer missing MeshRenderables for ground mesh layer.", __p, 2u);
      }
    }
    *uint64_t v66 = 0;
    goto LABEL_244;
  }
  if (!*(unsigned char *)(v44 + 3608)) {
    *(unsigned char *)(v44 + 3608) = 1;
  }
  *(void *)(v44 + 3600) = v729;
  *(unsigned char *)(v44 + 3616) = 1;
  if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
  }
  double v170 = (id)GEOGetVectorKitVKDefaultLog_log;
  if (os_log_type_enabled(v170, OS_LOG_TYPE_ERROR))
  {
    uint64_t v172 = *v43;
    uint64_t v171 = v43[1];
    if ((v787 & 0x10) != 0)
    {
      unint64_t v176 = v786;
      if (v786 < v783)
      {
        unint64_t v786 = v783;
        unint64_t v176 = v783;
      }
      unsigned int v177 = (const void **)v782;
    }
    else
    {
      if ((v787 & 8) == 0)
      {
        size_t v173 = 0;
        HIBYTE(v796) = 0;
        p_dst = (void **)&__dst;
        goto LABEL_239;
      }
      unsigned int v177 = (const void **)v780;
      unint64_t v176 = v781;
    }
    float v178 = *v177;
    size_t v173 = v176 - (void)*v177;
    if (v173 > 0x7FFFFFFFFFFFFFF7) {
      abort();
    }
    if (v173 >= 0x17)
    {
      uint64_t v179 = (v173 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v173 | 7) != 0x17) {
        uint64_t v179 = v173 | 7;
      }
      uint64_t v180 = v179 + 1;
      p_dst = (void **)operator new(v179 + 1);
      *((void *)&v796 + 1) = v180 | 0x8000000000000000;
      __dst = p_dst;
      *(void *)&long long v796 = v173;
    }
    else
    {
      HIBYTE(v796) = v176 - *(unsigned char *)v177;
      p_dst = (void **)&__dst;
      if (!v173)
      {
LABEL_239:
        *((unsigned char *)p_dst + v173) = 0;
        float32x2_t v181 = (void **)&__dst;
        if (v796 < 0) {
          float32x2_t v181 = __dst;
        }
        *(_DWORD *)long long __p = 134218498;
        *(void *)&__p[4] = v90;
        *(_WORD *)&__p[12] = 2048;
        *(void *)&__p[14] = (v171 - v172) >> 3;
        *(_WORD *)&__p[22] = 2080;
        *(void *)&__p[24] = v181;
        _os_log_impl(&dword_1A1780000, v170, OS_LOG_TYPE_ERROR, "Missing MeshRenderables for ground mesh layer for (%lu/%lu) of ground tiles. Tile debug info: (%s)", __p, 0x20u);
        if (SHIBYTE(v796) < 0) {
          operator delete(__dst);
        }
        goto LABEL_243;
      }
    }
    memmove(p_dst, v178, v173);
    goto LABEL_239;
  }
LABEL_243:

LABEL_244:
  *(void *)buf = *MEMORY[0x1E4FBA418];
  *(void *)&buf[*(void *)(*(void *)buf - 24)] = *(void *)(MEMORY[0x1E4FBA418] + 24);
  uint64_t v778 = MEMORY[0x1E4FBA470] + 16;
  if (v785 < 0) {
    operator delete(v784);
  }
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1A62391A0](&v788);
  uint64_t v44 = (uint64_t)v728;
LABEL_247:
  unsigned int v182 = *(void **)(*(void *)(v44 + 40) + 24);
  unsigned int v183 = (void *)*((void *)a2 + 1);
  int8x8_t v184 = (int8x8_t)v183[1];
  if (!*(void *)&v184)
  {
    uint64_t v187 = 0;
    uint64_t v188 = 0;
    BOOL v189 = MEMORY[0xE0] == 0;
    goto LABEL_297;
  }
  uint8x8_t v185 = (uint8x8_t)vcnt_s8(v184);
  v185.i16[0] = vaddlv_u8(v185);
  if (v185.u32[0] > 1uLL)
  {
    uint64_t v186 = 0x41E8D6E445F4145;
    if (*(void *)&v184 <= 0x41E8D6E445F4145uLL) {
      uint64_t v186 = 0x41E8D6E445F4145uLL % *(void *)&v184;
    }
  }
  else
  {
    uint64_t v186 = (*(void *)&v184 - 1) & 0x41E8D6E445F4145;
  }
  uint64_t v190 = *(void **)(*v183 + 8 * v186);
  if (!v190 || (float32x2_t v191 = (void *)*v190) == 0)
  {
    uint64_t v187 = 0;
    BOOL v189 = MEMORY[0xE0] == 0;
    goto LABEL_274;
  }
  if (v185.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v193 = v191[1];
      if (v193 == 0x41E8D6E445F4145)
      {
        if (v191[2] == 0x41E8D6E445F4145) {
          goto LABEL_270;
        }
      }
      else if ((v193 & (*(void *)&v184 - 1)) != v186)
      {
        goto LABEL_272;
      }
      float32x2_t v191 = (void *)*v191;
      if (!v191) {
        goto LABEL_272;
      }
    }
  }
  while (2)
  {
    unint64_t v192 = v191[1];
    if (v192 != 0x41E8D6E445F4145)
    {
      if (v192 >= *(void *)&v184) {
        v192 %= *(void *)&v184;
      }
      if (v192 != v186) {
        goto LABEL_272;
      }
      goto LABEL_258;
    }
    if (v191[2] != 0x41E8D6E445F4145)
    {
LABEL_258:
      float32x2_t v191 = (void *)*v191;
      if (!v191) {
        goto LABEL_272;
      }
      continue;
    }
    break;
  }
LABEL_270:
  uint64_t v194 = v191[5];
  if (*(void *)(v194 + 8) == 0x41E8D6E445F4145)
  {
    uint64_t v187 = *(void *)(v194 + 32);
    goto LABEL_273;
  }
LABEL_272:
  uint64_t v187 = 0;
LABEL_273:
  BOOL v189 = *(unsigned char *)(v187 + 224) == 0;
LABEL_274:
  uint8x8_t v195 = (uint8x8_t)vcnt_s8(v184);
  v195.i16[0] = vaddlv_u8(v195);
  if (v195.u32[0] > 1uLL)
  {
    unint64_t v196 = 0xE42D19AFCA302E68;
    if (*(void *)&v184 <= 0xE42D19AFCA302E68) {
      unint64_t v196 = 0xE42D19AFCA302E68 % *(void *)&v184;
    }
  }
  else
  {
    unint64_t v196 = (*(void *)&v184 - 1) & 0xE42D19AFCA302E68;
  }
  unint64_t v197 = *(void **)(*v183 + 8 * v196);
  if (!v197) {
    goto LABEL_296;
  }
  long long v198 = (void *)*v197;
  if (!v198) {
    goto LABEL_296;
  }
  if (v195.u32[0] < 2uLL)
  {
    uint64_t v199 = *(void *)&v184 - 1;
    while (1)
    {
      uint64_t v201 = v198[1];
      if (v201 == 0xE42D19AFCA302E68)
      {
        if (v198[2] == 0xE42D19AFCA302E68) {
          goto LABEL_294;
        }
      }
      else if ((v201 & v199) != v196)
      {
        goto LABEL_296;
      }
      long long v198 = (void *)*v198;
      if (!v198) {
        goto LABEL_296;
      }
    }
  }
  while (2)
  {
    unint64_t v200 = v198[1];
    if (v200 != 0xE42D19AFCA302E68)
    {
      if (v200 >= *(void *)&v184) {
        v200 %= *(void *)&v184;
      }
      if (v200 != v196) {
        goto LABEL_296;
      }
      goto LABEL_283;
    }
    if (v198[2] != 0xE42D19AFCA302E68)
    {
LABEL_283:
      long long v198 = (void *)*v198;
      if (!v198) {
        goto LABEL_296;
      }
      continue;
    }
    break;
  }
LABEL_294:
  uint64_t v202 = v198[5];
  if (*(void *)(v202 + 8) == 0xE42D19AFCA302E68)
  {
    uint64_t v188 = *(md::StyleLogicContext **)(v202 + 32);
    goto LABEL_297;
  }
LABEL_296:
  uint64_t v188 = 0;
LABEL_297:
  uint64_t v203 = *(void *)(v44 + 2032);
  unint64_t v204 = *(void *)(v203 + 8);
  _S0 = *(_DWORD *)(*((void *)v188 + 4) + 256);
  __asm { FCVT            H0, S0 }
  **(_WORD **)(v203 + 72) = _S0;
  if (*(void *)(v203 + 64) > v204) {
    unint64_t v204 = *(void *)(v203 + 64);
  }
  *(void *)(v203 + 56) = 0;
  *(void *)(v203 + 64) = v204;
  int8x8_t v209 = (int8x8_t)v183[1];
  if (!*(void *)&v209) {
    goto LABEL_322;
  }
  uint8x8_t v210 = (uint8x8_t)vcnt_s8(v209);
  v210.i16[0] = vaddlv_u8(v210);
  if (v210.u32[0] > 1uLL)
  {
    uint64_t v211 = 0x1AF456233693CD46;
    if (*(void *)&v209 <= 0x1AF456233693CD46uLL) {
      uint64_t v211 = 0x1AF456233693CD46uLL % *(void *)&v209;
    }
  }
  else
  {
    uint64_t v211 = (*(void *)&v209 - 1) & 0x1AF456233693CD46;
  }
  double v212 = *(void **)(*v183 + 8 * v211);
  if (!v212) {
    goto LABEL_322;
  }
  unint64_t v213 = (void *)*v212;
  if (!v213) {
    goto LABEL_322;
  }
  if (v210.u32[0] < 2uLL)
  {
    uint64_t v214 = *(void *)&v209 - 1;
    while (1)
    {
      uint64_t v216 = v213[1];
      if (v216 == 0x1AF456233693CD46)
      {
        if (v213[2] == 0x1AF456233693CD46) {
          goto LABEL_320;
        }
      }
      else if ((v216 & v214) != v211)
      {
        goto LABEL_322;
      }
      unint64_t v213 = (void *)*v213;
      if (!v213) {
        goto LABEL_322;
      }
    }
  }
  while (1)
  {
    unint64_t v215 = v213[1];
    if (v215 == 0x1AF456233693CD46) {
      break;
    }
    if (v215 >= *(void *)&v209) {
      v215 %= *(void *)&v209;
    }
    if (v215 != v211) {
      goto LABEL_322;
    }
LABEL_309:
    unint64_t v213 = (void *)*v213;
    if (!v213) {
      goto LABEL_322;
    }
  }
  if (v213[2] != 0x1AF456233693CD46) {
    goto LABEL_309;
  }
LABEL_320:
  uint64_t v217 = v213[5];
  if (*(void *)(v217 + 8) != 0x1AF456233693CD46)
  {
LABEL_322:
    uint64_t v218 = 0;
    goto LABEL_323;
  }
  uint64_t v218 = *(void *)(v217 + 32);
LABEL_323:
  BOOL v792 = *(unsigned __int8 *)(v218 + 3776) - 1 < 3;
  if (!v189 || *(unsigned char *)(v44 + 3560) == 3)
  {
    char v219 = (void *)v182[1];
    uint64_t v220 = v219[3];
    uint64_t v221 = v219[4];
    if (v221 == v220)
    {
      uint64_t v723 = 0;
    }
    else
    {
      uint64_t v222 = 0;
      while (1)
      {
        float v223 = *(unsigned __int8 **)(v220 + 8 * v222);
        if (*v223 == *(unsigned __int8 *)(v44 + 3356))
        {
          unint64_t v224 = *((void *)v223 + 1);
          uint64_t v225 = v219[15];
          if (v224 < (v219[16] - v225) >> 3) {
            break;
          }
        }
        if (++v222 >= (unint64_t)((v221 - v220) >> 3)) {
          goto LABEL_333;
        }
      }
      uint64_t v226 = *(void *)(v225 + 8 * v224);
      if (v226)
      {
        uint64_t v723 = *(void *)(*(void *)(v226 + 24) + 8 * *(unsigned __int8 *)(v44 + 3357));
        uint64_t v227 = v221 - v220;
        if (v221 == v220) {
          goto LABEL_341;
        }
        goto LABEL_334;
      }
LABEL_333:
      uint64_t v723 = 0;
      uint64_t v227 = v221 - v220;
      if (v221 == v220) {
        goto LABEL_341;
      }
LABEL_334:
      uint64_t v228 = 0;
      unint64_t v229 = v227 >> 3;
      while (1)
      {
        float v230 = *(unsigned __int8 **)(v220 + 8 * v228);
        if (*v230 == *(unsigned __int8 *)(v44 + 3352))
        {
          unint64_t v231 = *((void *)v230 + 1);
          uint64_t v232 = v219[15];
          if (v231 < (v219[16] - v232) >> 3) {
            break;
          }
        }
        if (++v228 >= v229) {
          goto LABEL_341;
        }
      }
      uint64_t v233 = *(void *)(v232 + 8 * v231);
      if (v233)
      {
        uint64_t v718 = *(void *)(*(void *)(v233 + 24) + 8 * *(unsigned __int8 *)(v44 + 3353));
        unint64_t v234 = (unsigned __int8 *)(v44 + 3354);
        goto LABEL_342;
      }
    }
LABEL_341:
    uint64_t v718 = 0;
    unint64_t v234 = (unsigned __int8 *)(v44 + 3354);
    goto LABEL_342;
  }
  float v257 = *(double *)(v218 + 40);
  char v219 = (void *)v182[1];
  uint64_t v220 = v219[3];
  uint64_t v221 = v219[4];
  if (v257 >= 0.0001)
  {
    if (v221 == v220)
    {
      uint64_t v723 = 0;
    }
    else
    {
      uint64_t v368 = 0;
      while (1)
      {
        uint64_t v369 = *(unsigned __int8 **)(v220 + 8 * v368);
        if (*v369 == *(unsigned __int8 *)(v44 + 3368))
        {
          unint64_t v370 = *((void *)v369 + 1);
          uint64_t v371 = v219[15];
          if (v370 < (v219[16] - v371) >> 3) {
            break;
          }
        }
        if (++v368 >= (unint64_t)((v221 - v220) >> 3)) {
          goto LABEL_770;
        }
      }
      uint64_t v372 = *(void *)(v371 + 8 * v370);
      if (v372)
      {
        uint64_t v723 = *(void *)(*(void *)(v372 + 24) + 8 * *(unsigned __int8 *)(v44 + 3369));
        uint64_t v373 = v221 - v220;
        if (v221 == v220) {
          goto LABEL_781;
        }
        goto LABEL_771;
      }
LABEL_770:
      uint64_t v723 = 0;
      uint64_t v373 = v221 - v220;
      if (v221 == v220) {
        goto LABEL_781;
      }
LABEL_771:
      uint64_t v640 = 0;
      unint64_t v641 = v373 >> 3;
      while (1)
      {
        v642 = *(unsigned __int8 **)(v220 + 8 * v640);
        if (*v642 == *(unsigned __int8 *)(v44 + 3362))
        {
          unint64_t v643 = *((void *)v642 + 1);
          uint64_t v644 = v219[15];
          if (v643 < (v219[16] - v644) >> 3) {
            break;
          }
        }
        if (++v640 >= v641) {
          goto LABEL_781;
        }
      }
      uint64_t v645 = *(void *)(v644 + 8 * v643);
      if (v645)
      {
        uint64_t v718 = *(void *)(*(void *)(v645 + 24) + 8 * *(unsigned __int8 *)(v44 + 3363));
LABEL_782:
        unint64_t v234 = (unsigned __int8 *)(v44 + 3365);
        goto LABEL_342;
      }
    }
LABEL_781:
    uint64_t v718 = 0;
    goto LABEL_782;
  }
  if (v221 == v220)
  {
    uint64_t v723 = 0;
  }
  else
  {
    uint64_t v258 = 0;
    while (1)
    {
      v259 = *(unsigned __int8 **)(v220 + 8 * v258);
      if (*v259 == *(unsigned __int8 *)(v44 + 3377))
      {
        unint64_t v260 = *((void *)v259 + 1);
        uint64_t v261 = v219[15];
        if (v260 < (v219[16] - v261) >> 3) {
          break;
        }
      }
      if (++v258 >= (unint64_t)((v221 - v220) >> 3)) {
        goto LABEL_763;
      }
    }
    uint64_t v262 = *(void *)(v261 + 8 * v260);
    if (v262)
    {
      uint64_t v723 = *(void *)(*(void *)(v262 + 24) + 8 * *(unsigned __int8 *)(v44 + 3378));
      uint64_t v263 = v221 - v220;
      if (v221 == v220) {
        goto LABEL_779;
      }
      goto LABEL_764;
    }
LABEL_763:
    uint64_t v723 = 0;
    uint64_t v263 = v221 - v220;
    if (v221 == v220) {
      goto LABEL_779;
    }
LABEL_764:
    uint64_t v634 = 0;
    unint64_t v635 = v263 >> 3;
    while (1)
    {
      std::string::size_type v636 = *(unsigned __int8 **)(v220 + 8 * v634);
      if (*v636 == *(unsigned __int8 *)(v44 + 3371))
      {
        unint64_t v637 = *((void *)v636 + 1);
        uint64_t v638 = v219[15];
        if (v637 < (v219[16] - v638) >> 3) {
          break;
        }
      }
      if (++v634 >= v635) {
        goto LABEL_779;
      }
    }
    uint64_t v639 = *(void *)(v638 + 8 * v637);
    if (v639)
    {
      uint64_t v718 = *(void *)(*(void *)(v639 + 24) + 8 * *(unsigned __int8 *)(v44 + 3372));
      unint64_t v234 = (unsigned __int8 *)(v44 + 3374);
      goto LABEL_342;
    }
  }
LABEL_779:
  uint64_t v718 = 0;
  unint64_t v234 = (unsigned __int8 *)(v44 + 3374);
LABEL_342:
  v688 = v188;
  if (v221 == v220)
  {
    int64_t v241 = (double *)v218;
    uint64_t v692 = 0;
    uint64_t v708 = 0;
    uint64_t v725 = 0;
LABEL_359:
    uint64_t v719 = 0;
    BOOL v716 = 1;
    goto LABEL_388;
  }
  uint64_t v235 = 0;
  while (1)
  {
    float v236 = *(unsigned __int8 **)(v220 + 8 * v235);
    if (*v236 == *v234)
    {
      unint64_t v237 = *((void *)v236 + 1);
      uint64_t v238 = v219[15];
      if (v237 < (v219[16] - v238) >> 3) {
        break;
      }
    }
    if (++v235 >= (unint64_t)((v221 - v220) >> 3)) {
      goto LABEL_350;
    }
  }
  uint64_t v239 = *(void *)(v238 + 8 * v237);
  if (!v239)
  {
LABEL_350:
    uint64_t v725 = 0;
    uint64_t v240 = v221 - v220;
    if (v221 != v220) {
      goto LABEL_351;
    }
LABEL_349:
    int64_t v241 = (double *)v218;
    uint64_t v692 = 0;
    uint64_t v708 = 0;
    goto LABEL_359;
  }
  uint64_t v725 = *(void *)(*(void *)(v239 + 24) + 8 * v234[1]);
  uint64_t v240 = v221 - v220;
  if (v221 == v220) {
    goto LABEL_349;
  }
LABEL_351:
  uint64_t v242 = 0;
  unint64_t v243 = v240 >> 3;
  while (1)
  {
    unsigned int v244 = *(unsigned __int8 **)(v220 + 8 * v242);
    if (*v244 == *(unsigned __int8 *)(v44 + 3389))
    {
      unint64_t v245 = *((void *)v244 + 1);
      uint64_t v246 = v219[15];
      if (v245 < (v219[16] - v246) >> 3) {
        break;
      }
    }
    if (++v242 >= v243) {
      goto LABEL_360;
    }
  }
  uint64_t v247 = *(void *)(v246 + 8 * v245);
  if (v247)
  {
    uint64_t v248 = *(void *)(*(void *)(v247 + 24) + 8 * *(unsigned __int8 *)(v44 + 3390));
    uint64_t v249 = v221 - v220;
    if (v221 == v220)
    {
LABEL_357:
      int64_t v241 = (double *)v218;
      uint64_t v719 = 0;
      goto LABEL_385;
    }
  }
  else
  {
LABEL_360:
    uint64_t v248 = 0;
    uint64_t v249 = v221 - v220;
    if (v221 == v220) {
      goto LABEL_357;
    }
  }
  uint64_t v250 = 0;
  unint64_t v251 = v249 >> 3;
  while (1)
  {
    unsigned int v252 = *(unsigned __int8 **)(v220 + 8 * v250);
    if (*v252 == *(unsigned __int8 *)(v44 + 3387))
    {
      unint64_t v253 = *((void *)v252 + 1);
      uint64_t v254 = v219[15];
      if (v253 < (v219[16] - v254) >> 3) {
        break;
      }
    }
    if (++v250 >= v251) {
      goto LABEL_377;
    }
  }
  uint64_t v255 = *(void *)(v254 + 8 * v253);
  if (v255)
  {
    uint64_t v719 = *(void *)(*(void *)(v255 + 24) + 8 * *(unsigned __int8 *)(v44 + 3388));
    uint64_t v256 = v221 - v220;
    if (v221 == v220) {
      goto LABEL_384;
    }
    goto LABEL_378;
  }
LABEL_377:
  uint64_t v719 = 0;
  uint64_t v256 = v221 - v220;
  if (v221 == v220) {
    goto LABEL_384;
  }
LABEL_378:
  uint64_t v264 = 0;
  unint64_t v265 = v256 >> 3;
  while (1)
  {
    unint64_t v266 = *(unsigned __int8 **)(v220 + 8 * v264);
    if (*v266 == *(unsigned __int8 *)(v44 + 3385))
    {
      unint64_t v267 = *((void *)v266 + 1);
      uint64_t v268 = v219[15];
      if (v267 < (v219[16] - v268) >> 3) {
        break;
      }
    }
    if (++v264 >= v265) {
      goto LABEL_384;
    }
  }
  uint64_t v269 = *(void *)(v268 + 8 * v267);
  if (v269)
  {
    int64_t v241 = (double *)v218;
    uint64_t v692 = *(void *)(*(void *)(v269 + 24) + 8 * *(unsigned __int8 *)(v44 + 3386));
    goto LABEL_386;
  }
LABEL_384:
  int64_t v241 = (double *)v218;
LABEL_385:
  uint64_t v692 = 0;
LABEL_386:
  BOOL v716 = v248 == 0;
  uint64_t v708 = v248;
  if (v248) {
    *(void *)(v248 + 32) = *(void *)(v44 + 3176);
  }
LABEL_388:
  uint64_t v689 = (*(uint64_t (**)(uint64_t, const md::LayoutContext *))(*(void *)v44 + 96))(v44, a2);
  md::DaVinciGroundRenderLayer::createMeshLayoutContext((md::DaVinciGroundRenderLayer *)buf, (const md::LayoutContext *)v44, a2);
  int v721 = *(unsigned __int8 *)(v187 + 228);
  if (!buf[6])
  {
    uint64_t v690 = 0;
    if (v779) {
      goto LABEL_405;
    }
    goto LABEL_420;
  }
  int v270 = *(unsigned __int8 *)(v44 + 3560);
  uint64_t v271 = 2;
  if (v270 == 2) {
    uint64_t v271 = 3;
  }
  if (v270 == 3) {
    uint64_t v271 = 4;
  }
  uint64_t v272 = (void *)v182[1];
  uint64_t v273 = v272[3];
  uint64_t v274 = v272[4];
  uint64_t v275 = v274 - v273;
  if (v274 == v273) {
    goto LABEL_401;
  }
  uint64_t v276 = 0;
  unint64_t v277 = v275 >> 3;
  while (1)
  {
    uint64_t v278 = *(void *)(v273 + 8 * v276);
    if (!*(unsigned char *)v278)
    {
      unint64_t v279 = *(void *)(v278 + 8);
      uint64_t v280 = v272[15];
      if (v279 < (v272[16] - v280) >> 3) {
        break;
      }
    }
    if (++v276 >= v277) {
      goto LABEL_401;
    }
  }
  uint64_t v281 = *(void *)(v280 + 8 * v279);
  if (!v281)
  {
LABEL_401:
    uint64_t v690 = 0;
    if (*(unsigned char *)(v187 + 228)) {
      goto LABEL_404;
    }
  }
  else
  {
    uint64_t v690 = *(void *)(*(void *)(v281 + 24) + 8 * v271);
    if (*(unsigned char *)(v187 + 228)) {
      goto LABEL_404;
    }
  }
  if (v270 == 1) {
    *(void *)(v690 + 32) = *(void *)(v44 + 3160);
  }
LABEL_404:
  if (!v779)
  {
LABEL_420:
    uint64_t v710 = 0;
    goto LABEL_421;
  }
LABEL_405:
  int v282 = *(unsigned __int8 *)(v44 + 3560);
  uint64_t v283 = 2;
  if (v282 == 2) {
    uint64_t v283 = 3;
  }
  if (v282 == 3) {
    uint64_t v283 = 4;
  }
  unint64_t v284 = (void *)v182[1];
  uint64_t v285 = v284[3];
  uint64_t v286 = v284[4];
  uint64_t v287 = v286 - v285;
  if (v286 == v285) {
    goto LABEL_417;
  }
  uint64_t v288 = 0;
  unint64_t v289 = v287 >> 3;
  while (1)
  {
    uint64_t v290 = *(void *)(v285 + 8 * v288);
    if (*(unsigned char *)v290 == 3)
    {
      unint64_t v291 = *(void *)(v290 + 8);
      uint64_t v292 = v284[15];
      if (v291 < (v284[16] - v292) >> 3) {
        break;
      }
    }
    if (++v288 >= v289) {
      goto LABEL_417;
    }
  }
  uint64_t v293 = *(void *)(v292 + 8 * v291);
  if (!v293)
  {
LABEL_417:
    uint64_t v710 = 0;
    if (v282 != 1) {
      goto LABEL_421;
    }
    goto LABEL_418;
  }
  uint64_t v710 = *(void *)(*(void *)(v293 + 24) + 8 * v283);
  if (v282 == 1) {
LABEL_418:
  }
    *(void *)(v710 + 32) = *(void *)(v44 + 3160);
LABEL_421:
  uint64_t v294 = v182[40];
  *(void *)&__p[8] = 0;
  *(void *)long long __p = 0;
  unint64_t v295 = *(void *)(v294 + 8);
  *(void *)&long long v296 = 0;
  *((void *)&v296 + 1) = v294;
  long long v735 = v296;
  if (v295) {
    unsigned int v297 = *(short float **)(v294 + 72);
  }
  else {
    unsigned int v297 = 0;
  }
  *(_OWORD *)long long __p = v296;
  *(void *)&__p[16] = 0;
  *(void *)&__p[24] = v295;
  *(void *)&__p[40] = v297;
  *(_WORD *)&__p[32] = 1;
  id v298 = *(id *)a2;
  unsigned int v299 = (void *)[v298 finalRenderTarget];
  uint64_t v300 = v299[42];
  if (v300)
  {
    unsigned int v301 = *(_DWORD *)(v300 + 36);
    goto LABEL_437;
  }
  uint64_t v302 = v299[11];
  if (v302)
  {
    BOOL v303 = v299 + 12;
    goto LABEL_430;
  }
  uint64_t v302 = v299[35];
  if (v302)
  {
    BOOL v303 = v299 + 36;
LABEL_430:
    uint64_t v304 = 80;
    if (*(_DWORD *)(v302 + 56) == 3) {
      uint64_t v304 = 196;
    }
    unsigned int v305 = *(_DWORD *)(v302 + v304);
    unsigned int v306 = v305 >> *v303;
    if (v306 <= 1) {
      unsigned int v306 = 1;
    }
    if (v305) {
      unsigned int v301 = v306;
    }
    else {
      unsigned int v301 = 0;
    }
  }
  else
  {
    unsigned int v301 = 0;
  }
LABEL_437:
  id v307 = *(id *)a2;
  uint64_t v308 = (void *)[v307 finalRenderTarget];
  uint64_t v309 = v308[42];
  if (v309)
  {
    LODWORD(v309) = *(_DWORD *)(v309 + 40);
    goto LABEL_450;
  }
  uint64_t v309 = v308[11];
  if (v309)
  {
    unint64_t v310 = v308 + 12;
    goto LABEL_443;
  }
  uint64_t v309 = v308[35];
  if (v309)
  {
    unint64_t v310 = v308 + 36;
LABEL_443:
    uint64_t v311 = 84;
    if (*(_DWORD *)(v309 + 56) == 3) {
      uint64_t v311 = 196;
    }
    unsigned int v312 = *(_DWORD *)(v309 + v311);
    unsigned int v313 = v312 >> *v310;
    if (v313 <= 1) {
      unsigned int v313 = 1;
    }
    if (v312) {
      LODWORD(v309) = v313;
    }
    else {
      LODWORD(v309) = 0;
    }
  }
LABEL_450:
  *unsigned int v297 = (short float)v301;
  v297[1] = (short float)v309;

  if (v295)
  {
    v314.i32[1] = DWORD1(v735);
    if ((void)v735 && *(unsigned char *)(*((void *)&v735 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v735 + 64))();
    }
    unint64_t v315 = *(void *)(*((void *)&v735 + 1) + 64);
    if (v315 <= v295) {
      unint64_t v315 = v295;
    }
    *(void *)(*((void *)&v735 + 1) + 56) = 0;
    *(void *)(*((void *)&v735 + 1) + 64) = v315;
  }
  unint64_t v316 = (void *)v182[42];
  unint64_t v317 = v316[1];
  uint64_t v318 = v316[9];
  v314.i32[0] = *(_DWORD *)((char *)&v778 + 2);
  int32x4_t v319 = (int32x4_t)vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(v314));
  *(void *)&long long v320 = vrev64q_s32(v319).u64[0];
  *((void *)&v320 + 1) = v319.i64[1];
  *(_OWORD *)uint64_t v318 = v320;
  int v321 = BYTE6(v778);
  *(_DWORD *)(v318 + 16) = v778;
  *(_DWORD *)(v318 + 20) = v321;
  if (v316[8] > v317) {
    unint64_t v317 = v316[8];
  }
  v316[7] = 0;
  v316[8] = v317;
  uint64_t v322 = *(void **)(v44 + 1752);
  unint64_t v323 = v322[1];
  uint64_t v324 = (float16x4_t *)v322[9];
  *uint64_t v324 = vcvt_f16_f32(v789);
  v324[1] = vcvt_f16_f32(v790);
  uint64_t v325 = v241;
  float v326 = v241[122];
  float v327 = v241[121];
  float v328 = (float)((float)(1.0309 / v326) - (float)(1.0 / v327)) / (float)((float)(1.0 / v326) - (float)(1.0 / v327));
  float v329 = 1.0 / (float)(1.0 - v328);
  _S1 = v328 / (float)(1.0 - v328);
  _S2 = v329 - _S1;
  _S3 = (int)v784;
  _S4 = 1.0 - *(float *)&v782[1];
  __asm
  {
    FCVT            H3, S3
    FCVT            H2, S2
    FCVT            H1, S1
    FCVT            H4, S4
  }
  v324[2].i16[0] = _S3;
  v324[2].i16[1] = LOWORD(_S2);
  v324[2].i16[2] = LOWORD(_S1);
  v324[2].i16[3] = LOWORD(_S4);
  _KR00_8 = v783;
  __asm
  {
    FCVT            H1, S1
    FCVT            H2, S2
  }
  v324[3].i16[0] = LOWORD(_S1);
  v324[3].i16[1] = LOWORD(_S2);
  if (v322[8] > v323) {
    unint64_t v323 = v322[8];
  }
  v322[7] = 0;
  v322[8] = v323;
  double v335 = v241[4];
  _D2 = v335 * 0.5;
  _D1 = v335 * 1.5;
  uint64_t v338 = *(void **)(v44 + 1848);
  unint64_t v339 = v338[1];
  uint64_t v340 = (_WORD *)v338[9];
  _S3 = v782[0];
  __asm { FCVT            H3, S3 }
  _WORD *v340 = _S3;
  v340[1] = 7193;
  __asm { FCVT            H2, D2 }
  v340[3] = LOWORD(_D2);
  __asm { FCVT            H1, D1 }
  v340[2] = LOWORD(_D1);
  uint64_t v342 = *(void **)(v44 + 1864);
  unint64_t v343 = v342[1];
  uint64_t v344 = (_WORD *)v342[9];
  _WORD *v344 = _S3;
  v344[1] = 6588;
  v344[3] = LOWORD(_D2);
  v344[2] = LOWORD(_D1);
  uint64_t v345 = *(void **)(v44 + 1880);
  unint64_t v346 = v345[1];
  unsigned int v347 = (_WORD *)v345[9];
  _WORD *v347 = _S3;
  v347[1] = 2702;
  v347[3] = LOWORD(_D2);
  v347[2] = LOWORD(_D1);
  unsigned int v348 = *(void **)(v44 + 1896);
  unint64_t v349 = v348[1];
  unsigned int v350 = (_WORD *)v348[9];
  *unsigned int v350 = _S3;
  v350[1] = COERCE_UNSIGNED_INT(1.0);
  v350[3] = LOWORD(_D2);
  v350[2] = LOWORD(_D1);
  if (v348[8] > v349) {
    unint64_t v349 = v348[8];
  }
  v348[7] = 0;
  v348[8] = v349;
  if (v345[8] > v346) {
    unint64_t v346 = v345[8];
  }
  v345[7] = 0;
  v345[8] = v346;
  if (v342[8] > v343) {
    unint64_t v343 = v342[8];
  }
  v342[7] = 0;
  v342[8] = v343;
  if (v338[8] > v339) {
    unint64_t v339 = v338[8];
  }
  v338[7] = 0;
  v338[8] = v339;
  unsigned int v351 = *(void **)(v44 + 1816);
  unint64_t v352 = v351[1];
  v353 = (_WORD *)v351[9];
  _S1 = v780[1];
  _S2 = v780[2];
  __asm
  {
    FCVT            H1, S1
    FCVT            H2, S2
  }
  _WORD *v353 = _S1;
  v353[1] = _S2;
  if (v351[8] > v352) {
    unint64_t v352 = v351[8];
  }
  v351[7] = 0;
  v351[8] = v352;
  uint64_t v356 = *(void *)(v44 + 1832);
  unint64_t v357 = *(void *)(v356 + 8);
  _S0 = 1.0 - *((float *)&v781 + 1);
  __asm { FCVT            H0, S0 }
  **(_WORD **)(v356 + 72) = LOWORD(_S0);
  if (*(void *)(v356 + 64) > v357) {
    unint64_t v357 = *(void *)(v356 + 64);
  }
  *(void *)(v356 + 56) = 0;
  *(void *)(v356 + 64) = v357;
  unint64_t v359 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v360 = (int8x8_t)v359[1];
  if (v360)
  {
    uint8x8_t v361 = (uint8x8_t)vcnt_s8(v360);
    v361.i16[0] = vaddlv_u8(v361);
    if (v361.u32[0] > 1uLL)
    {
      unint64_t v362 = 0xF014CCE28176CA44;
      if (*(void *)&v360 <= 0xF014CCE28176CA44) {
        unint64_t v362 = 0xF014CCE28176CA44 % *(void *)&v360;
      }
    }
    else
    {
      unint64_t v362 = (*(void *)&v360 - 1) & 0xF014CCE28176CA44;
    }
    uint64_t v363 = *v359;
    long long v364 = *(void **)(v363 + 8 * v362);
    if (!v364) {
      goto LABEL_505;
    }
    unint64_t v365 = (void *)*v364;
    if (!v365) {
      goto LABEL_505;
    }
    if (v361.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v367 = v365[1];
        if (v367 == 0xF014CCE28176CA44)
        {
          if (v365[2] == 0xF014CCE28176CA44) {
            goto LABEL_503;
          }
        }
        else if ((v367 & (*(void *)&v360 - 1)) != v362)
        {
          goto LABEL_505;
        }
        unint64_t v365 = (void *)*v365;
        if (!v365) {
          goto LABEL_505;
        }
      }
    }
    while (1)
    {
      unint64_t v366 = v365[1];
      if (v366 == 0xF014CCE28176CA44)
      {
        if (v365[2] == 0xF014CCE28176CA44)
        {
LABEL_503:
          uint64_t v374 = v365[5];
          if (*(void *)(v374 + 8) == 0xF014CCE28176CA44)
          {
            v717 = *(md::MeshRenderableContext **)(v374 + 32);
LABEL_506:
            if (v361.u32[0] > 1uLL)
            {
              unint64_t v375 = 0x8BD499FBD96FBB9ELL;
              if (*(void *)&v360 <= 0x8BD499FBD96FBB9ELL) {
                unint64_t v375 = 0x8BD499FBD96FBB9ELL % *(void *)&v360;
              }
            }
            else
            {
              unint64_t v375 = (*(void *)&v360 - 1) & 0x8BD499FBD96FBB9ELL;
            }
            uint64_t v376 = *(void **)(v363 + 8 * v375);
            if (!v376) {
              goto LABEL_528;
            }
            v377 = (void *)*v376;
            if (!v377) {
              goto LABEL_528;
            }
            if (v361.u32[0] < 2uLL)
            {
              uint64_t v378 = *(void *)&v360 - 1;
              while (1)
              {
                uint64_t v380 = v377[1];
                if (v380 == 0x8BD499FBD96FBB9ELL)
                {
                  if (v377[2] == 0x8BD499FBD96FBB9ELL) {
                    goto LABEL_526;
                  }
                }
                else if ((v380 & v378) != v375)
                {
                  goto LABEL_528;
                }
                v377 = (void *)*v377;
                if (!v377) {
                  goto LABEL_528;
                }
              }
            }
            while (1)
            {
              unint64_t v379 = v377[1];
              if (v379 == 0x8BD499FBD96FBB9ELL)
              {
                if (v377[2] == 0x8BD499FBD96FBB9ELL)
                {
LABEL_526:
                  unint64_t v381 = (int8x8_t *)v377[5];
                  if (*(void *)&v381[1] == 0x8BD499FBD96FBB9ELL)
                  {
                    int8x8_t v360 = v381[4];
                    goto LABEL_529;
                  }
LABEL_528:
                  int8x8_t v360 = 0;
                  goto LABEL_529;
                }
              }
              else
              {
                if (v379 >= *(void *)&v360) {
                  v379 %= *(void *)&v360;
                }
                if (v379 != v375) {
                  goto LABEL_528;
                }
              }
              v377 = (void *)*v377;
              if (!v377) {
                goto LABEL_528;
              }
            }
          }
LABEL_505:
          v717 = 0;
          goto LABEL_506;
        }
      }
      else
      {
        if (v366 >= *(void *)&v360) {
          v366 %= *(void *)&v360;
        }
        if (v366 != v362) {
          goto LABEL_505;
        }
      }
      unint64_t v365 = (void *)*v365;
      if (!v365) {
        goto LABEL_505;
      }
    }
  }
  v717 = 0;
LABEL_529:
  v776 = buf;
  if (*(float *)(*(void *)&v360 + 16) <= 0.01
    && *(unsigned char *)(*(void *)&v360 + 3)
    && (int v382 = *(unsigned __int8 *)(v44 + 3560), v775 = 0, v382 != 3))
  {
    int v727 = 0;
    BOOL v383 = **(unsigned char **)&v360 != 0;
    int v720 = 1;
  }
  else
  {
    int v720 = 0;
    BOOL v383 = 0;
    int v727 = 1;
  }
  BOOL v775 = v383;
  double v706 = 0.0;
  double v707 = 1.0;
  if (v721)
  {
    double v705 = 1.0;
    double v703 = 0.0;
    double v704 = 0.0;
    double v702 = 0.0;
    double v700 = 0.0;
    double v701 = 1.0;
    double v698 = 0.0;
    double v699 = 0.0;
    double v697 = 0.0;
    double v695 = 0.0;
    double v696 = 1.0;
    double v694 = 0.0;
    long long v693 = 0uLL;
  }
  else
  {
    double v705 = 1.0;
    double v703 = 0.0;
    double v704 = 0.0;
    double v702 = 0.0;
    double v700 = 0.0;
    double v701 = 1.0;
    double v698 = 0.0;
    double v699 = 0.0;
    double v697 = 0.0;
    double v695 = 0.0;
    double v696 = 1.0;
    double v694 = 0.0;
    long long v693 = 0uLL;
    if (buf[6])
    {
      uint64_t v384 = *(void *)(*(void *)(*(void *)(v182[1] + 96) + 8 * *(void *)(v182[10] + 32)) + 16);
      v385.i64[0] = *(unsigned int *)(v384 + 80);
      v385.i64[1] = *(unsigned int *)(v384 + 84);
      float64x2_t v386 = vcvtq_f64_u64(v385);
      double v387 = *(double *)(v187 + 264);
      double v388 = *(double *)(v187 + 288);
      double v389 = *(double *)(v187 + 232);
      LODWORD(v384) = *(unsigned __int8 *)(v187 + 240);
      memset(&__p[8], 0, 32);
      double v390 = v389 + -1.0;
      if (!v384) {
        double v390 = 1.0 - v389;
      }
      memset(&__p[48], 0, 32);
      v810.f64[0] = v390 / (v387 - v388);
      v810.f64[1] = 0.0;
      float64x2_t v391 = *(float64x2_t *)(v187 + 248);
      float64x2_t v392 = vsubq_f64(*(float64x2_t *)(v187 + 272), v391);
      float v393 = fmax(v392.f64[0], v392.f64[1]);
      *(double *)&uint64_t v394 = v393;
      float64x2_t v395 = vdivq_f64((float64x2_t)vdupq_lane_s64(v394, 0), v386);
      __asm { FMOV            V16.2D, #0.5 }
      float64x2_t v397 = vmlaq_f64(v391, _Q16, v392);
      float64x2_t v398 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(double *)&v394 * 0.5), 0);
      float64x2_t v399 = vsubq_f64(v397, v398);
      float64x2_t v400 = vaddq_f64(v398, v397);
      float64x2_t v401 = vmulq_f64(vrndmq_f64(vdivq_f64(v399, v395)), v395);
      float64x2_t v402 = vmulq_f64(vrndmq_f64(vdivq_f64(v400, v395)), v395);
      float64x2_t v403 = vsubq_f64(v402, v401);
      *(double *)long long __p = 2.0 / v403.f64[0];
      *(double *)&__p[40] = 2.0 / v403.f64[1];
      float64x2_t v811 = vdivq_f64(vnegq_f64(vaddq_f64(v402, v401)), v403);
      v812.f64[0] = -(v388 - v389 * v387) / (v387 - v388);
      v812.f64[1] = 1.0;
      gm::operator*<double,4,4,4>((double *)&__dst, (double *)__p, (double *)(v187 + 296));
      double v707 = *(double *)&__dst;
      long long v693 = v796;
      double v694 = *(double *)&v797;
      double v695 = *(double *)v798;
      double v696 = *(double *)&v798[1];
      double v697 = v799;
      double v698 = v800;
      double v699 = *(double *)&v801;
      double v700 = v802;
      double v701 = v803;
      double v702 = v804;
      double v703 = v805;
      double v706 = v807;
      double v704 = v806;
      double v705 = v808;
    }
  }
  v773 = 0;
  int v772 = 0;
  uint64_t v774 = 0;
  char v404 = *(const md::DaVinciGroundRenderable ***)v689;
  v715 = *(const md::DaVinciGroundRenderable ***)(v689 + 8);
  *(void *)(v44 + 3624) = ((uint64_t)v715 - *(void *)v689) >> 3;
  uint64_t v405 = (uint64_t **)a2;
  uint64_t v406 = v719;
  int v407 = v720;
  if (v715 != v404)
  {
    uint64_t v408 = (void **)(v44 + 3328);
    v714 = v241;
    uint64_t v709 = v241 + 101;
    __asm { FMOV            V8.2S, #1.0 }
    float v410 = 1.0;
    v730 = (void **)(v44 + 3328);
    while (1)
    {
      uint64_t v771 = 0;
      v722 = v404;
      uint64_t v411 = *v404;
      uint64_t v771 = v411;
      uint64_t v412 = *((void *)v411 + 48);
      long long v413 = (double *)*((void *)v325 + 698);
      if (!v413) {
        long long v413 = v325;
      }
      gm::operator*<double,4,4,4>((double *)__p, v413 + 101, (double *)v411 + 11);
      *(float *)&unsigned int v414 = *(double *)__p;
      *(float *)&unsigned int v415 = *(double *)&__p[8];
      v756.__locale_ = (std::locale::__imp *)__PAIR64__(v415, v414);
      float32_t v416 = *(double *)&__p[16];
      float v417 = *(double *)&__p[24];
      float32_t v757 = v416;
      float v758 = v417;
      float v418 = *(double *)&__p[32];
      float v419 = *(double *)&__p[40];
      float v759 = v418;
      float v760 = v419;
      *(float *)&unsigned int v420 = *(double *)&__p[48];
      float v421 = *(double *)&__p[56];
      unsigned int v761 = v420;
      float v762 = v421;
      float v422 = *(double *)&__p[64];
      float v423 = *(double *)&__p[72];
      float v763 = v422;
      float v764 = v423;
      float32_t v424 = v810.f64[0];
      float v425 = v810.f64[1];
      float32_t v765 = v424;
      float v766 = v425;
      float v426 = v811.f64[0];
      float v427 = v811.f64[1];
      float v767 = v426;
      float v768 = v427;
      float32_t v428 = v812.f64[0];
      float v429 = v812.f64[1];
      float32_t v769 = v428;
      float v770 = v429;
      float v430 = v417 + *(float *)&v414;
      float v431 = v421 + v418;
      float v432 = v425 + v422;
      float v433 = v429 + v426;
      float v434 = v417 - *(float *)&v414;
      float v435 = v421 - v418;
      float v436 = v425 - v422;
      float v437 = v429 - v426;
      float v438 = v417 + *(float *)&v415;
      float v439 = v421 + v419;
      float v440 = v425 + v423;
      float v441 = sqrtf((float)((float)(v438 * v438) + (float)(v439 * v439)) + (float)(v440 * v440));
      float v442 = v417 - *(float *)&v415;
      float v443 = v421 - v419;
      float v444 = v425 - v423;
      float v445 = v421 - *(float *)&v420;
      v446.f32[0] = v416;
      v446.f32[1] = v417 - v416;
      v447.f32[0] = v424;
      v447.f32[1] = v425 - v424;
      float32x2_t v448 = vdiv_f32(_D8, vsqrt_f32(vmla_f32(vmla_f32(vmul_f32(v446, v446), (float32x2_t)__PAIR64__(LODWORD(v445), v420), (float32x2_t)__PAIR64__(LODWORD(v445), v420)), v447, v447)));
      *(float *)&__dst = v416 * v448.f32[0];
      *((float *)&__dst + 1) = *(float *)&v420 * v448.f32[0];
      v446.f32[0] = v428;
      *(float32x2_t *)((char *)&v796 + 4) = vmul_f32(v448, v446);
      *(float *)&long long v796 = v424 * v448.f32[0];
      HIDWORD(v796) = vmuls_lane_f32(v445, v448, 1);
      *(double *)&unint64_t v797 = COERCE_DOUBLE(__PAIR64__(COERCE_UNSIGNED_INT(vmuls_lane_f32(v429 - v428, v448, 1)), COERCE_UNSIGNED_INT(vmuls_lane_f32(v425 - v424, v448, 1))));
      *(float *)v798 = (float)(v410 / v441) * v438;
      *((float *)v798 + 1) = (float)(v410 / v441) * v439;
      *(float *)&v798[1] = (float)(v410 / v441) * v440;
      *((float *)&v798[1] + 1) = (float)(v429 + v427) * (float)(v410 / v441);
      v446.f32[0] = v410 / sqrtf((float)((float)(v442 * v442) + (float)(v443 * v443)) + (float)(v444 * v444));
      *(float *)&double v799 = v446.f32[0] * v442;
      *((float *)&v799 + 1) = v446.f32[0] * v443;
      *(float *)&double v800 = v446.f32[0] * v444;
      *((float *)&v800 + 1) = (float)(v429 - v427) * v446.f32[0];
      v446.f32[0] = v410 / sqrtf((float)((float)(v430 * v430) + (float)(v431 * v431)) + (float)(v432 * v432));
      *(float *)&int v801 = v446.f32[0] * v430;
      *((float *)&v801 + 1) = v446.f32[0] * v431;
      *(float *)&double v802 = v446.f32[0] * v432;
      *((float *)&v802 + 1) = v433 * v446.f32[0];
      v446.f32[0] = v410 / sqrtf((float)((float)(v434 * v434) + (float)(v435 * v435)) + (float)(v436 * v436));
      *(float *)&double v803 = v446.f32[0] * v434;
      *((float *)&v803 + 1) = v446.f32[0] * v435;
      *(float *)&double v804 = v446.f32[0] * v436;
      *((float *)&v804 + 1) = v437 * v446.f32[0];
      geo::Frustum<float>::calculateCorners((float *)&__dst, (float *)&v756);
      unint64_t v449 = md::MeshRenderableContext::renderablesForRegistry((int8x8_t *)v717, *(const gdc::Registry **)(v412 + 1320));
      unint64_t v451 = (v449[1] - *v449) >> 3;
      unint64_t v452 = v773;
      long long v453 = (int8x16_t *)v772;
      unint64_t v454 = ((char *)v773 - (unsigned char *)v772) >> 3;
      if (v451 <= v454)
      {
        if (v451 < v454)
        {
          unint64_t v452 = (int8x16_t *)((char *)v772 + 8 * v451);
          v773 = v452;
        }
      }
      else
      {
        std::vector<unsigned long>::__append((uint64_t)&v772, v451 - v454);
        long long v453 = (int8x16_t *)v772;
        unint64_t v452 = v773;
      }
      if (v453 == v452)
      {
        long long v453 = v452;
        goto LABEL_565;
      }
      unint64_t v455 = (char *)v452 - (char *)v453 - 8;
      if (v455 <= 0x17) {
        break;
      }
      uint64_t v458 = (v455 >> 3) + 1;
      uint64_t v456 = v458 & 0x3FFFFFFFFFFFFFFCLL;
      int64x2_t v450 = (int64x2_t)xmmword_1A28FC760;
      char v459 = (int64x2_t *)&v453[1];
      uint64_t v460 = v458 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v459[-1] = v450;
        *char v459 = vaddq_s64(v450, vdupq_n_s64(2uLL));
        int64x2_t v450 = vaddq_s64(v450, vdupq_n_s64(4uLL));
        v459 += 2;
        v460 -= 4;
      }
      while (v460);
      if (v458 != v456)
      {
        long double v457 = (int8x16_t *)((char *)v453 + 8 * (v458 & 0x3FFFFFFFFFFFFFFCLL));
        do
        {
LABEL_555:
          v457->i64[0] = v456;
          long double v457 = (int8x16_t *)((char *)v457 + 8);
          ++v456;
        }
        while (v457 != v452);
      }
      *(void *)long long __p = v449;
      *(void *)&__p[8] = &v776;
      uint64_t v461 = *v449;
      unsigned int v462 = v453;
      while (1)
      {
        uint64_t v463 = *(void *)(v461 + 8 * v462->i64[0]);
        int v464 = *(unsigned __int8 *)(*(void *)(v463 + 216) + 32);
        if ((v464 - 4) < 0xFFFFFFFD || !v776[3] && (v464 - 1) < 2) {
          break;
        }
        if (!*(unsigned char *)(v463 + 144)) {
          break;
        }
        unsigned int v462 = (int8x16_t *)((char *)v462 + 8);
        if (v462 == v452) {
          goto LABEL_565;
        }
      }
      long double v465 = &v452[-1].u64[1];
      if (v462 == (int8x16_t *)v465)
      {
LABEL_564:
        unint64_t v452 = v462;
      }
      else
      {
        while (1)
        {
          uint64_t v490 = *(void *)(v461 + 8 * *v465);
          int v491 = *(unsigned __int8 *)(*(void *)(v490 + 216) + 32);
          if ((v491 - 4) >= 0xFFFFFFFD && (v776[3] || (v491 - 1) >= 2))
          {
            if (*(unsigned char *)(v490 + 144)) {
              break;
            }
          }
          if (--v465 == (unint64_t *)v462) {
            goto LABEL_564;
          }
        }
        if ((char *)v465 - (char *)v462 < 17)
        {
LABEL_631:
          unint64_t v505 = 0;
          unint64_t v503 = 0;
        }
        else
        {
          if ((((char *)v465 - (char *)v462) >> 3) + 1 >= 0xFFFFFFFFFFFFFFFLL) {
            unint64_t v503 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v503 = (((char *)v465 - (char *)v462) >> 3) + 1;
          }
          while (1)
          {
            unint64_t v504 = operator new(8 * v503, MEMORY[0x1E4FBA2D0]);
            if (v504) {
              break;
            }
            BOOL v619 = v503 > 1;
            v503 >>= 1;
            if (!v619) {
              goto LABEL_631;
            }
          }
          unint64_t v505 = v504;
        }
        unint64_t v452 = (int8x16_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_2 &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(v462, v465, (uint64_t **)__p, (((char *)v465 - (char *)v462) >> 3) + 1, (unint64_t)v505, v503);
        if (v505)
        {
          operator delete(v505);
          long long v453 = (int8x16_t *)v772;
        }
        uint64_t v405 = (uint64_t **)a2;
      }
LABEL_565:
      float64x2_t v466 = *(void **)(v44 + 3328);
      *(void *)(v44 + 3336) = v466;
      uint64_t v467 = v44;
      if (v452 >= v453) {
        unint64_t v468 = ((char *)v452 - (char *)v453) >> 3;
      }
      else {
        unint64_t v468 = 0;
      }
      if (v468 > (uint64_t)(*(void *)(v467 + 3344) - (void)v466) >> 3)
      {
        if (v468 >> 61) {
          abort();
        }
        v469 = (char *)operator new(8 * v468);
        *((void *)v728 + 416) = v469;
        *((void *)v728 + 417) = v469;
        *((void *)v728 + 418) = &v469[8 * v468];
        if (v466) {
          operator delete(v466);
        }
      }
      uint64_t v732 = v412;
      unint64_t v470 = v453;
      v736 = v453;
      uint64_t v44 = (uint64_t)v728;
      if (v453 == v452)
      {
        v752 = (void **)&__dst;
        v753 = v449;
        unint64_t v471 = v453;
        unint64_t v452 = v453;
        v754 = &v771;
        unint64_t v755 = &v792;
        int v407 = v720;
      }
      else
      {
        do
        {
          uint64_t v473 = *(void *)(*v449 + 8 * v470->i64[0]);
          if (*(unsigned char *)(v473 + 72) && *(unsigned char *)(v473 + 146))
          {
            unint64_t v474 = *(void **)(v44 + 3336);
            unint64_t v475 = *(void *)(v44 + 3344);
            if ((unint64_t)v474 < v475)
            {
              *unint64_t v474 = v473;
              v472 = v474 + 1;
            }
            else
            {
              unint64_t v476 = *v408;
              uint64_t v477 = (char *)v474 - (unsigned char *)*v408;
              uint64_t v478 = v477 >> 3;
              unint64_t v479 = (v477 >> 3) + 1;
              if (v479 >> 61) {
                abort();
              }
              uint64_t v480 = v475 - (void)v476;
              if (v480 >> 2 > v479) {
                unint64_t v479 = v480 >> 2;
              }
              if ((unint64_t)v480 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v481 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v481 = v479;
              }
              if (v481)
              {
                if (v481 >> 61) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                char v482 = operator new(8 * v481);
              }
              else
              {
                char v482 = 0;
              }
              v483 = &v482[8 * v478];
              void *v483 = v473;
              v472 = v483 + 1;
              if (v474 == (void *)v476)
              {
                unint64_t v476 = v474;
              }
              else
              {
                unint64_t v484 = (char *)(v474 - 1) - v476;
                if (v484 < 0x58) {
                  goto LABEL_853;
                }
                if ((unint64_t)((char *)v474 - &v482[v477]) < 0x20) {
                  goto LABEL_853;
                }
                uint64_t v485 = (v484 >> 3) + 1;
                v486 = (int64x2_t *)&v482[8 * v478 - 16];
                unsigned int v487 = (int64x2_t *)(v474 - 2);
                uint64_t v488 = v485 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  int64x2_t v450 = *v487;
                  v486[-1] = v487[-1];
                  int64x2_t *v486 = v450;
                  v486 -= 2;
                  v487 -= 2;
                  v488 -= 4;
                }
                while (v488);
                v483 -= v485 & 0x3FFFFFFFFFFFFFFCLL;
                v474 -= v485 & 0x3FFFFFFFFFFFFFFCLL;
                if (v485 != (v485 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_853:
                  do
                  {
                    uint64_t v489 = *--v474;
                    *--v483 = v489;
                  }
                  while (v474 != (void *)v476);
                  unint64_t v476 = *v730;
                }
              }
              uint64_t v44 = (uint64_t)v728;
              *((void *)v728 + 416) = v483;
              *((void *)v728 + 417) = v472;
              *((void *)v728 + 418) = &v482[8 * v481];
              if (v476) {
                operator delete(v476);
              }
              uint64_t v405 = (uint64_t **)a2;
            }
            *(void *)(v44 + 3336) = v472;
            uint64_t v408 = v730;
          }
          unint64_t v470 = (int8x16_t *)((char *)v470 + 8);
        }
        while (v470 != v452);
        v752 = (void **)&__dst;
        v753 = v449;
        v492 = v736;
        v754 = &v771;
        unint64_t v755 = &v792;
        int v407 = v720;
        while (1)
        {
          uint64_t v493 = (float *)v752;
          md::DaVinciGroundRenderLayer::adjustedMeshBounds((float32x4_t *)__p, *(md::MeshRenderable **)(*v753 + 8 * v492->i64[0]), *v754, *v755, (int32x4_t)v450);
          if (!geo::Intersect::encloses<float>(v493, (float *)__p)) {
            break;
          }
          v492 = (int8x16_t *)((char *)v492 + 8);
          if (v492 == v452) {
            goto LABEL_636;
          }
        }
        v494 = (int8x16_t *)((char *)v452 - 8);
        do
        {
          uint64_t v495 = (char *)v494 - (char *)v492;
          if (v494 == v492)
          {
            unint64_t v452 = v492;
            uint64_t v44 = (uint64_t)v728;
            goto LABEL_636;
          }
          v496 = (unint64_t *)v494;
          unint64_t v497 = (float *)v752;
          md::DaVinciGroundRenderLayer::adjustedMeshBounds((float32x4_t *)__p, *(md::MeshRenderable **)(*v753 + 8 * v494->i64[0]), *v754, *v755, (int32x4_t)v450);
          int v498 = geo::Intersect::encloses<float>(v497, (float *)__p);
          v494 = (int8x16_t *)(v496 - 1);
        }
        while (!v498);
        uint64_t v499 = (v495 >> 3) + 1;
        if (v495 < 17)
        {
          unint64_t v502 = 0;
          unint64_t v500 = 0;
          uint64_t v44 = (uint64_t)v728;
        }
        else
        {
          if (v499 >= 0xFFFFFFFFFFFFFFFLL) {
            unint64_t v500 = 0xFFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v500 = (v495 >> 3) + 1;
          }
          uint64_t v44 = (uint64_t)v728;
          while (1)
          {
            unint64_t v501 = (char *)operator new(8 * v500, MEMORY[0x1E4FBA2D0]);
            if (v501) {
              break;
            }
            BOOL v619 = v500 > 1;
            v500 >>= 1;
            if (!v619)
            {
              unint64_t v502 = 0;
              unint64_t v500 = 0;
              goto LABEL_633;
            }
          }
          unint64_t v502 = v501;
        }
LABEL_633:
        unint64_t v452 = (int8x16_t *)std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_3 &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(v492, v496, (uint64_t)&v752, v499, v502, v500, (int32x4_t)v450);
        if (v502) {
          operator delete(v502);
        }
        uint64_t v405 = (uint64_t **)a2;
LABEL_636:
        unint64_t v471 = v736;
      }
      int v750 = v471;
      uint64_t v751 = v452;
      if (buf[6]) {
        BOOL v506 = v721 == 0;
      }
      else {
        BOOL v506 = 0;
      }
      if (v506)
      {
        double v507 = *((double *)v771 + 11);
        double v508 = *((double *)v771 + 12);
        double v509 = *((double *)v771 + 13);
        double v510 = *((double *)v771 + 14);
        double v737 = v507 * v707 + v508 * v695 + v509 * v699 + v510 * v703;
        double v511 = *((double *)v771 + 15);
        double v512 = *((double *)v771 + 16);
        double v513 = *((double *)v771 + 17);
        double v514 = *((double *)v771 + 18);
        double v515 = *((double *)v771 + 19);
        double v516 = *((double *)v771 + 20);
        double v517 = *((double *)v771 + 21);
        double v518 = *((double *)v771 + 22);
        double v712 = v515 * v707 + v516 * v695 + v517 * v699 + v518 * v703;
        double v713 = v511 * v707 + v512 * v695 + v513 * v699 + v514 * v703;
        double v519 = v507 * *(double *)&v693 + v508 * v696;
        double v520 = v507 * *((double *)&v693 + 1) + v508 * v697;
        double v521 = v507 * v694 + v508 * v698;
        double v522 = *((double *)v771 + 23);
        double v523 = *((double *)v771 + 24);
        double v524 = v519 + v509 * v700 + v510 * v704;
        double v525 = v520 + v509 * v701;
        double v526 = v521 + v509 * v702;
        double v527 = v511 * *(double *)&v693 + v512 * v696;
        double v528 = v525 + v510 * v706;
        double v529 = v526 + v510 * v705;
        double v530 = v511 * *((double *)&v693 + 1) + v512 * v697;
        double v531 = v511 * v694 + v512 * v698;
        double v532 = v522 * v707 + v523 * v695;
        double v533 = v527 + v513 * v700 + v514 * v704;
        double v534 = v530 + v513 * v701;
        double v535 = v531 + v513 * v702;
        double v536 = v515 * *(double *)&v693 + v516 * v696 + v517 * v700 + v518 * v704;
        double v537 = v534 + v514 * v706;
        double v538 = v535 + v514 * v705;
        double v539 = v515 * *((double *)&v693 + 1) + v516 * v697;
        double v540 = v515 * v694 + v516 * v698;
        double v541 = v522 * *(double *)&v693 + v523 * v696;
        double v542 = v539 + v517 * v701 + v518 * v706;
        double v543 = v540 + v517 * v702;
        double v544 = v522 * *((double *)&v693 + 1) + v523 * v697;
        double v545 = v543 + v518 * v705;
        double v546 = v522 * v694 + v523 * v698;
        double v547 = *((double *)v771 + 25);
        double v548 = *((double *)v771 + 26);
        float v410 = 1.0;
        double v549 = v532 + v547 * v699 + v548 * v703;
        double v550 = v541 + v547 * v700 + v548 * v704;
        double v551 = v544 + v547 * v701 + v548 * v706;
        double v552 = v546 + v547 * v702 + v548 * v705;
        float v553 = v737;
        *(float *)&double v547 = v524;
        v554 = (void *)*((void *)v771 + 50);
        unint64_t v555 = v554[1];
        uint64_t v556 = v554[9];
        *(float *)uint64_t v556 = v553;
        *(_DWORD *)(v556 + 4) = LODWORD(v547);
        float v557 = v528;
        *(float *)&double v529 = v529;
        *(float *)(v556 + 8) = v557;
        *(_DWORD *)(v556 + 12) = LODWORD(v529);
        float v558 = v713;
        float v559 = v533;
        *(float *)(v556 + 16) = v558;
        *(float *)(v556 + 20) = v559;
        float v560 = v537;
        float v561 = v538;
        *(float *)(v556 + 24) = v560;
        *(float *)(v556 + 28) = v561;
        float v562 = v712;
        float v563 = v536;
        *(float *)(v556 + 32) = v562;
        *(float *)(v556 + 36) = v563;
        float v564 = v542;
        float v565 = v545;
        *(float *)(v556 + 40) = v564;
        *(float *)(v556 + 44) = v565;
        float v566 = v549;
        float v567 = v550;
        *(float *)(v556 + 48) = v566;
        *(float *)(v556 + 52) = v567;
        float v568 = v551;
        float v569 = v552;
        *(float *)(v556 + 56) = v568;
        *(float *)(v556 + 60) = v569;
        if (v554[8] > v555) {
          unint64_t v555 = v554[8];
        }
        v554[7] = 0;
        v554[8] = v555;
      }
      if (v779)
      {
        v570 = v771;
        gm::operator*<double,4,4,4>((double *)__p, v709, (double *)v771 + 11);
        float32x4_t v571 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&__p[32]), *(float64x2_t *)&__p[48]);
        float32x4_t v572 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&__p[64]), v810);
        float32x4_t v573 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v811), v812);
        uint64_t v574 = (void *)*((void *)v570 + 52);
        unint64_t v575 = v574[1];
        uint64_t v576 = (float32x4_t *)v574[9];
        *uint64_t v576 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)__p), *(float64x2_t *)&__p[16]);
        v576[1] = v571;
        v576[2] = v572;
        v576[3] = v573;
        if (v574[8] > v575) {
          unint64_t v575 = v574[8];
        }
        v574[7] = 0;
        v574[8] = v575;
      }
      v749[0] = &v750;
      v749[1] = v449;
      v749[2] = &v775;
      __int16 v748 = 257;
      v578 = (uint64_t *)md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator()((uint64_t)v749, (unsigned __int8 *)&v748);
      uint64_t v406 = v719;
      if ((_BYTE)v748) {
        LOBYTE(v748) = 0;
      }
      memset(__p, 0, 32);
      memset(&__p[40], 0, 32);
      *(_DWORD *)&__p[32] = 1065353216;
      *(_DWORD *)&__p[72] = 1065353216;
      float64x2_t v810 = 0u;
      float64x2_t v811 = 0u;
      memset(&v812.f64[1], 0, 32);
      LODWORD(v812.f64[0]) = 1065353216;
      int v813 = 1065353216;
      long long v814 = 0u;
      long long v815 = 0u;
      long long v817 = 0u;
      long long v818 = 0u;
      int v816 = 1065353216;
      int v819 = 1065353216;
      md::DaVinciGroundRenderLayer::layoutMainPass((uint64_t *)v44, (md::LayoutContext *)v405, (uint64_t)buf, (uint64_t)__p, (uint64_t)v771, v578, v577, v449, v718, v407);
      __int16 v747 = 513;
      v580 = (uint64_t *)md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator()((uint64_t)v749, (unsigned __int8 *)&v747);
      if ((_BYTE)v747) {
        LOBYTE(v747) = 0;
      }
      md::DaVinciGroundRenderLayer::layoutMainPass((uint64_t *)v44, (md::LayoutContext *)v405, (uint64_t)buf, (uint64_t)__p, (uint64_t)v771, v580, v579, v449, v725, v407);
      __int16 v746 = 769;
      int v582 = (uint64_t *)md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator()((uint64_t)v749, (unsigned __int8 *)&v746);
      if ((_BYTE)v746) {
        LOBYTE(v746) = 0;
      }
      md::DaVinciGroundRenderLayer::layoutMainPass((uint64_t *)v44, (md::LayoutContext *)v405, (uint64_t)buf, (uint64_t)__p, (uint64_t)v771, v582, v581, v449, v725, v407);
      __int16 v745 = 1;
      int v584 = (uint64_t *)md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator()((uint64_t)v749, (unsigned __int8 *)&v745);
      if ((_BYTE)v745) {
        LOBYTE(v745) = 0;
      }
      md::DaVinciGroundRenderLayer::layoutMainPass((uint64_t *)v44, (md::LayoutContext *)v405, (uint64_t)buf, (uint64_t)__p, (uint64_t)v771, v584, v583, v449, v723, v407);
      if (!v716)
      {
        __int16 v744 = 1025;
        uint64_t v588 = (uint64_t *)md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator()((uint64_t)v749, (unsigned __int8 *)&v744);
        if ((_BYTE)v744) {
          LOBYTE(v744) = 0;
        }
        md::DaVinciGroundRenderLayer::layoutMainPass((uint64_t *)v44, (md::LayoutContext *)v405, (uint64_t)buf, (uint64_t)__p, (uint64_t)v771, v588, v587, v449, v708, v407);
      }
      if (v775 && v719)
      {
        v743[0] = 0;
        md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator()((uint64_t)v749, v743);
        uint64_t v590 = v589;
        if (v743[0]) {
          v743[0] = 0;
        }
        v591 = v751;
        __int16 v742 = 769;
        v592 = md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_5::operator()(v589, v751, v449, (uint64_t)&v742);
        if ((_BYTE)v742) {
          LOBYTE(v742) = 0;
        }
        md::DaVinciGroundRenderLayer::layoutMainPass((uint64_t *)v44, (md::LayoutContext *)v405, (uint64_t)buf, (uint64_t)__p, (uint64_t)v771, v590->i64, v592->i64, v449, v692, v407);
        __int16 v741 = 1;
        uint64_t v593 = md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_5::operator()(v590, v591, v449, (uint64_t)&v741);
        if ((_BYTE)v741) {
          LOBYTE(v741) = 0;
        }
        md::DaVinciGroundRenderLayer::layoutMainPass((uint64_t *)v44, (md::LayoutContext *)v405, (uint64_t)buf, (uint64_t)__p, (uint64_t)v771, v590->i64, v593->i64, v449, v719, v407);
      }
      v594 = (uint64_t *)v772;
      v773 = (int8x16_t *)v772;
      uint64_t v595 = *(void *)(v44 + 3336) - *(void *)(v44 + 3328);
      if (!v595
        || (std::vector<unsigned long>::__append((uint64_t)&v772, v595 >> 3),
            v594 = (uint64_t *)v772,
            v596 = (uint64_t *)v773,
            v772 == v773))
      {
        v596 = v594;
        goto LABEL_700;
      }
      unint64_t v597 = (char *)v773 - (unsigned char *)v772 - 8;
      if (v597 < 0x18)
      {
        uint64_t v598 = 0;
        v599 = (uint64_t *)v772;
        goto LABEL_679;
      }
      uint64_t v600 = (v597 >> 3) + 1;
      uint64_t v598 = v600 & 0x3FFFFFFFFFFFFFFCLL;
      int64x2_t v585 = (int64x2_t)xmmword_1A28FC760;
      uint64_t v601 = (int64x2_t *)((char *)v772 + 16);
      uint64_t v602 = v600 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v601[-1] = v585;
        *uint64_t v601 = vaddq_s64(v585, vdupq_n_s64(2uLL));
        int64x2_t v585 = vaddq_s64(v585, vdupq_n_s64(4uLL));
        v601 += 2;
        v602 -= 4;
      }
      while (v602);
      if (v600 != v598)
      {
        v599 = &v594[v600 & 0x3FFFFFFFFFFFFFFCLL];
        do
LABEL_679:
          *v599++ = v598++;
        while (v599 != v596);
      }
      BOOL v603 = v594;
      while (1)
      {
        if (v727)
        {
          while (1)
          {
            long double v604 = (md::MeshRenderable *)*((void *)*v408 + *v603);
            if (!*((unsigned char *)v604 + 72)) {
              break;
            }
            md::DaVinciGroundRenderLayer::adjustedMeshBounds((float32x4_t *)&v793, v604, v771, v792, (int32x4_t)v585);
            if (!geo::Intersect::encloses<float>((float *)&__dst, (float *)v793.i32)) {
              break;
            }
            if (++v603 == v596) {
              goto LABEL_700;
            }
          }
        }
        else
        {
          while (1)
          {
            long double v605 = (md::MeshRenderable *)*((void *)*v408 + *v603);
            if (!*((unsigned char *)v605 + 72)) {
              break;
            }
            if (!*((unsigned char *)v605 + 147)) {
              break;
            }
            md::DaVinciGroundRenderLayer::adjustedMeshBounds((float32x4_t *)&v793, v605, v771, v792, (int32x4_t)v585);
            if (!geo::Intersect::encloses<float>((float *)&__dst, (float *)v793.i32)) {
              break;
            }
            if (++v603 == v596) {
              goto LABEL_700;
            }
          }
        }
        if (v603 == --v596) {
          break;
        }
        while (1)
        {
          long double v606 = (md::MeshRenderable *)*((void *)*v408 + *v596);
          if (*((unsigned char *)v606 + 72))
          {
            if (((*((unsigned char *)v606 + 147) == 0) & ~v727) == 0)
            {
              md::DaVinciGroundRenderLayer::adjustedMeshBounds((float32x4_t *)&v793, v606, v771, v792, (int32x4_t)v585);
              if (geo::Intersect::encloses<float>((float *)&__dst, (float *)v793.i32)) {
                break;
              }
            }
          }
          if (--v596 == v603) {
            goto LABEL_699;
          }
        }
        uint64_t v607 = *v603;
        *v603++ = *v596;
        uint64_t *v596 = v607;
        if (v603 == v596) {
          goto LABEL_700;
        }
      }
LABEL_699:
      v596 = v603;
LABEL_700:
      char v608 = *(unsigned char *)(v44 + 3560);
      int8x16_t v793 = 0uLL;
      unint64_t v794 = 0;
      if ((v608 & 0xFE) == 2)
      {
        if (v594 == v596)
        {
          v596 = v594;
          if (!buf[6]) {
            goto LABEL_723;
          }
          goto LABEL_719;
        }
        int8x16_t v609 = 0uLL;
        *(void *)&long long v586 = 0;
        long double v610 = v594;
        do
        {
          long long v733 = v586;
          int8x16_t v738 = v609;
          md::DaVinciGroundRenderLayer::adjustedMeshBounds((float32x4_t *)&v739, *((md::MeshRenderable **)*v408 + *v610), v771, v792, (int32x4_t)v585);
          v585.i64[1] = v739.i64[1];
          float32x4_t v611 = (float32x4_t)v739;
          v611.i32[3] = v738.i32[3];
          float32x4_t v612 = (float32x4_t)v738;
          v612.i32[3] = v739.i32[3];
          int8x16_t v609 = vbslq_s8((int8x16_t)vcgtq_f32(v612, v611), v739, v738);
          *(float32x2_t *)v585.i8 = v740;
          *((void *)&v586 + 1) = *((void *)&v733 + 1);
          *(float32x2_t *)&long long v586 = vmaxnm_f32(*(float32x2_t *)&v733, v740);
          ++v610;
        }
        while (v610 != v596);
        int8x16_t v793 = v609;
        unint64_t v794 = v586;
        float v613 = *((float *)&v586 + 1);
        float v614 = *(float *)&v609.i32[3];
        float v615 = *(float *)&v609.i32[2];
        float v616 = *(float *)&v609.i32[1];
        if (!buf[6]) {
          goto LABEL_723;
        }
      }
      else
      {
        if (*((unsigned __int8 *)v771 + 24) == 255)
        {
          uint64_t v618 = (*(uint64_t (**)(uint64_t))(*(void *)v732 + 32))(v732);
          md::GeometryLogic::adjustedMeshBounds((uint64_t)&v739, v618, *((void *)v771 + 29));
          float v616 = *(float *)&v739.i32[1];
          v609.i32[0] = v739.i32[0];
          int8x16_t v793 = v739;
          float v614 = *(float *)&v739.i32[3];
          float v615 = *(float *)&v739.i32[2];
          float v613 = v740.f32[1];
          LODWORD(v586) = v740.i32[0];
        }
        else
        {
          uint64_t v617 = (*(uint64_t (**)(uint64_t))(*(void *)v732 + 32))(v732);
          v609.i32[0] = *(_DWORD *)v617;
          float v616 = *(float *)(v617 + 4);
          v793.i32[0] = *(_DWORD *)v617;
          *(float *)&v793.i32[1] = v616;
          float v615 = *(float *)(v617 + 8);
          float v614 = *(float *)(v617 + 12);
          v793.i64[1] = __PAIR64__(LODWORD(v614), LODWORD(v615));
          LODWORD(v586) = *(_DWORD *)(v617 + 16);
          float v613 = *(float *)(v617 + 20);
        }
        unint64_t v794 = __PAIR64__(LODWORD(v613), v586);
        if (!buf[6]) {
          goto LABEL_723;
        }
      }
      BOOL v619 = v614 < *(float *)v609.i32 || *(float *)&v586 < v616;
      if (v619 || v613 < v615)
      {
LABEL_720:
        if (*(unsigned char *)(v44 + 3560) != 3 && !v721) {
          md::DaVinciGroundRenderLayer::layoutShadowMap(v44, v405[1], (uint64_t)buf, (uint64_t)v771, 0, v594, v596, v408, v690, 0, v691);
        }
        goto LABEL_723;
      }
LABEL_719:
      if (geo::Intersect::encloses<float>((float *)&__dst, (float *)v793.i32)) {
        goto LABEL_720;
      }
LABEL_723:
      if (v779
        && (*(float *)&v793.i32[3] < *(float *)v793.i32
         || *(float *)&v794 < *(float *)&v793.i32[1]
         || *((float *)&v794 + 1) < *(float *)&v793.i32[2]
         || geo::Intersect::encloses<float>((float *)&__dst, (float *)v793.i32)))
      {
        md::DaVinciGroundRenderLayer::layoutShadowMap(v44, v405[1], (uint64_t)buf, (uint64_t)v771, 1, v594, v596, v408, v710, 1u, v711);
      }
      md::DaVinciGroundRenderLayer::layoutRibbons(v44, (uint64_t)v405, (uint64_t)buf, (uint64_t)v771, v723, v407);
      md::DaVinciGroundRenderLayer::MaterialConstants::~MaterialConstants((md::DaVinciGroundRenderLayer::MaterialConstants *)__p);
      char v404 = v722 + 1;
      uint64_t v325 = v714;
      if (v722 + 1 == v715) {
        goto LABEL_735;
      }
    }
    uint64_t v456 = 0;
    long double v457 = v453;
    goto LABEL_555;
  }
LABEL_735:
  v621 = v405[1];
  int8x8_t v622 = (int8x8_t)v621[1];
  if (!*(void *)&v622) {
    goto LABEL_789;
  }
  uint8x8_t v623 = (uint8x8_t)vcnt_s8(v622);
  v623.i16[0] = vaddlv_u8(v623);
  if (v623.u32[0] > 1uLL)
  {
    unint64_t v624 = 0xC97B9E962ADF4AD4;
    if (*(void *)&v622 <= 0xC97B9E962ADF4AD4) {
      unint64_t v624 = 0xC97B9E962ADF4AD4 % *(void *)&v622;
    }
  }
  else
  {
    unint64_t v624 = (*(void *)&v622 - 1) & 0xC97B9E962ADF4AD4;
  }
  uint64_t v625 = *(void **)(*v621 + 8 * v624);
  if (!v625) {
    goto LABEL_789;
  }
  uint64_t v626 = (void *)*v625;
  if (!v626) {
    goto LABEL_789;
  }
  if (v623.u32[0] < 2uLL)
  {
    uint64_t v627 = *(void *)&v622 - 1;
    while (1)
    {
      uint64_t v629 = v626[1];
      if (v629 == 0xC97B9E962ADF4AD4)
      {
        if (v626[2] == 0xC97B9E962ADF4AD4) {
          goto LABEL_757;
        }
      }
      else if ((v629 & v627) != v624)
      {
        goto LABEL_789;
      }
      uint64_t v626 = (void *)*v626;
      if (!v626) {
        goto LABEL_789;
      }
    }
  }
  while (1)
  {
    unint64_t v628 = v626[1];
    if (v628 == 0xC97B9E962ADF4AD4) {
      break;
    }
    if (v628 >= *(void *)&v622) {
      v628 %= *(void *)&v622;
    }
    if (v628 != v624) {
      goto LABEL_789;
    }
LABEL_745:
    uint64_t v626 = (void *)*v626;
    if (!v626) {
      goto LABEL_789;
    }
  }
  if (v626[2] != 0xC97B9E962ADF4AD4) {
    goto LABEL_745;
  }
LABEL_757:
  uint64_t v630 = v626[5];
  if (*(void *)(v630 + 8) == 0xC97B9E962ADF4AD4)
  {
    v631 = *(uint64_t **)(v630 + 32);
    if (v631)
    {
      uint64_t v632 = *v631;
      uint64_t v633 = v631[1];
      if (v632 != v633)
      {
        while (*(unsigned char *)v632 != 11)
        {
          v632 += 16;
          if (v632 == v633) {
            goto LABEL_789;
          }
        }
      }
      if (v632 != v633 && *(void *)(v632 + 8) && *(unsigned char *)(v44 + 3560) == 1)
      {
        md::ElevatedPolygonRenderResources::resetPools(*(void (****)(uint64_t))(v44 + 3424));
        uint64_t v646 = *(void *)(v44 + 3424);
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*(void **)(v646 + 792));
        *(void *)(v646 + 784) = v646 + 792;
        *(void *)(v646 + 800) = 0;
        *(void *)(v646 + 792) = 0;
        md::ElevatedPolygonContext::ElevatedPolygonContext((md::ElevatedPolygonContext *)__p, (const md::LayoutContext *)v405, *(unsigned char *)(v44 + 3192), *(const md::StandardPassList **)(*(void *)(v44 + 40) + 24), v647);
        uint64_t v648 = *(const md::DaVinciGroundRenderable ***)v689;
        uint64_t v649 = *(const md::DaVinciGroundRenderable ***)(v689 + 8);
        if (*(const md::DaVinciGroundRenderable ***)v689 != v649)
        {
          do
            md::DaVinciGroundRenderLayer::layoutPredrapedPolygons((uint64_t **)v728, (const md::LayoutContext *)v405, *v648++, (const md::ElevatedPolygonContext *)__p, v688);
          while (v648 != v649);
        }
        uint64_t v44 = (uint64_t)v728;
      }
    }
  }
LABEL_789:
  if (v406) {
    int v650 = v407;
  }
  else {
    int v650 = 0;
  }
  if (v650 == 1)
  {
    unint64_t v651 = *(void *)(v406 + 72);
    v652 = *(uint64_t **)(v406 + 80);
    unint64_t v653 = 126 - 2 * __clz((uint64_t)((uint64_t)v652 - v651) >> 3);
    if (v652 == (uint64_t *)v651) {
      uint64_t v654 = 0;
    }
    else {
      uint64_t v654 = v653;
    }
    std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v651, v652, v654, 1);
    unint64_t v655 = *(void *)(v692 + 72);
    v656 = *(uint64_t **)(v692 + 80);
    unint64_t v657 = 126 - 2 * __clz((uint64_t)((uint64_t)v656 - v655) >> 3);
    if (v656 == (uint64_t *)v655) {
      uint64_t v658 = 0;
    }
    else {
      uint64_t v658 = v657;
    }
    std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v655, v656, v658, 1);
  }
  unint64_t v659 = *(void *)(v723 + 72);
  double v660 = *(uint64_t **)(v723 + 80);
  unint64_t v661 = 126 - 2 * __clz((uint64_t)((uint64_t)v660 - v659) >> 3);
  if (v660 == (uint64_t *)v659) {
    uint64_t v662 = 0;
  }
  else {
    uint64_t v662 = v661;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v659, v660, v662, 1);
  unint64_t v663 = *(void *)(v718 + 72);
  v664 = *(uint64_t **)(v718 + 80);
  unint64_t v665 = 126 - 2 * __clz((uint64_t)((uint64_t)v664 - v663) >> 3);
  if (v664 == (uint64_t *)v663) {
    uint64_t v666 = 0;
  }
  else {
    uint64_t v666 = v665;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v663, v664, v666, 1);
  unint64_t v667 = *(void *)(v725 + 72);
  v668 = *(uint64_t **)(v725 + 80);
  unint64_t v669 = 126 - 2 * __clz((uint64_t)((uint64_t)v668 - v667) >> 3);
  if (v668 == (uint64_t *)v667) {
    uint64_t v670 = 0;
  }
  else {
    uint64_t v670 = v669;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v667, v668, v670, 1);
  unint64_t v671 = *(void *)(v708 + 72);
  uint64_t v672 = *(uint64_t **)(v708 + 80);
  unint64_t v673 = 126 - 2 * __clz((uint64_t)((uint64_t)v672 - v671) >> 3);
  if (v672 == (uint64_t *)v671) {
    uint64_t v674 = 0;
  }
  else {
    uint64_t v674 = v673;
  }
  std::__introsort<std::_ClassicAlgPolicy,ggl::CommandBuffer::sortRenderItems(BOOL)::$_0 &,ggl::RenderItem **,false>(v671, v672, v674, 1);
  if (v791)
  {
    HIBYTE(v796) = 6;
    strcpy((char *)&__dst, "Ground");
    LODWORD(v797) = 14;
    HIBYTE(v799) = 9;
    strcpy((char *)v798, "Buidlings");
    HIBYTE(v803) = 7;
    LODWORD(v800) = 15;
    strcpy((char *)&v801, "NonTile");
    LODWORD(v804) = 16;
    if (*v405
      && (uint64_t v675 = LODWORD(v798[4 * *(unsigned __int8 *)(v44 + 3560) - 1]), (objc_opt_respondsToSelector() & 1) != 0))
    {
      uint64_t v676 = (ggl::DebugConsole *)[*v405 debugConsoleForId:v675];
    }
    else
    {
      uint64_t v676 = 0;
    }
    ggl::DebugConsole::begin(v676);
  }
  v677 = +[VKDebugSettings sharedSettings];
  int v678 = [v677 drawDaVinciElevationScalingDebug];

  if (v678)
  {
    if (*(void *)a2 && (objc_opt_respondsToSelector() & 1) != 0) {
      v679 = (ggl::DebugConsole *)[*(id *)a2 debugConsoleForId:14];
    }
    else {
      v679 = 0;
    }
    ggl::DebugConsole::begin(v679);
  }
  *(void *)(v44 + 3336) = *(void *)(v44 + 3328);
  switch(*(unsigned char *)(v44 + 3560))
  {
    case 0:
    case 1:
    case 4:
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      v680 = (id)GEOGetVectorKitPerformanceLog_log;
      v681 = v680;
      os_signpost_id_t v682 = *((void *)a2 + 10);
      if (v682 - 1 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled(v680)) {
        goto LABEL_842;
      }
      *(_WORD *)long long __p = 0;
      uint64_t v683 = "DaVinciGroundLayout";
      goto LABEL_840;
    case 2:
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      unint64_t v687 = (id)GEOGetVectorKitPerformanceLog_log;
      v681 = v687;
      os_signpost_id_t v682 = *((void *)a2 + 10);
      if (v682 - 1 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled(v687)) {
        goto LABEL_842;
      }
      *(_WORD *)long long __p = 0;
      uint64_t v683 = "DaVinciBuildingsLayout";
LABEL_840:
      v685 = v681;
      os_signpost_type_t v686 = OS_SIGNPOST_INTERVAL_END;
      break;
    case 3:
      if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
        dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
      }
      v684 = (id)GEOGetVectorKitPerformanceLog_log;
      v681 = v684;
      os_signpost_id_t v682 = *((void *)a2 + 10);
      if (v682 - 1 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled(v684)) {
        goto LABEL_842;
      }
      *(_WORD *)long long __p = 0;
      uint64_t v683 = "DaVinciNonTiledLayout";
      v685 = v681;
      os_signpost_type_t v686 = OS_SIGNPOST_INTERVAL_BEGIN;
      break;
    default:
      goto LABEL_843;
  }
  _os_signpost_emit_with_name_impl(&dword_1A1780000, v685, v686, v682, v683, "", __p, 2u);
LABEL_842:

LABEL_843:
  if (v772) {
    operator delete(v772);
  }
}

void sub_1A1AA6FA4(_Unwind_Exception *a1)
{
  if (!STACK[0x268]) {
    _Unwind_Resume(a1);
  }
  operator delete((void *)STACK[0x268]);
  _Unwind_Resume(a1);
}

uint64_t md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator()(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v3 = *(unsigned __int8 **)(a1 + 8);
  uint64_t v5 = **(int8x16_t ***)a1;
  BOOL v4 = *(int8x16_t **)(*(void *)a1 + 8);
  v23[0] = a2;
  v23[1] = v3;
  os_signpost_id_t v6 = *(unsigned __int8 **)(a1 + 16);
  v23[2] = v6;
  if (v5 != v4)
  {
    uint64_t v7 = *(void *)v3;
    if (*a2)
    {
      int v8 = a2[1];
      while (1)
      {
        uint64_t v9 = *(void *)(v7 + 8 * v5->i64[0]);
        int v10 = *(unsigned __int8 *)(v9 + 145);
        if (*(unsigned char *)(v9 + 147))
        {
          if (*v6) {
            BOOL v11 = 0;
          }
          else {
            BOOL v11 = v10 == v8;
          }
          if (!v11) {
            goto LABEL_15;
          }
        }
        else if (v10 != v8)
        {
          goto LABEL_15;
        }
        uint64_t v5 = (int8x16_t *)((char *)v5 + 8);
        if (v5 == v4) {
          return **(void **)a1;
        }
      }
    }
    while (!*(unsigned char *)(*(void *)(v7 + 8 * v5->i64[0]) + 147) || !*v6)
    {
      uint64_t v5 = (int8x16_t *)((char *)v5 + 8);
      if (v5 == v4) {
        return **(void **)a1;
      }
    }
LABEL_15:
    unsigned int v12 = &v4[-1].u64[1];
    if (v5 != (int8x16_t *)&v4[-1].u64[1])
    {
      if (*a2)
      {
        int v13 = a2[1];
        while (1)
        {
          uint64_t v14 = *(void *)(v7 + 8 * *v12);
          int v15 = *(unsigned __int8 *)(v14 + 145);
          if (*(unsigned char *)(v14 + 147))
          {
            if (*v6) {
              BOOL v16 = 0;
            }
            else {
              BOOL v16 = v15 == v13;
            }
            if (v16) {
              goto LABEL_30;
            }
          }
          else if (v15 == v13)
          {
            goto LABEL_30;
          }
          if (--v12 == (unint64_t *)v5) {
            return **(void **)a1;
          }
        }
      }
      while (*(unsigned char *)(*(void *)(v7 + 8 * *v12) + 147) && *v6)
      {
        if (--v12 == (unint64_t *)v5) {
          return **(void **)a1;
        }
      }
LABEL_30:
      if ((char *)v12 - (char *)v5 < 17)
      {
LABEL_37:
        uint64_t v21 = 0;
        unint64_t v17 = 0;
      }
      else
      {
        if ((((char *)v12 - (char *)v5) >> 3) + 1 >= 0xFFFFFFFFFFFFFFFLL) {
          unint64_t v17 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v17 = (((char *)v12 - (char *)v5) >> 3) + 1;
        }
        unsigned int v18 = (const std::nothrow_t *)MEMORY[0x1E4FBA2D0];
        while (1)
        {
          uint64_t v19 = operator new(8 * v17, v18);
          if (v19) {
            break;
          }
          BOOL v20 = v17 > 1;
          v17 >>= 1;
          if (!v20) {
            goto LABEL_37;
          }
        }
        uint64_t v21 = v19;
      }
      std::__stable_partition_impl<std::_ClassicAlgPolicy,md::DaVinciGroundRenderLayer::layout(md::LayoutContext const&)::$_4::operator() const(geo::optional<md::SceneLayer>)::{lambda(unsigned long)#1} &,std::__wrap_iter<unsigned long *>,long,std::pair<unsigned long *,long>>(v5, v12, v23, (((char *)v12 - (char *)v5) >> 3) + 1, (unint64_t)v21, v17);
      if (v21) {
        operator delete(v21);
      }
    }
  }
  return **(void **)a1;
}

uint64_t *md::MeshRenderableContext::renderablesForRegistry(int8x8_t *this, const gdc::Registry *a2)
{
  {
    int v13 = a2;
    uint64_t v14 = (md::MeshRenderableContext *)this;
    a2 = v13;
    this = (int8x8_t *)v14;
    if (v12)
    {
      __cxa_atexit((void (*)(void *))std::vector<md::MeshRenderable *>::~vector[abi:nn180100], &md::MeshRenderableContext::renderablesForRegistry(gdc::Registry const*)const::sentinal, &dword_1A1780000);
      a2 = v13;
      this = (int8x8_t *)v14;
    }
  }
  if (a2)
  {
    int8x8_t v2 = this[1];
    if (v2)
    {
      unint64_t v3 = *((unsigned __int16 *)a2 + 20);
      uint8x8_t v4 = (uint8x8_t)vcnt_s8(v2);
      v4.i16[0] = vaddlv_u8(v4);
      if (v4.u32[0] > 1uLL)
      {
        unint64_t v5 = *((unsigned __int16 *)a2 + 20);
        if (*(void *)&v2 <= v3) {
          unint64_t v5 = v3 % *(void *)&v2;
        }
      }
      else
      {
        unint64_t v5 = (v2.i32[0] - 1) & v3;
      }
      os_signpost_id_t v6 = *(uint64_t ****)(*(void *)this + 8 * v5);
      if (v6)
      {
        uint64_t v7 = *v6;
        if (v7)
        {
          if (v4.u32[0] < 2uLL)
          {
            uint64_t v8 = *(void *)&v2 - 1;
            double result = (uint64_t *)&md::MeshRenderableContext::renderablesForRegistry(gdc::Registry const*)const::sentinal;
            while (1)
            {
              int v10 = v7[1];
              if (v10 == (uint64_t *)v3)
              {
                if (*((unsigned __int16 *)v7 + 8) == v3) {
                  return (uint64_t *)(v7 + 3);
                }
              }
              else if (((unint64_t)v10 & v8) != v5)
              {
                return result;
              }
              uint64_t v7 = (uint64_t **)*v7;
              if (!v7) {
                return result;
              }
            }
          }
          double result = (uint64_t *)&md::MeshRenderableContext::renderablesForRegistry(gdc::Registry const*)const::sentinal;
          while (1)
          {
            unint64_t v11 = (unint64_t)v7[1];
            if (v11 == v3)
            {
              if (*((unsigned __int16 *)v7 + 8) == v3) {
                return (uint64_t *)(v7 + 3);
              }
            }
            else
            {
              if (v11 >= *(void *)&v2) {
                v11 %= *(void *)&v2;
              }
              if (v11 != v5) {
                return result;
              }
            }
            uint64_t v7 = (uint64_t **)*v7;
            if (!v7) {
              return result;
            }
          }
        }
      }
    }
  }
  return (uint64_t *)&md::MeshRenderableContext::renderablesForRegistry(gdc::Registry const*)const::sentinal;
}

uint64_t geo::Intersect::encloses<float>(float *a1, float *a2)
{
  float v2 = *a2;
  float v3 = a2[1];
  float v4 = a2[2];
  float v6 = *a1;
  float v5 = a1[1];
  if (*a1 >= 0.0) {
    float v7 = a2[3];
  }
  else {
    float v7 = *a2;
  }
  if (v5 >= 0.0) {
    float v8 = a2[4];
  }
  else {
    float v8 = a2[1];
  }
  float v9 = a1[2];
  float v10 = a1[3];
  if (v9 >= 0.0) {
    float v11 = a2[5];
  }
  else {
    float v11 = a2[2];
  }
  if ((float)((float)((float)(v10 + (float)(v7 * v6)) + (float)(v5 * v8)) + (float)(v9 * v11)) < 0.0) {
    return 0;
  }
  float v13 = a1[4];
  float v12 = a1[5];
  float v14 = v13 >= 0.0 ? a2[3] : *a2;
  float v15 = v12 >= 0.0 ? a2[4] : a2[1];
  float v16 = a1[6];
  float v17 = a1[7];
  float v18 = v16 >= 0.0 ? a2[5] : a2[2];
  if ((float)((float)((float)(v17 + (float)(v14 * v13)) + (float)(v12 * v15)) + (float)(v16 * v18)) < 0.0) {
    return 0;
  }
  float v20 = a1[8];
  float v19 = a1[9];
  float v21 = v20 >= 0.0 ? a2[3] : *a2;
  float v22 = v19 >= 0.0 ? a2[4] : a2[1];
  float v23 = a1[10];
  float v24 = a1[11];
  float v25 = v23 >= 0.0 ? a2[5] : a2[2];
  if ((float)((float)((float)(v24 + (float)(v21 * v20)) + (float)(v19 * v22)) + (float)(v23 * v25)) < 0.0) {
    return 0;
  }
  float v27 = a1[12];
  float v26 = a1[13];
  float v28 = v27 >= 0.0 ? a2[3] : *a2;
  float v29 = v26 >= 0.0 ? a2[4] : a2[1];
  float v31 = a1[14];
  float v30 = a1[15];
  float v32 = v31 >= 0.0 ? a2[5] : a2[2];
  if ((float)((float)((float)(v30 + (float)(v28 * v27)) + (float)(v26 * v29)) + (float)(v31 * v32)) < 0.0) {
    return 0;
  }
  float v34 = a1[16];
  float v33 = a1[17];
  float v35 = v34 >= 0.0 ? a2[3] : *a2;
  float v36 = v33 >= 0.0 ? a2[4] : a2[1];
  float v37 = a1[18];
  float v38 = v37 >= 0.0 ? a2[5] : a2[2];
  if ((float)((float)((float)(a1[19] + (float)(v35 * v34)) + (float)(v33 * v36)) + (float)(v37 * v38)) < 0.0) {
    return 0;
  }
  float v39 = a1[20];
  float v40 = a1[21];
  float v41 = v39 >= 0.0 ? a2[3] : *a2;
  float v42 = v40 >= 0.0 ? a2[4] : a2[1];
  float v43 = a1[22];
  float v44 = v43 >= 0.0 ? a2[5] : a2[2];
  if ((float)((float)((float)(a1[23] + (float)(v41 * v39)) + (float)(v40 * v42)) + (float)(v43 * v44)) < 0.0) {
    return 0;
  }
  if (v6 <= 0.0) {
    float v45 = a2[3];
  }
  else {
    float v45 = *a2;
  }
  float v46 = v10 + (float)(v45 * v6);
  if (v5 <= 0.0) {
    float v47 = a2[4];
  }
  else {
    float v47 = a2[1];
  }
  float v48 = v46 + (float)(v47 * v5);
  if (v9 <= 0.0) {
    float v49 = a2[5];
  }
  else {
    float v49 = a2[2];
  }
  uint64_t v50 = (float)(v48 + (float)(v49 * v9)) >= 0.0;
  if (v13 <= 0.0) {
    float v51 = a2[3];
  }
  else {
    float v51 = *a2;
  }
  float v52 = v17 + (float)(v51 * v13);
  if (v12 <= 0.0) {
    float v53 = a2[4];
  }
  else {
    float v53 = a2[1];
  }
  float v54 = v52 + (float)(v53 * v12);
  if (v16 <= 0.0) {
    float v55 = a2[5];
  }
  else {
    float v55 = a2[2];
  }
  if ((float)(v54 + (float)(v55 * v16)) >= 0.0) {
    ++v50;
  }
  if (v20 <= 0.0) {
    float v56 = a2[3];
  }
  else {
    float v56 = *a2;
  }
  float v57 = v24 + (float)(v56 * v20);
  if (v19 <= 0.0) {
    float v58 = a2[4];
  }
  else {
    float v58 = a2[1];
  }
  float v59 = v57 + (float)(v58 * v19);
  if (v23 <= 0.0) {
    float v60 = a2[5];
  }
  else {
    float v60 = a2[2];
  }
  if ((float)(v59 + (float)(v60 * v23)) >= 0.0) {
    ++v50;
  }
  if (v27 <= 0.0) {
    float v61 = a2[3];
  }
  else {
    float v61 = *a2;
  }
  float v62 = v30 + (float)(v61 * v27);
  if (v26 <= 0.0) {
    float v63 = a2[4];
  }
  else {
    float v63 = a2[1];
  }
  float v64 = v62 + (float)(v63 * v26);
  if (v31 <= 0.0) {
    float v65 = a2[5];
  }
  else {
    float v65 = a2[2];
  }
  if ((float)(v64 + (float)(v65 * v31)) >= 0.0) {
    ++v50;
  }
  if (v34 <= 0.0) {
    float v66 = a2[3];
  }
  else {
    float v66 = *a2;
  }
  float v67 = a1[19] + (float)(v66 * v34);
  if (v33 <= 0.0) {
    float v68 = a2[4];
  }
  else {
    float v68 = a2[1];
  }
  float v69 = v67 + (float)(v68 * v33);
  if (v37 <= 0.0) {
    float v70 = a2[5];
  }
  else {
    float v70 = a2[2];
  }
  if ((float)(v69 + (float)(v70 * v37)) >= 0.0) {
    ++v50;
  }
  if (v39 <= 0.0) {
    float v2 = a2[3];
  }
  if (v40 <= 0.0) {
    float v3 = a2[4];
  }
  if (v43 <= 0.0) {
    float v4 = a2[5];
  }
  if ((float)((float)((float)(a1[23] + (float)(v2 * v39)) + (float)(v3 * v40)) + (float)(v4 * v43)) >= 0.0) {
    ++v50;
  }
  if (v50 == 6) {
    return 1;
  }
  else {
    return 2;
  }
}

float32_t md::DaVinciGroundRenderLayer::adjustedMeshBounds(float32x4_t *this, md::MeshRenderable *a2, const md::DaVinciGroundRenderable *a3, int a4, int32x4_t a5)
{
  if (*((unsigned __int8 *)a3 + 24) == 255)
  {
    if (a4)
    {
      if (!*((unsigned char *)a2 + 124))
      {
        *(_OWORD *)((char *)a2 + 100) = xmmword_1A28FC710;
        *(void *)((char *)a2 + 116) = 0x80000000800000;
        *((unsigned char *)a2 + 124) = 1;
        if (!*((unsigned char *)a2 + 140)) {
          *((unsigned char *)a2 + 140) = 1;
        }
        *((_DWORD *)a2 + 34) = 0;
        *((void *)a2 + 16) = 0;
        md::GeometryLogic::calculateGeocentricBounds((float32_t *)a2 + 19, *((void *)a3 + 29), (uint64_t)a2 + 100, (uint64_t)a2 + 128);
        if (!*((unsigned char *)a2 + 124)) {
          goto LABEL_15;
        }
      }
      if (*((unsigned char *)a2 + 140))
      {
        float v9 = (char *)a2 + 128;
        float v10 = (float32x2_t *)((char *)a2 + 76);
        uint64_t v11 = *((void *)a3 + 29);
        float v12 = this;
        float v13 = (char *)a2 + 100;
      }
      else
      {
LABEL_15:
        float v12 = (float32x4_t *)std::__throw_bad_optional_access[abi:nn180100]();
      }
      *(double *)v7.i64 = md::GeometryLogic::scaleGeocentricBoundsWithNormal(v12, v10, (uint64_t)v13, (uint64_t)v9, v11, a5);
    }
    else
    {
      float v14 = (char *)a2 + 76;
      uint64_t v15 = *((void *)a3 + 29);
      v7.f32[0] = md::GeometryLogic::adjustedMeshBounds((uint64_t)this, (uint64_t)v14, v15);
    }
  }
  else
  {
    float32x4_t v7 = *(float32x4_t *)((char *)a2 + 76);
    *this = v7;
    this[1].i64[0] = *(void *)((char *)a2 + 92);
  }
  return v7.f32[0];
}

double md::GeometryLogic::scaleGeocentricBoundsWithNormal(float32x4_t *a1, float32x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int32x4_t a6)
{
  if ((*(unsigned char *)(a5 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    float v20 = &v18;
    float v19 = &v20;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v19, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  float32x2_t v11 = a2[1];
  v11.i32[1] = a2[2].i32[1];
  *(float32x2_t *)a6.i8 = vmul_n_f32(v11, (float)(*(float *)(*(void *)(a5 + 72) + 344) * *(float *)(*(void *)(a5 + 72) + 340))* *(float *)(*(void *)(a5 + 72) + 348));
  float32x4_t v12 = (float32x4_t)vzip1q_s32(a6, a6);
  v12.i32[2] = a6.i32[0];
  float32x2_t v13 = *(float32x2_t *)(a4 + 4);
  int32x2_t v14 = vzip1_s32(*(int32x2_t *)a4, (int32x2_t)v13);
  *(int32x2_t *)v15.f32 = v14;
  v15.i64[1] = __PAIR64__(v14.u32[0], vdup_lane_s32((int32x2_t)v13, 1).u32[0]);
  float32x2_t v16 = vmla_lane_f32(*(float32x2_t *)(a3 + 16), v13, *(float32x2_t *)a6.i8, 1);
  *a1 = vmlaq_f32(*(float32x4_t *)a3, v12, v15);
  *(float32x2_t *)a1[1].f32 = v16;
  return *(double *)a6.i64;
}

void md::DaVinciGroundRenderLayer::layoutPredrapedPolygons(uint64_t **this, const md::LayoutContext *a2, const md::DaVinciGroundRenderable *a3, const md::ElevatedPolygonContext *a4, const md::StyleLogicContext *a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a3 + 48);
  uint64_t v6 = *(void *)(v5 + 1344);
  uint64_t v25 = *(void *)(v5 + 1352);
  if (v6 != v25)
  {
    float v10 = (char *)(this + 425);
    do
    {
      v32[0] = *(void *)v6;
      uint64_t v11 = *(void *)(v6 + 8);
      v32[1] = v11;
      if (v11) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(v11 + 8), 1uLL, memory_order_relaxed);
      }
      long long v12 = *(_OWORD *)(v6 + 16);
      char v34 = *(unsigned char *)(v6 + 32);
      long long v33 = v12;
      float v36 = 0;
      float v37 = 0;
      float v35 = 0;
      int32x2_t v14 = *(unsigned char **)(v6 + 40);
      float32x2_t v13 = *(unsigned char **)(v6 + 48);
      int64_t v15 = v13 - v14;
      if (v13 != v14)
      {
        if (v15 < 0) {
          abort();
        }
        float32x2_t v16 = a2;
        float v35 = (char *)operator new(v13 - v14);
        float v36 = v35;
        float v17 = &v35[8 * (v15 >> 3)];
        float v37 = v17;
        memcpy(v35, v14, v15);
        float v36 = v17;
        a2 = v16;
      }
      int v38 = 0;
      md::layoutElevatedPolygonMeshes<md::DaVinciGroundRenderable>((uint64_t)a2, (uint64_t)a3, (unsigned __int8 *)a4, (uint64_t)v10, this[428], (uint64_t)v31, (uint64_t *)(v6 + 64), (unsigned int *)&xmmword_1A28FE3C0);
      if (*((unsigned char *)a4 + 32))
      {
        float v19 = *(void **)(v6 + 40);
        char v18 = *(void **)(v6 + 48);
        if (v19 != v18)
        {
          while (*v19 != *((void *)a4 + 3))
          {
            if (++v19 == v18)
            {
              float v19 = *(void **)(v6 + 48);
              break;
            }
          }
        }
        if (v19 != v18)
        {
          memset(v29, 0, sizeof(v29));
          char v30 = 1;
          *(_WORD *)geo::intern_linear_map<gss::StyleAttribute,unsigned short,geo::StdAllocator<unsigned char,gss::Allocator>,30ul>::operator[]((uint64_t *)v29, 0x10002u) = 1;
          gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes(&v27, *(void *)a5, (gss::FeatureAttributeSet *)(*(void *)(v6 + 64) + 240), (gss::QueryOverrides *)v29);
          md::layoutElevatedPolygonMeshes<md::DaVinciGroundRenderable>((uint64_t)a2, (uint64_t)a3, (unsigned __int8 *)a4, (uint64_t)v10, this[428], (uint64_t)v31, (uint64_t *)&v27, (unsigned int *)&xmmword_1A28FE3C0);
          float v21 = v28;
          if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
            std::__shared_weak_count::__release_weak(v21);
          }
          if (!v29[14])
          {
            uint64_t v22 = *(void *)v29;
            if (*(void *)v29)
            {
              uint64_t v23 = gss::Allocator::instance(v20);
              (*(void (**)(uint64_t, uint64_t, void))(*(void *)v23 + 40))(v23, v22, *(unsigned __int16 *)&v29[12]);
            }
          }
        }
      }
      if (v38 != -1) {
        ((void (*)(unsigned char *, void *))off_1EF5910A0[v38])(v29, v32);
      }
      v6 += 80;
    }
    while (v6 != v25);
  }
}

void sub_1A1AA7C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28)
{
  if (a28 == -1) {
    _Unwind_Resume(a1);
  }
  ((void (*)(uint64_t *, uint64_t))off_1EF5910A0[a28])(&a15, a10);
  _Unwind_Resume(a1);
}

float md::GeometryLogic::adjustedMeshBounds(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if ((*(unsigned char *)(a3 + 16) & 2) == 0
    && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
  {
    float32x2_t v13 = &v11;
    long long v12 = &v13;
    std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, &v12, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
  }
  uint64_t v6 = *(float **)(a3 + 72);
  float v7 = (float)(v6[86] * v6[85]) * v6[87];
  float v8 = v6[10];
  float v9 = v8 + (float)(*(float *)(a2 + 8) * v7);
  float result = v8 + (float)(*(float *)(a2 + 20) * v7);
  *(void *)a1 = *(void *)a2;
  *(float *)(a1 + 8) = v9;
  *(void *)(a1 + 12) = *(void *)(a2 + 12);
  *(float *)(a1 + 20) = result;
  return result;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0EEE10__dispatchB8nn180100IOZNS0_6__dtorINS0_8__traitsIJN2md16ServerDrapedMeshENS8_18ClientDrapedMeshesEEEELNS0_6_TraitE1EE9__destroyB8nn180100EvEUlRT_E_JRNS0_6__baseILSC_1EJS9_SA_EEEEEEDcSE_DpT0_(uint64_t a1, void *a2)
{
  float v3 = (void *)a2[5];
  if (v3)
  {
    a2[6] = v3;
    operator delete(v3);
  }
  float v4 = (std::__shared_weak_count *)a2[1];
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

void gdc::LayerDataRequestKey::keysInt32Str(std::string *this, unsigned __int16 *a2)
{
  gdc::LayerDataKey::keysInt32Str(&v10, a2 + 4);
  float v4 = std::string::append(&v10, " kt:", 4uLL);
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *(unsigned __int8 *)a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  float v8 = std::string::append(&v11, (const std::string::value_type *)p_p, size);
  *this = *v8;
  v8->__r_.__value_.__r.__words[0] = 0;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_9:
      if ((SHIBYTE(v10.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_13:
      operator delete(v10.__r_.__value_.__l.__data_);
      return;
    }
  }
  else if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(v11.__r_.__value_.__l.__data_);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_13;
  }
}

void gdc::LayerDataKey::keysInt32Str(std::string *this, unsigned __int16 *a2)
{
  gdc::GenericKey::keysInt32Str((gdc::GenericKey *)&v10, (void *)a2 + 1);
  float v4 = std::string::append(&v10, " t:", 3uLL);
  std::string::size_type v5 = v4->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v11.__r_.__value_.__l.__data_ = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
  v11.__r_.__value_.__r.__words[2] = v5;
  v4->__r_.__value_.__l.__size_ = 0;
  v4->__r_.__value_.__r.__words[2] = 0;
  v4->__r_.__value_.__r.__words[0] = 0;
  std::to_string(&__p, *a2);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    p_p = &__p;
  }
  else {
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  }
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    std::string::size_type size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else {
    std::string::size_type size = __p.__r_.__value_.__l.__size_;
  }
  float v8 = std::string::append(&v11, (const std::string::value_type *)p_p, size);
  *this = *v8;
  v8->__r_.__value_.__r.__words[0] = 0;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__p.__r_.__value_.__l.__data_);
    if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
LABEL_9:
      if ((SHIBYTE(v10.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
        return;
      }
LABEL_13:
      operator delete(v10.__r_.__value_.__l.__data_);
      return;
    }
  }
  else if ((SHIBYTE(v11.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    goto LABEL_9;
  }
  operator delete(v11.__r_.__value_.__l.__data_);
  if (SHIBYTE(v10.__r_.__value_.__r.__words[2]) < 0) {
    goto LABEL_13;
  }
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorShadows>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorShadows>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1AA85A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v16)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }

  (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants &,md::ls::UsesShadow const&,md::ls::IntendedStandardPassSceneDepth const*,md::ls::IntendedStandardPassShadow const*>>::each(uint64_t a1, uint64_t a2)
{
  float v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  float v4 = (void *)gdc::Registry::storage<md::ls::UsesShadow>(v3);
  std::string::size_type v5 = (void *)gdc::Registry::storage<md::ls::IntendedStandardPassSceneDepth>(v3);
  uint64_t v6 = (void *)gdc::Registry::storage<md::ls::IntendedStandardPassShadow>(v3);
  float v7 = (void *)gdc::Registry::storage<md::ls::FunctionConstants>(v3);
  float v8 = v7;
  float v9 = v7 + 4;
  if (v4[8] - v4[7] >= v7[8] - v7[7]) {
    uint64_t v10 = (uint64_t)(v7 + 4);
  }
  else {
    uint64_t v10 = (uint64_t)(v4 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v79, v10, v7, v4, *(void *)(v10 + 24));
  if (v4[8] - v4[7] >= v8[8] - v8[7]) {
    uint64_t v11 = (uint64_t)v9;
  }
  else {
    uint64_t v11 = (uint64_t)(v4 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v77, v11, v8, v4, *(void *)(v11 + 32));
  if (v78 == v82)
  {
    uint64_t result = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v13 = (void *)result;
  }
  else
  {
    uint64_t v13 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    do
    {
      *uint64_t v13 = *v12;
      unint64_t v14 = *v12;
      unint64_t v15 = HIDWORD(*v12);
      unint64_t v16 = v14 >> 39;
      uint64_t v17 = v8[4];
      if (v14 >> 39 < (v8[5] - v17) >> 3
        && (uint64_t v18 = *(void *)(v17 + 8 * v16)) != 0
        && (unint64_t v19 = *(unsigned __int16 *)(v18 + 2 * (HIDWORD(v14) & 0x7F)),
            uint64_t v21 = v8[7],
            uint64_t v20 = v8[8],
            v19 < (v20 - v21) >> 3)
        && ((uint64_t v22 = v21 + 8 * v19, v22 != v20) ? (v23 = *(_DWORD *)(v22 + 4) == v15) : (v23 = 0), v23))
      {
        uint64_t v76 = 33 * v19;
        uint64_t v24 = v8[11];
        uint64_t v25 = v8[10] + v76;
      }
      else
      {
        uint64_t v24 = v8[11];
        uint64_t v25 = v24;
      }
      if (v25 == v24) {
        uint64_t v26 = 0;
      }
      else {
        uint64_t v26 = v25;
      }
      uint64_t v27 = v4[4];
      if (v16 < (v4[5] - v27) >> 3
        && (uint64_t v28 = *(void *)(v27 + 8 * v16)) != 0
        && (unint64_t v29 = *(unsigned __int16 *)(v28 + 2 * (HIDWORD(v14) & 0x7F)),
            uint64_t v31 = v4[7],
            uint64_t v30 = v4[8],
            v29 < (v30 - v31) >> 3)
        && ((uint64_t v32 = v31 + 8 * v29, v32 != v30) ? (v33 = *(_DWORD *)(v32 + 4) == v15) : (v33 = 0), v33))
      {
        unint64_t v34 = v4[11];
        unint64_t v35 = v4[10] + v29;
      }
      else
      {
        unint64_t v34 = v4[11];
        unint64_t v35 = v34;
      }
      if (v35 == v34) {
        unint64_t v36 = 0;
      }
      else {
        unint64_t v36 = v35;
      }
      uint64_t v37 = v5[4];
      if (v16 < (v5[5] - v37) >> 3
        && (uint64_t v38 = *(void *)(v37 + 8 * v16)) != 0
        && (unint64_t v39 = *(unsigned __int16 *)(v38 + 2 * (HIDWORD(v14) & 0x7F)),
            uint64_t v41 = v5[7],
            uint64_t v40 = v5[8],
            v39 < (v40 - v41) >> 3)
        && ((v42 = v41 + 8 * v39, v42 != v40) ? (BOOL v43 = *(_DWORD *)(v42 + 4) == v15) : (BOOL v43 = 0), v43))
      {
        unint64_t v44 = v5[11];
        unint64_t v45 = v5[10] + v39;
      }
      else
      {
        unint64_t v44 = v5[11];
        unint64_t v45 = v44;
      }
      if (v45 == v44) {
        unint64_t v45 = 0;
      }
      uint64_t v46 = v6[4];
      if (v16 < (v6[5] - v46) >> 3
        && (uint64_t v47 = *(void *)(v46 + 8 * v16)) != 0
        && (unint64_t v48 = *(unsigned __int16 *)(v47 + 2 * (HIDWORD(v14) & 0x7F)),
            uint64_t v50 = v6[7],
            uint64_t v49 = v6[8],
            v48 < (v49 - v50) >> 3)
        && ((uint64_t v51 = v50 + 8 * v48, v51 != v49) ? (v52 = *(_DWORD *)(v51 + 4) == v15) : (v52 = 0), v52))
      {
        unint64_t v53 = v6[11];
        unint64_t v54 = v6[10] + v48;
      }
      else
      {
        unint64_t v53 = v6[11];
        unint64_t v54 = v53;
      }
      if (v54 == v53) {
        unint64_t v55 = 0;
      }
      else {
        unint64_t v55 = v54;
      }
      unint64_t v84 = v45;
      unint64_t v83 = v55;
      uint64_t v56 = *(void *)(a2 + 24);
      if (!v56)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants &,md::ls::UsesShadow const&>>::~Model();
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t *, unint64_t *))(*(void *)v56 + 48))(v56, v26, v36, &v84, &v83);
      float v58 = v82;
      long long v12 = *(unint64_t **)(v79 + 32);
      if (++v82 != v12)
      {
        uint64_t v59 = v80[4];
        unint64_t v60 = (v80[5] - v59) >> 3;
        float v61 = v58 + 2;
        while (1)
        {
          unint64_t v62 = *((unsigned int *)v61 - 1);
          unint64_t v63 = v62 >> 7;
          if (v62 >> 7 < v60)
          {
            uint64_t v64 = *(void *)(v59 + 8 * v63);
            if (v64)
            {
              unint64_t v65 = *(unsigned __int16 *)(v64 + 2 * (v62 & 0x7F));
              uint64_t v66 = v80[7];
              uint64_t result = v80[8];
              if (v65 < (result - v66) >> 3)
              {
                uint64_t v67 = v66 + 8 * v65;
                if (v67 != result && *(_DWORD *)(v67 + 4) == v62)
                {
                  uint64_t v69 = v81[4];
                  uint64_t result = v81[5] - v69;
                  if (v63 < result >> 3)
                  {
                    uint64_t v70 = *(void *)(v69 + 8 * v63);
                    if (v70)
                    {
                      unint64_t v71 = *(unsigned __int16 *)(v70 + 2 * (v62 & 0x7F));
                      uint64_t v73 = v81[7];
                      uint64_t v72 = v81[8];
                      uint64_t result = v72 - v73;
                      if (v71 < (v72 - v73) >> 3)
                      {
                        uint64_t v74 = v73 + 8 * v71;
                        if (v74 != v72 && *(_DWORD *)(v74 + 4) == v62) {
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          char v82 = v61;
          BOOL v23 = v61++ == v12;
          if (v23) {
            goto LABEL_9;
          }
        }
        long long v12 = v61 - 1;
      }
LABEL_9:
      ;
    }
    while (v78 != v12);
  }
  *uint64_t v13 = 0xFFFFFFFF00000000;
  return result;
}

void ecs2::Query<md::ls::FunctionConstants &,md::ls::UsesShadow const&>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants &,md::ls::UsesShadow const&>>::~Model()
{
}

uint64_t gdc::Registry::storage<md::ls::UsesShadow>(int8x8_t *a1)
{
  uint64_t v10 = 0x4C30532B0D2F6731;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x4C30532B0D2F6731;
    if (*(void *)&v1 <= 0x4C30532B0D2F6731uLL) {
      uint64_t v3 = 0x4C30532B0D2F6731uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x4C30532B0D2F6731;
  }
  float v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (std::string::size_type v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x4C30532B0D2F6731)
      {
        if (v5[2] == 0x4C30532B0D2F6731) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      std::string::size_type v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x4C30532B0D2F6731) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    std::string::size_type v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x4C30532B0D2F6731) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1AA8D28(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t *md::CurvedTextLabelPart::updateWithStyle(md::CurvedTextLabelPart *this, md::LabelManager *a2)
{
  md::TextLabelPart::updateWithStyle(this, a2);
  float v4 = (uint64_t *)*((void *)this + 4);
  uint64_t result = (uint64_t *)*v4;
  BOOL v6 = *((unsigned __int8 *)this + 864) == 1;
  uint64_t v7 = *v4 + 280;
  if (*((unsigned char *)this + 864) == 1) {
    uint64_t v8 = 6;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = *(void *)(v7 + 8 * (*((unsigned char *)this + 864) == 1));
  if (v9)
  {
    if (vabds_f32(*(float *)(v9 + 8), *((float *)result + 26)) >= 0.01)
    {
      uint64_t result = (uint64_t *)md::LabelStyle::updateStyleGroup<md::LabelTextStyleGroup>((unsigned __int8 *)result, v9, v8);
      uint64_t v9 = *(void *)(v7 + 8 * v6);
    }
  }
  else
  {
    uint64_t result = (uint64_t *)md::LabelStyle::prepareStyleGroup<md::LabelTextStyleGroup>((uint64_t)result, v8);
    uint64_t v9 = (uint64_t)result;
    *(void *)(v7 + 8 * v6) = result;
  }
  float v10 = *((float *)this + 157);
  if (v10 != 0.0)
  {
    uint64_t v11 = *(void *)v9;
    uint64_t v12 = *v4;
    float v14 = *(float *)(*v4 + 148);
    float v13 = *(float *)(*v4 + 152);
    *((float *)this + 244) = v13;
    *((unsigned char *)this + 1138) = *(unsigned char *)(v12 + 240);
    *((float *)this + 242) = v14 + (float)(v10 * 0.33);
    *((float *)this + 243) = (float)(*((float *)a2 + 44) * v13) + (float)(*(float *)(v11 + 100) * 0.33);
    uint64_t v15 = *(void *)(v12 + 264);
    if (!v15)
    {
      uint64_t result = md::LabelStyle::prepareStyleGroup<md::LabelLineStyleGroup>(v12);
      uint64_t v15 = *result;
      *(void *)(v12 + 264) = *result;
      uint64_t v12 = *v4;
    }
    *((_DWORD *)this + 287) = *(_DWORD *)(v15 + 52);
    int v16 = *((unsigned __int8 *)this + 1455);
    int v17 = *(unsigned __int8 *)(v12 + 248);
    if (v17 == 32 && (uint64_t v18 = **(void **)(*((void *)this + 72) + 16), *(unsigned char *)(v18 + 128) == 2))
    {
      BOOL v19 = *(unsigned char *)(v18 + 130) != 0;
      *((unsigned char *)this + 1455) = v19;
      if (!v16) {
        goto LABEL_18;
      }
    }
    else
    {
      BOOL v19 = 0;
      *((unsigned char *)this + 1455) = 0;
      if (!v16)
      {
LABEL_18:
        if (!*((unsigned char *)this + 1457))
        {
          float v20 = *(float *)(*((void *)this + 4) + 16);
          if (vabds_f32(v20, *((float *)this + 351)) > 0.5)
          {
            *((float *)this + 351) = v20;
            uint64_t v21 = *(uint64_t (**)(md::CurvedTextLabelPart *))(*(void *)this + 552);
            return (uint64_t *)v21(this);
          }
        }
        return result;
      }
    }
    if (!v19) {
      *((unsigned char *)this + 1452) = v17;
    }
    goto LABEL_18;
  }
  return result;
}

void sub_1A1AA906C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);

  _Unwind_Resume(a1);
}

void md::LabelCustomFeatureProvider::queueCommand(uint64_t a1, char a2, void *a3)
{
  if (*(void *)(*(void *)(a1 + 8) + 184))
  {
    uint64_t v4 = a3[3];
    if (v4)
    {
      std::string::size_type v5 = *(void (**)(void))(*(void *)v4 + 48);
      v5();
      return;
    }
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_47:
    abort();
  }
  uint64_t v8 = *(void *)(a1 + 168);
  uint64_t v9 = *(void *)(a1 + 176);
  float v10 = (std::__shared_weak_count *)operator new(0x40uLL);
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582128;
  LOBYTE(v10[1].__vftable) = a2;
  uint64_t v11 = a3[3];
  if (!v11) {
    goto LABEL_9;
  }
  if ((void *)v11 != a3)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
LABEL_9:
    v10[2].__shared_owners_ = v11;
    goto LABEL_11;
  }
  v10[2].__shared_owners_ = (uint64_t)&v10[1].__shared_owners_;
  (*(void (**)(void *))(*a3 + 24))(a3);
LABEL_11:
  *(void *)&long long v33 = v10 + 1;
  *((void *)&v33 + 1) = v10;
  uint64_t v12 = *(void **)(a1 + 176);
  unint64_t v13 = *(void *)(a1 + 184);
  if ((unint64_t)v12 >= v13)
  {
    uint64_t v14 = *(void *)(a1 + 168);
    uint64_t v15 = ((uint64_t)v12 - v14) >> 4;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 60) {
      goto LABEL_47;
    }
    uint64_t v17 = v13 - v14;
    if (v17 >> 3 > v16) {
      unint64_t v16 = v17 >> 3;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
      uint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v18 = v16;
    }
    if (v18)
    {
      uint64_t v19 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 192) + 16))(*(void *)(a1 + 192), 16 * v18, 8);
      float v20 = (_OWORD *)(v19 + 16 * v15);
      uint64_t v21 = v19 + 16 * v18;
      if (v19)
      {
        *float v20 = v33;
        long long v33 = 0uLL;
      }
    }
    else
    {
      uint64_t v21 = 0;
      float v20 = (_OWORD *)(16 * v15);
    }
    uint64_t v22 = v20 + 1;
    BOOL v23 = *(void **)(a1 + 168);
    uint64_t v24 = *(void **)(a1 + 176);
    if (v24 == v23)
    {
      *(void *)(a1 + 168) = v20;
      *(void *)(a1 + 176) = v22;
      uint64_t v27 = *(void *)(a1 + 184);
      *(void *)(a1 + 184) = v21;
    }
    else
    {
      do
      {
        long long v25 = *((_OWORD *)v24 - 1);
        v24 -= 2;
        *--float v20 = v25;
        void *v24 = 0;
        v24[1] = 0;
      }
      while (v24 != v23);
      uint64_t v24 = *(void **)(a1 + 168);
      uint64_t v26 = *(void **)(a1 + 176);
      *(void *)(a1 + 168) = v20;
      *(void *)(a1 + 176) = v22;
      uint64_t v27 = *(void *)(a1 + 184);
      for (*(void *)(a1 + 184) = v21; v26 != v24; v26 -= 2)
      {
        uint64_t v28 = (std::__shared_weak_count *)*(v26 - 1);
        if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }
    if (v24) {
      (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 192) + 40))(*(void *)(a1 + 192), v24, v27 - (void)v24);
    }
    float v10 = (std::__shared_weak_count *)*((void *)&v33 + 1);
    *(void *)(a1 + 176) = v22;
    if (!v10) {
      goto LABEL_39;
    }
  }
  else
  {
    if (v12)
    {
      *uint64_t v12 = v10 + 1;
      v12[1] = v10;
      long long v33 = 0uLL;
      float v10 = 0;
    }
    *(void *)(a1 + 176) = v12 + 2;
    if (!v10) {
      goto LABEL_39;
    }
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (v8 != v9) {
      return;
    }
    goto LABEL_40;
  }
LABEL_39:
  if (v8 != v9) {
    return;
  }
LABEL_40:
  uint64_t v29 = *(void *)(a1 + 8);
  unsigned __int8 v30 = atomic_load((unsigned __int8 *)(v29 + 3058));
  if (v30)
  {
    uint64_t v31 = *(void *)(v29 + 136);
    if (v31)
    {
      uint64_t v32 = *(void *)(v31 + 56);
      if (v32)
      {
        *(void *)&long long v33 = *(void *)(a1 + 8);
        char v34 = 9;
        (*(void (**)(uint64_t, long long *, char *))(*(void *)v32 + 48))(v32, &v33, &v34);
      }
    }
  }
}

void sub_1A1AA9448(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1A1AA9460(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

__n128 std::__function::__func<md::LabelCustomFeatureProvider::dataSourceFeaturesDidChangeForRect(GEOMapRect)::$_0,std::allocator<md::LabelCustomFeatureProvider::dataSourceFeaturesDidChangeForRect(GEOMapRect)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint8x8_t v2 = (char *)operator new(0x30uLL);
  *(void *)uint8x8_t v2 = &unk_1EF577B08;
  *(_OWORD *)(v2 + 8) = *(_OWORD *)(a1 + 8);
  __n128 result = *(__n128 *)(a1 + 24);
  *(__n128 *)(v2 + 24) = result;
  *((void *)v2 + 5) = *(void *)(a1 + 40);
  return result;
}

uint64_t gdc::Timer::Timer(uint64_t a1, void *a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  std::string::size_type v5 = a2;
  *(void *)a1 = &unk_1EF558F00;
  *(void *)(a1 + 8) = 0xBFF0000000000000;
  *(void *)(a1 + 16) = 850045863;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 81) = 0u;
  dispatch_source_t v6 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, v5);
  uint64_t v7 = *(void **)(a1 + 80);
  *(void *)(a1 + 80) = v6;

  uint64_t v8 = *(NSObject **)(a1 + 80);
  if (!v8) {
    goto LABEL_11;
  }
  v15[0] = MEMORY[0x1E4F143A8];
  v15[1] = 3321888768;
  v15[2] = ___ZN3gdc5TimerC2EPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18functionIFvvEEE_block_invoke;
  v15[3] = &__block_descriptor_72_ea8_40c27_ZTSNSt3__18functionIFvvEEE_e5_v8__0l;
  v15[4] = a1;
  uint64_t v9 = a3[3];
  if (!v9) {
    goto LABEL_5;
  }
  if ((void *)v9 != a3)
  {
    uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)v9 + 16))(v9);
LABEL_5:
    uint64_t v17 = (void *)v9;
    goto LABEL_7;
  }
  uint64_t v17 = v16;
  (*(void (**)(void *, void *))(*a3 + 24))(a3, v16);
LABEL_7:
  dispatch_source_set_event_handler(v8, v15);
  dispatch_resume(*(dispatch_object_t *)(a1 + 80));
  if (v17 == v16)
  {
    (*(void (**)(void *))(v16[0] + 32))(v16);
  }
  else if (v17)
  {
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(*v17 + 40))(v17, v10, v11, v12, v13);
  }
LABEL_11:

  return a1;
}

void sub_1A1AA96E8(_Unwind_Exception *a1)
{
  std::mutex::~mutex(v3);
  _Unwind_Resume(a1);
}

uint64_t ___ZN3gdc5TimerC2EPU28objcproto17OS_dispatch_queue8NSObjectNSt3__18functionIFvvEEE_block_invoke(uint64_t a1)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {
    if (v3 == a1 + 40)
    {
      uint64_t v7 = v6;
      (*(void (**)(uint64_t, void *))(*(void *)v3 + 24))(v3, v6);
    }
    else
    {
      uint64_t v7 = (void *)(*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3);
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  std::mutex::lock((std::mutex *)(v2 + 16));
  double v4 = *(double *)(v2 + 8);
  if (v4 <= 0.0) {
    *(unsigned char *)(v2 + 96) = 0;
  }
  else {
    *(CFAbsoluteTime *)(v2 + 88) = CFAbsoluteTimeGetCurrent() + v4;
  }
  std::mutex::unlock((std::mutex *)(v2 + 16));
  if (!v7) {
    std::__throw_bad_function_call[abi:nn180100]();
  }
  (*(void (**)(void *))(*v7 + 48))(v7);
  uint64_t result = (uint64_t)v7;
  if (v7 == v6) {
    return (*(uint64_t (**)(void *))(v6[0] + 32))(v6);
  }
  if (v7) {
    return (*(uint64_t (**)(void))(*v7 + 40))();
  }
  return result;
}

uint64_t std::__function::__func<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_1,std::allocator<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56F2E8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_1,std::allocator<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)dispatch_source_t v6 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LabelsAnimationFired", "", v6, 2u);
  }

  unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3058));
  if (v3)
  {
    uint64_t v4 = *(void *)(v1 + 136);
    if (v4)
    {
      uint64_t v5 = *(void *)(v4 + 56);
      if (v5)
      {
        uint64_t v8 = v1;
        char v7 = 9;
        (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v5 + 48))(v5, &v8, &v7);
      }
    }
  }
}

uint64_t std::__function::__func<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0,std::allocator<md::LabelsLogic::setNeedsLayoutCallback(std::function<void ()(md::LabelManager const*,md::NeedsLayoutReason)>)::$_0>,void ()(md::LabelManager const*,md::NeedsLayoutReason)>::operator()(uint64_t a1, uint64_t *a2, char *a3)
{
  uint64_t result = *(void *)(a1 + 32);
  if (result)
  {
    if (*(void *)(*(void *)(a1 + 40) + 160) == *a2)
    {
      char v5 = *a3;
      uint64_t v7 = *a2;
      char v6 = v5;
      return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)result + 48))(result, &v7, &v6);
    }
  }
  return result;
}

void std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_4,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_4>,void ()(md::LabelManager const*,md::NeedsLayoutReason)>::operator()(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  char v4 = *a3;
  md::MapEngine::setNeedsTick(v3, &v4);
}

uint64_t std::__function::__func<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_0,std::allocator<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56F2A0;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::World::World(VKSharedResources *,GEOApplicationAuditToken *,float,objc_object  {objcproto14MDRenderTarget}*,std::shared_ptr<md::TaskContext>,gdc::LoadingStatusTracker *,ggl::RenderTargetFormat const&,std::function<void ()(void)>,BOOL,md::RunLoopController *)::$_2,std::allocator<md::RunLoopController *>,std::function>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF578D98;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_0,std::allocator<md::LabelManager::LabelManager(gdc::WorldType,md::LabelManagerCreationParams const&)::$_0>,void ()(void)>::operator()(void *result)
{
  uint64_t v1 = result[1];
  atomic_store(1u, (unsigned __int8 *)(v1 + 3378));
  unsigned __int8 v2 = atomic_load((unsigned __int8 *)(v1 + 3058));
  if (v2)
  {
    uint64_t v3 = *(void *)(v1 + 136);
    if (v3)
    {
      uint64_t result = *(void **)(v3 + 56);
      if (result)
      {
        uint64_t v5 = v1;
        char v4 = 9;
        return (void *)(*(uint64_t (**)(void *, uint64_t *, char *))(*result + 48))(result, &v5, &v4);
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_31,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_31>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF579E30;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::PendingSceneLogic::PendingSceneLogic(md::World *,md::RunLoopController *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1,std::allocator<md::PendingSceneLogic::PendingSceneLogic(md::World *,md::RunLoopController *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF573230;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_32,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_32>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF521158;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::PendingSceneLogic::PendingSceneLogic(md::World *,md::RunLoopController *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_0,std::allocator<md::PendingSceneLogic::PendingSceneLogic(md::World *,md::RunLoopController *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5731E8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_31,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_31>,void ()(void)>::operator()(uint64_t a1)
{
  return md::MapEngine::logLayoutReasonsHistory(*(md::MapEngine **)(a1 + 8), 0);
}

void std::__function::__func<md::PendingSceneLogic::PendingSceneLogic(md::World *,md::RunLoopController *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1,std::allocator<md::PendingSceneLogic::PendingSceneLogic(md::World *,md::RunLoopController *,NSObject  {objcproto17OS_dispatch_queue}*,BOOL)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = **(void **)(*(void *)(a1 + 8) + 136);
  if (v1)
  {
    char v2 = 8;
    md::MapEngine::setNeedsTick(v1, &v2);
  }
}

uint64_t md::PointPosition::addElement(unint64_t *a1, void **a2)
{
  unint64_t v3 = *a1;
  unint64_t v4 = a1[1];
  uint64_t v5 = (void *)v3;
  if (v3 == v4)
  {
LABEL_6:
    if ((unint64_t)v5 >= a1[2])
    {
      uint64_t v8 = std::vector<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>,geo::StdAllocator<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>,mdm::Allocator>>::__push_back_slow_path<geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&>((uint64_t)a1, a2);
      unint64_t v3 = *a1;
    }
    else
    {
      if (v5)
      {
        void *v5 = 0;
        uint64_t v7 = *a2;
        void *v5 = *a2;
        if (v7) {
          ++*v7;
        }
      }
      uint64_t v8 = v5 + 1;
    }
    unint64_t v9 = 126 - 2 * __clz((uint64_t)((uint64_t)v8 - v3) >> 3);
    a1[1] = (unint64_t)v8;
    if (v8 == (uint64_t *)v3) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v9;
    }
    uint64_t v11 = 1;
    std::__introsort<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*,false>(v3, v8, v10, 1);
  }
  else
  {
    unint64_t v6 = v3;
    while (*(void *)(*(void *)v6 + 8) != (*a2)[1])
    {
      v6 += 8;
      if (v6 == v4)
      {
        uint64_t v5 = (void *)a1[1];
        goto LABEL_6;
      }
    }
    return 0;
  }
  return v11;
}

unint64_t std::__introsort<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*,false>(unint64_t result, uint64_t *a2, uint64_t a3, char a4)
{
  unint64_t v9 = (uint64_t *)result;
LABEL_2:
  while (2)
  {
    uint64_t v10 = v9;
LABEL_3:
    uint64_t v11 = v10;
    unint64_t v9 = v10 + 1;
    int64x2_t v150 = v10 + 2;
LABEL_4:
    uint64_t v12 = (char *)a2 - (char *)v11;
    unint64_t v13 = a2 - v11;
    if (!v5 && v4)
    {
      if (v12 <= 191)
      {
        BOOL v79 = v11 == a2 || v9 == a2;
        if (a4)
        {
          if (v79) {
            return result;
          }
          uint64_t v80 = 0;
          unint64_t v81 = v11;
          while (2)
          {
            unint64_t v83 = v81;
            unint64_t v81 = v9;
            uint64_t v84 = *v9;
            uint64_t v85 = *v83;
            uint64_t v86 = *v9 + 8;
            if (!*v9) {
              uint64_t v86 = 0;
            }
            unint64_t v87 = *(uint64_t **)(v86 + 72);
            uint64_t v88 = v85 + 8;
            if (!v85) {
              uint64_t v88 = 0;
            }
            uint64_t v89 = *(uint64_t **)(v88 + 72);
            if (v87 == v89)
            {
              if (*(unsigned __int8 *)(v86 + 129) < *(unsigned __int8 *)(v88 + 129))
              {
LABEL_209:
                *unint64_t v9 = v85;
                *unint64_t v83 = 0;
                uint64_t v90 = v80;
                char v82 = v11;
                if (v83 != v11)
                {
                  while (1)
                  {
                    uint64_t v91 = *(uint64_t *)((char *)v11 + v90 - 8);
                    uint64_t v92 = v91 + 8;
                    if (!v91) {
                      uint64_t v92 = 0;
                    }
                    uint64_t result = *(void *)(v92 + 72);
                    if (v87 == (uint64_t *)result)
                    {
                      uint64_t result = *(unsigned __int8 *)(v86 + 129);
                      if (result >= *(unsigned __int8 *)(v92 + 129))
                      {
                        char v82 = v83;
                        break;
                      }
                    }
                    else if ((unint64_t)v87 <= result)
                    {
                      char v82 = (uint64_t *)((char *)v11 + v90);
                      break;
                    }
                    --v83;
                    *(uint64_t *)((char *)v11 + v90) = v91;
                    *(uint64_t *)((char *)v11 + v90 - 8) = 0;
                    v90 -= 8;
                    if (!v90)
                    {
                      char v82 = v11;
                      break;
                    }
                  }
                }
                *char v82 = v84;
              }
            }
            else if (v87 > v89)
            {
              goto LABEL_209;
            }
            ++v9;
            v80 += 8;
            if (v81 + 1 == a2) {
              return result;
            }
            continue;
          }
        }
        if (v79) {
          return result;
        }
        while (2)
        {
          int64x2_t v139 = v11;
          uint64_t v11 = v9;
          uint64_t v140 = *v9;
          uint64_t v141 = *v139;
          uint64_t v142 = *v9 + 8;
          if (!*v9) {
            uint64_t v142 = 0;
          }
          unint64_t v143 = *(void *)(v142 + 72);
          uint64_t v144 = v141 + 8;
          if (!v141) {
            uint64_t v144 = 0;
          }
          unint64_t v145 = *(void *)(v144 + 72);
          if (v143 == v145)
          {
            if (*(unsigned __int8 *)(v142 + 129) < *(unsigned __int8 *)(v144 + 129)) {
              goto LABEL_320;
            }
          }
          else if (v143 > v145)
          {
LABEL_320:
            *unint64_t v9 = 0;
            do
            {
              while (1)
              {
                int64x2_t v146 = v139;
                v139[1] = v141;
                uint64_t v147 = *--v139;
                uint64_t v141 = v147;
                *int64x2_t v146 = 0;
                uint64_t v148 = v147 + 8;
                if (!v147) {
                  uint64_t v148 = 0;
                }
                unint64_t v149 = *(void *)(v148 + 72);
                if (v143 == v149) {
                  break;
                }
                if (v143 <= v149) {
                  goto LABEL_310;
                }
              }
            }
            while (*(unsigned __int8 *)(v142 + 129) < *(unsigned __int8 *)(v148 + 129));
LABEL_310:
            *int64x2_t v146 = v140;
          }
          ++v9;
          if (v11 + 1 == a2) {
            return result;
          }
          continue;
        }
      }
      if (!a3)
      {
        if (v11 == a2) {
          return result;
        }
        int64_t v93 = (v13 - 2) >> 1;
        int64_t v94 = v93;
        while (2)
        {
          uint64_t v96 = v94;
          if (v93 < v94) {
            goto LABEL_223;
          }
          uint64_t v97 = (2 * v94) | 1;
          uint64_t v95 = &v11[v97];
          if (2 * v96 + 2 < (uint64_t)v13)
          {
            uint64_t v98 = v95[1];
            if (*v95) {
              uint64_t v99 = *v95 + 8;
            }
            else {
              uint64_t v99 = 0;
            }
            unint64_t v100 = *(void *)(v99 + 72);
            if (v98) {
              uint64_t v101 = v98 + 8;
            }
            else {
              uint64_t v101 = 0;
            }
            unint64_t v102 = *(void *)(v101 + 72);
            if (v100 == v102)
            {
              if (*(unsigned __int8 *)(v99 + 129) >= *(unsigned __int8 *)(v101 + 129)) {
                goto LABEL_237;
              }
            }
            else if (v100 <= v102)
            {
              goto LABEL_237;
            }
            ++v95;
            uint64_t v97 = 2 * v96 + 2;
          }
LABEL_237:
          uint64_t v103 = v11[v96];
          if (*v95) {
            uint64_t v104 = *v95 + 8;
          }
          else {
            uint64_t v104 = 0;
          }
          uint64_t result = *(void *)(v104 + 72);
          uint64_t v105 = v103 + 8;
          if (!v103) {
            uint64_t v105 = 0;
          }
          int64x2_t v106 = *(uint64_t **)(v105 + 72);
          if ((uint64_t *)result == v106)
          {
            uint64_t result = *(unsigned __int8 *)(v105 + 129);
            if (*(unsigned __int8 *)(v104 + 129) < result) {
              goto LABEL_223;
            }
          }
          else if (result > (unint64_t)v106)
          {
            goto LABEL_223;
          }
          uint64_t v107 = v96;
          v11[v107] = 0;
          uint64_t result = *v95;
          v11[v107] = *v95;
LABEL_249:
          uint64_t *v95 = 0;
          if (v93 < v97) {
            goto LABEL_222;
          }
          int64x2_t v108 = v95;
          uint64_t v109 = 2 * v97;
          uint64_t v97 = (2 * v97) | 1;
          uint64_t v95 = &v11[v97];
          uint64_t v110 = v109 + 2;
          if (v110 < (uint64_t)v13)
          {
            uint64_t v111 = v95[1];
            if (*v95) {
              uint64_t v112 = *v95 + 8;
            }
            else {
              uint64_t v112 = 0;
            }
            unint64_t v113 = *(void *)(v112 + 72);
            if (v111) {
              uint64_t v114 = v111 + 8;
            }
            else {
              uint64_t v114 = 0;
            }
            unint64_t v115 = *(void *)(v114 + 72);
            if (v113 == v115)
            {
              if (*(unsigned __int8 *)(v112 + 129) >= *(unsigned __int8 *)(v114 + 129)) {
                goto LABEL_262;
              }
LABEL_261:
              ++v95;
              uint64_t v97 = v110;
            }
            else if (v113 > v115)
            {
              goto LABEL_261;
            }
          }
LABEL_262:
          uint64_t result = *v95;
          uint64_t v116 = *v95 + 8;
          if (!*v95) {
            uint64_t v116 = 0;
          }
          int64x2_t v117 = *(uint64_t **)(v116 + 72);
          if (v117 == v106)
          {
            if (*(unsigned __int8 *)(v116 + 129) < *(unsigned __int8 *)(v105 + 129))
            {
LABEL_221:
              uint64_t v95 = v108;
LABEL_222:
              uint64_t *v95 = v103;
LABEL_223:
              int64_t v94 = v96 - 1;
              if (v96) {
                continue;
              }
              uint64_t v118 = (unint64_t)v12 >> 3;
              while (2)
              {
                uint64_t v121 = 0;
                uint64_t v122 = *v11;
                uint64_t *v11 = 0;
                uint8x16_t v119 = v11;
LABEL_274:
                int8x16_t v123 = v119;
                v119 += v121 + 1;
                uint64_t v124 = 2 * v121;
                uint64_t v121 = (2 * v121) | 1;
                uint64_t v125 = v124 + 2;
                if (v125 < v118)
                {
                  uint64_t v126 = v119[1];
                  if (*v119) {
                    uint64_t v127 = *v119 + 8;
                  }
                  else {
                    uint64_t v127 = 0;
                  }
                  uint64_t result = *(void *)(v127 + 72);
                  if (v126) {
                    uint64_t v128 = v126 + 8;
                  }
                  else {
                    uint64_t v128 = 0;
                  }
                  int64x2_t v129 = *(uint64_t **)(v128 + 72);
                  if ((uint64_t *)result == v129)
                  {
                    if (*(unsigned __int8 *)(v127 + 129) >= *(unsigned __int8 *)(v128 + 129)) {
                      goto LABEL_273;
                    }
LABEL_272:
                    ++v119;
                    uint64_t v121 = v125;
                    goto LABEL_273;
                  }
                  if (result > (unint64_t)v129) {
                    goto LABEL_272;
                  }
                }
LABEL_273:
                *int8x16_t v123 = *v119;
                uint64_t *v119 = 0;
                if (v121 > (uint64_t)((unint64_t)(v118 - 2) >> 1))
                {
                  if (v119 == --a2) {
                    goto LABEL_269;
                  }
                  uint64_t *v119 = *a2;
                  *a2 = v122;
                  uint64_t v130 = (char *)v119 - (char *)v11 + 8;
                  if (v130 < 9) {
                    goto LABEL_270;
                  }
                  unint64_t v131 = ((unint64_t)v130 >> 3) - 2;
                  unint64_t v132 = v131 >> 1;
                  int64x2_t v133 = &v11[v131 >> 1];
                  uint64_t v122 = *v119;
                  if (*v133) {
                    uint64_t v134 = *v133 + 8;
                  }
                  else {
                    uint64_t v134 = 0;
                  }
                  uint8x16_t v135 = *(uint64_t **)(v134 + 72);
                  uint64_t v136 = v122 + 8;
                  if (!v122) {
                    uint64_t v136 = 0;
                  }
                  uint32x4_t v137 = *(uint64_t **)(v136 + 72);
                  if (v135 != v137)
                  {
                    if (v135 <= v137) {
                      goto LABEL_270;
                    }
LABEL_297:
                    uint64_t *v119 = 0;
                    uint64_t *v119 = *v133;
                    *int64x2_t v133 = 0;
                    uint8x16_t v119 = &v11[v131 >> 1];
                    while (v131 >= 2)
                    {
                      unint64_t v131 = v132 - 1;
                      unint64_t v132 = (v132 - 1) >> 1;
                      uint8x16_t v119 = &v11[v132];
                      uint64_t v138 = *v119 + 8;
                      if (!*v119) {
                        uint64_t v138 = 0;
                      }
                      uint64_t result = *(void *)(v138 + 72);
                      if ((uint64_t *)result == v137)
                      {
                        uint64_t result = *(unsigned __int8 *)(v136 + 129);
                        if (*(unsigned __int8 *)(v138 + 129) >= result)
                        {
LABEL_268:
                          uint8x16_t v119 = v133;
                          break;
                        }
                      }
                      else if (result <= (unint64_t)v137)
                      {
                        goto LABEL_268;
                      }
                      *int64x2_t v133 = *v119;
                      uint64_t *v119 = 0;
                      int64x2_t v133 = &v11[v132];
                    }
LABEL_269:
                    uint64_t *v119 = v122;
                    goto LABEL_270;
                  }
                  if (*(unsigned __int8 *)(v134 + 129) < *(unsigned __int8 *)(v136 + 129)) {
                    goto LABEL_297;
                  }
LABEL_270:
                  if (v118-- <= 2) {
                    return result;
                  }
                  continue;
                }
                goto LABEL_274;
              }
            }
          }
          else if (v117 > v106)
          {
            goto LABEL_221;
          }
          break;
        }
        *int64x2_t v108 = result;
        goto LABEL_249;
      }
      uint64_t v14 = &v11[v13 >> 1];
      uint64_t v15 = a2 - 1;
      if ((unint64_t)v12 >= 0x401)
      {
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(v11, &v11[v13 >> 1], a2 - 1);
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(v9, v14 - 1, a2 - 2);
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(v150, v14 + 1, a2 - 3);
        uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(v14 - 1, v14, v14 + 1);
        uint64_t v16 = *v11;
        uint64_t *v11 = 0;
        uint64_t *v11 = *v14;
        *uint64_t v14 = v16;
      }
      else
      {
        uint64_t result = (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(&v11[v13 >> 1], v11, a2 - 1);
      }
      --a3;
      uint64_t v17 = *v11;
      if ((a4 & 1) == 0)
      {
        uint64_t v18 = *(v11 - 1);
        if (v18) {
          uint64_t v19 = v18 + 8;
        }
        else {
          uint64_t v19 = 0;
        }
        unint64_t v20 = *(void *)(v19 + 72);
        uint64_t v21 = v17 + 8;
        if (!v17) {
          uint64_t v21 = 0;
        }
        unint64_t v22 = *(void *)(v21 + 72);
        if (v20 == v22)
        {
          if (*(unsigned __int8 *)(v19 + 129) >= *(unsigned __int8 *)(v21 + 129))
          {
            unint64_t v22 = *(void *)(v19 + 72);
LABEL_100:
            uint64_t *v11 = 0;
            uint64_t v48 = *v15;
            uint64_t v49 = *v15 + 8;
            if (!*v15) {
              uint64_t v49 = 0;
            }
            unint64_t v50 = *(void *)(v49 + 72);
            if (v22 == v50)
            {
              if (*(unsigned __int8 *)(v21 + 129) < *(unsigned __int8 *)(v49 + 129))
              {
                while (1)
                {
LABEL_109:
                  if (*v9) {
                    uint64_t v51 = *v9 + 8;
                  }
                  else {
                    uint64_t v51 = 0;
                  }
                  unint64_t v52 = *(void *)(v51 + 72);
                  if (v22 == v52)
                  {
                    if (*(unsigned __int8 *)(v21 + 129) < *(unsigned __int8 *)(v51 + 129)) {
                      goto LABEL_123;
                    }
                  }
                  else if (v22 > v52)
                  {
                    goto LABEL_123;
                  }
                  ++v9;
                }
              }
            }
            else if (v22 > v50)
            {
              goto LABEL_109;
            }
            while (v9 < a2)
            {
              if (*v9) {
                uint64_t v53 = *v9 + 8;
              }
              else {
                uint64_t v53 = 0;
              }
              unint64_t v54 = *(void *)(v53 + 72);
              if (v22 == v54)
              {
                if (*(unsigned __int8 *)(v21 + 129) < *(unsigned __int8 *)(v53 + 129)) {
                  break;
                }
              }
              else if (v22 > v54)
              {
                break;
              }
              ++v9;
            }
LABEL_123:
            uint64_t i = a2;
            if (v9 < a2)
            {
              for (uint64_t i = a2 - 1; ; --i)
              {
                if (v48) {
                  uint64_t v57 = v48 + 8;
                }
                else {
                  uint64_t v57 = 0;
                }
                unint64_t v58 = *(void *)(v57 + 72);
                if (v22 == v58)
                {
                  if (*(unsigned __int8 *)(v21 + 129) >= *(unsigned __int8 *)(v57 + 129)) {
                    break;
                  }
                }
                else if (v22 <= v58)
                {
                  break;
                }
                uint64_t v56 = *(i - 1);
                uint64_t v48 = v56;
              }
            }
            if (v9 >= i)
            {
              uint64_t v66 = 0;
              goto LABEL_152;
            }
            uint64_t v59 = *v9;
            while (2)
            {
              *unint64_t v9 = 0;
              *v9++ = *i;
              uint64_t *i = v59;
              while (1)
              {
                uint64_t v59 = *v9;
                uint64_t v60 = *v9 + 8;
                if (!*v9) {
                  uint64_t v60 = 0;
                }
                unint64_t v61 = *(void *)(v60 + 72);
                if (v22 != v61) {
                  break;
                }
                if (*(unsigned __int8 *)(v21 + 129) < *(unsigned __int8 *)(v60 + 129)) {
                  goto LABEL_144;
                }
LABEL_137:
                ++v9;
              }
              if (v22 <= v61) {
                goto LABEL_137;
              }
              do
              {
LABEL_144:
                while (1)
                {
                  uint64_t v62 = *--i;
                  uint64_t v63 = v62 + 8;
                  uint64_t v64 = v62 ? v63 : 0;
                  unint64_t v65 = *(void *)(v64 + 72);
                  if (v22 == v65) {
                    break;
                  }
                  if (v22 <= v65) {
                    goto LABEL_134;
                  }
                }
              }
              while (*(unsigned __int8 *)(v21 + 129) < *(unsigned __int8 *)(v64 + 129));
LABEL_134:
              if (v9 < i) {
                continue;
              }
              break;
            }
            uint64_t v66 = (void *)*v11;
LABEL_152:
            uint64_t v67 = v9 - 1;
            BOOL v4 = v9 - 1 >= v11;
            BOOL v5 = v9 - 1 == v11;
            if (v9 - 1 != v11)
            {
              if (v66)
              {
                BOOL v4 = *v66 != 0;
                BOOL v5 = (*v66)-- == 1;
                if (v5)
                {
                  float v68 = (std::__shared_weak_count *)v66[3];
                  if (v68 && !atomic_fetch_add(&v68->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v68->__on_zero_shared)(v68);
                    std::__shared_weak_count::__release_weak(v68);
                  }
                  uint64_t v69 = mdm::Allocator::instance((mdm::Allocator *)result);
                  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v69 + 40))(v69, *v11, 152);
                  uint64_t *v11 = 0;
                }
              }
              uint64_t *v11 = *v67;
              uint64_t v11 = v9 - 1;
              goto LABEL_161;
            }
            if (v66)
            {
              BOOL v4 = *v66 != 0;
              BOOL v5 = (*v66)-- == 1;
              if (v5)
              {
                uint64_t v70 = (std::__shared_weak_count *)v66[3];
                if (v70 && !atomic_fetch_add(&v70->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v70->__on_zero_shared)(v70);
                  std::__shared_weak_count::__release_weak(v70);
                }
                uint64_t v71 = mdm::Allocator::instance((mdm::Allocator *)result);
                uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v71 + 40))(v71, *v11, 152);
LABEL_161:
                uint64_t *v11 = 0;
              }
            }
            a4 = 0;
            *uint64_t v67 = v17;
            continue;
          }
        }
        else if (v20 <= v22)
        {
          goto LABEL_100;
        }
      }
      uint64_t *v11 = 0;
      uint64_t v23 = v17 + 8;
      if (!v17) {
        uint64_t v23 = 0;
      }
      unint64_t v24 = *(void *)(v23 + 72);
      for (uint64_t j = v9; ; ++j)
      {
        uint64_t v26 = *j;
        uint64_t v27 = *j + 8;
        if (!*j) {
          uint64_t v27 = 0;
        }
        unint64_t v28 = *(void *)(v27 + 72);
        if (v28 == v24)
        {
          if (*(unsigned __int8 *)(v27 + 129) >= *(unsigned __int8 *)(v23 + 129)) {
            goto LABEL_30;
          }
        }
        else if (v28 <= v24)
        {
LABEL_30:
          uint64_t v29 = j - 1;
          if (j - 1 != v11)
          {
            for (uint64_t k = a2 - 1; ; --k)
            {
              if (*k) {
                uint64_t v31 = *k + 8;
              }
              else {
                uint64_t v31 = 0;
              }
              unint64_t v32 = *(void *)(v31 + 72);
              if (v32 == v24)
              {
                if (*(unsigned __int8 *)(v31 + 129) < *(unsigned __int8 *)(v23 + 129)) {
                  goto LABEL_52;
                }
              }
              else if (v32 > v24)
              {
                goto LABEL_52;
              }
            }
          }
          uint64_t k = a2;
          if (j < a2)
          {
            for (uint64_t k = a2 - 1; ; --k)
            {
              if (*k) {
                uint64_t v33 = *k + 8;
              }
              else {
                uint64_t v33 = 0;
              }
              unint64_t v34 = *(void *)(v33 + 72);
              if (v34 == v24)
              {
                if (j >= k || *(unsigned __int8 *)(v33 + 129) < *(unsigned __int8 *)(v23 + 129)) {
                  break;
                }
              }
              else if (j >= k || v34 > v24)
              {
                break;
              }
            }
          }
LABEL_52:
          if (j < k)
          {
            unint64_t v35 = j;
            unint64_t v36 = k;
            while (1)
            {
              uint64_t *v35 = 0;
              *v35++ = *v36;
              *unint64_t v36 = v26;
              while (1)
              {
                uint64_t v26 = *v35;
                uint64_t v37 = *v35 + 8;
                if (!*v35) {
                  uint64_t v37 = 0;
                }
                unint64_t v38 = *(void *)(v37 + 72);
                if (v38 != v24) {
                  break;
                }
                if (*(unsigned __int8 *)(v37 + 129) >= *(unsigned __int8 *)(v23 + 129)) {
                  goto LABEL_62;
                }
LABEL_57:
                ++v35;
              }
              if (v38 > v24) {
                goto LABEL_57;
              }
LABEL_62:
              uint64_t v29 = v35 - 1;
              do
              {
                while (1)
                {
                  uint64_t v39 = *--v36;
                  uint64_t v40 = v39 + 8;
                  uint64_t v41 = v39 ? v40 : 0;
                  unint64_t v42 = *(void *)(v41 + 72);
                  if (v42 == v24) {
                    break;
                  }
                  if (v42 > v24) {
                    goto LABEL_54;
                  }
                }
              }
              while (*(unsigned __int8 *)(v41 + 129) >= *(unsigned __int8 *)(v23 + 129));
LABEL_54:
              if (v35 >= v36)
              {
                BOOL v43 = (void *)*v11;
                if (v29 == v11) {
                  goto LABEL_86;
                }
LABEL_71:
                if (v43)
                {
                  BOOL v5 = (*v43)-- == 1;
                  if (v5)
                  {
                    unint64_t v44 = (std::__shared_weak_count *)v43[3];
                    if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
                      std::__shared_weak_count::__release_weak(v44);
                    }
                    {
                      operator new();
                    }
                    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc
                                                                      + 40))(mdm::Allocator::instance(void)::alloc, *v11, 152);
                    uint64_t *v11 = 0;
                  }
                }
                uint64_t *v11 = *v29;
                unint64_t v45 = v29;
LABEL_80:
                *unint64_t v45 = 0;
                goto LABEL_81;
              }
            }
          }
          BOOL v43 = 0;
          if (v29 != v11) {
            goto LABEL_71;
          }
LABEL_86:
          if (v43)
          {
            BOOL v5 = (*v43)-- == 1;
            if (v5)
            {
              uint64_t v47 = (std::__shared_weak_count *)v43[3];
              if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
                std::__shared_weak_count::__release_weak(v47);
              }
              {
                operator new();
              }
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)mdm::Allocator::instance(void)::alloc + 40))(mdm::Allocator::instance(void)::alloc, *v11, 152);
              unint64_t v45 = v11;
              goto LABEL_80;
            }
          }
LABEL_81:
          *uint64_t v29 = v17;
          if (j < k) {
            goto LABEL_99;
          }
          BOOL v46 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(v11, v29);
          uint64_t v10 = v29 + 1;
          uint64_t result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(v29 + 1, a2);
          if (!result)
          {
            if (!v46)
            {
LABEL_99:
              uint64_t result = std::__introsort<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*,false>(v11, v29, a3, a4 & 1);
              a4 = 0;
              unint64_t v9 = v29 + 1;
              goto LABEL_2;
            }
            goto LABEL_3;
          }
          a2 = v29;
          if (v46) {
            return result;
          }
          goto LABEL_4;
        }
      }
    }
    break;
  }
  switch(v13)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      uint64_t v72 = *(a2 - 1);
      uint64_t v73 = *v11;
      if (v72) {
        uint64_t v74 = v72 + 8;
      }
      else {
        uint64_t v74 = 0;
      }
      unint64_t v75 = *(void *)(v74 + 72);
      uint64_t v76 = v73 + 8;
      if (!v73) {
        uint64_t v76 = 0;
      }
      unint64_t v77 = *(void *)(v76 + 72);
      if (v75 == v77)
      {
        if (*(unsigned __int8 *)(v74 + 129) >= *(unsigned __int8 *)(v76 + 129)) {
          return result;
        }
      }
      else if (v75 <= v77)
      {
        return result;
      }
      uint64_t *v11 = 0;
      uint64_t *v11 = *(a2 - 1);
      *(a2 - 1) = v73;
      break;
    case 3uLL:
      return (unint64_t)std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(v11, v9, a2 - 1);
    case 4uLL:
      return (unint64_t)std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*>(v11, v9, v150, a2 - 1);
    case 5uLL:
      return (unint64_t)std::__sort5_maybe_branchless[abi:nn180100]<std::_ClassicAlgPolicy,md::PointPosition::addElement(geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator> const&)::$_1 &,geo::fast_shared_ptr<md::PointLabelFeatureElement,mdm::MDAllocator>*,0>(v11, v9, v150, v11 + 3, a2 - 1);
    default:
      JUMPOUT(0);
  }
  return result;
}

void sub_1A1AAABCC(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if ((*v1)-- == 1)
    {
      BOOL v4 = (std::__shared_weak_count *)v1[3];
      if (v4)
      {
        if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
      uint64_t v5 = mdm::Allocator::instance((mdm::Allocator *)exception_object);
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v5 + 40))(v5, v1, 152);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t md::Logic<md::LabelsLogic,md::LabelsContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xA588623CD4116DAELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::LabelsLogic,md::LabelsContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>>::_runBeforeLayoutAtVariableRate(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xA588623CD4116DAELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 128))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::LabelsLogic,md::LabelsContext,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0xA588623CD4116DAELL)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      v7[0] = md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::resolveDependencies(**(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      v7[1] = v6;
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v7, v3);
    }
  }
  return result;
}

uint64_t md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::resolveDependencies(uint64_t a1, unint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xE42D19AFCA302E68;
    if (a2 <= 0xE42D19AFCA302E68) {
      unint64_t v3 = 0xE42D19AFCA302E68 % a2;
    }
  }
  else
  {
    unint64_t v3 = (a2 - 1) & 0xE42D19AFCA302E68;
  }
  uint64_t v5 = *(void **)(a1 + 8 * v3);
  if (!v5) {
    goto LABEL_25;
  }
  uint64_t v6 = (void *)*v5;
  if (!v6) {
    goto LABEL_25;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v8 = v6[1];
      if (v8 == 0xE42D19AFCA302E68)
      {
        if (v6[2] == 0xE42D19AFCA302E68) {
          goto LABEL_23;
        }
      }
      else if ((v8 & (a2 - 1)) != v3)
      {
        goto LABEL_25;
      }
      uint64_t v6 = (void *)*v6;
      if (!v6) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v6[1];
    if (v7 == 0xE42D19AFCA302E68) {
      break;
    }
    if (v7 >= a2) {
      v7 %= a2;
    }
    if (v7 != v3) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v6 = (void *)*v6;
    if (!v6) {
      goto LABEL_25;
    }
  }
  if (v6[2] != 0xE42D19AFCA302E68) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v9 = v6[5];
  if (*(void *)(v9 + 8) == 0xE42D19AFCA302E68)
  {
    uint64_t v10 = *(void *)(v9 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v10 = 0;
LABEL_26:
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v11 = 0xF014CCE28176CA44;
    if (a2 <= 0xF014CCE28176CA44) {
      unint64_t v11 = 0xF014CCE28176CA44 % a2;
    }
  }
  else
  {
    unint64_t v11 = (a2 - 1) & 0xF014CCE28176CA44;
  }
  uint64_t v12 = *(void **)(a1 + 8 * v11);
  if (!v12) {
    return v10;
  }
  unint64_t v13 = (void *)*v12;
  if (!v13) {
    return v10;
  }
  if (v2.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v15 = v13[1];
      if (v15 == 0xF014CCE28176CA44)
      {
        if (v13[2] == 0xF014CCE28176CA44) {
          goto LABEL_46;
        }
      }
      else if ((v15 & (a2 - 1)) != v11)
      {
        return v10;
      }
      unint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
    }
  }
  while (2)
  {
    unint64_t v14 = v13[1];
    if (v14 != 0xF014CCE28176CA44)
    {
      if (v14 >= a2) {
        v14 %= a2;
      }
      if (v14 != v11) {
        return v10;
      }
      goto LABEL_35;
    }
    if (v13[2] != 0xF014CCE28176CA44)
    {
LABEL_35:
      unint64_t v13 = (void *)*v13;
      if (!v13) {
        return v10;
      }
      continue;
    }
    break;
  }
LABEL_46:
  if (*(void *)(v13[5] + 8) == 0xF014CCE28176CA44) {
    return v10;
  }
  return v10;
}

uint64_t md::LabelsLogic::runBeforeLayout(uint64_t a1, md::LayoutContext *a2, void *a3, void *a4)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  v86[0] = &unk_1EF56D908;
  v86[1] = a2;
  v84[0] = &unk_1EF56D950;
  v84[1] = a2;
  uint64_t v85 = v84;
  uint64_t v89 = v88;
  unint64_t v87 = v86;
  v88[0] = &unk_1EF56D950;
  v88[1] = a2;
  std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0>,void ()(void)>::operator()((uint64_t)v86);
  if (v85 == v84)
  {
    (*(void (**)(void *))(v84[0] + 32))(v84);
  }
  else if (v85)
  {
    (*(void (**)(void))(*v85 + 40))();
  }
  if (v87 == v86)
  {
    (*(void (**)(void *))(v86[0] + 32))(v86);
  }
  else if (v87)
  {
    (*(void (**)(void))(*v87 + 40))();
  }
  uint64_t v8 = (void *)*((void *)a2 + 1);
  int8x8_t v9 = (int8x8_t)v8[1];
  if (!*(void *)&v9) {
    goto LABEL_36;
  }
  uint8x8_t v10 = (uint8x8_t)vcnt_s8(v9);
  v10.i16[0] = vaddlv_u8(v10);
  if (v10.u32[0] > 1uLL)
  {
    unint64_t v11 = 0xC97B9E962ADF4AD4;
    if (*(void *)&v9 <= 0xC97B9E962ADF4AD4) {
      unint64_t v11 = 0xC97B9E962ADF4AD4 % *(void *)&v9;
    }
  }
  else
  {
    unint64_t v11 = (*(void *)&v9 - 1) & 0xC97B9E962ADF4AD4;
  }
  uint64_t v12 = *(void **)(*v8 + 8 * v11);
  if (!v12) {
    goto LABEL_33;
  }
  unint64_t v13 = (void *)*v12;
  if (!v13) {
    goto LABEL_33;
  }
  if (v10.u32[0] < 2uLL)
  {
    uint64_t v14 = *(void *)&v9 - 1;
    do
    {
      uint64_t v16 = v13[1];
      if (v16 == 0xC97B9E962ADF4AD4)
      {
        if (v13[2] == 0xC97B9E962ADF4AD4) {
          goto LABEL_30;
        }
      }
      else if ((v16 & v14) != v11)
      {
        goto LABEL_33;
      }
      unint64_t v13 = (void *)*v13;
    }
    while (v13);
    int8x8_t v9 = 0;
LABEL_36:
    if (!*(unsigned char *)(a1 + 252)) {
      goto LABEL_37;
    }
    goto LABEL_58;
  }
  while (1)
  {
    unint64_t v15 = v13[1];
    if (v15 == 0xC97B9E962ADF4AD4) {
      break;
    }
    if (v15 >= *(void *)&v9) {
      v15 %= *(void *)&v9;
    }
    if (v15 != v11) {
      goto LABEL_33;
    }
LABEL_19:
    unint64_t v13 = (void *)*v13;
    if (!v13) {
      goto LABEL_33;
    }
  }
  if (v13[2] != 0xC97B9E962ADF4AD4) {
    goto LABEL_19;
  }
LABEL_30:
  uint64_t v17 = (int8x8_t *)v13[5];
  if (*(void *)&v17[1] != 0xC97B9E962ADF4AD4)
  {
LABEL_33:
    int8x8_t v9 = 0;
    if (*(unsigned char *)(a1 + 252)) {
      goto LABEL_58;
    }
LABEL_37:
    uint64_t v18 = **(void **)&v9;
    uint64_t v19 = *(void *)(*(void *)&v9 + 8);
    if (v18 != v19)
    {
      while (*(unsigned char *)v18 != 30)
      {
        v18 += 16;
        if (v18 == v19) {
          goto LABEL_43;
        }
      }
    }
    if (v18 == v19 || !*(void *)(v18 + 8))
    {
LABEL_43:
      if (*(double *)(a1 + 256) == 0.0)
      {
        if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
          dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
        }
        unint64_t v20 = (id)GEOGetVectorKitPerformanceLog_log;
        if (os_signpost_enabled(v20))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl(&dword_1A1780000, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LabelsLayoutWillWaitForDataLoad", "", buf, 2u);
        }

        *(void *)(a1 + 256) = *(void *)(md::LayoutContext::frameState(a2) + 88);
LABEL_50:
        if (!*(unsigned char *)(a1 + 252)) {
          goto LABEL_63;
        }
        goto LABEL_53;
      }
      if (*(double *)(md::LayoutContext::frameState(a2) + 88) - *(double *)(a1 + 256) < 1.0) {
        goto LABEL_50;
      }
    }
    *(unsigned char *)(a1 + 252) = 1;
LABEL_53:
    if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
    }
    uint64_t v21 = (id)GEOGetVectorKitPerformanceLog_log;
    if (os_signpost_enabled(v21))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl(&dword_1A1780000, v21, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LabelsLayoutCompletedWaitForDataLoad", "", buf, 2u);
    }

    if (*(unsigned char *)(a1 + 252)) {
      goto LABEL_58;
    }
    goto LABEL_63;
  }
  int8x8_t v9 = v17[4];
  if (!*(unsigned char *)(a1 + 252)) {
    goto LABEL_37;
  }
LABEL_58:
  char v22 = 0;
  uint64_t v23 = *(void *)(a1 + 160);
  atomic_compare_exchange_strong((atomic_uchar *volatile)(v23 + 3058), (unsigned __int8 *)&v22, 1u);
  if (!v22)
  {
    unsigned __int8 v24 = atomic_load((unsigned __int8 *)(v23 + 3058));
    if (v24)
    {
      uint64_t v25 = *(void *)(v23 + 136);
      if (v25)
      {
        uint64_t v26 = *(void *)(v25 + 56);
        if (v26)
        {
          *(void *)buf = v23;
          LOBYTE(v90) = 9;
          (*(void (**)(uint64_t, uint8_t *, long long *))(*(void *)v26 + 48))(v26, buf, &v90);
        }
      }
    }
  }
LABEL_63:
  uint64_t v27 = *a3;
  if (!*(unsigned char *)(*a3 + 82)) {
    goto LABEL_108;
  }
  unint64_t v83 = 0;
  unint64_t v28 = (gss::Allocator *)operator new(0x28uLL);
  *(void *)unint64_t v28 = &unk_1EF56D998;
  *((void *)v28 + 1) = v27;
  *((void *)v28 + 2) = a1;
  *((void *)v28 + 3) = v27;
  *((void *)v28 + 4) = v27 + 16;
  unint64_t v83 = v28;
  uint64_t v29 = *(uint8_t **)(v27 + 48);
  unsigned __int8 v30 = *(uint8_t **)(v27 + 56);
  if (v29 == v30) {
    goto LABEL_69;
  }
  while (2)
  {
    buf[0] = *v29;
    if (!v83)
    {
      std::__throw_bad_function_call[abi:nn180100]();
      goto LABEL_170;
    }
    (*(void (**)(gss::Allocator *, uint8_t *))(*(void *)v83 + 48))(v83, buf);
    if (++v29 != v30) {
      continue;
    }
    break;
  }
  unint64_t v28 = v83;
  if (v83 == (gss::Allocator *)v82)
  {
    unint64_t v28 = (gss::Allocator *)(*(uint64_t (**)(void *))(v82[0] + 32))(v82);
    uint64_t v31 = *(void *)(a1 + 232);
    if (!v31) {
      goto LABEL_71;
    }
  }
  else
  {
    if (v83) {
LABEL_69:
    }
      unint64_t v28 = (gss::Allocator *)(*(uint64_t (**)(gss::Allocator *))(*(void *)v28 + 40))(v28);
    uint64_t v31 = *(void *)(a1 + 232);
    if (!v31)
    {
LABEL_71:
      uint64_t v32 = gss::Allocator::instance(v28);
      uint64_t v92 = (long long *)v32;
      uint64_t v33 = (void *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v32 + 16))(v32, 16, 4);
      unint64_t v34 = v33;
      *(void *)&long long v90 = v33;
      uint64_t v91 = v33 + 2;
      if (v33) {
        *uint64_t v33 = 0xE00000005;
      }
      v33[1] = 65594;
      *((void *)&v90 + 1) = v33 + 2;
      gss::FeatureAttributeSet::FeatureAttributeSet((gss::FeatureAttributeSet *)buf, (uint64_t)&v90);
      (*(void (**)(uint64_t, void *, uint64_t))(*(void *)v32 + 40))(v32, v34, 16);
      uint64_t v35 = *(void *)v27;
      *(void *)((char *)&v90 + 7) = 0;
      *(void *)&long long v90 = 0;
      HIBYTE(v90) = 1;
      gss::StylesheetManager<gss::PropertyID>::styleQueryForFeatureAttributes((uint64_t **)&v75, v35, (gss::FeatureAttributeSet *)buf, (gss::QueryOverrides *)&v90);
      long long v36 = v75;
      uint64_t v37 = *(std::__shared_weak_count **)(a1 + 240);
      long long v75 = 0uLL;
      *(_OWORD *)(a1 + 232) = v36;
      if (v37 && !atomic_fetch_add(&v37->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v37->__on_zero_shared)(v37);
        std::__shared_weak_count::__release_weak(v37);
      }
      unint64_t v38 = (std::__shared_weak_count *)*((void *)&v75 + 1);
      if (*((void *)&v75 + 1)
        && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v75 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
        std::__shared_weak_count::__release_weak(v38);
      }
      if (*(void *)buf)
      {
        float32x2_t v78 = *(md::LabelManager **)buf;
        (*(void (**)(uint8_t *, void, uint64_t))(*(void *)v80 + 40))(v80, *(void *)buf, v79 - *(void *)buf);
      }
      uint64_t v31 = *(void *)(a1 + 232);
    }
  }
  uint64_t v39 = *(std::__shared_weak_count **)(a1 + 240);
  *(void *)&long long v90 = v31;
  *((void *)&v90 + 1) = v39;
  if (v39) {
    atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  gss::QueryableLocker<gss::PropertyID>::QueryableLocker((uint64_t *)buf, v31, (uint64_t)v39);
  if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
    std::__shared_weak_count::__release_weak(v39);
    if (v81) {
      goto LABEL_88;
    }
  }
  else if (v81)
  {
LABEL_88:
    float v40 = *(float *)(md::LayoutContext::frameState(a2) + 112);
    float v41 = *(float *)(a1 + 248);
    char v76 = 1;
    unint64_t v42 = *(void *)(*(void *)buf + 24);
    float v43 = fminf(fmaxf(v40, 0.0), 23.0);
    unint64_t v44 = *(float **)v42;
    if (*(void *)v42
      && (float v45 = *v44, LODWORD(v44) = *v44 == 1.0, *(unsigned char *)(v42 + 10))
      && (v45 != 0.0 ? (BOOL v46 = v45 == 1.0) : (BOOL v46 = 1), !v46)
      || (v47 = *(unsigned __int8 *)(v42 + v44 + 11), float v45 = 0.0, v47 == 2))
    {
      LOBYTE(v90) = 1;
      LOBYTE(v75) = 1;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v42, 0xFAu, 0, (BOOL *)&v90, v43);
      float v49 = v48;
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(v42, 0xFAu, 1u, (BOOL *)&v75, v43);
      BOOL v50 = (v90 | v75) != 0;
      float v52 = v49 + (float)((float)(v51 - v49) * v45);
    }
    else
    {
      gss::RenderStyle<gss::PropertyID>::styleSampledValueForKeyAtZ<float>(*(void *)(*(void *)buf + 24), 0xFAu, v47, (BOOL *)&v76, v43);
      BOOL v50 = v76;
    }
    if (!v50) {
      float v52 = v41;
    }
    *(float *)(a1 + 248) = v52;
    if (v52 != v41)
    {
      uint64_t v53 = *(md::LabelManager **)(*(void *)(*(void *)(a1 + 144) + 8) + 24);
      *(void *)&long long v90 = &unk_1EF56EA30;
      *((void *)&v90 + 1) = v53;
      uint64_t v91 = (void *)LODWORD(v52);
      uint64_t v92 = &v90;
      md::LabelManager::queueCommand(v53, 36, 1, &v90);
      if (v92 == &v90)
      {
        (*(void (**)(long long *))(v90 + 32))(&v90);
      }
      else if (v92)
      {
        (*(void (**)(void))(*(void *)v92 + 40))();
      }
    }
  }
  gss::QueryableLocker<gss::PropertyID>::~QueryableLocker((uint64_t)buf);
LABEL_108:
  uint64_t v54 = *(void *)(a1 + 160);
  uint64_t v55 = *(unsigned int *)(a1 + 220);
  if (*(_DWORD *)(v54 + 3548) != v55)
  {
    *(_DWORD *)(v54 + 3548) = v55;
    *(void *)buf = &unk_1EF56DEA8;
    float32x2_t v78 = (md::LabelManager *)v54;
    uint64_t v79 = v55;
    uint64_t v80 = buf;
    md::LabelManager::queueCommand((md::LabelManager *)v54, 6, 0, buf);
    if (v80 == buf)
    {
      (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
    }
    else if (v80)
    {
      (*(void (**)(void))(*(void *)v80 + 40))();
    }
    uint64_t v54 = *(void *)(a1 + 160);
  }
  uint64_t v56 = *(unsigned __int8 *)(a1 + 224);
  if (*(unsigned __int8 *)(v54 + 3552) != v56)
  {
    *(unsigned char *)(v54 + 3552) = v56;
    *(void *)buf = &unk_1EF56E0A0;
    float32x2_t v78 = (md::LabelManager *)v54;
    uint64_t v79 = v56;
    uint64_t v80 = buf;
    md::LabelManager::queueCommand((md::LabelManager *)v54, 68, 1, buf);
    if (v80 == buf)
    {
      (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
    }
    else if (v80)
    {
      (*(void (**)(void))(*(void *)v80 + 40))();
    }
    uint64_t v54 = *(void *)(a1 + 160);
  }
  uint64_t v57 = *(unsigned __int8 *)(v27 + 92);
  if (*(unsigned __int8 *)(v54 + 3555) != v57)
  {
    *(unsigned char *)(v54 + 3555) = v57;
    *(void *)buf = &unk_1EF56DF38;
    float32x2_t v78 = (md::LabelManager *)v54;
    uint64_t v79 = v57;
    uint64_t v80 = buf;
    md::LabelManager::queueCommand((md::LabelManager *)v54, 47, 1, buf);
    if (v80 == buf)
    {
      (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
    }
    else if (v80)
    {
      (*(void (**)(void))(*(void *)v80 + 40))();
    }
    uint64_t v54 = *(void *)(a1 + 160);
  }
  uint64_t v58 = *(unsigned __int8 *)(v27 + 93);
  if (*(unsigned __int8 *)(v54 + 3556) == v58)
  {
LABEL_130:
    uint64_t v59 = a3[1];
    if (!v59) {
      goto LABEL_138;
    }
    goto LABEL_131;
  }
  *(unsigned char *)(v54 + 3556) = v58;
  *(void *)buf = &unk_1EF56E178;
  float32x2_t v78 = (md::LabelManager *)v54;
  uint64_t v79 = v58;
  uint64_t v80 = buf;
  md::LabelManager::queueCommand((md::LabelManager *)v54, 66, 1, buf);
  if (v80 != buf)
  {
    if (v80) {
      (*(void (**)(void))(*(void *)v80 + 40))();
    }
    goto LABEL_130;
  }
  (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
  uint64_t v59 = a3[1];
  if (v59)
  {
LABEL_131:
    if (*(unsigned char *)(v59 + 40))
    {
      uint64_t v60 = *(md::LabelManager **)(a1 + 160);
      *(void *)buf = &unk_1EF56EB08;
      float32x2_t v78 = v60;
      uint64_t v80 = buf;
      md::LabelManager::queueCommand(v60, 20, 1, buf);
      if (v80 == buf)
      {
        (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
      }
      else if (v80)
      {
        (*(void (**)(void))(*(void *)v80 + 40))();
      }
    }
  }
LABEL_138:
  int v61 = *(unsigned __int8 *)(v27 + 96);
  int v62 = v61 == 1;
  uint64_t v63 = *(md::LabelManager **)(a1 + 160);
  if (*((unsigned __int8 *)v63 + 3554) != v62)
  {
    *((unsigned char *)v63 + 3554) = v62;
    *(void *)buf = &unk_1EF56DEF0;
    float32x2_t v78 = v63;
    uint64_t v79 = v61 == 1;
    uint64_t v80 = buf;
    md::LabelManager::queueCommand(v63, 45, 1, buf);
    if (v80 == buf)
    {
      (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
    }
    else if (v80)
    {
      (*(void (**)(void))(*(void *)v80 + 40))();
    }
  }
  uint64_t v64 = *(void *)(**(void **)(a1 + 144) + 40);
  uint64_t v65 = *(void *)(v64 + 304);
  *(void *)&long long v66 = *(void *)(v64 + 296);
  *((void *)&v66 + 1) = v65;
  if (v65) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v65 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v67 = *(std::__shared_weak_count **)(a1 + 128);
  *(_OWORD *)(a1 + 120) = v66;
  if (v67 && !atomic_fetch_add(&v67->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v67->__on_zero_shared)(v67);
    std::__shared_weak_count::__release_weak(v67);
  }
  float v68 = *(unsigned __int8 **)(a1 + 160);
  int v69 = v68[3553];
  if (*(unsigned char *)(v27 + 84) == 3) {
    int v70 = 2;
  }
  else {
    int v70 = 1;
  }
  *(void *)(a1 + 136) = v68;
  if (v69 != v70)
  {
    v68[3553] = v70;
    *(void *)buf = &unk_1EF56E058;
    float32x2_t v78 = (md::LabelManager *)v68;
    uint64_t v79 = v70;
    uint64_t v80 = buf;
    md::LabelManager::queueCommand((md::LabelManager *)v68, 7, 1, buf);
    if (v80 == buf)
    {
      (*(void (**)(uint8_t *))(*(void *)buf + 32))(buf);
    }
    else if (v80)
    {
      (*(void (**)(void))(*(void *)v80 + 40))();
    }
    float v68 = *(unsigned __int8 **)(a1 + 160);
  }
  md::LabelManager::synchWithHomeQueue((md::LabelManager *)v68, a2);
  uint64_t v72 = *(void *)(a1 + 120);
  uint64_t v71 = *(void *)(a1 + 128);
  if (v71) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v71 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v73 = (std::__shared_weak_count *)a4[1];
  *a4 = v72;
  a4[1] = v71;
  if (v73 && !atomic_fetch_add(&v73->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v73->__on_zero_shared)(v73);
    std::__shared_weak_count::__release_weak(v73);
  }
  a4[2] = *(void *)(a1 + 136);
  if (!v89)
  {
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_170:
    __break(1u);
  }
  (*(void (**)(void *))(*v89 + 48))(v89);
  uint64_t result = (uint64_t)v89;
  if (v89 == v88) {
    return (*(uint64_t (**)(void *))(v88[0] + 32))(v88);
  }
  if (v89) {
    return (*(uint64_t (**)(void))(*v89 + 40))();
  }
  return result;
}

void sub_1A1AAC07C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30)
{
  gss::QueryOverrides::~QueryOverrides((gss::QueryOverrides *)(v30 - 136));
  if (a13) {
    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a16 + 40))(a16, a13, a15 - a13);
  }
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)&a30);
  _Unwind_Resume(a1);
}

void *md::LabelManager::synchWithHomeQueue(md::LabelManager *this, const md::LayoutContext *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  v20[0] = &unk_1EF56E6D0;
  uint64_t v21 = v20;
  v18[0] = &unk_1EF56E718;
  uint64_t v19 = v18;
  uint64_t v23 = v22;
  v22[0] = &unk_1EF56E718;
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  BOOL v4 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v4))
  {
    *(_WORD *)uint64_t v17 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v4, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "LabelsSynchWithHome", "", v17, 2u);
  }

  if (v19 == v18)
  {
    (*(void (**)(void *))(v18[0] + 32))(v18);
  }
  else if (v19)
  {
    (*(void (**)(void))(*v19 + 40))();
  }
  if (v21 == v20)
  {
    (*(void (**)(void *))(v20[0] + 32))(v20);
    if (!a2) {
      goto LABEL_38;
    }
  }
  else
  {
    if (v21) {
      (*(void (**)(void))(*v21 + 40))();
    }
    if (!a2) {
      goto LABEL_38;
    }
  }
  uint64_t v5 = (void *)*((void *)a2 + 1);
  int8x8_t v6 = (int8x8_t)v5[1];
  if (!*(void *)&v6) {
    goto LABEL_38;
  }
  uint8x8_t v7 = (uint8x8_t)vcnt_s8(v6);
  v7.i16[0] = vaddlv_u8(v7);
  if (v7.u32[0] > 1uLL)
  {
    uint64_t v8 = 0x4927EB92E562CC46;
    if (*(void *)&v6 <= 0x4927EB92E562CC46uLL) {
      uint64_t v8 = 0x4927EB92E562CC46uLL % *(void *)&v6;
    }
  }
  else
  {
    uint64_t v8 = (*(void *)&v6 - 1) & 0x4927EB92E562CC46;
  }
  int8x8_t v9 = *(void **)(*v5 + 8 * v8);
  if (!v9) {
    goto LABEL_38;
  }
  uint8x8_t v10 = (void *)*v9;
  if (!v10) {
    goto LABEL_38;
  }
  if (v7.u32[0] < 2uLL)
  {
    uint64_t v11 = *(void *)&v6 - 1;
    while (1)
    {
      uint64_t v13 = v10[1];
      if (v13 == 0x4927EB92E562CC46)
      {
        if (v10[2] == 0x4927EB92E562CC46) {
          goto LABEL_36;
        }
      }
      else if ((v13 & v11) != v8)
      {
        goto LABEL_38;
      }
      uint8x8_t v10 = (void *)*v10;
      if (!v10) {
        goto LABEL_38;
      }
    }
  }
  while (1)
  {
    unint64_t v12 = v10[1];
    if (v12 == 0x4927EB92E562CC46) {
      break;
    }
    if (v12 >= *(void *)&v6) {
      v12 %= *(void *)&v6;
    }
    if (v12 != v8) {
      goto LABEL_38;
    }
LABEL_25:
    uint8x8_t v10 = (void *)*v10;
    if (!v10) {
      goto LABEL_38;
    }
  }
  if (v10[2] != 0x4927EB92E562CC46) {
    goto LABEL_25;
  }
LABEL_36:
  uint64_t v14 = v10[5];
  if (*(void *)(v14 + 8) == 0x4927EB92E562CC46)
  {
    uint64_t v15 = *(void *)(v14 + 32);
    goto LABEL_39;
  }
LABEL_38:
  uint64_t v15 = 0;
LABEL_39:
  *((void *)this + 209) = v15;
  (*(void (**)(void))(**((void **)this + 30) + 16))(*((void *)this + 30));
  if (!v23)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  (*(void (**)(void *))(*v23 + 48))(v23);
  uint64_t result = v23;
  if (v23 == v22) {
    return (void *)(*(uint64_t (**)(void *))(v22[0] + 32))(v22);
  }
  if (v23) {
    return (void *)(*(uint64_t (**)(void))(*v23 + 40))();
  }
  return result;
}

void sub_1A1AAC6E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)va);
  _Unwind_Resume(a1);
}

void sub_1A1AAC6F4(_Unwind_Exception *exception_object)
{
}

void sub_1A1AAC700(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t *a21)
{
  if (a21 == &a18)
  {
    (*(void (**)(uint64_t *))(a18 + 32))(&a18);
    _Unwind_Resume(exception_object);
  }
  if (!a21) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(void))(*a21 + 40))();
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_1,std::allocator<md::LabelManager::synchWithHomeQueue(md::LayoutContext const*)::$_1>,void ()(void)>::operator()()
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v0 = (id)GEOGetVectorKitPerformanceLog_log;
  if (os_signpost_enabled(v0))
  {
    *(_WORD *)uint64_t v1 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v0, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "LabelsSynchWithHome", "", v1, 2u);
  }
}

uint64_t md::CompositeLabeler::synchWithHomeQueue(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 8);
  for (uint64_t i = *(uint64_t **)(this + 16); v1 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 16))(v3))
    uint64_t v3 = *v1++;
  return this;
}

void md::StandardLabeler::synchWithHomeQueue(md::StandardLabeler *this)
{
  uint64_t v1 = (md::LabelCustomFeatureSupport *)*((void *)this + 4);
  md::LabelCustomFeatureSupport::flushQueuedCommands(v1);
  uint8x8_t v2 = (void *)*((void *)v1 + 9);
  if (v2 != (void *)((char *)v1 + 80))
  {
    do
    {
      uint64_t v3 = v2[26];
      if (v3 != v2[27])
      {
        unint64_t v4 = 0;
        do
        {
          long long v6 = *(_OWORD *)(v3 + 16 * v4);
          uint8x8_t v7 = *(std::__shared_weak_count **)(v3 + 16 * v4 + 8);
          if (v7) {
            atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v8 = *(void *)(v6 + 32);
          if (!v8)
          {
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
            return;
          }
          (*(void (**)(uint64_t))(*(void *)v8 + 48))(v8);
          if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
            std::__shared_weak_count::__release_weak(v7);
          }
          ++v4;
          uint64_t v3 = v2[26];
          uint64_t v5 = v2[27];
        }
        while (v4 < (v5 - v3) >> 4);
        while (v5 != v3)
        {
          int8x8_t v9 = *(std::__shared_weak_count **)(v5 - 8);
          if (v9)
          {
            if (!atomic_fetch_add(&v9->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v9->__on_zero_shared)(v9);
              std::__shared_weak_count::__release_weak(v9);
            }
          }
          v5 -= 16;
        }
        v2[27] = v3;
      }
      uint8x8_t v10 = (void *)v2[1];
      if (v10)
      {
        do
        {
          uint64_t v11 = v10;
          uint8x8_t v10 = (void *)*v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          uint64_t v11 = (void *)v2[2];
          BOOL v12 = *v11 == (void)v2;
          uint8x8_t v2 = v11;
        }
        while (!v12);
      }
      uint8x8_t v2 = v11;
    }
    while (v11 != (void *)((char *)v1 + 80));
  }
  md::LabelCustomFeatureSupport::flushQueuedCommands(v1);
}

void sub_1A1AACA48(_Unwind_Exception *exception_object)
{
  if (v1)
  {
    if (!atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

void md::LabelCustomFeatureSupport::flushQueuedCommands(md::LabelCustomFeatureSupport *this)
{
  uint64_t v1 = *((void *)this + 5);
  if (v1 != *((void *)this + 6))
  {
    unint64_t v3 = 0;
    do
    {
      long long v5 = *(_OWORD *)(v1 + 16 * v3);
      long long v6 = *(std::__shared_weak_count **)(v1 + 16 * v3 + 8);
      if (*((void *)&v5 + 1)) {
        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v5 + 1) + 8), 1uLL, memory_order_relaxed);
      }
      uint64_t v7 = *(void *)(v5 + 32);
      if (!v7)
      {
        std::__throw_bad_function_call[abi:nn180100]();
        __break(1u);
        return;
      }
      (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
      if (v6 && !atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
        std::__shared_weak_count::__release_weak(v6);
      }
      ++v3;
      uint64_t v1 = *((void *)this + 5);
      uint64_t v4 = *((void *)this + 6);
    }
    while (v3 < (v4 - v1) >> 4);
    for (; v4 != v1; v4 -= 16)
    {
      uint64_t v8 = *(std::__shared_weak_count **)(v4 - 8);
      if (v8)
      {
        if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
          std::__shared_weak_count::__release_weak(v8);
        }
      }
    }
    *((void *)this + 6) = v1;
  }
}

void sub_1A1AACC08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_1,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint8x8_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)long long v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "LabelsLogic", "", v5, 2u);
  }
}

void std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint8x8_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  unint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)long long v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "LabelsLogic", "", v5, 2u);
  }
}

void std::__function::__func<md::LabelCustomFeatureSupport::populateLabelFeaturesInTile(md::LabelMapTile *)::$_0,std::allocator<md::LabelCustomFeatureSupport::populateLabelFeaturesInTile(md::LabelMapTile *)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint8x8_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

uint64_t std::__shared_ptr_emplace<md::LabelFeatureSupportCommand>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  uint64_t result = *(void *)(a1 + 56);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void **std::__function::__func<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_2,std::allocator<md::LabelsLogic::runBeforeLayout(md::LayoutContext const&,md::LogicDependencies<gdc::TypeList<md::StyleLogicContext>,gdc::TypeList<md::MeshRenderableContext>>::ResolvedDependencies const&,md::LabelsContext &)::$_2>,void ()(md::StyleManagerEvent)>::operator()(void **result, unsigned char *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  uint8x8_t v2 = result;
  unint64_t v3 = result[2];
  switch(*a2)
  {
    case 0:
    case 4:
      os_signpost_id_t v4 = (std::__shared_weak_count *)*((void *)v3 + 30);
      *((void *)v3 + 29) = 0;
      *((void *)v3 + 30) = 0;
      if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
      md::LabelManager::setStyleManager(*((md::LabelManager **)v3 + 20), *(void *)v2[3], *((void *)v2[3] + 1));
      md::LabelManager::setSceneManager(*((md::LabelManager **)v3 + 20), *(void *)v2[4], *((std::__shared_weak_count **)v2[4] + 1));
      long long v5 = (md::LabelManager *)*((void *)v3 + 20);
      uint64_t v19 = (void (**)(void **))&unk_1EF56E910;
      unint64_t v20 = v5;
      char v22 = (void **)&v19;
      md::LabelManager::queueCommand(v5, 29, 1, &v19);
      goto LABEL_23;
    case 1:
      long long v6 = result[1];
      char v7 = v6[80];
      uint64_t v8 = *((void *)v3 + 20);
      uint64_t v9 = *((void *)v6 + 9);
      if (v7)
      {
        uint64_t v19 = (void (**)(void **))&unk_1EF56F018;
        unint64_t v20 = (md::LabelManager *)v8;
        uint64_t v21 = v9;
        char v22 = (void **)&v19;
        md::LabelManager::queueCommand((md::LabelManager *)v8, 27, 0, &v19);
        if (v22 == (void **)&v19)
        {
          v19[4]((void **)&v19);
        }
        else if (v22)
        {
          (*((void (**)(void))*v22 + 5))();
        }
        uint64_t v8 = *((void *)v3 + 20);
        uint64_t v9 = *((void *)v2[1] + 9);
      }
      else
      {
        *(unsigned char *)(v8 + 3380) = 1;
        *(unsigned char *)(v8 + 3043) = 1;
        *(unsigned char *)(v8 + 3045) = 1;
        *(unsigned char *)(v8 + 3047) = 1;
        unsigned __int8 v14 = atomic_load((unsigned __int8 *)(v8 + 3058));
        if (v14)
        {
          uint64_t v15 = *(void *)(v8 + 136);
          if (v15)
          {
            uint64_t v16 = *(void *)(v15 + 56);
            if (v16)
            {
              uint64_t v19 = (void (**)(void **))v8;
              char v18 = 9;
              (*(void (**)(uint64_t, void (***)(void **), char *))(*(void *)v16 + 48))(v16, &v19, &v18);
            }
          }
        }
        *(_WORD *)(v8 + 3381) = 1;
      }
      uint64_t v17 = operator new(0x20uLL);
      *uint64_t v17 = &unk_1EF56EE68;
      v17[1] = v8;
      v17[2] = v9;
      *((unsigned char *)v17 + 24) = v7;
      char v22 = (void **)v17;
      md::LabelManager::queueCommand((md::LabelManager *)v8, 28, 0, &v19);
      goto LABEL_23;
    case 2:
      uint64_t v10 = *((void *)v3 + 20);
      unsigned __int8 v11 = atomic_load((unsigned __int8 *)(v10 + 3058));
      if (v11)
      {
        uint64_t v12 = *(void *)(v10 + 136);
        if (v12)
        {
          uint64_t result = *(void ***)(v12 + 56);
          if (result)
          {
            uint64_t v19 = (void (**)(void **))*((void *)v3 + 20);
            char v18 = 9;
            return (void **)(*((uint64_t (**)(void **, void (***)(void **), char *))*result + 6))(result, &v19, &v18);
          }
        }
      }
      return result;
    case 3:
      uint64_t v13 = (md::LabelManager *)*((void *)v3 + 20);
      uint64_t v19 = (void (**)(void **))&unk_1EF56ECB8;
      unint64_t v20 = v13;
      char v22 = (void **)&v19;
      md::LabelManager::queueCommand(v13, 30, 0, &v19);
LABEL_23:
      uint64_t result = v22;
      if (v22 == (void **)&v19)
      {
        uint64_t result = (void **)((uint64_t (*)(void **))v19[4])((void **)&v19);
      }
      else if (v22)
      {
        uint64_t result = (void **)(*((uint64_t (**)(void))*v22 + 5))();
      }
      break;
    default:
      return result;
  }
  return result;
}

void sub_1A1AAD234(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void md::LabelManager::queueCommand(md::LabelManager *this, int a2, int a3, void *a4)
{
  if (*((void *)this + 23)) {
    BOOL v8 = a2 == 21;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8 && a2 != 2)
  {
    md::LabelManager::flushCommands(this);
    uint64_t v14 = a4[3];
    if (!v14)
    {
      std::__throw_bad_function_call[abi:nn180100]();
      float v45 = v44;
      std::__shared_weak_count::~__shared_weak_count(v5);
      operator delete(v46);
      std::mutex::unlock(v4);
      _Unwind_Resume(v45);
    }
    uint64_t v15 = *(void (**)(void))(*(void *)v14 + 48);
    v15();
    return;
  }
  std::mutex::lock((std::mutex *)((char *)this + 3176));
  if (a3 == 1)
  {
    uint64_t v12 = (unsigned __int8 **)*((void *)this + 405);
    uint64_t v13 = (unsigned __int8 **)*((void *)this + 406);
    if (v12 != v13)
    {
      while (**v12 != a2)
      {
        v12 += 2;
        if (v12 == v13) {
          goto LABEL_35;
        }
      }
      if (v12 != v13)
      {
        uint64_t v16 = v12 + 2;
        if (v12 + 2 != v13)
        {
          do
          {
            uint64_t v17 = *v16;
            if (**v16 != a2)
            {
              char v18 = v16[1];
              *uint64_t v16 = 0;
              v16[1] = 0;
              uint64_t v19 = (std::__shared_weak_count *)v12[1];
              *uint64_t v12 = v17;
              v12[1] = v18;
              if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
                std::__shared_weak_count::__release_weak(v19);
              }
              v12 += 2;
            }
            v16 += 2;
          }
          while (v16 != v13);
          uint64_t v13 = (unsigned __int8 **)*((void *)this + 406);
        }
      }
      if (v12 != v13)
      {
        do
        {
          unint64_t v20 = (std::__shared_weak_count *)*(v13 - 1);
          if (v20 && !atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
          v13 -= 2;
        }
        while (v13 != v12);
        *((void *)this + 406) = v12;
      }
    }
  }
LABEL_35:
  uint64_t v21 = (std::__shared_weak_count *)operator new(0x40uLL);
  v21->__shared_owners_ = 0;
  v21->__shared_weak_owners_ = 0;
  v21->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF580CD0;
  LOBYTE(v21[1].__vftable) = a2;
  uint64_t v22 = a4[3];
  if (!v22) {
    goto LABEL_38;
  }
  if ((void *)v22 != a4)
  {
    uint64_t v22 = (*(uint64_t (**)(uint64_t))(*(void *)v22 + 16))(v22);
LABEL_38:
    v21[2].__shared_owners_ = v22;
    goto LABEL_40;
  }
  v21[2].__shared_owners_ = (uint64_t)&v21[1].__shared_owners_;
  (*(void (**)(void *))(*a4 + 24))(a4);
LABEL_40:
  *(void *)&long long v47 = v21 + 1;
  *((void *)&v47 + 1) = v21;
  uint64_t v23 = (void *)*((void *)this + 406);
  unint64_t v24 = *((void *)this + 407);
  if ((unint64_t)v23 >= v24)
  {
    uint64_t v25 = *((void *)this + 405);
    uint64_t v26 = ((uint64_t)v23 - v25) >> 4;
    unint64_t v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 60) {
      abort();
    }
    uint64_t v28 = v24 - v25;
    if (v28 >> 3 > v27) {
      unint64_t v27 = v28 >> 3;
    }
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0) {
      uint64_t v29 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v29 = v27;
    }
    if (v29)
    {
      uint64_t v30 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 408) + 16))(*((void *)this + 408), 16 * v29, 8);
      uint64_t v31 = (_OWORD *)(v30 + 16 * v26);
      uint64_t v32 = v30 + 16 * v29;
      if (v30)
      {
        *uint64_t v31 = v47;
        long long v47 = 0uLL;
      }
    }
    else
    {
      uint64_t v32 = 0;
      uint64_t v31 = (_OWORD *)(16 * v26);
    }
    uint64_t v33 = v31 + 1;
    unint64_t v34 = (void *)*((void *)this + 406);
    uint64_t v35 = (void *)*((void *)this + 405);
    if (v34 == v35)
    {
      *((void *)this + 405) = v31;
      *((void *)this + 406) = v33;
      uint64_t v38 = *((void *)this + 407);
      *((void *)this + 407) = v32;
    }
    else
    {
      do
      {
        long long v36 = *((_OWORD *)v34 - 1);
        v34 -= 2;
        *--uint64_t v31 = v36;
        *unint64_t v34 = 0;
        v34[1] = 0;
      }
      while (v34 != v35);
      unint64_t v34 = (void *)*((void *)this + 405);
      uint64_t v37 = (void *)*((void *)this + 406);
      *((void *)this + 405) = v31;
      *((void *)this + 406) = v33;
      uint64_t v38 = *((void *)this + 407);
      for (*((void *)this + 407) = v32; v37 != v34; v37 -= 2)
      {
        uint64_t v39 = (std::__shared_weak_count *)*(v37 - 1);
        if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v39);
        }
      }
    }
    if (v34) {
      (*(void (**)(void, void *, uint64_t))(**((void **)this + 408) + 40))(*((void *)this + 408), v34, v38 - (void)v34);
    }
    uint64_t v21 = (std::__shared_weak_count *)*((void *)&v47 + 1);
    *((void *)this + 406) = v33;
    if (!v21) {
      goto LABEL_69;
    }
  }
  else
  {
    if (v23)
    {
      *uint64_t v23 = v21 + 1;
      v23[1] = v21;
      long long v47 = 0uLL;
      uint64_t v21 = 0;
    }
    *((void *)this + 406) = v23 + 2;
    if (!v21) {
      goto LABEL_69;
    }
  }
  if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
LABEL_69:
  unint64_t v40 = *((void *)this + 406) - *((void *)this + 405);
  atomic_store(0, (unsigned __int8 *)this + 3390);
  std::mutex::unlock((std::mutex *)((char *)this + 3176));
  unsigned __int8 v41 = atomic_load((unsigned __int8 *)this + 3058);
  if (v41)
  {
    uint64_t v42 = *((void *)this + 17);
    if (v42)
    {
      uint64_t v43 = *(void *)(v42 + 56);
      if (v43)
      {
        *(void *)&long long v47 = this;
        char v48 = 9;
        (*(void (**)(uint64_t, long long *, char *))(*(void *)v43 + 48))(v43, &v47, &v48);
      }
    }
  }
  if (v40 >= 0x191
    && !*((unsigned char *)this + 3055)
    && !*((unsigned char *)this + 3385)
    && !*((unsigned char *)this + 3384)
    && std::recursive_mutex::try_lock((std::recursive_mutex *)((char *)this + 24)))
  {
    md::LabelManager::flushCommands(this);
    std::recursive_mutex::unlock((std::recursive_mutex *)((char *)this + 24));
  }
}

void md::LabelManager::flushCommands(md::LabelManager *this)
{
  unsigned __int8 v1 = atomic_load((unsigned __int8 *)this + 3390);
  if ((v1 & 1) == 0)
  {
    uint8x8_t v2 = this;
    unint64_t v3 = &md::SignedDistanceFieldGenerator::_hypotCache[32854];
    {
LABEL_18:
        operator new();
    }
    uint64_t v4 = *((void *)v3 + 91);
    std::mutex::lock((std::mutex *)((char *)v2 + 3176));
    unint64_t v3 = (float *)*((void *)v2 + 405);
    long long v5 = (md::LabelManager *)*((void *)v2 + 406);
    *(_OWORD *)((char *)v2 + 3240) = 0u;
    uint64_t v6 = *((void *)v2 + 407);
    *((void *)v2 + 407) = 0;
    atomic_store(1u, (unsigned __int8 *)v2 + 3390);
    std::mutex::unlock((std::mutex *)((char *)v2 + 3176));
    if (v3 == (float *)v5)
    {
      if (!v3) {
        return;
      }
    }
    else
    {
      uint8x8_t v2 = (md::LabelManager *)v3;
      do
      {
        uint64_t v7 = *(void *)(*(void *)v2 + 32);
        if (!v7)
        {
          std::__throw_bad_function_call[abi:nn180100]();
          __break(1u);
          goto LABEL_18;
        }
        (*(void (**)(uint64_t))(*(void *)v7 + 48))(v7);
        uint8x8_t v2 = (md::LabelManager *)((char *)v2 + 16);
      }
      while (v2 != v5);
      if (!v3) {
        return;
      }
      do
      {
        BOOL v8 = (std::__shared_weak_count *)*((void *)v5 - 1);
        if (v8)
        {
          if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
            std::__shared_weak_count::__release_weak(v8);
          }
        }
        long long v5 = (md::LabelManager *)((char *)v5 - 16);
      }
      while (v5 != (md::LabelManager *)v3);
    }
    (*(void (**)(uint64_t, float *, uint64_t))(*(void *)v4 + 40))(v4, v3, v6 - (void)v3);
  }
}

void sub_1A1AADA6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

uint64_t std::__shared_ptr_emplace<md::LabelManagerCommand>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  uint64_t result = *(void *)(a1 + 56);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void md::LabelCustomFeatureProvider::featuresDidChangeForRect(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 64);
  uint8x8_t v2 = (void *)(a1 + 72);
  if (v1 != (void *)(a1 + 72))
  {
    char v4 = 0;
    do
    {
      if (GEOMapRectIntersectsRect())
      {
        *((unsigned char *)v1 + 176) = 0;
        long long v5 = (uint64_t *)v1[15];
        uint64_t v6 = (uint64_t *)v1[16];
        if (v5 == v6) {
          goto LABEL_9;
        }
        char v7 = 0;
        do
        {
          uint64_t v8 = *v5++;
          BOOL v9 = *(unsigned char *)(v8 + 120) != 0;
          v7 |= v9;
          v4 |= v9;
          md::LabelCustomFeatureSupport::populateLabelFeaturesInTile(*(md::LabelCustomFeatureSupport **)a1, *(md::LabelMapTile **)(v8 + 72), *(std::__shared_weak_count **)(v8 + 80));
        }
        while (v5 != v6);
        if ((v7 & 1) == 0)
        {
LABEL_9:
          uint64_t v10 = (NSArray *)(id)v1[20];
          md::LabelCustomFeatureProvider::removeAnnotationsFromFeatureMap((md::LabelCustomFeatureProvider *)a1, v10, 0);

          unsigned __int8 v11 = (void *)v1[20];
          if (v11)
          {
            v1[20] = 0;
          }
        }
      }
      uint64_t v12 = (void *)v1[1];
      if (v12)
      {
        do
        {
          uint64_t v13 = v12;
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          uint64_t v13 = (void *)v1[2];
          BOOL v14 = *v13 == (void)v1;
          uint64_t v1 = v13;
        }
        while (!v14);
      }
      uint64_t v1 = v13;
    }
    while (v13 != v2);
    if (v4)
    {
      uint64_t v15 = *(void *)(a1 + 8);
      *(unsigned char *)(v15 + 3045) = 1;
      *(unsigned char *)(v15 + 3047) = 1;
      unsigned __int8 v16 = atomic_load((unsigned __int8 *)(v15 + 3058));
      if (v16)
      {
        uint64_t v17 = *(void *)(v15 + 136);
        if (v17)
        {
          uint64_t v18 = *(void *)(v17 + 56);
          if (v18)
          {
            uint64_t v20 = v15;
            char v19 = 9;
            (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v18 + 48))(v18, &v20, &v19);
          }
        }
      }
    }
  }
}

void sub_1A1AADCA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<md::LabelCustomFeatureSupport::addDataSource(objc_object  {objcproto25VKCustomFeatureDataSource}*)::$_0,std::allocator<objc_object  {objcproto25VKCustomFeatureDataSource}*>,void ()(void)>::destroy(uint64_t a1)
{
}

void md::LabelCustomFeatureSupport::populateLabelFeaturesInTile(md::LabelCustomFeatureSupport *this, md::LabelMapTile *a2, std::__shared_weak_count *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a3 || (long long v5 = std::__shared_weak_count::lock(a3)) == 0) {
    std::__throw_bad_weak_ptr[abi:nn180100]();
  }
  uint64_t v6 = v5;
  atomic_fetch_add_explicit(&v5->__shared_owners_, 1uLL, memory_order_relaxed);
  char v7 = operator new(0x20uLL);
  void *v7 = &unk_1EF5777A8;
  v7[1] = this;
  void v7[2] = a2;
  v7[3] = v6;
  uint64_t v13 = v7;
  md::LabelCustomFeatureSupport::queueCommand((uint64_t)this, 2, v12);
  if (v13 == v12)
  {
    (*(void (**)(void *))(v12[0] + 32))(v12);
  }
  else if (v13)
  {
    (*(void (**)(void *, uint64_t, uint64_t, uint64_t, uint64_t))(*v13 + 40))(v13, v8, v9, v10, v11);
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
}

void sub_1A1AADE40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14)
{
}

void md::LabelCustomFeatureSupport::queueCommand(uint64_t a1, char a2, void *a3)
{
  if (*(void *)(*(void *)(a1 + 16) + 184))
  {
    uint64_t v4 = a3[3];
    if (v4)
    {
      long long v5 = *(void (**)(void))(*(void *)v4 + 48);
      v5();
      return;
    }
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_47:
    abort();
  }
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = (std::__shared_weak_count *)operator new(0x40uLL);
  v10->__shared_owners_ = 0;
  v10->__shared_weak_owners_ = 0;
  v10->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581F68;
  LOBYTE(v10[1].__vftable) = a2;
  uint64_t v11 = a3[3];
  if (!v11) {
    goto LABEL_9;
  }
  if ((void *)v11 != a3)
  {
    uint64_t v11 = (*(uint64_t (**)(uint64_t))(*(void *)v11 + 16))(v11);
LABEL_9:
    v10[2].__shared_owners_ = v11;
    goto LABEL_11;
  }
  v10[2].__shared_owners_ = (uint64_t)&v10[1].__shared_owners_;
  (*(void (**)(void *))(*a3 + 24))(a3);
LABEL_11:
  *(void *)&long long v33 = v10 + 1;
  *((void *)&v33 + 1) = v10;
  uint64_t v12 = *(void **)(a1 + 48);
  unint64_t v13 = *(void *)(a1 + 56);
  if ((unint64_t)v12 >= v13)
  {
    uint64_t v14 = *(void *)(a1 + 40);
    uint64_t v15 = ((uint64_t)v12 - v14) >> 4;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 60) {
      goto LABEL_47;
    }
    uint64_t v17 = v13 - v14;
    if (v17 >> 3 > v16) {
      unint64_t v16 = v17 >> 3;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF0) {
      uint64_t v18 = 0xFFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v18 = v16;
    }
    if (v18)
    {
      uint64_t v19 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 64) + 16))(*(void *)(a1 + 64), 16 * v18, 8);
      uint64_t v20 = (_OWORD *)(v19 + 16 * v15);
      uint64_t v21 = v19 + 16 * v18;
      if (v19)
      {
        *uint64_t v20 = v33;
        long long v33 = 0uLL;
      }
    }
    else
    {
      uint64_t v21 = 0;
      uint64_t v20 = (_OWORD *)(16 * v15);
    }
    uint64_t v22 = v20 + 1;
    uint64_t v23 = *(void **)(a1 + 40);
    unint64_t v24 = *(void **)(a1 + 48);
    if (v24 == v23)
    {
      *(void *)(a1 + 40) = v20;
      *(void *)(a1 + 48) = v22;
      uint64_t v27 = *(void *)(a1 + 56);
      *(void *)(a1 + 56) = v21;
    }
    else
    {
      do
      {
        long long v25 = *((_OWORD *)v24 - 1);
        v24 -= 2;
        *--uint64_t v20 = v25;
        void *v24 = 0;
        v24[1] = 0;
      }
      while (v24 != v23);
      unint64_t v24 = *(void **)(a1 + 40);
      uint64_t v26 = *(void **)(a1 + 48);
      *(void *)(a1 + 40) = v20;
      *(void *)(a1 + 48) = v22;
      uint64_t v27 = *(void *)(a1 + 56);
      for (*(void *)(a1 + 56) = v21; v26 != v24; v26 -= 2)
      {
        uint64_t v28 = (std::__shared_weak_count *)*(v26 - 1);
        if (v28 && !atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
          std::__shared_weak_count::__release_weak(v28);
        }
      }
    }
    if (v24) {
      (*(void (**)(void, void *, uint64_t))(**(void **)(a1 + 64) + 40))(*(void *)(a1 + 64), v24, v27 - (void)v24);
    }
    uint64_t v10 = (std::__shared_weak_count *)*((void *)&v33 + 1);
    *(void *)(a1 + 48) = v22;
    if (!v10) {
      goto LABEL_39;
    }
  }
  else
  {
    if (v12)
    {
      *uint64_t v12 = v10 + 1;
      v12[1] = v10;
      long long v33 = 0uLL;
      uint64_t v10 = 0;
    }
    *(void *)(a1 + 48) = v12 + 2;
    if (!v10) {
      goto LABEL_39;
    }
  }
  if (!atomic_fetch_add(&v10->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v10->__on_zero_shared)(v10);
    std::__shared_weak_count::__release_weak(v10);
    if (v8 != v9) {
      return;
    }
    goto LABEL_40;
  }
LABEL_39:
  if (v8 != v9) {
    return;
  }
LABEL_40:
  uint64_t v29 = *(void *)(a1 + 16);
  unsigned __int8 v30 = atomic_load((unsigned __int8 *)(v29 + 3058));
  if (v30)
  {
    uint64_t v31 = *(void *)(v29 + 136);
    if (v31)
    {
      uint64_t v32 = *(void *)(v31 + 56);
      if (v32)
      {
        *(void *)&long long v33 = *(void *)(a1 + 16);
        char v34 = 9;
        (*(void (**)(uint64_t, long long *, char *))(*(void *)v32 + 48))(v32, &v33, &v34);
      }
    }
  }
}

void sub_1A1AAE220(_Unwind_Exception *a1)
{
  std::__shared_weak_count::~__shared_weak_count(v1);
  operator delete(v3);
  _Unwind_Resume(a1);
}

void sub_1A1AAE238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

char *std::__function::__func<md::LabelCustomFeatureSupport::populateLabelFeaturesInTile(md::LabelMapTile *)::$_0,std::allocator<md::LabelCustomFeatureSupport::populateLabelFeaturesInTile(md::LabelMapTile *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = &unk_1EF5777A8;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

uint64_t std::__shared_ptr_emplace<md::LabelFeatureProviderCommand>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1 = a1 + 32;
  uint64_t result = *(void *)(a1 + 56);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void std::__function::__func<md::LabelCustomFeatureProvider::dataSourceFeaturesDidChangeForRect(GEOMapRect)::$_0,std::allocator<md::LabelCustomFeatureProvider::dataSourceFeaturesDidChangeForRect(GEOMapRect)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (*(unsigned char *)(v1 + 240))
  {
    uint64_t v2 = *(void *)(v1 + 232);
    *(_WORD *)(v2 + 128) = 0;
    uint64_t v3 = *(void *)(v2 + 112);
    if (v3)
    {
      *(void *)(v3 + 8) = 0;
      uint64_t v4 = *(std::__shared_weak_count **)(v2 + 120);
      *(void *)(v2 + 112) = 0;
      *(void *)(v2 + 120) = 0;
      if (v4)
      {
        if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
          std::__shared_weak_count::__release_weak(v4);
        }
      }
    }
    long long v5 = *(void **)(v2 + 80);
    if (v5)
    {
      *(void *)(v2 + 80) = 0;
    }
    md::LabelCustomFeatureProvider::clearFeatures((md::LabelCustomFeatureProvider *)v1, 1);
  }
  *(unsigned char *)(*(void *)v1 + 232) = 1;
  md::LabelCustomFeatureProvider::featuresDidChangeForRect(v1);
}

__n128 std::__function::__func<md::LabelManager::setTrafficEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setTrafficEnabled(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E568;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t md::CompositeLabeler::clearPreviouslySelectedLabelMarker(uint64_t this)
{
  uint64_t v1 = *(uint64_t **)(this + 8);
  for (uint64_t i = *(uint64_t **)(this + 16); v1 != i; this = (*(uint64_t (**)(uint64_t))(*(void *)v3 + 200))(v3))
    uint64_t v3 = *v1++;
  return this;
}

void md::StandardLabeler::clearPreviouslySelectedLabelMarker(md::StandardLabeler *this)
{
  uint64_t v1 = *((void *)this + 32);
  if (v1)
  {
    md::Label::setPreviouslySelected(*(md::Label **)(v1 + 288), *((LabelManager **)this + 3), 0);
    uint64_t v3 = *((void *)this + 6);
    v5[0] = 0;
    v5[1] = 0;
    md::LabelPool::setPreviouslySelectedLabel(v3, v5);
    uint64_t v4 = (std::__shared_weak_count *)*((void *)this + 33);
    *((void *)this + 32) = 0;
    *((void *)this + 33) = 0;
    if (v4)
    {
      if (!atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
        std::__shared_weak_count::__release_weak(v4);
      }
    }
  }
}

void *std::__function::__func<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0,std::allocator<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x30uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = &unk_1EF56EF40;
  v2[1] = v3;
  v2[2] = &unk_1EF559E78;
  v2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  long long v5 = (void *)v2[3];
  v2[3] = v4;

  *((unsigned char *)v2 + 40) = *(unsigned char *)(a1 + 40);
  return v2;
}

void std::__function::__func<md::LabelCustomFeatureSupport::addDataSource(objc_object  {objcproto25VKCustomFeatureDataSource}*)::$_0,std::allocator<objc_object  {objcproto25VKCustomFeatureDataSource}*>,void ()(void)>::operator()(uint64_t a1)
{
}

id std::__function::__func<md::LabelCustomFeatureSupport::addDataSource(objc_object  {objcproto25VKCustomFeatureDataSource}*)::$_0,std::allocator<objc_object  {objcproto25VKCustomFeatureDataSource}*>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  id v4 = *(void **)(a1 + 16);
  *a2 = &unk_1EF5776D0;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

uint64_t std::__function::__func<md::LabelManager::didReceiveMemoryWarning(BOOL)::$_0,std::allocator<md::LabelManager::didReceiveMemoryWarning(BOOL)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56EB98;
  a2[1] = v2;
  return result;
}

char *std::__function::__func<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0,std::allocator<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  id result = (char *)operator new(0x20uLL);
  *(void *)id result = &unk_1EF56E370;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

void std::__function::__func<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0,std::allocator<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0>,void ()(void)>::destroy_deallocate(uint64_t a1)
{
  *(void *)(a1 + 16) = &unk_1EF559B78;

  operator delete((void *)a1);
}

uint64_t std::__function::__func<md::LabelManager::clearPreviouslySelectedLabelMarker(void)::$_0,std::allocator<md::LabelManager::clearPreviouslySelectedLabelMarker(void)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  return (*(uint64_t (**)(void))(**(void **)(*(void *)(a1 + 8) + 240) + 200))();
}

uint64_t std::__function::__func<md::LabelManager::clearPreviouslySelectedLabelMarker(void)::$_0,std::allocator<md::LabelManager::clearPreviouslySelectedLabelMarker(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56F210;
  a2[1] = v2;
  return result;
}

md::LabelManager *md::LabelManager::setStyleManager(md::LabelManager *this, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  if (*((void *)this + 436) != a2)
  {
    uint64_t v3 = this;
    if (a3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(a3 + 8), 1uLL, memory_order_relaxed);
    }
    *((void *)this + 436) = a2;
    id v4 = (std::__shared_weak_count *)*((void *)this + 437);
    *((void *)this + 437) = a3;
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    v5[0] = &unk_1EF56E3B8;
    v5[1] = v3;
    uint64_t v6 = (md::LabelManager *)v5;
    md::LabelManager::queueCommand(v3, 8, 1, v5);
    this = v6;
    if (v6 == (md::LabelManager *)v5)
    {
      return (md::LabelManager *)(*(uint64_t (**)(void *))(v5[0] + 32))(v5);
    }
    else if (v6)
    {
      return (md::LabelManager *)(*(uint64_t (**)(void))(*(void *)v6 + 40))();
    }
  }
  return this;
}

void sub_1A1AAE8EC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

void md::LabelManager::setSceneManager(md::LabelManager *a1, uint64_t a2, std::__shared_weak_count *a3)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = 0;
  uint64_t v6 = operator new(0x20uLL);
  void *v6 = &unk_1EF56E370;
  v6[1] = a1;
  v6[2] = a2;
  void v6[3] = a3;
  if (a3) {
    atomic_fetch_add_explicit(&a3->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  uint64_t v10 = v6;
  md::LabelManager::queueCommand(a1, 34, 1, v9);
  if (v10 == v9)
  {
    (*(void (**)(void *))(v9[0] + 32))(v9);
    if (!a3) {
      return;
    }
    goto LABEL_11;
  }
  if (v10) {
    (*(void (**)(void *, uint64_t, uint64_t))(*v10 + 40))(v10, v7, v8);
  }
  if (a3)
  {
LABEL_11:
    if (!atomic_fetch_add(&a3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))a3->__on_zero_shared)(a3);
      std::__shared_weak_count::__release_weak(a3);
    }
  }
}

void sub_1A1AAEA80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
}

void std::__function::__func<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0,std::allocator<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0>,void ()(void)>::destroy_deallocate(void *__p)
{
  uint64_t v2 = (std::__shared_weak_count *)__p[3];
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  operator delete(__p);
}

uint64_t std::__function::__func<md::LabelManager::stylesheetDidChange(void)::$_0,std::allocator<md::LabelManager::stylesheetDidChange(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56E910;
  a2[1] = v2;
  return result;
}

void non-virtual thunk to'md::MapNavLabeler::setTrafficFeatures(md::RouteAnnotationSupport **this, NSArray *a2)
{
}

uint64_t std::__function::__func<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0,std::allocator<md::LabelManager::setExternalTrafficFeatures(NSArray *,BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  (***(void (****)(void, void, void))(*(void *)(v1 + 168) + 48))(*(void *)(*(void *)(v1 + 168) + 48), *(void *)(a1 + 24), *(unsigned __int8 *)(a1 + 40));
  uint64_t v2 = *(uint64_t (**)(void))(**(void **)(*(void *)(v1 + 168) + 32) + 136);
  return v2();
}

uint64_t std::__function::__func<md::LabelManager::setTrafficClosuresEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setTrafficClosuresEnabled(BOOL)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  int v2 = *(unsigned __int8 *)(result + 16);
  if (*(unsigned __int8 *)(v1 + 3030) != v2)
  {
    *(unsigned char *)(v1 + 3030) = v2;
    *(unsigned char *)(v1 + 3041) = 1;
    *(unsigned char *)(v1 + 3045) = 1;
    *(unsigned char *)(v1 + 3047) = 1;
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3058));
    if (v3)
    {
      uint64_t v4 = *(void *)(v1 + 136);
      if (v4)
      {
        id result = *(void *)(v4 + 56);
        if (result)
        {
          uint64_t v6 = v1;
          char v5 = 9;
          return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)result + 48))(result, &v6, &v5);
        }
      }
    }
  }
  return result;
}

void std::__function::__func<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0,std::allocator<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  id v2 = *(id *)(a1 + 24);
  id v5 = v2;
  if (v2)
  {
    id v3 = v2;
    id v2 = v5;
  }
  uint64_t v4 = *(void **)(v1 + 3472);
  *(void *)(v1 + 3472) = v2;
}

void *std::__function::__func<md::LabelManager::stylesheetWillTransition(gss::DisplayStyle,BOOL)::$_0,std::allocator<md::LabelManager::stylesheetWillTransition(gss::DisplayStyle,BOOL)::$_0>,void ()(void)>::operator()(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = result[1];
  unint64_t v3 = *(void *)(*(void *)(v2 + 336) + 161);
  if (*((unsigned __int8 *)result + 16) != v3
    || (uint64x2_t v4 = (uint64x2_t)vdupq_n_s64(v3),
        int32x4_t v5 = (int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_1A28FF420),
        v4.i64[0] = *(void *)&vmovn_s32(vuzp1q_s32((int32x4_t)vshlq_u64(v4, (uint64x2_t)xmmword_1A28FF430), v5)) & 0xFF00FF00FF00FFLL,
        v5.i32[0] = *(_DWORD *)((char *)result + 17),
        (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vceq_s16((int16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v5.i8), *(int16x4_t *)v4.i8), 0xFuLL))) & 1) == 0)|| __PAIR64__(*((unsigned __int8 *)result + 22), *((unsigned __int8 *)result + 21)) != __PAIR64__(BYTE6(v3), BYTE5(v3))|| *((unsigned __int8 *)result + 23) != HIBYTE(v3))
  {
    id result = (void *)md::LabelManager::startStylesheetAnimation(result[1], result[2]);
    if (!*((unsigned char *)v1 + 24))
    {
      *(unsigned char *)(v2 + 3375) = 0;
      return md::LabelManager::startStylesheetLabelAnimations((md::LabelManager *)v2);
    }
  }
  return result;
}

void std::__function::__func<md::LabelManager::setShowsPointsOfInterest(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPointsOfInterest(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (*(unsigned __int8 *)(v2 + 3032) != v3)
  {
    *(unsigned char *)(v2 + 3032) = v3;
    md::LabelManager::clearScene(v2, 0);
  }
}

uint64_t std::__function::__func<md::LabelManager::setNeedsOcclusionClear(void)::$_0,std::allocator<md::LabelManager::setNeedsOcclusionClear(void)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 3052) = 1;
  return result;
}

float std::__function::__func<md::LabelManager::setNavigationPuckSize(float)::$_0,std::allocator<md::LabelManager::setNavigationPuckSize(float)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  float result = *(float *)(a1 + 16);
  *(float *)(*(void *)(a1 + 8) + 3364) = result;
  return result;
}

void std::__function::__func<md::LabelManager::setTrafficEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setTrafficEnabled(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(unsigned __int8 *)(a1 + 16);
  if (*(unsigned __int8 *)(v1 + 3029) != v2)
  {
    *(unsigned char *)(v1 + 3029) = v2;
    uint64_t v3 = *(void *)(v1 + 3400);
    if (v3 && (*(unsigned int (**)(uint64_t))(*(void *)v3 + 160))(v3)) {
      md::LabelManager::deselectLabelMarkerImpl((md::LabelManager *)v1);
    }
    *(unsigned char *)(v1 + 3041) = 1;
    *(unsigned char *)(v1 + 3045) = 1;
    *(unsigned char *)(v1 + 3047) = 1;
    unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v1 + 3058));
    if (v4)
    {
      uint64_t v5 = *(void *)(v1 + 136);
      if (v5)
      {
        uint64_t v6 = *(void *)(v5 + 56);
        if (v6)
        {
          uint64_t v8 = v1;
          char v7 = 9;
          (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v6 + 48))(v6, &v8, &v7);
        }
      }
    }
  }
}

void std::__function::__func<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0,std::allocator<md::LabelManager::setSceneManager(std::shared_ptr<gss::StylesheetManager<gss::ScenePropertyID>> const&)::$_0>,void ()(void)>::operator()(void *a1)
{
  uint64_t v1 = a1[1];
  uint64_t v2 = a1[2];
  uint64_t v3 = a1[3];
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  unsigned __int8 v4 = *(std::__shared_weak_count **)(v1 + 352);
  *(void *)(v1 + 344) = v2;
  *(void *)(v1 + 352) = v3;
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
}

uint64_t std::__function::__func<md::LabelManager::setShowVenues(BOOL)::$_0,std::allocator<md::LabelManager::setShowVenues(BOOL)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 3389) = *(unsigned char *)(result + 16);
  return result;
}

__n128 std::__function::__func<md::LabelManager::setLabelMarkerSelectionEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setLabelMarkerSelectionEnabled(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56F060;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setTrafficClosuresEnabled(BOOL)::$_0,std::allocator<md::LabelManager::setTrafficClosuresEnabled(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56EEF8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *std::__function::__func<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0,std::allocator<md::LabelManager::setClientLocalizedStrings(VKClientLocalizedStrings *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = &unk_1EF56EEB0;
  v2[1] = v3;
  v2[2] = &unk_1EF559B78;
  v2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  uint64_t v5 = (void *)v2[3];
  v2[3] = v4;

  return v2;
}

__n128 std::__function::__func<md::LabelManager::stylesheetWillTransition(gss::DisplayStyle,BOOL)::$_0,std::allocator<md::LabelManager::stylesheetWillTransition(gss::DisplayStyle,BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = (char *)operator new(0x20uLL);
  *(void *)uint64_t v2 = &unk_1EF56EE68;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(v2 + 8) = result;
  *((void *)v2 + 3) = *(void *)(a1 + 24);
  return result;
}

__n128 std::__function::__func<md::LabelManager::setShowsPointsOfInterest(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPointsOfInterest(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56ED90;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<md::LabelManager::stylesheetDidTransition(void)::$_0,std::allocator<md::LabelManager::stylesheetDidTransition(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56ECB8;
  a2[1] = v2;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setNavigationPuckSize(float)::$_0,std::allocator<md::LabelManager::setNavigationPuckSize(float)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56EA30;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setNeedsClearScene(BOOL)::$_0,std::allocator<md::LabelManager::setNeedsClearScene(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E5F8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *std::__function::__func<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0,std::allocator<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t v2 = &unk_1EF56E5B0;
  v2[1] = v3;
  v2[2] = off_1EF559738;
  v2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  uint64_t v5 = (void *)v2[3];
  v2[3] = v4;

  return v2;
}

__n128 std::__function::__func<md::LabelManager::setLocalizeLabels(BOOL)::$_0,std::allocator<md::LabelManager::setLocalizeLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E520;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<md::LabelManager::setStyleManager(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0,std::allocator<md::LabelManager::setStyleManager(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56E3B8;
  a2[1] = v2;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setShowVenues(BOOL)::$_0,std::allocator<md::LabelManager::setShowVenues(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E208;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

uint64_t std::__function::__func<md::LabelManager::setNeedsOcclusionClear(void)::$_0,std::allocator<md::LabelManager::setNeedsOcclusionClear(void)::$_0>,void ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF56EB08;
  a2[1] = v2;
  return result;
}

uint64_t non-virtual thunk to'md::MapNavLabeler::setCurrentLocationText(id *this, NSString *a2)
{
  return [this[6] setCurrentLocationText:a2];
}

void non-virtual thunk to'md::StandardLabeler::setLabelExclusionRegions(uint64_t a1, void *a2)
{
  id v3 = a2;
  *(unsigned char *)(a1 + 352) = 1;
  id v4 = v3;
  id v7 = v4;
  if (v4)
  {
    id v5 = v4;
    id v4 = v7;
  }
  uint64_t v6 = *(void **)(a1 + 152);
  *(void *)(a1 + 152) = v4;
}

void non-virtual thunk to'md::StandardLabeler::setScreenLabelFeatures(uint64_t a1, void *a2)
{
}

void std::__function::__func<md::LabelManager::stylesheetDidFinishDecodingGlobalProperties(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0,std::allocator<md::LabelManager::stylesheetDidFinishDecodingGlobalProperties(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 8) + 336);
  std::mutex::lock((std::mutex *)v2);
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3 == *(void *)(v2 + 184))
  {
    if (v3 && (uint64_t v4 = *(void *)(v3 + 16)) != 0)
    {
      unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v4 + 2784));
      if ((v5 & 1) == 0) {
        std::__assoc_sub_state::wait(*(std::__assoc_sub_state **)(v4 + 2808));
      }
      uint64_t v6 = *(void *)(v4 + 120);
      id v7 = *(std::__shared_weak_count **)(v4 + 128);
      if (v7) {
        atomic_fetch_add_explicit(&v7->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      if (v6) {
        LOBYTE(v6) = *(unsigned char *)(v6 + 256) != 0;
      }
      *(unsigned char *)(v2 + 157) = v6;
      if (v7 && !atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
    else
    {
      *(unsigned char *)(v2 + 157) = 0;
    }
    md::LabelStyleCache::updateNavRoadSignScale((md::LabelStyleCache *)v2);
  }
  std::mutex::unlock((std::mutex *)v2);
}

void sub_1A1AAF41C(_Unwind_Exception *a1)
{
  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::LabelManager::setMKRenderingSelectionBalloon(BOOL)::$_0,std::allocator<md::LabelManager::setMKRenderingSelectionBalloon(BOOL)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 3056) = *(unsigned char *)(result + 16);
  return result;
}

uint64_t std::__function::__func<md::LabelManager::prepareForStylesheetTransition(gss::DisplayStyle)::$_0,std::allocator<md::LabelManager::prepareForStylesheetTransition(gss::DisplayStyle)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 8);
  if (!*(unsigned char *)(result + 3375)) {
    return md::LabelManager::startStylesheetAnimation(result, *(void *)(a1 + 16));
  }
  return result;
}

void std::__function::__func<md::LabelManager::setShowsPhysicalFeatureLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPhysicalFeatureLabels(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v2[3038] != v3)
  {
    v2[3038] = v3;
    if (v2[3036] && v2[3034] && v2[3035])
    {
      BOOL v4 = 1;
      if (v3)
      {
        if (v2[3037]) {
          BOOL v4 = v2[3039] == 0;
        }
      }
    }
    else
    {
      BOOL v4 = 1;
    }
    v2[3033] = v4;
    md::LabelManager::clearScene((uint64_t)v2, 0);
  }
}

uint64_t std::__function::__func<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0,std::allocator<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 8) + 168) + 64);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 80))(v2, v1);
}

uint64_t std::__function::__func<md::LabelManager::setShowingTrafficCasing(BOOL)::$_0,std::allocator<md::LabelManager::setShowingTrafficCasing(BOOL)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  int v2 = *(unsigned __int8 *)(result + 16);
  if (*(unsigned __int8 *)(v1 + 3031) != v2)
  {
    *(unsigned char *)(v1 + 3031) = v2;
    if (*(unsigned char *)(v1 + 3029))
    {
      *(unsigned char *)(v1 + 3045) = 1;
      *(unsigned char *)(v1 + 3047) = 1;
      unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3048));
      if ((v3 & 1) == 0)
      {
        unsigned __int8 v4 = atomic_load((unsigned __int8 *)(v1 + 3058));
        if (v4)
        {
          uint64_t v5 = *(void *)(v1 + 136);
          if (v5)
          {
            uint64_t result = *(void *)(v5 + 56);
            if (result)
            {
              uint64_t v7 = v1;
              char v6 = 9;
              return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)result + 48))(result, &v7, &v6);
            }
          }
        }
      }
    }
  }
  return result;
}

void std::__function::__func<md::LabelManager::setNavigationShieldSize(grl::SizeGroup)::$_0,std::allocator<md::LabelManager::setNavigationShieldSize(grl::SizeGroup)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (*(unsigned __int8 *)(v2 + 3361) != v3)
  {
    *(unsigned char *)(v2 + 3361) = v3;
    if (*(unsigned char *)(v2 + 192) == 2) {
      md::LabelManager::clearScene(v2, 2);
    }
  }
}

void std::__function::__func<md::LabelManager::didReceiveMemoryWarning(BOOL)::$_0,std::allocator<md::LabelManager::didReceiveMemoryWarning(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
}

uint64_t std::__function::__func<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0,std::allocator<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 16);
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 8) + 168) + 64);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 88))(v2, v1);
}

uint64_t std::__function::__func<md::LabelManager::setCurrentLocationText(NSString *)::$_0,std::allocator<md::LabelManager::setCurrentLocationText(NSString *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 8) + 168) + 32);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 144))(v2, v1);
}

void std::__function::__func<md::LabelManager::setShowsContourLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsContourLabels(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v2[3037] != v3)
  {
    v2[3037] = v3;
    if (!v2[3036] || !v2[3034]) {
      goto LABEL_8;
    }
    BOOL v4 = 1;
    if (!v3 || !v2[3035]) {
      goto LABEL_9;
    }
    if (v2[3038]) {
      BOOL v4 = v2[3039] == 0;
    }
    else {
LABEL_8:
    }
      BOOL v4 = 1;
LABEL_9:
    v2[3033] = v4;
    md::LabelManager::clearScene((uint64_t)v2, 0);
  }
}

uint64_t std::__function::__func<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0,std::allocator<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 8) + 168) + 40);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 8))(v2, v1);
}

void std::__function::__func<md::LabelManager::setShowsRoadShields(BOOL)::$_0,std::allocator<md::LabelManager::setShowsRoadShields(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v2[3035] != v3)
  {
    v2[3035] = v3;
    v5 = !v2[3036] || (v3 ? (BOOL v4 = v2[3034] == 0) : (BOOL v4 = 1), v4 || !v2[3037] || !v2[3038]) || v2[3039] == 0;
    v2[3033] = v5;
    md::LabelManager::clearScene((uint64_t)v2, 0);
  }
}

void std::__function::__func<md::LabelManager::setShowsPointLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPointLabels(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v2[3036] != v3)
  {
    v2[3036] = v3;
    BOOL v4 = !v3 || !v2[3034] || !v2[3035] || !v2[3037] || !v2[3038] || v2[3039] == 0;
    v2[3033] = v4;
    md::LabelManager::clearScene((uint64_t)v2, 0);
  }
}

void std::__function::__func<md::LabelManager::setLabelScaleFactor(gss::LabelScaleFactor)::$_0,std::allocator<md::LabelManager::setLabelScaleFactor(gss::LabelScaleFactor)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  int v2 = *(unsigned __int8 *)(a1 + 16);
  if (*(unsigned __int8 *)(v1 + 3368) != v2)
  {
    *(unsigned char *)(v1 + 3368) = v2;
    md::LabelManager::resolveLabelScaleFactor((md::LabelManager *)v1);
    *(unsigned char *)(v1 + 3373) = 1;
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3058));
    if (v3)
    {
      uint64_t v4 = *(void *)(v1 + 136);
      if (v4)
      {
        uint64_t v5 = *(void *)(v4 + 56);
        if (v5)
        {
          uint64_t v7 = v1;
          char v6 = 9;
          (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v5 + 48))(v5, &v7, &v6);
        }
      }
    }
  }
}

void std::__function::__func<md::LabelManager::setShowsRoadLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsRoadLabels(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  int v2 = *(unsigned char **)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v2[3034] != v3)
  {
    v2[3034] = v3;
    if (v3) {
      BOOL v4 = v2[3036] == 0;
    }
    else {
      BOOL v4 = 1;
    }
    BOOL v5 = v4 || !v2[3035] || !v2[3037] || !v2[3038] || v2[3039] == 0;
    v2[3033] = v5;
    md::LabelManager::clearScene((uint64_t)v2, 0);
  }
}

void std::__function::__func<md::LabelManager::setNeedsClearScene(BOOL)::$_0,std::allocator<md::LabelManager::setNeedsClearScene(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 16)) {
    uint64_t v1 = 1;
  }
  else {
    uint64_t v1 = 2;
  }
  md::LabelManager::clearScene(*(void *)(a1 + 8), v1);
}

uint64_t std::__function::__func<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0,std::allocator<md::LabelManager::setFocusedPolyline(VKPolylineOverlay *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 24);
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 8) + 168) + 32);
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v2 + 128))(v2, v1);
}

void std::__function::__func<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0,std::allocator<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0>,void ()(void)>::operator()(void *a1)
{
  uint64_t v2 = a1[1];
  uint64_t v1 = a1[2];
  if (v1 != *(void *)(v2 + 3576))
  {
    uint64_t v3 = a1[3];
    if (v3) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
    }
    *(void *)(v2 + 3576) = v1;
    BOOL v4 = *(std::__shared_weak_count **)(v2 + 3584);
    *(void *)(v2 + 3584) = v3;
    if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
    *(unsigned char *)(v2 + 3045) = 1;
    *(unsigned char *)(v2 + 3047) = 1;
    unsigned __int8 v5 = atomic_load((unsigned __int8 *)(v2 + 3058));
    if (v5)
    {
      uint64_t v6 = *(void *)(v2 + 136);
      if (v6)
      {
        uint64_t v7 = *(void *)(v6 + 56);
        if (v7)
        {
          uint64_t v9 = v2;
          char v8 = 9;
          (*(void (**)(uint64_t, uint64_t *, char *))(*(void *)v7 + 48))(v7, &v9, &v8);
        }
      }
    }
  }
}

uint64_t std::__function::__func<md::LabelManager::setTargetDisplay(gss::TargetDisplay)::$_0,std::allocator<md::LabelManager::setTargetDisplay(gss::TargetDisplay)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 3026) = *(unsigned char *)(result + 16);
  return result;
}

uint64_t std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_0,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  *(unsigned char *)(v1 + 201) = *(unsigned char *)(a1 + 16);
  return (*(uint64_t (**)(void, void))(**(void **)(*(void *)(v1 + 168) + 56) + 8))(*(void *)(*(void *)(v1 + 168) + 56), *(void *)(a1 + 24));
}

void std::__function::__func<md::LabelManager::setShowsLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsLabels(BOOL)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 8);
  int v3 = *(unsigned __int8 *)(a1 + 16);
  if (v2[3039] != v3)
  {
    v2[3039] = v3;
    if (v2[3036] && v2[3034] && v2[3035] && v2[3037])
    {
      if (v3) {
        BOOL v4 = v2[3038] == 0;
      }
      else {
        BOOL v4 = 1;
      }
      char v5 = v4;
    }
    else
    {
      char v5 = 1;
    }
    v2[3033] = v5;
    md::LabelManager::clearScene((uint64_t)v2, 0);
  }
}

void *std::__function::__func<md::LabelManager::setShieldIdiom(VKShieldIdiom)::$_0,std::allocator<md::LabelManager::setShieldIdiom(VKShieldIdiom)::$_0>,void ()(void)>::operator()(void *result)
{
  uint64_t v1 = result[1];
  uint64_t v2 = result[2];
  if (*(void *)(v1 + 3352) != v2)
  {
    *(void *)(v1 + 3352) = v2;
    *(unsigned char *)(v1 + 3373) = 1;
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3058));
    if (v3)
    {
      uint64_t v4 = *(void *)(v1 + 136);
      if (v4)
      {
        uint64_t result = *(void **)(v4 + 56);
        if (result)
        {
          uint64_t v6 = v1;
          char v5 = 9;
          return (void *)(*(uint64_t (**)(void *, uint64_t *, char *))(*result + 48))(result, &v6, &v5);
        }
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<md::LabelManager::setShieldSize(grl::SizeGroup)::$_0,std::allocator<md::LabelManager::setShieldSize(grl::SizeGroup)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  int v2 = *(unsigned __int8 *)(result + 16);
  if (*(unsigned __int8 *)(v1 + 3360) != v2)
  {
    *(unsigned char *)(v1 + 3360) = v2;
    *(unsigned char *)(v1 + 3373) = 1;
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3058));
    if (v3)
    {
      uint64_t v4 = *(void *)(v1 + 136);
      if (v4)
      {
        uint64_t result = *(void *)(v4 + 56);
        if (result)
        {
          uint64_t v6 = v1;
          char v5 = 9;
          return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)result + 48))(result, &v6, &v5);
        }
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<md::LabelManager::setGroundMode(gss::GroundMode)::$_0,std::allocator<md::LabelManager::setGroundMode(gss::GroundMode)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  int v2 = *(unsigned __int8 *)(result + 16);
  if (*(unsigned __int8 *)(v1 + 3025) != v2)
  {
    *(unsigned char *)(v1 + 3025) = v2;
    *(_WORD *)(v1 + 3373) = 257;
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3058));
    if (v3)
    {
      uint64_t v4 = *(void *)(v1 + 136);
      if (v4)
      {
        uint64_t result = *(void *)(v4 + 56);
        if (result)
        {
          uint64_t v6 = v1;
          char v5 = 9;
          return (*(uint64_t (**)(uint64_t, uint64_t *, char *))(*(void *)result + 48))(result, &v6, &v5);
        }
      }
    }
  }
  return result;
}

uint64_t std::__function::__func<md::LabelManager::setEmphasis(gss::Emphasis)::$_0,std::allocator<md::LabelManager::setEmphasis(gss::Emphasis)::$_0>,void ()(void)>::operator()(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 8);
  int v2 = *(unsigned __int8 *)(result + 16);
  if (*(unsigned __int8 *)(v1 + 3024) != v2)
  {
    *(unsigned char *)(v1 + 3024) = v2;
    unsigned __int8 v3 = atomic_load((unsigned __int8 *)(v1 + 3391));
    if (v3)
    {
      int v4 = 1;
    }
    else if (*(_DWORD *)(v1 + 196) == 5)
    {
      int v4 = 3;
    }
    else
    {
      int v4 = 2 * (*(unsigned char *)(v1 + 3024) == 1);
    }
    char v5 = (unsigned __int8 *)(v1 + 3394);
    int v6 = atomic_load(v5);
    if (v6 != v4) {
      atomic_store(v4, v5);
    }
  }
  return result;
}

char *std::__function::__func<md::LabelManager::stylesheetDidFinishDecodingGlobalProperties(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0,std::allocator<md::LabelManager::stylesheetDidFinishDecodingGlobalProperties(std::shared_ptr<gss::StylesheetManager<gss::PropertyID>> const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  uint64_t result = (char *)operator new(0x20uLL);
  *(void *)uint64_t result = &unk_1EF56F258;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

__n128 std::__function::__func<md::LabelManager::setMKRenderingSelectionBalloon(BOOL)::$_0,std::allocator<md::LabelManager::setMKRenderingSelectionBalloon(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56F0A8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::prepareForStylesheetTransition(gss::DisplayStyle)::$_0,std::allocator<md::LabelManager::prepareForStylesheetTransition(gss::DisplayStyle)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56F018;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setShowsPhysicalFeatureLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPhysicalFeatureLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51DB10;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *std::__function::__func<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0,std::allocator<md::LabelManager::setLabelExclusionRegions(NSArray<VKLabelExclusionRegion *> *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  int v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *int v2 = &unk_1EF56ED48;
  v2[1] = v3;
  v2[2] = &unk_1EF559E18;
  v2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  char v5 = (void *)v2[3];
  v2[3] = v4;

  return v2;
}

__n128 std::__function::__func<md::LabelManager::setShowingTrafficCasing(BOOL)::$_0,std::allocator<md::LabelManager::setShowingTrafficCasing(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56EC70;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setNavigationShieldSize(grl::SizeGroup)::$_0,std::allocator<md::LabelManager::setNavigationShieldSize(grl::SizeGroup)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56EC28;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

id std::__function::__func<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0,std::allocator<md::LabelManager::setScreenLabelFeatures(NSArray<VKScreenLabelFeature *> *)::$_0>,void ()(void)>::__clone(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  id v4 = *(void **)(a1 + 16);
  *a2 = &unk_1EF56EB50;
  a2[1] = v3;
  id result = v4;
  a2[2] = result;
  return result;
}

void *std::__function::__func<md::LabelManager::setCurrentLocationText(NSString *)::$_0,std::allocator<md::LabelManager::setCurrentLocationText(NSString *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  int v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *int v2 = &unk_1EF56EA78;
  v2[1] = v3;
  v2[2] = &unk_1EF559F18;
  v2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  char v5 = (void *)v2[3];
  v2[3] = v4;

  return v2;
}

__n128 std::__function::__func<md::LabelManager::setShowsContourLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsContourLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51DAC8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *std::__function::__func<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0,std::allocator<md::LabelManager::setARWalkingFeatures(VKARWalkingFeatureSet *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  int v2 = operator new(0x28uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *int v2 = &unk_1EF56E9A0;
  v2[1] = v3;
  v2[2] = &unk_1EF5599B8;
  v2[3] = 0;
  id v4 = *(id *)(a1 + 24);
  char v5 = (void *)v2[3];
  v2[3] = v4;

  return v2;
}

__n128 std::__function::__func<md::LabelManager::setShowsRoadShields(BOOL)::$_0,std::allocator<md::LabelManager::setShowsRoadShields(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E8C8;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setShowsPointLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsPointLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E880;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setLabelScaleFactor(gss::LabelScaleFactor)::$_0,std::allocator<md::LabelManager::setLabelScaleFactor(gss::LabelScaleFactor)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E838;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setShowsRoadLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsRoadLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E688;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setRouteUserOffset(geo::PolylineCoordinate const&)::$_0,std::allocator<md::LabelManager::setRouteUserOffset(geo::PolylineCoordinate const&)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E640;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

char *std::__function::__func<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0,std::allocator<md::LabelManager::setCategoryFilter(std::shared_ptr<md::LabelCategoryFilter> const&)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  __n128 result = (char *)operator new(0x20uLL);
  *(void *)__n128 result = &unk_1EF56E490;
  *(_OWORD *)(result + 8) = *(_OWORD *)(a1 + 8);
  uint64_t v3 = *(void *)(a1 + 24);
  *((void *)result + 3) = v3;
  if (v3) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v3 + 8), 1uLL, memory_order_relaxed);
  }
  return result;
}

__n128 std::__function::__func<md::LabelManager::setTargetDisplay(gss::TargetDisplay)::$_0,std::allocator<md::LabelManager::setTargetDisplay(gss::TargetDisplay)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E400;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void *std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_1,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_1>,void ()(void)>::__clone(uint64_t a1)
{
  int v2 = operator new(0x20uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *int v2 = &unk_1EF56E328;
  v2[1] = v3;
  *((unsigned char *)v2 + 16) = *(unsigned char *)(a1 + 16);
  v2[3] = *(id *)(a1 + 24);
  return v2;
}

void *std::__function::__func<md::LabelManager::setRouteContext(VKRouteContext *)::$_0,std::allocator<md::LabelManager::setRouteContext(VKRouteContext *)::$_0>,void ()(void)>::__clone(uint64_t a1)
{
  int v2 = operator new(0x20uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *int v2 = &unk_1EF56E2E0;
  v2[1] = v3;
  *((unsigned char *)v2 + 16) = *(unsigned char *)(a1 + 16);
  v2[3] = *(id *)(a1 + 24);
  return v2;
}

__n128 std::__function::__func<md::LabelManager::setShowsLabels(BOOL)::$_0,std::allocator<md::LabelManager::setShowsLabels(BOOL)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF51DA80;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setShieldIdiom(VKShieldIdiom)::$_0,std::allocator<md::LabelManager::setShieldIdiom(VKShieldIdiom)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E250;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setShieldSize(grl::SizeGroup)::$_0,std::allocator<md::LabelManager::setShieldSize(grl::SizeGroup)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E1C0;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setGroundMode(gss::GroundMode)::$_0,std::allocator<md::LabelManager::setGroundMode(gss::GroundMode)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56E178;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

__n128 std::__function::__func<md::LabelManager::setEmphasis(gss::Emphasis)::$_0,std::allocator<md::LabelManager::setEmphasis(gss::Emphasis)::$_0>,void ()(void)>::__clone(uint64_t a1, uint64_t a2)
{
  *(void *)a2 = &unk_1EF56DF38;
  __n128 result = *(__n128 *)(a1 + 8);
  *(__n128 *)(a2 + 8) = result;
  return result;
}

void md::LabelNavTrafficSupport::setRouteUserOffset(md::LabelNavTrafficSupport *this, const PolylineCoordinate *a2)
{
  *((PolylineCoordinate *)this + 17) = *a2;
  unsigned int v4 = *((_DWORD *)this + 36);
  if (a2->index <= v4 && (a2->index != v4 || a2->offset <= *((float *)this + 37))) {
    return;
  }
  char v5 = (char *)*((void *)this + 13);
  if (*((char **)this + 14) == v5) {
    goto LABEL_77;
  }
  unint64_t v6 = 0;
  while (1)
  {
    char v8 = &v5[16 * v6];
    uint64_t v9 = (*(void (**)(void))(**(void **)v8 + 200))();
    uint64_t v10 = [v9 routeOffset];
    if (a2->index < v10) {
      break;
    }
    if (a2->index == v10)
    {
      float v11 = *((float *)&v10 + 1);
      float offset = a2->offset;

      if (offset <= v11) {
        goto LABEL_60;
      }
    }
    else
    {
    }
    unint64_t v13 = (*(void (**)(void))(**(void **)v8 + 200))();
    [v13 setRouteRelevance:2];
    id v14 = v13;
    uint64_t v15 = (void *)*((void *)this + 9);
    unint64_t v16 = (void *)*((void *)this + 10);
    if (v15 != v16)
    {
      while (*v15 != *(void *)v8)
      {
        v15 += 2;
        if (v15 == v16)
        {
          uint64_t v15 = (void *)*((void *)this + 10);
          break;
        }
      }
    }
    if (v15 != v16)
    {
      uint64_t v17 = v15 + 2;
      if (v15 + 2 != v16)
      {
        do
        {
          uint64_t v15 = v17;
          long long v18 = *(_OWORD *)v17;
          *uint64_t v17 = 0;
          v17[1] = 0;
          uint64_t v19 = (std::__shared_weak_count *)*(v17 - 1);
          *((_OWORD *)v17 - 1) = v18;
          if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
            std::__shared_weak_count::__release_weak(v19);
          }
          uint64_t v17 = v15 + 2;
        }
        while (v15 + 2 != v16);
        unint64_t v16 = (void *)*((void *)this + 10);
      }
      while (v16 != v15)
      {
        uint64_t v20 = (std::__shared_weak_count *)*(v16 - 1);
        if (v20)
        {
          if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
            std::__shared_weak_count::__release_weak(v20);
          }
        }
        v16 -= 2;
      }
      *((void *)this + 10) = v15;
    }
    uint64_t v21 = (std::__shared_weak_count *)operator new(0x1A0uLL);
    v21->__shared_owners_ = 0;
    v21->__shared_weak_owners_ = 0;
    v21->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582240;
    uint64_t v22 = std::__construct_at[abi:nn180100]<md::TrafficIncidentLabelFeature,VKTrafficIncidentFeature * {__strong}&,std::shared_ptr<md::RouteAnnotationDedupingGroup> &,md::TrafficIncidentLabelFeature*>((uint64_t)&v21[1], v14, *((void *)this + 2), *((std::__shared_weak_count **)this + 3));
    *(void *)&long long v51 = v22;
    *((void *)&v51 + 1) = v21;
    uint64_t v23 = (uint64_t *)*((void *)this + 10);
    unint64_t v24 = *((void *)this + 11);
    if ((unint64_t)v23 >= v24)
    {
      uint64_t v25 = *((void *)this + 9);
      uint64_t v26 = ((uint64_t)v23 - v25) >> 4;
      unint64_t v27 = v26 + 1;
      if ((unint64_t)(v26 + 1) >> 60) {
        abort();
      }
      uint64_t v28 = v24 - v25;
      if (v28 >> 3 > v27) {
        unint64_t v27 = v28 >> 3;
      }
      if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF0) {
        uint64_t v29 = 0xFFFFFFFFFFFFFFFLL;
      }
      else {
        uint64_t v29 = v27;
      }
      if (v29)
      {
        uint64_t v30 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**((void **)this + 12) + 16))(*((void *)this + 12), 16 * v29, 8);
        uint64_t v31 = (_OWORD *)(v30 + 16 * v26);
        uint64_t v32 = v30 + 16 * v29;
        if (v30)
        {
          *uint64_t v31 = v51;
          long long v51 = 0uLL;
        }
      }
      else
      {
        uint64_t v32 = 0;
        uint64_t v31 = (_OWORD *)(16 * v26);
      }
      long long v33 = v31 + 1;
      char v34 = (void *)*((void *)this + 9);
      uint64_t v35 = (void *)*((void *)this + 10);
      if (v35 == v34)
      {
        *((void *)this + 9) = v31;
        *((void *)this + 10) = v33;
        uint64_t v38 = *((void *)this + 11);
        *((void *)this + 11) = v32;
      }
      else
      {
        do
        {
          long long v36 = *((_OWORD *)v35 - 1);
          v35 -= 2;
          *--uint64_t v31 = v36;
          void *v35 = 0;
          v35[1] = 0;
        }
        while (v35 != v34);
        uint64_t v35 = (void *)*((void *)this + 9);
        uint64_t v37 = (void *)*((void *)this + 10);
        *((void *)this + 9) = v31;
        *((void *)this + 10) = v33;
        uint64_t v38 = *((void *)this + 11);
        *((void *)this + 11) = v32;
        while (v37 != v35)
        {
          uint64_t v39 = (std::__shared_weak_count *)*(v37 - 1);
          if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
            std::__shared_weak_count::__release_weak(v39);
          }
          v37 -= 2;
        }
      }
      if (v35) {
        (*(void (**)(void, void *, uint64_t))(**((void **)this + 12) + 40))(*((void *)this + 12), v35, v38 - (void)v35);
      }
      uint64_t v21 = (std::__shared_weak_count *)*((void *)&v51 + 1);
      *((void *)this + 10) = v33;
      if (!v21) {
        goto LABEL_4;
      }
    }
    else
    {
      if (v23)
      {
        *uint64_t v23 = v22;
        v23[1] = (uint64_t)v21;
        long long v51 = 0uLL;
        uint64_t v21 = 0;
      }
      *((void *)this + 10) = v23 + 2;
      if (!v21) {
        goto LABEL_4;
      }
    }
    if (!atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
      std::__shared_weak_count::__release_weak(v21);
    }
LABEL_4:

    ++v6;
    char v5 = (char *)*((void *)this + 13);
    uint64_t v7 = (char *)*((void *)this + 14);
    if (v6 >= (v7 - v5) >> 4) {
      goto LABEL_61;
    }
  }

LABEL_60:
  char v5 = (char *)*((void *)this + 13);
  uint64_t v7 = (char *)*((void *)this + 14);
  uint64_t i = v7;
  if (!v6) {
    goto LABEL_75;
  }
LABEL_61:
  if (&v5[16 * v6] != v7)
  {
    uint64_t v41 = 16 * v6;
    do
    {
      uint64_t v42 = &v5[v41];
      long long v43 = *(_OWORD *)&v5[16 * v6];
      *(void *)uint64_t v42 = 0;
      *((void *)v42 + 1) = 0;
      unint64_t v44 = (std::__shared_weak_count *)*((void *)v5 + 1);
      *(_OWORD *)char v5 = v43;
      if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
        std::__shared_weak_count::__release_weak(v44);
      }
      v5 += 16;
    }
    while (&v5[v41] != v7);
    uint64_t v7 = (char *)*((void *)this + 14);
  }
  for (uint64_t i = v5; v7 != v5; v7 -= 16)
  {
    float v45 = (std::__shared_weak_count *)*((void *)v7 - 1);
    if (v45 && !atomic_fetch_add(&v45->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
      std::__shared_weak_count::__release_weak(v45);
    }
  }
  *((void *)this + 14) = v5;
  char v5 = (char *)*((void *)this + 13);
LABEL_75:
  if (v5 != i)
  {
    BOOL v46 = (*(void (**)(void))(**(void **)v5 + 200))();
    *((void *)this + 18) = [v46 routeOffset];

    goto LABEL_78;
  }
LABEL_77:
  *((void *)this + 18) = 0xFFFFFFFFLL;
LABEL_78:
  uint64_t v47 = *((void *)this + 1);
  *(unsigned char *)(v47 + 3041) = 1;
  unsigned __int8 v48 = atomic_load((unsigned __int8 *)(v47 + 3058));
  if (v48)
  {
    uint64_t v49 = *(void *)(v47 + 136);
    if (v49)
    {
      uint64_t v50 = *(void *)(v49 + 56);
      if (v50)
      {
        *(void *)&long long v51 = v47;
        char v52 = 9;
        (*(void (**)(uint64_t, long long *, char *))(*(void *)v50 + 48))(v50, &v51, &v52);
      }
    }
  }
}

void sub_1A1AB0910(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::LabelTransitSupport::setRouteContext(md::LabelTransitSupport *this, VKRouteContext *a2)
{
  unsigned int v4 = a2;
  char v5 = v4;
  if (*((unsigned char *)this + 113))
  {
    unint64_t v6 = (VKRouteContext *)*((void *)this + 6);
    if (v6 == v4) {
      goto LABEL_133;
    }
    uint64_t v7 = v4;
    char v8 = v7;
    if (v5) {
      uint64_t v9 = v7;
    }
    uint64_t v10 = (void *)*((void *)this + 6);
    *((void *)this + 6) = v8;

    if (v5 && v6)
    {
      *((unsigned char *)this + 114) = 1;
      *(unsigned char *)(*((void *)this + 2) + 3328) = 1;
    }
    uint64_t v104 = 0;
    uint64_t v105 = 0;
    uint64_t v106 = 0;
    std::string __p = 0;
    unint64_t v102 = 0;
    uint64_t j = 0;
    md::LabelTransitSupport::setExternalTransitNodeFeatures((uint64_t)this, (uint64_t **)&v104, (uint64_t **)&__p);
    if (v5)
    {
      float v11 = [[VKRouteContextObserverThunk alloc] initWithRouteContext:v8 transitSupport:this];
      uint64_t v12 = (void *)*((void *)this + 12);
      *((void *)this + 12) = v11;

      *((unsigned char *)this + 112) = 1;
      unint64_t v13 = [(VKRouteContext *)v8 routeInfo];
      id v14 = [v13 route];
      uint64_t v15 = (std::__shared_weak_count *)*((void *)this + 42);
      *((void *)this + 41) = 0;
      *((void *)this + 42) = 0;
      if (v15 && !atomic_fetch_add(&v15->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
      int v16 = *((_DWORD *)this + 90);
      if ((v16 + 1) > 1) {
        int v17 = v16 + 1;
      }
      else {
        int v17 = 1;
      }
      *((_DWORD *)this + 90) = v17;
      if (v14)
      {
        long long v18 = operator new(0x170uLL);
        v18[1] = 0;
        v18[2] = 0;
        *long long v18 = &unk_1EF5803D8;
        md::LabelTransitRoute::LabelTransitRoute((md::LabelTransitRoute *)(v18 + 3), v14, v17);
      }
      uint64_t v19 = (char *)this + 328;

      objc_storeStrong((id *)(*((void *)this + 41) + 8), a2);
      uint64_t v104 = 0;
      uint64_t v105 = 0;
      uint64_t v106 = 0;
      std::string __p = 0;
      unint64_t v102 = 0;
      uint64_t j = 0;
      md::LabelTransitRoute::generateTransitNodeFeatures(*((uint64_t ***)this + 41), (int64x2_t ***)&v104);
      uint64_t v20 = (md::LabelManager *)*((void *)this + 2);
      if (*(unsigned char *)(*((void *)v20 + 54) + 26) == 7) {
        goto LABEL_115;
      }
      uint64_t v21 = *(void *)v19;
      uint64_t v22 = *(void *)(*(void *)v19 + 312);
      for (uint64_t i = *(void *)(v21 + 320); i != v22; i -= 16)
      {
        unint64_t v24 = *(std::__shared_weak_count **)(i - 8);
        if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
          std::__shared_weak_count::__release_weak(v24);
        }
      }
      *(void *)(v21 + 320) = v22;
      uint64_t v99 = [*(id *)(v21 + 8) routeInfo];
      id v100 = *(id *)(v21 + 32);
      if (v99)
      {
        long long v33 = [v100 legs];
        uint64_t v34 = [v33 count];

        if (v34)
        {
          uint64_t v35 = [v100 legs];
          long long v36 = [v35 objectAtIndexedSubscript:0];
          uint64_t v37 = [v36 origin];
          uint64_t v38 = [v99 waypointInfoForWaypoint:v37];
          uint64_t v98 = v21 + 312;

          if (v38)
          {
            uint64_t v39 = [(VKRouteWaypointInfo *)v38 waypoint];
            char v40 = [v39 isCurrentLocation];

            if ((v40 & 1) == 0)
            {
              [(VKRouteWaypointInfo *)v38 setIsOnSelectedRoute:1];
              md::LabelTransitRoute::buildFeatureForWaypoint((md::LabelTransitRoute *)&v107, v20, v38, 1);
              uint64_t v41 = *(_OWORD **)(v21 + 320);
              if ((unint64_t)v41 >= *(void *)(v21 + 328))
              {
                uint64_t v42 = std::vector<std::shared_ptr<md::RouteAnnotationLabelFeature>,geo::StdAllocator<std::shared_ptr<md::RouteAnnotationLabelFeature>,mdm::Allocator>>::__emplace_back_slow_path<std::shared_ptr<md::RouteAnnotationLabelFeature>>(v98, (uint64_t)&v107);
              }
              else
              {
                if (v41)
                {
                  *uint64_t v41 = v107;
                  long long v107 = 0uLL;
                }
                uint64_t v42 = v41 + 1;
              }
              *(void *)(v21 + 320) = v42;
              long long v43 = (std::__shared_weak_count *)*((void *)&v107 + 1);
              if (*((void *)&v107 + 1)
                && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v107 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v43->__on_zero_shared)(v43);
                std::__shared_weak_count::__release_weak(v43);
              }
            }
          }

          unint64_t v44 = [v100 legs];
          float v45 = [v100 legs];
          BOOL v46 = objc_msgSend(v44, "objectAtIndexedSubscript:", objc_msgSend(v45, "count") - 1);
          uint64_t v47 = [v46 destination];
          unsigned __int8 v48 = [v99 waypointInfoForWaypoint:v47];

          if (v48)
          {
            [(VKRouteWaypointInfo *)v48 setIsOnSelectedRoute:1];
            md::LabelTransitRoute::buildFeatureForWaypoint((md::LabelTransitRoute *)&v107, v20, v48, 0);
            uint64_t v49 = *(_OWORD **)(v21 + 320);
            if ((unint64_t)v49 >= *(void *)(v21 + 328))
            {
              uint64_t v50 = std::vector<std::shared_ptr<md::RouteAnnotationLabelFeature>,geo::StdAllocator<std::shared_ptr<md::RouteAnnotationLabelFeature>,mdm::Allocator>>::__emplace_back_slow_path<std::shared_ptr<md::RouteAnnotationLabelFeature>>(v98, (uint64_t)&v107);
            }
            else
            {
              if (v49)
              {
                *uint64_t v49 = v107;
                long long v107 = 0uLL;
              }
              uint64_t v50 = v49 + 1;
            }
            *(void *)(v21 + 320) = v50;
            long long v51 = (std::__shared_weak_count *)*((void *)&v107 + 1);
            if (*((void *)&v107 + 1)
              && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v107 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v51->__on_zero_shared)(v51);
              std::__shared_weak_count::__release_weak(v51);
            }
          }

          uint64_t v53 = *(char **)(v21 + 312);
          char v52 = *(char **)(v21 + 320);
          if (v52 - v53 >= 1)
          {
            uint64_t v54 = (v52 - v53) >> 4;
            uint64_t v56 = (char *)__p;
            uint64_t v55 = v102;
            unint64_t v57 = v102 - (unsigned char *)__p;
            uint64_t v58 = (v102 - (unsigned char *)__p) >> 4;
            uint64_t v59 = (char *)__p + ((v102 - (unsigned char *)__p) & 0xFFFFFFFFFFFFFFF0);
            if (v54 <= (j - v102) >> 4)
            {
              uint64_t v64 = v102 - v59;
              uint64_t v65 = (v102 - v59) >> 4;
              if (v65 >= v54)
              {
                long long v66 = &v53[16 * v54];
                float v68 = v102;
              }
              else
              {
                long long v66 = &v53[16 * v65];
                if (v66 == v52)
                {
                  float v68 = v102;
                }
                else
                {
                  uint64_t v67 = &v53[16 * v65];
                  float v68 = v102;
                  do
                  {
                    *(void *)float v68 = *(void *)v67;
                    uint64_t v69 = *((void *)v67 + 1);
                    *((void *)v68 + 1) = v69;
                    if (v69) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v69 + 8), 1uLL, memory_order_relaxed);
                    }
                    v68 += 16;
                    v67 += 16;
                  }
                  while (v67 != v52);
                }
                unint64_t v102 = v68;
                if (v64 < 1) {
                  goto LABEL_114;
                }
              }
              uint64_t v80 = &v59[16 * v54];
              char v81 = &v68[-16 * v54];
              char v82 = v68;
              if (v81 < v55)
              {
                char v82 = v68;
                do
                {
                  *(_OWORD *)char v82 = *(_OWORD *)v81;
                  v82 += 16;
                  *(void *)char v81 = 0;
                  *((void *)v81 + 1) = 0;
                  v81 += 16;
                }
                while (v81 < v55);
              }
              unint64_t v102 = v82;
              if (v68 != v80)
              {
                unint64_t v83 = (std::__shared_weak_count **)(v68 - 8);
                uint64_t v84 = 16 * ((v68 - v80) >> 4);
                uint64_t v85 = (uint64_t)&v56[16 * v58 - 16];
                do
                {
                  uint64_t v86 = (void *)(v85 + v84);
                  long long v87 = *(_OWORD *)(v85 + v84);
                  *uint64_t v86 = 0;
                  v86[1] = 0;
                  uint64_t v88 = *v83;
                  *(_OWORD *)(v83 - 1) = v87;
                  if (v88 && !atomic_fetch_add(&v88->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v88->__on_zero_shared)(v88);
                    std::__shared_weak_count::__release_weak(v88);
                  }
                  v83 -= 2;
                  v84 -= 16;
                }
                while (v84);
              }
              for (; v53 != v66; v59 += 16)
              {
                uint64_t v90 = *(void *)v53;
                uint64_t v89 = *((void *)v53 + 1);
                if (v89) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v89 + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t v91 = (std::__shared_weak_count *)*((void *)v59 + 1);
                *(void *)uint64_t v59 = v90;
                *((void *)v59 + 1) = v89;
                if (v91 && !atomic_fetch_add(&v91->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
                  std::__shared_weak_count::__release_weak(v91);
                }
                v53 += 16;
              }
            }
            else
            {
              unint64_t v60 = v58 + v54;
              if ((unint64_t)(v58 + v54) >> 60) {
                abort();
              }
              uint64_t v61 = j - (unsigned char *)__p;
              if ((j - (unsigned char *)__p) >> 3 > v60) {
                unint64_t v60 = v61 >> 3;
              }
              if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v62 = 0xFFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v62 = v60;
              }
              if (v62)
              {
                if (v62 >> 60) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                uint64_t v63 = (char *)operator new(16 * v62);
              }
              else
              {
                uint64_t v63 = 0;
              }
              int v70 = &v63[16 * v58];
              uint64_t v71 = &v70[16 * v54];
              uint64_t v72 = v70;
              do
              {
                *(void *)uint64_t v72 = *(void *)v53;
                uint64_t v73 = *((void *)v53 + 1);
                *((void *)v72 + 1) = v73;
                if (v73) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v73 + 8), 1uLL, memory_order_relaxed);
                }
                v72 += 16;
                v53 += 16;
              }
              while (v72 != v71);
              if (v57 >= 0x10)
              {
                uint64_t v74 = 16 * v58;
                long long v75 = v56 - 16;
                do
                {
                  char v76 = &v75[v74];
                  *(_OWORD *)&v63[v74 - 16] = *(_OWORD *)&v75[v74];
                  *(void *)char v76 = 0;
                  *((void *)v76 + 1) = 0;
                  v74 -= 16;
                }
                while (v74);
                int v70 = v63;
              }
              unint64_t v77 = v102;
              if (v102 != v59)
              {
                do
                {
                  *(_OWORD *)uint64_t v71 = *(_OWORD *)v59;
                  v71 += 16;
                  *(void *)uint64_t v59 = 0;
                  *((void *)v59 + 1) = 0;
                  v59 += 16;
                }
                while (v59 != v77);
                uint64_t v59 = v77;
              }
              float32x2_t v78 = (char *)__p;
              std::string __p = v70;
              unint64_t v102 = v71;
              for (uint64_t j = &v63[16 * v62]; v59 != v78; v59 -= 16)
              {
                uint64_t v79 = (std::__shared_weak_count *)*((void *)v59 - 1);
                if (v79 && !atomic_fetch_add(&v79->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v79->__on_zero_shared)(v79);
                  std::__shared_weak_count::__release_weak(v79);
                }
              }
              if (v78) {
                operator delete(v78);
              }
            }
          }
        }
      }
LABEL_114:

LABEL_115:
      md::LabelTransitSupport::setExternalTransitNodeFeatures((uint64_t)this, (uint64_t **)&v104, (uint64_t **)&__p);
      uint64_t v92 = (char *)__p;
      if (__p)
      {
        uint64_t v93 = v102;
        if (v102 != __p)
        {
          do
          {
            int64_t v94 = (std::__shared_weak_count *)*((void *)v93 - 1);
            if (v94 && !atomic_fetch_add(&v94->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v94->__on_zero_shared)(v94);
              std::__shared_weak_count::__release_weak(v94);
            }
            v93 -= 16;
          }
          while (v93 != v92);
          uint64_t v92 = (char *)__p;
        }
        operator delete(v92);
      }
      uint64_t v95 = (char *)v104;
      if (v104)
      {
        uint64_t v96 = v105;
        if (v105 != v104)
        {
          do
          {
            uint64_t v97 = (std::__shared_weak_count *)*((void *)v96 - 1);
            if (v97 && !atomic_fetch_add(&v97->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v97->__on_zero_shared)(v97);
              std::__shared_weak_count::__release_weak(v97);
            }
            v96 -= 16;
          }
          while (v96 != v95);
          uint64_t v95 = (char *)v104;
        }
        operator delete(v95);
      }
      goto LABEL_133;
    }
    uint64_t v29 = (void *)*((void *)this + 12);
    if (v29)
    {
      *((void *)this + 12) = 0;
    }
    uint64_t v30 = (std::__shared_weak_count *)*((void *)this + 42);
    *((void *)this + 41) = 0;
    *((void *)this + 42) = 0;
    if (v30 && !atomic_fetch_add(&v30->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v30->__on_zero_shared)(v30);
      std::__shared_weak_count::__release_weak(v30);
    }
    int v31 = *((_DWORD *)this + 90);
    if ((v31 + 1) > 1) {
      int v32 = v31 + 1;
    }
    else {
      int v32 = 1;
    }
    *((_DWORD *)this + 90) = v32;
  }
  else
  {
    uint64_t v25 = v4;
    uint64_t v26 = v25;
    if (v25) {
      unint64_t v27 = v25;
    }
    uint64_t v28 = (void *)*((void *)this + 9);
    *((void *)this + 9) = v26;
  }
LABEL_133:
}

void sub_1A1AB13B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, void *a4, void *a5, ...)
{
  va_start(va2, a5);
  va_start(va1, a5);
  va_start(va, a5);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v12 = va_arg(va2, void);
  uint64_t v14 = va_arg(va2, void);
  uint64_t v15 = va_arg(va2, void);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);

  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)va);
  md::DynamicTrafficTileList::~DynamicTrafficTileList((md::DynamicTrafficTileList *)va1);

  _Unwind_Resume(a1);
}

void md::LabelStyleCache::updateNavRoadSignScale(md::LabelStyleCache *this)
{
  int v2 = (std::__shared_weak_count_vtbl *)*((void *)this + 23);
  if (!v2)
  {
    on_zero_shared = 0;
    char v7 = 1;
    float v8 = 1.0;
    float v6 = 1.0;
    float v4 = 1.0;
    goto LABEL_18;
  }
  on_zero_shared = (std::__shared_weak_count *)v2->__on_zero_shared;
  float v4 = 1.0;
  if (!on_zero_shared)
  {
    int v2 = 0;
LABEL_13:
    char v7 = 1;
    float v6 = 1.0;
    goto LABEL_14;
  }
  unsigned __int8 v5 = atomic_load((unsigned __int8 *)&on_zero_shared[116]);
  if ((v5 & 1) == 0) {
    std::__assoc_sub_state::wait((std::__assoc_sub_state *)on_zero_shared[117].__vftable);
  }
  int v2 = on_zero_shared[5].__vftable;
  on_zero_shared = (std::__shared_weak_count *)on_zero_shared[5].__shared_owners_;
  if (on_zero_shared) {
    atomic_fetch_add_explicit(&on_zero_shared->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  if (!v2) {
    goto LABEL_13;
  }
  float v6 = *((float *)&v2[5].~__shared_weak_count_0 + 1);
  char v7 = (char)v2->__on_zero_shared;
  if (v7)
  {
    char v7 = 0;
    float v8 = *((float *)&v2[5].__on_zero_shared + 1);
    uint64_t v9 = *((void *)this + 23);
    if (!v9) {
      goto LABEL_18;
    }
    goto LABEL_15;
  }
LABEL_14:
  float v8 = 1.0;
  uint64_t v9 = *((void *)this + 23);
  if (!v9) {
    goto LABEL_18;
  }
LABEL_15:
  if (*(unsigned char *)(*(void *)(v9 + 16) + 60) == 1) {
    float v4 = 0.75;
  }
  else {
    float v4 = 1.0;
  }
LABEL_18:
  switch(*((unsigned char *)this + 159))
  {
    case 0:
      if ((v7 & 1) != 0 || !BYTE1(v2->__on_zero_shared))
      {
        float v10 = 0.9;
        goto LABEL_39;
      }
      float v6 = *(float *)&v2[5].__get_deleter;
      break;
    case 1:
      if ((v7 & 1) == 0 && BYTE2(v2->__on_zero_shared)) {
        float v6 = *((float *)&v2[5].__get_deleter + 1);
      }
      break;
    case 2:
      if ((v7 & 1) != 0 || !BYTE3(v2->__on_zero_shared))
      {
        float v10 = 1.15;
        goto LABEL_39;
      }
      float v6 = *(float *)&v2[5].__on_zero_shared_weak;
      break;
    case 3:
      if ((v7 & 1) != 0 || !BYTE4(v2->__on_zero_shared))
      {
        float v10 = 1.3;
        goto LABEL_39;
      }
      float v6 = *((float *)&v2[5].__on_zero_shared_weak + 1);
      break;
    case 4:
    case 5:
      if ((v7 & 1) != 0 || !BYTE5(v2->__on_zero_shared))
      {
        float v10 = 1.45;
LABEL_39:
        float v6 = v6 * v10;
      }
      else
      {
        float v6 = *(float *)&v2[6].~__shared_weak_count;
      }
      break;
    default:
      float v6 = 0.0;
      break;
  }
  *((float *)this + 43) = v6 * v8;
  *((float *)this + 44) = v6 * v4;
  if (on_zero_shared && !atomic_fetch_add(&on_zero_shared->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))on_zero_shared->__on_zero_shared)(on_zero_shared);
    std::__shared_weak_count::__release_weak(on_zero_shared);
  }
}

void sub_1A1AB179C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *std::__function::__func<ecs2::ClearComponent::ClearComponent<md::ls::ItemsPrepared>(std::type_identity<md::ls::ItemsPrepared>)::{lambda(gdc::Registry &)#1},std::allocator<ecs2::ClearComponent::ClearComponent<md::ls::ItemsPrepared>(std::type_identity<md::ls::ItemsPrepared>)::{lambda(gdc::Registry &)#1}>,void ()(gdc::Registry &)>::operator()(uint64_t a1, int8x8_t *a2)
{
  __n128 result = (void *)gdc::Registry::storage<md::ls::ItemsPrepared>(a2);
  uint64_t v3 = result;
  if (result[29] && (float v4 = (void *)result[28]) != 0)
  {
    uint64_t v5 = result[31];
    uint64_t v6 = result[7];
    uint64_t v7 = (result[8] - v6) >> 3;
    while (1)
    {
      v10[0] = v6;
      v10[1] = v7;
      uint64_t v9 = v5;
      uint64_t v8 = v4[6];
      if (!v8) {
        break;
      }
      __n128 result = (void *)(*(uint64_t (**)(uint64_t, uint64_t *, void *))(*(void *)v8 + 48))(v8, &v9, v10);
      float v4 = (void *)*v4;
      if (!v4) {
        goto LABEL_6;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return (void *)std::__function::__func<ecs2::ForwardToExecute<md::ita::PushRenderItems>,std::allocator<ecs2::ForwardToExecute<md::ita::PushRenderItems>>,void ()(ecs2::Runtime &)>::operator()();
  }
  else
  {
LABEL_6:
    v3[8] = v3[7];
    v3[11] = v3[10];
  }
  return result;
}

uint64_t std::__function::__func<ecs2::ForwardToExecute<md::ita::PushRenderItems>,std::allocator<ecs2::ForwardToExecute<md::ita::PushRenderItems>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  *(void *)(a1 + 8) = a2;
  uint64_t v3 = *(int8x8_t **)(a2 + 8);
  float v4 = (void *)gdc::Registry::storage<md::ls::RenderItemID>(v3);
  uint64_t v5 = gdc::Registry::storage<md::ls::ItemsPrepared>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::CommandBufferRef>(v3);
  uint64_t v7 = (void *)v6;
  uint64_t v8 = v4 + 4;
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) < v4[8] - v4[7]) {
    uint64_t v8 = (void *)(v5 + 32);
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) < v8[4] - v8[3]) {
    uint64_t v8 = (void *)(v6 + 32);
  }
  char v76 = v8;
  unint64_t v77 = v4;
  float32x2_t v78 = (void *)v5;
  uint64_t v79 = (void *)v6;
  float v10 = (void *)v8[3];
  uint64_t v9 = (void *)v8[4];
  uint64_t v80 = v10;
  long long v75 = v9;
  if (v9 != v10
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v76))
  {
    uint64_t v11 = v10 + 1;
    do
    {
      float v10 = v11;
      uint64_t v80 = v11;
      if (v11 == v75) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v76);
      uint64_t v11 = v10 + 1;
    }
    while (!isValid);
  }
  if (v75 == v10)
  {
    uint64_t result = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    unint64_t v13 = (void *)result;
  }
  else
  {
    unint64_t v13 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v74 = v4;
    do
    {
      *unint64_t v13 = *v10;
      unint64_t v15 = *v10;
      uint64_t v16 = HIDWORD(*v10);
      unint64_t v17 = *v10 >> 39;
      uint64_t v18 = v4[4];
      if (v17 < (v4[5] - v18) >> 3
        && (uint64_t v19 = *(void *)(v18 + 8 * v17)) != 0
        && (unint64_t v20 = *(unsigned __int16 *)(v19 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v22 = v4[7],
            uint64_t v21 = v4[8],
            v20 < (v21 - v22) >> 3)
        && ((uint64_t v23 = v22 + 8 * v20, v23 != v21) ? (v24 = *(_DWORD *)(v23 + 4) == v16) : (v24 = 0), v24))
      {
        uint64_t v25 = v4[11];
        uint64_t v26 = v4[10] + 24 * v20;
      }
      else
      {
        uint64_t v25 = v4[11];
        uint64_t v26 = v25;
      }
      if (v26 == v25) {
        unint64_t v27 = 0;
      }
      else {
        unint64_t v27 = (unint64_t *)v26;
      }
      uint64_t v28 = v7[4];
      if (v17 < (v7[5] - v28) >> 3
        && (uint64_t v29 = *(void *)(v28 + 8 * v17)) != 0
        && (unint64_t v30 = *(unsigned __int16 *)(v29 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v32 = v7[7],
            uint64_t v31 = v7[8],
            v30 < (v31 - v32) >> 3)
        && ((uint64_t v33 = v32 + 8 * v30, v33 != v31) ? (v34 = *(_DWORD *)(v33 + 4) == v16) : (v34 = 0), v34))
      {
        uint64_t v35 = (void *)(v7[10] + 8 * v30);
      }
      else
      {
        uint64_t v35 = (void *)v7[11];
      }
      uint64_t v36 = **(void **)(v2 + 8);
      uint64_t v37 = *(void **)v36;
      uint64_t v38 = *(void **)(v36 + 8);
      if (v37 != v38)
      {
        while (*v37 != 0x41D4E9297E100630)
        {
          v37 += 5;
          if (v37 == v38) {
            goto LABEL_42;
          }
        }
      }
      if (v37 == v38)
      {
LABEL_42:
        uint64_t v39 = 0;
      }
      else
      {
        uint64_t v39 = (int8x8_t *)v37[3];
        char v40 = (std::__shared_weak_count *)v37[4];
        if (v40)
        {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v40->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v40->__on_zero_shared)(v40);
            std::__shared_weak_count::__release_weak(v40);
          }
        }
      }
      uint64_t v41 = **(void **)(v2 + 8);
      uint64_t v42 = *(void **)v41;
      long long v43 = *(void **)(v41 + 8);
      if (v42 != v43)
      {
        while (*v42 != 0xC94DD89A7B09BE9CLL)
        {
          v42 += 5;
          if (v42 == v43)
          {
            uint64_t v44 = 0;
            goto LABEL_54;
          }
        }
      }
      if (v42 == v43)
      {
        uint64_t v44 = 0;
      }
      else
      {
        float v45 = v7;
        uint64_t v46 = v2;
        uint64_t v47 = v13;
        uint64_t v44 = v42[3];
        unsigned __int8 v48 = (std::__shared_weak_count *)v42[4];
        if (v48)
        {
          atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
            std::__shared_weak_count::__release_weak(v48);
          }
        }
        unint64_t v13 = v47;
        uint64_t v2 = v46;
        uint64_t v7 = v45;
      }
      float v4 = v74;
LABEL_54:
      RenderIteuint64_t m = md::VKMRenderResourcesStore::getRenderItem(v39, *v27, v27[1]);
      uint64_t v50 = (*(uint64_t (**)(uint64_t, void))(*(void *)v44 + 40))(v44, *v35);
      uint64_t result = ggl::CommandBuffer::pushRenderItem(v50, RenderItem);
      float v10 = (void *)v76[4];
      uint64_t v14 = v80 + 1;
      uint64_t v80 = v14;
      if (v14 != v10)
      {
        uint64_t v52 = v77[4];
        while (1)
        {
          unint64_t v53 = *((unsigned int *)v14 + 1);
          unint64_t v54 = v53 >> 7;
          if (v53 >> 7 < (v77[5] - v52) >> 3)
          {
            uint64_t v55 = *(void *)(v52 + 8 * v54);
            if (v55)
            {
              uint64_t v56 = v53 & 0x7F;
              unint64_t v57 = *(unsigned __int16 *)(v55 + 2 * v56);
              uint64_t v58 = v77[7];
              uint64_t result = v77[8];
              if (v57 < (result - v58) >> 3)
              {
                uint64_t v59 = v58 + 8 * v57;
                if (v59 != result && *(_DWORD *)(v59 + 4) == v53)
                {
                  uint64_t v61 = v78[4];
                  uint64_t result = v78[5] - v61;
                  if (v54 < result >> 3)
                  {
                    uint64_t v62 = *(void *)(v61 + 8 * v54);
                    if (v62)
                    {
                      unint64_t v63 = *(unsigned __int16 *)(v62 + 2 * v56);
                      uint64_t v64 = v78[7];
                      uint64_t result = v78[8];
                      if (v63 < (result - v64) >> 3)
                      {
                        uint64_t v65 = v64 + 8 * v63;
                        if (v65 != result && *(_DWORD *)(v65 + 4) == v53)
                        {
                          uint64_t v67 = v79[4];
                          uint64_t result = v79[5] - v67;
                          if (v54 < result >> 3)
                          {
                            uint64_t v68 = *(void *)(v67 + 8 * v54);
                            if (v68)
                            {
                              unint64_t v69 = *(unsigned __int16 *)(v68 + 2 * v56);
                              uint64_t v71 = v79[7];
                              uint64_t v70 = v79[8];
                              uint64_t result = v70 - v71;
                              if (v69 < (v70 - v71) >> 3)
                              {
                                uint64_t v72 = v71 + 8 * v69;
                                if (*(_DWORD *)(v72 + 4) == v53 && v72 != v70) {
                                  break;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (++v14 == v10)
          {
            uint64_t v14 = v10;
            goto LABEL_13;
          }
        }
        float v10 = v14;
LABEL_13:
        uint64_t v80 = v14;
      }
    }
    while (v75 != v10);
  }
  *unint64_t v13 = 0xFFFFFFFF00000000;
  *(void *)(v2 + 8) = 0;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::ItemsPrepared>(int8x8_t *a1)
{
  unint64_t v10 = 0xC120277B06FDA0DALL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xC120277B06FDA0DALL;
    if (*(void *)&v1 <= 0xC120277B06FDA0DALL) {
      unint64_t v3 = 0xC120277B06FDA0DALL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xC120277B06FDA0DALL;
  }
  float v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xC120277B06FDA0DALL)
      {
        if (v5[2] == 0xC120277B06FDA0DALL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xC120277B06FDA0DALL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xC120277B06FDA0DALL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1AB1F74(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::CommandBufferRef>(int8x8_t *a1)
{
  unint64_t v10 = 0xE74BE2A9DD9BA5F1;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xE74BE2A9DD9BA5F1;
    if (*(void *)&v1 <= 0xE74BE2A9DD9BA5F1) {
      unint64_t v3 = 0xE74BE2A9DD9BA5F1 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xE74BE2A9DD9BA5F1;
  }
  float v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xE74BE2A9DD9BA5F1)
      {
        if (v5[2] == 0xE74BE2A9DD9BA5F1) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xE74BE2A9DD9BA5F1) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xE74BE2A9DD9BA5F1) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1AB21E4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void *md::CartographicRenderer::prune(void *result, uint64_t a2)
{
  uint8x8_t v2 = (void **)result[5];
  for (uint64_t i = (void **)result[6]; v2 != i; ++v2)
  {
    uint64_t result = *v2;
    if (*v2) {
      uint64_t result = (void *)(*(uint64_t (**)(void *, uint64_t))(*result + 56))(result, a2);
    }
  }
  return result;
}

uint64_t *md::RenderLayerProviderWrapper::resetAllResources(md::RenderLayerProviderWrapper *this)
{
  uint64_t v1 = *((void *)this + 1);
  if (*(void *)(v1 + 120))
  {
    uint8x8_t v2 = *(void **)(v1 + 112);
    if (v2)
    {
      do
      {
        uint64_t v6 = (void *)*v2;
        unint64_t v7 = (void *)v2[4];
        if (v7)
        {
          v2[5] = v7;
          operator delete(v7);
        }
        operator delete(v2);
        uint8x8_t v2 = v6;
      }
      while (v6);
    }
    *(void *)(v1 + 112) = 0;
    uint64_t v3 = *(void *)(v1 + 104);
    if (v3)
    {
      for (uint64_t i = 0; i != v3; ++i)
        *(void *)(*(void *)(v1 + 96) + 8 * i) = 0;
    }
    *(void *)(v1 + 120) = 0;
  }
  for (uint64_t j = *(void *)(v1 + 80); j != *(void *)(v1 + 72); *(void *)(v1 + 8) = v8)
  {
    uint64_t v10 = *(void *)(j - 8);
    j -= 8;
    uint64_t v9 = v10;
    uint64_t v11 = *(void *)(v1 + 24);
    unint64_t v12 = *(void *)(v1 + 32) - v11;
    uint64_t v13 = v11 + 8 * v10;
    unint64_t v14 = (unint64_t)*(unsigned int *)(v13 + 4) << 32;
    *(_DWORD *)(v13 + 4) = (v14 + 0x100000000) >> 32;
    *(void *)(*(void *)(v1 + 24) + 8 * v10) = v14 & 0xFFFFFFFF00000000 | (v12 >> 3);
    uint64_t v16 = *(char **)(v1 + 8);
    unint64_t v15 = *(void *)(v1 + 16);
    if ((unint64_t)v16 < v15)
    {
      *(void *)uint64_t v16 = v9;
      uint64_t v8 = v16 + 8;
    }
    else
    {
      unint64_t v17 = *(char **)v1;
      uint64_t v18 = (uint64_t)&v16[-*(void *)v1];
      uint64_t v19 = v18 >> 3;
      unint64_t v20 = (v18 >> 3) + 1;
      if (v20 >> 61) {
        abort();
      }
      uint64_t v21 = v15 - (void)v17;
      if (v21 >> 2 > v20) {
        unint64_t v20 = v21 >> 2;
      }
      if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v22 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v22 = v20;
      }
      if (v22)
      {
        if (v22 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v23 = operator new(8 * v22);
      }
      else
      {
        uint64_t v23 = 0;
      }
      BOOL v24 = &v23[8 * v19];
      void *v24 = v9;
      uint64_t v8 = v24 + 1;
      if (v16 != v17)
      {
        unint64_t v25 = v16 - 8 - v17;
        if (v25 < 0x58) {
          goto LABEL_55;
        }
        if ((unint64_t)(v16 - &v23[v18]) < 0x20) {
          goto LABEL_55;
        }
        uint64_t v26 = (v25 >> 3) + 1;
        unint64_t v27 = &v23[8 * v19 - 16];
        uint64_t v28 = v16 - 16;
        uint64_t v29 = v26 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v30 = *(_OWORD *)v28;
          *(v27 - 1) = *((_OWORD *)v28 - 1);
          _OWORD *v27 = v30;
          v27 -= 2;
          v28 -= 32;
          v29 -= 4;
        }
        while (v29);
        v24 -= v26 & 0x3FFFFFFFFFFFFFFCLL;
        v16 -= 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
        if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_55:
          do
          {
            uint64_t v31 = *((void *)v16 - 1);
            v16 -= 8;
            *--BOOL v24 = v31;
          }
          while (v16 != v17);
        }
      }
      *(void *)uint64_t v1 = v24;
      *(void *)(v1 + 8) = v8;
      *(void *)(v1 + 16) = &v23[8 * v22];
      if (v17) {
        operator delete(v17);
      }
    }
  }
  *(void *)(v1 + 80) = j;
  *(void *)(v1 + 56) = *(void *)(v1 + 48);
  md::DaVinciGroundRenderResources::resetPools((md::DaVinciGroundRenderResources *)(v1 + 136));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4016));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4040));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4064));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4088));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4112));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4120));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4128));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4136));
  ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4144));
  uint64_t v32 = *(void **)(v1 + 2896);
  if (v32)
  {
    do
    {
      if (v32[1])
      {
        unint64_t v34 = 0;
        uint64_t v35 = v32 + 2;
        uint64_t v36 = v32 + 2;
        uint64_t v37 = (void (***)(void))(v32 + 2);
        do
        {
          uint64_t v38 = (void (**)(void *))*v37;
          v37 += 15;
          (*v38)(v36);
          ++v34;
          v35 += 15;
          uint64_t v36 = v37;
        }
        while (v34 < v32[1]);
      }
      v32[1] = 0;
      uint64_t v32 = (void *)*v32;
    }
    while (v32);
    uint64_t v33 = *(void *)(v1 + 2896);
  }
  else
  {
    uint64_t v33 = 0;
  }
  *(void *)(v1 + 2904) = v33;
  uint64_t result = ggl::FragmentedPool<ggl::RenderItem>::pushAll(*(uint64_t **)(v1 + 4272));
  char v40 = *(void **)(v1 + 4296);
  if (v40)
  {
    do
    {
      if (v40[1])
      {
        unint64_t v42 = 0;
        long long v43 = v40 + 2;
        uint64_t result = v40 + 2;
        uint64_t v44 = v40 + 2;
        do
        {
          float v45 = (void (**)(uint64_t *))*v44;
          v44 += 15;
          (*v45)(result);
          ++v42;
          v43 += 15;
          uint64_t result = v44;
        }
        while (v42 < v40[1]);
      }
      v40[1] = 0;
      char v40 = (void *)*v40;
    }
    while (v40);
    uint64_t v41 = *(void *)(v1 + 4296);
  }
  else
  {
    uint64_t v41 = 0;
  }
  *(void *)(v1 + 4304) = v41;
  *((void *)this + 5) = *((void *)this + 4);
  return result;
}

uint64_t *ggl::FragmentedPool<ggl::RenderItem>::pushAll(uint64_t *result)
{
  uint64_t v1 = (uint64_t *)result[4];
  uint8x8_t v2 = (uint64_t *)result[5];
  if (v1 != v2)
  {
    uint64_t v3 = result;
    float v4 = (void *)result[1];
    while (1)
    {
      uint64_t v5 = *v1;
      unint64_t v6 = v3[2];
      if ((unint64_t)v4 >= v6) {
        break;
      }
      if (v4) {
        void *v4 = v5;
      }
      ++v4;
LABEL_4:
      v3[1] = (uint64_t)v4;
      if (++v1 == v2)
      {
        uint64_t v25 = v3[4];
        if (v25 != v3[5]) {
          v3[5] = v25;
        }
        return result;
      }
    }
    uint64_t v7 = ((uint64_t)v4 - *v3) >> 3;
    if ((unint64_t)(v7 + 1) >> 61) {
      abort();
    }
    uint64_t v8 = v6 - *v3;
    uint64_t v9 = v8 >> 2;
    if (v8 >> 2 <= (unint64_t)(v7 + 1)) {
      uint64_t v9 = v7 + 1;
    }
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v10 = v9;
    }
    if (v10)
    {
      uint64_t v11 = v10;
      uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[3] + 16))(v3[3], 8 * v10, 8);
      unint64_t v12 = &result[v7];
      uint64_t v10 = (uint64_t)&result[v11];
      if (result) {
        *unint64_t v12 = v5;
      }
    }
    else
    {
      unint64_t v12 = (uint64_t *)(8 * v7);
    }
    uint64_t v14 = *v3;
    uint64_t v13 = v3[1];
    uint64_t v15 = v13 - *v3;
    if (v13 == *v3)
    {
      unint64_t v17 = v12;
      goto LABEL_29;
    }
    unint64_t v16 = v15 - 8;
    if ((unint64_t)(v15 - 8) < 0x38)
    {
      unint64_t v17 = v12;
    }
    else
    {
      unint64_t v17 = v12;
      if ((unint64_t)(v13 - (void)v12) >= 0x20)
      {
        uint64_t v18 = (v16 >> 3) + 1;
        uint64_t v19 = v12 - 2;
        unint64_t v20 = (long long *)(v13 - 16);
        uint64_t v21 = v18 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v22 = *v20;
          *((_OWORD *)v19 - 1) = *(v20 - 1);
          *(_OWORD *)uint64_t v19 = v22;
          v19 -= 4;
          v20 -= 2;
          v21 -= 4;
        }
        while (v21);
        unint64_t v17 = &v12[-(v18 & 0x3FFFFFFFFFFFFFFCLL)];
        v13 -= 8 * (v18 & 0x3FFFFFFFFFFFFFFCLL);
        if (v18 == (v18 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_28;
        }
      }
    }
    do
    {
      uint64_t v23 = *(void *)(v13 - 8);
      v13 -= 8;
      *--unint64_t v17 = v23;
    }
    while (v13 != v14);
LABEL_28:
    uint64_t v13 = *v3;
LABEL_29:
    float v4 = v12 + 1;
    uint64_t *v3 = (uint64_t)v17;
    v3[1] = (uint64_t)(v12 + 1);
    uint64_t v24 = v3[2];
    v3[2] = v10;
    if (v13) {
      uint64_t result = (uint64_t *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v3[3] + 40))(v3[3], v13, v24 - v13);
    }
    goto LABEL_4;
  }
  return result;
}

void md::DaVinciGroundRenderResources::resetPools(md::DaVinciGroundRenderResources *this)
{
  uint8x8_t v2 = (uint64_t *)*((void *)this + 135);
  uint64_t v3 = (uint64_t *)v2[4];
  float v4 = (uint64_t *)v2[5];
  if (v3 == v4) {
    goto LABEL_33;
  }
  uint64_t v5 = (void *)v2[1];
  do
  {
    uint64_t v6 = *v3;
    unint64_t v7 = v2[2];
    if ((unint64_t)v5 < v7)
    {
      if (v5) {
        void *v5 = v6;
      }
      ++v5;
      goto LABEL_4;
    }
    uint64_t v8 = ((uint64_t)v5 - *v2) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
LABEL_751:
    }
      abort();
    uint64_t v9 = v7 - *v2;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v10;
    }
    if (v11)
    {
      uint64_t v12 = 8 * v11;
      uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[3] + 16))(v2[3], 8 * v11, 8);
      uint64_t v14 = (void *)(v13 + 8 * v8);
      uint64_t v11 = v13 + v12;
      if (v13) {
        *uint64_t v14 = v6;
      }
    }
    else
    {
      uint64_t v14 = (void *)(8 * v8);
    }
    uint64_t v16 = *v2;
    uint64_t v15 = v2[1];
    uint64_t v17 = v15 - *v2;
    if (v15 == *v2)
    {
      uint64_t v19 = v14;
      goto LABEL_29;
    }
    unint64_t v18 = v17 - 8;
    if ((unint64_t)(v17 - 8) < 0x38)
    {
      uint64_t v19 = v14;
    }
    else
    {
      uint64_t v19 = v14;
      if ((unint64_t)(v15 - (void)v14) >= 0x20)
      {
        uint64_t v20 = (v18 >> 3) + 1;
        uint64_t v21 = v14 - 2;
        long long v22 = (long long *)(v15 - 16);
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *v22;
          *(v21 - 1) = *(v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 2;
          v23 -= 4;
        }
        while (v23);
        uint64_t v19 = &v14[-(v20 & 0x3FFFFFFFFFFFFFFCLL)];
        v15 -= 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
        if (v20 == (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_28;
        }
      }
    }
    do
    {
      uint64_t v25 = *(void *)(v15 - 8);
      v15 -= 8;
      *--uint64_t v19 = v25;
    }
    while (v15 != v16);
LABEL_28:
    uint64_t v15 = *v2;
LABEL_29:
    uint64_t v5 = v14 + 1;
    *uint8x8_t v2 = (uint64_t)v19;
    v2[1] = (uint64_t)(v14 + 1);
    uint64_t v26 = v2[2];
    v2[2] = v11;
    if (v15) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[3] + 40))(v2[3], v15, v26 - v15);
    }
LABEL_4:
    v2[1] = (uint64_t)v5;
    ++v3;
  }
  while (v3 != v4);
  uint64_t v27 = v2[4];
  if (v27 != v2[5]) {
    v2[5] = v27;
  }
LABEL_33:
  uint64_t v28 = (uint64_t *)*((void *)this + 179);
  uint64_t v29 = (uint64_t *)v28[4];
  long long v30 = (uint64_t *)v28[5];
  if (v29 == v30) {
    goto LABEL_65;
  }
  uint64_t v31 = (void *)v28[1];
  while (2)
  {
    uint64_t v32 = *v29;
    unint64_t v33 = v28[2];
    if ((unint64_t)v31 < v33)
    {
      if (v31) {
        *uint64_t v31 = v32;
      }
      ++v31;
      goto LABEL_36;
    }
    uint64_t v34 = ((uint64_t)v31 - *v28) >> 3;
    if ((unint64_t)(v34 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v35 = v33 - *v28;
    uint64_t v36 = v35 >> 2;
    if (v35 >> 2 <= (unint64_t)(v34 + 1)) {
      uint64_t v36 = v34 + 1;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v37 = v36;
    }
    if (v37)
    {
      uint64_t v38 = 8 * v37;
      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v28[3] + 16))(v28[3], 8 * v37, 8);
      char v40 = (void *)(v39 + 8 * v34);
      uint64_t v37 = v39 + v38;
      if (v39) {
        *char v40 = v32;
      }
    }
    else
    {
      char v40 = (void *)(8 * v34);
    }
    uint64_t v42 = *v28;
    uint64_t v41 = v28[1];
    uint64_t v43 = v41 - *v28;
    if (v41 == *v28)
    {
      float v45 = v40;
      goto LABEL_61;
    }
    unint64_t v44 = v43 - 8;
    if ((unint64_t)(v43 - 8) < 0x38)
    {
      float v45 = v40;
      do
      {
LABEL_59:
        uint64_t v51 = *(void *)(v41 - 8);
        v41 -= 8;
        *--float v45 = v51;
      }
      while (v41 != v42);
      goto LABEL_60;
    }
    float v45 = v40;
    if ((unint64_t)(v41 - (void)v40) < 0x20) {
      goto LABEL_59;
    }
    uint64_t v46 = (v44 >> 3) + 1;
    uint64_t v47 = v40 - 2;
    unsigned __int8 v48 = (long long *)(v41 - 16);
    uint64_t v49 = v46 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v50 = *v48;
      *(v47 - 1) = *(v48 - 1);
      _OWORD *v47 = v50;
      v47 -= 2;
      v48 -= 2;
      v49 -= 4;
    }
    while (v49);
    float v45 = &v40[-(v46 & 0x3FFFFFFFFFFFFFFCLL)];
    v41 -= 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
    if (v46 != (v46 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_59;
    }
LABEL_60:
    uint64_t v41 = *v28;
LABEL_61:
    uint64_t v31 = v40 + 1;
    *uint64_t v28 = (uint64_t)v45;
    v28[1] = (uint64_t)(v40 + 1);
    uint64_t v52 = v28[2];
    v28[2] = v37;
    if (v41) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v28[3] + 40))(v28[3], v41, v52 - v41);
    }
LABEL_36:
    v28[1] = (uint64_t)v31;
    if (++v29 != v30) {
      continue;
    }
    break;
  }
  uint64_t v53 = v28[4];
  if (v53 != v28[5]) {
    v28[5] = v53;
  }
LABEL_65:
  unint64_t v54 = (uint64_t *)*((void *)this + 180);
  uint64_t v55 = (uint64_t *)v54[4];
  uint64_t v56 = (uint64_t *)v54[5];
  if (v55 == v56) {
    goto LABEL_97;
  }
  unint64_t v57 = (void *)v54[1];
  while (2)
  {
    uint64_t v58 = *v55;
    unint64_t v59 = v54[2];
    if ((unint64_t)v57 < v59)
    {
      if (v57) {
        *unint64_t v57 = v58;
      }
      ++v57;
      goto LABEL_68;
    }
    uint64_t v60 = ((uint64_t)v57 - *v54) >> 3;
    if ((unint64_t)(v60 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v61 = v59 - *v54;
    uint64_t v62 = v61 >> 2;
    if (v61 >> 2 <= (unint64_t)(v60 + 1)) {
      uint64_t v62 = v60 + 1;
    }
    if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v63 = v62;
    }
    if (v63)
    {
      uint64_t v64 = 8 * v63;
      uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v54[3] + 16))(v54[3], 8 * v63, 8);
      long long v66 = (void *)(v65 + 8 * v60);
      uint64_t v63 = v65 + v64;
      if (v65) {
        *long long v66 = v58;
      }
    }
    else
    {
      long long v66 = (void *)(8 * v60);
    }
    uint64_t v68 = *v54;
    uint64_t v67 = v54[1];
    uint64_t v69 = v67 - *v54;
    if (v67 == *v54)
    {
      uint64_t v71 = v66;
      goto LABEL_93;
    }
    unint64_t v70 = v69 - 8;
    if ((unint64_t)(v69 - 8) < 0x38)
    {
      uint64_t v71 = v66;
      do
      {
LABEL_91:
        uint64_t v77 = *(void *)(v67 - 8);
        v67 -= 8;
        *--uint64_t v71 = v77;
      }
      while (v67 != v68);
      goto LABEL_92;
    }
    uint64_t v71 = v66;
    if ((unint64_t)(v67 - (void)v66) < 0x20) {
      goto LABEL_91;
    }
    uint64_t v72 = (v70 >> 3) + 1;
    uint64_t v73 = v66 - 2;
    uint64_t v74 = (long long *)(v67 - 16);
    uint64_t v75 = v72 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v76 = *v74;
      *(v73 - 1) = *(v74 - 1);
      _OWORD *v73 = v76;
      v73 -= 2;
      v74 -= 2;
      v75 -= 4;
    }
    while (v75);
    uint64_t v71 = &v66[-(v72 & 0x3FFFFFFFFFFFFFFCLL)];
    v67 -= 8 * (v72 & 0x3FFFFFFFFFFFFFFCLL);
    if (v72 != (v72 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_91;
    }
LABEL_92:
    uint64_t v67 = *v54;
LABEL_93:
    unint64_t v57 = v66 + 1;
    *unint64_t v54 = (uint64_t)v71;
    v54[1] = (uint64_t)(v66 + 1);
    uint64_t v78 = v54[2];
    v54[2] = v63;
    if (v67) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v54[3] + 40))(v54[3], v67, v78 - v67);
    }
LABEL_68:
    v54[1] = (uint64_t)v57;
    if (++v55 != v56) {
      continue;
    }
    break;
  }
  uint64_t v79 = v54[4];
  if (v79 != v54[5]) {
    v54[5] = v79;
  }
LABEL_97:
  uint64_t v80 = (uint64_t *)*((void *)this + 139);
  char v81 = (uint64_t *)v80[4];
  char v82 = (uint64_t *)v80[5];
  if (v81 == v82) {
    goto LABEL_129;
  }
  unint64_t v83 = (void *)v80[1];
  while (2)
  {
    uint64_t v84 = *v81;
    unint64_t v85 = v80[2];
    if ((unint64_t)v83 < v85)
    {
      if (v83) {
        *unint64_t v83 = v84;
      }
      ++v83;
      goto LABEL_100;
    }
    uint64_t v86 = ((uint64_t)v83 - *v80) >> 3;
    if ((unint64_t)(v86 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v87 = v85 - *v80;
    uint64_t v88 = v87 >> 2;
    if (v87 >> 2 <= (unint64_t)(v86 + 1)) {
      uint64_t v88 = v86 + 1;
    }
    if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v89 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v89 = v88;
    }
    if (v89)
    {
      uint64_t v90 = 8 * v89;
      uint64_t v91 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80[3] + 16))(v80[3], 8 * v89, 8);
      uint64_t v92 = (void *)(v91 + 8 * v86);
      uint64_t v89 = v91 + v90;
      if (v91) {
        void *v92 = v84;
      }
    }
    else
    {
      uint64_t v92 = (void *)(8 * v86);
    }
    uint64_t v94 = *v80;
    uint64_t v93 = v80[1];
    uint64_t v95 = v93 - *v80;
    if (v93 == *v80)
    {
      uint64_t v97 = v92;
      goto LABEL_125;
    }
    unint64_t v96 = v95 - 8;
    if ((unint64_t)(v95 - 8) < 0x38)
    {
      uint64_t v97 = v92;
      do
      {
LABEL_123:
        uint64_t v103 = *(void *)(v93 - 8);
        v93 -= 8;
        *--uint64_t v97 = v103;
      }
      while (v93 != v94);
      goto LABEL_124;
    }
    uint64_t v97 = v92;
    if ((unint64_t)(v93 - (void)v92) < 0x20) {
      goto LABEL_123;
    }
    uint64_t v98 = (v96 >> 3) + 1;
    uint64_t v99 = v92 - 2;
    id v100 = (long long *)(v93 - 16);
    uint64_t v101 = v98 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v102 = *v100;
      *(v99 - 1) = *(v100 - 1);
      *uint64_t v99 = v102;
      v99 -= 2;
      v100 -= 2;
      v101 -= 4;
    }
    while (v101);
    uint64_t v97 = &v92[-(v98 & 0x3FFFFFFFFFFFFFFCLL)];
    v93 -= 8 * (v98 & 0x3FFFFFFFFFFFFFFCLL);
    if (v98 != (v98 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_123;
    }
LABEL_124:
    uint64_t v93 = *v80;
LABEL_125:
    unint64_t v83 = v92 + 1;
    *uint64_t v80 = (uint64_t)v97;
    v80[1] = (uint64_t)(v92 + 1);
    uint64_t v104 = v80[2];
    v80[2] = v89;
    if (v93) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80[3] + 40))(v80[3], v93, v104 - v93);
    }
LABEL_100:
    v80[1] = (uint64_t)v83;
    if (++v81 != v82) {
      continue;
    }
    break;
  }
  uint64_t v105 = v80[4];
  if (v105 != v80[5]) {
    void v80[5] = v105;
  }
LABEL_129:
  uint64_t v106 = (uint64_t *)*((void *)this + 140);
  long long v107 = (uint64_t *)v106[4];
  int64x2_t v108 = (uint64_t *)v106[5];
  if (v107 == v108) {
    goto LABEL_161;
  }
  uint64_t v109 = (void *)v106[1];
  while (2)
  {
    uint64_t v110 = *v107;
    unint64_t v111 = v106[2];
    if ((unint64_t)v109 < v111)
    {
      if (v109) {
        *uint64_t v109 = v110;
      }
      ++v109;
      goto LABEL_132;
    }
    uint64_t v112 = ((uint64_t)v109 - *v106) >> 3;
    if ((unint64_t)(v112 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v113 = v111 - *v106;
    uint64_t v114 = v113 >> 2;
    if (v113 >> 2 <= (unint64_t)(v112 + 1)) {
      uint64_t v114 = v112 + 1;
    }
    if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v115 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v115 = v114;
    }
    if (v115)
    {
      uint64_t v116 = 8 * v115;
      uint64_t v117 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v106[3] + 16))(v106[3], 8 * v115, 8);
      uint64_t v118 = (void *)(v117 + 8 * v112);
      uint64_t v115 = v117 + v116;
      if (v117) {
        void *v118 = v110;
      }
    }
    else
    {
      uint64_t v118 = (void *)(8 * v112);
    }
    uint64_t v120 = *v106;
    uint64_t v119 = v106[1];
    uint64_t v121 = v119 - *v106;
    if (v119 == *v106)
    {
      int8x16_t v123 = v118;
      goto LABEL_157;
    }
    unint64_t v122 = v121 - 8;
    if ((unint64_t)(v121 - 8) < 0x38)
    {
      int8x16_t v123 = v118;
      do
      {
LABEL_155:
        uint64_t v129 = *(void *)(v119 - 8);
        v119 -= 8;
        *--int8x16_t v123 = v129;
      }
      while (v119 != v120);
      goto LABEL_156;
    }
    int8x16_t v123 = v118;
    if ((unint64_t)(v119 - (void)v118) < 0x20) {
      goto LABEL_155;
    }
    uint64_t v124 = (v122 >> 3) + 1;
    uint64_t v125 = v118 - 2;
    uint64_t v126 = (long long *)(v119 - 16);
    uint64_t v127 = v124 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v128 = *v126;
      *(v125 - 1) = *(v126 - 1);
      *uint64_t v125 = v128;
      v125 -= 2;
      v126 -= 2;
      v127 -= 4;
    }
    while (v127);
    int8x16_t v123 = &v118[-(v124 & 0x3FFFFFFFFFFFFFFCLL)];
    v119 -= 8 * (v124 & 0x3FFFFFFFFFFFFFFCLL);
    if (v124 != (v124 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_155;
    }
LABEL_156:
    uint64_t v119 = *v106;
LABEL_157:
    uint64_t v109 = v118 + 1;
    *uint64_t v106 = (uint64_t)v123;
    v106[1] = (uint64_t)(v118 + 1);
    uint64_t v130 = v106[2];
    v106[2] = v115;
    if (v119) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v106[3] + 40))(v106[3], v119, v130 - v119);
    }
LABEL_132:
    v106[1] = (uint64_t)v109;
    if (++v107 != v108) {
      continue;
    }
    break;
  }
  uint64_t v131 = v106[4];
  if (v131 != v106[5]) {
    v106[5] = v131;
  }
LABEL_161:
  unint64_t v132 = (uint64_t *)*((void *)this + 141);
  int64x2_t v133 = (uint64_t *)v132[4];
  uint64_t v134 = (uint64_t *)v132[5];
  if (v133 == v134) {
    goto LABEL_193;
  }
  uint8x16_t v135 = (void *)v132[1];
  while (2)
  {
    uint64_t v136 = *v133;
    unint64_t v137 = v132[2];
    if ((unint64_t)v135 < v137)
    {
      if (v135) {
        *uint8x16_t v135 = v136;
      }
      ++v135;
      goto LABEL_164;
    }
    uint64_t v138 = ((uint64_t)v135 - *v132) >> 3;
    if ((unint64_t)(v138 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v139 = v137 - *v132;
    uint64_t v140 = v139 >> 2;
    if (v139 >> 2 <= (unint64_t)(v138 + 1)) {
      uint64_t v140 = v138 + 1;
    }
    if ((unint64_t)v139 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v141 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v141 = v140;
    }
    if (v141)
    {
      uint64_t v142 = 8 * v141;
      uint64_t v143 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v132[3] + 16))(v132[3], 8 * v141, 8);
      uint64_t v144 = (void *)(v143 + 8 * v138);
      uint64_t v141 = v143 + v142;
      if (v143) {
        *uint64_t v144 = v136;
      }
    }
    else
    {
      uint64_t v144 = (void *)(8 * v138);
    }
    uint64_t v146 = *v132;
    uint64_t v145 = v132[1];
    uint64_t v147 = v145 - *v132;
    if (v145 == *v132)
    {
      unint64_t v149 = v144;
      goto LABEL_189;
    }
    unint64_t v148 = v147 - 8;
    if ((unint64_t)(v147 - 8) < 0x38)
    {
      unint64_t v149 = v144;
      do
      {
LABEL_187:
        uint64_t v155 = *(void *)(v145 - 8);
        v145 -= 8;
        *--unint64_t v149 = v155;
      }
      while (v145 != v146);
      goto LABEL_188;
    }
    unint64_t v149 = v144;
    if ((unint64_t)(v145 - (void)v144) < 0x20) {
      goto LABEL_187;
    }
    uint64_t v150 = (v148 >> 3) + 1;
    int64x2_t v151 = v144 - 2;
    uint64_t v152 = (long long *)(v145 - 16);
    uint64_t v153 = v150 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v154 = *v152;
      *(v151 - 1) = *(v152 - 1);
      _OWORD *v151 = v154;
      v151 -= 2;
      v152 -= 2;
      v153 -= 4;
    }
    while (v153);
    unint64_t v149 = &v144[-(v150 & 0x3FFFFFFFFFFFFFFCLL)];
    v145 -= 8 * (v150 & 0x3FFFFFFFFFFFFFFCLL);
    if (v150 != (v150 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_187;
    }
LABEL_188:
    uint64_t v145 = *v132;
LABEL_189:
    uint8x16_t v135 = v144 + 1;
    *unint64_t v132 = (uint64_t)v149;
    v132[1] = (uint64_t)(v144 + 1);
    uint64_t v156 = v132[2];
    v132[2] = v141;
    if (v145) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v132[3] + 40))(v132[3], v145, v156 - v145);
    }
LABEL_164:
    v132[1] = (uint64_t)v135;
    if (++v133 != v134) {
      continue;
    }
    break;
  }
  uint64_t v157 = v132[4];
  if (v157 != v132[5]) {
    v132[5] = v157;
  }
LABEL_193:
  uint32x4_t v158 = (uint64_t *)*((void *)this + 138);
  int8x16_t v159 = (uint64_t *)v158[4];
  int64x2_t v160 = (uint64_t *)v158[5];
  if (v159 == v160) {
    goto LABEL_225;
  }
  int64x2_t v161 = (void *)v158[1];
  while (2)
  {
    uint64_t v162 = *v159;
    unint64_t v163 = v158[2];
    if ((unint64_t)v161 < v163)
    {
      if (v161) {
        void *v161 = v162;
      }
      ++v161;
      goto LABEL_196;
    }
    uint64_t v164 = ((uint64_t)v161 - *v158) >> 3;
    if ((unint64_t)(v164 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v165 = v163 - *v158;
    uint64_t v166 = v165 >> 2;
    if (v165 >> 2 <= (unint64_t)(v164 + 1)) {
      uint64_t v166 = v164 + 1;
    }
    if ((unint64_t)v165 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v167 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v167 = v166;
    }
    if (v167)
    {
      uint64_t v168 = 8 * v167;
      uint64_t v169 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v158[3] + 16))(v158[3], 8 * v167, 8);
      double v170 = (void *)(v169 + 8 * v164);
      uint64_t v167 = v169 + v168;
      if (v169) {
        void *v170 = v162;
      }
    }
    else
    {
      double v170 = (void *)(8 * v164);
    }
    uint64_t v172 = *v158;
    uint64_t v171 = v158[1];
    uint64_t v173 = v171 - *v158;
    if (v171 == *v158)
    {
      BOOL v175 = v170;
      goto LABEL_221;
    }
    unint64_t v174 = v173 - 8;
    if ((unint64_t)(v173 - 8) < 0x38)
    {
      BOOL v175 = v170;
      do
      {
LABEL_219:
        uint64_t v181 = *(void *)(v171 - 8);
        v171 -= 8;
        *--BOOL v175 = v181;
      }
      while (v171 != v172);
      goto LABEL_220;
    }
    BOOL v175 = v170;
    if ((unint64_t)(v171 - (void)v170) < 0x20) {
      goto LABEL_219;
    }
    uint64_t v176 = (v174 >> 3) + 1;
    unsigned int v177 = v170 - 2;
    float v178 = (long long *)(v171 - 16);
    uint64_t v179 = v176 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v180 = *v178;
      *(v177 - 1) = *(v178 - 1);
      _OWORD *v177 = v180;
      v177 -= 2;
      v178 -= 2;
      v179 -= 4;
    }
    while (v179);
    BOOL v175 = &v170[-(v176 & 0x3FFFFFFFFFFFFFFCLL)];
    v171 -= 8 * (v176 & 0x3FFFFFFFFFFFFFFCLL);
    if (v176 != (v176 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_219;
    }
LABEL_220:
    uint64_t v171 = *v158;
LABEL_221:
    int64x2_t v161 = v170 + 1;
    uint64_t *v158 = (uint64_t)v175;
    v158[1] = (uint64_t)(v170 + 1);
    uint64_t v182 = v158[2];
    v158[2] = v167;
    if (v171) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v158[3] + 40))(v158[3], v171, v182 - v171);
    }
LABEL_196:
    v158[1] = (uint64_t)v161;
    if (++v159 != v160) {
      continue;
    }
    break;
  }
  uint64_t v183 = v158[4];
  if (v183 != v158[5]) {
    v158[5] = v183;
  }
LABEL_225:
  int8x8_t v184 = (uint64_t *)*((void *)this + 142);
  uint8x8_t v185 = (uint64_t *)v184[4];
  uint64_t v186 = (uint64_t *)v184[5];
  if (v185 == v186) {
    goto LABEL_257;
  }
  uint64_t v187 = (void *)v184[1];
  while (2)
  {
    uint64_t v188 = *v185;
    unint64_t v189 = v184[2];
    if ((unint64_t)v187 < v189)
    {
      if (v187) {
        *uint64_t v187 = v188;
      }
      ++v187;
      goto LABEL_228;
    }
    uint64_t v190 = ((uint64_t)v187 - *v184) >> 3;
    if ((unint64_t)(v190 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v191 = v189 - *v184;
    uint64_t v192 = v191 >> 2;
    if (v191 >> 2 <= (unint64_t)(v190 + 1)) {
      uint64_t v192 = v190 + 1;
    }
    if ((unint64_t)v191 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v193 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v193 = v192;
    }
    if (v193)
    {
      uint64_t v194 = 8 * v193;
      uint64_t v195 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v184[3] + 16))(v184[3], 8 * v193, 8);
      unint64_t v196 = (void *)(v195 + 8 * v190);
      uint64_t v193 = v195 + v194;
      if (v195) {
        void *v196 = v188;
      }
    }
    else
    {
      unint64_t v196 = (void *)(8 * v190);
    }
    uint64_t v198 = *v184;
    uint64_t v197 = v184[1];
    uint64_t v199 = v197 - *v184;
    if (v197 == *v184)
    {
      uint64_t v201 = v196;
      goto LABEL_253;
    }
    unint64_t v200 = v199 - 8;
    if ((unint64_t)(v199 - 8) < 0x38)
    {
      uint64_t v201 = v196;
      do
      {
LABEL_251:
        uint64_t v207 = *(void *)(v197 - 8);
        v197 -= 8;
        *--uint64_t v201 = v207;
      }
      while (v197 != v198);
      goto LABEL_252;
    }
    uint64_t v201 = v196;
    if ((unint64_t)(v197 - (void)v196) < 0x20) {
      goto LABEL_251;
    }
    uint64_t v202 = (v200 >> 3) + 1;
    uint64_t v203 = v196 - 2;
    unint64_t v204 = (long long *)(v197 - 16);
    uint64_t v205 = v202 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v206 = *v204;
      *(v203 - 1) = *(v204 - 1);
      *uint64_t v203 = v206;
      v203 -= 2;
      v204 -= 2;
      v205 -= 4;
    }
    while (v205);
    uint64_t v201 = &v196[-(v202 & 0x3FFFFFFFFFFFFFFCLL)];
    v197 -= 8 * (v202 & 0x3FFFFFFFFFFFFFFCLL);
    if (v202 != (v202 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_251;
    }
LABEL_252:
    uint64_t v197 = *v184;
LABEL_253:
    uint64_t v187 = v196 + 1;
    uint64_t *v184 = (uint64_t)v201;
    v184[1] = (uint64_t)(v196 + 1);
    uint64_t v208 = v184[2];
    v184[2] = v193;
    if (v197) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v184[3] + 40))(v184[3], v197, v208 - v197);
    }
LABEL_228:
    v184[1] = (uint64_t)v187;
    if (++v185 != v186) {
      continue;
    }
    break;
  }
  uint64_t v209 = v184[4];
  if (v209 != v184[5]) {
    v184[5] = v209;
  }
LABEL_257:
  uint8x8_t v210 = (uint64_t *)*((void *)this + 143);
  uint64_t v211 = (uint64_t *)v210[4];
  double v212 = (uint64_t *)v210[5];
  if (v211 == v212) {
    goto LABEL_289;
  }
  unint64_t v213 = (void *)v210[1];
  while (2)
  {
    uint64_t v214 = *v211;
    unint64_t v215 = v210[2];
    if ((unint64_t)v213 < v215)
    {
      if (v213) {
        *unint64_t v213 = v214;
      }
      ++v213;
      goto LABEL_260;
    }
    uint64_t v216 = ((uint64_t)v213 - *v210) >> 3;
    if ((unint64_t)(v216 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v217 = v215 - *v210;
    uint64_t v218 = v217 >> 2;
    if (v217 >> 2 <= (unint64_t)(v216 + 1)) {
      uint64_t v218 = v216 + 1;
    }
    if ((unint64_t)v217 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v219 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v219 = v218;
    }
    if (v219)
    {
      uint64_t v220 = 8 * v219;
      uint64_t v221 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v210[3] + 16))(v210[3], 8 * v219, 8);
      uint64_t v222 = (void *)(v221 + 8 * v216);
      uint64_t v219 = v221 + v220;
      if (v221) {
        *uint64_t v222 = v214;
      }
    }
    else
    {
      uint64_t v222 = (void *)(8 * v216);
    }
    uint64_t v224 = *v210;
    uint64_t v223 = v210[1];
    uint64_t v225 = v223 - *v210;
    if (v223 == *v210)
    {
      uint64_t v227 = v222;
      goto LABEL_285;
    }
    unint64_t v226 = v225 - 8;
    if ((unint64_t)(v225 - 8) < 0x38)
    {
      uint64_t v227 = v222;
      do
      {
LABEL_283:
        uint64_t v233 = *(void *)(v223 - 8);
        v223 -= 8;
        *--uint64_t v227 = v233;
      }
      while (v223 != v224);
      goto LABEL_284;
    }
    uint64_t v227 = v222;
    if ((unint64_t)(v223 - (void)v222) < 0x20) {
      goto LABEL_283;
    }
    uint64_t v228 = (v226 >> 3) + 1;
    unint64_t v229 = v222 - 2;
    float v230 = (long long *)(v223 - 16);
    uint64_t v231 = v228 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v232 = *v230;
      *(v229 - 1) = *(v230 - 1);
      *unint64_t v229 = v232;
      v229 -= 2;
      v230 -= 2;
      v231 -= 4;
    }
    while (v231);
    uint64_t v227 = &v222[-(v228 & 0x3FFFFFFFFFFFFFFCLL)];
    v223 -= 8 * (v228 & 0x3FFFFFFFFFFFFFFCLL);
    if (v228 != (v228 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_283;
    }
LABEL_284:
    uint64_t v223 = *v210;
LABEL_285:
    unint64_t v213 = v222 + 1;
    *uint8x8_t v210 = (uint64_t)v227;
    v210[1] = (uint64_t)(v222 + 1);
    uint64_t v234 = v210[2];
    v210[2] = v219;
    if (v223) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v210[3] + 40))(v210[3], v223, v234 - v223);
    }
LABEL_260:
    v210[1] = (uint64_t)v213;
    if (++v211 != v212) {
      continue;
    }
    break;
  }
  uint64_t v235 = v210[4];
  if (v235 != v210[5]) {
    v210[5] = v235;
  }
LABEL_289:
  float v236 = (uint64_t *)*((void *)this + 144);
  unint64_t v237 = (uint64_t *)v236[4];
  uint64_t v238 = (uint64_t *)v236[5];
  if (v237 == v238) {
    goto LABEL_321;
  }
  uint64_t v239 = (void *)v236[1];
  while (2)
  {
    uint64_t v240 = *v237;
    unint64_t v241 = v236[2];
    if ((unint64_t)v239 < v241)
    {
      if (v239) {
        *uint64_t v239 = v240;
      }
      ++v239;
      goto LABEL_292;
    }
    uint64_t v242 = ((uint64_t)v239 - *v236) >> 3;
    if ((unint64_t)(v242 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v243 = v241 - *v236;
    uint64_t v244 = v243 >> 2;
    if (v243 >> 2 <= (unint64_t)(v242 + 1)) {
      uint64_t v244 = v242 + 1;
    }
    if ((unint64_t)v243 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v245 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v245 = v244;
    }
    if (v245)
    {
      uint64_t v246 = 8 * v245;
      uint64_t v247 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v236[3] + 16))(v236[3], 8 * v245, 8);
      uint64_t v248 = (void *)(v247 + 8 * v242);
      uint64_t v245 = v247 + v246;
      if (v247) {
        void *v248 = v240;
      }
    }
    else
    {
      uint64_t v248 = (void *)(8 * v242);
    }
    uint64_t v250 = *v236;
    uint64_t v249 = v236[1];
    uint64_t v251 = v249 - *v236;
    if (v249 == *v236)
    {
      unint64_t v253 = v248;
      goto LABEL_317;
    }
    unint64_t v252 = v251 - 8;
    if ((unint64_t)(v251 - 8) < 0x38)
    {
      unint64_t v253 = v248;
      do
      {
LABEL_315:
        uint64_t v259 = *(void *)(v249 - 8);
        v249 -= 8;
        *--unint64_t v253 = v259;
      }
      while (v249 != v250);
      goto LABEL_316;
    }
    unint64_t v253 = v248;
    if ((unint64_t)(v249 - (void)v248) < 0x20) {
      goto LABEL_315;
    }
    uint64_t v254 = (v252 >> 3) + 1;
    uint64_t v255 = v248 - 2;
    uint64_t v256 = (long long *)(v249 - 16);
    uint64_t v257 = v254 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v258 = *v256;
      *(v255 - 1) = *(v256 - 1);
      *uint64_t v255 = v258;
      v255 -= 2;
      v256 -= 2;
      v257 -= 4;
    }
    while (v257);
    unint64_t v253 = &v248[-(v254 & 0x3FFFFFFFFFFFFFFCLL)];
    v249 -= 8 * (v254 & 0x3FFFFFFFFFFFFFFCLL);
    if (v254 != (v254 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_315;
    }
LABEL_316:
    uint64_t v249 = *v236;
LABEL_317:
    uint64_t v239 = v248 + 1;
    *float v236 = (uint64_t)v253;
    v236[1] = (uint64_t)(v248 + 1);
    uint64_t v260 = v236[2];
    v236[2] = v245;
    if (v249) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v236[3] + 40))(v236[3], v249, v260 - v249);
    }
LABEL_292:
    v236[1] = (uint64_t)v239;
    if (++v237 != v238) {
      continue;
    }
    break;
  }
  uint64_t v261 = v236[4];
  if (v261 != v236[5]) {
    v236[5] = v261;
  }
LABEL_321:
  uint64_t v262 = (uint64_t *)*((void *)this + 145);
  uint64_t v263 = (uint64_t *)v262[4];
  uint64_t v264 = (uint64_t *)v262[5];
  if (v263 == v264) {
    goto LABEL_353;
  }
  unint64_t v265 = (void *)v262[1];
  while (2)
  {
    uint64_t v266 = *v263;
    unint64_t v267 = v262[2];
    if ((unint64_t)v265 < v267)
    {
      if (v265) {
        void *v265 = v266;
      }
      ++v265;
      goto LABEL_324;
    }
    uint64_t v268 = ((uint64_t)v265 - *v262) >> 3;
    if ((unint64_t)(v268 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v269 = v267 - *v262;
    uint64_t v270 = v269 >> 2;
    if (v269 >> 2 <= (unint64_t)(v268 + 1)) {
      uint64_t v270 = v268 + 1;
    }
    if ((unint64_t)v269 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v271 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v271 = v270;
    }
    if (v271)
    {
      uint64_t v272 = 8 * v271;
      uint64_t v273 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v262[3] + 16))(v262[3], 8 * v271, 8);
      uint64_t v274 = (void *)(v273 + 8 * v268);
      uint64_t v271 = v273 + v272;
      if (v273) {
        void *v274 = v266;
      }
    }
    else
    {
      uint64_t v274 = (void *)(8 * v268);
    }
    uint64_t v276 = *v262;
    uint64_t v275 = v262[1];
    uint64_t v277 = v275 - *v262;
    if (v275 == *v262)
    {
      unint64_t v279 = v274;
      goto LABEL_349;
    }
    unint64_t v278 = v277 - 8;
    if ((unint64_t)(v277 - 8) < 0x38)
    {
      unint64_t v279 = v274;
      do
      {
LABEL_347:
        uint64_t v285 = *(void *)(v275 - 8);
        v275 -= 8;
        *--unint64_t v279 = v285;
      }
      while (v275 != v276);
      goto LABEL_348;
    }
    unint64_t v279 = v274;
    if ((unint64_t)(v275 - (void)v274) < 0x20) {
      goto LABEL_347;
    }
    uint64_t v280 = (v278 >> 3) + 1;
    uint64_t v281 = v274 - 2;
    int v282 = (long long *)(v275 - 16);
    uint64_t v283 = v280 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v284 = *v282;
      *(v281 - 1) = *(v282 - 1);
      *uint64_t v281 = v284;
      v281 -= 2;
      v282 -= 2;
      v283 -= 4;
    }
    while (v283);
    unint64_t v279 = &v274[-(v280 & 0x3FFFFFFFFFFFFFFCLL)];
    v275 -= 8 * (v280 & 0x3FFFFFFFFFFFFFFCLL);
    if (v280 != (v280 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_347;
    }
LABEL_348:
    uint64_t v275 = *v262;
LABEL_349:
    unint64_t v265 = v274 + 1;
    uint64_t *v262 = (uint64_t)v279;
    v262[1] = (uint64_t)(v274 + 1);
    uint64_t v286 = v262[2];
    v262[2] = v271;
    if (v275) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v262[3] + 40))(v262[3], v275, v286 - v275);
    }
LABEL_324:
    v262[1] = (uint64_t)v265;
    if (++v263 != v264) {
      continue;
    }
    break;
  }
  uint64_t v287 = v262[4];
  if (v287 != v262[5]) {
    v262[5] = v287;
  }
LABEL_353:
  uint64_t v288 = (uint64_t *)*((void *)this + 168);
  unint64_t v289 = (uint64_t *)v288[4];
  uint64_t v290 = (uint64_t *)v288[5];
  if (v289 == v290) {
    goto LABEL_385;
  }
  unint64_t v291 = (void *)v288[1];
  while (2)
  {
    uint64_t v292 = *v289;
    unint64_t v293 = v288[2];
    if ((unint64_t)v291 < v293)
    {
      if (v291) {
        *unint64_t v291 = v292;
      }
      ++v291;
      goto LABEL_356;
    }
    uint64_t v294 = ((uint64_t)v291 - *v288) >> 3;
    if ((unint64_t)(v294 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v295 = v293 - *v288;
    uint64_t v296 = v295 >> 2;
    if (v295 >> 2 <= (unint64_t)(v294 + 1)) {
      uint64_t v296 = v294 + 1;
    }
    if ((unint64_t)v295 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v297 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v297 = v296;
    }
    if (v297)
    {
      uint64_t v298 = 8 * v297;
      uint64_t v299 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v288[3] + 16))(v288[3], 8 * v297, 8);
      uint64_t v300 = (void *)(v299 + 8 * v294);
      uint64_t v297 = v299 + v298;
      if (v299) {
        void *v300 = v292;
      }
    }
    else
    {
      uint64_t v300 = (void *)(8 * v294);
    }
    uint64_t v302 = *v288;
    uint64_t v301 = v288[1];
    uint64_t v303 = v301 - *v288;
    if (v301 == *v288)
    {
      unsigned int v305 = v300;
      goto LABEL_381;
    }
    unint64_t v304 = v303 - 8;
    if ((unint64_t)(v303 - 8) < 0x38)
    {
      unsigned int v305 = v300;
      do
      {
LABEL_379:
        uint64_t v311 = *(void *)(v301 - 8);
        v301 -= 8;
        *--unsigned int v305 = v311;
      }
      while (v301 != v302);
      goto LABEL_380;
    }
    unsigned int v305 = v300;
    if ((unint64_t)(v301 - (void)v300) < 0x20) {
      goto LABEL_379;
    }
    uint64_t v306 = (v304 >> 3) + 1;
    id v307 = v300 - 2;
    uint64_t v308 = (long long *)(v301 - 16);
    uint64_t v309 = v306 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v310 = *v308;
      *(v307 - 1) = *(v308 - 1);
      _OWORD *v307 = v310;
      v307 -= 2;
      v308 -= 2;
      v309 -= 4;
    }
    while (v309);
    unsigned int v305 = &v300[-(v306 & 0x3FFFFFFFFFFFFFFCLL)];
    v301 -= 8 * (v306 & 0x3FFFFFFFFFFFFFFCLL);
    if (v306 != (v306 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_379;
    }
LABEL_380:
    uint64_t v301 = *v288;
LABEL_381:
    unint64_t v291 = v300 + 1;
    uint64_t *v288 = (uint64_t)v305;
    v288[1] = (uint64_t)(v300 + 1);
    uint64_t v312 = v288[2];
    v288[2] = v297;
    if (v301) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v288[3] + 40))(v288[3], v301, v312 - v301);
    }
LABEL_356:
    v288[1] = (uint64_t)v291;
    if (++v289 != v290) {
      continue;
    }
    break;
  }
  uint64_t v313 = v288[4];
  if (v313 != v288[5]) {
    v288[5] = v313;
  }
LABEL_385:
  uint8x8_t v314 = (uint64_t *)*((void *)this + 169);
  unint64_t v315 = (uint64_t *)v314[4];
  unint64_t v316 = (uint64_t *)v314[5];
  if (v315 == v316) {
    goto LABEL_417;
  }
  unint64_t v317 = (void *)v314[1];
  while (2)
  {
    uint64_t v318 = *v315;
    unint64_t v319 = v314[2];
    if ((unint64_t)v317 < v319)
    {
      if (v317) {
        *unint64_t v317 = v318;
      }
      ++v317;
      goto LABEL_388;
    }
    uint64_t v320 = ((uint64_t)v317 - *v314) >> 3;
    if ((unint64_t)(v320 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v321 = v319 - *v314;
    uint64_t v322 = v321 >> 2;
    if (v321 >> 2 <= (unint64_t)(v320 + 1)) {
      uint64_t v322 = v320 + 1;
    }
    if ((unint64_t)v321 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v323 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v323 = v322;
    }
    if (v323)
    {
      uint64_t v324 = 8 * v323;
      uint64_t v325 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v314[3] + 16))(v314[3], 8 * v323, 8);
      float v326 = (void *)(v325 + 8 * v320);
      uint64_t v323 = v325 + v324;
      if (v325) {
        *float v326 = v318;
      }
    }
    else
    {
      float v326 = (void *)(8 * v320);
    }
    uint64_t v328 = *v314;
    uint64_t v327 = v314[1];
    uint64_t v329 = v327 - *v314;
    if (v327 == *v314)
    {
      uint64_t v331 = v326;
      goto LABEL_413;
    }
    unint64_t v330 = v329 - 8;
    if ((unint64_t)(v329 - 8) < 0x38)
    {
      uint64_t v331 = v326;
      do
      {
LABEL_411:
        uint64_t v337 = *(void *)(v327 - 8);
        v327 -= 8;
        *--uint64_t v331 = v337;
      }
      while (v327 != v328);
      goto LABEL_412;
    }
    uint64_t v331 = v326;
    if ((unint64_t)(v327 - (void)v326) < 0x20) {
      goto LABEL_411;
    }
    uint64_t v332 = (v330 >> 3) + 1;
    uint64_t v333 = v326 - 2;
    unint64_t v334 = (long long *)(v327 - 16);
    uint64_t v335 = v332 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v336 = *v334;
      *(v333 - 1) = *(v334 - 1);
      _OWORD *v333 = v336;
      v333 -= 2;
      v334 -= 2;
      v335 -= 4;
    }
    while (v335);
    uint64_t v331 = &v326[-(v332 & 0x3FFFFFFFFFFFFFFCLL)];
    v327 -= 8 * (v332 & 0x3FFFFFFFFFFFFFFCLL);
    if (v332 != (v332 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_411;
    }
LABEL_412:
    uint64_t v327 = *v314;
LABEL_413:
    unint64_t v317 = v326 + 1;
    uint64_t *v314 = (uint64_t)v331;
    v314[1] = (uint64_t)(v326 + 1);
    uint64_t v338 = v314[2];
    v314[2] = v323;
    if (v327) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v314[3] + 40))(v314[3], v327, v338 - v327);
    }
LABEL_388:
    v314[1] = (uint64_t)v317;
    if (++v315 != v316) {
      continue;
    }
    break;
  }
  uint64_t v339 = v314[4];
  if (v339 != v314[5]) {
    v314[5] = v339;
  }
LABEL_417:
  uint64_t v340 = (uint64_t *)*((void *)this + 170);
  char v341 = (uint64_t *)v340[4];
  uint64_t v342 = (uint64_t *)v340[5];
  if (v341 == v342) {
    goto LABEL_449;
  }
  unint64_t v343 = (void *)v340[1];
  while (2)
  {
    uint64_t v344 = *v341;
    unint64_t v345 = v340[2];
    if ((unint64_t)v343 < v345)
    {
      if (v343) {
        void *v343 = v344;
      }
      ++v343;
      goto LABEL_420;
    }
    uint64_t v346 = ((uint64_t)v343 - *v340) >> 3;
    if ((unint64_t)(v346 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v347 = v345 - *v340;
    uint64_t v348 = v347 >> 2;
    if (v347 >> 2 <= (unint64_t)(v346 + 1)) {
      uint64_t v348 = v346 + 1;
    }
    if ((unint64_t)v347 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v349 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v349 = v348;
    }
    if (v349)
    {
      uint64_t v350 = 8 * v349;
      uint64_t v351 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v340[3] + 16))(v340[3], 8 * v349, 8);
      unint64_t v352 = (void *)(v351 + 8 * v346);
      uint64_t v349 = v351 + v350;
      if (v351) {
        *unint64_t v352 = v344;
      }
    }
    else
    {
      unint64_t v352 = (void *)(8 * v346);
    }
    uint64_t v354 = *v340;
    uint64_t v353 = v340[1];
    uint64_t v355 = v353 - *v340;
    if (v353 == *v340)
    {
      unint64_t v357 = v352;
      goto LABEL_445;
    }
    unint64_t v356 = v355 - 8;
    if ((unint64_t)(v355 - 8) < 0x38)
    {
      unint64_t v357 = v352;
      do
      {
LABEL_443:
        uint64_t v363 = *(void *)(v353 - 8);
        v353 -= 8;
        *--unint64_t v357 = v363;
      }
      while (v353 != v354);
      goto LABEL_444;
    }
    unint64_t v357 = v352;
    if ((unint64_t)(v353 - (void)v352) < 0x20) {
      goto LABEL_443;
    }
    uint64_t v358 = (v356 >> 3) + 1;
    unint64_t v359 = v352 - 2;
    int8x8_t v360 = (long long *)(v353 - 16);
    uint64_t v361 = v358 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v362 = *v360;
      *(v359 - 1) = *(v360 - 1);
      *unint64_t v359 = v362;
      v359 -= 2;
      v360 -= 2;
      v361 -= 4;
    }
    while (v361);
    unint64_t v357 = &v352[-(v358 & 0x3FFFFFFFFFFFFFFCLL)];
    v353 -= 8 * (v358 & 0x3FFFFFFFFFFFFFFCLL);
    if (v358 != (v358 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_443;
    }
LABEL_444:
    uint64_t v353 = *v340;
LABEL_445:
    unint64_t v343 = v352 + 1;
    uint64_t *v340 = (uint64_t)v357;
    v340[1] = (uint64_t)(v352 + 1);
    uint64_t v364 = v340[2];
    v340[2] = v349;
    if (v353) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v340[3] + 40))(v340[3], v353, v364 - v353);
    }
LABEL_420:
    v340[1] = (uint64_t)v343;
    if (++v341 != v342) {
      continue;
    }
    break;
  }
  uint64_t v365 = v340[4];
  if (v365 != v340[5]) {
    v340[5] = v365;
  }
LABEL_449:
  unint64_t v366 = (uint64_t *)*((void *)this + 171);
  uint64_t v367 = (uint64_t *)v366[4];
  uint64_t v368 = (uint64_t *)v366[5];
  if (v367 == v368) {
    goto LABEL_481;
  }
  uint64_t v369 = (void *)v366[1];
  while (2)
  {
    uint64_t v370 = *v367;
    unint64_t v371 = v366[2];
    if ((unint64_t)v369 < v371)
    {
      if (v369) {
        void *v369 = v370;
      }
      ++v369;
      goto LABEL_452;
    }
    uint64_t v372 = ((uint64_t)v369 - *v366) >> 3;
    if ((unint64_t)(v372 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v373 = v371 - *v366;
    uint64_t v374 = v373 >> 2;
    if (v373 >> 2 <= (unint64_t)(v372 + 1)) {
      uint64_t v374 = v372 + 1;
    }
    if ((unint64_t)v373 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v375 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v375 = v374;
    }
    if (v375)
    {
      uint64_t v376 = 8 * v375;
      uint64_t v377 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v366[3] + 16))(v366[3], 8 * v375, 8);
      uint64_t v378 = (void *)(v377 + 8 * v372);
      uint64_t v375 = v377 + v376;
      if (v377) {
        void *v378 = v370;
      }
    }
    else
    {
      uint64_t v378 = (void *)(8 * v372);
    }
    uint64_t v380 = *v366;
    uint64_t v379 = v366[1];
    uint64_t v381 = v379 - *v366;
    if (v379 == *v366)
    {
      BOOL v383 = v378;
      goto LABEL_477;
    }
    unint64_t v382 = v381 - 8;
    if ((unint64_t)(v381 - 8) < 0x38)
    {
      BOOL v383 = v378;
      do
      {
LABEL_475:
        uint64_t v389 = *(void *)(v379 - 8);
        v379 -= 8;
        *--BOOL v383 = v389;
      }
      while (v379 != v380);
      goto LABEL_476;
    }
    BOOL v383 = v378;
    if ((unint64_t)(v379 - (void)v378) < 0x20) {
      goto LABEL_475;
    }
    uint64_t v384 = (v382 >> 3) + 1;
    uint64x2_t v385 = v378 - 2;
    float64x2_t v386 = (long long *)(v379 - 16);
    uint64_t v387 = v384 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v388 = *v386;
      *(v385 - 1) = *(v386 - 1);
      _OWORD *v385 = v388;
      v385 -= 2;
      v386 -= 2;
      v387 -= 4;
    }
    while (v387);
    BOOL v383 = &v378[-(v384 & 0x3FFFFFFFFFFFFFFCLL)];
    v379 -= 8 * (v384 & 0x3FFFFFFFFFFFFFFCLL);
    if (v384 != (v384 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_475;
    }
LABEL_476:
    uint64_t v379 = *v366;
LABEL_477:
    uint64_t v369 = v378 + 1;
    *unint64_t v366 = (uint64_t)v383;
    v366[1] = (uint64_t)(v378 + 1);
    uint64_t v390 = v366[2];
    v366[2] = v375;
    if (v379) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v366[3] + 40))(v366[3], v379, v390 - v379);
    }
LABEL_452:
    v366[1] = (uint64_t)v369;
    if (++v367 != v368) {
      continue;
    }
    break;
  }
  uint64_t v391 = v366[4];
  if (v391 != v366[5]) {
    v366[5] = v391;
  }
LABEL_481:
  float64x2_t v392 = (uint64_t *)*((void *)this + 174);
  float v393 = (uint64_t *)v392[4];
  uint64_t v394 = (uint64_t *)v392[5];
  if (v393 == v394) {
    goto LABEL_513;
  }
  float64x2_t v395 = (void *)v392[1];
  while (2)
  {
    uint64_t v396 = *v393;
    unint64_t v397 = v392[2];
    if ((unint64_t)v395 < v397)
    {
      if (v395) {
        void *v395 = v396;
      }
      ++v395;
      goto LABEL_484;
    }
    uint64_t v398 = ((uint64_t)v395 - *v392) >> 3;
    if ((unint64_t)(v398 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v399 = v397 - *v392;
    uint64_t v400 = v399 >> 2;
    if (v399 >> 2 <= (unint64_t)(v398 + 1)) {
      uint64_t v400 = v398 + 1;
    }
    if ((unint64_t)v399 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v401 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v401 = v400;
    }
    if (v401)
    {
      uint64_t v402 = 8 * v401;
      uint64_t v403 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v392[3] + 16))(v392[3], 8 * v401, 8);
      char v404 = (void *)(v403 + 8 * v398);
      uint64_t v401 = v403 + v402;
      if (v403) {
        *char v404 = v396;
      }
    }
    else
    {
      char v404 = (void *)(8 * v398);
    }
    uint64_t v406 = *v392;
    uint64_t v405 = v392[1];
    uint64_t v407 = v405 - *v392;
    if (v405 == *v392)
    {
      unint64_t v409 = v404;
      goto LABEL_509;
    }
    unint64_t v408 = v407 - 8;
    if ((unint64_t)(v407 - 8) < 0x38)
    {
      unint64_t v409 = v404;
      do
      {
LABEL_507:
        uint64_t v415 = *(void *)(v405 - 8);
        v405 -= 8;
        *--unint64_t v409 = v415;
      }
      while (v405 != v406);
      goto LABEL_508;
    }
    unint64_t v409 = v404;
    if ((unint64_t)(v405 - (void)v404) < 0x20) {
      goto LABEL_507;
    }
    uint64_t v410 = (v408 >> 3) + 1;
    uint64_t v411 = v404 - 2;
    uint64_t v412 = (long long *)(v405 - 16);
    uint64_t v413 = v410 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v414 = *v412;
      *(v411 - 1) = *(v412 - 1);
      _OWORD *v411 = v414;
      v411 -= 2;
      v412 -= 2;
      v413 -= 4;
    }
    while (v413);
    unint64_t v409 = &v404[-(v410 & 0x3FFFFFFFFFFFFFFCLL)];
    v405 -= 8 * (v410 & 0x3FFFFFFFFFFFFFFCLL);
    if (v410 != (v410 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_507;
    }
LABEL_508:
    uint64_t v405 = *v392;
LABEL_509:
    float64x2_t v395 = v404 + 1;
    uint64_t *v392 = (uint64_t)v409;
    v392[1] = (uint64_t)(v404 + 1);
    uint64_t v416 = v392[2];
    v392[2] = v401;
    if (v405) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v392[3] + 40))(v392[3], v405, v416 - v405);
    }
LABEL_484:
    v392[1] = (uint64_t)v395;
    if (++v393 != v394) {
      continue;
    }
    break;
  }
  uint64_t v417 = v392[4];
  if (v417 != v392[5]) {
    v392[5] = v417;
  }
LABEL_513:
  float v418 = (uint64_t *)*((void *)this + 176);
  float v419 = (uint64_t *)v418[4];
  unsigned int v420 = (uint64_t *)v418[5];
  if (v419 == v420) {
    goto LABEL_545;
  }
  float v421 = (void *)v418[1];
  while (2)
  {
    uint64_t v422 = *v419;
    unint64_t v423 = v418[2];
    if ((unint64_t)v421 < v423)
    {
      if (v421) {
        *float v421 = v422;
      }
      ++v421;
      goto LABEL_516;
    }
    uint64_t v424 = ((uint64_t)v421 - *v418) >> 3;
    if ((unint64_t)(v424 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v425 = v423 - *v418;
    uint64_t v426 = v425 >> 2;
    if (v425 >> 2 <= (unint64_t)(v424 + 1)) {
      uint64_t v426 = v424 + 1;
    }
    if ((unint64_t)v425 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v427 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v427 = v426;
    }
    if (v427)
    {
      uint64_t v428 = 8 * v427;
      uint64_t v429 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v418[3] + 16))(v418[3], 8 * v427, 8);
      float v430 = (void *)(v429 + 8 * v424);
      uint64_t v427 = v429 + v428;
      if (v429) {
        *float v430 = v422;
      }
    }
    else
    {
      float v430 = (void *)(8 * v424);
    }
    uint64_t v432 = *v418;
    uint64_t v431 = v418[1];
    uint64_t v433 = v431 - *v418;
    if (v431 == *v418)
    {
      float v435 = v430;
      goto LABEL_541;
    }
    unint64_t v434 = v433 - 8;
    if ((unint64_t)(v433 - 8) < 0x38)
    {
      float v435 = v430;
      do
      {
LABEL_539:
        uint64_t v441 = *(void *)(v431 - 8);
        v431 -= 8;
        *--float v435 = v441;
      }
      while (v431 != v432);
      goto LABEL_540;
    }
    float v435 = v430;
    if ((unint64_t)(v431 - (void)v430) < 0x20) {
      goto LABEL_539;
    }
    uint64_t v436 = (v434 >> 3) + 1;
    float v437 = v430 - 2;
    float v438 = (long long *)(v431 - 16);
    uint64_t v439 = v436 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v440 = *v438;
      *(v437 - 1) = *(v438 - 1);
      _OWORD *v437 = v440;
      v437 -= 2;
      v438 -= 2;
      v439 -= 4;
    }
    while (v439);
    float v435 = &v430[-(v436 & 0x3FFFFFFFFFFFFFFCLL)];
    v431 -= 8 * (v436 & 0x3FFFFFFFFFFFFFFCLL);
    if (v436 != (v436 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_539;
    }
LABEL_540:
    uint64_t v431 = *v418;
LABEL_541:
    float v421 = v430 + 1;
    uint64_t *v418 = (uint64_t)v435;
    v418[1] = (uint64_t)(v430 + 1);
    uint64_t v442 = v418[2];
    v418[2] = v427;
    if (v431) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v418[3] + 40))(v418[3], v431, v442 - v431);
    }
LABEL_516:
    v418[1] = (uint64_t)v421;
    if (++v419 != v420) {
      continue;
    }
    break;
  }
  uint64_t v443 = v418[4];
  if (v443 != v418[5]) {
    v418[5] = v443;
  }
LABEL_545:
  float v444 = (uint64_t *)*((void *)this + 173);
  float v445 = (uint64_t *)v444[4];
  float32x2_t v446 = (uint64_t *)v444[5];
  if (v445 == v446) {
    goto LABEL_577;
  }
  float32x2_t v447 = (void *)v444[1];
  while (2)
  {
    uint64_t v448 = *v445;
    unint64_t v449 = v444[2];
    if ((unint64_t)v447 < v449)
    {
      if (v447) {
        *float32x2_t v447 = v448;
      }
      ++v447;
      goto LABEL_548;
    }
    uint64_t v450 = ((uint64_t)v447 - *v444) >> 3;
    if ((unint64_t)(v450 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v451 = v449 - *v444;
    uint64_t v452 = v451 >> 2;
    if (v451 >> 2 <= (unint64_t)(v450 + 1)) {
      uint64_t v452 = v450 + 1;
    }
    if ((unint64_t)v451 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v453 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v453 = v452;
    }
    if (v453)
    {
      uint64_t v454 = 8 * v453;
      uint64_t v455 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v444[3] + 16))(v444[3], 8 * v453, 8);
      uint64_t v456 = (void *)(v455 + 8 * v450);
      uint64_t v453 = v455 + v454;
      if (v455) {
        *uint64_t v456 = v448;
      }
    }
    else
    {
      uint64_t v456 = (void *)(8 * v450);
    }
    uint64_t v458 = *v444;
    uint64_t v457 = v444[1];
    uint64_t v459 = v457 - *v444;
    if (v457 == *v444)
    {
      uint64_t v461 = v456;
      goto LABEL_573;
    }
    unint64_t v460 = v459 - 8;
    if ((unint64_t)(v459 - 8) < 0x38)
    {
      uint64_t v461 = v456;
      do
      {
LABEL_571:
        uint64_t v467 = *(void *)(v457 - 8);
        v457 -= 8;
        *--uint64_t v461 = v467;
      }
      while (v457 != v458);
      goto LABEL_572;
    }
    uint64_t v461 = v456;
    if ((unint64_t)(v457 - (void)v456) < 0x20) {
      goto LABEL_571;
    }
    uint64_t v462 = (v460 >> 3) + 1;
    uint64_t v463 = v456 - 2;
    int v464 = (long long *)(v457 - 16);
    uint64_t v465 = v462 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v466 = *v464;
      *(v463 - 1) = *(v464 - 1);
      *uint64_t v463 = v466;
      v463 -= 2;
      v464 -= 2;
      v465 -= 4;
    }
    while (v465);
    uint64_t v461 = &v456[-(v462 & 0x3FFFFFFFFFFFFFFCLL)];
    v457 -= 8 * (v462 & 0x3FFFFFFFFFFFFFFCLL);
    if (v462 != (v462 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_571;
    }
LABEL_572:
    uint64_t v457 = *v444;
LABEL_573:
    float32x2_t v447 = v456 + 1;
    uint64_t *v444 = (uint64_t)v461;
    v444[1] = (uint64_t)(v456 + 1);
    uint64_t v468 = v444[2];
    v444[2] = v453;
    if (v457) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v444[3] + 40))(v444[3], v457, v468 - v457);
    }
LABEL_548:
    v444[1] = (uint64_t)v447;
    if (++v445 != v446) {
      continue;
    }
    break;
  }
  uint64_t v469 = v444[4];
  if (v469 != v444[5]) {
    v444[5] = v469;
  }
LABEL_577:
  unint64_t v470 = (uint64_t *)*((void *)this + 175);
  unint64_t v471 = (uint64_t *)v470[4];
  v472 = (uint64_t *)v470[5];
  if (v471 == v472) {
    goto LABEL_609;
  }
  uint64_t v473 = (void *)v470[1];
  while (2)
  {
    uint64_t v474 = *v471;
    unint64_t v475 = v470[2];
    if ((unint64_t)v473 < v475)
    {
      if (v473) {
        void *v473 = v474;
      }
      ++v473;
      goto LABEL_580;
    }
    uint64_t v476 = ((uint64_t)v473 - *v470) >> 3;
    if ((unint64_t)(v476 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v477 = v475 - *v470;
    uint64_t v478 = v477 >> 2;
    if (v477 >> 2 <= (unint64_t)(v476 + 1)) {
      uint64_t v478 = v476 + 1;
    }
    if ((unint64_t)v477 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v479 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v479 = v478;
    }
    if (v479)
    {
      uint64_t v480 = 8 * v479;
      uint64_t v481 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v470[3] + 16))(v470[3], 8 * v479, 8);
      char v482 = (void *)(v481 + 8 * v476);
      uint64_t v479 = v481 + v480;
      if (v481) {
        void *v482 = v474;
      }
    }
    else
    {
      char v482 = (void *)(8 * v476);
    }
    uint64_t v484 = *v470;
    uint64_t v483 = v470[1];
    uint64_t v485 = v483 - *v470;
    if (v483 == *v470)
    {
      unsigned int v487 = v482;
      goto LABEL_605;
    }
    unint64_t v486 = v485 - 8;
    if ((unint64_t)(v485 - 8) < 0x38)
    {
      unsigned int v487 = v482;
      do
      {
LABEL_603:
        uint64_t v493 = *(void *)(v483 - 8);
        v483 -= 8;
        *--unsigned int v487 = v493;
      }
      while (v483 != v484);
      goto LABEL_604;
    }
    unsigned int v487 = v482;
    if ((unint64_t)(v483 - (void)v482) < 0x20) {
      goto LABEL_603;
    }
    uint64_t v488 = (v486 >> 3) + 1;
    uint64_t v489 = v482 - 2;
    uint64_t v490 = (long long *)(v483 - 16);
    uint64_t v491 = v488 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v492 = *v490;
      *(v489 - 1) = *(v490 - 1);
      _OWORD *v489 = v492;
      v489 -= 2;
      v490 -= 2;
      v491 -= 4;
    }
    while (v491);
    unsigned int v487 = &v482[-(v488 & 0x3FFFFFFFFFFFFFFCLL)];
    v483 -= 8 * (v488 & 0x3FFFFFFFFFFFFFFCLL);
    if (v488 != (v488 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_603;
    }
LABEL_604:
    uint64_t v483 = *v470;
LABEL_605:
    uint64_t v473 = v482 + 1;
    *unint64_t v470 = (uint64_t)v487;
    v470[1] = (uint64_t)(v482 + 1);
    uint64_t v494 = v470[2];
    v470[2] = v479;
    if (v483) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v470[3] + 40))(v470[3], v483, v494 - v483);
    }
LABEL_580:
    v470[1] = (uint64_t)v473;
    if (++v471 != v472) {
      continue;
    }
    break;
  }
  uint64_t v495 = v470[4];
  if (v495 != v470[5]) {
    v470[5] = v495;
  }
LABEL_609:
  v496 = (uint64_t *)*((void *)this + 137);
  unint64_t v497 = (uint64_t *)v496[4];
  int v498 = (uint64_t *)v496[5];
  if (v497 == v498) {
    goto LABEL_641;
  }
  uint64_t v499 = (void *)v496[1];
  while (2)
  {
    uint64_t v500 = *v497;
    unint64_t v501 = v496[2];
    if ((unint64_t)v499 < v501)
    {
      if (v499) {
        *uint64_t v499 = v500;
      }
      ++v499;
      goto LABEL_612;
    }
    uint64_t v502 = ((uint64_t)v499 - *v496) >> 3;
    if ((unint64_t)(v502 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v503 = v501 - *v496;
    uint64_t v504 = v503 >> 2;
    if (v503 >> 2 <= (unint64_t)(v502 + 1)) {
      uint64_t v504 = v502 + 1;
    }
    if ((unint64_t)v503 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v505 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v505 = v504;
    }
    if (v505)
    {
      uint64_t v506 = 8 * v505;
      uint64_t v507 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v496[3] + 16))(v496[3], 8 * v505, 8);
      double v508 = (void *)(v507 + 8 * v502);
      uint64_t v505 = v507 + v506;
      if (v507) {
        *double v508 = v500;
      }
    }
    else
    {
      double v508 = (void *)(8 * v502);
    }
    uint64_t v510 = *v496;
    uint64_t v509 = v496[1];
    uint64_t v511 = v509 - *v496;
    if (v509 == *v496)
    {
      double v513 = v508;
      goto LABEL_637;
    }
    unint64_t v512 = v511 - 8;
    if ((unint64_t)(v511 - 8) < 0x38)
    {
      double v513 = v508;
      do
      {
LABEL_635:
        uint64_t v519 = *(void *)(v509 - 8);
        v509 -= 8;
        *--double v513 = v519;
      }
      while (v509 != v510);
      goto LABEL_636;
    }
    double v513 = v508;
    if ((unint64_t)(v509 - (void)v508) < 0x20) {
      goto LABEL_635;
    }
    uint64_t v514 = (v512 >> 3) + 1;
    double v515 = v508 - 2;
    double v516 = (long long *)(v509 - 16);
    uint64_t v517 = v514 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v518 = *v516;
      *(v515 - 1) = *(v516 - 1);
      _OWORD *v515 = v518;
      v515 -= 2;
      v516 -= 2;
      v517 -= 4;
    }
    while (v517);
    double v513 = &v508[-(v514 & 0x3FFFFFFFFFFFFFFCLL)];
    v509 -= 8 * (v514 & 0x3FFFFFFFFFFFFFFCLL);
    if (v514 != (v514 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_635;
    }
LABEL_636:
    uint64_t v509 = *v496;
LABEL_637:
    uint64_t v499 = v508 + 1;
    uint64_t *v496 = (uint64_t)v513;
    v496[1] = (uint64_t)(v508 + 1);
    uint64_t v520 = v496[2];
    v496[2] = v505;
    if (v509) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v496[3] + 40))(v496[3], v509, v520 - v509);
    }
LABEL_612:
    v496[1] = (uint64_t)v499;
    if (++v497 != v498) {
      continue;
    }
    break;
  }
  uint64_t v521 = v496[4];
  if (v521 != v496[5]) {
    v496[5] = v521;
  }
LABEL_641:
  double v522 = (uint64_t *)*((void *)this + 172);
  double v523 = (uint64_t *)v522[4];
  double v524 = (uint64_t *)v522[5];
  if (v523 == v524) {
    goto LABEL_673;
  }
  double v525 = (void *)v522[1];
  while (2)
  {
    uint64_t v526 = *v523;
    unint64_t v527 = v522[2];
    if ((unint64_t)v525 < v527)
    {
      if (v525) {
        void *v525 = v526;
      }
      ++v525;
      goto LABEL_644;
    }
    uint64_t v528 = ((uint64_t)v525 - *v522) >> 3;
    if ((unint64_t)(v528 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v529 = v527 - *v522;
    uint64_t v530 = v529 >> 2;
    if (v529 >> 2 <= (unint64_t)(v528 + 1)) {
      uint64_t v530 = v528 + 1;
    }
    if ((unint64_t)v529 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v531 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v531 = v530;
    }
    if (v531)
    {
      uint64_t v532 = 8 * v531;
      uint64_t v533 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v522[3] + 16))(v522[3], 8 * v531, 8);
      double v534 = (void *)(v533 + 8 * v528);
      uint64_t v531 = v533 + v532;
      if (v533) {
        *double v534 = v526;
      }
    }
    else
    {
      double v534 = (void *)(8 * v528);
    }
    uint64_t v536 = *v522;
    uint64_t v535 = v522[1];
    uint64_t v537 = v535 - *v522;
    if (v535 == *v522)
    {
      double v539 = v534;
      goto LABEL_669;
    }
    unint64_t v538 = v537 - 8;
    if ((unint64_t)(v537 - 8) < 0x38)
    {
      double v539 = v534;
      do
      {
LABEL_667:
        uint64_t v545 = *(void *)(v535 - 8);
        v535 -= 8;
        *--double v539 = v545;
      }
      while (v535 != v536);
      goto LABEL_668;
    }
    double v539 = v534;
    if ((unint64_t)(v535 - (void)v534) < 0x20) {
      goto LABEL_667;
    }
    uint64_t v540 = (v538 >> 3) + 1;
    double v541 = v534 - 2;
    double v542 = (long long *)(v535 - 16);
    uint64_t v543 = v540 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v544 = *v542;
      *(v541 - 1) = *(v542 - 1);
      _OWORD *v541 = v544;
      v541 -= 2;
      v542 -= 2;
      v543 -= 4;
    }
    while (v543);
    double v539 = &v534[-(v540 & 0x3FFFFFFFFFFFFFFCLL)];
    v535 -= 8 * (v540 & 0x3FFFFFFFFFFFFFFCLL);
    if (v540 != (v540 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_667;
    }
LABEL_668:
    uint64_t v535 = *v522;
LABEL_669:
    double v525 = v534 + 1;
    *double v522 = (uint64_t)v539;
    v522[1] = (uint64_t)(v534 + 1);
    uint64_t v546 = v522[2];
    v522[2] = v531;
    if (v535) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v522[3] + 40))(v522[3], v535, v546 - v535);
    }
LABEL_644:
    v522[1] = (uint64_t)v525;
    if (++v523 != v524) {
      continue;
    }
    break;
  }
  uint64_t v547 = v522[4];
  if (v547 != v522[5]) {
    v522[5] = v547;
  }
LABEL_673:
  double v548 = (uint64_t *)*((void *)this + 177);
  double v549 = (uint64_t *)v548[4];
  double v550 = (uint64_t *)v548[5];
  if (v549 == v550) {
    goto LABEL_705;
  }
  double v551 = (void *)v548[1];
  while (2)
  {
    uint64_t v552 = *v549;
    unint64_t v553 = v548[2];
    if ((unint64_t)v551 < v553)
    {
      if (v551) {
        *double v551 = v552;
      }
      ++v551;
      goto LABEL_676;
    }
    uint64_t v554 = ((uint64_t)v551 - *v548) >> 3;
    if ((unint64_t)(v554 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v555 = v553 - *v548;
    uint64_t v556 = v555 >> 2;
    if (v555 >> 2 <= (unint64_t)(v554 + 1)) {
      uint64_t v556 = v554 + 1;
    }
    if ((unint64_t)v555 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v557 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v557 = v556;
    }
    if (v557)
    {
      uint64_t v558 = 8 * v557;
      uint64_t v559 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v548[3] + 16))(v548[3], 8 * v557, 8);
      float v560 = (void *)(v559 + 8 * v554);
      uint64_t v557 = v559 + v558;
      if (v559) {
        *float v560 = v552;
      }
    }
    else
    {
      float v560 = (void *)(8 * v554);
    }
    uint64_t v562 = *v548;
    uint64_t v561 = v548[1];
    uint64_t v563 = v561 - *v548;
    if (v561 == *v548)
    {
      float v565 = v560;
      goto LABEL_701;
    }
    unint64_t v564 = v563 - 8;
    if ((unint64_t)(v563 - 8) < 0x38)
    {
      float v565 = v560;
      do
      {
LABEL_699:
        uint64_t v571 = *(void *)(v561 - 8);
        v561 -= 8;
        *--float v565 = v571;
      }
      while (v561 != v562);
      goto LABEL_700;
    }
    float v565 = v560;
    if ((unint64_t)(v561 - (void)v560) < 0x20) {
      goto LABEL_699;
    }
    uint64_t v566 = (v564 >> 3) + 1;
    float v567 = v560 - 2;
    float v568 = (long long *)(v561 - 16);
    uint64_t v569 = v566 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v570 = *v568;
      *(v567 - 1) = *(v568 - 1);
      _OWORD *v567 = v570;
      v567 -= 2;
      v568 -= 2;
      v569 -= 4;
    }
    while (v569);
    float v565 = &v560[-(v566 & 0x3FFFFFFFFFFFFFFCLL)];
    v561 -= 8 * (v566 & 0x3FFFFFFFFFFFFFFCLL);
    if (v566 != (v566 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_699;
    }
LABEL_700:
    uint64_t v561 = *v548;
LABEL_701:
    double v551 = v560 + 1;
    uint64_t *v548 = (uint64_t)v565;
    v548[1] = (uint64_t)(v560 + 1);
    uint64_t v572 = v548[2];
    v548[2] = v557;
    if (v561) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v548[3] + 40))(v548[3], v561, v572 - v561);
    }
LABEL_676:
    v548[1] = (uint64_t)v551;
    if (++v549 != v550) {
      continue;
    }
    break;
  }
  uint64_t v573 = v548[4];
  if (v573 != v548[5]) {
    v548[5] = v573;
  }
LABEL_705:
  uint64_t v574 = (uint64_t *)*((void *)this + 178);
  unint64_t v575 = (uint64_t *)v574[4];
  uint64_t v576 = (uint64_t *)v574[5];
  if (v575 == v576) {
    goto LABEL_737;
  }
  v577 = (void *)v574[1];
  while (2)
  {
    uint64_t v578 = *v575;
    unint64_t v579 = v574[2];
    if ((unint64_t)v577 < v579)
    {
      if (v577) {
        void *v577 = v578;
      }
      ++v577;
      goto LABEL_708;
    }
    uint64_t v580 = ((uint64_t)v577 - *v574) >> 3;
    if ((unint64_t)(v580 + 1) >> 61) {
      goto LABEL_751;
    }
    uint64_t v581 = v579 - *v574;
    uint64_t v582 = v581 >> 2;
    if (v581 >> 2 <= (unint64_t)(v580 + 1)) {
      uint64_t v582 = v580 + 1;
    }
    if ((unint64_t)v581 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v583 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v583 = v582;
    }
    if (v583)
    {
      uint64_t v584 = 8 * v583;
      uint64_t v585 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v574[3] + 16))(v574[3], 8 * v583, 8);
      long long v586 = (void *)(v585 + 8 * v580);
      uint64_t v583 = v585 + v584;
      if (v585) {
        void *v586 = v578;
      }
    }
    else
    {
      long long v586 = (void *)(8 * v580);
    }
    uint64_t v588 = *v574;
    uint64_t v587 = v574[1];
    uint64_t v589 = v587 - *v574;
    if (v587 == *v574)
    {
      v591 = v586;
      goto LABEL_733;
    }
    unint64_t v590 = v589 - 8;
    if ((unint64_t)(v589 - 8) < 0x38)
    {
      v591 = v586;
      do
      {
LABEL_731:
        uint64_t v597 = *(void *)(v587 - 8);
        v587 -= 8;
        *--v591 = v597;
      }
      while (v587 != v588);
      goto LABEL_732;
    }
    v591 = v586;
    if ((unint64_t)(v587 - (void)v586) < 0x20) {
      goto LABEL_731;
    }
    uint64_t v592 = (v590 >> 3) + 1;
    uint64_t v593 = v586 - 2;
    v594 = (long long *)(v587 - 16);
    uint64_t v595 = v592 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v596 = *v594;
      *(v593 - 1) = *(v594 - 1);
      *uint64_t v593 = v596;
      v593 -= 2;
      v594 -= 2;
      v595 -= 4;
    }
    while (v595);
    v591 = &v586[-(v592 & 0x3FFFFFFFFFFFFFFCLL)];
    v587 -= 8 * (v592 & 0x3FFFFFFFFFFFFFFCLL);
    if (v592 != (v592 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_731;
    }
LABEL_732:
    uint64_t v587 = *v574;
LABEL_733:
    v577 = v586 + 1;
    *uint64_t v574 = (uint64_t)v591;
    v574[1] = (uint64_t)(v586 + 1);
    uint64_t v598 = v574[2];
    v574[2] = v583;
    if (v587) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v574[3] + 40))(v574[3], v587, v598 - v587);
    }
LABEL_708:
    v574[1] = (uint64_t)v577;
    if (++v575 != v576) {
      continue;
    }
    break;
  }
  uint64_t v599 = v574[4];
  if (v599 != v574[5]) {
    v574[5] = v599;
  }
LABEL_737:
  uint64_t v600 = *((void *)this + 311);
  uint64_t v601 = *((void *)this + 310);
  if (v600 != v601)
  {
    uint64_t v602 = *((void *)this + 311);
    do
    {
      long double v604 = *(void **)(v602 - 24);
      v602 -= 24;
      BOOL v603 = v604;
      if (v604)
      {
        *(void *)(v600 - 16) = v603;
        operator delete(v603);
      }
      uint64_t v600 = v602;
    }
    while (v602 != v601);
  }
  *((void *)this + 311) = v601;
  *((void *)this + 308) = *((void *)this + 307);
  long double v605 = (void *)*((void *)this + 317);
  if (v605)
  {
    do
    {
      if (v605[1])
      {
        unint64_t v607 = 0;
        char v608 = v605 + 2;
        int8x16_t v609 = v605 + 2;
        long double v610 = (void (***)(void))(v605 + 2);
        do
        {
          float32x4_t v611 = (void (**)(void *))*v610;
          v610 += 15;
          (*v611)(v609);
          ++v607;
          v608 += 15;
          int8x16_t v609 = v610;
        }
        while (v607 < v605[1]);
      }
      v605[1] = 0;
      long double v605 = (void *)*v605;
    }
    while (v605);
    uint64_t v606 = *((void *)this + 317);
  }
  else
  {
    uint64_t v606 = 0;
  }
  *((void *)this + 318) = v606;
}

void *md::DaVinciGroundRenderResources::prunePools(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[135];
  float v4 = *(void ***)v2;
  uint64_t v3 = *(void ***)(v2 + 8);
  if (*(void ***)v2 != v3)
  {
    do
    {
      this = *v4;
      if (*v4)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v3 = *(void ***)(v2 + 8);
      }
      ++v4;
    }
    while (v4 != v3);
    float v4 = *(void ***)v2;
  }
  *(void *)(v2 + 8) = v4;
  uint64_t v5 = v1[179];
  unint64_t v7 = *(void ***)v5;
  uint64_t v6 = *(void ***)(v5 + 8);
  if (*(void ***)v5 != v6)
  {
    do
    {
      this = *v7;
      if (*v7)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v6 = *(void ***)(v5 + 8);
      }
      ++v7;
    }
    while (v7 != v6);
    unint64_t v7 = *(void ***)v5;
  }
  *(void *)(v5 + 8) = v7;
  uint64_t v8 = v1[180];
  uint64_t v10 = *(void ***)v8;
  uint64_t v9 = *(void ***)(v8 + 8);
  if (*(void ***)v8 != v9)
  {
    do
    {
      this = *v10;
      if (*v10)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v9 = *(void ***)(v8 + 8);
      }
      ++v10;
    }
    while (v10 != v9);
    uint64_t v10 = *(void ***)v8;
  }
  *(void *)(v8 + 8) = v10;
  uint64_t v11 = v1[139];
  uint64_t v13 = *(void ***)v11;
  uint64_t v12 = *(void ***)(v11 + 8);
  if (*(void ***)v11 != v12)
  {
    do
    {
      this = *v13;
      if (*v13)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v12 = *(void ***)(v11 + 8);
      }
      ++v13;
    }
    while (v13 != v12);
    uint64_t v13 = *(void ***)v11;
  }
  *(void *)(v11 + 8) = v13;
  uint64_t v14 = v1[140];
  uint64_t v16 = *(void ***)v14;
  uint64_t v15 = *(void ***)(v14 + 8);
  if (*(void ***)v14 != v15)
  {
    do
    {
      this = *v16;
      if (*v16)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v15 = *(void ***)(v14 + 8);
      }
      ++v16;
    }
    while (v16 != v15);
    uint64_t v16 = *(void ***)v14;
  }
  *(void *)(v14 + 8) = v16;
  uint64_t v17 = v1[141];
  uint64_t v19 = *(void ***)v17;
  unint64_t v18 = *(void ***)(v17 + 8);
  if (*(void ***)v17 != v18)
  {
    do
    {
      this = *v19;
      if (*v19)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        unint64_t v18 = *(void ***)(v17 + 8);
      }
      ++v19;
    }
    while (v19 != v18);
    uint64_t v19 = *(void ***)v17;
  }
  *(void *)(v17 + 8) = v19;
  uint64_t v20 = v1[138];
  long long v22 = *(void ***)v20;
  uint64_t v21 = *(void ***)(v20 + 8);
  if (*(void ***)v20 != v21)
  {
    do
    {
      this = *v22;
      if (*v22)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v21 = *(void ***)(v20 + 8);
      }
      ++v22;
    }
    while (v22 != v21);
    long long v22 = *(void ***)v20;
  }
  *(void *)(v20 + 8) = v22;
  uint64_t v23 = v1[142];
  uint64_t v25 = *(void ***)v23;
  long long v24 = *(void ***)(v23 + 8);
  if (*(void ***)v23 != v24)
  {
    do
    {
      this = *v25;
      if (*v25)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        long long v24 = *(void ***)(v23 + 8);
      }
      ++v25;
    }
    while (v25 != v24);
    uint64_t v25 = *(void ***)v23;
  }
  *(void *)(v23 + 8) = v25;
  uint64_t v26 = v1[143];
  uint64_t v28 = *(void ***)v26;
  uint64_t v27 = *(void ***)(v26 + 8);
  if (*(void ***)v26 != v27)
  {
    do
    {
      this = *v28;
      if (*v28)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v27 = *(void ***)(v26 + 8);
      }
      ++v28;
    }
    while (v28 != v27);
    uint64_t v28 = *(void ***)v26;
  }
  *(void *)(v26 + 8) = v28;
  uint64_t v29 = v1[144];
  uint64_t v31 = *(void ***)v29;
  long long v30 = *(void ***)(v29 + 8);
  if (*(void ***)v29 != v30)
  {
    do
    {
      this = *v31;
      if (*v31)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        long long v30 = *(void ***)(v29 + 8);
      }
      ++v31;
    }
    while (v31 != v30);
    uint64_t v31 = *(void ***)v29;
  }
  *(void *)(v29 + 8) = v31;
  uint64_t v32 = v1[145];
  uint64_t v34 = *(void ***)v32;
  unint64_t v33 = *(void ***)(v32 + 8);
  if (*(void ***)v32 != v33)
  {
    do
    {
      this = *v34;
      if (*v34)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        unint64_t v33 = *(void ***)(v32 + 8);
      }
      ++v34;
    }
    while (v34 != v33);
    uint64_t v34 = *(void ***)v32;
  }
  *(void *)(v32 + 8) = v34;
  uint64_t v35 = v1[168];
  uint64_t v37 = *(void ***)v35;
  uint64_t v36 = *(void ***)(v35 + 8);
  if (*(void ***)v35 != v36)
  {
    do
    {
      this = *v37;
      if (*v37)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v36 = *(void ***)(v35 + 8);
      }
      ++v37;
    }
    while (v37 != v36);
    uint64_t v37 = *(void ***)v35;
  }
  *(void *)(v35 + 8) = v37;
  uint64_t v38 = v1[169];
  char v40 = *(void ***)v38;
  uint64_t v39 = *(void ***)(v38 + 8);
  if (*(void ***)v38 != v39)
  {
    do
    {
      this = *v40;
      if (*v40)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v39 = *(void ***)(v38 + 8);
      }
      ++v40;
    }
    while (v40 != v39);
    char v40 = *(void ***)v38;
  }
  *(void *)(v38 + 8) = v40;
  uint64_t v41 = v1[170];
  uint64_t v43 = *(void ***)v41;
  uint64_t v42 = *(void ***)(v41 + 8);
  if (*(void ***)v41 != v42)
  {
    do
    {
      this = *v43;
      if (*v43)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v42 = *(void ***)(v41 + 8);
      }
      ++v43;
    }
    while (v43 != v42);
    uint64_t v43 = *(void ***)v41;
  }
  *(void *)(v41 + 8) = v43;
  uint64_t v44 = v1[171];
  uint64_t v46 = *(void ***)v44;
  float v45 = *(void ***)(v44 + 8);
  if (*(void ***)v44 != v45)
  {
    do
    {
      this = *v46;
      if (*v46)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        float v45 = *(void ***)(v44 + 8);
      }
      ++v46;
    }
    while (v46 != v45);
    uint64_t v46 = *(void ***)v44;
  }
  *(void *)(v44 + 8) = v46;
  uint64_t v47 = v1[174];
  uint64_t v49 = *(void ***)v47;
  unsigned __int8 v48 = *(void ***)(v47 + 8);
  if (*(void ***)v47 != v48)
  {
    do
    {
      this = *v49;
      if (*v49)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        unsigned __int8 v48 = *(void ***)(v47 + 8);
      }
      ++v49;
    }
    while (v49 != v48);
    uint64_t v49 = *(void ***)v47;
  }
  *(void *)(v47 + 8) = v49;
  uint64_t v50 = v1[176];
  uint64_t v52 = *(void ***)v50;
  uint64_t v51 = *(void ***)(v50 + 8);
  if (*(void ***)v50 != v51)
  {
    do
    {
      this = *v52;
      if (*v52)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v51 = *(void ***)(v50 + 8);
      }
      ++v52;
    }
    while (v52 != v51);
    uint64_t v52 = *(void ***)v50;
  }
  *(void *)(v50 + 8) = v52;
  uint64_t v53 = v1[173];
  uint64_t v55 = *(void ***)v53;
  unint64_t v54 = *(void ***)(v53 + 8);
  if (*(void ***)v53 != v54)
  {
    do
    {
      this = *v55;
      if (*v55)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        unint64_t v54 = *(void ***)(v53 + 8);
      }
      ++v55;
    }
    while (v55 != v54);
    uint64_t v55 = *(void ***)v53;
  }
  *(void *)(v53 + 8) = v55;
  uint64_t v56 = v1[175];
  uint64_t v58 = *(void ***)v56;
  unint64_t v57 = *(void ***)(v56 + 8);
  if (*(void ***)v56 != v57)
  {
    do
    {
      this = *v58;
      if (*v58)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        unint64_t v57 = *(void ***)(v56 + 8);
      }
      ++v58;
    }
    while (v58 != v57);
    uint64_t v58 = *(void ***)v56;
  }
  *(void *)(v56 + 8) = v58;
  uint64_t v59 = v1[137];
  uint64_t v61 = *(void ***)v59;
  uint64_t v60 = *(void ***)(v59 + 8);
  if (*(void ***)v59 != v60)
  {
    do
    {
      this = *v61;
      if (*v61)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v60 = *(void ***)(v59 + 8);
      }
      ++v61;
    }
    while (v61 != v60);
    uint64_t v61 = *(void ***)v59;
  }
  *(void *)(v59 + 8) = v61;
  uint64_t v62 = v1[172];
  uint64_t v64 = *(void ***)v62;
  uint64_t v63 = *(void ***)(v62 + 8);
  if (*(void ***)v62 != v63)
  {
    do
    {
      this = *v64;
      if (*v64)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v63 = *(void ***)(v62 + 8);
      }
      ++v64;
    }
    while (v64 != v63);
    uint64_t v64 = *(void ***)v62;
  }
  *(void *)(v62 + 8) = v64;
  uint64_t v65 = v1[177];
  uint64_t v67 = *(void ***)v65;
  long long v66 = *(void ***)(v65 + 8);
  if (*(void ***)v65 != v66)
  {
    do
    {
      this = *v67;
      if (*v67)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        long long v66 = *(void ***)(v65 + 8);
      }
      ++v67;
    }
    while (v67 != v66);
    uint64_t v67 = *(void ***)v65;
  }
  *(void *)(v65 + 8) = v67;
  uint64_t v68 = v1[178];
  unint64_t v70 = *(void ***)v68;
  uint64_t v69 = *(void ***)(v68 + 8);
  if (*(void ***)v68 != v69)
  {
    do
    {
      this = *v70;
      if (*v70)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v69 = *(void ***)(v68 + 8);
      }
      ++v70;
    }
    while (v70 != v69);
    unint64_t v70 = *(void ***)v68;
  }
  *(void *)(v68 + 8) = v70;
  return this;
}

void *md::DaVinciGroundRenderLayer::prune(uint64_t a1)
{
  return md::DaVinciGroundRenderResources::prunePools((void *)(a1 + 568));
}

void *md::PolygonRenderResources::prunePools(void *this)
{
  uint64_t v1 = this;
  uint64_t v2 = this[22];
  float v4 = *(void ***)v2;
  uint64_t v3 = *(void ***)(v2 + 8);
  if (*(void ***)v2 != v3)
  {
    do
    {
      this = *v4;
      if (*v4)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v3 = *(void ***)(v2 + 8);
      }
      ++v4;
    }
    while (v4 != v3);
    float v4 = *(void ***)v2;
  }
  *(void *)(v2 + 8) = v4;
  uint64_t v5 = v1[23];
  unint64_t v7 = *(void ***)v5;
  uint64_t v6 = *(void ***)(v5 + 8);
  if (*(void ***)v5 != v6)
  {
    do
    {
      this = *v7;
      if (*v7)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v6 = *(void ***)(v5 + 8);
      }
      ++v7;
    }
    while (v7 != v6);
    unint64_t v7 = *(void ***)v5;
  }
  *(void *)(v5 + 8) = v7;
  uint64_t v8 = v1[24];
  uint64_t v10 = *(void ***)v8;
  uint64_t v9 = *(void ***)(v8 + 8);
  if (*(void ***)v8 != v9)
  {
    do
    {
      this = *v10;
      if (*v10)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v9 = *(void ***)(v8 + 8);
      }
      ++v10;
    }
    while (v10 != v9);
    uint64_t v10 = *(void ***)v8;
  }
  *(void *)(v8 + 8) = v10;
  uint64_t v11 = v1[25];
  uint64_t v13 = *(void ***)v11;
  uint64_t v12 = *(void ***)(v11 + 8);
  if (*(void ***)v11 != v12)
  {
    do
    {
      this = *v13;
      if (*v13)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v12 = *(void ***)(v11 + 8);
      }
      ++v13;
    }
    while (v13 != v12);
    uint64_t v13 = *(void ***)v11;
  }
  *(void *)(v11 + 8) = v13;
  uint64_t v14 = v1[26];
  uint64_t v16 = *(void ***)v14;
  uint64_t v15 = *(void ***)(v14 + 8);
  if (*(void ***)v14 != v15)
  {
    do
    {
      this = *v16;
      if (*v16)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v15 = *(void ***)(v14 + 8);
      }
      ++v16;
    }
    while (v16 != v15);
    uint64_t v16 = *(void ***)v14;
  }
  *(void *)(v14 + 8) = v16;
  uint64_t v17 = v1[27];
  uint64_t v19 = *(void ***)v17;
  unint64_t v18 = *(void ***)(v17 + 8);
  if (*(void ***)v17 != v18)
  {
    do
    {
      this = *v19;
      if (*v19)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        unint64_t v18 = *(void ***)(v17 + 8);
      }
      ++v19;
    }
    while (v19 != v18);
    uint64_t v19 = *(void ***)v17;
  }
  *(void *)(v17 + 8) = v19;
  uint64_t v20 = v1[28];
  long long v22 = *(void ***)v20;
  uint64_t v21 = *(void ***)(v20 + 8);
  if (*(void ***)v20 != v21)
  {
    do
    {
      this = *v22;
      if (*v22)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        uint64_t v21 = *(void ***)(v20 + 8);
      }
      ++v22;
    }
    while (v22 != v21);
    long long v22 = *(void ***)v20;
  }
  *(void *)(v20 + 8) = v22;
  uint64_t v23 = v1[29];
  uint64_t v25 = *(void ***)v23;
  long long v24 = *(void ***)(v23 + 8);
  if (*(void ***)v23 != v24)
  {
    do
    {
      this = *v25;
      if (*v25)
      {
        this = (void *)(*(uint64_t (**)(void *))(*this + 8))(this);
        long long v24 = *(void ***)(v23 + 8);
      }
      ++v25;
    }
    while (v25 != v24);
    uint64_t v25 = *(void ***)v23;
  }
  *(void *)(v23 + 8) = v25;
  return this;
}

void *md::ClientDrapedPolygonRenderLayer::prune(void *result)
{
  uint64_t v1 = result[60];
  uint64_t v2 = *(void **)v1;
  float v4 = **(void ****)v1;
  uint64_t v3 = *(void ***)(*(void *)v1 + 8);
  if (v4 != v3)
  {
    do
    {
      uint64_t result = *v4;
      if (*v4)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v3 = (void **)v2[1];
      }
      ++v4;
    }
    while (v4 != v3);
    float v4 = (void **)*v2;
  }
  v2[1] = v4;
  uint64_t v5 = *(void **)(v1 + 8);
  unint64_t v7 = (void **)*v5;
  uint64_t v6 = (void **)v5[1];
  if ((void **)*v5 != v6)
  {
    do
    {
      uint64_t result = *v7;
      if (*v7)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v6 = (void **)v5[1];
      }
      ++v7;
    }
    while (v7 != v6);
    unint64_t v7 = (void **)*v5;
  }
  v5[1] = v7;
  uint64_t v8 = *(void **)(v1 + 16);
  uint64_t v10 = (void **)*v8;
  uint64_t v9 = (void **)v8[1];
  if ((void **)*v8 != v9)
  {
    do
    {
      uint64_t result = *v10;
      if (*v10)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v9 = (void **)v8[1];
      }
      ++v10;
    }
    while (v10 != v9);
    uint64_t v10 = (void **)*v8;
  }
  v8[1] = v10;
  uint64_t v11 = *(void **)(v1 + 24);
  uint64_t v13 = (void **)*v11;
  uint64_t v12 = (void **)v11[1];
  if ((void **)*v11 != v12)
  {
    do
    {
      uint64_t result = *v13;
      if (*v13)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v12 = (void **)v11[1];
      }
      ++v13;
    }
    while (v13 != v12);
    uint64_t v13 = (void **)*v11;
  }
  v11[1] = v13;
  return result;
}

uint64_t *md::LandmarkRenderResources::resetPools(uint64_t **this)
{
  uint64_t v2 = *this;
  uint64_t v3 = (uint64_t *)(*this)[4];
  float v4 = (uint64_t *)(*this)[5];
  if (v3 == v4) {
    goto LABEL_33;
  }
  uint64_t v5 = (void *)v2[1];
  do
  {
    uint64_t v6 = *v3;
    unint64_t v7 = v2[2];
    if ((unint64_t)v5 < v7)
    {
      if (v5) {
        void *v5 = v6;
      }
      ++v5;
      goto LABEL_4;
    }
    uint64_t v8 = ((uint64_t)v5 - *v2) >> 3;
    if ((unint64_t)(v8 + 1) >> 61) {
LABEL_195:
    }
      abort();
    uint64_t v9 = v7 - *v2;
    uint64_t v10 = v9 >> 2;
    if (v9 >> 2 <= (unint64_t)(v8 + 1)) {
      uint64_t v10 = v8 + 1;
    }
    if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v11 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v11 = v10;
    }
    if (v11)
    {
      uint64_t v12 = 8 * v11;
      uint64_t v13 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[3] + 16))(v2[3], 8 * v11, 8);
      uint64_t v14 = (void *)(v13 + 8 * v8);
      uint64_t v11 = v13 + v12;
      if (v13) {
        *uint64_t v14 = v6;
      }
    }
    else
    {
      uint64_t v14 = (void *)(8 * v8);
    }
    uint64_t v16 = *v2;
    uint64_t v15 = v2[1];
    uint64_t v17 = v15 - *v2;
    if (v15 == *v2)
    {
      uint64_t v19 = v14;
      goto LABEL_29;
    }
    unint64_t v18 = v17 - 8;
    if ((unint64_t)(v17 - 8) < 0x38)
    {
      uint64_t v19 = v14;
    }
    else
    {
      uint64_t v19 = v14;
      if ((unint64_t)(v15 - (void)v14) >= 0x20)
      {
        uint64_t v20 = (v18 >> 3) + 1;
        uint64_t v21 = v14 - 2;
        long long v22 = (long long *)(v15 - 16);
        uint64_t v23 = v20 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v24 = *v22;
          *(v21 - 1) = *(v22 - 1);
          *uint64_t v21 = v24;
          v21 -= 2;
          v22 -= 2;
          v23 -= 4;
        }
        while (v23);
        uint64_t v19 = &v14[-(v20 & 0x3FFFFFFFFFFFFFFCLL)];
        v15 -= 8 * (v20 & 0x3FFFFFFFFFFFFFFCLL);
        if (v20 == (v20 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_28;
        }
      }
    }
    do
    {
      uint64_t v25 = *(void *)(v15 - 8);
      v15 -= 8;
      *--uint64_t v19 = v25;
    }
    while (v15 != v16);
LABEL_28:
    uint64_t v15 = *v2;
LABEL_29:
    uint64_t v5 = v14 + 1;
    *uint64_t v2 = (uint64_t)v19;
    v2[1] = (uint64_t)(v14 + 1);
    uint64_t v26 = v2[2];
    v2[2] = v11;
    if (v15) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[3] + 40))(v2[3], v15, v26 - v15);
    }
LABEL_4:
    v2[1] = (uint64_t)v5;
    ++v3;
  }
  while (v3 != v4);
  uint64_t v27 = v2[4];
  if (v27 != v2[5]) {
    v2[5] = v27;
  }
LABEL_33:
  uint64_t v28 = this[3];
  uint64_t v29 = (uint64_t *)v28[4];
  long long v30 = (uint64_t *)v28[5];
  if (v29 == v30) {
    goto LABEL_65;
  }
  uint64_t v31 = (void *)v28[1];
  while (2)
  {
    uint64_t v32 = *v29;
    unint64_t v33 = v28[2];
    if ((unint64_t)v31 < v33)
    {
      if (v31) {
        *uint64_t v31 = v32;
      }
      ++v31;
      goto LABEL_36;
    }
    uint64_t v34 = ((uint64_t)v31 - *v28) >> 3;
    if ((unint64_t)(v34 + 1) >> 61) {
      goto LABEL_195;
    }
    uint64_t v35 = v33 - *v28;
    uint64_t v36 = v35 >> 2;
    if (v35 >> 2 <= (unint64_t)(v34 + 1)) {
      uint64_t v36 = v34 + 1;
    }
    if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v37 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v37 = v36;
    }
    if (v37)
    {
      uint64_t v38 = 8 * v37;
      uint64_t v39 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v28[3] + 16))(v28[3], 8 * v37, 8);
      char v40 = (void *)(v39 + 8 * v34);
      uint64_t v37 = v39 + v38;
      if (v39) {
        *char v40 = v32;
      }
    }
    else
    {
      char v40 = (void *)(8 * v34);
    }
    uint64_t v42 = *v28;
    uint64_t v41 = v28[1];
    uint64_t v43 = v41 - *v28;
    if (v41 == *v28)
    {
      float v45 = v40;
      goto LABEL_61;
    }
    unint64_t v44 = v43 - 8;
    if ((unint64_t)(v43 - 8) < 0x38)
    {
      float v45 = v40;
      do
      {
LABEL_59:
        uint64_t v51 = *(void *)(v41 - 8);
        v41 -= 8;
        *--float v45 = v51;
      }
      while (v41 != v42);
      goto LABEL_60;
    }
    float v45 = v40;
    if ((unint64_t)(v41 - (void)v40) < 0x20) {
      goto LABEL_59;
    }
    uint64_t v46 = (v44 >> 3) + 1;
    uint64_t v47 = v40 - 2;
    unsigned __int8 v48 = (long long *)(v41 - 16);
    uint64_t v49 = v46 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v50 = *v48;
      *(v47 - 1) = *(v48 - 1);
      _OWORD *v47 = v50;
      v47 -= 2;
      v48 -= 2;
      v49 -= 4;
    }
    while (v49);
    float v45 = &v40[-(v46 & 0x3FFFFFFFFFFFFFFCLL)];
    v41 -= 8 * (v46 & 0x3FFFFFFFFFFFFFFCLL);
    if (v46 != (v46 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_59;
    }
LABEL_60:
    uint64_t v41 = *v28;
LABEL_61:
    uint64_t v31 = v40 + 1;
    *uint64_t v28 = (uint64_t)v45;
    v28[1] = (uint64_t)(v40 + 1);
    uint64_t v52 = v28[2];
    v28[2] = v37;
    if (v41) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v28[3] + 40))(v28[3], v41, v52 - v41);
    }
LABEL_36:
    v28[1] = (uint64_t)v31;
    if (++v29 != v30) {
      continue;
    }
    break;
  }
  uint64_t v53 = v28[4];
  if (v53 != v28[5]) {
    v28[5] = v53;
  }
LABEL_65:
  if (!*((unsigned char *)this + 272))
  {
    uint64_t v106 = this[1];
    long long v107 = (uint64_t *)v106[4];
    int64x2_t v108 = (uint64_t *)v106[5];
    if (v107 == v108) {
      goto LABEL_160;
    }
    uint64_t v109 = (void *)v106[1];
    while (1)
    {
      uint64_t v110 = *v107;
      unint64_t v111 = v106[2];
      if ((unint64_t)v109 >= v111) {
        break;
      }
      if (v109) {
        *uint64_t v109 = v110;
      }
      ++v109;
LABEL_131:
      v106[1] = (uint64_t)v109;
      if (++v107 == v108)
      {
        uint64_t v131 = v106[4];
        if (v131 != v106[5]) {
          v106[5] = v131;
        }
LABEL_160:
        uint64_t v80 = this[4];
        unint64_t v132 = (uint64_t *)v80[4];
        char v82 = v80 + 5;
        int64x2_t v133 = (uint64_t *)v80[5];
        if (v132 == v133) {
          goto LABEL_192;
        }
        uint64_t v134 = (void *)v80[1];
        while (2)
        {
          uint64_t v135 = *v132;
          unint64_t v136 = v80[2];
          if ((unint64_t)v134 < v136)
          {
            if (v134) {
              *uint64_t v134 = v135;
            }
            ++v134;
            goto LABEL_163;
          }
          uint64_t v137 = ((uint64_t)v134 - *v80) >> 3;
          if ((unint64_t)(v137 + 1) >> 61) {
            goto LABEL_195;
          }
          uint64_t v138 = v136 - *v80;
          uint64_t v139 = v138 >> 2;
          if (v138 >> 2 <= (unint64_t)(v137 + 1)) {
            uint64_t v139 = v137 + 1;
          }
          if ((unint64_t)v138 >= 0x7FFFFFFFFFFFFFF8) {
            uint64_t v140 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            uint64_t v140 = v139;
          }
          if (v140)
          {
            uint64_t v141 = 8 * v140;
            uint64_t v142 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80[3] + 16))(v80[3], 8 * v140, 8);
            uint64_t v143 = (void *)(v142 + 8 * v137);
            uint64_t v140 = v142 + v141;
            if (v142) {
              *uint64_t v143 = v135;
            }
          }
          else
          {
            uint64_t v143 = (void *)(8 * v137);
          }
          uint64_t v145 = *v80;
          uint64_t v144 = v80[1];
          uint64_t v146 = v144 - *v80;
          if (v144 != *v80)
          {
            unint64_t v147 = v146 - 8;
            if ((unint64_t)(v146 - 8) < 0x38)
            {
              unint64_t v148 = v143;
            }
            else
            {
              unint64_t v148 = v143;
              if ((unint64_t)(v144 - (void)v143) >= 0x20)
              {
                uint64_t v149 = (v147 >> 3) + 1;
                uint64_t v150 = v143 - 2;
                int64x2_t v151 = (long long *)(v144 - 16);
                uint64_t v152 = v149 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v153 = *v151;
                  *(v150 - 1) = *(v151 - 1);
                  _OWORD *v150 = v153;
                  v150 -= 2;
                  v151 -= 2;
                  v152 -= 4;
                }
                while (v152);
                unint64_t v148 = &v143[-(v149 & 0x3FFFFFFFFFFFFFFCLL)];
                v144 -= 8 * (v149 & 0x3FFFFFFFFFFFFFFCLL);
                if (v149 == (v149 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_187:
                  uint64_t v144 = *v80;
LABEL_188:
                  uint64_t v134 = v143 + 1;
                  *uint64_t v80 = (uint64_t)v148;
                  v80[1] = (uint64_t)(v143 + 1);
                  uint64_t v155 = v80[2];
                  v80[2] = v140;
                  if (v144) {
                    (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80[3] + 40))(v80[3], v144, v155 - v144);
                  }
LABEL_163:
                  v80[1] = (uint64_t)v134;
                  if (++v132 == v133)
                  {
LABEL_190:
                    uint64_t v156 = v80[4];
                    if (v156 != v80[5]) {
                      *char v82 = v156;
                    }
                    goto LABEL_192;
                  }
                  continue;
                }
              }
            }
            do
            {
              uint64_t v154 = *(void *)(v144 - 8);
              v144 -= 8;
              *--unint64_t v148 = v154;
            }
            while (v144 != v145);
            goto LABEL_187;
          }
          break;
        }
        unint64_t v148 = v143;
        goto LABEL_188;
      }
    }
    uint64_t v112 = ((uint64_t)v109 - *v106) >> 3;
    if ((unint64_t)(v112 + 1) >> 61) {
      goto LABEL_195;
    }
    uint64_t v113 = v111 - *v106;
    uint64_t v114 = v113 >> 2;
    if (v113 >> 2 <= (unint64_t)(v112 + 1)) {
      uint64_t v114 = v112 + 1;
    }
    if ((unint64_t)v113 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v115 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v115 = v114;
    }
    if (v115)
    {
      uint64_t v116 = 8 * v115;
      uint64_t v117 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v106[3] + 16))(v106[3], 8 * v115, 8);
      uint64_t v118 = (void *)(v117 + 8 * v112);
      uint64_t v115 = v117 + v116;
      if (v117) {
        void *v118 = v110;
      }
    }
    else
    {
      uint64_t v118 = (void *)(8 * v112);
    }
    uint64_t v120 = *v106;
    uint64_t v119 = v106[1];
    uint64_t v121 = v119 - *v106;
    if (v119 == *v106)
    {
      int8x16_t v123 = v118;
      goto LABEL_156;
    }
    unint64_t v122 = v121 - 8;
    if ((unint64_t)(v121 - 8) < 0x38)
    {
      int8x16_t v123 = v118;
    }
    else
    {
      int8x16_t v123 = v118;
      if ((unint64_t)(v119 - (void)v118) >= 0x20)
      {
        uint64_t v124 = (v122 >> 3) + 1;
        uint64_t v125 = v118 - 2;
        uint64_t v126 = (long long *)(v119 - 16);
        uint64_t v127 = v124 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v128 = *v126;
          *(v125 - 1) = *(v126 - 1);
          *uint64_t v125 = v128;
          v125 -= 2;
          v126 -= 2;
          v127 -= 4;
        }
        while (v127);
        int8x16_t v123 = &v118[-(v124 & 0x3FFFFFFFFFFFFFFCLL)];
        v119 -= 8 * (v124 & 0x3FFFFFFFFFFFFFFCLL);
        if (v124 == (v124 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_155;
        }
      }
    }
    do
    {
      uint64_t v129 = *(void *)(v119 - 8);
      v119 -= 8;
      *--int8x16_t v123 = v129;
    }
    while (v119 != v120);
LABEL_155:
    uint64_t v119 = *v106;
LABEL_156:
    uint64_t v109 = v118 + 1;
    *uint64_t v106 = (uint64_t)v123;
    v106[1] = (uint64_t)(v118 + 1);
    uint64_t v130 = v106[2];
    v106[2] = v115;
    if (v119) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v106[3] + 40))(v106[3], v119, v130 - v119);
    }
    goto LABEL_131;
  }
  unint64_t v54 = this[2];
  uint64_t v55 = (uint64_t *)v54[4];
  uint64_t v56 = (uint64_t *)v54[5];
  if (v55 == v56) {
    goto LABEL_98;
  }
  unint64_t v57 = (void *)v54[1];
  while (2)
  {
    uint64_t v58 = *v55;
    unint64_t v59 = v54[2];
    if ((unint64_t)v57 < v59)
    {
      if (v57) {
        *unint64_t v57 = v58;
      }
      ++v57;
      goto LABEL_69;
    }
    uint64_t v60 = ((uint64_t)v57 - *v54) >> 3;
    if ((unint64_t)(v60 + 1) >> 61) {
      goto LABEL_195;
    }
    uint64_t v61 = v59 - *v54;
    uint64_t v62 = v61 >> 2;
    if (v61 >> 2 <= (unint64_t)(v60 + 1)) {
      uint64_t v62 = v60 + 1;
    }
    if ((unint64_t)v61 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v63 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v63 = v62;
    }
    if (v63)
    {
      uint64_t v64 = 8 * v63;
      uint64_t v65 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v54[3] + 16))(v54[3], 8 * v63, 8);
      long long v66 = (void *)(v65 + 8 * v60);
      uint64_t v63 = v65 + v64;
      if (v65) {
        *long long v66 = v58;
      }
    }
    else
    {
      long long v66 = (void *)(8 * v60);
    }
    uint64_t v68 = *v54;
    uint64_t v67 = v54[1];
    uint64_t v69 = v67 - *v54;
    if (v67 == *v54)
    {
      uint64_t v71 = v66;
      goto LABEL_94;
    }
    unint64_t v70 = v69 - 8;
    if ((unint64_t)(v69 - 8) < 0x38)
    {
      uint64_t v71 = v66;
      do
      {
LABEL_92:
        uint64_t v77 = *(void *)(v67 - 8);
        v67 -= 8;
        *--uint64_t v71 = v77;
      }
      while (v67 != v68);
      goto LABEL_93;
    }
    uint64_t v71 = v66;
    if ((unint64_t)(v67 - (void)v66) < 0x20) {
      goto LABEL_92;
    }
    uint64_t v72 = (v70 >> 3) + 1;
    uint64_t v73 = v66 - 2;
    uint64_t v74 = (long long *)(v67 - 16);
    uint64_t v75 = v72 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v76 = *v74;
      *(v73 - 1) = *(v74 - 1);
      _OWORD *v73 = v76;
      v73 -= 2;
      v74 -= 2;
      v75 -= 4;
    }
    while (v75);
    uint64_t v71 = &v66[-(v72 & 0x3FFFFFFFFFFFFFFCLL)];
    v67 -= 8 * (v72 & 0x3FFFFFFFFFFFFFFCLL);
    if (v72 != (v72 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_92;
    }
LABEL_93:
    uint64_t v67 = *v54;
LABEL_94:
    unint64_t v57 = v66 + 1;
    *unint64_t v54 = (uint64_t)v71;
    v54[1] = (uint64_t)(v66 + 1);
    uint64_t v78 = v54[2];
    v54[2] = v63;
    if (v67) {
      (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v54[3] + 40))(v54[3], v67, v78 - v67);
    }
LABEL_69:
    v54[1] = (uint64_t)v57;
    if (++v55 != v56) {
      continue;
    }
    break;
  }
  uint64_t v79 = v54[4];
  if (v79 != v54[5]) {
    v54[5] = v79;
  }
LABEL_98:
  uint64_t v80 = this[5];
  char v81 = (uint64_t *)v80[4];
  char v82 = v80 + 5;
  unint64_t v83 = (uint64_t *)v80[5];
  if (v81 != v83)
  {
    uint64_t v84 = (void *)v80[1];
    while (1)
    {
      uint64_t v85 = *v81;
      unint64_t v86 = v80[2];
      if ((unint64_t)v84 >= v86) {
        break;
      }
      if (v84) {
        *uint64_t v84 = v85;
      }
      ++v84;
LABEL_101:
      v80[1] = (uint64_t)v84;
      if (++v81 == v83) {
        goto LABEL_190;
      }
    }
    uint64_t v87 = ((uint64_t)v84 - *v80) >> 3;
    if ((unint64_t)(v87 + 1) >> 61) {
      goto LABEL_195;
    }
    uint64_t v88 = v86 - *v80;
    uint64_t v89 = v88 >> 2;
    if (v88 >> 2 <= (unint64_t)(v87 + 1)) {
      uint64_t v89 = v87 + 1;
    }
    if ((unint64_t)v88 >= 0x7FFFFFFFFFFFFFF8) {
      uint64_t v90 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      uint64_t v90 = v89;
    }
    if (v90)
    {
      uint64_t v91 = 8 * v90;
      uint64_t v92 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80[3] + 16))(v80[3], 8 * v90, 8);
      uint64_t v93 = (void *)(v92 + 8 * v87);
      uint64_t v90 = v92 + v91;
      if (v92) {
        *uint64_t v93 = v85;
      }
    }
    else
    {
      uint64_t v93 = (void *)(8 * v87);
    }
    uint64_t v95 = *v80;
    uint64_t v94 = v80[1];
    uint64_t v96 = v94 - *v80;
    if (v94 != *v80)
    {
      unint64_t v97 = v96 - 8;
      if ((unint64_t)(v96 - 8) < 0x38)
      {
        uint64_t v98 = v93;
      }
      else
      {
        uint64_t v98 = v93;
        if ((unint64_t)(v94 - (void)v93) >= 0x20)
        {
          uint64_t v99 = (v97 >> 3) + 1;
          id v100 = v93 - 2;
          uint64_t v101 = (long long *)(v94 - 16);
          uint64_t v102 = v99 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v103 = *v101;
            *(v100 - 1) = *(v101 - 1);
            *id v100 = v103;
            v100 -= 2;
            v101 -= 2;
            v102 -= 4;
          }
          while (v102);
          uint64_t v98 = &v93[-(v99 & 0x3FFFFFFFFFFFFFFCLL)];
          v94 -= 8 * (v99 & 0x3FFFFFFFFFFFFFFCLL);
          if (v99 == (v99 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_125:
            uint64_t v94 = *v80;
LABEL_126:
            uint64_t v84 = v93 + 1;
            *uint64_t v80 = (uint64_t)v98;
            v80[1] = (uint64_t)(v93 + 1);
            uint64_t v105 = v80[2];
            v80[2] = v90;
            if (v94) {
              (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v80[3] + 40))(v80[3], v94, v105 - v94);
            }
            goto LABEL_101;
          }
        }
      }
      do
      {
        uint64_t v104 = *(void *)(v94 - 8);
        v94 -= 8;
        *--uint64_t v98 = v104;
      }
      while (v94 != v95);
      goto LABEL_125;
    }
    uint64_t v98 = v93;
    goto LABEL_126;
  }
LABEL_192:
  uint64_t v157 = this[11];
  return ggl::FragmentedPool<ggl::RenderItem>::pushAll(v157);
}

void *md::CoastlineRenderLayer::prune(void *result)
{
  uint64_t v1 = result[46];
  uint64_t v2 = *(void **)(v1 + 16);
  float v4 = (void **)*v2;
  uint64_t v3 = (void **)v2[1];
  if ((void **)*v2 != v3)
  {
    do
    {
      uint64_t result = *v4;
      if (*v4)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v3 = (void **)v2[1];
      }
      ++v4;
    }
    while (v4 != v3);
    float v4 = (void **)*v2;
  }
  v2[1] = v4;
  uint64_t v5 = *(void **)(v1 + 24);
  unint64_t v7 = (void **)*v5;
  uint64_t v6 = (void **)v5[1];
  if ((void **)*v5 != v6)
  {
    do
    {
      uint64_t result = *v7;
      if (*v7)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v6 = (void **)v5[1];
      }
      ++v7;
    }
    while (v7 != v6);
    unint64_t v7 = (void **)*v5;
  }
  v5[1] = v7;
  uint64_t v8 = *(void **)(v1 + 104);
  uint64_t v10 = (void **)*v8;
  uint64_t v9 = (void **)v8[1];
  if ((void **)*v8 != v9)
  {
    do
    {
      uint64_t result = *v10;
      if (*v10)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v9 = (void **)v8[1];
      }
      ++v10;
    }
    while (v10 != v9);
    uint64_t v10 = (void **)*v8;
  }
  v8[1] = v10;
  uint64_t v11 = *(void **)(v1 + 112);
  uint64_t v13 = (void **)*v11;
  uint64_t v12 = (void **)v11[1];
  if ((void **)*v11 != v12)
  {
    do
    {
      uint64_t result = *v13;
      if (*v13)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v12 = (void **)v11[1];
      }
      ++v13;
    }
    while (v13 != v12);
    uint64_t v13 = (void **)*v11;
  }
  v11[1] = v13;
  uint64_t v14 = *(void **)v1;
  uint64_t v16 = **(void ****)v1;
  uint64_t v15 = *(void ***)(*(void *)v1 + 8);
  if (v16 != v15)
  {
    do
    {
      uint64_t result = *v16;
      if (*v16)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v15 = (void **)v14[1];
      }
      ++v16;
    }
    while (v16 != v15);
    uint64_t v16 = (void **)*v14;
  }
  v14[1] = v16;
  uint64_t v17 = *(void **)(v1 + 8);
  uint64_t v19 = (void **)*v17;
  unint64_t v18 = (void **)v17[1];
  if ((void **)*v17 != v18)
  {
    do
    {
      uint64_t result = *v19;
      if (*v19)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        unint64_t v18 = (void **)v17[1];
      }
      ++v19;
    }
    while (v19 != v18);
    uint64_t v19 = (void **)*v17;
  }
  v17[1] = v19;
  return result;
}

void *md::PolygonRenderLayer<(md::MapDataType)59,md::MapTileDataRenderable<md::PolygonTileData>>::prune(uint64_t a1)
{
  return md::PolygonRenderResources::prunePools(*(void **)(a1 + 368));
}

void *md::PolygonRenderLayer<(md::MapDataType)41,md::MapTileDataRenderable<md::PolygonTileData>>::prune(uint64_t a1)
{
  return md::PolygonRenderResources::prunePools(*(void **)(a1 + 368));
}

void *md::PolygonRenderLayer<(md::MapDataType)1,md::MapTileDataRenderable<md::PolygonTileData>>::prune(uint64_t a1)
{
  return md::PolygonRenderResources::prunePools(*(void **)(a1 + 368));
}

void *md::FlyoverRenderLayer::prune(uint64_t a1)
{
  return md::FlyoverRenderResources::prunePools((void *)(a1 + 368));
}

uint64_t md::LabelRenderLayer::prune(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = (uint64_t *)(result + 56);
  *(_DWORD *)(result + 160) = 0;
  uint64_t v3 = *(uint64_t **)(result + 112);
  if (v3)
  {
    int v4 = 0;
    do
    {
      while (!*((unsigned char *)v3 + 64))
      {
        uint64_t v8 = v3[6];
        if (!v8 || *(void *)(v8 + 8) == -1) {
          break;
        }
        v3[7] = (uint64_t)v2;
        uint64_t v3 = (uint64_t *)*v3;
        ++v4;
        if (!v3) {
          goto LABEL_15;
        }
      }
      uint64_t v5 = (uint64_t *)*v3;
      uint64_t result = std::__hash_table<std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,std::__unordered_map_hasher<geo::QuadTile,std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,geo::QuadTileHash,std::equal_to<geo::QuadTile>,true>,std::__unordered_map_equal<geo::QuadTile,std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,std::equal_to<geo::QuadTile>,geo::QuadTileHash,true>,geo::StdAllocator<std::__hash_value_type<geo::QuadTile,md::LabelCachingStore<geo::QuadTile,std::shared_ptr<md::StandardLabelMapTile>,std::weak_ptr<md::StandardLabelMapTile>,geo::QuadTileHash,std::equal_to<geo::QuadTile>>::MapEntry>,mdm::Allocator>>::remove((uint64_t)&v14, (void *)(v1 + 88), v3);
      uint64_t v6 = v14;
      if (v14)
      {
        if (v16)
        {
          unint64_t v7 = *(std::__shared_weak_count **)(v14 + 48);
          if (v7) {
            std::__shared_weak_count::__release_weak(v7);
          }
        }
        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(*(void *)*v15 + 40))(*v15, v6, 72);
      }
      uint64_t v3 = v5;
    }
    while (v5);
  }
  else
  {
    int v4 = 0;
  }
LABEL_15:
  *(_DWORD *)(v1 + 156) = v4;
  if (*(void *)(v1 + 72))
  {
    uint64_t v9 = *(void *)(v1 + 56);
    uint64_t v10 = *(uint64_t **)(v1 + 64);
    uint64_t v11 = *v10;
    *(void *)(v11 + 8) = *(void *)(v9 + 8);
    **(void **)(v9 + 8) = v11;
    *(void *)(v1 + 72) = 0;
    if (v10 != v2)
    {
      do
      {
        uint64_t v12 = (uint64_t *)v10[1];
        uint64_t v13 = (std::__shared_weak_count *)v10[6];
        if (v13)
        {
          if (!atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
          }
        }
        uint64_t result = (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(v1 + 80) + 40))(*(void *)(v1 + 80), v10, 56);
        uint64_t v10 = v12;
      }
      while (v12 != v2);
    }
  }
  return result;
}

void *md::DebugRenderLayer::prune(void *result)
{
  uint64_t v1 = result;
  uint64_t v2 = *(void **)(result[6] + 112);
  int v4 = (void **)*v2;
  uint64_t v3 = (void **)v2[1];
  if ((void **)*v2 != v3)
  {
    do
    {
      uint64_t result = *v4;
      if (*v4)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v3 = (void **)v2[1];
      }
      ++v4;
    }
    while (v4 != v3);
    int v4 = (void **)*v2;
  }
  v2[1] = v4;
  uint64_t v5 = *(void **)(v1[6] + 136);
  unint64_t v7 = (void **)*v5;
  uint64_t v6 = (void **)v5[1];
  if ((void **)*v5 != v6)
  {
    do
    {
      uint64_t result = *v7;
      if (*v7)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v6 = (void **)v5[1];
      }
      ++v7;
    }
    while (v7 != v6);
    unint64_t v7 = (void **)*v5;
  }
  v5[1] = v7;
  uint64_t v8 = *(void **)(v1[6] + 144);
  uint64_t v10 = (void **)*v8;
  uint64_t v9 = (void **)v8[1];
  if ((void **)*v8 != v9)
  {
    do
    {
      uint64_t result = *v10;
      if (*v10)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v9 = (void **)v8[1];
      }
      ++v10;
    }
    while (v10 != v9);
    uint64_t v10 = (void **)*v8;
  }
  v8[1] = v10;
  uint64_t v11 = *(void **)(v1[6] + 160);
  uint64_t v13 = (void **)*v11;
  uint64_t v12 = (void **)v11[1];
  if ((void **)*v11 != v12)
  {
    do
    {
      uint64_t result = *v13;
      if (*v13)
      {
        uint64_t result = (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
        uint64_t v12 = (void **)v11[1];
      }
      ++v13;
    }
    while (v13 != v12);
    uint64_t v13 = (void **)*v11;
  }
  v11[1] = v13;
  return result;
}

void __destroy_helper_block_ea8_40c70_ZTSNSt3__110shared_ptrIN3gss17StylesheetManagerINS1_10PropertyIDEEEEE(uint64_t a1)
{
  uint64_t v1 = *(std::__shared_weak_count **)(a1 + 48);
  if (v1 && !atomic_fetch_add(&v1->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
    std::__shared_weak_count::__release_weak(v1);
  }
}

uint64_t std::__shared_ptr_pointer<gss::StylesheetManager<gss::PropertyID> *,std::shared_ptr<gss::StylesheetManager<gss::PropertyID>>::__shared_ptr_default_delete<gss::StylesheetManager<gss::PropertyID>,gss::StylesheetManager<gss::PropertyID>>,std::allocator<gss::StylesheetManager<gss::PropertyID>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 24);
  if (result)
  {
    gss::StylesheetManager<gss::PropertyID>::~StylesheetManager(result);
    JUMPOUT(0x1A6239270);
  }
  return result;
}

uint64_t gss::StylesheetManager<gss::PropertyID>::~StylesheetManager(uint64_t a1)
{
  uint64_t v2 = *(std::__shared_weak_count **)(a1 + 528);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
  }
  uint64_t v3 = (geo::read_write_lock *)pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 320));
  if (v3) {
    geo::read_write_lock::logFailure(v3, (uint64_t)"destruction", v4);
  }
  uint64_t v5 = (geo::read_write_lock *)pthread_rwlock_destroy((pthread_rwlock_t *)(a1 + 120));
  if (v5) {
    geo::read_write_lock::logFailure(v5, (uint64_t)"destruction", v6);
  }
  uint64_t v7 = *(void *)(a1 + 88);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 96);
    uint64_t v9 = *(void *)(a1 + 88);
    if (v8 != v7)
    {
      do
      {
        uint64_t v10 = *(std::__shared_weak_count **)(v8 - 8);
        if (v10) {
          std::__shared_weak_count::__release_weak(v10);
        }
        v8 -= 16;
      }
      while (v8 != v7);
      uint64_t v9 = *(void *)(a1 + 88);
    }
    *(void *)(a1 + 96) = v7;
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 112) + 40))(*(void *)(a1 + 112), v9, *(void *)(a1 + 104) - v9);
  }
  std::__hash_table<std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::__unordered_map_hasher<gss::StyleKey,std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<gss::StyleKey>,std::equal_to<gss::StyleKey>,true>,std::__unordered_map_equal<gss::StyleKey,std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<gss::StyleKey>,std::hash<gss::StyleKey>,true>,geo::StdAllocator<std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,gss::Allocator>>::__deallocate_node(a1 + 32, *(uint64_t **)(a1 + 56));
  uint64_t v11 = *(void *)(a1 + 32);
  *(void *)(a1 + 32) = 0;
  if (v11) {
    (*(void (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 48) + 40))(*(void *)(a1 + 48), v11, 8 * *(void *)(a1 + 40));
  }
  uint64_t v12 = *(std::__shared_weak_count **)(a1 + 24);
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
    uint64_t v13 = *(std::__shared_weak_count **)(a1 + 8);
    if (!v13) {
      return a1;
    }
    goto LABEL_21;
  }
  uint64_t v13 = *(std::__shared_weak_count **)(a1 + 8);
  if (v13) {
LABEL_21:
  }
    std::__shared_weak_count::__release_weak(v13);
  return a1;
}

uint64_t std::__hash_table<std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::__unordered_map_hasher<gss::StyleKey,std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::hash<gss::StyleKey>,std::equal_to<gss::StyleKey>,true>,std::__unordered_map_equal<gss::StyleKey,std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,std::equal_to<gss::StyleKey>,std::hash<gss::StyleKey>,true>,geo::StdAllocator<std::__hash_value_type<gss::StyleKey,std::weak_ptr<gss::StylesheetQuery<gss::PropertyID>>>,gss::Allocator>>::__deallocate_node(uint64_t result, uint64_t *a2)
{
  if (a2)
  {
    uint64_t v2 = a2;
    uint64_t v3 = result;
    do
    {
      int v4 = (uint64_t *)*v2;
      uint64_t v5 = (std::__shared_weak_count *)v2[9];
      if (v5) {
        std::__shared_weak_count::__release_weak(v5);
      }
      if (!*((unsigned char *)v2 + 62) && v2[6])
      {
        uint64_t v6 = gss::Allocator::instance((gss::Allocator *)v5);
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v6 + 40))(v6, v2[6], *((unsigned __int16 *)v2 + 30));
        v2[6] = 0;
      }
      uint64_t v7 = v2[2];
      if (v7)
      {
        v2[3] = v7;
        (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)v2[5] + 40))(v2[5], v7, v2[4] - v7);
      }
      uint64_t result = (*(uint64_t (**)(void, uint64_t *, uint64_t))(**(void **)(v3 + 32) + 40))(*(void *)(v3 + 32), v2, 80);
      uint64_t v2 = v4;
    }
    while (v4);
  }
  return result;
}

void grl::PathGenerator::createSquarePath(float *a1@<X0>, void *a2@<X8>, float a3@<S0>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x28uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582B70;
  uint64_t v7 = esl::QuartzPath::QuartzPath((esl::QuartzPath *)&v6[1]);
  ((void (*)(esl::QuartzPath *, void, float, float))v6[1].__on_zero_shared_weak)(v7, 0, *a1 + a3, a1[1]);
  ((void (*)(std::__shared_weak_count *, void, void, float, float, float, float, double))v6[1].__vftable[1].__on_zero_shared_weak)(&v6[1], 0, 0, a1[2] - a3, a1[1] + a3, a3, 4.7124, 0.0);
  ((void (*)(std::__shared_weak_count *, void, void, float, float, float, double, float))v6[1].__vftable[1].__on_zero_shared_weak)(&v6[1], 0, 0, a1[2] - a3, a1[3] - a3, a3, 0.0, 1.5708);
  ((void (*)(std::__shared_weak_count *, void, void, float, float, float, float, float))v6[1].__vftable[1].__on_zero_shared_weak)(&v6[1], 0, 0, *a1 + a3, a1[3] - a3, a3, 1.5708, 3.1416);
  ((void (*)(std::__shared_weak_count *, void, void, float, float, float, float, float))v6[1].__vftable[1].__on_zero_shared_weak)(&v6[1], 0, 0, *a1 + a3, a1[1] + a3, a3, 3.1416, 4.7124);
  ((void (*)(std::__shared_weak_count *))v6[1].__vftable[2].__on_zero_shared_weak)(&v6[1]);
  if (((uint64_t (*)(std::__shared_weak_count *))v6[1].__on_zero_shared)(&v6[1]))
  {
    *a2 = v6 + 1;
    a2[1] = v6;
  }
  else
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v8 = GEOGetGeoResourceLibEaselLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315650;
      uint64_t v10 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      __int16 v11 = 2080;
      uint64_t v12 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/PathGenerator.cpp";
      __int16 v13 = 1024;
      int v14 = 25;
      _os_log_impl(&dword_1A1780000, v8, OS_LOG_TYPE_ERROR, "Failed to create square path.: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v9, 0x1Cu);
    }
    *a2 = 0;
    a2[1] = 0;
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

uint64_t esl::QuartzPath::addArc(CGMutablePathRef *a1, BOOL a2, uint64_t a3, float a4, float a5, float a6, float a7, float a8)
{
  uint64_t v16 = (*((uint64_t (**)(CGMutablePathRef *))*a1 + 2))(a1);
  if (v16)
  {
    if (a3) {
      uint64_t v17 = (const CGAffineTransform *)(a3 + 8);
    }
    else {
      uint64_t v17 = 0;
    }
    CGPathAddArc(a1[1], v17, a4, a5, a6, a7, a8, a2);
  }
  return v16;
}

void grl::drawFillToContext(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *a1;
  if (!v5 || ((*(uint64_t (**)(uint64_t))(*(void *)v5 + 24))(v5) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v13 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&int8x8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v17 = 368;
    uint64_t v10 = "A non-nullptr context is required for drawFillToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_19:
    __int16 v11 = v13;
    uint32_t v12 = 28;
    goto LABEL_20;
  }
  if (!*a2 || ((*(uint64_t (**)(void))(*(void *)*a2 + 16))(*a2) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v13 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&int8x8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v17 = 371;
    uint64_t v10 = "A non-nullptr path is required for drawFillToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_19;
  }
  if (!*(unsigned char *)(a3 + 3))
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v13 = GEOGetGeoResourceLibRendererLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&int8x8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v17 = 374;
    uint64_t v10 = "A non-zero alpha color is required to draw for drawFillToContext().: Assertion with expression - %s : Failed i"
          "n file - %s line - %i";
    goto LABEL_19;
  }
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 24))())
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v9 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      uint64_t v10 = "Receieved empty path for drawFillToContext().";
      __int16 v11 = v9;
      uint32_t v12 = 2;
LABEL_20:
      _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_ERROR, v10, buf, v12);
    }
  }
  else
  {
    esl::QuartzColor::QuartzColor(buf, a3);
    if (esl::QuartzColor::isValid((esl::QuartzColor *)buf))
    {
      (*(void (**)(void))(*(void *)*a1 + 408))(*a1);
      (*(void (**)(void, unsigned char *))(*(void *)*a1 + 232))(*a1, buf);
      (*(void (**)(void, uint64_t))(*(void *)*a1 + 224))(*a1, a4);
      (*(void (**)(void))(*(void *)*a1 + 288))();
      (*(void (**)(void))(*(void *)*a1 + 312))();
      (*(void (**)(void))(*(void *)*a1 + 400))();
    }
    else
    {
      if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
      }
      int v14 = GEOGetGeoResourceLibEaselLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)uint64_t v15 = 0;
        _os_log_impl(&dword_1A1780000, v14, OS_LOG_TYPE_ERROR, "Failed to create the fill color for a path.", v15, 2u);
      }
    }
    *(void *)buf = &unk_1EF554AE8;
    *(void *)&uint8_t buf[8] = &unk_1EF5590F8;
    if (*(void *)&buf[16]) {
      CFRelease(*(CFTypeRef *)&buf[16]);
    }
  }
}

void grl::drawShadowToContext(void *a1, void *a2, uint64_t a3, float *a4, float a5)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  if (!v6 || ((*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v15 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v34 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    __int16 v35 = 2080;
    uint64_t v36 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
    __int16 v37 = 1024;
    int v38 = 556;
    uint32_t v12 = "A non-nullptr context is required for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_18:
    uint64_t v13 = v15;
    uint32_t v14 = 28;
    goto LABEL_19;
  }
  if (!*a2 || ((*(uint64_t (**)(void))(*(void *)*a2 + 16))(*a2) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v15 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    uint64_t v34 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    __int16 v35 = 2080;
    uint64_t v36 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
    __int16 v37 = 1024;
    int v38 = 559;
    uint32_t v12 = "A non-nullptr path is required for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_18;
  }
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 24))())
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v11 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      uint32_t v12 = "Receieved empty path for drawShadowToContext().";
      uint64_t v13 = v11;
      uint32_t v14 = 2;
LABEL_19:
      _os_log_impl(&dword_1A1780000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    }
  }
  else
  {
    unsigned int v16 = (*(uint64_t (**)(void))(*(void *)*a1 + 120))();
    Translatiouint64_t n = esl::AffineTransformMakeTranslation(0.0, -(float)v16, (uint64_t)buf);
    (*(void (**)(unsigned char *__return_ptr, CGFloat))(*(void *)*a2 + 120))(v31, Translation);
    uint64_t v19 = *(void *)v31;
    uint64_t v18 = *(std::__shared_weak_count **)&v31[8];
    uint64_t v29 = *(void *)v31;
    long long v30 = *(std::__shared_weak_count **)&v31[8];
    if (*(void *)&v31[8])
    {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(*(void *)&v31[8] + 8), 1uLL, memory_order_relaxed);
      if (*(void *)&v31[8]) {
        std::__shared_weak_count::__release_shared[abi:ne180100](*(std::__shared_weak_count **)&v31[8]);
      }
    }
    if (v19 && ((*(uint64_t (**)(uint64_t))(*(void *)v19 + 16))(v19) & 1) != 0)
    {
      esl::QuartzColor::QuartzColor(v31, a3);
      esl::QuartzColor::QuartzColor((esl::QuartzColor *)v27, 0.0, 0.0, 0.0, 1.0);
      if (esl::QuartzColor::isValid((esl::QuartzColor *)v31) && esl::QuartzColor::isValid((esl::QuartzColor *)v27))
      {
        (*(void (**)(void))(*(void *)*a1 + 408))(*a1);
        uint64_t v20 = *a1;
        float v21 = a4[1];
        float v22 = v21 + (float)(*(unsigned int (**)(void))(*(void *)*a1 + 120))(*a1);
        float v25 = *a4;
        float v26 = v22;
        if (v25 < 0.0) {
          float v25 = 0.0;
        }
        if (v22 < 0.0) {
          float v26 = 0.0;
        }
        (*(void (**)(uint64_t, float *, unsigned char *, float))(*(void *)v20 + 344))(v20, &v25, v31, a5);
        (*(void (**)(void, void *))(*(void *)*a1 + 232))(*a1, v27);
        (*(void (**)(void))(*(void *)*a1 + 296))(*a1);
        (*(void (**)(void))(*(void *)*a1 + 288))(*a1);
        (*(void (**)(void))(*(void *)*a1 + 312))(*a1);
        (*(void (**)(void))(*(void *)*a1 + 400))(*a1);
      }
      else
      {
        if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
        }
        long long v24 = GEOGetGeoResourceLibEaselLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v25) = 0;
          _os_log_impl(&dword_1A1780000, v24, OS_LOG_TYPE_ERROR, "Failed to create the shadow color for a path.", (uint8_t *)&v25, 2u);
        }
      }
      v27[0] = &unk_1EF554AE8;
      v27[1] = &unk_1EF5590F8;
      if (cf) {
        CFRelease(cf);
      }
      *(void *)uint64_t v31 = &unk_1EF554AE8;
      *(void *)&char v31[8] = &unk_1EF5590F8;
      if (*(void *)&v31[16]) {
        CFRelease(*(CFTypeRef *)&v31[16]);
      }
      uint64_t v18 = v30;
    }
    else
    {
      if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
      }
      uint64_t v23 = GEOGetGeoResourceLibEaselLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)uint64_t v31 = 136315650;
        *(void *)&v31[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
        *(_WORD *)&v31[12] = 2080;
        *(void *)&v31[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
        *(_WORD *)&v31[22] = 1024;
        int v32 = 568;
        _os_log_impl(&dword_1A1780000, v23, OS_LOG_TYPE_ERROR, "Failed to create a path for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i", v31, 0x1Cu);
      }
    }
    if (v18) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v18);
    }
  }
}

{
  uint64_t v6;
  uint64_t v11;
  float v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  float v16;
  float v17;
  void v18[2];
  CFTypeRef cf;
  unsigned char buf[24];
  int v21;
  uint64_t v22;

  float v22 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *a1;
  if (v6 && ((*(uint64_t (**)(uint64_t))(*(void *)v6 + 24))(v6) & 1) != 0)
  {
    if (*a2 && ((*(uint64_t (**)(void))(*(void *)*a2 + 40))(*a2) & 1) != 0)
    {
      esl::QuartzColor::QuartzColor(buf, a3);
      esl::QuartzColor::QuartzColor((esl::QuartzColor *)v18, 1.0, 1.0, 1.0, 1.0);
      if (esl::QuartzColor::isValid((esl::QuartzColor *)buf) && esl::QuartzColor::isValid((esl::QuartzColor *)v18))
      {
        (*(void (**)(void))(*(void *)*a1 + 408))(*a1);
        (*(void (**)(void, void *))(*(void *)*a1 + 232))(*a1, v18);
        uint64_t v11 = *a1;
        uint32_t v12 = a4[1];
        unsigned int v16 = *a4;
        int v17 = v12;
        if (v16 < 0.0) {
          unsigned int v16 = 0.0;
        }
        if (v12 < 0.0) {
          int v17 = 0.0;
        }
        (*(void (**)(uint64_t, float *, unsigned char *, float))(*(void *)v11 + 344))(v11, &v16, buf, a5);
        (*(void (**)(void))(*(void *)*a1 + 376))(*a1);
        (*(void (**)(void))(*(void *)*a1 + 400))(*a1);
      }
      else
      {
        if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
        }
        uint64_t v15 = GEOGetGeoResourceLibEaselLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
        {
          LOWORD(v16) = 0;
          _os_log_impl(&dword_1A1780000, v15, OS_LOG_TYPE_ERROR, "Failed to create the shadow color for an image.", (uint8_t *)&v16, 2u);
        }
      }
      v18[0] = &unk_1EF554AE8;
      v18[1] = &unk_1EF5590F8;
      if (cf) {
        CFRelease(cf);
      }
      *(void *)buf = &unk_1EF554AE8;
      *(void *)&uint8_t buf[8] = &unk_1EF5590F8;
      if (*(void *)&buf[16]) {
        CFRelease(*(CFTypeRef *)&buf[16]);
      }
      return;
    }
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v13 = GEOGetGeoResourceLibEaselLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
      *(_WORD *)&unsigned char buf[22] = 1024;
      float v21 = 596;
      uint32_t v14 = "A non-nullptr image is required for drawShadowToContext().: Assertion with expression - %s : Failed in file - %s line - %i";
      goto LABEL_20;
    }
  }
  else
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v13 = GEOGetGeoResourceLibEaselLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
      *(_WORD *)&unsigned char buf[22] = 1024;
      float v21 = 593;
      uint32_t v14 = "A non-nullptr context is required for drawShadowToContext().: Assertion with expression - %s : Failed in fil"
            "e - %s line - %i";
LABEL_20:
      _os_log_impl(&dword_1A1780000, v13, OS_LOG_TYPE_ERROR, v14, buf, 0x1Cu);
    }
  }
}

BOOL esl::QuartzPath::isValid(esl::QuartzPath *this)
{
  return *((void *)this + 1) != 0;
}

CGContext *esl::QuartzContext::height(esl::QuartzContext *this)
{
  uint64_t result = (CGContext *)*((void *)this + 1);
  if (result) {
    return (CGContext *)CGBitmapContextGetHeight(result);
  }
  return result;
}

uint64_t grl::ShapeLayerRenderer::renderShapeToContext(uint64_t a1, uint64_t a2, void *a3, uint64_t *a4)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  if (!*(unsigned char *)(a1 + 152))
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v11 = GEOGetGeoResourceLibRendererLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)buf = 0;
    uint32_t v12 = "Nullptr for LayerMetrics being used to render layer.";
    goto LABEL_24;
  }
  *(void *)buf = 0;
  if (!*(void *)(a1 + 204))
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v11 = GEOGetGeoResourceLibRendererLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)buf = 0;
    uint32_t v12 = "Metrics must contain a size to draw into a context.";
    goto LABEL_24;
  }
  if (!*a3 || ((*(uint64_t (**)(void))(*(void *)*a3 + 24))(*a3) & 1) == 0)
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v11 = GEOGetGeoResourceLibRendererLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_WORD *)buf = 0;
    uint32_t v12 = "A valid context is required to draw the path layer into.";
LABEL_24:
    _os_log_impl(&dword_1A1780000, v11, OS_LOG_TYPE_ERROR, v12, buf, 2u);
    return 0;
  }
  uint64_t v9 = *(unsigned char **)(a1 + 16);
  uint64_t v8 = *(unsigned char **)(a1 + 24);
  if (v9 != v8)
  {
    while (*v9 != 3)
    {
      if (++v9 == v8)
      {
        uint64_t v9 = *(unsigned char **)(a1 + 24);
        break;
      }
    }
  }
  if (v9 == v8)
  {
    BOOL v10 = 0;
  }
  else if (*(void *)(a1 + 124))
  {
    BOOL v10 = 1;
  }
  else
  {
    BOOL v10 = *(float *)(a1 + 132) != 0.0;
  }
  (*(void (**)(void, BOOL))(*(void *)*a3 + 456))(*a3, v10);
  uint64_t v102 = 0;
  long long v103 = 0;
  uint64_t v13 = 0;
  switch(*(unsigned char *)(a1 + 136))
  {
    case 0:
      v99.i32[0] = gm::Box<float,2>::operator+((float *)(a1 + 172), (float *)(a1 + 212));
      v99.i32[1] = v15;
      int v100 = v16;
      int v101 = v17;
      float v18 = 0.0;
      float v19 = 0.0;
      if (v10)
      {
        float v18 = (float)(*(unsigned int (**)(double))(*(void *)*a3 + 112))(0.0);
        float v19 = (float)(*(unsigned int (**)(void))(*(void *)*a3 + 120))();
      }
      *(float *)uint64_t v98 = v18;
      *(float *)&v98[1] = v19;
      grl::PathGenerator::createCirclePath((float *)&v99, (uint64_t)v98, buf);
      goto LABEL_43;
    case 1:
      v99.i32[0] = gm::Box<float,2>::operator+((float *)(a1 + 172), (float *)(a1 + 212));
      v99.i32[1] = v20;
      int v100 = v21;
      int v101 = v22;
      grl::PathGenerator::createSquarePath((float *)&v99, buf, *(float *)(a1 + 56));
      goto LABEL_43;
    case 2:
      goto LABEL_42;
    case 3:
      if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
      }
      uint64_t v23 = GEOGetGeoResourceLibRendererLog::log;
      if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_133;
      }
      *(_DWORD *)buf = 136315650;
      *(void *)&uint8_t buf[4] = "_data.shapeType() != ShapeType::Balloon";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/LayerRenderer.cpp";
      __int16 v105 = 1024;
      int v106 = 138;
      long long v24 = "Balloon paths have their own seperate drawing function, the code should never reach this point.: Assertion w"
            "ith expression - %s : Failed in file - %s line - %i";
      float v25 = v23;
      uint32_t v26 = 28;
      goto LABEL_132;
    case 4:
    case 6:
    case 7:
    case 8:
    case 9:
      goto LABEL_137;
    case 5:
      if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
      }
      uint64_t v27 = GEOGetGeoResourceLibRendererLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136315650;
        *(void *)&uint8_t buf[4] = "false";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/LayerRenderer.cpp";
        __int16 v105 = 1024;
        int v106 = 127;
        _os_log_impl(&dword_1A1780000, v27, OS_LOG_TYPE_ERROR, "Bottle shapetype is deprecated. Use Rectalloon instead.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
      }
LABEL_42:
      v99.i32[0] = gm::Box<float,2>::operator+((float *)(a1 + 172), (float *)(a1 + 212));
      v99.i32[1] = v28;
      int v100 = v29;
      int v101 = v30;
      grl::PathGenerator::createRectanglePath((float *)&v99, buf, *(float *)(a1 + 56));
LABEL_43:
      uint64_t v31 = *(void *)buf;
      int v32 = *(std::__shared_weak_count **)&buf[8];
      uint64_t v102 = *(void *)buf;
      long long v103 = *(std::__shared_weak_count **)&buf[8];
      if (!*(void *)buf || ((*(uint64_t (**)(void))(**(void **)buf + 16))(*(void *)buf) & 1) == 0) {
        goto LABEL_128;
      }
      if (*(void *)(a1 + 16) == *(void *)(a1 + 24))
      {
        if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
        }
        unint64_t v33 = GEOGetGeoResourceLibRendererLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "_data.hasLayerStyles()";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/LayerRenderer.cpp";
          __int16 v105 = 1024;
          int v106 = 147;
          _os_log_impl(&dword_1A1780000, v33, OS_LOG_TYPE_ERROR, "No LayerStyles given for path layer rendering.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
        }
      }
      uint64_t v34 = *(unsigned char **)(a1 + 16);
      __int16 v35 = *(unsigned char **)(a1 + 24);
      if (v34 == v35) {
        goto LABEL_134;
      }
      break;
    default:
LABEL_128:
      if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
      }
      uint64_t v68 = GEOGetGeoResourceLibRendererLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        long long v24 = "Failed to generate a path for a path layer.";
        float v25 = v68;
        uint32_t v26 = 2;
LABEL_132:
        _os_log_impl(&dword_1A1780000, v25, OS_LOG_TYPE_ERROR, v24, buf, v26);
      }
LABEL_133:
      uint64_t v13 = 0;
      goto LABEL_137;
  }
  do
  {
    switch(*v34)
    {
      case 0:
        if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
        }
        uint64_t v36 = GEOGetGeoResourceLibRendererLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136315650;
          *(void *)&uint8_t buf[4] = "iconLayer != LayerStyle::None";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/LayerRenderer.cpp";
          __int16 v105 = 1024;
          int v106 = 151;
          _os_log_impl(&dword_1A1780000, v36, OS_LOG_TYPE_ERROR, "Invalid LayerStyle enum being used for path layer rendering.: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
        }
        goto LABEL_124;
      case 1:
        unsigned int v37 = *(unsigned __int8 *)(a1 + 76);
        if (v37 >= 2)
        {
          if (v37 == 2)
          {
            switch(*(unsigned char *)(a1 + 100))
            {
              case 0:
                unint64_t v44 = (std::__shared_weak_count *)a3[1];
                uint64_t v92 = *a3;
                uint64_t v93 = v44;
                if (v44) {
                  atomic_fetch_add_explicit(&v44->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v90 = v31;
                uint64_t v91 = v32;
                if (v32) {
                  atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                *(_DWORD *)buf = *(_DWORD *)(a1 + 60);
                grl::drawFillToContext(&v92, &v90, (uint64_t)buf, 0);
                if (v91) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v91);
                }
                uint64_t v39 = v93;
                if (v93) {
                  goto LABEL_88;
                }
                break;
              case 1:
                float v45 = (std::__shared_weak_count *)a3[1];
                uint64_t v88 = *a3;
                uint64_t v89 = v45;
                if (v45) {
                  atomic_fetch_add_explicit(&v45->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v86 = v31;
                uint64_t v87 = v32;
                if (v32) {
                  atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                v98[0] = *(_DWORD *)(a1 + 92);
                float v46 = *(float *)(a1 + 96);
                float32x2_t v47 = *(float32x2_t *)(a1 + 212);
                *(float32x2_t *)buf = vadd_f32(*(float32x2_t *)(a1 + 236), v47);
                int v85 = *(_DWORD *)(a1 + 84);
                float v48 = *(float *)(a1 + 88);
                float32x2_t v99 = vadd_f32(v47, *(float32x2_t *)(a1 + 244));
                grl::drawLinearGradientToContext(&v88, &v86, (uint64_t)v98, v46, v48, (uint64_t)buf, (uint64_t)&v85, (uint64_t)&v99, *(unsigned __int8 *)(a1 + 48));
                if (v87) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v87);
                }
                uint64_t v39 = v89;
                if (v89) {
                  goto LABEL_88;
                }
                break;
              case 2:
                float v49 = gm::Box<float,2>::operator+((float *)(a1 + 172), (float *)(a1 + 212));
                float v52 = v49 + (float)((float)(v50 - v49) * 0.5);
                float v54 = v53 + (float)((float)(v51 - v53) * 0.5);
                *(float *)buf = v52;
                *(float *)&uint8_t buf[4] = v54;
                float v55 = *(float *)(a1 + 244);
                float v56 = *(float *)(a1 + 248);
                float v58 = *(float *)(a1 + 212);
                float v57 = *(float *)(a1 + 216);
                unint64_t v59 = (std::__shared_weak_count *)a3[1];
                uint64_t v83 = *a3;
                uint64_t v84 = v59;
                if (v59) {
                  atomic_fetch_add_explicit(&v59->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v81 = v31;
                char v82 = v32;
                if (v32) {
                  atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                float v60 = sqrtf((float)((float)((float)((float)(v55 + v58) - v52) * (float)((float)(v55 + v58) - v52)) + 0.0)+ (float)((float)((float)(v56 + v57) - v54) * (float)((float)(v56 + v57) - v54)));
                v99.i32[0] = *(_DWORD *)(a1 + 92);
                float v61 = v60 * *(float *)(a1 + 96);
                v98[0] = *(_DWORD *)(a1 + 84);
                grl::drawRadialGradientToContext(&v83, &v81, (uint64_t)&v99, v61, v60 * *(float *)(a1 + 88), (uint64_t)buf, (uint64_t)v98, *(unsigned __int8 *)(a1 + 48));
                if (v82) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v82);
                }
                uint64_t v39 = v84;
                if (v84) {
                  goto LABEL_88;
                }
                break;
              case 3:
                uint64_t v62 = (std::__shared_weak_count *)a3[1];
                uint64_t v79 = *a3;
                uint64_t v80 = v62;
                if (v62) {
                  atomic_fetch_add_explicit(&v62->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                uint64_t v77 = v31;
                uint64_t v78 = v32;
                if (v32) {
                  atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                v98[0] = *(_DWORD *)(a1 + 92);
                float v63 = *(float *)(a1 + 96);
                float32x2_t v64 = *(float32x2_t *)(a1 + 212);
                *(float32x2_t *)buf = vadd_f32(*(float32x2_t *)(a1 + 236), v64);
                int v85 = *(_DWORD *)(a1 + 84);
                float v65 = *(float *)(a1 + 88);
                float32x2_t v99 = vadd_f32(v64, *(float32x2_t *)(a1 + 244));
                grl::drawReflectedGradientToContext(&v79, &v77, (uint64_t)v98, v63, v65, (uint64_t)buf, (uint64_t)&v85, (uint64_t)&v99, *(unsigned __int8 *)(a1 + 48));
                if (v78) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v78);
                }
                uint64_t v39 = v80;
                if (v80) {
                  goto LABEL_88;
                }
                break;
              default:
                goto LABEL_124;
            }
          }
        }
        else
        {
          int v38 = (std::__shared_weak_count *)a3[1];
          uint64_t v96 = *a3;
          unint64_t v97 = v38;
          if (v38) {
            atomic_fetch_add_explicit(&v38->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          uint64_t v94 = v31;
          uint64_t v95 = v32;
          if (v32) {
            atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
          }
          *(_DWORD *)buf = *(_DWORD *)(a1 + 60);
          grl::drawFillToContext(&v96, &v94, (uint64_t)buf, 0);
          if (v95) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v95);
          }
          uint64_t v39 = v97;
          if (v97) {
            goto LABEL_88;
          }
        }
        goto LABEL_124;
      case 2:
        if (!*(unsigned char *)(a1 + 104) || *(float *)(a1 + 108) <= 0.0) {
          goto LABEL_126;
        }
        char v40 = (std::__shared_weak_count *)a3[1];
        uint64_t v75 = *a3;
        long long v76 = v40;
        if (v40) {
          atomic_fetch_add_explicit(&v40->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        uint64_t v73 = v31;
        uint64_t v74 = v32;
        if (v32) {
          atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        *(_DWORD *)buf = *(_DWORD *)(a1 + 101);
        grl::drawStrokeToContext(&v75, &v73, (uint64_t)buf, *(float *)(a1 + 108));
        if (v74) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v74);
        }
        uint64_t v39 = v76;
        if (!v76) {
          goto LABEL_124;
        }
        goto LABEL_88;
      case 3:
        uint64_t v42 = *(unsigned char **)(a1 + 16);
        uint64_t v41 = *(unsigned char **)(a1 + 24);
        if (v42 == v41) {
          goto LABEL_79;
        }
        break;
      default:
        goto LABEL_124;
    }
    while (*v42 != 3)
    {
      if (++v42 == v41)
      {
        uint64_t v42 = *(unsigned char **)(a1 + 24);
        break;
      }
    }
LABEL_79:
    if (v42 != v41 && (*(void *)(a1 + 124) || *(float *)(a1 + 132) != 0.0))
    {
      uint64_t v43 = (std::__shared_weak_count *)a3[1];
      uint64_t v71 = *a3;
      uint64_t v72 = v43;
      if (v43) {
        atomic_fetch_add_explicit(&v43->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      uint64_t v69 = v31;
      unint64_t v70 = v32;
      if (v32) {
        atomic_fetch_add_explicit(&v32->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      v99.i32[0] = *(_DWORD *)(a1 + 120);
      *(void *)buf = *(void *)(a1 + 124);
      grl::drawShadowToContext(&v71, &v69, (uint64_t)&v99, (float *)buf, *(float *)(a1 + 132));
      if (v70) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v70);
      }
      uint64_t v39 = v72;
      if (v72) {
LABEL_88:
      }
        std::__shared_weak_count::__release_shared[abi:ne180100](v39);
LABEL_124:
      if (*(unsigned char *)(a2 + 280))
      {
        (*(void (**)(unsigned char *__return_ptr))(*(void *)*a3 + 392))(buf);
        long long v66 = operator new(0x20uLL);
        v66[1] = *(_OWORD *)buf;
        uint64_t v67 = *a4;
        *(void *)long long v66 = *a4;
        *((void *)v66 + 1) = a4;
        *(void *)(v67 + 8) = v66;
        *a4 = (uint64_t)v66;
        ++a4[2];
      }
    }
LABEL_126:
    ++v34;
  }
  while (v34 != v35);
LABEL_134:
  if (*(unsigned char *)(a1 + 112))
  {
    (*(void (**)(void, uint64_t *))(*(void *)*a3 + 288))(*a3, &v102);
    (*(void (**)(void))(*(void *)*a3 + 264))();
  }
  uint64_t v13 = 1;
LABEL_137:
  if (v103) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v103);
  }
  return v13;
}

void esl::QuartzContext::fillPath(esl::QuartzContext *this)
{
  if ((*(unsigned int (**)(esl::QuartzContext *))(*(void *)this + 24))(this))
  {
    uint64_t v2 = (CGContext *)*((void *)this + 1);
    CGContextFillPath(v2);
  }
}

void grl::PathGenerator::createCirclePath(float *a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (std::__shared_weak_count *)operator new(0x28uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF582B70;
  uint64_t v7 = esl::QuartzPath::QuartzPath((esl::QuartzPath *)&v6[1]);
  ((void (*)(esl::QuartzPath *, void, uint64_t, float, float, float, float))v6[1].__vftable[1].__get_deleter)(v7, 0, a2, *a1, a1[1], a1[2], a1[3]);
  ((void (*)(std::__shared_weak_count *))v6[1].__vftable[2].__on_zero_shared_weak)(&v6[1]);
  if (((uint64_t (*)(std::__shared_weak_count *))v6[1].__on_zero_shared)(&v6[1]))
  {
    *a3 = v6 + 1;
    a3[1] = v6;
  }
  else
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v8 = GEOGetGeoResourceLibEaselLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR))
    {
      int v9 = 136315650;
      BOOL v10 = "!GRL_UNIQUE_NAME(didTriggerAssert)";
      __int16 v11 = 2080;
      uint32_t v12 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/PathGenerator.cpp";
      __int16 v13 = 1024;
      int v14 = 56;
      _os_log_impl(&dword_1A1780000, v8, OS_LOG_TYPE_ERROR, "Failed to create circular path.: Assertion with expression - %s : Failed in file - %s line - %i", (uint8_t *)&v9, 0x1Cu);
    }
    *a3 = 0;
    a3[1] = 0;
    std::__shared_weak_count::__release_shared[abi:ne180100](v6);
  }
}

esl::QuartzPath *esl::QuartzPath::QuartzPath(esl::QuartzPath *this)
{
  *(void *)this = &unk_1EF554A58;
  *((void *)this + 1) = 0;
  *((void *)this + 1) = CGPathCreateMutable();
  return this;
}

uint64_t esl::QuartzPath::addEllipseInRect(CGMutablePathRef *a1, uint64_t a2, float a3, float a4, float a5, float a6)
{
  uint64_t v12 = (*((uint64_t (**)(CGMutablePathRef *))*a1 + 2))(a1);
  if (v12)
  {
    if (a2) {
      __int16 v13 = (const CGAffineTransform *)(a2 + 8);
    }
    else {
      __int16 v13 = 0;
    }
    if ((float)(a5 - a3) >= 0.0) {
      float v14 = a5 - a3;
    }
    else {
      float v14 = 0.0;
    }
    if ((float)(a6 - a4) >= 0.0) {
      float v15 = a6 - a4;
    }
    else {
      float v15 = 0.0;
    }
    v17.origin.x = a3;
    v17.origin.y = a4;
    v17.size.width = v14;
    v17.size.height = v15;
    CGPathAddEllipseInRect(a1[1], v13, v17);
  }
  return v12;
}

uint64_t esl::QuartzPath::closeSubpath(CGMutablePathRef *this)
{
  return 1;
}

CGContext *esl::QuartzContext::width(esl::QuartzContext *this)
{
  uint64_t result = (CGContext *)*((void *)this + 1);
  if (result) {
    return (CGContext *)CGBitmapContextGetWidth(result);
  }
  return result;
}

void grl::drawLinearGradientToContext(void *a1, void *a2, uint64_t a3, float a4, float a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v37[5] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a1;
  if (!v10 || ((*(uint64_t (**)(uint64_t))(*(void *)v10 + 24))(v10) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v21 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v36 = 469;
    float v18 = "A non-nullptr context is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i";
LABEL_18:
    float v19 = v21;
    uint32_t v20 = 28;
    goto LABEL_19;
  }
  if (!*a2 || ((*(uint64_t (**)(void))(*(void *)*a2 + 16))(*a2) & 1) == 0)
  {
    if (GEOGetGeoResourceLibEaselLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibEaselLog::onceToken, &__block_literal_global_29);
    }
    uint64_t v21 = GEOGetGeoResourceLibEaselLog::log;
    if (!os_log_type_enabled((os_log_t)GEOGetGeoResourceLibEaselLog::log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136315650;
    *(void *)&uint8_t buf[4] = "!GRL_UNIQUE_NAME(didTriggerAssert)";
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/EaselUtilities.cpp";
    *(_WORD *)&unsigned char buf[22] = 1024;
    int v36 = 472;
    float v18 = "A non-nullptr path is required to draw a linear gradient.: Assertion with expression - %s : Failed in file - %s line - %i";
    goto LABEL_18;
  }
  if ((*(unsigned int (**)(void))(*(void *)*a2 + 24))())
  {
    if (GEOGetGeoResourceLibRendererLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibRendererLog::onceToken, &__block_literal_global_13_0);
    }
    uint64_t v17 = GEOGetGeoResourceLibRendererLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibRendererLog::log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      float v18 = "Receieved empty path for drawLinearGradientToContext().";
      float v19 = v17;
      uint32_t v20 = 2;
LABEL_19:
      _os_log_impl(&dword_1A1780000, v19, OS_LOG_TYPE_ERROR, v18, buf, v20);
    }
  }
  else
  {
    esl::QuartzColor::QuartzColor(buf, a3);
    esl::QuartzColor::QuartzColor(v37, a7);
    int v22 = (char *)operator new(0x40uLL);
    uint64_t v23 = 0;
    char v24 = 0;
    uint64_t v25 = 0;
    v34[0] = v22;
    v34[2] = v22 + 64;
    do
    {
      char v26 = v24;
      uint64_t v27 = &v22[v23];
      *(void *)uint64_t v27 = &unk_1EF554AE8;
      *((void *)v27 + 1) = &unk_1EF5590F8;
      __int32 v28 = &buf[32 * v25];
      uint64_t v29 = *((void *)v28 + 2);
      if (v29) {
        CFRetain(*((CFTypeRef *)v28 + 2));
      }
      *((void *)v27 + 2) = v29;
      v23 += 32;
      char v24 = 1;
      uint64_t v25 = 1;
    }
    while ((v26 & 1) == 0);
    uint64_t v30 = 0;
    v34[1] = &v22[v23];
    do
    {
      uint64_t v31 = &buf[v30 * 8];
      *((void *)v31 + 4) = &unk_1EF554AE8;
      *((void *)v31 + 5) = &unk_1EF5590F8;
      int v32 = (const void *)v37[v30 + 2];
      if (v32) {
        CFRelease(v32);
      }
      v30 -= 4;
    }
    while (v30 != -8);
    unint64_t v33 = (float *)operator new(8uLL);
    *(void *)&uint8_t buf[8] = v33 + 2;
    *(void *)&buf[16] = v33 + 2;
    *unint64_t v33 = a4;
    v33[1] = a5;
    *(void *)buf = v33;
    (*(void (**)(void))(*(void *)*a1 + 408))();
    (*(void (**)(void))(*(void *)*a1 + 288))();
    (*(void (**)(void))(*(void *)*a1 + 264))();
    (*(void (**)(void, uint64_t))(*(void *)*a1 + 224))(*a1, a9);
    (*(void (**)(void))(*(void *)*a1 + 360))();
    (*(void (**)(void))(*(void *)*a1 + 400))();
    if (*(void *)buf)
    {
      *(void *)&uint8_t buf[8] = *(void *)buf;
      operator delete(*(void **)buf);
    }
    *(void *)buf = v34;
    std::vector<esl::QuartzColor>::__destroy_vector::operator()[abi:ne180100]((void ***)buf);
  }
}

esl::QuartzColor *esl::QuartzColor::QuartzColor(esl::QuartzColor *this, float a2, float a3, float a4, float a5)
{
  *(void *)this = &unk_1EF554AE8;
  *((void *)this + 1) = &unk_1EF5590F8;
  *((void *)this + 2) = 0;
  uint64_t v5 = "(r >= 0.0f && g >= 0.0f && b >= 0.0f && a >= 0.0f) && \"Colors must be between 0 and 1.\"";
  int v6 = 150;
  if (a2 < 0.0 || a3 < 0.0 || a4 < 0.0 || a5 < 0.0) {
LABEL_17:
  }
    __assert_rtn("QuartzColor", "color.cpp", v6, v5);
  if (a2 > 1.0 || a3 > 1.0 || a4 > 1.0 || a5 > 1.0)
  {
    uint64_t v5 = "(r <= 1.0f && g <= 1.0f && b <= 1.0f && a <= 1.0f) && \"Colors must be between 0 and 1.\"";
    int v6 = 151;
    goto LABEL_17;
  }
  v12[0] = a2;
  v12[1] = a3;
  v12[2] = a4;
  void v12[3] = a5;
  esl::QuartzColor::createColor((uint64_t)this, 2, v12);
  return this;
}

void sub_1A1AB99A4(_Unwind_Exception *a1)
{
  geo::_retain_ptr<CGColor *,geo::_retain_cf<CGColor *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(v1);
  _Unwind_Resume(a1);
}

void *esl::QuartzColor::QuartzColor(void *a1, unsigned __int8 *a2)
{
  *a1 = &unk_1EF554AE8;
  a1[1] = &unk_1EF5590F8;
  a1[2] = 0;
  v3.i32[0] = *a2;
  v3.i32[1] = a2[1];
  float32x2_t v4 = (float32x2_t)vdup_n_s32(0x437F0000u);
  v5.i32[0] = a2[2];
  v5.i32[1] = a2[3];
  v7[0] = vcvtq_f64_f32(vdiv_f32(vcvt_f32_u32(v3), v4));
  v7[1] = vcvtq_f64_f32(vdiv_f32(vcvt_f32_u32(v5), v4));
  esl::QuartzColor::createColor((uint64_t)a1, 2, (const CGFloat *)v7);
  return a1;
}

void sub_1A1AB9A74(_Unwind_Exception *a1)
{
  geo::_retain_ptr<CGColor *,geo::_retain_cf<CGColor *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(v1);
  _Unwind_Resume(a1);
}

void *esl::QuartzColor::createColor(uint64_t a1, int a2, const CGFloat *a3)
{
  int v9 = &unk_1EF559018;
  CFTypeRef cf = 0;
  switch(a2)
  {
    case 0:
      CGColorSpaceRef v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC88]);
      goto LABEL_7;
    case 1:
      CGColorSpaceRef v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC10]);
      goto LABEL_7;
    case 2:
      CGColorSpaceRef v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DC98]);
      goto LABEL_7;
    case 3:
      CGColorSpaceRef v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB90]);
      goto LABEL_7;
    case 4:
      CGColorSpaceRef v5 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E4F1DB88]);
LABEL_7:
      CFTypeRef cf = v5;
      if (v5)
      {
        CGColorRef v6 = CGColorCreate(v5, a3);
        uint64_t v7 = *(const void **)(a1 + 16);
        *(void *)(a1 + 16) = v6;
        if (v7) {
          CFRelease(v7);
        }
      }
      break;
    default:
      return geo::_retain_ptr<CGColorSpace *,geo::_retain_cf<CGColorSpace *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(&v9);
  }
  return geo::_retain_ptr<CGColorSpace *,geo::_retain_cf<CGColorSpace *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(&v9);
}

void sub_1A1AB9BA0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  geo::_retain_ptr<CGColorSpace *,geo::_retain_cf<CGColorSpace *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *geo::_retain_ptr<CGColorSpace *,geo::_retain_cf<CGColorSpace *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(void *a1)
{
  *a1 = &unk_1EF559018;
  uint64_t v2 = (const void *)a1[1];
  if (v2) {
    CFRelease(v2);
  }
  return a1;
}

void std::vector<esl::QuartzColor>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  uint64_t v1 = *a1;
  uint64_t v2 = (char *)**a1;
  if (v2)
  {
    float32x2_t v4 = (char *)v1[1];
    CGColorSpaceRef v5 = **a1;
    if (v4 != v2)
    {
      CGColorRef v6 = v4 - 32;
      uint64_t v7 = v4 - 32;
      uint64_t v8 = v4 - 32;
      do
      {
        int v9 = *(void (***)(char *))v8;
        v8 -= 32;
        (*v9)(v7);
        v6 -= 32;
        BOOL v10 = v7 == v2;
        uint64_t v7 = v8;
      }
      while (!v10);
      CGColorSpaceRef v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void esl::QuartzColor::~QuartzColor(esl::QuartzColor *this)
{
  *(void *)this = &unk_1EF554AE8;
  geo::_retain_ptr<CGColor *,geo::_retain_cf<CGColor *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr((void *)this + 1);
}

{
  uint64_t vars8;

  *(void *)this = &unk_1EF554AE8;
  geo::_retain_ptr<CGColor *,geo::_retain_cf<CGColor *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr((void *)this + 1);
  JUMPOUT(0x1A6239270);
}

CGFloat esl::AffineTransformMakeTranslation@<D0>(float a1@<S0>, float a2@<S1>, uint64_t a3@<X8>)
{
  CGColorSpaceRef v5 = (long long *)MEMORY[0x1E4F1DAB8];
  *(void *)a3 = &unk_1EF554DC8;
  long long v6 = *v5;
  long long v7 = v5[1];
  *(_OWORD *)(a3 + 8) = *v5;
  *(_OWORD *)(a3 + 24) = v7;
  long long v8 = v5[2];
  *(_OWORD *)(a3 + 40) = v8;
  *(_OWORD *)&v11.a = v6;
  *(_OWORD *)&v11.c = v7;
  *(_OWORD *)&v11.tx = v8;
  CGAffineTransformTranslate(&v12, &v11, a1, a2);
  long long v9 = *(_OWORD *)&v12.c;
  *(_OWORD *)(a3 + 8) = *(_OWORD *)&v12.a;
  *(_OWORD *)(a3 + 24) = v9;
  CGFloat result = v12.tx;
  *(_OWORD *)(a3 + 40) = *(_OWORD *)&v12.tx;
  return result;
}

void esl::QuartzContext::beginPath(esl::QuartzContext *this)
{
  if ((*(unsigned int (**)(esl::QuartzContext *))(*(void *)this + 24))(this))
  {
    uint64_t v2 = (CGContext *)*((void *)this + 1);
    CGContextBeginPath(v2);
  }
}

void esl::QuartzContext::clip(esl::QuartzContext *this)
{
  if ((*(unsigned int (**)(esl::QuartzContext *))(*(void *)this + 24))(this))
  {
    uint64_t v2 = (CGContext *)*((void *)this + 1);
    CGContextClip(v2);
  }
}

uint64_t esl::QuartzContext::setShadowWithColor(void *a1, float *a2, const void *a3, float a4)
{
  uint64_t result = (*(uint64_t (**)(const void *))(*(void *)a3 + 48))(a3);
  if (result)
  {
    uint64_t result = (*(uint64_t (**)(void *))(*a1 + 24))(a1);
    if (result)
    {
      if (a4 < 0.0) {
        esl::QuartzContext::setShadowWithColor();
      }
      long long v9 = (CGContext *)a1[1];
      CGFloat v10 = *a2;
      CGFloat v11 = a2[1];
      esl::QuartzColor::color(a3, v12);
      v13.width = v10;
      v13.height = v11;
      CGContextSetShadowWithColor(v9, v13, a4, v12[1]);
      geo::_retain_ptr<CGColor *,geo::_retain_cf<CGColor *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr(v12);
      return 1;
    }
  }
  return result;
}

void sub_1A1AB9F5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  geo::_retain_ptr<CGColor *,geo::_retain_cf<CGColor *>,geo::_release_cf,geo::_hash_cf,geo::_equal_cf>::~_retain_ptr((uint64_t *)va);
  _Unwind_Resume(a1);
}

void *esl::QuartzPath::createMutableCopyByTransforming@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, void *a3@<X8>)
{
  CGMutablePathRef MutableCopyByTransformingPath = CGPathCreateMutableCopyByTransformingPath(*(CGPathRef *)(a1 + 8), (const CGAffineTransform *)(a2 + 8));
  uint64_t result = operator new(0x28uLL);
  result[1] = 0;
  result[2] = 0;
  void *result = &unk_1EF582B70;
  result[3] = &unk_1EF554A58;
  result[4] = MutableCopyByTransformingPath;
  *a3 = result + 3;
  a3[1] = result;
  return result;
}

uint64_t md::StandardRouteOverlayCache::addOverlay(uint64_t a1, void *a2, int a3)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  if (!v5) {
    return 0;
  }
  long long v6 = v5;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    if (!std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)(a1 + 96), (unint64_t)v6))
    {
      uint64_t v21 = v6;
      int v22 = operator new(0x378uLL);
      v22[1] = 0;
      v22[2] = 0;
      *int v22 = &unk_1EF580330;
      md::RouteLineOverlay::RouteLineOverlay((md::RouteLineOverlay *)(v22 + 3), v21, a3, v23);
    }
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    unint64_t v7 = (unint64_t)(id)GEOGetVectorKitRouteLog_log;
    if (os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl(&dword_1A1780000, (os_log_t)v7, OS_LOG_TYPE_INFO, "Failed to add overlay  %@. It is already being tracked", buf, 0xCu);
      uint64_t v10 = 0;
      goto LABEL_138;
    }
    goto LABEL_15;
  }
  unint64_t v7 = v6;
  long long v8 = (void *)(a1 + 136);
  if (std::__hash_table<std::__hash_value_type<altitude::Tile *,unsigned int>,std::__unordered_map_hasher<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::hash<altitude::Tile *>,std::equal_to<altitude::Tile *>,true>,std::__unordered_map_equal<altitude::Tile *,std::__hash_value_type<altitude::Tile *,unsigned int>,std::equal_to<altitude::Tile *>,std::hash<altitude::Tile *>,true>,std::allocator<std::__hash_value_type<altitude::Tile *,unsigned int>>>::find<altitude::Tile *>((void *)(a1 + 136), v7))
  {
    if (GEOGetVectorKitRouteLog_onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
    }
    long long v9 = (id)GEOGetVectorKitRouteLog_log;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl(&dword_1A1780000, v9, OS_LOG_TYPE_INFO, "Failed to add overlay %@. It is already being tracked", buf, 0xCu);
    }

LABEL_15:
    uint64_t v10 = 0;
    goto LABEL_138;
  }
  CGFloat v11 = (std::__shared_weak_count *)operator new(0xA8uLL);
  v11->__shared_owners_ = 0;
  v11->__shared_weak_owners_ = 0;
  v11->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF581360;
  v11[1].__shared_owners_ = 0;
  v11[1].__vftable = (std::__shared_weak_count_vtbl *)&v11[1].__shared_owners_;
  v11[1].__shared_weak_owners_ = 0;
  v11[2].std::__shared_count = 0u;
  *(_OWORD *)&v11[2].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v11[3].__shared_owners_ = 0u;
  v11[4].__vftable = 0;
  LODWORD(v11[4].__shared_owners_) = 1065353216;
  v11[4].__shared_weak_owners_ = 0;
  objc_initWeak((id *)&v11[5].__vftable, (id)v7);
  *(_OWORD *)&v11[5].__shared_owners_ = 0u;
  v11[6].std::__shared_count = 0u;
  LOBYTE(v11[6].__shared_weak_owners_) = a3;
  char v82 = v11 + 1;
  uint64_t v83 = v11;
  long long v78 = 0u;
  long long v79 = 0u;
  long long v80 = 0u;
  long long v81 = 0u;
  uint64_t v12 = [(id)v7 polylines];
  int v76 = a3;
  uint64_t v13 = [(id)v12 countByEnumeratingWithState:&v78 objects:v89 count:16];
  if (v13)
  {
    uint64_t v14 = *(void *)v79;
    do
    {
      for (uint64_t i = 0; i != v13; ++i)
      {
        if (*(void *)v79 != v14) {
          objc_enumerationMutation((id)v12);
        }
        md::RouteLineOverlayGroup::addPolyline((md::RouteLineOverlayGroup *)&v11[1], *(VKPolylineOverlay **)(*((void *)&v78 + 1) + 8 * i));
      }
      uint64_t v13 = [(id)v12 countByEnumeratingWithState:&v78 objects:v89 count:16];
    }
    while (v13);
  }

  *(void *)&long long v77 = v7;
  atomic_fetch_add_explicit(&v11->__shared_owners_, 1uLL, memory_order_relaxed);
  unint64_t v16 = 0x9DDFEA08EB382D69 * (((8 * v7) + 8) ^ HIDWORD(v7));
  unint64_t v17 = 0x9DDFEA08EB382D69 * (HIDWORD(v7) ^ (v16 >> 47) ^ v16);
  unint64_t v18 = 0x9DDFEA08EB382D69 * (v17 ^ (v17 >> 47));
  unint64_t v19 = *(void *)(a1 + 144);
  if (!v19) {
    goto LABEL_45;
  }
  uint8x8_t v20 = (uint8x8_t)vcnt_s8((int8x8_t)v19);
  v20.i16[0] = vaddlv_u8(v20);
  if (v20.u32[0] > 1uLL)
  {
    uint64_t v12 = 0x9DDFEA08EB382D69 * (v17 ^ (v17 >> 47));
    if (v18 >= v19) {
      uint64_t v12 = v18 % v19;
    }
  }
  else
  {
    uint64_t v12 = v18 & (v19 - 1);
  }
  char v24 = *(void **)(*v8 + 8 * v12);
  if (!v24 || (uint64_t v25 = (void *)*v24) == 0)
  {
LABEL_45:
    __int32 v28 = operator new(0x28uLL);
    uint64_t v29 = (void *)(a1 + 152);
    *(void *)buf = v28;
    *(void *)&uint8_t buf[8] = a1 + 152;
    *__int32 v28 = 0;
    v28[1] = v18;
    *((void *)&v77 + 1) = v11 + 1;
    *((_OWORD *)v28 + 1) = v77;
    v28[4] = v11;
    buf[16] = 1;
    float v30 = (float)(unint64_t)(*(void *)(a1 + 160) + 1);
    float v31 = *(float *)(a1 + 168);
    if (v19 && (float)(v31 * (float)v19) >= v30)
    {
LABEL_95:
      float v52 = (void *)*v8;
      float v53 = *(void **)(*v8 + 8 * v12);
      if (v53)
      {
        *__int32 v28 = *v53;
      }
      else
      {
        *__int32 v28 = *v29;
        *uint64_t v29 = v28;
        v52[v12] = v29;
        if (!*v28)
        {
LABEL_104:
          ++*(void *)(a1 + 160);
          goto LABEL_105;
        }
        unint64_t v54 = *(void *)(*v28 + 8);
        if ((v19 & (v19 - 1)) != 0)
        {
          if (v54 >= v19) {
            v54 %= v19;
          }
        }
        else
        {
          v54 &= v19 - 1;
        }
        float v53 = (void *)(*v8 + 8 * v54);
      }
      *float v53 = v28;
      goto LABEL_104;
    }
    BOOL v32 = 1;
    if (v19 >= 3) {
      BOOL v32 = (v19 & (v19 - 1)) != 0;
    }
    unint64_t v33 = v32 | (2 * v19);
    unint64_t v34 = vcvtps_u32_f32(v30 / v31);
    if (v33 <= v34) {
      size_t prime = v34;
    }
    else {
      size_t prime = v33;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v19 = *(void *)(a1 + 144);
    }
    if (prime <= v19)
    {
      if (prime >= v19) {
        goto LABEL_82;
      }
      unint64_t v46 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 160) / *(float *)(a1 + 168));
      if (v19 < 3 || (uint8x8_t v47 = (uint8x8_t)vcnt_s8((int8x8_t)v19), v47.i16[0] = vaddlv_u8(v47), v47.u32[0] > 1uLL))
      {
        unint64_t v46 = std::__next_prime(v46);
      }
      else
      {
        uint64_t v48 = 1 << -(char)__clz(v46 - 1);
        if (v46 >= 2) {
          unint64_t v46 = v48;
        }
      }
      if (prime <= v46) {
        size_t prime = v46;
      }
      if (prime >= v19)
      {
        unint64_t v19 = *(void *)(a1 + 144);
LABEL_82:
        if ((v19 & (v19 - 1)) != 0)
        {
          if (v18 >= v19) {
            uint64_t v12 = v18 % v19;
          }
          else {
            uint64_t v12 = v18;
          }
        }
        else
        {
          uint64_t v12 = (v19 - 1) & v18;
        }
        goto LABEL_95;
      }
      if (!prime)
      {
        uint64_t v75 = (void *)*v8;
        *long long v8 = 0;
        if (v75) {
          operator delete(v75);
        }
        unint64_t v19 = 0;
        *(void *)(a1 + 144) = 0;
        goto LABEL_82;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int v36 = operator new(8 * prime);
    unsigned int v37 = (void *)*v8;
    *long long v8 = v36;
    if (v37) {
      operator delete(v37);
    }
    uint64_t v38 = 0;
    *(void *)(a1 + 144) = prime;
    do
      *(void *)(*v8 + 8 * v38++) = 0;
    while (prime != v38);
    uint64_t v39 = (void *)*v29;
    if (!*v29)
    {
LABEL_81:
      unint64_t v19 = prime;
      goto LABEL_82;
    }
    size_t v40 = v39[1];
    size_t v41 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v42 = v40 & v41;
      *(void *)(*v8 + 8 * v42) = v29;
      for (uint64_t j = (void *)*v39; *v39; uint64_t j = (void *)*v39)
      {
        size_t v44 = j[1] & v41;
        if (v44 == v42)
        {
          uint64_t v39 = j;
        }
        else if (*(void *)(*v8 + 8 * v44))
        {
          *uint64_t v39 = *j;
          uint64_t v45 = 8 * v44;
          void *j = **(void **)(*v8 + v45);
          **(void **)(*v8 + v45) = j;
        }
        else
        {
          *(void *)(*v8 + 8 * v44) = v39;
          uint64_t v39 = j;
          size_t v42 = v44;
        }
      }
      goto LABEL_81;
    }
    if (v40 >= prime) {
      v40 %= prime;
    }
    *(void *)(*v8 + 8 * v40) = v29;
    float v49 = (void *)*v39;
    if (!*v39) {
      goto LABEL_81;
    }
    while (1)
    {
      size_t v51 = v49[1];
      if (v51 >= prime) {
        v51 %= prime;
      }
      if (v51 != v40)
      {
        if (!*(void *)(*v8 + 8 * v51))
        {
          *(void *)(*v8 + 8 * v51) = v39;
          goto LABEL_86;
        }
        *uint64_t v39 = *v49;
        uint64_t v50 = 8 * v51;
        *float v49 = **(void **)(*v8 + v50);
        **(void **)(*v8 + v50) = v49;
        float v49 = v39;
      }
      size_t v51 = v40;
LABEL_86:
      uint64_t v39 = v49;
      float v49 = (void *)*v49;
      size_t v40 = v51;
      if (!v49) {
        goto LABEL_81;
      }
    }
  }
  if (v20.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v27 = v25[1];
      if (v27 == v18)
      {
        if (v25[2] == v7) {
          goto LABEL_140;
        }
      }
      else if ((v27 & (v19 - 1)) != v12)
      {
        goto LABEL_45;
      }
      uint64_t v25 = (void *)*v25;
      if (!v25) {
        goto LABEL_45;
      }
    }
  }
  while (1)
  {
    unint64_t v26 = v25[1];
    if (v26 == v18) {
      break;
    }
    if (v26 >= v19) {
      v26 %= v19;
    }
    if (v26 != v12) {
      goto LABEL_45;
    }
LABEL_35:
    uint64_t v25 = (void *)*v25;
    if (!v25) {
      goto LABEL_45;
    }
  }
  if (v25[2] != v7) {
    goto LABEL_35;
  }
LABEL_140:
  if (!atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
    std::__shared_weak_count::__release_weak(v11);
  }
LABEL_105:
  [*(id *)(a1 + 8) startObserving:v7];
  float v55 = v83;
  if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v55->__on_zero_shared)(v55);
    std::__shared_weak_count::__release_weak(v55);
  }

  if (v76)
  {
    float v57 = (uint64_t **)(a1 + 80);
    float v56 = *(uint64_t **)(a1 + 80);
    if (v56)
    {
      while (1)
      {
        while (1)
        {
          float v58 = (uint64_t **)v56;
          unint64_t v59 = v56[4];
          if (v59 <= (unint64_t)v6) {
            break;
          }
          float v56 = *v58;
          float v57 = v58;
          if (!*v58) {
            goto LABEL_116;
          }
        }
        if (v59 >= (unint64_t)v6) {
          break;
        }
        float v56 = v58[1];
        if (!v56)
        {
          float v57 = v58 + 1;
          goto LABEL_116;
        }
      }
    }
    else
    {
      float v58 = (uint64_t **)(a1 + 80);
LABEL_116:
      float v60 = (uint64_t *)operator new(0x28uLL);
      v60[4] = (uint64_t)v6;
      *float v60 = 0;
      v60[1] = 0;
      v60[2] = (uint64_t)v58;
      *float v57 = v60;
      uint64_t v61 = **(void **)(a1 + 72);
      if (v61)
      {
        *(void *)(a1 + 72) = v61;
        float v60 = *v57;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 80), v60);
      ++*(void *)(a1 + 88);
    }
  }
  float v63 = (uint64_t **)(a1 + 56);
  uint64_t v62 = *(uint64_t **)(a1 + 56);
  if (v62)
  {
    while (1)
    {
      while (1)
      {
        float32x2_t v64 = (uint64_t **)v62;
        unint64_t v65 = v62[4];
        if (v65 <= (unint64_t)v6) {
          break;
        }
        uint64_t v62 = *v64;
        float v63 = v64;
        if (!*v64) {
          goto LABEL_126;
        }
      }
      if (v65 >= (unint64_t)v6) {
        break;
      }
      uint64_t v62 = v64[1];
      if (!v62)
      {
        float v63 = v64 + 1;
        goto LABEL_126;
      }
    }
  }
  else
  {
    float32x2_t v64 = (uint64_t **)(a1 + 56);
LABEL_126:
    long long v66 = (uint64_t *)operator new(0x28uLL);
    v66[4] = (uint64_t)v6;
    *long long v66 = 0;
    v66[1] = 0;
    v66[2] = (uint64_t)v64;
    char *v63 = v66;
    uint64_t v67 = **(void **)(a1 + 48);
    if (v67)
    {
      *(void *)(a1 + 48) = v67;
      long long v66 = *v63;
    }
    std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 56), v66);
    ++*(void *)(a1 + 64);
  }
  uint64_t v68 = *(void **)(a1 + 24);
  if ((unint64_t)v68 >= *(void *)(a1 + 32))
  {
    unint64_t v70 = std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__emplace_back_slow_path<objc_object  {objcproto14VKRouteOverlay}*&,geo::memory_management_mode const&>((void **)(a1 + 16), v6);
  }
  else
  {
    id v69 = v6;
    void *v68 = &unk_1EF559F98;
    v68[1] = v69;
    unint64_t v70 = (char *)(v68 + 3);
  }
  *(void *)(a1 + 24) = v70;
  if (GEOGetVectorKitRouteLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitRouteLog_onceToken, &__block_literal_global_33);
  }
  unint64_t v7 = (unint64_t)(id)GEOGetVectorKitRouteLog_log;
  uint64_t v10 = 1;
  if (os_log_type_enabled((os_log_t)v7, OS_LOG_TYPE_INFO))
  {
    uint64_t v71 = "false";
    uint64_t v72 = *(void *)(a1 + 64);
    uint64_t v73 = *(void *)(a1 + 88);
    if (v76) {
      uint64_t v71 = "true";
    }
    *(_DWORD *)buf = 138413058;
    *(void *)&uint8_t buf[4] = v6;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v71;
    __int16 v85 = 1024;
    int v86 = v72;
    __int16 v87 = 1024;
    int v88 = v73;
    _os_log_impl(&dword_1A1780000, (os_log_t)v7, OS_LOG_TYPE_INFO, "Added overlay %@ isPersistent:%s overlaysInViewCount:%d persistentOverlaysCount:%d", buf, 0x22u);
  }
LABEL_138:

  return v10;
}

void sub_1A1ABAF78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va2, a3);
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v19 = va_arg(va2, void);
  uint64_t v21 = va_arg(va2, void);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::LabelIdentifier,std::shared_ptr<md::HighPrecisionAltitudeRequest>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va2);
  md::components::Material::~Material((md::components::Material *)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);

  _Unwind_Resume(a1);
}

void sub_1A1ABB34C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1A1ABB3D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void md::RouteOverlayLogic::runBeforeLayout(uint64_t a1, uint64_t a2, uint64_t a3, id *a4)
{
  v113[2] = *(void **)MEMORY[0x1E4F143B8];
  v106[0] = &unk_1EF573788;
  v106[1] = a2;
  v104[0] = &unk_1EF5737D0;
  v104[1] = a2;
  __int16 v105 = v104;
  uint64_t v109 = v108;
  uint64_t v107 = v106;
  v108[0] = &unk_1EF5737D0;
  v108[1] = a2;
  _ZNSt3__110__function6__funcIZN2md17RouteOverlayLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_19RouteOverlayContextEE3__0NS_9allocatorISH_EEFvvEEclEv((uint64_t)v106);
  if (v105 == v104)
  {
    (*(void (**)(void *))(v104[0] + 32))(v104);
  }
  else if (v105)
  {
    (*(void (**)(void))(*v105 + 40))();
  }
  if (v107 == v106)
  {
    (*(void (**)(void *))(v106[0] + 32))(v106);
  }
  else if (v107)
  {
    (*(void (**)(void))(*v107 + 40))();
  }
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a4[4]);
  a4[3] = a4 + 4;
  a4[5] = 0;
  a4[4] = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a4[7]);
  a4[6] = a4 + 7;
  a4[8] = 0;
  a4[7] = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a4[17]);
  a4[16] = a4 + 17;
  a4[18] = 0;
  a4[17] = 0;
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(a4[20]);
  a4[19] = a4 + 20;
  a4[21] = 0;
  a4[20] = 0;
  *((unsigned char *)a4 + 176) = *(unsigned char *)(a1 + 192);
  unint64_t v7 = (uint64_t **)(a4 + 13);
  uint64_t v6 = (uint64_t *)a4[13];
  int v100 = 0;
  obuint64_t j = 0;
  uint64_t v98 = (uint64_t *)*a4;
  float32x2_t v99 = (uint64_t *)&v100;
  uint64_t v96 = v6;
  unint64_t v97 = (void **)(a4 + 1);
  uint64_t v95 = (void **)(a4 + 14);
  uint64_t v102 = &v99;
  long long v103 = &v100;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::insert_iterator<std::set<objc_object  {objcproto14VKRouteOverlay}*>> &>((uint64_t)&buf, (uint64_t)&v98, &v97, (uint64_t)&v96, &v95, &v102);
  uint64_t v8 = *(void *)(a1 + 128);
  uint64_t v9 = *(uint64_t **)(v8 + 24);
  uint64_t v10 = (void **)a4[3];
  unint64_t v97 = (void **)(v8 + 32);
  uint64_t v98 = v9;
  uint64_t v95 = &v100;
  uint64_t v96 = v99;
  uint64_t v102 = (uint64_t **)(a4 + 3);
  long long v103 = v10;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::insert_iterator<std::set<objc_object  {objcproto14VKRouteOverlay}*>> &>((uint64_t)&buf, (uint64_t)&v98, &v97, (uint64_t)&v96, &v95, &v102);
  uint64_t v11 = *(void *)(a1 + 128);
  uint64_t v12 = *(uint64_t **)(v11 + 24);
  uint64_t v13 = (void **)a4[6];
  unint64_t v97 = &v100;
  uint64_t v98 = v99;
  uint64_t v95 = (void **)(v11 + 32);
  uint64_t v96 = v12;
  uint64_t v102 = (uint64_t **)(a4 + 6);
  long long v103 = v13;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::insert_iterator<std::set<objc_object  {objcproto14VKRouteOverlay}*>> &>((uint64_t)&buf, (uint64_t)&v98, &v97, (uint64_t)&v96, &v95, &v102);
  locatiouint64_t n = (id *)a1;
  uint64_t v14 = *(void *)(a1 + 128);
  if ((id *)(v14 + 24) != a4)
  {
    std::__tree<objc_object  {objcproto14VKRouteOverlay}*>::__assign_multi<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>((uint64_t **)a4, *(void **)(v14 + 24), (void *)(v14 + 32));
    uint64_t v14 = *(void *)(a1 + 128);
  }
  uint64_t v15 = *(uint64_t **)(v14 + 48);
  uint64_t v16 = *v7;
  uint64_t v17 = (void **)a4[16];
  unint64_t v97 = (void **)(v14 + 56);
  uint64_t v98 = v15;
  uint64_t v95 = (void **)(a4 + 14);
  uint64_t v96 = v16;
  uint64_t v102 = (uint64_t **)(a4 + 16);
  long long v103 = v17;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::insert_iterator<std::set<objc_object  {objcproto14VKRouteOverlay}*>> &>((uint64_t)&buf, (uint64_t)&v98, &v97, (uint64_t)&v96, &v95, &v102);
  uint64_t v18 = *v7;
  uint64_t v19 = *(void *)(a1 + 128);
  uint8x8_t v20 = *(uint64_t **)(v19 + 48);
  uint64_t v21 = (void **)a4[19];
  unint64_t v97 = (void **)(a4 + 14);
  uint64_t v98 = v18;
  uint64_t v95 = (void **)(v19 + 56);
  uint64_t v96 = v20;
  uint64_t v102 = (uint64_t **)(a4 + 19);
  long long v103 = v21;
  std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::insert_iterator<std::set<objc_object  {objcproto14VKRouteOverlay}*>> &>((uint64_t)&buf, (uint64_t)&v98, &v97, (uint64_t)&v96, &v95, &v102);
  uint64_t v22 = *(void *)(a1 + 128);
  if (v7 != (uint64_t **)(v22 + 48)) {
    std::__tree<objc_object  {objcproto14VKRouteOverlay}*>::__assign_multi<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>((uint64_t **)a4 + 13, *(void **)(v22 + 48), (void *)(v22 + 56));
  }
  char v24 = a4[9];
  double v23 = a4[10];
  if (v23 != v24)
  {
    uint64_t v25 = v23 - 3;
    unint64_t v26 = (void (***)(void))(v23 - 3);
    uint64_t v27 = (void (***)(void))(v23 - 3);
    do
    {
      __int32 v28 = *v27;
      v27 -= 3;
      (*v28)(v26);
      v25 -= 3;
      BOOL v29 = v26 == v24;
      unint64_t v26 = v27;
    }
    while (!v29);
  }
  a4[10] = v24;
  *((void *)&buf + 1) = 0;
  uint64_t v111 = 0;
  *(void *)&long long buf = (char *)&buf + 8;
  std::set<objc_object  {objcproto14VKRouteOverlay}*>::insert[abi:nn180100]<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(&buf, *a4, a4 + 1);
  v113[0] = 0;
  v113[1] = 0;
  uint64_t v112 = (long long *)v113;
  std::set<objc_object  {objcproto14VKRouteOverlay}*>::insert[abi:nn180100]<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(&v112, *v7, a4 + 14);
  float v30 = (id *)buf;
  if ((long long *)buf != (long long *)((char *)&buf + 8))
  {
    float v31 = 0;
    while (1)
    {
      id v32 = v30[4];
      unint64_t v33 = v32;
      unint64_t v34 = a4[10];
      if (v34 >= a4[11])
      {
        int v36 = std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__emplace_back_slow_path<objc_object  {objcproto14VKRouteOverlay}*&,geo::memory_management_mode const&>(a4 + 9, v32);
      }
      else
      {
        id v35 = v32;
        *unint64_t v34 = &unk_1EF559F98;
        v34[1] = v35;
        int v36 = (char *)(v34 + 3);
      }
      a4[10] = v36;
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        break;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v41 = v33;
        if ([v41 selected])
        {
          size_t v40 = v41;
LABEL_29:
          size_t v42 = v40;

LABEL_31:
          float v31 = v42;
          goto LABEL_32;
        }
LABEL_30:
        size_t v42 = v31;
        goto LABEL_31;
      }
LABEL_32:

      uint64_t v43 = (id *)v30[1];
      if (v43)
      {
        do
        {
          size_t v44 = v43;
          uint64_t v43 = (id *)*v43;
        }
        while (v43);
      }
      else
      {
        do
        {
          size_t v44 = (id *)v30[2];
          BOOL v29 = *v44 == v30;
          float v30 = v44;
        }
        while (!v29);
      }
      float v30 = v44;
      if (v44 == (id *)((char *)&buf + 8)) {
        goto LABEL_39;
      }
    }
    id v37 = v33;
    uint64_t v38 = [v37 selectedPolyline];
    BOOL v39 = v38 == 0;

    if (!v39)
    {
      size_t v40 = [v37 selectedPolyline];
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  float v31 = 0;
LABEL_39:
  uint64_t v45 = v112;
  if (v112 != (long long *)v113)
  {
    while (1)
    {
      float v58 = *((id *)v45 + 4);
      unint64_t v59 = v58;
      float v60 = a4[10];
      if (v60 >= a4[11])
      {
        uint64_t v62 = std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__emplace_back_slow_path<objc_object  {objcproto14VKRouteOverlay}*&,geo::memory_management_mode const&>(a4 + 9, v58);
      }
      else
      {
        uint64_t v61 = v58;
        *float v60 = &unk_1EF559F98;
        v60[1] = v61;
        uint64_t v62 = (char *)(v60 + 3);
      }
      a4[10] = v62;
      objc_opt_class();
      if (objc_opt_isKindOfClass()) {
        break;
      }
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v67 = v59;
        if ([v67 selected])
        {
          long long v66 = v67;
LABEL_68:
          uint64_t v68 = v66;

LABEL_70:
          float v31 = v68;
          goto LABEL_71;
        }
LABEL_69:
        uint64_t v68 = v31;
        goto LABEL_70;
      }
LABEL_71:

      id v69 = (long long *)*((void *)v45 + 1);
      if (v69)
      {
        do
        {
          unint64_t v70 = v69;
          id v69 = *(long long **)v69;
        }
        while (v69);
      }
      else
      {
        do
        {
          unint64_t v70 = (long long *)*((void *)v45 + 2);
          BOOL v29 = *(void *)v70 == (void)v45;
          uint64_t v45 = v70;
        }
        while (!v29);
      }
      uint64_t v45 = v70;
      if (v70 == (long long *)v113) {
        goto LABEL_40;
      }
    }
    id v63 = v59;
    float32x2_t v64 = [v63 selectedPolyline];
    BOOL v65 = v64 == 0;

    if (!v65)
    {
      long long v66 = [v63 selectedPolyline];
      goto LABEL_68;
    }
    goto LABEL_69;
  }
LABEL_40:
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v113[0]);
  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(*((void **)&buf + 1));
  unint64_t v46 = a4 + 12;
  if (a4[12] != v31)
  {
    if (GEOGetVectorKitRouteOverlayLogicLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitRouteOverlayLogicLog(void)::onceToken, &__block_literal_global_153);
    }
    uint8x8_t v47 = GEOGetVectorKitRouteOverlayLogicLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitRouteOverlayLogicLog(void)::log, OS_LOG_TYPE_INFO))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v31;
      _os_log_impl(&dword_1A1780000, v47, OS_LOG_TYPE_INFO, "Updating selected polyline:%@", (uint8_t *)&buf, 0xCu);
    }
  }
  objc_storeStrong(a4 + 12, v31);
  objc_storeStrong(a4 + 23, location[22]);
  objc_storeStrong(a4 + 24, location[23]);
  if (a4 != location)
  {
    float v49 = (char *)location[25];
    uint64_t v48 = location[26];
    size_t v50 = v48 - v49;
    unint64_t v51 = (v48 - v49) >> 3;
    uint64_t v52 = (uint64_t)a4[27];
    float v53 = a4[25];
    if (v51 > (v52 - (uint64_t)v53) >> 3)
    {
      if (v53)
      {
        a4[26] = v53;
        operator delete(v53);
        uint64_t v52 = 0;
        a4[25] = 0;
        a4[26] = 0;
        a4[27] = 0;
      }
      if ((v50 & 0x8000000000000000) != 0) {
        goto LABEL_100;
      }
      uint64_t v54 = v52 >> 2;
      if (v52 >> 2 <= v51) {
        uint64_t v54 = (v48 - v49) >> 3;
      }
      unint64_t v55 = (unint64_t)v52 >= 0x7FFFFFFFFFFFFFF8 ? 0x1FFFFFFFFFFFFFFFLL : v54;
      if (v55 >> 61) {
LABEL_100:
      }
        abort();
      float v56 = (char *)operator new(8 * v55);
      float v53 = v56;
      a4[26] = v56;
      float v57 = a4 + 26;
      *(v57 - 1) = v56;
      v57[1] = &v56[8 * v55];
      if (v48 != v49) {
        memcpy(v56, v49, v48 - v49);
      }
      goto LABEL_85;
    }
    uint64_t v72 = a4[26];
    float v57 = a4 + 26;
    uint64_t v71 = v72;
    size_t v73 = (char *)v72 - (char *)v53;
    unint64_t v74 = v72 - v53;
    if (v74 >= v51)
    {
      if (v48 == v49)
      {
LABEL_85:
        *float v57 = (char *)v53 + v50;
        goto LABEL_86;
      }
      int v76 = v53;
      long long v77 = (char *)location[25];
    }
    else
    {
      uint64_t v75 = &v49[8 * v74];
      if (v71 != v53)
      {
        memmove(v53, location[25], v73);
        float v53 = (void *)*v57;
      }
      size_t v50 = v48 - v75;
      if (v48 == v75) {
        goto LABEL_85;
      }
      int v76 = v53;
      long long v77 = v75;
    }
    memmove(v76, v77, v50);
    goto LABEL_85;
  }
LABEL_86:

  std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v100);
  id v78 = *v46;
  id v79 = *v46;
  long long v80 = v79;
  if (location[17] != v79
    || (id v81 = location[18],
        [v79 routeRibbon],
        id v82 = (id)objc_claimAutoreleasedReturnValue(),
        LOBYTE(v81) = v81 == v82,
        v82,
        (v81 & 1) == 0))
  {
    objc_storeStrong(location + 17, v78);
    uint64_t v83 = [v80 routeRibbon];
    id v84 = location[18];
    location[18] = (id)v83;

    __int16 v85 = location[15];
    int v86 = [v80 routeRibbon];
    __int16 v87 = *(md::LabelManager **)(v85[1] + 24);
    int v88 = v86;
    uint64_t v102 = (uint64_t **)&unk_1EF559438;
    long long v103 = v88;
    float32x2_t v99 = (uint64_t *)v87;
    int v100 = &unk_1EF559438;
    obuint64_t j = 0;
    uint64_t v89 = v88;
    id v90 = obj;
    obuint64_t j = v89;

    uint64_t v112 = 0;
    uint64_t v91 = operator new(0x28uLL);
    uint64_t v92 = v99;
    *(void *)uint64_t v91 = &unk_1EF56E0E8;
    *((void *)v91 + 1) = v92;
    *((void *)v91 + 2) = &unk_1EF559438;
    *((void *)v91 + 3) = 0;
    objc_storeStrong((id *)v91 + 3, obj);
    id v93 = obj;
    obuint64_t j = 0;

    uint64_t v112 = (long long *)v91;
    md::LabelManager::queueCommand(v87, 26, 0, &buf);
    if (v112 == &buf)
    {
      (*(void (**)(long long *))(buf + 32))(&buf);
    }
    else if (v112)
    {
      (*(void (**)(void))(*(void *)v112 + 40))();
    }
    int v100 = &unk_1EF559438;

    uint64_t v102 = (uint64_t **)&unk_1EF559438;
  }

  if (v109)
  {
    (*(void (**)(void *))(*v109 + 48))(v109);
    if (v109 == v108)
    {
      (*(void (**)(void *))(v108[0] + 32))(v108);
    }
    else if (v109)
    {
      (*(void (**)(void))(*v109 + 40))();
    }
  }
  else
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
}

void sub_1A1ABBF28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  uint64_t v34 = *(void *)(v32 - 120);
  if (v34 == v31)
  {
    (*(void (**)(uint64_t))(*(void *)(v32 - 144) + 32))(v32 - 144);
  }
  else if (v34)
  {
    (*(void (**)(uint64_t))(*(void *)v34 + 40))(v34);
  }

  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)&a29);
  _Unwind_Resume(a1);
}

__n128 std::__set_difference[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void>,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long> &,std::insert_iterator<std::set<objc_object  {objcproto14VKRouteOverlay}*>> &>(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void *a5, void **a6)
{
  uint64_t v8 = *(void **)a2;
  uint64_t v9 = (void *)*a3;
  if (*(void *)a2 == *a3) {
    goto LABEL_58;
  }
  uint64_t v12 = *(void **)a4;
  if (*(void *)a4 == *a5)
  {
LABEL_39:
    id v37 = (void **)*a6;
    int v36 = a6[1];
    if (v8 == v9) {
      goto LABEL_60;
    }
    while (1)
    {
      uint64_t v38 = (uint64_t **)std::__tree<objc_object  {objcproto14VKRouteOverlay}*>::__find_equal<objc_object  {objcproto14VKRouteOverlay}*>(v37, v36, &v49, &v48, v8[4]);
      BOOL v39 = *v38;
      if (*v38)
      {
        size_t v40 = (uint64_t *)v39[1];
        if (!v40) {
          goto LABEL_50;
        }
      }
      else
      {
        id v41 = v38;
        BOOL v39 = (uint64_t *)operator new(0x28uLL);
        v39[4] = v8[4];
        uint64_t v42 = v49;
        *BOOL v39 = 0;
        v39[1] = 0;
        v39[2] = v42;
        *id v41 = v39;
        uint64_t v43 = (void *)**v37;
        size_t v44 = v39;
        if (v43)
        {
          *id v37 = v43;
          size_t v44 = *v41;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v37[1], v44);
        v37[2] = (void *)((char *)v37[2] + 1);
        size_t v40 = (uint64_t *)v39[1];
        if (!v40)
        {
          do
          {
LABEL_50:
            int v36 = (uint64_t *)v39[2];
            BOOL v26 = *v36 == (void)v39;
            BOOL v39 = v36;
          }
          while (!v26);
          goto LABEL_52;
        }
      }
      do
      {
        int v36 = v40;
        size_t v40 = (uint64_t *)*v40;
      }
      while (v40);
LABEL_52:
      uint64_t v45 = (void *)v8[1];
      if (v45)
      {
        do
        {
          unint64_t v46 = v45;
          uint64_t v45 = (void *)*v45;
        }
        while (v45);
      }
      else
      {
        do
        {
          unint64_t v46 = (void *)v8[2];
          BOOL v26 = *v46 == (void)v8;
          uint64_t v8 = v46;
        }
        while (!v26);
      }
      uint64_t v8 = v46;
      if (v46 == v9)
      {
        uint64_t v8 = v9;
        goto LABEL_60;
      }
    }
  }
  while (1)
  {
    unint64_t v15 = v8[4];
    unint64_t v16 = v12[4];
    if (v15 >= v16)
    {
      if (v16 >= v15)
      {
        uint64_t v32 = (void *)v8[1];
        if (v32)
        {
          do
          {
            unint64_t v33 = v32;
            uint64_t v32 = (void *)*v32;
          }
          while (v32);
        }
        else
        {
          do
          {
            unint64_t v33 = (void *)v8[2];
            BOOL v26 = *v33 == (void)v8;
            uint64_t v8 = v33;
          }
          while (!v26);
        }
        *(void *)a2 = v33;
        uint64_t v34 = *(void **)a4;
        id v35 = *(void **)(*(void *)a4 + 8);
        if (v35)
        {
          do
          {
            uint64_t v31 = v35;
            id v35 = (void *)*v35;
          }
          while (v35);
        }
        else
        {
          do
          {
            uint64_t v31 = (void *)v34[2];
            BOOL v26 = *v31 == (void)v34;
            uint64_t v34 = v31;
          }
          while (!v26);
        }
      }
      else
      {
        float v30 = (void *)v12[1];
        if (v30)
        {
          do
          {
            uint64_t v31 = v30;
            float v30 = (void *)*v30;
          }
          while (v30);
        }
        else
        {
          do
          {
            uint64_t v31 = (void *)v12[2];
            BOOL v26 = *v31 == (void)v12;
            uint64_t v12 = v31;
          }
          while (!v26);
        }
      }
      *(void *)a4 = v31;
    }
    else
    {
      uint64_t v17 = (void **)*a6;
      uint64_t v18 = (uint64_t **)std::__tree<objc_object  {objcproto14VKRouteOverlay}*>::__find_equal<objc_object  {objcproto14VKRouteOverlay}*>(*a6, a6[1], &v49, &v48, v15);
      uint64_t v19 = *v18;
      if (!*v18)
      {
        uint8x8_t v20 = v18;
        uint64_t v19 = (uint64_t *)operator new(0x28uLL);
        v19[4] = v8[4];
        uint64_t v21 = v49;
        *uint64_t v19 = 0;
        v19[1] = 0;
        v19[2] = v21;
        *uint8x8_t v20 = v19;
        uint64_t v22 = (void *)**v17;
        double v23 = v19;
        if (v22)
        {
          *uint64_t v17 = v22;
          double v23 = *v20;
        }
        std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v17[1], v23);
        v17[2] = (void *)((char *)v17[2] + 1);
      }
      a6[1] = v19;
      char v24 = (uint64_t *)v19[1];
      if (v24)
      {
        do
        {
          uint64_t v25 = v24;
          char v24 = (uint64_t *)*v24;
        }
        while (v24);
      }
      else
      {
        do
        {
          uint64_t v25 = (uint64_t *)v19[2];
          BOOL v26 = *v25 == (void)v19;
          uint64_t v19 = v25;
        }
        while (!v26);
      }
      a6[1] = v25;
      uint64_t v27 = *(void **)a2;
      __int32 v28 = *(void **)(*(void *)a2 + 8);
      if (v28)
      {
        do
        {
          BOOL v29 = v28;
          __int32 v28 = (void *)*v28;
        }
        while (v28);
      }
      else
      {
        do
        {
          BOOL v29 = (void *)v27[2];
          BOOL v26 = *v29 == (void)v27;
          uint64_t v27 = v29;
        }
        while (!v26);
      }
      *(void *)a2 = v29;
    }
    uint64_t v8 = *(void **)a2;
    uint64_t v9 = (void *)*a3;
    if (*(void *)a2 == *a3) {
      break;
    }
    uint64_t v12 = *(void **)a4;
    if (*(void *)a4 == *a5) {
      goto LABEL_39;
    }
  }
LABEL_58:
  id v37 = (void **)*a6;
  int v36 = a6[1];
LABEL_60:
  result.n128_u64[0] = (unint64_t)v37;
  result.n128_u64[1] = (unint64_t)v36;
  *(void *)a1 = v8;
  *(__n128 *)(a1 + 8) = result;
  return result;
}

void std::__tree<objc_object  {objcproto14VKRouteOverlay}*>::__assign_multi<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(uint64_t **a1, void *a2, void *a3)
{
  float32x2_t v4 = a2;
  if (a1[2])
  {
    uint64_t v6 = (uint64_t **)*a1;
    uint64_t v8 = a1 + 1;
    unint64_t v7 = a1[1];
    *a1 = (uint64_t *)(a1 + 1);
    _OWORD v7[2] = 0;
    a1[2] = 0;
    a1[1] = 0;
    uint64_t v9 = v6[1] ? v6[1] : (uint64_t *)v6;
    if (v9)
    {
      uint64_t v10 = (uint64_t *)v9[2];
      if (v10)
      {
        uint64_t v11 = (uint64_t *)*v10;
        if ((uint64_t *)*v10 == v9)
        {
          uint64_t *v10 = 0;
          while (1)
          {
            uint64_t v34 = (uint64_t *)v10[1];
            if (!v34) {
              break;
            }
            do
            {
              uint64_t v10 = v34;
              uint64_t v34 = (uint64_t *)*v34;
            }
            while (v34);
          }
        }
        else
        {
          for (v10[1] = 0; v11; uint64_t v11 = (uint64_t *)v10[1])
          {
            do
            {
              uint64_t v10 = v11;
              uint64_t v11 = (uint64_t *)*v11;
            }
            while (v11);
          }
        }
      }
      if (a2 != a3)
      {
        uint64_t v12 = v9;
        uint64_t v13 = v4;
        do
        {
          uint64_t v9 = v10;
          unint64_t v14 = v13[4];
          CGFloat v12[4] = v14;
          unint64_t v15 = *v8;
          unint64_t v16 = a1 + 1;
          uint64_t v17 = a1 + 1;
          if (*v8)
          {
            do
            {
              while (1)
              {
                unint64_t v16 = (uint64_t **)v15;
                if (v14 >= v15[4]) {
                  break;
                }
                unint64_t v15 = (uint64_t *)*v15;
                uint64_t v17 = v16;
                if (!*v16) {
                  goto LABEL_20;
                }
              }
              unint64_t v15 = (uint64_t *)v15[1];
            }
            while (v15);
            uint64_t v17 = v16 + 1;
          }
LABEL_20:
          *uint64_t v12 = 0;
          v12[1] = 0;
          v12[2] = (uint64_t)v16;
          *uint64_t v17 = v12;
          uint64_t v18 = (uint64_t *)**a1;
          if (v18)
          {
            *a1 = v18;
            uint64_t v12 = *v17;
          }
          std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v12);
          a1[2] = (uint64_t *)((char *)a1[2] + 1);
          if (v10)
          {
            uint64_t v10 = (uint64_t *)v10[2];
            if (v10)
            {
              uint64_t v21 = (uint64_t *)*v10;
              if ((uint64_t *)*v10 == v9)
              {
                uint64_t *v10 = 0;
                while (1)
                {
                  uint64_t v22 = (uint64_t *)v10[1];
                  if (!v22) {
                    break;
                  }
                  do
                  {
                    uint64_t v10 = v22;
                    uint64_t v22 = (uint64_t *)*v22;
                  }
                  while (v22);
                }
              }
              else
              {
                for (v10[1] = 0; v21; uint64_t v21 = (uint64_t *)v10[1])
                {
                  do
                  {
                    uint64_t v10 = v21;
                    uint64_t v21 = (uint64_t *)*v21;
                  }
                  while (v21);
                }
              }
            }
          }
          else
          {
            uint64_t v10 = 0;
          }
          uint64_t v19 = (void *)v13[1];
          if (v19)
          {
            do
            {
              float32x2_t v4 = v19;
              uint64_t v19 = (void *)*v19;
            }
            while (v19);
          }
          else
          {
            do
            {
              float32x2_t v4 = (void *)v13[2];
              BOOL v20 = *v4 == (void)v13;
              uint64_t v13 = v4;
            }
            while (!v20);
          }
          if (!v9) {
            break;
          }
          uint64_t v12 = v9;
          uint64_t v13 = v4;
        }
        while (v4 != a3);
      }
      std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v9);
      if (v10)
      {
        for (uint64_t i = (uint64_t *)v10[2]; i; uint64_t i = (uint64_t *)i[2])
          uint64_t v10 = i;
        std::__tree<std::pair<md::MapTileData *,BOOL>>::destroy(v10);
      }
    }
  }
  if (v4 != a3)
  {
    char v24 = a1 + 1;
    do
    {
      uint64_t v25 = (uint64_t *)operator new(0x28uLL);
      BOOL v26 = v25;
      unint64_t v27 = v4[4];
      v25[4] = v27;
      __int32 v28 = *v24;
      BOOL v29 = a1 + 1;
      float v30 = a1 + 1;
      if (*v24)
      {
        do
        {
          while (1)
          {
            BOOL v29 = (uint64_t **)v28;
            if (v27 >= v28[4]) {
              break;
            }
            __int32 v28 = (uint64_t *)*v28;
            float v30 = v29;
            if (!*v29) {
              goto LABEL_56;
            }
          }
          __int32 v28 = (uint64_t *)v28[1];
        }
        while (v28);
        float v30 = v29 + 1;
      }
LABEL_56:
      *uint64_t v25 = 0;
      v25[1] = 0;
      v25[2] = (uint64_t)v29;
      *float v30 = v25;
      uint64_t v31 = (uint64_t *)**a1;
      if (v31)
      {
        *a1 = v31;
        BOOL v26 = *v30;
      }
      std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(a1[1], v26);
      a1[2] = (uint64_t *)((char *)a1[2] + 1);
      uint64_t v32 = (void *)v4[1];
      if (v32)
      {
        do
        {
          unint64_t v33 = v32;
          uint64_t v32 = (void *)*v32;
        }
        while (v32);
      }
      else
      {
        do
        {
          unint64_t v33 = (void *)v4[2];
          BOOL v20 = *v33 == (void)v4;
          float32x2_t v4 = v33;
        }
        while (!v20);
      }
      float32x2_t v4 = v33;
    }
    while (v33 != a3);
  }
}

void *std::set<objc_object  {objcproto14VKRouteOverlay}*>::insert[abi:nn180100]<std::__tree_const_iterator<objc_object  {objcproto14VKRouteOverlay}*,std::__tree_node<objc_object  {objcproto14VKRouteOverlay}*,void *> *,long>>(void *result, void *a2, void *a3)
{
  if (a2 != a3)
  {
    v18[7] = v3;
    v18[8] = v4;
    uint64_t v6 = a2;
    unint64_t v7 = (void **)result;
    uint64_t v8 = result + 1;
    do
    {
      __n128 result = std::__tree<objc_object  {objcproto14VKRouteOverlay}*>::__find_equal<objc_object  {objcproto14VKRouteOverlay}*>(v7, v8, v18, &v17, v6[4]);
      if (*result)
      {
        uint64_t v9 = (void *)v6[1];
        if (v9) {
          goto LABEL_11;
        }
      }
      else
      {
        uint64_t v10 = (uint64_t **)result;
        uint64_t v11 = (uint64_t *)operator new(0x28uLL);
        v11[4] = v6[4];
        uint64_t v12 = v18[0];
        uint64_t *v11 = 0;
        v11[1] = 0;
        void v11[2] = v12;
        uint64_t *v10 = v11;
        uint64_t v13 = (void *)**v7;
        if (v13)
        {
          uint64_t *v7 = v13;
          unint64_t v14 = *v10;
        }
        else
        {
          unint64_t v14 = v11;
        }
        __n128 result = std::__tree_balance_after_insert[abi:nn180100]<std::__tree_node_base<void *> *>(v7[1], v14);
        _OWORD v7[2] = (void *)((char *)v7[2] + 1);
        uint64_t v9 = (void *)v6[1];
        if (v9)
        {
          do
          {
LABEL_11:
            unint64_t v15 = v9;
            uint64_t v9 = (void *)*v9;
          }
          while (v9);
          goto LABEL_3;
        }
      }
      do
      {
        unint64_t v15 = (void *)v6[2];
        BOOL v16 = *v15 == (void)v6;
        uint64_t v6 = v15;
      }
      while (!v16);
LABEL_3:
      uint64_t v6 = v15;
    }
    while (v15 != a3);
  }
  return result;
}

void *std::__tree<objc_object  {objcproto14VKRouteOverlay}*>::__find_equal<objc_object  {objcproto14VKRouteOverlay}*>(void *a1, void *a2, void *a3, void *a4, unint64_t a5)
{
  id v5 = a1 + 1;
  if (a1 + 1 == a2 || (unint64_t v6 = a2[4], v6 > a5))
  {
    uint64_t v7 = *a2;
    if ((void *)*a1 == a2)
    {
      uint64_t v9 = a2;
LABEL_17:
      if (v7)
      {
        *a3 = v9;
        return v9 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v7)
    {
      uint64_t v8 = (void *)*a2;
      do
      {
        uint64_t v9 = v8;
        uint64_t v8 = (void *)v8[1];
      }
      while (v8);
    }
    else
    {
      uint64_t v13 = a2;
      do
      {
        uint64_t v9 = (void *)v13[2];
        BOOL v14 = *v9 == (void)v13;
        uint64_t v13 = v9;
      }
      while (v14);
    }
    if (v9[4] < a5) {
      goto LABEL_17;
    }
    BOOL v16 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = v16;
          unint64_t v18 = v16[4];
          if (v18 <= a5) {
            break;
          }
          BOOL v16 = (void *)*v17;
          id v5 = v17;
          if (!*v17) {
            goto LABEL_41;
          }
        }
        if (v18 >= a5) {
          break;
        }
        id v5 = v17 + 1;
        BOOL v16 = (void *)v17[1];
      }
      while (v16);
      goto LABEL_41;
    }
LABEL_20:
    uint64_t v17 = a1 + 1;
LABEL_41:
    *a3 = v17;
    return v5;
  }
  if (v6 >= a5)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  uint64_t v10 = a2[1];
  if (v10)
  {
    uint64_t v11 = (void *)a2[1];
    do
    {
      uint64_t v12 = v11;
      uint64_t v11 = (void *)*v11;
    }
    while (v11);
  }
  else
  {
    uint64_t v19 = a2;
    do
    {
      uint64_t v12 = (void *)v19[2];
      BOOL v14 = *v12 == (void)v19;
      uint64_t v19 = v12;
    }
    while (!v14);
  }
  if (v12 != v5 && v12[4] <= a5)
  {
    BOOL v20 = (void *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v17 = v20;
          unint64_t v21 = v20[4];
          if (v21 <= a5) {
            break;
          }
          BOOL v20 = (void *)*v17;
          id v5 = v17;
          if (!*v17) {
            goto LABEL_41;
          }
        }
        if (v21 >= a5) {
          break;
        }
        id v5 = v17 + 1;
        BOOL v20 = (void *)v17[1];
      }
      while (v20);
      goto LABEL_41;
    }
    goto LABEL_20;
  }
  if (v10)
  {
    *a3 = v12;
    return v12;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
}

void _ZNSt3__110__function6__funcIZN2md17RouteOverlayLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_19RouteOverlayContextEE3__1NS_9allocatorISH_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)id v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "RouteOverlayLogic", "", v5, 2u);
  }
}

void _ZNSt3__110__function6__funcIZN2md17RouteOverlayLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJEEESA_EE20ResolvedDependenciesERNS2_19RouteOverlayContextEE3__0NS_9allocatorISH_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)id v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "RouteOverlayLogic", "", v5, 2u);
  }
}

uint64_t geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>::~_retain_ptr(uint64_t a1)
{
  *(void *)a1 = &unk_1EF559F98;

  return a1;
}

char *std::vector<geo::_retain_ptr<objc_object  {objcproto14VKRouteOverlay}* {__strong},geo::_retain_objc_arc,geo::_release_objc_arc,geo::_hash_objc,geo::_equal_objc>>::__emplace_back_slow_path<objc_object  {objcproto14VKRouteOverlay}*&,geo::memory_management_mode const&>(void **a1, void *a2)
{
  unint64_t v2 = 0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[1] - (unsigned char *)*a1) >> 3);
  unint64_t v3 = v2 + 1;
  if (v2 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) > v3) {
    unint64_t v3 = 0x5555555555555556 * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * (((unsigned char *)a1[2] - (unsigned char *)*a1) >> 3) >= 0x555555555555555) {
    unint64_t v6 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v6 = v3;
  }
  if (v6)
  {
    if (v6 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v7 = (char *)operator new(24 * v6);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v8 = &v7[24 * v2];
  uint64_t v9 = &v7[24 * v6];
  id v10 = a2;
  *(void *)uint64_t v8 = &unk_1EF559F98;
  *((void *)v8 + 1) = v10;
  uint64_t v11 = v8 + 24;
  uint64_t v13 = (id *)*a1;
  uint64_t v12 = (id *)a1[1];
  if (v12 == *a1)
  {
    *a1 = v8;
    a1[1] = v11;
    a1[2] = v9;
    if (!v12) {
      return v11;
    }
    goto LABEL_19;
  }
  uint64_t v14 = (uint64_t)&v7[24 * v2 - 24];
  do
  {
    *((void *)v8 - 3) = &unk_1EF559F98;
    v8 -= 24;
    *((void *)v8 + 1) = 0;
    objc_storeStrong((id *)v8 + 1, *(v12 - 2));
    unint64_t v15 = *(v12 - 2);
    *(v12 - 2) = 0;

    v14 -= 24;
    v12 -= 3;
  }
  while (v12 != v13);
  uint64_t v12 = (id *)*a1;
  BOOL v16 = (id *)a1[1];
  *a1 = v8;
  a1[1] = v11;
  a1[2] = v9;
  if (v16 != v12)
  {
    uint64_t v17 = v16 - 3;
    unint64_t v18 = v16 - 3;
    uint64_t v19 = v16 - 3;
    do
    {
      BOOL v20 = (void (**)(id *))*v19;
      v19 -= 3;
      (*v20)(v18);
      v17 -= 3;
      BOOL v21 = v18 == v12;
      unint64_t v18 = v19;
    }
    while (!v21);
  }
  if (v12) {
LABEL_19:
  }
    operator delete(v12);
  return v11;
}

void gms::NonZoomablePropertyStore<std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>::addProperty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>::unordered_map((uint64_t)&__p, a4);
  char v37 = 1;
  id v5 = __p;
  unint64_t v6 = v33;
  std::string __p = 0;
  unint64_t v33 = 0;
  uint64_t v38 = v5;
  unint64_t v39 = v6;
  uint64_t v7 = v34;
  size_t v40 = v34;
  uint64_t v41 = v35;
  int v42 = v36;
  if (v35)
  {
    unint64_t v8 = v34[1];
    if ((v6 & (v6 - 1)) != 0)
    {
      if (v8 >= v6) {
        v8 %= v6;
      }
    }
    else
    {
      v8 &= v6 - 1;
    }
    *((void *)v5 + v8) = &v40;
    uint64_t v34 = 0;
    uint64_t v35 = 0;
  }
  else if (v34)
  {
    do
    {
      uint64_t v9 = (void *)*v7;
      operator delete(v7);
      uint64_t v7 = v9;
    }
    while (v9);
  }
  id v10 = __p;
  std::string __p = 0;
  if (v10) {
    operator delete(v10);
  }
  if (v37)
  {
    if (*(unsigned char *)(a1 + 8))
    {
      if (*(void *)(a1 + 40))
      {
        uint64_t v11 = *(void **)(a1 + 32);
        if (v11)
        {
          do
          {
            uint64_t v12 = (void *)*v11;
            operator delete(v11);
            uint64_t v11 = v12;
          }
          while (v12);
        }
        *(void *)(a1 + 32) = 0;
        uint64_t v13 = *(void *)(a1 + 24);
        if (v13)
        {
          for (uint64_t i = 0; i != v13; ++i)
            *(void *)(*(void *)(a1 + 16) + 8 * i) = 0;
        }
        *(void *)(a1 + 40) = 0;
      }
      unint64_t v15 = v38;
      uint64_t v38 = 0;
      BOOL v16 = *(void **)(a1 + 16);
      *(void *)(a1 + 16) = v15;
      if (v16) {
        operator delete(v16);
      }
      unint64_t v17 = v39;
      unint64_t v18 = v40;
      *(void *)(a1 + 32) = v40;
      *(void *)(a1 + 24) = v17;
      unint64_t v39 = 0;
      uint64_t v19 = v41;
      *(void *)(a1 + 40) = v41;
      *(_DWORD *)(a1 + 48) = v42;
      if (v19)
      {
        unint64_t v20 = v18[1];
        if ((v17 & (v17 - 1)) != 0)
        {
          if (v20 >= v17) {
            v20 %= v17;
          }
        }
        else
        {
          v20 &= v17 - 1;
        }
        *(void *)(*(void *)(a1 + 16) + 8 * v20) = a1 + 32;
        size_t v40 = 0;
        uint64_t v41 = 0;
      }
      if (!v37) {
        return;
      }
LABEL_45:
      BOOL v29 = v40;
      if (v40)
      {
        do
        {
          float v30 = (void *)*v29;
          operator delete(v29);
          BOOL v29 = v30;
        }
        while (v30);
      }
      uint64_t v31 = v38;
      uint64_t v38 = 0;
      if (v31) {
        operator delete(v31);
      }
      return;
    }
    char v24 = v38;
    unint64_t v25 = v39;
    BOOL v26 = v40;
    uint64_t v27 = v41;
    *(void *)(a1 + 32) = v40;
    uint64_t v38 = 0;
    unint64_t v39 = 0;
    *(void *)(a1 + 16) = v24;
    *(void *)(a1 + 24) = v25;
    *(void *)(a1 + 40) = v27;
    *(_DWORD *)(a1 + 48) = v42;
    if (v27)
    {
      unint64_t v28 = v26[1];
      if ((v25 & (v25 - 1)) != 0)
      {
        if (v28 >= v25) {
          v28 %= v25;
        }
      }
      else
      {
        v28 &= v25 - 1;
      }
      v24[v28] = a1 + 32;
      size_t v40 = 0;
      uint64_t v41 = 0;
    }
    *(unsigned char *)(a1 + 8) = 1;
    if (v37) {
      goto LABEL_45;
    }
  }
  else if (*(unsigned char *)(a1 + 8))
  {
    BOOL v21 = *(void **)(a1 + 32);
    if (v21)
    {
      do
      {
        uint64_t v22 = (void *)*v21;
        operator delete(v21);
        BOOL v21 = v22;
      }
      while (v22);
    }
    double v23 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    if (v23) {
      operator delete(v23);
    }
    *(unsigned char *)(a1 + 8) = 0;
    if (v37) {
      goto LABEL_45;
    }
  }
}

void *std::__hash_table<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::__unordered_map_hasher<unsigned char,std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::hash<unsigned char>,std::equal_to<unsigned char>,true>,std::__unordered_map_equal<unsigned char,std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,std::equal_to<unsigned char>,std::hash<unsigned char>,true>,std::allocator<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>>>::__emplace_unique_key_args<unsigned char,std::pair<unsigned char const,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>> const&>(uint64_t a1, unsigned __int8 *a2, uint64_t a3)
{
  unint64_t v6 = *a2;
  unint64_t v7 = *(void *)(a1 + 8);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v3 = *a2;
      if (v7 <= v6) {
        unint64_t v3 = v6 % v7;
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
    }
    uint64_t v9 = *(void **)(*(void *)a1 + 8 * v3);
    if (v9)
    {
      __n128 result = (void *)*v9;
      if (*v9)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = result[1];
            if (v12 == v6)
            {
              if (*((unsigned __int8 *)result + 16) == v6) {
                return result;
              }
            }
            else if ((v12 & (v7 - 1)) != v3)
            {
              goto LABEL_23;
            }
            __n128 result = (void *)*result;
            if (!result) {
              goto LABEL_23;
            }
          }
        }
        do
        {
          unint64_t v11 = result[1];
          if (v11 == v6)
          {
            if (*((unsigned __int8 *)result + 16) == v6) {
              return result;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v3) {
              break;
            }
          }
          __n128 result = (void *)*result;
        }
        while (result);
      }
    }
  }
LABEL_23:
  BOOL v26 = operator new(0x30uLL);
  *BOOL v26 = 0;
  v26[1] = v6;
  *((unsigned char *)v26 + 16) = *(unsigned char *)a3;
  v26[4] = 0;
  v26[5] = 0;
  v26[3] = 0;
  std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>::__init_with_size[abi:ne180100]<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>*,std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>*>((uint64_t)(v26 + 3), *(void *)(a3 + 8), *(void *)(a3 + 16), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a3 + 16) - *(void *)(a3 + 8)) >> 4));
  float v13 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v14 = *(float *)(a1 + 32);
  if (!v7 || (float)(v14 * (float)v7) < v13)
  {
    BOOL v17 = 1;
    if (v7 >= 3) {
      BOOL v17 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v18 = v17 | (2 * v7);
    unint64_t v19 = vcvtps_u32_f32(v13 / v14);
    if (v18 <= v19) {
      size_t prime = v19;
    }
    else {
      size_t prime = v18;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
    }
    int8x8_t v21 = *(int8x8_t *)(a1 + 8);
    if (prime > *(void *)&v21) {
      goto LABEL_37;
    }
    if (prime < *(void *)&v21)
    {
      unint64_t v22 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (*(void *)&v21 < 3uLL || (uint8x8_t v23 = (uint8x8_t)vcnt_s8(v21), v23.i16[0] = vaddlv_u8(v23), v23.u32[0] > 1uLL))
      {
        unint64_t v22 = std::__next_prime(v22);
      }
      else
      {
        uint64_t v24 = 1 << -(char)__clz(v22 - 1);
        if (v22 >= 2) {
          unint64_t v22 = v24;
        }
      }
      if (prime <= v22) {
        size_t prime = v22;
      }
      if (prime < *(void *)&v21) {
LABEL_37:
      }
        std::__hash_table<std::__hash_value_type<char const*,DebugChapterInfo>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,DebugChapterInfo>,std::hash<char const*>,std::equal_to<char const*>,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,DebugChapterInfo>,std::equal_to<char const*>,std::hash<char const*>,true>,std::allocator<std::__hash_value_type<char const*,DebugChapterInfo>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v7 = *(void *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
      {
        unint64_t v3 = v6 % v7;
        unint64_t v15 = *(void **)(*(void *)a1 + 8 * (v6 % v7));
        BOOL v16 = v26;
        if (v15) {
          goto LABEL_26;
        }
      }
      else
      {
        unint64_t v3 = v6;
        unint64_t v15 = *(void **)(*(void *)a1 + 8 * v6);
        BOOL v16 = v26;
        if (v15) {
          goto LABEL_26;
        }
      }
    }
    else
    {
      unint64_t v3 = (v7 - 1) & v6;
      unint64_t v15 = *(void **)(*(void *)a1 + 8 * v3);
      BOOL v16 = v26;
      if (v15) {
        goto LABEL_26;
      }
    }
LABEL_50:
    *BOOL v16 = *(void *)(a1 + 16);
    *(void *)(a1 + 16) = v26;
    *(void *)(*(void *)a1 + 8 * v3) = a1 + 16;
    if (*v26)
    {
      unint64_t v25 = *(void *)(*v26 + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v25 >= v7) {
          v25 %= v7;
        }
      }
      else
      {
        v25 &= v7 - 1;
      }
      *(void *)(*(void *)a1 + 8 * v25) = v26;
    }
    goto LABEL_61;
  }
  unint64_t v15 = *(void **)(*(void *)a1 + 8 * v3);
  BOOL v16 = v26;
  if (!v15) {
    goto LABEL_50;
  }
LABEL_26:
  *BOOL v16 = *v15;
  *unint64_t v15 = v26;
LABEL_61:
  __n128 result = v26;
  ++*(void *)(a1 + 24);
  return result;
}

void sub_1A1ABD3AC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1A1ABD3C0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned char,std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>>::__init_with_size[abi:ne180100]<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>*,std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>>*>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (a4)
  {
    id v5 = (void *)result;
    if (a4 >= 0x555555555555556) {
      std::vector<double>::__throw_length_error[abi:ne180100]();
    }
    __n128 result = (uint64_t)operator new(48 * a4);
    uint64_t v8 = result;
    void *v5 = result;
    v5[1] = result;
    uint64_t v5[2] = result + 48 * a4;
    if (a2 != a3)
    {
      uint64_t v9 = 0;
      do
      {
        *(_WORD *)(v8 + v9) = *(_WORD *)(a2 + v9);
        __n128 result = std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>::unordered_map(v8 + v9 + 8, a2 + v9 + 8);
        v9 += 48;
      }
      while (a2 + v9 != a3);
      v8 += v9;
    }
    v5[1] = v8;
  }
  return result;
}

void sub_1A1ABD4A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
}

void sub_1A1ABD4B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  if (v12)
  {
    do
    {
      float v14 = *(void **)(v11 - 24);
      if (v14)
      {
        do
        {
          unint64_t v15 = (void *)*v14;
          operator delete(v14);
          float v14 = v15;
        }
        while (v15);
      }
      BOOL v16 = *(void **)(v11 - 40);
      *(void *)(v11 - 40) = 0;
      if (v16) {
        operator delete(v16);
      }
      v11 -= 48;
    }
    while (v11 != v10);
  }
  *(void *)(v9 + 8) = v10;
  std::__exception_guard_exceptions<std::vector<std::pair<gm::Range<unsigned char>,std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>>>>::__destroy_vector>::~__exception_guard_exceptions[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

uint64_t std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>>::unordered_map(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  unint64_t prime = *(void *)(a2 + 8);
  if (prime == 1)
  {
    unint64_t prime = 2;
LABEL_17:
    std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    unint64_t prime = std::__next_prime(*(void *)(a2 + 8));
    int8x8_t v5 = *(int8x8_t *)(a1 + 8);
    BOOL v6 = prime >= *(void *)&v5;
    if (prime > *(void *)&v5) {
      goto LABEL_17;
    }
  }
  else
  {
    int8x8_t v5 = 0;
    BOOL v6 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v6)
  {
    unint64_t v7 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v5 < 3uLL || (uint8x8_t v8 = (uint8x8_t)vcnt_s8(v5), v8.i16[0] = vaddlv_u8(v8), v8.u32[0] > 1uLL))
    {
      unint64_t v7 = std::__next_prime(v7);
    }
    else
    {
      uint64_t v9 = 1 << -(char)__clz(v7 - 1);
      if (v7 >= 2) {
        unint64_t v7 = v9;
      }
    }
    if (prime <= v7) {
      unint64_t prime = v7;
    }
    if (prime < *(void *)&v5) {
      goto LABEL_17;
    }
  }
LABEL_18:
  uint64_t v10 = *(uint64_t **)(a2 + 16);
  if (v10)
  {
    uint64_t v11 = (void *)(a1 + 16);
    unint64_t v12 = *(void *)(a1 + 8);
    do
    {
      float v13 = *((float *)v10 + 4);
      if (v13 == 0.0) {
        unint64_t v14 = 0;
      }
      else {
        unint64_t v14 = LODWORD(v13);
      }
      if (v12)
      {
        uint8x8_t v15 = (uint8x8_t)vcnt_s8((int8x8_t)v12);
        v15.i16[0] = vaddlv_u8(v15);
        if (v15.u32[0] > 1uLL)
        {
          unint64_t prime = v14;
          if (v14 >= v12) {
            unint64_t prime = v14 % v12;
          }
        }
        else
        {
          unint64_t prime = v14 & (v12 + 0xFFFFFFFF);
        }
        BOOL v16 = *(float ***)(*(void *)a1 + 8 * prime);
        if (v16)
        {
          BOOL v17 = *v16;
          if (v17)
          {
            if (v15.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v19 = *((void *)v17 + 1);
                if (v19 == v14)
                {
                  if (v17[4] == v13) {
                    goto LABEL_81;
                  }
                }
                else if ((v19 & (v12 - 1)) != prime)
                {
                  goto LABEL_43;
                }
                BOOL v17 = *(float **)v17;
                if (!v17) {
                  goto LABEL_43;
                }
              }
            }
            do
            {
              unint64_t v18 = *((void *)v17 + 1);
              if (v18 == v14)
              {
                if (v17[4] == v13) {
                  goto LABEL_81;
                }
              }
              else
              {
                if (v18 >= v12) {
                  v18 %= v12;
                }
                if (v18 != prime) {
                  break;
                }
              }
              BOOL v17 = *(float **)v17;
            }
            while (v17);
          }
        }
      }
LABEL_43:
      unint64_t v20 = operator new(0x20uLL);
      *unint64_t v20 = 0;
      v20[1] = v14;
      *((_DWORD *)v20 + 4) = *((_DWORD *)v10 + 4);
      uint64_t v21 = *(uint64_t *)((char *)v10 + 20);
      *((_DWORD *)v20 + 7) = *((_DWORD *)v10 + 7);
      *(void *)((char *)v20 + 20) = v21;
      float v22 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
      float v23 = *(float *)(a1 + 32);
      if (!v12 || (float)(v23 * (float)v12) < v22)
      {
        BOOL v24 = (v12 & (v12 - 1)) != 0;
        if (v12 < 3) {
          BOOL v24 = 1;
        }
        unint64_t v25 = v24 | (2 * v12);
        unint64_t v26 = vcvtps_u32_f32(v22 / v23);
        if (v25 <= v26) {
          size_t v27 = v26;
        }
        else {
          size_t v27 = v25;
        }
        if (v27 == 1)
        {
          size_t v27 = 2;
        }
        else if ((v27 & (v27 - 1)) != 0)
        {
          size_t v27 = std::__next_prime(v27);
          unint64_t v12 = *(void *)(a1 + 8);
        }
        if (v27 > v12) {
          goto LABEL_55;
        }
        if (v27 < v12)
        {
          unint64_t v28 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
          if (v12 < 3 || (uint8x8_t v29 = (uint8x8_t)vcnt_s8((int8x8_t)v12), v29.i16[0] = vaddlv_u8(v29), v29.u32[0] > 1uLL))
          {
            unint64_t v28 = std::__next_prime(v28);
          }
          else
          {
            uint64_t v30 = 1 << -(char)__clz(v28 - 1);
            if (v28 >= 2) {
              unint64_t v28 = v30;
            }
          }
          if (v27 <= v28) {
            size_t v27 = v28;
          }
          if (v27 < v12) {
LABEL_55:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(a1, v27);
        }
        unint64_t v12 = *(void *)(a1 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v14 >= v12) {
            unint64_t prime = v14 % v12;
          }
          else {
            unint64_t prime = v14;
          }
        }
        else
        {
          unint64_t prime = (v12 - 1) & v14;
        }
      }
      uint64_t v31 = *(void *)a1;
      uint64_t v32 = *(void **)(*(void *)a1 + 8 * prime);
      if (v32)
      {
        *unint64_t v20 = *v32;
      }
      else
      {
        *unint64_t v20 = *v11;
        void *v11 = v20;
        *(void *)(v31 + 8 * prime) = v11;
        if (!*v20) {
          goto LABEL_80;
        }
        unint64_t v33 = *(void *)(*v20 + 8);
        if ((v12 & (v12 - 1)) != 0)
        {
          if (v33 >= v12) {
            v33 %= v12;
          }
        }
        else
        {
          v33 &= v12 - 1;
        }
        uint64_t v32 = (void *)(*(void *)a1 + 8 * v33);
      }
      *uint64_t v32 = v20;
LABEL_80:
      ++*(void *)(a1 + 24);
LABEL_81:
      uint64_t v10 = (uint64_t *)*v10;
    }
    while (v10);
  }
  return a1;
}

{
  size_t prime;
  int8x8_t v5;
  BOOL v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t v9;
  float *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  unint64_t prime = *(void *)(a2 + 8);
  if (prime == 1)
  {
    unint64_t prime = 2;
LABEL_17:
    std::__hash_table<std::__hash_value_type<char const*,DebugChapterInfo>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,DebugChapterInfo>,std::hash<char const*>,std::equal_to<char const*>,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,DebugChapterInfo>,std::equal_to<char const*>,std::hash<char const*>,true>,std::allocator<std::__hash_value_type<char const*,DebugChapterInfo>>>::__do_rehash<true>(a1, prime);
    goto LABEL_18;
  }
  if ((prime & (prime - 1)) != 0)
  {
    unint64_t prime = std::__next_prime(*(void *)(a2 + 8));
    int8x8_t v5 = *(int8x8_t *)(a1 + 8);
    BOOL v6 = prime >= *(void *)&v5;
    if (prime > *(void *)&v5) {
      goto LABEL_17;
    }
  }
  else
  {
    int8x8_t v5 = 0;
    BOOL v6 = 1;
    if (prime) {
      goto LABEL_17;
    }
  }
  if (!v6)
  {
    unint64_t v7 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(void *)&v5 < 3uLL || (uint8x8_t v8 = (uint8x8_t)vcnt_s8(v5), v8.i16[0] = vaddlv_u8(v8), v8.u32[0] > 1uLL))
    {
      unint64_t v7 = std::__next_prime(v7);
    }
    else
    {
      uint64_t v9 = 1 << -(char)__clz(v7 - 1);
      if (v7 >= 2) {
        unint64_t v7 = v9;
      }
    }
    if (prime <= v7) {
      unint64_t prime = v7;
    }
    if (prime < *(void *)&v5) {
      goto LABEL_17;
    }
  }
LABEL_18:
  for (uint64_t i = *(float **)(a2 + 16); i; uint64_t i = *(float **)i)
    std::__hash_table<std::__hash_value_type<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::__unordered_map_hasher<float,std::__hash_value_type<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::hash<float>,std::equal_to<float>,true>,std::__unordered_map_equal<float,std::__hash_value_type<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::equal_to<float>,std::hash<float>,true>,std::allocator<std::__hash_value_type<float,geo::Color<float,3,(geo::ColorSpace)0>>>>::__emplace_unique_key_args<float,std::pair<float const,geo::Color<float,3,(geo::ColorSpace)0>> const&>(a1, i + 4, (uint64_t)(i + 4));
  return a1;
}

void sub_1A1ABD8D8(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A1ABDA1C(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

void sub_1A1ABDA30(_Unwind_Exception *a1)
{
  std::unordered_set<md::MuninJunction const*>::~unordered_set[abi:nn180100](v1);
  _Unwind_Resume(a1);
}

float *std::__hash_table<std::__hash_value_type<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::__unordered_map_hasher<float,std::__hash_value_type<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::hash<float>,std::equal_to<float>,true>,std::__unordered_map_equal<float,std::__hash_value_type<float,geo::Color<float,3,(geo::ColorSpace)0>>,std::equal_to<float>,std::hash<float>,true>,std::allocator<std::__hash_value_type<float,geo::Color<float,3,(geo::ColorSpace)0>>>>::__emplace_unique_key_args<float,std::pair<float const,geo::Color<float,3,(geo::ColorSpace)0>> const&>(uint64_t a1, float *a2, uint64_t a3)
{
  float v6 = *a2;
  if (*a2 == 0.0) {
    unint64_t v7 = 0;
  }
  else {
    unint64_t v7 = *(unsigned int *)a2;
  }
  unint64_t v8 = *(void *)(a1 + 8);
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v3 = v7;
      if (v7 >= v8) {
        unint64_t v3 = v7 % v8;
      }
    }
    else
    {
      unint64_t v3 = v7 & (v8 + 0xFFFFFFFF);
    }
    uint64_t v10 = *(float ***)(*(void *)a1 + 8 * v3);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v13 = *((void *)v11 + 1);
            if (v13 == v7)
            {
              if (v11[4] == v6) {
                return v11;
              }
            }
            else if ((v13 & (v8 - 1)) != v3)
            {
              goto LABEL_26;
            }
            uint64_t v11 = *(float **)v11;
            if (!v11) {
              goto LABEL_26;
            }
          }
        }
        do
        {
          unint64_t v12 = *((void *)v11 + 1);
          if (v12 == v7)
          {
            if (v11[4] == v6) {
              return v11;
            }
          }
          else
          {
            if (v12 >= v8) {
              v12 %= v8;
            }
            if (v12 != v3) {
              break;
            }
          }
          uint64_t v11 = *(float **)v11;
        }
        while (v11);
      }
    }
  }
LABEL_26:
  uint8x8_t v15 = operator new(0x20uLL);
  *uint8x8_t v15 = 0;
  v15[1] = v7;
  *((_DWORD *)v15 + 4) = *(_DWORD *)a3;
  *(void *)((char *)v15 + 20) = *(void *)(a3 + 4);
  *((_DWORD *)v15 + 7) = *(_DWORD *)(a3 + 12);
  float v16 = (float)(unint64_t)(*(void *)(a1 + 24) + 1);
  float v17 = *(float *)(a1 + 32);
  if (v8 && (float)(v17 * (float)v8) >= v16)
  {
    uint64_t v18 = *(void *)a1;
    uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
    if (v19)
    {
LABEL_29:
      *uint8x8_t v15 = *v19;
LABEL_64:
      *uint64_t v19 = v15;
      goto LABEL_65;
    }
  }
  else
  {
    BOOL v20 = 1;
    if (v8 >= 3) {
      BOOL v20 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v21 = v20 | (2 * v8);
    unint64_t v22 = vcvtps_u32_f32(v16 / v17);
    if (v21 <= v22) {
      size_t prime = v22;
    }
    else {
      size_t prime = v21;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v8 = *(void *)(a1 + 8);
    }
    if (prime > v8) {
      goto LABEL_40;
    }
    if (prime < v8)
    {
      unint64_t v24 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
      if (v8 < 3 || (uint8x8_t v25 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v25.i16[0] = vaddlv_u8(v25), v25.u32[0] > 1uLL))
      {
        unint64_t v24 = std::__next_prime(v24);
      }
      else
      {
        uint64_t v26 = 1 << -(char)__clz(v24 - 1);
        if (v24 >= 2) {
          unint64_t v24 = v26;
        }
      }
      if (prime <= v24) {
        size_t prime = v24;
      }
      if (prime < v8) {
LABEL_40:
      }
        std::__hash_table<std::__hash_value_type<char const*,DebugChapterInfo>,std::__unordered_map_hasher<char const*,std::__hash_value_type<char const*,DebugChapterInfo>,std::hash<char const*>,std::equal_to<char const*>,true>,std::__unordered_map_equal<char const*,std::__hash_value_type<char const*,DebugChapterInfo>,std::equal_to<char const*>,std::hash<char const*>,true>,std::allocator<std::__hash_value_type<char const*,DebugChapterInfo>>>::__do_rehash<true>(a1, prime);
    }
    unint64_t v8 = *(void *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
      {
        unint64_t v3 = v7 % v8;
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = *(void **)(*(void *)a1 + 8 * (v7 % v8));
        if (v19) {
          goto LABEL_29;
        }
      }
      else
      {
        unint64_t v3 = v7;
        uint64_t v18 = *(void *)a1;
        uint64_t v19 = *(void **)(*(void *)a1 + 8 * v7);
        if (v19) {
          goto LABEL_29;
        }
      }
    }
    else
    {
      unint64_t v3 = (v8 - 1) & v7;
      uint64_t v18 = *(void *)a1;
      uint64_t v19 = *(void **)(*(void *)a1 + 8 * v3);
      if (v19) {
        goto LABEL_29;
      }
    }
  }
  *uint8x8_t v15 = *(void *)(a1 + 16);
  *(void *)(a1 + 16) = v15;
  *(void *)(v18 + 8 * v3) = a1 + 16;
  if (*v15)
  {
    unint64_t v27 = *(void *)(*v15 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v27 >= v8) {
        v27 %= v8;
      }
    }
    else
    {
      v27 &= v8 - 1;
    }
    uint64_t v19 = (void *)(*(void *)a1 + 8 * v27);
    goto LABEL_64;
  }
LABEL_65:
  ++*(void *)(a1 + 24);
  return (float *)v15;
}

void sub_1A1ABDD78(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void md::NavigationLogic::runBeforeLayout(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t v8 = *a3;
  uint64_t v7 = a3[1];
  uint64_t v9 = a3[3];
  *(unsigned char *)a4 = *(unsigned char *)(*a3 + 84) == 3;
  objc_storeStrong((id *)(a4 + 40), *(id *)(a1 + 184));
  objc_storeStrong((id *)(a4 + 48), *(id *)(a1 + 160));
  *(_DWORD *)(a4 + 56) = *(_DWORD *)(a1 + 120);
  long long v10 = *(_OWORD *)(a1 + 128);
  *(void *)(a4 + 80) = *(void *)(a1 + 144);
  *(_OWORD *)(a4 + 64) = v10;
  *(void *)(a4 + 24) = 0xBFF0000000000000;
  *(void *)(a4 + 12) = *(void *)(a1 + 208);
  int v11 = *(unsigned __int8 *)(v8 + 96);
  if (*(unsigned __int8 *)(a1 + 224) != v11)
  {
    *(unsigned char *)(a1 + 224) = v11;
    md::NavigationLogic::_updatePolygonSelection((md::NavigationLogic *)a1);
  }
  if (*(unsigned char *)a4 || *(unsigned char *)(v8 + 84) == 7)
  {
    if (v9 && (unint64_t v12 = *(void **)(v9 + 184)) != 0)
    {
      id v13 = v12;
      unint64_t v14 = [v13 routeMatch];
      LODWORD(v15) = [v14 legIndex];
    }
    else
    {
      *(void *)(a4 + 4) = *(void *)(a1 + 200);
      id v16 = *(id *)(a1 + 184);
      id v13 = v16;
      if (!v16
        || ([v16 routeInfo],
            float v17 = objc_claimAutoreleasedReturnValue(),
            [v17 route],
            uint64_t v18 = objc_claimAutoreleasedReturnValue(),
            v18,
            v17,
            !v18))
      {
LABEL_20:

        if (!*(unsigned char *)v7) {
          goto LABEL_21;
        }
        goto LABEL_23;
      }
      uint64_t v19 = [v13 routeInfo];
      unint64_t v14 = [v19 route];

      LODWORD(v19) = *(_DWORD *)(a1 + 200);
      if (v19 >= [v14 pointCount]
        || (uint64_t v15 = objc_msgSend(v14, "legIndexForStepIndex:", objc_msgSend(v14, "stepIndexForPointIndex:", *(unsigned int *)(a1 + 200))), v15 == 0x7FFFFFFFFFFFFFFFLL))
      {
LABEL_19:

        goto LABEL_20;
      }
    }
    if (!*(unsigned char *)(a4 + 32)) {
      *(unsigned char *)(a4 + 32) = 1;
    }
    *(_DWORD *)(a4 + 36) = v15;
    goto LABEL_19;
  }
  if (!*(unsigned char *)(a4 + 32)) {
    *(unsigned char *)(a4 + 32) = 1;
  }
  *(_DWORD *)(a4 + 36) = 0;
  *(void *)(a4 + 4) = *MEMORY[0x1E4F64198];
  if (!*(unsigned char *)v7)
  {
LABEL_21:
    unsigned int v20 = *(_DWORD *)(v8 + 88);
    float v21 = 0.0;
    if (v20 > 0xA || ((1 << v20) & 0x418) == 0) {
      goto LABEL_27;
    }
  }
LABEL_23:
  md::LayoutContext::zoomAtCentrePoint(*(int8x8_t **)(a2 + 8));
  float v23 = fmaxf((float)(v22 * -0.28571) + 4.8571, 0.0);
  float v24 = 1.0811 - v23;
  BOOL v25 = v23 <= 1.0;
  float v26 = 0.081081;
  if (v25) {
    float v26 = v24;
  }
  float v21 = (float)(fminf(*(float *)(v7 + 16), 1.0) * 1.6216) / v26;
LABEL_27:
  *(float *)(a4 + 88) = v21;
  if (*(void *)(a4 + 128))
  {
    unint64_t v27 = *(void **)(a4 + 120);
    if (v27)
    {
      do
      {
        unint64_t v28 = (void *)*v27;
        operator delete(v27);
        unint64_t v27 = v28;
      }
      while (v28);
    }
    *(void *)(a4 + 120) = 0;
    uint64_t v29 = *(void *)(a4 + 112);
    if (v29)
    {
      for (uint64_t i = 0; i != v29; ++i)
        *(void *)(*(void *)(a4 + 104) + 8 * i) = 0;
    }
    *(void *)(a4 + 128) = 0;
  }
  uint64_t v31 = *(void *)(a4 + 104);
  *(void *)(a4 + 104) = 0;
  uint64_t v32 = *(void *)(a1 + 248);
  *(void *)(a1 + 248) = 0;
  unint64_t v33 = *(void **)(a4 + 104);
  *(void *)(a4 + 104) = v32;
  if (v33) {
    operator delete(v33);
  }
  uint64_t v34 = *(void **)(a1 + 248);
  *(void *)(a1 + 248) = v31;
  if (v34) {
    operator delete(v34);
  }
  uint64_t v35 = *(void *)(a4 + 120);
  uint64_t v36 = *(void *)(a4 + 112);
  *(void *)(a4 + 112) = *(void *)(a1 + 256);
  *(void *)(a1 + 256) = v36;
  *(void *)(a4 + 120) = *(void *)(a1 + 264);
  *(void *)(a1 + 264) = v35;
  uint64_t v37 = *(void *)(a4 + 128);
  *(void *)(a4 + 128) = *(void *)(a1 + 272);
  *(void *)(a1 + 272) = v37;
  int v38 = *(_DWORD *)(a4 + 136);
  *(_DWORD *)(a4 + 136) = *(_DWORD *)(a1 + 280);
  *(_DWORD *)(a1 + 280) = v38;
  if (*(void *)(a4 + 128))
  {
    unint64_t v39 = *(void *)(a4 + 112);
    unint64_t v40 = *(void *)(*(void *)(a4 + 120) + 8);
    if ((v39 & (v39 - 1)) != 0)
    {
      if (v40 >= v39) {
        v40 %= v39;
      }
    }
    else
    {
      v40 &= v39 - 1;
    }
    *(void *)(*(void *)(a4 + 104) + 8 * v40) = a4 + 120;
  }
  if (v37)
  {
    unint64_t v41 = *(void *)(a1 + 256);
    unint64_t v42 = *(void *)(*(void *)(a1 + 264) + 8);
    if ((v41 & (v41 - 1)) != 0)
    {
      if (v42 >= v41) {
        v42 %= v41;
      }
    }
    else
    {
      v42 &= v41 - 1;
    }
    *(void *)(*(void *)(a1 + 248) + 8 * v42) = a1 + 264;
  }
  id v43 = *(id *)(a1 + 296);
  size_t v44 = v43;
  if (v43 && ([v43 currentSnappedSegment], v77))
  {
    float v46 = *(float *)(v7 + 16);
    float v45 = *(float *)(v7 + 20);
    [v44 currentSnappedSegment];
    [v44 currentSnappedSegment];
    double v47 = (float)(v46 * v45);
    double v48 = *(double *)(a1 + 128);
    long double v49 = cos(v48 + v48) * -559.82 + 111132.92;
    long double v50 = v49 + cos(v48 * 4.0) * 1.175;
    long double v51 = v50 + cos(v48 * 6.0) * -0.0023;
    double v52 = v48 * 0.5;
    long double v53 = tan(v48 * 0.5 + 0.78103484);
    double v54 = log(v53);
    long double v55 = tan(v52 + 0.789761487);
    long double v56 = (v76 - v73) * v47 * fabs((log(v55) - v54) * 0.159154943) / v51;
    double v57 = 1.0 / sqrt((v74 - v71) * (v74 - v71) + (v75 - v72) * (v75 - v72) + v56 * v56);
    double v58 = v57 * (v74 - v71);
    double v59 = v57 * (v75 - v72);
    long double v60 = v57 * v56;
    double v61 = 1.0 / sqrt(v59 * v59 + v58 * v58);
    double v62 = v61 * v59;
    double v63 = -(v58 * v61);
    long double v64 = v63 * v60;
    long double v65 = -(v60 * v62);
    double v66 = -(v63 * v58 - v62 * v59);
    double v67 = 1.0 / sqrt(v64 * v64 + v65 * v65 + v66 * v66);
    double v68 = v67 * v64;
    double v69 = v67 * v65;
    double v70 = v67 * v66;
    if (v70 <= 0.860000014)
    {
      double v68 = 0.0;
      double v69 = 0.0;
      double v70 = 1.0;
    }
    *(double *)(a4 + 144) = v68;
    *(double *)(a4 + 152) = v69;
    *(double *)(a4 + 160) = v70;
  }
  else
  {
    *(void *)(a4 + 144) = 0;
    *(void *)(a4 + 152) = 0;
    *(void *)(a4 + 160) = 0x3FF0000000000000;
  }
  *(unsigned char *)(a4 + 168) = *(unsigned char *)(a1 + 240);
}

void sub_1A1ABE334(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1A1ABE374(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t md::Logic<md::VenueLogic,md::VenueLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::SceneContext>,gdc::TypeList<>>>::_runBeforeLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x4927EB92E562CC46)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::ElevationContext,md::SceneContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 144))(v5, a2, v6, v3);
    }
  }
  return result;
}

uint64_t md::Logic<md::VenueLogic,md::VenueLogicContext,md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::SceneContext>,gdc::TypeList<>>>::_runAfterLayout(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 8) == 0x4927EB92E562CC46)
  {
    uint64_t v3 = *(void *)(a3 + 32);
    if (v3)
    {
      uint64_t v5 = result;
      md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::ElevationContext,md::SceneContext>(v6, **(void **)(a2 + 8), *(void *)(*(void *)(a2 + 8) + 8));
      return (*(uint64_t (**)(uint64_t, uint64_t, void *, uint64_t))(*(void *)v5 + 152))(v5, a2, v6, v3);
    }
  }
  return result;
}

void *md::LogicDependencies<gdc::TypeList<md::CameraContext,md::ElevationContext,md::SceneContext>,gdc::TypeList<>>::buildRequiredTuple<md::CameraContext,md::ElevationContext,md::SceneContext>(void *result, uint64_t a2, unint64_t a3)
{
  if (!a3)
  {
    uint64_t v5 = 0;
    uint64_t v6 = 0;
    goto LABEL_71;
  }
  uint8x8_t v3 = (uint8x8_t)vcnt_s8((int8x8_t)a3);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    uint64_t v4 = 0x1AF456233693CD46;
    if (a3 <= 0x1AF456233693CD46) {
      uint64_t v4 = 0x1AF456233693CD46 % a3;
    }
  }
  else
  {
    uint64_t v4 = (a3 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v7 = *(void **)(a2 + 8 * v4);
  if (!v7) {
    goto LABEL_25;
  }
  uint64_t v8 = (void *)*v7;
  if (!v8) {
    goto LABEL_25;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v10 = v8[1];
      if (v10 == 0x1AF456233693CD46)
      {
        if (v8[2] == 0x1AF456233693CD46) {
          goto LABEL_23;
        }
      }
      else if ((v10 & (a3 - 1)) != v4)
      {
        goto LABEL_25;
      }
      uint64_t v8 = (void *)*v8;
      if (!v8) {
        goto LABEL_25;
      }
    }
  }
  while (1)
  {
    unint64_t v9 = v8[1];
    if (v9 == 0x1AF456233693CD46) {
      break;
    }
    if (v9 >= a3) {
      v9 %= a3;
    }
    if (v9 != v4) {
      goto LABEL_25;
    }
LABEL_12:
    uint64_t v8 = (void *)*v8;
    if (!v8) {
      goto LABEL_25;
    }
  }
  if (v8[2] != 0x1AF456233693CD46) {
    goto LABEL_12;
  }
LABEL_23:
  uint64_t v11 = v8[5];
  if (*(void *)(v11 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v6 = *(void *)(v11 + 32);
    goto LABEL_26;
  }
LABEL_25:
  uint64_t v6 = 0;
LABEL_26:
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v12 = 0x8BD499FBD96FBB9ELL;
    if (a3 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v12 = 0x8BD499FBD96FBB9ELL % a3;
    }
  }
  else
  {
    unint64_t v12 = (a3 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  id v13 = *(void **)(a2 + 8 * v12);
  if (!v13) {
    goto LABEL_48;
  }
  unint64_t v14 = (void *)*v13;
  if (!v14) {
    goto LABEL_48;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v16 = v14[1];
      if (v16 == 0x8BD499FBD96FBB9ELL)
      {
        if (v14[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_46;
        }
      }
      else if ((v16 & (a3 - 1)) != v12)
      {
        goto LABEL_48;
      }
      unint64_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_48;
      }
    }
  }
  while (2)
  {
    unint64_t v15 = v14[1];
    if (v15 != 0x8BD499FBD96FBB9ELL)
    {
      if (v15 >= a3) {
        v15 %= a3;
      }
      if (v15 != v12) {
        goto LABEL_48;
      }
      goto LABEL_35;
    }
    if (v14[2] != 0x8BD499FBD96FBB9ELL)
    {
LABEL_35:
      unint64_t v14 = (void *)*v14;
      if (!v14) {
        goto LABEL_48;
      }
      continue;
    }
    break;
  }
LABEL_46:
  uint64_t v17 = v14[5];
  if (*(void *)(v17 + 8) == 0x8BD499FBD96FBB9ELL)
  {
    uint64_t v5 = *(void *)(v17 + 32);
    goto LABEL_49;
  }
LABEL_48:
  uint64_t v5 = 0;
LABEL_49:
  if (v3.u32[0] > 1uLL)
  {
    unint64_t v18 = 0x99BED48DEFBBD82BLL;
    if (a3 <= 0x99BED48DEFBBD82BLL) {
      unint64_t v18 = 0x99BED48DEFBBD82BLL % a3;
    }
  }
  else
  {
    unint64_t v18 = (a3 - 1) & 0x99BED48DEFBBD82BLL;
  }
  uint64_t v19 = *(void **)(a2 + 8 * v18);
  if (!v19) {
    goto LABEL_71;
  }
  unsigned int v20 = (void *)*v19;
  if (!v20) {
    goto LABEL_71;
  }
  if (v3.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v22 = v20[1];
      if (v22 == 0x99BED48DEFBBD82BLL)
      {
        if (v20[2] == 0x99BED48DEFBBD82BLL) {
          goto LABEL_69;
        }
      }
      else if ((v22 & (a3 - 1)) != v18)
      {
        goto LABEL_71;
      }
      unsigned int v20 = (void *)*v20;
      if (!v20) {
        goto LABEL_71;
      }
    }
  }
  while (1)
  {
    unint64_t v21 = v20[1];
    if (v21 == 0x99BED48DEFBBD82BLL) {
      break;
    }
    if (v21 >= a3) {
      v21 %= a3;
    }
    if (v21 != v18) {
      goto LABEL_71;
    }
LABEL_58:
    unsigned int v20 = (void *)*v20;
    if (!v20) {
      goto LABEL_71;
    }
  }
  if (v20[2] != 0x99BED48DEFBBD82BLL) {
    goto LABEL_58;
  }
LABEL_69:
  uint64_t v23 = v20[5];
  if (*(void *)(v23 + 8) != 0x99BED48DEFBBD82BLL)
  {
LABEL_71:
    uint64_t v24 = 0;
    goto LABEL_72;
  }
  uint64_t v24 = *(void *)(v23 + 32);
LABEL_72:
  void *result = v6;
  result[1] = v5;
  result[2] = v24;
  return result;
}

void md::VenueLogic::runBeforeLayout(uint64_t a1, int8x8_t **a2, uint64_t *a3, uint64_t a4)
{
  uint64_t v321 = a4;
  uint64_t v370 = *MEMORY[0x1E4F143B8];
  v366[0] = &unk_1EF56D6C8;
  v366[1] = a2;
  v364[0] = &unk_1EF56D710;
  v364[1] = a2;
  uint64_t v365 = v364;
  uint64_t v369 = v368;
  uint64_t v367 = v366;
  v368[0] = &unk_1EF56D710;
  v368[1] = a2;
  _ZNSt3__110__function6__funcIZN2md10VenueLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17VenueLogicContextEE3__0NS_9allocatorISL_EEFvvEEclEv((uint64_t)v366);
  if (v365 == v364)
  {
    (*(void (**)(void *))(v364[0] + 32))(v364);
  }
  else if (v365)
  {
    (*(void (**)(void *))(*v365 + 40))(v365);
  }
  if (v367 == v366)
  {
    (*(void (**)(void *))(v366[0] + 32))(v366);
  }
  else if (v367)
  {
    (*(void (**)(void *))(*v367 + 40))(v367);
  }
  uint64_t v6 = *a3;
  uint64_t v323 = a3[1];
  uint64_t v7 = *(void *)a3[2];
  {
    qword_1EB3176C0 = 0;
    qword_1EB3176B8 = 0;
    md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet = (uint64_t)&qword_1EB3176B8;
    __cxa_atexit((void (*)(void *))std::set<gdc::LayerDataWithWorld>::~set[abi:nn180100], &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet, &dword_1A1780000);
  }
  uint64_t v8 = *(_WORD **)(v7 + 48);
  unint64_t v9 = *(_WORD **)(v7 + 56);
  uint64_t v10 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
  if (v8 != v9)
  {
    uint64_t v11 = *(_WORD **)(v7 + 48);
    while (*v11 != 6)
    {
      v11 += 16;
      if (v11 == v9) {
        goto LABEL_21;
      }
    }
    if (v11 == v9)
    {
      uint64_t v10 = &md::SceneStateManager::layerDataInView(unsigned short)const::kEmptySet;
    }
    else
    {
      while (*v8 != 6)
      {
        v8 += 16;
        if (v8 == v9)
        {
          uint64_t v8 = *(_WORD **)(v7 + 56);
          break;
        }
      }
      uint64_t v10 = (uint64_t *)(v8 + 4);
    }
  }
LABEL_21:
  unint64_t v12 = *(char **)(a1 + 184);
  uint64_t v13 = *(void *)(a1 + 192);
  uint64_t v339 = a1;
  uint64_t v330 = v6;
  if ((char *)v13 != v12)
  {
    do
    {
      unint64_t v14 = *(std::__shared_weak_count **)(v13 - 8);
      if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
        std::__shared_weak_count::__release_weak(v14);
      }
      v13 -= 16;
    }
    while ((char *)v13 != v12);
    uint64_t v13 = *(void *)(a1 + 184);
  }
  *(void *)(a1 + 192) = v12;
  unint64_t v15 = v10[2];
  if (v15 > (*(void *)(a1 + 200) - v13) >> 4)
  {
    if (v15 >> 60) {
LABEL_607:
    }
      abort();
    uint64_t v16 = (char *)operator new(16 * v15);
    uint64_t v17 = &v16[16 * v15];
    unint64_t v18 = &v12[(void)v16 - v13];
    if (v12 == (char *)v13)
    {
      *(void *)(a1 + 184) = v18;
      *(void *)(a1 + 192) = v18;
      *(void *)(a1 + 200) = v17;
      if (v12) {
LABEL_40:
      }
        operator delete(v12);
    }
    else
    {
      uint64_t v19 = &v12[(void)v16 - v13];
      do
      {
        long long v20 = *((_OWORD *)v12 - 1);
        v12 -= 16;
        *((_OWORD *)v19 - 1) = v20;
        v19 -= 16;
        *(void *)unint64_t v12 = 0;
        *((void *)v12 + 1) = 0;
      }
      while (v12 != (char *)v13);
      unint64_t v12 = *(char **)(a1 + 184);
      uint64_t v13 = *(void *)(a1 + 192);
      *(void *)(a1 + 184) = v19;
      *(void *)(a1 + 192) = v18;
      for (*(void *)(a1 + 200) = v17; (char *)v13 != v12; v13 -= 16)
      {
        unint64_t v21 = *(std::__shared_weak_count **)(v13 - 8);
        if (v21 && !atomic_fetch_add(&v21->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
          std::__shared_weak_count::__release_weak(v21);
        }
      }
      if (v12) {
        goto LABEL_40;
      }
    }
  }
  uint64_t v22 = (void *)*v10;
  if ((uint64_t *)*v10 != v10 + 1)
  {
    do
    {
      uint64_t v23 = v22[4];
      if (v23)
      {
        uint64_t v13 = *(void *)(v23 + 800);
        uint64_t v24 = *(_OWORD **)(v23 + 808);
        while ((_OWORD *)v13 != v24)
        {
          long long v25 = *(_OWORD *)v13;
          *(_OWORD *)uint64_t v353 = v25;
          if (*((void *)&v25 + 1)) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v25 + 1) + 8), 1uLL, memory_order_relaxed);
          }
          unint64_t v27 = *(char **)(a1 + 192);
          unint64_t v26 = *(void *)(a1 + 200);
          if ((unint64_t)v27 >= v26)
          {
            uint64_t v29 = *(char **)(a1 + 184);
            uint64_t v30 = (v27 - v29) >> 4;
            unint64_t v31 = v30 + 1;
            if ((unint64_t)(v30 + 1) >> 60) {
              abort();
            }
            long long v342 = v25;
            uint64_t v32 = v26 - (void)v29;
            if (v32 >> 3 > v31) {
              unint64_t v31 = v32 >> 3;
            }
            if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFF0) {
              unint64_t v33 = 0xFFFFFFFFFFFFFFFLL;
            }
            else {
              unint64_t v33 = v31;
            }
            if (v33 >> 60) {
LABEL_606:
            }
              std::__throw_bad_array_new_length[abi:nn180100]();
            uint64_t v34 = (char *)operator new(16 * v33);
            uint64_t v35 = &v34[16 * v30];
            *(_OWORD *)uint64_t v35 = v342;
            unint64_t v28 = v35 + 16;
            uint64_t v36 = &v34[16 * v33];
            *(_OWORD *)uint64_t v353 = 0uLL;
            if (v27 == v29)
            {
              *(void *)(v339 + 184) = v35;
              *(void *)(v339 + 192) = v28;
              *(void *)(v339 + 200) = v36;
            }
            else
            {
              do
              {
                long long v37 = *((_OWORD *)v27 - 1);
                v27 -= 16;
                *((_OWORD *)v35 - 1) = v37;
                v35 -= 16;
                *(void *)unint64_t v27 = 0;
                *((void *)v27 + 1) = 0;
              }
              while (v27 != v29);
              unint64_t v27 = *(char **)(v339 + 184);
              int v38 = *(char **)(v339 + 192);
              *(void *)(v339 + 184) = v35;
              *(void *)(v339 + 192) = v28;
              *(void *)(v339 + 200) = v36;
              while (v38 != v27)
              {
                unint64_t v39 = (std::__shared_weak_count *)*((void *)v38 - 1);
                if (v39 && !atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
                  std::__shared_weak_count::__release_weak(v39);
                }
                v38 -= 16;
              }
            }
            if (v27) {
              operator delete(v27);
            }
          }
          else
          {
            *(_OWORD *)unint64_t v27 = v25;
            *(_OWORD *)uint64_t v353 = 0uLL;
            unint64_t v28 = v27 + 16;
          }
          *(void *)(v339 + 192) = v28;
          a1 = v339;
          if (*(void *)&v353[8])
          {
            if (!atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v353[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
            {
              (*(void (**)(void))(**(void **)&v353[8] + 16))(*(void *)&v353[8]);
              std::__shared_weak_count::__release_weak(*(std::__shared_weak_count **)&v353[8]);
            }
          }
          v13 += 16;
        }
      }
      unint64_t v40 = (uint64_t *)v22[1];
      if (v40)
      {
        do
        {
          unint64_t v41 = v40;
          unint64_t v40 = (uint64_t *)*v40;
        }
        while (v40);
      }
      else
      {
        do
        {
          unint64_t v41 = (uint64_t *)v22[2];
          _ZF = *v41 == (void)v22;
          uint64_t v22 = v41;
        }
        while (!_ZF);
      }
      uint64_t v22 = v41;
    }
    while (v41 != v10 + 1);
  }
  unint64_t v42 = *(unint64_t ***)(a1 + 184);
  uint64_t v325 = *(unint64_t ***)(a1 + 192);
  uint64_t v43 = v330;
  if (v42 != v325)
  {
    uint64_t v329 = a1 + 288;
    float v326 = (void *)(a1 + 224);
    uint64_t v327 = (uint64_t *)(a1 + 208);
    uint64_t v340 = (void *)(a1 + 616);
    while (1)
    {
      size_t v44 = v42;
      float v45 = *v42;
      unint64_t v46 = *v45;
      *(void *)uint64_t v346 = *v45;
      *(void *)&v346[8] = v45;
      uint64_t v328 = v44;
      double v47 = (std::__shared_weak_count *)v44[1];
      *(void *)&v346[16] = v47;
      if (v47) {
        atomic_fetch_add_explicit(&v47->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      unint64_t v48 = *(void *)(v339 + 216);
      if (!v48) {
        break;
      }
      uint8x8_t v49 = (uint8x8_t)vcnt_s8((int8x8_t)v48);
      v49.i16[0] = vaddlv_u8(v49);
      if (v49.u32[0] > 1uLL)
      {
        uint64_t v13 = v46;
        if (v46 >= v48) {
          uint64_t v13 = v46 % v48;
        }
      }
      else
      {
        uint64_t v13 = (v48 - 1) & v46;
      }
      long double v50 = *(void **)(*v327 + 8 * v13);
      if (!v50) {
        break;
      }
      long double v51 = (void *)*v50;
      if (!v51) {
        break;
      }
      if (v49.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v53 = v51[1];
          if (v53 == v46)
          {
            if (v51[2] == v46) {
              goto LABEL_123;
            }
          }
          else if ((v53 & (v48 - 1)) != v13)
          {
            goto LABEL_104;
          }
          long double v51 = (void *)*v51;
          if (!v51) {
            goto LABEL_104;
          }
        }
      }
      while (1)
      {
        unint64_t v52 = v51[1];
        if (v52 == v46) {
          break;
        }
        if (v52 >= v48) {
          v52 %= v48;
        }
        if (v52 != v13) {
          goto LABEL_104;
        }
LABEL_94:
        long double v51 = (void *)*v51;
        if (!v51) {
          goto LABEL_104;
        }
      }
      if (v51[2] != v46) {
        goto LABEL_94;
      }
LABEL_123:
      a1 = v339;
      if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
        std::__shared_weak_count::__release_weak(v47);
      }
LABEL_145:
      double v67 = (void *)(*v328)[2];
      uint64_t v331 = (void *)(*v328)[3];
      if (v67 != v331)
      {
        do
        {
          std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__emplace_unique_key_args<unsigned long long,unsigned long long>(v329, v67[4], v67[4]);
          uint64_t v68 = *v67;
          uint64_t v69 = v67[1];
          uint64_t v332 = v67;
          uint64_t v333 = v69;
          while (v68 != v69)
          {
            uint64_t v335 = v68;
            double v71 = *(void **)(v68 + 144);
            double v70 = *(void **)(v68 + 152);
            unint64_t v343 = v70;
            while (v71 != v70)
            {
              double v73 = (char *)v71[2];
              double v72 = (char *)v71[3];
              if (v72 == v73) {
                goto LABEL_152;
              }
              unint64_t v74 = v71[1];
              if (!v74) {
                goto LABEL_152;
              }
              unint64_t v75 = *(void *)(a1 + 608);
              if (v75)
              {
                uint8x8_t v76 = (uint8x8_t)vcnt_s8((int8x8_t)v75);
                v76.i16[0] = vaddlv_u8(v76);
                if (v76.u32[0] > 1uLL)
                {
                  uint64_t v13 = v71[1];
                  if (v74 >= v75) {
                    uint64_t v13 = v74 % v75;
                  }
                }
                else
                {
                  uint64_t v13 = (v75 - 1) & v74;
                }
                char v77 = *(void ***)(*(void *)(a1 + 600) + 8 * v13);
                if (v77)
                {
                  id v78 = *v77;
                  if (*v77)
                  {
                    if (v76.u32[0] < 2uLL)
                    {
                      while (1)
                      {
                        uint64_t v80 = *((void *)v78 + 1);
                        if (v80 == v74)
                        {
                          if (*((void *)v78 + 2) == v74) {
                            goto LABEL_236;
                          }
                        }
                        else if ((v80 & (v75 - 1)) != v13)
                        {
                          goto LABEL_176;
                        }
                        id v78 = *(void **)v78;
                        if (!v78) {
                          goto LABEL_176;
                        }
                      }
                    }
                    do
                    {
                      unint64_t v79 = *((void *)v78 + 1);
                      if (v79 == v74)
                      {
                        if (*((void *)v78 + 2) == v74) {
                          goto LABEL_236;
                        }
                      }
                      else
                      {
                        if (v79 >= v75) {
                          v79 %= v75;
                        }
                        if (v79 != v13) {
                          break;
                        }
                      }
                      id v78 = *(void **)v78;
                    }
                    while (v78);
                  }
                }
              }
LABEL_176:
              id v78 = operator new(0x30uLL);
              *(void *)uint64_t v353 = v78;
              *(void *)&v353[8] = v340;
              *(void *)id v78 = 0;
              *((void *)v78 + 1) = v74;
              *((void *)v78 + 2) = v74;
              *((void *)v78 + 3) = 0;
              *((void *)v78 + 4) = 0;
              *((void *)v78 + 5) = 0;
              v353[16] = 1;
              float v81 = (float)(unint64_t)(*(void *)(a1 + 624) + 1);
              float v82 = *(float *)(a1 + 632);
              if (!v75 || (float)(v82 * (float)v75) < v81)
              {
                BOOL v83 = (v75 & (v75 - 1)) != 0;
                if (v75 < 3) {
                  BOOL v83 = 1;
                }
                unint64_t v84 = v83 | (2 * v75);
                unint64_t v85 = vcvtps_u32_f32(v81 / v82);
                if (v84 <= v85) {
                  size_t prime = v85;
                }
                else {
                  size_t prime = v84;
                }
                if (prime == 1)
                {
                  size_t prime = 2;
                }
                else if ((prime & (prime - 1)) != 0)
                {
                  size_t prime = std::__next_prime(prime);
                  unint64_t v75 = *(void *)(a1 + 608);
                }
                if (prime <= v75)
                {
                  if (prime < v75)
                  {
                    unint64_t v98 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 624) / *(float *)(a1 + 632));
                    if (v75 < 3
                      || (uint8x8_t v99 = (uint8x8_t)vcnt_s8((int8x8_t)v75), v99.i16[0] = vaddlv_u8(v99), v99.u32[0] > 1uLL))
                    {
                      unint64_t v98 = std::__next_prime(v98);
                    }
                    else
                    {
                      uint64_t v100 = 1 << -(char)__clz(v98 - 1);
                      if (v98 >= 2) {
                        unint64_t v98 = v100;
                      }
                    }
                    if (prime <= v98) {
                      size_t prime = v98;
                    }
                    if (prime >= v75)
                    {
                      unint64_t v75 = *(void *)(a1 + 608);
                    }
                    else
                    {
                      if (prime) {
                        goto LABEL_188;
                      }
                      int64x2_t v160 = *(void **)(a1 + 600);
                      *(void *)(a1 + 600) = 0;
                      if (v160) {
                        operator delete(v160);
                      }
                      unint64_t v75 = 0;
                      *(void *)(a1 + 608) = 0;
                    }
                  }
LABEL_213:
                  if ((v75 & (v75 - 1)) != 0)
                  {
                    if (v74 >= v75) {
                      uint64_t v13 = v74 % v75;
                    }
                    else {
                      uint64_t v13 = v74;
                    }
                  }
                  else
                  {
                    uint64_t v13 = (v75 - 1) & v74;
                  }
                  goto LABEL_226;
                }
LABEL_188:
                if (prime >> 61) {
                  goto LABEL_606;
                }
                __int16 v87 = operator new(8 * prime);
                int v88 = *(void **)(a1 + 600);
                *(void *)(a1 + 600) = v87;
                if (v88) {
                  operator delete(v88);
                }
                uint64_t v89 = 0;
                *(void *)(a1 + 608) = prime;
                do
                  *(void *)(*(void *)(a1 + 600) + 8 * v89++) = 0;
                while (prime != v89);
                id v90 = (void *)*v340;
                if (!*v340) {
                  goto LABEL_212;
                }
                size_t v91 = v90[1];
                size_t v92 = prime - 1;
                if ((prime & (prime - 1)) == 0)
                {
                  size_t v93 = v91 & v92;
                  *(void *)(*(void *)(a1 + 600) + 8 * v93) = v340;
                  for (uint64_t i = (void *)*v90; *v90; uint64_t i = (void *)*v90)
                  {
                    size_t v95 = i[1] & v92;
                    if (v95 == v93)
                    {
                      id v90 = i;
                    }
                    else
                    {
                      uint64_t v96 = *(void *)(a1 + 600);
                      if (*(void *)(v96 + 8 * v95))
                      {
                        void *v90 = *i;
                        uint64_t v97 = 8 * v95;
                        void *i = **(void **)(*(void *)(a1 + 600) + v97);
                        **(void **)(*(void *)(a1 + 600) + v97) = i;
                      }
                      else
                      {
                        *(void *)(v96 + 8 * v95) = v90;
                        id v90 = i;
                        size_t v93 = v95;
                      }
                    }
                  }
                  goto LABEL_212;
                }
                if (v91 >= prime) {
                  v91 %= prime;
                }
                *(void *)(*(void *)(a1 + 600) + 8 * v91) = v340;
                int v101 = (void *)*v90;
                if (!*v90)
                {
LABEL_212:
                  unint64_t v75 = prime;
                  goto LABEL_213;
                }
                while (2)
                {
                  size_t v103 = v101[1];
                  if (v103 >= prime) {
                    v103 %= prime;
                  }
                  if (v103 != v91)
                  {
                    uint64_t v104 = *(void *)(a1 + 600);
                    if (!*(void *)(v104 + 8 * v103))
                    {
                      *(void *)(v104 + 8 * v103) = v90;
LABEL_217:
                      id v90 = v101;
                      int v101 = (void *)*v101;
                      size_t v91 = v103;
                      if (!v101) {
                        goto LABEL_212;
                      }
                      continue;
                    }
                    void *v90 = *v101;
                    uint64_t v102 = 8 * v103;
                    *int v101 = **(void **)(*(void *)(a1 + 600) + v102);
                    **(void **)(*(void *)(a1 + 600) + v102) = v101;
                    int v101 = v90;
                  }
                  break;
                }
                size_t v103 = v91;
                goto LABEL_217;
              }
LABEL_226:
              uint64_t v105 = *(void *)(a1 + 600);
              int v106 = *(void **)(v105 + 8 * v13);
              if (v106)
              {
                *(void *)id v78 = *v106;
LABEL_234:
                *int v106 = v78;
                goto LABEL_235;
              }
              *(void *)id v78 = *v340;
              void *v340 = v78;
              *(void *)(v105 + 8 * v13) = v340;
              if (*(void *)v78)
              {
                unint64_t v107 = *(void *)(*(void *)v78 + 8);
                if ((v75 & (v75 - 1)) != 0)
                {
                  if (v107 >= v75) {
                    v107 %= v75;
                  }
                }
                else
                {
                  v107 &= v75 - 1;
                }
                int v106 = (void *)(*(void *)(a1 + 600) + 8 * v107);
                goto LABEL_234;
              }
LABEL_235:
              ++*(void *)(a1 + 624);
              double v73 = (char *)v71[2];
              double v72 = (char *)v71[3];
LABEL_236:
              uint64_t v108 = v72 - v73;
              if (v72 - v73 < 1) {
                goto LABEL_152;
              }
              uint64_t v13 = v108 >> 3;
              unint64_t v110 = *((void *)v78 + 3);
              uint64_t v109 = (char *)*((void *)v78 + 4);
              unint64_t v111 = (unint64_t)&v109[-v110];
              uint64_t v112 = (uint64_t)&v109[-v110] >> 3;
              uint64_t v113 = (char *)(v110 + ((unint64_t)&v109[-v110] & 0xFFFFFFFFFFFFFFF8));
              uint64_t v114 = *((void *)v78 + 5);
              if (v108 >> 3 > (v114 - (uint64_t)v109) >> 3)
              {
                unint64_t v115 = v112 + v13;
                if ((unint64_t)(v112 + v13) >> 61) {
                  goto LABEL_607;
                }
                uint64_t v116 = v114 - v110;
                if (v116 >> 2 > v115) {
                  unint64_t v115 = v116 >> 2;
                }
                _CF = (unint64_t)v116 >= 0x7FFFFFFFFFFFFFF8;
                unint64_t v118 = 0x1FFFFFFFFFFFFFFFLL;
                if (!_CF) {
                  unint64_t v118 = v115;
                }
                unint64_t v337 = v118;
                if (v118)
                {
                  if (v118 >> 61) {
                    goto LABEL_606;
                  }
                  uint64_t v119 = operator new(8 * v118);
                  uint64_t v113 = (char *)(v110 + ((unint64_t)&v109[-v110] & 0xFFFFFFFFFFFFFFF8));
                  uint64_t v112 = (uint64_t)&v109[-v110] >> 3;
                }
                else
                {
                  uint64_t v119 = 0;
                }
                uint64_t v134 = &v119[8 * v112];
                uint64_t v135 = &v134[8 * v13];
                if ((unint64_t)(v108 - 8) >= 0x38)
                {
                  if ((unint64_t)(&v119[v111 & 0xFFFFFFFFFFFFFFF8] - v73) >= 0x20)
                  {
                    unint64_t v137 = ((unint64_t)(v108 - 8) >> 3) + 1;
                    uint64_t v138 = 8 * (v137 & 0x3FFFFFFFFFFFFFFCLL);
                    unint64_t v136 = &v134[v138];
                    uint64_t v139 = (long long *)(v73 + 16);
                    uint64_t v140 = &v119[8 * v112 + 16];
                    uint64_t v141 = v137 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v142 = *v139;
                      *(v140 - 1) = *(v139 - 1);
                      *uint64_t v140 = v142;
                      v139 += 2;
                      v140 += 2;
                      v141 -= 4;
                    }
                    while (v141);
                    if (v137 == (v137 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_268:
                      if ((char *)v110 != v109)
                      {
                        if (v111 - 8 >= 0x68)
                        {
                          uint64_t v144 = v113;
                          if (v110
                             + (v111 & 0xFFFFFFFFFFFFFFF8)
                             - (unint64_t)&v119[v111 & 0xFFFFFFFFFFFFFFF8] >= 0x20)
                          {
                            unint64_t v145 = ((v111 - 8) >> 3) + 1;
                            uint64_t v144 = &v113[-8 * (v145 & 0x3FFFFFFFFFFFFFFCLL)];
                            uint64_t v146 = (long long *)(v110 + 8 * v112 - 16);
                            unint64_t v147 = &v119[8 * v112 - 16];
                            uint64_t v148 = v145 & 0x3FFFFFFFFFFFFFFCLL;
                            do
                            {
                              long long v149 = *v146;
                              *(v147 - 1) = *(v146 - 1);
                              *unint64_t v147 = v149;
                              v146 -= 2;
                              v147 -= 2;
                              v148 -= 4;
                            }
                            while (v148);
                            v134 -= 8 * (v145 & 0x3FFFFFFFFFFFFFFCLL);
                            if (v145 == (v145 & 0x3FFFFFFFFFFFFFFCLL)) {
                              goto LABEL_276;
                            }
                          }
                        }
                        else
                        {
                          uint64_t v144 = v113;
                        }
                        do
                        {
                          uint64_t v150 = *((void *)v144 - 1);
                          v144 -= 8;
                          *((void *)v134 - 1) = v150;
                          v134 -= 8;
                        }
                        while (v144 != (char *)v110);
                      }
LABEL_276:
                      uint64_t v151 = v109 - v113;
                      if (v109 != v113)
                      {
                        uint64_t v152 = v119;
                        memmove(v135, v113, v109 - v113);
                        uint64_t v119 = v152;
                      }
                      *((void *)v78 + 3) = v134;
                      *((void *)v78 + 4) = &v135[v151];
                      *((void *)v78 + 5) = &v119[8 * v337];
                      a1 = v339;
                      if (v110) {
                        operator delete((void *)v110);
                      }
                      goto LABEL_152;
                    }
                    v73 += v138;
                  }
                  else
                  {
                    unint64_t v136 = &v119[8 * v112];
                  }
                }
                else
                {
                  unint64_t v136 = &v119[8 * v112];
                }
                do
                {
                  uint64_t v143 = *(void *)v73;
                  v73 += 8;
                  *(void *)unint64_t v136 = v143;
                  v136 += 8;
                }
                while (v136 != v135);
                goto LABEL_268;
              }
              uint64_t v120 = v109 - v113;
              uint64_t v121 = (v109 - v113) >> 3;
              if (v121 >= v13)
              {
                unint64_t v122 = &v73[8 * v13];
                uint64_t v124 = (char *)*((void *)v78 + 4);
                a1 = v339;
LABEL_253:
                uint64_t v126 = &v113[8 * v13];
                size_t v127 = v124 - v126;
                uint64_t v128 = (v124 - v126) >> 3;
                uint64_t v129 = &v124[-8 * v13];
                uint64_t v130 = v124;
                if (v129 < v109)
                {
                  unint64_t v131 = (v111 & 0xFFFFFFFFFFFFFFF8) + v127;
                  unint64_t v132 = v110 + v131 + 8;
                  if ((unint64_t)v109 > v132) {
                    unint64_t v132 = (unint64_t)v109;
                  }
                  unint64_t v133 = v132 + ~v110 - v131;
                  if (v133 > 0x57)
                  {
                    uint64_t v130 = v124;
                    if ((unint64_t)&v126[-(v111 & 0xFFFFFFFFFFFFFFF8) - v110] >= 0x20)
                    {
                      uint64_t v153 = (v133 >> 3) + 1;
                      uint64_t v154 = 8 * (v153 & 0x3FFFFFFFFFFFFFFCLL);
                      v129 += v154;
                      uint64_t v155 = v124 + 16;
                      uint64_t v156 = (long long *)(v110 + 8 * v128 + 8 * v112 + 16);
                      uint64_t v157 = v153 & 0x3FFFFFFFFFFFFFFCLL;
                      do
                      {
                        long long v158 = *v156;
                        *(v155 - 1) = *(v156 - 1);
                        _OWORD *v155 = v158;
                        v155 += 2;
                        v156 += 2;
                        v157 -= 4;
                      }
                      while (v157);
                      uint64_t v130 = &v124[v154];
                      if (v153 == (v153 & 0x3FFFFFFFFFFFFFFCLL)) {
                        goto LABEL_285;
                      }
                    }
                  }
                  else
                  {
                    uint64_t v130 = v124;
                  }
                  do
                  {
                    uint64_t v159 = *(void *)v129;
                    v129 += 8;
                    *(void *)uint64_t v130 = v159;
                    v130 += 8;
                  }
                  while (v129 < v109);
                }
LABEL_285:
                *((void *)v78 + 4) = v130;
                if (v124 != v126)
                {
                  uint64_t v13 = (uint64_t)v113;
                  memmove(&v124[-8 * v128], v113, v127);
                  uint64_t v113 = (char *)v13;
                }
                if (v122 != v73) {
                  memmove(v113, v73, v122 - v73);
                }
                goto LABEL_152;
              }
              unint64_t v122 = &v73[8 * v121];
              int64_t v123 = v72 - v122;
              if (v72 != v122)
              {
                unint64_t v334 = &v73[8 * v121];
                memmove(*((void **)v78 + 4), v334, v72 - v122);
                uint64_t v112 = (uint64_t)&v109[-v110] >> 3;
                unint64_t v122 = v334;
                uint64_t v113 = (char *)(v110 + ((unint64_t)&v109[-v110] & 0xFFFFFFFFFFFFFFF8));
              }
              uint64_t v124 = &v109[v123];
              *((void *)v78 + 4) = &v109[v123];
              BOOL v125 = v120 < 1;
              a1 = v339;
              if (!v125) {
                goto LABEL_253;
              }
LABEL_152:
              v71 += 5;
              double v70 = v343;
            }
            uint64_t v68 = v335 + 184;
            uint64_t v69 = v333;
          }
          double v67 = v332 + 15;
          uint64_t v43 = v330;
        }
        while (v332 + 15 != v331);
      }
      unint64_t v42 = v328 + 2;
      if (v328 + 2 == v325) {
        goto LABEL_298;
      }
    }
LABEL_104:
    double v54 = (char *)operator new(0x28uLL);
    *(void *)uint64_t v353 = v54;
    *(void *)&v353[8] = v326;
    *(void *)double v54 = 0;
    *((void *)v54 + 1) = v46;
    *((void *)v54 + 2) = v46;
    *(_OWORD *)(v54 + 24) = *(_OWORD *)&v346[8];
    *(void *)&v346[8] = 0;
    *(void *)&v346[16] = 0;
    v353[16] = 1;
    float v55 = (float)(unint64_t)(*(void *)(v339 + 232) + 1);
    float v56 = *(float *)(v339 + 240);
    if (!v48 || (float)(v56 * (float)v48) < v55)
    {
      BOOL v57 = (v48 & (v48 - 1)) != 0;
      if (v48 < 3) {
        BOOL v57 = 1;
      }
      unint64_t v58 = v57 | (2 * v48);
      unint64_t v59 = vcvtps_u32_f32(v55 / v56);
      if (v58 <= v59) {
        size_t v60 = v59;
      }
      else {
        size_t v60 = v58;
      }
      if (v60 == 1)
      {
        size_t v60 = 2;
      }
      else if ((v60 & (v60 - 1)) != 0)
      {
        size_t v60 = std::__next_prime(v60);
        unint64_t v48 = *(void *)(v339 + 216);
      }
      if (v60 > v48) {
        goto LABEL_116;
      }
      if (v60 < v48)
      {
        unint64_t v61 = vcvtps_u32_f32((float)*(unint64_t *)(v339 + 232) / *(float *)(v339 + 240));
        if (v48 < 3 || (uint8x8_t v62 = (uint8x8_t)vcnt_s8((int8x8_t)v48), v62.i16[0] = vaddlv_u8(v62), v62.u32[0] > 1uLL))
        {
          unint64_t v61 = std::__next_prime(v61);
        }
        else
        {
          uint64_t v63 = 1 << -(char)__clz(v61 - 1);
          if (v61 >= 2) {
            unint64_t v61 = v63;
          }
        }
        if (v60 <= v61) {
          size_t v60 = v61;
        }
        if (v60 < v48) {
LABEL_116:
        }
          std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v327, v60);
      }
      unint64_t v48 = *(void *)(v339 + 216);
      if ((v48 & (v48 - 1)) != 0)
      {
        if (v46 >= v48) {
          uint64_t v13 = v46 % v48;
        }
        else {
          uint64_t v13 = v46;
        }
      }
      else
      {
        uint64_t v13 = (v48 - 1) & v46;
      }
    }
    uint64_t v64 = *v327;
    long double v65 = *(void **)(*v327 + 8 * v13);
    a1 = v339;
    if (v65)
    {
      *(void *)double v54 = *v65;
    }
    else
    {
      *(void *)double v54 = *v326;
      *float v326 = v54;
      *(void *)(v64 + 8 * v13) = v326;
      if (!*(void *)v54)
      {
LABEL_144:
        ++*(void *)(v339 + 232);
        goto LABEL_145;
      }
      unint64_t v66 = *(void *)(*(void *)v54 + 8);
      if ((v48 & (v48 - 1)) != 0)
      {
        if (v66 >= v48) {
          v66 %= v48;
        }
      }
      else
      {
        v66 &= v48 - 1;
      }
      long double v65 = (void *)(*v327 + 8 * v66);
    }
    *long double v65 = v54;
    goto LABEL_144;
  }
LABEL_298:
  long long v344 = *(_OWORD *)(v43 + 16);
  long double v161 = tan(*(double *)(v43 + 8) * 0.5 + 0.785398163);
  long double v162 = log(v161);
  *(void *)&v163.f64[0] = v344;
  v163.f64[1] = v162;
  __asm { FMOV            V1.2D, #0.5 }
  float64x2_t v362 = vmlaq_f64(_Q1, (float64x2_t)vdupq_n_s64(0x3FC45F306DC9C883uLL), v163);
  uint64_t v167 = a2[1];
  md::LayoutContext::zoomAtCentrePoint(v167);
  if (v168 <= 17.5 || *(unsigned char *)(a1 + 688))
  {
    if (v168 >= 17.3 || !*(unsigned char *)(a1 + 688)) {
      goto LABEL_310;
    }
    *(unsigned char *)(a1 + 688) = 0;
    float v169 = 0.0;
  }
  else
  {
    *(unsigned char *)(a1 + 688) = 1;
    float v169 = 1.0;
  }
  float v170 = *(float *)(a1 + 492);
  objc_msgSend(*(id *)(a1 + 672), "stop", v321);
  uint64_t v171 = [[VKTimedAnimation alloc] initWithDuration:(float)(vabds_f32(v169, v170) * 0.3)];
  uint64_t v172 = *(void **)(a1 + 672);
  *(void *)(a1 + 672) = v171;

  uint64_t v173 = *(void **)(a1 + 672);
  *(void *)uint64_t v353 = MEMORY[0x1E4F143A8];
  *(void *)&v353[8] = 3221225472;
  *(void *)&v353[16] = ___ZN2md10VenueLogic22_runExtrusionAnimationEv_block_invoke;
  *(void *)&long long v354 = &__block_descriptor_48_e8_v12__0f8l;
  *((void *)&v354 + 1) = a1;
  unint64_t v355 = __PAIR64__(LODWORD(v169), LODWORD(v170));
  [v173 setStepHandler:v353];
  unint64_t v174 = *(void **)(a1 + 672);
  *(void *)uint64_t v346 = MEMORY[0x1E4F143A8];
  *(void *)&v346[8] = 3221225472;
  *(void *)&v346[16] = ___ZN2md10VenueLogic22_runExtrusionAnimationEv_block_invoke_2;
  *(void *)&v346[24] = &__block_descriptor_44_e8_v12__0B8l;
  *(void *)&long long v347 = a1;
  *((float *)&v347 + 2) = v169;
  [v174 setCompletionHandler:v346];
  if (*(void *)(a1 + 816))
  {
    id v175 = *(id *)(a1 + 672);
    v363[0] = v175;
    uint64_t v176 = *(void *)(a1 + 816);
    if (!v176)
    {
LABEL_613:
      std::__throw_bad_function_call[abi:nn180100]();
      __break(1u);
      return;
    }
    (*(void (**)(uint64_t, id *))(*(void *)v176 + 48))(v176, v363);

    a1 = v339;
  }
  uint64_t v167 = a2[1];
LABEL_310:
  uint64_t v177 = a1;
  uint64_t v178 = *(void *)(a1 + 568);
  uint64_t v179 = *(void *)(v177 + 576);
  int8x8_t v180 = v167[1];
  if (!*(void *)&v180) {
    goto LABEL_334;
  }
  uint8x8_t v181 = (uint8x8_t)vcnt_s8(v180);
  v181.i16[0] = vaddlv_u8(v181);
  if (v181.u32[0] > 1uLL)
  {
    unint64_t v182 = 0xC97B9E962ADF4AD4;
    if (*(void *)&v180 <= 0xC97B9E962ADF4AD4) {
      unint64_t v182 = 0xC97B9E962ADF4AD4 % *(void *)&v180;
    }
  }
  else
  {
    unint64_t v182 = (*(void *)&v180 - 1) & 0xC97B9E962ADF4AD4;
  }
  uint64_t v183 = *(void **)(*(void *)v167 + 8 * v182);
  if (!v183) {
    goto LABEL_333;
  }
  int8x8_t v184 = (void *)*v183;
  if (!v184) {
    goto LABEL_333;
  }
  if (v181.u32[0] < 2uLL)
  {
    uint64_t v185 = *(void *)&v180 - 1;
    while (1)
    {
      uint64_t v187 = v184[1];
      if (v187 == 0xC97B9E962ADF4AD4)
      {
        if (v184[2] == 0xC97B9E962ADF4AD4) {
          goto LABEL_331;
        }
      }
      else if ((v187 & v185) != v182)
      {
        goto LABEL_333;
      }
      int8x8_t v184 = (void *)*v184;
      if (!v184) {
        goto LABEL_333;
      }
    }
  }
  while (1)
  {
    unint64_t v186 = v184[1];
    if (v186 == 0xC97B9E962ADF4AD4) {
      break;
    }
    if (v186 >= *(void *)&v180) {
      v186 %= *(void *)&v180;
    }
    if (v186 != v182) {
      goto LABEL_333;
    }
LABEL_320:
    int8x8_t v184 = (void *)*v184;
    if (!v184) {
      goto LABEL_333;
    }
  }
  if (v184[2] != 0xC97B9E962ADF4AD4) {
    goto LABEL_320;
  }
LABEL_331:
  uint64_t v188 = (int8x8_t *)v184[5];
  if (*(void *)&v188[1] == 0xC97B9E962ADF4AD4)
  {
    int8x8_t v180 = v188[4];
    goto LABEL_334;
  }
LABEL_333:
  int8x8_t v180 = 0;
LABEL_334:
  LOBYTE(v189) = *(unsigned char *)v323;
  if (*(unsigned char *)v323)
  {
    uint64_t v190 = **(void **)&v180;
    uint64_t v191 = *(void *)(*(void *)&v180 + 8);
    if (v190 != v191)
    {
      while (*(unsigned char *)v190 != 21)
      {
        v190 += 16;
        if (v190 == v191) {
          goto LABEL_342;
        }
      }
    }
    if (v190 == v191)
    {
LABEL_342:
      LOBYTE(v189) = 0;
    }
    else
    {
      uint64_t v189 = *(void *)(v190 + 8);
      if (v189) {
        LOBYTE(v189) = *(unsigned __int8 *)(md::LayoutContext::frameState((md::LayoutContext *)a2) + 128)
      }
                     - 1 < 3;
    }
  }
  *(unsigned char *)(v339 + 496) = v189;
  uint64_t v192 = +[VKDebugSettings sharedSettings];
  *(unsigned char *)(v339 + 560) = [v192 daVinciShowStackingVenues];

  uint64_t v336 = v339 + 208;
  uint64_t v193 = *(void *)(v339 + 912);
  if (v193 && !(*(unsigned int (**)(uint64_t))(*(void *)v193 + 48))(v193))
  {
    uint64_t v200 = *(void *)(v339 + 568);
    *(void *)(v339 + 480) = v200;
    goto LABEL_367;
  }
  md::LayoutContext::zoomAtCentrePoint(a2[1]);
  if (v194.n128_f32[0] > 0.0 && (float)(16.0 - *(float *)(v339 + 692)) > v194.n128_f32[0])
  {
LABEL_359:
    uint64_t v195 = 0;
    uint64_t v196 = 0;
    uint64_t v201 = (void *)v339;
    *(void *)(v339 + 568) = 0;
    goto LABEL_362;
  }
  v194.n128_f64[0] = md::VenueLogicContext::venuesInProximityToWorldPoint((unint64_t *)v353, v336, &v362, v194);
  if (*(void *)&v353[8] == *(void *)v353)
  {
    if (*(void *)&v353[8]) {
      operator delete(*(void **)&v353[8]);
    }
    goto LABEL_359;
  }
  uint64_t v195 = **(void **)v353;
  operator delete(*(void **)v353);
  *(void *)(v339 + 568) = v195;
  if (v195)
  {
    uint64_t v196 = *(void *)(v195 + 16);
    uint64_t v197 = *(void *)(v195 + 24);
    if (v196 != v197)
    {
      v194.n128_f64[0] = geo::ConvexHull2<double>::distanceSquaredTo(*(float64x2_t **)(v196 + 80), *(float64x2_t **)(v196 + 88), &v362);
      uint64_t v198 = v196 + 120;
      if (v196 + 120 != v197)
      {
        double v199 = v194.n128_f64[0];
        do
        {
          v194.n128_f64[0] = geo::ConvexHull2<double>::distanceSquaredTo(*(float64x2_t **)(v198 + 80), *(float64x2_t **)(v198 + 88), &v362);
          if (v194.n128_f64[0] < v199) {
            uint64_t v196 = v198;
          }
          double v199 = fmin(v194.n128_f64[0], v199);
          v198 += 120;
        }
        while (v198 != v197);
      }
    }
  }
  else
  {
    uint64_t v196 = 0;
  }
  uint64_t v201 = (void *)v339;
LABEL_362:
  v201[72] = v196;
  v201[60] = v195;
  uint64_t v202 = v201[90];
  if (v202)
  {
    if (v178 != v195 || (uint64_t v200 = v178, v179 != v196))
    {
      *(void *)uint64_t v353 = v195;
      *(void *)uint64_t v346 = v196;
      (*(void (**)(uint64_t, unsigned char *, unsigned char *, __n128))(*(void *)v202 + 48))(v202, v353, v346, v194);
      uint64_t v200 = *(void *)(v339 + 568);
    }
  }
  else
  {
    uint64_t v200 = v195;
  }
LABEL_367:
  uint64_t v203 = *(void *)(v339 + 752);
  if (v203)
  {
    if (v178 != v200)
    {
      *(void *)uint64_t v353 = v200;
      (*(void (**)(uint64_t, unsigned char *))(*(void *)v203 + 48))(v203, v353);
      uint64_t v178 = *(void *)(v339 + 568);
    }
    if (v178)
    {
LABEL_371:
      double v204 = sqrt(geo::ConvexHull2<double>::distanceSquaredTo(*(float64x2_t **)(v178 + 64), *(float64x2_t **)(v178 + 72), &v362));
      goto LABEL_374;
    }
  }
  else
  {
    uint64_t v178 = v200;
    if (v200) {
      goto LABEL_371;
    }
  }
  double v204 = 1.79769313e308;
LABEL_374:
  uint64_t v205 = (void *)v339;
  *(double *)(v339 + 584) = v204;
  long long v206 = *(unsigned char **)(v339 + 328);
  *(void *)(v339 + 336) = v206;
  int8x8_t v207 = *(int8x8_t *)(v339 + 608);
  if (!*(void *)&v207) {
    goto LABEL_420;
  }
  unint64_t v208 = *(void *)(v339 + 592);
  uint8x8_t v209 = (uint8x8_t)vcnt_s8(v207);
  v209.i16[0] = vaddlv_u8(v209);
  if (v209.u32[0] > 1uLL)
  {
    unint64_t v210 = *(void *)(v339 + 592);
    if (v208 >= *(void *)&v207) {
      unint64_t v210 = v208 % *(void *)&v207;
    }
  }
  else
  {
    unint64_t v210 = (*(void *)&v207 - 1) & v208;
  }
  uint64_t v211 = *(void *)(v339 + 600);
  double v212 = *(void **)(v211 + 8 * v210);
  if (!v212) {
    goto LABEL_420;
  }
  unint64_t v213 = (void *)*v212;
  if (!*v212) {
    goto LABEL_420;
  }
  uint64_t v214 = *(void *)&v207 - 1;
  if (v209.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v215 = v213[1];
      if (v208 == v215)
      {
        if (v213[2] == v208) {
          goto LABEL_395;
        }
      }
      else if ((v215 & v214) != v210)
      {
        goto LABEL_420;
      }
      unint64_t v213 = (void *)*v213;
      if (!v213) {
        goto LABEL_420;
      }
    }
  }
  while (2)
  {
    unint64_t v216 = v213[1];
    if (v208 != v216)
    {
      if (v216 >= *(void *)&v207) {
        v216 %= *(void *)&v207;
      }
      if (v216 != v210) {
        goto LABEL_420;
      }
      goto LABEL_389;
    }
    if (v213[2] != v208)
    {
LABEL_389:
      unint64_t v213 = (void *)*v213;
      if (!v213) {
        goto LABEL_420;
      }
      continue;
    }
    break;
  }
LABEL_395:
  if (v209.u32[0] > 1uLL)
  {
    unint64_t v217 = *(void *)(v339 + 592);
    if (v208 >= *(void *)&v207) {
      unint64_t v217 = v208 % *(void *)&v207;
    }
  }
  else
  {
    unint64_t v217 = v214 & v208;
  }
  uint64_t v218 = *(void **)(v211 + 8 * v217);
  if (!v218 || (uint64_t v219 = (void *)*v218) == 0) {
LABEL_610:
  }
    abort();
  if (v209.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v220 = v219[1];
      if (v220 == v208)
      {
        if (v219[2] == v208) {
          goto LABEL_407;
        }
      }
      else if ((v220 & v214) != v217)
      {
        goto LABEL_610;
      }
      uint64_t v219 = (void *)*v219;
      if (!v219) {
        goto LABEL_610;
      }
    }
  }
  while (1)
  {
    unint64_t v226 = v219[1];
    if (v226 == v208) {
      break;
    }
    if (v226 >= *(void *)&v207) {
      v226 %= *(void *)&v207;
    }
    if (v226 != v217) {
      goto LABEL_610;
    }
LABEL_411:
    uint64_t v219 = (void *)*v219;
    if (!v219) {
      goto LABEL_610;
    }
  }
  if (v219[2] != v208) {
    goto LABEL_411;
  }
LABEL_407:
  uint64_t v222 = (unsigned char *)v219[3];
  uint64_t v221 = (unsigned char *)v219[4];
  int64_t v223 = v221 - v222;
  if (v221 == v222)
  {
    uint64_t v225 = 0;
    uint64_t v224 = 0;
    goto LABEL_418;
  }
  if (v223 < 0) {
    goto LABEL_610;
  }
  uint64_t v224 = (char *)operator new(v221 - v222);
  uint64_t v225 = &v224[8 * (v223 >> 3)];
  memcpy(v224, v222, v223);
LABEL_418:
  std::vector<unsigned long long>::__insert_with_size[abi:nn180100]<std::__wrap_iter<unsigned long long const*>,std::__wrap_iter<unsigned long long const*>>((char **)(v339 + 328), v206, v224, v225, (v225 - v224) >> 3);
  if (v224) {
    operator delete(v224);
  }
LABEL_420:
  double v227 = COERCE_DOUBLE(v353);
  if (*(unsigned __int8 *)(md::LayoutContext::frameState((md::LayoutContext *)a2) + 128) - 1 > 2)
  {
    double v228 = fmax(*(double *)(v43 + 40) * 0.0333333333, 0.0);
    if (v228 <= 1.0) {
      double v229 = 1.0 - v228;
    }
    else {
      double v229 = 0.0;
    }
    *(float *)&double v229 = v229;
    (*((void (**)(double))VKAnimationCurveEaseIn + 2))(v229);
    double v231 = *(double *)(v43 + 3112);
    double v232 = *(double *)(v43 + 3120);
    double v233 = v230 * 0.305730681 / sqrt(v231 * v231 + v232 * v232);
    *(_OWORD *)&v353[8] = 0u;
    long long v354 = 0u;
    *(void *)uint64_t v353 = 0x3FF0000000000000;
    unint64_t v355 = 0x3FF0000000000000;
    long long v356 = 0uLL;
    *(double *)&long long v357 = v233 * v231;
    *((double *)&v357 + 1) = v233 * v232;
  }
  else
  {
    *(_OWORD *)&v353[8] = 0u;
    long long v354 = 0u;
    *(void *)uint64_t v353 = 0x3FF0000000000000;
    unint64_t v355 = 0x3FF0000000000000;
    long long v356 = 0u;
    long long v357 = 0u;
  }
  long long v359 = 0u;
  long long v360 = 0u;
  uint64_t v358 = 0x3FF0000000000000;
  uint64_t v361 = 0x3FF0000000000000;
  gm::operator*<double,4,4,4>((double *)v346, (double *)(v43 + 808), (double *)v353);
  long long v234 = *(_OWORD *)&v346[16];
  *(_OWORD *)(v339 + 352) = *(_OWORD *)v346;
  *(_OWORD *)(v339 + 368) = v234;
  long long v235 = v348;
  *(_OWORD *)(v339 + 384) = v347;
  *(_OWORD *)(v339 + 400) = v235;
  long long v236 = v350;
  *(_OWORD *)(v339 + 416) = v349;
  *(_OWORD *)(v339 + 432) = v236;
  v237.n128_u64[1] = *((void *)&v351 + 1);
  long long v238 = v352;
  *(_OWORD *)(v339 + 448) = v351;
  *(_OWORD *)(v339 + 464) = v238;
  *(float *)(v339 + 500) = *(float *)(v323 + 20) * *(float *)(v323 + 16);
  uint64_t v239 = *(uint64_t **)(v339 + 480);
  if (v239)
  {
    uint64_t v240 = *v239;
    if (*v239 != *(void *)(v339 + 552) && *(void *)(v339 + 536))
    {
      double v227 = *(double *)(v339 + 528);
      if (v227 != 0.0)
      {
        do
        {
          double v319 = **(double **)&v227;
          uint64_t v320 = *(void **)(*(void *)&v227 + 24);
          if (v320)
          {
            *(void *)(*(void *)&v227 + 32) = v320;
            operator delete(v320);
          }
          operator delete(*(void **)&v227);
          double v227 = v319;
        }
        while (v319 != 0.0);
      }
      *(void *)(v339 + 528) = 0;
      uint64_t v241 = *(void *)(v339 + 520);
      if (v241)
      {
        for (uint64_t j = 0; j != v241; ++j)
          *(void *)(*(void *)(v339 + 512) + 8 * j) = 0;
      }
      *(void *)(v339 + 536) = 0;
      uint64_t v239 = *(uint64_t **)(v339 + 480);
      uint64_t v240 = *v239;
    }
    *(void *)(v339 + 552) = v240;
    uint64_t v243 = (void *)v239[2];
    uint64_t v338 = (void *)v239[3];
    if (v243 != v338)
    {
      char v341 = (void *)(v339 + 528);
      unint64_t v345 = (uint64_t *)(v339 + 512);
      do
      {
        unint64_t v244 = v243[3];
        int8x8_t v245 = (int8x8_t)v205[32];
        if (!*(void *)&v245) {
          goto LABEL_457;
        }
        uint8x8_t v246 = (uint8x8_t)vcnt_s8(v245);
        v246.i16[0] = vaddlv_u8(v246);
        if (v246.u32[0] > 1uLL)
        {
          unint64_t v247 = v243[3];
          if (v244 >= *(void *)&v245) {
            unint64_t v247 = v244 % *(void *)&v245;
          }
        }
        else
        {
          unint64_t v247 = (*(void *)&v245 - 1) & v244;
        }
        uint64_t v248 = *(void **)(v205[31] + 8 * v247);
        if (!v248 || (uint64_t v249 = (void *)*v248) == 0)
        {
LABEL_457:
          unint64_t v253 = (unsigned __int16 *)(v243 + 7);
          goto LABEL_458;
        }
        if (v246.u32[0] < 2uLL)
        {
          uint64_t v250 = *(void *)&v245 - 1;
          while (1)
          {
            uint64_t v252 = v249[1];
            if (v244 == v252)
            {
              if (v249[2] == v244) {
                goto LABEL_505;
              }
            }
            else if ((v252 & v250) != v247)
            {
              goto LABEL_457;
            }
            uint64_t v249 = (void *)*v249;
            if (!v249) {
              goto LABEL_457;
            }
          }
        }
        while (1)
        {
          unint64_t v251 = v249[1];
          if (v244 == v251) {
            break;
          }
          if (v251 >= *(void *)&v245) {
            v251 %= *(void *)&v245;
          }
          if (v251 != v247) {
            goto LABEL_457;
          }
LABEL_447:
          uint64_t v249 = (void *)*v249;
          if (!v249) {
            goto LABEL_457;
          }
        }
        if (v249[2] != v244) {
          goto LABEL_447;
        }
LABEL_505:
        unint64_t v253 = (unsigned __int16 *)(v249 + 3);
LABEL_458:
        int v254 = *v253;
        uint64_t v255 = v243[1];
        if (*v243 != v255)
        {
          uint64_t v256 = *v243 + 184;
          do
          {
            _ZF = *(unsigned __int16 *)(v256 - 176) == v254 || v256 == v255;
            v256 += 184;
          }
          while (!_ZF);
        }
        unint64_t v258 = v205[65];
        if (!v258) {
          goto LABEL_486;
        }
        v237.n128_u64[0] = (unint64_t)vcnt_s8((int8x8_t)v258);
        v237.n128_u16[0] = vaddlv_u8((uint8x8_t)v237.n128_u64[0]);
        if (v237.n128_u32[0] > 1uLL)
        {
          double v227 = *((double *)v243 + 3);
          if (v244 >= v258) {
            *(void *)&double v227 = v244 % v258;
          }
        }
        else
        {
          *(void *)&double v227 = (v258 - 1) & v244;
        }
        uint64_t v259 = *(void ***)(*v345 + 8 * *(void *)&v227);
        if (!v259 || (uint64_t v260 = (char *)*v259) == 0)
        {
LABEL_486:
          uint64_t v260 = (char *)operator new(0x38uLL);
          *(void *)uint64_t v346 = v260;
          *(void *)&v346[8] = v339 + 528;
          *(void *)uint64_t v260 = 0;
          *((double *)v260 + 1) = *(double *)&v244;
          *((double *)v260 + 2) = *(double *)&v244;
          v237.n128_u32[1] = 0;
          v237.n128_u64[1] = 0;
          *(_OWORD *)(v260 + 24) = 0u;
          *(_OWORD *)(v260 + 40) = 0u;
          v346[16] = 1;
          v237.n128_f32[0] = (float)(unint64_t)(*(void *)(v339 + 536) + 1);
          float v263 = *(float *)(v339 + 544);
          if (!v258 || (float)(v263 * (float)v258) < v237.n128_f32[0])
          {
            BOOL v264 = (v258 & (v258 - 1)) != 0;
            if (v258 < 3) {
              BOOL v264 = 1;
            }
            unint64_t v265 = v264 | (2 * v258);
            v237.n128_f32[0] = v237.n128_f32[0] / v263;
            unint64_t v266 = vcvtps_u32_f32(v237.n128_f32[0]);
            if (v265 <= v266) {
              size_t v267 = v266;
            }
            else {
              size_t v267 = v265;
            }
            if (v267 == 1)
            {
              size_t v267 = 2;
            }
            else if ((v267 & (v267 - 1)) != 0)
            {
              size_t v267 = std::__next_prime(v267);
              unint64_t v258 = *(void *)(v339 + 520);
            }
            if (v267 > v258) {
              goto LABEL_498;
            }
            if (v267 < v258)
            {
              unint64_t v268 = vcvtps_u32_f32((float)*(unint64_t *)(v339 + 536) / *(float *)(v339 + 544));
              if (v258 < 3
                || (v237.n128_u64[0] = (unint64_t)vcnt_s8((int8x8_t)v258),
                    v237.n128_u16[0] = vaddlv_u8((uint8x8_t)v237.n128_u64[0]),
                    v237.n128_u32[0] > 1uLL))
              {
                unint64_t v268 = std::__next_prime(v268);
              }
              else
              {
                uint64_t v269 = 1 << -(char)__clz(v268 - 1);
                if (v268 >= 2) {
                  unint64_t v268 = v269;
                }
              }
              if (v267 <= v268) {
                size_t v267 = v268;
              }
              if (v267 < v258) {
LABEL_498:
              }
                std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>((uint64_t)v345, v267);
            }
            unint64_t v258 = *(void *)(v339 + 520);
            if ((v258 & (v258 - 1)) != 0)
            {
              if (v244 >= v258) {
                *(void *)&double v227 = v244 % v258;
              }
              else {
                double v227 = *(double *)&v244;
              }
            }
            else
            {
              *(void *)&double v227 = (v258 - 1) & v244;
            }
          }
          uint64_t v270 = *v345;
          uint64_t v271 = *(void **)(*v345 + 8 * *(void *)&v227);
          if (v271)
          {
            *(void *)uint64_t v260 = *v271;
            goto LABEL_523;
          }
          *(void *)uint64_t v260 = *v341;
          void *v341 = v260;
          *(void *)(v270 + 8 * *(void *)&v227) = v341;
          if (*(void *)v260)
          {
            unint64_t v272 = *(void *)(*(void *)v260 + 8);
            if ((v258 & (v258 - 1)) != 0)
            {
              if (v272 >= v258) {
                v272 %= v258;
              }
            }
            else
            {
              v272 &= v258 - 1;
            }
            uint64_t v271 = (void *)(*v345 + 8 * v272);
LABEL_523:
            void *v271 = v260;
          }
          uint64_t v205 = (void *)v339;
          ++*(void *)(v339 + 536);
          goto LABEL_525;
        }
        if (v237.n128_u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v262 = *((void *)v260 + 1);
            if (v262 == v244)
            {
              if (*((void *)v260 + 2) == v244) {
                goto LABEL_485;
              }
            }
            else if ((v262 & (v258 - 1)) != *(void *)&v227)
            {
              goto LABEL_486;
            }
            uint64_t v260 = *(char **)v260;
            if (!v260) {
              goto LABEL_486;
            }
          }
        }
        while (2)
        {
          unint64_t v261 = *((void *)v260 + 1);
          if (v261 != v244)
          {
            if (v261 >= v258) {
              v261 %= v258;
            }
            if (v261 != *(void *)&v227) {
              goto LABEL_486;
            }
LABEL_475:
            uint64_t v260 = *(char **)v260;
            if (!v260) {
              goto LABEL_486;
            }
            continue;
          }
          break;
        }
        if (*((void *)v260 + 2) != v244) {
          goto LABEL_475;
        }
LABEL_485:
        uint64_t v205 = (void *)v339;
LABEL_525:
        double v227 = *((double *)v260 + 3);
        if (*(void *)&v227 != *((void *)v260 + 4) && *((unsigned __int16 *)v260 + 24) == v254) {
          goto LABEL_436;
        }
        *((_WORD *)v260 + 24) = v254;
        *((double *)v260 + 4) = v227;
        unint64_t v273 = 0xD37A6F4DE9BD37A7 * ((uint64_t)(v243[1] - *v243) >> 3);
        if (0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*((void *)v260 + 5) - *(void *)&v227) >> 3) < v273)
        {
          if (v273 > 0x492492492492492) {
LABEL_609:
          }
            abort();
          uint64_t v274 = (char *)operator new(0x42C8590B21642C88 * ((uint64_t)(v243[1] - *v243) >> 3));
          *((void *)v260 + 3) = v274;
          *((void *)v260 + 4) = v274;
          *((void *)v260 + 5) = &v274[56 * v273];
          if (v227 != 0.0) {
            operator delete(*(void **)&v227);
          }
        }
        double v275 = *(double *)v243;
        uint64_t v276 = v243[1];
        while (2)
        {
          if (*(void *)&v275 != v276)
          {
            int v278 = *(__int16 *)(*(void *)&v275 + 8);
            if (v278 <= (__int16)v254)
            {
              v237.n128_f64[0] = (double)(v278 & ~(v278 >> 31));
              double v279 = v237.n128_f64[0] * 3.0;
              if (*(unsigned char *)(*(void *)&v275 + 168))
              {
                uint64_t v280 = *(void *)(*(void *)&v275 + 176);
                double v227 = *((double *)v260 + 4);
                unint64_t v281 = *((void *)v260 + 5);
                if (*(void *)&v227 >= v281)
                {
                  int v282 = (void *)*((void *)v260 + 3);
                  unint64_t v283 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v227 - (void)v282) >> 3) + 1;
                  if (v283 > 0x492492492492492) {
                    goto LABEL_609;
                  }
                  unint64_t v284 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v281 - (void)v282) >> 3);
                  if (2 * v284 > v283) {
                    unint64_t v283 = 2 * v284;
                  }
                  if (v284 >= 0x249249249249249) {
                    unint64_t v285 = 0x492492492492492;
                  }
                  else {
                    unint64_t v285 = v283;
                  }
                  if (v285)
                  {
                    if (v285 > 0x492492492492492) {
                      goto LABEL_606;
                    }
                    uint64_t v286 = (char *)operator new(56 * v285);
                  }
                  else
                  {
                    uint64_t v286 = 0;
                  }
                  unint64_t v291 = &v286[8 * ((uint64_t)(*(void *)&v227 - (void)v282) >> 3)];
                  *(double *)unint64_t v291 = v279;
                  *((void *)v291 + 1) = 0x3FF0000000000000;
                  *((double *)v291 + 2) = v279;
                  *((void *)v291 + 3) = 0;
                  *((_WORD *)v291 + 16) = v278;
                  *((void *)v291 + 5) = v280;
                  *((void *)v291 + 6) = 1;
                  uint64_t v292 = v291;
                  if (*(void **)&v227 != v282)
                  {
                    do
                    {
                      __n128 v237 = *(__n128 *)(*(void *)&v227 - 56);
                      long long v293 = *(_OWORD *)(*(void *)&v227 - 40);
                      long long v294 = *(_OWORD *)(*(void *)&v227 - 24);
                      *((void *)v292 - 1) = *(void *)(*(void *)&v227 - 8);
                      *(_OWORD *)(v292 - 24) = v294;
                      *(_OWORD *)(v292 - 40) = v293;
                      *(__n128 *)(v292 - 56) = v237;
                      v292 -= 56;
                      *(void *)&v227 -= 56;
                    }
                    while (*(void **)&v227 != v282);
                    goto LABEL_566;
                  }
                  goto LABEL_567;
                }
                **(double **)&double v227 = v279;
                *(void *)(*(void *)&v227 + 8) = 0x3FF0000000000000;
                *(double *)(*(void *)&v227 + 16) = v279;
                *(void *)(*(void *)&v227 + 24) = 0;
                *(_WORD *)(*(void *)&v227 + 32) = v278;
                *(void *)(*(void *)&v227 + 40) = v280;
                uint64_t v277 = (void *)(*(void *)&v227 + 56);
                *(void *)(*(void *)&v227 + 48) = 1;
              }
              else
              {
                double v227 = *((double *)v260 + 4);
                unint64_t v287 = *((void *)v260 + 5);
                if (*(void *)&v227 >= v287)
                {
                  uint64_t v288 = (void *)*((void *)v260 + 3);
                  unint64_t v289 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(*(void *)&v227 - (void)v288) >> 3) + 1;
                  if (v289 > 0x492492492492492) {
                    goto LABEL_609;
                  }
                  unint64_t v290 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v287 - (void)v288) >> 3);
                  if (2 * v290 > v289) {
                    unint64_t v289 = 2 * v290;
                  }
                  if (v290 >= 0x249249249249249) {
                    unint64_t v285 = 0x492492492492492;
                  }
                  else {
                    unint64_t v285 = v289;
                  }
                  if (v285)
                  {
                    if (v285 > 0x492492492492492) {
                      goto LABEL_606;
                    }
                    uint64_t v286 = (char *)operator new(56 * v285);
                  }
                  else
                  {
                    uint64_t v286 = 0;
                  }
                  unint64_t v291 = &v286[8 * ((uint64_t)(*(void *)&v227 - (void)v288) >> 3)];
                  *(double *)unint64_t v291 = v279;
                  *((void *)v291 + 1) = 0x3FF0000000000000;
                  *((double *)v291 + 2) = v279;
                  *((void *)v291 + 3) = 0;
                  *((_WORD *)v291 + 16) = v278;
                  v291[40] = 0;
                  v291[48] = 0;
                  uint64_t v292 = v291;
                  if (*(void **)&v227 != v288)
                  {
                    do
                    {
                      __n128 v237 = *(__n128 *)(*(void *)&v227 - 56);
                      long long v295 = *(_OWORD *)(*(void *)&v227 - 40);
                      long long v296 = *(_OWORD *)(*(void *)&v227 - 24);
                      *((void *)v292 - 1) = *(void *)(*(void *)&v227 - 8);
                      *(_OWORD *)(v292 - 24) = v296;
                      *(_OWORD *)(v292 - 40) = v295;
                      *(__n128 *)(v292 - 56) = v237;
                      v292 -= 56;
                      *(void *)&v227 -= 56;
                    }
                    while (*(void **)&v227 != v288);
LABEL_566:
                    double v227 = *((double *)v260 + 3);
                  }
LABEL_567:
                  uint64_t v277 = v291 + 56;
                  *((void *)v260 + 3) = v292;
                  *((void *)v260 + 4) = v291 + 56;
                  *((void *)v260 + 5) = &v286[56 * v285];
                  if (v227 != 0.0) {
                    operator delete(*(void **)&v227);
                  }
                }
                else
                {
                  **(double **)&double v227 = v279;
                  *(void *)(*(void *)&v227 + 8) = 0x3FF0000000000000;
                  *(double *)(*(void *)&v227 + 16) = v279;
                  *(void *)(*(void *)&v227 + 24) = 0;
                  *(_WORD *)(*(void *)&v227 + 32) = v278;
                  *(unsigned char *)(*(void *)&v227 + 40) = 0;
                  uint64_t v277 = (void *)(*(void *)&v227 + 56);
                  *(unsigned char *)(*(void *)&v227 + 48) = 0;
                }
              }
              *((void *)v260 + 4) = v277;
            }
            *(void *)&v275 += 184;
            continue;
          }
          break;
        }
        unint64_t v297 = *((void *)v260 + 3);
        unint64_t v298 = *((void *)v260 + 4);
        unint64_t v299 = 126 - 2 * __clz(0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v298 - v297) >> 3));
        if (v298 == v297) {
          uint64_t v300 = 0;
        }
        else {
          uint64_t v300 = v299;
        }
        __n128 v237 = std::__introsort<std::_ClassicAlgPolicy,md::VenueLogic::updateVenueLevelScales(void)::$_0 &,md::VenueLevelScale *,false>(v297, v298, v300, 1, v237);
        unint64_t v302 = *((void *)v260 + 3);
        uint64_t v301 = *((void *)v260 + 4);
        if (v301 != v302)
        {
          uint64_t v303 = (unint64_t)((uint64_t)(v301 - v302) / 56) <= 1 ? 1 : (uint64_t)(v301 - v302) / 56;
          *(void *)(v302 + 8) = 0x3FF0000000000000;
          if ((unint64_t)((uint64_t)(v301 - v302) / 56) >= 2)
          {
            uint64_t v304 = v303 - 1;
            unsigned int v305 = (double *)(v302 + 56);
            double v306 = 60.0;
            do
            {
              double v307 = v306 * 0.0333333333;
              if (v306 * 0.0333333333 > 1.0) {
                double v307 = 1.0;
              }
              if (v306 <= 0.0) {
                double v307 = 0.0;
              }
              if ((__int16)v254 < 11) {
                double v307 = 1.0;
              }
              v305[1] = v307;
              double v308 = (*(v305 - 7) - *v305) * v307;
              v305[3] = v308;
              double v306 = v306 - v308;
              v305 += 7;
              --v304;
            }
            while (v304);
          }
        }
        uint64_t v205 = (void *)v339;
        if (v302 != v301)
        {
          unint64_t v309 = v301 - 56;
          if (v301 - 56 > v302)
          {
            unint64_t v310 = v302 + 56;
            do
            {
              uint64_t v311 = *(void *)(v310 - 8);
              __n128 v237 = *(__n128 *)(v310 - 24);
              long long v312 = *(_OWORD *)(v310 - 40);
              long long v313 = *(_OWORD *)(v310 - 56);
              long long v315 = *(_OWORD *)(v309 + 16);
              long long v314 = *(_OWORD *)(v309 + 32);
              uint64_t v316 = *(void *)(v309 + 48);
              *(_OWORD *)(v310 - 56) = *(_OWORD *)v309;
              *(void *)(v310 - 8) = v316;
              *(_OWORD *)(v310 - 24) = v314;
              *(_OWORD *)(v310 - 40) = v315;
              *(_OWORD *)unint64_t v309 = v313;
              *(_OWORD *)(v309 + 16) = v312;
              *(__n128 *)(v309 + 32) = v237;
              *(void *)(v309 + 48) = v311;
              v309 -= 56;
              _CF = v310 >= v309;
              v310 += 56;
            }
            while (!_CF);
            uint64_t v301 = *((void *)v260 + 4);
          }
        }
        uint64_t v317 = *((void *)v260 + 3);
        if (v317 != v301)
        {
          double v318 = 0.0;
          do
          {
            if (*(__int16 *)(v317 + 32) >= 1) {
              *(double *)(v317 + 16) = v318;
            }
            double v318 = *(double *)(v317 + 24) + v318;
            v317 += 56;
          }
          while (v317 != v301);
        }
LABEL_436:
        v243 += 15;
      }
      while (v243 != v338);
    }
  }
  md::VenueLogicContext::operator=(v322, v336);
  if (!v369) {
    goto LABEL_613;
  }
  (*(void (**)(void *))(*v369 + 48))(v369);
  if (v369 == v368)
  {
    (*(void (**)(void *))(v368[0] + 32))(v368);
  }
  else if (v369)
  {
    (*(void (**)(void))(*v369 + 40))();
  }
}

void sub_1A1AC0CC4(_Unwind_Exception *a1)
{
  if (v1) {
    operator delete(v1);
  }
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v2 - 184));
  _Unwind_Resume(a1);
}

void md::LayoutContext::zoomAtCentrePoint(int8x8_t *this)
{
  int8x8_t v1 = this[1];
  if (!*(void *)&v1) {
    return;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xE42D19AFCA302E68;
    if (*(void *)&v1 <= 0xE42D19AFCA302E68) {
      unint64_t v3 = 0xE42D19AFCA302E68 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xE42D19AFCA302E68;
  }
  uint64_t v4 = *(void **)(*(void *)this + 8 * v3);
  if (v4)
  {
    uint64_t v5 = (void *)*v4;
    if (v5)
    {
      if (v2.u32[0] < 2uLL)
      {
        while (1)
        {
          uint64_t v7 = v5[1];
          if (v7 == 0xE42D19AFCA302E68)
          {
            if (v5[2] == 0xE42D19AFCA302E68) {
              goto LABEL_21;
            }
          }
          else if ((v7 & (*(void *)&v1 - 1)) != v3)
          {
            goto LABEL_21;
          }
          uint64_t v5 = (void *)*v5;
          if (!v5) {
            goto LABEL_21;
          }
        }
      }
      do
      {
        unint64_t v6 = v5[1];
        if (v6 == 0xE42D19AFCA302E68)
        {
          if (v5[2] == 0xE42D19AFCA302E68) {
            break;
          }
        }
        else
        {
          if (v6 >= *(void *)&v1) {
            v6 %= *(void *)&v1;
          }
          if (v6 != v3) {
            break;
          }
        }
        uint64_t v5 = (void *)*v5;
      }
      while (v5);
    }
  }
LABEL_21:
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v8 = 0x1AF456233693CD46;
    if (*(void *)&v1 <= 0x1AF456233693CD46uLL) {
      uint64_t v8 = 0x1AF456233693CD46uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v8 = (*(void *)&v1 - 1) & 0x1AF456233693CD46;
  }
  unint64_t v9 = *(void **)(*(void *)this + 8 * v8);
  if (v9)
  {
    uint64_t v10 = (void *)*v9;
    if (v10)
    {
      if (v2.u32[0] < 2uLL)
      {
        uint64_t v11 = *(void *)&v1 - 1;
        while (1)
        {
          uint64_t v13 = v10[1];
          if (v13 == 0x1AF456233693CD46)
          {
            if (v10[2] == 0x1AF456233693CD46) {
              goto LABEL_41;
            }
          }
          else if ((v13 & v11) != v8)
          {
            return;
          }
          uint64_t v10 = (void *)*v10;
          if (!v10) {
            return;
          }
        }
      }
      do
      {
        unint64_t v12 = v10[1];
        if (v12 == 0x1AF456233693CD46)
        {
          if (v10[2] == 0x1AF456233693CD46)
          {
LABEL_41:
            uint64_t v14 = v10[5];
            if (*(void *)(v14 + 8) == 0x1AF456233693CD46)
            {
              unint64_t v15 = *(double **)(v14 + 32);
              if (v15)
              {
                double v16 = v15[1];
                long double v17 = cos(v16 + v16) * -559.82 + 111132.92;
                long double v18 = v17 + cos(v16 * 4.0) * 1.175;
                long double v19 = v18 + cos(v16 * 6.0) * -0.0023;
                double v20 = v16 * 0.5;
                long double v21 = tan(v16 * 0.5 + 0.78103484);
                double v22 = log(v21);
                long double v23 = tan(v20 + 0.789761487);
                long double v24 = log(v23);
                log2(fabs((v24 - v22) * 0.159154943) * (v15[4] * (v15[470] + v15[470])) / v19);
              }
            }
            return;
          }
        }
        else
        {
          if (v12 >= *(void *)&v1) {
            v12 %= *(void *)&v1;
          }
          if (v12 != v8) {
            return;
          }
        }
        uint64_t v10 = (void *)*v10;
      }
      while (v10);
    }
  }
}

uint64_t md::VenueLogicContext::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
    uint64_t v4 = *(void **)(a2 + 16);
    uint64_t v5 = *(void *)(a1 + 8);
    if (!v5) {
      goto LABEL_14;
    }
    for (uint64_t i = 0; i != v5; ++i)
      *(void *)(*(void *)a1 + 8 * i) = 0;
    uint64_t v7 = *(void **)(a1 + 16);
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = 0;
    if (v7)
    {
      while (v4)
      {
        uint64_t v9 = v4[3];
        _OWORD v7[2] = v4[2];
        uint64_t v10 = v4[4];
        if (v10) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v10 + 8), 1uLL, memory_order_relaxed);
        }
        uint64_t v11 = (std::__shared_weak_count *)v7[4];
        v7[3] = v9;
        v7[4] = v10;
        if (v11 && !atomic_fetch_add(&v11->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
          std::__shared_weak_count::__release_weak(v11);
        }
        uint64_t v8 = (void *)*v7;
        std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi(a1, v7);
        uint64_t v4 = (void *)*v4;
        uint64_t v7 = v8;
        if (!v8) {
          goto LABEL_14;
        }
      }
      do
      {
        double v73 = v7;
        uint64_t v7 = (void *)*v7;
        unint64_t v74 = (std::__shared_weak_count *)v73[4];
        if (v74 && !atomic_fetch_add(&v74->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
          std::__shared_weak_count::__release_weak(v74);
        }
        operator delete(v73);
      }
      while (v7);
    }
    else
    {
LABEL_14:
      while (v4)
      {
        unint64_t v12 = operator new(0x28uLL);
        *unint64_t v12 = 0;
        v12[1] = 0;
        uint64_t v13 = v4[2];
        uint64_t v14 = v4[3];
        v12[2] = v13;
        CGColorRef v12[3] = v14;
        uint64_t v15 = v4[4];
        CGFloat v12[4] = v15;
        if (v15) {
          atomic_fetch_add_explicit((atomic_ullong *volatile)(v15 + 8), 1uLL, memory_order_relaxed);
        }
        v12[1] = v13;
        std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi(a1, v12);
        uint64_t v4 = (void *)*v4;
      }
    }
    *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 72);
    double v16 = *(uint64_t **)(a2 + 56);
    uint64_t v17 = *(void *)(a1 + 48);
    if (!v17) {
      goto LABEL_24;
    }
    for (uint64_t j = 0; j != v17; ++j)
      *(void *)(*(void *)(a1 + 40) + 8 * j) = 0;
    long double v19 = *(uint64_t **)(a1 + 56);
    *(void *)(a1 + 56) = 0;
    *(void *)(a1 + 64) = 0;
    if (v19)
    {
      while (v16)
      {
        v19[2] = v16[2];
        *((_WORD *)v19 + 12) = *((_WORD *)v16 + 12);
        double v20 = (uint64_t *)*v19;
        std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi(a1 + 40, v19);
        double v16 = (uint64_t *)*v16;
        long double v19 = v20;
        if (!v20) {
          goto LABEL_24;
        }
      }
      do
      {
        double v22 = (uint64_t *)*v19;
        operator delete(v19);
        long double v19 = v22;
      }
      while (v22);
    }
    else
    {
LABEL_24:
      while (v16)
      {
        long double v21 = operator new(0x20uLL);
        *(void *)long double v21 = 0;
        v21[1] = *((_OWORD *)v16 + 1);
        *((void *)v21 + 1) = *((void *)v21 + 2);
        std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi(a1 + 40, v21);
        double v16 = (uint64_t *)*v16;
      }
    }
    *(_DWORD *)(a1 + 112) = *(_DWORD *)(a2 + 112);
    std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>((void *)(a1 + 80), *(void **)(a2 + 96));
    long double v23 = *(char **)(a1 + 120);
    long long v25 = *(char **)(a2 + 120);
    long double v24 = *(unsigned char **)(a2 + 128);
    size_t v26 = v24 - v25;
    unint64_t v27 = (v24 - v25) >> 3;
    uint64_t v28 = *(void *)(a1 + 136);
    if (v27 > (v28 - (uint64_t)v23) >> 3)
    {
      if (v23)
      {
        *(void *)(a1 + 128) = v23;
        operator delete(v23);
        uint64_t v28 = 0;
        *(void *)(a1 + 120) = 0;
        *(void *)(a1 + 128) = 0;
        *(void *)(a1 + 136) = 0;
      }
      if ((v26 & 0x8000000000000000) != 0) {
        goto LABEL_96;
      }
      uint64_t v29 = v28 >> 2;
      if (v28 >> 2 <= v27) {
        uint64_t v29 = (v24 - v25) >> 3;
      }
      BOOL v30 = (unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v31 = 0x1FFFFFFFFFFFFFFFLL;
      if (!v30) {
        unint64_t v31 = v29;
      }
      if (v31 >> 61) {
LABEL_96:
      }
        abort();
      uint64_t v32 = 8 * v31;
      unint64_t v33 = (char *)operator new(8 * v31);
      long double v23 = v33;
      *(void *)(a1 + 128) = v33;
      uint64_t v34 = (char **)(a1 + 128);
      *(void *)(a1 + 120) = v33;
      *(void *)(a1 + 136) = &v33[v32];
      if (v24 != v25) {
        memcpy(v33, v25, v24 - v25);
      }
      goto LABEL_47;
    }
    uint64_t v34 = (char **)(a1 + 128);
    uint64_t v35 = *(unsigned char **)(a1 + 128);
    unint64_t v36 = (v35 - v23) >> 3;
    if (v36 >= v27)
    {
      if (v24 == v25)
      {
LABEL_47:
        *uint64_t v34 = &v23[v26];
        goto LABEL_48;
      }
      int v38 = *(void **)(a1 + 120);
      unint64_t v39 = *(char **)(a2 + 120);
    }
    else
    {
      long long v37 = &v25[8 * v36];
      if (v35 != v23)
      {
        memmove(*(void **)(a1 + 120), *(const void **)(a2 + 120), v35 - v23);
        long double v23 = *v34;
      }
      size_t v26 = v24 - v37;
      if (v24 == v37) {
        goto LABEL_47;
      }
      int v38 = v23;
      unint64_t v39 = v37;
    }
    memmove(v38, v39, v26);
    goto LABEL_47;
  }
LABEL_48:
  *(void *)(a1 + 144) = *(void *)(a2 + 144);
  *(void *)(a1 + 152) = *(void *)(a2 + 152);
  *(void *)(a1 + 160) = *(void *)(a2 + 160);
  *(void *)(a1 + 168) = *(void *)(a2 + 168);
  *(void *)(a1 + 176) = *(void *)(a2 + 176);
  *(void *)(a1 + 184) = *(void *)(a2 + 184);
  *(void *)(a1 + 192) = *(void *)(a2 + 192);
  *(void *)(a1 + 200) = *(void *)(a2 + 200);
  *(void *)(a1 + 208) = *(void *)(a2 + 208);
  *(void *)(a1 + 216) = *(void *)(a2 + 216);
  *(void *)(a1 + 224) = *(void *)(a2 + 224);
  *(void *)(a1 + 232) = *(void *)(a2 + 232);
  *(void *)(a1 + 240) = *(void *)(a2 + 240);
  *(void *)(a1 + 248) = *(void *)(a2 + 248);
  *(void *)(a1 + 256) = *(void *)(a2 + 256);
  *(void *)(a1 + 264) = *(void *)(a2 + 264);
  long long v40 = *(_OWORD *)(a2 + 272);
  *(_OWORD *)(a1 + 281) = *(_OWORD *)(a2 + 281);
  *(_OWORD *)(a1 + 272) = v40;
  uint64_t v75 = a2;
  if (a1 == a2) {
    goto LABEL_89;
  }
  *(_DWORD *)(a1 + 336) = *(_DWORD *)(a2 + 336);
  unint64_t v41 = *(uint64_t **)(a2 + 320);
  uint64_t v42 = *(void *)(a1 + 312);
  if (!v42) {
    goto LABEL_84;
  }
  for (uint64_t k = 0; k != v42; ++k)
    *(void *)(*(void *)(a1 + 304) + 8 * k) = 0;
  size_t v44 = *(uint64_t **)(a1 + 320);
  *(void *)(a1 + 320) = 0;
  *(void *)(a1 + 328) = 0;
  if (!v44)
  {
LABEL_84:
    while (v41)
    {
      uint64_t v64 = operator new(0x38uLL);
      *uint64_t v64 = 0;
      v64[1] = 0;
      uint64_t v65 = v41[2];
      v64[3] = 0;
      v64[2] = v65;
      v64[4] = 0;
      v64[5] = 0;
      double v67 = (unsigned char *)v41[3];
      unint64_t v66 = (unsigned char *)v41[4];
      int64_t v68 = v66 - v67;
      if (v66 != v67)
      {
        if ((unint64_t)(0x6DB6DB6DB6DB6DB7 * (v68 >> 3)) > 0x492492492492492) {
          abort();
        }
        uint64_t v69 = (char *)operator new(v68);
        v64[3] = v69;
        v64[4] = v69;
        double v70 = &v69[8 * (v68 >> 3)];
        v64[5] = v70;
        memcpy(v69, v67, v68);
        v64[4] = v70;
      }
      *((_WORD *)v64 + 24) = *((_WORD *)v41 + 24);
      v64[1] = v65;
      std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi(a1 + 304, v64);
      unint64_t v41 = (uint64_t *)*v41;
    }
    goto LABEL_89;
  }
  while (v41)
  {
    v44[2] = v41[2];
    if (v44 == v41) {
      goto LABEL_56;
    }
    double v47 = (char *)v44[3];
    uint8x8_t v49 = (char *)v41[3];
    unint64_t v48 = (unsigned char *)v41[4];
    __uint64_t n = v48 - v49;
    unint64_t v50 = 0x6DB6DB6DB6DB6DB7 * ((v48 - v49) >> 3);
    uint64_t v51 = v44[5];
    if (0x6DB6DB6DB6DB6DB7 * ((v51 - (uint64_t)v47) >> 3) < v50)
    {
      if (v47)
      {
        v44[4] = (uint64_t)v47;
        operator delete(v47);
        uint64_t v51 = 0;
        void v44[3] = 0;
        v44[4] = 0;
        v44[5] = 0;
      }
      if (v50 > 0x492492492492492) {
        goto LABEL_96;
      }
      unint64_t v52 = 0x6DB6DB6DB6DB6DB7 * (v51 >> 3);
      uint64_t v53 = 2 * v52;
      if (2 * v52 <= v50) {
        uint64_t v53 = 0x6DB6DB6DB6DB6DB7 * ((v48 - v49) >> 3);
      }
      unint64_t v54 = v52 >= 0x249249249249249 ? 0x492492492492492 : v53;
      if (v54 > 0x492492492492492) {
        goto LABEL_96;
      }
      uint64_t v55 = 56 * v54;
      float v56 = (char *)operator new(56 * v54);
      double v47 = v56;
      v44[4] = (uint64_t)v56;
      BOOL v57 = (void **)(v44 + 4);
      void v44[3] = (uint64_t)v56;
      v44[5] = (uint64_t)&v56[v55];
      if (v48 == v49)
      {
        size_t v45 = v48 - v49;
      }
      else
      {
        size_t v45 = v48 - v49;
        memcpy(v56, v49, __n);
      }
      goto LABEL_55;
    }
    BOOL v57 = (void **)(v44 + 4);
    unint64_t v58 = (unsigned char *)v44[4];
    unint64_t v59 = 0x6DB6DB6DB6DB6DB7 * ((v58 - v47) >> 3);
    if (v59 < v50)
    {
      if (v58 != v47)
      {
        memmove(v47, v49, v58 - v47);
        double v47 = (char *)*v57;
      }
      size_t v60 = &v49[56 * v59];
      size_t v45 = v48 - v60;
      if (!v45) {
        goto LABEL_55;
      }
      unint64_t v61 = v47;
      goto LABEL_78;
    }
    if (v48 != v49)
    {
      unint64_t v61 = (void *)v44[3];
      size_t v60 = (char *)v41[3];
      size_t v45 = v48 - v49;
LABEL_78:
      memmove(v61, v60, v45);
      goto LABEL_55;
    }
    size_t v45 = v48 - v49;
LABEL_55:
    *BOOL v57 = &v47[v45];
LABEL_56:
    *((_WORD *)v44 + 24) = *((_WORD *)v41 + 24);
    unint64_t v46 = (uint64_t *)*v44;
    std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi(a1 + 304, v44);
    unint64_t v41 = (uint64_t *)*v41;
    size_t v44 = v46;
    if (!v46) {
      goto LABEL_84;
    }
  }
  do
  {
    uint8x8_t v62 = (uint64_t *)*v44;
    uint64_t v63 = (void *)v44[3];
    if (v63)
    {
      v44[4] = (uint64_t)v63;
      operator delete(v63);
    }
    operator delete(v44);
    size_t v44 = v62;
  }
  while (v62);
LABEL_89:
  uint64_t v71 = *(void *)(v75 + 344);
  *(unsigned char *)(a1 + 352) = *(unsigned char *)(v75 + 352);
  *(void *)(a1 + 344) = v71;
  return a1;
}

void sub_1A1AC18E0(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<unsigned long long,std::hash<unsigned long long>,std::equal_to<unsigned long long>,std::allocator<unsigned long long>>::__assign_multi<std::__hash_const_iterator<std::__hash_node<unsigned long long,void *> *>>(void *a1, void *a2)
{
  uint64_t v4 = a1[1];
  if (!v4) {
    goto LABEL_7;
  }
  for (uint64_t i = 0; i != v4; ++i)
    *(void *)(*a1 + 8 * i) = 0;
  unint64_t v6 = (void *)a1[2];
  a1[2] = 0;
  a1[3] = 0;
  if (v6)
  {
    while (a2)
    {
      v6[2] = a2[2];
      uint64_t v7 = (void *)*v6;
      std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi((uint64_t)a1, v6);
      a2 = (void *)*a2;
      unint64_t v6 = v7;
      if (!v7) {
        goto LABEL_7;
      }
    }
    do
    {
      uint64_t v10 = (void *)*v6;
      operator delete(v6);
      unint64_t v6 = v10;
    }
    while (v10);
  }
  else
  {
LABEL_7:
    while (a2)
    {
      uint64_t v8 = operator new(0x18uLL);
      *uint64_t v8 = 0;
      uint64_t v9 = a2[2];
      v8[1] = v9;
      v8[2] = v9;
      std::__hash_table<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,md::PolygonRouteAttributes>>>::__node_insert_multi((uint64_t)a1, v8);
      a2 = (void *)*a2;
    }
  }
}

void sub_1A1AC1A30(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__function::__func<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_19,std::allocator<md::MapEngine::MapEngine(float,float,float,BOOL,VKMapViewPurpose,std::shared_ptr<md::TaskContext> const&,VKMapPurpose,std::unique_ptr<md::AnimationManager>,geo::linear_map<md::MapEngineSetting,long long,std::equal_to<md::MapEngineSetting>,std::allocator<std::pair<md::MapEngineSetting,long long>>,std::vector<std::pair<md::MapEngineSetting,long long>>> const&,unsigned long long,GEOApplicationAuditToken *)::$_19>,BOOL ()(void)>::operator()(uint64_t a1)
{
  int8x8_t v1 = (id *)(*(void *)(a1 + 8) + 848);
  id WeakRetained = objc_loadWeakRetained(v1);
  char v3 = objc_opt_respondsToSelector();

  if ((v3 & 1) == 0) {
    return 1;
  }
  id v4 = objc_loadWeakRetained(v1);
  uint64_t v5 = [v4 canChangeVenueFocus];

  return v5;
}

void sub_1A1AC1AB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void _ZNSt3__110__function6__funcIZN2md10VenueLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17VenueLogicContextEE3__1NS_9allocatorISL_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint8x8_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  char v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "VenueLogic", "", v5, 2u);
  }
}

void _ZNSt3__110__function6__funcIZN2md10VenueLogic15runBeforeLayoutERKNS2_13LayoutContextERKNS2_17LogicDependenciesIJN3gdc8TypeListIJNS2_13CameraContextENS2_16ElevationContextENS2_12SceneContextEEEENS9_IJEEEEE20ResolvedDependenciesERNS2_17VenueLogicContextEE3__0NS_9allocatorISL_EEFvvEEclEv(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint8x8_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  char v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "VenueLogic", "", v5, 2u);
  }
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::UpdateTileRenderables>,std::allocator<ecs2::ForwardToExecute<md::ita::UpdateTileRenderables>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1AC2054(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::function<void ()(md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>::Model<ecs2::RuntimeQuery<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>::Model<ecs2::RuntimeQuery<md::ls::TileRenderableDataHandle const&,md::ls::BoundsWidth const&,md::ls::NeedsUpdate<ggl::Tile::View> &,md::ls::TileViewConstantDataHandle &>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  char v3 = (void *)gdc::Registry::storage<md::ls::TileRenderableDataHandle>(v2);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::BoundsWidth>(v2);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::NeedsUpdate<ggl::Tile::View>>(v2);
  unint64_t v6 = (void *)gdc::Registry::storage<md::ls::TileViewConstantDataHandle>(v2);
  v98[0] = (uint64_t)v3;
  v98[1] = (uint64_t)v4;
  _DWORD v98[2] = (uint64_t)v5;
  v98[3] = (uint64_t)v6;
  gdc::RegistryQueryView<gdc::All<md::ls::PipelineSetupToApply const,md::ls::RenderState const,md::ls::DataIDSetToUse const,md::ls::RenderItemID const>,gdc::Any<>,gdc::None<>>::begin(v96, v98);
  uint64_t v7 = v3 + 4;
  if (v4[8] - v4[7] < v3[8] - v3[7]) {
    uint64_t v7 = v4 + 4;
  }
  if (v5[8] - v5[7] < v7[4] - v7[3]) {
    uint64_t v7 = v5 + 4;
  }
  if (v6[8] - v6[7] < v7[4] - v7[3]) {
    uint64_t v7 = v6 + 4;
  }
  uint64_t v8 = (unint64_t *)v7[4];
  uint64_t v9 = v97;
  if (v8 == v97)
  {
    uint64_t result = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v10 = (void *)result;
LABEL_97:
    void *v10 = 0xFFFFFFFF00000000;
  }
  else
  {
    uint64_t v10 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v11 = v96[0];
    unint64_t v12 = (void *)v96[1];
    uint64_t v13 = (void *)v96[2];
    size_t v93 = (void *)v96[4];
    uint64_t v94 = (void *)v96[3];
    while (1)
    {
      void *v10 = *v9;
      unint64_t v15 = *v9;
      unint64_t v16 = HIDWORD(*v9);
      unint64_t v17 = *v9 >> 39;
      uint64_t v18 = v3[4];
      if (v17 >= (v3[5] - v18) >> 3) {
        goto LABEL_19;
      }
      uint64_t v19 = *(void *)(v18 + 8 * v17);
      if (!v19) {
        goto LABEL_19;
      }
      unint64_t v20 = *(unsigned __int16 *)(v19 + 2 * (HIDWORD(v15) & 0x7F));
      uint64_t v22 = v3[7];
      uint64_t v21 = v3[8];
      if (v20 >= (v21 - v22) >> 3) {
        goto LABEL_19;
      }
      uint64_t v23 = v22 + 8 * v20;
      if (v23 != v21 && *(_DWORD *)(v23 + 4) == v16)
      {
        uint64_t v25 = v3[11];
        uint64_t v26 = v3[10] + 8 * v20;
      }
      else
      {
LABEL_19:
        uint64_t v25 = v3[11];
        uint64_t v26 = v25;
      }
      uint64_t v27 = v26 == v25 ? 0 : v26;
      if ((uint64_t v28 = v4[4], v17 < (v4[5] - v28) >> 3)
        && (uint64_t v29 = *(void *)(v28 + 8 * v17)) != 0
        && (unint64_t v30 = *(unsigned __int16 *)(v29 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v32 = v4[7],
            uint64_t v31 = v4[8],
            v30 < (v31 - v32) >> 3)
        && ((uint64_t v33 = v32 + 8 * v30, v33 != v31) ? (v34 = *(_DWORD *)(v33 + 4) == v16) : (v34 = 0), v34))
      {
        uint64_t v35 = v4[11];
        uint64_t v36 = v4[10] + 4 * v30;
      }
      else
      {
        uint64_t v35 = v4[11];
        uint64_t v36 = v35;
      }
      uint64_t v37 = v36 == v35 ? 0 : v36;
      if ((uint64_t v38 = v5[4], v17 < (v5[5] - v38) >> 3)
        && (uint64_t v39 = *(void *)(v38 + 8 * v17)) != 0
        && (unint64_t v40 = *(unsigned __int16 *)(v39 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v42 = v5[7],
            uint64_t v41 = v5[8],
            v40 < (v41 - v42) >> 3)
        && ((uint64_t v43 = v42 + 8 * v40, v43 != v41) ? (v44 = *(_DWORD *)(v43 + 4) == v16) : (v44 = 0), v44))
      {
        unint64_t v45 = v5[11];
        unint64_t v46 = v5[10] + v40;
      }
      else
      {
        unint64_t v45 = v5[11];
        unint64_t v46 = v45;
      }
      unint64_t v47 = v46 == v45 ? 0 : v46;
      if ((uint64_t v48 = v6[4], v17 < (v6[5] - v48) >> 3)
        && (uint64_t v49 = *(void *)(v48 + 8 * v17)) != 0
        && (unint64_t v50 = *(unsigned __int16 *)(v49 + 2 * (HIDWORD(v15) & 0x7F)),
            uint64_t v52 = v6[7],
            uint64_t v51 = v6[8],
            v50 < (v51 - v52) >> 3)
        && ((uint64_t v53 = v52 + 8 * v50, v53 != v51) ? (v54 = *(_DWORD *)(v53 + 4) == v16) : (v54 = 0), v54))
      {
        uint64_t v55 = v6[11];
        uint64_t v56 = v6[10] + 8 * v50;
      }
      else
      {
        uint64_t v55 = v6[11];
        uint64_t v56 = v55;
      }
      uint64_t v57 = *(void *)(a2 + 24);
      if (!v57) {
        break;
      }
      if (v56 == v55) {
        uint64_t v58 = 0;
      }
      else {
        uint64_t v58 = v56;
      }
      uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t))(*(void *)v57 + 48))(v57, v27, v37, v47, v58);
      size_t v60 = *(unint64_t **)(v11 + 32);
      uint64_t v14 = v9 + 1;
      uint64_t v97 = v9 + 1;
      if (v9 + 1 != v60)
      {
        uint64_t v61 = v12[4];
        while (1)
        {
          unint64_t v62 = *((unsigned int *)v14 + 1);
          unint64_t v63 = v62 >> 7;
          if (v62 >> 7 < (v12[5] - v61) >> 3)
          {
            uint64_t v64 = *(void *)(v61 + 8 * v63);
            if (v64)
            {
              uint64_t v65 = v62 & 0x7F;
              unint64_t v66 = *(unsigned __int16 *)(v64 + 2 * v65);
              uint64_t v68 = v12[7];
              uint64_t v67 = v12[8];
              uint64_t result = v67 - v68;
              if (v66 < (v67 - v68) >> 3)
              {
                uint64_t v69 = v68 + 8 * v66;
                if (v69 != v67 && *(_DWORD *)(v69 + 4) == v62)
                {
                  uint64_t v71 = v13[4];
                  if (v63 < (v13[5] - v71) >> 3)
                  {
                    uint64_t v72 = *(void *)(v71 + 8 * v63);
                    if (v72)
                    {
                      unint64_t v73 = *(unsigned __int16 *)(v72 + 2 * v65);
                      uint64_t v75 = v13[7];
                      uint64_t v74 = v13[8];
                      uint64_t result = v74 - v75;
                      if (v73 < (v74 - v75) >> 3)
                      {
                        uint64_t v76 = v75 + 8 * v73;
                        if (v76 != v74 && *(_DWORD *)(v76 + 4) == v62)
                        {
                          uint64_t v78 = v94[4];
                          if (v63 < (v94[5] - v78) >> 3)
                          {
                            uint64_t v79 = *(void *)(v78 + 8 * v63);
                            if (v79)
                            {
                              unint64_t v80 = *(unsigned __int16 *)(v79 + 2 * v65);
                              uint64_t v82 = v94[7];
                              uint64_t v81 = v94[8];
                              uint64_t result = v81 - v82;
                              if (v80 < (v81 - v82) >> 3)
                              {
                                uint64_t v83 = v82 + 8 * v80;
                                if (v83 != v81 && *(_DWORD *)(v83 + 4) == v62)
                                {
                                  uint64_t v85 = v93[4];
                                  if (v63 < (v93[5] - v85) >> 3)
                                  {
                                    uint64_t v86 = *(void *)(v85 + 8 * v63);
                                    if (v86)
                                    {
                                      unint64_t v87 = *(unsigned __int16 *)(v86 + 2 * v65);
                                      uint64_t v89 = v93[7];
                                      uint64_t v88 = v93[8];
                                      if (v87 < (v88 - v89) >> 3)
                                      {
                                        uint64_t v90 = v89 + 8 * v87;
                                        if (*(_DWORD *)(v90 + 4) == v62 && v90 != v88) {
                                          break;
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (++v14 == v60)
          {
            uint64_t v14 = v60;
            goto LABEL_10;
          }
        }
        size_t v60 = v14;
LABEL_10:
        uint64_t v97 = v14;
      }
      uint64_t v9 = v60;
      if (v8 == v60) {
        goto LABEL_97;
      }
    }
    std::__throw_bad_function_call[abi:nn180100]();
    return gdc::Registry::storage<md::ls::NeedsUpdate<ggl::Tile::View>>(v92);
  }
  return result;
}

uint64_t gdc::Registry::storage<md::ls::NeedsUpdate<ggl::Tile::View>>(int8x8_t *a1)
{
  unint64_t v10 = 0xBBBF2D3465784E7ELL;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xBBBF2D3465784E7ELL;
    if (*(void *)&v1 <= 0xBBBF2D3465784E7ELL) {
      unint64_t v3 = 0xBBBF2D3465784E7ELL % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xBBBF2D3465784E7ELL;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xBBBF2D3465784E7ELL)
      {
        if (v5[2] == 0xBBBF2D3465784E7ELL) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xBBBF2D3465784E7ELL) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xBBBF2D3465784E7ELL) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1AC2748(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::BoundsWidth>(int8x8_t *a1)
{
  uint64_t v10 = 0x1ADAB24DD42B2B4;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x1ADAB24DD42B2B4;
    if (*(void *)&v1 <= 0x1ADAB24DD42B2B4uLL) {
      uint64_t v3 = 0x1ADAB24DD42B2B4uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x1ADAB24DD42B2B4;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x1ADAB24DD42B2B4)
      {
        if (v5[2] == 0x1ADAB24DD42B2B4) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x1ADAB24DD42B2B4) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x1ADAB24DD42B2B4) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1AC29B8(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t *md::MaterialTextureManager::colorRampTexturesFromMaterial(uint64_t a1, unsigned int a2, uint64_t *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a3;
  if (!*a3) {
    return 0;
  }
  uint64_t v7 = *(void *)(v3 + 16);
  uint64_t v8 = *(std::__shared_weak_count **)(v3 + 24);
  if (v8)
  {
    atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)&long long v27 = v7;
    BYTE8(v27) = a2;
    if (!atomic_fetch_add(&v8->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
      std::__shared_weak_count::__release_weak(v8);
    }
  }
  else
  {
    *(void *)&long long v27 = *(void *)(v3 + 16);
    BYTE8(v27) = a2;
  }
  uint64_t v10 = std::__hash_table<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,std::__unordered_map_hasher<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyHash,md::MaterialTextureManager::ColorRampKeyEqual,true>,std::__unordered_map_equal<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyEqual,md::MaterialTextureManager::ColorRampKeyHash,true>,std::allocator<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>>>::find<md::MaterialTextureManager::ColorRampKey>((void *)(a1 + 240), (uint64_t *)v27, BYTE8(v27));
  if (v10)
  {
    uint64_t v9 = v10[4];
    goto LABEL_9;
  }
  (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*a3 + 1056))(&v31, (float)a2);
  if ((_BYTE)v31)
  {
    LOBYTE(v28) = 0;
    goto LABEL_20;
  }
  (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*a3 + 576))(&v28, (float)a2);
  if ((_BYTE)v31) {
LABEL_20:
  }
    std::allocate_shared[abi:nn180100]<md::ColorRampTexture,std::allocator<md::ColorRampTexture>,unsigned int const&,float const&,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>> &,md::SharedResourcesManager *&,void>((uint64_t)&v26, (uint64_t *)v33, *(void *)(a1 + 328));
  if ((_BYTE)v28) {
    std::allocate_shared[abi:nn180100]<md::ColorRampTexture,std::allocator<md::ColorRampTexture>,unsigned int const&,float const&,std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>> &,md::SharedResourcesManager *&,void>((uint64_t)&v26, (uint64_t *)__p, *(void *)(a1 + 328));
  }
  uint64_t v9 = (uint64_t *)std::__hash_table<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,std::__unordered_map_hasher<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyHash,md::MaterialTextureManager::ColorRampKeyEqual,true>,std::__unordered_map_equal<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyEqual,md::MaterialTextureManager::ColorRampKeyHash,true>,std::allocator<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>>>::__emplace_unique_key_args<md::MaterialTextureManager::ColorRampKey,std::piecewise_construct_t const&,std::tuple<md::MaterialTextureManager::ColorRampKey const&>,std::tuple<>>((uint64_t *)(a1 + 240), v27, BYTE8(v27), &v27)[4];
  if ((_BYTE)v28)
  {
    uint64_t v14 = __p;
    if (__p)
    {
      do
      {
        unint64_t v15 = (void *)*v14;
        operator delete(v14);
        uint64_t v14 = v15;
      }
      while (v15);
    }
    unint64_t v16 = v29;
    uint64_t v29 = 0;
    if (v16) {
      operator delete(v16);
    }
  }
  if ((_BYTE)v31)
  {
    unint64_t v17 = v33;
    if (v33)
    {
      do
      {
        uint64_t v18 = (void *)*v17;
        operator delete(v17);
        unint64_t v17 = v18;
      }
      while (v18);
    }
    uint64_t v19 = v32;
    uint64_t v32 = 0;
    if (v19) {
      operator delete(v19);
    }
  }
LABEL_9:
  uint64_t v11 = *(void *)(*a3 + 32);
  unint64_t v12 = *(std::__shared_weak_count **)(*a3 + 40);
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)&long long v27 = v11;
    BYTE8(v27) = a2;
    if (!atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
      std::__shared_weak_count::__release_weak(v12);
    }
  }
  else
  {
    *(void *)&long long v27 = *(void *)(*a3 + 32);
    BYTE8(v27) = a2;
  }
  if (!std::__hash_table<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,std::__unordered_map_hasher<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyHash,md::MaterialTextureManager::ColorRampKeyEqual,true>,std::__unordered_map_equal<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyEqual,md::MaterialTextureManager::ColorRampKeyHash,true>,std::allocator<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>>>::find<md::MaterialTextureManager::ColorRampKey>((void *)(a1 + 240), (uint64_t *)v27, BYTE8(v27)))
  {
    (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*a3 + 1064))(&v31, (float)a2);
    if ((_BYTE)v31)
    {
      LOBYTE(v28) = 0;
    }
    else
    {
      (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*a3 + 584))(&v28, (float)a2);
      if (!(_BYTE)v31)
      {
        if ((_BYTE)v28) {
          std::allocate_shared[abi:nn180100]<md::ColorRampTexture,std::allocator<md::ColorRampTexture>,unsigned int const&,float const&,std::unordered_map<float,geo::Color<float,4,(geo::ColorSpace)0>> &,md::SharedResourcesManager *&,void>((uint64_t)&v26, (uint64_t *)__p, *(void *)(a1 + 328));
        }
        std::__hash_table<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,std::__unordered_map_hasher<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyHash,md::MaterialTextureManager::ColorRampKeyEqual,true>,std::__unordered_map_equal<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyEqual,md::MaterialTextureManager::ColorRampKeyHash,true>,std::allocator<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>>>::__emplace_unique_key_args<md::MaterialTextureManager::ColorRampKey,std::piecewise_construct_t const&,std::tuple<md::MaterialTextureManager::ColorRampKey const&>,std::tuple<>>((uint64_t *)(a1 + 240), v27, BYTE8(v27), &v27);
        if ((_BYTE)v28)
        {
          unint64_t v20 = __p;
          if (__p)
          {
            do
            {
              uint64_t v21 = (void *)*v20;
              operator delete(v20);
              unint64_t v20 = v21;
            }
            while (v21);
          }
          uint64_t v22 = v29;
          uint64_t v29 = 0;
          if (v22) {
            operator delete(v22);
          }
        }
        if ((_BYTE)v31)
        {
          uint64_t v23 = v33;
          if (v33)
          {
            do
            {
              long double v24 = (void *)*v23;
              operator delete(v23);
              uint64_t v23 = v24;
            }
            while (v24);
          }
          uint64_t v25 = v32;
          uint64_t v32 = 0;
          if (v25) {
            operator delete(v25);
          }
        }
        return v9;
      }
    }
    std::allocate_shared[abi:nn180100]<md::ColorRampTexture,std::allocator<md::ColorRampTexture>,unsigned int const&,float const&,std::unordered_map<float,geo::Color<float,3,(geo::ColorSpace)0>> &,md::SharedResourcesManager *&,void>((uint64_t)&v26, (uint64_t *)v33, *(void *)(a1 + 328));
  }
  return v9;
}

void sub_1A1AC2F84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20)
{
}

uint64_t **std::__hash_table<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,std::__unordered_map_hasher<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyHash,md::MaterialTextureManager::ColorRampKeyEqual,true>,std::__unordered_map_equal<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyEqual,md::MaterialTextureManager::ColorRampKeyHash,true>,std::allocator<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>>>::find<md::MaterialTextureManager::ColorRampKey>(void *a1, uint64_t *a2, unsigned __int8 a3)
{
  int8x8_t v3 = (int8x8_t)a1[1];
  if (!*(void *)&v3) {
    return 0;
  }
  unint64_t v4 = ((unint64_t)&a2[8 * (unint64_t)a3 - 0xC3910C8D016B07DLL] + ((unint64_t)a3 >> 2) - 3) ^ a3;
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    unint64_t v6 = ((unint64_t)&a2[8 * (unint64_t)a3 - 0xC3910C8D016B07DLL] + ((unint64_t)a3 >> 2) - 3) ^ a3;
    if (v4 >= *(void *)&v3) {
      unint64_t v6 = v4 % *(void *)&v3;
    }
  }
  else
  {
    unint64_t v6 = v4 & (*(void *)&v3 - 1);
  }
  uint64_t v7 = *(uint64_t ****)(*a1 + 8 * v6);
  if (!v7) {
    return 0;
  }
  uint64_t result = *v7;
  if (*v7)
  {
    if (v5.u32[0] < 2uLL)
    {
      uint64_t v9 = *(void *)&v3 - 1;
      while (1)
      {
        uint64_t v13 = result[1];
        if (v13 == (uint64_t *)v4)
        {
          if (result[2] == a2 && *((unsigned __int8 *)result + 24) == a3) {
            return result;
          }
        }
        else if (((unint64_t)v13 & v9) != v6)
        {
          return 0;
        }
        uint64_t result = (uint64_t **)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v11 = (unint64_t)result[1];
      if (v11 == v4)
      {
        if (result[2] == a2 && *((unsigned __int8 *)result + 24) == a3) {
          return result;
        }
      }
      else
      {
        if (v11 >= *(void *)&v3) {
          v11 %= *(void *)&v3;
        }
        if (v11 != v6) {
          return 0;
        }
      }
      uint64_t result = (uint64_t **)*result;
    }
    while (result);
  }
  return result;
}

void *std::__hash_table<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,std::__unordered_map_hasher<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyHash,md::MaterialTextureManager::ColorRampKeyEqual,true>,std::__unordered_map_equal<md::MaterialTextureManager::ColorRampKey,std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>,md::MaterialTextureManager::ColorRampKeyEqual,md::MaterialTextureManager::ColorRampKeyHash,true>,std::allocator<std::__hash_value_type<md::MaterialTextureManager::ColorRampKey,std::shared_ptr<md::ColorRampTexture>>>>::__emplace_unique_key_args<md::MaterialTextureManager::ColorRampKey,std::piecewise_construct_t const&,std::tuple<md::MaterialTextureManager::ColorRampKey const&>,std::tuple<>>(uint64_t *a1, uint64_t a2, unsigned __int8 a3, _OWORD *a4)
{
  unint64_t v7 = (a2 + ((unint64_t)a3 << 6) + ((unint64_t)a3 >> 2) - 0x61C8864680B583EBLL) ^ a3;
  unint64_t v8 = a1[1];
  if (v8)
  {
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v4 = (a2 + ((unint64_t)a3 << 6) + ((unint64_t)a3 >> 2) - 0x61C8864680B583EBLL) ^ a3;
      if (v7 >= v8) {
        unint64_t v4 = v7 % v8;
      }
    }
    else
    {
      unint64_t v4 = v7 & (v8 - 1);
    }
    uint64_t v10 = *(void ***)(*a1 + 8 * v4);
    if (v10)
    {
      unint64_t v11 = *v10;
      if (*v10)
      {
        if (v9.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v15 = v11[1];
            if (v15 == v7)
            {
              if (v11[2] == a2 && *((unsigned __int8 *)v11 + 24) == a3) {
                return v11;
              }
            }
            else if ((v15 & (v8 - 1)) != v4)
            {
              goto LABEL_28;
            }
            unint64_t v11 = (void *)*v11;
            if (!v11) {
              goto LABEL_28;
            }
          }
        }
        do
        {
          unint64_t v13 = v11[1];
          if (v13 == v7)
          {
            if (v11[2] == a2 && *((unsigned __int8 *)v11 + 24) == a3) {
              return v11;
            }
          }
          else
          {
            if (v13 >= v8) {
              v13 %= v8;
            }
            if (v13 != v4) {
              break;
            }
          }
          unint64_t v11 = (void *)*v11;
        }
        while (v11);
      }
    }
  }
LABEL_28:
  unint64_t v16 = a1 + 2;
  unint64_t v11 = operator new(0x30uLL);
  void *v11 = 0;
  v11[1] = v7;
  *((_OWORD *)v11 + 1) = *a4;
  v11[4] = 0;
  v11[5] = 0;
  float v17 = (float)(unint64_t)(a1[3] + 1);
  float v18 = *((float *)a1 + 8);
  if (!v8 || (float)(v18 * (float)v8) < v17)
  {
    BOOL v19 = 1;
    if (v8 >= 3) {
      BOOL v19 = (v8 & (v8 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v8);
    unint64_t v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v8 = a1[1];
    }
    if (prime <= v8)
    {
      if (prime >= v8) {
        goto LABEL_65;
      }
      unint64_t v33 = vcvtps_u32_f32((float)(unint64_t)a1[3] / *((float *)a1 + 8));
      if (v8 < 3 || (uint8x8_t v34 = (uint8x8_t)vcnt_s8((int8x8_t)v8), v34.i16[0] = vaddlv_u8(v34), v34.u32[0] > 1uLL))
      {
        unint64_t v33 = std::__next_prime(v33);
      }
      else
      {
        uint64_t v35 = 1 << -(char)__clz(v33 - 1);
        if (v33 >= 2) {
          unint64_t v33 = v35;
        }
      }
      if (prime <= v33) {
        size_t prime = v33;
      }
      if (prime >= v8)
      {
        unint64_t v8 = a1[1];
LABEL_65:
        if ((v8 & (v8 - 1)) != 0)
        {
          if (v7 >= v8) {
            unint64_t v4 = v7 % v8;
          }
          else {
            unint64_t v4 = v7;
          }
        }
        else
        {
          unint64_t v4 = (v8 - 1) & v7;
        }
        goto LABEL_78;
      }
      if (!prime)
      {
        uint64_t v43 = (void *)*a1;
        *a1 = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v8 = 0;
        a1[1] = 0;
        goto LABEL_65;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v23 = operator new(8 * prime);
    long double v24 = (void *)*a1;
    *a1 = (uint64_t)v23;
    if (v24) {
      operator delete(v24);
    }
    uint64_t v25 = 0;
    a1[1] = prime;
    do
      *(void *)(*a1 + 8 * v25++) = 0;
    while (prime != v25);
    long long v26 = (void *)*v16;
    if (!*v16)
    {
LABEL_64:
      unint64_t v8 = prime;
      goto LABEL_65;
    }
    size_t v27 = v26[1];
    size_t v28 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v29 = v27 & v28;
      *(void *)(*a1 + 8 * v29) = v16;
      for (uint64_t i = (void *)*v26; *v26; uint64_t i = (void *)*v26)
      {
        size_t v31 = i[1] & v28;
        if (v31 == v29)
        {
          long long v26 = i;
        }
        else if (*(void *)(*a1 + 8 * v31))
        {
          *long long v26 = *i;
          uint64_t v32 = 8 * v31;
          void *i = **(void **)(*a1 + v32);
          **(void **)(*a1 + v32) = i;
        }
        else
        {
          *(void *)(*a1 + 8 * v31) = v26;
          long long v26 = i;
          size_t v29 = v31;
        }
      }
      goto LABEL_64;
    }
    if (v27 >= prime) {
      v27 %= prime;
    }
    *(void *)(*a1 + 8 * v27) = v16;
    uint64_t v36 = (void *)*v26;
    if (!*v26) {
      goto LABEL_64;
    }
    while (1)
    {
      size_t v38 = v36[1];
      if (v38 >= prime) {
        v38 %= prime;
      }
      if (v38 != v27)
      {
        if (!*(void *)(*a1 + 8 * v38))
        {
          *(void *)(*a1 + 8 * v38) = v26;
          goto LABEL_69;
        }
        *long long v26 = *v36;
        uint64_t v37 = 8 * v38;
        *uint64_t v36 = **(void **)(*a1 + v37);
        **(void **)(*a1 + v37) = v36;
        uint64_t v36 = v26;
      }
      size_t v38 = v27;
LABEL_69:
      long long v26 = v36;
      uint64_t v36 = (void *)*v36;
      size_t v27 = v38;
      if (!v36) {
        goto LABEL_64;
      }
    }
  }
LABEL_78:
  uint64_t v39 = *a1;
  unint64_t v40 = *(void **)(*a1 + 8 * v4);
  if (v40)
  {
    void *v11 = *v40;
LABEL_86:
    *unint64_t v40 = v11;
    goto LABEL_87;
  }
  void *v11 = *v16;
  *unint64_t v16 = v11;
  *(void *)(v39 + 8 * v4) = v16;
  if (*v11)
  {
    unint64_t v41 = *(void *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v41 >= v8) {
        v41 %= v8;
      }
    }
    else
    {
      v41 &= v8 - 1;
    }
    unint64_t v40 = (void *)(*a1 + 8 * v41);
    goto LABEL_86;
  }
LABEL_87:
  ++a1[3];
  return v11;
}

void sub_1A1AC3590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<md::MaterialTextureManager::TextureKey,std::shared_ptr<md::SharedTexture2D>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<md::MaterialTextureManager::TextureKey,std::shared_ptr<md::SharedTexture2D>>,void *>>>>::~unique_ptr[abi:nn180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

void grl::IconManager::loadGlobalResourcePack(uint64_t a1, uint64_t a2)
{
  v2[3] = 0;
  (*(void (**)(void *__return_ptr))(**(void **)(a2 + 8) + 40))(v2);
  geo::make_unique<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>,std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const&>();
}

void grl::IconManager::loadResourcePack(void *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t **a5)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (std::__shared_mutex_base *)(a2 + 272);
  std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(a2 + 272));
  uint8x8_t v9 = (uint64_t **)(a2 + 448);
  uint64_t v10 = *(void *)(a2 + 448);
  if (!v10) {
    goto LABEL_8;
  }
  uint64_t v11 = a2 + 448;
  do
  {
    BOOL v12 = std::less<std::pair<std::string,float>>::operator()[abi:nn180100]((const void **)(v10 + 32), (const void **)a3);
    unint64_t v13 = (uint64_t *)(v10 + 8);
    if (!v12)
    {
      unint64_t v13 = (uint64_t *)v10;
      uint64_t v11 = v10;
    }
    uint64_t v10 = *v13;
  }
  while (*v13);
  if ((uint64_t **)v11 == v9
    || std::less<std::pair<std::string,float>>::operator()[abi:nn180100]((const void **)a3, (const void **)(v11 + 32)))
  {
LABEL_8:
    std::__shared_mutex_base::unlock_shared(v8);
    std::__shared_mutex_base::lock(v8);
    uint64_t v14 = *v9;
    uint64_t v15 = (uint64_t **)(a2 + 448);
    if (*v9)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v15 = (uint64_t **)v14;
          unint64_t v16 = (const void **)(v14 + 4);
          if (!std::less<std::pair<std::string,float>>::operator()[abi:nn180100]((const void **)a3, (const void **)v14 + 4))break; {
          uint64_t v14 = *v15;
          }
          uint8x8_t v9 = v15;
          if (!*v15) {
            goto LABEL_15;
          }
        }
        if (!std::less<std::pair<std::string,float>>::operator()[abi:nn180100](v16, (const void **)a3)) {
          break;
        }
        uint64_t v14 = v15[1];
        if (!v14)
        {
          uint8x8_t v9 = v15 + 1;
          goto LABEL_15;
        }
      }
      uint64_t v11 = (uint64_t)v15;
    }
    else
    {
LABEL_15:
      uint64_t v11 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a2 + 456) + 16))(*(void *)(a2 + 456), 128, 8);
      float v17 = (std::string *)(v11 + 32);
      if (*(char *)(a3 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v17, *(const std::string::value_type **)a3, *(void *)(a3 + 8));
      }
      else
      {
        long long v18 = *(_OWORD *)a3;
        *(void *)(v11 + 48) = *(void *)(a3 + 16);
        *(_OWORD *)&v17->__r_.__value_.__l.__data_ = v18;
      }
      *(_DWORD *)(v11 + 56) = *(_DWORD *)(a3 + 24);
      *(void *)(v11 + 64) = 850045863;
      *(_OWORD *)(v11 + 72) = 0u;
      *(_OWORD *)(v11 + 88) = 0u;
      *(_OWORD *)(v11 + 104) = 0u;
      *(void *)(v11 + 120) = 0;
      *(void *)uint64_t v11 = 0;
      *(void *)(v11 + 8) = 0;
      *(void *)(v11 + 16) = v15;
      *uint8x8_t v9 = (uint64_t *)v11;
      uint64_t v19 = **(void **)(a2 + 440);
      unint64_t v20 = (uint64_t *)v11;
      if (v19)
      {
        *(void *)(a2 + 440) = v19;
        unint64_t v20 = *v9;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a2 + 448), v20);
      ++*(void *)(a2 + 464);
    }
    std::__shared_mutex_base::unlock(v8);
  }
  else
  {
    std::__shared_mutex_base::unlock_shared(v8);
  }
  unint64_t v21 = (std::mutex *)(v11 + 64);
  std::mutex::lock((std::mutex *)(v11 + 64));
  grl::IconManager::retrieveResourcePack(&v79, a2, (float *)a3, a4);
  if (v79)
  {
    uint64_t v22 = v80;
    *a1 = v79;
    a1[1] = v22;
    goto LABEL_168;
  }
  uint64_t v71 = (std::mutex *)(v11 + 64);
  std::string::basic_string[abi:nn180100]<0>(&__p, "");
  LODWORD(v83) = 0;
  uint64_t v24 = **a5;
  uint64_t v23 = (*a5)[1];
  if (v24 != v23)
  {
    int v72 = 0;
    do
    {
      grl::codec::ResourcePack::PackExtension((const std::string *)v24, &v88);
      if (a4 > 2) {
        uint64_t v25 = 0;
      }
      else {
        uint64_t v25 = off_1E5AB2BE0[(char)a4];
      }
      int v26 = std::string::compare(&v88, v25);
      int v27 = v26;
      if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0)
      {
        operator delete(v88.__r_.__value_.__l.__data_);
        if (!v27)
        {
LABEL_35:
          grl::codec::ResourcePack::RegionForPack((const std::string *)v24, (uint64_t)&__str);
          std::string::size_type v28 = std::string::rfind(&__str, 45, 0xFFFFFFFFFFFFFFFFLL);
          if (v28 == -1)
          {
            int v33 = 0;
          }
          else
          {
            std::string::size_type v29 = v28;
            std::string::size_type v30 = v28 + 1;
            std::string::size_type size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
            if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
              std::string::size_type size = __str.__r_.__value_.__l.__size_;
            }
            if (v30 >= size)
            {
              int v33 = 0;
            }
            else
            {
              uint64_t v32 = std::string::basic_string(&v88, &__str, v30, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v77);
              if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0)
              {
                uint8x8_t v34 = (void *)v88.__r_.__value_.__r.__words[0];
                int v33 = atoi(v88.__r_.__value_.__l.__data_);
                operator delete(v34);
              }
              else
              {
                int v33 = atoi((const char *)v32);
              }
            }
            std::string::basic_string(&v88, &__str, 0, v29, (std::allocator<char> *)&v77);
            if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
              operator delete(__str.__r_.__value_.__l.__data_);
            }
            std::string __str = v88;
          }
          char v35 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          int v36 = *(char *)(a3 + 23);
          if (v36 >= 0) {
            size_t v37 = *(unsigned __int8 *)(a3 + 23);
          }
          else {
            size_t v37 = *(void *)(a3 + 8);
          }
          if (v36 >= 0) {
            size_t v38 = (const std::string::value_type *)a3;
          }
          else {
            size_t v38 = *(const std::string::value_type **)a3;
          }
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            std::string::size_type v39 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          }
          else {
            std::string::size_type v39 = __str.__r_.__value_.__l.__size_;
          }
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            p_str = &__str;
          }
          else {
            p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          if (v39 >= v37) {
            size_t v41 = v37;
          }
          else {
            size_t v41 = v39;
          }
          if (!memcmp(v38, p_str, v41) && v39 == v37)
          {
            LODWORD(v77) = 0;
            if (grl::codec::ResourcePack::PackSupportsContentScale((const std::string *)v24, (float *)&v77, *(float *)(a3 + 24)))
            {
              int v43 = v77;
              if (*(float *)&v77 > *(float *)&v83 || *(float *)&v77 == *(float *)&v83 && v33 >= v72)
              {
                if (*(char *)(v24 + 23) < 0)
                {
                  std::string::__init_copy_ctor_external(&v88, *(const std::string::value_type **)v24, *(void *)(v24 + 8));
                  int v43 = v77;
                }
                else
                {
                  long long v44 = *(_OWORD *)v24;
                  v88.__r_.__value_.__r.__words[2] = *(void *)(v24 + 16);
                  *(_OWORD *)&v88.__r_.__value_.__l.__data_ = v44;
                }
                LODWORD(v89) = v43;
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
                {
                  operator delete(__p.__r_.__value_.__l.__data_);
                  int v43 = LODWORD(v89);
                }
                std::string __p = v88;
                LODWORD(v83) = v43;
                int v72 = v33;
              }
            }
            char v35 = HIBYTE(__str.__r_.__value_.__r.__words[2]);
          }
          if (v35 < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
        }
      }
      else if (!v26)
      {
        goto LABEL_35;
      }
      v24 += 24;
    }
    while (v24 != v23);
  }
  std::string::size_type v45 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v45 = __p.__r_.__value_.__l.__size_;
  }
  if (!v45)
  {
    if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
    }
    unint64_t v46 = GEOGetGeoResourceLibIconManagerLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
    {
      if (a4 > 2) {
        unint64_t v47 = "";
      }
      else {
        unint64_t v47 = off_1E5AB2BF8[(char)a4];
      }
      if (*(char *)(a3 + 23) >= 0) {
        uint64_t v48 = (const std::string::value_type *)a3;
      }
      else {
        uint64_t v48 = *(const std::string::value_type **)a3;
      }
      double v49 = *(float *)(a3 + 24);
      LODWORD(v88.__r_.__value_.__l.__data_) = 136315650;
      *(std::string::size_type *)((char *)v88.__r_.__value_.__r.__words + 4) = (std::string::size_type)v47;
      WORD2(v88.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v88.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v48;
      HIWORD(v88.__r_.__value_.__r.__words[2]) = 2048;
      double v89 = v49;
      _os_log_impl(&dword_1A1780000, v46, OS_LOG_TYPE_ERROR, "No packs of type %s available for key: [%s, %f]", (uint8_t *)&v88, 0x20u);
    }
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(&v88, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
  }
  else
  {
    std::string v88 = __p;
  }
  std::string::size_type v50 = HIBYTE(v88.__r_.__value_.__r.__words[2]);
  if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
    std::string::size_type v50 = v88.__r_.__value_.__l.__size_;
  }
  unint64_t v21 = v71;
  if (v50)
  {
    (*(void (**)(uint64_t *__return_ptr))(**(void **)(a2 + 8) + 56))(&v77);
    uint64_t v51 = v77;
    if (v77)
    {
      uint64_t v52 = v78;
      if (v78)
      {
        atomic_fetch_add_explicit(&v78->__shared_owners_, 1uLL, memory_order_relaxed);
        grl::IconManager::decodePack(&v75, a2, v51, v52, a3, a4);
        std::__shared_weak_count::__release_shared[abi:ne180100](v52);
      }
      else
      {
        grl::IconManager::decodePack(&v75, a2, v77, 0, a3, a4);
      }
      if (v75)
      {
        unint64_t v62 = v76;
        *a1 = v75;
        a1[1] = v62;
      }
      else
      {
        if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
          dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
        }
        unint64_t v63 = GEOGetGeoResourceLibIconManagerLog::log;
        if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
        {
          if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            uint64_t v64 = &v88;
          }
          else {
            uint64_t v64 = (std::string *)v88.__r_.__value_.__r.__words[0];
          }
          if (*(char *)(a3 + 23) >= 0) {
            uint64_t v65 = (const std::string::value_type *)a3;
          }
          else {
            uint64_t v65 = *(const std::string::value_type **)a3;
          }
          double v66 = *(float *)(a3 + 24);
          if (a4 > 2) {
            uint64_t v67 = "";
          }
          else {
            uint64_t v67 = off_1E5AB2BF8[(char)a4];
          }
          grl::buildStringFromResourceNames(**a5, 0xAAAAAAAAAAAAAAABLL * (((*a5)[1] - **a5) >> 3), &__str);
          if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
            double v70 = &__str;
          }
          else {
            double v70 = (std::string *)__str.__r_.__value_.__r.__words[0];
          }
          LODWORD(__p.__r_.__value_.__l.__data_) = 136316162;
          *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v64;
          WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
          *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v65;
          HIWORD(__p.__r_.__value_.__r.__words[2]) = 2048;
          double v83 = v66;
          __int16 v84 = 2080;
          uint64_t v85 = (std::string *)v67;
          __int16 v86 = 2080;
          unint64_t v87 = v70;
          _os_log_impl(&dword_1A1780000, v63, OS_LOG_TYPE_ERROR, "Failed to decode pack for packName:%s packKey:%s.%f packType:%s resourceNames:%s", (uint8_t *)&__p, 0x34u);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
            operator delete(__str.__r_.__value_.__l.__data_);
          }
          unint64_t v21 = v71;
        }
        *a1 = 0;
        a1[1] = 0;
        if (v76) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v76);
        }
      }
    }
    else
    {
      if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
        dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
      }
      uint64_t v57 = GEOGetGeoResourceLibIconManagerLog::log;
      if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
      {
        if ((v88.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v58 = &v88;
        }
        else {
          uint64_t v58 = (std::string *)v88.__r_.__value_.__r.__words[0];
        }
        if (*(char *)(a3 + 23) >= 0) {
          unint64_t v59 = (const std::string::value_type *)a3;
        }
        else {
          unint64_t v59 = *(const std::string::value_type **)a3;
        }
        double v60 = *(float *)(a3 + 24);
        if (a4 > 2) {
          uint64_t v61 = "";
        }
        else {
          uint64_t v61 = off_1E5AB2BF8[(char)a4];
        }
        grl::buildStringFromResourceNames(**a5, 0xAAAAAAAAAAAAAAABLL * (((*a5)[1] - **a5) >> 3), &__str);
        if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          uint64_t v69 = &__str;
        }
        else {
          uint64_t v69 = (std::string *)__str.__r_.__value_.__r.__words[0];
        }
        LODWORD(__p.__r_.__value_.__l.__data_) = 136316162;
        *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v58;
        WORD2(__p.__r_.__value_.__r.__words[1]) = 2080;
        *(std::string::size_type *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v59;
        HIWORD(__p.__r_.__value_.__r.__words[2]) = 2048;
        double v83 = v60;
        __int16 v84 = 2080;
        uint64_t v85 = (std::string *)v61;
        __int16 v86 = 2080;
        unint64_t v87 = v69;
        _os_log_impl(&dword_1A1780000, v57, OS_LOG_TYPE_ERROR, "Failed to stream resource for packName:%s packKey:%s.%f packType:%s resourceNames:%s", (uint8_t *)&__p, 0x34u);
        if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__str.__r_.__value_.__l.__data_);
        }
        unint64_t v21 = v71;
      }
      *a1 = 0;
      a1[1] = 0;
    }
    if (v78) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v78);
    }
  }
  else
  {
    if (GEOGetGeoResourceLibIconManagerLog::onceToken != -1) {
      dispatch_once(&GEOGetGeoResourceLibIconManagerLog::onceToken, &__block_literal_global_1);
    }
    uint64_t v53 = GEOGetGeoResourceLibIconManagerLog::log;
    if (os_log_type_enabled((os_log_t)GEOGetGeoResourceLibIconManagerLog::log, OS_LOG_TYPE_ERROR))
    {
      if (*(char *)(a3 + 23) >= 0) {
        BOOL v54 = (const std::string::value_type *)a3;
      }
      else {
        BOOL v54 = *(const std::string::value_type **)a3;
      }
      double v55 = *(float *)(a3 + 24);
      if (a4 > 2) {
        uint64_t v56 = "";
      }
      else {
        uint64_t v56 = off_1E5AB2BF8[(char)a4];
      }
      grl::buildStringFromResourceNames(**a5, 0xAAAAAAAAAAAAAAABLL * (((*a5)[1] - **a5) >> 3), &__str);
      if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
        uint64_t v68 = &__str;
      }
      else {
        uint64_t v68 = (std::string *)__str.__r_.__value_.__r.__words[0];
      }
      LODWORD(__p.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)__p.__r_.__value_.__r.__words + 4) = (std::string::size_type)v54;
      WORD2(__p.__r_.__value_.__r.__words[1]) = 2048;
      *(double *)((char *)&__p.__r_.__value_.__r.__words[1] + 6) = v55;
      HIWORD(__p.__r_.__value_.__r.__words[2]) = 2080;
      double v83 = *(double *)&v56;
      __int16 v84 = 2080;
      uint64_t v85 = v68;
      _os_log_impl(&dword_1A1780000, v53, OS_LOG_TYPE_ERROR, "Failed to resolve packName for packKey:%s.%f packType:%s with resourceNames:%s", (uint8_t *)&__p, 0x2Au);
      if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
        operator delete(__str.__r_.__value_.__l.__data_);
      }
      unint64_t v21 = v71;
    }
    *a1 = 0;
    a1[1] = 0;
  }
  if (SHIBYTE(v88.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(v88.__r_.__value_.__l.__data_);
  }
  if (v80) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v80);
  }
LABEL_168:
  std::mutex::unlock(v21);
}

std::string *grl::codec::ResourcePack::PackExtension@<X0>(const std::string *a1@<X0>, std::string *a2@<X8>)
{
  std::string::size_type v4 = std::string::rfind(a1, 46, 0xFFFFFFFFFFFFFFFFLL) + 1;
  if (v4 > 1) {
    return std::string::basic_string(a2, a1, v4, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v6);
  }
  return (std::string *)std::string::basic_string[abi:nn180100]<0>(a2, (char *)&str_1_1);
}

std::string *grl::codec::ResourcePack::RegionForPack@<X0>(const std::string *a1@<X0>, uint64_t a2@<X8>)
{
  std::string::size_type v4 = std::string::find(a1, 64, 0);
  if (v4 == -1) {
    std::string::size_type v4 = std::string::find(a1, 46, 0);
  }
  uint64_t result = std::string::basic_string((std::string *)a2, a1, 0, v4, (std::allocator<char> *)&v8);
  uint64_t v6 = *(unsigned __int8 *)(a2 + 23);
  if ((v6 & 0x80u) == 0) {
    unint64_t v7 = (unsigned char *)a2;
  }
  else {
    unint64_t v7 = *(unsigned char **)a2;
  }
  if ((v6 & 0x80u) != 0) {
    uint64_t v6 = *(void *)(a2 + 8);
  }
  for (; v6; --v6)
  {
    if (*v7 == 95) {
      unsigned char *v7 = 32;
    }
    ++v7;
  }
  return result;
}

BOOL grl::codec::ResourcePack::PackSupportsContentScale(const std::string *a1, float *a2, float a3)
{
  std::string::size_type v6 = std::string::find(a1, 64, 0);
  if (v6 == -1)
  {
    float v10 = 1.0;
  }
  else
  {
    std::string::size_type v7 = v6;
    std::string::size_type v8 = std::string::find(a1, 120, v6);
    std::string::basic_string(&v13, a1, v7 + 1, v8 - (v7 + 1), (std::allocator<char> *)&__p);
    if ((v13.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      uint8x8_t v9 = &v13;
    }
    else {
      uint8x8_t v9 = (std::string *)v13.__r_.__value_.__r.__words[0];
    }
    std::string::basic_string[abi:nn180100]<0>(&__p, (char *)v9);
    float v10 = std::stof(&__p, 0);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(v13.__r_.__value_.__l.__data_);
    }
  }
  if (a2) {
    *a2 = v10;
  }
  return v10 <= ceilf(a3);
}

void md::GeoResourceProvider::streamForResourceName(uint64_t *a1@<X1>, void *a2@<X8>)
{
  std::string::size_type v4 = [MEMORY[0x1E4F64908] sharedManager];
  if (*((char *)a1 + 23) >= 0) {
    uint8x8_t v5 = a1;
  }
  else {
    uint8x8_t v5 = (uint64_t *)*a1;
  }
  std::string::size_type v6 = [NSString stringWithUTF8String:v5];
  id v14 = [v4 pathForResourceWithName:v6 fallbackBundle:0 fallbackNameHandler:&__block_literal_global_82];

  if (v14 && [v14 UTF8String])
  {
    std::string::size_type v7 = (std::__shared_weak_count *)operator new(0x258uLL);
    v7->__shared_owners_ = 0;
    v7->__shared_weak_owners_ = 0;
    v7->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58B150;
    std::string::size_type v8 = &v7[1].__vftable;
    uint64_t v9 = MEMORY[0x1E4FBA460] + 64;
    v7[18].__shared_weak_owners_ = MEMORY[0x1E4FBA460] + 64;
    float v10 = *(std::__shared_weak_count_vtbl **)(MEMORY[0x1E4FBA3F8] + 16);
    uint64_t v11 = *(std::__shared_weak_count_vtbl **)(MEMORY[0x1E4FBA3F8] + 8);
    v7[1].__vftable = v11;
    *(std::__shared_weak_count_vtbl **)((char *)&v7[1].__vftable + (unint64_t)v11[-1].__on_zero_shared) = v10;
    v7[1].__shared_owners_ = 0;
    BOOL v12 = (std::ios_base *)((char *)&v7[1] + (unint64_t)v7[1].__vftable[-1].__on_zero_shared);
    std::ios_base::init(v12, &v7[1].__shared_weak_owners_);
    uint64_t v13 = MEMORY[0x1E4FBA460] + 24;
    v12[1].__vftable = 0;
    v12[1].__fmtflags_ = -1;
    v7[1].__vftable = (std::__shared_weak_count_vtbl *)v13;
    v7[18].__shared_weak_owners_ = v9;
    MEMORY[0x1A6238C00](&v7[1].__shared_weak_owners_);
    if (!std::filebuf::open()) {
      std::ios_base::clear((std::ios_base *)((char *)v8 + *(void *)(*v8 - 24)), *(_DWORD *)((char *)v8 + *(void *)(*v8 - 24) + 32) | 4);
    }
    if (v7[6].__shared_weak_owners_)
    {
      *a2 = v8;
      a2[1] = v7;
    }
    else
    {
      *a2 = 0;
      a2[1] = 0;
      if (!atomic_fetch_add(&v7->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
        std::__shared_weak_count::__release_weak(v7);
      }
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
}

void sub_1A1AC45A8(_Unwind_Exception *a1)
{
  std::istream::~istream();
  MEMORY[0x1A62391A0](v3);
  std::__shared_weak_count::~__shared_weak_count(v2);
  operator delete(v5);

  _Unwind_Resume(a1);
}

void grl::IconManager::decodePack(grl::codec::IconDataPack **a1, uint64_t a2, uint64_t a3, std::__shared_weak_count *a4, uint64_t a5, int a6)
{
  if (a6 != 2)
  {
    if (a6 != 1)
    {
      if (!a6)
      {
        if (a4)
        {
          atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!a3) {
            goto LABEL_12;
          }
LABEL_25:
          BOOL v12 = (std::__shared_weak_count *)operator new(0x1A8uLL);
          v12->__shared_owners_ = 0;
          v12->__shared_weak_owners_ = 0;
          v12->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A350;
          uint64_t v13 = (grl::codec::IconDataPack *)&v12[1];
          std::string::size_type v28 = grl::codec::IconDataPack::IconDataPack((grl::codec::IconDataPack *)&v12[1], -1);
          uint64_t v153 = a3;
          uint64_t v154 = a4;
          char v29 = ((uint64_t (*)(grl::codec::IconDataPack *, uint64_t *))v12[1].__on_zero_shared_weak)(v28, &v153);
          if (v154) {
            std::__shared_weak_count::__release_shared[abi:ne180100](v154);
          }
          if (v29)
          {
            grl::codec::IconDataPack::setImageAtlasSize(v13, *(void *)(a2 + 472));
            if (!*(unsigned char *)(a2 + 88))
            {
              unint64_t v16 = (std::__shared_mutex_base *)(a2 + 104);
              std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(a2 + 104));
              uint64_t v30 = *(void *)(a2 + 96);
              if (v30)
              {
                long long v18 = (std::mutex *)(v30 + 240);
                std::mutex::lock((std::mutex *)(v30 + 240));
                uint64_t v31 = *(void *)(a2 + 96);
                uint64_t v32 = (void *)(v31 + 40);
                uint64_t v21 = geo::LRUPolicy<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash>::get(v31 + 80, (void *)(v31 + 40), (float *)a5);
                if (v31 + 80 == v21)
                {
                  uint64_t v148 = v18;
                  int v33 = std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::find<std::pair<std::string,float>>((void *)(v31 + 40), (float *)a5);
                  if (v33)
                  {
                    uint8x8_t v34 = (char *)v33;
                    char v35 = (uint64_t *)*((void *)v33 + 6);
                    uint64_t v36 = *v35;
                    *(void *)(v36 + 8) = v35[1];
                    *(void *)v35[1] = v36;
                    --*(void *)(v31 + 96);
                    std::__destroy_at[abi:nn180100]<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,0>((uint64_t)(v35 + 2));
                    operator delete(v35);
                    std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::erase((void *)(v31 + 40), v34);
                  }
                  size_t v37 = (char *)operator new(0x40uLL);
                  size_t v38 = (std::string *)(v37 + 16);
                  *(void *)size_t v37 = 0;
                  *((void *)v37 + 1) = 0;
                  if (*(char *)(a5 + 23) < 0)
                  {
                    std::string::__init_copy_ctor_external(v38, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
                  }
                  else
                  {
                    *(_OWORD *)&v38->__r_.__value_.__l.__data_ = *(_OWORD *)a5;
                    *((void *)v37 + 4) = *(void *)(a5 + 16);
                  }
                  *((_DWORD *)v37 + 10) = *(_DWORD *)(a5 + 24);
                  *((void *)v37 + 6) = 0;
                  *((void *)v37 + 7) = 0;
                  *(void *)size_t v37 = v31 + 80;
                  uint64_t v77 = *(void **)(v31 + 88);
                  *((void *)v37 + 1) = v77;
                  *uint64_t v77 = v37;
                  uint64_t v78 = *(void *)(v31 + 96) + 1;
                  *(void *)(v31 + 88) = v37;
                  *(void *)(v31 + 96) = v78;
                  unint64_t v79 = grl::codec::PackKeyHash::operator()(a5);
                  unint64_t v80 = *(void *)(v31 + 48);
                  unint64_t v152 = v79;
                  long long v149 = v16;
                  if (v80)
                  {
                    unint64_t v81 = v79;
                    uint8x8_t v82 = (uint8x8_t)vcnt_s8((int8x8_t)v80);
                    v82.i16[0] = vaddlv_u8(v82);
                    unint64_t v83 = v82.u32[0];
                    if (v82.u32[0] > 1uLL)
                    {
                      unint64_t v84 = v79;
                      if (v79 >= v80) {
                        unint64_t v84 = v79 % v80;
                      }
                    }
                    else
                    {
                      unint64_t v84 = (v80 - 1) & v79;
                    }
                    uint64_t v100 = *(unsigned __int8 ***)(*v32 + 8 * v84);
                    unint64_t v150 = v84;
                    if (v100)
                    {
                      for (uint64_t i = *v100; i; uint64_t i = *(unsigned __int8 **)i)
                      {
                        unint64_t v102 = *((void *)i + 1);
                        if (v102 == v81)
                        {
                          BOOL v103 = std::equal_to<std::pair<std::string,float>>::operator()[abi:nn180100](i + 16, (float *)a5);
                          unint64_t v84 = v150;
                          unint64_t v81 = v152;
                          if (v103) {
                            goto LABEL_219;
                          }
                        }
                        else
                        {
                          if (v83 > 1)
                          {
                            if (v102 >= v80) {
                              v102 %= v80;
                            }
                          }
                          else
                          {
                            v102 &= v80 - 1;
                          }
                          if (v102 != v84) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  uint64_t v104 = (void *)(v31 + 56);
                  uint64_t v105 = (char *)operator new(0x38uLL);
                  unint64_t v106 = v152;
                  *(void *)uint64_t v105 = 0;
                  *((void *)v105 + 1) = v152;
                  unint64_t v107 = (std::string *)(v105 + 16);
                  if (*(char *)(a5 + 23) < 0)
                  {
                    std::string::__init_copy_ctor_external(v107, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
                    unint64_t v106 = v152;
                  }
                  else
                  {
                    *(_OWORD *)&v107->__r_.__value_.__l.__data_ = *(_OWORD *)a5;
                    *((void *)v105 + 4) = *(void *)(a5 + 16);
                  }
                  unint64_t v108 = v150;
                  *((_DWORD *)v105 + 10) = *(_DWORD *)(a5 + 24);
                  *((void *)v105 + 6) = v37;
                  float v109 = (float)(unint64_t)(*(void *)(v31 + 64) + 1);
                  float v110 = *(float *)(v31 + 72);
                  if (v80 && (float)(v110 * (float)v80) >= v109)
                  {
LABEL_209:
                    long long v142 = (void *)*v32;
                    uint64_t v143 = *(void **)(*v32 + 8 * v108);
                    if (v143)
                    {
                      *(void *)uint64_t v105 = *v143;
                    }
                    else
                    {
                      *(void *)uint64_t v105 = *v104;
                      *uint64_t v104 = v105;
                      v142[v108] = v104;
                      if (!*(void *)v105) {
                        goto LABEL_218;
                      }
                      unint64_t v144 = *(void *)(*(void *)v105 + 8);
                      if ((v80 & (v80 - 1)) != 0)
                      {
                        if (v144 >= v80) {
                          v144 %= v80;
                        }
                      }
                      else
                      {
                        v144 &= v80 - 1;
                      }
                      uint64_t v143 = (void *)(*v32 + 8 * v144);
                    }
                    *uint64_t v143 = v105;
LABEL_218:
                    ++*(void *)(v31 + 64);
LABEL_219:
                    while (*(void *)(v31 + 96) > *(void *)(v31 + 32))
                      geo::Cache<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash,geo::LRUPolicy>::_pop((void *)(v31 + 32));
                    uint64_t v21 = *(void *)(v31 + 88);
LABEL_222:
                    long long v18 = v148;
                    unint64_t v16 = v149;
                    goto LABEL_223;
                  }
                  BOOL v111 = 1;
                  if (v80 >= 3) {
                    BOOL v111 = (v80 & (v80 - 1)) != 0;
                  }
                  unint64_t v112 = v111 | (2 * v80);
                  unint64_t v113 = vcvtps_u32_f32(v109 / v110);
                  if (v112 <= v113) {
                    size_t v114 = v113;
                  }
                  else {
                    size_t v114 = v112;
                  }
                  if (v114 == 1)
                  {
                    size_t v114 = 2;
                  }
                  else if ((v114 & (v114 - 1)) != 0)
                  {
                    size_t prime = std::__next_prime(v114);
                    unint64_t v106 = v152;
                    size_t v114 = prime;
                  }
                  unint64_t v80 = *(void *)(v31 + 48);
                  if (v114 > v80)
                  {
LABEL_136:
                    if (!(v114 >> 61))
                    {
                      int64_t v123 = operator new(8 * v114);
                      uint64_t v124 = (void *)*v32;
                      *uint64_t v32 = v123;
                      if (v124) {
                        operator delete(v124);
                      }
                      uint64_t v125 = 0;
                      *(void *)(v31 + 48) = v114;
                      do
                        *(void *)(*v32 + 8 * v125++) = 0;
                      while (v114 != v125);
                      uint64_t v126 = (void *)*v104;
                      unint64_t v106 = v152;
                      if (*v104)
                      {
                        size_t v127 = v126[1];
                        uint8x8_t v128 = (uint8x8_t)vcnt_s8((int8x8_t)v114);
                        v128.i16[0] = vaddlv_u8(v128);
                        if (v128.u32[0] > 1uLL)
                        {
                          if (v127 >= v114) {
                            v127 %= v114;
                          }
                        }
                        else
                        {
                          v127 &= v114 - 1;
                        }
                        *(void *)(*v32 + 8 * v127) = v104;
                        uint64_t v140 = (void *)*v126;
                        if (*v126)
                        {
                          do
                          {
                            size_t v141 = v140[1];
                            if (v128.u32[0] > 1uLL)
                            {
                              if (v141 >= v114) {
                                v141 %= v114;
                              }
                            }
                            else
                            {
                              v141 &= v114 - 1;
                            }
                            if (v141 != v127)
                            {
                              if (!*(void *)(*v32 + 8 * v141))
                              {
                                *(void *)(*v32 + 8 * v141) = v126;
                                goto LABEL_200;
                              }
                              *uint64_t v126 = *v140;
                              *uint64_t v140 = **(void **)(*v32 + 8 * v141);
                              **(void **)(*v32 + 8 * v141) = v140;
                              uint64_t v140 = v126;
                            }
                            size_t v141 = v127;
LABEL_200:
                            uint64_t v126 = v140;
                            uint64_t v140 = (void *)*v140;
                            size_t v127 = v141;
                          }
                          while (v140);
                        }
                      }
                      unint64_t v80 = v114;
                      goto LABEL_204;
                    }
LABEL_247:
                    std::__throw_bad_array_new_length[abi:nn180100]();
                  }
                  if (v114 < v80)
                  {
                    unint64_t v132 = vcvtps_u32_f32((float)*(unint64_t *)(v31 + 64) / *(float *)(v31 + 72));
                    if (v80 < 3
                      || (uint8x8_t v133 = (uint8x8_t)vcnt_s8((int8x8_t)v80), v133.i16[0] = vaddlv_u8(v133), v133.u32[0] > 1uLL))
                    {
                      unint64_t v132 = std::__next_prime(v132);
                      unint64_t v106 = v152;
                    }
                    else
                    {
                      uint64_t v134 = 1 << -(char)__clz(v132 - 1);
                      if (v132 >= 2) {
                        unint64_t v132 = v134;
                      }
                    }
                    if (v114 <= v132) {
                      size_t v114 = v132;
                    }
                    if (v114 >= v80)
                    {
                      unint64_t v80 = *(void *)(v31 + 48);
                    }
                    else
                    {
                      if (v114) {
                        goto LABEL_136;
                      }
                      unint64_t v147 = (void *)*v32;
                      *uint64_t v32 = 0;
                      if (v147) {
                        operator delete(v147);
                      }
                      unint64_t v80 = 0;
                      *(void *)(v31 + 48) = 0;
                      unint64_t v106 = v152;
                    }
                  }
LABEL_204:
                  if ((v80 & (v80 - 1)) != 0)
                  {
                    if (v106 >= v80) {
                      unint64_t v108 = v106 % v80;
                    }
                    else {
                      unint64_t v108 = v106;
                    }
                  }
                  else
                  {
                    unint64_t v108 = (v80 - 1) & v106;
                  }
                  goto LABEL_209;
                }
LABEL_223:
                atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
                unint64_t v145 = *(std::__shared_weak_count **)(v21 + 56);
                *(void *)(v21 + 48) = v13;
                *(void *)(v21 + 56) = v12;
                if (v145) {
                  std::__shared_weak_count::__release_shared[abi:ne180100](v145);
                }
                uint64_t v68 = v18;
LABEL_226:
                std::mutex::unlock(v68);
              }
LABEL_227:
              std::__shared_mutex_base::unlock_shared(v16);
              goto LABEL_228;
            }
            goto LABEL_228;
          }
LABEL_48:
          uint64_t v11 = v12;
          goto LABEL_49;
        }
        if (a3) {
          goto LABEL_25;
        }
      }
LABEL_50:
      *a1 = 0;
      a1[1] = 0;
      return;
    }
    if (a4)
    {
      atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
      if (!a3)
      {
LABEL_12:
        uint64_t v11 = a4;
LABEL_49:
        std::__shared_weak_count::__release_shared[abi:ne180100](v11);
        goto LABEL_50;
      }
    }
    else if (!a3)
    {
      goto LABEL_50;
    }
    BOOL v12 = (std::__shared_weak_count *)operator new(0x140uLL);
    v12->__shared_owners_ = 0;
    v12->__shared_weak_owners_ = 0;
    v12->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A388;
    uint64_t v13 = (grl::codec::IconDataPack *)&v12[1];
    id v14 = grl::codec::IconConfigPack::IconConfigPack((grl::codec::IconConfigPack *)&v12[1], -1);
    uint64_t v153 = a3;
    uint64_t v154 = a4;
    char v15 = ((uint64_t (*)(grl::codec::IconConfigPack *, uint64_t *))v12[1].__on_zero_shared_weak)(v14, &v153);
    if (v154) {
      std::__shared_weak_count::__release_shared[abi:ne180100](v154);
    }
    if ((v15 & 1) == 0) {
      goto LABEL_48;
    }
    grl::codec::IconConfigPack::setLocationCacheSize(v13, *(void *)(a2 + 480));
    if (*(unsigned char *)(a2 + 88)) {
      goto LABEL_228;
    }
    unint64_t v16 = (std::__shared_mutex_base *)(a2 + 104);
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(a2 + 104));
    uint64_t v17 = *(void *)(a2 + 96);
    if (!v17) {
      goto LABEL_227;
    }
    long long v18 = (std::mutex *)(v17 + 304);
    std::mutex::lock((std::mutex *)(v17 + 304));
    uint64_t v19 = *(void *)(a2 + 96);
    unint64_t v20 = (void *)(v19 + 112);
    uint64_t v21 = geo::LRUPolicy<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash>::get(v19 + 152, (void *)(v19 + 112), (float *)a5);
    if (v19 + 152 != v21) {
      goto LABEL_223;
    }
    uint64_t v148 = v18;
    uint64_t v22 = std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::find<std::pair<std::string,float>>((void *)(v19 + 112), (float *)a5);
    if (v22)
    {
      uint64_t v23 = (char *)v22;
      uint64_t v24 = (uint64_t *)*((void *)v22 + 6);
      uint64_t v25 = *v24;
      *(void *)(v25 + 8) = v24[1];
      *(void *)v24[1] = v25;
      --*(void *)(v19 + 168);
      std::__destroy_at[abi:nn180100]<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,0>((uint64_t)(v24 + 2));
      operator delete(v24);
      std::__hash_table<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::__unordered_map_hasher<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,grl::codec::PackKeyHash,std::equal_to<std::pair<std::string,float>>,true>,std::__unordered_map_equal<std::pair<std::string,float>,std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>,std::equal_to<std::pair<std::string,float>>,grl::codec::PackKeyHash,true>,std::allocator<std::__hash_value_type<std::pair<std::string,float>,std::__list_iterator<std::pair<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>>,void *>>>>::erase((void *)(v19 + 112), v23);
    }
    int v26 = (char *)operator new(0x40uLL);
    int v27 = (std::string *)(v26 + 16);
    *(void *)int v26 = 0;
    *((void *)v26 + 1) = 0;
    if (*(char *)(a5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v27, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
    }
    else
    {
      *(_OWORD *)&v27->__r_.__value_.__l.__data_ = *(_OWORD *)a5;
      *((void *)v26 + 4) = *(void *)(a5 + 16);
    }
    *((_DWORD *)v26 + 10) = *(_DWORD *)(a5 + 24);
    *((void *)v26 + 6) = 0;
    *((void *)v26 + 7) = 0;
    *(void *)int v26 = v19 + 152;
    uint64_t v69 = *(void **)(v19 + 160);
    *((void *)v26 + 1) = v69;
    void *v69 = v26;
    uint64_t v70 = *(void *)(v19 + 168) + 1;
    *(void *)(v19 + 160) = v26;
    *(void *)(v19 + 168) = v70;
    unint64_t v71 = grl::codec::PackKeyHash::operator()(a5);
    unint64_t v72 = *(void *)(v19 + 120);
    unint64_t v151 = v71;
    long long v149 = v16;
    if (v72)
    {
      unint64_t v73 = v71;
      uint8x8_t v74 = (uint8x8_t)vcnt_s8((int8x8_t)v72);
      v74.i16[0] = vaddlv_u8(v74);
      unint64_t v75 = v74.u32[0];
      if (v74.u32[0] > 1uLL)
      {
        unint64_t v76 = v71;
        if (v71 >= v72) {
          unint64_t v76 = v71 % v72;
        }
      }
      else
      {
        unint64_t v76 = (v72 - 1) & v71;
      }
      uint64_t v85 = *(unsigned __int8 ***)(*v20 + 8 * v76);
      unint64_t v150 = v76;
      if (v85)
      {
        for (uint64_t j = *v85; j; uint64_t j = *(unsigned __int8 **)j)
        {
          unint64_t v87 = *((void *)j + 1);
          if (v87 == v73)
          {
            BOOL v88 = std::equal_to<std::pair<std::string,float>>::operator()[abi:nn180100](j + 16, (float *)a5);
            unint64_t v76 = v150;
            unint64_t v73 = v151;
            if (v88) {
              goto LABEL_186;
            }
          }
          else
          {
            if (v75 > 1)
            {
              if (v87 >= v72) {
                v87 %= v72;
              }
            }
            else
            {
              v87 &= v72 - 1;
            }
            if (v87 != v76) {
              break;
            }
          }
        }
      }
    }
    double v89 = (void *)(v19 + 128);
    uint64_t v90 = (char *)operator new(0x38uLL);
    unint64_t v91 = v151;
    *(void *)uint64_t v90 = 0;
    *((void *)v90 + 1) = v151;
    size_t v92 = (std::string *)(v90 + 16);
    if (*(char *)(a5 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v92, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
      unint64_t v91 = v151;
    }
    else
    {
      *(_OWORD *)&v92->__r_.__value_.__l.__data_ = *(_OWORD *)a5;
      *((void *)v90 + 4) = *(void *)(a5 + 16);
    }
    unint64_t v93 = v150;
    *((_DWORD *)v90 + 10) = *(_DWORD *)(a5 + 24);
    *((void *)v90 + 6) = v26;
    float v94 = (float)(unint64_t)(*(void *)(v19 + 136) + 1);
    float v95 = *(float *)(v19 + 144);
    if (v72 && (float)(v95 * (float)v72) >= v94)
    {
LABEL_176:
      unint64_t v137 = (void *)*v20;
      uint64_t v138 = *(void **)(*v20 + 8 * v93);
      if (v138)
      {
        *(void *)uint64_t v90 = *v138;
      }
      else
      {
        *(void *)uint64_t v90 = *v89;
        void *v89 = v90;
        v137[v93] = v89;
        if (!*(void *)v90) {
          goto LABEL_185;
        }
        unint64_t v139 = *(void *)(*(void *)v90 + 8);
        if ((v72 & (v72 - 1)) != 0)
        {
          if (v139 >= v72) {
            v139 %= v72;
          }
        }
        else
        {
          v139 &= v72 - 1;
        }
        uint64_t v138 = (void *)(*v20 + 8 * v139);
      }
      *uint64_t v138 = v90;
LABEL_185:
      ++*(void *)(v19 + 136);
LABEL_186:
      while (*(void *)(v19 + 168) > *(void *)(v19 + 104))
        geo::Cache<std::pair<std::string,float>,std::shared_ptr<grl::codec::IconDataPack>,grl::codec::PackKeyHash,geo::LRUPolicy>::_pop((void *)(v19 + 104));
      uint64_t v21 = *(void *)(v19 + 160);
      goto LABEL_222;
    }
    BOOL v96 = 1;
    if (v72 >= 3) {
      BOOL v96 = (v72 & (v72 - 1)) != 0;
    }
    unint64_t v97 = v96 | (2 * v72);
    unint64_t v98 = vcvtps_u32_f32(v94 / v95);
    if (v97 <= v98) {
      size_t v99 = v98;
    }
    else {
      size_t v99 = v97;
    }
    if (v99 == 1)
    {
      size_t v99 = 2;
    }
    else if ((v99 & (v99 - 1)) != 0)
    {
      size_t v115 = std::__next_prime(v99);
      unint64_t v91 = v151;
      size_t v99 = v115;
    }
    unint64_t v72 = *(void *)(v19 + 120);
    if (v99 > v72) {
      goto LABEL_125;
    }
    if (v99 < v72)
    {
      unint64_t v129 = vcvtps_u32_f32((float)*(unint64_t *)(v19 + 136) / *(float *)(v19 + 144));
      if (v72 < 3 || (uint8x8_t v130 = (uint8x8_t)vcnt_s8((int8x8_t)v72), v130.i16[0] = vaddlv_u8(v130), v130.u32[0] > 1uLL))
      {
        unint64_t v129 = std::__next_prime(v129);
        unint64_t v91 = v151;
      }
      else
      {
        uint64_t v131 = 1 << -(char)__clz(v129 - 1);
        if (v129 >= 2) {
          unint64_t v129 = v131;
        }
      }
      if (v99 <= v129) {
        size_t v99 = v129;
      }
      if (v99 >= v72)
      {
        unint64_t v72 = *(void *)(v19 + 120);
      }
      else
      {
        if (v99)
        {
LABEL_125:
          if (v99 >> 61) {
            goto LABEL_247;
          }
          uint64_t v116 = operator new(8 * v99);
          uint64_t v117 = (void *)*v20;
          *unint64_t v20 = v116;
          if (v117) {
            operator delete(v117);
          }
          uint64_t v118 = 0;
          *(void *)(v19 + 120) = v99;
          do
            *(void *)(*v20 + 8 * v118++) = 0;
          while (v99 != v118);
          uint64_t v119 = (void *)*v89;
          unint64_t v91 = v151;
          if (*v89)
          {
            size_t v120 = v119[1];
            uint8x8_t v121 = (uint8x8_t)vcnt_s8((int8x8_t)v99);
            v121.i16[0] = vaddlv_u8(v121);
            if (v121.u32[0] > 1uLL)
            {
              if (v120 >= v99) {
                v120 %= v99;
              }
            }
            else
            {
              v120 &= v99 - 1;
            }
            *(void *)(*v20 + 8 * v120) = v89;
            uint64_t v135 = (void *)*v119;
            if (*v119)
            {
              do
              {
                size_t v136 = v135[1];
                if (v121.u32[0] > 1uLL)
                {
                  if (v136 >= v99) {
                    v136 %= v99;
                  }
                }
                else
                {
                  v136 &= v99 - 1;
                }
                if (v136 != v120)
                {
                  if (!*(void *)(*v20 + 8 * v136))
                  {
                    *(void *)(*v20 + 8 * v136) = v119;
                    goto LABEL_167;
                  }
                  void *v119 = *v135;
                  *uint64_t v135 = **(void **)(*v20 + 8 * v136);
                  **(void **)(*v20 + 8 * v136) = v135;
                  uint64_t v135 = v119;
                }
                size_t v136 = v120;
LABEL_167:
                uint64_t v119 = v135;
                uint64_t v135 = (void *)*v135;
                size_t v120 = v136;
              }
              while (v135);
            }
          }
          unint64_t v72 = v99;
          goto LABEL_171;
        }
        uint64_t v146 = (void *)*v20;
        *unint64_t v20 = 0;
        if (v146) {
          operator delete(v146);
        }
        unint64_t v72 = 0;
        *(void *)(v19 + 120) = 0;
        unint64_t v91 = v151;
      }
    }
LABEL_171:
    if ((v72 & (v72 - 1)) != 0)
    {
      if (v91 >= v72) {
        unint64_t v93 = v91 % v72;
      }
      else {
        unint64_t v93 = v91;
      }
    }
    else
    {
      unint64_t v93 = (v72 - 1) & v91;
    }
    goto LABEL_176;
  }
  if (a4)
  {
    atomic_fetch_add_explicit(&a4->__shared_owners_, 1uLL, memory_order_relaxed);
    if (!a3) {
      goto LABEL_12;
    }
  }
  else if (!a3)
  {
    goto LABEL_50;
  }
  BOOL v12 = (std::__shared_weak_count *)operator new(0x1F8uLL);
  v12->__shared_owners_ = 0;
  v12->__shared_weak_owners_ = 0;
  v12->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF58A318;
  uint64_t v13 = (grl::codec::IconDataPack *)&v12[1];
  v12[2].std::__shared_count = 0u;
  *(_OWORD *)&v12[2].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[3].__shared_owners_ = 0u;
  v12[4].std::__shared_count = 0u;
  *(_OWORD *)&v12[4].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[5].__shared_owners_ = 0u;
  v12[6].std::__shared_count = 0u;
  *(_OWORD *)&v12[6].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[7].__shared_owners_ = 0u;
  v12[8].std::__shared_count = 0u;
  *(_OWORD *)&v12[8].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[9].__shared_owners_ = 0u;
  v12[10].std::__shared_count = 0u;
  *(_OWORD *)&v12[10].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[11].__shared_owners_ = 0u;
  v12[12].std::__shared_count = 0u;
  *(_OWORD *)&v12[12].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[13].__shared_owners_ = 0u;
  v12[14].std::__shared_count = 0u;
  *(_OWORD *)&v12[14].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[15].__shared_owners_ = 0u;
  v12[16].std::__shared_count = 0u;
  *(_OWORD *)&v12[16].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[17].__shared_owners_ = 0u;
  v12[18].std::__shared_count = 0u;
  *(_OWORD *)&v12[18].__shared_weak_owners_ = 0u;
  *(_OWORD *)&v12[19].__shared_owners_ = 0u;
  v12[20].std::__shared_count = 0u;
  v12[20].__shared_weak_owners_ = 0;
  *(_OWORD *)&v12[1].__shared_owners_ = 0u;
  v12[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF567250;
  std::string::size_type v39 = (grl::Allocator *)std::string::basic_string[abi:nn180100]<0>(&v12[1].__shared_owners_, "Default");
  LODWORD(v12[2].__shared_owners_) = 1065353216;
  v12[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF5671D0;
  v12[2].__shared_weak_owners_ = 0;
  v12[3].__vftable = 0;
  unint64_t v40 = (grl::Allocator *)grl::Allocator::instance(v39);
  v12[3].__shared_owners_ = (uint64_t)v40;
  v12[3].__shared_weak_owners_ = 0;
  size_t v41 = (grl::Allocator *)grl::Allocator::instance(v40);
  v12[4].__vftable = (std::__shared_weak_count_vtbl *)v41;
  v12[4].__shared_owners_ = 0;
  LODWORD(v12[4].__shared_weak_owners_) = 1065353216;
  v12[5].__vftable = 0;
  v12[5].__shared_owners_ = 0;
  uint64_t v42 = (grl::Allocator *)grl::Allocator::instance(v41);
  v12[5].__shared_weak_owners_ = (uint64_t)v42;
  v12[6].__vftable = 0;
  int v43 = (grl::Allocator *)grl::Allocator::instance(v42);
  v12[6].__shared_owners_ = (uint64_t)v43;
  v12[6].__shared_weak_owners_ = 0;
  LODWORD(v12[7].__vftable) = 1065353216;
  v12[7].__shared_owners_ = 0;
  v12[7].__shared_weak_owners_ = 0;
  long long v44 = (grl::Allocator *)grl::Allocator::instance(v43);
  v12[8].__vftable = (std::__shared_weak_count_vtbl *)v44;
  v12[8].__shared_owners_ = 0;
  std::string::size_type v45 = (grl::Allocator *)grl::Allocator::instance(v44);
  v12[8].__shared_weak_owners_ = (uint64_t)v45;
  v12[9].__vftable = 0;
  LODWORD(v12[9].__shared_owners_) = 1065353216;
  v12[9].__shared_weak_owners_ = 0;
  v12[10].__vftable = 0;
  unint64_t v46 = (grl::Allocator *)grl::Allocator::instance(v45);
  v12[10].__shared_owners_ = (uint64_t)v46;
  v12[10].__shared_weak_owners_ = 0;
  unint64_t v47 = (grl::Allocator *)grl::Allocator::instance(v46);
  v12[11].__vftable = (std::__shared_weak_count_vtbl *)v47;
  v12[11].__shared_owners_ = 0;
  LODWORD(v12[11].__shared_weak_owners_) = 1065353216;
  v12[12].__shared_owners_ = 0;
  uint64_t v48 = (grl::Allocator *)grl::Allocator::instance(v47);
  v12[12].__shared_weak_owners_ = (uint64_t)v48;
  v12[13].__vftable = 0;
  v12[12].__vftable = (std::__shared_weak_count_vtbl *)&v12[12].__shared_owners_;
  v12[13].__shared_weak_owners_ = 0;
  double v49 = (grl::Allocator *)grl::Allocator::instance(v48);
  v12[14].__vftable = (std::__shared_weak_count_vtbl *)v49;
  v12[14].__shared_owners_ = 0;
  v12[13].__shared_owners_ = (uint64_t)&v12[13].__shared_weak_owners_;
  v12[15].__vftable = 0;
  std::string::size_type v50 = (grl::Allocator *)grl::Allocator::instance(v49);
  v12[15].__shared_owners_ = (uint64_t)v50;
  v12[15].__shared_weak_owners_ = 0;
  v12[14].__shared_weak_owners_ = (uint64_t)&v12[15];
  v12[16].__shared_owners_ = 0;
  uint64_t v51 = (grl::Allocator *)grl::Allocator::instance(v50);
  v12[16].__shared_weak_owners_ = (uint64_t)v51;
  v12[17].__vftable = 0;
  v12[16].__vftable = (std::__shared_weak_count_vtbl *)&v12[16].__shared_owners_;
  v12[17].__shared_owners_ = 0;
  v12[17].__shared_weak_owners_ = 0;
  uint64_t v52 = (grl::Allocator *)grl::Allocator::instance(v51);
  v12[18].__vftable = (std::__shared_weak_count_vtbl *)v52;
  v12[18].__shared_owners_ = 0;
  uint64_t v53 = (grl::Allocator *)grl::Allocator::instance(v52);
  v12[18].__shared_weak_owners_ = (uint64_t)v53;
  v12[19].__vftable = 0;
  LODWORD(v12[19].__shared_owners_) = 1065353216;
  v12[20].__vftable = 0;
  v12[20].__shared_owners_ = grl::Allocator::instance(v53);
  v12[20].__shared_weak_owners_ = 0;
  v12[19].__shared_weak_owners_ = (uint64_t)&v12[20];
  uint64_t v153 = a3;
  uint64_t v154 = a4;
  char v54 = ((uint64_t (*)(std::__shared_weak_count *, uint64_t *))v12[1].__on_zero_shared_weak)(&v12[1], &v153);
  if (v154) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v154);
  }
  if ((v54 & 1) == 0) {
    goto LABEL_48;
  }
  if (!*(unsigned char *)(a2 + 88))
  {
    unint64_t v16 = (std::__shared_mutex_base *)(a2 + 104);
    std::__shared_mutex_base::lock_shared((std::__shared_mutex_base *)(a2 + 104));
    uint64_t v55 = *(void *)(a2 + 96);
    if (v55)
    {
      uint64_t v56 = (std::mutex *)(v55 + 176);
      std::mutex::lock((std::mutex *)(v55 + 176));
      uint64_t v57 = *(uint64_t ***)(a2 + 96);
      unint64_t v59 = (uint64_t *)(v57 + 1);
      uint64_t v58 = (uint64_t)v57[1];
      if (v58)
      {
        while (1)
        {
          while (1)
          {
            double v60 = (uint64_t *)v58;
            uint64_t v61 = (const void **)(v58 + 32);
            if (!std::less<std::pair<std::string,float>>::operator()[abi:nn180100]((const void **)a5, (const void **)(v58 + 32)))break; {
            uint64_t v58 = *v60;
            }
            unint64_t v59 = v60;
            if (!*v60) {
              goto LABEL_52;
            }
          }
          if (!std::less<std::pair<std::string,float>>::operator()[abi:nn180100](v61, (const void **)a5)) {
            break;
          }
          uint64_t v58 = v60[1];
          if (!v58)
          {
            unint64_t v59 = v60 + 1;
            goto LABEL_52;
          }
        }
        uint64_t v62 = (uint64_t)v60;
      }
      else
      {
        double v60 = (uint64_t *)(v57 + 1);
LABEL_52:
        uint64_t v62 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t))(*v57[2] + 16))(v57[2], 80, 8);
        unint64_t v63 = (std::string *)(v62 + 32);
        if (*(char *)(a5 + 23) < 0)
        {
          std::string::__init_copy_ctor_external(v63, *(const std::string::value_type **)a5, *(void *)(a5 + 8));
        }
        else
        {
          long long v64 = *(_OWORD *)a5;
          *(void *)(v62 + 48) = *(void *)(a5 + 16);
          *(_OWORD *)&v63->__r_.__value_.__l.__data_ = v64;
        }
        *(_DWORD *)(v62 + 56) = *(_DWORD *)(a5 + 24);
        *(void *)(v62 + 64) = 0;
        *(void *)(v62 + 72) = 0;
        *(void *)uint64_t v62 = 0;
        *(void *)(v62 + 8) = 0;
        *(void *)(v62 + 16) = v60;
        *unint64_t v59 = v62;
        uint64_t v65 = (uint64_t *)**v57;
        double v66 = (uint64_t *)v62;
        if (v65)
        {
          *uint64_t v57 = v65;
          double v66 = (uint64_t *)*v59;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v57[1], v66);
        v57[3] = (uint64_t *)((char *)v57[3] + 1);
      }
      atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v67 = *(std::__shared_weak_count **)(v62 + 72);
      *(void *)(v62 + 64) = v13;
      *(void *)(v62 + 72) = v12;
      if (v67) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v67);
      }
      uint64_t v68 = v56;
      goto LABEL_226;
    }
    goto LABEL_227;
  }
LABEL_228:
  *a1 = v13;
  a1[1] = (grl::codec::IconDataPack *)v12;
}

void grl::codec::IconConfigPack::setLocationCacheSize(grl::codec::IconConfigPack *this, uint64_t a2)
{
  std::string::size_type v4 = (std::mutex *)((char *)this + 232);
  std::mutex::lock((std::mutex *)((char *)this + 232));
  *((void *)this + 9) = a2;
  while (*((void *)this + 17) > *((void *)this + 9))
    geo::Cache<grl::codec::IconConfigPack::IconLocationIndex,std::shared_ptr<std::map<grl::IconKey,std::shared_ptr<grl::codec::IconData>,std::less<grl::IconKey>,geo::StdAllocator<std::pair<grl::IconKey const,std::shared_ptr<grl::codec::IconData>>,grl::Allocator>>>,grl::codec::IconConfigPack::IconLocationIndexHash,geo::LRUPolicy>::_pop((uint64_t)this + 72);
  std::mutex::unlock(v4);
}

grl::codec::IconDataPack *grl::codec::IconDataPack::IconDataPack(grl::codec::IconDataPack *this, uint64_t a2)
{
  *(void *)this = &unk_1EF567250;
  std::string::size_type v4 = (grl::Allocator *)std::string::basic_string[abi:nn180100]<0>((void *)this + 1, "Default");
  *((_DWORD *)this + 8) = 1065353216;
  *(void *)this = &unk_1EF567210;
  *((void *)this + 6) = 0;
  uint8x8_t v5 = (grl::Allocator *)grl::Allocator::instance(v4);
  *((void *)this + 7) = v5;
  *((void *)this + 8) = 0;
  *((void *)this + 5) = (char *)this + 48;
  *((void *)this + 9) = a2;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  *((void *)this + 15) = (char *)this + 120;
  *((void *)this + 16) = (char *)this + 120;
  *((void *)this + 20) = 0;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 0;
  *((void *)this + 21) = grl::Allocator::instance(v5);
  *((void *)this + 22) = 0;
  *((void *)this + 19) = (char *)this + 160;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  *((void *)this + 41) = 0;
  *((void *)this + 42) = 850045863;
  *(_OWORD *)((char *)this + 344) = 0u;
  *(_OWORD *)((char *)this + 360) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  *((void *)this + 49) = 0;
  return this;
}

void grl::codec::IconDataPack::setImageAtlasSize(grl::codec::IconDataPack *this, uint64_t a2)
{
  std::string::size_type v4 = (std::mutex *)((char *)this + 336);
  std::mutex::lock((std::mutex *)((char *)this + 336));
  *((void *)this + 9) = a2;
  while (*((void *)this + 17) > *((void *)this + 9))
    geo::Cache<unsigned short,std::shared_ptr<esl::QuartzImage>,std::hash<unsigned short>,geo::LRUPolicy>::_pop((uint64_t)this + 72);
  std::mutex::unlock(v4);
}

grl::codec::IconConfigPack *grl::codec::IconConfigPack::IconConfigPack(grl::codec::IconConfigPack *this, uint64_t a2)
{
  *(void *)this = &unk_1EF567250;
  std::string::size_type v4 = (grl::Allocator *)std::string::basic_string[abi:nn180100]<0>((void *)this + 1, "Default");
  *((_DWORD *)this + 8) = 1065353216;
  *(void *)this = &unk_1EF567290;
  *((void *)this + 6) = 0;
  uint8x8_t v5 = (grl::Allocator *)grl::Allocator::instance(v4);
  *((void *)this + 26) = 0;
  *((void *)this + 7) = v5;
  *((void *)this + 8) = 0;
  *((void *)this + 5) = (char *)this + 48;
  *((void *)this + 9) = a2;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_DWORD *)this + 28) = 1065353216;
  *((void *)this + 15) = (char *)this + 120;
  *((void *)this + 16) = (char *)this + 120;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 178) = 0u;
  std::string::size_type v6 = (grl::Allocator *)grl::Allocator::instance(v5);
  *((void *)this + 27) = v6;
  *((void *)this + 25) = (char *)this + 208;
  *((_OWORD *)this + 14) = xmmword_1A28FCCA0;
  *((_OWORD *)this + 15) = 0u;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((void *)this + 36) = 0;
  uint64_t v7 = grl::Allocator::instance(v6);
  std::string::size_type v8 = (grl::Allocator *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 16))(v7, 64, 8);
  *(void *)std::string::size_type v8 = &unk_1EF58B188;
  *((void *)v8 + 1) = 0;
  *((void *)v8 + 2) = 0;
  *((void *)v8 + 3) = v7;
  *((void *)v8 + 5) = 0;
  *((void *)v8 + 6) = grl::Allocator::instance(v8);
  *((void *)v8 + 7) = 0;
  *((void *)v8 + 4) = (char *)v8 + 40;
  uint64_t v9 = (std::__shared_weak_count *)*((void *)this + 20);
  *((void *)this + 19) = (char *)v8 + 32;
  *((void *)this + 20) = v8;
  if (v9) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v9);
  }
  return this;
}

uint64_t grl::codec::IconMapPack::decode(grl::Allocator *a1, void *a2)
{
  memset(v42, 0, sizeof(v42));
  v41[0] = 0;
  v41[1] = (void *)grl::Allocator::instance(a1);
  v41[2] = 0;
  unint64_t v40 = (uint64_t *)v41;
  std::string::size_type v4 = (std::__shared_weak_count *)a2[1];
  v39[0] = *a2;
  v39[1] = v4;
  if (!v4)
  {
    if (grl::codec::ResourcePack::decodeHeader((uint64_t)a1, v39, (uint64_t)v42, &v40)) {
      goto LABEL_3;
    }
LABEL_58:
    int v20 = 317;
    uint64_t v21 = "decodeHeader(packStream, headerName, chapterDataPositions)";
    uint64_t v22 = "Failed to decode Pack Header";
    goto LABEL_59;
  }
  atomic_fetch_add_explicit(&v4->__shared_owners_, 1uLL, memory_order_relaxed);
  BOOL v5 = grl::codec::ResourcePack::decodeHeader((uint64_t)a1, v39, (uint64_t)v42, &v40);
  std::__shared_weak_count::__release_shared[abi:ne180100](v4);
  if (!v5) {
    goto LABEL_58;
  }
LABEL_3:
  if (*(unsigned char *)v42[0] != 73
    || *((unsigned char *)v42[0] + 1) != 67
    || *((unsigned char *)v42[0] + 2) != 79
    || *((unsigned char *)v42[0] + 3) != 78
    || *((unsigned char *)v42[0] + 4) != 77
    || *((unsigned char *)v42[0] + 5) != 65
    || *((unsigned char *)v42[0] + 6) != 80
    || *((unsigned char *)v42[0] + 7) != 80
    || *((unsigned char *)v42[0] + 8) != 65
    || *((unsigned char *)v42[0] + 9) != 67
    || *((unsigned char *)v42[0] + 10) != 75)
  {
    int v20 = 319;
    uint64_t v21 = "headerName[0] == 'I' && headerName[1] == 'C' && headerName[2] == 'O' && headerName[3] == 'N' && headerName[4] "
          "== 'M' && headerName[5] == 'A' && headerName[6] == 'P' && headerName[7] == 'P' && headerName[8] == 'A' && head"
          "erName[9] == 'C' && headerName[10] == 'K'";
    uint64_t v22 = "Magic code is wrong";
LABEL_59:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v22, v21, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v20);
    goto LABEL_60;
  }
  __int16 v38 = 0;
  std::string::size_type v6 = v40;
  if (v40 == (uint64_t *)v41)
  {
LABEL_55:
    uint64_t v19 = 1;
    goto LABEL_61;
  }
  while (1)
  {
    unsigned int v7 = *((unsigned __int16 *)v6 + 16);
    if (v7 <= 0xC)
    {
      if (v7 == 1)
      {
        std::string __p = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        BOOL v12 = (std::__shared_weak_count *)a2[1];
        uint64_t v33 = *a2;
        uint8x8_t v34 = v12;
        if (v12) {
          atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        char v13 = grl::codec::ResourcePack::decodeChapterData((uint64_t)a1, &v33, (uint64_t)(v6 + 5), (uint64_t)&__p);
        if (v34) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v34);
        }
        if (v13)
        {
          if (!grl::codec::ResourcePack::decodePackInfo((uint64_t)a1, (uint64_t)&__p, &v38))
          {
            int v24 = 328;
            uint64_t v25 = "decodePackInfo(chapterData, context)";
            int v26 = "Could not decode Pack Info chapter";
            goto LABEL_70;
          }
          goto LABEL_47;
        }
        int v24 = 327;
        goto LABEL_68;
      }
      if (v7 == 11)
      {
        std::string __p = 0;
        uint64_t v36 = 0;
        uint64_t v37 = 0;
        std::string::size_type v8 = (std::__shared_weak_count *)a2[1];
        uint64_t v31 = *a2;
        uint64_t v32 = v8;
        if (v8) {
          atomic_fetch_add_explicit(&v8->__shared_owners_, 1uLL, memory_order_relaxed);
        }
        char v9 = grl::codec::ResourcePack::decodeChapterData((uint64_t)a1, &v31, (uint64_t)(v6 + 5), (uint64_t)&__p);
        if (v32) {
          std::__shared_weak_count::__release_shared[abi:ne180100](v32);
        }
        if (v9)
        {
          if ((grl::codec::IconMapPack::decodeIconIDMapping((uint64_t)a1, (unsigned int *)__p, (uint64_t)v36) & 1) == 0)
          {
            int v24 = 333;
            uint64_t v25 = "decodeIconIDMapping(chapterData, context)";
            int v26 = "Could not decode Icon ID chapter";
            goto LABEL_70;
          }
LABEL_47:
          if (__p)
          {
            uint64_t v36 = __p;
            operator delete(__p);
          }
          goto LABEL_49;
        }
        int v24 = 332;
        goto LABEL_68;
      }
      goto LABEL_49;
    }
    if (v7 == 13) {
      break;
    }
    if (v7 == 14)
    {
      std::string __p = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      float v10 = (std::__shared_weak_count *)a2[1];
      uint64_t v29 = *a2;
      uint64_t v30 = v10;
      if (v10) {
        atomic_fetch_add_explicit(&v10->__shared_owners_, 1uLL, memory_order_relaxed);
      }
      char v11 = grl::codec::ResourcePack::decodeChapterData((uint64_t)a1, &v29, (uint64_t)(v6 + 5), (uint64_t)&__p);
      if (v30) {
        std::__shared_weak_count::__release_shared[abi:ne180100](v30);
      }
      if (v11)
      {
        if (!grl::codec::IconMapPack::decodeRegionMapping(a1, __p, (uint64_t)v36))
        {
          int v24 = 338;
          uint64_t v25 = "decodeRegionMapping(chapterData, context)";
          int v26 = "Could not decode Region Name chapter";
          goto LABEL_70;
        }
        goto LABEL_47;
      }
      int v24 = 337;
LABEL_68:
      uint64_t v25 = "decodeChapterData(packStream, chapterPair.second, chapterData)";
      int v26 = "Could not decode Chapter Data";
      goto LABEL_70;
    }
LABEL_49:
    unint64_t v16 = (uint64_t *)v6[1];
    if (v16)
    {
      do
      {
        uint64_t v17 = v16;
        unint64_t v16 = (uint64_t *)*v16;
      }
      while (v16);
    }
    else
    {
      do
      {
        uint64_t v17 = (uint64_t *)v6[2];
        BOOL v18 = *v17 == (void)v6;
        std::string::size_type v6 = v17;
      }
      while (!v18);
    }
    std::string::size_type v6 = v17;
    if (v17 == (uint64_t *)v41) {
      goto LABEL_55;
    }
  }
  std::string __p = 0;
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  id v14 = (std::__shared_weak_count *)a2[1];
  uint64_t v27 = *a2;
  std::string::size_type v28 = v14;
  if (v14) {
    atomic_fetch_add_explicit(&v14->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  char v15 = grl::codec::ResourcePack::decodeChapterData((uint64_t)a1, &v27, (uint64_t)(v6 + 5), (uint64_t)&__p);
  if (v28) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v28);
  }
  if ((v15 & 1) == 0)
  {
    int v24 = 342;
    goto LABEL_68;
  }
  if (grl::codec::IconMapPack::decodeFallbackMapping((uint64_t)a1, (unsigned int *)__p, (uint64_t)v36)) {
    goto LABEL_47;
  }
  int v24 = 343;
  uint64_t v25 = "decodeFallbackMapping(chapterData, context)";
  int v26 = "Could not decode Fallback chapter";
LABEL_70:
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v26, v25, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v24);
  if (__p)
  {
    uint64_t v36 = __p;
    operator delete(__p);
  }
LABEL_60:
  uint64_t v19 = 0;
LABEL_61:
  std::__tree<std::__value_type<VKTrafficFeatureType,unsigned long>,std::__map_value_compare<VKTrafficFeatureType,std::__value_type<VKTrafficFeatureType,unsigned long>,std::less<VKTrafficFeatureType>,true>,geo::StdAllocator<std::__value_type<VKTrafficFeatureType,unsigned long>,mdm::Allocator>>::destroy((uint64_t)&v40, v41[0]);
  if (v42[0]) {
    operator delete(v42[0]);
  }
  return v19;
}

uint64_t grl::codec::IconMapPack::decodeFallbackMapping(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  if ((unint64_t)(a3 - (void)a2) < 4)
  {
    int v3 = 506;
    std::string::size_type v4 = "keyFallbackCount.has_value()";
    goto LABEL_52;
  }
  unint64_t v5 = (unint64_t)a2;
  unint64_t v55 = a3 - (void)a2;
  unsigned int v7 = *a2;
  char v54 = a2 - 1;
  std::string::size_type v8 = (void *)(a1 + 392);
  std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::StdAllocator<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::Allocator>>::__rehash<true>(a1 + 392, vcvtps_u32_f32((float)*a2 / *(float *)(a1 + 440)));
  unint64_t v53 = v5;
  unsigned int v51 = v7;
  if (v7)
  {
    int v9 = 0;
    std::string::size_type v50 = (uint64_t *)(a1 + 416);
    unint64_t v10 = 4;
    unint64_t v11 = v55;
    while (1)
    {
      if (v10 + 4 > v11)
      {
        int v3 = 511;
        std::string::size_type v4 = "key.has_value()";
        std::string::size_type v28 = "Key could not be read";
        goto LABEL_53;
      }
      unint64_t v12 = v10;
      v10 += 8;
      if (v10 > v11)
      {
        int v3 = 513;
        std::string::size_type v4 = "value.has_value()";
        std::string::size_type v28 = "Value could not be read";
        goto LABEL_53;
      }
      unint64_t v13 = *(unsigned int *)(v5 + v12);
      unsigned int v14 = v54[v10 / 4];
      unint64_t v15 = *(void *)(a1 + 400);
      if (v15)
      {
        uint8x8_t v16 = (uint8x8_t)vcnt_s8((int8x8_t)v15);
        v16.i16[0] = vaddlv_u8(v16);
        if (v16.u32[0] > 1uLL)
        {
          unint64_t v5 = *(unsigned int *)(v5 + v12);
          if (v15 <= v13) {
            unint64_t v5 = v13 % v15;
          }
        }
        else
        {
          unint64_t v5 = (v15 - 1) & v13;
        }
        uint64_t v17 = *(uint64_t **)(*v8 + 8 * v5);
        if (v17)
        {
          for (uint64_t i = *v17; i; uint64_t i = *(void *)i)
          {
            unint64_t v19 = *(void *)(i + 8);
            if (v19 == v13)
            {
              if (*(_DWORD *)(i + 16) == v13)
              {
                unint64_t v5 = v53;
                goto LABEL_45;
              }
            }
            else
            {
              if (v16.u32[0] > 1uLL)
              {
                if (v19 >= v15) {
                  v19 %= v15;
                }
              }
              else
              {
                v19 &= v15 - 1;
              }
              if (v19 != v5) {
                break;
              }
            }
          }
        }
      }
      uint64_t i = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 424) + 16))(*(void *)(a1 + 424), 24, 8);
      *(void *)uint64_t i = 0;
      *(void *)(i + 8) = v13;
      *(_DWORD *)(i + 16) = v13;
      *(_DWORD *)(i + 20) = 0;
      float v20 = (float)(unint64_t)(*(void *)(a1 + 432) + 1);
      float v21 = *(float *)(a1 + 440);
      if (!v15 || (float)(v21 * (float)v15) < v20)
      {
        BOOL v22 = (v15 & (v15 - 1)) != 0;
        if (v15 < 3) {
          BOOL v22 = 1;
        }
        unint64_t v23 = v22 | (2 * v15);
        unint64_t v24 = vcvtps_u32_f32(v20 / v21);
        if (v23 <= v24) {
          size_t v25 = v24;
        }
        else {
          size_t v25 = v23;
        }
        std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::StdAllocator<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::Allocator>>::__rehash<true>((unint64_t)v8, v25);
        unint64_t v15 = *(void *)(a1 + 400);
        if ((v15 & (v15 - 1)) != 0)
        {
          if (v15 <= v13) {
            unint64_t v5 = v13 % v15;
          }
          else {
            unint64_t v5 = v13;
          }
        }
        else
        {
          unint64_t v5 = (v15 - 1) & v13;
        }
      }
      int v26 = *(uint64_t **)(*v8 + 8 * v5);
      unint64_t v11 = v55;
      if (v26)
      {
        *(void *)uint64_t i = *v26;
        unint64_t v5 = v53;
      }
      else
      {
        *(void *)uint64_t i = *v50;
        uint64_t *v50 = i;
        *(void *)(*v8 + 8 * v5) = v50;
        unint64_t v5 = v53;
        if (!*(void *)i) {
          goto LABEL_44;
        }
        unint64_t v27 = *(void *)(*(void *)i + 8);
        if ((v15 & (v15 - 1)) != 0)
        {
          if (v27 >= v15) {
            v27 %= v15;
          }
        }
        else
        {
          v27 &= v15 - 1;
        }
        int v26 = (uint64_t *)(*v8 + 8 * v27);
      }
      *int v26 = i;
LABEL_44:
      ++*(void *)(a1 + 432);
LABEL_45:
      *(_DWORD *)(i + 20) = v14;
      if (++v9 == v51)
      {
        unint64_t v29 = v12 + 12;
        goto LABEL_50;
      }
    }
  }
  unint64_t v29 = 8;
  unint64_t v11 = v55;
LABEL_50:
  if (v29 <= v11)
  {
    unsigned int v52 = *(_DWORD *)(v5 + v29 - 4);
    if (!v52)
    {
      char v30 = 1;
      return v30 & 1;
    }
    BOOL v32 = 0;
    unsigned int v33 = 0;
    uint8x8_t v34 = (uint64_t *)(a1 + 456);
    while (v29 + 4 <= v11)
    {
      if (v29 + 8 > v11)
      {
        int v47 = 524;
        uint64_t v48 = "max.has_value()";
        double v49 = "Max could not be read";
        goto LABEL_78;
      }
      unint64_t v35 = v29 + 12;
      if (v29 + 12 > v11)
      {
        int v47 = 526;
        uint64_t v48 = "value.has_value()";
        double v49 = "Value could not be read";
        goto LABEL_78;
      }
      uint64_t v36 = *(unsigned int *)(v5 + v29);
      uint64_t v37 = *(unsigned int *)((char *)v54 + v29 + 8);
      v29 += 12;
      int v38 = *(unsigned int *)((char *)v54 + v35);
      uint64_t v39 = *v34;
      unint64_t v40 = (uint64_t **)(a1 + 456);
      uint64_t v41 = a1 + 456;
      if (*v34)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v41 = v39;
            unsigned int v42 = *(_DWORD *)(v39 + 28);
            if (v42 <= v36) {
              break;
            }
LABEL_64:
            uint64_t v39 = *(void *)v41;
            unint64_t v40 = (uint64_t **)v41;
            if (!*(void *)v41) {
              goto LABEL_69;
            }
          }
          if (v42 >= v36)
          {
            unsigned int v43 = *(_DWORD *)(v41 + 32);
            if (v43 > v37) {
              goto LABEL_64;
            }
            if (v43 >= v37) {
              goto LABEL_72;
            }
          }
          uint64_t v39 = *(void *)(v41 + 8);
          if (!v39)
          {
            unint64_t v40 = (uint64_t **)(v41 + 8);
            break;
          }
        }
      }
LABEL_69:
      uint64_t v44 = v41;
      uint64_t v41 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(a1 + 464) + 16))(*(void *)(a1 + 464), 40, 8);
      *(void *)(v41 + 28) = v36 | (v37 << 32);
      *(_DWORD *)(v41 + 36) = 0;
      *(void *)uint64_t v41 = 0;
      *(void *)(v41 + 8) = 0;
      *(void *)(v41 + 16) = v44;
      *unint64_t v40 = (uint64_t *)v41;
      uint64_t v45 = **(void **)(a1 + 448);
      unint64_t v46 = (uint64_t *)v41;
      if (v45)
      {
        *(void *)(a1 + 448) = v45;
        unint64_t v46 = *v40;
      }
      std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 456), v46);
      ++*(void *)(a1 + 472);
      unint64_t v11 = v55;
LABEL_72:
      *(_DWORD *)(v41 + 36) = v38;
      ++v33;
      char v30 = 1;
      BOOL v32 = v33 >= v52;
      unint64_t v5 = v53;
      if (v33 == v52) {
        return v30 & 1;
      }
    }
    int v47 = 522;
    uint64_t v48 = "min.has_value()";
    double v49 = "Min could not be read";
LABEL_78:
    printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v49, v48, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v47);
    char v30 = v32;
    return v30 & 1;
  }
  int v3 = 518;
  std::string::size_type v4 = "dataFallbackCount.has_value()";
LABEL_52:
  std::string::size_type v28 = "Count could not be read";
LABEL_53:
  printf("\n%s : Parse Error Here: - %s : Failed in file - %s line - %i\n", v28, v4, "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoResourceLib/GeoResourceLib/Codec/IconMapPack.cpp", v3);
  char v30 = 0;
  return v30 & 1;
}

unint64_t std::__hash_table<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::__unordered_map_hasher<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::hash<grl::codec::IconMapKeyValue>,std::equal_to<grl::codec::IconMapKeyValue>,true>,std::__unordered_map_equal<grl::codec::IconMapKeyValue,std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,std::equal_to<grl::codec::IconMapKeyValue>,std::hash<grl::codec::IconMapKeyValue>,true>,geo::StdAllocator<std::__hash_value_type<grl::codec::IconMapKeyValue,unsigned int>,grl::Allocator>>::__rehash<true>(unint64_t result, size_t __n)
{
  unint64_t v2 = result;
  if (__n == 1)
  {
    unint64_t v3 = 2;
  }
  else
  {
    unint64_t v3 = __n;
    if ((__n & (__n - 1)) != 0)
    {
      uint64_t result = std::__next_prime(__n);
      unint64_t v3 = result;
    }
  }
  int8x8_t v4 = *(int8x8_t *)(v2 + 8);
  if (v3 <= *(void *)&v4)
  {
    if (v3 >= *(void *)&v4) {
      return result;
    }
    uint64_t result = vcvtps_u32_f32((float)*(unint64_t *)(v2 + 40) / *(float *)(v2 + 48));
    if (*(void *)&v4 < 3uLL || (uint8x8_t v10 = (uint8x8_t)vcnt_s8(v4), v10.i16[0] = vaddlv_u8(v10), v10.u32[0] > 1uLL))
    {
      uint64_t result = std::__next_prime(result);
    }
    else
    {
      uint64_t v11 = 1 << -(char)__clz(result - 1);
      if (result >= 2) {
        uint64_t result = v11;
      }
    }
    if (v3 <= result) {
      unint64_t v3 = result;
    }
    if (v3 >= *(void *)&v4) {
      return result;
    }
    if (!v3)
    {
      uint64_t v14 = *(void *)v2;
      *(void *)unint64_t v2 = 0;
      if (v14) {
        uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 16) + 40))(*(void *)(v2 + 16), v14, 8 * *(void *)(v2 + 8));
      }
      *(void *)(v2 + 8) = 0;
      return result;
    }
  }
  uint64_t result = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v2 + 16) + 16))(*(void *)(v2 + 16), 8 * v3, 8);
  uint64_t v5 = *(void *)v2;
  *(void *)unint64_t v2 = result;
  if (v5) {
    uint64_t result = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v2 + 16) + 40))(*(void *)(v2 + 16), v5, 8 * *(void *)(v2 + 8));
  }
  uint64_t v6 = 0;
  *(void *)(v2 + 8) = v3;
  do
    *(void *)(*(void *)v2 + 8 * v6++) = 0;
  while (v3 != v6);
  unsigned int v7 = *(void **)(v2 + 24);
  if (v7)
  {
    unint64_t v8 = v7[1];
    uint8x8_t v9 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      if (v8 >= v3) {
        v8 %= v3;
      }
    }
    else
    {
      v8 &= v3 - 1;
    }
    *(void *)(*(void *)v2 + 8 * v8) = v2 + 24;
    unint64_t v12 = (void *)*v7;
    if (*v7)
    {
      do
      {
        unint64_t v13 = v12[1];
        if (v9.u32[0] > 1uLL)
        {
          if (v13 >= v3) {
            v13 %= v3;
          }
        }
        else
        {
          v13 &= v3 - 1;
        }
        if (v13 != v8)
        {
          if (!*(void *)(*(void *)v2 + 8 * v13))
          {
            *(void *)(*(void *)v2 + 8 * v13) = v7;
            goto LABEL_30;
          }
          void *v7 = *v12;
          *unint64_t v12 = **(void **)(*(void *)v2 + 8 * v13);
          **(void **)(*(void *)v2 + 8 * v13) = v12;
          unint64_t v12 = v7;
        }
        unint64_t v13 = v8;
LABEL_30:
        unsigned int v7 = v12;
        unint64_t v12 = (void *)*v12;
        unint64_t v8 = v13;
      }
      while (v12);
    }
  }
  return result;
}

void grl::ResourceProvider::resourceNamesOfResourceAndPackType(uint64_t a1@<X0>, unsigned int a2@<W1>, int a3@<W2>, unint64_t a4@<X3>, void *a5@<X8>)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  LOBYTE(v48) = a2;
  BYTE1(v48) = a3;
  *((void *)&v48 + 1) = a4;
  uint8x8_t v10 = (std::mutex *)(a1 + 176);
  std::mutex::lock((std::mutex *)(a1 + 176));
  uint64_t v11 = (uint64_t **)(a1 + 240);
  uint64_t v12 = std::__tree<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::__map_value_compare<grl::ResourceProvider::ResourceCacheKey,std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::less<grl::ResourceProvider::ResourceCacheKey>,true>,std::allocator<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>>>::find<grl::ResourceProvider::ResourceCacheKey>(a1 + 240, (unsigned __int8 *)&v48);
  if (a1 + 248 != v12)
  {
    uint64_t v13 = *(void *)(v12 + 56);
    *a5 = *(void *)(v12 + 48);
    a5[1] = v13;
    if (v13) {
      atomic_fetch_add_explicit((atomic_ullong *volatile)(v13 + 8), 1uLL, memory_order_relaxed);
    }
    std::mutex::unlock(v10);
    return;
  }
  std::mutex::unlock(v10);
  long long v45 = 0uLL;
  uint64_t v46 = 0;
  uint64_t v47 = grl::Allocator::instance(v14);
  (*(void (**)(uint64_t **__return_ptr, uint64_t, unint64_t))(*(void *)a1 + 24))(&v43, a1, a4);
  if (!v43)
  {
    int v26 = (grl::Allocator *)operator new(0x38uLL);
    *((void *)v26 + 3) = 0;
    *((void *)v26 + 1) = 0;
    *((void *)v26 + 2) = 0;
    *(void *)int v26 = &unk_1EF57F6F0;
    *((void *)v26 + 4) = 0;
    *((void *)v26 + 5) = 0;
    *((void *)v26 + 6) = grl::Allocator::instance(v26);
    *a5 = (char *)v26 + 24;
    a5[1] = v26;
    goto LABEL_33;
  }
  unint64_t v15 = (std::mutex *)(a1 + 112);
  std::mutex::lock(v15);
  uint8x8_t v16 = (std::string *)*v43;
  uint64_t v17 = (std::string *)v43[1];
  v41[0] = &v45;
  while (v16 != v17)
  {
    std::string::size_type v18 = std::string::rfind(v16, 46, 0xFFFFFFFFFFFFFFFFLL);
    if (v18 == -1) {
      goto LABEL_23;
    }
    std::string::basic_string(&v49, v16, v18 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)v39);
    grl::ResourceTypeFromPackExtension((int64_t)&v49, v39);
    grl::codec::PackTypeFromExtension((int64_t)&v49, __p);
    BOOL v20 = LOBYTE(v39[0]) && LOBYTE(__p[0]) && BYTE1(v39[0]) == a2 && BYTE1(__p[0]) == a3;
    if ((SHIBYTE(v49.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
    {
      if (!v20) {
        goto LABEL_23;
      }
LABEL_22:
      std::back_insert_iterator<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>>::operator=[abi:nn180100]((unint64_t **)v41, (long long *)v16);
      goto LABEL_23;
    }
    operator delete(v49.__r_.__value_.__l.__data_);
    if (v20) {
      goto LABEL_22;
    }
LABEL_23:
    ++v16;
  }
  if ((void)v45 == *((void *)&v45 + 1) && *v43 != v43[1])
  {
    if (qword_1EB34D538 != -1) {
      dispatch_once(&qword_1EB34D538, &__block_literal_global_2);
    }
    unint64_t v27 = _MergedGlobals_3;
    if (os_log_type_enabled((os_log_t)_MergedGlobals_3, OS_LOG_TYPE_ERROR))
    {
      std::string::size_type v28 = v41;
      grl::buildStringFromResourceNames(*v43, 0xAAAAAAAAAAAAAAABLL * ((v43[1] - *v43) >> 3), v41);
      if (v42 < 0) {
        std::string::size_type v28 = (void **)v41[0];
      }
      if (a2 > 3) {
        unint64_t v29 = (char *)&str_5_1;
      }
      else {
        unint64_t v29 = off_1E5AB2978[(char)a2];
      }
      char v30 = 0;
      uint64_t v31 = 0;
      char v40 = 2;
      strcpy((char *)v39, "00");
      do
      {
        char v32 = v30;
        if ((a4 >> v31))
        {
          uint64_t v33 = v31 ^ 1;
          if (v40 >= 0) {
            uint8x8_t v34 = v39;
          }
          else {
            uint8x8_t v34 = (void **)v39[0];
          }
          *((unsigned char *)v34 + v33) = 49;
        }
        char v30 = 1;
        uint64_t v31 = 1;
      }
      while ((v32 & 1) == 0);
      if (v40 >= 0) {
        unint64_t v35 = v39;
      }
      else {
        unint64_t v35 = (void **)v39[0];
      }
      grl::buildStringFromResourceNames(v45, 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((void *)&v45 + 1) - v45) >> 3), __p);
      if (v38 >= 0) {
        uint64_t v36 = __p;
      }
      else {
        uint64_t v36 = (void **)__p[0];
      }
      LODWORD(v49.__r_.__value_.__l.__data_) = 136315906;
      *(std::string::size_type *)((char *)v49.__r_.__value_.__r.__words + 4) = (std::string::size_type)v28;
      WORD2(v49.__r_.__value_.__r.__words[1]) = 2080;
      *(std::string::size_type *)((char *)&v49.__r_.__value_.__r.__words[1] + 6) = (std::string::size_type)v29;
      HIWORD(v49.__r_.__value_.__r.__words[2]) = 2080;
      std::string::size_type v50 = v35;
      __int16 v51 = 2080;
      unsigned int v52 = v36;
      _os_log_impl(&dword_1A1780000, v27, OS_LOG_TYPE_ERROR, "Resources names got filtered to empty set for resourceType:%s location:%s input:%s output:%s", (uint8_t *)&v49, 0x2Au);
      if (v38 < 0) {
        operator delete(__p[0]);
      }
      if (v40 < 0) {
        operator delete(v39[0]);
      }
      if (v42 < 0) {
        operator delete(v41[0]);
      }
    }
  }
  std::mutex::unlock(v15);
  std::mutex::lock(v10);
  float v21 = (char *)operator new(0x38uLL);
  *((void *)v21 + 1) = 0;
  *((void *)v21 + 2) = 0;
  *(void *)float v21 = &unk_1EF57F6F0;
  long long v22 = v45;
  uint64_t v23 = v47;
  *((void *)v21 + 5) = v46;
  *((void *)v21 + 6) = v23;
  v49.__r_.__value_.__l.__size_ = (std::string::size_type)v21;
  *(_OWORD *)(v21 + 24) = v22;
  long long v45 = 0uLL;
  uint64_t v46 = 0;
  v49.__r_.__value_.__r.__words[0] = (std::string::size_type)(v21 + 24);
  unint64_t v24 = std::__tree<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::__map_value_compare<grl::ResourceProvider::ResourceCacheKey,std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::less<grl::ResourceProvider::ResourceCacheKey>,true>,std::allocator<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>>>::__emplace_unique_key_args<grl::ResourceProvider::ResourceCacheKey,grl::ResourceProvider::ResourceCacheKey&,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>(v11, (unsigned __int8 *)&v48, &v48, (long long *)&v49);
  if (v49.__r_.__value_.__l.__size_) {
    std::__shared_weak_count::__release_shared[abi:ne180100]((std::__shared_weak_count *)v49.__r_.__value_.__l.__size_);
  }
  uint64_t v25 = v24[7];
  *a5 = v24[6];
  a5[1] = v25;
  if (v25) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v25 + 8), 1uLL, memory_order_relaxed);
  }
  std::mutex::unlock(v10);
LABEL_33:
  if (v44) {
    std::__shared_weak_count::__release_shared[abi:ne180100](v44);
  }
  v49.__r_.__value_.__r.__words[0] = (std::string::size_type)&v45;
  std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>>::__destroy_vector::operator()[abi:nn180100]((uint64_t **)&v49);
}

int64_t grl::codec::PackTypeFromExtension@<X0>(int64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unsigned int v2 = 0;
  int v3 = *(char *)(a1 + 23);
  if (v3 >= 0) {
    int64_t v4 = a1;
  }
  else {
    int64_t v4 = *(void *)a1;
  }
  if (v3 >= 0) {
    int64_t v5 = *(unsigned __int8 *)(a1 + 23);
  }
  else {
    int64_t v5 = *(void *)(a1 + 8);
  }
  int64_t v6 = v4 + v5;
  while (1)
  {
    unsigned int v7 = "";
    if (v2 <= 2) {
      unsigned int v7 = off_1E5AB2B78[v2];
    }
    int64_t result = strlen(v7);
    if (!result) {
      break;
    }
    int64_t v9 = result;
    if (v5 >= result)
    {
      int v11 = *v7;
      int64_t v12 = v5;
      int64_t result = v4;
      do
      {
        int64_t v13 = v12 - v9;
        if (v13 == -1) {
          break;
        }
        int64_t result = (int64_t)memchr((void *)result, v11, v13 + 1);
        if (!result) {
          break;
        }
        int64_t v14 = result;
        int64_t result = memcmp((const void *)result, v7, v9);
        if (!result)
        {
          if (v14 == v6 || v14 - v4 == -1) {
            break;
          }
          goto LABEL_23;
        }
        int64_t result = v14 + 1;
        int64_t v12 = v6 - (v14 + 1);
      }
      while (v12 >= v9);
    }
    if (v2++ >= 2)
    {
      *a2 = 0;
      return result;
    }
  }
LABEL_23:
  *a2 = 1;
  a2[1] = v2;
  return result;
}

void *std::__tree<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::__map_value_compare<grl::ResourceProvider::ResourceCacheKey,std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>,std::less<grl::ResourceProvider::ResourceCacheKey>,true>,std::allocator<std::__value_type<grl::ResourceProvider::ResourceCacheKey,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>>>::__emplace_unique_key_args<grl::ResourceProvider::ResourceCacheKey,grl::ResourceProvider::ResourceCacheKey&,std::shared_ptr<std::vector<std::string,geo::StdAllocator<std::string,grl::Allocator>> const>>(uint64_t **a1, unsigned __int8 *a2, _OWORD *a3, long long *a4)
{
  unint64_t v8 = a1 + 1;
  unsigned int v7 = (unsigned __int8 *)a1[1];
  if (v7)
  {
    while (1)
    {
      while (1)
      {
        uint8x8_t v10 = v7;
        int v11 = v7 + 32;
        if (!grl::ResourceProvider::ResourceCacheKey::operator<(a2, v7 + 32)) {
          break;
        }
        unsigned int v7 = (unsigned __int8 *)*v10;
        unint64_t v8 = (uint64_t **)v10;
        if (!*v10) {
          goto LABEL_9;
        }
      }
      if (!grl::ResourceProvider::ResourceCacheKey::operator<(v11, a2)) {
        break;
      }
      unsigned int v7 = (unsigned __int8 *)v10[1];
      if (!v7)
      {
        unint64_t v8 = (uint64_t **)(v10 + 1);
        goto LABEL_9;
      }
    }
  }
  else
  {
    uint8x8_t v10 = a1 + 1;
LABEL_9:
    int64_t v12 = v10;
    uint8x8_t v10 = operator new(0x40uLL);
    long long v13 = *a4;
    *((_OWORD *)v10 + 2) = *a3;
    *((_OWORD *)v10 + 3) = v13;
    *(void *)a4 = 0;
    *((void *)a4 + 1) = 0;
    void *v10 = 0;
    v10[1] = 0;
    void v10[2] = v12;
    *unint64_t v8 = v10;
    int64_t v14 = (uint64_t *)**a1;
    unint64_t v15 = v10;
    if (v14)
    {
      *a1 = v14;
      unint64_t v15 = *v8;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v15);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v10;
}

void sub_1A1AC6D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void ggl::MetalDeviceContext::beginFrame(uint64_t a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 64), 0xFFFFFFFFFFFFFFFFLL);
  if (!*(void *)(a1 + 40)) {
    operator new();
  }
  if (GEOGetGeoGLMetalDeviceContextLog(void)::onceToken != -1) {
    dispatch_once(&GEOGetGeoGLMetalDeviceContextLog(void)::onceToken, &__block_literal_global_53322);
  }
  unsigned int v2 = GEOGetGeoGLMetalDeviceContextLog(void)::log;
  if (os_log_type_enabled((os_log_t)GEOGetGeoGLMetalDeviceContextLog(void)::log, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)long long buf = 136315650;
    int64_t v4 = "false";
    __int16 v5 = 2080;
    int64_t v6 = "/Library/Caches/com.apple.xbs/Sources/VectorKit/geo/GeoGL/GeoGL/MetalDeviceContext.mm";
    __int16 v7 = 1024;
    int v8 = 144;
    _os_log_impl(&dword_1A1780000, v2, OS_LOG_TYPE_FAULT, "Frame already active: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
  }
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CreatePipelineStates>,std::allocator<ecs2::ForwardToExecute<md::ita::CreatePipelineStates>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1AC7B94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  if (a13 == v15)
  {
    (*(void (**)(uint64_t *))(a10 + 32))(&a10);
  }
  else if (a13)
  {
    (*(void (**)(void))(*(void *)a13 + 40))();
  }
  (*(void (**)(uint64_t))(*(void *)v14 + 8))(v14);
  (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsOpaque const&>>::each(uint64_t a1, uint64_t a2)
{
  int v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  int64_t v4 = (void *)gdc::Registry::storage<md::ls::FunctionConstants>(v3);
  __int16 v5 = (void *)gdc::Registry::storage<md::ls::RequiredPipelinePoolID>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::IsOpaque>(v3);
  uint8x8_t v10 = (void *)v6;
  int v11 = v4 + 4;
  if (v5[8] - v5[7] < v4[8] - v4[7]) {
    int v11 = v5 + 4;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) >= v11[4] - v11[3]) {
    uint64_t v12 = (uint64_t)v11;
  }
  else {
    uint64_t v12 = v6 + 32;
  }
  v83[0] = v12;
  v83[1] = v4;
  v83[2] = v5;
  v83[3] = v6;
  uint64_t v14 = *(void **)(v12 + 24);
  uint64_t v13 = *(void **)(v12 + 32);
  unint64_t v84 = v14;
  if (v13 != v14
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v83))
  {
    uint64_t v15 = v14 + 1;
    do
    {
      uint64_t v14 = v15;
      unint64_t v84 = v15;
      if (v15 == v13) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v83);
      uint64_t v15 = v14 + 1;
    }
    while (!isValid);
  }
  uint64_t v17 = &ecs2::Runtime::_localEntity;
  std::string::size_type v18 = ecs2::Runtime::_localEntity;
  if (v13 == v14) {
    goto LABEL_82;
  }
  unint64_t v19 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *unint64_t v19 = *v14;
    unint64_t v21 = *v14;
    uint64_t v22 = HIDWORD(*v14);
    unint64_t v23 = *v14 >> 39;
    uint64_t v24 = v4[4];
    if (v23 >= (v4[5] - v24) >> 3) {
      goto LABEL_23;
    }
    uint64_t v25 = *(void *)(v24 + 8 * v23);
    if (!v25) {
      goto LABEL_23;
    }
    unint64_t v26 = *(unsigned __int16 *)(v25 + 2 * (HIDWORD(v21) & 0x7F));
    uint64_t v28 = v4[7];
    uint64_t v27 = v4[8];
    if (v26 >= (v27 - v28) >> 3) {
      goto LABEL_23;
    }
    uint64_t v29 = v28 + 8 * v26;
    if (v29 != v27 && *(_DWORD *)(v29 + 4) == v22)
    {
      uint64_t v82 = 33 * v26;
      uint64_t v31 = v4[11];
      uint64_t v32 = v4[10] + v82;
    }
    else
    {
LABEL_23:
      uint64_t v31 = v4[11];
      uint64_t v32 = v31;
    }
    uint64_t v33 = v32 == v31 ? 0 : v32;
    if ((uint64_t v34 = v5[4], v23 < (v5[5] - v34) >> 3)
      && (uint64_t v35 = *(void *)(v34 + 8 * v23)) != 0
      && (unint64_t v36 = *(unsigned __int16 *)(v35 + 2 * (HIDWORD(v21) & 0x7F)), v38 = v5[7], v37 = v5[8], v36 < (v37 - v38) >> 3)
      && ((uint64_t v39 = v38 + 8 * v36, v39 != v37) ? (v40 = *(_DWORD *)(v39 + 4) == v22) : (v40 = 0), v40))
    {
      unint64_t v41 = v5[11];
      unint64_t v42 = v5[10] + v36;
    }
    else
    {
      unint64_t v41 = v5[11];
      unint64_t v42 = v41;
    }
    unint64_t v43 = v42 == v41 ? 0 : v42;
    uint64_t v44 = v10[4];
    if (v23 < (v10[5] - v44) >> 3)
    {
      uint64_t v45 = *(void *)(v44 + 8 * v23);
      if (v45)
      {
        unint64_t v46 = *(unsigned __int16 *)(v45 + 2 * (HIDWORD(v21) & 0x7F));
        uint64_t v48 = v10[7];
        uint64_t v47 = v10[8];
        if (v46 < (v47 - v48) >> 3)
        {
          uint64_t v49 = v48 + 8 * v46;
          if (v49 != v47 && *(_DWORD *)(v49 + 4) == v22) {
            break;
          }
        }
      }
    }
    unint64_t v51 = v10[11];
    unint64_t v52 = v51;
    uint64_t v53 = *(void *)(a2 + 24);
    if (!v53) {
      goto LABEL_81;
    }
LABEL_46:
    if (v52 == v51) {
      unint64_t v54 = 0;
    }
    else {
      unint64_t v54 = v52;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(void *)v53 + 48))(v53, v33, v43, v54);
    uint64_t v56 = *(void **)(v12 + 32);
    BOOL v20 = v14 + 1;
    unint64_t v84 = v14 + 1;
    if (v14 + 1 != v56)
    {
      uint64_t v57 = v4[4];
      uint64_t v59 = v4[7];
      uint64_t v58 = v4[8];
      uint64_t v60 = v5[4];
      uint64_t result = v5[7];
      uint64_t v61 = v5[8];
      uint64_t v62 = v10[4];
      uint64_t v64 = v10[7];
      uint64_t v63 = v10[8];
      while (1)
      {
        unint64_t v65 = *((unsigned int *)v20 + 1);
        unint64_t v66 = v65 >> 7;
        if (v65 >> 7 < (v4[5] - v57) >> 3)
        {
          uint64_t v67 = *(void *)(v57 + 8 * v66);
          if (v67)
          {
            uint64_t v68 = v65 & 0x7F;
            unint64_t v69 = *(unsigned __int16 *)(v67 + 2 * v68);
            if ((v58 - v59) >> 3 > v69)
            {
              uint64_t v70 = v59 + 8 * v69;
              BOOL v71 = v70 != v58 && *(_DWORD *)(v70 + 4) == v65;
              if (v71 && v66 < (v5[5] - v60) >> 3)
              {
                uint64_t v73 = *(void *)(v60 + 8 * v66);
                if (v73)
                {
                  unint64_t v74 = *(unsigned __int16 *)(v73 + 2 * v68);
                  if ((v61 - result) >> 3 > v74)
                  {
                    unint64_t v75 = result + 8 * v74;
                    BOOL v76 = v75 != v61 && *(_DWORD *)(v75 + 4) == v65;
                    if (v76 && v66 < (v10[5] - v62) >> 3)
                    {
                      uint64_t v78 = *(void *)(v62 + 8 * v66);
                      if (v78)
                      {
                        unint64_t v79 = *(unsigned __int16 *)(v78 + 2 * v68);
                        if ((v63 - v64) >> 3 > v79)
                        {
                          uint64_t v80 = v64 + 8 * v79;
                          if (*(_DWORD *)(v80 + 4) == v65 && v80 != v63) {
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (++v20 == v56)
        {
          BOOL v20 = v56;
          goto LABEL_14;
        }
      }
      uint64_t v56 = v20;
LABEL_14:
      unint64_t v84 = v20;
    }
    uint64_t v14 = v56;
    if (v13 == v56) {
      goto LABEL_83;
    }
  }
  unint64_t v51 = v10[11];
  unint64_t v52 = v10[10] + v46;
  uint64_t v53 = *(void *)(a2 + 24);
  if (v53) {
    goto LABEL_46;
  }
LABEL_81:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_82:
  uint64_t result = ((uint64_t (*)(uint64_t (**)(void), uint64_t, uint64_t, uint64_t))v18)(v17, v7, v8, v9);
  unint64_t v19 = (void *)result;
LABEL_83:
  *unint64_t v19 = 0xFFFFFFFF00000000;
  return result;
}

void ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>::Model<ecs2::RuntimeQuery<md::ls::FunctionConstants const&,md::ls::RequiredPipelinePoolID const&,md::ls::IsTransparent const&>>::each(uint64_t a1, uint64_t a2)
{
  int v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  int64_t v4 = (void *)gdc::Registry::storage<md::ls::FunctionConstants>(v3);
  __int16 v5 = (void *)gdc::Registry::storage<md::ls::RequiredPipelinePoolID>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::IsTransparent>(v3);
  uint8x8_t v10 = (void *)v6;
  int v11 = v4 + 4;
  if (v5[8] - v5[7] < v4[8] - v4[7]) {
    int v11 = v5 + 4;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) >= v11[4] - v11[3]) {
    uint64_t v12 = (uint64_t)v11;
  }
  else {
    uint64_t v12 = v6 + 32;
  }
  v83[0] = v12;
  v83[1] = v4;
  v83[2] = v5;
  v83[3] = v6;
  uint64_t v14 = *(void **)(v12 + 24);
  uint64_t v13 = *(void **)(v12 + 32);
  unint64_t v84 = v14;
  if (v13 != v14
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v83))
  {
    uint64_t v15 = v14 + 1;
    do
    {
      uint64_t v14 = v15;
      unint64_t v84 = v15;
      if (v15 == v13) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v83);
      uint64_t v15 = v14 + 1;
    }
    while (!isValid);
  }
  uint64_t v17 = &ecs2::Runtime::_localEntity;
  std::string::size_type v18 = ecs2::Runtime::_localEntity;
  if (v13 == v14) {
    goto LABEL_82;
  }
  unint64_t v19 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *unint64_t v19 = *v14;
    unint64_t v21 = *v14;
    uint64_t v22 = HIDWORD(*v14);
    unint64_t v23 = *v14 >> 39;
    uint64_t v24 = v4[4];
    if (v23 >= (v4[5] - v24) >> 3) {
      goto LABEL_23;
    }
    uint64_t v25 = *(void *)(v24 + 8 * v23);
    if (!v25) {
      goto LABEL_23;
    }
    unint64_t v26 = *(unsigned __int16 *)(v25 + 2 * (HIDWORD(v21) & 0x7F));
    uint64_t v28 = v4[7];
    uint64_t v27 = v4[8];
    if (v26 >= (v27 - v28) >> 3) {
      goto LABEL_23;
    }
    uint64_t v29 = v28 + 8 * v26;
    if (v29 != v27 && *(_DWORD *)(v29 + 4) == v22)
    {
      uint64_t v82 = 33 * v26;
      uint64_t v31 = v4[11];
      uint64_t v32 = v4[10] + v82;
    }
    else
    {
LABEL_23:
      uint64_t v31 = v4[11];
      uint64_t v32 = v31;
    }
    uint64_t v33 = v32 == v31 ? 0 : v32;
    if ((uint64_t v34 = v5[4], v23 < (v5[5] - v34) >> 3)
      && (uint64_t v35 = *(void *)(v34 + 8 * v23)) != 0
      && (unint64_t v36 = *(unsigned __int16 *)(v35 + 2 * (HIDWORD(v21) & 0x7F)), v38 = v5[7], v37 = v5[8], v36 < (v37 - v38) >> 3)
      && ((uint64_t v39 = v38 + 8 * v36, v39 != v37) ? (v40 = *(_DWORD *)(v39 + 4) == v22) : (v40 = 0), v40))
    {
      unint64_t v41 = v5[11];
      unint64_t v42 = v5[10] + v36;
    }
    else
    {
      unint64_t v41 = v5[11];
      unint64_t v42 = v41;
    }
    unint64_t v43 = v42 == v41 ? 0 : v42;
    uint64_t v44 = v10[4];
    if (v23 < (v10[5] - v44) >> 3)
    {
      uint64_t v45 = *(void *)(v44 + 8 * v23);
      if (v45)
      {
        unint64_t v46 = *(unsigned __int16 *)(v45 + 2 * (HIDWORD(v21) & 0x7F));
        uint64_t v48 = v10[7];
        uint64_t v47 = v10[8];
        if (v46 < (v47 - v48) >> 3)
        {
          uint64_t v49 = v48 + 8 * v46;
          if (v49 != v47 && *(_DWORD *)(v49 + 4) == v22) {
            break;
          }
        }
      }
    }
    uint64_t v51 = v10[11];
    uint64_t v52 = v51;
    uint64_t v53 = *(void *)(a2 + 24);
    if (!v53) {
      goto LABEL_81;
    }
LABEL_46:
    if (v52 == v51) {
      uint64_t v54 = 0;
    }
    else {
      uint64_t v54 = v52;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(*(void *)v53 + 48))(v53, v33, v43, v54);
    uint64_t v56 = *(void **)(v12 + 32);
    BOOL v20 = v14 + 1;
    unint64_t v84 = v14 + 1;
    if (v14 + 1 != v56)
    {
      uint64_t v57 = v4[4];
      uint64_t v59 = v4[7];
      uint64_t v58 = v4[8];
      uint64_t v60 = v5[4];
      uint64_t result = v5[7];
      uint64_t v61 = v5[8];
      uint64_t v62 = v10[4];
      uint64_t v64 = v10[7];
      uint64_t v63 = v10[8];
      while (1)
      {
        unint64_t v65 = *((unsigned int *)v20 + 1);
        unint64_t v66 = v65 >> 7;
        if (v65 >> 7 < (v4[5] - v57) >> 3)
        {
          uint64_t v67 = *(void *)(v57 + 8 * v66);
          if (v67)
          {
            uint64_t v68 = v65 & 0x7F;
            unint64_t v69 = *(unsigned __int16 *)(v67 + 2 * v68);
            if ((v58 - v59) >> 3 > v69)
            {
              uint64_t v70 = v59 + 8 * v69;
              BOOL v71 = v70 != v58 && *(_DWORD *)(v70 + 4) == v65;
              if (v71 && v66 < (v5[5] - v60) >> 3)
              {
                uint64_t v73 = *(void *)(v60 + 8 * v66);
                if (v73)
                {
                  unint64_t v74 = *(unsigned __int16 *)(v73 + 2 * v68);
                  if ((v61 - result) >> 3 > v74)
                  {
                    unint64_t v75 = result + 8 * v74;
                    BOOL v76 = v75 != v61 && *(_DWORD *)(v75 + 4) == v65;
                    if (v76 && v66 < (v10[5] - v62) >> 3)
                    {
                      uint64_t v78 = *(void *)(v62 + 8 * v66);
                      if (v78)
                      {
                        unint64_t v79 = *(unsigned __int16 *)(v78 + 2 * v68);
                        if ((v63 - v64) >> 3 > v79)
                        {
                          uint64_t v80 = v64 + 8 * v79;
                          if (*(_DWORD *)(v80 + 4) == v65 && v80 != v63) {
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (++v20 == v56)
        {
          BOOL v20 = v56;
          goto LABEL_14;
        }
      }
      uint64_t v56 = v20;
LABEL_14:
      unint64_t v84 = v20;
    }
    uint64_t v14 = v56;
    if (v13 == v56) {
      goto LABEL_83;
    }
  }
  uint64_t v51 = v10[11];
  uint64_t v52 = v10[10] + 4 * v46;
  uint64_t v53 = *(void *)(a2 + 24);
  if (v53) {
    goto LABEL_46;
  }
LABEL_81:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_82:
  uint64_t result = ((uint64_t (*)(uint64_t (**)(void), uint64_t, uint64_t, uint64_t))v18)(v17, v7, v8, v9);
  unint64_t v19 = (void *)result;
LABEL_83:
  *unint64_t v19 = 0xFFFFFFFF00000000;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::CreatePipelines>,std::allocator<ecs2::ForwardToExecute<md::ita::CreatePipelines>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v227 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  int v3 = *(int8x8_t **)(a2 + 8);
  int64_t v4 = (void *)gdc::Registry::storage<md::ls::RenderItemID>(v3);
  __int16 v5 = (void *)gdc::Registry::storage<md::ls::RequiredPipelinePoolID>(v3);
  uint64_t v6 = v5;
  uint64_t v7 = v5 + 4;
  if (v5[8] - v5[7] >= v4[8] - v4[7]) {
    uint64_t v8 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v215, v8, v4, v5, *(void *)(v8 + 24));
  if (v6[8] - v6[7] >= v4[8] - v4[7]) {
    uint64_t v9 = (uint64_t)(v4 + 4);
  }
  else {
    uint64_t v9 = (uint64_t)v7;
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v213, v9, v4, v6, *(void *)(v9 + 32));
  if (v214 != v218)
  {
    uint64_t v10 = ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v12 = (void *)v10;
    uint64_t v211 = v6;
    uint64_t v212 = v2;
    unint64_t v210 = (void *)v10;
    while (1)
    {
      *uint64_t v12 = *v11;
      unint64_t v13 = *v11;
      uint64_t v14 = v6[4];
      if (v13 >> 39 < (v6[5] - v14) >> 3
        && (uint64_t v15 = *(void *)(v14 + 8 * (v13 >> 39))) != 0
        && (unint64_t v16 = *(unsigned __int16 *)(v15 + 2 * (HIDWORD(v13) & 0x7F)),
            uint64_t v18 = v6[7],
            uint64_t v17 = v6[8],
            v16 < (v17 - v18) >> 3)
        && ((unint64_t v19 = HIDWORD(v13), v20 = v18 + 8 * v16, v20 != v17)
          ? (BOOL v21 = *(_DWORD *)(v20 + 4) == v19)
          : (BOOL v21 = 0),
            v21))
      {
        uint64_t v22 = (unsigned __int8 *)v6[11];
        unint64_t v23 = (unsigned __int8 *)(v6[10] + v16);
      }
      else
      {
        uint64_t v22 = (unsigned __int8 *)v6[11];
        unint64_t v23 = v22;
      }
      if (v23 == v22) {
        uint64_t v24 = 0;
      }
      else {
        uint64_t v24 = v23;
      }
      uint64_t v25 = **(void **)(v2 + 8);
      unint64_t v26 = *(void **)v25;
      uint64_t v27 = *(void **)(v25 + 8);
      if (v26 != v27)
      {
        while (*v26 != 0x41D4E9297E100630)
        {
          v26 += 5;
          if (v26 == v27) {
            goto LABEL_29;
          }
        }
      }
      if (v26 == v27)
      {
LABEL_29:
        uint64_t v29 = 0;
      }
      else
      {
        uint64_t v29 = v26[3];
        uint64_t v28 = (std::__shared_weak_count *)v26[4];
        if (v28)
        {
          atomic_fetch_add_explicit(&v28->__shared_owners_, 1uLL, memory_order_relaxed);
          if (!atomic_fetch_add(&v28->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v28->__on_zero_shared)(v28);
            std::__shared_weak_count::__release_weak(v28);
          }
        }
      }
      unsigned int v30 = *v24;
      if (v30 < 8) {
        break;
      }
      if (v30 - 8 < 4)
      {
        Flyover::GetDataIDs((Flyover *)v10);
        uint64_t v31 = &Flyover::GetDataIDs(void)::kDataIDs;
        goto LABEL_34;
      }
      uint64_t v31 = 0;
      if (v30 > 0xB)
      {
LABEL_84:
        uint64_t v35 = 0;
        goto LABEL_70;
      }
LABEL_35:
      switch(v30)
      {
        case 0u:
          uint64_t v32 = ggl::FragmentedPool<ggl::DaVinci::GroundPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10496) + 1080));
          goto LABEL_69;
        case 1u:
          uint64_t v32 = ggl::FragmentedPool<ggl::DaVinci::GroundNonCompressedPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10496) + 1096));
          goto LABEL_69;
        case 2u:
          uint64_t v32 = ggl::FragmentedPool<ggl::DaVinci::GroundDepthPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10496)
                                                                                           + 1104));
          goto LABEL_69;
        case 3u:
          uint64_t v35 = ggl::FragmentedPool<ggl::DaVinci::GroundShadowMapPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10496)
                                                                                               + 1112));
          uint64_t v58 = *(void **)(v35 + 32);
          void *v58 = 0;
          v58[1] = 0;
          uint64_t v59 = *(void *)(v35 + 32);
          *(void *)(v59 + 16) = 0;
          *(void *)(v59 + 24) = 0;
          break;
        case 4u:
          uint64_t v32 = ggl::FragmentedPool<ggl::DaVinci::RibbonPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10496) + 1120));
          goto LABEL_69;
        case 5u:
          uint64_t v32 = ggl::FragmentedPool<ggl::DaVinci::DecalPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10496) + 1128));
          goto LABEL_69;
        case 6u:
          uint64_t v32 = ggl::FragmentedPool<ggl::DaVinci::LinearDepthPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10496)
                                                                                           + 1432));
          goto LABEL_69;
        case 7u:
          uint64_t v32 = ggl::FragmentedPool<ggl::DaVinci::PackedLinearDepthPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10496)
                                                                                                 + 1440));
          goto LABEL_69;
        case 8u:
          uint64_t v32 = ggl::FragmentedPool<ggl::Flyover::FlyoverPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10504)
                                                                                       + 1120));
          goto LABEL_69;
        case 9u:
          uint64_t v46 = *(void *)(*(void *)(v29 + 10504) + 1144);
          uint64_t v47 = *(void *)(v46 + 8);
          if (v47 == *(void *)v46)
          {
            uint64_t v152 = *(void *)(v46 + 88);
            if (!v152) {
              goto LABEL_307;
            }
            uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)v152 + 48))(v152);
            uint64_t v48 = *(uint64_t **)(v46 + 40);
            unint64_t v153 = *(void *)(v46 + 48);
            if ((unint64_t)v48 >= v153)
            {
              uint64_t v161 = *(void *)(v46 + 32);
              uint64_t v162 = ((uint64_t)v48 - v161) >> 3;
              unint64_t v163 = v162 + 1;
              if ((unint64_t)(v162 + 1) >> 61) {
                abort();
              }
              uint64_t v164 = v153 - v161;
              if (v164 >> 2 > v163) {
                unint64_t v163 = v164 >> 2;
              }
              if ((unint64_t)v164 >= 0x7FFFFFFFFFFFFFF8) {
                uint64_t v165 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v165 = v163;
              }
              if (v165)
              {
                uint64_t v166 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v46 + 56) + 16))(*(void *)(v46 + 56), 8 * v165, 8);
                uint64_t v56 = (uint64_t *)(v166 + 8 * v162);
                uint64_t v57 = v166 + 8 * v165;
                if (v166) {
                  *uint64_t v56 = v35;
                }
              }
              else
              {
                uint64_t v57 = 0;
                uint64_t v56 = (uint64_t *)(8 * v162);
              }
              uint64_t v195 = *(void *)(v46 + 32);
              uint64_t v177 = *(void *)(v46 + 40);
              uint64_t v196 = v177 - v195;
              if (v177 != v195)
              {
                unint64_t v197 = v196 - 8;
                if ((unint64_t)(v196 - 8) < 0x38)
                {
                  uint8x8_t v181 = v56;
                }
                else
                {
                  uint8x8_t v181 = v56;
                  if ((unint64_t)(v177 - (void)v56) >= 0x20)
                  {
                    uint64_t v198 = (v197 >> 3) + 1;
                    double v199 = v56 - 2;
                    uint64_t v200 = (long long *)(v177 - 16);
                    uint64_t v201 = v198 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v202 = *v200;
                      *((_OWORD *)v199 - 1) = *(v200 - 1);
                      *(_OWORD *)double v199 = v202;
                      v199 -= 4;
                      v200 -= 2;
                      v201 -= 4;
                    }
                    while (v201);
                    uint8x8_t v181 = &v56[-(v198 & 0x3FFFFFFFFFFFFFFCLL)];
                    v177 -= 8 * (v198 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v198 == (v198 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_296:
                      uint64_t v177 = *(void *)(v46 + 32);
LABEL_297:
                      uint64_t v154 = v56 + 1;
                      *(void *)(v46 + 32) = v181;
                      *(void *)(v46 + 40) = v56 + 1;
                      uint64_t v209 = *(void *)(v46 + 48);
                      *(void *)(v46 + 48) = v57;
                      if (v177) {
                        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v46 + 56) + 40))(*(void *)(v46 + 56), v177, v209 - v177);
                      }
                      goto LABEL_299;
                    }
                  }
                }
                do
                {
                  uint64_t v208 = *(void *)(v177 - 8);
                  v177 -= 8;
                  *--uint8x8_t v181 = v208;
                }
                while (v177 != v195);
                goto LABEL_296;
              }
LABEL_280:
              uint8x8_t v181 = v56;
              goto LABEL_297;
            }
          }
          else
          {
            uint64_t v35 = *(void *)(v47 - 8);
            *(void *)(v46 + 8) = v47 - 8;
            uint64_t v48 = *(uint64_t **)(v46 + 40);
            unint64_t v49 = *(void *)(v46 + 48);
            if ((unint64_t)v48 >= v49)
            {
              uint64_t v50 = *(void *)(v46 + 32);
              uint64_t v51 = ((uint64_t)v48 - v50) >> 3;
              unint64_t v52 = v51 + 1;
              if ((unint64_t)(v51 + 1) >> 61) {
                abort();
              }
              uint64_t v53 = v49 - v50;
              if (v53 >> 2 > v52) {
                unint64_t v52 = v53 >> 2;
              }
              if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
                uint64_t v54 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v54 = v52;
              }
              if (v54)
              {
                uint64_t v55 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v46 + 56) + 16))(*(void *)(v46 + 56), 8 * v54, 8);
                uint64_t v56 = (uint64_t *)(v55 + 8 * v51);
                uint64_t v57 = v55 + 8 * v54;
                if (v55) {
                  *uint64_t v56 = v35;
                }
              }
              else
              {
                uint64_t v57 = 0;
                uint64_t v56 = (uint64_t *)(8 * v51);
              }
              uint64_t v178 = *(void *)(v46 + 32);
              uint64_t v177 = *(void *)(v46 + 40);
              uint64_t v179 = v177 - v178;
              if (v177 != v178)
              {
                unint64_t v180 = v179 - 8;
                if ((unint64_t)(v179 - 8) < 0x38)
                {
                  uint8x8_t v181 = v56;
                }
                else
                {
                  uint8x8_t v181 = v56;
                  if ((unint64_t)(v177 - (void)v56) >= 0x20)
                  {
                    uint64_t v182 = (v180 >> 3) + 1;
                    uint64_t v183 = v56 - 2;
                    int8x8_t v184 = (long long *)(v177 - 16);
                    uint64_t v185 = v182 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v186 = *v184;
                      *((_OWORD *)v183 - 1) = *(v184 - 1);
                      *(_OWORD *)uint64_t v183 = v186;
                      v183 -= 4;
                      v184 -= 2;
                      v185 -= 4;
                    }
                    while (v185);
                    uint8x8_t v181 = &v56[-(v182 & 0x3FFFFFFFFFFFFFFCLL)];
                    v177 -= 8 * (v182 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v182 == (v182 & 0x3FFFFFFFFFFFFFFCLL)) {
                      goto LABEL_296;
                    }
                  }
                }
                do
                {
                  uint64_t v204 = *(void *)(v177 - 8);
                  v177 -= 8;
                  *--uint8x8_t v181 = v204;
                }
                while (v177 != v178);
                goto LABEL_296;
              }
              goto LABEL_280;
            }
          }
          if (v48) {
            uint64_t *v48 = v35;
          }
          uint64_t v154 = v48 + 1;
LABEL_299:
          *(void *)(v46 + 40) = v154;
          int64_t v223 = (void *)v35;
          uint64_t v207 = *(void *)(v46 + 120);
          if (!v207)
          {
LABEL_307:
            std::__throw_bad_function_call[abi:nn180100]();
            __break(1u);
            return;
          }
          goto LABEL_293;
        case 0xAu:
          uint64_t v32 = ggl::FragmentedPool<ggl::FlyoverNight::FlyoverPipelineSetup>::pop(*(void *)(*(void *)(v29 + 10504)
                                                                                            + 1168));
LABEL_69:
          uint64_t v35 = v32;
          break;
        case 0xBu:
          uint64_t v33 = *(void *)(*(void *)(v29 + 10504) + 1192);
          uint64_t v34 = *(void *)(v33 + 8);
          if (v34 == *(void *)v33)
          {
            uint64_t v149 = *(void *)(v33 + 88);
            if (!v149) {
              goto LABEL_307;
            }
            uint64_t v35 = (*(uint64_t (**)(uint64_t))(*(void *)v149 + 48))(v149);
            unint64_t v36 = *(uint64_t **)(v33 + 40);
            unint64_t v150 = *(void *)(v33 + 48);
            if ((unint64_t)v36 >= v150)
            {
              uint64_t v155 = *(void *)(v33 + 32);
              uint64_t v156 = ((uint64_t)v36 - v155) >> 3;
              unint64_t v157 = v156 + 1;
              if ((unint64_t)(v156 + 1) >> 61) {
                abort();
              }
              uint64_t v158 = v150 - v155;
              if (v158 >> 2 > v157) {
                unint64_t v157 = v158 >> 2;
              }
              if ((unint64_t)v158 >= 0x7FFFFFFFFFFFFFF8) {
                uint64_t v159 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v159 = v157;
              }
              if (v159)
              {
                uint64_t v160 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v33 + 56) + 16))(*(void *)(v33 + 56), 8 * v159, 8);
                uint64_t v44 = (uint64_t *)(v160 + 8 * v156);
                uint64_t v45 = v160 + 8 * v159;
                if (v160) {
                  uint64_t *v44 = v35;
                }
              }
              else
              {
                uint64_t v45 = 0;
                uint64_t v44 = (uint64_t *)(8 * v156);
              }
              uint64_t v187 = *(void *)(v33 + 32);
              uint64_t v167 = *(void *)(v33 + 40);
              uint64_t v188 = v167 - v187;
              if (v167 != v187)
              {
                unint64_t v189 = v188 - 8;
                if ((unint64_t)(v188 - 8) < 0x38)
                {
                  uint64_t v171 = v44;
                }
                else
                {
                  uint64_t v171 = v44;
                  if ((unint64_t)(v167 - (void)v44) >= 0x20)
                  {
                    uint64_t v190 = (v189 >> 3) + 1;
                    uint64_t v191 = v44 - 2;
                    uint64_t v192 = (long long *)(v167 - 16);
                    uint64_t v193 = v190 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v194 = *v192;
                      *((_OWORD *)v191 - 1) = *(v192 - 1);
                      *(_OWORD *)uint64_t v191 = v194;
                      v191 -= 4;
                      v192 -= 2;
                      v193 -= 4;
                    }
                    while (v193);
                    uint64_t v171 = &v44[-(v190 & 0x3FFFFFFFFFFFFFFCLL)];
                    v167 -= 8 * (v190 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v190 == (v190 & 0x3FFFFFFFFFFFFFFCLL))
                    {
LABEL_289:
                      uint64_t v167 = *(void *)(v33 + 32);
LABEL_290:
                      unint64_t v151 = v44 + 1;
                      *(void *)(v33 + 32) = v171;
                      *(void *)(v33 + 40) = v44 + 1;
                      uint64_t v206 = *(void *)(v33 + 48);
                      *(void *)(v33 + 48) = v45;
                      if (v167) {
                        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v33 + 56) + 40))(*(void *)(v33 + 56), v167, v206 - v167);
                      }
                      goto LABEL_292;
                    }
                  }
                }
                do
                {
                  uint64_t v205 = *(void *)(v167 - 8);
                  v167 -= 8;
                  *--uint64_t v171 = v205;
                }
                while (v167 != v187);
                goto LABEL_289;
              }
LABEL_271:
              uint64_t v171 = v44;
              goto LABEL_290;
            }
          }
          else
          {
            uint64_t v35 = *(void *)(v34 - 8);
            *(void *)(v33 + 8) = v34 - 8;
            unint64_t v36 = *(uint64_t **)(v33 + 40);
            unint64_t v37 = *(void *)(v33 + 48);
            if ((unint64_t)v36 >= v37)
            {
              uint64_t v38 = *(void *)(v33 + 32);
              uint64_t v39 = ((uint64_t)v36 - v38) >> 3;
              unint64_t v40 = v39 + 1;
              if ((unint64_t)(v39 + 1) >> 61) {
                abort();
              }
              uint64_t v41 = v37 - v38;
              if (v41 >> 2 > v40) {
                unint64_t v40 = v41 >> 2;
              }
              if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8) {
                uint64_t v42 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                uint64_t v42 = v40;
              }
              if (v42)
              {
                uint64_t v43 = (*(uint64_t (**)(void, uint64_t, uint64_t))(**(void **)(v33 + 56) + 16))(*(void *)(v33 + 56), 8 * v42, 8);
                uint64_t v44 = (uint64_t *)(v43 + 8 * v39);
                uint64_t v45 = v43 + 8 * v42;
                if (v43) {
                  uint64_t *v44 = v35;
                }
              }
              else
              {
                uint64_t v45 = 0;
                uint64_t v44 = (uint64_t *)(8 * v39);
              }
              uint64_t v168 = *(void *)(v33 + 32);
              uint64_t v167 = *(void *)(v33 + 40);
              uint64_t v169 = v167 - v168;
              if (v167 != v168)
              {
                unint64_t v170 = v169 - 8;
                if ((unint64_t)(v169 - 8) < 0x38)
                {
                  uint64_t v171 = v44;
                }
                else
                {
                  uint64_t v171 = v44;
                  if ((unint64_t)(v167 - (void)v44) >= 0x20)
                  {
                    uint64_t v172 = (v170 >> 3) + 1;
                    uint64_t v173 = v44 - 2;
                    unint64_t v174 = (long long *)(v167 - 16);
                    uint64_t v175 = v172 & 0x3FFFFFFFFFFFFFFCLL;
                    do
                    {
                      long long v176 = *v174;
                      *((_OWORD *)v173 - 1) = *(v174 - 1);
                      *(_OWORD *)uint64_t v173 = v176;
                      v173 -= 4;
                      v174 -= 2;
                      v175 -= 4;
                    }
                    while (v175);
                    uint64_t v171 = &v44[-(v172 & 0x3FFFFFFFFFFFFFFCLL)];
                    v167 -= 8 * (v172 & 0x3FFFFFFFFFFFFFFCLL);
                    if (v172 == (v172 & 0x3FFFFFFFFFFFFFFCLL)) {
                      goto LABEL_289;
                    }
                  }
                }
                do
                {
                  uint64_t v203 = *(void *)(v167 - 8);
                  v167 -= 8;
                  *--uint64_t v171 = v203;
                }
                while (v167 != v168);
                goto LABEL_289;
              }
              goto LABEL_271;
            }
          }
          if (v36) {
            *unint64_t v36 = v35;
          }
          unint64_t v151 = v36 + 1;
LABEL_292:
          *(void *)(v33 + 40) = v151;
          int64_t v223 = (void *)v35;
          uint64_t v207 = *(void *)(v33 + 120);
          if (!v207) {
            goto LABEL_307;
          }
LABEL_293:
          (*(void (**)(uint64_t, void **))(*(void *)v207 + 48))(v207, &v223);
          break;
        default:
          goto LABEL_84;
      }
LABEL_70:
      ggl::PipelineSetup::resetData(v35);
      uint64_t v60 = *(void *)(v29 + 384);
      if (*(void *)(v29 + 376) == v60)
      {
        uint64_t v63 = ((*(void *)(v29 + 432) - *(void *)(v29 + 424)) >> 4) | 0x100000000;
        unint64_t v65 = *(uint64_t **)(v29 + 408);
        unint64_t v64 = *(void *)(v29 + 416);
        if ((unint64_t)v65 >= v64)
        {
          uint64_t v67 = *(char **)(v29 + 400);
          uint64_t v68 = ((char *)v65 - v67) >> 3;
          unint64_t v69 = v68 + 1;
          if ((unint64_t)(v68 + 1) >> 61) {
            abort();
          }
          uint64_t v70 = v64 - (void)v67;
          if (v70 >> 2 > v69) {
            unint64_t v69 = v70 >> 2;
          }
          if ((unint64_t)v70 >= 0x7FFFFFFFFFFFFFF8) {
            unint64_t v71 = 0x1FFFFFFFFFFFFFFFLL;
          }
          else {
            unint64_t v71 = v69;
          }
          if (v71)
          {
            if (v71 >> 61) {
              goto LABEL_303;
            }
            unint64_t v72 = (char *)operator new(8 * v71);
          }
          else
          {
            unint64_t v72 = 0;
          }
          uint64_t v73 = (uint64_t *)&v72[8 * v68];
          uint64_t *v73 = v63;
          unint64_t v66 = v73 + 1;
          if (v65 != (uint64_t *)v67)
          {
            unint64_t v74 = (char *)v65 - v67 - 8;
            if (v74 < 0x58) {
              goto LABEL_315;
            }
            if ((unint64_t)(v67 - v72) < 0x20) {
              goto LABEL_315;
            }
            uint64_t v75 = (v74 >> 3) + 1;
            BOOL v76 = &v72[8 * v68 - 16];
            uint64_t v77 = v65 - 2;
            uint64_t v78 = v75 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v79 = *(_OWORD *)v77;
              *((_OWORD *)v76 - 1) = *((_OWORD *)v77 - 1);
              *(_OWORD *)BOOL v76 = v79;
              v76 -= 32;
              v77 -= 4;
              v78 -= 4;
            }
            while (v78);
            v73 -= v75 & 0x3FFFFFFFFFFFFFFCLL;
            v65 -= v75 & 0x3FFFFFFFFFFFFFFCLL;
            if (v75 != (v75 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_315:
              do
              {
                uint64_t v80 = *--v65;
                *--uint64_t v73 = v80;
              }
              while (v65 != (uint64_t *)v67);
            }
            unint64_t v65 = *(uint64_t **)(v29 + 400);
          }
          *(void *)(v29 + 400) = v73;
          *(void *)(v29 + 408) = v66;
          *(void *)(v29 + 416) = &v72[8 * v71];
          if (v65) {
            operator delete(v65);
          }
        }
        else
        {
          *unint64_t v65 = v63;
          unint64_t v66 = v65 + 1;
        }
        *(void *)(v29 + 408) = v66;
        unint64_t v62 = *(v66 - 1);
      }
      else
      {
        uint64_t v61 = *(void *)(v60 - 8);
        *(void *)(v29 + 384) = v60 - 8;
        *(_DWORD *)(*(void *)(v29 + 400) + 8 * v61) = (*(void *)(v29 + 432) - *(void *)(v29 + 424)) >> 4;
        *(_DWORD *)(*(void *)(v29 + 400) + 8 * v61 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(v29 + 400)
                                                                                                + 8 * v61
                                                                                                + 4) << 32)
                                                           + 0x100000000) >> 32;
        unint64_t v62 = v61 | ((unint64_t)*(unsigned int *)(*(void *)(v29 + 400) + 8 * v61 + 4) << 32);
      }
      uint64_t v82 = *(uint64_t **)(v29 + 432);
      unint64_t v81 = *(void *)(v29 + 440);
      if ((unint64_t)v82 >= v81)
      {
        unint64_t v84 = *(uint64_t **)(v29 + 424);
        uint64_t v85 = ((char *)v82 - (char *)v84) >> 4;
        unint64_t v86 = v85 + 1;
        if ((unint64_t)(v85 + 1) >> 60) {
          abort();
        }
        uint64_t v87 = v81 - (void)v84;
        if (v87 >> 3 > v86) {
          unint64_t v86 = v87 >> 3;
        }
        if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF0) {
          unint64_t v88 = 0xFFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v88 = v86;
        }
        if (v88)
        {
          if (v88 >> 60) {
            goto LABEL_303;
          }
          double v89 = (char *)operator new(16 * v88);
        }
        else
        {
          double v89 = 0;
        }
        uint64_t v90 = (uint64_t *)&v89[16 * v85];
        uint64_t *v90 = v35;
        v90[1] = (uint64_t)v31;
        unint64_t v91 = v90;
        if (v82 != v84)
        {
          do
          {
            *((_OWORD *)v91 - 1) = *((_OWORD *)v82 - 1);
            v91 -= 2;
            v82 -= 2;
          }
          while (v82 != v84);
          uint64_t v82 = *(uint64_t **)(v29 + 424);
        }
        unint64_t v83 = v90 + 2;
        *(void *)(v29 + 424) = v91;
        *(void *)(v29 + 432) = v90 + 2;
        *(void *)(v29 + 440) = &v89[16 * v88];
        if (v82) {
          operator delete(v82);
        }
      }
      else
      {
        *uint64_t v82 = v35;
        v82[1] = (uint64_t)v31;
        unint64_t v83 = v82 + 2;
      }
      *(void *)(v29 + 432) = v83;
      unint64_t v93 = *(void *)(v29 + 456);
      unint64_t v92 = *(void *)(v29 + 464);
      if (v93 >= v92)
      {
        float v95 = *(unsigned char **)(v29 + 448);
        uint64_t v96 = (uint64_t)(v93 - (void)v95) >> 3;
        unint64_t v97 = v96 + 1;
        if ((unint64_t)(v96 + 1) >> 61) {
          abort();
        }
        uint64_t v98 = v92 - (void)v95;
        if (v98 >> 2 > v97) {
          unint64_t v97 = v98 >> 2;
        }
        if ((unint64_t)v98 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v99 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v99 = v97;
        }
        if (v99)
        {
          if (v99 >> 61) {
LABEL_303:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          uint64_t v100 = operator new(8 * v99);
        }
        else
        {
          uint64_t v100 = 0;
        }
        int v101 = &v100[8 * v96];
        *int v101 = v62;
        float v94 = v101 + 1;
        if ((unsigned char *)v93 != v95)
        {
          unint64_t v102 = v93 - (void)v95 - 8;
          if (v102 < 0x58) {
            goto LABEL_316;
          }
          if ((unint64_t)(v95 - v100) < 0x20) {
            goto LABEL_316;
          }
          uint64_t v103 = (v102 >> 3) + 1;
          uint64_t v104 = &v100[8 * v96 - 16];
          uint64_t v105 = (long long *)(v93 - 16);
          uint64_t v106 = v103 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v107 = *v105;
            *(v104 - 1) = *(v105 - 1);
            *uint64_t v104 = v107;
            v104 -= 2;
            v105 -= 2;
            v106 -= 4;
          }
          while (v106);
          v101 -= v103 & 0x3FFFFFFFFFFFFFFCLL;
          v93 -= 8 * (v103 & 0x3FFFFFFFFFFFFFFCLL);
          if (v103 != (v103 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_316:
            do
            {
              uint64_t v108 = *(void *)(v93 - 8);
              v93 -= 8;
              *--int v101 = v108;
            }
            while ((unsigned char *)v93 != v95);
          }
        }
        *(void *)(v29 + 448) = v101;
        *(void *)(v29 + 456) = v94;
        *(void *)(v29 + 464) = &v100[8 * v99];
        if (v95) {
          operator delete(v95);
        }
      }
      else
      {
        *(void *)unint64_t v93 = v62;
        v93 += 8;
        float v94 = (void *)v93;
      }
      float v109 = (uint64_t *)(v29 + 296);
      *(void *)(v29 + 456) = v94;
      unint64_t v110 = *(void *)(v29 + 304);
      if (v110)
      {
        uint8x8_t v111 = (uint8x8_t)vcnt_s8((int8x8_t)v110);
        v111.i16[0] = vaddlv_u8(v111);
        if (v111.u32[0] > 1uLL)
        {
          unint64_t v93 = v62;
          if (v62 >= v110) {
            unint64_t v93 = v62 % v110;
          }
        }
        else
        {
          unint64_t v93 = (v110 - 1) & v62;
        }
        unint64_t v112 = *(void **)(*v109 + 8 * v93);
        if (v112)
        {
          unint64_t v113 = (void *)*v112;
          if (v113)
          {
            if (v111.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v115 = v113[1];
                if (v115 == v62)
                {
                  if (v113[2] == v62) {
                    goto LABEL_193;
                  }
                }
                else if ((v115 & (v110 - 1)) != v93)
                {
                  goto LABEL_155;
                }
                unint64_t v113 = (void *)*v113;
                if (!v113) {
                  goto LABEL_155;
                }
              }
            }
            do
            {
              unint64_t v114 = v113[1];
              if (v114 == v62)
              {
                if (v113[2] == v62) {
                  goto LABEL_193;
                }
              }
              else
              {
                if (v114 >= v110) {
                  v114 %= v110;
                }
                if (v114 != v93) {
                  break;
                }
              }
              unint64_t v113 = (void *)*v113;
            }
            while (v113);
          }
        }
      }
LABEL_155:
      uint64_t v116 = (char *)operator new(0x30uLL);
      *(void *)uint64_t v116 = 0;
      *((void *)v116 + 1) = v62;
      *((void *)v116 + 2) = v62;
      *(_OWORD *)(v116 + 24) = xmmword_1A28FCC60;
      v116[40] = 0;
      float v117 = (float)(unint64_t)(*(void *)(v29 + 320) + 1);
      float v118 = *(float *)(v29 + 328);
      if ((((float)(v118 * (float)v110) >= v117) & ~(v110 == 0)) == 0)
      {
        BOOL v119 = v110 < 3 || (v110 & (v110 - 1)) != 0;
        unint64_t v120 = v119 | (2 * v110);
        unint64_t v121 = vcvtps_u32_f32(v117 / v118);
        if (v120 <= v121) {
          size_t prime = v121;
        }
        else {
          size_t prime = v120;
        }
        if (prime == 1)
        {
          size_t prime = 2;
        }
        else if ((prime & (prime - 1)) != 0)
        {
          size_t prime = std::__next_prime(prime);
          unint64_t v110 = *(void *)(v29 + 304);
        }
        if (prime > v110) {
          goto LABEL_167;
        }
        if (prime < v110)
        {
          unint64_t v123 = vcvtps_u32_f32((float)*(unint64_t *)(v29 + 320) / *(float *)(v29 + 328));
          if (v110 < 3
            || (uint8x8_t v124 = (uint8x8_t)vcnt_s8((int8x8_t)v110), v124.i16[0] = vaddlv_u8(v124), v124.u32[0] > 1uLL))
          {
            unint64_t v123 = std::__next_prime(v123);
          }
          else
          {
            uint64_t v125 = 1 << -(char)__clz(v123 - 1);
            if (v123 >= 2) {
              unint64_t v123 = v125;
            }
          }
          if (prime <= v123) {
            size_t prime = v123;
          }
          if (prime < v110) {
LABEL_167:
          }
            std::__hash_table<unsigned long,std::hash<unsigned long>,std::equal_to<unsigned long>,std::allocator<unsigned long>>::__do_rehash<true>(v29 + 296, prime);
        }
        unint64_t v110 = *(void *)(v29 + 304);
        if ((v110 & (v110 - 1)) != 0)
        {
          if (v62 >= v110) {
            unint64_t v93 = v62 % v110;
          }
          else {
            unint64_t v93 = v62;
          }
        }
        else
        {
          unint64_t v93 = (v110 - 1) & v62;
        }
      }
      uint64_t v126 = *v109;
      size_t v127 = *(void **)(*v109 + 8 * v93);
      if (v127)
      {
        *(void *)uint64_t v116 = *v127;
      }
      else
      {
        *(void *)uint64_t v116 = *(void *)(v29 + 312);
        *(void *)(v29 + 312) = v116;
        *(void *)(v126 + 8 * v93) = v29 + 312;
        if (!*(void *)v116) {
          goto LABEL_192;
        }
        unint64_t v128 = *(void *)(*(void *)v116 + 8);
        if ((v110 & (v110 - 1)) != 0)
        {
          if (v128 >= v110) {
            v128 %= v110;
          }
        }
        else
        {
          v128 &= v110 - 1;
        }
        size_t v127 = (void *)(*v109 + 8 * v128);
      }
      *size_t v127 = v116;
LABEL_192:
      ++*(void *)(v29 + 320);
LABEL_193:
      uint64_t v2 = v212;
      unint64_t v129 = *(void **)(v212 + 8);
      uint64_t v12 = v210;
      uint64_t v130 = *v210;
      uint64_t v220 = (uint64_t (**)(void **))&unk_1EF523360;
      *(void *)&long long v221 = v62;
      *((void *)&v221 + 1) = v130;
      uint64_t v222 = (void **)&v220;
      uint64_t v225 = &v223;
      int64_t v223 = &unk_1EF523360;
      long long v224 = v221;
      int v226 = 0;
      ecs2::Runtime::queueCommand(v129, (uint64_t)&v223);
      if (v226 != -1) {
        ((void (*)(char *, void **))off_1EF58FF48[v226])(&v219, &v223);
      }
      int v226 = -1;
      uint64_t v10 = (uint64_t)v222;
      uint64_t v6 = v211;
      if (v222 == (void **)&v220)
      {
        uint64_t v10 = v220[4]((void **)&v220);
      }
      else if (v222)
      {
        uint64_t v10 = (*((uint64_t (**)(void))*v222 + 5))();
      }
      uint64_t v131 = v218;
      int v11 = *(unint64_t **)(v215 + 32);
      if (++v218 != v11)
      {
        uint64_t v132 = v216[4];
        unint64_t v133 = (v216[5] - v132) >> 3;
        uint64_t v134 = v131 + 2;
        while (1)
        {
          unint64_t v135 = *((unsigned int *)v134 - 1);
          unint64_t v136 = v135 >> 7;
          if (v135 >> 7 < v133)
          {
            uint64_t v137 = *(void *)(v132 + 8 * v136);
            if (v137)
            {
              unint64_t v138 = *(unsigned __int16 *)(v137 + 2 * (v135 & 0x7F));
              uint64_t v139 = v216[7];
              uint64_t v10 = v216[8];
              if (v138 < (v10 - v139) >> 3)
              {
                uint64_t v140 = v139 + 8 * v138;
                if (v140 != v10 && *(_DWORD *)(v140 + 4) == v135)
                {
                  uint64_t v142 = v217[4];
                  uint64_t v10 = v217[5] - v142;
                  if (v136 < v10 >> 3)
                  {
                    uint64_t v143 = *(void *)(v142 + 8 * v136);
                    if (v143)
                    {
                      unint64_t v144 = *(unsigned __int16 *)(v143 + 2 * (v135 & 0x7F));
                      uint64_t v146 = v217[7];
                      uint64_t v145 = v217[8];
                      uint64_t v10 = v145 - v146;
                      if (v144 < (v145 - v146) >> 3)
                      {
                        uint64_t v147 = v146 + 8 * v144;
                        if (v147 != v145 && *(_DWORD *)(v147 + 4) == v135) {
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          uint64_t v218 = v134;
          BOOL v21 = v134++ == v11;
          if (v21) {
            goto LABEL_9;
          }
        }
        int v11 = v134 - 1;
      }
LABEL_9:
      if (v214 == v11) {
        goto LABEL_302;
      }
    }
    DaVinci::GetDataIDs((DaVinci *)v10);
    uint64_t v31 = &DaVinci::GetDataIDs(void)::kDataIDs;
LABEL_34:
    unsigned int v30 = *v24;
    goto LABEL_35;
  }
  uint64_t v12 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
LABEL_302:
  *uint64_t v12 = 0xFFFFFFFF00000000;
  *(void *)(v2 + 8) = 0;
}

void sub_1A1AC96A4(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::DetermineDataIDsNeeded>,std::allocator<ecs2::ForwardToExecute<md::ita::DetermineDataIDsNeeded>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  int v3 = (void *)gdc::Registry::storage<md::ls::RequiredPipelinePoolID>(*(int8x8_t **)(a2 + 8));
  int64_t v4 = v3;
  uint64_t v6 = (unint64_t *)v3[7];
  __int16 v5 = (uint64_t *)v3[8];
  uint64_t v7 = (char *)v5 - (char *)v6;
  if (v5 != (uint64_t *)v6)
  {
    if ((unint64_t v8 = *((unsigned int *)v6 + 1), v9 = v3[4], v10 = (v3[5] - v9) >> 3, v8 >> 7 >= v10)
      || (uint64_t v11 = *(void *)(v9 + 8 * (v8 >> 7))) == 0
      || (unint64_t v12 = *(unsigned __int16 *)(v11 + 2 * (v8 & 0x7F)), v12 >= v7 >> 3)
      || ((unint64_t v13 = (uint64_t *)&v6[v12], v13 != v5) ? (v14 = *((_DWORD *)v13 + 1) == v8) : (v14 = 0), !v14))
    {
      unint64_t v15 = v7 >> 3;
      unint64_t v16 = (uint64_t *)(v6 + 1);
      do
      {
        if (v16 == v5) {
          goto LABEL_51;
        }
        unint64_t v17 = *((unsigned int *)v16 + 1);
        uint64_t v18 = (uint64_t *)v3[8];
        if (v17 >> 7 < v10)
        {
          uint64_t v19 = *(void *)(v9 + 8 * (v17 >> 7));
          uint64_t v18 = (uint64_t *)v3[8];
          if (v19)
          {
            unint64_t v20 = *(unsigned __int16 *)(v19 + 2 * (v17 & 0x7F));
            uint64_t v18 = (uint64_t *)v3[8];
            if (v15 > v20)
            {
              uint64_t v18 = (uint64_t *)&v6[v20];
              if (*((_DWORD *)v18 + 1) != v17) {
                uint64_t v18 = (uint64_t *)v3[8];
              }
            }
          }
        }
        ++v16;
      }
      while (v18 == v5);
      uint64_t v6 = (unint64_t *)(v16 - 1);
    }
  }
  if (v5 != (uint64_t *)v6)
  {
    BOOL v21 = (Flyover *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    uint64_t v22 = v21;
    do
    {
      *(void *)uint64_t v22 = *v6;
      unint64_t v24 = *v6;
      unint64_t v25 = *v6 >> 39;
      uint64_t v26 = v4[4];
      if (v25 < (v4[5] - v26) >> 3
        && (uint64_t v27 = *(void *)(v26 + 8 * v25)) != 0
        && (unint64_t v28 = *(unsigned __int16 *)(v27 + 2 * (HIDWORD(v24) & 0x7F)),
            uint64_t v30 = v4[7],
            uint64_t v29 = v4[8],
            v28 < (v29 - v30) >> 3)
        && ((unint64_t v31 = HIDWORD(v24), v32 = v30 + 8 * v28, v32 != v29)
          ? (BOOL v33 = *(_DWORD *)(v32 + 4) == v31)
          : (BOOL v33 = 0),
            v33))
      {
        uint64_t v34 = (unsigned __int8 *)(v4[10] + v28);
      }
      else
      {
        uint64_t v34 = (unsigned __int8 *)v4[11];
      }
      unsigned int v35 = *v34;
      BOOL v36 = v35 >= 8;
      unsigned int v37 = v35 - 8;
      if (v36)
      {
        if (v37 >= 4) {
          goto LABEL_41;
        }
        Flyover::GetDataIDs(v21);
        uint64_t v38 = *(void **)(a1 + 8);
        uint64_t v39 = *(void *)v22;
        unint64_t v40 = &Flyover::GetDataIDs(void)::kDataIDs;
      }
      else
      {
        DaVinci::GetDataIDs(v21);
        uint64_t v38 = *(void **)(a1 + 8);
        uint64_t v39 = *(void *)v22;
        unint64_t v40 = &DaVinci::GetDataIDs(void)::kDataIDs;
      }
      uint64_t v50 = (uint64_t (**)(void **))&unk_1EF5220D0;
      *(void *)&long long v51 = v40;
      *((void *)&v51 + 1) = v39;
      unint64_t v52 = (void **)&v50;
      uint64_t v55 = &v53;
      uint64_t v53 = &unk_1EF5220D0;
      long long v54 = v51;
      int v56 = 0;
      ecs2::Runtime::queueCommand(v38, (uint64_t)&v53);
      if (v56 != -1) {
        ((void (*)(char *, void **))off_1EF58FF48[v56])(&v49, &v53);
      }
      int v56 = -1;
      BOOL v21 = (Flyover *)v52;
      if (v52 == (void **)&v50)
      {
        BOOL v21 = (Flyover *)v50[4]((void **)&v50);
      }
      else if (v52)
      {
        BOOL v21 = (Flyover *)(*((uint64_t (**)(void))*v52 + 5))();
      }
LABEL_41:
      uint64_t v41 = v4[4];
      uint64_t v42 = v4[7];
      unint64_t v23 = (uint64_t *)v4[8];
      uint64_t v43 = (uint64_t *)(v6 + 1);
      while (v43 != v23)
      {
        unint64_t v44 = *((unsigned int *)v43 + 1);
        uint64_t v45 = v4[8];
        if (v44 >> 7 < (v4[5] - v41) >> 3)
        {
          uint64_t v46 = *(void *)(v41 + 8 * (v44 >> 7));
          uint64_t v45 = v4[8];
          if (v46)
          {
            unint64_t v47 = *(unsigned __int16 *)(v46 + 2 * (v44 & 0x7F));
            uint64_t v45 = v4[8];
            if (((uint64_t)v23 - v42) >> 3 > v47)
            {
              uint64_t v45 = v42 + 8 * v47;
              if (*(_DWORD *)(v45 + 4) != v44) {
                uint64_t v45 = v4[8];
              }
            }
          }
        }
        ++v43;
        if ((uint64_t *)v45 != v23)
        {
          unint64_t v23 = v43 - 1;
          break;
        }
      }
      uint64_t v6 = (unint64_t *)v23;
    }
    while (v5 != v23);
  }
LABEL_51:
  uint64_t result = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  void *result = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::RequiredPipelinePoolID>(int8x8_t *a1)
{
  unint64_t v10 = 0xE54E641F7C1F9B89;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xE54E641F7C1F9B89;
    if (*(void *)&v1 <= 0xE54E641F7C1F9B89) {
      unint64_t v3 = 0xE54E641F7C1F9B89 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xE54E641F7C1F9B89;
  }
  int64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (__int16 v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xE54E641F7C1F9B89)
      {
        if (v5[2] == 0xE54E641F7C1F9B89) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      __int16 v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xE54E641F7C1F9B89) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    __int16 v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xE54E641F7C1F9B89) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1AC9CB4(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void *md::PuckRenderLayer::layout(md::PuckRenderLayer *this, const md::LayoutContext *a2)
{
  uint64_t v162 = *MEMORY[0x1E4F143B8];
  v158[0] = &unk_1EF571388;
  v158[1] = a2;
  v156[0] = &unk_1EF5713D0;
  v156[1] = a2;
  unint64_t v157 = v156;
  uint64_t v161 = v160;
  uint64_t v159 = v158;
  v160[0] = &unk_1EF5713D0;
  v160[1] = a2;
  std::__function::__func<md::PuckRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::PuckRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()((uint64_t)v158);
  if (v157 == v156)
  {
    (*(void (**)(void *))(v156[0] + 32))(v156);
  }
  else if (v157)
  {
    (*(void (**)(void *))(*v157 + 40))(v157);
  }
  if (v159 == v158)
  {
    (*(void (**)(void *))(v158[0] + 32))(v158);
  }
  else if (v159)
  {
    (*(void (**)(void *))(*v159 + 40))(v159);
  }
  int64_t v4 = *(void **)(*(void *)(*((void *)this + 5) + 24) + 8);
  uint64_t v5 = v4[3];
  uint64_t v6 = v4[4];
  uint64_t v7 = v6 - v5;
  if (v6 == v5) {
    goto LABEL_16;
  }
  uint64_t v8 = 0;
  unint64_t v9 = v7 >> 3;
  while (1)
  {
    unint64_t v10 = *(unsigned __int8 **)(v5 + 8 * v8);
    if (*v10 == *((unsigned __int8 *)this + 56))
    {
      unint64_t v11 = *((void *)v10 + 1);
      uint64_t v12 = v4[15];
      if (v11 < (v4[16] - v12) >> 3) {
        break;
      }
    }
    if (++v8 >= v9) {
      goto LABEL_16;
    }
  }
  uint64_t v13 = *(void *)(v12 + 8 * v11);
  if (!v13) {
LABEL_16:
  }
    uint64_t v14 = 0;
  else {
    uint64_t v14 = *(void *)(*(void *)(v13 + 24) + 8 * *((unsigned __int8 *)this + 57));
  }
  uint64_t v15 = *(void *)(v14 + 72);
  if (*(void *)(v14 + 80) != v15) {
    *(void *)(v14 + 80) = v15;
  }
  unint64_t v16 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v17 = (int8x8_t)v16[1];
  if (!*(void *)&v17) {
    goto LABEL_110;
  }
  uint8x8_t v18 = (uint8x8_t)vcnt_s8(v17);
  v18.i16[0] = vaddlv_u8(v18);
  if (v18.u32[0] > 1uLL)
  {
    unint64_t v19 = 0xA60DDA5A69582425;
    if (*(void *)&v17 <= 0xA60DDA5A69582425) {
      unint64_t v19 = 0xA60DDA5A69582425 % *(void *)&v17;
    }
  }
  else
  {
    unint64_t v19 = (*(void *)&v17 - 1) & 0xA60DDA5A69582425;
  }
  uint64_t v20 = *v16;
  BOOL v21 = *(void **)(*v16 + 8 * v19);
  if (!v21) {
    goto LABEL_110;
  }
  uint64_t v22 = (void *)*v21;
  if (!*v21) {
    goto LABEL_110;
  }
  uint64_t v23 = *(void *)&v17 - 1;
  if (v18.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v24 = v22[1];
      if (v24 == 0xA60DDA5A69582425)
      {
        if (v22[2] == 0xA60DDA5A69582425) {
          goto LABEL_40;
        }
      }
      else if ((v24 & v23) != v19)
      {
        goto LABEL_110;
      }
      uint64_t v22 = (void *)*v22;
      if (!v22) {
        goto LABEL_110;
      }
    }
  }
  while (1)
  {
    unint64_t v25 = v22[1];
    if (v25 == 0xA60DDA5A69582425) {
      break;
    }
    if (v25 >= *(void *)&v17) {
      v25 %= *(void *)&v17;
    }
    if (v25 != v19) {
      goto LABEL_110;
    }
LABEL_34:
    uint64_t v22 = (void *)*v22;
    if (!v22) {
      goto LABEL_110;
    }
  }
  if (v22[2] != 0xA60DDA5A69582425) {
    goto LABEL_34;
  }
LABEL_40:
  uint64_t v26 = v22[5];
  if (*(void *)(v26 + 8) != 0xA60DDA5A69582425) {
    goto LABEL_110;
  }
  uint64_t v27 = *(id **)(v26 + 32);
  if (!v27) {
    goto LABEL_110;
  }
  if (v18.u32[0] > 1uLL)
  {
    uint64_t v28 = 0x3070CB6B3C7F21D3;
    if (*(void *)&v17 <= 0x3070CB6B3C7F21D3uLL) {
      uint64_t v28 = 0x3070CB6B3C7F21D3uLL % *(void *)&v17;
    }
  }
  else
  {
    uint64_t v28 = v23 & 0x3070CB6B3C7F21D3;
  }
  uint64_t v29 = *(void **)(v20 + 8 * v28);
  if (!v29) {
    goto LABEL_110;
  }
  uint64_t v30 = (void *)*v29;
  if (!v30) {
    goto LABEL_110;
  }
  if (v18.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v31 = v30[1];
      if (v31 == 0x3070CB6B3C7F21D3)
      {
        if (v30[2] == 0x3070CB6B3C7F21D3) {
          goto LABEL_62;
        }
      }
      else if ((v31 & v23) != v28)
      {
        goto LABEL_110;
      }
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        goto LABEL_110;
      }
    }
  }
  while (2)
  {
    unint64_t v32 = v30[1];
    if (v32 != 0x3070CB6B3C7F21D3)
    {
      if (v32 >= *(void *)&v17) {
        v32 %= *(void *)&v17;
      }
      if (v32 != v28) {
        goto LABEL_110;
      }
      goto LABEL_56;
    }
    if (v30[2] != 0x3070CB6B3C7F21D3)
    {
LABEL_56:
      uint64_t v30 = (void *)*v30;
      if (!v30) {
        goto LABEL_110;
      }
      continue;
    }
    break;
  }
LABEL_62:
  uint64_t v33 = v30[5];
  if (*(void *)(v33 + 8) != 0x3070CB6B3C7F21D3) {
    goto LABEL_110;
  }
  uint64_t v34 = *(void *)(v33 + 32);
  if (!v34) {
    goto LABEL_110;
  }
  if (v18.u32[0] > 1uLL)
  {
    uint64_t v35 = 0x1AF456233693CD46;
    if (*(void *)&v17 <= 0x1AF456233693CD46uLL) {
      uint64_t v35 = 0x1AF456233693CD46uLL % *(void *)&v17;
    }
  }
  else
  {
    uint64_t v35 = v23 & 0x1AF456233693CD46;
  }
  BOOL v36 = *(void **)(v20 + 8 * v35);
  if (!v36) {
    goto LABEL_110;
  }
  unsigned int v37 = (void *)*v36;
  if (!v37) {
    goto LABEL_110;
  }
  if (v18.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v38 = v37[1];
      if (v38 == 0x1AF456233693CD46)
      {
        if (v37[2] == 0x1AF456233693CD46) {
          goto LABEL_84;
        }
      }
      else if ((v38 & v23) != v35)
      {
        goto LABEL_110;
      }
      unsigned int v37 = (void *)*v37;
      if (!v37) {
        goto LABEL_110;
      }
    }
  }
  while (2)
  {
    unint64_t v39 = v37[1];
    if (v39 != 0x1AF456233693CD46)
    {
      if (v39 >= *(void *)&v17) {
        v39 %= *(void *)&v17;
      }
      if (v39 != v35) {
        goto LABEL_110;
      }
      goto LABEL_78;
    }
    if (v37[2] != 0x1AF456233693CD46)
    {
LABEL_78:
      unsigned int v37 = (void *)*v37;
      if (!v37) {
        goto LABEL_110;
      }
      continue;
    }
    break;
  }
LABEL_84:
  uint64_t v40 = v37[5];
  if (*(void *)(v40 + 8) != 0x1AF456233693CD46) {
    goto LABEL_110;
  }
  uint64_t v41 = *(void *)(v40 + 32);
  if (!v41) {
    goto LABEL_110;
  }
  if (v18.u32[0] > 1uLL)
  {
    unint64_t v42 = 0x9AEE7E062376E454;
    if (*(void *)&v17 <= 0x9AEE7E062376E454) {
      unint64_t v42 = 0x9AEE7E062376E454 % *(void *)&v17;
    }
  }
  else
  {
    unint64_t v42 = v23 & 0x9AEE7E062376E454;
  }
  uint64_t v43 = *(void **)(v20 + 8 * v42);
  if (!v43) {
    goto LABEL_110;
  }
  unint64_t v44 = (void *)*v43;
  if (!v44) {
    goto LABEL_110;
  }
  if (v18.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v45 = v44[1];
      if (v45 == 0x9AEE7E062376E454)
      {
        if (v44[2] == 0x9AEE7E062376E454) {
          goto LABEL_106;
        }
      }
      else if ((v45 & v23) != v42)
      {
        goto LABEL_110;
      }
      unint64_t v44 = (void *)*v44;
      if (!v44) {
        goto LABEL_110;
      }
    }
  }
  while (2)
  {
    unint64_t v46 = v44[1];
    if (v46 != 0x9AEE7E062376E454)
    {
      if (v46 >= *(void *)&v17) {
        v46 %= *(void *)&v17;
      }
      if (v46 != v42) {
        goto LABEL_110;
      }
      goto LABEL_100;
    }
    if (v44[2] != 0x9AEE7E062376E454)
    {
LABEL_100:
      unint64_t v44 = (void *)*v44;
      if (!v44) {
        goto LABEL_110;
      }
      continue;
    }
    break;
  }
LABEL_106:
  uint64_t v47 = v44[5];
  if (*(void *)(v47 + 8) == 0x9AEE7E062376E454)
  {
    uint64_t v48 = *(unsigned __int8 **)(v47 + 32);
    if (v48)
    {
      if (v48[208] && !v48[209])
      {
        if (v18.u32[0] > 1uLL)
        {
          uint64_t v50 = 0x1B8B241A8D896A1DLL;
          if (*(void *)&v17 <= 0x1B8B241A8D896A1DuLL) {
            uint64_t v50 = 0x1B8B241A8D896A1DuLL % *(void *)&v17;
          }
        }
        else
        {
          uint64_t v50 = v23 & 0x1B8B241A8D896A1DLL;
        }
        long long v51 = *(void **)(v20 + 8 * v50);
        if (v51)
        {
          unint64_t v52 = (void *)*v51;
          if (v52)
          {
            if (v18.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v53 = v52[1];
                if (v53 == 0x1B8B241A8D896A1DLL)
                {
                  if (v52[2] == 0x1B8B241A8D896A1DLL) {
                    goto LABEL_137;
                  }
                }
                else if ((v53 & v23) != v50)
                {
                  goto LABEL_110;
                }
                unint64_t v52 = (void *)*v52;
                if (!v52) {
                  goto LABEL_110;
                }
              }
            }
            do
            {
              unint64_t v54 = v52[1];
              if (v54 == 0x1B8B241A8D896A1DLL)
              {
                if (v52[2] == 0x1B8B241A8D896A1DLL)
                {
LABEL_137:
                  uint64_t v55 = v52[5];
                  if (*(void *)(v55 + 8) == 0x1B8B241A8D896A1DLL)
                  {
                    uint64_t v56 = *(void *)(v55 + 32);
                    if (v56)
                    {
                      id v57 = *(id *)(v56 + 48);
                      if (v57)
                      {
                        uint64_t v58 = v57;
                        BOOL v59 = [*(id *)(v56 + 48) puck] == 0;

                        if (!v59)
                        {
                          uint64_t v60 = *((void *)this + 6);
                          id v61 = *v27;
                          id v62 = *(id *)(v56 + 48);
                          uint64_t v63 = [v62 puck];
                          id v64 = *(id *)(*((void *)this + 5) + 104);
                          [v64 contentScale];
                          *(float *)&double v65 = v65;
                          md::PuckRenderResources::update(v60, v61, v63, *v48, (uint64_t)(v48 + 56), *(float *)&v65);

                          float64x2_t v66 = *(float64x2_t *)(v48 + 232);
                          float64x2_t v148 = *(float64x2_t *)(v48 + 216);
                          float64x2_t v149 = v66;
                          float64x2_t v67 = *(float64x2_t *)(v48 + 248);
                          float64x2_t v68 = *(float64x2_t *)(v48 + 296);
                          float64x2_t v69 = *(float64x2_t *)(v48 + 264);
                          float64x2_t v152 = *(float64x2_t *)(v48 + 280);
                          float64x2_t v153 = v68;
                          float64x2_t v70 = *(float64x2_t *)(v48 + 296);
                          float64x2_t v71 = *(float64x2_t *)(v48 + 328);
                          float64x2_t v154 = *(float64x2_t *)(v48 + 312);
                          float64x2_t v155 = v71;
                          float64x2_t v72 = *(float64x2_t *)(v48 + 264);
                          float64x2_t v150 = v67;
                          float64x2_t v151 = v72;
                          float64x2_t v144 = v152;
                          float64x2_t v145 = v70;
                          float64x2_t v73 = *(float64x2_t *)(v48 + 328);
                          float64x2_t v146 = v154;
                          float64x2_t v147 = v73;
                          float32x4_t v74 = *(float32x4_t *)(v48 + 232);
                          float64x2_t v140 = *(float64x2_t *)(v48 + 216);
                          float64x2_t v141 = (float64x2_t)v74;
                          v74.i64[0] = *((void *)v48 + 11);
                          v74.i32[2] = *((_DWORD *)v48 + 24);
                          float64x2_t v142 = *(float64x2_t *)(v48 + 248);
                          float64x2_t v143 = v69;
                          float v118 = *((float *)v48 + 17);
                          float32x4_t v121 = v74;
                          int v75 = *((_DWORD *)v48 + 25);
                          uint64_t v76 = *(void *)(*((void *)this + 6) + 32);
                          gm::operator*<double,4,4,4>(v132.f64, (double *)(v41 + 808), v140.f64);
                          float64x2_t v140 = v132;
                          float64x2_t v141 = v133;
                          float64x2_t v142 = v134;
                          float64x2_t v143 = v135;
                          float64x2_t v144 = v136;
                          float64x2_t v145 = v137;
                          float64x2_t v146 = v138;
                          float64x2_t v147 = v139;
                          float v128 = *((float *)v48 + 16);
                          float32x4_t v124 = *(float32x4_t *)(v48 + 72);
                          ggl::ConstantDataTyped<ggl::Textured::Style>::write((uint64_t *)&v132, *(void *)(*(void *)(v76 + 64) + 48));
                          **(_OWORD **)&v134.f64[1] = vmulq_n_f32(v124, v128);
                          ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v132);
                          float64x2_t v103 = v140;
                          float64x2_t v105 = v142;
                          float64x2_t v107 = v144;
                          float64x2_t v109 = v141;
                          float64x2_t v125 = v145;
                          float64x2_t v129 = v147;
                          float64x2_t v111 = v146;
                          float64x2_t v114 = v143;
                          ggl::ConstantDataTyped<ggl::Textured::Style>::write((uint64_t *)&v132, **(void **)(v76 + 64));
                          float32x4_t v77 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v103), v109);
                          float64_t v78 = v134.f64[1];
                          float32x4_t v104 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v105), v114);
                          float32x4_t v106 = v77;
                          **(_OWORD **)&v134.f64[1] = v77;
                          *(float32x4_t *)(*(void *)&v78 + 16) = v104;
                          float32x4_t v101 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v111), v129);
                          float32x4_t v102 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v107), v125);
                          *(float32x4_t *)(*(void *)&v78 + 32) = v102;
                          *(float32x4_t *)(*(void *)&v78 + 48) = v101;
                          ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v132);
                          ggl::DaVinci::GroundDepthPipelineSetup::setElevationsDeviceData(*(void *)(v76 + 64), *(void *)(v76 + 160), *(void *)(*((void *)this + 6) + 240));
                          uint64_t v79 = *(void *)(*((void *)this + 6) + 48);
                          gm::operator*<double,4,4,4>(v132.f64, (double *)(v41 + 808), v148.f64);
                          float64x2_t v148 = v132;
                          float64x2_t v149 = v133;
                          float64x2_t v150 = v134;
                          float64x2_t v151 = v135;
                          float64x2_t v152 = v136;
                          float64x2_t v153 = v137;
                          float64x2_t v154 = v138;
                          float64x2_t v155 = v139;
                          ggl::ConstantDataTyped<ggl::Textured::Style>::write((uint64_t *)&v132, *(void *)(*(void *)(v79 + 64) + 16));
                          float32x4_t v80 = vmulq_n_f32(v121, v118);
                          float64_t v81 = v134.f64[1];
                          *(_DWORD *)(*(void *)&v134.f64[1] + 8) = v80.i32[2];
                          **(void **)&float64_t v81 = v80.i64[0];
                          *(_DWORD *)(*(void *)&v81 + 12) = v75;
                          ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v132);
                          float64x2_t v108 = v148;
                          float64x2_t v110 = v150;
                          float64x2_t v122 = v151;
                          float64x2_t v126 = v153;
                          float64x2_t v112 = v152;
                          float64x2_t v115 = v149;
                          float64x2_t v130 = v155;
                          float64x2_t v119 = v154;
                          ggl::ConstantDataTyped<ggl::Textured::Style>::write((uint64_t *)&v132, **(void **)(v79 + 64));
                          float32x4_t v82 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v112), v126);
                          float64_t v83 = v134.f64[1];
                          float32x4_t v123 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v110), v122);
                          float32x4_t v127 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v108), v115);
                          **(_OWORD **)&v134.f64[1] = v127;
                          *(float32x4_t *)(*(void *)&v83 + 16) = v123;
                          float32x4_t v84 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v119), v130);
                          float32x4_t v131 = v82;
                          *(float32x4_t *)(*(void *)&v83 + 32) = v82;
                          *(float32x4_t *)(*(void *)&v83 + 48) = v84;
                          float32x4_t v120 = v84;
                          ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v132);
                          uint64_t v85 = *((void *)this + 6);
                          uint64_t v86 = *(void *)(v85 + 144);
                          uint64_t v87 = 16;
                          if (*(unsigned __int8 *)(v34 + 320) - 1 < 3) {
                            uint64_t v87 = 32;
                          }
                          uint64_t v88 = *(void *)(v85 + 160);
                          uint64_t v89 = *(void *)(v34 + v87);
                          *(void *)(v88 + 64) = v89;
                          *(void *)(v86 + 64) = v89;
                          ggl::CommandBuffer::pushRenderItem(v14, v88);
                          ggl::CommandBuffer::pushRenderItem(v14, v86);
                          if (!v48[129])
                          {
                            uint64_t v90 = *(void *)(*((void *)this + 6) + 64);
                            float v116 = *((float *)v48 + 35);
                            float32x4_t v113 = *(float32x4_t *)(v48 + 148);
                            ggl::ConstantDataTyped<ggl::Textured::Style>::write((uint64_t *)&v132, *(void *)(*(void *)(v90 + 64) + 48));
                            **(_OWORD **)&v134.f64[1] = vmulq_n_f32(v113, v116);
                            ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v132);
                            ggl::ConstantDataTyped<ggl::Textured::Style>::write((uint64_t *)&v132, **(void **)(v90 + 64));
                            float64_t v91 = v134.f64[1];
                            **(_OWORD **)&v134.f64[1] = v106;
                            *(float32x4_t *)(*(void *)&v91 + 16) = v104;
                            *(float32x4_t *)(*(void *)&v91 + 32) = v102;
                            *(float32x4_t *)(*(void *)&v91 + 48) = v101;
                            ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v132);
                            ggl::DaVinci::GroundDepthPipelineSetup::setElevationsDeviceData(*(void *)(v90 + 64), *(void *)(v90 + 160), *(void *)(*((void *)this + 6) + 240));
                            v92.i64[0] = *(void *)(v48 + 164);
                            v92.i32[2] = *((_DWORD *)v48 + 43);
                            float32x4_t v117 = v92;
                            v113.i32[0] = *((_DWORD *)v48 + 36);
                            int v93 = *((_DWORD *)v48 + 44);
                            uint64_t v94 = *(void *)(*((void *)this + 6) + 80);
                            ggl::ConstantDataTyped<ggl::Textured::Style>::write((uint64_t *)&v132, *(void *)(*(void *)(v94 + 64) + 16));
                            float32x4_t v95 = vmulq_n_f32(v117, v113.f32[0]);
                            float64_t v96 = v134.f64[1];
                            *(_DWORD *)(*(void *)&v134.f64[1] + 8) = v95.i32[2];
                            **(void **)&float64_t v96 = v95.i64[0];
                            *(_DWORD *)(*(void *)&v96 + 12) = v93;
                            ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v132);
                            ggl::ConstantDataTyped<ggl::Textured::Style>::write((uint64_t *)&v132, **(void **)(v94 + 64));
                            float64_t v97 = v134.f64[1];
                            **(_OWORD **)&v134.f64[1] = v127;
                            *(float32x4_t *)(*(void *)&v97 + 16) = v123;
                            *(float32x4_t *)(*(void *)&v97 + 32) = v131;
                            *(float32x4_t *)(*(void *)&v97 + 48) = v120;
                            ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&v132);
                            uint64_t v98 = *((void *)this + 6);
                            uint64_t v99 = *(void *)(v98 + 192);
                            uint64_t v100 = *(void *)(v98 + 176);
                            *(void *)(v99 + 64) = v89;
                            *(void *)(v100 + 64) = v89;
                            ggl::CommandBuffer::pushRenderItem(v14, v99);
                            ggl::CommandBuffer::pushRenderItem(v14, v100);
                          }
                        }
                      }
                    }
                  }
                  break;
                }
              }
              else
              {
                if (v54 >= *(void *)&v17) {
                  v54 %= *(void *)&v17;
                }
                if (v54 != v50) {
                  break;
                }
              }
              unint64_t v52 = (void *)*v52;
            }
            while (v52);
          }
        }
      }
    }
  }
LABEL_110:
  if (!v161)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    __break(1u);
  }
  (*(void (**)(void *))(*v161 + 48))(v161);
  uint64_t result = v161;
  if (v161 == v160) {
    return (void *)(*(uint64_t (**)(void *))(v160[0] + 32))(v160);
  }
  if (v161) {
    return (void *)(*(uint64_t (**)(void))(*v161 + 40))();
  }
  return result;
}

void sub_1A1ACA90C(_Unwind_Exception *a1)
{
  geo::ScopedFunctions::~ScopedFunctions((geo::ScopedFunctions *)(v1 - 144));
  _Unwind_Resume(a1);
}

void sub_1A1ACA958()
{
  JUMPOUT(0x1A1ACA960);
}

void sub_1A1ACA96C(_Unwind_Exception *exception_object)
{
}

void sub_1A1ACA978(_Unwind_Exception *a1)
{
  uint64_t v4 = *(void *)(v2 - 120);
  if (v4 == v1)
  {
    (*(void (**)(uint64_t))(*(void *)(v2 - 144) + 32))(v2 - 144);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  std::function<void ()(void)>::~function((void *)(v2 - 208));
  std::function<void ()(void)>::~function((void *)(v2 - 176));
  _Unwind_Resume(a1);
}

void sub_1A1ACA9F8(_Unwind_Exception *exception_object)
{
  uint64_t v3 = *(void *)(v1 - 120);
  if (v3 == v1 - 144)
  {
    (*(void (**)(uint64_t))(*(void *)(v1 - 144) + 32))(v1 - 144);
    _Unwind_Resume(exception_object);
  }
  if (!v3) {
    _Unwind_Resume(exception_object);
  }
  (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  _Unwind_Resume(exception_object);
}

void std::__function::__func<md::PuckRenderLayer::layout(md::LayoutContext const&)::$_1,std::allocator<md::PuckRenderLayer::layout(md::LayoutContext const&)::$_1>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_END, v4, "PuckLayout", "", v5, 2u);
  }
}

void std::__function::__func<md::PuckRenderLayer::layout(md::LayoutContext const&)::$_0,std::allocator<md::PuckRenderLayer::layout(md::LayoutContext const&)::$_0>,void ()(void)>::operator()(uint64_t a1)
{
  if (GEOGetVectorKitPerformanceLog_onceToken != -1) {
    dispatch_once(&GEOGetVectorKitPerformanceLog_onceToken, &__block_literal_global_17);
  }
  uint64_t v2 = (id)GEOGetVectorKitPerformanceLog_log;
  uint64_t v3 = v2;
  os_signpost_id_t v4 = *(void *)(*(void *)(a1 + 8) + 80);
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)uint64_t v5 = 0;
    _os_signpost_emit_with_name_impl(&dword_1A1780000, v3, OS_SIGNPOST_INTERVAL_BEGIN, v4, "PuckLayout", "", v5, 2u);
  }
}

void md::ClientDrapedPolygonRenderLayer::ClientDrapedPolygonRenderLayer(uint64_t a1, int a2, uint64_t a3, const ggl::StandardLibrary *a4, uint64_t a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a2 == 58)
  {
    uint64_t v13 = *(void *)(a5 + 8);
    int v11 = *(unsigned __int16 *)(v13 + 96);
    uint64_t v12 = (unsigned __int16 *)(v13 + 144);
  }
  else
  {
    if (a2 != 57)
    {
      uint64_t v15 = 0;
      unint64_t v16 = 0;
LABEL_7:
      int8x8_t v17 = operator new(2uLL);
      *int8x8_t v17 = a2;
      *(void *)a1 = &unk_1EF530C60;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
      int64_t v18 = v16 - v15;
      if (v18)
      {
        if (v18 < 0) {
          abort();
        }
        unint64_t v19 = (char *)operator new(v18);
        *(void *)(a1 + 8) = v19;
        uint64_t v20 = &v19[2 * (v18 >> 1)];
        *(void *)(a1 + 24) = v20;
        memcpy(v19, v15, v18);
        *(void *)(a1 + 16) = v20;
      }
      *(void *)&long long v21 = v17;
      *((void *)&v21 + 1) = v17 + 1;
      *(_WORD *)(a1 + 32) = 0;
      *(unsigned char *)(a1 + 34) = 49;
      *(void *)(a1 + 40) = a3;
      *(_WORD *)(a1 + 48) = 0;
      *(_DWORD *)(a1 + 52) = 0;
      *(_OWORD *)(a1 + 80) = 0u;
      *(_OWORD *)(a1 + 96) = 0u;
      *(void *)(a1 + 112) = 0;
      *(_DWORD *)(a1 + 120) = 1065353216;
      *(void *)(a1 + 136) = 0;
      *(void *)(a1 + 160) = 0;
      *(void *)(a1 + 128) = a1 + 136;
      *(void *)(a1 + 144) = 0;
      *(void *)(a1 + 152) = a1 + 160;
      *(void *)(a1 + 184) = 0;
      *(void *)(a1 + 168) = 0;
      *(void *)(a1 + 176) = a1 + 184;
      *(void *)(a1 + 216) = 0;
      *(void *)(a1 + 208) = 0;
      *(void *)(a1 + 192) = 0;
      *(void *)(a1 + 200) = a1 + 208;
      *(void *)(a1 + 240) = 0;
      *(void *)(a1 + 232) = 0;
      *(void *)(a1 + 224) = a1 + 232;
      *(_OWORD *)(a1 + 248) = xmmword_1A28FE5C0;
      *(void *)(a1 + 312) = 0;
      *(_OWORD *)(a1 + 264) = 0u;
      *(_OWORD *)(a1 + 280) = 0u;
      *(_OWORD *)(a1 + 296) = 0u;
      *(_OWORD *)(a1 + 320) = v21;
      *(void *)(a1 + 336) = v17 + 1;
      *(_DWORD *)(a1 + 344) = 2;
      *(void *)a1 = &unk_1EF541FB0;
      *(void *)(a1 + 352) = a1 + 360;
      *(void *)(a1 + 360) = 0;
      *(void *)(a1 + 384) = 0;
      *(void *)(a1 + 392) = 0;
      *(void *)(a1 + 368) = 0;
      *(void *)(a1 + 376) = a1 + 384;
      *(void *)(a1 + 400) = a1 + 408;
      *(void *)(a1 + 408) = 0;
      *(void *)(a1 + 432) = 0;
      *(void *)(a1 + 440) = 0;
      *(void *)(a1 + 416) = 0;
      *(void *)(a1 + 424) = a1 + 432;
      *(_WORD *)(a1 + 448) = a2;
      *(_WORD *)(a1 + 450) = 33;
      if (v15) {
        operator delete(v15);
      }
      *(void *)a1 = &unk_1EF54C0B8;
      uint64_t v22 = (uint64_t **)(a1 + 456);
      if (a2 == 58)
      {
        uint64_t v24 = *(void *)(a5 + 8);
        int v27 = 0;
        __int16 v28 = *(_WORD *)(v24 + 96);
        int v29 = 1;
        __int16 v30 = *(_WORD *)(v24 + 144);
        std::map<md::DrapedPolygonPlacement,md::CommandBufferLocation>::map[abi:nn180100](v22, &v27, 2);
      }
      else if (a2 == 57)
      {
        uint64_t v23 = *(void *)(a5 + 8);
        int v27 = 0;
        __int16 v28 = *(_WORD *)(v23 + 94);
        int v29 = 1;
        __int16 v30 = *(_WORD *)(v23 + 142);
        std::map<md::DrapedPolygonPlacement,md::CommandBufferLocation>::map[abi:nn180100](v22, &v27, 2);
      }
      else
      {
        *(void *)(a1 + 464) = 0;
        *(void *)(a1 + 472) = 0;
        *(void *)(a1 + 456) = a1 + 464;
      }
      unint64_t v25 = (const RenderTargetFormat *)[*(id *)(a3 + 104) format];
      uint64_t v26 = operator new(0x348uLL);
      v26[1] = 0;
      v26[2] = 0;
      *uint64_t v26 = &unk_1EF582588;
      md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources((md::ElevatedPolygonRenderResources *)(v26 + 3), a4, v25);
    }
    uint64_t v10 = *(void *)(a5 + 8);
    int v11 = *(unsigned __int16 *)(v10 + 94);
    uint64_t v12 = (unsigned __int16 *)(v10 + 142);
  }
  int v14 = *v12;
  uint64_t v15 = (char *)operator new(4uLL);
  *(_DWORD *)uint64_t v15 = v11 | (v14 << 16);
  unint64_t v16 = v15 + 4;
  goto LABEL_7;
}

void sub_1A1ACAF2C(_Unwind_Exception *a1)
{
  *(void *)uint64_t v1 = v2;
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v1 + 432));
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v1 + 408));
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v1 + 384));
  std::__tree<gdc::LayerDataWithWorld>::destroy(*(void **)(v1 + 360));
  md::CartographicTiledRenderLayer<md::ElevatedPolygonRenderable>::~CartographicTiledRenderLayer(v1);
  _Unwind_Resume(a1);
}

void md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(md::ElevatedPolygonRenderResources *this, const ggl::StandardLibrary *a2, const RenderTargetFormat *a3)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  *((unsigned char *)this + 80) = 0;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 4) = 0u;
  uint64_t v6 = (char *)this + 324;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_OWORD *)this = 0u;
  *(_OWORD *)((char *)this + 84) = xmmword_1A28FC970;
  *(void *)((char *)this + 100) = 0;
  *(_OWORD *)((char *)this + 108) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  uint64_t v7 = (char *)this + 136;
  *((void *)this + 16) = (char *)this + 136;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *((unsigned char *)this + 200) = 0;
  *(_OWORD *)((char *)this + 204) = xmmword_1A28FC970;
  *(_OWORD *)((char *)this + 220) = 0u;
  *(void *)((char *)this + 236) = 0;
  uint64_t v58 = (char *)this + 256;
  *((void *)this + 31) = (char *)this + 256;
  *((_OWORD *)this + 16) = 0u;
  *((_OWORD *)this + 17) = 0u;
  *((_OWORD *)this + 18) = 0u;
  *((_OWORD *)this + 19) = 0u;
  *((unsigned char *)this + 320) = 0;
  *(_OWORD *)((char *)this + 324) = xmmword_1A28FC970;
  *(void *)((char *)this + 356) = 0;
  *(_OWORD *)((char *)this + 340) = 0u;
  *(_OWORD *)((char *)this + 376) = 0u;
  uint64_t v8 = (char *)this + 376;
  *((void *)this + 46) = (char *)this + 376;
  *(_OWORD *)((char *)this + 392) = 0u;
  BOOL v59 = (_OWORD *)((char *)this + 392);
  *(_OWORD *)((char *)this + 408) = 0u;
  *(_OWORD *)((char *)this + 424) = 0u;
  *((unsigned char *)this + 440) = 0;
  *(_OWORD *)((char *)this + 444) = xmmword_1A28FC970;
  *(void *)((char *)this + 476) = 0;
  *(_OWORD *)((char *)this + 460) = 0u;
  *((_OWORD *)this + 31) = 0u;
  uint64_t v60 = (char *)this + 496;
  *((void *)this + 61) = (char *)this + 496;
  *(_OWORD *)((char *)this + 520) = 0u;
  *((_DWORD *)this + 136) = 0;
  *((void *)this + 67) = 0;
  *((void *)this + 64) = &unk_1EF55A890;
  *(void *)((char *)this + 548) = 66304;
  *((_DWORD *)this + 139) = 0;
  *((void *)this + 70) = 0xFF7F0200000700;
  *((_WORD *)this + 284) = 0;
  *((unsigned char *)this + 570) = 3;
  *((unsigned char *)this + 587) = 0;
  *(_OWORD *)((char *)this + 571) = 0u;
  *(_OWORD *)((char *)this + 636) = 0u;
  *((_WORD *)this + 350) = 257;
  *((unsigned char *)this + 720) = 0;
  *((_OWORD *)this + 44) = 0u;
  *(_OWORD *)((char *)this + 728) = 0u;
  *((void *)this + 93) = 32;
  unint64_t v9 = malloc_type_malloc(0xF10uLL, 0xB644C221uLL);
  *unint64_t v9 = 0;
  v9[1] = 0;
  *((void *)this + 91) = v9;
  *((void *)this + 92) = v9;
  *((void *)this + 94) = 0;
  *((void *)this + 96) = 0;
  *((void *)this + 95) = 0;
  {
    operator new();
  }
  *((void *)this + 97) = mdm::Allocator::instance(void)::alloc;
  *((void *)this + 100) = 0;
  *((void *)this + 99) = 0;
  *((void *)this + 98) = (char *)this + 792;
  *((_WORD *)this + 404) = 2048;
  id v61 = a2;
  uint64_t v10 = *((void *)a2 + 10);
  unint64_t v11 = *(void *)(v10 + 632);
  uint64_t v12 = *(std::__shared_weak_count **)(v10 + 640);
  if (v12) {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v13 = *(_OWORD *)&a3->colorFormatsCount;
  long long v65 = *(_OWORD *)a3->colorFormats;
  long long v66 = v13;
  long long v64 = 0uLL;
  v67[0] = 1;
  *(_OWORD *)&v67[4] = xmmword_1A28FCEE0;
  *(_DWORD *)&v67[20] = 7;
  memset(&v67[24], 0, 20);
  char v68 = 15;
  float64x2_t v70 = 0;
  uint64_t v71 = 0;
  float64x2_t v69 = &v70;
  if (v12)
  {
    atomic_fetch_add_explicit(&v12->__shared_owners_, 1uLL, memory_order_relaxed);
    int v14 = (std::__shared_weak_count *)*((void *)&v64 + 1);
    *(void *)&long long v64 = v11;
    *((void *)&v64 + 1) = v12;
    if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
      std::__shared_weak_count::__release_weak(v14);
    }
  }
  else
  {
    long long v64 = v11;
  }
  id v62 = 0;
  uint64_t v63 = 0;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v70);
  uint64_t v15 = v62;
  float64x2_t v69 = &v62;
  float64x2_t v70 = v62;
  uint64_t v71 = v63;
  if (v63)
  {
    v62[2] = &v70;
    id v62 = 0;
    uint64_t v63 = 0;
    uint64_t v15 = 0;
  }
  else
  {
    float64x2_t v69 = &v70;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v15);
  long long v16 = v64;
  long long v64 = 0uLL;
  int8x8_t v17 = (std::__shared_weak_count *)*((void *)this + 5);
  *((_OWORD *)this + 2) = v16;
  if (v17 && !atomic_fetch_add(&v17->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  long long v18 = v66;
  *((_OWORD *)this + 3) = v65;
  *((_OWORD *)this + 4) = v18;
  *((_OWORD *)this + 5) = *(_OWORD *)v67;
  *(_OWORD *)((char *)this + 92) = *(_OWORD *)&v67[12];
  *(_OWORD *)((char *)this + 108) = *(_OWORD *)&v67[28];
  *((unsigned char *)this + 124) = v68;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 17));
  unint64_t v19 = v70;
  *((void *)this + 16) = v69;
  *((void *)this + 17) = v19;
  uint64_t v20 = v71;
  *((void *)this + 18) = v71;
  if (v20)
  {
    v19[2] = v7;
    unint64_t v19 = 0;
    float64x2_t v69 = &v70;
    float64x2_t v70 = 0;
    uint64_t v71 = 0;
  }
  else
  {
    *((void *)this + 16) = v7;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v19);
  long long v21 = (std::__shared_weak_count *)*((void *)&v64 + 1);
  if (*((void *)&v64 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v64 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v21->__on_zero_shared)(v21);
    std::__shared_weak_count::__release_weak(v21);
  }
  if (v12 && !atomic_fetch_add(&v12->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v12->__on_zero_shared)(v12);
    std::__shared_weak_count::__release_weak(v12);
  }
  uint64_t v22 = *((void *)v61 + 10);
  unint64_t v23 = *(void *)(v22 + 656);
  uint64_t v24 = *(std::__shared_weak_count **)(v22 + 664);
  if (v24) {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v25 = *(_OWORD *)&a3->colorFormatsCount;
  long long v65 = *(_OWORD *)a3->colorFormats;
  long long v66 = v25;
  long long v64 = 0uLL;
  v67[0] = 1;
  *(_OWORD *)&v67[4] = xmmword_1A28FCEE0;
  *(_DWORD *)&v67[20] = 7;
  memset(&v67[24], 0, 20);
  char v68 = 15;
  float64x2_t v70 = 0;
  uint64_t v71 = 0;
  float64x2_t v69 = &v70;
  if (v24)
  {
    atomic_fetch_add_explicit(&v24->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v26 = (std::__shared_weak_count *)*((void *)&v64 + 1);
    *(void *)&long long v64 = v23;
    *((void *)&v64 + 1) = v24;
    if (v26 && !atomic_fetch_add(&v26->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v26->__on_zero_shared)(v26);
      std::__shared_weak_count::__release_weak(v26);
    }
  }
  else
  {
    long long v64 = v23;
  }
  id v62 = 0;
  uint64_t v63 = 0;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v70);
  int v27 = v62;
  float64x2_t v69 = &v62;
  float64x2_t v70 = v62;
  uint64_t v71 = v63;
  if (v63)
  {
    v62[2] = &v70;
    id v62 = 0;
    uint64_t v63 = 0;
    int v27 = 0;
  }
  else
  {
    float64x2_t v69 = &v70;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v27);
  long long v28 = v64;
  long long v64 = 0uLL;
  int v29 = (std::__shared_weak_count *)*((void *)this + 20);
  *(_OWORD *)((char *)this + 152) = v28;
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
  }
  long long v30 = v66;
  *(_OWORD *)((char *)this + 168) = v65;
  *(_OWORD *)((char *)this + 184) = v30;
  *(_OWORD *)((char *)this + 200) = *(_OWORD *)v67;
  *(_OWORD *)((char *)this + 212) = *(_OWORD *)&v67[12];
  *(_OWORD *)((char *)this + 228) = *(_OWORD *)&v67[28];
  *((unsigned char *)this + 244) = v68;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 32));
  uint64_t v31 = v70;
  *((void *)this + 31) = v69;
  *((void *)this + 32) = v31;
  uint64_t v32 = v71;
  *((void *)this + 33) = v71;
  if (v32)
  {
    v31[2] = v58;
    uint64_t v31 = 0;
    float64x2_t v69 = &v70;
    float64x2_t v70 = 0;
    uint64_t v71 = 0;
  }
  else
  {
    *((void *)this + 31) = v58;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v31);
  uint64_t v33 = (std::__shared_weak_count *)*((void *)&v64 + 1);
  if (*((void *)&v64 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v64 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v33->__on_zero_shared)(v33);
    std::__shared_weak_count::__release_weak(v33);
  }
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  uint64_t v34 = *((void *)v61 + 10);
  unint64_t v35 = *(void *)(v34 + 608);
  BOOL v36 = *(std::__shared_weak_count **)(v34 + 616);
  if (v36) {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v37 = *(_OWORD *)&a3->colorFormatsCount;
  long long v65 = *(_OWORD *)a3->colorFormats;
  long long v66 = v37;
  long long v64 = 0uLL;
  v67[0] = 1;
  *(_OWORD *)&v67[4] = xmmword_1A28FCEE0;
  *(_DWORD *)&v67[20] = 7;
  memset(&v67[24], 0, 20);
  char v68 = 15;
  float64x2_t v70 = 0;
  uint64_t v71 = 0;
  float64x2_t v69 = &v70;
  if (v36)
  {
    atomic_fetch_add_explicit(&v36->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v38 = (std::__shared_weak_count *)*((void *)&v64 + 1);
    *(void *)&long long v64 = v35;
    *((void *)&v64 + 1) = v36;
    if (v38 && !atomic_fetch_add(&v38->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v38->__on_zero_shared)(v38);
      std::__shared_weak_count::__release_weak(v38);
    }
  }
  else
  {
    long long v64 = v35;
  }
  id v62 = 0;
  uint64_t v63 = 0;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v70);
  unint64_t v39 = v62;
  float64x2_t v69 = &v62;
  float64x2_t v70 = v62;
  uint64_t v71 = v63;
  if (v63)
  {
    v62[2] = &v70;
    id v62 = 0;
    uint64_t v63 = 0;
    unint64_t v39 = 0;
  }
  else
  {
    float64x2_t v69 = &v70;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v39);
  long long v40 = v64;
  long long v64 = 0uLL;
  uint64_t v41 = (std::__shared_weak_count *)*((void *)this + 35);
  *((_OWORD *)this + 17) = v40;
  if (v41 && !atomic_fetch_add(&v41->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v41->__on_zero_shared)(v41);
    std::__shared_weak_count::__release_weak(v41);
  }
  long long v42 = v66;
  *((_OWORD *)this + 18) = v65;
  *((_OWORD *)this + 19) = v42;
  *((_OWORD *)this + 20) = *(_OWORD *)v67;
  *(_OWORD *)((char *)this + 332) = *(_OWORD *)&v67[12];
  *(_OWORD *)(v6 + 24) = *(_OWORD *)&v67[28];
  *((unsigned char *)this + 364) = v68;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 47));
  uint64_t v43 = v70;
  *((void *)this + 46) = v69;
  *((void *)this + 47) = v43;
  uint64_t v44 = v71;
  *((void *)this + 48) = v71;
  if (v44)
  {
    v43[2] = v8;
    uint64_t v43 = 0;
    float64x2_t v69 = &v70;
    float64x2_t v70 = 0;
    uint64_t v71 = 0;
  }
  else
  {
    *((void *)this + 46) = v8;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v43);
  uint64_t v45 = (std::__shared_weak_count *)*((void *)&v64 + 1);
  if (*((void *)&v64 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v64 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v45->__on_zero_shared)(v45);
    std::__shared_weak_count::__release_weak(v45);
  }
  if (v36 && !atomic_fetch_add(&v36->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v36->__on_zero_shared)(v36);
    std::__shared_weak_count::__release_weak(v36);
  }
  uint64_t v46 = *((void *)v61 + 10);
  unint64_t v47 = *(void *)(v46 + 584);
  uint64_t v48 = *(std::__shared_weak_count **)(v46 + 592);
  if (v48) {
    atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
  }
  long long v49 = *(_OWORD *)&a3->colorFormatsCount;
  long long v65 = *(_OWORD *)a3->colorFormats;
  long long v66 = v49;
  long long v64 = 0uLL;
  v67[0] = 1;
  *(_OWORD *)&v67[4] = xmmword_1A28FCEE0;
  *(_DWORD *)&v67[20] = 7;
  memset(&v67[24], 0, 20);
  char v68 = 15;
  float64x2_t v70 = 0;
  uint64_t v71 = 0;
  float64x2_t v69 = &v70;
  if (v48)
  {
    atomic_fetch_add_explicit(&v48->__shared_owners_, 1uLL, memory_order_relaxed);
    uint64_t v50 = (std::__shared_weak_count *)*((void *)&v64 + 1);
    *(void *)&long long v64 = v47;
    *((void *)&v64 + 1) = v48;
    if (v50 && !atomic_fetch_add(&v50->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v50->__on_zero_shared)(v50);
      std::__shared_weak_count::__release_weak(v50);
    }
  }
  else
  {
    long long v64 = v47;
  }
  id v62 = 0;
  uint64_t v63 = 0;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v70);
  long long v51 = v62;
  float64x2_t v69 = &v62;
  float64x2_t v70 = v62;
  uint64_t v71 = v63;
  if (v63)
  {
    v62[2] = &v70;
    id v62 = 0;
    uint64_t v63 = 0;
    long long v51 = 0;
  }
  else
  {
    float64x2_t v69 = &v70;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v51);
  long long v52 = v64;
  long long v64 = 0uLL;
  uint64_t v53 = (std::__shared_weak_count *)*((void *)this + 50);
  *BOOL v59 = v52;
  if (v53 && !atomic_fetch_add(&v53->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v53->__on_zero_shared)(v53);
    std::__shared_weak_count::__release_weak(v53);
  }
  long long v54 = v66;
  *(_OWORD *)((char *)this + 408) = v65;
  *(_OWORD *)((char *)this + 424) = v54;
  *(_OWORD *)((char *)this + 440) = *(_OWORD *)v67;
  *(_OWORD *)((char *)this + 452) = *(_OWORD *)&v67[12];
  *((_OWORD *)v6 + 9) = *(_OWORD *)&v67[28];
  *((unsigned char *)this + 484) = v68;
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*((void **)this + 62));
  uint64_t v55 = v70;
  *((void *)this + 61) = v69;
  *((void *)this + 62) = v55;
  uint64_t v56 = v71;
  *((void *)this + 63) = v71;
  if (v56)
  {
    v55[2] = v60;
    uint64_t v55 = 0;
    float64x2_t v69 = &v70;
    float64x2_t v70 = 0;
    uint64_t v71 = 0;
  }
  else
  {
    *((void *)this + 61) = v60;
  }
  std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(v55);
  id v57 = (std::__shared_weak_count *)*((void *)&v64 + 1);
  if (*((void *)&v64 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v64 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v57->__on_zero_shared)(v57);
    std::__shared_weak_count::__release_weak(v57);
  }
  if (v48)
  {
    if (!atomic_fetch_add(&v48->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v48->__on_zero_shared)(v48);
      std::__shared_weak_count::__release_weak(v48);
    }
  }
  operator new();
}

void std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(void *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(*a1);
    std::__tree<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::__map_value_compare<unsigned long long,std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>,std::less<unsigned long long>,true>,std::allocator<std::__value_type<unsigned long long,std::shared_ptr<ggl::SinglePassRouteLine::BasePipelineState>>>>::destroy(a1[1]);
    uint64_t v2 = (std::__shared_weak_count *)a1[6];
    if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
    operator delete(a1);
  }
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_7DaVinci44ElevatedStrokeColorWithDistancePipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C480;
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_7DaVinci42ElevatedFillColorWithDistancePipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C438;
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_7DaVinci32ElevatedStrokeColorPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C3F0;
}

void _ZNKSt3__110__function6__funcIZN3ggl14FragmentedPoolINS2_7DaVinci30ElevatedFillColorPipelineSetupEEC1ENS_8functionIFPS5_vEEENS7_IFvS8_EEEmmEd1_UlS8_E_NS_9allocatorISD_EESB_E7__cloneEPNS0_6__baseISB_EE(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF57C3A8;
}

void std::__function::__func<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_3,std::allocator<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_3>,ggl::DaVinci::ElevatedFillColorWithDistancePipelineSetup * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF5783C0;
}

void std::__function::__func<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_2,std::allocator<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_2>,ggl::DaVinci::ElevatedFillColorPipelineSetup * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF578378;
}

void std::__function::__func<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_1,std::allocator<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_1>,ggl::DaVinci::ElevatedStrokeColorWithDistancePipelineSetup * ()(void)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EF578330;
}

uint64_t std::__function::__func<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_0,std::allocator<md::ElevatedPolygonRenderResources::ElevatedPolygonRenderResources(ggl::StandardLibrary const&,ggl::RenderTargetFormat const&)::$_0>,ggl::DaVinci::ElevatedStrokeColorPipelineSetup * ()(void)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EF5782E8;
  a2[1] = v2;
  return result;
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::AssignShadowTextureIndex>,std::allocator<ecs2::ForwardToExecute<md::ita::AssignShadowTextureIndex>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1ACD8C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::function<void ()(md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v4 + 8))(v4);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>::Model<ecs2::RuntimeQuery<md::ls::RequiresShaderTextureID<DaVinci::ShadowTexture> const&,md::ls::PipelineSetup &>>::~Model()
{
}

void *std::__function::__func<ecs2::ForwardToExecute<md::ita::AssignStyleTextureIndex>,std::allocator<ecs2::ForwardToExecute<md::ita::AssignStyleTextureIndex>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  uint64_t v2 = *(int8x8_t **)(a2 + 8);
  HasMaterialRasterRender = (void *)gdc::Registry::storage<md::ls::HasMaterialRasterRenderItem>(v2);
  uint64_t v4 = gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::StyleTexture>>(v2);
  uint64_t v5 = gdc::Registry::storage<md::ls::PipelineSetup>(v2);
  uint64_t v6 = (void *)v5;
  uint64_t v7 = HasMaterialRasterRender + 4;
  if (*(void *)(v4 + 64) - *(void *)(v4 + 56) < HasMaterialRasterRender[8] - HasMaterialRasterRender[7]) {
    uint64_t v7 = (void *)(v4 + 32);
  }
  if (*(void *)(v5 + 64) - *(void *)(v5 + 56) < v7[4] - v7[3]) {
    uint64_t v7 = (void *)(v5 + 32);
  }
  float64x2_t v137 = v7;
  float64x2_t v138 = HasMaterialRasterRender;
  float64x2_t v139 = (void *)v4;
  float64x2_t v140 = (void *)v5;
  uint64_t v8 = (void *)v7[3];
  unint64_t v9 = (void *)v7[4];
  float64x2_t v141 = v8;
  if (v9 == v8)
  {
    uint64_t v10 = a1;
  }
  else
  {
    uint64_t v10 = a1;
    if (!gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v137))
    {
      unint64_t v11 = v8 + 1;
      do
      {
        uint64_t v8 = v11;
        float64x2_t v141 = v11;
        if (v11 == v9) {
          break;
        }
        BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(&v137);
        unint64_t v11 = v8 + 1;
      }
      while (!isValid);
    }
  }
  if (v9 == v8)
  {
    uint64_t result = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    goto LABEL_172;
  }
  uint64_t result = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  float64x2_t v136 = result;
  do
  {
LABEL_15:
    void *result = *v8;
    unint64_t v14 = *v8;
    uint64_t v15 = HIDWORD(*v8);
    unint64_t v16 = *v8 >> 39;
    uint64_t v17 = HasMaterialRasterRender[4];
    if (v16 < (HasMaterialRasterRender[5] - v17) >> 3
      && (uint64_t v18 = *(void *)(v17 + 8 * v16)) != 0
      && (unint64_t v19 = *(unsigned __int16 *)(v18 + 2 * (HIDWORD(v14) & 0x7F)),
          uint64_t v21 = HasMaterialRasterRender[7],
          uint64_t v20 = HasMaterialRasterRender[8],
          v19 < (v20 - v21) >> 3)
      && ((uint64_t v22 = v21 + 8 * v19, v22 != v20) ? (v23 = *(_DWORD *)(v22 + 4) == v15) : (v23 = 0), v23))
    {
      uint64_t v24 = HasMaterialRasterRender[10] + 8 * v19;
    }
    else
    {
      uint64_t v24 = HasMaterialRasterRender[11];
    }
    uint64_t v25 = v6[4];
    if (v16 < (v6[5] - v25) >> 3
      && (uint64_t v26 = *(void *)(v25 + 8 * v16)) != 0
      && (v27 = *(unsigned __int16 *)(v26 + 2 * (HIDWORD(v14) & 0x7F)), v29 = v6[7], uint64_t v28 = v6[8], v27 < (v28 - v29) >> 3)
      && ((uint64_t v30 = v29 + 8 * v27, v30 != v28) ? (v31 = *(_DWORD *)(v30 + 4) == v15) : (v31 = 0), v31))
    {
      uint64_t v32 = v6[11];
      uint64_t v33 = v6[10] + 8 * v27;
    }
    else
    {
      uint64_t v32 = v6[11];
      uint64_t v33 = v32;
    }
    if (v33 == v32) {
      uint64_t v34 = 0;
    }
    else {
      uint64_t v34 = (unint64_t *)v33;
    }
    uint64_t v35 = **(void **)(v10 + 8);
    BOOL v36 = *(void **)v35;
    long long v37 = *(void **)(v35 + 8);
    if (v36 != v37)
    {
      while (*v36 != 0x41D4E9297E100630)
      {
        v36 += 5;
        if (v36 == v37) {
          goto LABEL_42;
        }
      }
    }
    if (v36 == v37)
    {
LABEL_42:
      uint64_t v38 = 0;
    }
    else
    {
      uint64_t v38 = (void *)v36[3];
      unint64_t v39 = (std::__shared_weak_count *)v36[4];
      if (v39)
      {
        atomic_fetch_add_explicit(&v39->__shared_owners_, 1uLL, memory_order_relaxed);
        if (!atomic_fetch_add(&v39->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v39->__on_zero_shared)(v39);
          std::__shared_weak_count::__release_weak(v39);
        }
      }
    }
    uint64_t v40 = (uint64_t)(v38 + 37);
    unint64_t v41 = *v34;
    unint64_t v42 = *v34;
    uint64_t v43 = v38[50];
    unint64_t v44 = (v38[51] - v43) >> 3;
    if (v42 < v44
      && (uint64_t v45 = *(void *)(v43 + 8 * v42)) != 0
      && HIDWORD(v41) == HIDWORD(v45)
      && ((v46 = v38[53], v46 + 16 * v45 != v38[54]) ? (BOOL v47 = v46 == 0) : (BOOL v47 = 1), !v47))
    {
      uint64_t v56 = *(void *)(v43 + 8 * v42);
      id v57 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>((uint64_t)(v38 + 37), v41, v34);
      ++v57[3];
      uint64_t v58 = v46 + 16 * v56;
      uint64_t v10 = a1;
      uint64_t v48 = *(void **)(v58 + 8);
      unint64_t v41 = *v34;
      uint64_t v43 = v38[50];
      unint64_t v42 = *v34;
      if (v42 >= (v38[51] - v43) >> 3) {
        goto LABEL_62;
      }
    }
    else
    {
      uint64_t v48 = 0;
      if (v42 >= v44) {
        goto LABEL_62;
      }
    }
    uint64_t v49 = *(void *)(v43 + 8 * v42);
    if (v49 && HIDWORD(v41) == HIDWORD(v49))
    {
      uint64_t v50 = v38[53];
      long long v51 = (uint64_t *)v38[54];
      long long v52 = (uint64_t *)(v50 + 16 * v49);
      if (v52 != v51 && v50 != 0)
      {
        long long v54 = std::__hash_table<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::__unordered_map_hasher<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::hash<geo::handle<md::PipelineItem>>,std::equal_to<geo::handle<md::PipelineItem>>,true>,std::__unordered_map_equal<geo::handle<md::PipelineItem>,std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>,std::equal_to<geo::handle<md::PipelineItem>>,std::hash<geo::handle<md::PipelineItem>>,true>,std::allocator<std::__hash_value_type<geo::handle<md::PipelineItem>,md::Counter>>>::__emplace_unique_key_args<geo::handle<md::PipelineItem>,std::piecewise_construct_t const&,std::tuple<geo::handle<md::PipelineItem> const&>,std::tuple<>>(v40, v41, v34);
        ++v54[3];
        uint64_t v55 = *v52;
        goto LABEL_63;
      }
    }
LABEL_62:
    uint64_t v55 = 0;
LABEL_63:
    uint64_t v59 = *(void *)v24;
    if (*(unsigned char *)(*(void *)v24 + 122))
    {
      uint64_t v60 = *(void *)(v59 + 32);
      md::StyleTexture<md::LowZoomClimateStyle>::_processStylePixelsIfNecessary(v60);
    }
    else
    {
      uint64_t v60 = *(void *)(v59 + 16);
      md::StyleTexture<md::LowZoomStyle>::_processStylePixelsIfNecessary(v60);
    }
    uint64_t v61 = *(void *)(v60 + 24);
    {
      gdc::typeIndex<DaVinci::StyleTexture>(void)::index = atomic_fetch_add(gdc::internal::nextIndex(void)::index, 1uLL);
    }
    unint64_t v62 = v48[1];
    if (!v62) {
      goto LABEL_137;
    }
    unint64_t v63 = gdc::typeIndex<DaVinci::StyleTexture>(void)::index;
    uint8x8_t v64 = (uint8x8_t)vcnt_s8((int8x8_t)v62);
    v64.i16[0] = vaddlv_u8(v64);
    if (v64.u32[0] > 1uLL)
    {
      uint64_t v65 = gdc::typeIndex<DaVinci::StyleTexture>(void)::index;
      if (gdc::typeIndex<DaVinci::StyleTexture>(void)::index >= v62) {
        uint64_t v65 = gdc::typeIndex<DaVinci::StyleTexture>(void)::index % v62;
      }
    }
    else
    {
      uint64_t v65 = (v62 - 1) & gdc::typeIndex<DaVinci::StyleTexture>(void)::index;
    }
    long long v66 = *(void **)(*v48 + 8 * v65);
    if (!v66) {
      goto LABEL_137;
    }
    float64x2_t v67 = (void *)*v66;
    if (!v67) {
      goto LABEL_137;
    }
    if (v64.u32[0] < 2uLL)
    {
      unint64_t v68 = v62 - 1;
      while (1)
      {
        uint64_t v70 = v67[1];
        if (gdc::typeIndex<DaVinci::StyleTexture>(void)::index == v70)
        {
          if (v67[2] == gdc::typeIndex<DaVinci::StyleTexture>(void)::index) {
            goto LABEL_88;
          }
        }
        else if ((v70 & v68) != v65)
        {
          goto LABEL_137;
        }
        float64x2_t v67 = (void *)*v67;
        if (!v67) {
          goto LABEL_137;
        }
      }
    }
    while (1)
    {
      unint64_t v69 = v67[1];
      if (gdc::typeIndex<DaVinci::StyleTexture>(void)::index == v69) {
        break;
      }
      if (v69 >= v62) {
        v69 %= v62;
      }
      if (v69 != v65) {
        goto LABEL_137;
      }
LABEL_77:
      float64x2_t v67 = (void *)*v67;
      if (!v67) {
        goto LABEL_137;
      }
    }
    if (v67[2] != gdc::typeIndex<DaVinci::StyleTexture>(void)::index) {
      goto LABEL_77;
    }
LABEL_88:
    {
      if (v134)
      {
        md::typeToIntMap(v134);
        uint64_t v10 = a1;
      }
    }
    if (!qword_1E957F030) {
      goto LABEL_173;
    }
    uint8x8_t v71 = (uint8x8_t)vcnt_s8((int8x8_t)qword_1E957F030);
    v71.i16[0] = vaddlv_u8(v71);
    if (v71.u32[0] > 1uLL)
    {
      unint64_t v72 = v63;
      if (v63 >= qword_1E957F030) {
        unint64_t v72 = v63 % qword_1E957F030;
      }
    }
    else
    {
      unint64_t v72 = (qword_1E957F030 - 1) & v63;
    }
    float64x2_t v73 = *(uint64_t ****)(md::typeToIntMap(void)::typeToIntMap + 8 * v72);
    if (!v73 || (float32x4_t v74 = *v73) == 0) {
LABEL_173:
    }
      abort();
    if (v71.u32[0] < 2uLL)
    {
      while (1)
      {
        uint64_t v76 = v74[1];
        if ((uint64_t *)v63 == v76)
        {
          if (v74[2] == (uint64_t *)v63) {
            goto LABEL_109;
          }
        }
        else if (((unint64_t)v76 & (qword_1E957F030 - 1)) != v72)
        {
          goto LABEL_173;
        }
        float32x4_t v74 = (uint64_t **)*v74;
        if (!v74) {
          goto LABEL_173;
        }
      }
    }
    while (2)
    {
      unint64_t v75 = (unint64_t)v74[1];
      if (v63 != v75)
      {
        if (v75 >= qword_1E957F030) {
          v75 %= (unint64_t)qword_1E957F030;
        }
        if (v75 != v72) {
          goto LABEL_173;
        }
LABEL_99:
        float32x4_t v74 = (uint64_t **)*v74;
        if (!v74) {
          goto LABEL_173;
        }
        continue;
      }
      break;
    }
    if (v74[2] != (uint64_t *)v63) {
      goto LABEL_99;
    }
LABEL_109:
    uint64_t v78 = *((int *)v74 + 6);
    uint64_t v77 = *((int *)v74 + 7);
    if (v78 != -1)
    {
      uint64_t v79 = *(void *)(v55 + 16);
      if (v79)
      {
        uint64_t v80 = *(void *)(*(void *)(v79 + 48) + 72);
        uint64_t v81 = *(void *)(v80 + 8);
        uint64_t v82 = *(void *)(v81 + 72);
        if (v82)
        {
          uint64_t v83 = 0;
          uint64_t v84 = *(void *)(v81 + 64);
          uint64_t v85 = (unsigned __int8 *)(v84 + 1);
          while (1)
          {
            int v86 = *v85;
            v85 += 2;
            if (v86 == v78) {
              break;
            }
            if (v82 == ++v83) {
              goto LABEL_115;
            }
          }
          int v93 = (unsigned __int8 *)(v84 + 2 * v83);
LABEL_122:
          *(void *)(*(void *)(v55 + 96) + 8 * *v93) = v61;
        }
        else
        {
LABEL_115:
          uint64_t v87 = *(void *)(v80 + 24);
          uint64_t v88 = *(void *)(v87 + 72);
          if (v88)
          {
            uint64_t v89 = 0;
            uint64_t v90 = *(void *)(v87 + 64);
            float64_t v91 = (unsigned __int8 *)(v90 + 1);
            while (1)
            {
              int v92 = *v91;
              v91 += 2;
              if (v92 == v78) {
                break;
              }
              if (v88 == ++v89) {
                goto LABEL_123;
              }
            }
            int v93 = (unsigned __int8 *)(v90 + 2 * v89);
            goto LABEL_122;
          }
        }
      }
    }
LABEL_123:
    if (v77 != -1)
    {
      uint64_t v94 = *(void *)(v55 + 16);
      if (v94)
      {
        uint64_t v95 = *(void *)(*(void *)(v94 + 48) + 72);
        uint64_t v96 = *(void *)(v95 + 8);
        uint64_t v97 = *(void *)(v96 + 72);
        if (v97)
        {
          uint64_t v98 = 0;
          uint64_t v99 = *(void *)(v96 + 64);
          uint64_t v100 = (unsigned __int8 *)(v99 + 1);
          while (1)
          {
            int v101 = *v100;
            v100 += 2;
            if (v101 == v77) {
              break;
            }
            if (v97 == ++v98) {
              goto LABEL_129;
            }
          }
          float64x2_t v108 = (unsigned __int8 *)(v99 + 2 * v98);
LABEL_136:
          *(void *)(*(void *)(v55 + 96) + 8 * *v108) = v61;
        }
        else
        {
LABEL_129:
          uint64_t v102 = *(void *)(v95 + 24);
          uint64_t v103 = *(void *)(v102 + 72);
          if (v103)
          {
            uint64_t v104 = 0;
            uint64_t v105 = *(void *)(v102 + 64);
            float32x4_t v106 = (unsigned __int8 *)(v105 + 1);
            while (1)
            {
              int v107 = *v106;
              v106 += 2;
              if (v107 == v77) {
                break;
              }
              if (v103 == ++v104) {
                goto LABEL_137;
              }
            }
            float64x2_t v108 = (unsigned __int8 *)(v105 + 2 * v104);
            goto LABEL_136;
          }
        }
      }
    }
LABEL_137:
    uint64_t v8 = (void *)v137[4];
    float64x2_t v109 = v141 + 1;
    float64x2_t v141 = v109;
    if (v109 == v8)
    {
      uint64_t result = v136;
      if (v9 == v8) {
        break;
      }
      goto LABEL_15;
    }
    uint64_t v110 = v138[4];
    uint64_t result = v136;
    do
    {
      unint64_t v111 = *((unsigned int *)v109 + 1);
      unint64_t v112 = v111 >> 7;
      if (v111 >> 7 < (v138[5] - v110) >> 3)
      {
        uint64_t v113 = *(void *)(v110 + 8 * v112);
        if (v113)
        {
          uint64_t v114 = v111 & 0x7F;
          unint64_t v115 = *(unsigned __int16 *)(v113 + 2 * v114);
          uint64_t v116 = v138[7];
          uint64_t v117 = v138[8];
          if (v115 < (v117 - v116) >> 3)
          {
            uint64_t v118 = v116 + 8 * v115;
            if (v118 != v117 && *(_DWORD *)(v118 + 4) == v111)
            {
              uint64_t v120 = v139[4];
              if (v112 < (v139[5] - v120) >> 3)
              {
                uint64_t v121 = *(void *)(v120 + 8 * v112);
                if (v121)
                {
                  unint64_t v122 = *(unsigned __int16 *)(v121 + 2 * v114);
                  uint64_t v123 = v139[7];
                  uint64_t v124 = v139[8];
                  if (v122 < (v124 - v123) >> 3)
                  {
                    uint64_t v125 = v123 + 8 * v122;
                    if (v125 != v124 && *(_DWORD *)(v125 + 4) == v111)
                    {
                      uint64_t v127 = v140[4];
                      if (v112 < (v140[5] - v127) >> 3)
                      {
                        uint64_t v128 = *(void *)(v127 + 8 * v112);
                        if (v128)
                        {
                          unint64_t v129 = *(unsigned __int16 *)(v128 + 2 * v114);
                          uint64_t v131 = v140[7];
                          uint64_t v130 = v140[8];
                          if (v129 < (v130 - v131) >> 3)
                          {
                            uint64_t v132 = v131 + 8 * v129;
                            if (*(_DWORD *)(v132 + 4) == v111 && v132 != v130)
                            {
                              uint64_t v8 = v109;
                              goto LABEL_165;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      ++v109;
    }
    while (v109 != v8);
    float64x2_t v109 = v8;
LABEL_165:
    float64x2_t v141 = v109;
  }
  while (v9 != v8);
LABEL_172:
  void *result = 0xFFFFFFFF00000000;
  *(void *)(v10 + 8) = 0;
  return result;
}

void sub_1A1ACE15C(_Unwind_Exception *a1)
{
}

unint64_t *std::__function::__func<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorLandCover>,std::allocator<ecs2::ForwardToExecute<md::ita::PrepareFunctionConstantDescriptorLandCover>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  *(void *)(a1 + 8) = a2;
  uint64_t v3 = *(int8x8_t **)(a2 + 8);
  HasMaterialRasterRender = (void *)gdc::Registry::storage<md::ls::HasMaterialRasterRenderItem>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::FunctionConstants>(v3);
  uint64_t v6 = v5;
  uint64_t v7 = v5 + 4;
  if (HasMaterialRasterRender[8] - HasMaterialRasterRender[7] >= v5[8] - v5[7]) {
    uint64_t v8 = (uint64_t)(v5 + 4);
  }
  else {
    uint64_t v8 = (uint64_t)(HasMaterialRasterRender + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(&v45, v8, v5, HasMaterialRasterRender, *(void *)(v8 + 24));
  if (HasMaterialRasterRender[8] - HasMaterialRasterRender[7] >= v6[8] - v6[7]) {
    uint64_t v9 = (uint64_t)v7;
  }
  else {
    uint64_t v9 = (uint64_t)(HasMaterialRasterRender + 4);
  }
  gdc::RegistryQueryView<gdc::All<md::ls::FinishedProcessingDepthPrePass const,md::ls::PendingProcessingDepthPrePass const>,gdc::Any<>,gdc::None<>>::Iterator::Iterator(v43, v9, v6, HasMaterialRasterRender, *(void *)(v9 + 32));
  if (v44 == v48)
  {
    uint64_t result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  }
  else
  {
    uint64_t result = (unint64_t *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
    do
    {
      unint64_t *result = *v11;
      unint64_t v12 = *v11;
      uint64_t v13 = v6[4];
      if (v12 >> 39 < (v6[5] - v13) >> 3
        && (uint64_t v14 = *(void *)(v13 + 8 * (v12 >> 39))) != 0
        && (unint64_t v15 = *(unsigned __int16 *)(v14 + 2 * (HIDWORD(v12) & 0x7F)),
            uint64_t v17 = v6[7],
            uint64_t v16 = v6[8],
            v15 < (v16 - v17) >> 3)
        && ((unint64_t v18 = HIDWORD(v12), v19 = v17 + 8 * v15, v19 != v16)
          ? (BOOL v20 = *(_DWORD *)(v19 + 4) == v18)
          : (BOOL v20 = 0),
            v20))
      {
        uint64_t v21 = v6[11];
        uint64_t v22 = v6[10] + 33 * v15;
      }
      else
      {
        uint64_t v21 = v6[11];
        uint64_t v22 = v21;
      }
      if (v22 == v21) {
        uint64_t v23 = 0;
      }
      else {
        uint64_t v23 = v22;
      }
      *(_WORD *)(v23 + 9) = 257;
      uint64_t v24 = v48;
      unint64_t v11 = *(unint64_t **)(v45 + 32);
      if (++v48 != v11)
      {
        uint64_t v25 = v46[4];
        unint64_t v26 = (v46[5] - v25) >> 3;
        unint64_t v27 = v24 + 2;
        while (1)
        {
          unint64_t v28 = *((unsigned int *)v27 - 1);
          unint64_t v29 = v28 >> 7;
          if (v28 >> 7 < v26)
          {
            uint64_t v30 = *(void *)(v25 + 8 * v29);
            if (v30)
            {
              unint64_t v31 = *(unsigned __int16 *)(v30 + 2 * (v28 & 0x7F));
              uint64_t v33 = v46[7];
              uint64_t v32 = v46[8];
              if (v31 < (v32 - v33) >> 3)
              {
                uint64_t v34 = v33 + 8 * v31;
                if (v34 != v32 && *(_DWORD *)(v34 + 4) == v28)
                {
                  uint64_t v36 = v47[4];
                  if (v29 < (v47[5] - v36) >> 3)
                  {
                    uint64_t v37 = *(void *)(v36 + 8 * v29);
                    if (v37)
                    {
                      unint64_t v38 = *(unsigned __int16 *)(v37 + 2 * (v28 & 0x7F));
                      uint64_t v39 = v47[7];
                      uint64_t v40 = v47[8];
                      if (v38 < (v40 - v39) >> 3)
                      {
                        uint64_t v41 = v39 + 8 * v38;
                        if (v41 != v40 && *(_DWORD *)(v41 + 4) == v28) {
                          break;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          uint64_t v48 = v27;
          BOOL v20 = v27++ == v11;
          if (v20) {
            goto LABEL_9;
          }
        }
        unint64_t v11 = v27 - 1;
      }
LABEL_9:
      ;
    }
    while (v44 != v11);
  }
  unint64_t *result = 0xFFFFFFFF00000000;
  *(void *)(a1 + 8) = 0;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::HasMaterialRasterRenderItem>(int8x8_t *a1)
{
  unint64_t v10 = 0xD5B48B62BD07EF80;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xD5B48B62BD07EF80;
    if (*(void *)&v1 <= 0xD5B48B62BD07EF80) {
      unint64_t v3 = 0xD5B48B62BD07EF80 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xD5B48B62BD07EF80;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xD5B48B62BD07EF80)
      {
        if (v5[2] == 0xD5B48B62BD07EF80) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xD5B48B62BD07EF80) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xD5B48B62BD07EF80) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1ACE600(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t gdc::Registry::storage<md::ls::RequiresShaderTextureID<DaVinci::StyleTexture>>(int8x8_t *a1)
{
  uint64_t v10 = 0x57EF686AEB2B6CD0;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    uint64_t v3 = 0x57EF686AEB2B6CD0;
    if (*(void *)&v1 <= 0x57EF686AEB2B6CD0uLL) {
      uint64_t v3 = 0x57EF686AEB2B6CD0uLL % *(void *)&v1;
    }
  }
  else
  {
    uint64_t v3 = (*(void *)&v1 - 1) & 0x57EF686AEB2B6CD0;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0x57EF686AEB2B6CD0)
      {
        if (v5[2] == 0x57EF686AEB2B6CD0) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0x57EF686AEB2B6CD0) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0x57EF686AEB2B6CD0) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1ACE870(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

void std::__function::__func<ecs2::ForwardToExecute<md::ita::AssignStyleSSAOConstantData>,std::allocator<ecs2::ForwardToExecute<md::ita::AssignStyleSSAOConstantData>>,void ()(ecs2::Runtime &)>::operator()(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  *(void *)(a1 + 8) = a2;
  operator new();
}

void sub_1A1ACEF6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  std::function<void ()(md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &)>::~function((uint64_t *)va);
  (*(void (**)(uint64_t))(*(void *)v6 + 8))(v6);
  _Unwind_Resume(a1);
}

void ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>::Model<ecs2::RuntimeQuery<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>>::~Model()
{
}

uint64_t ecs2::Query<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>::Model<ecs2::RuntimeQuery<md::ls::IsMaterial const&,md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>> const&,md::ls::PipelineSetup &>>::each(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(int8x8_t **)(*(void *)(a1 + 8) + 8);
  uint64_t v4 = (void *)gdc::Registry::storage<md::ls::IsMaterial>(v3);
  uint64_t v5 = (void *)gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>>(v3);
  uint64_t v6 = gdc::Registry::storage<md::ls::PipelineSetup>(v3);
  uint64_t v10 = (void *)v6;
  unint64_t v11 = v4 + 4;
  if (v5[8] - v5[7] < v4[8] - v4[7]) {
    unint64_t v11 = v5 + 4;
  }
  if (*(void *)(v6 + 64) - *(void *)(v6 + 56) >= v11[4] - v11[3]) {
    uint64_t v12 = (uint64_t)v11;
  }
  else {
    uint64_t v12 = v6 + 32;
  }
  v82[0] = v12;
  v82[1] = v4;
  v82[2] = v5;
  void v82[3] = v6;
  uint64_t v14 = *(void **)(v12 + 24);
  uint64_t v13 = *(void **)(v12 + 32);
  uint64_t v83 = v14;
  if (v13 != v14
    && !gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v82))
  {
    unint64_t v15 = v14 + 1;
    do
    {
      uint64_t v14 = v15;
      uint64_t v83 = v15;
      if (v15 == v13) {
        break;
      }
      BOOL isValid = gdc::RegistryQueryView<gdc::All<md::ls::RenderItemID const,md::ls::ItemsPrepared const,md::ls::CommandBufferRef>,gdc::Any<>,gdc::None<>>::Iterator::isValid(v82);
      unint64_t v15 = v14 + 1;
    }
    while (!isValid);
  }
  uint64_t v17 = &ecs2::Runtime::_localEntity;
  unint64_t v18 = ecs2::Runtime::_localEntity;
  if (v13 == v14) {
    goto LABEL_82;
  }
  uint64_t v19 = (void *)ecs2::Runtime::_localEntity(&ecs2::Runtime::_localEntity);
  while (1)
  {
    *uint64_t v19 = *v14;
    unint64_t v21 = *v14;
    uint64_t v22 = HIDWORD(*v14);
    unint64_t v23 = *v14 >> 39;
    uint64_t v24 = v4[4];
    if (v23 >= (v4[5] - v24) >> 3) {
      goto LABEL_23;
    }
    uint64_t v25 = *(void *)(v24 + 8 * v23);
    if (!v25) {
      goto LABEL_23;
    }
    unint64_t v26 = *(unsigned __int16 *)(v25 + 2 * (HIDWORD(v21) & 0x7F));
    uint64_t v28 = v4[7];
    uint64_t v27 = v4[8];
    if (v26 >= (v27 - v28) >> 3) {
      goto LABEL_23;
    }
    uint64_t v29 = v28 + 8 * v26;
    if (v29 != v27 && *(_DWORD *)(v29 + 4) == v22)
    {
      uint64_t v31 = v4[11];
      uint64_t v32 = v4[10] + 8 * v26;
    }
    else
    {
LABEL_23:
      uint64_t v31 = v4[11];
      uint64_t v32 = v31;
    }
    uint64_t v33 = v32 == v31 ? 0 : v32;
    if ((uint64_t v34 = v5[4], v23 < (v5[5] - v34) >> 3)
      && (uint64_t v35 = *(void *)(v34 + 8 * v23)) != 0
      && (unint64_t v36 = *(unsigned __int16 *)(v35 + 2 * (HIDWORD(v21) & 0x7F)), v38 = v5[7], v37 = v5[8], v36 < (v37 - v38) >> 3)
      && ((uint64_t v39 = v38 + 8 * v36, v39 != v37) ? (v40 = *(_DWORD *)(v39 + 4) == v22) : (v40 = 0), v40))
    {
      unint64_t v41 = v5[11];
      unint64_t v42 = v5[10] + v36;
    }
    else
    {
      unint64_t v41 = v5[11];
      unint64_t v42 = v41;
    }
    unint64_t v43 = v42 == v41 ? 0 : v42;
    uint64_t v44 = v10[4];
    if (v23 < (v10[5] - v44) >> 3)
    {
      uint64_t v45 = *(void *)(v44 + 8 * v23);
      if (v45)
      {
        unint64_t v46 = *(unsigned __int16 *)(v45 + 2 * (HIDWORD(v21) & 0x7F));
        uint64_t v48 = v10[7];
        uint64_t v47 = v10[8];
        if (v46 < (v47 - v48) >> 3)
        {
          uint64_t v49 = v48 + 8 * v46;
          if (v49 != v47 && *(_DWORD *)(v49 + 4) == v22) {
            break;
          }
        }
      }
    }
    uint64_t v51 = v10[11];
    uint64_t v52 = v51;
    uint64_t v53 = *(void *)(a2 + 24);
    if (!v53) {
      goto LABEL_81;
    }
LABEL_46:
    if (v52 == v51) {
      uint64_t v54 = 0;
    }
    else {
      uint64_t v54 = v52;
    }
    uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, unint64_t, uint64_t))(*(void *)v53 + 48))(v53, v33, v43, v54);
    uint64_t v56 = *(void **)(v12 + 32);
    BOOL v20 = v14 + 1;
    uint64_t v83 = v14 + 1;
    if (v14 + 1 != v56)
    {
      uint64_t v57 = v4[4];
      uint64_t v59 = v4[7];
      uint64_t v58 = v4[8];
      uint64_t v60 = v5[4];
      uint64_t result = v5[7];
      uint64_t v61 = v5[8];
      uint64_t v62 = v10[4];
      uint64_t v64 = v10[7];
      uint64_t v63 = v10[8];
      while (1)
      {
        unint64_t v65 = *((unsigned int *)v20 + 1);
        unint64_t v66 = v65 >> 7;
        if (v65 >> 7 < (v4[5] - v57) >> 3)
        {
          uint64_t v67 = *(void *)(v57 + 8 * v66);
          if (v67)
          {
            uint64_t v68 = v65 & 0x7F;
            unint64_t v69 = *(unsigned __int16 *)(v67 + 2 * v68);
            if ((v58 - v59) >> 3 > v69)
            {
              uint64_t v70 = v59 + 8 * v69;
              BOOL v71 = v70 != v58 && *(_DWORD *)(v70 + 4) == v65;
              if (v71 && v66 < (v5[5] - v60) >> 3)
              {
                uint64_t v73 = *(void *)(v60 + 8 * v66);
                if (v73)
                {
                  unint64_t v74 = *(unsigned __int16 *)(v73 + 2 * v68);
                  if ((v61 - result) >> 3 > v74)
                  {
                    unint64_t v75 = result + 8 * v74;
                    BOOL v76 = v75 != v61 && *(_DWORD *)(v75 + 4) == v65;
                    if (v76 && v66 < (v10[5] - v62) >> 3)
                    {
                      uint64_t v78 = *(void *)(v62 + 8 * v66);
                      if (v78)
                      {
                        unint64_t v79 = *(unsigned __int16 *)(v78 + 2 * v68);
                        if ((v63 - v64) >> 3 > v79)
                        {
                          uint64_t v80 = v64 + 8 * v79;
                          if (*(_DWORD *)(v80 + 4) == v65 && v80 != v63) {
                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (++v20 == v56)
        {
          BOOL v20 = v56;
          goto LABEL_14;
        }
      }
      uint64_t v56 = v20;
LABEL_14:
      uint64_t v83 = v20;
    }
    uint64_t v14 = v56;
    if (v13 == v56) {
      goto LABEL_83;
    }
  }
  uint64_t v51 = v10[11];
  uint64_t v52 = v10[10] + 8 * v46;
  uint64_t v53 = *(void *)(a2 + 24);
  if (v53) {
    goto LABEL_46;
  }
LABEL_81:
  std::__throw_bad_function_call[abi:nn180100]();
LABEL_82:
  uint64_t result = ((uint64_t (*)(uint64_t (**)(void), uint64_t, uint64_t, uint64_t))v18)(v17, v7, v8, v9);
  uint64_t v19 = (void *)result;
LABEL_83:
  *uint64_t v19 = 0xFFFFFFFF00000000;
  return result;
}

uint64_t gdc::Registry::storage<md::ls::RequiresShaderConstantDataID<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>>(int8x8_t *a1)
{
  unint64_t v10 = 0xCDC9872DC17B96C4;
  int8x8_t v1 = a1[16];
  if (!*(void *)&v1) {
    goto LABEL_21;
  }
  uint8x8_t v2 = (uint8x8_t)vcnt_s8(v1);
  v2.i16[0] = vaddlv_u8(v2);
  if (v2.u32[0] > 1uLL)
  {
    unint64_t v3 = 0xCDC9872DC17B96C4;
    if (*(void *)&v1 <= 0xCDC9872DC17B96C4) {
      unint64_t v3 = 0xCDC9872DC17B96C4 % *(void *)&v1;
    }
  }
  else
  {
    unint64_t v3 = (*(void *)&v1 - 1) & 0xCDC9872DC17B96C4;
  }
  uint64_t v4 = *(void **)(*(void *)&a1[15] + 8 * v3);
  if (!v4 || (uint64_t v5 = (void *)*v4) == 0) {
LABEL_21:
  }
    operator new();
  if (v2.u32[0] < 2uLL)
  {
    uint64_t v6 = *(void *)&v1 - 1;
    while (1)
    {
      uint64_t v8 = v5[1];
      if (v8 == 0xCDC9872DC17B96C4)
      {
        if (v5[2] == 0xCDC9872DC17B96C4) {
          return v5[3];
        }
      }
      else if ((v8 & v6) != v3)
      {
        goto LABEL_21;
      }
      uint64_t v5 = (void *)*v5;
      if (!v5) {
        goto LABEL_21;
      }
    }
  }
  while (1)
  {
    unint64_t v7 = v5[1];
    if (v7 == 0xCDC9872DC17B96C4) {
      break;
    }
    if (v7 >= *(void *)&v1) {
      v7 %= *(void *)&v1;
    }
    if (v7 != v3) {
      goto LABEL_21;
    }
LABEL_11:
    uint64_t v5 = (void *)*v5;
    if (!v5) {
      goto LABEL_21;
    }
  }
  if (v5[2] != 0xCDC9872DC17B96C4) {
    goto LABEL_11;
  }
  return v5[3];
}

void sub_1A1ACF5B0(_Unwind_Exception *a1)
{
  (*(void (**)(uint64_t))(*(void *)v1 + 8))(v1);
  _Unwind_Resume(a1);
}

uint64_t __destroy_helper_block_ea8_40c27_ZTSNSt3__18functionIFvmEEE(uint64_t a1)
{
  uint64_t v1 = a1 + 40;
  uint64_t result = *(void *)(a1 + 64);
  if (result == v1) {
    return (*(uint64_t (**)(uint64_t))(*(void *)v1 + 32))(v1);
  }
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 40))();
  }
  return result;
}

void md::DaVinciGroundRenderLayer::layoutMaterialRenderables(uint64_t a1, md::LayoutContext *a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, uint64_t a9, char a10)
{
  uint64_t v980 = *MEMORY[0x1E4F143B8];
  v900 = *(void **)(*(void *)(a1 + 40) + 24);
  uint64_t v14 = (uint64_t *)*((void *)a2 + 1);
  int8x8_t v15 = (int8x8_t)v14[1];
  if (!*(void *)&v15)
  {
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    uint64_t v884 = 0;
    uint64_t v898 = 0;
    uint64_t v20 = 0;
    uint64_t v899 = 0;
    uint64_t v968 = 0;
    if (!MEMORY[0]) {
      return;
    }
    goto LABEL_166;
  }
  uint8x8_t v16 = (uint8x8_t)vcnt_s8(v15);
  v16.i16[0] = vaddlv_u8(v16);
  if (v16.u32[0] > 1uLL)
  {
    uint64_t v17 = 0x1AF456233693CD46;
    if (*(void *)&v15 <= 0x1AF456233693CD46uLL) {
      uint64_t v17 = 0x1AF456233693CD46uLL % *(void *)&v15;
    }
  }
  else
  {
    uint64_t v17 = (*(void *)&v15 - 1) & 0x1AF456233693CD46;
  }
  uint64_t v21 = *v14;
  uint64_t v22 = *(void **)(v21 + 8 * v17);
  if (!v22) {
    goto LABEL_26;
  }
  unint64_t v23 = (void *)*v22;
  if (!v23) {
    goto LABEL_26;
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v25 = v23[1];
      if (v25 == 0x1AF456233693CD46)
      {
        if (v23[2] == 0x1AF456233693CD46) {
          goto LABEL_24;
        }
      }
      else if ((v25 & (*(void *)&v15 - 1)) != v17)
      {
        goto LABEL_26;
      }
      unint64_t v23 = (void *)*v23;
      if (!v23) {
        goto LABEL_26;
      }
    }
  }
  while (1)
  {
    unint64_t v24 = v23[1];
    if (v24 == 0x1AF456233693CD46) {
      break;
    }
    if (v24 >= *(void *)&v15) {
      v24 %= *(void *)&v15;
    }
    if (v24 != v17) {
      goto LABEL_26;
    }
LABEL_13:
    unint64_t v23 = (void *)*v23;
    if (!v23) {
      goto LABEL_26;
    }
  }
  if (v23[2] != 0x1AF456233693CD46) {
    goto LABEL_13;
  }
LABEL_24:
  uint64_t v26 = v23[5];
  if (*(void *)(v26 + 8) == 0x1AF456233693CD46)
  {
    uint64_t v884 = *(void *)(v26 + 32);
    goto LABEL_27;
  }
LABEL_26:
  uint64_t v884 = 0;
LABEL_27:
  uint64_t v968 = 0;
  if (v16.u32[0] > 1uLL)
  {
    uint64_t v27 = 0x1DCE255EA309B4ADLL;
    if (*(void *)&v15 <= 0x1DCE255EA309B4ADuLL) {
      uint64_t v27 = 0x1DCE255EA309B4ADuLL % *(void *)&v15;
    }
  }
  else
  {
    uint64_t v27 = (*(void *)&v15 - 1) & 0x1DCE255EA309B4ADLL;
  }
  uint64_t v28 = *(void **)(v21 + 8 * v27);
  if (!v28) {
    goto LABEL_49;
  }
  uint64_t v29 = (void *)*v28;
  if (!v29) {
    goto LABEL_49;
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v31 = v29[1];
      if (v31 == 0x1DCE255EA309B4ADLL)
      {
        if (v29[2] == 0x1DCE255EA309B4ADLL) {
          goto LABEL_47;
        }
      }
      else if ((v31 & (*(void *)&v15 - 1)) != v27)
      {
        goto LABEL_49;
      }
      uint64_t v29 = (void *)*v29;
      if (!v29) {
        goto LABEL_49;
      }
    }
  }
  while (2)
  {
    unint64_t v30 = v29[1];
    if (v30 != 0x1DCE255EA309B4ADLL)
    {
      if (v30 >= *(void *)&v15) {
        v30 %= *(void *)&v15;
      }
      if (v30 != v27) {
        goto LABEL_49;
      }
      goto LABEL_36;
    }
    if (v29[2] != 0x1DCE255EA309B4ADLL)
    {
LABEL_36:
      uint64_t v29 = (void *)*v29;
      if (!v29) {
        goto LABEL_49;
      }
      continue;
    }
    break;
  }
LABEL_47:
  uint64_t v32 = v29[5];
  if (*(void *)(v32 + 8) == 0x1DCE255EA309B4ADLL)
  {
    uint64_t v33 = *(void *)(v32 + 32);
    goto LABEL_50;
  }
LABEL_49:
  uint64_t v33 = 0;
LABEL_50:
  uint64_t v968 = v33;
  if (v16.u32[0] > 1uLL)
  {
    uint64_t v34 = 0x41E8D6E445F4145;
    if (*(void *)&v15 <= 0x41E8D6E445F4145uLL) {
      uint64_t v34 = 0x41E8D6E445F4145uLL % *(void *)&v15;
    }
  }
  else
  {
    uint64_t v34 = (*(void *)&v15 - 1) & 0x41E8D6E445F4145;
  }
  uint64_t v35 = *(void **)(v21 + 8 * v34);
  if (!v35) {
    goto LABEL_72;
  }
  unint64_t v36 = (void *)*v35;
  if (!v36) {
    goto LABEL_72;
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v38 = v36[1];
      if (v38 == 0x41E8D6E445F4145)
      {
        if (v36[2] == 0x41E8D6E445F4145) {
          goto LABEL_70;
        }
      }
      else if ((v38 & (*(void *)&v15 - 1)) != v34)
      {
        goto LABEL_72;
      }
      unint64_t v36 = (void *)*v36;
      if (!v36) {
        goto LABEL_72;
      }
    }
  }
  while (2)
  {
    unint64_t v37 = v36[1];
    if (v37 != 0x41E8D6E445F4145)
    {
      if (v37 >= *(void *)&v15) {
        v37 %= *(void *)&v15;
      }
      if (v37 != v34) {
        goto LABEL_72;
      }
      goto LABEL_59;
    }
    if (v36[2] != 0x41E8D6E445F4145)
    {
LABEL_59:
      unint64_t v36 = (void *)*v36;
      if (!v36) {
        goto LABEL_72;
      }
      continue;
    }
    break;
  }
LABEL_70:
  uint64_t v39 = v36[5];
  if (*(void *)(v39 + 8) == 0x41E8D6E445F4145)
  {
    uint64_t v898 = *(void *)(v39 + 32);
    goto LABEL_73;
  }
LABEL_72:
  uint64_t v898 = 0;
LABEL_73:
  if (v16.u32[0] > 1uLL)
  {
    unint64_t v40 = 0xD2404CDD1F9A6950;
    if (*(void *)&v15 <= 0xD2404CDD1F9A6950) {
      unint64_t v40 = 0xD2404CDD1F9A6950 % *(void *)&v15;
    }
  }
  else
  {
    unint64_t v40 = (*(void *)&v15 - 1) & 0xD2404CDD1F9A6950;
  }
  unint64_t v41 = *(void **)(v21 + 8 * v40);
  if (!v41) {
    goto LABEL_95;
  }
  unint64_t v42 = (void *)*v41;
  if (!v42) {
    goto LABEL_95;
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v44 = v42[1];
      if (v44 == 0xD2404CDD1F9A6950)
      {
        if (v42[2] == 0xD2404CDD1F9A6950) {
          goto LABEL_93;
        }
      }
      else if ((v44 & (*(void *)&v15 - 1)) != v40)
      {
        goto LABEL_95;
      }
      unint64_t v42 = (void *)*v42;
      if (!v42) {
        goto LABEL_95;
      }
    }
  }
  while (2)
  {
    unint64_t v43 = v42[1];
    if (v43 != 0xD2404CDD1F9A6950)
    {
      if (v43 >= *(void *)&v15) {
        v43 %= *(void *)&v15;
      }
      if (v43 != v40) {
        goto LABEL_95;
      }
      goto LABEL_82;
    }
    if (v42[2] != 0xD2404CDD1F9A6950)
    {
LABEL_82:
      unint64_t v42 = (void *)*v42;
      if (!v42) {
        goto LABEL_95;
      }
      continue;
    }
    break;
  }
LABEL_93:
  uint64_t v45 = v42[5];
  if (*(void *)(v45 + 8) == 0xD2404CDD1F9A6950)
  {
    uint64_t v19 = *(int8x8_t ***)(v45 + 32);
    goto LABEL_96;
  }
LABEL_95:
  uint64_t v19 = 0;
LABEL_96:
  if (v16.u32[0] > 1uLL)
  {
    unint64_t v46 = 0xDFC317497CF9A4BFLL;
    if (*(void *)&v15 <= 0xDFC317497CF9A4BFLL) {
      unint64_t v46 = 0xDFC317497CF9A4BFLL % *(void *)&v15;
    }
  }
  else
  {
    unint64_t v46 = (*(void *)&v15 - 1) & 0xDFC317497CF9A4BFLL;
  }
  uint64_t v47 = *(void **)(v21 + 8 * v46);
  if (!v47) {
    goto LABEL_118;
  }
  uint64_t v48 = (void *)*v47;
  if (!v48) {
    goto LABEL_118;
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v50 = v48[1];
      if (v50 == 0xDFC317497CF9A4BFLL)
      {
        if (v48[2] == 0xDFC317497CF9A4BFLL) {
          goto LABEL_116;
        }
      }
      else if ((v50 & (*(void *)&v15 - 1)) != v46)
      {
        goto LABEL_118;
      }
      uint64_t v48 = (void *)*v48;
      if (!v48) {
        goto LABEL_118;
      }
    }
  }
  while (2)
  {
    unint64_t v49 = v48[1];
    if (v49 != 0xDFC317497CF9A4BFLL)
    {
      if (v49 >= *(void *)&v15) {
        v49 %= *(void *)&v15;
      }
      if (v49 != v46) {
        goto LABEL_118;
      }
      goto LABEL_105;
    }
    if (v48[2] != 0xDFC317497CF9A4BFLL)
    {
LABEL_105:
      uint64_t v48 = (void *)*v48;
      if (!v48) {
        goto LABEL_118;
      }
      continue;
    }
    break;
  }
LABEL_116:
  uint64_t v51 = v48[5];
  if (*(void *)(v51 + 8) == 0xDFC317497CF9A4BFLL)
  {
    uint64_t v20 = *(void *)(v51 + 32);
    goto LABEL_119;
  }
LABEL_118:
  uint64_t v20 = 0;
LABEL_119:
  if (v16.u32[0] > 1uLL)
  {
    unint64_t v52 = 0xE42D19AFCA302E68;
    if (*(void *)&v15 <= 0xE42D19AFCA302E68) {
      unint64_t v52 = 0xE42D19AFCA302E68 % *(void *)&v15;
    }
  }
  else
  {
    unint64_t v52 = (*(void *)&v15 - 1) & 0xE42D19AFCA302E68;
  }
  uint64_t v53 = *(void **)(v21 + 8 * v52);
  if (!v53) {
    goto LABEL_141;
  }
  uint64_t v54 = (void *)*v53;
  if (!v54) {
    goto LABEL_141;
  }
  if (v16.u32[0] < 2uLL)
  {
    while (1)
    {
      uint64_t v56 = v54[1];
      if (v56 == 0xE42D19AFCA302E68)
      {
        if (v54[2] == 0xE42D19AFCA302E68) {
          goto LABEL_139;
        }
      }
      else if ((v56 & (*(void *)&v15 - 1)) != v52)
      {
        goto LABEL_141;
      }
      uint64_t v54 = (void *)*v54;
      if (!v54) {
        goto LABEL_141;
      }
    }
  }
  while (2)
  {
    unint64_t v55 = v54[1];
    if (v55 != 0xE42D19AFCA302E68)
    {
      if (v55 >= *(void *)&v15) {
        v55 %= *(void *)&v15;
      }
      if (v55 != v52) {
        goto LABEL_141;
      }
      goto LABEL_128;
    }
    if (v54[2] != 0xE42D19AFCA302E68)
    {
LABEL_128:
      uint64_t v54 = (void *)*v54;
      if (!v54) {
        goto LABEL_141;
      }
      continue;
    }
    break;
  }
LABEL_139:
  uint64_t v57 = v54[5];
  if (*(void *)(v57 + 8) == 0xE42D19AFCA302E68)
  {
    uint64_t v18 = *(void *)(v57 + 32);
    goto LABEL_142;
  }
LABEL_141:
  uint64_t v18 = 0;
LABEL_142:
  if (v16.u32[0] > 1uLL)
  {
    unint64_t v58 = 0x8BD499FBD96FBB9ELL;
    if (*(void *)&v15 <= 0x8BD499FBD96FBB9ELL) {
      unint64_t v58 = 0x8BD499FBD96FBB9ELL % *(void *)&v15;
    }
  }
  else
  {
    unint64_t v58 = (*(void *)&v15 - 1) & 0x8BD499FBD96FBB9ELL;
  }
  uint64_t v59 = *(void **)(v21 + 8 * v58);
  if (!v59) {
    goto LABEL_165;
  }
  uint64_t v60 = (void *)*v59;
  if (!v60) {
    goto LABEL_165;
  }
  if (v16.u32[0] < 2uLL)
  {
    uint64_t v61 = *(void *)&v15 - 1;
    while (1)
    {
      uint64_t v63 = v60[1];
      if (v63 == 0x8BD499FBD96FBB9ELL)
      {
        if (v60[2] == 0x8BD499FBD96FBB9ELL) {
          goto LABEL_162;
        }
      }
      else if ((v63 & v61) != v58)
      {
        goto LABEL_165;
      }
      uint64_t v60 = (void *)*v60;
      if (!v60) {
        goto LABEL_165;
      }
    }
  }
  while (1)
  {
    unint64_t v62 = v60[1];
    if (v62 == 0x8BD499FBD96FBB9ELL) {
      break;
    }
    if (v62 >= *(void *)&v15) {
      v62 %= *(void *)&v15;
    }
    if (v62 != v58) {
      goto LABEL_165;
    }
LABEL_151:
    uint64_t v60 = (void *)*v60;
    if (!v60) {
      goto LABEL_165;
    }
  }
  if (v60[2] != 0x8BD499FBD96FBB9ELL) {
    goto LABEL_151;
  }
LABEL_162:
  uint64_t v64 = v60[5];
  if (*(void *)(v64 + 8) == 0x8BD499FBD96FBB9ELL)
  {
    uint64_t v899 = *(void *)(v64 + 32);
    if (!*v19) {
      return;
    }
LABEL_166:
    if (*(void *)(a1 + 3144))
    {
      uint64_t v860 = v18;
      v838 = v19;
      unint64_t v65 = +[VKDebugSettings sharedSettings];
      md::TerrainDebugOptions::TerrainDebugOptions((md::TerrainDebugOptions *)&v964, v65);

      if (v20) {
        BOOL v843 = *(unsigned char *)(v20 + 64) != 0;
      }
      else {
        BOOL v843 = 0;
      }
      uint64_t v963 = *(void *)(a5 + 384);
      unint64_t v66 = +[VKDebugSettings sharedSettings];
      int v851 = [v66 daVinciPlanarOverride];

      uint64_t v67 = +[VKDebugSettings sharedSettings];
      int v859 = [v67 daVinciWaterEnabled];

      uint64_t v68 = +[VKDebugSettings sharedSettings];
      char v69 = [v68 daVinciColorCorrectionOverride];

      char v962 = v69;
      BOOL v70 = *(unsigned char *)(a3 + 5) != 0;
      int v881 = *(unsigned __int8 *)(a5 + 24);
      unsigned __int8 v870 = v881 != 255;
      if (v881 != 255) {
        BOOL v70 = 0;
      }
      unsigned int v871 = v70;
      BOOL v71 = +[VKDebugSettings sharedSettings];
      int v902 = [v71 enableTileClipping];

      unint64_t v72 = +[VKDebugSettings sharedSettings];
      unsigned __int8 v869 = [v72 enableTileClippingDebug];

      unint64_t v74 = (float *)(a3 + 20);
      int v75 = *(unsigned __int8 *)(v898 + 224);
      v961[0] = a1;
      v961[1] = a4;
      v961[2] = &v968;
      v961[3] = &v963;
      v960[0] = a1;
      v960[1] = a4;
      v960[2] = &v962;
      v960[3] = a3 + 20;
      v959[0] = a1;
      v959[1] = a4;
      if (a6 != a7)
      {
        uint64_t v837 = a1 + 568;
        if (v75) {
          char v76 = 2;
        }
        else {
          char v76 = 1;
        }
        char v904 = v76;
        uint64_t v901 = (void *)(a1 + 3440);
        uint64_t v848 = (float *)(a1 + 368);
        double v847 = (float *)(a1 + 448);
        v861 = (uint64_t *)(a1 + 3248);
        double v846 = (float *)(a1 + 408);
        v842 = (float *)(a1 + 488);
        double v77 = 1.0;
        __asm { FMOV            V1.4S, #1.0 }
        int8x16_t v839 = _Q1;
        float v840 = v73;
        float v844 = v73;
        size_t v849 = a7;
        v850 = a8;
        unint64_t v903 = (float *)(a3 + 20);
        while (1)
        {
          uint64_t v81 = *(void *)(*a8 + 8 * *a6);
          if (*(unsigned char *)(v81 + 8) == 1 && (v904 & *(unsigned char *)(v81 + 376)) != 0) {
            break;
          }
LABEL_177:
          if (++a6 == a7) {
            return;
          }
        }
        unint64_t v958 = *(void *)(v81 + 240);
        if (v902)
        {
          uint64_t v82 = *(void *)(a5 + 248);
          uint64_t v83 = *(std::__shared_weak_count **)(a5 + 256);
          uint64_t v956 = v82;
          double v957 = v83;
          if (v83) {
            atomic_fetch_add_explicit(&v83->__shared_owners_, 1uLL, memory_order_relaxed);
          }
        }
        else
        {
          uint64_t v83 = 0;
          uint64_t v82 = 0;
          double v957 = 0;
          uint64_t v956 = 0;
        }
        BOOL v84 = v82 != 0;
        if (*(unsigned char *)(v81 + 64))
        {
          unint64_t v85 = *(void *)(v81 + 48);
          unsigned __int8 v86 = *(unsigned char *)(v81 + 56);
          if (std::__hash_table<md::UniqueRenderID,md::UniqueRenderIDHash,md::UniqueRenderIDKeyEqual,std::allocator<md::UniqueRenderID>>::find<md::UniqueRenderID>(v901, v85, v86))
          {
LABEL_1313:
            if (v83)
            {
              if (!atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
                std::__shared_weak_count::__release_weak(v83);
              }
            }
            goto LABEL_177;
          }
          std::__hash_table<md::UniqueRenderID,md::UniqueRenderIDHash,md::UniqueRenderIDKeyEqual,std::allocator<md::UniqueRenderID>>::__emplace_unique_key_args<md::UniqueRenderID,md::UniqueRenderID const&>((uint64_t)v901, v85, v86, (_OWORD *)(v81 + 48));
          double v957 = 0;
          uint64_t v956 = 0;
          if (v83 && !atomic_fetch_add(&v83->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v83->__on_zero_shared)(v83);
            std::__shared_weak_count::__release_weak(v83);
          }
          BOOL v84 = 0;
        }
        uint64_t v906 = (uint64_t *)(v81 + 224);
        (*(void (**)(unsigned char *__return_ptr, float))(**(void **)(v81 + 224) + 360))(v955, *v74);
        if (!v955[0] || v955[1])
        {
          if (!*(unsigned char *)(v81 + 149)
            && (((*(void (**)(std::string *__return_ptr, float))(*(void *)*v906 + 848))(&__p, *v74),
                 __p.__r_.__value_.__s.__data_[0])
              ? (_ZF = __p.__r_.__value_.__s.__data_[1] == 0)
              : (_ZF = 1),
                _ZF ? (int v88 = 0) : (int v88 = 1),
                !v88)
            || !a10
            || !*(unsigned char *)v899
            || *(unsigned char *)(v81 + 147))
          {
            (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*v906 + 752))(&v954, *v74);
            (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*v906 + 784))(&v953, *v74);
            (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*v906 + 976))(&v952, *v74);
            (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*v906 + 928))(&v951, *v74);
            if ((_BYTE)v952)
            {
              LOBYTE(v949) = 0;
              uint64_t v89 = v81 + 224;
            }
            else
            {
              uint64_t v89 = v81 + 224;
              (*(void (**)(uint64_t *__return_ptr, float))(*(void *)*v906 + 232))(&v949, *v74);
            }
            (*(void (**)(char *__return_ptr, float))(**(void **)v89 + 1040))(&v946, *v74);
            if (v946) {
              double v944 = 0;
            }
            else {
              (*(void (**)(char *__return_ptr, float))(*(void *)*v906 + 816))(&v944, *v74);
            }
            int v887 = *(unsigned __int8 *)(v81 + 368);
            if (!*(unsigned char *)(v81 + 368)) {
              goto LABEL_221;
            }
            uint64_t v90 = *((void *)a2 + 4);
            float64_t v91 = (std::__shared_weak_count *)*((void *)a2 + 5);
            if (v91)
            {
              atomic_fetch_add_explicit(&v91->__shared_owners_, 1uLL, memory_order_relaxed);
              int v92 = *(unsigned __int8 *)(v90 + 20);
              if (atomic_fetch_add(&v91->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                if (!v92) {
                  goto LABEL_1312;
                }
              }
              else
              {
                ((void (*)(std::__shared_weak_count *))v91->__on_zero_shared)(v91);
                std::__shared_weak_count::__release_weak(v91);
                if (!v92) {
                  goto LABEL_1312;
                }
              }
            }
            else if (!*(unsigned char *)(v90 + 20))
            {
              goto LABEL_1312;
            }
            uint64_t v93 = *(void *)(v81 + 352);
            if ((*(unsigned char *)(v93 + 16) & 2) == 0
              && atomic_load_explicit((atomic_ullong *volatile)&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, memory_order_acquire) != -1)
            {
              __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v910;
              *(void *)long long buf = &__p;
              std::__call_once(&ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::flag, buf, (void (__cdecl *)(void *))std::__call_once_proxy[abi:nn180100]<std::tuple<ggl::ResourceAccessor::accessBuffer(ggl::ResourceAccessor*,ggl::BufferData const*,gm::Range<unsigned long>,ggl::BufferAccess,ggl::BufferSync)::$_0 &&>>);
            }
            if (**(float **)(v93 + 72) > 0.0)
            {
LABEL_221:
              uint64_t v94 = v81 + 224;
              (*(void (**)(std::string *__return_ptr, float))(*(void *)*v906 + 888))(&__p, *v74);
              int v95 = __p.__r_.__value_.__s.__data_[0];
              int v96 = __p.__r_.__value_.__s.__data_[1];
              __p.__r_.__value_.__s.__data_[0] = 1;
              int hasAlpha = md::MaterialTextureManager::hasAlpha(v906, &__p, (int)*v74);
              uint64_t v100 = a3;
              int v101 = hasAlpha;
              if (v95 && v96)
              {
                uint64_t v102 = *(void *)(a1 + 3144);
                uint64_t v103 = *(std::__shared_weak_count **)(v102 + 320);
                unint64_t v882 = *(uint32x2_t **)(v102 + 312);
                if (v103)
                {
                  p_shared_owners = &v103->__shared_owners_;
                  atomic_fetch_add_explicit(&v103->__shared_owners_, 1uLL, memory_order_relaxed);
LABEL_234:
                  if (!atomic_fetch_add(p_shared_owners, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v103->__on_zero_shared)(v103);
                    std::__shared_weak_count::__release_weak(v103);
                  }
                }
              }
              else
              {
                uint64_t v105 = *(md::SharedResource **)(v81 + 256);
                if (v105)
                {
                  uint64_t v106 = md::LayoutContext::frameState(a2);
                  md::SharedResource::addFrameRef(v105, *(void *)(v106 + 624));
                  unint64_t v882 = (uint32x2_t *)*((void *)v105 + 4);
                }
                else
                {
                  uint64_t v107 = *(void *)(a1 + 3144);
                  buf[0] = 1;
                  float v108 = *v903;
                  float64x2_t v109 = *(std::__shared_weak_count **)(a1 + 2104);
                  uint64_t v942 = *(void *)(a1 + 2096);
                  int8x8_t v943 = v109;
                  if (v109) {
                    atomic_fetch_add_explicit(&v109->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  md::MaterialTextureManager::textureFromMaterial((__n128 *)&__p, v107, v906, &v958, buf, (int)v108);
                  uint64_t v110 = (md::SharedResource *)__p.__r_.__value_.__r.__words[0];
                  uint64_t v111 = md::LayoutContext::frameState(a2);
                  md::SharedResource::addFrameRef(v110, *(void *)(v111 + 624));
                  unint64_t v882 = (uint32x2_t *)*((void *)v110 + 4);
                  std::string::size_type size = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
                  if (__p.__r_.__value_.__l.__size_
                    && !atomic_fetch_add((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
                    std::__shared_weak_count::__release_weak(size);
                  }
                  uint64_t v103 = v943;
                  if (v943)
                  {
                    p_shared_owners = &v943->__shared_owners_;
                    goto LABEL_234;
                  }
                }
              }
              if ((_BYTE)v952) {
                char v113 = v951;
              }
              else {
                char v113 = v949;
              }
              v99.n128_u32[0] = v950;
              v98.n128_u32[0] = HIDWORD(v951);
              if ((_BYTE)v952) {
                v99.n128_f32[0] = *((float *)&v951 + 1);
              }
              unsigned __int8 v867 = v84;
              if (v887 && !*(unsigned char *)(v81 + 328))
              {
                BOOL v114 = 1;
              }
              else
              {
                if ((_BYTE)v951)
                {
                  v98.n128_f64[0] = *((float *)&v951 + 1);
                }
                else
                {
                  v98.n128_f64[0] = v99.n128_f32[0];
                  if (!v113) {
                    v98.n128_f64[0] = v77;
                  }
                }
                BOOL v114 = v98.n128_f64[0] >= 0.999999;
              }
              uint64_t v115 = *(void *)(a1 + 3144);
              uint64_t v117 = *(uint32x2_t **)(v115 + 312);
              uint64_t v116 = *(std::__shared_weak_count **)(v115 + 320);
              if (v116)
              {
                atomic_fetch_add_explicit(&v116->__shared_owners_, 1uLL, memory_order_relaxed);
                if (!atomic_fetch_add(&v116->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *, __n128, __n128))v116->__on_zero_shared)(v116, v98, v99);
                  std::__shared_weak_count::__release_weak(v116);
                }
              }
              if (v117 == v882)
              {
                int v118 = 0;
                BOOL v879 = 0;
              }
              else if ((_BYTE)v954)
              {
                int v118 = 1;
                BOOL v879 = 1;
              }
              else
              {
                BOOL v879 = (_BYTE)v953 != 0;
                int v118 = 1;
              }
              int v119 = v114 & ~v118;
              if (!v101) {
                int v119 = v114;
              }
              int v896 = v119;
              uint64_t v120 = *(md::SharedResource **)(v81 + 296);
              if (v120)
              {
                uint64_t v121 = md::LayoutContext::frameState(a2);
                uint64_t v122 = v860;
                md::SharedResource::addFrameRef(v120, *(void *)(v121 + 624));
                uint64_t v868 = *((void *)v120 + 4);
              }
              else
              {
                uint64_t v133 = *(void *)(a1 + 3144);
                buf[0] = 4;
                float v134 = *v903;
                float64x2_t v135 = *(std::__shared_weak_count **)(a1 + 2104);
                uint64_t v940 = *(void *)(a1 + 2096);
                uint64_t v941 = v135;
                uint64_t v122 = v860;
                if (v135) {
                  atomic_fetch_add_explicit(&v135->__shared_owners_, 1uLL, memory_order_relaxed);
                }
                md::MaterialTextureManager::textureFromMaterial((__n128 *)&__p, v133, v906, &v958, buf, (int)v134);
                float64x2_t v136 = (md::SharedResource *)__p.__r_.__value_.__r.__words[0];
                uint64_t v137 = md::LayoutContext::frameState(a2);
                md::SharedResource::addFrameRef(v136, *(void *)(v137 + 624));
                uint64_t v868 = *((void *)v136 + 4);
                float64x2_t v138 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
                if (__p.__r_.__value_.__l.__size_
                  && !atomic_fetch_add((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v138->__on_zero_shared)(v138);
                  std::__shared_weak_count::__release_weak(v138);
                }
                float64x2_t v139 = v941;
                if (v941 && !atomic_fetch_add(&v941->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v139->__on_zero_shared)(v139);
                  std::__shared_weak_count::__release_weak(v139);
                }
              }
              uint64_t v123 = *(void *)(a1 + 3144);
              uint64_t v125 = *(void *)(v123 + 312);
              uint64_t v124 = *(std::__shared_weak_count **)(v123 + 320);
              if (v124)
              {
                atomic_fetch_add_explicit(&v124->__shared_owners_, 1uLL, memory_order_relaxed);
                if (!atomic_fetch_add(&v124->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v124->__on_zero_shared)(v124);
                  std::__shared_weak_count::__release_weak(v124);
                }
              }
              int v872 = *(unsigned __int8 *)(*(void *)(v81 + 216) + 61);
              float64x2_t v126 = *(std::__shared_weak_count **)(v81 + 232);
              *(void *)&long long v939 = *(void *)(v81 + 224);
              *((void *)&v939 + 1) = v126;
              if (v126) {
                atomic_fetch_add_explicit(&v126->__shared_owners_, 1uLL, memory_order_relaxed);
              }
              unint64_t v938 = v958;
              LODWORD(v127) = v967;
              int v128 = v896;
              uint64_t v855 = v125;
              if (!v967) {
                goto LABEL_306;
              }
              unint64_t v127 = *(unsigned __int8 *)(v81 + 377);
              if (!*(unsigned char *)(v81 + 377)) {
                goto LABEL_306;
              }
              unint64_t v129 = *(int8x8_t **)(v963 + 1304);
              if (v129)
              {
                int8x8_t v130 = v129[6];
                if (v130)
                {
                  uint8x8_t v131 = (uint8x8_t)vcnt_s8(v130);
                  v131.i16[0] = vaddlv_u8(v131);
                  if (v131.u32[0] > 1uLL)
                  {
                    unint64_t v132 = *(unsigned __int8 *)(v81 + 377);
                    if (*(void *)&v130 <= v127) {
                      unint64_t v132 = v127 % *(void *)&v130;
                    }
                  }
                  else
                  {
                    unint64_t v132 = (v130.i32[0] - 1) & v127;
                  }
                  float64x2_t v143 = *(uint64_t ****)(*(void *)&v129[5] + 8 * v132);
                  if (v143)
                  {
                    float64x2_t v144 = *v143;
                    if (v144)
                    {
                      if (v131.u32[0] < 2uLL)
                      {
                        uint64_t v145 = *(void *)&v130 - 1;
                        while (1)
                        {
                          float64x2_t v147 = v144[1];
                          if (v147 == (uint64_t *)v127)
                          {
                            if (*((unsigned __int8 *)v144 + 16) == v127) {
                              goto LABEL_781;
                            }
                          }
                          else if (((unint64_t)v147 & v145) != v132)
                          {
                            goto LABEL_305;
                          }
                          float64x2_t v144 = (uint64_t **)*v144;
                          if (!v144) {
                            goto LABEL_305;
                          }
                        }
                      }
                      do
                      {
                        unint64_t v146 = (unint64_t)v144[1];
                        if (v146 == v127)
                        {
                          if (*((unsigned __int8 *)v144 + 16) == v127)
                          {
LABEL_781:
                            unint64_t v127 = (unint64_t)v144[3];
                            unint64_t v858 = v127;
                            if (v127)
                            {
                              BOOL v487 = 0;
                              buf[0] = 0;
                              uint8_t buf[8] = 0;
                              if (v965 | v966) {
                                BOOL v487 = v964 == 0;
                              }
                              BOOL updated = md::MaterialRaster::updateStyleTextureIfNecessary(v127, *v838, (uint64_t)buf, v487, *(unsigned __int8 *)(v122 + 72) == 1, *v903);
                              if (!*(unsigned char *)(v858 + 123)) {
                                int v128 = 0;
                              }
                              int v896 = v128;
                              if (buf[8])
                              {
                                unint64_t v938 = *(void *)buf;
                                uint64_t v488 = *v838;
                                *(_OWORD *)&__p.__r_.__value_.__l.__data_ = *(unint64_t *)buf;
                                gms::MaterialManager<ggl::Texture2D>::materialForKeyAndAttributes(v910, v488, (uint64_t *)&__p, 0);
                                long long v489 = *(_OWORD *)v910;
                                *(_OWORD *)v910 = 0uLL;
                                long long v939 = v489;
                                if (v126 && !atomic_fetch_add(&v126->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v126->__on_zero_shared)(v126);
                                  std::__shared_weak_count::__release_weak(v126);
                                }
                                uint64_t v490 = *(std::__shared_weak_count **)&v910[8];
                                if (*(void *)&v910[8]
                                  && !atomic_fetch_add((atomic_ullong *volatile)(*(void *)&v910[8] + 8), 0xFFFFFFFFFFFFFFFFLL))
                                {
                                  ((void (*)(std::__shared_weak_count *))v490->__on_zero_shared)(v490);
                                  std::__shared_weak_count::__release_weak(v490);
                                }
                                int v142 = v859;
                              }
                              else
                              {
                                int v142 = 0;
                              }
                              LODWORD(v127) = 1;
                              goto LABEL_307;
                            }
LABEL_306:
                            unint64_t v858 = 0;
                            BOOL updated = 0;
                            int v142 = v859;
                            goto LABEL_307;
                          }
                        }
                        else
                        {
                          if (v146 >= *(void *)&v130) {
                            v146 %= *(void *)&v130;
                          }
                          if (v146 != v132) {
                            break;
                          }
                        }
                        float64x2_t v144 = (uint64_t **)*v144;
                      }
                      while (v144);
                    }
                  }
                }
LABEL_305:
                LODWORD(v127) = 0;
                goto LABEL_306;
              }
              if (GEOGetVectorKitVKDefaultLog_onceToken != -1) {
                dispatch_once(&GEOGetVectorKitVKDefaultLog_onceToken, &__block_literal_global_5_16469);
              }
              float64x2_t v140 = (id)GEOGetVectorKitVKDefaultLog_log;
              if (os_log_type_enabled(v140, OS_LOG_TYPE_ERROR))
              {
                gdc::LayerDataRequestKey::keysInt32Str(&__p, (unsigned __int16 *)(v963 + 16));
                p_p = &__p;
                if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0) {
                  p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
                }
                *(_DWORD *)long long buf = 136315138;
                *(void *)&uint8_t buf[4] = p_p;
                _os_log_impl(&dword_1A1780000, v140, OS_LOG_TYPE_ERROR, "Tile:%s has renderables referencing a material raster but no raster set", buf, 0xCu);
                if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
                  operator delete(__p.__r_.__value_.__l.__data_);
                }
              }

              LODWORD(v127) = 0;
              unint64_t v858 = 0;
              BOOL updated = 0;
              int v142 = v859;
              uint64_t v100 = a3;
              uint64_t v122 = v860;
              uint64_t v94 = v81 + 224;
LABEL_307:
              if (v964) {
                LODWORD(v127) = 1;
              }
              int v876 = v127;
              (*(void (**)(uint64_t *__return_ptr, float))(**(void **)v94 + 456))(&v937, *v903);
              int v854 = v937;
              (*(void (**)(char *__return_ptr, float))(**(void **)v94 + 1008))(&v934, *v903);
              if (v934)
              {
                long long v931 = 0;
                BOOL v148 = 1;
              }
              else
              {
                (*(void (**)(__int8 *__return_ptr, float))(**(void **)v94 + 200))(&v931, *v903);
                if (v934) {
                  BOOL v148 = 1;
                }
                else {
                  BOOL v148 = v931 != 0;
                }
              }
              BOOL v877 = v148;
              if (v872 == 1) {
                int v149 = v142;
              }
              else {
                int v149 = 0;
              }
              if (v149 == 1 && *(unsigned char *)(v939 + 8) == 5)
              {
                uint64_t v150 = *(void *)(a1 + 3144);
                float v151 = *v903;
                float64x2_t v152 = (std::__shared_weak_count *)*((void *)&v939 + 1);
                long long v930 = v939;
                if (*((void *)&v939 + 1)) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v939 + 1) + 8), 1uLL, memory_order_relaxed);
                }
                float64x2_t v153 = md::MaterialTextureManager::colorRampTexturesFromMaterial(v150, (int)v151, (uint64_t *)&v930);
                float64x2_t v155 = v154;
                if (v152 && !atomic_fetch_add(&v152->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v152->__on_zero_shared)(v152);
                  std::__shared_weak_count::__release_weak(v152);
                }
              }
              else
              {
                float64x2_t v153 = 0;
                float64x2_t v155 = 0;
              }
              unsigned int v874 = ((unint64_t)v153 | (unint64_t)v155) != 0;
              unsigned __int8 v156 = atomic_load((unsigned __int8 *)(*(void *)(v122 + 32) + 254));
              int v157 = v156 & (v153 != 0);
              if (!v155) {
                int v157 = 0;
              }
              int v866 = v157;
              (*(void (**)(std::string *__return_ptr, float))(**(void **)v94 + 1224))(&__p, *v903);
              BOOL v158 = 0;
              if (__p.__r_.__value_.__s.__data_[0]) {
                _S8 = *((float *)__p.__r_.__value_.__r.__words + 1);
              }
              else {
                _S8 = 1.0;
              }
              if (*(unsigned char *)(v100 + 7) && *(float *)(v100 + 68) >= 0.001)
              {
                float v160 = fmax(*(double *)(v884 + 32) * 0.5, 250.0)
                     * (float)((float)(*(float *)(v100 + 64) * *(float *)(*(void *)(a5 + 8) + 624))
                             * fmaxf((float)(*(float *)(v100 + 20) * 0.125) + -0.875, 0.0));
                BOOL v158 = v160 >= 0.001;
              }
              uint64_t v161 = v900[20];
              if (v161
                && (unint64_t v162 = *(void *)(v161 + 32),
                    uint64_t v163 = *(void *)(v900[1] + 96),
                    v162 < (*(void *)(v900[1] + 104) - v163) >> 3))
              {
                uint64_t v845 = *(void *)(*(void *)(v163 + 8 * v162) + 16);
                BOOL v164 = v843;
                if (!v845) {
                  BOOL v164 = 0;
                }
                if (v164)
                {
                  if (v946) {
                    BOOL v165 = 1;
                  }
                  else {
                    BOOL v165 = v944 != 0;
                  }
                  BOOL v873 = v165;
                  unsigned int v166 = v871;
                  if ((v896 & 1) == 0) {
LABEL_342:
                  }
                    unsigned int v166 = *(unsigned char *)(v100 + 5) != 0;
LABEL_343:
                  uint64_t v885 = v81;
                  v852 = v155;
                  int8x8_t v865 = (md::SharedResource *)v153;
                  __int8 v167 = v118;
                  if (*(unsigned char *)v899)
                  {
                    uint64_t v168 = v885;
                    BOOL v853 = *(unsigned char *)(v885 + 147) != 0;
                  }
                  else
                  {
                    BOOL v853 = 1;
                    uint64_t v168 = v885;
                  }
                  int v169 = *(unsigned __int8 *)(*(void *)(v168 + 216) + 61);
                  int v170 = *(unsigned __int8 *)(*(void *)v94 + 8);
                  int v171 = *(unsigned __int8 *)(v100 + 6);
                  int v172 = *(unsigned __int8 *)(v100 + 9);
                  if (*(unsigned char *)(v100 + 7)) {
                    unsigned __int8 v173 = v158;
                  }
                  else {
                    unsigned __int8 v173 = 0;
                  }
                  BOOL v175 = _S8 > 0.01 && *(unsigned char *)v100 != 0;
                  unsigned __int8 v862 = v175;
                  int v176 = *(unsigned __int8 *)(v100 + 4);
                  int v177 = *(unsigned __int8 *)(v100 + 16);
                  if (v881 != 255)
                  {
                    uint64_t v909 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::GroundNonCompressedPipelineSetup>::pop(*(void *)(a1 + 1664));
                    HIBYTE(v834) = v876;
                    LOBYTE(v834) = 0;
                    HIBYTE(v831) = v169 == 1;
                    LOBYTE(v831) = v873;
                    HIBYTE(v829) = v876;
                    LOBYTE(v829) = v853;
                    HIBYTE(v826) = a10;
                    LOBYTE(v826) = v866;
                    md::DaVinciPipelineStateManager<ggl::DaVinci::GroundNonCompressedPipelineState,std::shared_ptr<ggl::DaVinciGroundNotCompressedShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)&__p, a1 + 688, v166, v176 != 0, v170 == 3, v170 == 4, v171 != 0, v874, v826, v829, v831, v172 != 0, v879, v870, v173, v167, v868 != v855, v887 != 0, v862,
                      v854 != 0,
                      v877,
                      v177 != 0,
                      0,
                      v867,
                      v869,
                      updated,
                      0,
                      0,
                      v834);
                    long long v178 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
                    uint64_t v179 = (std::__shared_weak_count *)*((void *)&v178 + 1);
                    if ((void)v178 && **(void **)(v178 + 40) == *((void *)v909 + 1))
                    {
                      uint64_t v187 = *((void *)v909 + 2);
                      uint8x8_t v181 = (unsigned char *)a3;
                      if (v187 && v187 != (void)v178)
                      {
                        long long v863 = v178;
                        ggl::PipelineSetup::resetData((uint64_t)v909);
                        long long v178 = v863;
                      }
                      if (v179) {
                        atomic_fetch_add_explicit(&v179->__shared_owners_, 1uLL, memory_order_relaxed);
                      }
                      unint64_t v180 = (std::__shared_weak_count *)*((void *)v909 + 3);
                      *((_OWORD *)v909 + 1) = v178;
                      if (v180) {
                        goto LABEL_373;
                      }
                    }
                    else
                    {
                      unint64_t v180 = (std::__shared_weak_count *)*((void *)v909 + 3);
                      *((void *)v909 + 2) = 0;
                      *((void *)v909 + 3) = 0;
                      uint8x8_t v181 = (unsigned char *)a3;
                      if (!v180) {
                        goto LABEL_375;
                      }
LABEL_373:
                      if (!atomic_fetch_add(&v180->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v180->__on_zero_shared)(v180);
                        std::__shared_weak_count::__release_weak(v180);
                      }
                    }
LABEL_375:
                    if (!v179 || atomic_fetch_add(&v179->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      uint64_t v188 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
                      if (__p.__r_.__value_.__l.__size_) {
                        goto LABEL_378;
                      }
LABEL_379:
                      if (*v181) {
                        goto LABEL_380;
                      }
LABEL_389:
                      uint64_t v196 = *(uint64_t **)(a1 + 3128);
                      uint64_t v197 = *v196;
                      uint64_t v198 = (std::__shared_weak_count *)v196[1];
                      if (v198)
                      {
                        atomic_fetch_add_explicit(&v198->__shared_owners_, 1uLL, memory_order_relaxed);
                        *(void *)(*((void *)v909 + 12) + 24) = v197;
                        uint64_t v199 = v885;
                        if (!atomic_fetch_add(&v198->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                          goto LABEL_397;
                        }
                      }
                      else
                      {
                        *(void *)(*((void *)v909 + 12) + 24) = v197;
                        uint64_t v199 = v885;
                      }
                      goto LABEL_518;
                    }
                    ((void (*)(std::__shared_weak_count *))v179->__on_zero_shared)(v179);
                    std::__shared_weak_count::__release_weak(v179);
                    uint64_t v188 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
                    if (!__p.__r_.__value_.__l.__size_) {
                      goto LABEL_379;
                    }
LABEL_378:
                    if (atomic_fetch_add(&v188->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL)) {
                      goto LABEL_379;
                    }
                    ((void (*)(std::__shared_weak_count *))v188->__on_zero_shared)(v188);
                    std::__shared_weak_count::__release_weak(v188);
                    if (!*v181) {
                      goto LABEL_389;
                    }
LABEL_380:
                    unint64_t v189 = +[VKDebugSettings sharedSettings];
                    int v190 = [v189 daVinciSSAODepthAwareUpsampleEnabled];

                    if (v190)
                    {
                      uint64_t v191 = v900;
                      uint64_t v192 = v900[19];
                      if (!v192) {
                        goto LABEL_393;
                      }
                    }
                    else
                    {
                      uint64_t v191 = v900;
                      uint64_t v192 = v900[17];
                      if (!v192) {
                        goto LABEL_393;
                      }
                    }
                    unint64_t v193 = *(void *)(v192 + 32);
                    uint64_t v195 = (uint64_t *)(v191[1] + 96);
                    uint64_t v194 = *v195;
                    if (v193 >= (v195[1] - *v195) >> 3) {
                      uint64_t v192 = 0;
                    }
                    else {
                      uint64_t v192 = *(void *)(*(void *)(v194 + 8 * v193) + 16);
                    }
LABEL_393:
                    *(void *)(*((void *)v909 + 12) + 24) = v192;
                    uint64_t v200 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>::pop(*(void *)(a1 + 1936));
                    unint64_t v201 = v200[1];
                    uint64_t v202 = v200[9];
                    __int16 v203 = *(_WORD *)(v898 + 216);
                    *(_DWORD *)uint64_t v202 = *(_DWORD *)(v898 + 212);
                    *(_WORD *)(v202 + 4) = v203;
                    __asm { FCVT            H0, S8 }
                    *(_WORD *)(v202 + 8) = _H0;
                    if (v200[8] > v201) {
                      unint64_t v201 = v200[8];
                    }
                    v200[7] = 0;
                    v200[8] = v201;
                    uint64_t v205 = *((void *)v909 + 8);
                    *(void *)(v205 + 432) = v200;
                    *(void *)(v205 + 440) = 0;
                    uint64_t v206 = *((void *)v909 + 20);
                    uint64_t v198 = *(std::__shared_weak_count **)(v206 + 440);
                    *(void *)(v206 + 432) = 0;
                    *(void *)(v206 + 440) = 0;
                    uint64_t v199 = v885;
                    if (v198 && !atomic_fetch_add(&v198->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
LABEL_397:
                      ((void (*)(std::__shared_weak_count *))v198->__on_zero_shared)(v198);
                      std::__shared_weak_count::__release_weak(v198);
                    }
LABEL_518:
                    md::DaVinciGroundRenderLayer::setupDaVinciGroundTileDataBindings<ggl::DaVinci::GroundNonCompressedPipelineSetup>((uint64_t)v909, v199);
                    float v289 = *(float *)(a3 + 40);
                    if (*(unsigned __int8 *)(a5 + 24) == 255)
                    {
                      if (*(unsigned char *)(a3 + 5) && *(unsigned char *)(a3 + 4))
                      {
                        double v292 = *(double *)(a5 + 288);
                        double v293 = *(double *)(a5 + 296);
                        double v294 = *(double *)(a5 + 304);
                        double v295 = *(double *)(a5 + 312);
                        double v296 = v293 + v293;
                        double v297 = (v293 + v293) * v293;
                        double v298 = (v294 + v294) * v294;
                        double v299 = v292 + v292;
                        double v300 = (v292 + v292) * v293;
                        double v301 = (v294 + v294) * v295;
                        double v302 = v294 * (v292 + v292);
                        double v77 = 1.0;
                        double v303 = 1.0 - (v292 + v292) * v292;
                        double v304 = v296 * v294;
                        *(double *)long long buf = 1.0 - (v297 + v298);
                        *(double *)&uint8_t buf[8] = v301 + v300;
                        *((double *)&v976 + 1) = v300 - v301;
                        *(double *)&long long v977 = v303 - v298;
                        *(double *)&v978[8] = v295 * v296 + v302;
                        *(double *)&v978[16] = v304 - v295 * v299;
                        *(double *)&buf[16] = v302 - v295 * v296;
                        *((double *)&v977 + 1) = v295 * v299 + v304;
                        *(double *)&v978[24] = v303 - v297;
                        *(void *)&long long v976 = 0;
                        *(void *)v978 = 0;
                        memset(&v978[32], 0, 32);
                        uint64_t v979 = 0x3FF0000000000000;
                        gm::Matrix<double,4,4>::inverted<int,void>((double *)&__p, (double *)buf);
                        double v305 = *(double *)(a3 + 80);
                        double v306 = *(double *)(a3 + 88);
                        double v307 = *(double *)(a3 + 96);
                        double v308 = *(double *)(a3 + 104);
                        _Q0 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)&__p.__r_.__value_.__l.__data_, v305), *(float64x2_t *)&v972[8], v306), *(float64x2_t *)&v973[8], v307), *(float64x2_t *)&v974[8], v308);
                        _D1 = *(double *)&__p.__r_.__value_.__r.__words[2] * v305
                            + *(double *)&v972[24] * v306
                            + *(double *)&v973[24] * v307
                            + *(double *)&v974[24] * v308;
                      }
                      else
                      {
                        _Q0 = *(float64x2_t *)(a3 + 80);
                        _D1 = *(double *)(a3 + 96);
                      }
                    }
                    else
                    {
                      _Q0 = *(float64x2_t *)(a3 + 112);
                      _D1 = *(double *)(a3 + 128);
                    }
                    unint64_t v309 = (float *)(a3 + 20);
                    _S8 = 1.0 / v289;
                    _D2 = _Q0.f64[1];
                    __asm
                    {
                      FCVT            H2, D2
                      FCVT            H0, D0
                    }
                    WORD1(_Q0.f64[0]) = LOWORD(_D2);
                    __asm { FCVT            H9, D1 }
                    int v864 = LODWORD(_Q0.f64[0]);
                    *(void *)long long buf = vcvtq_f32_f16(*(float16x4_t *)&_Q0.f64[0]).u64[0];
                    __asm { FCVT            S0, H9 }
                    *(_DWORD *)&uint8_t buf[8] = _S0;
                    *(float *)&unsigned char buf[12] = _S8;
                    long long v314 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::StyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,md::DaVinciGroundRenderLayer::StyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::StyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::StyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,std::equal_to<md::DaVinciGroundRenderLayer::StyleCacheKey>,md::DaVinciGroundRenderLayer::StyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>>>::find<md::DaVinciGroundRenderLayer::StyleCacheKey>(v848, (float *)buf);
                    if (v314)
                    {
                      uint64_t v316 = v314[4];
                      uint64_t v218 = v885;
                    }
                    else
                    {
                      uint64_t v317 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::Style>>::pop(*(void *)(a1 + 1704));
                      uint64_t v316 = v317;
                      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
                      unint64_t v318 = *(void *)(v317 + 8);
                      if (v318) {
                        uint64_t v319 = *(void *)(v317 + 72);
                      }
                      else {
                        uint64_t v319 = 0;
                      }
                      *(void *)&_Q0 = 0;
                      *((void *)&_Q0 + 1) = v317;
                      long long v857 = _Q0;
                      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = _Q0;
                      __p.__r_.__value_.__r.__words[2] = 0;
                      *(void *)uint64_t v972 = v318;
                      *(void *)&v972[16] = v319;
                      *(_WORD *)&v972[8] = 1;
                      __asm { FCVT            H0, S8 }
                      *(_DWORD *)uint64_t v319 = v864;
                      *(_WORD *)(v319 + 4) = _H9;
                      *(_WORD *)(v319 + 6) = _Q0;
                      std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::StyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,md::DaVinciGroundRenderLayer::StyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::StyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::StyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>,std::equal_to<md::DaVinciGroundRenderLayer::StyleCacheKey>,md::DaVinciGroundRenderLayer::StyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::StyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::Style> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::StyleCacheKey,md::DaVinciGroundRenderLayer::StyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::Style> *&>(v848, (float *)buf, buf, v317);
                      unint64_t v309 = (float *)(a3 + 20);
                      uint64_t v218 = v885;
                      if (v318)
                      {
                        v315.i32[3] = HIDWORD(v857);
                        if ((void)v857 && *(unsigned char *)(*((void *)&v857 + 1) + 17) != 2) {
                          (*(void (**)(void))(*(void *)v857 + 64))();
                        }
                        unint64_t v321 = *(void *)(*((void *)&v857 + 1) + 64);
                        if (v321 <= v318) {
                          unint64_t v321 = v318;
                        }
                        *(void *)(*((void *)&v857 + 1) + 56) = 0;
                        *(void *)(*((void *)&v857 + 1) + 64) = v321;
                      }
                    }
                    uint64_t v322 = *((void *)v909 + 8);
                    *(void *)(v322 + 80) = v316;
                    *(void *)(v322 + 88) = 0;
                    uint64_t v323 = *((void *)v909 + 20);
                    uint64_t v324 = *(std::__shared_weak_count **)(v323 + 88);
                    *(void *)(v323 + 80) = 0;
                    *(void *)(v323 + 88) = 0;
                    if (v324 && !atomic_fetch_add(&v324->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v324->__on_zero_shared)(v324);
                      std::__shared_weak_count::__release_weak(v324);
                    }
                    a7 = v849;
                    a8 = v850;
                    if (!v887) {
                      goto LABEL_547;
                    }
                    uint64_t v325 = *(std::__shared_weak_count **)(v218 + 232);
                    uint64_t v920 = *(void *)(v218 + 224);
                    uint64_t v921 = v325;
                    if (v325) {
                      atomic_fetch_add_explicit(&v325->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    uint64_t v326 = md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_1::operator()(v961, &v958);
                    uint64_t v327 = *((void *)v909 + 8);
                    *(void *)(v327 + 256) = v326;
                    *(void *)(v327 + 264) = 0;
                    uint64_t v328 = *((void *)v909 + 20);
                    uint64_t v329 = *(std::__shared_weak_count **)(v328 + 264);
                    *(void *)(v328 + 256) = 0;
                    *(void *)(v328 + 264) = 0;
                    if (v329 && !atomic_fetch_add(&v329->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v329->__on_zero_shared)(v329);
                      std::__shared_weak_count::__release_weak(v329);
                    }
                    uint64_t v330 = v921;
                    if (v921 && !atomic_fetch_add(&v921->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v330->__on_zero_shared)(v330);
                      std::__shared_weak_count::__release_weak(v330);
                      if (v879)
                      {
LABEL_548:
                        uint64_t v331 = *(std::__shared_weak_count **)(v218 + 232);
                        uint64_t v918 = *(void *)(v218 + 224);
                        v919 = v331;
                        if (v331) {
                          atomic_fetch_add_explicit(&v331->__shared_owners_, 1uLL, memory_order_relaxed);
                        }
                        uint64_t v332 = md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_2::operator()((uint64_t)v960, (uint64_t)&v918, &v958);
                        uint64_t v333 = *((void *)v909 + 8);
                        *(void *)(v333 + 240) = v332;
                        *(void *)(v333 + 248) = 0;
                        uint64_t v334 = *((void *)v909 + 20);
                        uint64_t v335 = *(std::__shared_weak_count **)(v334 + 248);
                        *(void *)(v334 + 240) = 0;
                        *(void *)(v334 + 248) = 0;
                        if (v335 && !atomic_fetch_add(&v335->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v335->__on_zero_shared)(v335);
                          std::__shared_weak_count::__release_weak(v335);
                        }
                        uint64_t v336 = v919;
                        if (v919 && !atomic_fetch_add(&v919->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                        {
                          ((void (*)(std::__shared_weak_count *))v336->__on_zero_shared)(v336);
                          std::__shared_weak_count::__release_weak(v336);
                        }
                      }
                    }
                    else
                    {
LABEL_547:
                      if (v879) {
                        goto LABEL_548;
                      }
                    }
                    *(void *)(*((void *)v909 + 12) + 16) = v882;
                    if (v877) {
                      *(void *)(*((void *)v909 + 12) + 40) = v868;
                    }
                    int v337 = *(unsigned __int8 *)(v218 + 396);
                    if (*(unsigned char *)(v218 + 396))
                    {
                      v315.i64[0] = *(void *)(v218 + 380);
                      v315.i32[2] = *(_DWORD *)(v218 + 388);
                      float32x4_t v841 = v315;
                      float v844 = *(float *)(v218 + 392);
                    }
                    else
                    {
                      float32x4_t v338 = v841;
                      v338.i8[0] = 0;
                      float32x4_t v841 = v338;
                    }
                    float v339 = *v309;
                    uint64_t v341 = *(void *)(v218 + 224);
                    uint64_t v340 = *(std::__shared_weak_count **)(v218 + 232);
                    uint64_t v916 = v341;
                    v917 = v340;
                    if (v340) {
                      atomic_fetch_add_explicit(&v340->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    (*(void (**)(unsigned char *__return_ptr, uint64_t, float))(*(void *)v341 + 976))(v910, v341, v339);
                    (*(void (**)(int8x16_t *__return_ptr, uint64_t, float))(*(void *)v341 + 928))(&v969, v341, v339);
                    if (v910[0])
                    {
                      buf[0] = 0;
                      goto LABEL_567;
                    }
                    (*(void (**)(unsigned char *__return_ptr, uint64_t, float))(*(void *)v341 + 232))(buf, v341, v339);
                    if (v910[0])
                    {
LABEL_567:
                      float v344 = *(float *)&v969.i32[1];
                      if (!v969.i8[0]) {
                        float v344 = 1.0;
                      }
                      v345.i64[0] = *(void *)&v910[4];
                      v345.i64[1] = __PAIR64__(LODWORD(v344), *(unsigned int *)&v910[12]);
                      if (v337)
                      {
LABEL_570:
                        float32x4_t v346 = vmlaq_n_f32(v345, vsubq_f32(v841, v345), v844);
                        v346.i32[3] = v345.i32[3];
                        float32x4_t v345 = v346;
                      }
                    }
                    else
                    {
                      v342.i32[0] = 0;
                      v343.i8[0] = buf[0];
                      float32x4_t v345 = (float32x4_t)vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v343, v342), 0), v839, *(int8x16_t *)&buf[4]);
                      if (v337) {
                        goto LABEL_570;
                      }
                    }
                    float32x4_t v888 = v345;
                    *(float32x4_t *)&__p.__r_.__value_.__l.__data_ = v345;
                    __p.__r_.__value_.__s.__data_[16] = 1;
                    uint64_t v347 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::find<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>(v847, (float *)&__p);
                    if (v347)
                    {
                      uint64_t v348 = *(void *)(v347 + 40);
                    }
                    else
                    {
                      uint64_t v349 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleColor>>::pop(*(void *)(a1 + 1960));
                      uint64_t v348 = v349;
                      unint64_t v350 = *(void *)(v349 + 8);
                      **(float16x4_t **)(v349 + 72) = vcvt_f16_f32(v888);
                      if (*(void *)(v349 + 64) > v350) {
                        unint64_t v350 = *(void *)(v349 + 64);
                      }
                      *(void *)(v349 + 56) = 0;
                      *(void *)(v349 + 64) = v350;
                      std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleColor> *&>(v847, (unsigned int *)&__p, (uint64_t)&__p, v349);
                    }
                    uint64_t v351 = *((void *)v909 + 8);
                    *(void *)(v351 + 448) = v348;
                    *(void *)(v351 + 456) = 0;
                    uint64_t v352 = *((void *)v909 + 20);
                    uint64_t v353 = *(std::__shared_weak_count **)(v352 + 456);
                    *(void *)(v352 + 448) = 0;
                    *(void *)(v352 + 456) = 0;
                    if (v353 && !atomic_fetch_add(&v353->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v353->__on_zero_shared)(v353);
                      std::__shared_weak_count::__release_weak(v353);
                    }
                    long long v354 = v917;
                    if (v917 && !atomic_fetch_add(&v917->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v354->__on_zero_shared)(v354);
                      std::__shared_weak_count::__release_weak(v354);
                    }
                    unint64_t v355 = (unsigned char *)*((void *)v909 + 2);
                    if (v355[317])
                    {
                      uint64_t v356 = *((void *)v909 + 8);
                      *(void *)(v356 + 232) = 0;
                      uint64_t v357 = v900[42];
                      *(void *)(v356 + 224) = v357;
                      uint64_t v358 = *((void *)v909 + 20);
                      uint64_t v359 = v900[43];
                      if (v359) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v359 + 8), 1uLL, memory_order_relaxed);
                      }
                      long long v360 = *(std::__shared_weak_count **)(v358 + 232);
                      *(void *)(v358 + 224) = v357;
                      *(void *)(v358 + 232) = v359;
                      if (v360 && !atomic_fetch_add(&v360->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v360->__on_zero_shared)(v360);
                        std::__shared_weak_count::__release_weak(v360);
                      }
                      unint64_t v355 = (unsigned char *)*((void *)v909 + 2);
                    }
                    if (v355[331])
                    {
                      uint64_t v361 = *((void *)v909 + 8);
                      *(void *)(v361 + 120) = 0;
                      uint64_t v362 = *(void *)(a1 + 1832);
                      *(void *)(v361 + 112) = v362;
                      uint64_t v363 = *((void *)v909 + 20);
                      uint64_t v364 = *(void *)(a1 + 1840);
                      if (v364) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v364 + 8), 1uLL, memory_order_relaxed);
                      }
                      uint64_t v365 = *(std::__shared_weak_count **)(v363 + 120);
                      *(void *)(v363 + 112) = v362;
                      *(void *)(v363 + 120) = v364;
                      if (v365 && !atomic_fetch_add(&v365->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v365->__on_zero_shared)(v365);
                        std::__shared_weak_count::__release_weak(v365);
                      }
                      unint64_t v355 = (unsigned char *)*((void *)v909 + 2);
                    }
                    if (v355[330])
                    {
                      uint64_t v366 = *((void *)v909 + 8);
                      *(void *)(v366 + 104) = 0;
                      uint64_t v367 = *(void *)(a1 + 1816);
                      *(void *)(v366 + 96) = v367;
                      uint64_t v368 = *((void *)v909 + 20);
                      uint64_t v369 = *(void *)(a1 + 1824);
                      if (v369) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v369 + 8), 1uLL, memory_order_relaxed);
                      }
                      uint64_t v370 = *(std::__shared_weak_count **)(v368 + 104);
                      *(void *)(v368 + 96) = v367;
                      *(void *)(v368 + 104) = v369;
                      if (v370 && !atomic_fetch_add(&v370->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v370->__on_zero_shared)(v370);
                        std::__shared_weak_count::__release_weak(v370);
                      }
                    }
                    if (*(unsigned char *)(*((void *)v909 + 2) + 326))
                    {
                      uint64_t v371 = *((void *)v909 + 8);
                      *(void *)(v371 + 200) = 0;
                      uint64_t v372 = *(void *)(v898 + 32);
                      *(void *)(v371 + 192) = v372;
                      uint64_t v373 = *((void *)v909 + 20);
                      uint64_t v374 = *(void *)(v898 + 40);
                      if (v374) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v374 + 8), 1uLL, memory_order_relaxed);
                      }
                      uint64_t v375 = *(std::__shared_weak_count **)(v373 + 200);
                      *(void *)(v373 + 192) = v372;
                      *(void *)(v373 + 200) = v374;
                      if (v375 && !atomic_fetch_add(&v375->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v375->__on_zero_shared)(v375);
                        std::__shared_weak_count::__release_weak(v375);
                      }
                    }
                    uint64_t v376 = *((void *)v909 + 8);
                    *(void *)(v376 + 56) = 0;
                    uint64_t v377 = *(void *)(v898 + 16);
                    *(void *)(v376 + 48) = v377;
                    uint64_t v378 = *((void *)v909 + 20);
                    uint64_t v379 = *(void *)(v898 + 24);
                    if (v379) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v379 + 8), 1uLL, memory_order_relaxed);
                    }
                    uint64_t v380 = *(std::__shared_weak_count **)(v378 + 56);
                    *(void *)(v378 + 48) = v377;
                    *(void *)(v378 + 56) = v379;
                    if (v380 && !atomic_fetch_add(&v380->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v380->__on_zero_shared)(v380);
                      std::__shared_weak_count::__release_weak(v380);
                    }
                    uint64_t v381 = *(uint64_t **)(v218 + 32);
                    unint64_t v382 = (uint64_t *)*((void *)v909 + 4);
                    v382[1] = 0;
                    uint64_t v383 = *v381;
                    *unint64_t v382 = *v381;
                    uint64_t v384 = (void *)*((void *)v909 + 16);
                    uint64_t v385 = v381[1];
                    if (v385) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v385 + 8), 1uLL, memory_order_relaxed);
                    }
                    float64x2_t v386 = (std::__shared_weak_count *)v384[1];
                    void *v384 = v383;
                    v384[1] = v385;
                    if (v386 && !atomic_fetch_add(&v386->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v386->__on_zero_shared)(v386);
                      std::__shared_weak_count::__release_weak(v386);
                    }
                    uint64_t v387 = (void *)*((void *)v909 + 8);
                    v387[1] = 0;
                    uint64_t v388 = *(void *)(a5 + 216);
                    *uint64_t v387 = v388;
                    uint64_t v389 = (void *)*((void *)v909 + 20);
                    uint64_t v390 = *(void *)(a5 + 224);
                    if (v390) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v390 + 8), 1uLL, memory_order_relaxed);
                    }
                    uint64_t v391 = (std::__shared_weak_count *)v389[1];
                    *uint64_t v389 = v388;
                    v389[1] = v390;
                    if (v391 && !atomic_fetch_add(&v391->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v391->__on_zero_shared)(v391);
                      std::__shared_weak_count::__release_weak(v391);
                    }
                    uint64_t v392 = *((void *)v909 + 8);
                    *(void *)(v392 + 168) = 0;
                    uint64_t v393 = *(void *)(a5 + 448);
                    *(void *)(v392 + 160) = v393;
                    uint64_t v394 = *((void *)v909 + 20);
                    uint64_t v395 = *(void *)(a5 + 456);
                    if (v395) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v395 + 8), 1uLL, memory_order_relaxed);
                    }
                    uint64_t v396 = *(std::__shared_weak_count **)(v394 + 168);
                    *(void *)(v394 + 160) = v393;
                    *(void *)(v394 + 168) = v395;
                    if (v396 && !atomic_fetch_add(&v396->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v396->__on_zero_shared)(v396);
                      std::__shared_weak_count::__release_weak(v396);
                    }
                    uint64_t v397 = *((void *)v909 + 8);
                    *(void *)(v397 + 24) = 0;
                    uint64_t v398 = *(void *)(a5 + 232);
                    *(void *)(v397 + 16) = v398;
                    uint64_t v399 = *((void *)v909 + 20);
                    uint64_t v400 = *(void *)(a5 + 240);
                    if (v400) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v400 + 8), 1uLL, memory_order_relaxed);
                    }
                    uint64_t v401 = *(std::__shared_weak_count **)(v399 + 24);
                    *(void *)(v399 + 16) = v398;
                    *(void *)(v399 + 24) = v400;
                    if (v401 && !atomic_fetch_add(&v401->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v401->__on_zero_shared)(v401);
                      std::__shared_weak_count::__release_weak(v401);
                    }
                    uint64_t v402 = v909;
                    if (*(unsigned char *)(a3 + 6))
                    {
                      uint64_t v403 = *((void *)v909 + 8);
                      *(void *)(v403 + 40) = 0;
                      uint64_t v404 = *(void *)(a5 + 400);
                      *(void *)(v403 + 32) = v404;
                      uint64_t v405 = *((void *)v909 + 20);
                      uint64_t v406 = *(void *)(a5 + 408);
                      if (v406) {
                        atomic_fetch_add_explicit((atomic_ullong *volatile)(v406 + 8), 1uLL, memory_order_relaxed);
                      }
                      uint64_t v407 = *(std::__shared_weak_count **)(v405 + 40);
                      *(void *)(v405 + 32) = v404;
                      *(void *)(v405 + 40) = v406;
                      if (v407 && !atomic_fetch_add(&v407->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v407->__on_zero_shared)(v407);
                        std::__shared_weak_count::__release_weak(v407);
                      }
                      uint64_t v408 = v900[12];
                      if (v408)
                      {
                        unint64_t v409 = *(void *)(v408 + 32);
                        uint64_t v410 = *(void *)(v900[1] + 96);
                        if (v409 >= (*(void *)(v900[1] + 104) - v410) >> 3) {
                          uint64_t v408 = 0;
                        }
                        else {
                          uint64_t v408 = *(void *)(*(void *)(v410 + 8 * v409) + 16);
                        }
                      }
                      uint64_t v402 = v909;
                      *(void *)(*((void *)v909 + 12) + 8) = v408;
                    }
                    uint64_t v411 = *((void *)v402 + 8);
                    *(void *)(v411 + 216) = 0;
                    uint64_t v412 = v900[40];
                    *(void *)(v411 + 208) = v412;
                    uint64_t v413 = *((void *)v402 + 20);
                    uint64_t v414 = v900[41];
                    if (v414) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v414 + 8), 1uLL, memory_order_relaxed);
                    }
                    uint64_t v415 = *(std::__shared_weak_count **)(v413 + 216);
                    *(void *)(v413 + 208) = v412;
                    *(void *)(v413 + 216) = v414;
                    if (v415 && !atomic_fetch_add(&v415->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v415->__on_zero_shared)(v415);
                      std::__shared_weak_count::__release_weak(v415);
                    }
                    **((void **)v909 + 12) = *(void *)(a3 + 280);
                    uint64_t v416 = *((void *)v909 + 8);
                    uint64_t v417 = v956;
                    float v418 = v957;
                    *(void *)(v416 + 176) = v956;
                    *(void *)(v416 + 184) = 0;
                    uint64_t v419 = *((void *)v909 + 20);
                    if (v418) {
                      atomic_fetch_add_explicit(&v418->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    unsigned int v420 = *(std::__shared_weak_count **)(v419 + 184);
                    *(void *)(v419 + 176) = v417;
                    *(void *)(v419 + 184) = v418;
                    if (v420 && !atomic_fetch_add(&v420->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v420->__on_zero_shared)(v420);
                      std::__shared_weak_count::__release_weak(v420);
                    }
                    uint64_t v421 = *((void *)v909 + 8);
                    uint64_t v422 = v956;
                    unint64_t v423 = v957;
                    *(void *)(v421 + 176) = v956;
                    *(void *)(v421 + 184) = 0;
                    uint64_t v424 = *((void *)v909 + 20);
                    if (v423) {
                      atomic_fetch_add_explicit(&v423->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    uint64_t v425 = *(std::__shared_weak_count **)(v424 + 184);
                    *(void *)(v424 + 176) = v422;
                    *(void *)(v424 + 184) = v423;
                    if (v425 && !atomic_fetch_add(&v425->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v425->__on_zero_shared)(v425);
                      std::__shared_weak_count::__release_weak(v425);
                    }
                    md::DaVinciGroundRenderLayer::setupDaVinciGroundTileDataBindings<ggl::DaVinci::GroundNonCompressedPipelineSetup>((uint64_t)v909, v218);
                    if (v876)
                    {
                      unint64_t v428 = v964;
                      if (!v964) {
                        goto LABEL_798;
                      }
                      uint64_t v429 = *(void **)(v963 + 1304);
                      unint64_t v430 = v429[1];
                      if (!v430) {
                        goto LABEL_798;
                      }
                      *(int8x8_t *)_Q0.i8 = vcnt_s8((int8x8_t)v430);
                      _Q0.i16[0] = vaddlv_u8(*(uint8x8_t *)_Q0.i8);
                      if (_Q0.u32[0] > 1uLL)
                      {
                        unint64_t v431 = v964;
                        if (v430 <= v964) {
                          unint64_t v431 = v964 % v430;
                        }
                      }
                      else
                      {
                        unint64_t v431 = (v430 - 1) & (unint64_t)v964;
                      }
                      unint64_t v471 = *(uint64_t ***)(*v429 + 8 * v431);
                      if (!v471) {
                        goto LABEL_798;
                      }
                      v472 = *v471;
                      if (!v472) {
                        goto LABEL_798;
                      }
                      if (_Q0.u32[0] < 2uLL)
                      {
                        unint64_t v473 = v430 - 1;
                        while (1)
                        {
                          uint64_t v474 = v472[1];
                          if (v474 == v964)
                          {
                            if (*((_DWORD *)v472 + 4) == v964) {
                              goto LABEL_794;
                            }
                          }
                          else if ((v474 & v473) != v431)
                          {
                            goto LABEL_798;
                          }
                          v472 = (uint64_t *)*v472;
                          if (!v472) {
                            goto LABEL_798;
                          }
                        }
                      }
                      while (1)
                      {
                        unint64_t v475 = v472[1];
                        if (v475 == v964)
                        {
                          if (*((_DWORD *)v472 + 4) == v964)
                          {
LABEL_794:
                            if (v472[3])
                            {
                              uint64_t v491 = md::DaVinciGroundRenderResources::debugTextureForAttribute(v837, v964);
                              int8x8_t v492 = (int8x8_t)v429[1];
                              if (!*(void *)&v492) {
                                goto LABEL_1344;
                              }
                              *(int8x8_t *)_Q0.i8 = vcnt_s8(v492);
                              _Q0.i16[0] = vaddlv_u8(*(uint8x8_t *)_Q0.i8);
                              if (_Q0.u32[0] > 1uLL)
                              {
                                unint64_t v493 = v428;
                                if (*(void *)&v492 <= v428) {
                                  unint64_t v493 = v428 % *(void *)&v492;
                                }
                              }
                              else
                              {
                                unint64_t v493 = (v492.i32[0] - 1) & v428;
                              }
                              int v816 = *(uint64_t ***)(*v429 + 8 * v493);
                              if (!v816 || (long long v817 = *v816) == 0)
                              {
LABEL_1344:
                                uint64_t v495 = 0;
                                float v497 = 255.0;
                                uint64_t v496 = v491;
                                goto LABEL_808;
                              }
                              if (_Q0.u32[0] < 2uLL)
                              {
                                uint64_t v818 = *(void *)&v492 - 1;
                                while (1)
                                {
                                  uint64_t v820 = v817[1];
                                  if (v820 == v428)
                                  {
                                    if (*((_DWORD *)v817 + 4) == v428) {
                                      goto LABEL_1343;
                                    }
                                  }
                                  else if ((v820 & v818) != v493)
                                  {
                                    goto LABEL_1344;
                                  }
                                  long long v817 = (uint64_t *)*v817;
                                  if (!v817) {
                                    goto LABEL_1364;
                                  }
                                }
                              }
                              while (1)
                              {
                                unint64_t v819 = v817[1];
                                if (v819 == v428)
                                {
                                  if (*((_DWORD *)v817 + 4) == v428)
                                  {
LABEL_1343:
                                    uint64_t v496 = v491;
                                    uint64_t v495 = v817[3];
LABEL_802:
                                    float v497 = 255.0;
                                    goto LABEL_808;
                                  }
                                }
                                else
                                {
                                  if (v819 >= *(void *)&v492) {
                                    v819 %= *(void *)&v492;
                                  }
                                  if (v819 != v493) {
                                    goto LABEL_1344;
                                  }
                                }
                                long long v817 = (uint64_t *)*v817;
                                if (!v817)
                                {
LABEL_1364:
                                  float v497 = 255.0;
                                  uint64_t v495 = 0;
                                  uint64_t v496 = v491;
                                  goto LABEL_808;
                                }
                              }
                            }
LABEL_798:
                            if (!v858)
                            {
                              uint64_t v495 = 0;
                              uint64_t v496 = 0;
                              goto LABEL_802;
                            }
                            if (*(unsigned char *)(v858 + 122))
                            {
                              uint64_t v494 = *(void *)(v858 + 32);
                              md::StyleTexture<md::LowZoomClimateStyle>::_processStylePixelsIfNecessary(v494);
                            }
                            else
                            {
                              uint64_t v494 = *(void *)(v858 + 16);
                              md::StyleTexture<md::LowZoomStyle>::_processStylePixelsIfNecessary(v494);
                            }
                            uint64_t v496 = *(void *)(v494 + 24);
                            uint64_t v495 = *(void *)v858;
                            int v498 = *(std::__shared_weak_count **)(v858 + 8);
                            if (v498)
                            {
                              atomic_fetch_add_explicit(&v498->__shared_owners_, 1uLL, memory_order_relaxed);
                              if (!atomic_fetch_add(&v498->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v498->__on_zero_shared)(v498);
                                std::__shared_weak_count::__release_weak(v498);
                              }
                            }
                            _Q0.i16[0] = *(_WORD *)(v858 + 120);
                            float v497 = (float)_Q0.u32[0];
LABEL_808:
                            uint64_t v499 = v909;
                            uint64_t v500 = *(void *)(*((void *)v909 + 8) + 272);
                            if (!v500)
                            {
                              unint64_t v501 = (std::__shared_weak_count *)operator new(0xE8uLL);
                              v501->__shared_owners_ = 0;
                              v501->__shared_weak_owners_ = 0;
                              v501->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587528;
                              uint64_t v502 = ggl::BufferData::BufferData((uint64_t)&v501[1], qword_1E955BA40, 2, 1, 6, 1);
                              v501[9].__shared_owners_ = (uint64_t)ggl::DaVinci::LandCoverSettings::reflection(void)::reflection;
                              v501[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55E718;
                              uint64_t v503 = *((void *)v909 + 8);
                              *(void *)(v503 + 272) = v502;
                              *(void *)(v503 + 280) = 0;
                              uint64_t v504 = *((void *)v909 + 20);
                              atomic_fetch_add_explicit(&v501->__shared_owners_, 1uLL, memory_order_relaxed);
                              uint64_t v505 = *(std::__shared_weak_count **)(v504 + 280);
                              *(void *)(v504 + 272) = v502;
                              *(void *)(v504 + 280) = v501;
                              if (v505 && !atomic_fetch_add(&v505->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v505->__on_zero_shared)(v505);
                                std::__shared_weak_count::__release_weak(v505);
                              }
                              if (!atomic_fetch_add(&v501->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v501->__on_zero_shared)(v501);
                                std::__shared_weak_count::__release_weak(v501);
                              }
                              uint64_t v499 = v909;
                              uint64_t v500 = *(void *)(*((void *)v909 + 8) + 272);
                              unint64_t v309 = (float *)(a3 + 20);
                            }
                            unint64_t v506 = *(void *)(v500 + 8);
                            **(float **)(v500 + 72) = v497;
                            *(void *)(*((void *)v499 + 12) + 56) = v495;
                            *(void *)(*((void *)v499 + 12) + 64) = v496;
                            if (*(void *)(v500 + 64) > v506) {
                              unint64_t v506 = *(void *)(v500 + 64);
                            }
                            *(void *)(v500 + 56) = 0;
                            *(void *)(v500 + 64) = v506;
                            if (!updated)
                            {
LABEL_818:
                              uint64_t v507 = 0;
                              *(void *)(*((void *)v909 + 12) + 80) = 0;
                              goto LABEL_867;
                            }
LABEL_668:
                            float v435 = *(void **)(v963 + 1304);
                            if (v966)
                            {
                              int8x8_t v436 = (int8x8_t)v435[1];
                              if (v436)
                              {
                                *(int8x8_t *)_Q0.i8 = vcnt_s8(v436);
                                _Q0.i16[0] = vaddlv_u8(*(uint8x8_t *)_Q0.i8);
                                if (_Q0.u32[0] > 1uLL) {
                                  uint64_t v437 = *(void *)&v436 <= 0x99uLL ? 0x99uLL % *(void *)&v436 : 153;
                                }
                                else {
                                  uint64_t v437 = (v436.i32[0] - 1) & 0x99;
                                }
                                char v482 = *(uint64_t ***)(*v435 + 8 * v437);
                                if (v482)
                                {
                                  uint64_t v483 = *v482;
                                  if (v483)
                                  {
                                    if (_Q0.u32[0] < 2uLL)
                                    {
                                      uint64_t v484 = *(void *)&v436 - 1;
                                      while (1)
                                      {
                                        uint64_t v486 = v483[1];
                                        if (v486 == 153)
                                        {
                                          if (*((_DWORD *)v483 + 4) == 153) {
                                            goto LABEL_819;
                                          }
                                        }
                                        else if ((v486 & v484) != v437)
                                        {
                                          goto LABEL_820;
                                        }
                                        uint64_t v483 = (uint64_t *)*v483;
                                        if (!v483) {
                                          goto LABEL_820;
                                        }
                                      }
                                    }
                                    do
                                    {
                                      unint64_t v485 = v483[1];
                                      if (v485 == 153)
                                      {
                                        if (*((_DWORD *)v483 + 4) == 153)
                                        {
LABEL_819:
                                          uint64_t v508 = v483[3];
                                          if (!v508) {
                                            break;
                                          }
LABEL_831:
                                          *(void *)(*((void *)v909 + 12) + 80) = v508;
                                          if (!v965
                                            || (int8x8_t v514 = (int8x8_t)v435[1], !*(void *)&v514)
                                            || ((*(int8x8_t *)_Q0.i8 = vcnt_s8(v514),
                                                 _Q0.i16[0] = vaddlv_u8(*(uint8x8_t *)_Q0.i8),
                                                 _Q0.u32[0] > 1uLL)
                                              ? (*(void *)&v514 <= 0x9AuLL
                                               ? (uint64_t v515 = 0x9AuLL % *(void *)&v514)
                                               : (uint64_t v515 = 154))
                                              : (uint64_t v515 = (v514.i32[0] - 1) & 0x9ALL),
                                                (double v516 = *(uint64_t ***)(*v435 + 8 * v515)) == 0
                                             || (uint64_t v517 = *v516) == 0))
                                          {
LABEL_856:
                                            uint64_t v521 = a1 + 3248;
                                            uint64_t v522 = *v861;
                                            if (!*v861) {
                                              goto LABEL_866;
                                            }
                                            do
                                            {
                                              unsigned int v523 = *(_DWORD *)(v522 + 32);
                                              BOOL v524 = v523 >= 0x9A;
                                              if (v523 >= 0x9A) {
                                                double v525 = (uint64_t *)v522;
                                              }
                                              else {
                                                double v525 = (uint64_t *)(v522 + 8);
                                              }
                                              if (v524) {
                                                uint64_t v521 = v522;
                                              }
                                              uint64_t v522 = *v525;
                                            }
                                            while (*v525);
                                            if ((uint64_t *)v521 != v861 && *(_DWORD *)(v521 + 32) <= 0x9Au) {
                                              uint64_t v507 = *(void *)(v521 + 40);
                                            }
                                            else {
LABEL_866:
                                            }
                                              uint64_t v507 = 0;
                                            goto LABEL_867;
                                          }
                                          if (_Q0.u32[0] < 2uLL)
                                          {
                                            uint64_t v518 = *(void *)&v514 - 1;
                                            while (1)
                                            {
                                              uint64_t v520 = v517[1];
                                              if (v520 == 154)
                                              {
                                                if (*((_DWORD *)v517 + 4) == 154) {
                                                  goto LABEL_855;
                                                }
                                              }
                                              else if ((v520 & v518) != v515)
                                              {
                                                goto LABEL_856;
                                              }
                                              uint64_t v517 = (uint64_t *)*v517;
                                              if (!v517) {
                                                goto LABEL_856;
                                              }
                                            }
                                          }
                                          while (1)
                                          {
                                            unint64_t v519 = v517[1];
                                            if (v519 == 154)
                                            {
                                              if (*((_DWORD *)v517 + 4) == 154)
                                              {
LABEL_855:
                                                uint64_t v507 = v517[3];
                                                if (!v507) {
                                                  goto LABEL_856;
                                                }
LABEL_867:
                                                *(void *)(*((void *)v909 + 12) + 72) = v507;
                                                if (v874)
                                                {
                                                  long long v915 = v939;
                                                  if (*((void *)&v939 + 1)) {
                                                    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v939 + 1) + 8), 1uLL, memory_order_relaxed);
                                                  }
                                                  uint64_t v526 = md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_3::operator()(v959, &v938, (uint64_t)v865);
                                                  uint64_t v527 = *((void *)v909 + 8);
                                                  *(void *)(v527 + 352) = v526;
                                                  *(void *)(v527 + 360) = 0;
                                                  uint64_t v528 = *((void *)v909 + 20);
                                                  uint64_t v529 = *(std::__shared_weak_count **)(v528 + 360);
                                                  *(void *)(v528 + 352) = 0;
                                                  *(void *)(v528 + 360) = 0;
                                                  if (v529
                                                    && !atomic_fetch_add(&v529->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v529->__on_zero_shared)(v529);
                                                    std::__shared_weak_count::__release_weak(v529);
                                                  }
                                                  uint64_t v530 = (std::__shared_weak_count *)*((void *)&v915 + 1);
                                                  if (*((void *)&v915 + 1)
                                                    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v915 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v530->__on_zero_shared)(v530);
                                                    std::__shared_weak_count::__release_weak(v530);
                                                  }
                                                  uint64_t v531 = md::LayoutContext::frameState(a2);
                                                  md::SharedResource::addFrameRef(v865, *(void *)(v531 + 624));
                                                  *(void *)(*((void *)v909 + 12) + 88) = *((void *)v865 + 4);
                                                  if (!v866) {
                                                    goto LABEL_898;
                                                  }
                                                  long long v914 = v939;
                                                  if (*((void *)&v939 + 1)) {
                                                    atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v939 + 1) + 8), 1uLL, memory_order_relaxed);
                                                  }
                                                  uint64_t v532 = md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_3::operator()(v959, &v938, (uint64_t)v852);
                                                  uint64_t v533 = *((void *)v909 + 8);
                                                  *(void *)(v533 + 368) = v532;
                                                  *(void *)(v533 + 376) = 0;
                                                  uint64_t v534 = *((void *)v909 + 20);
                                                  uint64_t v535 = *(std::__shared_weak_count **)(v534 + 376);
                                                  *(void *)(v534 + 368) = 0;
                                                  *(void *)(v534 + 376) = 0;
                                                  if (v535
                                                    && !atomic_fetch_add(&v535->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v535->__on_zero_shared)(v535);
                                                    std::__shared_weak_count::__release_weak(v535);
                                                  }
                                                  uint64_t v536 = (std::__shared_weak_count *)*((void *)&v914 + 1);
                                                  if (*((void *)&v914 + 1)
                                                    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v914 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v536->__on_zero_shared)(v536);
                                                    std::__shared_weak_count::__release_weak(v536);
                                                  }
                                                  uint64_t v537 = md::LayoutContext::frameState(a2);
                                                  md::SharedResource::addFrameRef(v852, *(void *)(v537 + 624));
                                                  *(void *)(*((void *)v909 + 12) + 96) = *((void *)v852 + 4);
                                                  uint64_t v538 = *((void *)v909 + 8);
                                                  *(void *)(v538 + 392) = 0;
                                                  uint64_t v539 = *(void *)(a1 + 2032);
                                                  *(void *)(v538 + 384) = v539;
                                                  uint64_t v540 = *((void *)v909 + 20);
                                                  uint64_t v541 = *(void *)(a1 + 2040);
                                                  if (v541) {
                                                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v541 + 8), 1uLL, memory_order_relaxed);
                                                  }
                                                  double v542 = *(std::__shared_weak_count **)(v540 + 392);
                                                  *(void *)(v540 + 384) = v539;
                                                  *(void *)(v540 + 392) = v541;
                                                  if (!v542) {
                                                    goto LABEL_898;
                                                  }
LABEL_896:
                                                  if (!atomic_fetch_add(&v542->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v542->__on_zero_shared)(v542);
                                                    std::__shared_weak_count::__release_weak(v542);
                                                  }
                                                  goto LABEL_898;
                                                }
                                                uint64_t v543 = *((void *)v909 + 8);
                                                *(void *)(v543 + 352) = 0;
                                                *(void *)(v543 + 360) = 0;
                                                uint64_t v544 = *((void *)v909 + 20);
                                                uint64_t v545 = *(std::__shared_weak_count **)(v544 + 360);
                                                *(void *)(v544 + 352) = 0;
                                                *(void *)(v544 + 360) = 0;
                                                if (v545
                                                  && !atomic_fetch_add(&v545->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v545->__on_zero_shared)(v545);
                                                  std::__shared_weak_count::__release_weak(v545);
                                                }
                                                *(void *)(*((void *)v909 + 12) + 88) = 0;
                                                uint64_t v546 = *((void *)v909 + 8);
                                                *(void *)(v546 + 368) = 0;
                                                *(void *)(v546 + 376) = 0;
                                                uint64_t v547 = *((void *)v909 + 20);
                                                double v548 = *(std::__shared_weak_count **)(v547 + 376);
                                                *(void *)(v547 + 368) = 0;
                                                *(void *)(v547 + 376) = 0;
                                                if (v548
                                                  && !atomic_fetch_add(&v548->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v548->__on_zero_shared)(v548);
                                                  std::__shared_weak_count::__release_weak(v548);
                                                }
                                                *(void *)(*((void *)v909 + 12) + 96) = 0;
                                                uint64_t v549 = *((void *)v909 + 8);
                                                *(void *)(v549 + 384) = 0;
                                                *(void *)(v549 + 392) = 0;
                                                uint64_t v550 = *((void *)v909 + 20);
                                                double v542 = *(std::__shared_weak_count **)(v550 + 392);
                                                *(void *)(v550 + 384) = 0;
                                                *(void *)(v550 + 392) = 0;
                                                if (v542) {
                                                  goto LABEL_896;
                                                }
LABEL_898:
                                                float v551 = *(float *)(v899 + 20);
                                                if (*(unsigned char *)(v218 + 145) == 1 && *(unsigned char *)(a1 + 3560) == 1)
                                                {
                                                  if (v551 >= 0.25)
                                                  {
                                                    int v552 = 1;
                                                    goto LABEL_905;
                                                  }
LABEL_903:
                                                  int v552 = 2;
                                                }
                                                else
                                                {
                                                  if (v551 < 0.25) {
                                                    goto LABEL_903;
                                                  }
                                                  int v552 = 0;
                                                }
LABEL_905:
                                                if (*(unsigned char *)(*((void *)v909 + 2) + 309))
                                                {
                                                  unint64_t v553 = (uint64_t *)(a1 + 1848);
                                                  if (v552)
                                                  {
                                                    if (v552 == 2) {
                                                      unint64_t v553 = (uint64_t *)(a1 + 1880);
                                                    }
                                                    else {
                                                      unint64_t v553 = (uint64_t *)(a1 + 1864);
                                                    }
                                                  }
                                                  uint64_t v554 = *((void *)v909 + 8);
                                                  *(void *)(v554 + 296) = 0;
                                                  uint64_t v555 = *v553;
                                                  *(void *)(v554 + 288) = *v553;
                                                  uint64_t v556 = *((void *)v909 + 20);
                                                  uint64_t v557 = v553[1];
                                                  if (v557) {
                                                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v557 + 8), 1uLL, memory_order_relaxed);
                                                  }
                                                  uint64_t v558 = *(std::__shared_weak_count **)(v556 + 296);
                                                  *(void *)(v556 + 288) = v555;
                                                  *(void *)(v556 + 296) = v557;
                                                  if (v558
                                                    && !atomic_fetch_add(&v558->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v558->__on_zero_shared)(v558);
                                                    std::__shared_weak_count::__release_weak(v558);
                                                  }
                                                }
                                                if (*(unsigned char *)(*((void *)v909 + 2) + 320))
                                                {
                                                  uint64_t v559 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>::pop(*(void *)(a1 + 1912));
                                                  _S3 = *(_DWORD *)(a3 + 68);
                                                  *(double *)_Q1.i64 = fmax(*(double *)(v884 + 32) * 0.5, 250.0);
                                                  unint64_t v561 = v559[1];
                                                  uint64_t v562 = (_WORD *)v559[9];
                                                  *(double *)_Q0.i64 = *(double *)_Q1.i64
                                                                     * (float)((float)(*(float *)(a3 + 64)
                                                                                     * *(float *)(*(void *)(a5 + 8)
                                                                                                + 624))
                                                                             * fmaxf((float)(*(float *)(a3 + 20) * 0.125)+ -0.875, 0.0));
                                                  __asm
                                                  {
                                                    FCVT            H0, D0
                                                    FCVT            H1, S3
                                                  }
                                                  if (!*(unsigned char *)(a3 + 7)) {
                                                    *(short float *)_Q1.i16 = COERCE_SHORT_FLOAT(0);
                                                  }
                                                  _WORD *v562 = _Q0.i16[0];
                                                  v562[1] = _Q1.i16[0];
                                                  if (v559[8] > v561) {
                                                    unint64_t v561 = v559[8];
                                                  }
                                                  v559[7] = 0;
                                                  v559[8] = v561;
                                                  uint64_t v563 = *((void *)v909 + 8);
                                                  *(void *)(v563 + 320) = v559;
                                                  *(void *)(v563 + 328) = 0;
                                                  uint64_t v564 = *((void *)v909 + 20);
                                                  float v565 = *(std::__shared_weak_count **)(v564 + 328);
                                                  *(void *)(v564 + 320) = 0;
                                                  *(void *)(v564 + 328) = 0;
                                                  if (v565
                                                    && !atomic_fetch_add(&v565->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v565->__on_zero_shared)(v565);
                                                    std::__shared_weak_count::__release_weak(v565);
                                                  }
                                                }
                                                if (v934)
                                                {
                                                  _Q0.i64[0] = v935;
                                                  _Q0.i32[2] = v936;
                                                }
                                                else
                                                {
                                                  _Q0.i32[0] = 0;
                                                  _Q1.i8[0] = v931;
                                                  int8x16_t v566 = vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(_Q1, _Q0), 0);
                                                  _Q1.i64[0] = v932;
                                                  _Q1.i32[2] = v933;
                                                  _Q0 = vbslq_s8(v566, (int8x16_t)0, _Q1);
                                                }
                                                if (*(unsigned char *)(*((void *)v909 + 2) + 327))
                                                {
                                                  float32x4_t v889 = (float32x4_t)_Q0;
                                                  float v567 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>::pop(*(void *)(a1 + 1928));
                                                  unint64_t v568 = v567[1];
                                                  uint64_t v569 = v567[9];
                                                  float16x4_t v570 = vcvt_f16_f32(v889);
                                                  *(_WORD *)(v569 + 4) = v570.i16[2];
                                                  *(_DWORD *)uint64_t v569 = v570.i32[0];
                                                  if (v567[8] > v568) {
                                                    unint64_t v568 = v567[8];
                                                  }
                                                  v567[7] = 0;
                                                  v567[8] = v568;
                                                  uint64_t v571 = *((void *)v909 + 8);
                                                  *(void *)(v571 + 304) = v567;
                                                  *(void *)(v571 + 312) = 0;
                                                  uint64_t v572 = *((void *)v909 + 20);
                                                  uint64_t v573 = *(std::__shared_weak_count **)(v572 + 312);
                                                  *(void *)(v572 + 304) = 0;
                                                  *(void *)(v572 + 312) = 0;
                                                  if (v573
                                                    && !atomic_fetch_add(&v573->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v573->__on_zero_shared)(v573);
                                                    std::__shared_weak_count::__release_weak(v573);
                                                  }
                                                }
                                                (*(void (**)(unsigned char *__return_ptr, float))(*(void *)*v906 + 504))(v910, *v309);
                                                if (v910[0]) {
                                                  _S8 = *(float *)&v910[4];
                                                }
                                                else {
                                                  _S8 = 1.0;
                                                }
                                                if ((_BYTE)v937) {
                                                  _S9 = *((float *)&v937 + 1);
                                                }
                                                else {
                                                  _S9 = 0.0;
                                                }
                                                if (!*(unsigned char *)(*((void *)v909 + 2) + 326)) {
                                                  goto LABEL_946;
                                                }
                                                uint64_t v576 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>>>::find<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>(v846, _S8, _S9);
                                                if (v576)
                                                {
                                                  v577 = (void *)*((void *)v576 + 3);
                                                }
                                                else
                                                {
                                                  uint64_t v578 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>::pop(*(void *)(a1 + 1968));
                                                  v577 = v578;
                                                  unint64_t v579 = v578[1];
                                                  uint64_t v580 = (_WORD *)v578[9];
                                                  __asm
                                                  {
                                                    FCVT            H0, S8
                                                    FCVT            H1, S9
                                                  }
                                                  _WORD *v580 = _H0;
                                                  v580[1] = _H1;
                                                  if (v578[8] > v579) {
                                                    unint64_t v579 = v578[8];
                                                  }
                                                  v578[7] = 0;
                                                  v578[8] = v579;
                                                  std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,md::DaVinciGroundRenderLayer::ShinyStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *&>(v846, LODWORD(_S8) | ((unint64_t)LODWORD(_S9) << 32), (uint64_t)v578, _S8, _S9);
                                                }
                                                uint64_t v583 = *((void *)v909 + 8);
                                                *(void *)(v583 + 336) = v577;
                                                *(void *)(v583 + 344) = 0;
                                                uint64_t v584 = *((void *)v909 + 20);
                                                uint64_t v585 = *(std::__shared_weak_count **)(v584 + 344);
                                                *(void *)(v584 + 336) = 0;
                                                *(void *)(v584 + 344) = 0;
                                                if (v585
                                                  && !atomic_fetch_add(&v585->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v585->__on_zero_shared)(v585);
                                                  std::__shared_weak_count::__release_weak(v585);
                                                  if (v873)
                                                  {
LABEL_947:
                                                    *(void *)(*((void *)v909 + 12) + 32) = v845;
                                                    if (v946)
                                                    {
                                                      v586.i64[0] = v947;
                                                      v586.i64[1] = __PAIR64__(v839.u32[3], v948);
                                                    }
                                                    else
                                                    {
                                                      float32x4_t v586 = v945;
                                                    }
                                                    float32x4_t v890 = v586;
                                                    *(float32x4_t *)long long buf = v586;
                                                    buf[16] = 1;
                                                    uint64_t v587 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::find<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>(v842, (float *)buf);
                                                    if (v587)
                                                    {
                                                      uint64_t v588 = *(void *)(v587 + 40);
                                                    }
                                                    else
                                                    {
                                                      uint64_t v589 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>::pop(*(void *)(a1 + 1920));
                                                      uint64_t v588 = v589;
                                                      *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
                                                      unint64_t v590 = *(void *)(v589 + 8);
                                                      if (v590) {
                                                        v591 = *(float16x4_t **)(v589 + 72);
                                                      }
                                                      else {
                                                        v591 = 0;
                                                      }
                                                      float32x4_t v592 = v890;
                                                      v593.i64[0] = 0;
                                                      v593.i64[1] = v589;
                                                      float32x4_t v891 = v593;
                                                      *(float32x4_t *)&__p.__r_.__value_.__l.__data_ = v593;
                                                      __p.__r_.__value_.__r.__words[2] = 0;
                                                      *(void *)uint64_t v972 = v590;
                                                      *(void *)&v972[16] = v591;
                                                      *(_WORD *)&v972[8] = 1;
                                                      float16x4_t *v591 = vcvt_f16_f32(v592);
                                                      std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *&>(v842, (unsigned int *)buf, (uint64_t)buf, v589);
                                                      if (v590)
                                                      {
                                                        if (v891.i64[0] && *(unsigned char *)(v891.i64[1] + 17) != 2) {
                                                          (*(void (**)(void))(*(void *)v891.i64[0] + 64))();
                                                        }
                                                        unint64_t v594 = *(void *)(v891.i64[1] + 64);
                                                        if (v594 <= v590) {
                                                          unint64_t v594 = v590;
                                                        }
                                                        *(void *)(v891.i64[1] + 56) = 0;
                                                        *(void *)(v891.i64[1] + 64) = v594;
                                                      }
                                                    }
                                                    uint64_t v595 = *((void *)v909 + 8);
                                                    *(void *)(v595 + 464) = v588;
                                                    *(void *)(v595 + 472) = 0;
                                                    uint64_t v596 = *((void *)v909 + 20);
                                                    uint64_t v597 = *(std::__shared_weak_count **)(v596 + 472);
                                                    *(void *)(v596 + 464) = 0;
                                                    *(void *)(v596 + 472) = 0;
                                                    if (v597
                                                      && !atomic_fetch_add(&v597->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                    {
                                                      ((void (*)(std::__shared_weak_count *))v597->__on_zero_shared)(v597);
                                                      std::__shared_weak_count::__release_weak(v597);
                                                    }
                                                  }
                                                }
                                                else
                                                {
LABEL_946:
                                                  if (v873) {
                                                    goto LABEL_947;
                                                  }
                                                }
                                                if (*(unsigned __int8 *)(*v906 + 8) - 3 <= 1
                                                  && *(unsigned char *)(*((void *)v909 + 2) + 329))
                                                {
                                                  uint64_t v598 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>::pop(*(void *)(a1 + 1952));
                                                  uint64_t v599 = *((void *)v909 + 8);
                                                  *(void *)(v599 + 64) = v598;
                                                  *(void *)(v599 + 72) = 0;
                                                  uint64_t v600 = *((void *)v909 + 20);
                                                  uint64_t v601 = *(std::__shared_weak_count **)(v600 + 72);
                                                  *(void *)(v600 + 64) = 0;
                                                  *(void *)(v600 + 72) = 0;
                                                  if (v601
                                                    && !atomic_fetch_add(&v601->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v601->__on_zero_shared)(v601);
                                                    std::__shared_weak_count::__release_weak(v601);
                                                  }
                                                }
                                                else
                                                {
                                                  uint64_t v598 = 0;
                                                }
                                                uint64_t v602 = "standard material renderable - ground non compressed";
                                                if (!v598)
                                                {
LABEL_1196:
                                                  *((void *)&v977 + 1) = 0;
                                                  long long v976 = 0uLL;
                                                  LODWORD(v977) = 0;
                                                  *(_DWORD *)v978 = 1065353216;
                                                  memset(&v978[8], 0, 32);
                                                  __n128 v738 = (__n128)vdupq_n_s64(1uLL);
                                                  *(__n128 *)&v978[40] = v738;
                                                  *(void *)&v978[56] = 0;
                                                  *(void *)long long buf = &off_1EF55A458;
                                                  *(void *)&buf[16] = v602;
                                                  if (*(unsigned char *)(v218 + 176)
                                                    && (uint64_t v739 = *(void *)(v218 + 152)) != 0
                                                    && *(unsigned char *)(v218 + 145) == 4)
                                                  {
                                                    float32x2_t v740 = *(std::__shared_weak_count **)(v218 + 160);
                                                    if (v740) {
                                                      atomic_fetch_add_explicit(&v740->__shared_owners_, 1uLL, memory_order_relaxed);
                                                    }
                                                    if (*(unsigned char *)(v218 + 193))
                                                    {
                                                      unsigned int v741 = *(_DWORD *)(a1 + 3188) + *(unsigned __int8 *)(v218 + 192);
                                                      if (v741 >= 0xFF) {
                                                        unsigned int v741 = 255;
                                                      }
                                                      *(unsigned char *)(v739 + 208) = 1;
                                                      LODWORD(v977) = v741;
                                                    }
                                                    *(void *)&long long v976 = v739;
                                                    if (v740
                                                      && !atomic_fetch_add(&v740->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                    {
                                                      ((void (*)(std::__shared_weak_count *))v740->__on_zero_shared)(v740);
                                                      std::__shared_weak_count::__release_weak(v740);
                                                    }
                                                  }
                                                  else
                                                  {
                                                    if (*(unsigned char *)(v218 + 145) == 3) {
                                                      char v742 = v896;
                                                    }
                                                    else {
                                                      char v742 = 1;
                                                    }
                                                    if (v742) {
                                                      *(void *)&long long v976 = md::DaVinciRenderStateCache::renderState((unsigned __int8 **)(a1 + 2992), *(unsigned __int8 *)(*(void *)(v218 + 216)+ 32), v896, 1, 0, 1, (*(unsigned __int8 *)(v218 + 400) | *(unsigned __int8 *)(a3 + 1)) != 0, 3);
                                                    }
                                                    else {
                                                      *(void *)&long long v976 = a1 + 2776;
                                                    }
                                                  }
                                                  *((void *)&v976 + 1) = v909;
                                                  *(void *)&v978[48] = *(unsigned int *)(*(void *)(v218 + 32) + 16);
                                                  v738.n128_f32[0] = *v903;
                                                  (*(void (**)(int8x16_t *__return_ptr, __n128))(**(void **)(v218 + 224) + 264))(&v969, v738);
                                                  if (*(unsigned char *)(v218 + 188))
                                                  {
                                                    if (!v969.i8[0]) {
                                                      v969.i8[0] = 1;
                                                    }
                                                    v969.i32[1] = *(_DWORD *)(v218 + 184);
                                                  }
                                                  unint64_t v743 = (*(uint64_t (**)(uint64_t))(*(void *)v218 + 16))(v218);
                                                  if (v969.i8[0])
                                                  {
                                                    if (v896) {
                                                      int v744 = 1;
                                                    }
                                                    else {
                                                      int v744 = 2;
                                                    }
                                                    uint64_t v745 = (v744 + 2 * v969.i32[1]);
                                                  }
                                                  else
                                                  {
                                                    uint64_t v745 = 4294967294;
                                                    if (v896) {
                                                      uint64_t v745 = 0;
                                                    }
                                                  }
                                                  *((void *)&v977 + 1) = (v743 >> 4) | (unint64_t)(v745 << 8);
                                                  if (*(unsigned char *)(v218 + 145) == 3) {
                                                    char v746 = v896;
                                                  }
                                                  else {
                                                    char v746 = 1;
                                                  }
                                                  if ((v746 & 1) == 0)
                                                  {
                                                    LODWORD(v912) = 0;
                                                    *(_DWORD *)uint64_t v913 = 1065353216;
                                                    memset(&v913[8], 0, 32);
                                                    BOOL v747 = 1;
                                                    *(int64x2_t *)&v913[40] = vdupq_n_s64(1uLL);
                                                    *(void *)&v913[56] = 0;
                                                    *(void *)v910 = &off_1EF55A458;
                                                    *(void *)&v910[16] = v602;
                                                    *((void *)&v912 + 1) = 0;
                                                    long long v911 = (unint64_t)(a1 + 2560);
                                                    if (*(unsigned char *)v899) {
                                                      BOOL v747 = *(unsigned char *)(v218 + 147) != 0;
                                                    }
                                                    int v748 = *(unsigned __int8 *)(*v906 + 8);
                                                    int v749 = *(unsigned __int8 *)(a3 + 6);
                                                    int v750 = *(unsigned __int8 *)(a3 + 9);
                                                    uint64_t v751 = (void *)ggl::FragmentedPool<ggl::DaVinci::GroundDepthPipelineSetup>::pop(*(void *)(a1 + 1672));
                                                    HIBYTE(v833) = v872 == 1;
                                                    LOBYTE(v833) = 0;
                                                    HIBYTE(v828) = a10;
                                                    LOBYTE(v828) = 0;
                                                    md::DaVinciPipelineStateManager<ggl::DaVinci::GroundDepthPipelineState,std::shared_ptr<ggl::DaVinciGroundDepthShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)&__p, a1 + 808, v871, 0, v748 == 3, v748 == 4, v749 != 0, 0, v828, v747, v833, v750 != 0, 0, v870, 0, 1, 1u, 0, 0,
                                                      0,
                                                      0,
                                                      0,
                                                      v881 == 255,
                                                      v867,
                                                      v869,
                                                      0,
                                                      0,
                                                      0,
                                                      0);
                                                    long long v752 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                                                    if (__p.__r_.__value_.__l.__size_) {
                                                      atomic_fetch_add_explicit((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 1uLL, memory_order_relaxed);
                                                    }
                                                    if ((void)v752 && **(void **)(v752 + 40) == v751[1])
                                                    {
                                                      uint64_t v754 = v751[2];
                                                      if (v754 && v754 != (void)v752) {
                                                        ggl::PipelineSetup::resetData((uint64_t)v751);
                                                      }
                                                      if (*((void *)&v752 + 1)) {
                                                        atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v752 + 1) + 8), 1uLL, memory_order_relaxed);
                                                      }
                                                      v753 = (std::__shared_weak_count *)v751[3];
                                                      *((_OWORD *)v751 + 1) = v752;
                                                      if (v753) {
                                                        goto LABEL_1243;
                                                      }
                                                    }
                                                    else
                                                    {
                                                      v753 = (std::__shared_weak_count *)v751[3];
                                                      v751[2] = 0;
                                                      v751[3] = 0;
                                                      if (!v753) {
                                                        goto LABEL_1245;
                                                      }
LABEL_1243:
                                                      if (!atomic_fetch_add(&v753->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                      {
                                                        ((void (*)(std::__shared_weak_count *))v753->__on_zero_shared)(v753);
                                                        std::__shared_weak_count::__release_weak(v753);
                                                      }
                                                    }
LABEL_1245:
                                                    if (*((void *)&v752 + 1)
                                                      && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v752 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                                                    {
                                                      (*(void (**)(void))(**((void **)&v752 + 1) + 16))(*((void *)&v752 + 1));
                                                      std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v752
                                                                                               + 1));
                                                    }
                                                    unint64_t v755 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
                                                    if (__p.__r_.__value_.__l.__size_
                                                      && !atomic_fetch_add((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
                                                    {
                                                      ((void (*)(std::__shared_weak_count *))v755->__on_zero_shared)(v755);
                                                      std::__shared_weak_count::__release_weak(v755);
                                                    }
                                                    std::locale v756 = *(uint64_t **)(v218 + 32);
                                                    float32_t v757 = (uint64_t *)v751[4];
                                                    v757[1] = 0;
                                                    uint64_t v758 = *v756;
                                                    uint64_t *v757 = *v756;
                                                    float v759 = (void *)v751[16];
                                                    uint64_t v760 = v756[1];
                                                    if (v760) {
                                                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v760 + 8), 1uLL, memory_order_relaxed);
                                                    }
                                                    unsigned int v761 = (std::__shared_weak_count *)v759[1];
                                                    *float v759 = v758;
                                                    v759[1] = v760;
                                                    if (v761
                                                      && !atomic_fetch_add(&v761->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                    {
                                                      ((void (*)(std::__shared_weak_count *))v761->__on_zero_shared)(v761);
                                                      std::__shared_weak_count::__release_weak(v761);
                                                    }
                                                    float v762 = (void *)v751[8];
                                                    v762[1] = 0;
                                                    uint64_t v763 = *(void *)(a5 + 216);
                                                    void *v762 = v763;
                                                    float v764 = (void *)v751[20];
                                                    uint64_t v765 = *(void *)(a5 + 224);
                                                    if (v765) {
                                                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v765 + 8), 1uLL, memory_order_relaxed);
                                                    }
                                                    float v766 = (std::__shared_weak_count *)v764[1];
                                                    void *v764 = v763;
                                                    v764[1] = v765;
                                                    if (v766
                                                      && !atomic_fetch_add(&v766->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                    {
                                                      ((void (*)(std::__shared_weak_count *))v766->__on_zero_shared)(v766);
                                                      std::__shared_weak_count::__release_weak(v766);
                                                    }
                                                    uint64_t v767 = v751[8];
                                                    *(void *)(v767 + 24) = 0;
                                                    uint64_t v768 = *(void *)(a5 + 232);
                                                    *(void *)(v767 + 16) = v768;
                                                    uint64_t v769 = v751[20];
                                                    uint64_t v770 = *(void *)(a5 + 240);
                                                    if (v770) {
                                                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v770 + 8), 1uLL, memory_order_relaxed);
                                                    }
                                                    uint64_t v771 = *(std::__shared_weak_count **)(v769 + 24);
                                                    *(void *)(v769 + 16) = v768;
                                                    *(void *)(v769 + 24) = v770;
                                                    if (v771
                                                      && !atomic_fetch_add(&v771->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                    {
                                                      ((void (*)(std::__shared_weak_count *))v771->__on_zero_shared)(v771);
                                                      std::__shared_weak_count::__release_weak(v771);
                                                    }
                                                    uint64_t v772 = v751[8];
                                                    uint64_t v773 = v956;
                                                    uint64_t v774 = v957;
                                                    *(void *)(v772 + 48) = v956;
                                                    *(void *)(v772 + 56) = 0;
                                                    uint64_t v775 = v751[20];
                                                    if (v774) {
                                                      atomic_fetch_add_explicit(&v774->__shared_owners_, 1uLL, memory_order_relaxed);
                                                    }
                                                    v776 = *(std::__shared_weak_count **)(v775 + 56);
                                                    *(void *)(v775 + 48) = v773;
                                                    *(void *)(v775 + 56) = v774;
                                                    if (v776
                                                      && !atomic_fetch_add(&v776->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                    {
                                                      ((void (*)(std::__shared_weak_count *))v776->__on_zero_shared)(v776);
                                                      std::__shared_weak_count::__release_weak(v776);
                                                    }
                                                    if (v872 == 1)
                                                    {
                                                      uint64_t v777 = **(void **)(v218 + 216);
                                                      uint64_t v780 = *(void **)(v777 + 120);
                                                      char v779 = (void *)(v777 + 120);
                                                      uint64_t v778 = v780;
                                                      if (v780)
                                                      {
                                                        unint64_t v781 = v779;
                                                        v782 = v778;
                                                        do
                                                        {
                                                          unint64_t v783 = v782[4];
                                                          BOOL v784 = v783 >= 2;
                                                          if (v783 >= 2) {
                                                            char v785 = v782;
                                                          }
                                                          else {
                                                            char v785 = v782 + 1;
                                                          }
                                                          if (v784) {
                                                            unint64_t v781 = v782;
                                                          }
                                                          v782 = (void *)*v785;
                                                        }
                                                        while (*v785);
                                                        if (v781 != v779 && v781[4] <= 2uLL)
                                                        {
                                                          while (1)
                                                          {
                                                            while (1)
                                                            {
                                                              unint64_t v786 = v778[4];
                                                              if (v786 < 3) {
                                                                break;
                                                              }
                                                              uint64_t v778 = (void *)*v778;
                                                              if (!v778) {
                                                                goto LABEL_1369;
                                                              }
                                                            }
                                                            if (v786 == 2) {
                                                              break;
                                                            }
                                                            uint64_t v778 = (void *)v778[1];
                                                            if (!v778) {
LABEL_1369:
                                                            }
                                                              abort();
                                                          }
                                                          uint64_t v787 = v778[5];
                                                          uint64_t v788 = (std::__shared_weak_count *)v778[6];
                                                          if (v788) {
                                                            atomic_fetch_add_explicit(&v788->__shared_owners_, 1uLL, memory_order_relaxed);
                                                          }
                                                          if (v787) {
                                                            ggl::DaVinci::GroundDepthPipelineSetup::setElevationsDeviceData(v751[4], v751[16], v787);
                                                          }
                                                          if (v788
                                                            && !atomic_fetch_add(&v788->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                          {
                                                            ((void (*)(std::__shared_weak_count *))v788->__on_zero_shared)(v788);
                                                            std::__shared_weak_count::__release_weak(v788);
                                                          }
                                                        }
                                                      }
                                                    }
                                                    *((void *)&v911 + 1) = v751;
                                                    if (v881 == 255)
                                                    {
                                                      if (*(unsigned char *)(v218 + 200))
                                                      {
                                                        int v809 = *(_DWORD *)(v218 + 196);
                                                        uint64_t v810 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>::pop(*(void *)(a1 + 1976));
                                                        unint64_t v811 = *(void *)(v810 + 8);
                                                        **(_DWORD **)(v810 + 72) = v809;
                                                        if (*(void *)(v810 + 64) > v811) {
                                                          unint64_t v811 = *(void *)(v810 + 64);
                                                        }
                                                        *(void *)(v810 + 56) = 0;
                                                        *(void *)(v810 + 64) = v811;
                                                        uint64_t v812 = v751[8];
                                                        *(void *)(v812 + 32) = v810;
                                                        *(void *)(v812 + 40) = 0;
                                                      }
                                                      else
                                                      {
                                                        uint64_t v813 = v751[8];
                                                        *(void *)(v813 + 32) = *(void *)(a1 + 2016);
                                                        *(void *)(v813 + 40) = 0;
                                                      }
                                                      uint64_t v814 = v751[20];
                                                      long long v815 = *(std::__shared_weak_count **)(v814 + 40);
                                                      *(void *)(v814 + 32) = 0;
                                                      *(void *)(v814 + 40) = 0;
                                                      if (v815
                                                        && !atomic_fetch_add(&v815->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                      {
                                                        ((void (*)(std::__shared_weak_count *))v815->__on_zero_shared)(v815);
                                                        std::__shared_weak_count::__release_weak(v815);
                                                      }
                                                    }
                                                    *(void *)&v913[48] = *(unsigned int *)(*(void *)(v218 + 32)
                                                                                           + 16);
                                                    *((void *)&v912 + 1) = 0;
                                                    uint64_t v789 = **(void **)(v218 + 216);
                                                    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1EF55A458;
                                                    *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = *(_OWORD *)&v910[8];
                                                    *(_OWORD *)uint64_t v972 = v911;
                                                    *(_OWORD *)v974 = *(_OWORD *)&v913[32];
                                                    *(_OWORD *)&v974[16] = *(_OWORD *)&v913[48];
                                                    *(_OWORD *)&v972[16] = v912;
                                                    *(_OWORD *)uint64_t v973 = *(_OWORD *)v913;
                                                    *(_OWORD *)&v973[16] = *(_OWORD *)&v913[16];
                                                    float32x4_t v790 = *(void **)(a1 + 3112);
                                                    uint64_t v791 = v790[1];
                                                    if (v791 == *(void *)(a1 + 3120))
                                                    {
                                                      float32x4_t v790 = (void *)*v790;
                                                      if (!v790)
                                                      {
                                                        float32x4_t v790 = malloc_type_malloc(120 * v791 + 16, 0xB644C221uLL);
                                                        *float32x4_t v790 = 0;
                                                        v790[1] = 0;
                                                        **(void **)(a1 + 3112) = v790;
                                                      }
                                                      *(void *)(a1 + 3112) = v790;
                                                      uint64_t v791 = v790[1];
                                                    }
                                                    BOOL v792 = &v790[15 * v791];
                                                    v790[1] = v791 + 1;
                                                    v792[2] = &off_1EF55A458;
                                                    long long v793 = *(_OWORD *)&__p.__r_.__value_.__r.__words[1];
                                                    long long v794 = *(_OWORD *)v972;
                                                    *(_OWORD *)(v792 + 7) = *(_OWORD *)&v972[16];
                                                    *(_OWORD *)(v792 + 5) = v794;
                                                    *(_OWORD *)(v792 + 3) = v793;
                                                    long long v795 = *(_OWORD *)v973;
                                                    long long v796 = *(_OWORD *)&v973[16];
                                                    long long v797 = *(_OWORD *)v974;
                                                    *(_OWORD *)(v792 + 15) = *(_OWORD *)&v974[16];
                                                    *(_OWORD *)(v792 + 13) = v797;
                                                    *(_OWORD *)(v792 + 11) = v796;
                                                    *(_OWORD *)(v792 + 9) = v795;
                                                    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1EF55A458;
                                                    __p.__r_.__value_.__r.__words[2] = 3131955885;
                                                    v792[10] = v789;
                                                    *(_OWORD *)(v792 + 11) = *(_OWORD *)(v218 + 16);
                                                    v792[13] = 0;
                                                    v792[14] = 1;
                                                    ggl::CommandBuffer::pushRenderItem(a9, (uint64_t)(v792 + 2));
                                                  }
                                                  if (*(unsigned char *)(a3 + 176))
                                                  {
                                                    int64x2_t v798 = vdupq_n_s64(1uLL);
                                                    v798.i64[0] = (*(void *)(v218 + 24) - *(void *)(v218 + 16))
                                                                * *(unsigned int *)(*(void *)(v218 + 32) + 16);
                                                    *(int64x2_t *)(a3 + 184) = vaddq_s64(v798, *(int64x2_t *)(a3 + 184));
                                                    *(int64x2_t *)(a3 + 200) = vaddq_s64(*(int64x2_t *)(a3 + 200), v798);
                                                  }
                                                  uint64_t v799 = **(void **)(v218 + 216);
                                                  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1EF55A458;
                                                  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = *(_OWORD *)&buf[8];
                                                  *(_OWORD *)uint64_t v972 = v976;
                                                  *(_OWORD *)v974 = *(_OWORD *)&v978[32];
                                                  *(_OWORD *)&v974[16] = *(_OWORD *)&v978[48];
                                                  *(_OWORD *)&v972[16] = v977;
                                                  *(_OWORD *)uint64_t v973 = *(_OWORD *)v978;
                                                  *(_OWORD *)&v973[16] = *(_OWORD *)&v978[16];
                                                  double v800 = *(void **)(a1 + 3112);
                                                  uint64_t v801 = v800[1];
                                                  if (v801 == *(void *)(a1 + 3120))
                                                  {
                                                    double v800 = (void *)*v800;
                                                    if (!v800)
                                                    {
                                                      double v800 = malloc_type_malloc(120 * v801 + 16, 0xB644C221uLL);
                                                      *double v800 = 0;
                                                      v800[1] = 0;
                                                      **(void **)(a1 + 3112) = v800;
                                                    }
                                                    *(void *)(a1 + 3112) = v800;
                                                    uint64_t v801 = v800[1];
                                                  }
                                                  double v802 = &v800[15 * v801];
                                                  v800[1] = v801 + 1;
                                                  v802[2] = &off_1EF55A458;
                                                  long long v803 = *(_OWORD *)&__p.__r_.__value_.__r.__words[1];
                                                  long long v804 = *(_OWORD *)v972;
                                                  *(_OWORD *)(v802 + 7) = *(_OWORD *)&v972[16];
                                                  *(_OWORD *)(v802 + 5) = v804;
                                                  *(_OWORD *)(v802 + 3) = v803;
                                                  long long v805 = *(_OWORD *)v973;
                                                  long long v806 = *(_OWORD *)&v973[16];
                                                  long long v807 = *(_OWORD *)v974;
                                                  *(_OWORD *)(v802 + 15) = *(_OWORD *)&v974[16];
                                                  *(_OWORD *)(v802 + 13) = v807;
                                                  *(_OWORD *)(v802 + 11) = v806;
                                                  *(_OWORD *)(v802 + 9) = v805;
                                                  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)&off_1EF55A458;
                                                  __p.__r_.__value_.__r.__words[2] = 3131955885;
                                                  v802[10] = v799;
                                                  *(_OWORD *)(v802 + 11) = *(_OWORD *)(v218 + 16);
                                                  v802[13] = 0;
                                                  v802[14] = 1;
                                                  ggl::CommandBuffer::pushRenderItem(a9, (uint64_t)(v802 + 2));
                                                  double v808 = (std::__shared_weak_count *)*((void *)&v939 + 1);
                                                  if (*((void *)&v939 + 1)
                                                    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v939 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                                                  {
                                                    ((void (*)(std::__shared_weak_count *))v808->__on_zero_shared)(v808);
                                                    std::__shared_weak_count::__release_weak(v808);
                                                  }
                                                  unint64_t v74 = (float *)(a3 + 20);
                                                  goto LABEL_1312;
                                                }
LABEL_1171:
                                                uint64_t v720 = *v906;
                                                if (*(unsigned __int8 *)(*v906 + 8) - 3 <= 1)
                                                {
                                                  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
                                                  unint64_t v721 = *(void *)(v598 + 8);
                                                  if (v721) {
                                                    v722 = *(float16x4_t **)(v598 + 72);
                                                  }
                                                  else {
                                                    v722 = 0;
                                                  }
                                                  *(void *)&long long v723 = 0;
                                                  *((void *)&v723 + 1) = v598;
                                                  long long v880 = v723;
                                                  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v723;
                                                  __p.__r_.__value_.__r.__words[2] = 0;
                                                  *(void *)uint64_t v972 = v721;
                                                  *(void *)&v972[16] = v722;
                                                  *(_WORD *)&v972[8] = 1;
                                                  uint32x2_t v724 = v882[10];
                                                  if (v851)
                                                  {
                                                    uint64_t v725 = +[VKDebugSettings sharedSettings];
                                                    [v725 daVinciPlanarPixelPerMeterOverride];
                                                    int32x2_t v895 = v726;

                                                    uint64_t v720 = *v906;
                                                  }
                                                  else
                                                  {
                                                    int32x2_t v895 = (int32x2_t)0x4200000042000000;
                                                  }
                                                  float v886 = *(float *)(v963 + 1168);
                                                  (*(void (**)(unsigned char *__return_ptr, float))(*(void *)v720 + 392))(buf, *v903);
                                                  (*(void (**)(unsigned char *__return_ptr, float))(*(void *)*v906 + 424))(v910, *v903);
                                                  LODWORD(v729) = *(_DWORD *)&buf[8];
                                                  if (buf[0])
                                                  {
                                                    v730.f32[0] = *(float *)&buf[4];
                                                  }
                                                  else
                                                  {
                                                    *(float *)&double v729 = 1.0;
                                                    v730.f32[0] = 1.0;
                                                  }
                                                  LODWORD(v728) = *(_DWORD *)&v910[4];
                                                  if (v910[0]) {
                                                    float v731 = *(float *)&v910[8];
                                                  }
                                                  else {
                                                    float v731 = 0.0;
                                                  }
                                                  if (v910[0]) {
                                                    *(float *)&double v727 = *(float *)&v910[4];
                                                  }
                                                  else {
                                                    *(float *)&double v727 = 0.0;
                                                  }
                                                  if (v851)
                                                  {
                                                    uint64_t v732 = +[VKDebugSettings sharedSettings];
                                                    [v732 daVinciPlanarTilingOverride];
                                                    __int32 v883 = v733;

                                                    int64x2_t v734 = +[VKDebugSettings sharedSettings];
                                                    [v734 daVinciPlanarOffsetOverride];
                                                    float v878 = v735;

                                                    float v731 = v878;
                                                    *(float *)&double v727 = v878;
                                                    v730.i32[0] = v883;
                                                    LODWORD(v729) = v883;
                                                  }
                                                  *(float32x2_t *)v736.f32 = vdiv_f32((float32x2_t)vdup_lane_s32(v895, 0), vmul_n_f32(vcvt_f32_u32(v724), v886));
                                                  v736.i64[1] = v736.i64[0];
                                                  v730.i32[1] = LODWORD(v729);
                                                  v730.i64[1] = __PAIR64__(LODWORD(v731), LODWORD(v727));
                                                  float16x4_t *v722 = vcvt_f16_f32(vmulq_f32(v730, v736));
                                                  if (v721)
                                                  {
                                                    if ((void)v880 && *(unsigned char *)(*((void *)&v880 + 1) + 17) != 2) {
                                                      (*(void (**)(void))(*(void *)v880 + 64))();
                                                    }
                                                    unint64_t v737 = *(void *)(*((void *)&v880 + 1) + 64);
                                                    if (v737 <= v721) {
                                                      unint64_t v737 = v721;
                                                    }
                                                    *(void *)(*((void *)&v880 + 1) + 56) = 0;
                                                    *(void *)(*((void *)&v880 + 1) + 64) = v737;
                                                  }
                                                }
                                                goto LABEL_1196;
                                              }
                                            }
                                            else
                                            {
                                              if (v519 >= *(void *)&v514) {
                                                v519 %= *(void *)&v514;
                                              }
                                              if (v519 != v515) {
                                                goto LABEL_856;
                                              }
                                            }
                                            uint64_t v517 = (uint64_t *)*v517;
                                            if (!v517) {
                                              goto LABEL_856;
                                            }
                                          }
                                        }
                                      }
                                      else
                                      {
                                        if (v485 >= *(void *)&v436) {
                                          v485 %= *(void *)&v436;
                                        }
                                        if (v485 != v437) {
                                          break;
                                        }
                                      }
                                      uint64_t v483 = (uint64_t *)*v483;
                                    }
                                    while (v483);
                                  }
                                }
                              }
                            }
LABEL_820:
                            uint64_t v509 = a1 + 3248;
                            uint64_t v510 = *v861;
                            if (!*v861) {
                              goto LABEL_830;
                            }
                            do
                            {
                              unsigned int v511 = *(_DWORD *)(v510 + 32);
                              BOOL v512 = v511 >= 0x99;
                              if (v511 >= 0x99) {
                                double v513 = (uint64_t *)v510;
                              }
                              else {
                                double v513 = (uint64_t *)(v510 + 8);
                              }
                              if (v512) {
                                uint64_t v509 = v510;
                              }
                              uint64_t v510 = *v513;
                            }
                            while (*v513);
                            if ((uint64_t *)v509 != v861 && *(_DWORD *)(v509 + 32) <= 0x99u) {
                              uint64_t v508 = *(void *)(v509 + 40);
                            }
                            else {
LABEL_830:
                            }
                              uint64_t v508 = 0;
                            goto LABEL_831;
                          }
                        }
                        else
                        {
                          if (v475 >= v430) {
                            v475 %= v430;
                          }
                          if (v475 != v431) {
                            goto LABEL_798;
                          }
                        }
                        v472 = (uint64_t *)*v472;
                        if (!v472) {
                          goto LABEL_798;
                        }
                      }
                    }
                    *(void *)(*((void *)v909 + 12) + 64) = 0;
                    *(void *)(*((void *)v909 + 12) + 56) = 0;
                    uint64_t v432 = *((void *)v909 + 8);
                    *(void *)(v432 + 272) = 0;
                    *(void *)(v432 + 280) = 0;
                    uint64_t v433 = *((void *)v909 + 20);
                    unint64_t v434 = *(std::__shared_weak_count **)(v433 + 280);
                    *(void *)(v433 + 272) = 0;
                    *(void *)(v433 + 280) = 0;
                    if (v434 && !atomic_fetch_add(&v434->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v434->__on_zero_shared)(v434);
                      std::__shared_weak_count::__release_weak(v434);
                    }
                    if (!updated) {
                      goto LABEL_818;
                    }
                    goto LABEL_668;
                  }
                  uint64_t v909 = (ggl::PipelineSetup *)ggl::FragmentedPool<ggl::DaVinci::GroundPipelineSetup>::pop(*(void *)(a1 + 1648));
                  if (v896) {
                    uint64_t v182 = a1 + 568;
                  }
                  else {
                    uint64_t v182 = a1 + 928;
                  }
                  HIBYTE(v835) = v876;
                  LOBYTE(v835) = 0;
                  HIBYTE(v832) = v169 == 1;
                  LOBYTE(v832) = v873;
                  HIBYTE(v830) = v876;
                  LOBYTE(v830) = v853;
                  HIBYTE(v827) = a10;
                  LOBYTE(v827) = v866;
                  md::DaVinciPipelineStateManager<ggl::DaVinci::GroundPipelineState,std::shared_ptr<ggl::DaVinciGroundShader>,ggl::ColorBufferOperation>::pipelineStateForFunctionConstants((std::__shared_weak_count **)&__p, v182, v166, v176 != 0, v170 == 3, v170 == 4, v171 != 0, v874, v827, v830, v832, v172 != 0, v879, v870, v173, v167, v868 != v855, v887 != 0, v862,
                    v854 != 0,
                    v877,
                    v177 != 0,
                    1u,
                    v867,
                    v869,
                    updated,
                    0,
                    0,
                    v835);
                  long long v183 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
                  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
                  int8x8_t v184 = (std::__shared_weak_count *)*((void *)&v183 + 1);
                  if ((void)v183 && **(void **)(v183 + 40) == *((void *)v909 + 1))
                  {
                    uint64_t v207 = *((void *)v909 + 2);
                    uint64_t v186 = v885;
                    if (v207 && v207 != (void)v183)
                    {
                      long long v856 = v183;
                      ggl::PipelineSetup::resetData((uint64_t)v909);
                      long long v183 = v856;
                    }
                    if (v184) {
                      atomic_fetch_add_explicit(&v184->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    uint64_t v185 = (std::__shared_weak_count *)*((void *)v909 + 3);
                    *((_OWORD *)v909 + 1) = v183;
                    if (v185) {
                      goto LABEL_404;
                    }
                  }
                  else
                  {
                    uint64_t v185 = (std::__shared_weak_count *)*((void *)v909 + 3);
                    *((void *)v909 + 2) = 0;
                    *((void *)v909 + 3) = 0;
                    uint64_t v186 = v885;
                    if (!v185) {
                      goto LABEL_406;
                    }
LABEL_404:
                    if (!atomic_fetch_add(&v185->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v185->__on_zero_shared)(v185);
                      std::__shared_weak_count::__release_weak(v185);
                    }
                  }
LABEL_406:
                  if (v184 && !atomic_fetch_add(&v184->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v184->__on_zero_shared)(v184);
                    std::__shared_weak_count::__release_weak(v184);
                  }
                  uint64_t v208 = (std::__shared_weak_count *)__p.__r_.__value_.__l.__size_;
                  if (__p.__r_.__value_.__l.__size_
                    && !atomic_fetch_add((atomic_ullong *volatile)(__p.__r_.__value_.__l.__size_ + 8), 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v208->__on_zero_shared)(v208);
                    std::__shared_weak_count::__release_weak(v208);
                  }
                  if (*(unsigned char *)(v186 + 200))
                  {
                    int v209 = *(_DWORD *)(v186 + 196);
                    uint64_t v210 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::Tile::PositionScaleInfo>>::pop(*(void *)(a1 + 1976));
                    unint64_t v211 = *(void *)(v210 + 8);
                    **(_DWORD **)(v210 + 72) = v209;
                    if (*(void *)(v210 + 64) > v211) {
                      unint64_t v211 = *(void *)(v210 + 64);
                    }
                    *(void *)(v210 + 56) = 0;
                    *(void *)(v210 + 64) = v211;
                    uint64_t v212 = *((void *)v909 + 8);
                    *(void *)(v212 + 144) = v210;
                    *(void *)(v212 + 152) = 0;
                    uint64_t v213 = *((void *)v909 + 20);
                  }
                  else
                  {
                    uint64_t v214 = *((void *)v909 + 8);
                    *(void *)(v214 + 144) = *(void *)(a1 + 2016);
                    *(void *)(v214 + 152) = 0;
                    uint64_t v213 = *((void *)v909 + 20);
                  }
                  uint64_t v215 = *(std::__shared_weak_count **)(v213 + 152);
                  *(void *)(v213 + 144) = 0;
                  *(void *)(v213 + 152) = 0;
                  if (v215 && !atomic_fetch_add(&v215->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v215->__on_zero_shared)(v215);
                    std::__shared_weak_count::__release_weak(v215);
                  }
                  md::DaVinciGroundRenderLayer::setupStyleConstantData<ggl::DaVinci::GroundPipelineSetup,ggl::DaVinci::GroundPipelineState>(a1, (uint64_t)v909, a5, a3);
                  a7 = v849;
                  a8 = v850;
                  unint64_t v217 = (float *)(a3 + 20);
                  uint64_t v218 = v885;
                  if (v879)
                  {
                    char v219 = *(std::__shared_weak_count **)(v885 + 232);
                    uint64_t v928 = *(void *)(v885 + 224);
                    v929 = v219;
                    if (v219) {
                      atomic_fetch_add_explicit(&v219->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    uint64_t v220 = md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_2::operator()((uint64_t)v960, (uint64_t)&v928, &v958);
                    uint64_t v221 = *((void *)v909 + 8);
                    *(void *)(v221 + 240) = v220;
                    *(void *)(v221 + 248) = 0;
                    uint64_t v222 = *((void *)v909 + 20);
                    int64_t v223 = *(std::__shared_weak_count **)(v222 + 248);
                    *(void *)(v222 + 240) = 0;
                    *(void *)(v222 + 248) = 0;
                    if (v223 && !atomic_fetch_add(&v223->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v223->__on_zero_shared)(v223);
                      std::__shared_weak_count::__release_weak(v223);
                    }
                    long long v224 = v929;
                    if (v929 && !atomic_fetch_add(&v929->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v224->__on_zero_shared)(v224);
                      std::__shared_weak_count::__release_weak(v224);
                    }
                  }
                  if (v887)
                  {
                    *(void *)(*((void *)v909 + 12) + 48) = *(void *)(v885 + 312);
                    uint64_t v225 = *((void *)v909 + 8);
                    *(void *)(v225 + 408) = 0;
                    uint64_t v226 = *(void *)(v885 + 336);
                    *(void *)(v225 + 400) = v226;
                    uint64_t v227 = *((void *)v909 + 20);
                    uint64_t v228 = *(void *)(v885 + 344);
                    if (v228) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v228 + 8), 1uLL, memory_order_relaxed);
                    }
                    double v229 = *(std::__shared_weak_count **)(v227 + 408);
                    *(void *)(v227 + 400) = v226;
                    *(void *)(v227 + 408) = v228;
                    if (v229 && !atomic_fetch_add(&v229->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v229->__on_zero_shared)(v229);
                      std::__shared_weak_count::__release_weak(v229);
                    }
                    uint64_t v230 = *((void *)v909 + 8);
                    *(void *)(v230 + 424) = 0;
                    uint64_t v231 = *(void *)(v885 + 352);
                    *(void *)(v230 + 416) = v231;
                    uint64_t v232 = *((void *)v909 + 20);
                    uint64_t v233 = *(void *)(v885 + 360);
                    if (v233) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v233 + 8), 1uLL, memory_order_relaxed);
                    }
                    long long v234 = *(std::__shared_weak_count **)(v232 + 424);
                    *(void *)(v232 + 416) = v231;
                    *(void *)(v232 + 424) = v233;
                    if (v234 && !atomic_fetch_add(&v234->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v234->__on_zero_shared)(v234);
                      std::__shared_weak_count::__release_weak(v234);
                    }
                    long long v235 = *(std::__shared_weak_count **)(v885 + 232);
                    uint64_t v926 = *(void *)(v885 + 224);
                    uint64_t v927 = v235;
                    if (v235) {
                      atomic_fetch_add_explicit(&v235->__shared_owners_, 1uLL, memory_order_relaxed);
                    }
                    uint64_t v236 = md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_1::operator()(v961, &v958);
                    uint64_t v237 = *((void *)v909 + 8);
                    *(void *)(v237 + 256) = v236;
                    *(void *)(v237 + 264) = 0;
                    uint64_t v238 = *((void *)v909 + 20);
                    uint64_t v239 = *(std::__shared_weak_count **)(v238 + 264);
                    *(void *)(v238 + 256) = 0;
                    *(void *)(v238 + 264) = 0;
                    if (v239 && !atomic_fetch_add(&v239->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v239->__on_zero_shared)(v239);
                      std::__shared_weak_count::__release_weak(v239);
                    }
                    uint64_t v240 = v927;
                    if (v927 && !atomic_fetch_add(&v927->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v240->__on_zero_shared)(v240);
                      std::__shared_weak_count::__release_weak(v240);
                    }
                  }
                  *(void *)(*((void *)v909 + 12) + 16) = v882;
                  if (v877) {
                    *(void *)(*((void *)v909 + 12) + 40) = v868;
                  }
                  int v241 = *(unsigned __int8 *)(v885 + 396);
                  if (*(unsigned char *)(v885 + 396))
                  {
                    v216.i64[0] = *(void *)(v885 + 380);
                    v216.i32[2] = *(_DWORD *)(v885 + 388);
                    float32x4_t v836 = v216;
                    float v840 = *(float *)(v885 + 392);
                  }
                  else
                  {
                    float32x4_t v242 = v836;
                    v242.i8[0] = 0;
                    float32x4_t v836 = v242;
                  }
                  float v243 = *v903;
                  uint64_t v245 = *(void *)(v885 + 224);
                  unint64_t v244 = *(std::__shared_weak_count **)(v885 + 232);
                  uint64_t v924 = v245;
                  unint64_t v925 = v244;
                  if (v244) {
                    atomic_fetch_add_explicit(&v244->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  (*(void (**)(unsigned char *__return_ptr, uint64_t, float))(*(void *)v245 + 976))(buf, v245, v243);
                  (*(void (**)(uint64_t *__return_ptr, uint64_t, float))(*(void *)v245 + 928))(&v970, v245, v243);
                  if (buf[0])
                  {
                    __p.__r_.__value_.__s.__data_[0] = 0;
                    goto LABEL_458;
                  }
                  (*(void (**)(std::string *__return_ptr, uint64_t, float))(*(void *)v245 + 232))(&__p, v245, v243);
                  if (buf[0])
                  {
LABEL_458:
                    float v246 = *((float *)&v970 + 1);
                    if (!(_BYTE)v970) {
                      float v246 = 1.0;
                    }
                    *(void *)v910 = *(void *)&buf[4];
                    *(_DWORD *)&v910[8] = *(_DWORD *)&buf[12];
                    *(float *)&v910[12] = v246;
                    if (v241) {
                      goto LABEL_461;
                    }
                  }
                  else
                  {
                    int8x16_t v969 = v839;
                    uint64_t v476 = (int8x16_t *)((char *)__p.__r_.__value_.__r.__words + 4);
                    if (!__p.__r_.__value_.__s.__data_[0]) {
                      uint64_t v476 = &v969;
                    }
                    *(int8x16_t *)v910 = *v476;
                    if (v241)
                    {
LABEL_461:
                      float32x4_t v247 = vmlaq_n_f32(*(float32x4_t *)v910, vsubq_f32(v836, *(float32x4_t *)v910), v840);
                      *(_DWORD *)&v910[8] = v247.i32[2];
                      *(void *)v910 = v247.i64[0];
                    }
                  }
                  md::DaVinciGroundRenderLayer::setupStyleColorConstantData<ggl::DaVinci::GroundPipelineSetup,ggl::DaVinci::GroundPipelineState>(a1, (uint64_t)v909, (float32x4_t *)v910);
                  if (v244 && !atomic_fetch_add(&v244->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v244->__on_zero_shared)(v244);
                    std::__shared_weak_count::__release_weak(v244);
                  }
                  uint64_t v248 = (unsigned char *)*((void *)v909 + 2);
                  if (v248[317])
                  {
                    uint64_t v249 = *((void *)v909 + 8);
                    *(void *)(v249 + 232) = 0;
                    uint64_t v250 = v900[42];
                    *(void *)(v249 + 224) = v250;
                    uint64_t v251 = *((void *)v909 + 20);
                    uint64_t v252 = v900[43];
                    if (v252) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v252 + 8), 1uLL, memory_order_relaxed);
                    }
                    unint64_t v253 = *(std::__shared_weak_count **)(v251 + 232);
                    *(void *)(v251 + 224) = v250;
                    *(void *)(v251 + 232) = v252;
                    if (v253 && !atomic_fetch_add(&v253->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v253->__on_zero_shared)(v253);
                      std::__shared_weak_count::__release_weak(v253);
                    }
                    uint64_t v248 = (unsigned char *)*((void *)v909 + 2);
                  }
                  if (v248[331])
                  {
                    uint64_t v254 = *((void *)v909 + 8);
                    *(void *)(v254 + 120) = 0;
                    uint64_t v255 = *(void *)(a1 + 1832);
                    *(void *)(v254 + 112) = v255;
                    uint64_t v256 = *((void *)v909 + 20);
                    uint64_t v257 = *(void *)(a1 + 1840);
                    if (v257) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v257 + 8), 1uLL, memory_order_relaxed);
                    }
                    unint64_t v258 = *(std::__shared_weak_count **)(v256 + 120);
                    *(void *)(v256 + 112) = v255;
                    *(void *)(v256 + 120) = v257;
                    if (v258 && !atomic_fetch_add(&v258->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v258->__on_zero_shared)(v258);
                      std::__shared_weak_count::__release_weak(v258);
                    }
                    uint64_t v248 = (unsigned char *)*((void *)v909 + 2);
                  }
                  if (v248[330])
                  {
                    uint64_t v259 = *((void *)v909 + 8);
                    *(void *)(v259 + 104) = 0;
                    uint64_t v260 = *(void *)(a1 + 1816);
                    *(void *)(v259 + 96) = v260;
                    uint64_t v261 = *((void *)v909 + 20);
                    uint64_t v262 = *(void *)(a1 + 1824);
                    if (v262) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v262 + 8), 1uLL, memory_order_relaxed);
                    }
                    float v263 = *(std::__shared_weak_count **)(v261 + 104);
                    *(void *)(v261 + 96) = v260;
                    *(void *)(v261 + 104) = v262;
                    if (v263 && !atomic_fetch_add(&v263->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v263->__on_zero_shared)(v263);
                      std::__shared_weak_count::__release_weak(v263);
                    }
                  }
                  if (*(unsigned char *)(*((void *)v909 + 2) + 326))
                  {
                    uint64_t v264 = *((void *)v909 + 8);
                    *(void *)(v264 + 200) = 0;
                    uint64_t v265 = *(void *)(v898 + 32);
                    *(void *)(v264 + 192) = v265;
                    uint64_t v266 = *((void *)v909 + 20);
                    uint64_t v267 = *(void *)(v898 + 40);
                    if (v267) {
                      atomic_fetch_add_explicit((atomic_ullong *volatile)(v267 + 8), 1uLL, memory_order_relaxed);
                    }
                    unint64_t v268 = *(std::__shared_weak_count **)(v266 + 200);
                    *(void *)(v266 + 192) = v265;
                    *(void *)(v266 + 200) = v267;
                    if (v268 && !atomic_fetch_add(&v268->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                    {
                      ((void (*)(std::__shared_weak_count *))v268->__on_zero_shared)(v268);
                      std::__shared_weak_count::__release_weak(v268);
                    }
                  }
                  uint64_t v269 = *((void *)v909 + 8);
                  *(void *)(v269 + 56) = 0;
                  uint64_t v270 = *(void *)(v898 + 16);
                  *(void *)(v269 + 48) = v270;
                  uint64_t v271 = *((void *)v909 + 20);
                  uint64_t v272 = *(void *)(v898 + 24);
                  if (v272) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v272 + 8), 1uLL, memory_order_relaxed);
                  }
                  unint64_t v273 = *(std::__shared_weak_count **)(v271 + 56);
                  *(void *)(v271 + 48) = v270;
                  *(void *)(v271 + 56) = v272;
                  if (v273 && !atomic_fetch_add(&v273->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v273->__on_zero_shared)(v273);
                    std::__shared_weak_count::__release_weak(v273);
                  }
                  md::DaVinciGroundRenderLayer::setupCommonGroundPipelineSetup<ggl::DaVinci::GroundPipelineSetup>(v909, (void *)a5, v900, **(void **)(v885 + 32), *(void *)(*(void *)(v885 + 32) + 8), &v956, a3);
                  uint64_t v274 = *((void *)v909 + 8);
                  uint64_t v275 = v956;
                  uint64_t v276 = v957;
                  *(void *)(v274 + 176) = v956;
                  *(void *)(v274 + 184) = 0;
                  uint64_t v277 = *((void *)v909 + 20);
                  if (v276) {
                    atomic_fetch_add_explicit(&v276->__shared_owners_, 1uLL, memory_order_relaxed);
                  }
                  int v278 = *(std::__shared_weak_count **)(v277 + 184);
                  *(void *)(v277 + 176) = v275;
                  *(void *)(v277 + 184) = v276;
                  if (v278 && !atomic_fetch_add(&v278->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v278->__on_zero_shared)(v278);
                    std::__shared_weak_count::__release_weak(v278);
                  }
                  md::DaVinciGroundRenderLayer::setupSSAOGroundPipelineSetup<ggl::DaVinci::GroundPipelineSetup>(a1, v898, v909, v900, v862, _S8);
                  uint64_t v279 = **(void **)(v885 + 216);
                  int v282 = *(void **)(v279 + 120);
                  unint64_t v281 = (void *)(v279 + 120);
                  uint64_t v280 = v282;
                  if (v282)
                  {
                    unint64_t v283 = v281;
                    unint64_t v284 = v280;
                    do
                    {
                      uint64_t v285 = v284[4];
                      BOOL v286 = v285 == 0;
                      if (v285) {
                        unint64_t v287 = v284;
                      }
                      else {
                        unint64_t v287 = v284 + 1;
                      }
                      if (!v286) {
                        unint64_t v283 = v284;
                      }
                      unint64_t v284 = (void *)*v287;
                    }
                    while (*v287);
                    if (v283 == v281 || v283[4] > 1uLL)
                    {
                      uint64_t v280 = 0;
                    }
                    else
                    {
                      while (1)
                      {
                        while (1)
                        {
                          unint64_t v288 = v280[4];
                          if (v288 < 2) {
                            break;
                          }
                          uint64_t v280 = (void *)*v280;
                          if (!v280) {
                            goto LABEL_1368;
                          }
                        }
                        if (v288) {
                          break;
                        }
                        uint64_t v280 = (void *)v280[1];
                        if (!v280) {
LABEL_1368:
                        }
                          abort();
                      }
                      uint64_t v280 = (void *)v280[5];
                    }
                  }
                  uint64_t v438 = *((void *)v909 + 4);
                  *(void *)(v438 + 16) = v280;
                  *(void *)(v438 + 24) = 0;
                  uint64_t v439 = *((void *)v909 + 16);
                  long long v440 = *(std::__shared_weak_count **)(v439 + 24);
                  *(void *)(v439 + 16) = 0;
                  *(void *)(v439 + 24) = 0;
                  if (v440 && !atomic_fetch_add(&v440->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v440->__on_zero_shared)(v440);
                    std::__shared_weak_count::__release_weak(v440);
                  }
                  uint64_t v441 = **(void **)(v885 + 216);
                  float v444 = *(void **)(v441 + 120);
                  uint64_t v443 = (void *)(v441 + 120);
                  uint64_t v442 = v444;
                  if (v444)
                  {
                    float v445 = v442;
                    do
                    {
                      float32x2_t v446 = v445;
                      float v445 = (void *)*v445;
                    }
                    while (v445);
                    if (v446 == v443 || v446[4])
                    {
                      uint64_t v442 = 0;
                    }
                    else
                    {
                      while (v442[4])
                      {
                        uint64_t v442 = (void *)*v442;
                        if (!v442) {
                          goto LABEL_1368;
                        }
                      }
                      uint64_t v442 = (void *)v442[5];
                    }
                  }
                  uint64_t v447 = *((void *)v909 + 4);
                  *(void *)(v447 + 32) = v442;
                  *(void *)(v447 + 40) = 0;
                  uint64_t v448 = *((void *)v909 + 16);
                  unint64_t v449 = *(std::__shared_weak_count **)(v448 + 40);
                  *(void *)(v448 + 32) = 0;
                  *(void *)(v448 + 40) = 0;
                  if (v449 && !atomic_fetch_add(&v449->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v449->__on_zero_shared)(v449);
                    std::__shared_weak_count::__release_weak(v449);
                  }
                  uint64_t v450 = **(void **)(v885 + 216);
                  uint64_t v453 = *(void **)(v450 + 120);
                  uint64_t v452 = (void *)(v450 + 120);
                  uint64_t v451 = v453;
                  if (v453)
                  {
                    uint64_t v454 = v452;
                    uint64_t v455 = v451;
                    do
                    {
                      unint64_t v456 = v455[4];
                      _CF = v456 >= 2;
                      if (v456 >= 2) {
                        uint64_t v458 = v455;
                      }
                      else {
                        uint64_t v458 = v455 + 1;
                      }
                      if (_CF) {
                        uint64_t v454 = v455;
                      }
                      uint64_t v455 = (void *)*v458;
                    }
                    while (*v458);
                    if (v454 == v452 || v454[4] > 2uLL)
                    {
                      uint64_t v451 = 0;
                    }
                    else
                    {
                      while (1)
                      {
                        while (1)
                        {
                          unint64_t v459 = v451[4];
                          if (v459 < 3) {
                            break;
                          }
                          uint64_t v451 = (void *)*v451;
                          if (!v451) {
                            goto LABEL_1368;
                          }
                        }
                        if (v459 == 2) {
                          break;
                        }
                        uint64_t v451 = (void *)v451[1];
                        if (!v451) {
                          goto LABEL_1368;
                        }
                      }
                      uint64_t v451 = (void *)v451[5];
                    }
                  }
                  uint64_t v460 = *((void *)v909 + 4);
                  *(void *)(v460 + 48) = v451;
                  *(void *)(v460 + 56) = 0;
                  uint64_t v461 = *((void *)v909 + 16);
                  uint64_t v462 = *(std::__shared_weak_count **)(v461 + 56);
                  *(void *)(v461 + 48) = 0;
                  *(void *)(v461 + 56) = 0;
                  if (v462 && !atomic_fetch_add(&v462->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v462->__on_zero_shared)(v462);
                    std::__shared_weak_count::__release_weak(v462);
                    if (v876) {
                      goto LABEL_711;
                    }
                  }
                  else if (v876)
                  {
LABEL_711:
                    unint64_t v463 = v964;
                    if (!v964) {
                      goto LABEL_980;
                    }
                    int v464 = *(void **)(v963 + 1304);
                    unint64_t v465 = v464[1];
                    if (!v465) {
                      goto LABEL_980;
                    }
                    uint8x8_t v466 = (uint8x8_t)vcnt_s8((int8x8_t)v465);
                    v466.i16[0] = vaddlv_u8(v466);
                    if (v466.u32[0] > 1uLL)
                    {
                      unint64_t v467 = v964;
                      if (v465 <= v964) {
                        unint64_t v467 = v964 % v465;
                      }
                    }
                    else
                    {
                      unint64_t v467 = (v465 - 1) & (unint64_t)v964;
                    }
                    uint64_t v477 = *(uint64_t ***)(*v464 + 8 * v467);
                    if (!v477) {
                      goto LABEL_980;
                    }
                    uint64_t v478 = *v477;
                    if (!v478) {
                      goto LABEL_980;
                    }
                    if (v466.u32[0] < 2uLL)
                    {
                      unint64_t v479 = v465 - 1;
                      while (1)
                      {
                        uint64_t v481 = v478[1];
                        if (v481 == v964)
                        {
                          if (*((_DWORD *)v478 + 4) == v964) {
                            goto LABEL_976;
                          }
                        }
                        else if ((v481 & v479) != v467)
                        {
                          goto LABEL_980;
                        }
                        uint64_t v478 = (uint64_t *)*v478;
                        if (!v478) {
                          goto LABEL_980;
                        }
                      }
                    }
                    while (1)
                    {
                      unint64_t v480 = v478[1];
                      if (v480 == v964)
                      {
                        if (*((_DWORD *)v478 + 4) == v964)
                        {
LABEL_976:
                          if (v478[3])
                          {
                            uint64_t v603 = md::DaVinciGroundRenderResources::debugTextureForAttribute(v837, v964);
                            int8x8_t v604 = (int8x8_t)v464[1];
                            if (v604)
                            {
                              uint8x8_t v605 = (uint8x8_t)vcnt_s8(v604);
                              v605.i16[0] = vaddlv_u8(v605);
                              if (v605.u32[0] > 1uLL)
                              {
                                unint64_t v606 = v463;
                                if (*(void *)&v604 <= v463) {
                                  unint64_t v606 = v463 % *(void *)&v604;
                                }
                              }
                              else
                              {
                                unint64_t v606 = (v604.i32[0] - 1) & v463;
                              }
                              unint64_t v821 = *(uint64_t ***)(*v464 + 8 * v606);
                              if (v821)
                              {
                                v822 = *v821;
                                if (v822)
                                {
                                  if (v605.u32[0] < 2uLL)
                                  {
                                    uint64_t v823 = *(void *)&v604 - 1;
                                    while (1)
                                    {
                                      uint64_t v825 = v822[1];
                                      if (v825 == v463)
                                      {
                                        if (*((_DWORD *)v822 + 4) == v463) {
                                          goto LABEL_1366;
                                        }
                                      }
                                      else if ((v825 & v823) != v606)
                                      {
                                        goto LABEL_1362;
                                      }
                                      v822 = (uint64_t *)*v822;
                                      if (!v822) {
                                        goto LABEL_1365;
                                      }
                                    }
                                  }
                                  while (1)
                                  {
                                    unint64_t v824 = v822[1];
                                    if (v824 == v463)
                                    {
                                      if (*((_DWORD *)v822 + 4) == v463)
                                      {
LABEL_1366:
                                        uint64_t v609 = v822[3];
                                        goto LABEL_1363;
                                      }
                                    }
                                    else
                                    {
                                      if (v824 >= *(void *)&v604) {
                                        v824 %= *(void *)&v604;
                                      }
                                      if (v824 != v606) {
                                        break;
                                      }
                                    }
                                    v822 = (uint64_t *)*v822;
                                    if (!v822)
                                    {
LABEL_1365:
                                      float v611 = 255.0;
                                      uint64_t v609 = 0;
                                      uint64_t v610 = v603;
                                      goto LABEL_989;
                                    }
                                  }
                                }
                              }
                            }
LABEL_1362:
                            uint64_t v609 = 0;
LABEL_1363:
                            float v611 = 255.0;
                            uint64_t v610 = v603;
                            goto LABEL_989;
                          }
LABEL_980:
                          if (v858)
                          {
                            if (*(unsigned char *)(v858 + 122))
                            {
                              uint64_t v607 = *(void *)(v858 + 32);
                              md::StyleTexture<md::LowZoomClimateStyle>::_processStylePixelsIfNecessary(v607);
                            }
                            else
                            {
                              uint64_t v607 = *(void *)(v858 + 16);
                              md::StyleTexture<md::LowZoomStyle>::_processStylePixelsIfNecessary(v607);
                            }
                            uint64_t v610 = *(void *)(v607 + 24);
                            uint64_t v609 = *(void *)v858;
                            float32x4_t v612 = *(std::__shared_weak_count **)(v858 + 8);
                            if (v612)
                            {
                              atomic_fetch_add_explicit(&v612->__shared_owners_, 1uLL, memory_order_relaxed);
                              if (!atomic_fetch_add(&v612->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                              {
                                ((void (*)(std::__shared_weak_count *))v612->__on_zero_shared)(v612);
                                std::__shared_weak_count::__release_weak(v612);
                              }
                            }
                            LOWORD(v608) = *(_WORD *)(v858 + 120);
                            float v611 = (float)v608;
                          }
                          else
                          {
                            uint64_t v609 = 0;
                            uint64_t v610 = 0;
                            float v611 = 255.0;
                          }
LABEL_989:
                          float v613 = v909;
                          uint64_t v614 = *(void *)(*((void *)v909 + 8) + 272);
                          if (!v614)
                          {
                            float v615 = (std::__shared_weak_count *)operator new(0xE8uLL);
                            v615->__shared_owners_ = 0;
                            v615->__shared_weak_owners_ = 0;
                            v615->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF587528;
                            uint64_t v616 = ggl::BufferData::BufferData((uint64_t)&v615[1], qword_1E955BA40, 2, 1, 6, 1);
                            v615[9].__shared_owners_ = (uint64_t)ggl::DaVinci::LandCoverSettings::reflection(void)::reflection;
                            v615[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EF55E718;
                            uint64_t v617 = *((void *)v909 + 8);
                            *(void *)(v617 + 272) = v616;
                            *(void *)(v617 + 280) = 0;
                            uint64_t v618 = *((void *)v909 + 20);
                            atomic_fetch_add_explicit(&v615->__shared_owners_, 1uLL, memory_order_relaxed);
                            BOOL v619 = *(std::__shared_weak_count **)(v618 + 280);
                            *(void *)(v618 + 272) = v616;
                            *(void *)(v618 + 280) = v615;
                            if (v619 && !atomic_fetch_add(&v619->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v619->__on_zero_shared)(v619);
                              std::__shared_weak_count::__release_weak(v619);
                            }
                            if (!atomic_fetch_add(&v615->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                            {
                              ((void (*)(std::__shared_weak_count *))v615->__on_zero_shared)(v615);
                              std::__shared_weak_count::__release_weak(v615);
                            }
                            float v613 = v909;
                            uint64_t v614 = *(void *)(*((void *)v909 + 8) + 272);
                            unint64_t v217 = (float *)(a3 + 20);
                          }
                          unint64_t v620 = *(void *)(v614 + 8);
                          **(float **)(v614 + 72) = v611;
                          *(void *)(*((void *)v613 + 12) + 56) = v609;
                          *(void *)(*((void *)v613 + 12) + 64) = v610;
                          if (*(void *)(v614 + 64) > v620) {
                            unint64_t v620 = *(void *)(v614 + 64);
                          }
                          *(void *)(v614 + 56) = 0;
                          *(void *)(v614 + 64) = v620;
LABEL_999:
                          if (!updated)
                          {
                            uint64_t v625 = 0;
                            *(void *)(*((void *)v909 + 12) + 80) = 0;
                            goto LABEL_1072;
                          }
                          v621 = *(void **)(v963 + 1304);
                          if (v966)
                          {
                            int8x8_t v622 = (int8x8_t)v621[1];
                            if (v622)
                            {
                              uint8x8_t v623 = (uint8x8_t)vcnt_s8(v622);
                              v623.i16[0] = vaddlv_u8(v623);
                              if (v623.u32[0] > 1uLL) {
                                uint64_t v624 = *(void *)&v622 <= 0x99uLL ? 0x99uLL % *(void *)&v622 : 153;
                              }
                              else {
                                uint64_t v624 = (v622.i32[0] - 1) & 0x99;
                              }
                              uint64_t v626 = *(uint64_t ***)(*v621 + 8 * v624);
                              if (v626)
                              {
                                uint64_t v627 = *v626;
                                if (v627)
                                {
                                  if (v623.u32[0] < 2uLL)
                                  {
                                    uint64_t v628 = *(void *)&v622 - 1;
                                    while (1)
                                    {
                                      uint64_t v630 = v627[1];
                                      if (v630 == 153)
                                      {
                                        if (*((_DWORD *)v627 + 4) == 153) {
                                          goto LABEL_1024;
                                        }
                                      }
                                      else if ((v630 & v628) != v624)
                                      {
                                        goto LABEL_1025;
                                      }
                                      uint64_t v627 = (uint64_t *)*v627;
                                      if (!v627) {
                                        goto LABEL_1025;
                                      }
                                    }
                                  }
                                  do
                                  {
                                    unint64_t v629 = v627[1];
                                    if (v629 == 153)
                                    {
                                      if (*((_DWORD *)v627 + 4) == 153)
                                      {
LABEL_1024:
                                        uint64_t v631 = v627[3];
                                        if (!v631) {
                                          break;
                                        }
LABEL_1036:
                                        *(void *)(*((void *)v909 + 12) + 80) = v631;
                                        if (!v965
                                          || (int8x8_t v637 = (int8x8_t)v621[1], !*(void *)&v637)
                                          || ((uint8x8_t v638 = (uint8x8_t)vcnt_s8(v637),
                                               v638.i16[0] = vaddlv_u8(v638),
                                               v638.u32[0] > 1uLL)
                                            ? (*(void *)&v637 <= 0x9AuLL
                                             ? (uint64_t v639 = 0x9AuLL % *(void *)&v637)
                                             : (uint64_t v639 = 154))
                                            : (uint64_t v639 = (v637.i32[0] - 1) & 0x9ALL),
                                              (v640 = *(uint64_t ***)(*v621 + 8 * v639)) == 0 || (unint64_t v641 = *v640) == 0))
                                        {
LABEL_1061:
                                          uint64_t v645 = a1 + 3248;
                                          uint64_t v646 = *v861;
                                          if (!*v861) {
                                            goto LABEL_1071;
                                          }
                                          do
                                          {
                                            unsigned int v647 = *(_DWORD *)(v646 + 32);
                                            BOOL v648 = v647 >= 0x9A;
                                            if (v647 >= 0x9A) {
                                              uint64_t v649 = (uint64_t *)v646;
                                            }
                                            else {
                                              uint64_t v649 = (uint64_t *)(v646 + 8);
                                            }
                                            if (v648) {
                                              uint64_t v645 = v646;
                                            }
                                            uint64_t v646 = *v649;
                                          }
                                          while (*v649);
                                          if ((uint64_t *)v645 != v861 && *(_DWORD *)(v645 + 32) <= 0x9Au) {
                                            uint64_t v625 = *(void *)(v645 + 40);
                                          }
                                          else {
LABEL_1071:
                                          }
                                            uint64_t v625 = 0;
                                          goto LABEL_1072;
                                        }
                                        if (v638.u32[0] < 2uLL)
                                        {
                                          uint64_t v642 = *(void *)&v637 - 1;
                                          while (1)
                                          {
                                            uint64_t v644 = v641[1];
                                            if (v644 == 154)
                                            {
                                              if (*((_DWORD *)v641 + 4) == 154) {
                                                goto LABEL_1060;
                                              }
                                            }
                                            else if ((v644 & v642) != v639)
                                            {
                                              goto LABEL_1061;
                                            }
                                            unint64_t v641 = (uint64_t *)*v641;
                                            if (!v641) {
                                              goto LABEL_1061;
                                            }
                                          }
                                        }
                                        while (1)
                                        {
                                          unint64_t v643 = v641[1];
                                          if (v643 == 154)
                                          {
                                            if (*((_DWORD *)v641 + 4) == 154)
                                            {
LABEL_1060:
                                              uint64_t v625 = v641[3];
                                              if (!v625) {
                                                goto LABEL_1061;
                                              }
LABEL_1072:
                                              *(void *)(*((void *)v909 + 12) + 72) = v625;
                                              if (v874)
                                              {
                                                long long v923 = v939;
                                                if (*((void *)&v939 + 1)) {
                                                  atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v939 + 1) + 8), 1uLL, memory_order_relaxed);
                                                }
                                                uint64_t v650 = md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_3::operator()(v959, &v938, (uint64_t)v865);
                                                uint64_t v651 = *((void *)v909 + 8);
                                                *(void *)(v651 + 352) = v650;
                                                *(void *)(v651 + 360) = 0;
                                                uint64_t v652 = *((void *)v909 + 20);
                                                unint64_t v653 = *(std::__shared_weak_count **)(v652 + 360);
                                                *(void *)(v652 + 352) = 0;
                                                *(void *)(v652 + 360) = 0;
                                                if (v653
                                                  && !atomic_fetch_add(&v653->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v653->__on_zero_shared)(v653);
                                                  std::__shared_weak_count::__release_weak(v653);
                                                }
                                                uint64_t v654 = (std::__shared_weak_count *)*((void *)&v923 + 1);
                                                if (*((void *)&v923 + 1)
                                                  && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v923 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v654->__on_zero_shared)(v654);
                                                  std::__shared_weak_count::__release_weak(v654);
                                                }
                                                uint64_t v655 = md::LayoutContext::frameState(a2);
                                                md::SharedResource::addFrameRef(v865, *(void *)(v655 + 624));
                                                *(void *)(*((void *)v909 + 12) + 88) = *((void *)v865 + 4);
                                                if (!v866) {
                                                  goto LABEL_1103;
                                                }
                                                long long v922 = v939;
                                                if (*((void *)&v939 + 1)) {
                                                  atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v939 + 1) + 8), 1uLL, memory_order_relaxed);
                                                }
                                                uint64_t v656 = md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_3::operator()(v959, &v938, (uint64_t)v852);
                                                uint64_t v657 = *((void *)v909 + 8);
                                                *(void *)(v657 + 368) = v656;
                                                *(void *)(v657 + 376) = 0;
                                                uint64_t v658 = *((void *)v909 + 20);
                                                unint64_t v659 = *(std::__shared_weak_count **)(v658 + 376);
                                                *(void *)(v658 + 368) = 0;
                                                *(void *)(v658 + 376) = 0;
                                                if (v659
                                                  && !atomic_fetch_add(&v659->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v659->__on_zero_shared)(v659);
                                                  std::__shared_weak_count::__release_weak(v659);
                                                }
                                                double v660 = (std::__shared_weak_count *)*((void *)&v922 + 1);
                                                if (*((void *)&v922 + 1)
                                                  && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v922 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v660->__on_zero_shared)(v660);
                                                  std::__shared_weak_count::__release_weak(v660);
                                                }
                                                uint64_t v661 = md::LayoutContext::frameState(a2);
                                                md::SharedResource::addFrameRef(v852, *(void *)(v661 + 624));
                                                *(void *)(*((void *)v909 + 12) + 96) = *((void *)v852 + 4);
                                                uint64_t v662 = *((void *)v909 + 8);
                                                *(void *)(v662 + 392) = 0;
                                                uint64_t v663 = *(void *)(a1 + 2032);
                                                *(void *)(v662 + 384) = v663;
                                                uint64_t v664 = *((void *)v909 + 20);
                                                uint64_t v665 = *(void *)(a1 + 2040);
                                                if (v665) {
                                                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v665 + 8), 1uLL, memory_order_relaxed);
                                                }
                                                uint64_t v666 = *(std::__shared_weak_count **)(v664 + 392);
                                                *(void *)(v664 + 384) = v663;
                                                *(void *)(v664 + 392) = v665;
                                                if (!v666) {
                                                  goto LABEL_1103;
                                                }
LABEL_1101:
                                                if (!atomic_fetch_add(&v666->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v666->__on_zero_shared)(v666);
                                                  std::__shared_weak_count::__release_weak(v666);
                                                }
                                                goto LABEL_1103;
                                              }
                                              uint64_t v667 = *((void *)v909 + 8);
                                              *(void *)(v667 + 352) = 0;
                                              *(void *)(v667 + 360) = 0;
                                              uint64_t v668 = *((void *)v909 + 20);
                                              unint64_t v669 = *(std::__shared_weak_count **)(v668 + 360);
                                              *(void *)(v668 + 352) = 0;
                                              *(void *)(v668 + 360) = 0;
                                              if (v669
                                                && !atomic_fetch_add(&v669->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                              {
                                                ((void (*)(std::__shared_weak_count *))v669->__on_zero_shared)(v669);
                                                std::__shared_weak_count::__release_weak(v669);
                                              }
                                              *(void *)(*((void *)v909 + 12) + 88) = 0;
                                              uint64_t v670 = *((void *)v909 + 8);
                                              *(void *)(v670 + 368) = 0;
                                              *(void *)(v670 + 376) = 0;
                                              uint64_t v671 = *((void *)v909 + 20);
                                              uint64_t v672 = *(std::__shared_weak_count **)(v671 + 376);
                                              *(void *)(v671 + 368) = 0;
                                              *(void *)(v671 + 376) = 0;
                                              if (v672
                                                && !atomic_fetch_add(&v672->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                              {
                                                ((void (*)(std::__shared_weak_count *))v672->__on_zero_shared)(v672);
                                                std::__shared_weak_count::__release_weak(v672);
                                              }
                                              *(void *)(*((void *)v909 + 12) + 96) = 0;
                                              uint64_t v673 = *((void *)v909 + 8);
                                              *(void *)(v673 + 384) = 0;
                                              *(void *)(v673 + 392) = 0;
                                              uint64_t v674 = *((void *)v909 + 20);
                                              uint64_t v666 = *(std::__shared_weak_count **)(v674 + 392);
                                              *(void *)(v674 + 384) = 0;
                                              *(void *)(v674 + 392) = 0;
                                              if (v666) {
                                                goto LABEL_1101;
                                              }
LABEL_1103:
                                              float v675 = *(float *)(v899 + 20);
                                              if (*(unsigned char *)(v885 + 145) == 1 && *(unsigned char *)(a1 + 3560) == 1)
                                              {
                                                if (v675 >= 0.25)
                                                {
                                                  int v676 = 1;
                                                  goto LABEL_1110;
                                                }
LABEL_1108:
                                                int v676 = 2;
                                              }
                                              else
                                              {
                                                if (v675 < 0.25) {
                                                  goto LABEL_1108;
                                                }
                                                int v676 = 0;
                                              }
LABEL_1110:
                                              if (*(unsigned char *)(*((void *)v909 + 2) + 309))
                                              {
                                                v677 = (uint64_t *)(a1 + 1848);
                                                if (v676)
                                                {
                                                  if (v676 == 2) {
                                                    v677 = (uint64_t *)(a1 + 1880);
                                                  }
                                                  else {
                                                    v677 = (uint64_t *)(a1 + 1864);
                                                  }
                                                }
                                                uint64_t v678 = *((void *)v909 + 8);
                                                *(void *)(v678 + 296) = 0;
                                                uint64_t v679 = *v677;
                                                *(void *)(v678 + 288) = *v677;
                                                uint64_t v680 = *((void *)v909 + 20);
                                                uint64_t v681 = v677[1];
                                                if (v681) {
                                                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v681 + 8), 1uLL, memory_order_relaxed);
                                                }
                                                os_signpost_id_t v682 = *(std::__shared_weak_count **)(v680 + 296);
                                                *(void *)(v680 + 288) = v679;
                                                *(void *)(v680 + 296) = v681;
                                                if (v682
                                                  && !atomic_fetch_add(&v682->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v682->__on_zero_shared)(v682);
                                                  std::__shared_weak_count::__release_weak(v682);
                                                }
                                              }
                                              md::DaVinciGroundRenderLayer::setupStyleGroundOcclusionConstantData<ggl::DaVinci::GroundPipelineSetup,ggl::DaVinci::GroundPipelineState>(a1, v909, v884, a5, a3);
                                              if (v934)
                                              {
                                                v683.i64[0] = v935;
                                                v683.i32[2] = v936;
                                              }
                                              else
                                              {
                                                v683.i32[0] = 0;
                                                v684.i8[0] = v931;
                                                int8x16_t v685 = vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v684, v683), 0);
                                                v684.i64[0] = v932;
                                                v684.i32[2] = v933;
                                                int8x16_t v683 = vbslq_s8(v685, (int8x16_t)0, v684);
                                              }
                                              if (*(unsigned char *)(*((void *)v909 + 2) + 327))
                                              {
                                                float32x4_t v892 = (float32x4_t)v683;
                                                os_signpost_type_t v686 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleEmissiveColor>>::pop(*(void *)(a1 + 1928));
                                                unint64_t v687 = v686[1];
                                                uint64_t v688 = v686[9];
                                                float16x4_t v689 = vcvt_f16_f32(v892);
                                                *(_WORD *)(v688 + 4) = v689.i16[2];
                                                *(_DWORD *)uint64_t v688 = v689.i32[0];
                                                if (v686[8] > v687) {
                                                  unint64_t v687 = v686[8];
                                                }
                                                v686[7] = 0;
                                                v686[8] = v687;
                                                uint64_t v690 = *((void *)v909 + 8);
                                                *(void *)(v690 + 304) = v686;
                                                *(void *)(v690 + 312) = 0;
                                                uint64_t v691 = *((void *)v909 + 20);
                                                uint64_t v692 = *(std::__shared_weak_count **)(v691 + 312);
                                                *(void *)(v691 + 304) = 0;
                                                *(void *)(v691 + 312) = 0;
                                                if (v692
                                                  && !atomic_fetch_add(&v692->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v692->__on_zero_shared)(v692);
                                                  std::__shared_weak_count::__release_weak(v692);
                                                }
                                              }
                                              (*(void (**)(unsigned char *__return_ptr, float))(*(void *)*v906
                                                                                                 + 504))(v910, *v217);
                                              if (v910[0]) {
                                                _S8 = *(float *)&v910[4];
                                              }
                                              else {
                                                _S8 = 1.0;
                                              }
                                              if ((_BYTE)v937) {
                                                _S9 = *((float *)&v937 + 1);
                                              }
                                              else {
                                                _S9 = 0.0;
                                              }
                                              if (*(unsigned char *)(*((void *)v909 + 2) + 326))
                                              {
                                                double v695 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>>>::find<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>(v846, _S8, _S9);
                                                if (v695)
                                                {
                                                  double v696 = (void *)*((void *)v695 + 3);
                                                }
                                                else
                                                {
                                                  double v697 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle>>::pop(*(void *)(a1 + 1968));
                                                  double v696 = v697;
                                                  unint64_t v698 = v697[1];
                                                  double v699 = (_WORD *)v697[9];
                                                  __asm
                                                  {
                                                    FCVT            H0, S8
                                                    FCVT            H1, S9
                                                  }
                                                  _WORD *v699 = _H0;
                                                  v699[1] = _H1;
                                                  if (v697[8] > v698) {
                                                    unint64_t v698 = v697[8];
                                                  }
                                                  v697[7] = 0;
                                                  v697[8] = v698;
                                                  std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>,std::equal_to<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey>,md::DaVinciGroundRenderLayer::ShinyStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ShinyStyleCacheKey,md::DaVinciGroundRenderLayer::ShinyStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::MaterialStyle> *&>(v846, LODWORD(_S8) | ((unint64_t)LODWORD(_S9) << 32), (uint64_t)v697, _S8, _S9);
                                                }
                                                uint64_t v702 = *((void *)v909 + 8);
                                                *(void *)(v702 + 336) = v696;
                                                *(void *)(v702 + 344) = 0;
                                                uint64_t v703 = *((void *)v909 + 20);
                                                double v704 = *(std::__shared_weak_count **)(v703 + 344);
                                                *(void *)(v703 + 336) = 0;
                                                *(void *)(v703 + 344) = 0;
                                                if (v704
                                                  && !atomic_fetch_add(&v704->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v704->__on_zero_shared)(v704);
                                                  std::__shared_weak_count::__release_weak(v704);
                                                }
                                              }
                                              if (v873)
                                              {
                                                *(void *)(*((void *)v909 + 12) + 32) = v845;
                                                if (v946)
                                                {
                                                  v705.i64[0] = v947;
                                                  v705.i64[1] = __PAIR64__(v839.u32[3], v948);
                                                }
                                                else
                                                {
                                                  float32x4_t v705 = v945;
                                                }
                                                float32x4_t v893 = v705;
                                                *(float32x4_t *)long long buf = v705;
                                                buf[16] = 1;
                                                uint64_t v706 = std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::find<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>(v842, (float *)buf);
                                                if (v706)
                                                {
                                                  uint64_t v707 = *(void *)(v706 + 40);
                                                }
                                                else
                                                {
                                                  uint64_t v708 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask>>::pop(*(void *)(a1 + 1920));
                                                  uint64_t v707 = v708;
                                                  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = 0uLL;
                                                  unint64_t v709 = *(void *)(v708 + 8);
                                                  if (v709) {
                                                    uint64_t v710 = *(float16x4_t **)(v708 + 72);
                                                  }
                                                  else {
                                                    uint64_t v710 = 0;
                                                  }
                                                  float32x4_t v711 = v893;
                                                  v712.i64[0] = 0;
                                                  v712.i64[1] = v708;
                                                  float32x4_t v894 = v712;
                                                  *(float32x4_t *)&__p.__r_.__value_.__l.__data_ = v712;
                                                  __p.__r_.__value_.__r.__words[2] = 0;
                                                  *(void *)uint64_t v972 = v709;
                                                  *(void *)&v972[16] = v710;
                                                  *(_WORD *)&v972[8] = 1;
                                                  *uint64_t v710 = vcvt_f16_f32(v711);
                                                  std::__hash_table<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::__unordered_map_hasher<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,true>,std::__unordered_map_equal<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>,std::equal_to<md::DaVinciGroundRenderLayer::ColorStyleCacheKey>,md::DaVinciGroundRenderLayer::ColorStyleCacheKeyHasher,true>,std::allocator<std::__hash_value_type<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *>>>::__emplace_unique_key_args<md::DaVinciGroundRenderLayer::ColorStyleCacheKey,md::DaVinciGroundRenderLayer::ColorStyleCacheKey const&,ggl::ConstantDataTyped<ggl::DaVinci::StyleRouteLineMask> *&>(v842, (unsigned int *)buf, (uint64_t)buf, v708);
                                                  if (v709)
                                                  {
                                                    if (v894.i64[0] && *(unsigned char *)(v894.i64[1] + 17) != 2) {
                                                      (*(void (**)(void))(*(void *)v894.i64[0] + 64))();
                                                    }
                                                    unint64_t v713 = *(void *)(v894.i64[1] + 64);
                                                    if (v713 <= v709) {
                                                      unint64_t v713 = v709;
                                                    }
                                                    *(void *)(v894.i64[1] + 56) = 0;
                                                    *(void *)(v894.i64[1] + 64) = v713;
                                                  }
                                                }
                                                uint64_t v714 = *((void *)v909 + 8);
                                                *(void *)(v714 + 464) = v707;
                                                *(void *)(v714 + 472) = 0;
                                                uint64_t v715 = *((void *)v909 + 20);
                                                BOOL v716 = *(std::__shared_weak_count **)(v715 + 472);
                                                *(void *)(v715 + 464) = 0;
                                                *(void *)(v715 + 472) = 0;
                                                if (v716
                                                  && !atomic_fetch_add(&v716->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v716->__on_zero_shared)(v716);
                                                  std::__shared_weak_count::__release_weak(v716);
                                                }
                                              }
                                              if (*(unsigned __int8 *)(*v906 + 8) - 3 <= 1
                                                && *(unsigned char *)(*((void *)v909 + 2) + 329))
                                              {
                                                uint64_t v598 = ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::PlanarParameters>>::pop(*(void *)(a1 + 1952));
                                                uint64_t v717 = *((void *)v909 + 8);
                                                *(void *)(v717 + 64) = v598;
                                                *(void *)(v717 + 72) = 0;
                                                uint64_t v718 = *((void *)v909 + 20);
                                                uint64_t v719 = *(std::__shared_weak_count **)(v718 + 72);
                                                *(void *)(v718 + 64) = 0;
                                                *(void *)(v718 + 72) = 0;
                                                if (v719
                                                  && !atomic_fetch_add(&v719->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                                                {
                                                  ((void (*)(std::__shared_weak_count *))v719->__on_zero_shared)(v719);
                                                  std::__shared_weak_count::__release_weak(v719);
                                                }
                                              }
                                              else
                                              {
                                                uint64_t v598 = 0;
                                              }
                                              uint64_t v602 = "standard material renderable - ground pipeline";
                                              if (!v598) {
                                                goto LABEL_1196;
                                              }
                                              goto LABEL_1171;
                                            }
                                          }
                                          else
                                          {
                                            if (v643 >= *(void *)&v637) {
                                              v643 %= *(void *)&v637;
                                            }
                                            if (v643 != v639) {
                                              goto LABEL_1061;
                                            }
                                          }
                                          unint64_t v641 = (uint64_t *)*v641;
                                          if (!v641) {
                                            goto LABEL_1061;
                                          }
                                        }
                                      }
                                    }
                                    else
                                    {
                                      if (v629 >= *(void *)&v622) {
                                        v629 %= *(void *)&v622;
                                      }
                                      if (v629 != v624) {
                                        break;
                                      }
                                    }
                                    uint64_t v627 = (uint64_t *)*v627;
                                  }
                                  while (v627);
                                }
                              }
                            }
                          }
LABEL_1025:
                          uint64_t v632 = a1 + 3248;
                          uint64_t v633 = *v861;
                          if (!*v861) {
                            goto LABEL_1035;
                          }
                          do
                          {
                            unsigned int v634 = *(_DWORD *)(v633 + 32);
                            BOOL v635 = v634 >= 0x99;
                            if (v634 >= 0x99) {
                              std::string::size_type v636 = (uint64_t *)v633;
                            }
                            else {
                              std::string::size_type v636 = (uint64_t *)(v633 + 8);
                            }
                            if (v635) {
                              uint64_t v632 = v633;
                            }
                            uint64_t v633 = *v636;
                          }
                          while (*v636);
                          if ((uint64_t *)v632 != v861 && *(_DWORD *)(v632 + 32) <= 0x99u) {
                            uint64_t v631 = *(void *)(v632 + 40);
                          }
                          else {
LABEL_1035:
                          }
                            uint64_t v631 = 0;
                          goto LABEL_1036;
                        }
                      }
                      else
                      {
                        if (v480 >= v465) {
                          v480 %= v465;
                        }
                        if (v480 != v467) {
                          goto LABEL_980;
                        }
                      }
                      uint64_t v478 = (uint64_t *)*v478;
                      if (!v478) {
                        goto LABEL_980;
                      }
                    }
                  }
                  *(void *)(*((void *)v909 + 12) + 64) = 0;
                  *(void *)(*((void *)v909 + 12) + 56) = 0;
                  uint64_t v468 = *((void *)v909 + 8);
                  *(void *)(v468 + 272) = 0;
                  *(void *)(v468 + 280) = 0;
                  uint64_t v469 = *((void *)v909 + 20);
                  unint64_t v470 = *(std::__shared_weak_count **)(v469 + 280);
                  *(void *)(v469 + 272) = 0;
                  *(void *)(v469 + 280) = 0;
                  if (v470 && !atomic_fetch_add(&v470->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v470->__on_zero_shared)(v470);
                    std::__shared_weak_count::__release_weak(v470);
                  }
                  goto LABEL_999;
                }
              }
              else
              {
                uint64_t v845 = 0;
              }
              BOOL v873 = 0;
              unsigned int v166 = v871;
              if ((v896 & 1) == 0) {
                goto LABEL_342;
              }
              goto LABEL_343;
            }
          }
        }
LABEL_1312:
        uint64_t v83 = v957;
        goto LABEL_1313;
      }
    }
  }
  else
  {
LABEL_165:
    uint64_t v899 = 0;
    if (*v19) {
      goto LABEL_166;
    }
  }
}

void sub_1A1AD5E5C(_Unwind_Exception *a1)
{
}

uint64_t md::DaVinciGroundRenderLayer::layoutMaterialRenderables(md::LayoutContext const&,md::DaVinciGroundRenderLayer::MeshLayoutContext const&,md::DaVinciGroundRenderLayer::MaterialConstants &,md::DaVinciGroundRenderable *,geo::slice<std::__wrap_iter<unsigned long *>>,std::vector<md::MeshRenderable *> const&,ggl::CommandBuffer *,BOOL)::$_3::operator()(void *a1, unint64_t *a2, uint64_t a3)
{
  unint64_t v5 = (unint64_t)a1;
  uint64_t v6 = (int8x8_t *)a1[1];
  int8x8_t v7 = v6[26];
  if (v7)
  {
    unint64_t v8 = *a2;
    uint8x8_t v9 = (uint8x8_t)vcnt_s8(v7);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      unint64_t v10 = *a2;
      if (v8 >= *(void *)&v7) {
        unint64_t v10 = v8 % *(void *)&v7;
      }
    }
    else
    {
      unint64_t v10 = (*(void *)&v7 - 1) & v8;
    }
    unint64_t v11 = *(void **)(*(void *)&v6[25] + 8 * v10);
    if (v11)
    {
      uint64_t v12 = (void *)*v11;
      if (v12)
      {
        if (v9.u32[0] < 2uLL)
        {
          uint64_t v13 = *(void *)&v7 - 1;
          while (1)
          {
            uint64_t v15 = v12[1];
            if (v15 == v8)
            {
              if (v12[2] == v8) {
                return v12[3];
              }
            }
            else if ((v15 & v13) != v10)
            {
              goto LABEL_21;
            }
            uint64_t v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_21;
            }
          }
        }
        do
        {
          unint64_t v14 = v12[1];
          if (v14 == v8)
          {
            if (v12[2] == v8) {
              return v12[3];
            }
          }
          else
          {
            if (v14 >= *(void *)&v7) {
              v14 %= *(void *)&v7;
            }
            if (v14 != v10) {
              break;
            }
          }
          uint64_t v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_21:
  uint64_t v16 = *(void *)(*a1 + 1728);
  uint64_t v17 = *(void *)(v16 + 8);
  if (v17 == *(void *)v16)
  {
    uint64_t v28 = *(void *)(v16 + 88);
    if (!v28)
    {
LABEL_171:
      std::__throw_bad_function_call[abi:nn180100]();
LABEL_172:
      abort();
    }
    uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)v28 + 48))(v28);
    uint64_t v19 = *(uint64_t **)(v16 + 40);
    unint64_t v29 = *(void *)(v16 + 48);
    if ((unint64_t)v19 >= v29)
    {
      uint64_t v31 = *(void *)(v16 + 32);
      uint64_t v32 = ((uint64_t)v19 - v31) >> 3;
      unint64_t v23 = v32 + 1;
      if ((unint64_t)(v32 + 1) >> 61) {
        goto LABEL_172;
      }
      uint64_t v33 = v29 - v31;
      if (v33 >> 2 > v23) {
        unint64_t v23 = v33 >> 2;
      }
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v23)
      {
        uint64_t v34 = 8 * v23;
        uint64_t v35 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v16 + 56) + 16))(*(void *)(v16 + 56), 8 * v23, 8);
        uint64_t v27 = (uint64_t *)(v35 + 8 * v32);
        unint64_t v23 = v35 + v34;
        if (v35) {
          uint64_t *v27 = v18;
        }
      }
      else
      {
        uint64_t v27 = (uint64_t *)(8 * v32);
      }
      unint64_t v30 = v27 + 1;
      uint64_t v45 = *(void *)(v16 + 32);
      uint64_t v36 = *(void *)(v16 + 40);
      if (v36 == v45) {
        goto LABEL_69;
      }
      unint64_t v46 = v36 - v45 - 8;
      if (v46 < 0x38)
      {
        uint64_t v48 = *(void *)(v16 + 40);
      }
      else if ((unint64_t)(v36 - (void)v27) < 0x20)
      {
        uint64_t v48 = *(void *)(v16 + 40);
      }
      else
      {
        uint64_t v47 = (v46 >> 3) + 1;
        uint64_t v48 = v36 - 8 * (v47 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v49 = v27 - 2;
        uint64_t v50 = (long long *)(v36 - 16);
        uint64_t v51 = v47 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v52 = *v50;
          *((_OWORD *)v49 - 1) = *(v50 - 1);
          *(_OWORD *)unint64_t v49 = v52;
          v49 -= 4;
          v50 -= 2;
          v51 -= 4;
        }
        while (v51);
        v27 -= v47 & 0x3FFFFFFFFFFFFFFCLL;
        if (v47 == (v47 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_68;
        }
      }
      do
      {
        uint64_t v54 = *(void *)(v48 - 8);
        v48 -= 8;
        *--uint64_t v27 = v54;
      }
      while (v48 != v45);
      goto LABEL_68;
    }
  }
  else
  {
    uint64_t v18 = *(void *)(v17 - 8);
    *(void *)(v16 + 8) = v17 - 8;
    uint64_t v19 = *(uint64_t **)(v16 + 40);
    unint64_t v20 = *(void *)(v16 + 48);
    if ((unint64_t)v19 >= v20)
    {
      uint64_t v21 = *(void *)(v16 + 32);
      uint64_t v22 = ((uint64_t)v19 - v21) >> 3;
      unint64_t v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 61) {
        goto LABEL_172;
      }
      uint64_t v24 = v20 - v21;
      if (v24 >> 2 > v23) {
        unint64_t v23 = v24 >> 2;
      }
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v23 = 0x1FFFFFFFFFFFFFFFLL;
      }
      if (v23)
      {
        uint64_t v25 = 8 * v23;
        uint64_t v26 = (*(uint64_t (**)(void, unint64_t, uint64_t))(**(void **)(v16 + 56) + 16))(*(void *)(v16 + 56), 8 * v23, 8);
        uint64_t v27 = (uint64_t *)(v26 + 8 * v22);
        unint64_t v23 = v26 + v25;
        if (v26) {
          uint64_t *v27 = v18;
        }
      }
      else
      {
        uint64_t v27 = (uint64_t *)(8 * v22);
      }
      unint64_t v30 = v27 + 1;
      uint64_t v37 = *(void *)(v16 + 32);
      uint64_t v36 = *(void *)(v16 + 40);
      if (v36 == v37) {
        goto LABEL_69;
      }
      unint64_t v38 = v36 - v37 - 8;
      if (v38 < 0x38)
      {
        uint64_t v40 = *(void *)(v16 + 40);
      }
      else if ((unint64_t)(v36 - (void)v27) < 0x20)
      {
        uint64_t v40 = *(void *)(v16 + 40);
      }
      else
      {
        uint64_t v39 = (v38 >> 3) + 1;
        uint64_t v40 = v36 - 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v41 = v27 - 2;
        unint64_t v42 = (long long *)(v36 - 16);
        uint64_t v43 = v39 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v44 = *v42;
          *((_OWORD *)v41 - 1) = *(v42 - 1);
          *(_OWORD *)unint64_t v41 = v44;
          v41 -= 4;
          v42 -= 2;
          v43 -= 4;
        }
        while (v43);
        v27 -= v39 & 0x3FFFFFFFFFFFFFFCLL;
        if (v39 == (v39 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_68;
        }
      }
      do
      {
        uint64_t v53 = *(void *)(v40 - 8);
        v40 -= 8;
        *--uint64_t v27 = v53;
      }
      while (v40 != v37);
LABEL_68:
      uint64_t v36 = *(void *)(v16 + 32);
LABEL_69:
      *(void *)(v16 + 32) = v27;
      *(void *)(v16 + 40) = v30;
      uint64_t v55 = *(void *)(v16 + 48);
      *(void *)(v16 + 48) = v23;
      if (v36) {
        (*(void (**)(void, uint64_t, uint64_t))(**(void **)(v16 + 56) + 40))(*(void *)(v16 + 56), v36, v55 - v36);
      }
      goto LABEL_71;
    }
  }
  if (v19) {
    *uint64_t v19 = v18;
  }
  unint64_t v30 = v19 + 1;
LABEL_71:
  *(void *)(v16 + 40) = v30;
  *(void *)&long long v102 = v18;
  uint64_t v56 = *(void *)(v16 + 120);
  if (!v56) {
    goto LABEL_171;
  }
  (*(void (**)(uint64_t, long long *))(*(void *)v56 + 48))(v56, &v102);
  long long v102 = 0uLL;
  unint64_t v57 = *(void *)(v18 + 8);
  *(void *)&long long v58 = 0;
  *((void *)&v58 + 1) = v18;
  long long v101 = v58;
  if (v57) {
    uint64_t v59 = *(float **)(v18 + 72);
  }
  else {
    uint64_t v59 = 0;
  }
  long long v102 = v58;
  uint64_t v103 = 0;
  unint64_t v104 = v57;
  uint64_t v106 = v59;
  __int16 v105 = 1;
  float v60 = *(float *)(a3 + 48);
  v59[1] = -v60;
  *uint64_t v59 = 1.0 / (float)(*(float *)(a3 + 52) - v60);
  uint64_t v61 = *(void *)(v5 + 8);
  unint64_t v62 = *a2;
  unint64_t v63 = *(void *)(v61 + 208);
  if (v63)
  {
    uint8x8_t v64 = (uint8x8_t)vcnt_s8((int8x8_t)v63);
    v64.i16[0] = vaddlv_u8(v64);
    if (v64.u32[0] > 1uLL)
    {
      unint64_t v5 = *a2;
      if (v62 >= v63) {
        unint64_t v5 = v62 % v63;
      }
    }
    else
    {
      unint64_t v5 = (v63 - 1) & v62;
    }
    unint64_t v65 = *(void **)(*(void *)(v61 + 200) + 8 * v5);
    if (v65)
    {
      unint64_t v66 = (void *)*v65;
      if (v66)
      {
        if (v64.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v68 = v66[1];
            if (v68 == v62)
            {
              if (v66[2] == v62) {
                goto LABEL_163;
              }
            }
            else if ((v68 & (v63 - 1)) != v5)
            {
              goto LABEL_96;
            }
            unint64_t v66 = (void *)*v66;
            if (!v66) {
              goto LABEL_96;
            }
          }
        }
        do
        {
          unint64_t v67 = v66[1];
          if (v67 == v62)
          {
            if (v66[2] == v62) {
              goto LABEL_163;
            }
          }
          else
          {
            if (v67 >= v63) {
              v67 %= v63;
            }
            if (v67 != v5) {
              break;
            }
          }
          unint64_t v66 = (void *)*v66;
        }
        while (v66);
      }
    }
  }
LABEL_96:
  char v69 = operator new(0x20uLL);
  void *v69 = 0;
  v69[1] = v62;
  v69[2] = v62;
  v69[3] = v18;
  float v70 = (float)(unint64_t)(*(void *)(v61 + 224) + 1);
  float v71 = *(float *)(v61 + 232);
  if (!v63 || (float)(v71 * (float)v63) < v70)
  {
    BOOL v72 = 1;
    if (v63 >= 3) {
      BOOL v72 = (v63 & (v63 - 1)) != 0;
    }
    unint64_t v73 = v72 | (2 * v63);
    unint64_t v74 = vcvtps_u32_f32(v70 / v71);
    if (v73 <= v74) {
      size_t prime = v74;
    }
    else {
      size_t prime = v73;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v63 = *(void *)(v61 + 208);
    }
    if (prime <= v63)
    {
      if (prime >= v63) {
        goto LABEL_148;
      }
      unint64_t v88 = vcvtps_u32_f32((float)*(unint64_t *)(v61 + 224) / *(float *)(v61 + 232));
      if (v63 < 3 || (uint8x8_t v89 = (uint8x8_t)vcnt_s8((int8x8_t)v63), v89.i16[0] = vaddlv_u8(v89), v89.u32[0] > 1uLL))
      {
        unint64_t v88 = std::__next_prime(v88);
      }
      else
      {
        uint64_t v90 = 1 << -(char)__clz(v88 - 1);
        if (v88 >= 2) {
          unint64_t v88 = v90;
        }
      }
      if (prime <= v88) {
        size_t prime = v88;
      }
      if (prime >= v63) {
        goto LABEL_148;
      }
      if (!prime)
      {
        int v95 = *(void **)(v61 + 200);
        *(void *)(v61 + 200) = 0;
        if (v95) {
          operator delete(v95);
        }
        *(void *)(v61 + 208) = 0;
        goto LABEL_148;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    char v76 = operator new(8 * prime);
    double v77 = *(void **)(v61 + 200);
    *(void *)(v61 + 200) = v76;
    if (v77) {
      operator delete(v77);
    }
    uint64_t v78 = 0;
    *(void *)(v61 + 208) = prime;
    do
      *(void *)(*(void *)(v61 + 200) + 8 * v78++) = 0;
    while (prime != v78);
    uint64_t v80 = v61 + 216;
    unint64_t v79 = *(void **)(v61 + 216);
    if (!v79)
    {
LABEL_148:
      unint64_t v63 = *(void *)(v61 + 208);
      if ((v63 & (v63 - 1)) != 0)
      {
        if (v62 >= v63) {
          unint64_t v5 = v62 % v63;
        }
        else {
          unint64_t v5 = v62;
        }
      }
      else
      {
        unint64_t v5 = (v63 - 1) & v62;
      }
      goto LABEL_153;
    }
    size_t v81 = v79[1];
    size_t v82 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v83 = v81 & v82;
      *(void *)(*(void *)(v61 + 200) + 8 * v83) = v80;
      while (1)
      {
        BOOL v84 = (void *)*v79;
        if (!*v79) {
          break;
        }
        size_t v85 = v84[1] & v82;
        if (v85 == v83)
        {
          unint64_t v79 = (void *)*v79;
        }
        else
        {
          uint64_t v86 = *(void *)(v61 + 200);
          if (*(void *)(v86 + 8 * v85))
          {
            *unint64_t v79 = *v84;
            uint64_t v87 = 8 * v85;
            *BOOL v84 = **(void **)(*(void *)(v61 + 200) + v87);
            **(void **)(*(void *)(v61 + 200) + v87) = v84;
          }
          else
          {
            *(void *)(v86 + 8 * v85) = v79;
            unint64_t v79 = v84;
            size_t v83 = v85;
          }
        }
      }
      goto LABEL_148;
    }
    if (v81 >= prime) {
      v81 %= prime;
    }
    *(void *)(*(void *)(v61 + 200) + 8 * v81) = v80;
    float64_t v91 = (void *)*v79;
    if (!*v79) {
      goto LABEL_148;
    }
    while (1)
    {
      size_t v93 = v91[1];
      if (v93 >= prime) {
        v93 %= prime;
      }
      if (v93 != v81)
      {
        uint64_t v94 = *(void *)(v61 + 200);
        if (!*(void *)(v94 + 8 * v93))
        {
          *(void *)(v94 + 8 * v93) = v79;
          goto LABEL_134;
        }
        *unint64_t v79 = *v91;
        uint64_t v92 = 8 * v93;
        *float64_t v91 = **(void **)(*(void *)(v61 + 200) + v92);
        **(void **)(*(void *)(v61 + 200) + v92) = v91;
        float64_t v91 = v79;
      }
      size_t v93 = v81;
LABEL_134:
      unint64_t v79 = v91;
      float64_t v91 = (void *)*v91;
      size_t v81 = v93;
      if (!v91) {
        goto LABEL_148;
      }
    }
  }
LABEL_153:
  uint64_t v96 = *(void *)(v61 + 200);
  uint64_t v97 = *(void **)(v96 + 8 * v5);
  if (v97)
  {
    void *v69 = *v97;
  }
  else
  {
    void *v69 = *(void *)(v61 + 216);
    *(void *)(v61 + 216) = v69;
    *(void *)(v96 + 8 * v5) = v61 + 216;
    if (!*v69) {
      goto LABEL_162;
    }
    unint64_t v98 = *(void *)(*v69 + 8);
    if ((v63 & (v63 - 1)) != 0)
    {
      if (v98 >= v63) {
        v98 %= v63;
      }
    }
    else
    {
      v98 &= v63 - 1;
    }
    uint64_t v97 = (void *)(*(void *)(v61 + 200) + 8 * v98);
  }
  *uint64_t v97 = v69;
LABEL_162:
  ++*(void *)(v61 + 224);
LABEL_163:
  if (v57)
  {
    if ((void)v101 && *(unsigned char *)(*((void *)&v101 + 1) + 17) != 2) {
      (*(void (**)(void))(*(void *)v101 + 64))();
    }
    unint64_t v99 = *(void *)(*((void *)&v101 + 1) + 64);
    if (v99 <= v57) {
      unint64_t v99 = v57;
    }
    *(void *)(*((void *)&v101 + 1) + 56) = 0;
    *(void *)(*((void *)&v101 + 1) + 64) = v99;
  }
  return v18;
}

void sub_1A1AD6A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  operator delete(v11);
  ggl::BufferMemory::~BufferMemory((ggl::BufferMemory *)&a11);
  _Unwind_Resume(a1);
}

void gms::Material<ggl::Texture2D>::minNoColorCorrection(unsigned char *a1@<X8>)
{
  *a1 = 0;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::shininess@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 152);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 360))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::gradientMaskFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 248);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 696))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::saturationRemapRange@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 192);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 504))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::brightnessRemapRange@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 200);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 528))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::gradientMaskFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 208);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 552))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::emissiveFactorRGB@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 240);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 672))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::emissiveFactor@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 104);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 168))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::ssaoIntensity@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 288);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 840))();
  }
  *a2 = 0;
  return result;
}

uint64_t gms::_BasicMaterial<ggl::Texture2D>::specularity@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  unint64_t v3 = *(uint64_t (****)(void))(a1 + 144);
  if (v3) {
    return (**v3)(v3);
  }
  uint64_t result = *(void *)(a1 + 72);
  if (result) {
    return (*(uint64_t (**)(void))(*(void *)result + 336))();
  }
  *a2 = 0;
  return result;
}

void *gms::BasicMaterial<ggl::Texture2D>::shininess@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  float v3 = a3.n128_f32[0];
  float v6 = **(float **)(a1 + 48);
  a3.n128_u32[1] = 872415232;
  if ((v6 > 0.00000011921 || (uint64_t v7 = *(void *)(a1 + 16)) == 0) && (v6 < 1.0 || (uint64_t v7 = *(void *)(a1 + 32)) == 0))
  {
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      (*(void (**)(uint64_t *__return_ptr, float))(*(void *)v10 + 360))(&v14, a3.n128_f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      LOBYTE(v14) = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(uint64_t *__return_ptr, float))(*result + 360))(&v13, v3);
        if ((_BYTE)v14)
        {
LABEL_11:
          if ((_BYTE)v13)
          {
            float v11 = *((float *)&v14 + 1) + (float)((float)(*((float *)&v13 + 1) - *((float *)&v14 + 1)) * v6);
            *(unsigned char *)a2 = 1;
            *(float *)(a2 + 4) = v11;
            return result;
          }
          int v12 = HIDWORD(v14);
LABEL_18:
          *(_DWORD *)(a2 + 4) = v12;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!(_BYTE)v13) {
          return result;
        }
        int v12 = HIDWORD(v13);
        goto LABEL_18;
      }
    }
    LOBYTE(v13) = 0;
    if ((_BYTE)v14) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  unint64_t v8 = *(uint64_t (**)(__n128))(*(void *)v7 + 360);
  return (void *)v8(a3);
}

void *gms::BasicMaterial<ggl::Texture2D>::gradientMaskFactorRGB@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float32x4_t a3@<Q0>, float32x4_t a4@<Q1>)
{
  float v4 = a3.f32[0];
  float v7 = **(float **)(a1 + 48);
  a3.i32[1] = 872415232;
  if ((v7 > 0.00000011921 || (uint64_t v8 = *(void *)(a1 + 16)) == 0) && (v7 < 1.0 || (uint64_t v8 = *(void *)(a1 + 32)) == 0))
  {
    float v14 = v7;
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11)
    {
      (*(void (**)(char *__return_ptr, float32_t))(*(void *)v11 + 696))(v18, a3.f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      v18[0] = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(char *__return_ptr, float))(*result + 696))(v15, v4);
        if (v18[0])
        {
LABEL_11:
          if (v15[0])
          {
            *(unsigned char *)a2 = 1;
            a3.i64[0] = v19;
            a3.i32[2] = v20;
            a4.i64[0] = v16;
            a4.i32[2] = v17;
            float32x4_t v12 = vmlaq_n_f32(a3, vsubq_f32(a4, a3), v14);
            *(_DWORD *)(a2 + 12) = v12.i32[2];
            *(void *)(a2 + 4) = v12.i64[0];
            return result;
          }
          *(void *)(a2 + 4) = v19;
          unsigned __int32 v13 = v20;
LABEL_18:
          *(_DWORD *)(a2 + 12) = v13;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!v15[0]) {
          return result;
        }
        *(void *)(a2 + 4) = v16;
        unsigned __int32 v13 = v17;
        goto LABEL_18;
      }
    }
    v15[0] = 0;
    if (v18[0]) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint8x8_t v9 = *(uint64_t (**)(__n128))(*(void *)v8 + 696);
  return (void *)v9((__n128)a3);
}

void *gms::BasicMaterial<ggl::Texture2D>::saturationRemapRange@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  float v3 = a3.n128_f32[0];
  float v6 = **(float **)(a1 + 48);
  a3.n128_u32[1] = 872415232;
  if ((v6 > 0.00000011921 || (uint64_t v7 = *(void *)(a1 + 16)) == 0) && (v6 < 1.0 || (uint64_t v7 = *(void *)(a1 + 32)) == 0))
  {
    float v12 = v6;
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      (*(void (**)(char *__return_ptr, float))(*(void *)v10 + 504))(v15, a3.n128_f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      v15[0] = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(char *__return_ptr, float))(*result + 504))(v13, v3);
        if (v15[0])
        {
LABEL_11:
          if (v13[0])
          {
            *(unsigned char *)a2 = 1;
            *(float32x2_t *)(a2 + 4) = vmla_n_f32(v16, vsub_f32(v14, v16), v12);
            return result;
          }
          float32x2_t v11 = v16;
LABEL_18:
          *(float32x2_t *)(a2 + 4) = v11;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!v13[0]) {
          return result;
        }
        float32x2_t v11 = v14;
        goto LABEL_18;
      }
    }
    v13[0] = 0;
    if (v15[0]) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(uint64_t (**)(__n128))(*(void *)v7 + 504);
  return (void *)v8(a3);
}

void *gms::BasicMaterial<ggl::Texture2D>::brightnessRemapRange@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  float v3 = a3.n128_f32[0];
  float v6 = **(float **)(a1 + 48);
  a3.n128_u32[1] = 872415232;
  if ((v6 > 0.00000011921 || (uint64_t v7 = *(void *)(a1 + 16)) == 0) && (v6 < 1.0 || (uint64_t v7 = *(void *)(a1 + 32)) == 0))
  {
    float v12 = v6;
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      (*(void (**)(char *__return_ptr, float))(*(void *)v10 + 528))(v15, a3.n128_f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      v15[0] = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(char *__return_ptr, float))(*result + 528))(v13, v3);
        if (v15[0])
        {
LABEL_11:
          if (v13[0])
          {
            *(unsigned char *)a2 = 1;
            *(float32x2_t *)(a2 + 4) = vmla_n_f32(v16, vsub_f32(v14, v16), v12);
            return result;
          }
          float32x2_t v11 = v16;
LABEL_18:
          *(float32x2_t *)(a2 + 4) = v11;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!v13[0]) {
          return result;
        }
        float32x2_t v11 = v14;
        goto LABEL_18;
      }
    }
    v13[0] = 0;
    if (v15[0]) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(uint64_t (**)(__n128))(*(void *)v7 + 528);
  return (void *)v8(a3);
}

void *gms::BasicMaterial<ggl::Texture2D>::gradientMaskFactor@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  float v3 = a3.n128_f32[0];
  float v6 = **(float **)(a1 + 48);
  a3.n128_u32[1] = 872415232;
  if ((v6 > 0.00000011921 || (uint64_t v7 = *(void *)(a1 + 16)) == 0) && (v6 < 1.0 || (uint64_t v7 = *(void *)(a1 + 32)) == 0))
  {
    float v12 = v6;
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      (*(void (**)(char *__return_ptr, float))(*(void *)v10 + 552))(v15, a3.n128_f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      v15[0] = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(char *__return_ptr, float))(*result + 552))(v13, v3);
        if (v15[0])
        {
LABEL_11:
          if (v13[0])
          {
            *(unsigned char *)a2 = 1;
            *(float32x4_t *)(a2 + 4) = vmlaq_n_f32(v16, vsubq_f32(v14, v16), v12);
            return result;
          }
          float32x4_t v11 = v16;
LABEL_18:
          *(float32x4_t *)(a2 + 4) = v11;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!v13[0]) {
          return result;
        }
        float32x4_t v11 = v14;
        goto LABEL_18;
      }
    }
    v13[0] = 0;
    if (v15[0]) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(uint64_t (**)(__n128))(*(void *)v7 + 552);
  return (void *)v8(a3);
}

void *gms::BasicMaterial<ggl::Texture2D>::emissiveFactorRGB@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float32x4_t a3@<Q0>, float32x4_t a4@<Q1>)
{
  float v4 = a3.f32[0];
  float v7 = **(float **)(a1 + 48);
  a3.i32[1] = 872415232;
  if ((v7 > 0.00000011921 || (uint64_t v8 = *(void *)(a1 + 16)) == 0) && (v7 < 1.0 || (uint64_t v8 = *(void *)(a1 + 32)) == 0))
  {
    float v14 = v7;
    uint64_t v11 = *(void *)(a1 + 16);
    if (v11)
    {
      (*(void (**)(char *__return_ptr, float32_t))(*(void *)v11 + 672))(v18, a3.f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      v18[0] = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(char *__return_ptr, float))(*result + 672))(v15, v4);
        if (v18[0])
        {
LABEL_11:
          if (v15[0])
          {
            *(unsigned char *)a2 = 1;
            a3.i64[0] = v19;
            a3.i32[2] = v20;
            a4.i64[0] = v16;
            a4.i32[2] = v17;
            float32x4_t v12 = vmlaq_n_f32(a3, vsubq_f32(a4, a3), v14);
            *(_DWORD *)(a2 + 12) = v12.i32[2];
            *(void *)(a2 + 4) = v12.i64[0];
            return result;
          }
          *(void *)(a2 + 4) = v19;
          unsigned __int32 v13 = v20;
LABEL_18:
          *(_DWORD *)(a2 + 12) = v13;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!v15[0]) {
          return result;
        }
        *(void *)(a2 + 4) = v16;
        unsigned __int32 v13 = v17;
        goto LABEL_18;
      }
    }
    v15[0] = 0;
    if (v18[0]) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint8x8_t v9 = *(uint64_t (**)(__n128))(*(void *)v8 + 672);
  return (void *)v9((__n128)a3);
}

void *gms::BasicMaterial<ggl::Texture2D>::emissiveFactor@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  float v3 = a3.n128_f32[0];
  float v6 = **(float **)(a1 + 48);
  a3.n128_u32[1] = 872415232;
  if ((v6 > 0.00000011921 || (uint64_t v7 = *(void *)(a1 + 16)) == 0) && (v6 < 1.0 || (uint64_t v7 = *(void *)(a1 + 32)) == 0))
  {
    float v12 = v6;
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      (*(void (**)(char *__return_ptr, float))(*(void *)v10 + 168))(v15, a3.n128_f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      v15[0] = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(char *__return_ptr, float))(*result + 168))(v13, v3);
        if (v15[0])
        {
LABEL_11:
          if (v13[0])
          {
            *(unsigned char *)a2 = 1;
            *(float32x4_t *)(a2 + 4) = vmlaq_n_f32(v16, vsubq_f32(v14, v16), v12);
            return result;
          }
          float32x4_t v11 = v16;
LABEL_18:
          *(float32x4_t *)(a2 + 4) = v11;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!v13[0]) {
          return result;
        }
        float32x4_t v11 = v14;
        goto LABEL_18;
      }
    }
    v13[0] = 0;
    if (v15[0]) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(uint64_t (**)(__n128))(*(void *)v7 + 168);
  return (void *)v8(a3);
}

void *gms::BasicMaterial<ggl::Texture2D>::ssaoIntensity@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  float v3 = a3.n128_f32[0];
  float v6 = **(float **)(a1 + 48);
  a3.n128_u32[1] = 872415232;
  if ((v6 > 0.00000011921 || (uint64_t v7 = *(void *)(a1 + 16)) == 0) && (v6 < 1.0 || (uint64_t v7 = *(void *)(a1 + 32)) == 0))
  {
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      (*(void (**)(uint64_t *__return_ptr, float))(*(void *)v10 + 840))(&v14, a3.n128_f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      LOBYTE(v14) = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(uint64_t *__return_ptr, float))(*result + 840))(&v13, v3);
        if ((_BYTE)v14)
        {
LABEL_11:
          if ((_BYTE)v13)
          {
            float v11 = *((float *)&v14 + 1) + (float)((float)(*((float *)&v13 + 1) - *((float *)&v14 + 1)) * v6);
            *(unsigned char *)a2 = 1;
            *(float *)(a2 + 4) = v11;
            return result;
          }
          int v12 = HIDWORD(v14);
LABEL_18:
          *(_DWORD *)(a2 + 4) = v12;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!(_BYTE)v13) {
          return result;
        }
        int v12 = HIDWORD(v13);
        goto LABEL_18;
      }
    }
    LOBYTE(v13) = 0;
    if ((_BYTE)v14) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(uint64_t (**)(__n128))(*(void *)v7 + 840);
  return (void *)v8(a3);
}

void *gms::BasicMaterial<ggl::Texture2D>::specularity@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, __n128 a3@<Q0>)
{
  float v3 = a3.n128_f32[0];
  float v6 = **(float **)(a1 + 48);
  a3.n128_u32[1] = 872415232;
  if ((v6 > 0.00000011921 || (uint64_t v7 = *(void *)(a1 + 16)) == 0) && (v6 < 1.0 || (uint64_t v7 = *(void *)(a1 + 32)) == 0))
  {
    uint64_t v10 = *(void *)(a1 + 16);
    if (v10)
    {
      (*(void (**)(uint64_t *__return_ptr, float))(*(void *)v10 + 336))(&v14, a3.n128_f32[0]);
      uint64_t result = *(void **)(a1 + 32);
      if (result) {
        goto LABEL_10;
      }
    }
    else
    {
      LOBYTE(v14) = 0;
      uint64_t result = *(void **)(a1 + 32);
      if (result)
      {
LABEL_10:
        uint64_t result = (*(void *(**)(uint64_t *__return_ptr, float))(*result + 336))(&v13, v3);
        if ((_BYTE)v14)
        {
LABEL_11:
          if ((_BYTE)v13)
          {
            float v11 = *((float *)&v14 + 1) + (float)((float)(*((float *)&v13 + 1) - *((float *)&v14 + 1)) * v6);
            *(unsigned char *)a2 = 1;
            *(float *)(a2 + 4) = v11;
            return result;
          }
          int v12 = HIDWORD(v14);
LABEL_18:
          *(_DWORD *)(a2 + 4) = v12;
          *(unsigned char *)a2 = 1;
          return result;
        }
LABEL_15:
        *(unsigned char *)a2 = 0;
        if (!(_BYTE)v13) {
          return result;
        }
        int v12 = HIDWORD(v13);
        goto LABEL_18;
      }
    }
    LOBYTE(v13) = 0;
    if ((_BYTE)v14) {
      goto LABEL_11;
    }
    goto LABEL_15;
  }
  uint64_t v8 = *(uint64_t (**)(__n128))(*(void *)v7 + 336);
  return (void *)v8(a3);
}

void md::DaVinciGroundRenderLayer::setupStyleGroundOcclusionConstantData<ggl::DaVinci::GroundPipelineSetup,ggl::DaVinci::GroundPipelineState>(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)(a2[2] + 320))
  {
    uint8x8_t v9 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleGroundOcclusion>>::pop(*(void *)(a1 + 1912));
    unint64_t v10 = v9[1];
    _S3 = *(_DWORD *)(a5 + 68);
    _D0 = fmax(*(double *)(a3 + 32) * 0.5, 250.0)
        * (float)((float)(*(float *)(a5 + 64) * *(float *)(*(void *)(a4 + 8) + 624))
                * fmaxf((float)(*(float *)(a5 + 20) * 0.125) + -0.875, 0.0));
    __asm
    {
      FCVT            H0, D0
      FCVT            H1, S3
    }
    if (!*(unsigned char *)(a5 + 7)) {
      _H1 = COERCE_SHORT_FLOAT(0);
    }
    unint64_t v20 = v9[8];
    uint64_t v19 = v9[9];
    *(_WORD *)uint64_t v19 = _H0;
    *(short float *)(v19 + 2) = _H1;
    if (v20 > v10) {
      unint64_t v10 = v20;
    }
    v9[7] = 0;
    v9[8] = v10;
    uint64_t v21 = a2[8];
    *(void *)(v21 + 320) = v9;
    *(void *)(v21 + 328) = 0;
    uint64_t v22 = a2[20];
    unint64_t v23 = *(std::__shared_weak_count **)(v22 + 328);
    *(void *)(v22 + 320) = 0;
    *(void *)(v22 + 328) = 0;
    if (v23 && !atomic_fetch_add(&v23->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v23->__on_zero_shared)(v23);
      std::__shared_weak_count::__release_weak(v23);
    }
  }
}

uint64_t md::MaterialRenderable::hash(md::MaterialRenderable *this)
{
  return *((void *)this + 30);
}

void md::DaVinciGroundRenderLayer::setupCommonGroundPipelineSetup<ggl::DaVinci::GroundPipelineSetup>(void *a1, void *a2, void *a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  int v12 = (void *)a1[4];
  *int v12 = a4;
  v12[1] = 0;
  uint64_t v13 = (void *)a1[16];
  if (a5) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(a5 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v14 = (std::__shared_weak_count *)v13[1];
  *uint64_t v13 = a4;
  v13[1] = a5;
  if (v14 && !atomic_fetch_add(&v14->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v14->__on_zero_shared)(v14);
    std::__shared_weak_count::__release_weak(v14);
  }
  uint64_t v15 = (void *)a1[8];
  uint64_t v16 = a2[27];
  uint64_t v17 = a2[28];
  *uint64_t v15 = v16;
  v15[1] = 0;
  uint64_t v18 = (void *)a1[20];
  if (v17) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v17 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v19 = (std::__shared_weak_count *)v18[1];
  *uint64_t v18 = v16;
  v18[1] = v17;
  if (v19 && !atomic_fetch_add(&v19->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
    std::__shared_weak_count::__release_weak(v19);
  }
  uint64_t v20 = a1[8];
  uint64_t v21 = a2[56];
  uint64_t v22 = a2[57];
  *(void *)(v20 + 160) = v21;
  *(void *)(v20 + 168) = 0;
  uint64_t v23 = a1[20];
  if (v22) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v22 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v24 = *(std::__shared_weak_count **)(v23 + 168);
  *(void *)(v23 + 160) = v21;
  *(void *)(v23 + 168) = v22;
  if (v24 && !atomic_fetch_add(&v24->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v24->__on_zero_shared)(v24);
    std::__shared_weak_count::__release_weak(v24);
  }
  uint64_t v25 = a1[8];
  uint64_t v26 = a2[29];
  uint64_t v27 = a2[30];
  *(void *)(v25 + 16) = v26;
  *(void *)(v25 + 24) = 0;
  uint64_t v28 = a1[20];
  if (v27) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v27 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v29 = *(std::__shared_weak_count **)(v28 + 24);
  *(void *)(v28 + 16) = v26;
  *(void *)(v28 + 24) = v27;
  if (v29 && !atomic_fetch_add(&v29->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
    std::__shared_weak_count::__release_weak(v29);
    if (!*(unsigned char *)(a7 + 6)) {
      goto LABEL_33;
    }
  }
  else if (!*(unsigned char *)(a7 + 6))
  {
    goto LABEL_33;
  }
  uint64_t v30 = a1[8];
  uint64_t v31 = a2[50];
  uint64_t v32 = a2[51];
  *(void *)(v30 + 32) = v31;
  *(void *)(v30 + 40) = 0;
  uint64_t v33 = a1[20];
  if (v32) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v32 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v34 = *(std::__shared_weak_count **)(v33 + 40);
  *(void *)(v33 + 32) = v31;
  *(void *)(v33 + 40) = v32;
  if (v34 && !atomic_fetch_add(&v34->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
    std::__shared_weak_count::__release_weak(v34);
  }
  uint64_t v35 = a3[12];
  if (v35)
  {
    unint64_t v36 = *(void *)(v35 + 32);
    uint64_t v37 = *(void *)(a3[1] + 96);
    if (v36 >= (*(void *)(a3[1] + 104) - v37) >> 3) {
      uint64_t v35 = 0;
    }
    else {
      uint64_t v35 = *(void *)(*(void *)(v37 + 8 * v36) + 16);
    }
  }
  *(void *)(a1[12] + 8) = v35;
LABEL_33:
  uint64_t v38 = a1[8];
  uint64_t v39 = a3[40];
  uint64_t v40 = a3[41];
  *(void *)(v38 + 208) = v39;
  *(void *)(v38 + 216) = 0;
  uint64_t v41 = a1[20];
  if (v40) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v40 + 8), 1uLL, memory_order_relaxed);
  }
  unint64_t v42 = *(std::__shared_weak_count **)(v41 + 216);
  *(void *)(v41 + 208) = v39;
  *(void *)(v41 + 216) = v40;
  if (v42 && !atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
  *(void *)a1[12] = *(void *)(a7 + 280);
  uint64_t v43 = a1[8];
  uint64_t v44 = *a6;
  uint64_t v45 = a6[1];
  *(void *)(v43 + 176) = *a6;
  *(void *)(v43 + 184) = 0;
  uint64_t v46 = a1[20];
  if (v45) {
    atomic_fetch_add_explicit((atomic_ullong *volatile)(v45 + 8), 1uLL, memory_order_relaxed);
  }
  uint64_t v47 = *(std::__shared_weak_count **)(v46 + 184);
  *(void *)(v46 + 176) = v44;
  *(void *)(v46 + 184) = v45;
  if (v47 && !atomic_fetch_add(&v47->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v47->__on_zero_shared)(v47);
    std::__shared_weak_count::__release_weak(v47);
  }
}

void md::DaVinciGroundRenderLayer::setupSSAOGroundPipelineSetup<ggl::DaVinci::GroundPipelineSetup>(uint64_t a1, uint64_t a2, void *a3, void *a4, char a5, float a6)
{
  if (a5)
  {
    _S8 = a6;
    float v11 = +[VKDebugSettings sharedSettings];
    int v12 = [v11 daVinciSSAODepthAwareUpsampleEnabled];

    if (v12)
    {
      uint64_t v13 = a4[19];
      if (!v13) {
        goto LABEL_13;
      }
    }
    else
    {
      uint64_t v13 = a4[17];
      if (!v13)
      {
LABEL_13:
        *(void *)(a3[12] + 24) = v13;
        uint64_t v20 = (void *)ggl::FragmentedPool<ggl::ConstantDataTyped<ggl::DaVinci::StyleSSAO>>::pop(*(void *)(a1 + 1936));
        unint64_t v21 = v20[1];
        uint64_t v22 = v20[9];
        __int16 v23 = *(_WORD *)(a2 + 216);
        *(_DWORD *)uint64_t v22 = *(_DWORD *)(a2 + 212);
        *(_WORD *)(v22 + 4) = v23;
        __asm { FCVT            H0, S8 }
        *(_WORD *)(v22 + 8) = _H0;
        if (v20[8] > v21) {
          unint64_t v21 = v20[8];
        }
        v20[7] = 0;
        v20[8] = v21;
        uint64_t v29 = a3[8];
        *(void *)(v29 + 432) = v20;
        *(void *)(v29 + 440) = 0;
        uint64_t v30 = a3[20];
        uint64_t v31 = *(atomic_ullong **)(v30 + 440);
        *(void *)(v30 + 432) = 0;
        *(void *)(v30 + 440) = 0;
        if (!v31 || atomic_fetch_add(v31 + 1, 0xFFFFFFFFFFFFFFFFLL)) {
          return;
        }
        (*(void (**)(atomic_ullong *))(*v31 + 16))(v31);
        uint64_t v17 = (std::__shared_weak_count *)v31;
LABEL_19:
        std::__shared_weak_count::__release_weak(v17);
        return;
      }
    }
    unint64_t v18 = *(void *)(v13 + 32);
    uint64_t v19 = *(void *)(a4[1] + 96);
    if (v18 >= (*(void *)(a4[1] + 104) - v19) >> 3) {
      uint64_t v13 = 0;
    }
    else {
      uint64_t v13 = *(void *)(*(void *)(v19 + 8 * v18) + 16);
    }
    goto LABEL_13;
  }
  uint64_t v14 = *(uint64_t **)(a1 + 3128);
  uint64_t v15 = *v14;
  uint64_t v16 = (atomic_ullong *)v14[1];
  if (!v16)
  {
    *(void *)(a3[12] + 24) = v15;
    return;
  }
  atomic_fetch_add_explicit(v16 + 1, 1uLL, memory_order_relaxed);
  *(void *)(a3[12] + 24) = v15;
  if (!atomic_fetch_add(v16 + 1, 0xFFFFFFFFFFFFFFFFLL))
  {
    (*(void (**)(atomic_ullong *))(*v16 + 16))(v16);
    uint64_t v17 = (std::__shared_weak_count *)v16;
    goto LABEL_19;
  }
}

void sub_1A1AD8430(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__function::__func<md::DaVinciGroundRenderResources::DaVinciGroundRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_28,std::allocator<md::DaVinciGroundRenderResources::DaVinciGroundRenderResources(VKSharedResources *,ggl::RenderTargetFormat const&)::$_28>,ggl::ConstantDataTyped<ggl::DaVinci::GradientParameters> * ()(void)>::operator()()
{
}

void md::Device::Device(uint64_t a1)
{
  *(_DWORD *)a1 = 0;
  *(void *)(a1 + 8) = 0;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 16) = 0;
  operator new();
}

void sub_1A1ADAD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, md::SharedDeviceResources **a10, uint64_t a11, ...)
{
  va_start(va3, a11);
  va_start(va2, a11);
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v21 = va_arg(va1, void);
  uint64_t v23 = va_arg(va1, void);
  va_copy(va2, va1);
  uint64_t v24 = va_arg(va2, void);
  uint64_t v26 = va_arg(va2, void);
  va_copy(va3, va2);
  uint64_t v27 = va_arg(va3, void);
  uint64_t v29 = va_arg(va3, void);

  std::mutex::~mutex(v12);
  uint64_t v19 = *(void *)(v11 + 136);
  *(void *)(v11 + 136) = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }

  *(void *)uint64_t v11 = off_1EF560C50;
  uint64_t v20 = *(std::__shared_weak_count **)(v11 + 88);
  if (v20)
  {
    if (!atomic_fetch_add(&v20->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v20->__on_zero_shared)(v20);
      std::__shared_weak_count::__release_weak(v20);
    }
  }
  MEMORY[0x1A6239270](v11, 0x10A1C405B3935E5);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va1);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va2);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100]((uint64_t)va3);
  std::unique_ptr<md::SharedDeviceResources>::~unique_ptr[abi:nn180100](a10);
  std::shared_ptr<md::MapTileData>::~shared_ptr[abi:nn180100](a11);
  _Unwind_Resume(a1);
}

uint64_t ggl::crc32::compute<32ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  unsigned int v21 = ggl::crc32::crc32Table[v20 ^ a1[22]] ^ (v20 >> 8);
  unsigned int v22 = ggl::crc32::crc32Table[v21 ^ a1[23]] ^ (v21 >> 8);
  unsigned int v23 = ggl::crc32::crc32Table[v22 ^ a1[24]] ^ (v22 >> 8);
  unsigned int v24 = ggl::crc32::crc32Table[v23 ^ a1[25]] ^ (v23 >> 8);
  unsigned int v25 = ggl::crc32::crc32Table[v24 ^ a1[26]] ^ (v24 >> 8);
  unsigned int v26 = ggl::crc32::crc32Table[v25 ^ a1[27]] ^ (v25 >> 8);
  unsigned int v27 = ggl::crc32::crc32Table[v26 ^ a1[28]] ^ (v26 >> 8);
  unsigned int v28 = ggl::crc32::crc32Table[v27 ^ a1[29]] ^ (v27 >> 8);
  return ggl::crc32::crc32Table[v28 ^ a1[30]] ^ ~(v28 >> 8);
}

uint64_t ggl::crc32::compute<28ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  unsigned int v21 = ggl::crc32::crc32Table[v20 ^ a1[22]] ^ (v20 >> 8);
  unsigned int v22 = ggl::crc32::crc32Table[v21 ^ a1[23]] ^ (v21 >> 8);
  unsigned int v23 = ggl::crc32::crc32Table[v22 ^ a1[24]] ^ (v22 >> 8);
  unsigned int v24 = ggl::crc32::crc32Table[v23 ^ a1[25]] ^ (v23 >> 8);
  return ggl::crc32::crc32Table[v24 ^ a1[26]] ^ ~(v24 >> 8);
}

uint64_t ggl::crc32::compute<30ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  unsigned int v21 = ggl::crc32::crc32Table[v20 ^ a1[22]] ^ (v20 >> 8);
  unsigned int v22 = ggl::crc32::crc32Table[v21 ^ a1[23]] ^ (v21 >> 8);
  unsigned int v23 = ggl::crc32::crc32Table[v22 ^ a1[24]] ^ (v22 >> 8);
  unsigned int v24 = ggl::crc32::crc32Table[v23 ^ a1[25]] ^ (v23 >> 8);
  unsigned int v25 = ggl::crc32::crc32Table[v24 ^ a1[26]] ^ (v24 >> 8);
  unsigned int v26 = ggl::crc32::crc32Table[v25 ^ a1[27]] ^ (v25 >> 8);
  return ggl::crc32::crc32Table[v26 ^ a1[28]] ^ ~(v26 >> 8);
}

uint64_t ggl::crc32::compute<26ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  unsigned int v21 = ggl::crc32::crc32Table[v20 ^ a1[22]] ^ (v20 >> 8);
  unsigned int v22 = ggl::crc32::crc32Table[v21 ^ a1[23]] ^ (v21 >> 8);
  return ggl::crc32::crc32Table[v22 ^ a1[24]] ^ ~(v22 >> 8);
}

uint64_t ggl::crc32::compute<27ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  unsigned int v21 = ggl::crc32::crc32Table[v20 ^ a1[22]] ^ (v20 >> 8);
  unsigned int v22 = ggl::crc32::crc32Table[v21 ^ a1[23]] ^ (v21 >> 8);
  unsigned int v23 = ggl::crc32::crc32Table[v22 ^ a1[24]] ^ (v22 >> 8);
  return ggl::crc32::crc32Table[v23 ^ a1[25]] ^ ~(v23 >> 8);
}

uint64_t ggl::crc32::compute<31ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  unsigned int v21 = ggl::crc32::crc32Table[v20 ^ a1[22]] ^ (v20 >> 8);
  unsigned int v22 = ggl::crc32::crc32Table[v21 ^ a1[23]] ^ (v21 >> 8);
  unsigned int v23 = ggl::crc32::crc32Table[v22 ^ a1[24]] ^ (v22 >> 8);
  unsigned int v24 = ggl::crc32::crc32Table[v23 ^ a1[25]] ^ (v23 >> 8);
  unsigned int v25 = ggl::crc32::crc32Table[v24 ^ a1[26]] ^ (v24 >> 8);
  unsigned int v26 = ggl::crc32::crc32Table[v25 ^ a1[27]] ^ (v25 >> 8);
  unsigned int v27 = ggl::crc32::crc32Table[v26 ^ a1[28]] ^ (v26 >> 8);
  return ggl::crc32::crc32Table[v27 ^ a1[29]] ^ ~(v27 >> 8);
}

uint64_t ggl::crc32::compute<38ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  unsigned int v21 = ggl::crc32::crc32Table[v20 ^ a1[22]] ^ (v20 >> 8);
  unsigned int v22 = ggl::crc32::crc32Table[v21 ^ a1[23]] ^ (v21 >> 8);
  unsigned int v23 = ggl::crc32::crc32Table[v22 ^ a1[24]] ^ (v22 >> 8);
  unsigned int v24 = ggl::crc32::crc32Table[v23 ^ a1[25]] ^ (v23 >> 8);
  unsigned int v25 = ggl::crc32::crc32Table[v24 ^ a1[26]] ^ (v24 >> 8);
  unsigned int v26 = ggl::crc32::crc32Table[v25 ^ a1[27]] ^ (v25 >> 8);
  unsigned int v27 = ggl::crc32::crc32Table[v26 ^ a1[28]] ^ (v26 >> 8);
  unsigned int v28 = ggl::crc32::crc32Table[v27 ^ a1[29]] ^ (v27 >> 8);
  unsigned int v29 = ggl::crc32::crc32Table[v28 ^ a1[30]] ^ (v28 >> 8);
  unsigned int v30 = ggl::crc32::crc32Table[v29 ^ a1[31]] ^ (v29 >> 8);
  unsigned int v31 = ggl::crc32::crc32Table[v30 ^ a1[32]] ^ (v30 >> 8);
  unsigned int v32 = ggl::crc32::crc32Table[v31 ^ a1[33]] ^ (v31 >> 8);
  unsigned int v33 = ggl::crc32::crc32Table[v32 ^ a1[34]] ^ (v32 >> 8);
  unsigned int v34 = ggl::crc32::crc32Table[v33 ^ a1[35]] ^ (v33 >> 8);
  return ggl::crc32::crc32Table[v34 ^ a1[36]] ^ ~(v34 >> 8);
}

uint64_t ggl::crc32::compute<34ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  unsigned int v21 = ggl::crc32::crc32Table[v20 ^ a1[22]] ^ (v20 >> 8);
  unsigned int v22 = ggl::crc32::crc32Table[v21 ^ a1[23]] ^ (v21 >> 8);
  unsigned int v23 = ggl::crc32::crc32Table[v22 ^ a1[24]] ^ (v22 >> 8);
  unsigned int v24 = ggl::crc32::crc32Table[v23 ^ a1[25]] ^ (v23 >> 8);
  unsigned int v25 = ggl::crc32::crc32Table[v24 ^ a1[26]] ^ (v24 >> 8);
  unsigned int v26 = ggl::crc32::crc32Table[v25 ^ a1[27]] ^ (v25 >> 8);
  unsigned int v27 = ggl::crc32::crc32Table[v26 ^ a1[28]] ^ (v26 >> 8);
  unsigned int v28 = ggl::crc32::crc32Table[v27 ^ a1[29]] ^ (v27 >> 8);
  unsigned int v29 = ggl::crc32::crc32Table[v28 ^ a1[30]] ^ (v28 >> 8);
  unsigned int v30 = ggl::crc32::crc32Table[v29 ^ a1[31]] ^ (v29 >> 8);
  return ggl::crc32::crc32Table[v30 ^ a1[32]] ^ ~(v30 >> 8);
}

uint64_t ggl::crc32::compute<24ul>(char *a1)
{
  int v1 = ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) ^ a1[3]];
  unsigned int v2 = v1 ^ ((ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]] ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8);
  unsigned int v3 = ggl::crc32::crc32Table[(v1 ^ ((unsigned __int16)(LOWORD(ggl::crc32::crc32Table[(LOBYTE(ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]]) ^ ((unsigned __int16)~LOWORD(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) >> 8)) ^ a1[2]]) ^ ((ggl::crc32::crc32Table[~LOBYTE(ggl::crc32::crc32Table[*a1 ^ 0xFFLL]) ^ a1[1]] ^ ((ggl::crc32::crc32Table[*a1 ^ 0xFFLL] ^ 0xFFFFFFu) >> 8)) >> 8)) >> 8)) ^ a1[4]] ^ (v2 >> 8);
  unsigned int v4 = ggl::crc32::crc32Table[v3 ^ a1[5]] ^ (v3 >> 8);
  unsigned int v5 = ggl::crc32::crc32Table[v4 ^ a1[6]] ^ (v4 >> 8);
  unsigned int v6 = ggl::crc32::crc32Table[v5 ^ a1[7]] ^ (v5 >> 8);
  unsigned int v7 = ggl::crc32::crc32Table[v6 ^ a1[8]] ^ (v6 >> 8);
  unsigned int v8 = ggl::crc32::crc32Table[v7 ^ a1[9]] ^ (v7 >> 8);
  unsigned int v9 = ggl::crc32::crc32Table[v8 ^ a1[10]] ^ (v8 >> 8);
  unsigned int v10 = ggl::crc32::crc32Table[v9 ^ a1[11]] ^ (v9 >> 8);
  unsigned int v11 = ggl::crc32::crc32Table[v10 ^ a1[12]] ^ (v10 >> 8);
  unsigned int v12 = ggl::crc32::crc32Table[v11 ^ a1[13]] ^ (v11 >> 8);
  unsigned int v13 = ggl::crc32::crc32Table[v12 ^ a1[14]] ^ (v12 >> 8);
  unsigned int v14 = ggl::crc32::crc32Table[v13 ^ a1[15]] ^ (v13 >> 8);
  unsigned int v15 = ggl::crc32::crc32Table[v14 ^ a1[16]] ^ (v14 >> 8);
  unsigned int v16 = ggl::crc32::crc32Table[v15 ^ a1[17]] ^ (v15 >> 8);
  unsigned int v17 = ggl::crc32::crc32Table[v16 ^ a1[18]] ^ (v16 >> 8);
  unsigned int v18 = ggl::crc32::crc32Table[v17 ^ a1[19]] ^ (v17 >> 8);
  unsigned int v19 = ggl::crc32::crc32Table[v18 ^ a1[20]] ^ (v18 >> 8);
  unsigned int v20 = ggl::crc32::crc32Table[v19 ^ a1[21]] ^ (v19 >> 8);
  return ggl::crc32::crc32Table[v20 ^ a1[22]] ^ ~(v20 >> 8);
}

ggl::Data *ggl::Data::Data(ggl::Data *this, const unsigned __int8 *a2, size_t a3)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = &unk_1EF560428;
  if (a3)
  {
    unsigned int v6 = &qword_1EB32C000;
    {
      unsigned int v6 = &qword_1EB32C000;
      if (v9) {
        operator new();
      }
    }
    unsigned int v7 = (void *)(*(uint64_t (**)(uint64_t, size_t, uint64_t))(*(void *)v6[287] + 16))(v6[287], a3, 8);
    *((void *)this + 1) = v7;
    *((void *)this + 2) = a3;
    memcpy(v7, a2, a3);
  }
  return this;
}

BOOL ggl::MetalDevice::isDeviceValid(ggl::MetalDevice *this)
{
  return *((void *)this + 13) != 0;
}

void md::LabelsLogic::prune(uint64_t a1, int a2)
{
  for (uint64_t i = *(uint64_t ***)(a1 + 192); i; uint64_t i = (uint64_t **)*i)
    md::LabelManager::didReceiveMemoryWarning((md::FontTrackingCache **)i[3], a2 == 2);
}

void md::LabelManager::didReceiveMemoryWarning(md::FontTrackingCache **this, int a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  v4[0] = &unk_1EF56EB98;
  v4[1] = this;
  unsigned int v5 = v4;
  md::LabelManager::queueCommand((md::LabelManager *)this, 1, 1, v4);
  if (v5 == v4)
  {
    (*(void (**)(void *))(v4[0] + 32))(v4);
    if (!a2) {
      return;
    }
    goto LABEL_7;
  }
  if (v5) {
    (*(void (**)(void))(*v5 + 40))();
  }
  if (a2)
  {
LABEL_7:
    if (md::LabelManager::tryWaitForBkgdUpdateComplete((md::LabelManager *)this, 0x1F4u))
    {
      if (*((unsigned char *)this + 3384))
      {
        *((unsigned char *)this + 3384) = 0;
        md::FontTrackingCache::updateForDisplay(this[39]);
        (*(void (**)(md::FontTrackingCache *))(*(void *)this[30] + 48))(this[30]);
      }
      md::LabelManager::flushCommands((md::LabelManager *)this);
    }
  }
}

void sub_1A1ADC714(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  std::function<void ()(void)>::~function((uint64_t *)va);
  _Unwind_Resume(a1);
}

uint64_t mre::GGLResourceStore::releaseTexture(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (std::__shared_mutex_base *)(a1 + 104);
  std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 104));
  uint64_t v5 = *(void *)(a1 + 600);
  if (a2 < (unint64_t)((*(void *)(a1 + 608) - v5) >> 3)
    && (uint64_t v6 = *(void *)(v5 + 8 * a2)) != 0
    && HIDWORD(a2) == HIDWORD(v6)
    && (uint64_t v7 = *(void *)(a1 + 624),
        unsigned int v8 = v6,
        int v9 = (void *)(v7 + 40 * v6),
        unsigned int v10 = *(void **)(a1 + 632),
        v9 != v10))
  {
    if (*v9 && !*(unsigned char *)(v7 + 40 * v8 + 32))
    {
      (*(void (**)(void))(*(void *)*v9 + 8))(*v9);
      unsigned int v10 = *(void **)(a1 + 632);
    }
    if (v10 != v9)
    {
      unint64_t v13 = *(void *)(*(void *)(a1 + 648)
                                    + 0x6666666666666668 * (((unint64_t)v9 - *(void *)(a1 + 624)) >> 3)) | ((unint64_t)*(unsigned int *)(*(void *)(a1 + 600) + 8 * *(void *)(*(void *)(a1 + 648) + 0x6666666666666668 * (((unint64_t)v9 - *(void *)(a1 + 624)) >> 3)) + 4) << 32);
      geo::packed_array<mre::TextureStorage,geo::handle<mre::Texture>>::erase(a1 + 576, &v13);
    }
    uint64_t v11 = 1;
  }
  else
  {
    uint64_t v11 = 0;
  }
  std::__shared_mutex_base::unlock(v4);
  return v11;
}

void ggl::Buffer::~Buffer(ggl::Buffer *this)
{
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 16))(v2, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unsigned int v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3)
  {
    if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
}

{
  uint64_t v2;
  std::__shared_weak_count *v3;
  uint64_t vars8;

  *(void *)this = &unk_1EF55D4B8;
  uint64_t v2 = *((void *)this + 1);
  if (v2)
  {
    (*(void (**)(uint64_t, void))(*(void *)v2 + 16))(v2, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  unsigned int v3 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v3 && !atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
  JUMPOUT(0x1A6239270);
}

void ggl::Texture2D::~Texture2D(ggl::Texture2D *this)
{
  ggl::Texture2D::~Texture2D(this);
  JUMPOUT(0x1A6239270);
}

{
  std::__shared_weak_count *v2;
  std::__shared_weak_count *v3;
  std::__shared_weak_count *v4;
  uint64_t v5;
  std::__shared_weak_count *v6;

  *(void *)this = &unk_1EF562EE0;
  *((void *)this + 5) = &unk_1EF562F00;
  uint64_t v2 = (std::__shared_weak_count *)*((void *)this + 18);
  if (v2 && !atomic_fetch_add(&v2->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
    std::__shared_weak_count::__release_weak(v2);
    unsigned int v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  else
  {
    unsigned int v3 = (std::__shared_weak_count *)*((void *)this + 15);
    if (!v3) {
      goto LABEL_7;
    }
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_7:
  *(void *)this = &unk_1EF55EFB8;
  *((void *)this + 5) = &unk_1EF55EFD8;
  unsigned int v4 = (std::__shared_weak_count *)*((void *)this + 12);
  if (v4 && !atomic_fetch_add(&v4->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
    std::__shared_weak_count::__release_weak(v4);
  }
  *(void *)this = &unk_1EF55D4B8;
  uint64_t v5 = *((void *)this + 1);
  if (v5)
  {
    (*(void (**)(uint64_t, void))(*(void *)v5 + 16))(v5, *((void *)this + 3));
    *((void *)this + 3) = 3735927469;
  }
  uint64_t v6 = (std::__shared_weak_count *)*((void *)this + 2);
  if (v6)
  {
    if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
}

void ta2::TextureAtlas::startFrame(ta2::TextureAtlas *this)
{
  uint64_t v392 = *MEMORY[0x1E4F143B8];
  if (!*((void *)this + 36)) {
    operator new[]();
  }
  uint64_t v1 = *((void *)this + 34);
  std::mutex::lock((std::mutex *)v1);
  uint64_t v2 = *(ta2::TextureAtlasRegion ***)(v1 + 64);
  unsigned int v3 = *(ta2::TextureAtlasRegion ***)(v1 + 72);
  if (v2 != v3)
  {
    do
    {
      unsigned int v4 = *v2;
      uint64_t v5 = (ta2::TextureAtlasPage *)*((void *)*v2 + 3);
      if (v5) {
        ta2::TextureAtlasPage::textureRegionWasFreed(v5, *v2);
      }
      *((unsigned char *)v4 + 80) = 2;
      ++v2;
    }
    while (v2 != v3);
    uint64_t v2 = *(ta2::TextureAtlasRegion ***)(v1 + 64);
  }
  *(void *)(v1 + 72) = v2;
  std::mutex::unlock((std::mutex *)v1);
  uint64_t j = (uint64_t *)*((void *)this + 14);
  uint64_t v364 = (unint64_t **)((char *)this + 112);
  for (uint64_t i = (uint64_t *)*((void *)this + 15); j != i; j += 2)
  {
    uint64_t v366 = j;
    uint64_t v7 = *j;
    int v9 = *(long long **)(*j + 368);
    unsigned int v8 = *(long long **)(*j + 376);
    unsigned int v10 = (long long *)((char *)v9 + 24);
    if ((long long *)((char *)v9 + 24) != v8)
    {
      long long v11 = *v9;
      *int v9 = *(long long *)((char *)v9 + 24);
      *(long long *)((char *)v9 + 24) = v11;
      uint64_t v12 = *((void *)v9 + 2);
      *((void *)v9 + 2) = *((void *)v9 + 5);
      *((void *)v9 + 5) = v12;
      if (v9 + 3 != v8)
      {
        unint64_t v13 = v9 + 4;
        do
        {
          unsigned int v14 = (long long *)(v13 - 2);
          long long v15 = *((_OWORD *)v13 - 1);
          uint64_t v17 = *(v13 - 4);
          uint64_t v16 = *(v13 - 3);
          *(v13 - 3) = *v13;
          *(v13 - 1) = v17;
          *unint64_t v13 = v16;
          unsigned int v18 = v13 + 3;
          unsigned int v19 = (long long *)(v13 + 1);
          uint64_t v22 = *(v13 - 5);
          unsigned int v20 = (long long *)(v13 - 5);
          uint64_t v21 = v22;
          if (v20 == v10) {
            unsigned int v10 = v14;
          }
          *unsigned int v20 = v15;
          *(void *)unsigned int v14 = v21;
          unint64_t v13 = v18;
        }
        while (v19 != v8);
        if (v14 != v10)
        {
          unsigned int v23 = v10;
          while (1)
          {
            uint64_t v24 = *(void *)v14;
            *(void *)unsigned int v14 = *(void *)v23;
            *(void *)unsigned int v23 = v24;
            uint64_t v25 = *((void *)v14 + 1);
            *((void *)v14 + 1) = *((void *)v23 + 1);
            *((void *)v23 + 1) = v25;
            uint64_t v26 = *((void *)v14 + 2);
            *((void *)v14 + 2) = *((void *)v23 + 2);
            *((void *)v23 + 2) = v26;
            unsigned int v14 = (long long *)((char *)v14 + 24);
            unsigned int v23 = (long long *)((char *)v23 + 24);
            BOOL v27 = v14 == v10;
            if (v23 == v8)
            {
              if (v14 == v10) {
                break;
              }
              unsigned int v23 = (long long *)((char *)v10 + 24);
              while (1)
              {
                uint64_t v28 = *(void *)v14;
                *(void *)unsigned int v14 = *(void *)v10;
                *(void *)unsigned int v10 = v28;
                uint64_t v29 = *((void *)v14 + 1);
                *((void *)v14 + 1) = *((void *)v10 + 1);
                *((void *)v10 + 1) = v29;
                uint64_t v30 = *((void *)v14 + 2);
                *((void *)v14 + 2) = *((void *)v10 + 2);
                *((void *)v10 + 2) = v30;
                unsigned int v14 = (long long *)((char *)v14 + 24);
                BOOL v27 = v14 == v10;
                if (v23 != v8) {
                  break;
                }
                if (v14 == v10) {
                  goto LABEL_27;
                }
              }
            }
            if (v27) {
              unsigned int v10 = v23;
            }
          }
        }
      }
    }
LABEL_27:
    uint64_t v31 = *(void *)(v7 + 376);
    unsigned int v32 = *(int8x16_t ***)(v31 - 24);
    unsigned int v33 = *(int8x16_t ***)(v31 - 16);
    if (v32 != v33)
    {
      if (*(unsigned char *)(*(void *)v7 + 96))
      {
        do
        {
          uint64_t v37 = *v32;
          if (*(unsigned char *)(*(void *)v7 + 96))
          {
            v38.i64[0] = 0xFFFFFFFF00000000;
            v38.i64[1] = 0xFFFFFFFF00000000;
            int64x2_t v39 = vaddq_s64((int64x2_t)vbslq_s8(v38, v37[2], (int8x16_t)vaddq_s64((int64x2_t)v37[2], (int64x2_t)xmmword_1A28FE760)), (int64x2_t)xmmword_1A28FE770);
            *(int64x2_t *)long long buf = v39;
            if (*(unsigned char *)(v7 + 80))
            {
              __int32 v40 = v39.i32[2];
              __int32 v41 = v39.i32[0];
              __int32 v42 = v39.i32[3];
              __int32 v43 = v39.i32[1];
              if (geo::GuillotineBin::erase((geo::GuillotineBin *)(v7 + 88), (long long *)buf))
              {
                *(_DWORD *)(v7 + 40) += (v42 - v43) * (v41 - v40);
              }
              else
              {
                geo::GuillotineBin::addFreeRegion(v7 + 88, (uint64_t)buf);
                *(_DWORD *)(v7 + 40) += (v42 - v43) * (v41 - v40);
                if (*(unsigned char *)(v7 + 53)) {
                  geo::GuillotineBin::mergeFreeList(v7 + 88);
                }
              }
            }
            uint64_t v37 = *v32;
          }
          *(_DWORD *)(v7 + 208) += (((unint64_t)(v37[2].i64[1] + 0x100000000) >> 32)
                                  - ((unint64_t)(v37[2].i64[0] - 0x100000000) >> 32))
                                 * (v37[2].i64[0] - v37[2].i64[1] - 2);
          v32 += 2;
        }
        while (v32 != v33);
        uint64_t v31 = *(void *)(v7 + 376);
        unsigned int v32 = *(int8x16_t ***)(v31 - 24);
        unsigned int v33 = *(int8x16_t ***)(v31 - 16);
      }
      else
      {
        int v34 = *(_DWORD *)(v7 + 208);
        uint64_t v35 = *(int8x16_t ***)(v31 - 24);
        do
        {
          unint64_t v36 = *v35;
          v35 += 2;
          v34 += (((unint64_t)(v36[2].i64[1] + 0x100000000) >> 32)
                - ((unint64_t)(v36[2].i64[0] - 0x100000000) >> 32))
               * (v36[2].i64[0] - v36[2].i64[1] - 2);
          *(_DWORD *)(v7 + 208) = v34;
        }
        while (v35 != v33);
      }
      for (uint64_t j = v366; v33 != v32; v33 -= 2)
      {
        uint64_t v44 = (std::__shared_weak_count *)*(v33 - 1);
        if (v44 && !atomic_fetch_add(&v44->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v44->__on_zero_shared)(v44);
          std::__shared_weak_count::__release_weak(v44);
        }
      }
    }
    *(void *)(v31 - 16) = v32;
  }
  uint64_t v46 = (long long *)*((void *)this + 40);
  uint64_t v45 = (long long *)*((void *)this + 41);
  uint64_t v47 = (long long *)((char *)v46 + 24);
  if ((long long *)((char *)v46 + 24) != v45)
  {
    long long v48 = *v46;
    long long *v46 = *(long long *)((char *)v46 + 24);
    *(long long *)((char *)v46 + 24) = v48;
    uint64_t v49 = *((void *)v46 + 2);
    *((void *)v46 + 2) = *((void *)v46 + 5);
    *((void *)v46 + 5) = v49;
    if (v46 + 3 != v45)
    {
      uint64_t v50 = v46 + 4;
      do
      {
        uint64_t v51 = (long long *)(v50 - 2);
        long long v52 = *((_OWORD *)v50 - 1);
        uint64_t v54 = *(v50 - 4);
        uint64_t v53 = *(v50 - 3);
        *(v50 - 3) = *v50;
        *(v50 - 1) = v54;
        void *v50 = v53;
        uint64_t v55 = v50 + 3;
        uint64_t v56 = (long long *)(v50 + 1);
        uint64_t v59 = *(v50 - 5);
        unint64_t v57 = (long long *)(v50 - 5);
        uint64_t v58 = v59;
        if (v57 == v47) {
          uint64_t v47 = v51;
        }
        *unint64_t v57 = v52;
        *(void *)uint64_t v51 = v58;
        uint64_t v50 = v55;
      }
      while (v56 != v45);
      if (v51 != v47)
      {
        float v60 = v47;
        while (1)
        {
          uint64_t v61 = *(void *)v51;
          *(void *)uint64_t v51 = *(void *)v60;
          *(void *)float v60 = v61;
          uint64_t v62 = *((void *)v51 + 1);
          *((void *)v51 + 1) = *((void *)v60 + 1);
          *((void *)v60 + 1) = v62;
          uint64_t v63 = *((void *)v51 + 2);
          *((void *)v51 + 2) = *((void *)v60 + 2);
          *((void *)v60 + 2) = v63;
          uint64_t v51 = (long long *)((char *)v51 + 24);
          float v60 = (long long *)((char *)v60 + 24);
          BOOL v64 = v51 == v47;
          if (v60 == v45)
          {
            if (v51 == v47) {
              break;
            }
            float v60 = (long long *)((char *)v47 + 24);
            while (1)
            {
              uint64_t v65 = *(void *)v51;
              *(void *)uint64_t v51 = *(void *)v47;
              *(void *)uint64_t v47 = v65;
              uint64_t v66 = *((void *)v51 + 1);
              *((void *)v51 + 1) = *((void *)v47 + 1);
              *((void *)v47 + 1) = v66;
              uint64_t v67 = *((void *)v51 + 2);
              *((void *)v51 + 2) = *((void *)v47 + 2);
              *((void *)v47 + 2) = v67;
              uint64_t v51 = (long long *)((char *)v51 + 24);
              BOOL v64 = v51 == v47;
              if (v60 != v45) {
                break;
              }
              if (v51 == v47) {
                goto LABEL_62;
              }
            }
          }
          if (v64) {
            uint64_t v47 = v60;
          }
        }
      }
    }
  }
LABEL_62:
  uint64_t v68 = *((void *)this + 41);
  uint64_t v69 = *(void *)(v68 - 24);
  for (uint64_t k = *(void *)(v68 - 16); k != v69; k -= 16)
  {
    float v71 = *(std::__shared_weak_count **)(k - 8);
    if (v71 && !atomic_fetch_add(&v71->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v71->__on_zero_shared)(v71);
      std::__shared_weak_count::__release_weak(v71);
    }
  }
  *(void *)(v68 - 16) = v69;
  unint64_t v73 = (long long *)*((void *)this + 37);
  BOOL v72 = (long long *)*((void *)this + 38);
  unint64_t v74 = (long long *)((char *)v73 + 24);
  if ((long long *)((char *)v73 + 24) != v72)
  {
    long long v75 = *v73;
    long long *v73 = *(long long *)((char *)v73 + 24);
    *(long long *)((char *)v73 + 24) = v75;
    uint64_t v76 = *((void *)v73 + 2);
    *((void *)v73 + 2) = *((void *)v73 + 5);
    *((void *)v73 + 5) = v76;
    if (v73 + 3 != v72)
    {
      double v77 = v73 + 4;
      do
      {
        uint64_t v78 = (long long *)(v77 - 2);
        long long v79 = *((_OWORD *)v77 - 1);
        uint64_t v81 = *(v77 - 4);
        uint64_t v80 = *(v77 - 3);
        *(v77 - 3) = *v77;
        *(v77 - 1) = v81;
        *double v77 = v80;
        size_t v82 = v77 + 3;
        size_t v83 = (long long *)(v77 + 1);
        uint64_t v86 = *(v77 - 5);
        BOOL v84 = (long long *)(v77 - 5);
        uint64_t v85 = v86;
        if (v84 == v74) {
          unint64_t v74 = v78;
        }
        *BOOL v84 = v79;
        *(void *)uint64_t v78 = v85;
        double v77 = v82;
      }
      while (v83 != v72);
      if (v78 != v74)
      {
        uint64_t v87 = v74;
        while (1)
        {
          uint64_t v88 = *(void *)v78;
          *(void *)uint64_t v78 = *(void *)v87;
          *(void *)uint64_t v87 = v88;
          uint64_t v89 = *((void *)v78 + 1);
          *((void *)v78 + 1) = *((void *)v87 + 1);
          *((void *)v87 + 1) = v89;
          uint64_t v90 = *((void *)v78 + 2);
          *((void *)v78 + 2) = *((void *)v87 + 2);
          *((void *)v87 + 2) = v90;
          uint64_t v78 = (long long *)((char *)v78 + 24);
          uint64_t v87 = (long long *)((char *)v87 + 24);
          BOOL v91 = v78 == v74;
          if (v87 == v72)
          {
            if (v78 == v74) {
              break;
            }
            uint64_t v87 = (long long *)((char *)v74 + 24);
            while (1)
            {
              uint64_t v92 = *(void *)v78;
              *(void *)uint64_t v78 = *(void *)v74;
              *(void *)unint64_t v74 = v92;
              uint64_t v93 = *((void *)v78 + 1);
              *((void *)v78 + 1) = *((void *)v74 + 1);
              *((void *)v74 + 1) = v93;
              uint64_t v94 = *((void *)v78 + 2);
              *((void *)v78 + 2) = *((void *)v74 + 2);
              *((void *)v74 + 2) = v94;
              uint64_t v78 = (long long *)((char *)v78 + 24);
              BOOL v91 = v78 == v74;
              if (v87 != v72) {
                break;
              }
              if (v78 == v74) {
                goto LABEL_83;
              }
            }
          }
          if (v91) {
            unint64_t v74 = v87;
          }
        }
      }
    }
  }
LABEL_83:
  uint64_t v95 = *((void *)this + 38);
  uint64_t v96 = *(uint64_t **)(v95 - 24);
  uint64_t v97 = *(uint64_t **)(v95 - 16);
  if (v96 != v97)
  {
    do
    {
      uint64_t v98 = *v96++;
      (*(void (**)(void, uint64_t))(**((void **)this + 43) + 64))(*((void *)this + 43), v98);
    }
    while (v96 != v97);
    uint64_t v95 = *((void *)this + 38);
    uint64_t v96 = *(uint64_t **)(v95 - 24);
  }
  *(void *)(v95 - 16) = v96;
  unint64_t v99 = (std::mutex *)((char *)this + 160);
  if (*((unsigned char *)this + 72) != 1)
  {
    std::mutex::lock(v99);
    uint64_t v383 = (void *)*((void *)this + 28);
    char v113 = (char *)v383;
    long long v372 = *(_OWORD *)((char *)this + 232);
    *((void *)this + 28) = 0;
    *((void *)this + 29) = 0;
    long long v384 = v372;
    *((void *)this + 30) = 0;
    std::mutex::unlock((std::mutex *)((char *)this + 160));
    BOOL v114 = this;
    if (v113 == (char *)v372 && *((void *)this + 31) == *((void *)this + 32)) {
      goto LABEL_427;
    }
    uint64_t v380 = 0;
    uint64_t v381 = 0;
    uint64_t v382 = 0;
    ta2::TextureAtlas::createRegionItems(&v383, (uint64_t)&v380);
    uint64_t v377 = 0;
    uint64_t v378 = 0;
    unint64_t v379 = 0;
    __p[0] = 0;
    __p[1] = 0;
    uint64_t v376 = 0;
    uint64_t v115 = (unint64_t *)*((void *)this + 14);
    uint64_t v116 = (unint64_t *)*((void *)this + 15);
    int64_t v117 = (char *)v116 - (char *)v115;
    if (v116 == v115)
    {
      uint64_t v121 = 0;
      uint64_t v115 = (unint64_t *)*((void *)this + 15);
      if (!v116)
      {
LABEL_172:
        *((_OWORD *)v114 + 7) = *(_OWORD *)__p;
        BOOL v165 = (__n128 *)v377;
        *((void *)v114 + 16) = v376;
        __p[1] = 0;
        uint64_t v376 = 0;
        __p[0] = 0;
        uint64_t v166 = *((void *)v114 + 41);
        uint64_t v168 = (void **)(v166 - 24);
        __int8 v167 = *(char **)(v166 - 24);
        unint64_t v169 = v121 - v165;
        uint64_t v170 = *(void *)(v166 - 8);
        if (v169 <= (v170 - (uint64_t)v167) >> 4)
        {
          unint64_t v174 = *(char **)(v166 - 16);
          unint64_t v175 = (v174 - v167) >> 4;
          if (v175 >= v169)
          {
            if (v165 != v121)
            {
              do
              {
                unint64_t v181 = v165->n128_u64[0];
                unint64_t v180 = v165->n128_u64[1];
                if (v180) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v180 + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t v182 = (std::__shared_weak_count *)*((void *)v167 + 1);
                *(void *)__int8 v167 = v181;
                *((void *)v167 + 1) = v180;
                if (v182 && !atomic_fetch_add(&v182->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v182->__on_zero_shared)(v182);
                  std::__shared_weak_count::__release_weak(v182);
                }
                v167 += 16;
                ++v165;
              }
              while (v165 != v121);
              unint64_t v174 = *(char **)(v166 - 16);
            }
            for (; v174 != v167; v174 -= 16)
            {
              int v190 = (std::__shared_weak_count *)*((void *)v174 - 1);
              if (v190 && !atomic_fetch_add(&v190->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v190->__on_zero_shared)(v190);
                std::__shared_weak_count::__release_weak(v190);
              }
            }
            *(void *)(v166 - 16) = v167;
          }
          else
          {
            int v176 = &v165[v175];
            if (v174 != v167)
            {
              do
              {
                unint64_t v178 = v165->n128_u64[0];
                unint64_t v177 = v165->n128_u64[1];
                if (v177) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v177 + 8), 1uLL, memory_order_relaxed);
                }
                uint64_t v179 = (std::__shared_weak_count *)*((void *)v167 + 1);
                *(void *)__int8 v167 = v178;
                *((void *)v167 + 1) = v177;
                if (v179 && !atomic_fetch_add(&v179->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v179->__on_zero_shared)(v179);
                  std::__shared_weak_count::__release_weak(v179);
                }
                ++v165;
                v167 += 16;
              }
              while (v165 != v176);
              __int8 v167 = *(char **)(v166 - 16);
            }
            uint64_t v188 = v167;
            if (v176 != v121)
            {
              uint64_t v188 = v167;
              do
              {
                *(void *)uint64_t v188 = v176->n128_u64[0];
                unint64_t v189 = v176->n128_u64[1];
                *((void *)v188 + 1) = v189;
                if (v189) {
                  atomic_fetch_add_explicit((atomic_ullong *volatile)(v189 + 8), 1uLL, memory_order_relaxed);
                }
                v188 += 16;
                ++v176;
              }
              while (v176 != v121);
            }
            *(void *)(v166 - 16) = v188;
          }
        }
        else
        {
          if (v167)
          {
            int v171 = *(char **)(v166 - 16);
            int v172 = *(void **)(v166 - 24);
            if (v171 != v167)
            {
              do
              {
                unsigned __int8 v173 = (std::__shared_weak_count *)*((void *)v171 - 1);
                if (v173 && !atomic_fetch_add(&v173->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v173->__on_zero_shared)(v173);
                  std::__shared_weak_count::__release_weak(v173);
                }
                v171 -= 16;
              }
              while (v171 != v167);
              int v172 = *v168;
            }
            *(void *)(v166 - 16) = v167;
            operator delete(v172);
            uint64_t v170 = 0;
            void *v168 = 0;
            *(void *)(v166 - 16) = 0;
            *(void *)(v166 - 8) = 0;
          }
          if ((char *)v121 - (char *)v165 < 0) {
            goto LABEL_488;
          }
          uint64_t v183 = v170 >> 3;
          if (v170 >> 3 <= v169) {
            uint64_t v183 = v121 - v165;
          }
          _CF = (unint64_t)v170 >= 0x7FFFFFFFFFFFFFF0;
          unint64_t v184 = 0xFFFFFFFFFFFFFFFLL;
          if (!_CF) {
            unint64_t v184 = v183;
          }
          if (v184 >> 60) {
            goto LABEL_488;
          }
          uint64_t v185 = 2 * v184;
          uint64_t v186 = operator new(16 * v184);
          *(void *)(v166 - 24) = v186;
          *(void *)(v166 - 16) = v186;
          for (*(void *)(v166 - 8) = &v186[v185]; v165 != v121; ++v165)
          {
            void *v186 = v165->n128_u64[0];
            unint64_t v187 = v165->n128_u64[1];
            v186[1] = v187;
            if (v187) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v187 + 8), 1uLL, memory_order_relaxed);
            }
            v186 += 2;
          }
          *(void *)(v166 - 16) = v186;
        }
        uint64_t v191 = (__n128 *)v377;
        uint64_t v192 = v378;
        if (v377 != v378)
        {
          if (GEOGetVectorKitTextureAtlasLog(void)::onceToken != -1) {
            dispatch_once(&GEOGetVectorKitTextureAtlasLog(void)::onceToken, &__block_literal_global_17999);
          }
          unint64_t v193 = GEOGetVectorKitTextureAtlasLog(void)::log;
          if (os_log_type_enabled((os_log_t)GEOGetVectorKitTextureAtlasLog(void)::log, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = (unint64_t)((char *)v192 - (char *)v191) >> 4;
            _os_log_impl(&dword_1A1780000, v193, OS_LOG_TYPE_INFO, "repacking icon atlas cnt=%i", buf, 8u);
          }
          do
          {
            ta2::TextureAtlas::createRegionItems((void *)(v191->n128_u64[0] + 344), (uint64_t)&v380);
            unint64_t v194 = v191->n128_u64[0];
            uint64_t v195 = *(void *)(v191->n128_u64[0] + 344);
            for (uint64_t m = *(void *)(v191->n128_u64[0] + 352); m != v195; m -= 16)
            {
              uint64_t v197 = *(std::__shared_weak_count **)(m - 8);
              if (v197 && !atomic_fetch_add(&v197->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v197->__on_zero_shared)(v197);
                std::__shared_weak_count::__release_weak(v197);
              }
            }
            *(void *)(v194 + 352) = v195;
            ++v191;
          }
          while (v191 != v192);
        }
        uint64_t v198 = (char *)v380;
        uint64_t v199 = v381;
        unint64_t v200 = 126 - 2 * __clz(0x8E38E38E38E38E39 * ((v381 - (unsigned char *)v380) >> 3));
        if (v381 == v380) {
          uint64_t v201 = 0;
        }
        else {
          uint64_t v201 = v200;
        }
        std::__introsort<std::_ClassicAlgPolicy,ta2::TextureAtlas::sortRegionItems(std::vector<ta2::TextureAtlas::RegionItem> &)::$_0 &,ta2::TextureAtlas::RegionItem*,false>((unint64_t)v380, (long long *)v381, v201, 1);
        uint64_t v374 = v198;
        uint64_t v367 = v199;
        if (v199 != v198)
        {
LABEL_248:
          uint64_t v204 = (uint64_t *)*((void *)this + 14);
          uint64_t v369 = (uint64_t *)*((void *)this + 15);
          if (v204 == v369)
          {
            uint64_t v205 = (uint64_t *)*((void *)this + 14);
            uint64_t v206 = this;
            goto LABEL_338;
          }
          while (1)
          {
            uint64_t v207 = *v204;
            uint64_t v208 = (geo::SkylineBin *)(*v204 + 24);
            int v209 = (geo::GuillotineBin *)(*v204 + 88);
            uint64_t v211 = *(void *)(*(void *)v374 + 32);
            uint64_t v210 = *(void *)(*(void *)v374 + 40);
            unsigned int v212 = v210 - v211 + 2;
            unint64_t v213 = (unint64_t)(v210 + 0x100000000) >> 32;
            unint64_t v214 = (unint64_t)(v211 - 0x100000000) >> 32;
            unsigned int v215 = v213 - v214;
            int v216 = *(_DWORD *)(*v204 + 48);
            if (v216 == 1)
            {
              v386[0] = 0;
              v385[0] = 0;
              unint64_t PositionForNewNodeMinWaste = geo::SkylineBin::findPositionForNewNodeMinWaste(v208, v212, (int)v213 - (int)v214, v386, &v387, v385, v202, v203);
              int v251 = v250;
              *(void *)long long buf = PositionForNewNodeMinWaste;
              *(void *)&uint8_t buf[8] = v250;
              if (v385[0] == -1)
              {
                *(void *)long long buf = 0;
                *(void *)&uint8_t buf[8] = 0;
                if (*(unsigned char *)(v207 + 80))
                {
                  unint64_t v255 = geo::GuillotineBin::insert(v209, v212, v215, *(unsigned __int8 *)(v207 + 53));
                  unint64_t v253 = HIDWORD(v255);
                  *(void *)long long buf = v255;
                  unint64_t v254 = HIDWORD(v256);
                  *(void *)&uint8_t buf[8] = v256;
                  int v252 = v255;
                  int v251 = v256;
                }
                else
                {
                  LODWORD(v253) = 0;
                  LODWORD(v254) = 0;
                  int v252 = 0;
                  int v251 = 0;
                }
              }
              else
              {
                int v252 = PositionForNewNodeMinWaste;
                unint64_t v253 = HIDWORD(PositionForNewNodeMinWaste);
                unint64_t v254 = HIDWORD(v250);
                geo::SkylineBin::addSkylineLevel((uint64_t)v208, v385[0], (int *)buf);
              }
              if ((v251 - v252) * (v254 - v253)) {
                goto LABEL_332;
              }
              goto LABEL_333;
            }
            if (!v216) {
              break;
            }
LABEL_334:
            if ((HIDWORD(v214) - HIDWORD(v213)) * (v214 - v213) == v215 * v212)
            {
              *(_DWORD *)(v207 + 208) += v215 * v212;
              *((void *)v374 + 4) = v213;
              *((void *)v374 + 5) = v214;
              *((void *)v374 + 7) = v207;
              goto LABEL_247;
            }
            if (!*(_DWORD *)(v207 + 212)) {
              *(_DWORD *)(v207 + 212) = (float)((float)*(unsigned int *)(v207 + 208) * 0.8);
            }
            v204 += 2;
            if (v204 == v369)
            {
              uint64_t v206 = this;
              uint64_t v205 = (uint64_t *)*((void *)this + 14);
              uint64_t v204 = (uint64_t *)*((void *)this + 15);
LABEL_338:
              _ZF = v205 == v204;
              uint64_t v281 = 48;
              if (_ZF) {
                uint64_t v281 = 40;
              }
              *(void *)float64x2_t v386 = *(void *)((char *)v206 + v281);
              std::allocate_shared[abi:nn180100]<ta2::TextureAtlasPage,std::allocator<ta2::TextureAtlasPage>,ta2::TextureAtlas &,gm::Matrix<unsigned int,2,1> &,unsigned int &,BOOL &,BOOL,std::shared_ptr<mre::GraphicsResourceStore> &,void>(v385, (uint64_t)v206, (uint32x2_t *)v386, *((_DWORD *)v206 + 25), *((unsigned char *)v206 + 96), 0, *((void *)v206 + 43), *((std::__shared_weak_count **)v206 + 44));
              if (!ta2::TextureAtlasPage::reserveRegions(v385[0], (unint64_t)v374, 1uLL, v282, v283, v284, v285, v286))
              {
                if (GEOGetVectorKitTextureAtlasLog(void)::onceToken != -1) {
                  dispatch_once(&GEOGetVectorKitTextureAtlasLog(void)::onceToken, &__block_literal_global_17999);
                }
                double v298 = GEOGetVectorKitTextureAtlasLog(void)::log;
                if (os_log_type_enabled((os_log_t)GEOGetVectorKitTextureAtlasLog(void)::log, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v300 = *(void *)(*(void *)v374 + 32);
                  uint64_t v299 = *(void *)(*(void *)v374 + 40);
                  *(_DWORD *)long long buf = 67110146;
                  *(_DWORD *)&uint8_t buf[4] = v299 - v300 + 2;
                  *(_WORD *)&uint8_t buf[8] = 1024;
                  *(_DWORD *)&buf[10] = ((unint64_t)(v299 + 0x100000000) >> 32)
                                      - ((unint64_t)(v300 - 0x100000000) >> 32);
                  *(_WORD *)&buf[14] = 2080;
                  *(void *)&buf[16] = "false";
                  *(_WORD *)uint64_t v389 = 2080;
                  *(void *)&v389[2] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/TextureAtlas2.cpp";
                  __int16 v390 = 1024;
                  int v391 = 407;
                  _os_log_impl(&dword_1A1780000, v298, OS_LOG_TYPE_ERROR, "Failed to allocate(%i,%i) in a new page: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x28u);
                }
                goto LABEL_388;
              }
              unint64_t v288 = (unint64_t *)*((void *)v206 + 14);
              unint64_t v287 = *((void *)v206 + 15);
              unint64_t v289 = *((void *)v206 + 16);
              if (v287 < v289)
              {
                if (v288 == (unint64_t *)v287)
                {
                  unint64_t v310 = v385[1];
                  *(_OWORD *)unint64_t v288 = *(_OWORD *)v385;
                  if (v310) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v310 + 8), 1uLL, memory_order_relaxed);
                  }
                  *((void *)this + 15) = v288 + 2;
                }
                else
                {
                  unint64_t v290 = v287 - 16;
                  unint64_t v291 = (_OWORD *)*((void *)v206 + 15);
                  if (v287 >= 0x10)
                  {
                    do
                    {
                      *v291++ = *(_OWORD *)v290;
                      *(void *)unint64_t v290 = 0;
                      *(void *)(v290 + 8) = 0;
                      v290 += 16;
                    }
                    while (v290 < v287);
                  }
                  *((void *)this + 15) = v291;
                  if ((unint64_t *)v287 != v288 + 2)
                  {
                    double v292 = (std::__shared_weak_count **)(v287 - 8);
                    uint64_t v293 = 2 * ((uint64_t)(v287 - (void)(v288 + 2)) >> 4);
                    double v294 = v288 - 2;
                    do
                    {
                      double v295 = (char *)&v294[v293];
                      long long v296 = *(_OWORD *)&v294[v293];
                      *(void *)double v295 = 0;
                      *((void *)v295 + 1) = 0;
                      double v297 = *v292;
                      *(_OWORD *)(v292 - 1) = v296;
                      if (v297 && !atomic_fetch_add(&v297->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                      {
                        ((void (*)(std::__shared_weak_count *))v297->__on_zero_shared)(v297);
                        std::__shared_weak_count::__release_weak(v297);
                      }
                      v292 -= 2;
                      v293 -= 2;
                    }
                    while (v293 * 8);
                  }
                  double v306 = v385;
                  if (v288 <= v385) {
                    double v306 = &v385[2 * (*((void *)this + 15) > (unint64_t)v385)];
                  }
                  unint64_t v308 = *v306;
                  unint64_t v307 = v306[1];
                  if (v307) {
                    atomic_fetch_add_explicit((atomic_ullong *volatile)(v307 + 8), 1uLL, memory_order_relaxed);
                  }
                  unint64_t v309 = (std::__shared_weak_count *)v288[1];
                  unint64_t *v288 = v308;
                  v288[1] = v307;
                  if (v309 && !atomic_fetch_add(&v309->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                  {
                    ((void (*)(std::__shared_weak_count *))v309->__on_zero_shared)(v309);
                    std::__shared_weak_count::__release_weak(v309);
                  }
                }
                goto LABEL_387;
              }
              unint64_t v301 = ((uint64_t)(v287 - (void)v288) >> 4) + 1;
              if (v301 >> 60) {
                goto LABEL_488;
              }
              uint64_t v302 = v289 - (void)v288;
              if (v302 >> 3 > v301) {
                unint64_t v301 = v302 >> 3;
              }
              if ((unint64_t)v302 >= 0x7FFFFFFFFFFFFFF0) {
                unint64_t v301 = 0xFFFFFFFFFFFFFFFLL;
              }
              if (v301)
              {
                if (!(v301 >> 60))
                {
                  uint64_t v303 = 2 * v301;
                  double v304 = operator new(16 * v301);
                  double v305 = &v304[v303];
                  goto LABEL_374;
                }
LABEL_489:
                std::__throw_bad_array_new_length[abi:nn180100]();
              }
              double v304 = operator new(0x10uLL);
              double v305 = v304 + 2;
LABEL_374:
              unint64_t v311 = v385[1];
              void *v304 = v385[0];
              v304[1] = v311;
              if (v311)
              {
                atomic_fetch_add_explicit((atomic_ullong *volatile)(v311 + 8), 1uLL, memory_order_relaxed);
                long long v312 = *v364;
                long long v313 = v304 + 2;
                if (*v364 != v288)
                {
                  long long v314 = v288;
                  do
                  {
                    long long v315 = *((_OWORD *)v314 - 1);
                    v314 -= 2;
                    *((_OWORD *)v304 - 1) = v315;
                    v304 -= 2;
                    unint64_t *v314 = 0;
                    v314[1] = 0;
                  }
                  while (v314 != v312);
                }
              }
              else
              {
                long long v313 = v304 + 2;
              }
              uint64_t v316 = (unint64_t *)*((void *)this + 15);
              if (v316 == v288)
              {
                uint64_t v317 = this;
              }
              else
              {
                do
                {
                  *v313++ = *(_OWORD *)v288;
                  unint64_t *v288 = 0;
                  v288[1] = 0;
                  v288 += 2;
                }
                while (v288 != v316);
                uint64_t v317 = this;
                unint64_t v288 = (unint64_t *)*((void *)this + 15);
              }
              unint64_t v318 = (unint64_t *)*((void *)v317 + 14);
              *((void *)v317 + 14) = v304;
              *((void *)v317 + 15) = v313;
              *((void *)v317 + 16) = v305;
              if (v288 == v318)
              {
                if (!v288) {
                  goto LABEL_387;
                }
                goto LABEL_386;
              }
              do
              {
                uint64_t v320 = (std::__shared_weak_count *)*(v288 - 1);
                if (v320 && !atomic_fetch_add(&v320->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v320->__on_zero_shared)(v320);
                  std::__shared_weak_count::__release_weak(v320);
                }
                v288 -= 2;
              }
              while (v288 != v318);
              unint64_t v288 = v318;
              if (v318) {
LABEL_386:
              }
                operator delete(v288);
LABEL_387:
              ta2::TextureAtlas::clearPageEdges((uint64_t)this, v385[0]);
LABEL_388:
              uint64_t v319 = (std::__shared_weak_count *)v385[1];
              if (v385[1] && !atomic_fetch_add((atomic_ullong *volatile)(v385[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v319->__on_zero_shared)(v319);
                std::__shared_weak_count::__release_weak(v319);
              }
LABEL_247:
              v374 += 72;
              if (v374 == v367) {
                goto LABEL_397;
              }
              goto LABEL_248;
            }
          }
          uint64_t v217 = *(void *)(v207 + 56);
          uint64_t v218 = *(void *)(v207 + 64) - v217;
          if (!v218) {
            goto LABEL_328;
          }
          unint64_t v219 = v218 / 12;
          if (v219 <= 1) {
            unint64_t v219 = 1;
          }
          unsigned int v220 = *(_DWORD *)(v207 + 32);
          if (*(unsigned char *)(v207 + 52))
          {
            unint64_t v221 = 0;
            int v222 = 0;
            LODWORD(v223) = 0;
            unint64_t v224 = 0;
            uint64_t v225 = (unsigned int *)(v217 + 8);
            unsigned int v226 = -1;
            unint64_t v227 = -1;
            unsigned int v228 = -1;
            unsigned int v229 = -1;
            while (1)
            {
              uint64_t v231 = (int *)(v217 + 12 * v221);
              int v232 = *v231;
              uint64_t v233 = *v231 + v212;
              if (v233 > v220) {
                goto LABEL_277;
              }
              unsigned int v234 = v231[1];
              if (v212)
              {
                long long v235 = v225;
                unsigned int v202 = v212;
                while (1)
                {
                  if (v234 <= *(v235 - 1)) {
                    unsigned int v234 = *(v235 - 1);
                  }
                  uint64_t v236 = v234 + v215;
                  if (v236 > *(_DWORD *)(v207 + 36)) {
                    break;
                  }
                  unsigned int v237 = *v235;
                  v235 += 3;
                  uint64_t v203 = v237;
                  _CF = v202 >= v237;
                  v202 -= v237;
                  BOOL v238 = v202 != 0 && _CF;
                  if (!_CF) {
                    unsigned int v202 = 0;
                  }
                  if (!v238)
                  {
                    _ZF = v236 == v226;
                    if (v236 >= v226) {
                      goto LABEL_274;
                    }
                    goto LABEL_271;
                  }
                }
              }
              else
              {
                uint64_t v236 = v234 + v215;
                _ZF = v236 == v226;
                if (v236 < v226)
                {
LABEL_271:
                  unsigned int v240 = *(_DWORD *)(v217 + 12 * v221 + 8);
LABEL_272:
                  unint64_t v227 = v221;
                  unsigned int v226 = v236;
                  unsigned int v228 = v240;
                  unsigned int v229 = v240;
                  LODWORD(v223) = v234;
                  int v222 = *v231;
                  unint64_t v224 = v233 | (v236 << 32);
                  goto LABEL_277;
                }
LABEL_274:
                if (_ZF)
                {
                  unsigned int v240 = *(_DWORD *)(v217 + 12 * v221 + 8);
                  if (v240 < v229) {
                    goto LABEL_272;
                  }
                }
              }
LABEL_277:
              uint64_t v241 = v232 + v215;
              if (v241 <= v220)
              {
                unsigned int v242 = v231[1];
                if (v215)
                {
                  float v243 = v225;
                  unsigned int v244 = v215;
                  while (1)
                  {
                    if (v242 <= *(v243 - 1)) {
                      unsigned int v242 = *(v243 - 1);
                    }
                    uint64_t v245 = v242 + v212;
                    if (v245 > *(_DWORD *)(v207 + 36)) {
                      goto LABEL_260;
                    }
                    unsigned int v246 = *v243;
                    v243 += 3;
                    unsigned int v202 = v246;
                    _CF = v244 >= v246;
                    v244 -= v246;
                    BOOL v247 = v244 != 0 && _CF;
                    if (!_CF) {
                      unsigned int v244 = 0;
                    }
                    if (!v247)
                    {
                      BOOL v248 = v245 == v226;
                      if (v245 < v226) {
                        goto LABEL_258;
                      }
                      goto LABEL_289;
                    }
                  }
                }
                uint64_t v245 = v242 + v212;
                BOOL v248 = v245 == v226;
                if (v245 < v226)
                {
LABEL_258:
                  unsigned int v230 = *(_DWORD *)(v217 + 12 * v221 + 8);
                }
                else
                {
LABEL_289:
                  if (!v248) {
                    goto LABEL_260;
                  }
                  unsigned int v230 = *(_DWORD *)(v217 + 12 * v221 + 8);
                  unsigned int v229 = v228;
                  if (v230 >= v228) {
                    goto LABEL_260;
                  }
                }
                unint64_t v227 = v221;
                unsigned int v226 = v245;
                unsigned int v228 = v230;
                unsigned int v229 = v230;
                LODWORD(v223) = v242;
                int v222 = v232;
                unint64_t v224 = v241 | (v245 << 32);
              }
LABEL_260:
              ++v221;
              v225 += 3;
              if (v221 == v219) {
                goto LABEL_326;
              }
            }
          }
          unint64_t v257 = 0;
          int v222 = 0;
          LODWORD(v223) = 0;
          unint64_t v224 = 0;
          if (v212)
          {
            unint64_t v258 = (unsigned int *)(v217 + 8);
            unsigned int v259 = -1;
            unint64_t v227 = -1;
            unsigned int v260 = -1;
            while (1)
            {
              uint64_t v262 = (int *)(v217 + 12 * v257);
              int v263 = *v262;
              uint64_t v264 = *v262 + v212;
              if (v264 <= v220)
              {
                unsigned int v265 = v262[1];
                uint64_t v266 = v258;
                unsigned int v267 = v212;
                do
                {
                  if (v265 <= *(v266 - 1)) {
                    unsigned int v265 = *(v266 - 1);
                  }
                  uint64_t v268 = v265 + v215;
                  if (v268 > *(_DWORD *)(v207 + 36)) {
                    goto LABEL_301;
                  }
                  unsigned int v269 = *v266;
                  v266 += 3;
                  _CF = v267 >= v269;
                  v267 -= v269;
                  BOOL v270 = v267 != 0 && _CF;
                  if (!_CF) {
                    unsigned int v267 = 0;
                  }
                }
                while (v270);
                if (v268 < v259)
                {
                  unsigned int v261 = *(_DWORD *)(v217 + 12 * v257 + 8);
LABEL_300:
                  unint64_t v227 = v257;
                  unsigned int v259 = v265 + v215;
                  unsigned int v260 = v261;
                  LODWORD(v223) = v265;
                  int v222 = v263;
                  unint64_t v224 = v264 | (v268 << 32);
                  goto LABEL_301;
                }
                if (v268 == v259)
                {
                  unsigned int v261 = *(_DWORD *)(v217 + 12 * v257 + 8);
                  if (v261 < v260) {
                    goto LABEL_300;
                  }
                }
              }
LABEL_301:
              ++v257;
              v258 += 3;
              if (v257 == v219) {
                goto LABEL_326;
              }
            }
          }
          uint64_t v271 = (unsigned int *)(v217 + 8);
          unsigned int v272 = -1;
          unint64_t v227 = -1;
          unsigned int v273 = -1;
          while (1)
          {
            uint64_t v275 = *(v271 - 2);
            if (v275 <= v220)
            {
              int v276 = *(v271 - 1);
              uint64_t v277 = v276 + v215;
              if (v277 < v272)
              {
                unsigned int v274 = *v271;
              }
              else
              {
                if (v277 != v272) {
                  goto LABEL_320;
                }
                unsigned int v274 = *v271;
                if (*v271 >= v273) {
                  goto LABEL_320;
                }
              }
              unint64_t v227 = v257;
              unsigned int v272 = v276 + v215;
              unsigned int v273 = v274;
              LODWORD(v223) = *(v271 - 1);
              int v222 = *(v271 - 2);
              unint64_t v224 = v275 | (v277 << 32);
            }
LABEL_320:
            ++v257;
            v271 += 3;
            if (v219 == v257)
            {
LABEL_326:
              *(_DWORD *)long long buf = v222;
              uint8_t buf[4] = v223;
              buf[5] = BYTE1(v223);
              buf[6] = BYTE2(v223);
              buf[7] = BYTE3(v223);
              *(void *)&uint8_t buf[8] = v224;
              if (v227 != -1)
              {
                unint64_t v278 = HIDWORD(v224);
                geo::SkylineBin::addSkylineLevel((uint64_t)v208, v227, (int *)buf);
                goto LABEL_331;
              }
LABEL_328:
              *(void *)long long buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              if (*(unsigned char *)(v207 + 80))
              {
                unint64_t v279 = geo::GuillotineBin::insert(v209, v212, v215, *(unsigned __int8 *)(v207 + 53));
                int v222 = v279;
                unint64_t v223 = HIDWORD(v279);
                *(void *)long long buf = v279;
                unint64_t v278 = HIDWORD(v280);
                *(void *)&uint8_t buf[8] = v280;
                LODWORD(v224) = v280;
              }
              else
              {
                LODWORD(v223) = 0;
                LODWORD(v278) = 0;
                int v222 = 0;
                LODWORD(v224) = 0;
              }
LABEL_331:
              if ((v224 - v222) * (v278 - v223)) {
LABEL_332:
              }
                *(_DWORD *)(v207 + 40) += v215 * v212;
LABEL_333:
              unint64_t v213 = *(void *)buf;
              unint64_t v214 = *(void *)&buf[8];
              goto LABEL_334;
            }
          }
        }
LABEL_397:
        unint64_t v321 = (__n128 *)v377;
        BOOL v114 = this;
        if (v377 == v378) {
          ta2::TextureAtlas::createReloadRegionItems((__n128 **)this + 31, (uint64_t)&v380);
        }
        std::vector<std::shared_ptr<ta2::TextureAtlasRegion>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<std::shared_ptr<ta2::TextureAtlasRegion>*>,std::__wrap_iter<std::shared_ptr<ta2::TextureAtlasRegion>*>>((void **)this + 31, *((void *)this + 31), v383, (void *)v384, (uint64_t)(v384 - (void)v383) >> 4);
        ta2::TextureAtlas::loadRegions((uint64_t)this, (uint64_t *)v380, (uint64_t *)v381);
        uint64_t v322 = (char *)__p[0];
        if (__p[0])
        {
          uint64_t v323 = (char *)__p[1];
          if (__p[1] != __p[0])
          {
            do
            {
              uint64_t v324 = (std::__shared_weak_count *)*((void *)v323 - 1);
              if (v324 && !atomic_fetch_add(&v324->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v324->__on_zero_shared)(v324);
                std::__shared_weak_count::__release_weak(v324);
              }
              v323 -= 16;
            }
            while (v323 != v322);
            uint64_t v322 = (char *)__p[0];
            unint64_t v321 = (__n128 *)v377;
          }
          operator delete(v322);
          BOOL v114 = this;
        }
        if (v321)
        {
          uint64_t v325 = v378;
          uint64_t v326 = v321;
          if (v378 != v321)
          {
            do
            {
              uint64_t v327 = (std::__shared_weak_count *)v325[-1].n128_u64[1];
              if (v327 && !atomic_fetch_add(&v327->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v327->__on_zero_shared)(v327);
                std::__shared_weak_count::__release_weak(v327);
              }
              --v325;
            }
            while (v325 != v321);
            uint64_t v326 = v377;
            BOOL v114 = this;
          }
          uint64_t v378 = v321;
          operator delete(v326);
        }
        uint64_t v328 = (char *)v380;
        if (v380)
        {
          uint64_t v329 = v381;
          if (v381 != v380)
          {
            do
            {
              uint64_t v330 = (std::__shared_weak_count *)*((void *)v329 - 8);
              if (v330 && !atomic_fetch_add(&v330->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
              {
                ((void (*)(std::__shared_weak_count *))v330->__on_zero_shared)(v330);
                std::__shared_weak_count::__release_weak(v330);
              }
              v329 -= 72;
            }
            while (v329 != v328);
            uint64_t v328 = (char *)v380;
            BOOL v114 = this;
          }
          operator delete(v328);
        }
        char v113 = (char *)v383;
LABEL_427:
        if (!v113) {
          goto LABEL_461;
        }
        uint64_t v331 = (char *)v384;
        uint64_t v332 = v113;
        if ((char *)v384 != v113)
        {
          do
          {
            uint64_t v333 = (std::__shared_weak_count *)*((void *)v331 - 1);
            if (v333 && !atomic_fetch_add(&v333->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v333->__on_zero_shared)(v333);
              std::__shared_weak_count::__release_weak(v333);
            }
            v331 -= 16;
          }
          while (v331 != v113);
          uint64_t v332 = v383;
          BOOL v114 = this;
        }
        *(void *)&long long v384 = v113;
        goto LABEL_460;
      }
    }
    else
    {
      if (v117 < 0) {
        goto LABEL_488;
      }
      uint64_t v118 = v117 >> 4;
      int v119 = operator new(v117);
      uint64_t v120 = 0;
      uint64_t v121 = 0;
      unint64_t v122 = 0;
      __p[0] = v119;
      __p[1] = v119;
      uint64_t v376 = &v119[2 * v118];
      do
      {
        unint64_t v123 = v115[v120];
        if (*(_DWORD *)(v123 + 208) >= *(_DWORD *)(v123 + 212))
        {
          if (v119 >= v376)
          {
            int v119 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)__p, *(__n128 *)&v115[v120]);
          }
          else
          {
            void *v119 = v123;
            unint64_t v125 = v115[v120 + 1];
            v119[1] = v125;
            if (v125) {
              atomic_fetch_add_explicit((atomic_ullong *volatile)(v125 + 8), 1uLL, memory_order_relaxed);
            }
            v119 += 2;
          }
          __p[1] = v119;
        }
        else if ((unint64_t)v121 >= v379)
        {
          uint64_t v121 = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)&v377, *(__n128 *)&v115[v120]);
          uint64_t v378 = v121;
        }
        else
        {
          v121->n128_u64[0] = v123;
          unint64_t v124 = v115[v120 + 1];
          v121->n128_u64[1] = v124;
          if (v124) {
            atomic_fetch_add_explicit((atomic_ullong *volatile)(v124 + 8), 1uLL, memory_order_relaxed);
          }
          uint64_t v378 = ++v121;
        }
        ++v122;
        uint64_t v115 = (unint64_t *)*((void *)this + 14);
        uint64_t v116 = (unint64_t *)*((void *)this + 15);
        v120 += 2;
      }
      while (v122 < ((char *)v116 - (char *)v115) >> 4);
      BOOL v114 = this;
      if (!v115) {
        goto LABEL_172;
      }
    }
    if (v116 != v115)
    {
      do
      {
        BOOL v164 = (std::__shared_weak_count *)*(v116 - 1);
        if (v164 && !atomic_fetch_add(&v164->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v164->__on_zero_shared)(v164);
          std::__shared_weak_count::__release_weak(v164);
        }
        v116 -= 2;
      }
      while (v116 != v115);
      uint64_t v116 = *v364;
    }
    *((void *)v114 + 15) = v115;
    operator delete(v116);
    uint64_t v121 = v378;
    goto LABEL_172;
  }
  std::mutex::lock(v99);
  uint64_t v383 = (void *)*((void *)this + 28);
  uint64_t v100 = (char *)v383;
  long long v371 = *(_OWORD *)((char *)this + 232);
  *((void *)this + 28) = 0;
  *((void *)this + 29) = 0;
  long long v384 = v371;
  *((void *)this + 30) = 0;
  std::mutex::unlock((std::mutex *)((char *)this + 160));
  long long v101 = (char *)v371;
  if (v100 != (char *)v371 || *((void *)this + 31) != *((void *)this + 32))
  {
    uint64_t v380 = 0;
    uint64_t v381 = 0;
    uint64_t v382 = 0;
    ta2::TextureAtlas::createRegionItems(&v383, (uint64_t)&v380);
    uint64_t v102 = *((void *)this + 14);
    if (v102 != *((void *)this + 15) && *(_DWORD *)(*(void *)v102 + 208) >= *(_DWORD *)(*(void *)v102 + 212))
    {
      uint64_t v103 = v380;
      unint64_t v104 = 0x8E38E38E38E38E39 * ((v381 - (unsigned char *)v380) >> 3);
      unint64_t v105 = 126 - 2 * __clz(v104);
      uint64_t v106 = v381 == v380 ? 0 : v105;
      std::__introsort<std::_ClassicAlgPolicy,ta2::TextureAtlas::sortRegionItems(std::vector<ta2::TextureAtlas::RegionItem> &)::$_0 &,ta2::TextureAtlas::RegionItem*,false>((unint64_t)v380, (long long *)v381, v106, 1);
      if (ta2::TextureAtlasPage::reserveRegions(**v364, (unint64_t)v103, v104, v107, v108, v109, v110, v111))
      {
        unint64_t v112 = this;
        ta2::TextureAtlas::createReloadRegionItems((__n128 **)this + 31, (uint64_t)&v380);
LABEL_442:
        std::vector<std::shared_ptr<ta2::TextureAtlasRegion>>::__insert_with_size[abi:nn180100]<std::__wrap_iter<std::shared_ptr<ta2::TextureAtlasRegion>*>,std::__wrap_iter<std::shared_ptr<ta2::TextureAtlasRegion>*>>((void **)v112 + 31, *((void *)v112 + 31), v100, v101, (v101 - v100) >> 4);
        uint64_t v163 = (uint64_t *)v380;
        ta2::TextureAtlas::loadRegions((uint64_t)v112, (uint64_t *)v380, (uint64_t *)v381);
        BOOL v114 = v112;
        if (v163) {
          goto LABEL_443;
        }
LABEL_451:
        uint64_t v100 = (char *)v383;
        if (v383) {
          goto LABEL_452;
        }
        goto LABEL_461;
      }
    }
    if (GEOGetVectorKitTextureAtlasLog(void)::onceToken != -1) {
      dispatch_once(&GEOGetVectorKitTextureAtlasLog(void)::onceToken, &__block_literal_global_17999);
    }
    float64x2_t v126 = GEOGetVectorKitTextureAtlasLog(void)::log;
    if (os_log_type_enabled((os_log_t)GEOGetVectorKitTextureAtlasLog(void)::log, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl(&dword_1A1780000, v126, OS_LOG_TYPE_INFO, "repacking glyph atlas", buf, 2u);
    }
    unint64_t v127 = (uint64_t *)*((void *)this + 14);
    unsigned int v128 = 2;
    if (v127 != *((uint64_t **)this + 15))
    {
      uint64_t v129 = *v127;
      unsigned int v130 = *(_DWORD *)(v129 + 208);
      ta2::TextureAtlas::createRegionItems((void *)(v129 + 344), (uint64_t)&v380);
      unint64_t v131 = 126 - 2 * __clz(0x8E38E38E38E38E39 * ((v381 - (unsigned char *)v380) >> 3));
      if (v381 == v380) {
        uint64_t v132 = 0;
      }
      else {
        uint64_t v132 = v131;
      }
      if (((float)((float)(v130 >> 12) * 1.25) + 127) >> 7 <= 2) {
        unsigned int v128 = 2;
      }
      else {
        unsigned int v128 = ((float)((float)(v130 >> 12) * 1.25) + 127) >> 7;
      }
      v133.n128_f64[0] = std::__introsort<std::_ClassicAlgPolicy,ta2::TextureAtlas::sortRegionItems(std::vector<ta2::TextureAtlas::RegionItem> &)::$_0 &,ta2::TextureAtlas::RegionItem*,false>((unint64_t)v380, (long long *)v381, v132, 1);
      unint64_t v134 = **v364;
      uint64_t v135 = *(void *)(v134 + 344);
      for (uint64_t n = *(void *)(v134 + 352); n != v135; n -= 16)
      {
        uint64_t v137 = *(std::__shared_weak_count **)(n - 8);
        if (v137 && !atomic_fetch_add(&v137->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *, __n128))v137->__on_zero_shared)(v137, v133);
          std::__shared_weak_count::__release_weak(v137);
        }
      }
      *(void *)(v134 + 352) = v135;
    }
    LODWORD(v377) = v128 << 7;
    HIDWORD(v377) = 4096;
    float64x2_t v138 = 0;
    while (1)
    {
      uint64_t v370 = v138;
      std::allocate_shared[abi:nn180100]<ta2::TextureAtlasPage,std::allocator<ta2::TextureAtlasPage>,ta2::TextureAtlas &,gm::Matrix<unsigned int,2,1> &,unsigned int &,BOOL &,BOOL,std::shared_ptr<mre::GraphicsResourceStore> &,void>(buf, (uint64_t)this, (uint32x2_t *)&v377, *((_DWORD *)this + 25), *((unsigned char *)this + 96), 1, *((void *)this + 43), *((std::__shared_weak_count **)this + 44));
      long long v144 = *(_OWORD *)buf;
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = 0;
      __n128 v373 = (__n128)v144;
      if (v370 && !atomic_fetch_add(&v370->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v370->__on_zero_shared)(v370);
        std::__shared_weak_count::__release_weak(v370);
        *(void *)&long long v144 = v373.n128_u64[0];
        uint64_t v145 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8])
        {
LABEL_139:
          if (!atomic_fetch_add(&v145->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            ((void (*)(std::__shared_weak_count *))v145->__on_zero_shared)(v145);
            std::__shared_weak_count::__release_weak(v145);
            *(void *)&long long v144 = v373.n128_u64[0];
          }
        }
      }
      else
      {
        uint64_t v145 = *(std::__shared_weak_count **)&buf[8];
        if (*(void *)&buf[8]) {
          goto LABEL_139;
        }
      }
      unint64_t v146 = (float32x2_t *)v144;
      if (ta2::TextureAtlasPage::reserveRegions(v144, (unint64_t)v380, 0x8E38E38E38E38E39 * ((v381 - (unsigned char *)v380) >> 3), v139, v140, v141, v142, v143)&& !*(void *)&v146[25])
      {
        unsigned int v147 = (*((_DWORD *)this + 26) + v146[5].i32[1] + 31) & 0xFFFFFFE0;
        if (v147 <= 0x1000)
        {
          __int32 v148 = v146[22].i32[0];
          v149.i32[0] = v148;
          v149.i32[1] = (*((_DWORD *)this + 26) + v146[5].i32[1] + 31) & 0xFFFFFFE0;
          v146[22].i32[1] = v147;
          __asm { FMOV            V1.2S, #1.0 }
          v146[23] = vdiv_f32(_D1, vcvt_f32_u32(v149));
          *(_DWORD *)long long buf = v148;
          *(_DWORD *)&uint8_t buf[4] = v147;
          float64x2_t v154 = (uint64_t (***)(void))v146[1];
          *(_DWORD *)&uint8_t buf[8] = *(_DWORD *)(*(void *)v146 + 32);
          *(_DWORD *)&unsigned char buf[12] = 3;
          v146[25] = (float32x2_t)(**v154)();
          unsigned __int32 v155 = v146[22].u32[1];
          if (v146[5].i32[1] <= v155) {
            v146[4].i32[1] = v155;
          }
          ta2::TextureAtlas::clearPageEdges((uint64_t)this, (uint64_t)v146);
          uint64_t v156 = *((void *)this + 41);
          int v157 = (void **)(v156 - 24);
          uint64_t v158 = *(void *)(v156 - 24);
          if (v158)
          {
            uint64_t v159 = *(void *)(v156 - 16);
            float v160 = *(void **)(v156 - 24);
            if (v159 != v158)
            {
              do
              {
                uint64_t v161 = *(std::__shared_weak_count **)(v159 - 8);
                if (v161 && !atomic_fetch_add(&v161->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
                {
                  ((void (*)(std::__shared_weak_count *))v161->__on_zero_shared)(v161);
                  std::__shared_weak_count::__release_weak(v161);
                }
                v159 -= 16;
              }
              while (v159 != v158);
              float v160 = *v157;
            }
            *(void *)(v156 - 16) = v158;
            operator delete(v160);
            void *v157 = 0;
            *(void *)(v156 - 16) = 0;
            *(void *)(v156 - 8) = 0;
          }
          *(_OWORD *)(v156 - 24) = *((_OWORD *)this + 7);
          *(void *)(v156 - 8) = *((void *)this + 16);
          *uint64_t v364 = 0;
          *((void *)this + 15) = 0;
          *((void *)this + 16) = 0;
          *((void *)this + 15) = std::vector<std::shared_ptr<md::MuninRoadLabel>>::__push_back_slow_path<std::shared_ptr<md::MuninRoadLabel> const&>((uint64_t)v364, v373);
          if (v373.n128_u64[1]
            && !atomic_fetch_add((atomic_ullong *volatile)(v373.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
          {
            (*(void (**)(unint64_t))(*(void *)v373.n128_u64[1] + 16))(v373.n128_u64[1]);
            std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v373.n128_u64[1]);
          }
          uint64_t v100 = (char *)v383;
          long long v101 = (char *)v384;
          unint64_t v112 = this;
          goto LABEL_442;
        }
      }
      LODWORD(v377) = v377 + 128;
      float64x2_t v138 = (std::__shared_weak_count *)v373.n128_u64[1];
      if (v377 > 0x1000)
      {
        if (GEOGetVectorKitTextureAtlasLog(void)::onceToken != -1) {
          dispatch_once(&GEOGetVectorKitTextureAtlasLog(void)::onceToken, &__block_literal_global_17999);
        }
        BOOL v114 = this;
        unint64_t v162 = GEOGetVectorKitTextureAtlasLog(void)::log;
        if (os_log_type_enabled((os_log_t)GEOGetVectorKitTextureAtlasLog(void)::log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136315650;
          *(void *)&uint8_t buf[4] = "false";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = "/Library/Caches/com.apple.xbs/Sources/VectorKit/src/TextureAtlas2.cpp";
          *(_WORD *)&unsigned char buf[22] = 1024;
          *(_DWORD *)uint64_t v389 = 273;
          _os_log_impl(&dword_1A1780000, v162, OS_LOG_TYPE_ERROR, "overflowed single page texture: Assertion with expression - %s : Failed in file - %s line - %i", buf, 0x1Cu);
        }
        if (v373.n128_u64[1]
          && !atomic_fetch_add((atomic_ullong *volatile)(v373.n128_u64[1] + 8), 0xFFFFFFFFFFFFFFFFLL))
        {
          (*(void (**)(unint64_t))(*(void *)v373.n128_u64[1] + 16))(v373.n128_u64[1]);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v373.n128_u64[1]);
        }
        uint64_t v163 = (uint64_t *)v380;
        if (!v380) {
          goto LABEL_451;
        }
LABEL_443:
        uint64_t v334 = v381;
        uint64_t v335 = v163;
        if (v381 != (char *)v163)
        {
          do
          {
            uint64_t v336 = (std::__shared_weak_count *)*((void *)v334 - 8);
            if (v336 && !atomic_fetch_add(&v336->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
            {
              ((void (*)(std::__shared_weak_count *))v336->__on_zero_shared)(v336);
              std::__shared_weak_count::__release_weak(v336);
            }
            v334 -= 72;
          }
          while (v334 != (char *)v163);
          uint64_t v335 = v380;
          BOOL v114 = this;
        }
        uint64_t v381 = (char *)v163;
        operator delete(v335);
        goto LABEL_451;
      }
    }
  }
  BOOL v114 = this;
  if (v100)
  {
LABEL_452:
    int v337 = (char *)v384;
    uint64_t v332 = v100;
    if ((char *)v384 != v100)
    {
      do
      {
        float32x4_t v338 = (std::__shared_weak_count *)*((void *)v337 - 1);
        if (v338 && !atomic_fetch_add(&v338->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
        {
          ((void (*)(std::__shared_weak_count *))v338->__on_zero_shared)(v338);
          std::__shared_weak_count::__release_weak(v338);
        }
        v337 -= 16;
      }
      while (v337 != v100);
      uint64_t v332 = v383;
      BOOL v114 = this;
    }
    *(void *)&long long v384 = v100;
LABEL_460:
    operator delete(v332);
  }
LABEL_461:
  float v339 = (char *)*((void *)v114 + 14);
  uint64_t v340 = (char *)*((void *)v114 + 15);
  int64_t v341 = v340 - v339;
  unint64_t v342 = (v340 - v339) >> 4;
  int8x16_t v343 = (unsigned char *)*((void *)v114 + 17);
  float v344 = (unsigned char *)*((void *)v114 + 18);
  unint64_t v345 = (v344 - v343) >> 3;
  unint64_t v346 = v342 - v345;
  if (v342 > v345)
  {
    uint64_t v347 = *((void *)v114 + 19);
    if (v346 <= (v347 - (uint64_t)v344) >> 3)
    {
      bzero(*((void **)v114 + 18), 8 * v346);
      *((void *)v114 + 18) = &v344[8 * v346];
LABEL_483:
      float v339 = (char *)*((void *)v114 + 14);
      uint64_t v340 = (char *)*((void *)v114 + 15);
      goto LABEL_484;
    }
    if ((v341 & 0x8000000000000000) == 0)
    {
      uint64_t v348 = v347 - (void)v343;
      uint64_t v349 = v348 >> 2;
      if (v348 >> 2 <= v342) {
        uint64_t v349 = v342;
      }
      _CF = (unint64_t)v348 >= 0x7FFFFFFFFFFFFFF8;
      unint64_t v350 = 0x1FFFFFFFFFFFFFFFLL;
      if (!_CF) {
        unint64_t v350 = v349;
      }
      if (v350 >> 61) {
        goto LABEL_489;
      }
      uint64_t v351 = 8 * v350;
      uint64_t v352 = operator new(8 * v350);
      uint64_t v353 = &v352[8 * v345];
      bzero(v353, 8 * v346);
      long long v354 = &v353[8 * v346];
      if (v344 == v343)
      {
        int8x16_t v343 = v344;
      }
      else
      {
        unint64_t v355 = v344 - v343 - 8;
        if (v355 < 0x58) {
          goto LABEL_492;
        }
        if ((unint64_t)(v343 - v352) < 0x20) {
          goto LABEL_492;
        }
        uint64_t v356 = (v355 >> 3) + 1;
        uint64_t v357 = &v352[8 * v345 - 16];
        uint64_t v358 = (long long *)(v344 - 16);
        uint64_t v359 = v356 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v360 = *v358;
          *(v357 - 1) = *(v358 - 1);
          _OWORD *v357 = v360;
          v357 -= 2;
          v358 -= 2;
          v359 -= 4;
        }
        while (v359);
        v353 -= 8 * (v356 & 0x3FFFFFFFFFFFFFFCLL);
        v344 -= 8 * (v356 & 0x3FFFFFFFFFFFFFFCLL);
        if (v356 != (v356 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_492:
          do
          {
            uint64_t v361 = *((void *)v344 - 1);
            v344 -= 8;
            *((void *)v353 - 1) = v361;
            v353 -= 8;
          }
          while (v344 != v343);
          int8x16_t v343 = (unsigned char *)*((void *)this + 17);
        }
      }
      *((void *)this + 17) = v353;
      *((void *)this + 18) = v354;
      BOOL v114 = this;
      *((void *)this + 19) = &v352[v351];
      if (v343) {
        operator delete(v343);
      }
      goto LABEL_483;
    }
LABEL_488:
    abort();
  }
  if (v342 < v345) {
    *((void *)v114 + 18) = &v343[8 * v342];
  }
LABEL_484:
  if (v339 != v340)
  {
    unsigned int v362 = 0;
    do
    {
      uint64_t v363 = *(void *)v339;
      v339 += 16;
      *(void *)(*((void *)v114 + 17) + 8 * v362++) = *(void *)(v363 + 200);
    }
    while (v339 != v340);
  }
}

uint64_t mre::GGLResourceStore::releaseBuffer(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (std::__shared_mutex_base *)(a1 + 272);
  std::__shared_mutex_base::lock((std::__shared_mutex_base *)(a1 + 272));
  uint64_t v5 = *(void *)(a1 + 696);
  if (a2 < (unint64_t)((*(void *)(a1 + 704) - v5) >> 3)
    && (uint64_t v6 = *(void *)(v5 + 8 * a2)) != 0
    && HIDWORD(a2) == HIDWORD(v6)
    && (v7 = *(void *)(a1 + 720), unsigned int v8 = (void *)(v7 + 32 * v6), v9 = *(void **)(a1 + 728), v8 != v9))
  {
    if (*v8 && !*(unsigned char *)(v7 + 32 * v6 + 24))
    {
      (*(void (**)(void))(*(void *)*v8 + 8))(*v8);
      int v9 = *(void **)(a1 + 728);
    }
    if (v9 != v8)
    {
      uint64_t v10 = *(void *)(a1 + 720);
      uint64_t v11 = *(void *)(a1 + 744);
      unint64_t v12 = *(void *)(v11 + (((uint64_t)v8 - v10) >> 2));
      uint64_t v13 = *(void *)(a1 + 696);
      if (v12 < (*(void *)(a1 + 704) - v13) >> 3)
      {
        uint64_t v14 = *(void *)(v13 + 8 * v12);
        if (v14)
        {
          if (HIDWORD(*(void *)(v13 + 8 * *(void *)(v11 + (((uint64_t)v8 - v10) >> 2)))) == HIDWORD(v14))
          {
            long long v15 = *(unint64_t **)(a1 + 680);
            unint64_t v16 = *(void *)(a1 + 688);
            if ((unint64_t)v15 >= v16)
            {
              unsigned int v20 = *(unint64_t **)(a1 + 672);
              int64_t v21 = (char *)v15 - (char *)v20;
              uint64_t v22 = v15 - v20;
              unint64_t v23 = v22 + 1;
              if ((unint64_t)(v22 + 1) >> 61) {
                abort();
              }
              uint64_t v24 = v16 - (void)v20;
              if (v24 >> 2 > v23) {
                unint64_t v23 = v24 >> 2;
              }
              if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
                unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
              }
              else {
                unint64_t v25 = v23;
              }
              if (v25)
              {
                if (v25 >> 61) {
                  std::__throw_bad_array_new_length[abi:nn180100]();
                }
                uint64_t v26 = operator new(8 * v25);
                int64_t v21 = (char *)v15 - (char *)v20;
                uint64_t v22 = v15 - v20;
              }
              else
              {
                uint64_t v26 = 0;
              }
              BOOL v27 = (unint64_t *)&v26[8 * v22];
              uint64_t v28 = &v26[8 * v25];
              unint64_t *v27 = v12;
              uint64_t v17 = v27 + 1;
              if (v15 != v20)
              {
                unint64_t v29 = (char *)v15 - (char *)v20 - 8;
                if (v29 < 0x58) {
                  goto LABEL_41;
                }
                if ((unint64_t)((char *)v15 - v26 - v21) < 0x20) {
                  goto LABEL_41;
                }
                uint64_t v30 = (v29 >> 3) + 1;
                uint64_t v31 = &v26[8 * v22 - 16];
                unsigned int v32 = v15 - 2;
                uint64_t v33 = v30 & 0x3FFFFFFFFFFFFFFCLL;
                do
                {
                  long long v34 = *(_OWORD *)v32;
                  *(v31 - 1) = *((_OWORD *)v32 - 1);
                  *uint64_t v31 = v34;
                  v31 -= 2;
                  v32 -= 4;
                  v33 -= 4;
                }
                while (v33);
                v27 -= v30 & 0x3FFFFFFFFFFFFFFCLL;
                v15 -= v30 & 0x3FFFFFFFFFFFFFFCLL;
                if (v30 != (v30 & 0x3FFFFFFFFFFFFFFCLL))
                {
LABEL_41:
                  do
                  {
                    unint64_t v35 = *--v15;
                    *--BOOL v27 = v35;
                  }
                  while (v15 != v20);
                }
              }
              *(void *)(a1 + 672) = v27;
              *(void *)(a1 + 680) = v17;
              *(void *)(a1 + 688) = v28;
              if (v20)
              {
                operator delete(v20);
                uint64_t v13 = *(void *)(a1 + 696);
                int v9 = *(void **)(a1 + 728);
                uint64_t v10 = *(void *)(a1 + 720);
                uint64_t v11 = *(void *)(a1 + 744);
              }
            }
            else
            {
              *long long v15 = v12;
              uint64_t v17 = v15 + 1;
            }
            *(void *)(a1 + 680) = v17;
            uint64_t v36 = *(void *)(v13 + 8 * v12);
            uint64_t v37 = v36;
            uint64_t v38 = *(void *)(v11 + (((uint64_t)v9 - v10) >> 2) - 8);
            int64x2_t v39 = (_OWORD *)(v10 + 32 * v36);
            *(_OWORD *)uint64_t v46 = *v39;
            long long v40 = *v39;
            *(_OWORD *)&v46[16] = v39[1];
            long long v41 = *(_OWORD *)((char *)v9 - 23);
            *int64x2_t v39 = *((_OWORD *)v9 - 2);
            *(_OWORD *)((char *)v39 + 9) = v41;
            *(_OWORD *)((char *)v9 - 23) = *(_OWORD *)&v46[9];
            *((_OWORD *)v9 - 2) = v40;
            *(_DWORD *)(*(void *)(a1 + 696) + 8 * v38) = v36;
            uint64_t v42 = *(void *)(a1 + 744);
            v37 *= 8;
            uint64_t v43 = *(void *)(v42 + v37);
            uint64_t v44 = *(void **)(a1 + 752);
            uint64_t v45 = *--v44;
            *(void *)(v42 + v37) = v45;
            void *v44 = v43;
            *(void *)(a1 + 728) -= 32;
            *(void *)(a1 + 752) = v44;
            *(_DWORD *)(*(void *)(a1 + 696) + 8 * v12 + 4) = (((unint64_t)*(unsigned int *)(*(void *)(a1 + 696) + 8 * v12 + 4) << 32)
                                                              + 0x100000000) >> 32;
            *(_DWORD *)(*(void *)(a1 + 696) + 8 * v12) = (*(void *)(a1 + 704) - *(void *)(a1 + 696)) >> 3;
          }
        }
      }
    }
    uint64_t v18 = 1;
  }
  else
  {
    uint64_t v18 = 0;
  }
  std::__shared_mutex_base::unlock(v4);
  return v18;
}